IOleControlImpl<CSearchAssistantOC>,
    public IOleObjectImpl<CSearchAssistantOC>,
    public IOleInPlaceActiveObjectImpl<CSearchAssistantOC>,
    public IViewObjectExImpl<CSearchAssistantOC>,
    public IOleInPlaceObjectWindowlessImpl<CSearchAssistantOC>,
    public IDataObjectImpl<CSearchAssistantOC>,
    public CProxy_SearchAssistantEvents<CSearchAssistantOC>,
    public IConnectionPointContainerImpl<CSearchAssistantOC>,
    public ISpecifyPropertyPagesImpl<CSearchAssistantOC>,
#ifndef UNIX
    public IObjectSafetyImpl<CSearchAssistantOC, INTERFACESAFE_FOR_UNTRUSTED_CALLER>,
#else
    public IObjectSafety,
#endif
    public IOleCommandTarget,
    public IObjectWithSite  // HACKHACK: need non-IOleClientSite host for FindXXX methods.
{
public:
    CSearchAssistantOC();
    ~CSearchAssistantOC();

BEGIN_COM_MAP(CSearchAssistantOC)
    COM_INTERFACE_ENTRY(ISearchAssistantOC3)
    COM_INTERFACE_ENTRY_IID(IID_ISearchAssistantOC, ISearchAssistantOC3)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IOleCommandTarget)
    COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY_IMPL(IOleControl)
    COM_INTERFACE_ENTRY_IMPL(IOleObject)
    COM_INTERFACE_ENTRY_IMPL(IQuickActivate)
    COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
    COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
    COM_INTERFACE_ENTRY_IMPL(IDataObject)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CSearchAssistantOC)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
#ifndef UNDER_CE
    PROP_PAGE(CLSID_StockColorPage)
#endif
END_PROPERTY_MAP()


BEGIN_CONNECTION_POINT_MAP(CSearchAssistantOC)
    CONNECTION_POINT_ENTRY(DIID__SearchAssistantEvents)
END_CONNECTION_POINT_MAP()


BEGIN_MSG_MAP(CSearchAssistantOC)
    MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
END_MSG_MAP()


// IViewObjectEx
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
    {
        ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
        *pdwStatus = 0;
        return S_OK;
    }

public:
    // *** ISearchAssistantOC methods ***

    STDMETHOD(AddNextMenuItem)(BSTR bstrText, long idItem);
    STDMETHOD(SetDefaultSearchUrl)(BSTR bstrUrl);
    STDMETHOD(NavigateToDefaultSearch)();
    STDMETHOD(IsRestricted)(BSTR bstrGuid, VARIANT_BOOL *pVal);
    STDMETHOD(get_ShellFeaturesEnabled)(VARIANT_BOOL *pVal);
    STDMETHOD(get_SearchAssistantDefault)(VARIANT_BOOL *pVal);
    STDMETHOD(get_Searches)(ISearches **ppid);
    STDMETHOD(get_InWebFolder)(VARIANT_BOOL *pVal);
    STDMETHOD(PutProperty)(VARIANT_BOOL bPerLocale, BSTR bstrName, BSTR bstrValue);
    STDMETHOD(GetProperty)(VARIANT_BOOL bPerLocale, BSTR bstrName, BSTR *pbstrValue);
    STDMETHOD(put_EventHandled)(VARIANT_BOOL bHandled);
    STDMETHOD(ResetNextMenu)();
    STDMETHOD(FindOnWeb)() ;
    STDMETHOD(FindFilesOrFolders)() ;
    STDMETHOD(FindComputer)() ;
    STDMETHOD(FindPrinter)() ;
    STDMETHOD(FindPeople)() ;
    STDMETHOD(GetSearchAssistantURL)(VARIANT_BOOL bSubstitute, VARIANT_BOOL bCustomize, BSTR *pbstrValue);
    STDMETHOD(NotifySearchSettingsChanged)();
    STDMETHOD(put_ASProvider)(BSTR Provider);
    STDMETHOD(get_ASProvider)(BSTR *pProvider);
    STDMETHOD(put_ASSetting)(int Setting);
    STDMETHOD(get_ASSetting)(int *pSetting);
    STDMETHOD(NETDetectNextNavigate)();
    STDMETHOD(PutFindText)(BSTR FindText);
    STDMETHOD(get_Version)(int *pVersion);
    STDMETHOD(EncodeString)(BSTR bstrValue, BSTR bstrCharSet, VARIANT_BOOL bUseUTF8, BSTR *pbstrResult);

    // *** ISearchAssistantOC2 methods ***
    STDMETHOD(get_ShowFindPrinter)(VARIANT_BOOL *pbShowFindPrinter);

    // *** ISearchAssistantOC3 methods ***
    STDMETHOD(get_SearchCompanionAvailable)(VARIANT_BOOL *pbAvailable);
    STDMETHOD(put_UseSearchCompanion)(VARIANT_BOOL bUseSC);
    STDMETHOD(get_UseSearchCompanion)(VARIANT_BOOL *pbUseSC);

    // *** IObjectWithSite ***
    STDMETHOD(SetSite)(IUnknown*) ;
    STDMETHOD(GetSite)(REFIID, void**) ;

#ifdef UNIX
    // *** IObjectSafety ***
    STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
    {
        ATLTRACE(_T("IObjectSafetyImpl::GetInterfaceSafetyOptions\n"));
        if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
            return E_POINTER;
        HRESULT hr = S_OK;
        if (riid == IID_IDispatch)
        {
            *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
            *pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
        }
        else
        {
            *pdwSupportedOptions = 0;
            *pdwEnabledOptions = 0;
            hr = E_NOINTERFACE;
        }
        return hr;
    }

    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
    {
        ATLTRACE(_T("IObjectSafetyImpl::SetInterfaceSafetyOptions\n"));
        /* // If we're being asked to set our safe for scripting option then oblige */
        if (riid == IID_IDispatch)
        {
            /* // Store our current safety level to return in GetInterfaceSafetyOptions */
            m_dwSafety = dwEnabledOptions & dwOptionSetMask;
            return S_OK;
        }
        return E_NOINTERFACE;
    }

#endif

    // *** IOleObject overrides ***
    STDMETHOD(SetClientSite)(IOleClientSite *pClientSite);

    STDMETHOD(QueryStatus)(const GUID *pguidCmdGroup,
                           ULONG cCmds, 
                           OLECMD prgCmds[],
                           OLECMDTEXT *pCmdText);
    
    STDMETHOD(Exec)(const GUID *pguidCmdGroup,
                    DWORD nCmdID, 
                    DWORD nCmdexecopt,
                    VARIANT *pvaIn,
                    VARIANT *pvaOut);

    HRESULT OnDraw(ATL_DRAWINFO& di);

    BOOL    IsTrustedSite();
    HRESULT ShowSearchBand( REFGUID guidSearch ) ;

    static HRESULT UpdateRegistry(BOOL bRegister);

private:

    ISearchBandTBHelper *m_pSearchBandTBHelper;

    BOOL        m_bSafetyInited  : 1;
    BOOL        m_bIsTrustedSite : 1;
    IUnknown*   m_punkSite ; // to accomodate clients who aren't hosting us as an OC.
    
    VARIANT_BOOL m_bEventHandled;

    STDMETHOD(LocalZoneCheck)(); // for wininet netdetect security

#ifdef UNIX
    DWORD m_dwSafety;
#endif
};


#define CP_BOGUS                ((UINT)-1)
#define CP_UTF_8                65001

#endif // __SRCHASST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\srchasst.cpp ===
#include "priv.h"
#include "caggunk.h"
#include "srchasst.h"
#include "dhuihand.h"
#include "mlang.h"  // fo char conversion
#include "..\browseui\legacy.h"  // for CITIDM_GETFOLDERSEARCHES
#include "varutil.h"
#include <wininet.h>

/////////////////////////////////////////////////////////////////////////////
// CSearchAssistantOC

//  If you change this, change browseui also.
const WCHAR c_wszThisBandIsYourBand[] = L"$$SearchBand$$";

//  HKLM values
#define REG_SZ_SEARCH       L"Software\\Microsoft\\Internet Explorer\\Search"
#define REG_SZ_SEARCHASSIST L"SearchAssistant"
#define REG_SZ_SEARCHCFG    L"CustomizeSearch"

//  HKCU values
#define REG_SZ_IE_MAIN      L"Software\\Microsoft\\Internet Explorer\\Main" 
#define REG_SZ_IE_SEARCURL  L"Software\\Microsoft\\Internet Explorer\\SearchURL"
#define REG_SZ_SEARCHBAR    L"Search Bar"
#define REG_SZ_USECUSTOM    L"Use Custom Search URL"
#define REG_SZ_AUTOSEARCH   L"AutoSearch"
#define REG_SZ_PROVIDER     L"Provider"
#define REG_SZ_USE_SEARCH_COMP  L"Use Search Asst"

#define SAOC_VERSION        2

const WCHAR c_wszSearchProps[] = REG_SZ_SEARCH L"\\SearchProperties";

STDAPI_(VARIANT_BOOL) UseCustomInternetSearch()
{
    VARIANT_BOOL bRet;
    DWORD dwVal;
    DWORD cbVal = sizeof(dwVal);
    
    if ((SHGetValueW(HKEY_CURRENT_USER, 
                    REG_SZ_IE_MAIN, 
                    REG_SZ_USECUSTOM, 
                    NULL, 
                    &dwVal, 
                    &cbVal) == ERROR_SUCCESS) &&
        (FALSE != dwVal))
    {
        bRet = VARIANT_TRUE;
    }
    else
    {
        bRet = VARIANT_FALSE;
    }

    return bRet;
}

STDAPI_(BOOL) GetSearchAssistantUrlW(LPWSTR pwszUrl, int cchUrl, BOOL bSubstitute, BOOL bCustomize)
{
    BOOL bResult;
    WCHAR wszUrlTmp[MAX_URL_STRING];
    WCHAR *pwszUrlRead;
    DWORD cb;

    ASSERT(pwszUrl);
    *pwszUrl = 0;

    if (bSubstitute)
    {
        cb = sizeof(wszUrlTmp);
        pwszUrlRead = wszUrlTmp;
    }
    else
    {
        cb = cchUrl * sizeof(WCHAR);
        pwszUrlRead = pwszUrl;
    }
    
    bResult = SHGetValueW(HKEY_LOCAL_MACHINE, 
                          REG_SZ_SEARCH, 
                          bCustomize ? REG_SZ_SEARCHCFG : REG_SZ_SEARCHASSIST,
                          NULL, (BYTE *)pwszUrlRead, &cb) == ERROR_SUCCESS;
    if (bResult && bSubstitute)
    {
        bResult = SUCCEEDED(URLSubstitution(wszUrlTmp, pwszUrl, cchUrl, URLSUB_ALL));
    }

    return bResult;
}

STDAPI_(BOOL) GetDefaultInternetSearchUrlW(LPWSTR pwszUrl, int cchUrl, BOOL bSubstitute)
{
    BOOL bResult = FALSE;
    DWORD cb;

    ASSERT(pwszUrl);
    *pwszUrl = 0;

    if (UseCustomInternetSearch())
    {
        //  First try the user specific value
        cb = cchUrl * sizeof(TCHAR);
        bResult = SHGetValueW(HKEY_CURRENT_USER, REG_SZ_IE_MAIN, REG_SZ_SEARCHBAR, 
                             NULL, (BYTE *)pwszUrl, &cb) == ERROR_SUCCESS;
    }
    
    if (!bResult)
    {
        bResult = GetSearchAssistantUrlW(pwszUrl, cchUrl, bSubstitute, FALSE);
    }

    return bResult;
}

STDAPI_(BOOL) GetSearchAssistantUrlA(LPSTR pszUrl, int cchUrl, BOOL bSubstitute, BOOL bCustomize)
{
    WCHAR wszUrl[INTERNET_MAX_URL_LENGTH];

    BOOL bResult = GetSearchAssistantUrlW(wszUrl, ARRAYSIZE(wszUrl), bSubstitute, bCustomize);

    SHUnicodeToAnsi(wszUrl, pszUrl, cchUrl);

    return bResult;
}

STDAPI_(BOOL) GetDefaultInternetSearchUrlA(LPSTR pszUrl, int cchUrl, BOOL bSubstitute)
{
    WCHAR wszUrl[INTERNET_MAX_URL_LENGTH];

    BOOL bResult = GetDefaultInternetSearchUrlW(wszUrl, ARRAYSIZE(wszUrl), bSubstitute);

    SHUnicodeToAnsi(wszUrl, pszUrl, cchUrl);

    return bResult;
}

void SetDefaultInternetSearchUrlW(LPCWSTR pwszUrl)
{
    DWORD dwUseCustom = FALSE;
    DWORD cb;
    
    if ((NULL != pwszUrl) && (0 != *pwszUrl))
    {
        cb = (lstrlenW(pwszUrl) + 1) * sizeof(WCHAR);
        if (SHSetValueW(HKEY_CURRENT_USER, REG_SZ_IE_MAIN, REG_SZ_SEARCHBAR, REG_SZ,
                        pwszUrl, cb) == ERROR_SUCCESS)
        {
            dwUseCustom = TRUE;
        }
    }

    cb = sizeof(dwUseCustom);

    SHSetValueW(HKEY_CURRENT_USER, REG_SZ_IE_MAIN, REG_SZ_USECUSTOM, REG_DWORD, 
                &dwUseCustom, cb);
}

HRESULT CSearch_Create(GUID *pguid, BSTR bstrTitle, BSTR bstrUrl, ISearch **ppSearch)
{
    HRESULT hres = E_INVALIDARG;

    ASSERT(ppSearch);
    *ppSearch = NULL;

    if (bstrTitle && bstrUrl && pguid)
    {
        BSTR _bstrTitle = SysAllocString(bstrTitle);
        BSTR _bstrUrl   = SysAllocString(bstrUrl);

        if (_bstrTitle && _bstrUrl)
        {
            CSearch *ps = new CSearch(pguid, _bstrTitle, _bstrUrl);

            if (ps)
            {
                hres = ps->QueryInterface(IID_ISearch, (void **)ppSearch);
                ps->Release();
            }
        }
        else
        {
            if (_bstrTitle)
                SysFreeString(_bstrTitle);

            if (_bstrUrl)
                SysFreeString(_bstrUrl);

            hres = E_OUTOFMEMORY;
        }
    }
    return hres;
}

CSearch::CSearch(GUID *pguid, BSTR bstrTitle, BSTR bstrUrl) :
    _cRef(1), _bstrTitle(bstrTitle), _bstrUrl(bstrUrl),
    CImpIDispatch(LIBID_SHDocVw, 1, 1, IID_ISearch)
{
    SHStringFromGUID(*pguid, _szId, ARRAYSIZE(_szId));
}

CSearch::~CSearch()
{
    if (_bstrTitle)
        SysFreeString(_bstrTitle);

    if (_bstrUrl)
        SysFreeString(_bstrUrl);
}

STDMETHODIMP CSearch::QueryInterface(REFIID riid, void** ppv)
{
    static const QITAB qit[] = {
        QITABENT(CSearch, ISearch),
        QITABENTMULTI(CSearch, IDispatch, ISearch),
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CSearch::AddRef()
{
    InterlockedIncrement(&_cRef);
    return _cRef;
}

STDMETHODIMP_(ULONG) CSearch::Release()
{
    if (InterlockedDecrement(&_cRef) > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CSearch::get_Title(BSTR *pbstrTitle)
{
    HRESULT hres = NOERROR;
    
    *pbstrTitle = SysAllocString(_bstrTitle);
    if (!*pbstrTitle)
        hres = E_OUTOFMEMORY;

    return hres;
}

HRESULT CSearch::get_Id(BSTR  *pbstrId)
{
    HRESULT hres = NOERROR;

    *pbstrId = SysAllocString(_szId);
    if (!*pbstrId)
        hres = E_OUTOFMEMORY;

    return hres;
}

HRESULT CSearch::get_Url(BSTR *pbstrUrl)
{
    HRESULT hres = NOERROR;
    
    *pbstrUrl = SysAllocString(_bstrUrl);
    if (!*pbstrUrl)
        hres = E_OUTOFMEMORY;

    return hres;
}

HRESULT CSearchCollection_Create(IFolderSearches *pfs, ISearches **ppSearches)
{
    HRESULT hres = E_INVALIDARG;
    
    ASSERT(ppSearches);
    *ppSearches = NULL;

    if (pfs)
    {
        CSearchCollection *psc = new CSearchCollection(pfs);

        if (psc)
        {
            hres = psc->QueryInterface(IID_ISearches, (void **)ppSearches);
            psc->Release();
        }
        else
            hres = E_OUTOFMEMORY;
    }
    
    return hres;
}

CSearchCollection::CSearchCollection(IFolderSearches *pfs) :
    _cRef(1), CImpIDispatch(LIBID_SHDocVw, 1, 1, IID_ISearches)
{
    GUID guid;

    if (SUCCEEDED(pfs->DefaultSearch(&guid)))
        SHStringFromGUID(guid, _szDefault, ARRAYSIZE(_szDefault));
    
    _hdsaItems = DSA_Create(SIZEOF(URLSEARCH), 4);
    if (_hdsaItems)
    {
        IEnumUrlSearch *penum;

        if (SUCCEEDED(pfs->EnumSearches(&penum)))
        {
            URLSEARCH    us;
            ULONG        cElt;

            penum->Reset();
            while (S_OK == penum->Next(1, &us, &cElt) && 1 == cElt)
                DSA_AppendItem(_hdsaItems, &us);

            penum->Release();
        }
    }
}

CSearchCollection::~CSearchCollection()
{
    DSA_Destroy(_hdsaItems);
    _hdsaItems = NULL;
}

STDMETHODIMP CSearchCollection::QueryInterface(REFIID riid, void** ppv)
{
    static const QITAB qit[] = {
        QITABENT(CSearchCollection, ISearches),
        QITABENTMULTI(CSearchCollection, IDispatch, ISearches),
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CSearchCollection::AddRef()
{
    InterlockedIncrement(&_cRef);
    return _cRef;
}

STDMETHODIMP_(ULONG) CSearchCollection::Release()
{
    if (InterlockedDecrement(&_cRef) > 0)
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CSearchCollection::get_Count(long *plCount)
{
    *plCount = 0;
    
    if (_hdsaItems)
    {
        *plCount =  DSA_GetItemCount(_hdsaItems);
    }
    return S_OK;
}

STDMETHODIMP CSearchCollection::get_Default(BSTR *pbstrDefault)
{
    HRESULT hres = E_OUTOFMEMORY;
    
    *pbstrDefault = SysAllocString(_szDefault);
    if (*pbstrDefault)
        hres = S_OK;
    
    return hres;
}

STDMETHODIMP CSearchCollection::Item(VARIANT index, ISearch **ppid)
{
    HRESULT hres = E_NOTIMPL;
    
    *ppid = NULL;
    
    switch (index.vt)
    {
        case VT_I2:
            index.lVal = (long)index.iVal;
            // And fall through...

        case VT_I4:
            if ((index.lVal >= 0) && (index.lVal < DSA_GetItemCount(_hdsaItems)))
            {
                LPURLSEARCH pus;

                pus = (LPURLSEARCH)DSA_GetItemPtr(_hdsaItems, index.lVal);
                ASSERT(pus);
                
                hres = CSearch_Create(&pus->guid, pus->wszName, pus->wszUrl, ppid);
            }

            break;
#if 0
        // should we worry about this one?
        case VT_BSTR:
#endif
    }

    return hres;
}

STDMETHODIMP CSearchCollection::_NewEnum(IUnknown **ppunk)
{
    *ppunk = NULL;
    return E_NOTIMPL;
}


CSearchAssistantOC::CSearchAssistantOC()
    :   m_punkSite(NULL)
{
#ifdef UNIX
    m_dwSafety = 0;
#endif
}

CSearchAssistantOC::~CSearchAssistantOC()
{
    ATOMICRELEASE(m_pSearchBandTBHelper);
    ATOMICRELEASE(m_punkSite);
}

HRESULT CSearchAssistantOC::OnDraw(ATL_DRAWINFO& di)
{
    return S_OK;
}

STDMETHODIMP CSearchAssistantOC::SetClientSite(IOleClientSite *pClientSite)
{
    if (NULL != pClientSite)
    {
        HRESULT hr;       
        IWebBrowser2 *pWebBrowser2;

        hr = IUnknown_QueryService(pClientSite, SID_SWebBrowserApp, IID_IWebBrowser2, 
                                   (void **)&pWebBrowser2);
        if (SUCCEEDED(hr))
        {
            BSTR bstrProp = SysAllocString(c_wszThisBandIsYourBand);
            if (bstrProp)
            {
                VARIANT var;
                hr = pWebBrowser2->GetProperty(bstrProp, &var);
                if (SUCCEEDED(hr))
                {
                    if (var.vt == VT_UNKNOWN)
                    {
                        ATOMICRELEASE(m_pSearchBandTBHelper);

                        hr = var.punkVal->QueryInterface(IID_ISearchBandTBHelper, 
                                                         (void **)&m_pSearchBandTBHelper);
                        ASSERT(SUCCEEDED(hr));

                        if (m_pSearchBandTBHelper)
                            m_pSearchBandTBHelper->SetOCCallback(this);
                    }

                    VariantClear(&var);
                }

                SysFreeString(bstrProp);
            }
            
            pWebBrowser2->Release();
        }
    }
    else
    {
        if (NULL != m_pSearchBandTBHelper)
        {
            m_pSearchBandTBHelper->SetOCCallback(NULL);
            ATOMICRELEASE(m_pSearchBandTBHelper);
        }
    }
    return IOleObjectImpl<CSearchAssistantOC>::SetClientSite(pClientSite);
}

STDMETHODIMP CSearchAssistantOC::QueryStatus(const GUID *pguidCmdGroup,
                                             ULONG cCmds, 
                                             OLECMD prgCmds[],
                                             OLECMDTEXT *pCmdText)
{
    return E_NOTIMPL;
}
    
STDMETHODIMP CSearchAssistantOC::Exec(const GUID *pguidCmdGroup,
                                      DWORD nCmdID, 
                                      DWORD nCmdexecopt,
                                      VARIANT *pvaIn,
                                      VARIANT *pvaOut)
{
    HRESULT hr = E_UNEXPECTED;
    
    if (NULL == pguidCmdGroup)
    {
        switch (nCmdID)
        {
            case SBID_SEARCH_NEXT:
                if ((NULL != pvaIn) && (pvaIn->vt == VT_I4))
                {
                    Fire_OnNextMenuSelect(pvaIn->lVal);

                    hr = S_OK;
                }
                else
                {
                    hr = E_INVALIDARG;
                }
                break;

            case SBID_SEARCH_NEW:
                if (NULL != pvaOut)
                {
                    m_bEventHandled = VARIANT_FALSE;

                    Fire_OnNewSearch();

                    pvaOut->vt = VT_BOOL;
                    pvaOut->boolVal = m_bEventHandled;

                    hr = S_OK;
                }
                else
                {
                    hr = E_INVALIDARG;
                }
                break;
        }
    }

    return hr;
}

STDMETHODIMP CSearchAssistantOC::AddNextMenuItem(BSTR bstrText, long idItem)
{
    HRESULT hr;

    if (IsTrustedSite())
    {
        if (NULL != m_pSearchBandTBHelper)
        {
            hr = m_pSearchBandTBHelper->AddNextMenuItem(bstrText, idItem);

            ASSERT(SUCCEEDED(hr));

        }
        hr = S_OK;
    }
    else
    {
        hr = E_ACCESSDENIED;
    }
    return hr;
}

STDMETHODIMP CSearchAssistantOC::ResetNextMenu()
{
    HRESULT hr;

    if (IsTrustedSite())
    {
        if (NULL != m_pSearchBandTBHelper)
        {
            hr = m_pSearchBandTBHelper->ResetNextMenu();
            
            ASSERT(SUCCEEDED(hr));
        }
        hr = S_OK;
    }
    else
    {
        hr = E_ACCESSDENIED;
    }

    return hr;
}


STDMETHODIMP CSearchAssistantOC::SetDefaultSearchUrl(BSTR bstrUrl)
{
    HRESULT hr;
    
    if (IsTrustedSite())
    {
        SetDefaultInternetSearchUrlW(bstrUrl);
        hr = S_OK;
    }
    else
    {
        hr = E_ACCESSDENIED;
    }
    
    return hr;
}

STDMETHODIMP CSearchAssistantOC::NavigateToDefaultSearch()
{
    HRESULT hr;
    

    IWebBrowser2 *pWebBrowser2;

    hr = IUnknown_QueryService(m_spClientSite, SID_SWebBrowserApp, IID_IWebBrowser2, 
                               (void **)&pWebBrowser2);
    if (SUCCEEDED(hr))
    {
        WCHAR wszUrl[INTERNET_MAX_URL_LENGTH];

        if (GetDefaultInternetSearchUrlW(wszUrl, ARRAYSIZE(wszUrl), TRUE))
        {
            BSTR bstrUrl = SysAllocString(wszUrl);


            if (NULL != bstrUrl) 
            {
                VARIANT varFrame;
                varFrame.vt = VT_BSTR;
                varFrame.bstrVal = SysAllocString(L"_search");
                if (NULL != varFrame.bstrVal)
                {
                    hr = pWebBrowser2->Navigate(bstrUrl, NULL, &varFrame, NULL, NULL);

                    ASSERT(SUCCEEDED(hr));

                    SysFreeString(varFrame.bstrVal);
                }

                SysFreeString(bstrUrl);
            }
        }
        pWebBrowser2->Release();
    }
 
    return S_OK;
}

typedef struct _GUIDREST
{
    const GUID *  pguid;
    RESTRICTIONS  rest;
} GUIDREST;

HRESULT CSearchAssistantOC::IsRestricted(BSTR bstrGuid, VARIANT_BOOL *pVal)
{
    HRESULT hr;
    GUID guid;

    if (IsTrustedSite())
    {
        *pVal = VARIANT_FALSE; // default to not restricted
        if (SUCCEEDED(SHCLSIDFromString(bstrGuid, &guid)))
        {
            // find computer is special because if it restricted then we show
            // it else don't show it (restriction name is HASFINDCOMPUTER
            if (IsEqualGUID(guid, SRCID_SFindComputer))
            {
                if (!SHRestricted(REST_HASFINDCOMPUTERS))
                    *pVal = VARIANT_TRUE;
            }
            else
            {
                static GUIDREST agr[] = 
                {
                    {&SRCID_SFileSearch, REST_NOFIND},
                    // rest_nofindprinter does not exist yet
                    //{&SRCID_SFindPrinter, REST_NOFINDPRINTER},
                };

                for (int i=0; i < ARRAYSIZE(agr); i++)
                {
                    if (IsEqualGUID(guid, *agr[i].pguid))
                    {
                        if (SHRestricted(agr[i].rest))
                            *pVal = VARIANT_TRUE;
                        break;
                    }
                }
            }
        }
        hr = S_OK;
    }
    else
    {
        hr = E_ACCESSDENIED;
    }

    return hr;
}

HRESULT CSearchAssistantOC::get_ShellFeaturesEnabled(VARIANT_BOOL *pVal)
{
    HRESULT hr;
    
    if (IsTrustedSite())
    {
        if (pVal)
        {
            *pVal = (GetUIVersion() >= 5) ? VARIANT_TRUE : VARIANT_FALSE;
            hr = S_OK;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_ACCESSDENIED;
    }
    
    return hr;
}

HRESULT CSearchAssistantOC::get_SearchAssistantDefault(VARIANT_BOOL *pVal)
{
    HRESULT hr;

    if (IsTrustedSite())
    {
        if (pVal)
        {
            *pVal = !UseCustomInternetSearch();
            hr = S_OK;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_ACCESSDENIED;
    }
    
    return hr;
}

STDMETHODIMP CSearchAssistantOC::get_Searches(ISearches **ppid)
{
    HRESULT hr;
    *ppid = NULL;

    if (IsTrustedSite())
    {
        IServiceProvider *psp;
        hr = IUnknown_QueryService(m_spClientSite, SID_STopLevelBrowser, IID_IServiceProvider, (void**)&psp);
        if (SUCCEEDED(hr))
        {
            IOleCommandTarget *pct;

            hr = psp->QueryService(SID_SExplorerToolbar, IID_IOleCommandTarget, (void **)&pct);
            if (SUCCEEDED(hr))
            {
                VARIANTARG var = {0};
                
                hr = pct->Exec(&CGID_PrivCITCommands, CITIDM_GETFOLDERSEARCHES, 0, NULL, &var);
                if (SUCCEEDED(hr))
                {
                    IFolderSearches *pfs;

                    ASSERT(var.vt == VT_UNKNOWN && var.punkVal);
                    hr = var.punkVal->QueryInterface(IID_IFolderSearches, (void **)&pfs);
                    if (SUCCEEDED(hr))
                    {
                        hr = CSearchCollection_Create(pfs, ppid);
                        pfs->Release();
                    }
                    var.punkVal->Release();
                }
                pct->Release();
                
                hr = S_OK;
            }

            psp->Release();
        }
    }
    else
    {
        hr = E_ACCESSDENIED;
    }

    return hr;
}

STDMETHODIMP CSearchAssistantOC::get_InWebFolder(VARIANT_BOOL *pVal)
{
    HRESULT hr;

    if (IsTrustedSite())
    {
        ASSERT(pVal);
        *pVal = VARIANT_FALSE;

        IBrowserService2 *pbs;
        
        hr = IUnknown_QueryService(m_spClientSite, SID_STopLevelBrowser, IID_IBrowserService2, (void **)&pbs);

        if (SUCCEEDED(hr))
        {
            ITEMIDLIST *pidl;

            hr = pbs->GetPidl(&pidl);

            if (SUCCEEDED(hr))
            {
                // REARCHITECT: Don't use ILIsWeb().  We should use IShellFolder2::GetDefaultSearchGUID() and
                //   test for SRCID_SWebSearch vs. SRCID_SFileSearch/SRCID_SFindComputer/SRCID_SFindPrinter.
                //   This is because Shell Extensions need a way to indicate what kind of search they want
                //   and ILIsWeb() doesn't provide that.  An example of this is "Web Folders" won't return
                //   TRUE from ILIsWeb().  The use of ILIsWeb() should be limited.
                if (ILIsWeb(pidl))
                {
                    *pVal = VARIANT_TRUE;
                }
                
                ILFree(pidl);
            }
            pbs->Release();
        }
        hr = S_OK;
    }
    else
    {
        hr = E_ACCESSDENIED;
    }
    return hr;
}

void GetPerLocalePath(WCHAR *pwszKeyName, int cchKeyName)
{
    ASSERT(cchKeyName >= (ARRAYSIZE(c_wszSearchProps) + 1));
    
    StrCpyNW(pwszKeyName, c_wszSearchProps, cchKeyName);
    *(pwszKeyName + (ARRAYSIZE(c_wszSearchProps) - 1)) = L'\\';

    GetWebLocaleAsRFC1766(pwszKeyName + ARRAYSIZE(c_wszSearchProps), 
                          cchKeyName - (ARRAYSIZE(c_wszSearchProps)));
}

STDMETHODIMP CSearchAssistantOC::PutProperty(VARIANT_BOOL bPerLocale, BSTR bstrName, BSTR bstrValue)
{
    HRESULT hr;

    if (IsTrustedSite())
    {
        HKEY hkey;
        LPCWSTR pwszKeyName;
        WCHAR wszKeyName[MAX_PATH];
        DWORD dwDisposition;

        if (bPerLocale)
        {
            GetPerLocalePath(wszKeyName, ARRAYSIZE(wszKeyName));
            pwszKeyName = wszKeyName;
        }
        else
        {
            pwszKeyName = c_wszSearchProps;
        }

        if (RegCreateKeyExW(HKEY_CURRENT_USER, pwszKeyName, 0, NULL, REG_OPTION_NON_VOLATILE, 
                           KEY_WRITE, NULL, &hkey, &dwDisposition) == ERROR_SUCCESS)
        {
            if ((NULL != bstrValue) && (bstrValue[0] != 0))
            {
                RegSetValueExW(hkey, bstrName, 0, REG_BINARY, (LPBYTE)bstrValue, 
                               SysStringByteLen(bstrValue));
            }
            else
            {
                //  Empty or NULL string means remove the property
                RegDeleteValue(hkey, bstrName);
            }
            RegCloseKey(hkey);
        }
        hr = S_OK;
    }
    else
    {
        hr = E_ACCESSDENIED;
    }
    return hr;
}

STDMETHODIMP CSearchAssistantOC::GetProperty(VARIANT_BOOL bPerLocale, BSTR bstrName, BSTR *pbstrValue)
{
    HRESULT hr;

    if (NULL != pbstrValue)
    {
        *pbstrValue = NULL;
        
        if (IsTrustedSite())
        {
            HKEY hkey;
            LPCWSTR pwszKeyName;
            WCHAR wszKeyName[MAX_PATH];

            if (bPerLocale)
            {
                GetPerLocalePath(wszKeyName, ARRAYSIZE(wszKeyName));
                pwszKeyName = wszKeyName;
            }
            else
            {
                pwszKeyName = c_wszSearchProps;
            }

            if (RegOpenKeyExW(HKEY_CURRENT_USER, pwszKeyName, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
            {
                DWORD dwType;
                DWORD cbSize;
                
                if ((RegQueryValueExW(hkey, bstrName, NULL, &dwType, NULL, &cbSize) == ERROR_SUCCESS) &&
                    (dwType == REG_BINARY))
                {
                    BSTR bstrValue = SysAllocStringByteLen(NULL, cbSize);

                    if (NULL != bstrValue)
                    {
                        if (RegQueryValueExW(hkey, bstrName, NULL, &dwType, (LPBYTE)bstrValue, &cbSize) == ERROR_SUCCESS)
                        {
                            *pbstrValue = bstrValue;
                        }
                        else
                        {
                            SysFreeString(bstrValue);
                        }
                    }
                }
                
                RegCloseKey(hkey);
            }
            hr = S_OK;
        }
        else
        {
            hr = E_ACCESSDENIED;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

STDMETHODIMP CSearchAssistantOC::put_EventHandled(VARIANT_BOOL bHandled)
{
    HRESULT hr;
    
    if (IsTrustedSite())
    {
        m_bEventHandled = bHandled;
        hr = S_OK;
    }
    else
    {
        hr = E_ACCESSDENIED;
    }

    return hr;
}

STDMETHODIMP CSearchAssistantOC::GetSearchAssistantURL(VARIANT_BOOL bSubstitute, VARIANT_BOOL bCustomize, BSTR *pbstrValue)
{
    HRESULT hr;
    
    if (IsTrustedSite())
    {
        if (NULL != pbstrValue)
        {
            WCHAR wszUrl[INTERNET_MAX_URL_LENGTH];

            if (GetSearchAssistantUrlW(wszUrl, ARRAYSIZE(wszUrl), bSubstitute, bCustomize))
            {
                *pbstrValue = SysAllocString(wszUrl);
            }
            hr = S_OK;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_ACCESSDENIED;
    }

    return hr;
}

STDMETHODIMP CSearchAssistantOC::NotifySearchSettingsChanged()
{
    HRESULT hr;
    
    if (IsTrustedSite())
    {
        SendShellIEBroadcastMessage(WM_WININICHANGE, 0, (LPARAM)SEARCH_SETTINGS_CHANGED, 3000);
        hr = S_OK;
    }
    else
    {
        hr = E_ACCESSDENIED;
    }

    return hr;
}

STDMETHODIMP CSearchAssistantOC::put_ASProvider(BSTR Provider)
{
    HRESULT hr;
    
    if (IsTrustedSite())
    {
        if (Provider)
        {
            DWORD dwRet = SHSetValueW(HKEY_CURRENT_USER, REG_SZ_IE_SEARCURL, REG_SZ_PROVIDER, REG_SZ,
                                      Provider, (lstrlenW(Provider) + 1) * sizeof(WCHAR));

            ASSERT(ERROR_SUCCESS == dwRet);
        }
        hr = S_OK;
    }
    else
    {
        hr = E_ACCESSDENIED;
    }

    return hr;
}

STDMETHODIMP CSearchAssistantOC::get_ASProvider(BSTR *pProvider)
{
    HRESULT hr;
    
    if (IsTrustedSite())
    {
        if (NULL != pProvider)
        {
            HKEY hkey;

            if (ERROR_SUCCESS == RegOpenKeyExW(HKEY_CURRENT_USER, REG_SZ_IE_SEARCURL, 0, KEY_READ, &hkey))
            {
                DWORD dwType;
                DWORD dwSize;
                
                if ((ERROR_SUCCESS == RegQueryValueExW(hkey, REG_SZ_PROVIDER, NULL, 
                                                       &dwType, NULL, &dwSize)) && 
                                                       (REG_SZ == dwType))
                {
                    *pProvider = SysAllocStringByteLen(NULL, dwSize);
                    if (NULL != *pProvider)
                    {
                        if (ERROR_SUCCESS != RegQueryValueExW(hkey, REG_SZ_PROVIDER, NULL, 
                                                              &dwType, (LPBYTE)*pProvider, &dwSize))
                        {
                            *pProvider = 0;
                        }
                    }
                }
                RegCloseKey(hkey);
            }
            hr = S_OK;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_ACCESSDENIED;
    }

    return hr;
}

STDMETHODIMP CSearchAssistantOC::put_ASSetting(int Setting)
{
    HRESULT hr;
    
    if (IsTrustedSite())
    {
        DWORD dwRet = SHSetValueW(HKEY_CURRENT_USER, REG_SZ_IE_MAIN, REG_SZ_AUTOSEARCH, REG_DWORD,
                                  &Setting, sizeof(DWORD));

        ASSERT(ERROR_SUCCESS == dwRet);
        hr = S_OK;
    }
    else
    {
        hr = E_ACCESSDENIED;
    }

    return hr;
}

STDMETHODIMP CSearchAssistantOC::get_ASSetting(int *pSetting)
{
    HRESULT hr;
    
    if (IsTrustedSite())
    {
        if (NULL != pSetting)
        {
            DWORD dwSize = sizeof(int);

            *pSetting = -1;
            
            DWORD dwRet = SHGetValueW(HKEY_CURRENT_USER, REG_SZ_IE_MAIN, REG_SZ_AUTOSEARCH, NULL,
                                      pSetting, &dwSize);

            hr = S_OK;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_ACCESSDENIED;
    }

    return hr;
}

BOOL CSearchAssistantOC::IsTrustedSite()
{
    if (!m_bSafetyInited && m_spClientSite)
    {
        m_bSafetyInited = TRUE;

        IHTMLDocument2 *pHTMLDocument2;
      
        HRESULT hr = GetHTMLDoc2(m_spClientSite, &pHTMLDocument2);

        if (SUCCEEDED(hr))
        {
            ASSERT(NULL != pHTMLDocument2);

            IHTMLLocation *pHTMLLocation;

            hr = pHTMLDocument2->get_location(&pHTMLLocation);

            if (SUCCEEDED(hr) && (NULL != pHTMLLocation))
            {           
                BSTR bstrUrl;

                pHTMLLocation->get_href(&bstrUrl);

                if (SUCCEEDED(hr) && (NULL != bstrUrl))
                {
                    HKEY hkey;
                    
                    //  FEATURE (tnoonan)
                    //  This code is duped with CSearchBand::_IsSafeUrl in browseui
                    
                    if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\SafeSites", 0, KEY_READ, &hkey) == ERROR_SUCCESS)
                    {        
                        WCHAR wszValue[MAX_PATH];
                        WCHAR wszData[MAX_URL_STRING];
                        WCHAR wszExpandedUrl[MAX_URL_STRING];
                        DWORD cbData = SIZEOF(wszData);
                        DWORD cchValue = ARRAYSIZE(wszValue);

                        for (int i=0; RegEnumValueW(hkey, i, wszValue, &cchValue, NULL, NULL, (LPBYTE)wszData, &cbData) == ERROR_SUCCESS; i++)
                        {
                            if (SHExpandEnvironmentStringsW(wszData, wszExpandedUrl, ARRAYSIZE(wszExpandedUrl)) > 0)
                            {
                                cchValue = ARRAYSIZE(wszExpandedUrl);
                                if (SUCCEEDED(UrlCanonicalizeW(wszExpandedUrl, wszExpandedUrl, &cchValue, 0)))
                                {
                                    if (cchValue > 0)
                                    {
                                        BOOL bRet;
                                        if (wszExpandedUrl[cchValue-1] == L'*')
                                        {
                                            bRet = StrCmpNIW(bstrUrl, wszExpandedUrl, cchValue - 1) == 0;
                                        }
                                        else
                                        {
                                            bRet = StrCmpIW(bstrUrl, wszExpandedUrl) == 0;
                                        }

                                        m_bIsTrustedSite = bRet ? TRUE : FALSE;
                                        
                                        if (m_bIsTrustedSite)
                                            break;
                                    }
                                }
                                cbData = SIZEOF(wszData);
                                cchValue = ARRAYSIZE(wszValue);
                            }
                        }
                        RegCloseKey(hkey);
                    }

                    SysFreeString(bstrUrl);
                }
                
                pHTMLLocation->Release();
            }
            
            pHTMLDocument2->Release();
        }
    }

    return m_bIsTrustedSite;
}

HRESULT CSearchAssistantOC::UpdateRegistry(BOOL bRegister)
{
    //this control uses selfreg.inx, not the ATL registry goo
    return S_OK;
}

STDMETHODIMP CSearchAssistantOC::FindOnWeb()
{
    if (!IsTrustedSite() && m_punkSite==NULL)
        return E_ACCESSDENIED ;

    return ShowSearchBand( SRCID_SWebSearch ) ;
}

STDMETHODIMP CSearchAssistantOC::FindFilesOrFolders()
{
    if (!IsTrustedSite() && m_punkSite==NULL)
        return E_ACCESSDENIED ;

    return ShowSearchBand( SRCID_SFileSearch ) ;
}

STDMETHODIMP CSearchAssistantOC::FindComputer()
{
    if (!IsTrustedSite() && m_punkSite==NULL)
        return E_ACCESSDENIED ;

    return ShowSearchBand( SRCID_SFindComputer ) ;
}

STDMETHODIMP CSearchAssistantOC::FindPrinter()
{
    if (!IsTrustedSite() && m_punkSite==NULL)
        return E_ACCESSDENIED ;

    HRESULT hr = E_FAIL;
    IShellDispatch2* psd2;
    if( SUCCEEDED( (hr = CoCreateInstance( CLSID_Shell, NULL, CLSCTX_INPROC_SERVER,
                                           IID_IShellDispatch2, (void**)&psd2 )) ) )
    {
        hr = psd2->FindPrinter( NULL, NULL, NULL ) ;
        psd2->Release();
    }
    return hr ;
}

STDMETHODIMP CSearchAssistantOC::FindPeople()
{
    if (!IsTrustedSite() && m_punkSite==NULL)
    {
        return E_ACCESSDENIED;
    }

    SHELLEXECUTEINFO sei = {0};
    sei.cbSize = sizeof(SHELLEXECUTEINFO);
    sei.hwnd = HWND_DESKTOP;
    sei.lpVerb = TEXT("open");
    sei.lpFile = TEXT("wab.exe");
    sei.lpParameters = TEXT("/find");
    sei.lpDirectory = NULL;
    sei.nShow = SW_SHOWNORMAL;

    if (!ShellExecuteEx(&sei))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        return S_OK;
    }
}

// Wininet helper method to retry autodetection

// check to make sure that the hosting page is on
// the local computer.
// stolen from the zones code by joshco
//
STDMETHODIMP CSearchAssistantOC::LocalZoneCheck( )
{
    HRESULT hr = E_ACCESSDENIED;

    //  Return S_FALSE if we don't have a host site since we have no way of doing a 
    //  security check.  This is as far as VB 5.0 apps get.
    if (!m_spClientSite)
        return S_FALSE;

    //  1)  Get an IHTMLDocument2 pointer
    //  2)  Get URL from doc
    //  3)  Create security manager
    //  4)  Check if doc URL zone is local, if so everything's S_OK
    //  5)  Otherwise, get and compare doc URL SID to requested URL SID

    IHTMLDocument2 *pHtmlDoc;
    if (SUCCEEDED(GetHTMLDoc2(m_spClientSite, &pHtmlDoc)))
    {
        ASSERT(pHtmlDoc);
        BSTR bstrDocUrl;
        if (SUCCEEDED(pHtmlDoc->get_URL(&bstrDocUrl)))
        {
            ASSERT(bstrDocUrl);
            IInternetSecurityManager *pSecMgr;

            if (SUCCEEDED(CoCreateInstance(CLSID_InternetSecurityManager, 
                                           NULL, 
                                           CLSCTX_INPROC_SERVER,
                                           IID_IInternetSecurityManager, 
                                           (void **)&pSecMgr)))
            {
                ASSERT(pSecMgr);
                DWORD dwZoneID = URLZONE_UNTRUSTED;
                if (SUCCEEDED(pSecMgr->MapUrlToZone(bstrDocUrl, &dwZoneID, 0)))
                {
                    if (dwZoneID == URLZONE_LOCAL_MACHINE)
                        hr = S_OK;
                }
               
                pSecMgr->Release();
            }
            SysFreeString(bstrDocUrl);
        }
        pHtmlDoc->Release();
    }
    else
    {
        //  If we don't have an IHTMLDocument2 we aren't running in a browser that supports
        //  our OM.  We shouldn't block in this case since we could potentially
        //  get here from other hosts (VB, WHS, etc.).
        hr = S_FALSE;
    }

    return hr;
}

// set flags so that the next navigate will cause 
// a proxy autodetection cycle
// used in dnserr.htm along with location.reload.
// added by joshco
//
STDMETHODIMP CSearchAssistantOC::NETDetectNextNavigate()
{
    HRESULT hr = S_FALSE;

 CHAR  szConnectionName[100];
 DWORD dwBufLen;
 DWORD dwFlags;
 BOOL fResult;

 if (  LocalZoneCheck() != S_OK ) {
     // some security problem.. time to bail.
    hr=E_ACCESSDENIED;
    goto error;
    }

 dwBufLen = sizeof(szConnectionName);

       // find the connection name via internetconnected state
       
 fResult = InternetGetConnectedStateExA(&dwFlags,  szConnectionName,dwBufLen, 0 );

 INTERNET_PER_CONN_OPTION_LISTA list;
 INTERNET_PER_CONN_OPTIONA option;
       
 list.dwSize = sizeof(INTERNET_PER_CONN_OPTION_LISTA);
 if(!fResult || (dwFlags & INTERNET_CONNECTION_LAN))
    {
        list.pszConnection = NULL;
    }
    else
    {
        list.pszConnection =  szConnectionName;
    }

 list.dwOptionCount = 1;
 list.pOptions = &option;
 option.dwOption = INTERNET_PER_CONN_FLAGS;
 dwBufLen= sizeof(list);

   // now call internetsetoption to do it..
   // first set this connectoid to enable autodetect
 if ( ! InternetQueryOptionA(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION ,
         &list,&dwBufLen) ) 
    {
           goto error;
    }
               
 option.Value.dwValue |= PROXY_TYPE_AUTO_DETECT ;

 if ( ! InternetSetOptionA(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION ,
        &list,sizeof(list))) 
   {
         goto error;
   }

 if ( ! InternetInitializeAutoProxyDll(0) ) {
         goto error;
   }

 //  Now set the autodetect flags for this connectoid to
 //  do a passive detect and shut itself off if it doesnt work
 option.dwOption = INTERNET_PER_CONN_AUTODISCOVERY_FLAGS;
 
 if ( ! InternetQueryOptionA(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION ,
         &list,&dwBufLen) ) 
    {
           goto error;
    }
               
 option.Value.dwValue &= ~(AUTO_PROXY_FLAG_DETECTION_RUN) ;

 if ( ! InternetSetOptionA(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION ,
        &list,sizeof(list))) 
   {
         goto error;
   }


 
 if ( ! InternetSetOptionA(NULL, INTERNET_OPTION_SETTINGS_CHANGED,NULL, 0) ) {
         goto error;
   }



 hr=S_OK;
 error: ;
     
 return hr;
}

STDMETHODIMP CSearchAssistantOC::PutFindText(BSTR FindText)
{
    HRESULT hr;
    
    if (IsTrustedSite())
    {
        IServiceProvider *pServiceProvider;
        
        hr = IUnknown_QueryService(m_pSearchBandTBHelper, 
                                   SID_SProxyBrowser, 
                                   IID_IServiceProvider, 
                                   (void **)&pServiceProvider);
        if (SUCCEEDED(hr))
        {
            IWebBrowser2 *pWebBrowser2;
            hr = pServiceProvider->QueryService(SID_SWebBrowserApp, 
                                                IID_IWebBrowser2, 
                                                (void **)&pWebBrowser2);
            if (SUCCEEDED(hr))
            {
                ::PutFindText(pWebBrowser2, FindText);
                pWebBrowser2->Release();
            }
            pServiceProvider->Release();
        }
        hr = S_OK;
    }
    else
    {
        hr = E_ACCESSDENIED;
    }

    return hr;
}

STDMETHODIMP CSearchAssistantOC::get_Version(int *pVersion)
{
    if (NULL != pVersion)
    {
        *pVersion = SAOC_VERSION;
    }
    return S_OK;
}

// x_hex_digit and URLEncode were stolen from trident

inline int x_hex_digit(int c)
{
    if (c >= 0 && c <= 9)
    {
        return c + '0';
    }
    if (c >= 10 && c <= 15)
    {
        return c - 10 + 'A';
    }
    return '0';
}

/*
   The following array was copied directly from NCSA Mosaic 2.2
 */
static const unsigned char isAcceptable[96] =
/*   0 1 2 3 4 5 6 7 8 9 A B C D E F */
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0,    /* 2x   !"#$%&'()*+,-./  */
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,    /* 3x  0123456789:;<=>?  */
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,    /* 4x  @ABCDEFGHIJKLMNO  */
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,    /* 5x  PQRSTUVWXYZ[\]^_  */
 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,    /* 6x  `abcdefghijklmno  */
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0};   /* 7x  pqrstuvwxyz{\}~  
DEL */

// Performs URL-encoding of null-terminated strings. Pass NULL in pbOut
// to find buffer length required. Note that '\0' is not written out.

int URLEncode(char * pbOut, const char * pchIn)
{
    int     lenOut = 0;
    char *  pchOut = pbOut;

    ASSERT(pchIn);

    for (; *pchIn; pchIn++, lenOut++)
    {
        if (*pchIn == ' ')
        {
            if (pchOut)
                *pchOut++ = '+';
        }
        else if (*pchIn >= 32 && *pchIn <= 127 && isAcceptable[*pchIn - 32])
        {
            if (pchOut)
                *pchOut++ = *pchIn;
        }
        else
        {
            if (pchOut)
                *pchOut++ = '%';
            lenOut++;

            if (pchOut)
                *pchOut++ = (char)x_hex_digit((*pchIn >> 4) & 0xf);
            lenOut++;

            if (pchOut)
                *pchOut++ = (char)x_hex_digit(*pchIn & 0xf);
        }
    }
    return lenOut;
}

STDMETHODIMP CSearchAssistantOC::EncodeString(BSTR bstrValue, BSTR bstrCharSet, VARIANT_BOOL bUseUTF8, BSTR *pbstrResult)
{

    if ((NULL != bstrValue) && (NULL != pbstrResult))
    {
        HRESULT hr;
        IMultiLanguage2 *pMultiLanguage2;

        *pbstrResult = NULL;
        
        hr = CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER,
                              IID_IMultiLanguage2, (void**)&pMultiLanguage2);

        if (SUCCEEDED(hr))
        {
            UINT uiCodePage = CP_BOGUS;
            UINT cchVal = SysStringLen(bstrValue);
            DWORD dwMode = 0;

            if (!bUseUTF8)
            {
                //  We're not using UTF so try and get the code page from the 
                //  charset.
                
                MIMECSETINFO info;
                
                hr = pMultiLanguage2->GetCharsetInfo(bstrCharSet, &info);

                if (SUCCEEDED(hr))
                {                   
                    hr = pMultiLanguage2->ConvertStringFromUnicodeEx(&dwMode,
                                                                     info.uiCodePage,
                                                                     bstrValue,
                                                                     &cchVal,
                                                                     NULL,
                                                                     NULL,
                                                                     MLCONVCHARF_NOBESTFITCHARS,
                                                                     NULL);
                    if (S_OK == hr)
                    {
                        uiCodePage = info.uiCodePage;
                    }
                }
            }
            else
            {
                uiCodePage = CP_UTF_8;
            }

            if (uiCodePage == CP_BOGUS)
            {
                //  we have characters which don't work in the charset or the charset
                //  is unknown to MLang, maybe MLang can figure out a code page to use.
                
                IMLangCodePages *pMLangCodePages;

                //  When all else fails...
                uiCodePage = CP_ACP;

                hr = pMultiLanguage2->QueryInterface(IID_IMLangCodePages,
                                                     (void **)&pMLangCodePages);
                if (SUCCEEDED(hr))
                {
                    DWORD dwCodePages = 0;
                    long cchProcessed = 0;
                    UINT uiTmpCP = 0;
                    
                    if (SUCCEEDED(pMLangCodePages->GetStrCodePages(bstrValue, cchVal, 
                                                                   0, &dwCodePages,
                                                                   &cchProcessed)) 

                        &&

                        SUCCEEDED(pMLangCodePages->CodePagesToCodePage(dwCodePages,
                                                                       0,
                                                                       &uiTmpCP)))
                    {
                        uiCodePage = uiTmpCP;
                    }

                    pMLangCodePages->Release();
                }
            }

            dwMode = 0;

            UINT cbVal = 0;

            //  Ask MLang how big of a buffer we need
            hr = pMultiLanguage2->ConvertStringFromUnicode(&dwMode,
                                                           uiCodePage,
                                                           bstrValue,
                                                           &cchVal,
                                                           NULL,
                                                           &cbVal);

            if (SUCCEEDED(hr))
            {
                CHAR *pszValue = new CHAR[cbVal + 1];

                if (NULL != pszValue)
                {
                    //  Really convert the string
                    hr = pMultiLanguage2->ConvertStringFromUnicode(&dwMode,
                                                                   uiCodePage,
                                                                   bstrValue,
                                                                   &cchVal,
                                                                   pszValue,
                                                                   &cbVal);
                    if (SUCCEEDED(hr))
                    {
                        pszValue[cbVal] = 0;
                        
                        int cbEncVal = URLEncode(NULL, pszValue);
                        CHAR *pszEncVal = new CHAR[cbEncVal];

                        if (NULL != pszEncVal)
                        {
                            URLEncode(pszEncVal, pszValue);

                            int cchResult = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                                                                pszEncVal, cbEncVal,
                                                                NULL, 0);

                            *pbstrResult = SysAllocStringLen(NULL, cchResult);

                            if (NULL != *pbstrResult)
                            {
                                MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                                                    pszEncVal, cbEncVal,
                                                    *pbstrResult, cchResult);
                            }

                            delete [] pszEncVal;
                        }
                    }
                    delete [] pszValue;
                }
            }
            pMultiLanguage2->Release();
        }
    }


    return S_OK;
}

STDMETHODIMP CSearchAssistantOC::get_ShowFindPrinter(VARIANT_BOOL *pbShowFindPrinter)
{
    HRESULT hr;

    if (IsTrustedSite())
    {
        if (NULL != pbShowFindPrinter)
        {
            IShellDispatch2* psd;

            *pbShowFindPrinter = VARIANT_FALSE;

            if (SUCCEEDED(CoCreateInstance(CLSID_Shell, 0, CLSCTX_INPROC_SERVER, 
                                          IID_IShellDispatch2, (void**)&psd)))
            {
                BSTR bstrName = SysAllocString( L"DirectoryServiceAvailable");

                if (bstrName)
                {
                    VARIANT varRet = {0};
                    
                    if (SUCCEEDED(psd->GetSystemInformation(bstrName, &varRet)))
                    {
                        ASSERT(VT_BOOL == varRet.vt);
                        *pbShowFindPrinter = varRet.boolVal;
                    }
                    SysFreeString(bstrName);
                }
                psd->Release();
            }
            hr = S_OK;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_ACCESSDENIED;
    }

    return hr;
}


STDMETHODIMP CSearchAssistantOC::get_SearchCompanionAvailable(VARIANT_BOOL *pbAvailable)
{
    HRESULT hr = E_ACCESSDENIED;
    if (IsTrustedSite())
    {
        if (pbAvailable != NULL)
        {
            BOOL fSCAvailable = FALSE;
            // need to determine if search companion is available on system and supports user locale
            ISearchCompanionInfo*   psci;
            hr = CoCreateInstance(CLSID_SearchCompanionInfo, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(ISearchCompanionInfo, &psci));
            if (SUCCEEDED(hr))
            {
                hr = psci->IsSearchCompanionInetAvailable(&fSCAvailable);
                psci->Release();
            }
            *pbAvailable = fSCAvailable ? VARIANT_TRUE : VARIANT_FALSE;
            hr = S_OK;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    return hr;
}

STDMETHODIMP CSearchAssistantOC::put_UseSearchCompanion(VARIANT_BOOL bUseSC)
{
    HRESULT hr = E_ACCESSDENIED;
    if (IsTrustedSite())
    {
        LPCTSTR pszUseSC = bUseSC ? TEXT("yes") : TEXT("no");
        SHSetValue(HKEY_CURRENT_USER, REG_SZ_IE_MAIN, REG_SZ_USE_SEARCH_COMP, REG_SZ, pszUseSC, CbFromCch(lstrlen(pszUseSC) + 1));

        if (bUseSC)
        {
            // disable "Use Custom Search URL" as SC won't launch if custom search URL is defined
            DWORD dwUseCustom = FALSE;
            SHSetValue(HKEY_CURRENT_USER, REG_SZ_IE_MAIN, REG_SZ_USECUSTOM, REG_DWORD, &dwUseCustom, sizeof(dwUseCustom));
        }
        
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CSearchAssistantOC::get_UseSearchCompanion(VARIANT_BOOL *pbUseSC)
{
    HRESULT hr = E_ACCESSDENIED;
    if (IsTrustedSite())
    {
        if (pbUseSC != NULL)
        {
            BOOL fUseSC = SHRegGetBoolUSValue(REG_SZ_IE_MAIN, REG_SZ_USE_SEARCH_COMP, FALSE, FALSE);
            *pbUseSC = fUseSC ? VARIANT_TRUE : VARIANT_FALSE;
            hr = S_OK;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    return hr;
}


#ifdef ENABLE_THIS_FOR_IE5X

STDMETHODIMP CSearchAssistantOC::RefreshLocation(IDispatch *pLocation)
{
    HRESULT hr;
    
    if (IsTrustedSite())
    {
        if (NULL != pLocation)
        {
            IHTMLLocation *pHTMLLocation;

            IUnknown_QueryService(pLocation, IID_IHTMLLocation, IID_IHTMLLocation, (void **)&pHTMLLocation);

            if (pHTMLLocation)
            {
                pHTMLLocation->reload(VARIANT_TRUE);
                pHTMLLocation->Release();
            }
        }
        hr = S_OK;
    }
    else
    {
        hr = E_ACCESSDENIED;
    }

    return hr;

}

#endif
//-------------------------------------------------------------------------//
#define REG_SZ_SHELL_SEARCH TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\") \
                            TEXT("Explorer\\FindExtensions\\Static\\ShellSearch")
//-------------------------------------------------------------------------//
HRESULT GetSearchURLs( 
    IN REFGUID guidSearch, 
    OUT LPTSTR pszUrl, 
    IN DWORD cch, 
    OUT OPTIONAL LPTSTR pszUrlNavNew, 
    OUT DWORD cchNavNew, 
    OUT BOOL *pfRunInProcess )
{
    HRESULT hr = E_FAIL ;
    DWORD   cb ;
    DWORD   dwType ;
    DWORD   dwErr ;

    *pfRunInProcess = FALSE ;
    if( pszUrlNavNew && cchNavNew )
        *pszUrlNavNew = 0 ;

    if( IsEqualGUID( guidSearch, SRCID_SWebSearch ) )
    {
        if( GetDefaultInternetSearchUrlW( pszUrl, cch, TRUE ) )
            hr = S_OK ;
    }
    else
    {
        //  The shell search URL-eating stuff was adapted from
        //  CShellSearchExt::_GetSearchUrls() in browseui\browband.cpp, 
        //  and should be kept in sync.

        TCHAR szSubKey[32];
        HKEY  hkey, hkeySub;
        if( (dwErr = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_SZ_SHELL_SEARCH, 
                                   0, KEY_READ, &hkey )) != ERROR_SUCCESS )
            return HRESULT_FROM_WIN32( dwErr ) ;

        hr = E_FAIL ;

        for( int i = 0; 
             wnsprintf( szSubKey, ARRAYSIZE(szSubKey), TEXT("%d"), i ), 
                RegOpenKey(hkey, szSubKey, &hkeySub) == ERROR_SUCCESS ;
             i++ )
        {
            TCHAR szSearchGuid[MAX_PATH];

            cb = SIZEOF(szSearchGuid);
            
            if( SHGetValue( hkeySub, TEXT("SearchGUID"), NULL, &dwType, (BYTE*)szSearchGuid, &cb ) == ERROR_SUCCESS )
            {
                GUID guid;
                SHCLSIDFromString(szSearchGuid, &guid);

                if( IsEqualGUID( guid, guidSearch ) )
                {
                    cb = cch * sizeof(TCHAR);
                    if( SHGetValue( hkeySub, TEXT("SearchGUID\\Url"), NULL, 
                                    &dwType, (BYTE*)pszUrl, &cb ) == ERROR_SUCCESS )
                    {
                        if( pszUrlNavNew && cchNavNew )
                        {
                            // See if there is a secondary URL that we should navigate to
                            cb = cchNavNew * sizeof(TCHAR);
                            SHGetValue(hkeySub, TEXT("SearchGUID\\UrlNavNew"), NULL, &dwType, (BYTE*)pszUrlNavNew, &cb);
                        }

                        // try to grab the RunInProcess flag
                        *pfRunInProcess = (BOOL)SHRegGetIntW( hkeySub, L"RunInProcess", 0 );

                        RegCloseKey(hkeySub);
                        hr = S_OK ;
                        break;
                    }
                }
            }
            RegCloseKey(hkeySub);
        }
        RegCloseKey( hkey ) ;
    }
    return hr ;
}

STDMETHODIMP _IsShellSearchBand( REFGUID guidSearch )
{
    if (IsEqualGUID( guidSearch, SRCID_SFileSearch ) ||
        IsEqualGUID( guidSearch, SRCID_SFindComputer ) ||
        IsEqualGUID( guidSearch, SRCID_SFindPrinter ) )
        return S_OK;
    return S_FALSE;
}

//-------------------------------------------------------------------------//
//  Establishes the correct shell search dialog, etc.
STDMETHODIMP _ShowShellSearchBand( IWebBrowser2* pwb2, REFGUID guidSearch )
{
    ASSERT( pwb2 );
    ASSERT( S_OK == _IsShellSearchBand( guidSearch ) );

    HRESULT hr;
    VARIANT varBand;
    if (SUCCEEDED( (hr = InitBSTRVariantFromGUID(&varBand, CLSID_FileSearchBand)) ))
    {
        //  Retrieve the FileSearchBand's unknown from the browser frame as a VT_UNKNOWN property;
        //  (FileSearchBand initialized and this when he was created and hosted.)
        VARIANT varFsb;
        if (SUCCEEDED( (hr = pwb2->GetProperty( varBand.bstrVal, &varFsb )) ))
        {
            if (VT_UNKNOWN == varFsb.vt && varFsb.punkVal != NULL )
            {
                //  Retrieve the IFileSearchBand interface
                IFileSearchBand* pfsb;
                if (SUCCEEDED( (hr = varFsb.punkVal->QueryInterface( IID_IFileSearchBand, (LPVOID*)&pfsb )) ))
                {
                    //  Assign the correct search type to the band
                    VARIANT varSearchID;
                    if (SUCCEEDED( (hr = InitBSTRVariantFromGUID(&varSearchID, guidSearch)) ))
                    {
                        VARIANT      varNil = {0};
                        VARIANT_BOOL bNavToResults = VARIANT_FALSE ; 
                            // Note [scotthan]: we only navigate to results when we create a 
                            // new frame for the search, which we never do from srchasst.
                        pfsb->SetSearchParameters( &varSearchID.bstrVal, bNavToResults, &varNil, &varNil );
                        VariantClear( &varSearchID );
                    }
                    pfsb->Release();
                }
            }
            VariantClear( &varFsb );
        }
        VariantClear( &varBand );
    }
    return hr;
}

//-------------------------------------------------------------------------//
//  The goop to show a search band in the current browser frame.
//  6/1
HRESULT CSearchAssistantOC::ShowSearchBand( REFGUID guidSearch ) 
{
    HRESULT           hr = E_FAIL;
    TCHAR             szUrl[MAX_URL_STRING];
    TCHAR             szUrlNavNew[MAX_URL_STRING];
    CLSID             clsidBand;
    BOOL              fShellSearchBand = FALSE;
    BOOL              fRunInProcess = FALSE;
    IUnknown*         punkSite = m_punkSite ? m_punkSite : (IUnknown*)m_spClientSite;

    if( !punkSite )
        return E_UNEXPECTED ;

    //  Determine band class and whether the band supports navigation
    if( (fShellSearchBand = (S_OK == _IsShellSearchBand( guidSearch ))) )
    {
        if (SHRestricted(REST_NOFIND) && IsEqualGUID(guidSearch, SRCID_SFileSearch))
            return E_ACCESSDENIED;
        clsidBand = CLSID_FileSearchBand;
    }
    else
    {
        clsidBand = CLSID_SearchBand;
        //  we need to navigate to a search URL, grope the registry for that special URL
        if( FAILED( (hr= GetSearchURLs( guidSearch, szUrl, ARRAYSIZE(szUrl), 
                                        szUrlNavNew, ARRAYSIZE(szUrlNavNew), 
                                        &fRunInProcess )) ) )
            return hr;
    }
        
    //  FEATURE [scotthan]: this function will fail unless invoked from within a browser.
    //  This sits fine for now since SearchAsst is designed as a browser band.
    IWebBrowser2* pwb2;
    hr = IUnknown_QueryServiceForWebBrowserApp(punkSite, IID_PPV_ARG(IWebBrowser2, &pwb2));
    if (SUCCEEDED(hr))
    {
        SA_BSTRGUID bstrClsid;
        InitFakeBSTR(&bstrClsid, clsidBand);

        VARIANT var;
        var.bstrVal = bstrClsid.wsz;
        var.vt = VT_BSTR;

        VARIANT  varNil = {0};
            
        // show a search bar
        hr = pwb2->ShowBrowserBar(&var, &varNil, &varNil);
        if( SUCCEEDED( hr ) )
        {
            VARIANT varFlags;
            if( fShellSearchBand )
            {
                hr= _ShowShellSearchBand( pwb2, guidSearch );
            }
            else
            {
                varFlags.vt = VT_I4;
                varFlags.lVal = navBrowserBar;
                var.bstrVal = SysAllocString( T2W( szUrl ) ) ;
                var.vt = VT_BSTR ;

                // navigate the search bar to the correct url
                hr = pwb2->Navigate2(&var, &varFlags, &varNil, &varNil, &varNil);

                SysFreeString(var.bstrVal);
                    
                if( SUCCEEDED( hr ) )
                {
                    hr = pwb2->put_Visible( TRUE ) ;
                }
            }
        }
        pwb2->Release();
    }
    return hr;
}

STDMETHODIMP CSearchAssistantOC::SetSite( IUnknown* punkSite )
{
    ATOMICRELEASE(m_punkSite);
    if ((m_punkSite = punkSite) != NULL)
        m_punkSite->AddRef() ;
    return S_OK ;
}

STDMETHODIMP CSearchAssistantOC::GetSite( REFIID riid, void** ppvSite )
{
    if( !m_punkSite )
        return E_FAIL ;
    return m_punkSite->QueryInterface( riid, ppvSite ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\strmwrap.cpp ===
#include "priv.h"

#define MAX_STREAMS 5 
#define CP_UNICODE 1200

class CStreamWrap : public IStream
{

public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv);
    STDMETHOD_(ULONG,AddRef) (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IStream methods ***
    STDMETHOD(Read) (THIS_ void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHOD(Write) (THIS_ VOID const *pv, ULONG cb, ULONG *pcbWritten);
    STDMETHOD(Seek) (THIS_ LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHOD(SetSize) (THIS_ ULARGE_INTEGER libNewSize);
    STDMETHOD(CopyTo) (THIS_ IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    STDMETHOD(Commit) (THIS_ DWORD grfCommitFlags);
    STDMETHOD(Revert) (THIS);
    STDMETHOD(LockRegion) (THIS_ ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHOD(UnlockRegion) (THIS_ ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHOD(Stat) (THIS_ STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHOD(Clone)(THIS_ IStream **ppstm);

    HRESULT Init(IStream *aStreams[], UINT cStreams, UINT uiCodePage);
    CStreamWrap();

private:
    ~CStreamWrap();

    LONG        _cRef;
    IStream     *_aStreams[MAX_STREAMS];
    BOOL        _fFirstReadForStream[MAX_STREAMS];
    UINT        _cStreams;
    UINT        _iCurStream;
    UINT        _uiCodePage;
    UINT        _uiBOM;         // Byte order marker
};

CStreamWrap::CStreamWrap() : _cRef(1)
{
}

CStreamWrap::~CStreamWrap()
{
    while (_cStreams--)
    {
        if (_aStreams[_cStreams])
        {
            _aStreams[_cStreams]->Release();
            _aStreams[_cStreams] = NULL;
        }
    }
}

HRESULT CStreamWrap::Init(IStream *aStreams[], UINT cStreams, UINT uiCodePage)
{
    if (cStreams > ARRAYSIZE(_aStreams))
        return E_FAIL; 
    
    for (_cStreams = 0; _cStreams < cStreams; _cStreams++)
    {
        _aStreams[_cStreams] = aStreams[_cStreams];
        _fFirstReadForStream[_cStreams] = TRUE;
        _aStreams[_cStreams]->AddRef();
    }

    _uiCodePage = uiCodePage;
    _uiBOM = 0xfeff;            // FEATURE - set default to byte order of machine
    
    return S_OK;
}

STDMETHODIMP CStreamWrap::QueryInterface(REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IStream) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = SAFECAST(this, IStream *);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    this->AddRef();
    return NOERROR;
}

STDMETHODIMP_(ULONG) CStreamWrap::AddRef()
{
    return InterlockedIncrement(&this->_cRef);
}

STDMETHODIMP_(ULONG) CStreamWrap::Release()
{
    if (InterlockedDecrement(&this->_cRef))
        return this->_cRef;

    delete this;
    return 0;
}

// Byte order marker macros
#define IS_BOM_LITTLE_ENDIAN(pv) ((*(WORD*)pv) == 0xfffe)
#define IS_BOM_BIG_ENDIAN(pv)    ((*(WORD*)pv) == 0xfeff)

STDMETHODIMP CStreamWrap::Read(void *pv, ULONG cb, ULONG *pcbRead)
{
    ULONG cbReadTotal = 0;
    ULONG cbLeftToRead = cb;
    HRESULT hres = NOERROR;

    while (cbLeftToRead && (_iCurStream < _cStreams))
    {
        ULONG cbReadThisStream;
        hres = _aStreams[_iCurStream]->Read(pv, cbLeftToRead, &cbReadThisStream);

        // REVIEW: what if one stream's implementation returns a failure code
        // when reading at the end of the stream?  We bail prematurely.
        if (SUCCEEDED(hres))
        {
            cbLeftToRead -= cbReadThisStream;

            if(_uiCodePage == CP_UNICODE)
            {
                if((_fFirstReadForStream[_iCurStream]) &&
                   (cbReadThisStream >= 2) &&
                   ((IS_BOM_LITTLE_ENDIAN(pv)) || (IS_BOM_BIG_ENDIAN(pv)))
                   )
                {
                    if(_iCurStream == 0)
                    {
                        _uiBOM = (*(WORD*)pv);    // Save first streams byte order marker as default
                    }
                    else
                    {
                        // REVIEW: should handle swapping bytes to default for IE6
                        if(_uiBOM != (*(WORD*)pv))  // BOM not default
                            return(E_FAIL);
                            
                        // Skip past unicode document lead bytes
                        cbReadThisStream -= 2;
                        MoveMemory((BYTE*)pv, (BYTE*)pv+2, cbReadThisStream);
                    }
                }

                _fFirstReadForStream[_iCurStream] = FALSE;
            }
            cbReadTotal += cbReadThisStream;
            pv = (char *)pv + cbReadThisStream;

            if (cbLeftToRead)
            {
                _iCurStream++;
                hres = S_OK;
            }
        }
        else
            break;
    }

    if (pcbRead)
        *pcbRead = cbReadTotal;

    if (SUCCEEDED(hres) && cbLeftToRead)
        hres = S_FALSE; // still success! but not completely

    return hres;
}

STDMETHODIMP CStreamWrap::Write(const void *pv, ULONG cb, ULONG *pcbWritten)
{
    if (pcbWritten)
        *pcbWritten = 0;
    return E_NOTIMPL;
}

// FEATURE: could at least support seaking to 0, as that's a common thing to do.
// REVIEW: not too hard to implement thoroughly - cache Stat calls on each
// substream (help implement ::Stat in this file too, which IMO is needed.)
STDMETHODIMP CStreamWrap::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
    return E_NOTIMPL;
}

STDMETHODIMP CStreamWrap::SetSize(ULARGE_INTEGER libNewSize)
{
    return E_NOTIMPL;
}

//
// REVIEW: this could use the internal buffer in the stream to avoid
// extra buffer copies.
//
STDMETHODIMP CStreamWrap::CopyTo(IStream *pstmTo, ULARGE_INTEGER cb,
             ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
{
    BYTE buf[512];
    ULONG cbRead;
    HRESULT hres = NOERROR;

    if (pcbRead)
    {
        pcbRead->LowPart = 0;
        pcbRead->HighPart = 0;
    }
    if (pcbWritten)
    {
        pcbWritten->LowPart = 0;
        pcbWritten->HighPart = 0;
    }

    ASSERT(cb.HighPart == 0);

    while (cb.LowPart)
    {
        hres = this->Read(buf, min(cb.LowPart, SIZEOF(buf)), &cbRead);

        if (FAILED(hres) || (cbRead == 0))
            break;

        if (pcbRead)
            pcbRead->LowPart += cbRead;

        cb.LowPart -= cbRead;

        hres = pstmTo->Write(buf, cbRead, &cbRead);

        if (pcbWritten)
            pcbWritten->LowPart += cbRead;

        if (FAILED(hres) || (cbRead == 0))
            break;
    }

    return hres;
}

STDMETHODIMP CStreamWrap::Commit(DWORD grfCommitFlags)
{
    return NOERROR;
}

STDMETHODIMP CStreamWrap::Revert()
{
    return E_NOTIMPL;
}

STDMETHODIMP CStreamWrap::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    return E_NOTIMPL;
}

STDMETHODIMP CStreamWrap::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    return E_NOTIMPL;
}

// FEATURE: you gotta support Stat, or Trident will barf on this stream.
//         Trivial to implement too, just call Stat on each sub-stream.
STDMETHODIMP CStreamWrap::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    return E_NOTIMPL;
}


// REVIEW: so simple to implement, it's probably worth doing
STDMETHODIMP CStreamWrap::Clone(IStream **ppstm)
{
    return E_NOTIMPL;
}

// in:
//      ppstm       array of stream pointers
//      cStreams    number of streams in the array
//

SHDOCAPI SHCreateStreamWrapperCP(IStream *aStreams[], UINT cStreams, DWORD grfMode, UINT uiCodePage, IStream **ppstm)
{
    HRESULT hres;

    *ppstm = NULL;

    if (grfMode != STGM_READ)
        return E_INVALIDARG;

    CStreamWrap *pwrap = new CStreamWrap();
    if (pwrap)
    {
        hres = pwrap->Init(aStreams, cStreams, uiCodePage);
        if (SUCCEEDED(hres))
            pwrap->QueryInterface(IID_IStream, (void **)ppstm);
        pwrap->Release();
    }
    else
        hres = E_OUTOFMEMORY;

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\tbext.cpp ===
////////////////////////////////////////////////////////////////////////////
// File:   TBExt.cpp   (toolbar extension classes)
// Author: Karim Farouki
//
// We define here three classes:
// (1) CToolbarExt a base class that takes care of the
//     button work for our custom extensions
// (2) CToolbarExtBand the object which deals with custom
//     buttons that plug into bands
// (3) CToolbarExtExec the object which deals with custom
//     buttons (or tools menu items) that exec stuff.
//
// The latter two are derived from the former 
#include "priv.h"
#include <mshtmcid.h>
#include "tbext.h"


//////////////////////////////
// Class CToolbarExt
//
// This is the base class from which CToolbarExtBand and CToolbarExtExec
// both inherit.  It takes care of all the ToolbarButton specific stuff
// like lazy loading the appropriate icons, and keeping track of the button
// text.

// Constructor / Destructor
//
CToolbarExt::CToolbarExt() : _cRef(1)
{ 
    ASSERT(_hIcon == NULL);
    ASSERT(_hIconSm == NULL);
    ASSERT(_hHotIcon == NULL);
    ASSERT(_hHotIconSm == NULL);
    ASSERT(_bstrButtonText == NULL);
    ASSERT(_bstrToolTip == NULL);
    ASSERT(_hkeyThisExtension == NULL);
    ASSERT(_hkeyCurrentLang == NULL);
    ASSERT(_pisb == NULL);
    
    DllAddRef();
}

// Destructor
//
CToolbarExt::~CToolbarExt() 
{ 
    if (_pisb)
        _pisb->Release();
    
    if (_bstrButtonText)
        SysFreeString(_bstrButtonText);

    if (_bstrToolTip)
        SysFreeString(_bstrToolTip);

    if (_hIcon)
        DestroyIcon(_hIcon);

    if (_hIconSm)
        DestroyIcon(_hIconSm);

    if (_hHotIcon)
        DestroyIcon(_hHotIcon);

    if (_hHotIconSm)
        DestroyIcon(_hHotIconSm);

    if (_hkeyThisExtension)
        RegCloseKey(_hkeyThisExtension);

    if (_hkeyCurrentLang)
        RegCloseKey(_hkeyCurrentLang);

    DllRelease();
}


// IUnknown implementation
//
STDMETHODIMP CToolbarExt::QueryInterface(const IID& iid, void** ppv)
{    
	if (iid == IID_IUnknown)
    	*ppv = static_cast<IBrowserExtension*>(this); 
	else if (iid == IID_IBrowserExtension)
		*ppv = static_cast<IBrowserExtension*>(this);
	else if (iid == IID_IOleCommandTarget)
        *ppv = static_cast<IOleCommandTarget*>(this);
    else if (iid == IID_IObjectWithSite)
        *ppv = static_cast<IObjectWithSite*>(this);
    else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG) CToolbarExt::AddRef()
{
	return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CToolbarExt::Release() 
{
	if (InterlockedDecrement(&_cRef) == 0)
	{
		delete this;
		return 0;
	}
	return _cRef;
}

// IBrowserExtension::Init Implementation.  We'll read the ButtonText here but wait on the icons until
// a specific variant of the icon is requested.
STDMETHODIMP CToolbarExt::Init(REFGUID rguid)
{
    HRESULT hr = S_OK;
    LPOLESTR pszGUID;

    if (SUCCEEDED(StringFromCLSID(rguid, &pszGUID)))
    {
        //Open the extension reg key associated with this guid
        WCHAR szKey[MAX_PATH];
        StrCpyN(szKey, TEXT("Software\\Microsoft\\Internet Explorer\\Extensions\\"), ARRAYSIZE(szKey));
        StrCatBuff(szKey, pszGUID, ARRAYSIZE(szKey));

        // We will keep _hkeyThisExtension around... it will be closed in the destructor!
        if (RegOpenKeyEx(HKEY_CURRENT_USER, szKey, 0, KEY_READ, &_hkeyThisExtension) == ERROR_SUCCESS ||
            RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, KEY_READ, &_hkeyThisExtension) == ERROR_SUCCESS)
        {
            // See if there is a subkey for the current language
            LANGID langid = MLGetUILanguage();
            WCHAR szBuff[MAX_PATH];
            wnsprintf(szBuff, ARRAYSIZE(szBuff), L"Lang%04x", langid);
            RegOpenKeyEx(_hkeyThisExtension, szBuff, 0, KEY_READ, &_hkeyCurrentLang);
            
            // Now get the button text
            _RegReadString(_hkeyThisExtension, TEXT("ButtonText"), &_bstrButtonText);
        }

        CoTaskMemFree(pszGUID);
    }

    if (!_bstrButtonText)
        hr = E_FAIL;

    return hr;
}

//
// Gets the icon closest to the desired size from an .ico file or from the 
// resource in a .dll of .exe file
//
HICON CToolbarExt::_ExtractIcon
(
    LPWSTR pszPath, // file to get icon from
    int resid,      // resource id (0 if unused)
    int cx,         // desired icon width
    int cy          // desired icon height
)
{
    HICON hIcon = NULL;

    WCHAR szPath[MAX_PATH];
    SHExpandEnvironmentStrings(pszPath, szPath, ARRAYSIZE(szPath));

    // If no resource id, assume it's an ico file
    if (resid == 0)
    {
        hIcon = (HICON)LoadImage(0, szPath, IMAGE_ICON, cx, cy, LR_LOADFROMFILE);
    }

    // Otherwise, see if it's a resouce
    if (hIcon == NULL)
    {
        HINSTANCE hInst = LoadLibraryEx(szPath, NULL, LOAD_LIBRARY_AS_DATAFILE);
        if (hInst)
        {
            hIcon = (HICON)LoadImage(hInst, MAKEINTRESOURCE(resid), IMAGE_ICON, cx, cy, LR_DEFAULTCOLOR);
            FreeLibrary(hInst);
        }
    }

    return hIcon;
}

//
// Returns the desired icon in pvarProperty
//
HRESULT CToolbarExt::_GetIcon
(
    LPCWSTR pszIcon,            // Name of icon value in registry
    int nWidth,                 // icon width
    int nHeight,                // icon height
    HICON& rhIcon,              // location to cached icon
    VARIANTARG * pvarProperty   // used for return icon
)
{
    HRESULT hr = S_OK;
    if (pvarProperty)
    {
        if (rhIcon == NULL)
        {
            BSTR bstrIconName;
            if (_RegReadString(_hkeyThisExtension, pszIcon, &bstrIconName, TRUE))
            {
                // Parse entry such as "file.ext,1" to get the icon index
                int nIconIndex = PathParseIconLocation(bstrIconName);

                // If the entry was ",#" then it's an index into our built-in button bitmap
                if (*bstrIconName == L'\0')
                {
                    pvarProperty->vt = VT_I4;
                    pvarProperty->lVal = nIconIndex;
                    SysFreeString(bstrIconName);
                    return hr;
                }
                else
                {
                    rhIcon = _ExtractIcon(bstrIconName, nIconIndex, nWidth, nHeight);
                }
                SysFreeString(bstrIconName);
            }
        }

        if (rhIcon)
        {
            pvarProperty->vt = VT_BYREF;
            pvarProperty->byref = rhIcon;
        }
        else
        {
            VariantInit(pvarProperty);
        }
    }
    return hr;
}

//
// Implementation of IBrowserExtension::GetProperty().  There are two important points here:
// (1) We are lazy loading the appropriate icons.  This way if the user never goes into small icon
//     mode we never create the images...
// (2) If we are called with a NULL pvarProperty then we must still return S_OK if the iPropID
//     is for a property that we support and E_NOTIMPL if we do not.  This is why the if (pvarProperty)
//     check is done for each case rather tan outside the case block.  This behavior is important
//     for CBrowserExtension::Update() who passes in a NULL pvarProperty but still is trying to determine
//     what kind of extension this is!
//
STDMETHODIMP CToolbarExt::GetProperty(SHORT iPropID, VARIANTARG * pvarProperty)
{
    HRESULT hr = S_OK;

    if (pvarProperty)
        VariantInit(pvarProperty); // in case of failure
    
    switch (iPropID)
    {
        case TBEX_BUTTONTEXT:
            if (pvarProperty)
            {
                pvarProperty->bstrVal = SysAllocString(_bstrButtonText);
                if (pvarProperty->bstrVal)
                {
                    pvarProperty->vt = VT_BSTR;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            break;

        case TBEX_GRAYICON:

            // For Whistler, we now use a 24 x 24 icons
            if (SHUseClassicToolbarGlyphs())
            {
                hr = _GetIcon(TEXT("Icon"), 20, 20, _hIcon, pvarProperty);
            }
            else
            {
                hr = _GetIcon(TEXT("Icon"), 24, 24, _hIcon, pvarProperty);
            }
            break;

        case TBEX_GRAYICONSM:
            hr = _GetIcon(TEXT("Icon"), 16, 16, _hIconSm, pvarProperty);
            break;

        case TBEX_HOTICON:
            // For Whistler, we now use a 24 x 24 icons
            if (SHUseClassicToolbarGlyphs())
            {
                hr = _GetIcon(TEXT("HotIcon"), 20, 20, _hHotIcon, pvarProperty);
            }
            else
            {
                hr = _GetIcon(TEXT("HotIcon"), 24, 24, _hHotIcon, pvarProperty);
            }
            break;

        case TBEX_HOTICONSM:
            hr = _GetIcon(TEXT("HotIcon"), 16, 16, _hHotIconSm, pvarProperty);
            break;

        case TBEX_DEFAULTVISIBLE:
            if (pvarProperty)
            {
                BOOL fVisible = _RegGetBoolValue(L"Default Visible", FALSE);
                pvarProperty->vt = VT_BOOL;
                pvarProperty->boolVal = fVisible ? VARIANT_TRUE : VARIANT_FALSE;
            }
            break;

        default:
            hr = E_NOTIMPL;
    }

    return hr;
}

//
// IOleCommandTarget Implementation
//
STDMETHODIMP CToolbarExt::QueryStatus(const GUID* pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT* pCmdText)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;
    if (pguidCmdGroup && IsEqualGUID(*pguidCmdGroup, CLSID_ToolbarExtButtons))
    {
        // Default to all commands enabled
        for (ULONG i = 0; i < cCmds; i++)
        {
//            if (prgCmds[i].cmdID == 1)
                // Execing this object is supported and can be done at this point
                rgCmds[i].cmdf = OLECMDF_ENABLED | OLECMDF_SUPPORTED;
//            else
//                prgCmds[i].cmdf = 0;
        }
        hr = S_OK;
    }

    // Return an empty pCmdText
    if (pCmdText != NULL)
    {
        pCmdText->cwActual = 0;
    }
    return hr;
}

//
// IObjectWithSite Implementation
//
STDMETHODIMP CToolbarExt::SetSite(IUnknown* pUnkSite)
{
    if (_pisb != NULL)
    {
        _pisb->Release();
        _pisb = NULL;
    }
    
    if (pUnkSite)
        pUnkSite->QueryInterface(IID_IShellBrowser, (void **)&_pisb);
        
    return S_OK;
}
   
STDMETHODIMP CToolbarExt::GetSite(REFIID riid, void ** ppvSite)
{
    return E_NOTIMPL;
}


BOOL CToolbarExt::_RegGetBoolValue
(
    LPCWSTR         pszPropName,
    BOOL            fDefault
)
{
    WCHAR szData[MAX_PATH];
    DWORD cbData = SIZEOF(szData);

    if ((_hkeyCurrentLang && RegQueryValueEx(_hkeyCurrentLang, pszPropName, NULL, NULL, (unsigned char *)szData, &cbData) == ERROR_SUCCESS) ||
        (_hkeyThisExtension && RegQueryValueEx(_hkeyThisExtension, pszPropName, NULL, NULL, (unsigned char *)szData, &cbData) == ERROR_SUCCESS))
    {
        if ((0 == StrCmpI(L"TRUE", szData)) || 
            (0 == StrCmpI(L"YES", szData)))
        {
            fDefault = TRUE;        // We read TRUE from the registry.
        }
        else if ((0 == StrCmpI(L"FALSE", szData)) || 
            (0 == StrCmpI(L"NO", szData)))
        {
            fDefault = FALSE;        // We read TRUE from the registry.
        }
    }

    return fDefault;
}



// Private Helper Functions
//
// shlwapi has some similar function; however, they all insist on reopening and closing the key in question
// with each read.  It is explicitly suggested that we use our own helper if we are caching the key...
BOOL CToolbarExt::_RegReadString
(
    HKEY hkeyThisExtension,
    LPCWSTR pszPropName,
    BSTR * pbstrProp,
    BOOL fExpand            // = FALSE, Expand Environment strings
    )
{
    WCHAR   szData[MAX_PATH];
    *pbstrProp = NULL;
    BOOL fSuccess = FALSE;
    
    // First try the optional location for localized content
    if (_hkeyCurrentLang)
    {
        if (SUCCEEDED(SHLoadRegUIString(_hkeyCurrentLang, pszPropName, szData, ARRAYSIZE(szData))))
        {
            fSuccess = TRUE;
        }
    }

    // Next try default location
    if (!fSuccess && _hkeyThisExtension)
    {
        if (SUCCEEDED(SHLoadRegUIString(hkeyThisExtension, pszPropName, szData, ARRAYSIZE(szData))))
        {
            fSuccess = TRUE;
        }
    }

    if (fSuccess)
    {
        LPWSTR psz = szData;
        WCHAR szExpand[MAX_PATH];
        if (fExpand)
        {
            SHExpandEnvironmentStrings(szData, szExpand, ARRAYSIZE(szExpand));
            psz = szExpand;
        }
        *pbstrProp = SysAllocString(psz);
    }
    return (NULL != *pbstrProp);
}


///////////////////////////////////////////////////////////
// Class CToolbarExtBand
//
// This class adds to the base functionality of CToolbarExt
// by storing the CLSID for a registered band, and displaying that
// band upon execution of IOleCommandTarget::Exec
//
//
STDAPI CToolbarExtBand_CreateInstance(
            IUnknown        * punkOuter,
            IUnknown        ** ppunk,
            LPCOBJECTINFO   poi
            )
{
    HRESULT hr = S_OK;

    *ppunk = NULL;

    CToolbarExtBand * lpTEB = new CToolbarExtBand();

    if (lpTEB == NULL)
        hr = E_OUTOFMEMORY;
    else
        *ppunk = SAFECAST(lpTEB, IBrowserExtension *);

    return hr;
}

// Constructor / Destructor
//
CToolbarExtBand::CToolbarExtBand()
{
    ASSERT(_cRef == 1);
    ASSERT(_bBandState == FALSE);
    ASSERT(_bstrBandCLSID == NULL);
}

// Destructor
//
CToolbarExtBand::~CToolbarExtBand() 
{ 
    if (_bstrBandCLSID)
        SysFreeString(_bstrBandCLSID);
}

// IBrowserExtension::Init()   We pass the majroity of the work on to the base class, then we load
// the BandCLSID and cache it.
STDMETHODIMP CToolbarExtBand::Init(REFGUID rguid)
{
    HRESULT hr = CToolbarExt::Init(rguid);
    
    _RegReadString(_hkeyThisExtension, TEXT("BandCLSID"), &_bstrBandCLSID);
    
    if (!(_bstrButtonText && _bstrBandCLSID))
        hr = E_FAIL;

    return hr;
}
    
STDMETHODIMP CToolbarExtBand::QueryStatus
(
    const GUID * pguidCmdGroup,
    ULONG  cCmds,
    OLECMD prgCmds[],
    OLECMDTEXT * pCmdText
    )
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;
    if (pguidCmdGroup && IsEqualGUID(*pguidCmdGroup, CLSID_ToolbarExtButtons))
    {
        VARIANT varClsid;
      
        // Default to all commands enabled
        for (ULONG i = 0; i < cCmds; i++)
        {
            varClsid.vt = VT_BSTR;
            varClsid.bstrVal = _bstrBandCLSID;
            prgCmds[i].cmdf = OLECMDF_ENABLED | OLECMDF_SUPPORTED;

            hr = IUnknown_Exec(_pisb, &CGID_ShellDocView, SHDVID_ISBROWSERBARVISIBLE, 0, &varClsid, NULL);
            if (S_OK == hr)
            {
                prgCmds[i].cmdf |= OLECMDF_LATCHED;
            }
        }
        hr = S_OK;
    }
    return hr;
}

// Take the pIShellBrowser (obtained from IObjectWithSite::SetSite()) and disply the band
STDMETHODIMP CToolbarExtBand::Exec( 
                const GUID              * pguidCmdGroup,
                DWORD                   nCmdID,
                DWORD                   nCmdexecopt,
                VARIANT                 * pvaIn,
                VARIANT                 * pvaOut
                )
{
    HRESULT hr = E_FAIL;
    
    if (_pisb)
    {
        VARIANT varClsid;
        varClsid.vt = VT_BSTR;
        varClsid.bstrVal = _bstrBandCLSID;
      
        _bBandState = !_bBandState;
        IUnknown_Exec(_pisb, &CGID_ShellDocView, SHDVID_SHOWBROWSERBAR, _bBandState, &varClsid, NULL);

        hr = S_OK;
    }
    
    return hr;
}


///////////////////////////////////////////////////////////////////////
// Class CToolbarExtExec
//
// Expands on the base class by adding support for tools menu plug-ins.
// An instance of this class can be a button OR a menu OR BOTH.  It also
// keeps track of a BSTR which it ShellExecutes in its IOleCommandTarget::Exec()
//
STDAPI CToolbarExtExec_CreateInstance(
            IUnknown        * punkOuter,
            IUnknown        ** ppunk,
            LPCOBJECTINFO   poi
            )
{
    HRESULT hr = S_OK;

    *ppunk = NULL;

    CToolbarExtExec * lpTEE = new CToolbarExtExec();

    if (lpTEE == NULL)
        hr = E_OUTOFMEMORY;
    else
        *ppunk = SAFECAST(lpTEE, IBrowserExtension *);

    return hr;
}

CToolbarExtExec::CToolbarExtExec()
{
    ASSERT(_cRef == 1);
    ASSERT(_bstrToolTip == NULL);
    ASSERT(_bstrExec == NULL);
    ASSERT(_bstrScript == NULL);
    ASSERT(_bstrMenuText == NULL);
    ASSERT(_bstrMenuCustomize == NULL);
    ASSERT(_bstrMenuStatusBar == NULL);
    ASSERT(_punkExt == NULL);
}

CToolbarExtExec::~CToolbarExtExec()
{
    if (_bstrToolTip)
        SysFreeString(_bstrToolTip);

    if (_bstrExec)
        SysFreeString(_bstrExec);

    if (_bstrScript)
        SysFreeString(_bstrScript);

    if (_bstrMenuText)
        SysFreeString(_bstrMenuText);

    if (_bstrMenuCustomize)
        SysFreeString(_bstrMenuCustomize);

    if (_bstrMenuStatusBar)
        SysFreeString(_bstrMenuStatusBar);

    if (_punkExt)
        _punkExt->Release();
}

// Pass on the work for the toolbar button intiaztion to the base class then determine the object
// type and initialize the menu information if necessary...
STDMETHODIMP CToolbarExtExec::Init(REFGUID rguid)
{
    HRESULT hr = CToolbarExt::Init(rguid);

    // If the baseclass initialization went OK, then we have a working button
    if (hr == S_OK)
        _bButton = TRUE;

    // Get app and/or script to execute (optional)
    _RegReadString(_hkeyThisExtension, TEXT("Exec"), &_bstrExec, TRUE);
    _RegReadString(_hkeyThisExtension, TEXT("Script"), &_bstrScript, TRUE);

        
    // See if we have a menu item
    if (_RegReadString(_hkeyThisExtension, TEXT("MenuText"), &_bstrMenuText))
    {
        _RegReadString(_hkeyThisExtension, TEXT("MenuCustomize"), &_bstrMenuCustomize);
        _RegReadString(_hkeyThisExtension, TEXT("MenuStatusBar"), &_bstrMenuStatusBar);
        _bMenuItem = TRUE;
    }

    if (_bMenuItem || _bButton)
    {
        hr = S_OK;
    }

    return hr;
}

// It we're a button try passing the work on to the base class, if that doesn't cut it we'll
// check the menu stuff...
STDMETHODIMP CToolbarExtExec::GetProperty(SHORT iPropID, VARIANTARG * pvarProperty)
{
    HRESULT     hr = S_OK;
    BOOL        fImple = FALSE;

    if (_bButton)
    {
        // If The generic button's getproperty returns S_OK then our job here is done
        if (CToolbarExt::GetProperty(iPropID, pvarProperty) == S_OK)
            fImple = TRUE;
    }

    if (_bMenuItem && !fImple)
    {
        fImple = TRUE;

        if (pvarProperty)
            VariantInit(pvarProperty);

        switch (iPropID)
        {
            case TMEX_CUSTOM_MENU:
            {
                if (pvarProperty)
                {
                    pvarProperty->bstrVal = SysAllocString(_bstrMenuCustomize);
                    if (pvarProperty->bstrVal)
                    {
                        pvarProperty->vt = VT_BSTR;
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
            break;

            case TMEX_MENUTEXT:
                if (pvarProperty)
                {
                    pvarProperty->bstrVal = SysAllocString(_bstrMenuText);
                    if (pvarProperty->bstrVal)
                    {
                        pvarProperty->vt = VT_BSTR;
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
                break;

            case TMEX_STATUSBARTEXT:
                if (pvarProperty)
                {
                    pvarProperty->bstrVal = SysAllocString(_bstrMenuStatusBar);
                    if (pvarProperty->bstrVal)
                    {
                        pvarProperty->vt = VT_BSTR;
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
                break;

            default:
                fImple = FALSE;
        }
    }

    if (!fImple)
        hr = E_NOTIMPL;

    return hr;
}

STDMETHODIMP CToolbarExtExec::SetSite(IUnknown* punkSite)
{
    // Give the external object our site
    IUnknown_SetSite(_punkExt, punkSite);
    
    // Call base class
    return CToolbarExt::SetSite(punkSite);
}

STDMETHODIMP CToolbarExtExec::QueryStatus(const GUID * pguidCmdGroup, ULONG  cCmds, OLECMD rgCmds[], OLECMDTEXT * pCmdText)
{
    HRESULT hr = S_OK;

    // Pass query to external object if it exists
    IOleCommandTarget* pCmd;
    if (_punkExt && SUCCEEDED(_punkExt->QueryInterface(IID_IOleCommandTarget, (LPVOID*)&pCmd)))
    {
        hr = pCmd->QueryStatus(pguidCmdGroup, cCmds, rgCmds, pCmdText);
        pCmd->Release();
    }
    else
    {
        // Let base class handle this
        hr = CToolbarExt::QueryStatus(pguidCmdGroup, cCmds, rgCmds, pCmdText);
    }

    return hr;
}

// Shell execute the _bstrExec 
STDMETHODIMP CToolbarExtExec::Exec(
                const GUID              * pguidCmdGroup,
                DWORD                   nCmdId,
                DWORD                   nCmdexecopt,
                VARIANT                 * pvaIn,
                VARIANT                 * pvaOut
                )
{
    HRESULT hr = S_OK;

    //
    // The first time this is called, we lazy instantiate an external object if
    // one is registered.. This object can JIT in components and provide a
    // command target.
    //
    if (!_bExecCalled)
    {
        // We only do this once
        _bExecCalled = TRUE;

        BSTR bstrExtCLSID;
        if (_RegReadString(_hkeyThisExtension, TEXT("clsidExtension"), &bstrExtCLSID))
        {
            // We have an extension clsid, so create the object.  This gives the object an oportunity
            // to jit in code when its button or menu is invoked.
            CLSID clsidExt;

            if (CLSIDFromString(bstrExtCLSID, &clsidExt) == S_OK)
            {
                if (SUCCEEDED(CoCreateInstance(clsidExt, NULL, CLSCTX_INPROC_SERVER,
                                     IID_IUnknown, (void **)&_punkExt)))
                {
                    // Give the object our site (optional)
                    IUnknown_SetSite(_punkExt, _pisb);
                }
            }
            SysFreeString(bstrExtCLSID);
        }
    }

    // Pass command to external object if it exists
    IOleCommandTarget* pCmd;
    if (_punkExt && SUCCEEDED(_punkExt->QueryInterface(IID_IOleCommandTarget, (LPVOID*)&pCmd)))
    {
        hr = pCmd->Exec(pguidCmdGroup, nCmdId, nCmdexecopt, pvaIn, pvaOut);
        pCmd->Release();
    }

    // Run a script if one was specified
    if(_bstrScript && _pisb)
    {
        IOleCommandTarget *poct = NULL;
        VARIANT varArg;
        varArg.vt = VT_BSTR;
        varArg.bstrVal = _bstrScript;
        hr = _pisb->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&poct);
        if (SUCCEEDED(hr))
        {
            // Tell MSHTML to execute the script
            hr = poct->Exec(&CGID_MSHTML, IDM_RUNURLSCRIPT, 0, &varArg, NULL);
            poct->Release();
        }
    }

    // Launch executable if one was specified
    if (_bstrExec)
    {
        SHELLEXECUTEINFO sei = { 0 };

        sei.cbSize = sizeof(sei);
        sei.lpFile = _bstrExec;
        sei.nShow = SW_SHOWNORMAL;

        // We are using ShellExecuteEx over ShellExecute because the Unicode version of ShellExecute
        // is bogus on 95/98
        if (ShellExecuteExW(&sei) == FALSE)
            hr = E_FAIL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\swindows.cpp ===
#include "priv.h"
#include "dspsprt.h"
#include "basesb.h"
#include "cnctnpt.h"
#include "stdenum.h"
#include "winlist.h"
#include <varutil.h>

#define WM_INVOKE_ON_RIGHT_THREAD   (WM_USER)

class CSDEnumWindows;

class WindowData
{
private:
    long m_cRef;

public:
    // Pidl variable is changed on the fly requiring reads/writes to be
    // protected by critical sections. Pid is also changed after creation but
    // only by _EnsurePid. So as long code calls _EnsurePid before reading Pid
    // no critical sections are required to read.
    
    LPITEMIDLIST pidl;
    IDispatch *pid;     // The IDispatch for the item
    long      lCookie;  // The cookie to make sure that the person releasing is the one that added it
    HWND      hwnd;     // The top hwnd, so we can
    DWORD     dwThreadId; // when it is in the pending box...
    BOOL      fActive:1;
    int       swClass;
    
    WindowData()
    {
        ASSERT(pid == NULL);
        ASSERT(hwnd == NULL);
        ASSERT(pidl == NULL);
        
        m_cRef = 1;
    }

    ~WindowData()
    {
        if (pid)
            pid->Release();
        ILFree(pidl); // null is OK
    }
    
    ULONG AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    ULONG Release()
    {
        if (InterlockedDecrement(&m_cRef))
            return m_cRef;

        delete this;
        return 0;
    }
};


class CSDWindows : public IShellWindows
                 , public IConnectionPointContainer
                 , protected CImpIDispatch
{
    friend CSDEnumWindows;

public:
    CSDWindows(void);

    BOOL Init(void);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IDispatch
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo)
        { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
        { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
        { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

    // IConnectionPointContainer
    STDMETHODIMP EnumConnectionPoints(LPENUMCONNECTIONPOINTS * ppEnum);
    STDMETHODIMP FindConnectionPoint(REFIID iid, IConnectionPoint ** ppCP);

    // IShellWindows
    STDMETHODIMP get_WindowPath (BSTR *pbs);
    STDMETHODIMP get_Count(long *plCount);
    STDMETHODIMP Item(VARIANT, IDispatch **ppid);
    STDMETHODIMP _NewEnum(IUnknown **ppunk);
    STDMETHODIMP Register(IDispatch *pid, long HWND, int swClass, long *plCookie);
    STDMETHODIMP RegisterPending(long lThreadId, VARIANT* pvarloc, VARIANT* pvarlocRoot, int swClass, long *plCookie);
    STDMETHODIMP Revoke(long lCookie);

    STDMETHODIMP OnNavigate(long lCookie, VARIANT* pvarLoc);
    STDMETHODIMP OnActivated(long lCookie, VARIANT_BOOL fActive);
    STDMETHODIMP FindWindowSW(VARIANT* varLoc, VARIANT* varlocRoot, int swClass, long * phwnd, int swfwOptions, IDispatch** ppdispAuto);
    STDMETHODIMP OnCreated(long lCookie, IUnknown *punk);
    STDMETHODIMP ProcessAttachDetach(VARIANT_BOOL fAttach);

private:
    ~CSDWindows(void);
    WindowData* _FindItem(long lCookie);
    WindowData* _FindAndRemovePendingItem(HWND hwnd, long lCookie);
    void _EnsurePid(WindowData *pwd);
    void _DoInvokeCookie(DISPID dispid, long lCookie, BOOL fCheckThread);
    HRESULT _Item(VARIANT index, IDispatch **ppid, BOOL fRemoveDeadwood);
    static LRESULT CALLBACK s_ThreadNotifyWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    int _NewCookie();
#ifdef DEBUG
    void _DBDumpList(void);
#endif

    LONG            m_cRef;
    LONG            m_cProcessAttach;
    HDPA            m_hdpa;             // DPA to hold information about each window
    HDPA            m_hdpaPending;      // DPA to hold information about pending windows.
    LONG            m_cTickCount;       // used to generate cookies
    HWND            m_hwndHack;
    DWORD           m_dwThreadID;
    // Embed our Connection Point object - implmentation in cnctnpt.cpp
    CConnectionPoint m_cpWindowsEvents;
};

#ifdef DEBUG // used by DBGetClassSymbolic
EXTERN_C const int SIZEOF_CSDWindows = SIZEOF(CSDWindows);
#endif

class CSDEnumWindows : public IEnumVARIANT
{
public:
    CSDEnumWindows(CSDWindows *psdw);

    // IUnknown
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumFORMATETC
    STDMETHODIMP Next(ULONG, VARIANT *, ULONG *);
    STDMETHODIMP Skip(ULONG);
    STDMETHODIMP Reset(void);
    STDMETHODIMP Clone(IEnumVARIANT **);

private:
    ~CSDEnumWindows();

    LONG        m_cRef;
    CSDWindows  *m_psdw;
    int         m_iCur;
};

STDAPI CSDWindows_CreateInstance(IShellWindows **ppsw)
{
    HRESULT hr = E_OUTOFMEMORY;   // assume failure...
    *ppsw = NULL;

    CSDWindows* psdf = new CSDWindows();
    if (psdf)
    {
        if (psdf->Init())
            hr = psdf->QueryInterface(IID_PPV_ARG(IShellWindows, ppsw));
        psdf->Release();
    }
    return hr;
}

CSDWindows::CSDWindows(void) :
    CImpIDispatch(LIBID_SHDocVw, 1, 1, IID_IShellWindows)
{
    DllAddRef();
    m_cRef = 1;
    ASSERT(m_hdpa == NULL);
    ASSERT(m_hdpaPending == NULL);
    ASSERT(m_cProcessAttach == 0);

    m_cpWindowsEvents.SetOwner((IUnknown*)SAFECAST(this, IShellWindows*), &DIID_DShellWindowsEvents);
}

int DPA_SWindowsFree(void *p, void *d)
{
    ((WindowData*)p)->Release();
    return 1;
}

CSDWindows::~CSDWindows(void)
{
    if (m_hdpa)
    {
        // We need to release the data associated with all of the items in the list
        // as well as release our usage of the interfaces...
        HDPA hdpa = m_hdpa;
        m_hdpa = NULL;

        DPA_DestroyCallback(hdpa, DPA_SWindowsFree, 0);
        hdpa = NULL;
    }
    if (m_hdpaPending)
    {
        // We need to release the data associated with all of the items in the list
        // as well as release our usage of the interfaces...
        HDPA hdpa = m_hdpaPending;
        m_hdpaPending = NULL;

        DPA_DestroyCallback(hdpa, DPA_SWindowsFree, 0);
        hdpa = NULL;
    }
    if (m_hwndHack)
        DestroyWindow(m_hwndHack);

    DllRelease();
}

BOOL CSDWindows::Init(void)
{
    m_hdpa = ::DPA_Create(0);
    m_hdpaPending = ::DPA_Create(0);
    m_dwThreadID = GetCurrentThreadId();
    m_hwndHack = SHCreateWorkerWindow(s_ThreadNotifyWndProc, NULL, 0, 0, (HMENU)0, this);

    if (!m_hdpa || !m_hdpaPending || !m_hwndHack)
        return FALSE;

    return TRUE;
}

STDMETHODIMP CSDWindows::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CSDWindows, IConnectionPointContainer), 
        QITABENT(CSDWindows, IShellWindows),
        QITABENTMULTI(CSDWindows, IDispatch, IShellWindows),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CSDWindows::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CSDWindows::Release(void)
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}


// IShellWindows implementation

STDMETHODIMP CSDWindows::get_Count(long *plCount)
{
#ifdef DEBUG
    if (*plCount == -1)
        _DBDumpList();
#endif

    *plCount = 0;

    ENTERCRITICAL;
    for (int i = DPA_GetPtrCount(m_hdpa) - 1; i >= 0; i--)
    {
        WindowData* pwd = (WindowData*)DPA_FastGetPtr(m_hdpa, i);
        if (pwd->hwnd)
            (*plCount)++;   // only count those with non NULL hwnd
    }
    LEAVECRITICAL;
    return S_OK;
}

#ifdef DEBUG
void CSDWindows::_DBDumpList(void)
{
    ENTERCRITICAL;
    for (int i = DPA_GetPtrCount(m_hdpa) - 1; i >= 0; i--)
    {
        TCHAR szClass[32];
        WindowData* pwd = (WindowData*)DPA_FastGetPtr(m_hdpa, i);

        szClass[0] = 0;
        if (IsWindow(pwd->hwnd))
            GetClassName(pwd->hwnd, szClass, ARRAYSIZE(szClass));

        TraceMsg(DM_TRACE, "csdw.dbdl: i=%d hwnd=%x (class=%s) cookie=%d tid=%d IDisp=%x pidl=%x fActive=%u swClass=%d", i,
            pwd->hwnd, szClass, pwd->lCookie, pwd->dwThreadId,
            pwd->pid, pwd->pidl, pwd->fActive, pwd->swClass);
    }
    LEAVECRITICAL;
}
#endif

/*
 * function to ensure that the pid is around and registered.
 * For delay registered guys, this involves calling back to the registered
 * window handle via a private message to tell it to give us a marshalled
 * IDispatch.
 *
 * Callers of _EnusrePid must have pwd addref'ed to ensure it will stay
 * alive.
 */

#define WAIT_TIME 20000 // 20 seconds

void CSDWindows::_EnsurePid(WindowData *pwd)
{
    IDispatch *pid = pwd->pid;
    if (!pid) 
    {
        ASSERT(pwd->hwnd);

#ifndef NO_MARSHALLING
        // we can not pass a stream between two processes, so we ask 
        // the other process to create a shared memory block with our
        // information in it such that we can then create a stream on it...

        // IDispatch from.  They will CoMarshalInterface their IDispatch
        // into the stream and return TRUE if successful.  We then
        // reset the stream pointer to the head and unmarshal the IDispatch
        // and store it in our list.
        DWORD       dwProcId = GetCurrentProcessId();
        DWORD_PTR   dwResult;

        // Use SendMessageTimeoutA since SendMessageTimeoutW doesn't work on w95.
        if (SendMessageTimeoutA(pwd->hwnd, WMC_MARSHALIDISPATCHSLOW, 0, 
                (LPARAM)dwProcId, SMTO_ABORTIFHUNG, WAIT_TIME, &dwResult) && dwResult)
        {
            // There should be an easier way to get this but for now...
            DWORD cb;
            LPBYTE pv = (LPBYTE)SHLockShared((HANDLE)dwResult, dwProcId);
            
            // Don't know for sure a good way to get the size so assume that first DWORD
            // is size of rest of the area
            if (pv && ((cb = *((DWORD*)pv)) > 0))
            {
                IStream *pIStream;
                if (SUCCEEDED(CreateStreamOnHGlobal(NULL, TRUE, &pIStream))) 
                {
                    const LARGE_INTEGER li = {0, 0};
    
                    pIStream->Write(pv + sizeof(DWORD), cb, NULL);
                    pIStream->Seek(li, STREAM_SEEK_SET, NULL);
                    CoUnmarshalInterface(pIStream, IID_PPV_ARG(IDispatch, &pid));
                    pIStream->Release();
                }
            }
            SHUnlockShared(pv);
            SHFreeShared((HANDLE)dwResult, dwProcId);
        }
#else
        // UNIX IE has no marshalling capability YET 
        SendMessage(pwd->hwnd, WMC_MARSHALIDISPATCHSLOW, 0, (LPARAM)&(pid));
        // Since we don't use CoMarshal... stuff here we need to increment the
        // reference count.
        pid->AddRef();
#endif
        if (pid)
        {
            pid->AddRef();

            ENTERCRITICAL;
        
            // make sure a race on this did not already set pwd->pid
            if (NULL == pwd->pid)
                pwd->pid = pid;
        
            LEAVECRITICAL;

            pid->Release();
        }
    }
}

typedef struct
{
    WindowData * pwd;
    HDPA hdpaWindowList;
    int swClass;
} TMW;

BOOL CALLBACK CSDEnumWindowsProc(HWND hwnd, LPARAM lParam)
{
    TMW *ptwm = (TMW *) lParam;
    BOOL fFound = FALSE;

    // We walk a global hdpa window list, so we better be in a critical section.
    ASSERTCRITICAL;
    
    ASSERT(ptwm && ptwm->hdpaWindowList);
    ptwm->pwd = NULL;
    
    for (int i = DPA_GetPtrCount(ptwm->hdpaWindowList) - 1; (i >= 0) && !fFound; i--)
    {
        WindowData *pwd = (WindowData*)DPA_FastGetPtr(ptwm->hdpaWindowList, i);
        if (pwd->hwnd == hwnd && (ptwm->swClass == -1 || ptwm->swClass == pwd->swClass))
        {
            ptwm->pwd = pwd;
            pwd->AddRef();
            fFound = TRUE;
            break;
        }
    }
    return !fFound;
}

void CSDGetTopMostWindow(TMW* ptmw)
{
    EnumWindows(CSDEnumWindowsProc, (LPARAM)ptmw);
}


// Just like Item, except caller can specify if error is returned vs window deleted when
// window is in enumeration list but can't get idispatch.   This permits ::Next
// operator to skip bad windows, but still return valid ones.

HRESULT CSDWindows::_Item(VARIANT index, IDispatch **ppid, BOOL fRemoveDeadwood)
{
    TMW tmw;
    tmw.pwd = NULL;
    tmw.hdpaWindowList = m_hdpa;
    tmw.swClass = -1;

    *ppid = NULL;

    // This is sortof gross, but if we are passed a pointer to another variant, simply
    // update our copy here...
    if (index.vt == (VT_BYREF|VT_VARIANT) && index.pvarVal)
        index = *index.pvarVal;

    ASSERT(!(fRemoveDeadwood && index.vt != VT_I2 && index.vt != VT_I4));

Retry:

    switch (index.vt)
    {
    case VT_UI4:
        tmw.swClass = index.ulVal;
        // fall through
        
    case VT_ERROR:
        {
            HWND hwnd = GetActiveWindow();
            if (!hwnd)
                hwnd = GetForegroundWindow();

            if (hwnd)
            {
                ENTERCRITICAL;

                if (!CSDEnumWindowsProc(hwnd, (LPARAM)&tmw)) 
                {
                    ASSERT(tmw.pwd);
                }

                LEAVECRITICAL;
            }
            if (!tmw.pwd)
            {
                ENTERCRITICAL;
                CSDGetTopMostWindow(&tmw);
                LEAVECRITICAL;
            }
        }
        break;

    case VT_I2:
        index.lVal = (long)index.iVal;
        // And fall through...

    case VT_I4:
        if ((index.lVal >= 0))
        {
            ENTERCRITICAL;
            tmw.pwd = (WindowData*)DPA_GetPtr(m_hdpa, index.lVal);
            if (tmw.pwd)
                tmw.pwd->AddRef();
            LEAVECRITICAL;
        }
        break;

    default:
        return E_INVALIDARG;
    }

    if (tmw.pwd) 
    {
        _EnsurePid(tmw.pwd);
        
        *ppid = tmw.pwd->pid;
        if (tmw.pwd->hwnd && !IsWindow(tmw.pwd->hwnd))
        {
            *ppid = NULL;
        }
        
        if (*ppid)
        {
            (*ppid)->AddRef();
            tmw.pwd->Release();
            tmw.pwd = NULL;
            return S_OK;
        }
        else if (fRemoveDeadwood)
        {
            // In case the window was blown away in a fault we should try to recover...
            // We can only do this if caller is expecting to have item deleted out from
            // under it (see CSDEnumWindows::Next, below)
            Revoke(tmw.pwd->lCookie);
            tmw.swClass = -1;
            tmw.pwd->Release();
            tmw.pwd = NULL;
            goto Retry;
        }
        else
        {
            tmw.pwd->Release();
            tmw.pwd = NULL;
        }
    }

    return S_FALSE;   // Not a strong error, but a null pointer type of error
}

/*
 * This is essentially an array lookup operator for the collection.
 * Collection.Item by itself the same as the collection itself.
 * Otherwise you can refer to the item by index or by path, which
 * shows up in the VARIANT parameter.  We have to check the type
 * of the variant to see if it's VT_I4 (an index) or VT_BSTR (a
 * path) and do the right thing.
 */

STDMETHODIMP CSDWindows::Item(VARIANT index, IDispatch **ppid)
{
    return _Item(index, ppid, FALSE);
}

STDMETHODIMP CSDWindows::_NewEnum(IUnknown **ppunk)
{
    *ppunk = new CSDEnumWindows(this);
    return *ppunk ? S_OK : E_OUTOFMEMORY;
}

// IConnectionPointContainer

STDMETHODIMP CSDWindows::FindConnectionPoint(REFIID iid, IConnectionPoint **ppCP)
{
    if (IsEqualIID(iid, DIID_DShellWindowsEvents) ||
        IsEqualIID(iid, IID_IDispatch))
    {
        *ppCP = m_cpWindowsEvents.CastToIConnectionPoint();
    }
    else
    {
        *ppCP = NULL;
        return E_NOINTERFACE;
    }

    (*ppCP)->AddRef();
    return S_OK;
}



STDMETHODIMP CSDWindows::EnumConnectionPoints(LPENUMCONNECTIONPOINTS * ppEnum)
{
    return CreateInstance_IEnumConnectionPoints(ppEnum, 1, m_cpWindowsEvents.CastToIConnectionPoint());
}

void CSDWindows::_DoInvokeCookie(DISPID dispid, long lCookie, BOOL fCheckThread)
{
    // if we don't have any sinks, then there's nothing to do.  we intentionally
    // ignore errors here.  Note: if we add more notification types we may want to
    // have this function call the equivelent code as is in iedisp code for DoInvokeParam.
    //
    if (m_cpWindowsEvents.IsEmpty())
        return;

    if (fCheckThread && (m_dwThreadID != GetCurrentThreadId()))
    {
        PostMessage(m_hwndHack, WM_INVOKE_ON_RIGHT_THREAD, (WPARAM)dispid, (LPARAM)lCookie);
        return;
    }

    VARIANTARG VarArgList[1] = {0};
    DISPPARAMS dispparams = {0};

    // fill out DISPPARAMS structure
    dispparams.rgvarg = VarArgList;
    dispparams.cArgs = 1;

    VarArgList[0].vt = VT_I4;
    VarArgList[0].lVal = lCookie;

    IConnectionPoint_SimpleInvoke(&m_cpWindowsEvents, dispid, &dispparams);
}

// Guarantee a non-zero cookie, since 0 is used as a NULL value in
// various places (eg shbrowse.cpp)
int CSDWindows::_NewCookie()
{
    m_cTickCount++;
    if (0 == m_cTickCount)
        m_cTickCount++;
    return m_cTickCount;
}

STDMETHODIMP CSDWindows::Register(IDispatch *pid, long hwnd, int swClass, long *plCookie)
{
    if (!plCookie || (hwnd == NULL && swClass != SWC_CALLBACK) || (swClass == SWC_CALLBACK && pid == NULL))
        return E_POINTER;

    BOOL fAllocatedNewItem = FALSE;

    // If the pid isn't specified now (delay register), we'll call back later to
    // get it if we need it.
    if (pid)
        pid->AddRef();

    // We need to be carefull as to not leave a window of opertunity between removing the item from
    // the pending list till it is on the main list or some other thread could open a different window
    // up... Also guard m_hdpa
    // To avoid deadlocks, do not add any callouts to the code below!
    ENTERCRITICAL; 

    // First see if we have
    WindowData *pwd = _FindAndRemovePendingItem(IntToPtr_(HWND, hwnd), 0);
    if (!pwd)
    {
        pwd = new WindowData();
        if (!pwd)
        {
            LEAVECRITICAL;
            
            if (pid)
                pid->Release();
            return E_OUTOFMEMORY;
        }

        pwd->lCookie = _NewCookie();
    }

    pwd->pid = pid;
    pwd->swClass = swClass;
    pwd->hwnd = IntToPtr_(HWND, hwnd);

    if (plCookie)
        *plCookie = pwd->lCookie;

    // Give our refcount to the DPA
    DPA_AppendPtr(m_hdpa, pwd);

    LEAVECRITICAL;
    
    // We should now notify anyone waiting that there is a window registered...
    _DoInvokeCookie(DISPID_WINDOWREGISTERED, pwd->lCookie, TRUE);

    return S_OK;
}

STDMETHODIMP CSDWindows::RegisterPending(long lThreadId, VARIANT* pvarloc, VARIANT* pvarlocRoot, int swClass, long *plCookie)
{
    if (plCookie)
        *plCookie = 0;

    HRESULT hr = E_OUTOFMEMORY;
    WindowData *pwd = new WindowData();
    if (pwd)
    {
        // pwd is not in any DPA at this point so it is safe to change
        // variables outside of critical section
        pwd->swClass = swClass;
        pwd->dwThreadId = (DWORD)lThreadId;
        pwd->pidl = VariantToIDList(pvarloc);
        if (pwd->pidl)
        {
            ASSERT(!pvarlocRoot || pvarlocRoot->vt == VT_EMPTY);

            ENTERCRITICAL; // guards m_hdpa access

            pwd->lCookie = _NewCookie();
            if (plCookie)
                *plCookie = pwd->lCookie;

            // Give our refcount to the DPA
            DPA_AppendPtr(m_hdpaPending, pwd);

            LEAVECRITICAL;

            hr = S_OK;     // success
        }
        else
            pwd->Release();
    }
    return hr;
}

WindowData* CSDWindows::_FindItem(long lCookie)
{
    WindowData * pResult = NULL;

    ENTERCRITICAL;
    
    for (int i = DPA_GetPtrCount(m_hdpa) - 1; i >= 0; i--)
    {
        WindowData* pwd = (WindowData*)DPA_FastGetPtr(m_hdpa, i);
        if (pwd->lCookie == lCookie)
        {
            pResult = pwd;
            pResult->AddRef();
        }
    }
    
    LEAVECRITICAL;

    return pResult;
}

WindowData* CSDWindows::_FindAndRemovePendingItem(HWND hwnd, long lCookie)
{
    WindowData* pwdRet = NULL; // assume error
    DWORD dwThreadId = hwnd ? GetWindowThreadProcessId(hwnd, NULL) : 0;

    ENTERCRITICAL;
    
    for (int i = DPA_GetPtrCount(m_hdpaPending) - 1;i >= 0; i--)
    {
        WindowData* pwd = (WindowData*)DPA_FastGetPtr(m_hdpaPending, i);
        if ((pwd->dwThreadId == dwThreadId)  || (pwd->lCookie == lCookie))
        {
            pwdRet = pwd;
            DPA_DeletePtr(m_hdpaPending, i);
            break;
        }
    }
    
    // Since we are both removing the WindowData from the pending array (Release)
    // and returning it (AddRef) we can just leave its refcount alone. The
    // caller should release it when they are done with it.
    
    LEAVECRITICAL;
    
    return pwdRet;
}

STDMETHODIMP CSDWindows::Revoke(long lCookie)
{
    WindowData *pwd = NULL;
    HRESULT hr = S_FALSE;

    ENTERCRITICAL; // guards m_hdpa
    
    for (int i = DPA_GetPtrCount(m_hdpa) - 1; i >= 0; i--)
    {
        pwd = (WindowData*)DPA_FastGetPtr(m_hdpa, i);
        if (pwd->lCookie == lCookie)
        {
            // Remove it from the list while in semaphore...
            // Since we are deleting the WindowData from the array we should not
            // addref it. We are taking the refcount from the array.
            DPA_DeletePtr(m_hdpa, i);
            break;
        }
    }
    
    LEAVECRITICAL;

    if ((i >= 0) || (pwd = _FindAndRemovePendingItem(NULL, lCookie)))
    {
        // event for window going away
        _DoInvokeCookie(DISPID_WINDOWREVOKED, pwd->lCookie, TRUE);
        pwd->Release();
        hr = S_OK;
    }

    return hr;
}

STDMETHODIMP CSDWindows::OnNavigate(long lCookie, VARIANT* pvarLoc)
{
    HRESULT hr;
    WindowData* pwd = _FindItem(lCookie);
    if (pwd)
    {
        // NOTE: this is where we mess with the pidl inside of a WindowData struct.
        // this is why we need to protect all access to pwd->pidl with a critsec
        
        ENTERCRITICAL;

        ILFree(pwd->pidl);
        pwd->pidl = VariantToIDList(pvarLoc);
        hr = pwd->pidl ? S_OK : E_OUTOFMEMORY;

        LEAVECRITICAL;

        pwd->Release();
    }
    else
        hr = E_INVALIDARG;
    return hr;
}

STDMETHODIMP CSDWindows::OnActivated(long lCookie, VARIANT_BOOL fActive)
{
    WindowData* pwd = _FindItem(lCookie);
    if (pwd) 
    {
        pwd->fActive = (BOOL)fActive;
        pwd->Release();
    }
    return pwd ? S_OK : E_INVALIDARG;
}

STDMETHODIMP CSDWindows::OnCreated(long lCookie, IUnknown *punk)
{
    HRESULT hr = E_FAIL;
    WindowData* pwd = _FindItem(lCookie);
    if (pwd)
    {
        _EnsurePid(pwd);
        ITargetNotify *ptgn;
        if (pwd->pid && SUCCEEDED(pwd->pid->QueryInterface(IID_PPV_ARG(ITargetNotify, &ptgn))))
        {
            hr = ptgn->OnCreate(punk, lCookie);
            ptgn->Release();
        }
        
        pwd->Release();
    }
    return hr;
}

void _FreeWindowDataAndPidl(WindowData **ppwd, LPITEMIDLIST *ppidl)
{
    if (*ppidl)
    {
        ILFree(*ppidl);
        *ppidl = NULL;
    }

    if (*ppwd)
    {
        (*ppwd)->Release();
        *ppwd = NULL;
    }
}

BOOL _GetWindowDataAndPidl(HDPA hdpa, int i, WindowData **ppwd, LPITEMIDLIST *ppidl)
{
    _FreeWindowDataAndPidl(ppwd, ppidl);

    ENTERCRITICAL;

    *ppwd = (WindowData*)DPA_GetPtr(hdpa, i);
    if (*ppwd)
    {
        (*ppwd)->AddRef();

        // NOTE: pwd->pidl can change out from under us when we are outside of 
        // the critsec so we must clone it so we can play with it when we don't
        // hold the critsec

        *ppidl = ILClone((*ppwd)->pidl);
    }

    LEAVECRITICAL;

    return *ppwd ? TRUE : FALSE;
}

STDMETHODIMP CSDWindows::FindWindowSW(VARIANT* pvarLoc, VARIANT* pvarLocRoot, int swClass, 
                                      long *phwnd, int swfwOptions, IDispatch** ppdispOut)
{
    HRESULT hr = S_FALSE;   // success, but none found
    int i;

    LPITEMIDLIST pidlFree = VariantToIDList(pvarLoc);
    LPCITEMIDLIST pidl = pidlFree ? pidlFree : &s_idlNULL;

    ASSERT(!pvarLocRoot || pvarLocRoot->vt == VT_EMPTY);

    long lCookie = 0;

    if (pvarLoc && (swfwOptions & SWFO_COOKIEPASSED))
    {
        if (pvarLoc->vt == VT_I4)
            lCookie = pvarLoc->lVal;
        else if (pvarLoc->vt == VT_I2)
            lCookie = (LONG)pvarLoc->iVal;
    }

    if (ppdispOut)
        *ppdispOut = NULL;

    if (phwnd)
        *phwnd = NULL;

    if (swfwOptions & SWFO_NEEDDISPATCH)
    {
        if (!ppdispOut)
        {
            ILFree(pidlFree);
            return E_POINTER;
        }
    }

    WindowData* pwd = NULL;
    LPITEMIDLIST pidlCur = NULL;

    // If no PIDL we will assume an Empty idl...
    if (swfwOptions & SWFO_INCLUDEPENDING)
    {
        for (i = 0; _GetWindowDataAndPidl(m_hdpaPending, i, &pwd, &pidlCur); i++)
        {
            if ((pwd->swClass == swClass) &&
                (!lCookie || (lCookie == pwd->lCookie)) &&
                ILIsEqual(pidlCur, pidl))
            {
                if (phwnd)
                    *phwnd = pwd->lCookie;   // Something for them to use...

                _FreeWindowDataAndPidl(&pwd, &pidlCur);
                // found a pending window, return E_PENDING to say that the open is currently pending
                hr = E_PENDING;
                break;
            }

            _FreeWindowDataAndPidl(&pwd, &pidlCur);
        }
    }

    if (S_FALSE == hr)
    {
        for (i = 0; _GetWindowDataAndPidl(m_hdpa, i, &pwd, &pidlCur); i++)
        {
            if ((pwd->swClass == swClass) &&
                (!lCookie || (lCookie == pwd->lCookie)) &&
                (pidlCur && ILIsEqual(pidlCur, pidl)))
            {
                if (swfwOptions & SWFO_NEEDDISPATCH)
                    _EnsurePid(pwd);

                if (phwnd)
                {
                    // test the found window to see if it is valid, if not
                    // blow it away and start over
                    if (pwd->hwnd && !IsWindow(pwd->hwnd))
                    {
                        Revoke(pwd->lCookie);
                        i = 0;      // start over in this case
            
                        _FreeWindowDataAndPidl(&pwd, &pidlCur);
                        continue;
                    }
                    *phwnd = PtrToLong(pwd->hwnd); // windows handles 32b
                    hr = S_OK;  // terminate the loop
                }

                if (swfwOptions & SWFO_NEEDDISPATCH)
                {
                    hr = pwd->pid ? pwd->pid->QueryInterface(IID_PPV_ARG(IDispatch, ppdispOut)) : E_NOINTERFACE;
                }
                _FreeWindowDataAndPidl(&pwd, &pidlCur);
                break;
            }
            _FreeWindowDataAndPidl(&pwd, &pidlCur);
        }
    }

    ILFree(pidlFree);
    return hr;
}

HRESULT CSDWindows::ProcessAttachDetach(VARIANT_BOOL fAttach)
{
    if (fAttach)
        InterlockedIncrement(&m_cProcessAttach);
    else if (0 == InterlockedDecrement(&m_cProcessAttach))
    {
        // last process ref, we can now blow away the object in the shell context...
        if (g_dwWinListCFRegister) 
        {
#ifdef DEBUG
            long cwindow;
            get_Count(&cwindow);
            //ASSERT(cwindow==0);
            if (cwindow != 0)
                TraceMsg(DM_ERROR, "csdw.pad: cwindow=%d (!=0)", cwindow);
#endif
            CoRevokeClassObject(g_dwWinListCFRegister);
            g_dwWinListCFRegister = 0;
        }
    }
    return S_OK;
}

CSDEnumWindows::CSDEnumWindows(CSDWindows *psdw)
{
    DllAddRef();
    m_cRef = 1;
    m_psdw = psdw;
    m_psdw->AddRef();
    m_iCur = 0;
}

CSDEnumWindows::~CSDEnumWindows(void)
{
    DllRelease();
    m_psdw->Release();
}

STDMETHODIMP CSDEnumWindows::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CSDEnumWindows, IEnumVARIANT),    // IID_IEnumVARIANT
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CSDEnumWindows::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CSDEnumWindows::Release(void)
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}

STDMETHODIMP CSDEnumWindows::Next(ULONG cVar, VARIANT *pVar, ULONG *pulVar)
{
    ULONG       cReturn = 0;
    HRESULT     hr;

    if (!pulVar)
    {
        if (cVar != 1)
            return E_POINTER;
    }
    else
        *pulVar = 0;

    VARIANT index;
    index.vt = VT_I4;

    while (cVar > 0)
    {
        IDispatch *pid;

        index.lVal = m_iCur++;
        
        hr = m_psdw->_Item(index, &pid, TRUE);            
        if (S_OK != hr)
            break;

        pVar->pdispVal = pid;
        pVar->vt = VT_DISPATCH;
        pVar++;
        cReturn++;
        cVar--;
    }

    if (NULL != pulVar)
        *pulVar = cReturn;

    return cReturn ? S_OK : S_FALSE;
}

STDMETHODIMP CSDEnumWindows::Skip(ULONG cSkip)
{
    long cItems;
    m_psdw->get_Count(&cItems);

    if ((int)(m_iCur + cSkip) >= cItems)
        return S_FALSE;

    m_iCur += cSkip;
    return S_OK;
}

STDMETHODIMP CSDEnumWindows::Reset(void)
{
    m_iCur = 0;
    return S_OK;
}

STDMETHODIMP CSDEnumWindows::Clone(LPENUMVARIANT *ppEnum)
{
    CSDEnumWindows *pNew = new CSDEnumWindows(m_psdw);
    if (pNew)
    {
        *ppEnum = SAFECAST(pNew, IEnumVARIANT *);
        return S_OK;
    }

    *ppEnum = NULL;
    return E_OUTOFMEMORY;
}

LRESULT CALLBACK CSDWindows::s_ThreadNotifyWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CSDWindows* pThis = (CSDWindows*)GetWindowPtr0(hwnd);
    LRESULT lRes = 0;
    
    if (uMsg < WM_USER)
        return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
    else    
    {
        switch (uMsg) 
        {
        case WM_INVOKE_ON_RIGHT_THREAD:
            pThis->_DoInvokeCookie((DISPID)wParam, (LONG)lParam, FALSE);
            break;
        }
    }
    return lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\tasklist.cpp ===
#include "priv.h"
#include "resource.h"
#include <trayp.h>

class TaskbarList : public ITaskbarList2
{
public:
    TaskbarList();

    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ITaskbarList Methods
    STDMETHODIMP HrInit(void);
    STDMETHODIMP AddTab(HWND hwnd);
    STDMETHODIMP DeleteTab(HWND hwnd);
    STDMETHODIMP ActivateTab(HWND hwnd);
    STDMETHODIMP SetActiveAlt(HWND hwnd);

    // ITaskbarList2 Methods
    STDMETHODIMP MarkFullscreenWindow(HWND hwnd, BOOL fFullscreen);

protected:
    ~TaskbarList();
    HWND _HwndGetTaskbarList(void);

    UINT        _cRef;
    HWND        _hwndTaskbarList;
    int         _wm_shellhook;
};


//////////////////////////////////////////////////////////////////////////////
//
// TaskbarList Object
//
//////////////////////////////////////////////////////////////////////////////

STDAPI TaskbarList_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory
    
    TaskbarList *pTL = new TaskbarList();
    if (pTL)
    {
        *ppunk = SAFECAST(pTL, IUnknown *);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}


TaskbarList::TaskbarList() 
{
    _cRef = 1;
    _hwndTaskbarList = NULL;
    _wm_shellhook = RegisterWindowMessage(TEXT("SHELLHOOK"));
    DllAddRef();
}       


TaskbarList::~TaskbarList()
{
    ASSERT(_cRef == 0);                 // should always have zero

    DllRelease();
}    

HWND TaskbarList::_HwndGetTaskbarList(void)
{
    if (_hwndTaskbarList && IsWindow(_hwndTaskbarList))
        return _hwndTaskbarList;

    _hwndTaskbarList = FindWindow(TEXT("Shell_TrayWnd"), NULL);
    if (_hwndTaskbarList)
        _hwndTaskbarList = (HWND)SendMessage(_hwndTaskbarList, WMTRAY_QUERY_VIEW, 0, 0);
    
    return _hwndTaskbarList;
}


//////////////////////////////////
//
// IUnknown Methods...
//
HRESULT TaskbarList::QueryInterface(REFIID iid, void **ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(TaskbarList, ITaskbarList),
        QITABENT(TaskbarList, ITaskbarList2),
        { 0 },
    };

    return QISearch(this, qit, iid, ppv);
}

ULONG TaskbarList::AddRef()
{
    return ++_cRef;
}

ULONG TaskbarList::Release()
{
    if (--_cRef)
        return _cRef;

    delete this;
    return 0;   
}


//////////////////////////////////
//
// ITaskbarList Methods...
//
HRESULT TaskbarList::HrInit(void)
{
    HWND hwndTL = _HwndGetTaskbarList();

    if (hwndTL == NULL)
        return E_NOTIMPL;

    return S_OK;
}

HRESULT TaskbarList::AddTab(HWND hwnd)
{
    HWND hwndTL = _HwndGetTaskbarList();

    if (hwndTL)
        SendMessage(hwndTL, _wm_shellhook, HSHELL_WINDOWCREATED, (LPARAM) hwnd);

    return S_OK;
}

HRESULT TaskbarList::DeleteTab(HWND hwnd)
{
    HWND hwndTL = _HwndGetTaskbarList();

    if (hwndTL)
        SendMessage(hwndTL, _wm_shellhook, HSHELL_WINDOWDESTROYED, (LPARAM) hwnd);

    return S_OK;
}

HRESULT TaskbarList::ActivateTab(HWND hwnd)
{
    HWND hwndTL = _HwndGetTaskbarList();

    if (hwndTL)
    {
        SendMessage(hwndTL, _wm_shellhook, HSHELL_WINDOWACTIVATED, (LPARAM) hwnd);
        SendMessage(hwndTL, TBC_SETACTIVEALT , 0, (LPARAM) hwnd);
    }
    return S_OK;
}


HRESULT TaskbarList::SetActiveAlt(HWND hwnd)
{
    HWND hwndTL = _HwndGetTaskbarList();

    if (hwndTL)
        SendMessage(hwndTL, TBC_SETACTIVEALT , 0, (LPARAM) hwnd);

    return S_OK;
}

HRESULT TaskbarList::MarkFullscreenWindow(HWND hwnd, BOOL fFullscreen)
{
    if (GetUIVersion() >= 6)
    {
        HWND hwndTL = _HwndGetTaskbarList();

        if (hwndTL)
            SendMessage(hwndTL, TBC_MARKFULLSCREEN, (WPARAM) fFullscreen, (LPARAM) hwnd);

        return S_OK;
    }

    return E_FAIL;   // ITaskbarList2 not supported downlevel
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\tframe.cpp ===
#include "priv.h"
#include <varutil.h>
#include "hlframe.h"
#include "winlist.h"
#include "resource.h" //CLSID_SearchBand
#include "interned.h" // IHTMLPrivateWindow

// Locally defined FINDFRAME flag used to guarantee ITargetFrame vs ITargetFrame2 compatibility

#define FINDFRAME_OLDINTERFACE FINDFRAME_INTERNAL


STDAPI SafeGetItemObject(LPSHELLVIEW psv, UINT uItem, REFIID riid, LPVOID *ppv);
HRESULT TargetQueryService(LPUNKNOWN punk, REFIID riid, void **ppvObj);
HRESULT CoCreateNewIEWindow( DWORD dwClsContext, REFIID riid, void **ppvunk );

/******************************************************************

    NAME:       SetOleStrMember

    SYNOPSIS:   sets a new value for OleStr member
******************************************************************/
HRESULT SetOleStrMember(WCHAR **ppszMember, LPCOLESTR pszNewValue)
{
    HRESULT hr;

    if (*ppszMember)
    {
        LocalFree(*ppszMember);
        *ppszMember = NULL;
    }

    if (pszNewValue)
    {
        *ppszMember = StrDupW(pszNewValue);
        hr = *ppszMember ? S_OK : E_OUTOFMEMORY;
    }
    else
    {
        *ppszMember = NULL;
        hr = S_OK;
    }
    return hr;
}

/******************************************************************

    NAME:       GetOleStrMember

    SYNOPSIS:   gets a value for OleStr member as new CoTaskMemAlloc
    LPOLESTR
******************************************************************/
HRESULT GetOleStrMember(LPCOLESTR pszMember, WCHAR **ppszReturnValue)
{
    HRESULT hr;

    if (pszMember)
        hr = SHStrDupW(pszMember, ppszReturnValue);
    else
    {
        hr = S_OK;
        *ppszReturnValue = NULL;
    }
    return hr;
}

/*******************************************************************

    NAME:       CIEFrameAuto::SetFrameName

    SYNOPSIS:   Sets the Frame Name.  Frees current one if exists.

********************************************************************/

STDMETHODIMP CIEFrameAuto::SetFrameName(LPCOLESTR pszFrameName)
{
    //  AOL and other 3rd Party 3.0 compatibility.  The ITargetNotify
    //  object that sets off a window open operation via AOL container
    //  registers itself in ShellCallbacks list and wnsprintf's the
    //  coresponding cookie in the front of the frame name ("" if there
    //  is no frame name as in _blank).  we extract the cookie, notify
    //  all registered callbacks, then set the name MINUS the _[NNNNN..]
    //  that was prepending to the frame name.
    if (pszFrameName && pszFrameName[0] == '_' && pszFrameName[1] == '[')
    {
#define MAX_COOKIE 24
        WCHAR wszCookie[MAX_COOKIE + 1];   // big enough for "cbCookie"
        int i;
        long cbCookie;
        BOOL fNonDigit = FALSE;
        IShellWindows*   psw = NULL;

        for (i = 2; i < MAX_COOKIE && pszFrameName[i] && pszFrameName[i] != ']'; i++)
        {
            wszCookie[i-2] = pszFrameName[i];
            if (i != 2 || pszFrameName[2] != '-')
                fNonDigit = fNonDigit ||  pszFrameName[i] < '0' || pszFrameName[i] > '9';
        }
        wszCookie[i-2] = 0;
        if (i >= 3 && pszFrameName[i] == ']' && !fNonDigit)
        {
            cbCookie = StrToIntW(wszCookie);
            psw = WinList_GetShellWindows(TRUE);
            if (psw)
            {
                IUnknown *punkThis;

                if (SUCCEEDED(QueryInterface(IID_IUnknown, (LPVOID *) &punkThis)))
                {
                    psw->OnCreated(cbCookie, punkThis);
                    punkThis->Release();
                }
                psw->Release();
            }
            pszFrameName = pszFrameName + i + 1;
            if (pszFrameName[0] == 0) pszFrameName = NULL;
        }
    }
    return SetOleStrMember(&m_pszFrameName, pszFrameName);
}

    
/*******************************************************************

    NAME:       CIEFrameAuto::GetFrameName

    SYNOPSIS:   Gets the Frame Name.  Allocates a copy (this is an
    [OUT] parameter

********************************************************************/

STDMETHODIMP CIEFrameAuto::GetFrameName(WCHAR **ppszFrameName)
{
    return GetOleStrMember(m_pszFrameName, ppszFrameName);
}


/*******************************************************************

    NAME:       CIEFrameAuto::_GetParentFramePrivate

    SYNOPSIS:   Gets an the IUnknown pointer of the parent frame, or
    NULL if this is a top level frame. This pointer must be Released
    by Caller after use.

    IMPLEMENTATION:
    A Frame Container is required to implement ITargetFrame::GetParentFrame and
    implement GetParentFrame by returning the IUnknown pointer of the Browser that
    hosts it. A Browser implements GetParentFrame by returning NULL if it's
    top level or calling GetParentFrame on its Container if it is embedded.
    
    NOTE: THIS PRIVATE VERSION doesn't check for parent being desktopframe.

********************************************************************/
HRESULT CIEFrameAuto::_GetParentFramePrivate(LPUNKNOWN *ppunkParentFrame)
{
    LPOLEOBJECT pOleObject = NULL;
    LPOLECLIENTSITE pOleClientSite = NULL;
    HRESULT hr = S_OK;
    LPUNKNOWN punkParent = NULL;

    //  Start off with OleObject for this OCX embedding, it will
    //  be null if we're top level (a CIEFrameAuto, not a CVOCBrowser)
    _GetOleObject(&pOleObject);
    if (pOleObject != NULL)
    {

    //  Assumes GetClientSite succeeds and returns NULL if we
    //  are not embedded
        hr = pOleObject->GetClientSite( &pOleClientSite);
        if (FAILED(hr)) goto errExit;
        pOleObject->Release();
        pOleObject = NULL;

    //  If pOleClientSite is NULL, then we are at the top level
        if (pOleClientSite == NULL)
        {
            hr = S_OK;
            goto errExit;
        }
        else
        {
            hr = TargetQueryService(pOleClientSite, IID_IUnknown, (LPVOID*)&punkParent);
            if (FAILED(hr)) 
            {
                // if parent container does not support ITargetFrame, then
                // the parent container must be some other app, like VB.  In this
                // case, we've already found the outermost frame (us).  Return
                // S_OK and a NULL ptgfTargetFrame which indicates that we are the
                // outermost HTML frame.
                hr = S_OK;
            }
            SAFERELEASE(pOleClientSite);
        }
    }

errExit:
    SAFERELEASE(pOleObject);
    SAFERELEASE(pOleClientSite);
    *ppunkParentFrame = punkParent;
    return hr;
}

/*******************************************************************

    NAME:       CIEFrameAuto::GetParentFrame

    SYNOPSIS:   Gets an the IUnknown pointer of the parent frame, or
    NULL if this is a top level frame. This pointer must be Released
    by Caller after use.

    IMPLEMENTATION:
    A Frame Container is required to implement ITargetFrame::GetParentFrame and
    implement GetParentFrame by returning the IUnknown pointer of the Browser that
    hosts it. A Browser implements GetParentFrame by returning NULL if it's
    top level or calling GetParentFrame on its Container if it is embedded.

********************************************************************/
STDMETHODIMP CIEFrameAuto::GetParentFrame(LPUNKNOWN *ppunkParentFrame)
{
    HRESULT hr = _GetParentFramePrivate(ppunkParentFrame);
    
    //  Check if the parent is the desktop, if so, the frame chain stops
    //  at us
    if (SUCCEEDED(hr) && *ppunkParentFrame)
    {
       LPTARGETFRAME2 ptgfParent;
       DWORD dwOptions;

       if (SUCCEEDED((*ppunkParentFrame)->QueryInterface(IID_ITargetFrame2, (LPVOID *)&ptgfParent)))
       {
           ptgfParent->GetFrameOptions(&dwOptions);
           if (dwOptions & FRAMEOPTIONS_DESKTOP)
           {
               (*ppunkParentFrame)->Release();
               *ppunkParentFrame = NULL;
           }
           ptgfParent->Release();
       }
    }
    return hr;
}

// PLEASE PROPOGATE ANY CHANGES TO THESE ENUMS TO \mshtml\iextag\httpwfh.h
typedef enum _TARGET_TYPE {
TARGET_FRAMENAME,
TARGET_SELF,
TARGET_PARENT,
TARGET_BLANK,
TARGET_TOP,
TARGET_MAIN,
TARGET_SEARCH,
TARGET_MEDIA
} TARGET_TYPE;

typedef struct _TARGETENTRY {
    TARGET_TYPE targetType;
    const WCHAR *pTargetValue;
} TARGETENTRY;

static const TARGETENTRY targetTable[] =
{
    {TARGET_SELF, L"_self"},
    {TARGET_PARENT, L"_parent"},
    {TARGET_BLANK, L"_blank"},
    {TARGET_TOP, L"_top"},
    {TARGET_MAIN, L"_main"},
    {TARGET_SEARCH, L"_search"},
    {TARGET_MEDIA, L"_media"},
    {TARGET_SELF, NULL}
};


/*******************************************************************

    NAME:       ParseTargetType

    SYNOPSIS:   Maps pszTarget into a target class.

    IMPLEMENTATION:
    Treats unknown MAGIC targets as _self

********************************************************************/
// PLEASE PROPOGATE ANY CHANGES TO THIS FUNCTION TO \mshtml\iextag\httpwf.cxx
TARGET_TYPE ParseTargetType(LPCOLESTR pszTarget)
{
    const TARGETENTRY *pEntry = targetTable;

    if (pszTarget[0] != '_') return TARGET_FRAMENAME;
    while (pEntry->pTargetValue)
    {
        if (!StrCmpW(pszTarget, pEntry->pTargetValue)) return pEntry->targetType;
        pEntry++;
    }
    //  Treat unknown MAGIC targets as regular frame name! <<for NETSCAPE compatibility>>
    return TARGET_FRAMENAME;

}

/*******************************************************************

    NAME:       TargetQueryService

    SYNOPSIS:   Returns a pointer to containing Browser's ITargetFrame
                interface (or NULL if container does not support it)

    NOTES:      If we don't yet have this interface pointer yet,
                this function will QueryInterface to get it.

********************************************************************/
HRESULT TargetQueryService(LPUNKNOWN punk, REFIID riid, void **ppvObj)
{
    //  Get the ITargetFrame for the embedding.
    return IUnknown_QueryService(punk, IID_ITargetFrame2, riid, ppvObj);
}


/*******************************************************************

    NAME:       _TargetTopLevelWindows

    SYNOPSIS:   see FindFrame, does the named targets across windows

********************************************************************/
HRESULT _TargetTopLevelWindows(LPTARGETFRAMEPRIV ptgfpThis, LPCOLESTR pszTargetName, DWORD dwFlags, LPUNKNOWN *ppunkTargetFrame)
{
    IShellWindows*   psw = NULL;
    HRESULT hr = E_FAIL;

    *ppunkTargetFrame = NULL;
    psw = WinList_GetShellWindows(TRUE);
    if (psw != NULL)
    {
        IUnknown *punkEnum;
        IEnumVARIANT *penumVariant;
        VARIANT VarResult;
        BOOL fDone = FALSE;
        LPTARGETFRAMEPRIV ptgfpWindowFrame;

        hr = psw->_NewEnum(&punkEnum);
        if (SUCCEEDED(hr))
        {
            hr = punkEnum->QueryInterface(IID_IEnumVARIANT, (LPVOID *)&penumVariant);
            if (SUCCEEDED(hr))
            {
                while (!fDone)
                {
                    VariantInit(&VarResult);
                    hr = penumVariant->Next(1, &VarResult, NULL);
                    if (hr == NOERROR)
                    {
                        if (VarResult.vt == VT_DISPATCH && VarResult.pdispVal)
                        {
                            hr = VarResult.pdispVal->QueryInterface(IID_ITargetFramePriv, (LPVOID *)&ptgfpWindowFrame);
                            if (SUCCEEDED(hr))
                            {
                                if (ptgfpWindowFrame != ptgfpThis)
                                {
                                    hr = ptgfpWindowFrame->FindFrameDownwards(pszTargetName,
                                                                             dwFlags,
                                                                             ppunkTargetFrame);
                                    if (SUCCEEDED(hr) && *ppunkTargetFrame != NULL)
                                    {
                                        fDone = TRUE;
                                    }
                                }
                                ptgfpWindowFrame->Release();
                            }
                        }
                    }
                    else fDone = TRUE;
                    VariantClear(&VarResult);
                }
                penumVariant->Release();
            }
            punkEnum->Release();
        }
        psw->Release();
    }
    return hr;
}

/*******************************************************************

  NAME:         CreateTargetFrame

  SYNOPSIS:     Creates a new window, if pszTargetName is not special
                target, names it pszTargetName.  returns IUnknown for
                the object that implements ITargetFrame,IHlinkFrame and
                IWebBrowserApp.
********************************************************************/
// PLEASE PROPOGATE ANY CHANGES TO THIS FUNCTION TO \mshtml\iextag\httpwf.cxx
HRESULT CreateTargetFrame(LPCOLESTR pszTargetName, LPUNKNOWN /*IN,OUT*/ *ppunk)
{
    LPTARGETFRAME2 ptgfWindowFrame;
    HRESULT hr = S_OK;

    //  Launch a new window, set it's frame name to pszTargetName
    //  return it's IUnknown. If the new window is passed to us,
    //  just set the target name.

    if (NULL == *ppunk)
    {
#ifndef  UNIX
        hr = CoCreateNewIEWindow(CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER, IID_IUnknown, (LPVOID*)ppunk);
#else
        hr = CoCreateInternetExplorer( IID_IUnknown, 
                                       CLSCTX_LOCAL_SERVER | CLSCTX_INPROC_SERVER,
                                       (LPVOID*) ppunk );
#endif
    }

    if (SUCCEEDED(hr))
    {
        //  Don't set frame name if target is special or missing
        if (pszTargetName && ParseTargetType(pszTargetName) == TARGET_FRAMENAME)
        {
            HRESULT hrLocal;
            hrLocal = (*ppunk)->QueryInterface(IID_ITargetFrame2, (LPVOID *)&ptgfWindowFrame);
            if (SUCCEEDED(hrLocal))
            {
                ptgfWindowFrame->SetFrameName(pszTargetName);
                ptgfWindowFrame->Release();
            }
        }

        // Even if we don't set the frame name, we still want to return
        // success, otherwise we'd have a blank window hanging around.
    }

    return hr;
}

/*******************************************************************

    NAME:       CIEFrameAuto::_DoNamedTarget

    SYNOPSIS:   see FindFrame, does the named targets.  checks itself
    then if that fails, all children except for punkContextFrame (if
    punkContextFrame != NULL).  if all of the above fail, will recurse
    upwards if necessary, if punkContextFrame != NULL.  if punkContextFrame
    is NULL, then this works out to checking ourself and all children
    then giving up.

********************************************************************/
HRESULT CIEFrameAuto::_DoNamedTarget(LPCOLESTR pszTargetName, LPUNKNOWN punkContextFrame, DWORD dwFlags, LPUNKNOWN * ppunkTargetFrame)
{
    // asserts
    HRESULT hr = S_OK;
    HRESULT hrLocal;
    LPUNKNOWN punkParent = NULL;
    LPUNKNOWN punkThisFrame = NULL;
    LPTARGETFRAMEPRIV ptgfpParent = NULL;
    LPUNKNOWN punkThis = NULL;
    LPUNKNOWN punkChildObj = NULL;
    LPUNKNOWN punkChildFrame = NULL;
    LPTARGETFRAMEPRIV ptgfpChild = NULL;
    LPOLECONTAINER pOleContainer = NULL;
    LPENUMUNKNOWN penumUnknown = NULL;
    LPUNKNOWN punkProxyContextFrame = NULL;
    LPTARGETFRAMEPRIV ptgfpTarget = NULL;

    ASSERT(ppunkTargetFrame);

    *ppunkTargetFrame = NULL;

    hr = QueryInterface(IID_IUnknown, (LPVOID*)&punkThis);
    ASSERT(punkThis != NULL);

    if (FAILED(hr))
        goto exitPoint;

    //  First check for match on US!
    if (m_pszFrameName && !StrCmpW(pszTargetName, m_pszFrameName))
    {
        *ppunkTargetFrame = punkThis;
        //  Set punkThis to NULL to prevent Release at exit
        punkThis = NULL;
        goto exitPoint;
    }
    //  we ask our ShellView's embedded DocObject if it supports ITargetFrame.  If it does,
    //  we first let it look for the target.
    hrLocal = GetFramesContainer(&pOleContainer);
    if (SUCCEEDED(hrLocal) && pOleContainer != NULL)
    {
        hr = pOleContainer->EnumObjects(OLECONTF_EMBEDDINGS, &penumUnknown);
        if (hr != S_OK || penumUnknown == NULL)
            goto exitPoint;

        while (TRUE)
        {
            hr = penumUnknown->Next(1, &punkChildObj, NULL);
            if (punkChildObj == NULL)
            {
                hr = S_OK;
                break;
            }
            hrLocal = punkChildObj->QueryInterface(IID_ITargetFramePriv, (LPVOID *) &ptgfpChild);
            if (SUCCEEDED(hrLocal))
            {
                hr = ptgfpChild->QueryInterface(IID_IUnknown, (LPVOID *) &punkChildFrame);
                if (FAILED(hr))
                    goto exitPoint;

                //  IF this isn't the punkContextFrame, see if embedding supports ITargetFrame
                if (punkChildFrame != punkContextFrame)
                {
                    hr = ptgfpChild->FindFrameDownwards(pszTargetName,
                                                        dwFlags,
                                                        ppunkTargetFrame);

                    if (hr != S_OK || *ppunkTargetFrame != NULL)
                        goto exitPoint;
                }
            }
            punkChildObj->Release();
            punkChildObj = NULL;
            SAFERELEASE(punkChildFrame);
            SAFERELEASE(ptgfpChild);
        }
    }

    if (!(*ppunkTargetFrame) && pOleContainer)
    {
        hr = _FindWindowByName(pOleContainer, pszTargetName, ppunkTargetFrame);
        if (S_OK == hr)
            goto exitPoint;
    }

    //  We don't recurse to parent in punkContextFrame is NULL
    if (punkContextFrame == NULL)
        goto exitPoint;

    hr = GetParentFrame(&punkParent);

    if (hr != S_OK)
        goto exitPoint;

    if (punkParent != NULL)
    {
        //  We have a parent, recurse upwards, with ourself as context frame
        hr = punkParent->QueryInterface(IID_ITargetFramePriv, (LPVOID*)&ptgfpParent);

        if (hr != S_OK)
            goto exitPoint;

        hr = ptgfpParent->FindFrameInContext(pszTargetName,
                                             punkThis,
                                             dwFlags,
                                             ppunkTargetFrame);
        goto exitPoint;
    }

    //  At this point we've come to the top level frame.
    //  Enumerate top level windows, unless we're a toolbar

    *ppunkTargetFrame = NULL;
    if (_psb != _psbProxy)
    {
        //  Webbar : Find in context of top frame of proxy
        hr = TargetQueryService(_psbProxy, IID_ITargetFramePriv, (LPVOID *) &ptgfpTarget);
        if (SUCCEEDED(hr) && ptgfpTarget)
        {
            hr = ptgfpTarget->QueryInterface(IID_IUnknown, (LPVOID *) &punkProxyContextFrame);
            if (SUCCEEDED(hr))
            {
                hr = ptgfpTarget->FindFrameInContext(pszTargetName,
                                                     punkProxyContextFrame,
                                                     dwFlags,
                                                     ppunkTargetFrame);
                if (*ppunkTargetFrame)
                    goto exitPoint;
            }
        }
    }
    else if (!(FINDFRAME_OLDINTERFACE & dwFlags))
    {
        hr = _TargetTopLevelWindows((LPTARGETFRAMEPRIV)this, pszTargetName, dwFlags, ppunkTargetFrame);
        if (*ppunkTargetFrame)
            goto exitPoint;
    }

    //  Now we have exhausted all frames.  Unless FINDFRAME_JUSTTESTEXISTENCE
    //  is set in dwFlags, create a new window, set it's frame name and return it
    if (dwFlags & FINDFRAME_JUSTTESTEXISTENCE)
    {
        hr = S_OK;
    }
    else
    {
        //  CreateTargetFrame will not work with AOL 3.01 clients
        //  so we must return E_FAIL

        hr = E_FAIL;
    }


exitPoint:
    SAFERELEASE(punkProxyContextFrame);
    SAFERELEASE(ptgfpTarget);
    SAFERELEASE(punkThis);
    SAFERELEASE(punkThisFrame);
    SAFERELEASE(ptgfpParent);
    SAFERELEASE(punkParent);
    SAFERELEASE(punkChildFrame);
    SAFERELEASE(ptgfpChild);
    SAFERELEASE(penumUnknown);
    SAFERELEASE(pOleContainer);
    SAFERELEASE(punkChildObj);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method    : CIEFrameAuto::_FindWindowByName
//
//  Synopsis  : Searches the give container for the given frame name.
//              This method is called when _DoNamedTarget fails to find
//              the target frame in one of the container's embeddings.
//
//+-------------------------------------------------------------------------

HRESULT
CIEFrameAuto::_FindWindowByName(IOleContainer * pOleContainer,
                                LPCOLESTR       pszTargetName,
                                LPUNKNOWN     * ppunkTargetFrame)
{
    HRESULT hr;
    IHTMLDocument2     * pDocument;
    IHTMLPrivateWindow * pPrivWindow;
    IHTMLWindow2       * pHTMLWindow;
    IServiceProvider   * pServiceProvider;
    IWebBrowserApp     * pWebBrowserApp;

    ASSERT(pOleContainer);
    ASSERT(ppunkTargetFrame);

    hr = pOleContainer->QueryInterface(IID_IHTMLDocument2, (void**)&pDocument);
    if (SUCCEEDED(hr))
    {
        hr = pDocument->get_parentWindow(&pHTMLWindow);
        if (SUCCEEDED(hr))
        {
            hr = pHTMLWindow->QueryInterface(IID_IHTMLPrivateWindow, (void**)&pPrivWindow);
            pHTMLWindow->Release();

            if (SUCCEEDED(hr))
            {
                hr = pPrivWindow->FindWindowByName(pszTargetName, &pHTMLWindow);
                if (S_OK == hr)
                {
                    hr = pHTMLWindow->QueryInterface(IID_IServiceProvider, (void **) &pServiceProvider);
                    if (S_OK == hr)
                    {
                        hr = pServiceProvider->QueryService(SID_SWebBrowserApp, IID_IWebBrowserApp, (void **) &pWebBrowserApp);
                        if (S_OK == hr)
                        {
                            *ppunkTargetFrame = SAFECAST(pWebBrowserApp, IUnknown*);
                            (*ppunkTargetFrame)->AddRef();

                            pWebBrowserApp->Release();
                        }

                        pServiceProvider->Release();
                    }

                    pHTMLWindow->Release();
                }

                pPrivWindow->Release();
            }
        }

        pDocument->Release();
    }

    return hr;
}

/*******************************************************************

    NAME:       CIEFrameAuto::SetFrameSrc

    SYNOPSIS:   Sets the Frame original SRC url.  Frees current one if exists.

********************************************************************/
HRESULT CIEFrameAuto::SetFrameSrc(LPCOLESTR pszFrameSrc)
{
    return SetOleStrMember(&m_pszFrameSrc, pszFrameSrc);
}

IShellView* CIEFrameAuto::_GetShellView(void)
{
    IShellView* psv = NULL;
    if (_psb) {
        _psb->QueryActiveShellView(&psv);
    }

    return psv;
}

/*******************************************************************

    NAME:       CIEFrameAuto::GetFrameSrc

    SYNOPSIS:   Gets the Frame original URL.  Allocates a copy (this is an
    [OUT] parameter

    NOTES:      If we are at top level, SRC is dynamic, so ask our
    contained DocObject to do it for us.

********************************************************************/
HRESULT CIEFrameAuto::GetFrameSrc(WCHAR **ppszFrameSrc)
{
    LPUNKNOWN punkParent = NULL;
    LPTARGETFRAME ptgfTargetFrame = NULL;
    LPTARGETCONTAINER ptgcTargetContainer = NULL;
    HRESULT hr;

    *ppszFrameSrc = NULL;
    hr = GetParentFrame(&punkParent);
    if (hr != S_OK) goto exitPoint;

    // If we're an embedding we have original src. If we're top level and
    // src has been set, return that, else defer to document
    if (punkParent != NULL || m_pszFrameSrc)
    {
        hr = GetOleStrMember(m_pszFrameSrc, ppszFrameSrc);
    }
    else // We're top level without an explicit SRC
    {
        *ppszFrameSrc = NULL;
        hr = S_OK;
        IShellView* psv = _GetShellView();
        if (psv)
        {
            HRESULT hrLocal = SafeGetItemObject(psv, SVGIO_BACKGROUND, IID_ITargetContainer, (LPVOID*) &ptgcTargetContainer);

            if (SUCCEEDED(hrLocal))
            {
                hr = ptgcTargetContainer->GetFrameUrl(ppszFrameSrc);
            }
            else
            {
                //  Backwards compatibility
                hrLocal = SafeGetItemObject(psv, SVGIO_BACKGROUND, IID_ITargetFrame, (LPVOID*) &ptgfTargetFrame);

                if (SUCCEEDED(hrLocal))
                {
                    hr = ptgfTargetFrame->GetFrameSrc(ppszFrameSrc);
                }
            }
            psv->Release();
        }
    }

exitPoint:
    SAFERELEASE(punkParent);
    SAFERELEASE(ptgfTargetFrame);
    SAFERELEASE(ptgcTargetContainer);
    return hr;
}



    
/*******************************************************************

    NAME:       CIEFrameAuto::GetFramesContainer

    SYNOPSIS:   Returns an addref'ed pointer to the LPOLECONTAINER
    for our nested frames.  Can be NULL.

********************************************************************/
HRESULT CIEFrameAuto::GetFramesContainer(LPOLECONTAINER *ppContainer)
{
    HRESULT hr;
    LPTARGETFRAME ptgfTargetFrame = NULL;
    LPTARGETCONTAINER ptgcTargetContainer = NULL;

    // FEATURE REVIEW -- why is S_OK and NULL a valid return? E_FAIL makes way more sense...
    // (That's what will get returned if _psv->GetItemObject failes.)
    hr = S_OK;
    *ppContainer = NULL;
    IShellView* psv = _GetShellView();
    if (psv)
    {
        HRESULT hrLocal;

        hrLocal = SafeGetItemObject(psv, SVGIO_BACKGROUND, IID_ITargetContainer, (LPVOID*) &ptgcTargetContainer);

        if (SUCCEEDED(hrLocal))
        {
            hr = ptgcTargetContainer->GetFramesContainer(ppContainer);
        }
        else
        {
            //  Backwards compatibility
            hrLocal = SafeGetItemObject(psv, SVGIO_BACKGROUND, IID_ITargetFrame, (LPVOID*) &ptgfTargetFrame);

            if (SUCCEEDED(hrLocal))
            {
                hr = ptgfTargetFrame->GetFramesContainer(ppContainer);
            }
        }
        psv->Release();
    }
    SAFERELEASE(ptgcTargetContainer);
    SAFERELEASE(ptgfTargetFrame);

    return hr;
}


/*******************************************************************

    NAME:       CIEFrameAuto::SetFrameOptions

    SYNOPSIS:   Sets the Frame Options.

********************************************************************/
HRESULT CIEFrameAuto::SetFrameOptions(DWORD dwFlags)
{
    m_dwFrameOptions = dwFlags;
    return S_OK;
}

    
/*******************************************************************

    NAME:       CIEFrameAuto::GetFrameOptions

    SYNOPSIS:   Returns the frame options

********************************************************************/

HRESULT CIEFrameAuto::GetFrameOptions(LPDWORD pdwFlags)
{
    *pdwFlags = m_dwFrameOptions;

    // If we are full screen turn on a few extras...
    VARIANT_BOOL fFullScreen;
    if ((SUCCEEDED(get_FullScreen(&fFullScreen)) && fFullScreen == VARIANT_TRUE) ||
        (SUCCEEDED(get_TheaterMode(&fFullScreen)) && fFullScreen == VARIANT_TRUE)) {
        *pdwFlags |= FRAMEOPTIONS_SCROLL_AUTO | FRAMEOPTIONS_NO3DBORDER;
    } else if (_psbProxy != _psb) {
        // If we are in the WebBar, turn off the 3D border. 
        *pdwFlags |= FRAMEOPTIONS_NO3DBORDER;
    }
    // if we are desktop, turn on FRAMEOPTIONS_DESKTOP
    if (_fDesktopFrame)
    {
        *pdwFlags |= FRAMEOPTIONS_DESKTOP;
    }
    return S_OK;
}


/*******************************************************************

    NAME:       CIEFrameAuto::SetFrameMargins

    SYNOPSIS:   Sets the Frame margins.

********************************************************************/
HRESULT CIEFrameAuto::SetFrameMargins(DWORD dwWidth, DWORD dwHeight)
{
    m_dwFrameMarginWidth = dwWidth;
    m_dwFrameMarginHeight = dwHeight;
    return S_OK;
}

    
/*******************************************************************

    NAME:       CIEFrameAuto::GetFrameMargins

    SYNOPSIS:   Returns the frame margins

********************************************************************/

HRESULT CIEFrameAuto::GetFrameMargins(LPDWORD pdwWidth, LPDWORD pdwHeight)
{
    *pdwWidth = m_dwFrameMarginWidth;
    *pdwHeight = m_dwFrameMarginHeight;
    return S_OK;
}

/*******************************************************************

    NAME:       CIEFrameAuto::_fDesktopComponent

    SYNOPSIS:   Returns TRUE if this frame is a desktop component
    top level frame or a the top frame of a browser band other than
    the search pane.  These panes need special treatment of FindFrame
    and navigate.

*******************************************************************/
BOOL CIEFrameAuto::_fDesktopComponent()
{
    BOOL fInDesktop = FALSE;
    LPUNKNOWN punkParent;

    //  Special interpretation for desktop components and non-search browser bands
    //  NULL pszTargetName at top level frames is defined as being targeted
    //  to the window whose frame is "_desktop".  this will create a new top level
    //  browser as necessary and return it's frame.
    if (SUCCEEDED(_GetParentFramePrivate(&punkParent)) && punkParent)
    {
        DWORD dwOptions;
        LPTARGETFRAME2 ptgfTop;

        
        //  not a top level frame unless our parent is desktop frame
        if (SUCCEEDED(punkParent->QueryInterface(IID_ITargetFrame2, (LPVOID *) &ptgfTop)))
        {
            if (SUCCEEDED(ptgfTop->GetFrameOptions(&dwOptions)))
            {
                fInDesktop = (dwOptions & FRAMEOPTIONS_DESKTOP) ? TRUE:FALSE;
            }
            ptgfTop->Release();
        }
        punkParent->Release();
    }
    else if (m_dwFrameOptions & FRAMEOPTIONS_BROWSERBAND)
    {
        //  a browser band - check for search band (proxied hlinkframe)
        fInDesktop = _psb == _psbProxy;
    }
    return fInDesktop;
}

//  ITargetFrame2 members
    
/*******************************************************************

    NAME:       CIEFrameAuto::GetTargetAlias

    SYNOPSIS:   Gets the Frame Name.  Allocates a copy (this is an
    [OUT] parameter

********************************************************************/

STDMETHODIMP CIEFrameAuto::GetTargetAlias(LPCOLESTR pszTargetName, WCHAR **ppszTargetAlias)
{
    BOOL fInDesktop = _fDesktopComponent();
    
    //  Special interpretation for desktop components and non-search browser bands
    //  NULL pszTargetName and "_top" at top level frames are defined as being targeted
    //  to the window whose frame is "_desktop".  this will create a new top level
    //  browser as necessary and return it's frame.

    if (pszTargetName == NULL && _fDesktopComponent())
        return GetOleStrMember(L"_desktop", ppszTargetAlias);
    *ppszTargetAlias = NULL;
    return E_FAIL;
}

/*******************************************************************

    NAME:       CIEFrameAuto::FindFrame

    SYNOPSIS:   Gets an the IUnknown pointer of the frame referenced
    by pszTarget. This pointer must be Released by Caller after use.
    punkContextFrame, if not NULL, is the IUnknown pointer for the immediate
    descendent frame in whose subtree the Target reference (eg anchor with a Target tag)
    resides.  dwFlags are flags which modify FindFrame's behaviour and
    can be any combination of FINDFRAME_FLAGS. In particular, SETTING
    FINDFRAME_JUSTTESTEXISTENCE allows the caller to defeat the default
    FindFrame behavior of creating a new top level frame named pszTarget,
    if pszTarget does not exist.

    IMPLEMENTATION:

    NOTE: In HTML all anchors and other TARGET tags can occur ONLY in
    leaf FRAMES!!

    punkContextFrame is significant only if pszTarget is not
    a MAGIC target name (_self, _top, _blank, _parent).

    Non-MAGIC target names:

    first off, this frame should check if it matches pszTarget and return
    it's own IUnknown pointer forthwith.

    if punkContextFrame is not NULL, all child Frames
    except punkContextFrame should be searched (depth first) for
    pszTarget with punkContextFrame == NULL.  on failure, the parent of this
    frame should be recursively called with this frame replacing punkContextFrame.
    if this is a top level Frame (so there is no parent), all top level frames
    should be called with punkContextFrame == NULL.  if this fails, then a new top level
    frame should be created (unless FINDFRAME_JUSTTESTEXISTENCE is set in
    dwFlags), named pszTarget and its IUnknown returned.

    if punkContextFrame is NULL, all child Frames should be searched
    depth first for pszTarget.  on failure, NULL should be returned.


    MAGIC target names:

    _self should return the IUnknown of this ITargetFrame
    _top should be recursively passed up to the top level ITargetFrame. if
    there is no FrameParent, this defaults to _self.
    _parent should return the IUnknown of the FrameParent ITargetFrame. if
    there is no FrameParent, this defaults to _self.
    _blank should be recursively passed up to the top level ITargetFrame,
    which should create a unnamed top level frame

********************************************************************/

STDMETHODIMP CIEFrameAuto::FindFrame(LPCOLESTR pszTargetName,
                                           DWORD dwFlags,
                                           LPUNKNOWN *ppunkTargetFrame)
{
    LPTARGETFRAMEPRIV ptgfpTarget = NULL;
    LPUNKNOWN punkContextFrame = NULL;
    HRESULT hr = E_FAIL;
    BOOL fInContext = TRUE;
    BOOL fWasMain = FALSE;
    TARGET_TYPE targetType;

    if (pszTargetName == NULL || *pszTargetName == 0)
        pszTargetName = L"_self";
    targetType  = ParseTargetType(pszTargetName);
    if (targetType == TARGET_MAIN)
    {
        fWasMain = TRUE;
        pszTargetName = L"_self";
    }

    *ppunkTargetFrame = NULL;

    // Default behavior:
    //  If this is a webbar and targeting _main, find frame in _psbProxy and return it
    //  If this is in browser, find frame relative to ourselves
    if (_psb != _psbProxy && fWasMain)
    {
        //  Webbar : Find in context of top frame of proxy
        hr = TargetQueryService(_psbProxy, IID_ITargetFramePriv, (LPVOID *) &ptgfpTarget);
    }
    else
    {
        //   Browser : A normal find in context in ourself

        hr = QueryInterface(IID_ITargetFramePriv, (LPVOID *) &ptgfpTarget);
    }

    if (SUCCEEDED(hr) && ptgfpTarget)
    {
        if (fInContext) 
        {
            hr = ptgfpTarget->QueryInterface(IID_IUnknown, (LPVOID *) &punkContextFrame);
            if (SUCCEEDED(hr))
            {
                hr = ptgfpTarget->FindFrameInContext(pszTargetName,
                                                     punkContextFrame,
                                                     dwFlags,
                                                     ppunkTargetFrame);

            }
        }
        else
        {
            hr = ptgfpTarget->FindFrameDownwards(pszTargetName,
                                                 dwFlags,
                                                 ppunkTargetFrame);
        }

    }

    SAFERELEASE(punkContextFrame);
    SAFERELEASE(ptgfpTarget);
    if (SUCCEEDED(hr) 
        && *ppunkTargetFrame == NULL
        && !(FINDFRAME_OLDINTERFACE&dwFlags)) hr = S_FALSE;
    return hr;
}

//  ITargetFramePriv members

/*******************************************************************

    NAME:       CIEFrameAuto::FindFrameDownwards

    SYNOPSIS:   

    IMPLEMENTATION:


********************************************************************/

STDMETHODIMP CIEFrameAuto::FindFrameDownwards(LPCOLESTR pszTargetName,
                                              DWORD dwFlags,
                                              LPUNKNOWN *ppunkTargetFrame)
{
    return FindFrameInContext(pszTargetName, 
                              NULL, 
                              dwFlags | FINDFRAME_JUSTTESTEXISTENCE,
                              ppunkTargetFrame);
}

/*******************************************************************

    NAME:       CIEFrameAuto::FindFrameInContext

    SYNOPSIS:   

    IMPLEMENTATION:


********************************************************************/

STDMETHODIMP CIEFrameAuto::FindFrameInContext(LPCOLESTR pszTargetName,
                                              LPUNKNOWN punkContextFrame,
                                              DWORD dwFlags,
                                              LPUNKNOWN *ppunkTargetFrame)
{
    //asserts
    TARGET_TYPE targetType;
    HRESULT hr = S_OK;
    LPUNKNOWN punkParent = NULL;
    LPUNKNOWN punkThisFrame = NULL;
    LPTARGETFRAMEPRIV ptgfpTargetFrame = NULL;
    LPUNKNOWN punkThis = NULL;

    targetType  = ParseTargetType(pszTargetName);
    if (targetType == TARGET_FRAMENAME)
    {
        hr = _DoNamedTarget(pszTargetName, punkContextFrame, dwFlags, ppunkTargetFrame);
        goto exitPoint;
    }

    //  Must be a Magic Target

    //for search, first show the search bar and then reach across to get it's TargetFrame
    if (targetType == TARGET_SEARCH)
    {
        SA_BSTRGUID  strGuid;
        VARIANT      vaGuid;

        InitFakeBSTR(&strGuid, CLSID_SearchBand);

        vaGuid.vt = VT_BSTR;
        vaGuid.bstrVal = strGuid.wsz;

        //if we're in an explorer bar, use the proxy's pbs
        IBrowserService *pbs = _pbs;
        if (_psb != _psbProxy)
        {
            EVAL(SUCCEEDED(_psbProxy->QueryInterface(IID_IBrowserService, (void**)&pbs)));
        }

        IUnknown_Exec(pbs, &CGID_ShellDocView, SHDVID_SHOWBROWSERBAR, 1, &vaGuid, NULL);

        VARIANT vaPunkBand = {0};
        hr = IUnknown_Exec(pbs, &CGID_ShellDocView, SHDVID_GETBROWSERBAR, NULL, NULL, &vaPunkBand);

        if (_psb != _psbProxy)
        {
            ATOMICRELEASE(pbs);
        }

        if (hr == S_OK)
        {
            IDeskBand* pband;
            
            pband = (IDeskBand*)vaPunkBand.punkVal;
            ASSERT(pband);
            
            if (pband)
            {
                IBrowserBand* pbb;
                
                hr = pband->QueryInterface(IID_IBrowserBand, (LPVOID*)&pbb);
                if (SUCCEEDED(hr))
                {
                    // now, get the pidl search pane is navigated to.
                    // if it's null we have to navigate it to something -- default search url (web search)
                    // this used to be in CSearchBand::_NavigateOC but caused problems
                    // if user had dial up networking set up and tried to get to the file search we would 
                    // first set pidl to web search url (_NavigateOC is called by _CreateOCHost) which would 
                    // cause AutoDial dialog to come up and then we would navigate the pane to the file search
                    // (nt5 bug#186970) reljai -- 6/22/98
                    VARIANT varPidl = {0};

                    if (SUCCEEDED(IUnknown_Exec(pbb, &CGID_SearchBand, SBID_GETPIDL, 0, NULL, &varPidl)))
                    {
                        ISearchItems* psi;
                        LPITEMIDLIST  pidl = VariantToIDList(&varPidl);
                        
                        VariantClear(&varPidl);
                        if (!pidl && SUCCEEDED(IUnknown_QueryService(pbb, SID_SExplorerToolbar, IID_ISearchItems, (void **)&psi)))
                        {
                            // get the default search url
                            WCHAR wszSearchUrl[INTERNET_MAX_URL_LENGTH];
        
                            if (SUCCEEDED(psi->GetDefaultSearchUrl(wszSearchUrl, ARRAYSIZE(wszSearchUrl))))
                            {
                                IBandNavigate* pbn;

                                if (SUCCEEDED(pbb->QueryInterface(IID_IBandNavigate, (void **)&pbn)))
                                {
                                    // reuse pidl
                                    IECreateFromPathW(wszSearchUrl, &pidl);
                                    pbn->Select(pidl);
                                    pbn->Release();
                                }
                            }
                            psi->Release();
                        }
                        ILFree(pidl);
                    }
                    
                    IWebBrowser2* pwb;

                    hr = pbb->GetObjectBB(IID_IWebBrowser2, (LPVOID*)&pwb);

                    //set the search pane's opener property
                    if (SUCCEEDED(hr))
                    {
                        IDispatch* pdisp;
                        
                        if (SUCCEEDED(pwb->get_Document(&pdisp)) && pdisp)
                        {
                            IHTMLDocument2* pDoc;
                            if (SUCCEEDED(pdisp->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc)) && pDoc)
                            {
                                IHTMLWindow2* pWindow;
                            
                                if (SUCCEEDED(pDoc->get_parentWindow(&pWindow)) && pWindow)
                                {
                                    VARIANT var;
                                    VariantInit(&var);
                                    var.vt = VT_DISPATCH;
                                    _omwin.QueryInterface(IID_IUnknown, (void**)&var.pdispVal);
                                    
                                    pWindow->put_opener(var);

                                    VariantClear(&var);
                                    pWindow->Release();
                                }
                                pDoc->Release();
                            }
                            pdisp->Release();
                        }
                    }

                    if (SUCCEEDED(hr))
                    {
                        hr = pwb->QueryInterface(IID_ITargetFramePriv, (void **)ppunkTargetFrame);
                        pwb->Release();
                    }

                    pbb->Release();
                }
                pband->Release();
            }
        }
        else
        {
            //maybe we're the search bar
            //hack to let search pane know to remember the next navigation
            IUnknown *punkThis;

            if (SUCCEEDED(_psb->QueryInterface(IID_IUnknown, (void**)&punkThis)))
            {
                hr = QueryInterface(IID_ITargetFramePriv, (void**)&ptgfpTargetFrame);

                if (SUCCEEDED(hr))
                    *ppunkTargetFrame = ptgfpTargetFrame;
                ptgfpTargetFrame = NULL;
                punkThis->Release();
            }
        }
        
        goto exitPoint;
    }

    // content pane of MediaBar:
    if (targetType == TARGET_MEDIA)
    {
        SA_BSTRGUID  strGuid;
        VARIANT      vaGuid;

        InitFakeBSTR(&strGuid, CLSID_MediaBand);

        vaGuid.vt = VT_BSTR;
        vaGuid.bstrVal = strGuid.wsz;

        //if we're in an explorer bar, use the proxy's pbs
        IBrowserService *pbs = _pbs;
        if (_psb != _psbProxy)
        {
            EVAL(SUCCEEDED(_psbProxy->QueryInterface(IID_IBrowserService, (void**)&pbs)));
        }

        IUnknown_Exec(pbs, &CGID_ShellDocView, SHDVID_SHOWBROWSERBAR, 1, &vaGuid, NULL);

        VARIANT vaPunkBand = {0};
        hr = IUnknown_Exec(pbs, &CGID_ShellDocView, SHDVID_GETBROWSERBAR, NULL, NULL, &vaPunkBand);

        if (_psb != _psbProxy)
        {
            ATOMICRELEASE(pbs);
        }

        if (hr == S_OK)
        {
            IDeskBand* pband;
            
            pband = (IDeskBand*)vaPunkBand.punkVal;
            ASSERT(pband);
            
            if (pband)
            {
                IBrowserBand* pbb;
                
                hr = pband->QueryInterface(IID_IBrowserBand, (LPVOID*)&pbb);
                if (SUCCEEDED(hr))
                {
                    IWebBrowser2* pwb;

                    hr = pbb->GetObjectBB(IID_IWebBrowser2, (LPVOID*)&pwb);

                    //set the media pane's opener property
                    if (SUCCEEDED(hr))
                    {
                        IDispatch* pdisp;
                        
                        if (SUCCEEDED(pwb->get_Document(&pdisp)) && pdisp)
                        {
                            IHTMLDocument2* pDoc;
                            if (SUCCEEDED(pdisp->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc)) && pDoc)
                            {
                                IHTMLWindow2* pWindow;
                            
                                if (SUCCEEDED(pDoc->get_parentWindow(&pWindow)) && pWindow)
                                {
                                    VARIANT var;
                                    VariantInit(&var);
                                    var.vt = VT_DISPATCH;
                                    _omwin.QueryInterface(IID_IUnknown, (void**)&var.pdispVal);
                                    
                                    pWindow->put_opener(var);

                                    VariantClear(&var);
                                    pWindow->Release();
                                }
                                pDoc->Release();
                            }
                            pdisp->Release();
                        }
                    }

                    if (SUCCEEDED(hr))
                    {
                        hr = pwb->QueryInterface(IID_ITargetFramePriv, (void **)ppunkTargetFrame);
                        pwb->Release();
                    }

                    pbb->Release();
                }
                pband->Release();
            }
        }
        else
        {
            ASSERT(0);      // means we have no explorer bands at all........
                            // but the SHDVID_SHOWBROWSERBAR just before does launch the media bar
        }
        
        goto exitPoint;
    }



    hr = QueryInterface(IID_IUnknown, (LPVOID*)&punkThis);
    ASSERT(punkThis != NULL);
    if (targetType == TARGET_SELF)
    {
        *ppunkTargetFrame = punkThis;
    //  Set punkThis to NULL to prevent Release at exit
        punkThis = NULL;
    }
    else  // _blank, _parent, _top
    {
        hr = GetParentFrame(&punkParent);
        if (hr != S_OK) goto exitPoint;

        if (punkParent == NULL)
        {
            if (targetType == TARGET_PARENT || targetType == TARGET_TOP)
            {
                *ppunkTargetFrame = punkThis;
                //  Set punkThis to NULL to prevent Release at exit
                punkThis = NULL;
            }
            else // TARGET_BLANK
            {
                if (dwFlags & FINDFRAME_JUSTTESTEXISTENCE)
                {
                    //  It is the client's responsibility to handle "_blank"
                    hr = S_OK;
                }
                else
                {
                    //  CreateTargetFrame will not work with AOL 3.01 clients
                    //  so we must return E_FAIL

                    hr = E_FAIL;
                }
                *ppunkTargetFrame = NULL;
            }
        }
        else // punkParent != NULL
        {
            //  Handle parent ourself, defer _top and _blank to top level frame
            if (targetType == TARGET_PARENT)
            {
                *ppunkTargetFrame = punkParent;
                //  Set punkThisFrame to NULL to prevent Release at exit
                punkParent = NULL;
            }
            else
            {
                hr = punkParent->QueryInterface(IID_ITargetFramePriv, (LPVOID*)&ptgfpTargetFrame);
                if (hr != S_OK) goto exitPoint;
                hr = ptgfpTargetFrame->FindFrameInContext(pszTargetName,
                                             punkThis,
                                             dwFlags,
                                             ppunkTargetFrame);
            }
        }
    }

exitPoint:
    SAFERELEASE(punkThis);
    SAFERELEASE(punkThisFrame);
    SAFERELEASE(ptgfpTargetFrame);
    SAFERELEASE(punkParent);
    return hr;
}

HRESULT CIEFrameAuto::_GetOleObject(IOleObject** ppobj)
{
    HRESULT hres = E_UNEXPECTED;
    if (_pbs) {
        hres = _pbs->GetOleObject(ppobj);
    }

    return hres;
}

//  ITargetFrame implementation for backwards compatibility

HRESULT CIEFrameAuto::CTargetFrame::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    CIEFrameAuto* pie = IToClass(CIEFrameAuto, _TargetFrame, this);

    return pie->QueryInterface(riid, ppvObj);
}

ULONG CIEFrameAuto::CTargetFrame::AddRef(void) 
{
    CIEFrameAuto* pie = IToClass(CIEFrameAuto, _TargetFrame, this);

    return pie->AddRef();
}

ULONG CIEFrameAuto::CTargetFrame::Release(void) 
{
    CIEFrameAuto* pie = IToClass(CIEFrameAuto, _TargetFrame, this);

    return pie->Release();
}

/*******************************************************************

    NAME:       CIEFrameAuto::CTargetFrame::SetFrameName

    SYNOPSIS:   Sets the Frame Name.  Frees current one if exists.

********************************************************************/

STDMETHODIMP CIEFrameAuto::CTargetFrame::SetFrameName(LPCOLESTR pszFrameName)
{
    CIEFrameAuto* pie = IToClass(CIEFrameAuto, _TargetFrame, this);

    return pie->SetFrameName(pszFrameName);
}

    
/*******************************************************************

    NAME:       CIEFrameAuto::CTargetFrame::GetFrameName

    SYNOPSIS:   Gets the Frame Name.  Allocates a copy (this is an
    [OUT] parameter

********************************************************************/

STDMETHODIMP CIEFrameAuto::CTargetFrame::GetFrameName(WCHAR **ppszFrameName)
{
    CIEFrameAuto* pie = IToClass(CIEFrameAuto, _TargetFrame, this);

    return pie->GetFrameName(ppszFrameName);
}


/*******************************************************************

    NAME:       CIEFrameAuto::CTargetFrame::GetParentFrame

    SYNOPSIS:   Gets an the IUnknown pointer of the parent frame, or
    NULL if this is a top level frame. This pointer must be Released
    by Caller after use.

    IMPLEMENTATION:
    A Frame Container is required to implement ITargetFrame::GetParentFrame and
    implement GetParentFrame by returning the IUnknown pointer of the Browser that
    hosts it. A Browser implements GetParentFrame by returning NULL if it's
    top level or calling GetParentFrame on its Container if it is embedded.

********************************************************************/
STDMETHODIMP CIEFrameAuto::CTargetFrame::GetParentFrame(LPUNKNOWN *ppunkParentFrame)
{
    CIEFrameAuto* pie = IToClass(CIEFrameAuto, _TargetFrame, this);

    return pie->GetParentFrame(ppunkParentFrame);
}

/*******************************************************************

    NAME:       CIEFrameAuto::CTargetFrame::FindFrame

    SYNOPSIS:   Gets an the IUnknown pointer of the frame referenced
    by pszTarget. This pointer must be Released by Caller after use.
    punkContextFrame, if not NULL, is the IUnknown pointer for the immediate
    descendent frame in whose subtree the Target reference (eg anchor with a Target tag)
    resides.  dwFlags are flags which modify FindFrame's behaviour and
    can be any combination of FINDFRAME_FLAGS. In particular, SETTING
    FINDFRAME_JUSTTESTEXISTENCE allows the caller to defeat the default
    FindFrame behavior of creating a new top level frame named pszTarget,
    if pszTarget does not exist.

    IMPLEMENTATION:

    NOTE: In HTML all anchors and other TARGET tags can occur ONLY in
    leaf FRAMES!!

    punkContextFrame is significant only if pszTarget is not
    a MAGIC target name (_self, _top, _blank, _parent).

    Non-MAGIC target names:

    first off, this frame should check if it matches pszTarget and return
    it's own IUnknown pointer forthwith.

    if punkContextFrame is not NULL, all child Frames
    except punkContextFrame should be searched (depth first) for
    pszTarget with punkContextFrame == NULL.  on failure, the parent of this
    frame should be recursively called with this frame replacing punkContextFrame.
    if this is a top level Frame (so there is no parent), all top level frames
    should be called with punkContextFrame == NULL.  if this fails, then a new top level
    frame should be created (unless FINDFRAME_JUSTTESTEXISTENCE is set in
    dwFlags), named pszTarget and its IUnknown returned.

    if punkContextFrame is NULL, all child Frames should be searched
    depth first for pszTarget.  on failure, NULL should be returned.


    MAGIC target names:

    _self should return the IUnknown of this ITargetFrame
    _top should be recursively passed up to the top level ITargetFrame. if
    there is no FrameParent, this defaults to _self.
    _parent should return the IUnknown of the FrameParent ITargetFrame. if
    there is no FrameParent, this defaults to _self.
    _blank should be recursively passed up to the top level ITargetFrame,
    which should create a unnamed top level frame

********************************************************************/

STDMETHODIMP CIEFrameAuto::CTargetFrame::FindFrame(LPCOLESTR pszTargetName,
                                      LPUNKNOWN punkContextFrame,
                                      DWORD dwFlags,
                                      LPUNKNOWN *ppunkTargetFrame)
{
    CIEFrameAuto* pie = IToClass(CIEFrameAuto, _TargetFrame, this);
    
    return pie->FindFrame(pszTargetName, dwFlags|FINDFRAME_OLDINTERFACE, ppunkTargetFrame);
}

/*******************************************************************

    NAME:       CIEFrameAuto::CTargetFrame::RemoteNavigate

    SYNOPSIS:   Used in response to WM_COPYDATA message with dwData
                equal to TF_NAVIGATE.  Does a FindFrame (named
                target only) and if frame is not found returns
                S_FALSE.  If found, returns S_OK and fires off the
                navigate. cLength is number of ULONGs in pulData

    TODO:       Relies on RemoteNavigate member of top level MSHTML
                docobject host.  Need to write the equivalent code
                to work if top level frame contains some other DocObject.
                Post,etc require help from bindstatuscallback.

********************************************************************/
HRESULT CIEFrameAuto::CTargetFrame::RemoteNavigate(ULONG cLength,ULONG *pulData)
{
    //  FEATURE chrisfra 10/22/96 - this is now here purely for backwards compatibility and
    //  should be removed for ie4.0
    return E_FAIL;
}

/*******************************************************************

    NAME:       CIEFrameAuto::CTargetFrame::SetFrameSrc

    SYNOPSIS:   Sets the Frame original SRC url.  Frees current one if exists.

********************************************************************/
HRESULT CIEFrameAuto::CTargetFrame::SetFrameSrc(LPCOLESTR pszFrameSrc)
{
    CIEFrameAuto* pie = IToClass(CIEFrameAuto, _TargetFrame, this);

    return pie->SetFrameSrc(pszFrameSrc);
}
    
/*******************************************************************

    NAME:       CIEFrameAuto::CTargetFrame::GetFrameSrc

    SYNOPSIS:   Gets the Frame original URL.  Allocates a copy (this is an
    [OUT] parameter

    NOTES:      If we are at top level, SRC is dynamic, so ask our
    contained DocObject to do it for us.

********************************************************************/
HRESULT CIEFrameAuto::CTargetFrame::GetFrameSrc(WCHAR **ppszFrameSrc)
{
    CIEFrameAuto* pie = IToClass(CIEFrameAuto, _TargetFrame, this);

    return pie->GetFrameSrc(ppszFrameSrc);
}



    
/*******************************************************************

    NAME:       CIEFrameAuto::CTargetFrame::GetFramesContainer

    SYNOPSIS:   Returns an addref'ed pointer to the LPOLECONTAINER
    for our nested frames.  Can be NULL.

********************************************************************/
HRESULT CIEFrameAuto::CTargetFrame::GetFramesContainer(LPOLECONTAINER *ppContainer)
{
    CIEFrameAuto* pie = IToClass(CIEFrameAuto, _TargetFrame, this);

    return pie->GetFramesContainer(ppContainer);
}


/*******************************************************************

    NAME:       CIEFrameAuto::CTargetFrame::SetFrameOptions

    SYNOPSIS:   Sets the Frame Options.

********************************************************************/
HRESULT CIEFrameAuto::CTargetFrame::SetFrameOptions(DWORD dwFlags)
{
    CIEFrameAuto* pie = IToClass(CIEFrameAuto, _TargetFrame, this);

    return pie->SetFrameOptions(dwFlags);
}

    
/*******************************************************************

    NAME:       CIEFrameAuto::CTargetFrame::GetFrameOptions

    SYNOPSIS:   Returns the frame options

********************************************************************/

HRESULT CIEFrameAuto::CTargetFrame::GetFrameOptions(LPDWORD pdwFlags)
{
    CIEFrameAuto* pie = IToClass(CIEFrameAuto, _TargetFrame, this);

    return pie->GetFrameOptions(pdwFlags);
}


/*******************************************************************

    NAME:       CIEFrameAuto::CTargetFrame::SetFrameMargins

    SYNOPSIS:   Sets the Frame margins.

********************************************************************/
HRESULT CIEFrameAuto::CTargetFrame::SetFrameMargins(DWORD dwWidth, DWORD dwHeight)
{
    CIEFrameAuto* pie = IToClass(CIEFrameAuto, _TargetFrame, this);

    return pie->SetFrameMargins(dwWidth, dwHeight);
}

    
/*******************************************************************

  NAME:       CIEFrameAuto::CTargetFrame::GetFrameMargins

    SYNOPSIS:   Returns the frame margins

********************************************************************/

HRESULT CIEFrameAuto::CTargetFrame::GetFrameMargins(LPDWORD pdwWidth, LPDWORD pdwHeight)
{
    CIEFrameAuto* pie = IToClass(CIEFrameAuto, _TargetFrame, this);

    return pie->GetFrameMargins(pdwWidth, pdwHeight);
}


/*******************************************************************

  NAME:       CIEFrameAuto::FindBrowserByIndex

    SYNOPSIS:   Returns an IUnknown that points to a Browser that
                has the requested index

********************************************************************/

HRESULT CIEFrameAuto::FindBrowserByIndex(DWORD dwID,IUnknown **ppunkBrowser)
{
    HRESULT hr = S_OK;
    IOleContainer * poc = NULL;
    IBrowserService *pbs;
    ASSERT(ppunkBrowser);
    *ppunkBrowser = NULL;

    if (!_psb)
        return E_FAIL;

    // first check self
    if(SUCCEEDED(_psb->QueryInterface(IID_IBrowserService, (LPVOID *) &pbs)))
    {
        ASSERT(pbs);
        if(dwID == pbs->GetBrowserIndex())
        {
            //  this is the one...
            *ppunkBrowser = (IUnknown *)pbs;
            goto exitPoint;
        }
        SAFERELEASE(pbs);
    }

    hr = GetFramesContainer(&poc);

    if (SUCCEEDED(hr) && poc)
    {
        IEnumUnknown *penum = NULL;
        IUnknown *punk;

        hr = E_FAIL;
        
        if (S_OK != poc->EnumObjects(OLECONTF_EMBEDDINGS, &penum) || penum == NULL) 
            goto exitPoint;

        while (S_OK == penum->Next(1, &punk, NULL))
        {
            ITargetFramePriv *ptf;
            if (punk == NULL)
               break;

            if(SUCCEEDED(punk->QueryInterface(IID_ITargetFramePriv, (LPVOID *) &ptf)))
            {
                ASSERT(ptf);

                hr = ptf->FindBrowserByIndex(dwID, ppunkBrowser);
                SAFERELEASE(ptf);

            }

            SAFERELEASE(punk);
        
            if (SUCCEEDED(hr))  //foundit!
                break;

        }

        // Native frames - no WebBrowser OC in frame. Note that 
        // if a WebOC is included on a web page with an <OBJECT>
        // tag, navigations in the WebOC will be placed in the travel 
        // log. However, since the WebOC does not currently support 
        // ITravelLogClient, back and forward will not work correctly.
        // The WebOC will need to be updated to support ITravelLogClient.
        //        
        if (FAILED(hr))
        {
            IHTMLDocument2   * pDoc = NULL;
            IHTMLWindow2     * pWnd = NULL;
            IHTMLWindow2     * pTop = NULL;
            ITravelLogClient * ptlc = NULL;
            
            if (SUCCEEDED(poc->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc)))
            {
                if (SUCCEEDED(pDoc->get_parentWindow(&pWnd)))
                {
                    if (SUCCEEDED(pWnd->get_top(&pTop)))
                    {
                        if (SUCCEEDED(pTop->QueryInterface(IID_ITravelLogClient, (void**)&ptlc)))
                        {
                            hr = ptlc->FindWindowByIndex(dwID, ppunkBrowser);
                        }
                    }
                }
            }

            SAFERELEASE(pDoc);
            SAFERELEASE(pWnd);
            SAFERELEASE(pTop);
            SAFERELEASE(ptlc);
        }
        
        SAFERELEASE(penum);
        SAFERELEASE(poc);
    }
    else 
    {
        hr = E_FAIL;
    }

exitPoint:

    return hr;
}

//  External helper function for TRIDENT when it stands alone w/o the steely thews of
//  shdocvw CIEFrameAuto to shield it's pityfull body.
STDAPI HlinkFindFrame(LPCWSTR pszFrameName, LPUNKNOWN *ppunk)
{
    HRESULT hres = E_FAIL;

    *ppunk = NULL;
    if (pszFrameName)
    {
        switch (ParseTargetType(pszFrameName))
        {
        case TARGET_FRAMENAME:
            hres = _TargetTopLevelWindows(NULL, pszFrameName, FINDFRAME_JUSTTESTEXISTENCE, ppunk);
            break;
        case TARGET_BLANK:
            hres = S_FALSE;
            break;
        }
    }
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\tbext.h ===
///////////////////////////////////////////////////////
// File:   TBBxt.h    (Toolbar Button Extension Headers
// Author: Karim Farouki
//
// We declare here three classes:
// (1) CToolbarExt a base class that takes care of the
//     button work for our custom extensions
// (2) CToolbarExtBand the object which deals with custom
//     buttons that plug into bands
// (3) CToolbarExtExec the object which deals with custom
//     buttons (or tools menu items) that exec stuff.
//
// The latter two are derived from the former 

#ifndef _TBEXT_H
#define _TBEXT_H

#include "priv.h"

//
// Internal interface for accessing ther properties of a button/menu extension.
// This interface will likely go away afer IE5B2 when we move this functionality to
// a browser helper object.
//
typedef enum _tagGetPropertyIDs 
{
    TBEX_BUTTONTEXT     = 100,     // VT_BSTR
    TBEX_TOOLTIPTEXT    = 101,     // VT_BSTR
    TBEX_GRAYICON       = 102,     // HICON as a VT_BYREF
    TBEX_HOTICON        = 103,     // HICON as a VT_BYREF
    TBEX_GRAYICONSM     = 104,     // HICON as a VT_BYREF     
    TBEX_HOTICONSM      = 105,     // HICON as a VT_BYREF
    TBEX_DEFAULTVISIBLE = 106,     // VT_BOOL
    TMEX_MENUTEXT       = 200,     // VT_BSTR   
    TMEX_STATUSBARTEXT  = 201,     // VT_BSTR
    TMEX_CUSTOM_MENU    = 202,     // VT_BSTR
} GETPROPERTYIDS;

interface IBrowserExtension : IUnknown
{
    virtual STDMETHODIMP Init(REFGUID refguid) = 0;
    virtual STDMETHODIMP GetProperty(SHORT iPropID, VARIANTARG * varProperty) = 0;
};

class CToolbarExt : public IBrowserExtension,
                    public IOleCommandTarget,
                    public IObjectWithSite
{
public:
    // Constructor/Destructor
    CToolbarExt();
    virtual ~CToolbarExt();

    // IUnknown Interface Members
    STDMETHODIMP            QueryInterface(const IID& iid, void** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IBrowserExtension Interface Members
    STDMETHODIMP Init(REFGUID rguid);
    STDMETHODIMP GetProperty(SHORT iPropID, VARIANTARG * pvarProperty);

    // IOleCommandTarget Interface Members
    STDMETHODIMP QueryStatus(const GUID * pguidCmdGroup, ULONG  cCmds, OLECMD prgCmds[], OLECMDTEXT * pCmdText);
    STDMETHODIMP Exec(const GUID * pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANT* pvaIn, VARIANT* pvaOut) = 0;

    // IObjectWithSite Interface Members        
    STDMETHODIMP SetSite(IUnknown* pUnkSite);
    STDMETHODIMP GetSite(REFIID riid, void ** ppvSite);

protected:
    BOOL _RegGetBoolValue(LPCWSTR pszPropName, BOOL fDefault);
    BOOL _RegReadString(HKEY hkeyThisExtension, LPCWSTR szPropName, BSTR * pbstrProp, BOOL fExpand = FALSE);
    HICON _ExtractIcon(LPWSTR pszPath, int resid, int cx, int cy);
    HRESULT _GetIcon(LPCWSTR pszIcon, int nWidth, int nHeight, HICON& rhIcon, VARIANTARG * pvarProperty);

    long            _cRef;
    HICON           _hIcon;             // gray icon regular size
    HICON           _hIconSm;           // gray icon small
    HICON           _hHotIcon;          // Hot... are color versions of above
    HICON           _hHotIconSm;
    BSTR            _bstrButtonText;    // The buttons caption
    BSTR            _bstrToolTip;       // This is optional (not supported on our side yet)
    HKEY            _hkeyThisExtension; 
    HKEY            _hkeyCurrentLang;   // optional location for localized strings
    IShellBrowser*  _pisb;              // passed in by IObjectWithSite::SetSite()  Used to load band
};

class CToolbarExtBand : public CToolbarExt
{
public:
    // Constructor / Destructor
    CToolbarExtBand();
    virtual ~CToolbarExtBand();
    
    // Overridden IBrowserExtension Interface Members
    STDMETHODIMP Init(REFGUID rguid);

    // Overridden IOleCommandTarget Interface Members
    STDMETHODIMP QueryStatus(const GUID * pguidCmdGroup, ULONG  cCmds, OLECMD prgCmds[], OLECMDTEXT * pCmdText);
    STDMETHODIMP Exec(const GUID * pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANT* pvaIn, VARIANT* pvaOut);

protected:
    BOOL            _bBandState;        // This is a hack... ideally state will be determined from the browser
    BSTR            _bstrBandCLSID;     // CLSID of band to load.  Kept as BSTR because this is how it is passed
                                        // to load the band
};

class CToolbarExtExec : public CToolbarExt
{
public:
    // Constructor / Destructor
    CToolbarExtExec();
    virtual ~CToolbarExtExec();
    
    // Overridden IBrowserExtension Interface Members
    STDMETHODIMP Init(REFGUID rguid);
    STDMETHODIMP GetProperty(SHORT iPropID, VARIANTARG * pvarProperty);

    // Overridden IObjectWithSite Interface Members        
    STDMETHODIMP SetSite(IUnknown* pUnkSite);

    // Overridden IOleCommandTarget Interface Members
    STDMETHODIMP QueryStatus(const GUID * pguidCmdGroup, ULONG  cCmds, OLECMD prgCmds[], OLECMDTEXT * pCmdText);
    STDMETHODIMP Exec(const GUID * pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANT* pvaIn, VARIANT* pvaOut);

protected:
    BOOL            _bButton;           // Does this object support being a button?
    BOOL            _bMenuItem;         // Does it support being a menu item?
    BOOL            _bExecCalled;       // if Exec was called
    BSTR            _bstrExec;          // Thing to ShellExecute
    BSTR            _bstrScript;        // Script to Execute
    BSTR            _bstrMenuText;
    BSTR            _bstrMenuCustomize; // the menu that is to be customized
    BSTR            _bstrMenuStatusBar;
    IUnknown*       _punkExt;           // (Optional) created when button is first pressed
};

#endif // _TBEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\thicket.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       thicket.hxx
//
//  Contents:   Save as Office9 'Thicket' format API
//
//----------------------------------------------------------------------------

#ifndef _THICKET_HXX_
#define _THICKET_HXX_

void SaveBrowserFile( HWND hwnd, LPUNKNOWN punk );

#endif // _THICKET_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\thicket.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994
//
//  File:       persist.cxx
//
//  Contents:   Implmentation of Office9 Thicket Save API
//
//----------------------------------------------------------------------------
#include "priv.h"

//#include "headers.hxx"
//#include "formkrnl.hxx"
#include <platform.h>
#include <mlang.h>
#include "resource.h"
#include "impexp.h"
#include "reload.h"
//#include <siterc.h>
#include "packager.h"
#include "iehelpid.h"
#include "thicket.h"
#include "apithk.h"

#include <mluisupp.h>
#include <mshtmcid.h>

#define NUM_OLE_CMDS                          1

#define SAVEAS_OK                             0x00000001
#define SAVEAS_NEVER_ASK_AGAIN                0x00000002

#define CODEPAGE_UNICODE                      0x000004B0
#define CODEPAGE_UTF8                         0x0000FDE9
#define UNICODE_TEXT                          TEXT("Unicode")

#define REGSTR_VAL_SAVEDIRECTORY              TEXT("Save Directory")
#define REGKEY_SAVEAS_WARNING_RESTRICTION     TEXT("SOFTWARE\\Microsoft\\Internet Explorer\\Main")
#define REGVALUE_SAVEAS_WARNING               TEXT("NoSaveAsPOSTWarning")

#define WM_WORKER_THREAD_COMPLETED            WM_USER + 1000

#define MAX_ENCODING_DESC_LEN                 1024


const static DWORD aSaveAsHelpIDs[] =
{
    IDC_SAVE_CHARSET,   IDH_CHAR_SET_SAVE_AS,
    0,                  0
};

INT_PTR CALLBACK SaveAsWarningDlgProc(HWND hDlg, UINT msg, WPARAM wParam,
                                      LPARAM lParam);

HRESULT SaveToThicket( HWND hwnd, LPCTSTR pszFileName, IHTMLDocument2 *pDoc,
                       UINT codepageSrc, UINT codepageDst,
                       UINT iPackageStyle );

HRESULT
FormsGetFileName(
        HWND hwndOwner,
        LPTSTR pstrFile,
        int cchFile,
        LPARAM lCustData,
        DWORD *pnFilterIndex,
        BOOL bForceHTMLOnly);
HRESULT
GetFileNameFromURL( LPWSTR pwszURL, LPTSTR pszFile, DWORD cchFile);

void ReportThicketError( HWND hwnd, HRESULT hr );

#define DOWNLOAD_PROGRESS  0x9001
#define DOWNLOAD_COMPLETE  0x9002
#define THICKET_TIMER      0x9003
#define THICKET_INTERVAL   1000

#define MDLGMSG(psz, x)         TraceMsg(0, "shd TR-MODELESS::%s %x", psz, x)

static DWORD s_dwInetComVerMS = 0;
static DWORD s_dwInetComVerLS = 0;

struct ThicketCPInfo
{
    UINT    cpSrc;
    UINT    cpDst;
    LPWSTR lpwstrDocCharSet;
};

class CThicketUI
{
public:
    CThicketUI(void) :
        _hDlg(NULL),
        _hWndProg(NULL),
        _iErrorDL(0),
        _hrDL(E_FAIL),
#ifndef NO_MARSHALLING
        _pstmDoc(NULL),
#else
        _pDoc(NULL),
#endif
        _pszFileName(NULL),
        _dwDLMax(0),
        _codepageSrc(0),
        _codepageDst(0),
        _iPackageStyle(PACKAGE_THICKET),
        _fCancel(FALSE) {};

    ~CThicketUI(void) 
    { 
#ifndef NO_MARSHALLING
        SAFERELEASE(_pstmDoc);
#endif
        SAFELOCALFREE(_pszFileName); 
    };

    // CThicketUI methods
    HRESULT SaveDocument( HWND hWnd, LPCTSTR pszFileName, IHTMLDocument2 *pDoc,
                          UINT codepageSrc, UINT codepageDst,
                          UINT iPackageStyle );

protected:
    static BOOL_PTR ThicketUIDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    static DWORD WINAPI ThicketUIThreadProc( LPVOID );

    BOOL DlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);

    HWND                _hDlg;
    HWND                _hWndProg;
    int                 _iErrorDL;
    HRESULT             _hrDL;
#ifndef UNIX
    IStream             *_pstmDoc;      // marshalled IHTMLDocument2
#else
    IHTMLDocument2      *_pDoc;
#endif
    LPTSTR              _pszFileName;
    DWORD               _dwDLMax;
    UINT                _codepageSrc;
    UINT                _codepageDst;
    BOOL                _fThreadStarted;
    UINT                _iPackageStyle;
    BOOL                _fCancel;
};

HRESULT
CThicketUI::SaveDocument( HWND hWnd, LPCTSTR pszFileName, IHTMLDocument2 *pDoc,
                          UINT codepageSrc, UINT codepageDst,
                          UINT iPackageStyle)
{
    _pszFileName = StrDup(pszFileName);
    _codepageSrc = codepageSrc;
    _codepageDst = codepageDst;
    _iPackageStyle = iPackageStyle;

#ifndef NO_MARSHALLING
    // We don't do anything with pDoc until we're on the worker thread,
    // so marshall it.
    _hrDL = CoMarshalInterThreadInterfaceInStream(IID_IHTMLDocument2, pDoc, &_pstmDoc);

    if (SUCCEEDED(_hrDL))
#else
    _pDoc = pDoc;
#endif
    {
        // Needs to be modal cuz we're going to work with pDoc on the worker thread
        // so we don't want the user to navigate away from it, close the window, etc.
        DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_SAVETHICKET),
                         hWnd, CThicketUI::ThicketUIDlgProc, (LPARAM)this);

     //   HWND hwnd = MLCreateDialogParamWrap(MLGetHinst(), MAKEINTRESOURCE(IDD_SAVETHICKET),
     //                                 NULL, CThicketUI::ThicketUIDlgProc, (LPARAM)this);
     //   if (!hwnd)
     //       _hrDL = E_FAIL;
    }

    return _hrDL;
}

BOOL_PTR
CThicketUI::ThicketUIDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL        fRet = FALSE;
    CThicketUI* ptui = NULL;

    if (msg == WM_INITDIALOG)
    {
        ptui = (CThicketUI*)lParam;
    }
    else
        ptui = (CThicketUI*)GetWindowLongPtr(hDlg, DWLP_USER);

    if (ptui)
    {
        fRet = ptui->DlgProc(hDlg, msg, wParam, lParam);

        if (msg == WM_DESTROY || msg == WM_WORKER_THREAD_COMPLETED)
        {
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
            fRet = TRUE;
        }
    }

    return fRet;
}

BOOL
CThicketUI::DlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet = TRUE;

    switch (msg)
    {
    case WM_INITDIALOG:
        _hDlg = hDlg;
        _hWndProg = GetDlgItem(hDlg, IDC_THICKETPROGRESS);
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);

        _hrDL = S_FALSE;

#ifndef NO_MARSHALLING
        //_hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ThicketUIThreadProc, this, 0, &_idThread);
        if (!(_fThreadStarted = SHQueueUserWorkItem(ThicketUIThreadProc,
                                                    this,
                                                    0,
                                                    (DWORD_PTR)NULL,
                                                    (DWORD_PTR *)NULL,
                                                    "shdocvw.dll",
                                                    TPS_LONGEXECTIME)))
            _hrDL = E_FAIL;
#else
        ThicketUIThreadProc((LPVOID)this);
#endif

        if (FAILED(_hrDL))
             EndDialog(hDlg, 0);
        else
        {
            ShowWindow(hDlg, SW_SHOWNORMAL);
            Animate_OpenEx(GetDlgItem(hDlg, IDD_ANIMATE), HINST_THISDLL, IDA_DOWNLOAD);
            ShowWindow(GetDlgItem(hDlg, IDD_DOWNLOADICON), SW_HIDE);
        }
        fRet = FALSE;
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDCANCEL:
            _fCancel = TRUE;
            // and wait for the worker thread to quit, polling at WM_TIMER
            break;

        default:
            break;
        }
        break;

    case WM_WORKER_THREAD_COMPLETED:
        _hrDL = (DWORD) wParam;
        EndDialog(hDlg,0);
        break;

    //case WM_CLOSE:
    //    KillTimer( hDlg, THICKET_TIMER );
    //    _fCancel = TRUE;
    //    while( _hrDL == S_FALSE );
    //    break;

    case WM_DESTROY:
        _fCancel = TRUE;
        while( _hrDL == S_FALSE )
        {
            Sleep(0);
        }
        break;

    default:
        fRet = FALSE;
    }

    return fRet;
}

DWORD WINAPI CThicketUI::ThicketUIThreadProc( LPVOID ppv )
{
    HRESULT hr = S_OK;
    CThicketUI* ptui = (CThicketUI *)ppv;

    ASSERT(ptui);

    hr = CoInitialize(NULL);
    if (SUCCEEDED(hr))
    {
        IHTMLDocument2 *pDoc = NULL;

#ifndef NO_MARSHALLING
        hr = CoGetInterfaceAndReleaseStream( ptui->_pstmDoc, IID_IHTMLDocument2,(LPVOID*)&pDoc);

        // CoGetInterfaceAndReleaseStream always releases the stream
        ptui->_pstmDoc = NULL;
#else
        pDoc = ptui->_pDoc;
        pDoc->AddRef();
#endif

        if (SUCCEEDED(hr))
        {
            CThicketProgress    tprog( ptui->_hDlg );
            CDocumentPackager   docPkgr(ptui->_iPackageStyle);

            hr = S_FALSE;

            hr = docPkgr.PackageDocument( pDoc, ptui->_pszFileName,
                          &ptui->_fCancel, &tprog,
                          0, 100,
                          ptui->_codepageDst );

            pDoc->Release(); // release marshalled interface
        }

        CoUninitialize();
    }

    PostMessage(ptui->_hDlg, WM_WORKER_THREAD_COMPLETED, hr, 0);

    return 0;
}


//+------------------------------------------------------------------------
//
//
//
//-------------------------------------------------------------------------
HRESULT
SaveToThicket( HWND hWnd, LPCTSTR pszFileName, IHTMLDocument2 *pDoc,
               UINT codepageSrc, UINT codepageDst, UINT iPackageStyle )
{
    HRESULT     hr;
    CThicketUI* ptui;

#ifdef OLD_THICKET
    LPTSTR      lpszURL;

    lpszURL = bstrDocURL;

    const   DWORD       dwMaxPathLen        = 24;

    URL_COMPONENTS urlComp;
    TCHAR   rgchUrlPath[MAX_PATH];
    TCHAR   rgchCanonicalUrl[MAX_URL_STRING];
    DWORD   dwLen;

    dwLen = ARRAYSIZE(rgchCanonicalUrl);

    hr = UrlCanonicalize( lpszURL, rgchCanonicalUrl, &dwLen, 0);
    if (FAILED(hr))
        return E_FAIL;

    ZeroMemory(&urlComp, sizeof(urlComp));

    urlComp.dwStructSize = sizeof(urlComp);
    urlComp.lpszUrlPath = rgchUrlPath;
    urlComp.dwUrlPathLength = ARRAYSIZE(rgchUrlPath);

    hr = InternetCrackUrl(rgchCanonicalUrl, lstrlen(rgchCanonicalUrl), ICU_DECODE, &urlComp);
    if (FAILED(hr))
        return E_FAIL;

    // Since this is not a snap-shot, saving the doc over itself is a no-op.
    // This means we can avoid some nasty issues with the save-over, safe-save,
    // et al, by short circuiting the save here.
    if ( StrCmpI(pszFileName, rgchUrlPath) == 0 )
    {
        if (PathFileExists(pszFileName))
            return S_OK;
        else
            return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

#endif //OLD_THICKET

    ptui = new CThicketUI;
    if (ptui)
    {
        hr = ptui->SaveDocument( hWnd, pszFileName, pDoc, codepageSrc, codepageDst, iPackageStyle );
        delete ptui;
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

//+------------------------------------------------------------------------
//
//
//
//-------------------------------------------------------------------------

void SaveBrowserFile( HWND hwnd, LPUNKNOWN punk )
{
    HRESULT         hr;
    TCHAR           szFileDst[MAX_PATH];
    DWORD           iFilter = 1;
    IHTMLDocument2  *pDoc;
    BSTR            bstrURL = NULL;
    ThicketCPInfo   tcpi;
    BSTR            bstrCharSet = NULL;
    BSTR            bstrTitle = NULL;
    BSTR            bstrMime = NULL;
    IOleCommandTarget *pOleCommandTarget = NULL;
    WCHAR          *pwzExt = NULL;
    OLECMD          pCmd[NUM_OLE_CMDS];
    ULONG           nCmds = NUM_OLE_CMDS;
    BOOL            bForceHTMLOnly = FALSE;

    static const WCHAR *wzImage = L" Image";
    

    hr = punk->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc);
    if (FAILED(hr))
        goto Cleanup;

    if (FAILED(pDoc->get_URL( &bstrURL )))
        goto Cleanup;

    hr = pDoc->get_charset( &bstrCharSet );
    if (FAILED(hr))
        goto Cleanup;

    tcpi.cpSrc = CP_ACP;
    tcpi.lpwstrDocCharSet = bstrCharSet;

    // If it is an image file, then bring up trident to do the save.
    // APPCOMPAT: This is a crappy way to do this. We are hard-coding the
    // image types, so we know to put up the "Save as image" dialog.
    // We originally tried looking at the MIME type, but Trident returns
    // inconsistent MIME types to us (ex. under some platforms we get
    // "JPG Image" and under others we get "JPG File"!).

    ASSERT(bstrURL);

    pwzExt = bstrURL + lstrlenW(bstrURL);

    while (pwzExt > bstrURL && *pwzExt != L'.')
    {
        pwzExt--;
    }

    hr = pDoc->QueryInterface(IID_IOleCommandTarget,
                              (void **)&pOleCommandTarget);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    if (pwzExt > bstrURL) {

        // Found a "dot". Now pwzExt points to what we think is the extension

        if (!StrCmpIW(pwzExt, L".JPG") ||
            !StrCmpIW(pwzExt, L".GIF") ||
            !StrCmpIW(pwzExt, L".BMP") ||
            !StrCmpIW(pwzExt, L".XBM") ||
            !StrCmpIW(pwzExt, L".ART") ||
            !StrCmpIW(pwzExt, L".PNG") ||
            !StrCmpIW(pwzExt, L".WMF") ||
            !StrCmpIW(pwzExt, L".TIFF") ||
            !StrCmpIW(pwzExt, L".JPEG"))
        {
            hr = pOleCommandTarget->Exec(&CGID_MSHTML, IDM_SAVEPICTURE, 0,
                                         NULL, NULL);

            // FEATURE: Handle a failed HR here. It is very unlikely that
            // this will fail, yet regular save-as code (that follows)
            // will succeed. We always exit out of here, so we will
            // never get two UI dialogs thrown at the user. We should
            // come up with a good scheme to propagate an error dialog
            // to the user. Possible scenario: low disk space causing
            // a fail-out.

            goto Cleanup;
        }
    }

    // IE5 RAID #54672: Save-as has problems saving pages generated by POSTs
    // This code is to detect if the page was generated by POST data and
    // warn the user that saving may not work.

    pCmd[0].cmdID = SHDVID_PAGEFROMPOSTDATA;
    hr = pOleCommandTarget->QueryStatus(&CGID_ShellDocView, nCmds, pCmd, NULL);

    if (FAILED(hr))
    {
        goto Cleanup;
    }

    if (pCmd[0].cmdf & OLECMDF_LATCHED)
    {
        HKEY         hkeySaveAs = 0;
        DWORD        dwValue = 0;
        DWORD        dwSize = 0;
        INT_PTR      iFlags = 0;

        bForceHTMLOnly = TRUE;

        if (RegOpenKeyEx(HKEY_CURRENT_USER,
                         REGKEY_SAVEAS_WARNING_RESTRICTION, 0,
                         KEY_READ, &hkeySaveAs) == ERROR_SUCCESS)
        {
            dwSize = sizeof(DWORD);

            if (RegQueryValueEx(hkeySaveAs, REGVALUE_SAVEAS_WARNING, NULL,
                                NULL, (LPBYTE)&dwValue, &dwSize) == ERROR_SUCCESS)
            {

                if (dwValue)
                {
                    // restriction set, don't show dialog
                    RegCloseKey(hkeySaveAs);
                    goto Continue;
                }
            }

            RegCloseKey(hkeySaveAs);
        }

        iFlags = DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(DLG_SAVEAS_WARNING),
                                hwnd, SaveAsWarningDlgProc, (LPARAM)0);

        if (!(iFlags & SAVEAS_OK))
        {
            goto Cleanup;
        }
        
        if (iFlags & SAVEAS_NEVER_ASK_AGAIN)
        {
            HKEY                 hkey = 0;
            DWORD                dwNeverAsk = 1;

            if (RegOpenKeyEx(HKEY_CURRENT_USER,
                             REGKEY_SAVEAS_WARNING_RESTRICTION, 0,
                             KEY_ALL_ACCESS, &hkey) == ERROR_SUCCESS)
            {

                RegSetValueEx(hkey, REGVALUE_SAVEAS_WARNING, 0, REG_DWORD,
                              (CONST BYTE *)&dwNeverAsk,
                              sizeof(dwNeverAsk));
                RegCloseKey(hkey);
            }
        }
    }
    
Continue:

    // Suggest a file name
    
    szFileDst[0] = 0;

    // Our favorite candidate is the title,  fall back on the file name.
    hr = pDoc->get_title(&bstrTitle);
    if (SUCCEEDED(hr) && lstrlenW(bstrTitle))
    {
        StrCpyN(szFileDst, bstrTitle, ARRAYSIZE(szFileDst));
    }
    else
        hr = GetFileNameFromURL(bstrURL, szFileDst, ARRAYSIZE(szFileDst));

    if (FAILED(hr))
        goto Cleanup;

    PathCleanupSpec(NULL, szFileDst);

    hr = FormsGetFileName(hwnd, szFileDst, ARRAYSIZE(szFileDst),
                          (LONG_PTR)&tcpi, &iFilter, bForceHTMLOnly);

    if (hr==S_OK)
        hr = SaveToThicket( hwnd, szFileDst, pDoc, tcpi.cpSrc, tcpi.cpDst, iFilter);

Cleanup:

    if (FAILED(hr))
        ReportThicketError(hwnd, hr);

    if (pOleCommandTarget)
        pOleCommandTarget->Release();

    if (pDoc)
        pDoc->Release();

    if (bstrURL)
        SysFreeString(bstrURL);

    if (bstrCharSet)
        SysFreeString(bstrCharSet);

    if (bstrTitle)
        SysFreeString(bstrTitle);

    return;
}

void ReportThicketError( HWND hwnd, HRESULT hr )
{
    LPTSTR lpstrMsg = NULL;

    switch (hr)
    {
    case HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY):
    case E_OUTOFMEMORY:
        lpstrMsg = MAKEINTRESOURCE(IDS_THICKETERRMEM);
        break;

    case E_ACCESSDENIED:
    case STG_E_ACCESSDENIED:
        lpstrMsg = MAKEINTRESOURCE(IDS_THICKETERRACC);
        break;

    case HRESULT_FROM_WIN32(ERROR_DISK_FULL):
    case STG_E_MEDIUMFULL:
        lpstrMsg = MAKEINTRESOURCE(IDS_THICKETERRFULL);
        break;

    case HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
        lpstrMsg = MAKEINTRESOURCE(IDS_THICKETERRFNF);
        break;

    case E_ABORT:
        // Ray says we don't want a canceled message box.
        //lpstrMsg = MAKEINTRESOURCE(IDS_THICKETABORT);
        break;

    case E_FAIL:
    default:
        lpstrMsg = MAKEINTRESOURCE(IDS_THICKETERRMISC);
        break;
    }

    if ( lpstrMsg )
    {
        MLShellMessageBox(
                        hwnd,
                        lpstrMsg,
                        MAKEINTRESOURCE(IDS_THICKETERRTITLE),
                        MB_OK | MB_ICONERROR);
    }
}

//+--------------------------------------------------------------------------
//
//  File:       file.cxx
//
//  Contents:   Import/export dialog helpers
//
//  History:    16-May-95   RobBear     Taken from formtool
//
//---------------------------------------------------------------------------

const CHAR c_szNT4ResourceLocale[]      = ".DEFAULT\\Control Panel\\International";
const CHAR c_szWin9xResourceLocale[]    = ".Default\\Control Panel\\desktop\\ResourceLocale";
const CHAR c_szLocale[]                 = "Locale";

LANGID
MLGetShellLanguage()
{
    LANGID  lidShell = 0;

    // FEATURE: this fn is copied from shlwapi. there really should be a
    // shlwapi export. if MLGetUILanguage has any merit, then
    // MLGetShellLanguage has merit as well.

    if (IsOS(OS_WIN2000ORGREATER))
    {
        static LANGID (CALLBACK* pfnGetUserDefaultUILanguage)(void) = NULL;

        if (pfnGetUserDefaultUILanguage == NULL)
        {
            HMODULE hmod = GetModuleHandle(TEXT("KERNEL32"));

            if (hmod)
                pfnGetUserDefaultUILanguage = (LANGID (CALLBACK*)(void))GetProcAddress(hmod, "GetUserDefaultUILanguage");
        }
        if (pfnGetUserDefaultUILanguage)
            lidShell = pfnGetUserDefaultUILanguage();
    }
    else
    {
        CHAR szLangID[12];
        DWORD cb, dwRet;

        cb = sizeof(szLangID) - 2*sizeof(szLangID[0]);  // avoid 2 byte buffer overrun
        if (IsOS(OS_NT))
            dwRet = SHGetValueA(HKEY_USERS, c_szNT4ResourceLocale, c_szLocale, NULL, szLangID + 2, &cb);
        else
            dwRet = SHGetValueA(HKEY_USERS, c_szWin9xResourceLocale, NULL, NULL, szLangID + 2, &cb);

        if (ERROR_SUCCESS == dwRet)
        {
            // IE uses a string rep of the hex value
            szLangID[0] = '0';
            szLangID[1] = 'x';
            StrToIntExA(szLangID, STIF_SUPPORT_HEX, (LPINT)&lidShell);
        }
    }

    return lidShell;
}

/*
 *  Stolen from Trident's src\core\cdutil\file.cxx
 */

// Hook procedure for open file dialog.

UINT_PTR APIENTRY SaveOFNHookProc(HWND hdlg,
                                  UINT uiMsg,
                                  WPARAM wParam,
                                  LPARAM lParam)
{
    ULONG i, iCurSel;
    BOOL  bFoundEncoding = FALSE;
    WCHAR wzEncoding[MAX_ENCODING_DESC_LEN];

    switch (uiMsg)
    {
        // Populate the dropdown.
        case WM_INITDIALOG:
        {
            HRESULT hr;
            LPOPENFILENAME pofn = (LPOPENFILENAME)lParam;
            ThicketCPInfo *ptcpi = (ThicketCPInfo *)pofn->lCustData;
            IMultiLanguage2 *pMultiLanguage = NULL;
            IEnumCodePage  *pEnumCodePage = NULL;
            //UINT            codepageDefault = ptcpi->cp;
            MIMECSETINFO    csetInfo;
            LANGID          langid;

#ifdef UNIX
            SetWindowLongPtr(hdlg, DWLP_USER, (LONG_PTR)ptcpi);
#endif /* UNIX */

            hr = CoCreateInstance(
                    CLSID_CMultiLanguage,
                    NULL,
                    CLSCTX_INPROC_SERVER,
                    IID_IMultiLanguage2,
                    (void**)&pMultiLanguage);
            if (hr)
                break;

            hr = pMultiLanguage->GetCharsetInfo(ptcpi->lpwstrDocCharSet,&csetInfo);
            if (hr)
                break;

#ifndef UNIX
            // the shell combobox where this stuff shows up
            // doesn't know how to fontlink... so we have
            // to stay in the shell's codepage
            langid = MLGetShellLanguage();
#else
            langid = GetSystemDefaultLangID();
#endif /* UNIX */
            if (pMultiLanguage->EnumCodePages( MIMECONTF_SAVABLE_BROWSER | MIMECONTF_VALID,
                                               langid,
                                               &pEnumCodePage) == S_OK)
            {
                MIMECPINFO cpInfo;
                ULONG      ccpInfo;
                UINT       cpDefault;

                if (pMultiLanguage->GetCodePageInfo(csetInfo.uiInternetEncoding, langid, &cpInfo) == S_OK &&
                    !(cpInfo.dwFlags & MIMECONTF_SAVABLE_BROWSER))
                {
                    // If the codepage selected is not savable (eg JP_AUTO),
                    // use the family codepage.
                    cpDefault = cpInfo.uiFamilyCodePage;
                }
                else
                    cpDefault = csetInfo.uiInternetEncoding;

                ptcpi->cpSrc = csetInfo.uiInternetEncoding;

                if (cpDefault == CODEPAGE_UNICODE &&
                    pofn->nFilterIndex == PACKAGE_MHTML) {
                    cpDefault = CODEPAGE_UTF8;
                }

                for (i = 0; pEnumCodePage->Next(1, &cpInfo, &ccpInfo) == S_OK; ++i)
                {
                    TCHAR *lpszDesc;
                    INT_PTR iIdx;

                    if (cpInfo.uiCodePage == CODEPAGE_UNICODE &&
                        pofn->nFilterIndex == PACKAGE_MHTML) {
                        i--;
                        continue;
                    }

                    if (cpDefault == cpInfo.uiCodePage)
                    {
                       StrCpyNW(wzEncoding, cpInfo.wszDescription,
                                lstrlen(cpInfo.wszDescription) + 1);
                       bFoundEncoding = TRUE;
                    }

                    lpszDesc = cpInfo.wszDescription;

                    iIdx = SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET,
                                              CB_ADDSTRING, 0,
                                              (LPARAM)lpszDesc);
                    SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET,
                                       CB_SETITEMDATA, iIdx,
                                       (LPARAM)cpInfo.uiCodePage);
                }

                if (bFoundEncoding)
                {
                    INT_PTR iIndex = 0;

                    iIndex = SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET,
                                                CB_FINDSTRINGEXACT, -1,
                                                (LPARAM)wzEncoding);

                    SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET, CB_SETCURSEL,
                                       (WPARAM)iIndex, 0);
                }
                else
                {
                    // No encoding found! Bad error. Recover by selecting
                    // the first one.

                    SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET, CB_SETCURSEL,
                                       0, 0);
                }

            }
            SAFERELEASE(pEnumCodePage);
            SAFERELEASE(pMultiLanguage);
            break;
        }

#ifdef UNIX
        case WM_COMMAND:
        {
          switch (GET_WM_COMMAND_ID(wParam,lParam))
          {
            case IDOK:
            {
                 ThicketCPInfo *ptcpi = (ThicketCPInfo *)GetWindowLongPtr(hdlg,DWLP_USER);

                 ptcpi->cpDst = CP_ACP;
                 iCurSel = (int) SendDlgItemMessage (hdlg, IDC_SAVE_CHARSET, CB_GETCURSEL, 0, 0);
                 ptcpi->cpDst =
                 (UINT)SendDlgItemMessage (hdlg, IDC_SAVE_CHARSET, CB_GETITEMDATA,
                 (WPARAM)iCurSel, (LPARAM)0);

                 // To spare us from re-instantiating MLANG, we'll set the src and dest
                 // to CP_ACP if no change is indicated.
                 if (ptcpi->cpDst == ptcpi->cpSrc)
                    ptcpi->cpDst = ptcpi->cpSrc = CP_ACP;
           }
           break;
         }
        }
        break;
#endif /* UNIX */

        case WM_NOTIFY:
        {
            LPOFNOTIFY phdr = (LPOFNOTIFY)lParam;

            switch (phdr->hdr.code)
            {
                case CDN_FILEOK:
                {
                    LPOPENFILENAME pofn = (LPOPENFILENAME)phdr->lpOFN;
                    ThicketCPInfo *ptcpi = (ThicketCPInfo *)pofn->lCustData;

                    iCurSel = (int) SendDlgItemMessage (hdlg, IDC_SAVE_CHARSET, CB_GETCURSEL, 0, 0);
                    ptcpi->cpDst = //*(UINT *)phdr->lpOFN->lCustData =
                        (UINT)SendDlgItemMessage (hdlg, IDC_SAVE_CHARSET, CB_GETITEMDATA,
                                             (WPARAM)iCurSel, (LPARAM)0);
                }

                // HACK! This case is implemented to implement a hack for
                // IE5 RAID #60672. MIMEOLE cannot save UNICODE encoding,
                // so when the user selects MHTML saves, we should remove
                // this option.  This code should be removed when MIMEOLE
                // fixes their bug (targeted for NT5 RTM). Contact SBailey
                // for the status of this.

                case CDN_TYPECHANGE:
                {
                    LPOPENFILENAME pofn = (LPOPENFILENAME)phdr->lpOFN;
                    ThicketCPInfo *ptcpi = (ThicketCPInfo *)pofn->lCustData;
                    UINT uiCPSel, uiCP;
                    int iType = pofn->nFilterIndex;
                    UINT iCount;
                    int iCurSel;
                    int iSet = -1;

                    if (iType == PACKAGE_MHTML)
                    {
                        iCurSel = (int)SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET, CB_GETCURSEL, 0, 0);

                        uiCPSel = (UINT)SendDlgItemMessage (hdlg, IDC_SAVE_CHARSET, CB_GETITEMDATA,
                                             (WPARAM)iCurSel, (LPARAM)0);
                         
                        // If you selected unicode, make it look like you
                        // really selected UTF-8

                        if (uiCPSel == CODEPAGE_UNICODE)
                        {
                            uiCPSel = CODEPAGE_UTF8;
                        }

                        i = (int) SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET,
                                                     CB_FINDSTRINGEXACT,
                                                     (WPARAM)0,
                                                     (LPARAM)UNICODE_TEXT);
                        if (i != CB_ERR)
                        {
                            SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET,
                                               CB_DELETESTRING, i, (LPARAM)0);
                        }

                        iCount = (int)SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET,
                                                         CB_GETCOUNT, 0, 0);

                        // Set selected item back

                        for (i = 0; i < iCount; i++)
                        {
                            uiCP = (UINT)SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET, CB_GETITEMDATA,
                                                            (WPARAM)i, (LPARAM)0);
                            if (uiCP == uiCPSel)
                            {
                                iSet = i;
                            }
                        }

                        if (iSet != 0xffffffff)
                        {
                            SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET, CB_SETCURSEL,
                                               (WPARAM)iSet, (LPARAM)0);
                        }
                    }
                    else
                    {
                        // Store current selection

                        iCurSel = (int)SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET, CB_GETCURSEL, 0, 0);

                        uiCPSel = (UINT)SendDlgItemMessage (hdlg, IDC_SAVE_CHARSET, CB_GETITEMDATA,
                                             (WPARAM)iCurSel, (LPARAM)0);

                        // Add unicode back in, if it was removed

                        i = (int) SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET,
                                                     CB_FINDSTRINGEXACT,
                                                     (WPARAM)0,
                                                     (LPARAM)UNICODE_TEXT);

                        if (i == CB_ERR) {
                            // Unicode does not exist, add it back in
                            i = (int) SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET,
                                                         CB_ADDSTRING, 0,
                                                         (LPARAM)UNICODE_TEXT);
    
                            SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET,
                                               CB_SETITEMDATA, i,
                                               (LPARAM)CODEPAGE_UNICODE);

    
                            // Make sure the same encoding selected before is
                            // still selected.
                            iCount = (int)SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET,
                                                             CB_GETCOUNT, 0, 0);
                            for (i = 0; i < iCount; i++)
                            {
                                uiCP = (UINT)SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET, CB_GETITEMDATA,
                                                                (WPARAM)i, (LPARAM)0);
                                if (uiCP == uiCPSel)
                                {
                                    iSet = i;
                                }
                            }
    
                            if (iCurSel != 0xffffffff)
                            {
                                SendDlgItemMessage(hdlg, IDC_SAVE_CHARSET, CB_SETCURSEL,
                                                   (WPARAM)iSet, (LPARAM)0);
                            }
                        }

                    }

                }
                break;
            }
        }
        break;

        case WM_HELP:
        {
            SHWinHelpOnDemandWrap((HWND)((LPHELPINFO) lParam)->hItemHandle,
                          c_szHelpFile,
                          HELP_WM_HELP,
                          (DWORD_PTR)aSaveAsHelpIDs);
        }
        break;

        case WM_CONTEXTMENU:
        {
            SHWinHelpOnDemandWrap((HWND) wParam,
                          c_szHelpFile, 
                          HELP_CONTEXTMENU,
                          (DWORD_PTR)aSaveAsHelpIDs);
        }
        break;
    }
    return (FALSE);
}

//
// Protect the naive users from themselves, if somebody enters a filename
// of microsoft.com when saving http://www.microsoft.com we don't want
// to save a .COM file since this will be interpreted as an executable.
// bad things will happen
//
void CleanUpFilename(LPTSTR pszFile, int iPackageStyle)
{
    //
    // If we find .COM as the file extension replace it with the file extension
    // of the filetype they are saving the file as
    //
    LPTSTR pszExt = PathFindExtension(pszFile);

    ASSERT(pszExt);
    if (StrCmpI(pszExt, TEXT(".COM")) == 0) // REVIEW any other file types???
    {
        //
        // Map the package style to a default extension. NOTE this relies on 
        // the fact that the filter index maps to the PACKAGE style enum
        // (as does the rest of the thicket code).
        //
        switch (iPackageStyle)
        {
        case PACKAGE_THICKET:
        case PACKAGE_HTML:
            StrCatBuff(pszFile, TEXT(".htm"), MAX_PATH); 
            break;

        case PACKAGE_MHTML:
            StrCatBuff(pszFile, TEXT(".mht"), MAX_PATH); 
            break;

        case PACKAGE_TEXT:
            StrCatBuff(pszFile, TEXT(".txt"), MAX_PATH); 
            break;

        default:
            ASSERT(FALSE);  // Unknown package type
            break;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   FormsGetFileName
//
//  Synopsis:   Gets a file name using either the GetOpenFileName or
//              GetSaveFileName functions.
//
//  Arguments:  [fSaveFile]   -- TRUE means use GetSaveFileName
//                               FALSE means use GetOpenFileName
//
//              [idFilterRes] -- The string resource specifying text in the
//                                  dialog box.  It must have the
//                                  following format:
//                            Note: the string has to be _one_ contiguous string.
//                                  The example is broken up to make it fit
//                                  on-screen. The verical bar ("pipe") characters
//                                  are changed to '\0'-s on the fly.
//                                  This allows the strings to be localized
//                                  using Espresso.
//
//          IDS_FILENAMERESOURCE, "Save Dialog As|         // the title
//                                 odg|                    // default extension
//                                 Forms3 Dialog (*.odg)|  // pairs of filter strings
//                                 *.odg|
//                                 Any File (*.*)|
//                                 *.*|"
//
//              [pstrFile]    -- Buffer for file name.
//              [cchFile]     -- Size of buffer in characters.
//
//  Modifies:   [pstrFile]
//
//----------------------------------------------------------------------------
#ifdef _MAC
extern "C" {
char * __cdecl _p2cstr(unsigned char *);
}
#endif

#define CHAR_DOT                TEXT('.')
#define CHAR_DOT_REPLACEMENT    TEXT('_')

void ReplaceDotsInFileName(LPTSTR pszFileName)
{
    ASSERT(pszFileName);

    while (*pszFileName)
    {
        if (*pszFileName == CHAR_DOT)
        {
            *pszFileName = CHAR_DOT_REPLACEMENT;
        }
        pszFileName++;
    }
}


HRESULT
FormsGetFileName(
        HWND hwndOwner,
        LPTSTR pstrFile,
        int cchFile,
        LPARAM lCustData,
        DWORD *pnFilterIndex,
        BOOL bForceHTMLOnly)
{
    HRESULT         hr  = S_OK;
    BOOL            fOK;
    DWORD           dwCommDlgErr;
    LPTSTR          pstr;
    OPENFILENAME    ofn;
    TCHAR           achBuffer[4096];    //  Max. size of a string resource
    TCHAR *         cp;
    TCHAR *         pstrExt;
    int             cbBuffer;
    TCHAR           achPath[MAX_PATH];
    DWORD           dwType = REG_SZ;
    DWORD           cbData = MAX_PATH * sizeof(TCHAR);
    int             idFilterRes;


    // Initialize ofn struct
    memset(&ofn, 0, sizeof(ofn));
    ofn.lStructSize     = sizeof(ofn);
    ofn.hwndOwner       = hwndOwner;
    ofn.Flags           =   OFN_FILEMUSTEXIST   |
                            OFN_PATHMUSTEXIST   |
                            OFN_OVERWRITEPROMPT |
                            OFN_HIDEREADONLY    |
#ifndef UNIX
                            OFN_NOCHANGEDIR     |
                            OFN_EXPLORER;
#else
                            OFN_NOCHANGEDIR;
#endif /* UNIX */

    ofn.lpfnHook        = NULL;
    ofn.nMaxFile        = cchFile;
    ofn.lCustData       = lCustData;
    ofn.lpstrFile       = pstrFile;
#ifndef NO_IME
    // We add an extra control to the save file dialog.

    if (lCustData)
    {
        ofn.Flags |= OFN_ENABLETEMPLATE | OFN_ENABLEHOOK;
        ofn.lpfnHook = SaveOFNHookProc;
        ofn.lpTemplateName = MAKEINTRESOURCE(IDD_ADDTOSAVE_DIALOG);
        ofn.hInstance = g_hinst;
    }

#endif

    //
    // Find the extension and set the filter index based on what the
    // extension is.  After these loops pstrExt will either be NULL if
    // we didn't find an extension, or will point to the extension starting
    // at the '.'

    pstrExt = pstrFile;
    while (*pstrExt)
        pstrExt++;
    while ( pstrExt >= pstrFile )
    {
        if( *pstrExt == TEXT('.') )
            break;
        pstrExt--;
    }
    if( pstrExt < pstrFile )
        pstrExt = NULL;

    // Load the filter spec.
    // FEATURE: Convert table to stringtable for localization

    if ( SHRestricted2W( REST_NoBrowserSaveWebComplete, NULL, 0 ) )
        idFilterRes = IDS_NOTHICKET_SAVE;
    else if ( s_dwInetComVerMS != 0xFFFFFFFF )
    {
#ifndef UNIX
        if (s_dwInetComVerMS == 0)
        {
            TCHAR szPath[MAX_PATH];

            GetSystemDirectory( szPath, MAX_PATH );
            StrCatBuff( szPath, TEXT("\\INETCOMM.DLL"), MAX_PATH );
            if (FAILED(GetVersionFromFile(szPath, &s_dwInetComVerMS, &s_dwInetComVerLS)))
                s_dwInetComVerMS = 0xFFFFFFFF;
        }

        if (s_dwInetComVerMS >= 0x50000 && s_dwInetComVerMS != 0xFFFFFFFF)
            idFilterRes = IDS_THICKET_SAVE;
        else
            idFilterRes = IDS_NOMHTML_SAVE;
#else
        // on UNIX we don't have inetcomm.dll if oe is not installed
        {
           HINSTANCE hInetComm = NULL;

           if ((hInetComm = LoadLibrary(TEXT("INETCOMM.DLL"))))
           {
              idFilterRes = IDS_THICKET_SAVE;
              FreeLibrary(hInetComm);
           }
           else
              idFilterRes = IDS_NOMHTML_SAVE;
        }
#endif
    }
    else
        idFilterRes = IDS_THICKET_SAVE;

    cbBuffer = MLLoadShellLangString(idFilterRes, achBuffer, ARRAYSIZE(achBuffer));
    ASSERT(cbBuffer > 0);
    if ( ! cbBuffer )
        return E_FAIL;

    ofn.lpstrTitle = achBuffer;

    for ( cp = achBuffer; *cp; cp++ )
    {
        if ( *cp == TEXT('|') )
        {
            *cp = TEXT('\0');
        }
    }

    ASSERT(ofn.lpstrTitle);

    // Default extension is second string.
    pstr = (LPTSTR) ofn.lpstrTitle;
    while (*pstr++)
    {
    }

    // N.B. (johnv) Here we assume that filter index one corresponds with the default
    //  extension, otherwise we would have to introduce a default filter index into
    //  the resource string.
    ofn.nFilterIndex    = ((pnFilterIndex)? *pnFilterIndex : 1);
    ofn.lpstrDefExt     = pstr;

    // Filter is third string.
    while(*pstr++)
    {
    }

    ofn.lpstrFilter = pstr;

    // Try to match the extension with an entry in the filter list
    // If we match, remove the extension from the incoming path string,
    //   set the default extension to the one we found, and appropriately
    //   set the filter index.

    if (pstrExt && !bForceHTMLOnly)
    {
        // N.B. (johnv) We are searching more than we need to.

        int    iIndex = 0;
        const TCHAR* pSearch = ofn.lpstrFilter;

        while( pSearch )
        {
            if( StrStr( pSearch, pstrExt ) )
            {
                ofn.nFilterIndex = (iIndex / 2) + 1;
                ofn.lpstrDefExt = pstrExt + 1;

                // Remove the extension from the file name we pass in
                *pstrExt = TEXT('\0');

                break;
            }
            pSearch += lstrlen(pSearch);
            if( pSearch[1] == 0 )
                break;

            pSearch++;
            iIndex++;
        }
    }

    // Suggest HTML Only as default save-type

    if (bForceHTMLOnly)
    {
        // NOTE: These are hard-coded indices based on shdoclc.rc's
        // IDS_THICKET_SAVE, IDS_NOMHTML_SAVE, IDS_NOTHICKET_SAVE ordering.
        // This saves us the perf hit of doing string comparisons to find
        // HTML only

        switch (idFilterRes)
        {
            case IDS_NOTHICKET_SAVE:
                ofn.nFilterIndex = 1;
                break;

            case IDS_NOMHTML_SAVE:
                ofn.nFilterIndex = 2;
                break;

            default:
                ASSERT(idFilterRes == IDS_THICKET_SAVE);
                ofn.nFilterIndex = 3;
                break;
        }
    }

    if ( SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_MAIN, REGSTR_VAL_SAVEDIRECTORY,
                    &dwType, achPath, &cbData) != ERROR_SUCCESS ||
         !PathFileExists(achPath))
    {
        SHGetSpecialFolderPath(hwndOwner, achPath, CSIDL_PERSONAL, FALSE);
    }

    ofn.lpstrInitialDir = achPath;

    // We don't want to suggest dots in the filename
    ReplaceDotsInFileName(pstrFile);

    // Now, at last, we're ready to call the save file dialog
    fOK = GetSaveFileName(&ofn);

    // if working with the abbreviated format list, adjust the index
    if (idFilterRes == IDS_NOTHICKET_SAVE)
        ofn.nFilterIndex += 2;
    else if ( idFilterRes == IDS_NOMHTML_SAVE && ofn.nFilterIndex > 1 )
        ofn.nFilterIndex += 1;

    if (fOK)
    {
        //
        // Protect the naive users from themselves, if somebody enters a filename
        // of microsoft.com when saving http://www.microsoft.com we don't want
        // to save a .COM file since this will be interpreted as an executable.
        // bad things will happen
        //
        CleanUpFilename(pstrFile, ofn.nFilterIndex);

        TCHAR *lpszFileName;

        StrCpyN( achPath, pstrFile, ARRAYSIZE(achPath) );

        lpszFileName = PathFindFileName( achPath );
        *lpszFileName = 0;

        SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_MAIN, REGSTR_VAL_SAVEDIRECTORY,
                   REG_SZ, achPath, (lstrlen(achPath) * sizeof(TCHAR)));

        if (pnFilterIndex)
            *pnFilterIndex = ofn.nFilterIndex;

        if (ofn.nFilterIndex != PACKAGE_MHTML)
        {
            // we can only do this if we're not packaging MHTML
            // because MHTML requires that we tag with the explicit
            // charset, even if it was the default. unlike thicket
            // which inherits the charset from the original document,
            // MHTML must be explicitly tagged or else some system
            // charset tags will sneak in.

            ThicketCPInfo * ptcpi = (ThicketCPInfo *)lCustData;

            // To spare us from re-instantiating MLANG, we'll set the src and dest
            // to CP_ACP if no change is indicated.
            if (ptcpi->cpDst == ptcpi->cpSrc)
               ptcpi->cpDst = ptcpi->cpSrc = CP_ACP;
        }
    }
    else
    {
#ifndef WINCE
        dwCommDlgErr = CommDlgExtendedError();
        if (dwCommDlgErr)
        {
            hr = HRESULT_FROM_WIN32(dwCommDlgErr);
        }
        else
        {
            hr = S_FALSE;
        }
#else // WINCE
        hr = E_FAIL;
#endif // WINCE
    }

    return hr;
}

HRESULT
GetFileNameFromURL( LPWSTR pwszURL, LPTSTR pszFile, DWORD cchFile)
{
    HRESULT         hr = S_OK;
    PARSEDURLW      puw = {0};
    int             cchUrl;

    cchUrl = SysStringLen(pwszURL);

    if (cchUrl)
    {
        puw.cbSize = sizeof(PARSEDURLW);
        if (SUCCEEDED(ParseURLW(pwszURL, &puw)))
        {
            OLECHAR *pwchBookMark;
            DWORD   dwSize;
            INTERNET_CACHE_ENTRY_INFOW      ceiT;
            LPINTERNET_CACHE_ENTRY_INFOW    pcei = NULL;

            // Temporarily, null out the '#' in the url
            pwchBookMark = StrRChrW(puw.pszSuffix, NULL,'#');
            if (pwchBookMark)
            {
                *pwchBookMark = 0;
            }

            dwSize = sizeof(INTERNET_CACHE_ENTRY_INFO);
            if ( !GetUrlCacheEntryInfoW( pwszURL, &ceiT, &dwSize ) &&
                 GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
                 (pcei = (LPINTERNET_CACHE_ENTRY_INFOW)new BYTE[dwSize]) != NULL &&
                 GetUrlCacheEntryInfoW( pwszURL, pcei, &dwSize ) )
            {
                StrCpyN(pszFile, PathFindFileName(pcei->lpszLocalFileName), cchFile);
                PathUndecorate(pszFile);
            }

            if(pcei)
                delete[] pcei;

            if (pwchBookMark)
                *pwchBookMark = '#';

            if ( !pszFile[0] )
            {
                OLECHAR *pwchQuery;
                TCHAR   szFileT[MAX_PATH];

                // Temporarily, null out the '?' in the url
                pwchQuery = StrRChrW(puw.pszSuffix, NULL,'?');
                if (pwchQuery)
                {
                    *pwchQuery = 0;
                }

                // IE5 bug 15055 - http://my.excite.com/?uid=B56E4E2D34DF3FED.save_uid
                // fails to save because we were passing "my.excite.com/" as the file
                // name to the file dialog. It doesn't like this.
                if (!pwchQuery || (pwchQuery[-1] != '/' && pwchQuery[-1] != '\\'))
                {
                    dwSize = ARRAYSIZE(szFileT);

                    StrCpyN(szFileT, PathFindFileName(puw.pszSuffix), dwSize);

                    if ( !InternetCanonicalizeUrl( szFileT, pszFile, &dwSize, ICU_DECODE | ICU_NO_ENCODE) )
                        StrCpyN(pszFile, szFileT, cchFile);

                    pszFile[cchFile - 1] = 0;
                }

                if (pwchQuery)
                    *pwchQuery = '?';
            }
        }
    }

    if (!pszFile[0])
    {
        MLLoadString(IDS_UNTITLED, pszFile, cchFile);
    }

    return hr;
}

INT_PTR CALLBACK SaveAsWarningDlgProc(HWND hDlg, UINT msg, WPARAM wParam,
                                      LPARAM lParam)
{
    BOOL        fRet = FALSE;
    HRESULT     hr = S_OK;
    int         iFlags = 0;
    INT_PTR     bChecked = 0;

    switch (msg)
    {
        case WM_INITDIALOG:
            MessageBeep(MB_ICONEXCLAMATION);
            fRet = TRUE;

        case WM_COMMAND:
            bChecked = SendDlgItemMessage(hDlg, IDC_SAVEAS_WARNING_CB,
                                                  BM_GETCHECK, 0, 0 );
            iFlags = (bChecked) ? (SAVEAS_NEVER_ASK_AGAIN) : (0);

            switch (LOWORD(wParam))
            {
                case IDYES:
                    iFlags |= SAVEAS_OK;
                    // fall through

                case IDNO:
                    EndDialog(hDlg, iFlags);
                    fRet = TRUE;
                    break;
            }
    
        default:
            fRet = FALSE;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\tlog.cpp ===
#include "priv.h"
#include "dspsprt.h"
#include <hlink.h>
#include "iface.h"
#include "resource.h"
#include <mluisupp.h>
#include "shdocfl.h"

class CTravelLog;

class CEnumEntry : public IEnumTravelLogEntry
{
public:
    // *** IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // *** IEnumTravelLogEntry specific methods  
    STDMETHODIMP Next(ULONG  cElt, ITravelLogEntry **rgElt, ULONG *pcEltFetched);
    STDMETHODIMP Skip(ULONG cElt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumTravelLogEntry **ppEnum);

    CEnumEntry();
    void Init(CTravelLog *ptl, IUnknown *punk, DWORD dwOffset, DWORD dwFlags); 
    void  SetBase();

protected:
    ~CEnumEntry();
    
    LONG            _cRef;
    DWORD           _dwFlags;
    DWORD           _dwOffset; 
    LONG            _lStart;
    CTravelLog      *_ptl;
    IUnknown        *_punk;
};

class CTravelEntry : public ITravelEntry, 
                     public ITravelLogEntry,
                     public IPropertyBag
{
public:
    CTravelEntry(BOOL fIsLocalAnchor);

    // *** IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // *** ITravelEntry specific methods
    STDMETHODIMP Update(IUnknown *punk, BOOL fIsLocalAnchor);
    STDMETHODIMP Invoke(IUnknown *punk);
    STDMETHODIMP GetPidl(LPITEMIDLIST *ppidl);
    
    // *** ITravelLogEntry specific methods
    STDMETHODIMP GetTitle(LPOLESTR *ppszTitle);
    STDMETHODIMP GetURL(LPOLESTR *ppszURL);  
    
    // *** IPropertyBag specific methods
    STDMETHODIMP Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
    STDMETHODIMP Write(LPCOLESTR pszPropName, VARIANT *pVar);

    static HRESULT CreateTravelEntry(IBrowserService *pbs, BOOL fIsLocalAnchor, CTravelEntry **ppte);
    void SetPrev(CTravelEntry *ptePrev);
    void SetNext(CTravelEntry *pteNext);
    CTravelEntry *GetPrev() {return _ptePrev;}
    CTravelEntry *GetNext() {return _pteNext;}
    void RemoveSelf();
    BOOL CanInvoke(IUnknown *punk, BOOL fAllowLocalAnchor);
    HRESULT GetIndexBrowser(IUnknown *punkIn, IUnknown ** ppsbOut) const;
    DWORD Size();
    DWORD ListSize();
    HRESULT Clone(CTravelEntry **ppte);
    HRESULT UpdateExternal(IUnknown *punk, IUnknown *punkHLBrowseContext);
    HRESULT UpdateSelf(IUnknown *punk) 
        {return Update(punk, (_type == TET_LOCALANCHOR));}
    BOOL IsExternal(void)
        { return (_type==TET_EXTERNALNAV); }
    HRESULT GetDisplayName(LPTSTR psz, DWORD cch, DWORD dwFlags);
    BOOL IsEqual(LPCITEMIDLIST pidl)
        {return ILIsEqual(pidl, _pidl);}
    BOOL IsLocalAnchor(void)
        { return (_type==TET_LOCALANCHOR);}
        
protected:
    CTravelEntry(void);
    HRESULT _InvokeExternal(IUnknown *punk);
    HRESULT _UpdateTravelLog(IUnknown *punk, BOOL fIsLocalAnchor);
    HRESULT _UpdateFromTLClient(IUnknown * punk, IStream ** ppStream);
    LONG _cRef;

    ~CTravelEntry();
    void _Reset(void);
    enum {
        TET_EMPTY   = 0,
        TET_DEFAULT = 1,
        TET_LOCALANCHOR,
        TET_EXTERNALNAV
#ifdef FEATURE_STARTPAGE
        , TET_CLOSEDOWN
#endif
    };

    DWORD _type;            //  flags for our own sake...
    LPITEMIDLIST _pidl;     //  pidl of the entry
    HGLOBAL _hGlobalData;   //  the stream data saved by the entry
    DWORD _bid;             //  the BrowserIndex for frame specific navigation
    DWORD _dwCookie;        //  if _hGlobalData is NULL the cookie should be set
    WCHAR * _pwzTitle;
    WCHAR * _pwzUrlLocation;
    
    IHlink *_phl;
    IHlinkBrowseContext *_phlbc;
    IPropertyBag    *_ppb;

    CTravelEntry *_ptePrev;
    CTravelEntry *_pteNext;
};


CTravelEntry::CTravelEntry(BOOL fIsLocalAnchor) : _cRef(1)
{
    //these should always be allocated
    //  thus they will always start 0
    if (fIsLocalAnchor)
        _type = TET_LOCALANCHOR;
    else
        ASSERT(!_type);

    ASSERT(!_pwzTitle);
    ASSERT(!_pwzUrlLocation);
    ASSERT(!_pidl);
    ASSERT(!_hGlobalData);
    ASSERT(!_bid);
    ASSERT(!_dwCookie);
    ASSERT(!_ptePrev);
    ASSERT(!_pteNext);
    ASSERT(!_phl);
    ASSERT(!_ppb);
    ASSERT(!_phlbc);
    TraceMsg(TF_TRAVELLOG, "TE[%X] created _type = %x", this, _type);

#ifdef FEATURE_STARTPAGE
    if (fIsLocalAnchor == 42) // HACK ALERT! Special value for CloseDown
    {
        _type = TET_CLOSEDOWN;
        _bid = -1;   // BID_TOPFRAMEBROWSER;
        _pwzTitle = StrDup(TEXT("Close"));
    }
#endif

}

CTravelEntry::CTravelEntry(void) : _cRef(1)
{
    ASSERT(!_type);
    ASSERT(!_pwzTitle);
    ASSERT(!_pwzUrlLocation);
    ASSERT(!_pidl);
    ASSERT(!_hGlobalData);
    ASSERT(!_bid);
    ASSERT(!_dwCookie);
    ASSERT(!_ptePrev);
    ASSERT(!_pteNext);
    ASSERT(!_phl);
    ASSERT(!_ppb);
    ASSERT(!_phlbc);

    TraceMsg(TF_TRAVELLOG, "TE[%X] created", this, _type);
}

HGLOBAL CloneHGlobal(HGLOBAL hGlobalIn)
{
    DWORD dwSize = (DWORD)GlobalSize(hGlobalIn);
    HGLOBAL hGlobalOut = GlobalAlloc(GlobalFlags(hGlobalIn), dwSize);
    HGLOBAL hGlobalResult = NULL;

    if (NULL != hGlobalOut)
    {
        LPVOID pIn= GlobalLock(hGlobalIn);

        if (NULL != pIn)
        {
            LPVOID pOut= GlobalLock(hGlobalOut);

            if (NULL != pOut)
            {
                memcpy(pOut, pIn, dwSize);
                GlobalUnlock(hGlobalOut);
                hGlobalResult = hGlobalOut;
            }

            GlobalUnlock(hGlobalIn);
        }

        if (!hGlobalResult)
        {
            GlobalFree(hGlobalOut);
            hGlobalOut = NULL;
        }
    }

    return hGlobalResult;
}


HRESULT 
CTravelEntry::Clone(CTravelEntry **ppte)
{
    //  dont ever clone an external entry
    if (_type == TET_EXTERNALNAV)
        return E_FAIL;

    CTravelEntry *pte = new CTravelEntry();
    HRESULT hr = S_OK;

    if (pte)
    {
        pte->_type = _type;
        pte->_bid = _bid;
        pte->_dwCookie = _dwCookie;

        if (_pwzTitle)
        {
            pte->_pwzTitle = StrDup(_pwzTitle);
            if (!pte->_pwzTitle)
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if (_pwzUrlLocation)
        {
            pte->_pwzUrlLocation = StrDup(_pwzUrlLocation);
            if (!pte->_pwzUrlLocation)
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if (_pidl)
        {
            pte->_pidl = ILClone(_pidl);
            if (!pte->_pidl)
                hr = E_OUTOFMEMORY;
        }
        else
            pte->_pidl = NULL;

        if (_hGlobalData)
        {
            pte->_hGlobalData = CloneHGlobal(_hGlobalData);

            if (NULL == pte->_hGlobalData)
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            ASSERT(NULL == pte->_hGlobalData);
        }
    }
    else 
        hr = E_OUTOFMEMORY;

    if (FAILED(hr) && pte)
    {
        pte->Release();
        *ppte = NULL;
    }
    else
        *ppte = pte;

    TraceMsg(TF_TRAVELLOG, "TE[%X] Clone hr = %x", this, hr);

    return hr;
}

CTravelEntry::~CTravelEntry()
{
    ILFree(_pidl);

    if (_hGlobalData)
    {
        GlobalFree(_hGlobalData);
        _hGlobalData = NULL;
    }

    if (_pwzTitle)
    {
        LocalFree(_pwzTitle);
        _pwzTitle = NULL;
    }

    if (_pwzUrlLocation)
    {
        LocalFree(_pwzUrlLocation);
        _pwzUrlLocation = NULL;
    }

    if (_pteNext)
    {
        _pteNext->Release();
    }

    // Don't need to release _ptePrev because TravelEntry only addref's pteNext

    ATOMICRELEASE(_ppb);
    ATOMICRELEASE(_phl);
    ATOMICRELEASE(_phlbc);
    
    TraceMsg(TF_TRAVELLOG, "TE[%X] destroyed ", this);
}

HRESULT CTravelEntry::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = { 
        QITABENT(CTravelEntry, ITravelEntry), // IID_ITravelEntry
        QITABENT(CTravelEntry, ITravelLogEntry),
        QITABENT(CTravelEntry, IPropertyBag),
        { 0 }, 
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CTravelEntry::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CTravelEntry::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

//+-------------------------------------------------------------------------
//
//  Method    : CTravelEntry::GetIndexBrowser
//
//  Synopsis  : This method finds and returns the IUnknown of the browser
//              with the index in _bid. This method first checks to see
//              if the passed in punk supports ITravelLogClient. If it 
//              doesn't, it checks for IBrowserService. 
//
//--------------------------------------------------------------------------

HRESULT
CTravelEntry::GetIndexBrowser(IUnknown * punk, IUnknown ** ppunkBrowser) const
{
    HRESULT hr = E_FAIL;
    ITravelLogClient * ptlcTop = NULL;
    
    ASSERT(ppunkBrowser);
        
    hr = punk->QueryInterface(IID_PPV_ARG(ITravelLogClient, &ptlcTop));

    if (SUCCEEDED(hr))
    {
        hr = ptlcTop->FindWindowByIndex(_bid, ppunkBrowser);
    }

    TraceMsg(TF_TRAVELLOG, "TE[%X]::GetIndexBrowser _bid = %X, hr = %X", this, _bid, hr);
    
    SAFERELEASE(ptlcTop);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method    : CTravelEntry::CanInvoke
//
//  Synopsis  : This method determines if the current travel entry can
//              be invoked. There are two criteria that determine if
//              this entry can be invoked. 
//              1) If the entry is a local anchor, fAllowLocalAnchor must
//                 be TRUE.
//              2) A browser with the index in _bid must exist. 
//
//--------------------------------------------------------------------------

BOOL CTravelEntry::CanInvoke(IUnknown *punk, BOOL fAllowLocalAnchor)
{
    IUnknown * punkBrowser = NULL;
    BOOL       fRet = IsLocalAnchor() ? fAllowLocalAnchor : TRUE;

    if (fRet)
        fRet = fRet && SUCCEEDED(GetIndexBrowser(punk, &punkBrowser));

    SAFERELEASE(punkBrowser);

    return fRet;
}

DWORD CTravelEntry::Size()
{
    DWORD cbSize = SIZEOF(*this);

    if (_pidl)
        cbSize += ILGetSize(_pidl);

    if (_hGlobalData)
    {
        cbSize += (DWORD)GlobalSize(_hGlobalData);
    }

    if (_pwzTitle)
    {
        cbSize += (DWORD)LocalSize(_pwzTitle);
    }

    if (_pwzUrlLocation)
    {
        cbSize += (DWORD)LocalSize(_pwzUrlLocation);
    }

    return cbSize;
}

DWORD CTravelEntry::ListSize()
{
    CTravelEntry *pte = GetNext();

    DWORD cb = Size();
    while (pte)
    {
        cb += pte->Size();
        pte = pte->GetNext();
    }
    return cb;
}


void CTravelEntry::_Reset()
{
    Pidl_Set(&_pidl, NULL);

    if (NULL != _hGlobalData)
    {
        GlobalFree(_hGlobalData);
        _hGlobalData = NULL;
    }

    ATOMICRELEASE(_phl);
    ATOMICRELEASE(_phlbc);

    _bid = 0;
    _type = TET_EMPTY;
    _dwCookie = 0;

    if (_pwzTitle)
    {
        LocalFree(_pwzTitle);
        _pwzTitle = NULL;
    }

    if (_pwzUrlLocation)
    {
        LocalFree(_pwzUrlLocation);
        _pwzUrlLocation = NULL;
    }

    TraceMsg(TF_TRAVELLOG, "TE[%X]::_Reset", this);
}

HRESULT CTravelEntry::_UpdateTravelLog(IUnknown *punk, BOOL fIsLocalAnchor)
{
    IBrowserService *pbs;
    HRESULT hr = E_FAIL;
    //  we need to update here
    if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IBrowserService, &pbs))))
    {
        ITravelLog *ptl;
        if (SUCCEEDED(pbs->GetTravelLog(&ptl)))
        {
            hr = ptl->UpdateEntry(punk, fIsLocalAnchor);
            ptl->Release();
        }
        pbs->Release();
    }

    return hr;
}

HRESULT CTravelEntry::_InvokeExternal(IUnknown *punk)
{
    HRESULT hr = E_FAIL;

    ASSERT(_phl);
    ASSERT(_phlbc);
    
    TraceMsg(TF_TRAVELLOG, "TE[%X]::InvokeExternal entered on _bid = %X, _phl = %X, _phlbc = %X", this, _bid, _phl, _phlbc);

    // set the size and position of the browser frame window, so that the
    // external target can sync up its frame window to those coordinates
    HLBWINFO hlbwi;

    hlbwi.cbSize = sizeof(hlbwi);
    hlbwi.grfHLBWIF = 0;

    IOleWindow *pow;
    HWND hwnd = NULL;
    if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IOleWindow, &pow))))
    {
        pow->GetWindow(&hwnd);
        pow->Release();
    }

    if (hwnd) 
    {
        WINDOWPLACEMENT wp = {0};

        wp.length = sizeof(WINDOWPLACEMENT);
        GetWindowPlacement(hwnd, &wp);
        hlbwi.grfHLBWIF = HLBWIF_HASFRAMEWNDINFO;
        hlbwi.rcFramePos = wp.rcNormalPosition;
        if (wp.showCmd == SW_SHOWMAXIMIZED)
            hlbwi.grfHLBWIF |= HLBWIF_FRAMEWNDMAXIMIZED;
    }

    _phlbc->SetBrowseWindowInfo(&hlbwi);

    //
    //  right now we always now we are going back, but later on
    //  maybe we should ask the browser whether this is back or forward
    //
    hr = _phl->Navigate(HLNF_NAVIGATINGBACK, NULL, NULL, _phlbc);
    
    IServiceProvider *psp; 
    if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IServiceProvider, &psp))))
    {
        IWebBrowser2 *pwb;
        ASSERT(psp);
        if (SUCCEEDED(psp->QueryService(SID_SWebBrowserApp, IID_IWebBrowser2, (void **)&pwb)))
        {
            ASSERT(pwb);
            pwb->put_Visible(FALSE);
            pwb->Release();
        }

        psp->Release();
    }

    _UpdateTravelLog(punk, FALSE);

    TraceMsg(TF_TRAVELLOG, "TE[%X]::InvokeExternal exited hr = %X", this, hr);

    return hr;
}

HRESULT CTravelEntry::Invoke(IUnknown *punk)
{
    IPersistHistory *pph = NULL;
    HRESULT hr = E_FAIL;
    IUnknown * punkBrowser = NULL;
    IHTMLWindow2 * pWindow = NULL;

    TraceMsg(TF_TRAVELLOG, "TE[%X]::Invoke entered on _bid = %X", this, _bid);
    TraceMsgW(TF_TRAVELLOG, "TE[%X]::Invoke title '%s'", this, _pwzTitle);

    if (_type == TET_EXTERNALNAV)
    {
        hr = _InvokeExternal(punk);
        goto Quit;
    }

    // Get the window/browser with the index. If that
    // fails, punk may be a IHTMLWindow2. If so,
    // get its IPersistHistory so the travel entry
    // can be loaded directly. (This is needed by Trident
    // in order to navigate in frames when traveling
    // backwards or forwards.
    //
    hr = GetIndexBrowser(punk, &punkBrowser);
    if (!hr)
    {
        hr = punkBrowser->QueryInterface(IID_PPV_ARG(IPersistHistory, &pph));
    }
    else
    {
        hr = punk->QueryInterface(IID_PPV_ARG(IHTMLWindow2, &pWindow));
        if (!hr)
        {
            hr = pWindow->QueryInterface(IID_PPV_ARG(IPersistHistory, &pph));
        }
    }

    if (SUCCEEDED(hr))
    {
        ASSERT(pph);

#ifdef FEATURE_STARTPAGE
        if (_type == TET_CLOSEDOWN)
        {
            HWND hwnd;
            hr = IUnknown_GetWindow(punkBrowser, &hwnd);
            if (SUCCEEDED(hr))
                PostMessage(hwnd, WM_CLOSE, 0, 0);

            goto Quit;
        }
#endif

        if (_type == TET_LOCALANCHOR)
        {
            ITravelLogClient * pTLClient;

            hr = pph->QueryInterface(IID_PPV_ARG(ITravelLogClient, &pTLClient)); 

            if (SUCCEEDED(hr))
            {
                hr = pTLClient->LoadHistoryPosition(_pwzUrlLocation, _dwCookie);
                pTLClient->Release();
            }
            else
            {
                hr = pph->SetPositionCookie(_dwCookie);
            }
        }
        else
        {
            //  we need to clone it
            ASSERT(_hGlobalData);
            
            HGLOBAL hGlobal = CloneHGlobal(_hGlobalData);

            if (NULL != hGlobal)
            {
                IStream *pstm;
                
                hr = CreateStreamOnHGlobal(hGlobal, TRUE, &pstm);

                if (SUCCEEDED(hr))
                {
                    hr = pph->LoadHistory(pstm, NULL);
                    pstm->Release();
                }
                else
                {
                    GlobalFree(hGlobal);
                    hGlobal = NULL;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        pph->Release();
    }

Quit:

    SAFERELEASE(punkBrowser);
    SAFERELEASE(pWindow);

    TraceMsg(TF_TRAVELLOG, "TE[%X]::Invoke exited on _bid = %X, hr = %X", this, _bid, hr);
    return hr;
}

HRESULT CTravelEntry::UpdateExternal(IUnknown *punk, IUnknown *punkHLBrowseContext)
{
    TraceMsg(TF_TRAVELLOG, "TE[%X]::UpdateExternal entered on punk = %X, punkhlbc = %X", this, punk, punkHLBrowseContext);

    _Reset();
    ASSERT(punkHLBrowseContext);
    punkHLBrowseContext->QueryInterface(IID_PPV_ARG(IHlinkBrowseContext, &_phlbc));
    ASSERT(_phlbc);

    _type = TET_EXTERNALNAV;

    HRESULT hr = E_FAIL;

    //
    //  right now we only support externals being previous.  we never actually navigate
    //  to another app.  we handle everything in pane ourselves.
    //  so theoretically we never need to worry about HLID_NEXT
    _phlbc->GetHlink((ULONG) HLID_PREVIOUS, &_phl);
    
    IBrowserService *pbs;
    punk->QueryInterface(IID_PPV_ARG(IBrowserService, &pbs));

    if (pbs && _phl) 
    {
        _bid = pbs->GetBrowserIndex();

        WCHAR *pwszTarget;
        hr = _phl->GetStringReference(HLINKGETREF_ABSOLUTE, &pwszTarget, NULL);
        if (SUCCEEDED(hr))
        {
            TCHAR szName[MAX_URL_STRING];
            StrCpyN(szName, pwszTarget, ARRAYSIZE(szName));
            OleFree(pwszTarget);

            // create pidl
            hr = IECreateFromPath(szName, &_pidl);
        }
    }

    ATOMICRELEASE(pbs);

    TraceMsg(TF_TRAVELLOG, "TE[%X]::UpdateExternal exited _bid = %X, hr = %X", this, _bid, hr);

    return hr;
}

HRESULT CTravelEntry::Update(IUnknown *punk, BOOL fIsLocalAnchor)
{
    HRESULT hr, hrStat;
    STATSTG stg;
    IStream         * pstm = NULL;
    IPersistHistory * pph  = NULL;
    
    ASSERT(punk);
        
    //  this means that we went back to an external app, 
    //  and now we are going forward again.  we dont persist 
    //  any state info about them that would be different.
    if (_type == TET_EXTERNALNAV)
    {
        TraceMsg(TF_TRAVELLOG, "TE[%X]::Update NOOP on external entry", this);
        return S_OK;
    }

    _Reset();
    
    // Try ITravelLogClient first. If that fails, revert to IBrowserService.
    //
    hr = _UpdateFromTLClient(punk, &pstm);
    if (hr)
        goto Cleanup;
    
    hr = punk->QueryInterface(IID_PPV_ARG(IPersistHistory, &pph));

    ASSERT(SUCCEEDED(hr));

    if (hr)
        goto Cleanup;

    if (fIsLocalAnchor)
    {
        //  persist a cookie
        //
        _type = TET_LOCALANCHOR;
        hr = pph->GetPositionCookie(&_dwCookie);
    }
    else
    {
        _type = TET_DEFAULT;

        //  persist a stream
        //
        ASSERT(!_hGlobalData);

        if (!pstm)
        {
            hr = CreateStreamOnHGlobal(NULL, FALSE, &pstm);

            if (hr)
                goto Cleanup;
                
            pph->SaveHistory(pstm);
        }

        hrStat = pstm->Stat(&stg, STATFLAG_NONAME);

        hr = GetHGlobalFromStream(pstm, &_hGlobalData);

        //  This little exercise here is to shrink the memory block we get from
        //  the OLE API which allocates blocks in chunks of 8KB.  Typical stream
        //  sizes are only a few hundred bytes.

        if (hrStat)
            goto Cleanup;
            
        HGLOBAL hGlobalTemp = GlobalReAlloc(_hGlobalData, stg.cbSize.LowPart, GMEM_MOVEABLE);
                        
        if (NULL != hGlobalTemp)
        {
            _hGlobalData = hGlobalTemp;
        }
    }

Cleanup:
    if (FAILED(hr))
        _Reset();

    SAFERELEASE(pstm);
    SAFERELEASE(pph);

    TraceMsg(TF_TRAVELLOG, "TE[%X]::Update exited on _bid = %X, hr = %X", this, _bid, hr);
    
    return hr;
}

//+-----------------------------------------------------------------------------
//
//  Method    : CTravelEntry::_UpdateFromTLClient
//
//  Synopsis  : Updates the travel entry using the ITravelLogClient interface
//
//------------------------------------------------------------------------------

HRESULT
CTravelEntry::_UpdateFromTLClient(IUnknown * punk, IStream ** ppStream)
{
    HRESULT    hr;
    WINDOWDATA windata = {0};
    ITravelLogClient * ptlc = NULL;
    
    hr = punk->QueryInterface(IID_PPV_ARG(ITravelLogClient, &ptlc));

    if (hr)
        goto Cleanup;

    hr = ptlc->GetWindowData(&windata);

    if (hr)
        goto Cleanup;
            
    _bid = windata.dwWindowID;
                
    ILFree(_pidl);

    if (windata.pidl)
    {
        _pidl = ILClone(windata.pidl);
    }
    else
    {
        hr = IEParseDisplayNameWithBCW(windata.uiCP, windata.lpszUrl, NULL, &_pidl);
        if (hr)
            goto Cleanup;
    }

    ASSERT(_pidl);

    // If there is an url location, append it to the end of the url
    //
    if (_pwzUrlLocation)
    {
        LocalFree(_pwzUrlLocation);
        _pwzUrlLocation = NULL;
    }

    if (windata.lpszUrlLocation && *windata.lpszUrlLocation)
    {
        _pwzUrlLocation = StrDup(windata.lpszUrlLocation);
    }

    //  Pick up the title as a display name for menus and such.
    //
    if (_pwzTitle)
    {
        LocalFree(_pwzTitle);
        _pwzTitle = NULL;
    }

    if (windata.lpszTitle)
        _pwzTitle = StrDup(windata.lpszTitle);

    *ppStream = windata.pStream;

    TraceMsgW(TF_TRAVELLOG, "TE[%X]::_UpdateFromTLClient - ptlc:[0x%X] _bid:[%ld] Url:[%ws] Title:[%ws] UrlLocation:[%ws] ppStream:[0x%X]",
              this, ptlc, _bid, windata.lpszUrl, _pwzTitle, _pwzUrlLocation, *ppStream);

Cleanup:
    ILFree(windata.pidl);

    CoTaskMemFree(windata.lpszUrl);
    CoTaskMemFree(windata.lpszUrlLocation);
    CoTaskMemFree(windata.lpszTitle);
    
    SAFERELEASE(ptlc);

    // Don't release windata.pStream. It will
    // be released when ppStream is released.
    
    return hr;
}

HRESULT CTravelEntry::GetPidl(LPITEMIDLIST * ppidl)
{
    if (EVAL(ppidl))
    {
        *ppidl = ILClone(_pidl);
        if (*ppidl)
            return S_OK;
    }
    return E_FAIL;
}

void CTravelEntry::SetNext(CTravelEntry *pteNext)
{
    if (_pteNext)
        _pteNext->Release();

    _pteNext = pteNext;

    if (_pteNext) 
    {
        _pteNext->_ptePrev = this;
    }
}

void CTravelEntry::SetPrev(CTravelEntry *ptePrev)
{
    _ptePrev = ptePrev;
    if (_ptePrev)
        _ptePrev->SetNext(this);
}

//
//  this is for removing from the middle of the list...
//
void CTravelEntry::RemoveSelf()
{
    if (_pteNext)
        _pteNext->_ptePrev = _ptePrev;

    // remove yourself from the list
    if (_ptePrev) 
    {
        // after this point, we may be destroyed so can't touch any more member vars
        _ptePrev->_pteNext = _pteNext;
    }

    _ptePrev = NULL;
    _pteNext = NULL;

    // we lose a reference now because we're gone from _ptePrev's _pteNext
    // (or if we were the top of the list, we're also nuked)
    Release();
}


HRESULT GetUnescapedUrlIfAppropriate(LPCITEMIDLIST pidl, LPTSTR pszUrl, DWORD cch)
{
    TCHAR szUrl[MAX_URL_STRING];

    // The SHGDN_NORMAL display name will be the pretty name (Web Page title) unless
    // it's an FTP URL or the web page didn't set a title.
    if (SUCCEEDED(IEGetDisplayName(pidl, szUrl, SHGDN_NORMAL)) &&
        UrlIs(szUrl, URLIS_URL))
    {
        // NT #279192, If an URL is escaped, it normally contains three types of
        // escaped chars.
        // 1) Seperating type chars ('#' for frag, '?' for params, etc.)
        // 2) DBCS chars,
        // 3) Data (a bitmap in the url by escaping the binary bytes)
        // Since #2 is very common, we want to try to unescape it so it has meaning
        // to the user.  UnEscaping isn't safe if the user can copy or modify the data
        // because they could loose data when it's reparsed.  One thing we need to
        // do for #2 to work is for it to be in ANSI when unescaped.  This is needed
        // or the DBCS lead and trail bytes will be in unicode as [0x<LeadByte> 0x00]
        // [0x<TrailByte> 0x00].  Being in ANSI could cause a problem if the the string normally
        // crosses code pages, but that is uncommon or non-existent in the IsURLChild()
        // case.
        CHAR szUrlAnsi[MAX_URL_STRING];

        SHTCharToAnsi(szUrl, szUrlAnsi, ARRAYSIZE(szUrlAnsi));
        UrlUnescapeA(szUrlAnsi, NULL, NULL, URL_UNESCAPE_INPLACE|URL_UNESCAPE_HIGH_ANSI_ONLY);
        SHAnsiToTChar(szUrlAnsi, pszUrl, cch);
    }
    else
    {
        StrCpyN(pszUrl, szUrl, cch);    // Truncate if needed
    }

    return S_OK;
}


#define TEGDN_FORSYSTEM     0x00000001

HRESULT CTravelEntry::GetDisplayName(LPTSTR psz, DWORD cch, DWORD dwFlags)
{
    if (!psz || !cch)
        return E_INVALIDARG;

    psz[0] = 0;
    if ((NULL != _pwzTitle) && (*_pwzTitle != 0))
    {
        StrCpyNW(psz, _pwzTitle, cch);
    }
    else if (_pidl)
    {
        GetUnescapedUrlIfAppropriate(_pidl, psz, cch);
    }

    if (dwFlags & TEGDN_FORSYSTEM)
    {
        if (!SHIsDisplayable(psz, g_fRunOnFE, g_bRunOnNT5))
        {
            // Display name isn't system-displayable.  Just use the path/url instead.
            SHTitleFromPidl(_pidl, psz, cch, FALSE);
        }
    }

    SHCleanupUrlForDisplay(psz);
    return psz[0] ? S_OK : E_FAIL;
}

HRESULT CTravelEntry::GetTitle(LPOLESTR *ppszTitle)
{
    HRESULT     hres = S_OK;
    TCHAR       szTitle[MAX_BROWSER_WINDOW_TITLE];

    ASSERT(IS_VALID_WRITE_PTR(ppszTitle, LPOLESTR));

    hres = GetDisplayName(szTitle, MAX_BROWSER_WINDOW_TITLE, TEGDN_FORSYSTEM);

    if(SUCCEEDED(hres))
    {
        ASSERT(*szTitle);

        hres = SHStrDup(szTitle, ppszTitle);
    }

    return hres;
}


HRESULT CTravelEntry::GetURL(LPOLESTR *ppszUrl)
{
    HRESULT         hres = E_FAIL;
    LPITEMIDLIST    pidl = NULL;
    WCHAR           wszURL[MAX_URL_STRING];

    if(_pidl)
        hres = ::IEGetDisplayName(_pidl, wszURL, SHGDN_FORPARSING);

    if(SUCCEEDED(hres))
        hres = SHStrDup(wszURL, ppszUrl);

    return hres;
}

HRESULT CTravelEntry::Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog)
{
    if(!_ppb)
    {
        return E_INVALIDARG;
    }
    return _ppb->Read(pszPropName, pVar, pErrorLog);
}

HRESULT CTravelEntry::Write(LPCOLESTR pszPropName, VARIANT *pVar)
{
    HRESULT hres = S_OK;

    if(!_ppb)
    {
        hres = SHCreatePropertyBagOnMemory(STGM_READWRITE, IID_IPropertyBag, (void **) &_ppb);
    }
    if(SUCCEEDED(hres))
    {
        ASSERT(_ppb);
        hres = _ppb->Write(pszPropName, pVar);
    }
    return hres;
}

    
class CTravelLog : public ITravelLog, 
                   public ITravelLogEx
{
public:
    // *** IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef() ;
    STDMETHODIMP_(ULONG) Release();

    // *** ITravelLog specific methods
    STDMETHODIMP AddEntry(IUnknown *punk, BOOL fIsLocalAnchor);
    STDMETHODIMP UpdateEntry(IUnknown *punk, BOOL fIsLocalAnchor);
    STDMETHODIMP UpdateExternal(IUnknown *punk, IUnknown *punkHLBrowseContext);
    STDMETHODIMP Travel(IUnknown *punk, int iOffset);
    STDMETHODIMP GetTravelEntry(IUnknown *punk, int iOffset, ITravelEntry **ppte);
    STDMETHODIMP FindTravelEntry(IUnknown *punk, LPCITEMIDLIST pidl, ITravelEntry **ppte);
    STDMETHODIMP GetToolTipText(IUnknown *punk, int iOffset, int idsTemplate, LPWSTR pwzText, DWORD cchText);
    STDMETHODIMP InsertMenuEntries(IUnknown *punk, HMENU hmenu, int nPos, int idFirst, int idLast, DWORD dwFlags);
    STDMETHODIMP Clone(ITravelLog **pptl);
    STDMETHODIMP_(DWORD) CountEntries(IUnknown *punk);
    STDMETHODIMP Revert(void);

    // *** ITravelLogEx specific methods
    STDMETHODIMP FindTravelEntryWithUrl(IUnknown * punk, UINT uiCP, LPOLESTR lpszUrl, ITravelEntry ** ppte);
    STDMETHODIMP TravelToUrl(IUnknown * punk, UINT uiCP, LPOLESTR lpszUrl);
    STDMETHOD(DeleteIndexEntry)(IUnknown *punk,  int index);
    STDMETHOD(DeleteUrlEntry)(IUnknown *punk, UINT uiCP, LPOLESTR pszUrl);
    STDMETHOD(CountEntryNodes)(IUnknown *punk, DWORD dwFlags, DWORD *pdwCount);
    STDMETHOD(CreateEnumEntry)(IUnknown *punk, IEnumTravelLogEntry **ppEnum, DWORD dwFlags);
    STDMETHOD(DeleteEntry)(IUnknown *punk, ITravelLogEntry *pte);
    STDMETHOD(InsertEntry)(IUnknown *punkBrowser, ITravelLogEntry *pteRelativeTo, BOOL fPrepend, 
                        IUnknown* punkTLClient, ITravelLogEntry **ppEntry);
    STDMETHOD(TravelToEntry)(IUnknown *punkBrowser, ITravelLogEntry *pteDestination);


    CTravelLog();

protected:
    ~CTravelLog();
    HRESULT _FindEntryByOffset(IUnknown *punk, int iOffset, CTravelEntry **ppte);
    HRESULT _FindEntryByPidl(IUnknown * punk, LPCITEMIDLIST pidl, CTravelEntry ** ppte);
    HRESULT _FindEntryByPunk(IUnknown * punk, ITravelLogEntry *pteSearch, CTravelEntry ** ppte);
        
    void _DeleteFrameSetEntry(IUnknown *punk, CTravelEntry *pte);
    void _Prune(void);
    
    LONG _cRef;
    DWORD _cbMaxSize;
    DWORD _cbTotalSize;

    CTravelEntry *_pteCurrent;  //pteCurrent
    CTravelEntry *_pteUpdate;
    CTravelEntry *_pteRoot;
};

CTravelLog::CTravelLog() : _cRef(1) 
{
    ASSERT(!_pteCurrent);
    ASSERT(!_pteUpdate);
    ASSERT(!_pteRoot);

    DWORD dwType, dwSize = SIZEOF(_cbMaxSize), dwDefault = 1024 * 1024;
    
    SHRegGetUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\TravelLog"), TEXT("MaxSize"), &dwType, (LPVOID)&_cbMaxSize, &dwSize, FALSE, (void *)&dwDefault, SIZEOF(dwDefault));
    TraceMsg(TF_TRAVELLOG, "TL[%X] created", this);
}

CTravelLog::~CTravelLog()
{
    //DestroyList by releasing the root
    SAFERELEASE(_pteRoot);
    TraceMsg(TF_TRAVELLOG, "TL[%X] destroyed ", this);
}

HRESULT CTravelLog::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = { 
        QITABENT(CTravelLog, ITravelLog),   // IID_ITravelLog
        QITABENT(CTravelLog, ITravelLogEx), // IID_ITravelLogEx
        { 0 }, 
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CTravelLog::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CTravelLog::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CTravelLog::AddEntry(IUnknown *punk, BOOL fIsLocalAnchor)
{
    ASSERT(punk);

    if(SHRestricted2W(REST_NoNavButtons, NULL, 0))
    {
        return S_FALSE;
    }

    TraceMsg(TF_TRAVELLOG, "TL[%X]::AddEntry punk = %X, IsLocal = %s", this, punk, fIsLocalAnchor ? "TRUE" : "FALSE");

#ifdef FEATURE_STARTPAGE
    if (!_pteCurrent)
    {
        if (SHRegGetBoolUSValue(REGSTR_PATH_EXPLORER, TEXT("FaultID"), FALSE, FALSE))
        {
            CTravelEntry *pteClose = new CTravelEntry(42);
            if (pteClose)
            {
                _pteRoot = pteClose;
                _pteCurrent = pteClose;
                _cbTotalSize += pteClose->Size();
            }
        }
    }
#endif

    CTravelEntry *pte = new CTravelEntry(fIsLocalAnchor);
    if (pte)
    {
        //replace the current with the new

        if (_pteCurrent)
        {
            CTravelEntry *pteNext = _pteCurrent->GetNext();
            if (pteNext)
            {
                _cbTotalSize -= pteNext->ListSize();
            }

            //  the list keeps its own ref count, and only needs
            //  to be modified when passed outside of the list

            //  setnext will release the current next if necessary
            //  this will also set pte->prev = pteCurrent
            _pteCurrent->SetNext(pte);
        }
        else
            _pteRoot = pte;

        _cbTotalSize += pte->Size();

        _pteCurrent = pte;

        ASSERT(_cbTotalSize == _pteRoot->ListSize());
    }
    TraceMsg(TF_TRAVELLOG, "TL[%X]::AddEntry punk = %X, IsLocal = %d, pte = %X", this, punk, fIsLocalAnchor, pte);

    return pte ? S_OK : E_OUTOFMEMORY;
}

void CTravelLog::_Prune(void)
{
    // FEATURE: need an increment or something

    ASSERT(_cbTotalSize == _pteRoot->ListSize());

    while (_cbTotalSize > _cbMaxSize && _pteRoot != _pteCurrent)
    {
        CTravelEntry *pte = _pteRoot;
        _pteRoot = _pteRoot->GetNext();

        _cbTotalSize -= pte->Size();
        pte->RemoveSelf();

        ASSERT(_cbTotalSize == _pteRoot->ListSize());
    }
}


HRESULT CTravelLog::UpdateEntry(IUnknown *punk, BOOL fIsLocalAnchor)
{
    CTravelEntry *pte = _pteUpdate ? _pteUpdate : _pteCurrent;

    //  this can happen under weird stress conditions, evidently
    if (!pte)
        return E_FAIL;

    _cbTotalSize -= pte->Size();
    HRESULT hr = pte->Update(punk, fIsLocalAnchor);
    _cbTotalSize += pte->Size();

    ASSERT(_cbTotalSize == _pteRoot->ListSize());

    // Debug prints need to be before _Prune() since pte can get freed by _Prune() resulting
    // in a crash if pte->Size() is called
    TraceMsg(TF_TRAVELLOG, "TL[%X]::UpdateEntry pte->Size() = %d", this, pte->Size());
    TraceMsg(TF_TRAVELLOG, "TL[%X]::UpdateEntry punk = %X, IsLocal = %d, hr = %X", this, punk, fIsLocalAnchor, hr);
    
    _Prune();

    _pteUpdate = NULL;

    return hr;
}

HRESULT CTravelLog::UpdateExternal(IUnknown *punk, IUnknown *punkHLBrowseContext)
{
    CTravelEntry *pte = _pteUpdate ? _pteUpdate : _pteCurrent;

    ASSERT(punk);
    ASSERT(pte);
    ASSERT(punkHLBrowseContext);

    if (pte)
        return pte->UpdateExternal(punk, punkHLBrowseContext);

    return E_FAIL;
}

HRESULT CTravelLog::Travel(IUnknown *punk, int iOffset)
{
    ASSERT(punk);
    HRESULT hr = E_FAIL;

    CTravelEntry *pte;

    TraceMsg(TF_TRAVELLOG, "TL[%X]::Travel entered with punk = %X, iOffset = %d", this, punk, iOffset);

    if (SUCCEEDED(_FindEntryByOffset(punk, iOffset, &pte)))
    {
#ifdef DEBUG
            TCHAR szPath[MAX_PATH];
            LPITEMIDLIST pidl;
            pte->GetPidl(&pidl);
            
            SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath), NULL);
            ILFree(pidl);
            TraceMsgW(TF_TRAVELLOG, "TL[%X]::URL %s", this, szPath);
#endif

        // we will update where we are before we move away...
        //  but external navigates dont go through the normal activation
        //  so we dont want to setup the external to be updated
        //  _pteUpdate is also what allows us to Revert().
        if (!_pteCurrent->IsExternal() && !_pteUpdate)
            _pteUpdate = _pteCurrent;

        _pteCurrent = pte;
        hr = _pteCurrent->Invoke(punk);

        //
        //  if the entry bails with an error, then we need to reset ourself
        //  to what we were.  right now, the only place this should happen
        //  is if an Abort was returned from SetPositionCookie
        //  because somebody aborted during before navigate.
        //  but i think that any error means that we can legitimately Revert().
        //
        if (FAILED(hr))
        {
            Revert();
        }
    }

    TraceMsg(TF_TRAVELLOG, "TL[%X]::Travel exited with hr = %X", this, hr);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method    : CTravelLog::TravelToUrl
//
//  Interface : ITravelLogEx
//
//  Synopsis  : Travels to the specified URL in the travel log.
//
//----------------------------------------------------------------------------

HRESULT
CTravelLog::TravelToUrl(IUnknown * punk, UINT uiCP, LPOLESTR lpszUrl)
{
    ASSERT(punk);
    ASSERT(lpszUrl);

    HRESULT        hr;
    LPITEMIDLIST   pidl;
    CTravelEntry * pte    = NULL;
    DWORD          cchOut = INTERNET_MAX_URL_LENGTH;
    TCHAR          szUrl[INTERNET_MAX_URL_LENGTH];
    
    hr = UrlCanonicalize(lpszUrl, szUrl, &cchOut, URL_ESCAPE_SPACES_ONLY);
    if (SUCCEEDED(hr))
    {
        hr = IEParseDisplayName(uiCP, szUrl, &pidl);
        if (SUCCEEDED(hr))
        {
            hr = _FindEntryByPidl(punk, pidl, &pte);
            ILFree(pidl);
    
            if (SUCCEEDED(hr))
            {
                // We will update where we are before we move away...
                // but external navigates don't go through the normal activation
                // so we dont want to setup the external to be updated
                // _pteUpdate is also what allows us to Revert().
                //
                if (!_pteCurrent->IsExternal() && !_pteUpdate)
                {
                    _pteUpdate = _pteCurrent;
                }

                _pteCurrent = pte;
                hr = _pteCurrent->Invoke(punk);
            
                //  If the entry bails with an error, then we need to reset ourself
                //  to what we were. Right now, the only place this should happen
                //  is if an Abort was returned from SetPositionCookie
                //  because somebody aborted during before navigate.
                //  But i think that any error means that we can legitimately Revert().
                //
                if (FAILED(hr))
                {
                    Revert();
                }
            }
        }
    }

    TraceMsg(TF_TRAVELLOG, "TL[%X]::TravelToUrl exited with hr = %X", this, hr);

    return hr;
}


HRESULT CTravelLog::_FindEntryByOffset(IUnknown *punk, int iOffset, CTravelEntry **ppte)
{
    CTravelEntry *pte = _pteCurrent;
    BOOL fAllowLocalAnchor = TRUE;

    if (iOffset < 0)
    {
        while (iOffset && pte)
        {
            pte = pte->GetPrev();
            if (pte && pte->CanInvoke(punk, fAllowLocalAnchor))
            {
                iOffset++;
                fAllowLocalAnchor = fAllowLocalAnchor && pte->IsLocalAnchor();
            }

        }
    }
    else if (iOffset > 0)
    {
        while (iOffset && pte)
        {
            pte = pte->GetNext();
            if (pte && pte->CanInvoke(punk, fAllowLocalAnchor))
            {
                iOffset--;
                fAllowLocalAnchor = fAllowLocalAnchor && pte->IsLocalAnchor();
            }
        }
    }

    if (pte)
    {

        *ppte = pte;
        return S_OK;
    }
    return E_FAIL;
}

HRESULT CTravelLog::GetTravelEntry(IUnknown *punk, int iOffset, ITravelEntry **ppte)
{
    HRESULT hr;
    BOOL fCheckExternal = FALSE;
    if (iOffset == TLOG_BACKEXTERNAL) 
    {
        iOffset = TLOG_BACK;
        fCheckExternal = TRUE;
    }

    if (iOffset == 0)
    {
        //  APPCOMPAT - going back and fore between external apps is dangerous - zekel 24-JUN-97
        //  we always fail if the current is external
        //  this is because word will attempt to navigate us to 
        //  the same url instead of FORE when the user selects
        //  it from the drop down.
        if (_pteCurrent && _pteCurrent->IsExternal())
        {
            hr = E_FAIL;
            ASSERT(!_pteCurrent->GetPrev());
            TraceMsg(TF_TRAVELLOG, "TL[%X]::GetTravelEntry current is External", this);
            goto Quit;
        }
    }

    CTravelEntry *pte;
    hr = _FindEntryByOffset(punk, iOffset, &pte);

    //
    // If TLOG_BACKEXTERNAL is specified, we return S_OK only if the previous
    // entry is external.
    //
    if (fCheckExternal && SUCCEEDED(hr)) {
        if (!pte->IsExternal()) {
            hr = E_FAIL;
        }
        TraceMsg(TF_TRAVELLOG, "TL[%X]::GetTravelEntry(BACKEX)", this);
    }

    if (ppte && SUCCEEDED(hr)) {
        hr = pte->QueryInterface(IID_PPV_ARG(ITravelEntry, ppte));
    }

Quit:

    TraceMsg(TF_TRAVELLOG, "TL[%X]::GetTravelEntry iOffset = %d, hr = %X", this, iOffset, hr);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method    : CTravelLog::FindTravelEntry
//
//  Synopsis  : Finds the travel entry with the specified PIDL and returns
//              the ITravelEntry interface of the entry.
//
//----------------------------------------------------------------------------

HRESULT CTravelLog::FindTravelEntry(IUnknown *punk, LPCITEMIDLIST pidl, ITravelEntry **ppte)
{
    CTravelEntry * pte = _pteRoot;
    
    _FindEntryByPidl(punk, pidl, &pte);
    
    if (pte)
    {
        return pte->QueryInterface(IID_PPV_ARG(ITravelEntry, ppte));
    }

    *ppte =  NULL;
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Method    : CTravelLog::_FindEntryByPidl
//
//  Synopsis  : Finds and returns the travel entry with the specified PIDL.
//              This private method returns a CTravelEntry instead of
//              an ITravelEntry.
//
//----------------------------------------------------------------------------

HRESULT
CTravelLog::_FindEntryByPidl(IUnknown * punk, LPCITEMIDLIST pidl, CTravelEntry ** ppte)
{
    CTravelEntry * pte = _pteRoot;
    BOOL fAllowLocalAnchor = TRUE;

    ASSERT(punk);
    ASSERT(pidl);
    ASSERT(ppte);
    
    while (pte)
    {
        if (pte->CanInvoke(punk, fAllowLocalAnchor) && pte->IsEqual(pidl))
        {
            *ppte = pte;
            return S_OK;
        }

        fAllowLocalAnchor = fAllowLocalAnchor && pte->IsLocalAnchor();

        pte = pte->GetNext();
    }

    *ppte = NULL;
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Method    : CTravelLog::FindEntryByPunk
//
//  Interface : ITravelLogEx
//
//  Synopsis  : Find the entry object given its punk.
//
//----------------------------------------------------------------------------

HRESULT 
CTravelLog::_FindEntryByPunk(IUnknown * punk, ITravelLogEntry *pteSearch, CTravelEntry ** ppte)
{
    CTravelEntry     *pte = _pteRoot;
    ITravelEntry     *pteCur;
    BOOL             fAllowLocalAnchor = TRUE;

    ASSERT(ppte);

    // check for the current entry.
    // often the current entry will fail CanInvoke because it's incomplete at this time.
    if (IsSameObject(pteSearch, SAFECAST(_pteCurrent, ITravelEntry*)))
    {
        *ppte = _pteCurrent;
        return S_OK;
    }

    while (pte)
    {
        pteCur = SAFECAST(pte, ITravelEntry*);
        
        if ((pte->CanInvoke(punk, fAllowLocalAnchor)) && IsSameObject(pteCur, pteSearch))
        {
            *ppte = pte;
            return S_OK;
        }
        
        fAllowLocalAnchor = fAllowLocalAnchor && pte->IsLocalAnchor();
        pte = pte->GetNext();
    }
    
    *ppte = NULL;
    return E_FAIL;
}
//+---------------------------------------------------------------------------
//
//  Method    : CTravelLog::FindTravelEntryWithUrl
//
//  Interface : ITravelLogEx
//
//  Synopsis  : Finds and returns the travel entry with the specified URL.
//
//----------------------------------------------------------------------------

HRESULT 
CTravelLog::FindTravelEntryWithUrl(IUnknown * punk, UINT uiCP, LPOLESTR lpszUrl, ITravelEntry ** ppte)
{
    LPITEMIDLIST pidl;
    HRESULT      hr = E_FAIL;
    
    ASSERT(punk);
    ASSERT(lpszUrl);
    ASSERT(ppte);

    if (SUCCEEDED(IEParseDisplayNameWithBCW(uiCP, lpszUrl, NULL, &pidl)))
    {
        hr = FindTravelEntry(punk, pidl, ppte);
        ILFree(pidl);
    }
        
    return hr;
}


HRESULT CTravelLog::Clone(ITravelLog **pptl)
{
    CTravelLog *ptl = new CTravelLog();
    HRESULT hr = S_OK;

    if (ptl && _pteCurrent)
    {
        // first set the current pointer
        hr = _pteCurrent->Clone(&ptl->_pteCurrent);

        if (SUCCEEDED(hr))
        {
            ptl->_cbTotalSize = _cbTotalSize;
            
            CTravelEntry *pteSrc;
            CTravelEntry *pteClone, *pteDst = ptl->_pteCurrent;
            
            //  then we need to loop forward and set each
            for (pteSrc = _pteCurrent->GetNext(), pteDst = ptl->_pteCurrent;
                pteSrc; pteSrc = pteSrc->GetNext())
            {
                ASSERT(pteDst);
                if (FAILED(pteSrc->Clone(&pteClone)))
                    break;

                ASSERT(pteClone);
                pteDst->SetNext(pteClone);
                pteDst = pteClone;
            }
                
            //then loop back and set them all
            for (pteSrc = _pteCurrent->GetPrev(), pteDst = ptl->_pteCurrent;
                pteSrc; pteSrc = pteSrc->GetPrev())
            {
                ASSERT(pteDst);
                if (FAILED(pteSrc->Clone(&pteClone)))
                    break;

                ASSERT(pteClone);
                pteDst->SetPrev(pteClone);
                pteDst = pteClone;
            }   

            //  the root is the furthest back we could go
            ptl->_pteRoot = pteDst;

        }


    }
    else 
        hr = E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
    {
        ptl->QueryInterface(IID_PPV_ARG(ITravelLog, pptl));
    }
    else 
    {
        *pptl = NULL;
    }
    
    if (ptl) 
        ptl->Release();

    TraceMsg(TF_TRAVELLOG, "TL[%X]::Clone hr = %x, ptlClone = %X", this, hr, ptl);

    return hr;
}

// HACKHACK: 3rd parameter used to be idsTemplate, which we would use to grab the
// string template.  However, since there's no way the caller can specify the hinst
// of the module in which to look for this resource, this broke in the shdocvw /
// browseui split (callers would pass offsets into browseui.dll; we'd look for them in
// shdocvw.dll).  My solution is is to ignore this parameter entirely and assume that:
//
//  if iOffset is negative, the caller wants the "back to" text
//  else, the caller wants the "forward to" text
//
// tjgreen 14-july-98.
//
HRESULT CTravelLog::GetToolTipText(IUnknown *punk, int iOffset, int, LPWSTR pwzText, DWORD cchText)
{
    TCHAR szName[MAX_URL_STRING];
    TCHAR szTemplate[80];

    TraceMsg(TF_TRAVELLOG, "TL[%X]::ToolTip entering iOffset = %d, ptlClone = %X", this, iOffset);
    ASSERT(pwzText);
    ASSERT(cchText);

    *pwzText = 0;

    CTravelEntry *pte;
    HRESULT hr = _FindEntryByOffset(punk, iOffset, &pte);
    if (SUCCEEDED(hr))
    {
        ASSERT(pte);

        pte->GetDisplayName(szName, SIZECHARS(szName), 0);

        int idsTemplate = (iOffset < 0) ? IDS_NAVIGATEBACKTO : IDS_NAVIGATEFORWARDTO;

        if (MLLoadString(idsTemplate, szTemplate, ARRAYSIZE(szTemplate))) {
            DWORD cchTemplateLen = lstrlen(szTemplate);
            DWORD cchLen = cchTemplateLen + lstrlen(szName);
            if (cchLen > cchText) {
                // so that we don't overflow the pwzText buffer
                szName[cchText - cchTemplateLen - 1] = 0;
            }

            wnsprintf(pwzText, cchText, szTemplate, szName);
        }
        else
            hr = E_UNEXPECTED;
    }

    TraceMsg(TF_TRAVELLOG, "TL[%X]::ToolTip exiting hr = %X, pwzText = %ls", this, hr, pwzText);
    return hr;
}

HRESULT CTravelLog::InsertMenuEntries(IUnknown *punk, HMENU hmenu, int iIns, int idFirst, int idLast, DWORD dwFlags)
{
    ASSERT(idLast >= idFirst);
    ASSERT(hmenu);
    ASSERT(punk);

    int cItemsBack = idLast - idFirst + 1;
    int cItemsFore = 0;
    
    CTravelEntry *pte;
    LONG cAdded = 0;
    TCHAR szName[40];
    DWORD cchName = SIZECHARS(szName);
    UINT uFlags = MF_STRING | MF_ENABLED | MF_BYPOSITION;
    TraceMsg(TF_TRAVELLOG, "TL[%X]::InsertMenuEntries entered on punk = %X, hmenu = %X, iIns = %d, idRange = %d-%d, flags = %X", this, punk, hmenu, iIns, idFirst, idLast, dwFlags);


    ASSERT(cItemsFore >= 0);
    ASSERT(cItemsBack >= 0);

    if (IsFlagSet(dwFlags, TLMENUF_INCLUDECURRENT))
        cItemsBack--;

    if (IsFlagSet(dwFlags, TLMENUF_BACKANDFORTH))
    {
        cItemsFore = cItemsBack / 2;
        cItemsBack = cItemsBack - cItemsFore;
    }
    else if (IsFlagSet(dwFlags, TLMENUF_FORE))
    {
        cItemsFore = cItemsBack;
        cItemsBack = 0;
    }

    while (cItemsFore)
    {
        if (SUCCEEDED(_FindEntryByOffset(punk, cItemsFore, &pte)))
        {
            pte->GetDisplayName(szName, cchName, TEGDN_FORSYSTEM);
            ASSERT(*szName);
            FixAmpersands(szName, ARRAYSIZE(szName));
            InsertMenu(hmenu, iIns, uFlags, idLast, szName);
            cAdded++;
            TraceMsg(TF_TRAVELLOG, "TL[%X]::IME Fore id = %d, szName = %s", this, idLast, szName);
        }
        
        cItemsFore--;
        idLast--;
    }

    if (IsFlagSet(dwFlags, TLMENUF_INCLUDECURRENT))
    {
        // clear the name
        *szName = 0;

        //have to get the title from the actual pbs
        IBrowserService *pbs ;
        WCHAR wzTitle[MAX_PATH];

        LPITEMIDLIST pidl = NULL;

        if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IBrowserService, &pbs))))
        {
            pbs->GetPidl(&pidl);

            if (SUCCEEDED(pbs->GetTitle(NULL, wzTitle, SIZECHARS(wzTitle))))
            {
                StrCpyN(szName, wzTitle, cchName);
            }
            else if (pidl)
            {
                GetUnescapedUrlIfAppropriate(pidl, szName, ARRAYSIZE(szName));
            }

            pbs->Release();
        }

        if (!SHIsDisplayable(szName, g_fRunOnFE, g_bRunOnNT5) && pidl)
        {
            // Display name isn't system-displayable.  Just use the path/url instead.
            SHTitleFromPidl(pidl, szName, ARRAYSIZE(szName), FALSE);
        }

        if (!(*szName))
            TraceMsg(TF_ERROR, "CTravelLog::InsertMenuEntries -- failed to find title for current entry");

        ILFree(pidl);

        FixAmpersands(szName, ARRAYSIZE(szName));
        InsertMenu(hmenu, iIns, uFlags | (IsFlagSet(dwFlags, TLMENUF_CHECKCURRENT) ? MF_CHECKED : 0), idLast, szName);
        cAdded++;
        TraceMsg(TF_TRAVELLOG, "TL[%X]::IME Current id = %d, szName = %s", this, idLast, szName);

        idLast--;
    }

    
    if (IsFlagSet(dwFlags, TLMENUF_BACKANDFORTH))
    {
        //  we need to reverse the order of insertion for back
        //  when both directions are displayed
        int i;
        for (i = 1; i <= cItemsBack; i++, idLast--)
        {
            if (SUCCEEDED(_FindEntryByOffset(punk, -i, &pte)))
            {
                pte->GetDisplayName(szName, cchName, TEGDN_FORSYSTEM);
                ASSERT(*szName);
                FixAmpersands(szName, ARRAYSIZE(szName));
                InsertMenu(hmenu, iIns, uFlags, idLast, szName);
                cAdded++;
                TraceMsg(TF_TRAVELLOG, "TL[%X]::IME Back id = %d, szName = %s", this, idLast, szName);

            }
        }
    }
    else while (cItemsBack)
    {
        if (SUCCEEDED(_FindEntryByOffset(punk, -cItemsBack, &pte)))
        {
            pte->GetDisplayName(szName, cchName, TEGDN_FORSYSTEM);
            ASSERT(*szName);
            FixAmpersands(szName, ARRAYSIZE(szName));
            InsertMenu(hmenu, iIns, uFlags, idLast, szName);
            cAdded++;
            TraceMsg(TF_TRAVELLOG, "TL[%X]::IME Back id = %d, szName = %s", this, idLast, szName);
        }

        cItemsBack--;
        idLast--;
    }

    TraceMsg(TF_TRAVELLOG, "TL[%X]::InsertMenuEntries exiting added = %d", this, cAdded);
    return cAdded ? S_OK : S_FALSE;
}

DWORD CTravelLog::CountEntries(IUnknown *punk)
{
    CTravelEntry *pte = _pteRoot;
    DWORD dw = 0;
    BOOL fAllowLocalAnchor = TRUE;

    while (pte)
    {
        if (pte->CanInvoke(punk, fAllowLocalAnchor))
            dw++;

        fAllowLocalAnchor = fAllowLocalAnchor && pte->IsLocalAnchor();

        pte = pte->GetNext();
    }

    TraceMsg(TF_TRAVELLOG, "TL[%X]::CountEntries count = %d", this, dw);
    return dw;
}

HRESULT CTravelLog::Revert(void)
{
    // this function should only be called when
    //  we have travelled, and we stop the travel before finishing
    if (_pteUpdate)
    {
        // trade them back
        _pteCurrent = _pteUpdate;
        _pteUpdate = NULL;
        return S_OK;
    }
    return E_FAIL;
}


//
// delete nodes belonging to the frameset pte 
//
void CTravelLog::_DeleteFrameSetEntry(IUnknown *punk, CTravelEntry *pte)
{
    ASSERT(pte);

    CTravelEntry    *ptetmp = pte;
    BOOL            fAllowLocalAnchor = TRUE;

    while(ptetmp && ptetmp != _pteCurrent)
        ptetmp = ptetmp->GetNext();

    if(ptetmp)
    // entry on left of _pteCurrent , delete on left
        do {
            if(pte == _pteRoot)
                _pteRoot =  pte->GetNext();

            ptetmp = pte;
            pte = pte->GetPrev();
            fAllowLocalAnchor = fAllowLocalAnchor && ptetmp->IsLocalAnchor();

            _cbTotalSize -= ptetmp->Size();
            ptetmp->RemoveSelf();

        } while (pte && !(pte->CanInvoke(punk, fAllowLocalAnchor)));    

    else
        if (pte)
        {
            do {
                ptetmp = pte;
                pte = pte->GetNext();
                fAllowLocalAnchor = fAllowLocalAnchor && ptetmp->IsLocalAnchor();

                _cbTotalSize -= ptetmp->Size();
                ptetmp->RemoveSelf();

            } while(pte && !(pte->CanInvoke(punk, fAllowLocalAnchor)));
        }
    }
    
    
//+---------------------------------------------------------------------------
//
//  Method    : CTravelLog::DeleteIndexEntry
//
//  Interface : ITravelLogEx
//
//  Synopsis  : Delete the entry given by index. 
//
//----------------------------------------------------------------------------

HRESULT CTravelLog::DeleteIndexEntry(IUnknown *punk, int index)
{
    HRESULT         hres = E_FAIL;

    CTravelEntry    *pte;
    IBrowserService *pbs;
    BOOL            fAllowLocalAnchor = TRUE;
    
    ASSERT(punk);

    if (index == 0)              // don't delete current entry
        return hres;            

    hres = _FindEntryByOffset(punk, index, &pte);
    if(SUCCEEDED(hres)) 
    {
        _DeleteFrameSetEntry(punk, pte);

        ASSERT(_cbTotalSize  == _pteRoot->ListSize());
    
        if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IBrowserService, &pbs))))
        {
            pbs->UpdateBackForwardState();
            pbs->Release();
        }
    }
    
    return hres;
}


//+---------------------------------------------------------------------------
//
//  Method    : CTravelLog::DeleteUrlEntry
//
//  Interface : ITravelLogEx
//
//  Synopsis  : Delete all the entries given by URL. Fails for current entry. 
//
//----------------------------------------------------------------------------

HRESULT CTravelLog::DeleteUrlEntry(IUnknown *punk, UINT uiCP, LPOLESTR lpszUrl)
{
    HRESULT         hres = E_FAIL;
    CTravelEntry    *pte;
    IBrowserService *pbs;
    LPITEMIDLIST    pidl;
    BOOL            fAllowLocalAnchor = TRUE;
    int             count = 0;
    
    ASSERT(punk);
    
    if (SUCCEEDED(IEParseDisplayNameWithBCW(uiCP, lpszUrl, NULL, &pidl)))
    {
        // delete only if different from current
        if(!_pteCurrent->IsEqual(pidl))
        {
            hres = S_OK;
            while(SUCCEEDED(_FindEntryByPidl(punk, pidl, &pte)))
            {
                _DeleteFrameSetEntry(punk, pte);
                count++;
                    
                ASSERT(_cbTotalSize == _pteRoot->ListSize());
            }
        } 

        ILFree(pidl);

        if (count && SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IBrowserService, &pbs))))
        {
            pbs->UpdateBackForwardState();
            pbs->Release();
        }
    }   
    return hres;
}

//+---------------------------------------------------------------------------
//
//  Method    : CTravelLog::DeleteEntry
//
//  Interface : ITravelLogEx
//
//  Synopsis  : Delete the entries given by punk. Fails for current entry. 
//
//----------------------------------------------------------------------------
HRESULT CTravelLog::DeleteEntry(IUnknown *punk, ITravelLogEntry *ptleDelete)
{
    HRESULT         hres;

    CTravelEntry    *pte;
    BOOL            fAllowLocalAnchor = TRUE;
    IBrowserService *pbs;

    ASSERT(punk);

    hres = _FindEntryByPunk(punk, ptleDelete, &pte);
    if(SUCCEEDED(hres) && pte != _pteCurrent) // don't remove current
    {
        _DeleteFrameSetEntry(punk, pte);

        ASSERT(_cbTotalSize  == _pteRoot->ListSize());
    
        if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IBrowserService, &pbs))))
        {
            pbs->UpdateBackForwardState();
            pbs->Release();
        }
        
    } else
        hres = E_FAIL;
    
    
    return hres;
}


//+---------------------------------------------------------------------------
//
//  Method    : CTravelLog::CountEntryNodes
//
//  Synopsis  : Counts Back/Forward entries including the current one
//              as given by dwFlags
//
//----------------------------------------------------------------------------

HRESULT CTravelLog::CountEntryNodes(IUnknown *punk, DWORD dwFlags, DWORD *pdwCount)
{
    CTravelEntry    *pte;
    BOOL fAllowLocalAnchor = TRUE;
        
    ASSERT(punk);
    DWORD dwCount = 0;
    
    if(!_pteCurrent)
    {
        *pdwCount = 0;
        return S_OK;
    }

    if(IsFlagSet(dwFlags, TLMENUF_BACK))
    {
        pte = _pteRoot;
        while (pte != _pteCurrent)
        {
            if(pte->CanInvoke(punk, fAllowLocalAnchor))
            {
                dwCount++;
                fAllowLocalAnchor = fAllowLocalAnchor && pte->IsLocalAnchor();
            }   
            pte = pte->GetNext();
        }
    } 

    if(IsFlagSet(dwFlags, TLMENUF_INCLUDECURRENT))
    {
        if(_pteCurrent->CanInvoke(punk, fAllowLocalAnchor))
        {
            dwCount++;
            fAllowLocalAnchor = fAllowLocalAnchor && _pteCurrent->IsLocalAnchor();
        }   
    }
    
    if(IsFlagSet(dwFlags, TLMENUF_FORE))
    {
        pte = _pteCurrent->GetNext();
        while (pte)
        {
            if(pte->CanInvoke(punk, fAllowLocalAnchor))
            {
                dwCount++;
                fAllowLocalAnchor = fAllowLocalAnchor && pte->IsLocalAnchor();
            }   
            pte = pte->GetNext();
        }
    } 

    *pdwCount = dwCount;
    
    TraceMsg(TF_TRAVELLOG, "TL[%X]::CountEntryNodes count = %d", this, *pdwCount);
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Method    : CTravelLog::CreateEnumEntry
//
//  Synopsis  : Returns an enumerator object for the back/fore travel entries 
//              as selected by the dwFlags option
//
//----------------------------------------------------------------------------
HRESULT 
CTravelLog::CreateEnumEntry(IUnknown *punk, IEnumTravelLogEntry **ppEnum, DWORD dwFlags)
{
    HRESULT     hres = E_OUTOFMEMORY;
    CEnumEntry  *penum;

    ASSERT(punk);
    ASSERT(ppEnum);
    
    *ppEnum = 0;
    
    penum = new CEnumEntry();

    if(penum)
    {
        penum->Init(this, punk, 0, dwFlags);
        *ppEnum = SAFECAST(penum, IEnumTravelLogEntry *);
        hres = S_OK;
    }

    return hres;
}

//+---------------------------------------------------------------------------
//
//  Method    : CTravelLogEx::InsertEntry
//
//  Synopsis  : Inserts an entry into the specified position in the 
//              travellog and calls Update with the given IUnknown.
//
//----------------------------------------------------------------------------
HRESULT
CTravelLog::InsertEntry(IUnknown *punkBrowser, ITravelLogEntry *pteRelativeTo, BOOL fPrepend, 
                        IUnknown* punkTLClient, ITravelLogEntry **ppEntry)
{
    HRESULT    hres = E_FAIL;
    CTravelEntry * pteRelative;
    CTravelEntry * pte;
    IBrowserService *pbs;
        
    TraceMsg(TF_TRAVELLOG, "TL[%X]::InsertEntry", this);
  
    ASSERT(punkBrowser);

    _FindEntryByPunk(punkBrowser, pteRelativeTo, &pteRelative);

    if (!pteRelative)
        pteRelative = _pteCurrent;

    pte = new CTravelEntry(FALSE);

    if (!pte)
        return E_OUTOFMEMORY;

    if (fPrepend)
    {
        // keep relative alive as it's reconnected
        pteRelative->AddRef();
        pte->SetPrev(pteRelative->GetPrev());
        pteRelative->SetPrev(pte);
        if (pteRelative == _pteRoot)
        {
            _pteRoot = pte;
        }
    }
    else
    {
        CTravelEntry * pteNext = pteRelative->GetNext();
        if (pteNext)
            pteNext->AddRef();
        pte->SetNext(pteNext);
        pteRelative->SetNext(pte);
    }

    // update will fill in all the data from the passed in TL Client
    hres = pte->Update(punkTLClient, FALSE);

    _cbTotalSize += pte->Size();
    ASSERT(_cbTotalSize == _pteRoot->ListSize());

    if (SUCCEEDED(punkBrowser->QueryInterface(IID_PPV_ARG(IBrowserService, &pbs))))
    {
        pbs->UpdateBackForwardState();
        pbs->Release();
        hres = S_OK;
    }

    // return the ITLEntry for the new entry
    if (SUCCEEDED(hres) && ppEntry)
    {
        hres = pte->QueryInterface(IID_PPV_ARG(ITravelLogEntry, ppEntry));
    }

    return hres;
}

//+---------------------------------------------------------------------------
//
//  Method    : CTravelLog::TravelToEntry
//
//  Synopsis  : Travels directly to the specified entry.
//              Invoke cannot be called directly due to update strangeness.
//
//----------------------------------------------------------------------------
HRESULT CTravelLog::TravelToEntry(
    IUnknown *punkBrowser,
    ITravelLogEntry *pteDestination)
{
    HRESULT hr = E_FAIL;
    CTravelEntry    *pte = NULL;

    ASSERT(punkBrowser);
    ASSERT(pteDestination);

    _FindEntryByPunk(punkBrowser, pteDestination , &pte);
    if (pte)
    {
        if (!_pteCurrent->IsExternal() && !_pteUpdate)
            _pteUpdate = _pteCurrent;

        _pteCurrent = pte;

        hr = pte->Invoke(punkBrowser);

        if (FAILED(hr))
        {
            Revert();
        }
    }


    return hr;
}


#ifdef TRAVELDOCS
GetNewDocument()
{
    new CTraveledDocument();

    ptd->Init();

    DPA_Add(ptd);
    DPA_Sort();
}

// really need to use ILIsEqual() instead of this

int ILCompareFastButWrong(LPITEMIDLIST pidl1, LPITEMIDLIST pidl2)
{
    int iret;
    DWORD cb1 = ILGetSize(ptd1->_pidl); 
    DWORD cb2 = ILGetSize(ptd2->_pidl);
    iret = cb1 - cb2;
    if (0 == iret)
        iret = memcmp(pidl1, cb1, pidl2, cb2);
    return iret;
}

static int CTraveledDocument::Compare(PTRAVELEDDOCUMENT ptd1, PTRAVELEDDOCUMENT ptd2)
{
    int iret;
    
    iret = ptd1->_type - ptd2->_type;
    if (0 = iret)
    {
        iret = ptd1->_hash - ptd2->_hash;
        if (0 == iret)
        {
            switch (ptd1->_type)
            {
            case TDOC_PIDL:
                iret = ILCompareFastButWrong(ptd1->_pidl, ptd2->_pidl);
                break;

            case TDOC_URL:
                iret = UrlCompare((LPTSTR)ptd1->_strUrl, (LPTSTR)ptd2->_strUrl, FALSE);
                break;

            default:
                ASSERT(FALSE);
            }
        }
    }
    return iret;
}
#endif //TRAVELDOCS


HRESULT CreateTravelLog(ITravelLog **pptl)
{
    HRESULT hres;
    CTravelLog *ptl =  new CTravelLog();
    if (ptl)
    {
        hres = ptl->QueryInterface(IID_PPV_ARG(ITravelLog, pptl));
        ptl->Release();
    }
    else
    {
        *pptl = NULL;
        hres = E_OUTOFMEMORY;
    }
    return hres;
}

CEnumEntry::CEnumEntry() :_cRef(1)
{   
    ASSERT(!_ptl);
    ASSERT(!_punk);

    TraceMsg(TF_TRAVELLOG, "EET[%X] created ", this);
}

CEnumEntry::~CEnumEntry()
{
    SAFERELEASE(_ptl);
    SAFERELEASE(_punk);
    
    TraceMsg(TF_TRAVELLOG, "EET[%X] destroyed ", this);
}

HRESULT CEnumEntry::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = { 
        QITABENT(CEnumEntry, IEnumTravelLogEntry), 
        { 0 }, 
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CEnumEntry::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CEnumEntry::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}


void CEnumEntry::Init(CTravelLog *ptl, IUnknown *punk, DWORD dwOffset, DWORD dwFlags)
{
    ASSERT(ptl);
    ASSERT(punk);
    
    _ptl        = ptl;
    _dwFlags    = dwFlags;
    _punk       = punk;
    _dwOffset   = dwOffset;
    _lStart     = 0;
    
    _ptl->AddRef();
    _punk->AddRef();
    
    SetBase();
}

void  CEnumEntry::SetBase()
{   
    ITravelEntry *ptetmp;

// the start is always computed relative to the current entry
    if(IsFlagSet(_dwFlags, TLEF_RELATIVE_FORE|TLEF_RELATIVE_BACK))
    {
        _lStart = -1;
        while(SUCCEEDED(_ptl->GetTravelEntry(_punk, _lStart, &ptetmp)))
        {
            _lStart--;
            ptetmp->Release();
        }
        _lStart++;
    }
    else if(!IsFlagSet(_dwFlags, TLEF_RELATIVE_INCLUDE_CURRENT))
        _lStart = IsFlagSet(_dwFlags, TLEF_RELATIVE_BACK) ? -1: 1;
}

HRESULT CEnumEntry::Reset()
{
    _dwOffset = 0;

// base changes when add/delete entries
    SetBase();
    return S_OK;
}

HRESULT CEnumEntry::Skip(ULONG cElt)
{
    HRESULT        hres;
    ITravelEntry   *pte;
    ULONG          uCount;
    LONG           lIndex;
    BOOL           fToRight;
    BOOL           fIncludeCurrent;
    
    fToRight = IsFlagSet(_dwFlags, TLEF_RELATIVE_FORE);
    fIncludeCurrent = IsFlagSet(_dwFlags, TLEF_RELATIVE_INCLUDE_CURRENT);

    for (uCount = 0;  uCount < cElt; uCount++)
    {
        lIndex = fToRight ? _lStart + _dwOffset : _lStart - _dwOffset;
        if(lIndex || fIncludeCurrent)
        {
           if(SUCCEEDED(hres = _ptl->GetTravelEntry(_punk, lIndex, &pte)))
            {   
                _dwOffset++;
                pte->Release();
            }
            else
                break;
        }
        else
        {
            _dwOffset++;
            uCount--;
        }
    }
        
    if ( uCount != cElt )
        hres = S_FALSE;

    return hres;
}

HRESULT CEnumEntry::Next(ULONG  cElt, ITravelLogEntry **rgpte2, ULONG *pcEltFetched)
{
    HRESULT         hres = S_OK;
    ULONG           uCount = 0;
    ITravelEntry    *pte;
    LONG            lIndex;
    BOOL           fToRight;
    BOOL           fIncludeCurrent;
    
    fToRight = IsFlagSet(_dwFlags, TLEF_RELATIVE_FORE);
    fIncludeCurrent = IsFlagSet(_dwFlags, TLEF_RELATIVE_INCLUDE_CURRENT);
    
    if(pcEltFetched)
        *pcEltFetched = 0;
        
    for (uCount = 0; uCount < cElt; uCount++)
    {
        lIndex = fToRight ? _lStart + _dwOffset : _lStart - _dwOffset;
        if(lIndex || fIncludeCurrent)
        {
            hres = _ptl->GetTravelEntry(_punk, lIndex, &pte);
       
            if(SUCCEEDED(hres))
            {
                _dwOffset++;
                pte->QueryInterface(IID_PPV_ARG(ITravelLogEntry, &rgpte2[uCount]));
                pte->Release();
            }
            else
                break;  
        } 
        else
        {        
            _dwOffset++;
            uCount--;
        }
    }
    
    if (pcEltFetched )
        *pcEltFetched = uCount;

    if ( uCount != cElt )
    {
        hres = S_FALSE;
        for(;uCount < cElt; uCount++)
            rgpte2[uCount] = 0;
    }

    return hres;
}

STDMETHODIMP CEnumEntry::Clone(IEnumTravelLogEntry **ppEnum)
{
    HRESULT     hres = E_OUTOFMEMORY;
    CEnumEntry  *penum;

    ASSERT(ppEnum);
    
    *ppEnum = 0;
    penum = new CEnumEntry();

    if(penum)
    {
        penum->Init(_ptl, _punk, _dwOffset, _dwFlags);
        *ppEnum = SAFECAST(penum, IEnumTravelLogEntry*);
        hres = S_OK;
    }

    return hres;
}


// Helper object for creating new travel entries
class CPublicTravelLogCreateHelper : public ITravelLogClient, IPersistHistory
{
public:
    // *** IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef() ;
    STDMETHODIMP_(ULONG) Release();

    // ITravelLogClient methods

    STDMETHODIMP FindWindowByIndex(DWORD dwID, IUnknown **ppunk);
    STDMETHODIMP GetWindowData(WINDOWDATA *pwindata);
    STDMETHODIMP LoadHistoryPosition(LPOLESTR pszUrlLocation, DWORD dwCookie)
    { return SetPositionCookie(dwCookie); }
    
    // IPersist methods. (dummy)
    STDMETHODIMP GetClassID(CLSID *pClassID)
    { ASSERT(FALSE); return E_NOTIMPL; } 
 
    // IPersistHistory methods. (dummy)
    // These should never be called, but Update QI's the client to see if it supports IPH.
    STDMETHODIMP LoadHistory(IStream *pStream, IBindCtx *pbc)
    { return E_NOTIMPL; }

    STDMETHODIMP SaveHistory(IStream *pStream)
    { ASSERT(FALSE); return S_OK; }

    STDMETHODIMP SetPositionCookie(DWORD dwPositioncookie)
    { return E_NOTIMPL; }
    
    STDMETHODIMP GetPositionCookie(DWORD *pdwPositioncookie)
    { return E_NOTIMPL; }


    CPublicTravelLogCreateHelper(IBrowserService *pbs, LPCOLESTR pszUrl, LPCOLESTR pszTitle);
    

protected:
    ~CPublicTravelLogCreateHelper();

    LONG                 _cRef;
    IBrowserService        *_pbs;
    LPOLESTR             _pszUrl;
    LPOLESTR             _pszTitle;
};

CPublicTravelLogCreateHelper::CPublicTravelLogCreateHelper(IBrowserService *pbs, LPCOLESTR pszUrl, LPCOLESTR pszTitle) : _pbs(pbs), _cRef(1) 
{
    ASSERT(_pbs);
    ASSERT(!_pszUrl);
    ASSERT(!_pszTitle);
    ASSERT(pszUrl);
    ASSERT(pszTitle);

    if(_pbs)
        _pbs->AddRef();
    if(pszUrl)
    {
        SHStrDup(pszUrl, &_pszUrl);
    }
    if(pszTitle)
    {
        SHStrDup(pszTitle, &_pszTitle);
    }
    
    TraceMsg(TF_TRAVELLOG, "TPLCH[%X] created", this);
}

CPublicTravelLogCreateHelper::~CPublicTravelLogCreateHelper()
{
    SAFERELEASE(_pbs);
    CoTaskMemFree(_pszUrl);
    CoTaskMemFree(_pszTitle);

    TraceMsg(TF_TRAVELLOG, "TPLCH[%X] destroyed ", this);
}

HRESULT CPublicTravelLogCreateHelper ::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = { 
        QITABENT(CPublicTravelLogCreateHelper , ITravelLogClient),
        QITABENT(CPublicTravelLogCreateHelper , IPersistHistory),
        QITABENT(CPublicTravelLogCreateHelper , IPersist),
        { 0 }, 
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CPublicTravelLogCreateHelper ::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CPublicTravelLogCreateHelper ::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}


// ITravelLogClient::FindWindowByIndex
HRESULT
CPublicTravelLogCreateHelper::FindWindowByIndex(DWORD dwID, IUnknown **ppunk)
{
    *ppunk = NULL;
    return E_NOTIMPL;
}


// ITravelLogClient::GetWindowData
// turns around and talks to the browser
HRESULT 
CPublicTravelLogCreateHelper::GetWindowData(WINDOWDATA *pwindata)
{
    HRESULT hres;

    ITravelLogClient2 *pcli;
    hres = _pbs->QueryInterface(IID_PPV_ARG(ITravelLogClient2, &pcli));
    if (SUCCEEDED(hres))
        hres = pcli->GetDummyWindowData(_pszUrl, _pszTitle, pwindata);

    if (pcli)
        pcli->Release();

    return SUCCEEDED(hres) ? S_OK : E_FAIL;
}


// Implements the publicly exposed interface ITravelLogStg (can be QS'd for from top browser)
class CPublicTravelLog : public ITravelLogStg
{
public:
    // *** IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef() ;
    STDMETHODIMP_(ULONG) Release();

    // *** ITravelLogStg specific methods
    STDMETHODIMP CreateEntry(LPCOLESTR pszUrl, LPCOLESTR pszTitle, ITravelLogEntry *ptleRelativeTo, 
                            BOOL fPrepend, ITravelLogEntry **pptle);
    STDMETHODIMP TravelTo(ITravelLogEntry *ptle);
    STDMETHODIMP EnumEntries(TLENUMF flags, IEnumTravelLogEntry **ppenum);
    STDMETHODIMP FindEntries(TLENUMF flags, LPCOLESTR pszUrl, IEnumTravelLogEntry **ppenum);
    STDMETHODIMP GetCount(TLENUMF flags, DWORD *pcEntries);
    STDMETHODIMP RemoveEntry(ITravelLogEntry *ptle);
    STDMETHODIMP GetRelativeEntry(int iOffset, ITravelLogEntry **ptle);

    CPublicTravelLog(IBrowserService *pbs, ITravelLogEx *ptlx);
    

protected:
    ~CPublicTravelLog();

    LONG                 _cRef;
    IBrowserService        *_pbs;
    ITravelLogEx        *_ptlx;
};


CPublicTravelLog::CPublicTravelLog(IBrowserService *pbs, ITravelLogEx *ptlx) : _pbs(pbs), _ptlx(ptlx), _cRef(1) 
{
    ASSERT(pbs);
    ASSERT(ptlx);

    // We don't addref _pbs because we are always contained within the browser serivce, 
    // so avoid the circular ref.
    if(_ptlx)
        _ptlx->AddRef();
    
    TraceMsg(TF_TRAVELLOG, "TLP[%X] created", this);
}

CPublicTravelLog::~CPublicTravelLog()
{
    // We don't need to release _pbs because we are always contained within the browser serivce, 
    // so we didn't addref to avoid the circular ref so don't release 
    SAFERELEASE(_ptlx);
    
    TraceMsg(TF_TRAVELLOG, "TLP[%X] destroyed ", this);
}

HRESULT CPublicTravelLog::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = { 
        QITABENT(CPublicTravelLog, ITravelLogStg),       // IID_ITravelLogStg
        { 0 }, 
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CPublicTravelLog::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CPublicTravelLog::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}


//+---------------------------------------------------------------------------
//
//  Method    : CPublicTravelLog::CreateEntry
//
//  Interface : ITravelLogStg
//
//  Synopsis  : Insert a new dummy entry.
//              Creates an entry in the travel log and passes CPTHCEHelper
//              as travel log client; that gets called back and fills in the
//              data from the browser.
//
//----------------------------------------------------------------------------

HRESULT CPublicTravelLog::CreateEntry(LPCOLESTR pszUrl, LPCOLESTR pszTitle, ITravelLogEntry *ptleRelativeTo, 
                                      BOOL fPrepend, ITravelLogEntry **pptle)
{
    HRESULT     hres = E_FAIL;
    CPublicTravelLogCreateHelper * ptlch;
    ITravelLogClient *ptlc;

    ptlch = new CPublicTravelLogCreateHelper(_pbs, pszUrl, pszTitle);
    if (!ptlch)
        return E_OUTOFMEMORY;
    ptlc = SAFECAST(ptlch, ITravelLogClient *);

    if (ptlc)
    {
        // Create TLogEntry and have it get its data from the helper.
        hres = _ptlx->InsertEntry(_pbs, ptleRelativeTo, fPrepend, ptlc, pptle);
    }

    ptlc->Release();

    return hres;
}


HRESULT CPublicTravelLog::TravelTo(ITravelLogEntry *ptle)
{
    if (ptle)
        return _ptlx->TravelToEntry(_pbs, ptle);
    else
        return E_POINTER;
}

//+---------------------------------------------------------------------------
//
//  Method    : CPublicTravelLog::EnumEntries
//
//  Interface : ITravelLogStg
//
//  Synopsis  : Get an enumerators for specific entries given by flags.
//              Flags should match with those used by ITravelLogEx!
//
//----------------------------------------------------------------------------
HRESULT CPublicTravelLog::EnumEntries(TLENUMF flags, IEnumTravelLogEntry **ppenum)
{    
    return _ptlx->CreateEnumEntry(_pbs, ppenum, flags);
}


//+---------------------------------------------------------------------------
//
//  Method    : CPublicTravelLog::FindEntries
//
//  Interface : ITravelLogStg
//
//  Synopsis  : Allow to retrieve  duplicate entries.
//              Flags should match with those used by ITravelLogEx!
//
//----------------------------------------------------------------------------
HRESULT CPublicTravelLog::FindEntries(TLENUMF flags, LPCOLESTR pszUrl, IEnumTravelLogEntry **ppenum)
{
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
//  Method    : CPublicTravelLog::GetCount
//
//  Interface : ITravelLogStg
//
//  Synopsis  : Public methods to get ITravelLogEx count.
//              Flags should match with those used by ITravelLogEx!
//
//----------------------------------------------------------------------------
HRESULT CPublicTravelLog::GetCount(TLENUMF flags, DWORD *pcEntries)
{
    return _ptlx->CountEntryNodes(_pbs, flags, pcEntries);
}


//+---------------------------------------------------------------------------
//
//  Method    : CPublicTravelLog::RemoveEntry
//
//  Interface : ITravelLogStg
//
//  Synopsis  : Delete the entry ant its frameset.
//
//----------------------------------------------------------------------------
HRESULT CPublicTravelLog::RemoveEntry(ITravelLogEntry *ptle)
{
    HRESULT     hr = E_FAIL;

    if(ptle)
          hr = _ptlx->DeleteEntry(_pbs, ptle);
     
    return hr;
}


HRESULT CPublicTravelLog::GetRelativeEntry(int iOffset, ITravelLogEntry **pptle)
{
    HRESULT            hr = E_FAIL;
    ITravelEntry*    pte;
    ITravelLog*        ptl;

    if(SUCCEEDED(_ptlx->QueryInterface(IID_PPV_ARG(ITravelLog, &ptl))))
    {
        hr =  ptl->GetTravelEntry(_pbs, iOffset, &pte);
        if(SUCCEEDED(hr) && pte)
        {
            hr = pte->QueryInterface(IID_PPV_ARG(ITravelLogEntry, pptle));
            pte->Release();
        }
        ptl->Release();
    }

    return hr;
}

// public method used by the browser to create us
HRESULT CreatePublicTravelLog(IBrowserService *pbs, ITravelLogEx* ptlx, ITravelLogStg **pptlstg)
{
    HRESULT         hres;
    
    CPublicTravelLog *ptlp =  new CPublicTravelLog(pbs, ptlx);
    
    if (ptlp)
    {
        hres = ptlp->QueryInterface(IID_PPV_ARG(ITravelLogStg, pptlstg));
        ptlp->Release();        
    }
    else
    {
        *pptlstg = NULL;
        hres = E_OUTOFMEMORY;
    }
    return hres;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\track.h ===
#ifndef TRACK_INC_
#define TRACK_INC_

#include "urltrack.h"

typedef struct _LRecord
{
    struct _LRecord    *pNext;
    LPTSTR              pthisUrl;         // URL name of this document
    DWORD               Context;         // browsing from
    BOOL                fuseCache;
    FILETIME            ftIn;
}LRecord;

class   CUrlTrackingStg : public IUrlTrackingStg
{
public:
     CUrlTrackingStg ();
    ~CUrlTrackingStg (void);

    // IUnknown methods
    virtual STDMETHODIMP  QueryInterface(REFIID riid, PVOID *ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // IUrlTrackingStg methods
    STDMETHODIMP     OnLoad(LPCTSTR lpUrl, BRMODE ContextMode, BOOL fUseCache);
    STDMETHODIMP     OnUnload(LPCTSTR lpUrl);

protected:
    LPINTERNET_CACHE_ENTRY_INFO          QueryCacheEntry (LPCTSTR lpUrl);

    HANDLE           OpenLogFile (LPCTSTR lpFileName);
    HRESULT          UpdateLogFile(LRecord* pNode, SYSTEMTIME* pst);

    LRecord*         AddNode();
    void             DeleteAllNode();
    void             DeleteFirstNode();
    void             DeleteCurrentNode(LRecord *pThis);
    LRecord*         FindCurrentNode(LPCTSTR lpUrl);

    void             cleanup();
    void             ReadTrackingPrefix();
    BOOL             ConvertToPrefixedURL(LPCTSTR lpszUrl, LPTSTR *lplpPrefixedUrl);

    HRESULT          WininetWorkAround(LPCTSTR lpszUrl, LPCTSTR lpOldFile, LPTSTR lpFile);
    void             DetermineAppModule();

private:
    DWORD   _cRef;
            
    HANDLE           _hFile;                // handle to log file
    LRecord         *_pRecords;             // link list of tracked items
    LPTSTR           _lpPfx;    

    BOOL             _fModule:1;
    BOOL             _fScreenSaver:1;
};


#endif // TRACK_INC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\trsite.cpp ===
#include "priv.h"
#include "basesb.h"

#define DISPID_ONTRANSITIONFINISH     1
const GUID DIID_ICSSTransitionEvents = {0x8E64AA50L,0xDC42,0x11D0,0x99,0x49,0x00,0xA0,0xC9,0x0A,0x8F,0xF2};

//
// Notes:
//  - CTransitionSite object is always contained in a CBaseBrowser object,
//   therefore, it does not have its own reference count.
//  - The macro CONTAINERMAP maps the pointer to this object up to the
//   containing object.
//  - CTransitionSite is a friend class of CBaseBrowser class.
//
// Notes:
//  - Having anything be a friend of CBaseBrowser is not good.
//  - This object is completely contained by it's parent object,
//    so to avoid a reference loop we keep our pContainer pointer
//    with no reference. Do not QI off it or we will leak!
//
#define TF_TRSITE           0
#define TF_TRDRAW           TF_ALWAYS
#define TF_TREXTDRAW        0
#define TF_TRLIFE           0
#define TF_ADDREFRELEASE    0
#define TF_TRSPB            0
#define TF_DEBUGQI          0

/////////////////////////////////////////////////////////////////////////////
// Design constants
/////////////////////////////////////////////////////////////////////////////
#define MIN_TRANSITION_DURATION     0.0
#define MAX_TRANSITION_DURATION     100.0

#define MIN_ONVIEWCHANGE_DURATION   1500    // ms

#define TSPB_CREATE_INCR            4
    // CTransitionSitePropertyBag property list create size

/////////////////////////////////////////////////////////////////////////////
// Module variables
/////////////////////////////////////////////////////////////////////////////
static const TCHAR      c_szTransitionsKey[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CSSFilters");
static const OLECHAR    c_szDurationProp[] = OLESTR("Duration");
static OLECHAR *        s_szApplyMethod = OLESTR("Apply");
static OLECHAR *        s_szPlayMethod = OLESTR("Play");
static OLECHAR *        s_szStopMethod = OLESTR("Stop");

/////////////////////////////////////////////////////////////////////////////
// CTransitionSite
/////////////////////////////////////////////////////////////////////////////
#undef THISCLASS

CTransitionSite::CTransitionSite
(
    IShellBrowser * pcont
) : _pContainer(pcont) // DO NOT ADDREF
{
    TraceMsg(TF_TRLIFE, "TRS::ctor called");

    ASSERT(pcont != NULL);

    _uState = TRSTATE_NONE;
    _ptiCurrent = NULL;
}

CTransitionSite::~CTransitionSite
(
)
{
    TraceMsg(TF_TRLIFE, "TRS::dtor called");

#ifdef DEBUG
    ASSERT(_pSite == NULL);
    ASSERT(_psvNew == NULL);
    ASSERT(_pvoNew == NULL);
    ASSERT(_hwndViewNew == NULL);
    ASSERT(_pTransition == NULL);
    ASSERT(_pDispTransition == NULL);
    ASSERT(_dwTransitionSink == NULL);
#endif  // DEBUG

    for (int te = teFirstEvent; te < teNumEvents; te++)
        SAFERELEASE(_tiEventInfo[te].pPropBag);
}

/////////////////////////////////////////////////////////////////////////////
// CTransitionSite::_ApplyTransition
/////////////////////////////////////////////////////////////////////////////
HRESULT CTransitionSite::_ApplyTransition
(
    BOOL bSiteChanging
)
{
    HRESULT hrResult = S_OK;

    TraceMsg(TF_TRSITE, "TRS::_ApplyTransition(%d) called", bSiteChanging);

    if (_ptiCurrent != NULL)
        _OnComplete();

    ASSERT(_ptiCurrent == NULL);

    if (bSiteChanging && (_tiEventInfo[teSiteEnter].clsid != CLSID_NULL))
        _ptiCurrent = &_tiEventInfo[teSiteEnter];
    else if (_tiEventInfo[tePageEnter].clsid != CLSID_NULL)
        _ptiCurrent = &_tiEventInfo[tePageEnter];
    else
        _ptiCurrent = NULL;

    // Allow the contatiner a chance to set a transition if we don't have one.
    if (_ptiCurrent == NULL)
    {
        // vaIn.vt = VT_BOOL; vaIn.boolVal = Site is changing;
        VARIANTARG  vaIn = { VT_BOOL, bSiteChanging };

        // vaOut[0].vt = VT_I4; vaOut[0].lVal = TransitionEvent
        // vaOut[1].vt = VT_BSTR; vaOut[1].bstrVal = Transition String.
        VARIANTARG  vaOut[2] = { 0 };

        if (SUCCEEDED(hrResult = IUnknown_Exec(_pContainer,
                                                    &CGID_ShellDocView,
                                                    SHDVID_GETTRANSITION,
                                                    OLECMDEXECOPT_DODEFAULT,
                                                    &vaIn,
                                                    vaOut)))
        {
            TRANSITIONINFO ti = { 0 };

            if  (
                (vaOut[0].vt == VT_I4)
                &&
                ((vaOut[0].lVal >= teFirstEvent) && (vaOut[0].lVal < teNumEvents))
                &&
                (vaOut[1].vt == VT_BSTR)
                &&
                (vaOut[1].bstrVal != NULL)
                &&
                ParseTransitionInfo((LPWSTR)vaOut[1].bstrVal, &ti)
                )
            {
                hrResult = _SetTransitionInfo((TransitionEvent)vaOut[0].lVal, &ti);
                _ptiCurrent = &_tiEventInfo[vaOut[0].lVal];
            }
            else
                hrResult = E_UNEXPECTED;

            SAFERELEASE(ti.pPropBag);
        }

        TraceMsg(TF_TRSITE, "hrResult = 0x%.8X after _pContainer->Exec()", hrResult);

        VariantClear(&vaOut[0]);
        VariantClear(&vaOut[1]);
    }

    if (SUCCEEDED(hrResult))
    {
        if (SUCCEEDED(hrResult = _LoadTransition()))
        {
            ASSERT(_hwndViewNew != NULL);

            // We need to hide the view window to draw on our own DC.
            _fViewIsVisible = ::IsWindowVisible(_hwndViewNew);
            if (_fViewIsVisible)
                ::ShowWindow(_hwndViewNew, SW_HIDE);

            _pContainer->EnableModelessSB(FALSE);
        }
    }
    else
    {
        // Make sure we don't fiddle with the window visibility
        // in _OnComplete if we didn't succeed.
        _hwndViewNew = NULL;

        _OnComplete();
    }

    return hrResult;
}

/////////////////////////////////////////////////////////////////////////////
// CTransitionSite::_LoadTransition
/////////////////////////////////////////////////////////////////////////////
HRESULT CTransitionSite::_LoadTransition
(
)
{
    HRESULT hrResult;

    TraceMsg(TF_TRSITE, "TRS::_LoadTransition called");

    if ((_ptiCurrent == NULL) || (_ptiCurrent->clsid == CLSID_NULL))
        return E_INVALIDARG;

    // Create the transition.
    for (;;)
    {
        ASSERT(_pTransition == NULL);
        if (FAILED(hrResult = CoCreateInstance( _ptiCurrent->clsid,
                                                NULL,
                                                CLSCTX_INPROC_SERVER,
                                                IID_IHTMLViewFilter,
                                                (void **)&_pTransition)))
        {
            TraceMsg(TF_ERROR, "TRS::_LoadTransition CoCreateInstance failed 0x%X", hrResult);
            break;
        }

        ASSERT(_pDispTransition == NULL);
        if (FAILED(hrResult = _pTransition->QueryInterface( IID_IDispatch,
                                                            (void **)&_pDispTransition)))
        {
            TraceMsg(TF_ERROR, "TRS::_LoadTransition QI::IDispatch failed 0x%X", hrResult);
            break;
        }

        ASSERT(_dwTransitionSink == 0);
        if (FAILED(hrResult = ConnectToConnectionPoint( SAFECAST(this, IDispatch *),
                                                        DIID_ICSSTransitionEvents,
                                                        TRUE,
                                                        _pTransition,
                                                        &_dwTransitionSink,
                                                        NULL)))
        {
            TraceMsg(TF_ERROR, "TRS::_LoadTransition ConnectToConnectionPoint failed 0x%X", hrResult);
            break;
        }

        // Supply the property bag to the transition (if needed)
        IPersistPropertyBag * pPersistPropBag;
        if  (
            (_ptiCurrent->pPropBag != NULL)
            &&
            SUCCEEDED(_pTransition->QueryInterface(IID_IPersistPropertyBag, (void **)&pPersistPropBag))
            )
        {
            EVAL(SUCCEEDED(pPersistPropBag->InitNew()));
            EVAL(SUCCEEDED(pPersistPropBag->Load(SAFECAST(_ptiCurrent->pPropBag, IPropertyBag *), NULL)));
            ATOMICRELEASE(pPersistPropBag);
        }

        if (FAILED(hrResult = _pTransition->SetSite(SAFECAST(this, IHTMLViewFilterSite *))))
        {
            TraceMsg(TF_ERROR, "TRS::_LoadTransition _pT->SetSite failed 0x%X", hrResult);
            break;
        }

        if (FAILED(hrResult = _pTransition->SetSource(SAFECAST(this, IHTMLViewFilter *))))
        {
            TraceMsg(TF_ERROR, "TRS::_LoadTransition _pT->SetSource failed 0x%X", hrResult);
            break;
        }

        if (FAILED(hrResult = _InitWait()))
        {
            TraceMsg(TF_ERROR, "TRS::_LoadTransition _InitWait failed 0x%X", hrResult);
            break;
        }

        hrResult = S_OK;
        break;
    }

    if (FAILED(hrResult))
        _OnComplete();

    return hrResult;
}

/////////////////////////////////////////////////////////////////////////////
// CTransitionSite::_SetTransitionInfo
/////////////////////////////////////////////////////////////////////////////
HRESULT CTransitionSite::_SetTransitionInfo
(
    TransitionEvent     te,
    TRANSITIONINFO *    pti
)
{
    TraceMsg(TF_TRSITE, "TRS::_SetTransitionInfo(%d)", te);
    
    ASSERT((te >= teFirstEvent) && (te < teNumEvents));

    SAFERELEASE(_tiEventInfo[te].pPropBag);        

    _tiEventInfo[te] = *pti;

    if (_tiEventInfo[te].pPropBag != NULL)
        _tiEventInfo[te].pPropBag->AddRef();

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CTransitionSite::_InitWait
/////////////////////////////////////////////////////////////////////////////
HRESULT CTransitionSite::_InitWait()
{
    HRESULT hrResult;

    TraceMsg(TF_TRSITE, "TRS::_InitWait called");

    ASSERT(_pTransition != NULL);
    ASSERT(_pDispTransition != NULL);
    ASSERT(_uState == TRSTATE_NONE);

    for (;;)
    {
        RECT rc;
        IBrowserService2 *pbs2;
        if (SUCCEEDED(_pContainer->QueryInterface(IID_IBrowserService2, (void **)&pbs2)))
        {
            pbs2->GetViewRect(&rc);
            pbs2->Release();
        }

        EVAL(SUCCEEDED(hrResult = _pTransition->SetPosition(&rc)));
        TraceMsg(TF_TRSITE, "TRS::_InitWait called _pTransition->SetPosition 0x%X", hrResult);

        DISPID dispid;
        if (FAILED(hrResult = _pDispTransition->GetIDsOfNames(  IID_NULL,
                                                                &s_szApplyMethod,
                                                                1,
                                                                LOCALE_USER_DEFAULT,
                                                                &dispid)))
        {
            TraceMsg(TF_ERROR, "TRS::_InitWait _pDispTransition->GetIDsOfNames(Apply) failed 0x%X", hrResult);
            break;
        }

        unsigned int uArgError = (unsigned int)-1;
        DISPPARAMS dispparamsNoArgs = { NULL, NULL, 0, 0 };
        if (FAILED(hrResult = _pDispTransition->Invoke( dispid,
                                                        IID_NULL,
                                                        LOCALE_USER_DEFAULT,
                                                        DISPATCH_METHOD,
                                                        &dispparamsNoArgs,
                                                        NULL,
                                                        NULL,
                                                        &uArgError)))
        {
            TraceMsg(TF_ERROR, "TRS::_InitWait _pDispTransition->Invoke(Apply) failed 0x%X", hrResult);
            break;
        }

        break;
    }

    if (SUCCEEDED(hrResult))
        _uState = TRSTATE_INITIALIZING;

    return hrResult;
}

/////////////////////////////////////////////////////////////////////////////
// CTransitionSite::_StartTransition
/////////////////////////////////////////////////////////////////////////////
HRESULT CTransitionSite::_StartTransition
(
)
{
    HRESULT hrResult;
    
    TraceMsg(TF_TRSITE, "TRS::_StartTransition");

    ASSERT(_uState == TRSTATE_INITIALIZING);

    for (;;)
    {
        if (_pDispTransition == NULL)
        {
            hrResult = E_UNEXPECTED;
            break;
        }

        if  (
            FAILED(hrResult = _psvNew->QueryInterface(IID_IViewObject, (void **)&_pvoNew))
            ||
            FAILED(hrResult = _pvoNew->SetAdvise(   DVASPECT_CONTENT,
                                                    0,
                                                    SAFECAST(this, IAdviseSink *)))
            )
        {
            TraceMsg(TF_ERROR, "TRS::_StartTransition QI for IViewObject failed 0x%X", hrResult);
            break;
        }

        _uState = TRSTATE_STARTPAINTING;

        DISPID dispid;
        if (FAILED(hrResult = _pDispTransition->GetIDsOfNames(  IID_NULL,
                                                                &s_szPlayMethod,
                                                                1,
                                                                LOCALE_USER_DEFAULT,
                                                                &dispid)))
        {
            TraceMsg(TF_ERROR, "TRS::_StartTransition _pDispTransition->GetIDsOfNames(Play) failed 0x%X", hrResult);
            break;
        }

        unsigned int uArgError = (unsigned int)-1;
        DISPPARAMS dispparamsNoArgs = { NULL, NULL, 0, 0 };
        if (FAILED(hrResult = _pDispTransition->Invoke( dispid,
                                                        IID_NULL,
		                                                LOCALE_USER_DEFAULT,
                                                        DISPATCH_METHOD,
                                                        &dispparamsNoArgs,
                                                        NULL,
                                                        NULL,
                                                        &uArgError)))
        {
            TraceMsg(TF_ERROR, "TRS::_StartTransition _pDispTransition->Invoke(Play) failed 0x%X", hrResult);
            break;
        }

        _uState = TRSTATE_PAINTING;
        break;
    }

    if (FAILED(hrResult))
        _OnComplete();

    return hrResult;
}

/////////////////////////////////////////////////////////////////////////////
// CTransitionSite::_StopTransition
/////////////////////////////////////////////////////////////////////////////
HRESULT CTransitionSite::_StopTransition
(
)
{
    HRESULT hrResult;

    for (;;)
    {
        if (_pDispTransition == NULL)
        {
            hrResult = E_UNEXPECTED;
            break;
        }

        DISPID dispid;
        if (FAILED(hrResult = _pDispTransition->GetIDsOfNames(  IID_NULL,
                                                                &s_szStopMethod,
                                                                1,
                                                                LOCALE_USER_DEFAULT,
                                                                &dispid)))
        {
            TraceMsg(TF_ERROR, "TRS::_StopTransition _pDispTransition->GetIDsOfNames(Stop) failed 0x%X", hrResult);
            break;
        }

        unsigned int uArgError = (unsigned int)-1;
        DISPPARAMS dispparamsNoArgs = { NULL, NULL, 0, 0 };
        if (FAILED(hrResult = _pDispTransition->Invoke( dispid,
                                                        IID_NULL,
		                                                LOCALE_USER_DEFAULT,
                                                        DISPATCH_METHOD,
                                                        &dispparamsNoArgs,
                                                        NULL,
                                                        NULL,
                                                        &uArgError)))
        {
            TraceMsg(TF_ERROR, "TRS::_StopTransition _pDispTransition->Invoke(Stop) failed 0x%X", hrResult);
            break;
        }

        break;
    }

    _OnComplete();

    return hrResult;
}

/////////////////////////////////////////////////////////////////////////////
// CTransitionSite::_UpdateEventList
/////////////////////////////////////////////////////////////////////////////
HRESULT CTransitionSite::_UpdateEventList
(
)
{
    SAFERELEASE(_tiEventInfo[teSiteEnter].pPropBag);
    _tiEventInfo[teSiteEnter] = _tiEventInfo[teSiteExit];
    _tiEventInfo[teSiteExit].clsid = CLSID_NULL;
    _tiEventInfo[teSiteExit].pPropBag = NULL;

    SAFERELEASE(_tiEventInfo[tePageEnter].pPropBag);
    _tiEventInfo[tePageEnter] = _tiEventInfo[tePageExit];
    _tiEventInfo[tePageExit].clsid = CLSID_NULL;
    _tiEventInfo[tePageExit].pPropBag = NULL;

    _uState     = TRSTATE_NONE;
    _ptiCurrent = NULL;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CTransitionSite::_OnComplete
/////////////////////////////////////////////////////////////////////////////
HRESULT CTransitionSite::_OnComplete
(
)
{
    TraceMsg(TF_TRSITE, "TRS::_OnComplete() called");

    if (_dwTransitionSink != 0)
    {
        EVAL(SUCCEEDED(ConnectToConnectionPoint(SAFECAST(this, IDispatch *),
                                                DIID_ICSSTransitionEvents,
                                                FALSE,
                                                _pTransition,
                                                &_dwTransitionSink,
                                                NULL)));
        _dwTransitionSink = 0;
    }
    
    if (_pvoNew != NULL)
    {
        _pvoNew->SetAdvise(DVASPECT_CONTENT, 0, 0);
        ATOMICRELEASE(_pvoNew);
    }

    ATOMICRELEASE(_pDispTransition);

    if (_pTransition != NULL)
    {
        _pTransition->SetSource(NULL);
        _pTransition->SetSite(NULL);

        ASSERT(_pSite == NULL);

        ATOMICRELEASE(_pTransition);
    }

    if (_hwndViewNew != NULL)
    {
        if (_fViewIsVisible)
            ::ShowWindow(_hwndViewNew, SW_SHOW);

        _pContainer->EnableModelessSB(TRUE);
    }

    ATOMICRELEASE(_psvNew);
    _hwndViewNew = NULL;

    return _UpdateEventList();
}

/////////////////////////////////////////////////////////////////////////////
// IUnknown interface
/////////////////////////////////////////////////////////////////////////////
HRESULT CTransitionSite::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IHTMLViewFilter))
    {
        *ppvObj = SAFECAST(this, IHTMLViewFilter *);
    }
    else if (IsEqualIID(riid, IID_IHTMLViewFilterSite))
    {
        *ppvObj = SAFECAST(this, IHTMLViewFilterSite *);
    }
    else if (IsEqualIID(riid, DIID_ICSSTransitionEvents) ||
            IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = SAFECAST(this, IDispatch *);
    }
    else if (IsEqualIID(riid, IID_IServiceProvider))
    {
        return _pContainer->QueryInterface(IID_IServiceProvider, ppvObj);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

ULONG CTransitionSite::AddRef()
{
    TraceMsg(TF_ADDREFRELEASE, "TRS::AddRef()");
    return _pContainer->AddRef();
}

ULONG CTransitionSite::Release()
{
    TraceMsg(TF_ADDREFRELEASE, "TRS::Release()");
    return _pContainer->Release();
}


/////////////////////////////////////////////////////////////////////////////
// IHTMLViewFilter interface
/////////////////////////////////////////////////////////////////////////////
HRESULT CTransitionSite::SetSource(IHTMLViewFilter * pFilter)
{
    ASSERT(0);
    return E_FAIL;
}

HRESULT CTransitionSite::GetSource
(
    IHTMLViewFilter ** ppFilter
)
{
    ASSERT(0);
    return E_FAIL;
}

HRESULT CTransitionSite::SetSite
(
    IHTMLViewFilterSite * pFilterSite
)
{
    TraceMsg(TF_TRSITE, "TRS::SetSite called with %x", pFilterSite);

    ATOMICRELEASE(_pSite);

    _pSite = pFilterSite;
    if (pFilterSite != NULL)
        pFilterSite->AddRef();

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CTransitionSite::GetSite
/////////////////////////////////////////////////////////////////////////////
HRESULT CTransitionSite::GetSite
(
    IHTMLViewFilterSite ** ppFilterSite
)
{
    TraceMsg(TF_TRSITE, "TRS::GetSite called _pSite=%x", _pSite);
    *ppFilterSite = _pSite;

    if (_pSite != NULL)
    {
        _pSite->AddRef();
        return S_OK;
    }

    return S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CTransitionSite::SetPosition
/////////////////////////////////////////////////////////////////////////////
HRESULT CTransitionSite::SetPosition
(
    LPCRECT prc
)
{
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CTransitionSite::Draw
/////////////////////////////////////////////////////////////////////////////
HRESULT CTransitionSite::Draw
(
    HDC     hDC,
    LPCRECT prc
)
{
    HRESULT hrResult;
    HWND    hwndView = NULL;    // init to suppress bogus C4701 warning

    TraceMsg(TF_TREXTDRAW,
             "TRS::Draw called with hdc=%x (%d,%d)-(%d,%d)",
             hDC, prc->left, prc->top, prc->right, prc->bottom);

    if ((_uState == TRSTATE_STARTPAINTING) || (_uState == TRSTATE_PAINTING))
    {
        ASSERT(_pvoNew != NULL);

        RECTL rcl = { prc->left, prc->top, prc->right, prc->bottom };

        if (FAILED(hrResult = _pvoNew->Draw(DVASPECT_CONTENT,
                                            -1,
                                            NULL,
                                            NULL,
                                            NULL,
                                            hDC,
                                            &rcl,
                                            NULL,
                                            NULL,
                                            0)))
        {
            TraceMsg(TF_ERROR, "TRS::Draw IVO::Draw failed 0x%X", hrResult);
            hwndView = _hwndViewNew;
        }
    }
    else
    {
        IShellView * psv;
        hrResult = _pContainer->QueryActiveShellView(&psv);
        if (SUCCEEDED(hrResult))
        {
            hrResult = OleDraw(psv, DVASPECT_CONTENT, hDC, prc);
            psv->Release();
        }
        if (FAILED(hrResult))
        {
            IBrowserService2 *pbs;
            
            TraceMsg(TF_WARNING, "TRS:Draw OleDraw failed 0x%X", hrResult);
            
            if (SUCCEEDED(_pContainer->QueryInterface(IID_IBrowserService2, (void **)&pbs)))
            {
                pbs->GetViewWindow(&hwndView);
                pbs->Release();
            }
        }
    }

    // As a last resort, if IViewObject::Draw fails, try WM_PRINT
    if (FAILED(hrResult))
    {
        ASSERT((hwndView != NULL) && IsWindow(hwndView));

        // DrawEdge(..., EDGE_SUNKEN, BF_ADJUST|BF_RECT|BF_SOFT);

        ::SendMessage(hwndView, WM_PRINT, (WPARAM)hDC, PRF_NONCLIENT | PRF_CLIENT | PRF_CHILDREN | PRF_ERASEBKGND);
        hrResult = S_OK;
    }

    return hrResult;
}

/////////////////////////////////////////////////////////////////////////////
// CTransitionSite::GetStatusBits
/////////////////////////////////////////////////////////////////////////////
HRESULT CTransitionSite::GetStatusBits
(
    DWORD * pdwFlags
)
{
    *pdwFlags = FILTER_STATUS_OPAQUE;
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IHTMLViewFilterSite interface
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CTransitionSite::GetDC
/////////////////////////////////////////////////////////////////////////////
HRESULT CTransitionSite::GetDC
(
    LPCRECT prc,
    DWORD   dwFlags,
    HDC *   phDC
)
{
    HWND hwnd;
    _pContainer->GetWindow(&hwnd);
    *phDC = ::GetDC(hwnd);
    
    TraceMsg(TF_TRSITE, "TRS::GetDC returning *phDC=%x", *phDC);

    return ((*phDC != NULL) ? S_OK : E_FAIL);
}

/////////////////////////////////////////////////////////////////////////////
// CTransitionSite::ReleaseDC
/////////////////////////////////////////////////////////////////////////////
HRESULT CTransitionSite::ReleaseDC
(
    HDC hDC
)
{
    TraceMsg(TF_TRSITE, "TRS::ReleaseDC called with %x", hDC);
    
    HWND hwnd;
    _pContainer->GetWindow(&hwnd);
    ::ReleaseDC(hwnd, hDC);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CTransitionSite::InvalidateRect
/////////////////////////////////////////////////////////////////////////////
HRESULT CTransitionSite::InvalidateRect
(
    LPCRECT prc,
    BOOL    fErase
)
{
#ifdef DEBUG
    if (prc) {
        TraceMsg(TF_TREXTDRAW, "TRS::InvalidateRect called with (%x, %x)-(%x, %x) fErase=%d",
             prc->left, prc->top, prc->right, prc->bottom, fErase);
    } else {
        TraceMsg(TF_TREXTDRAW, "TRS::InvalidateRect called prc=NULL, fErase=%d", fErase);
    }
#endif

    DWORD dwFlags = RDW_INVALIDATE | RDW_UPDATENOW;
    dwFlags |= (fErase ? RDW_ERASE : 0);

    HWND hwnd;
    _pContainer->GetWindow(&hwnd);
    ::RedrawWindow(hwnd, prc, NULL, dwFlags);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CTransitionSite::InvalidateRgn
/////////////////////////////////////////////////////////////////////////////
HRESULT CTransitionSite::InvalidateRgn
(
    HRGN hrgn,
    BOOL fErase
)
{
    TraceMsg(TF_TRSITE, "TRS::InvalidateRgn called");

    DWORD dwFlags = RDW_INVALIDATE | RDW_UPDATENOW;
    dwFlags |= (fErase ? RDW_ERASE : 0);

    HWND hwnd;
    _pContainer->GetWindow(&hwnd);
    ::RedrawWindow(hwnd, NULL, hrgn, dwFlags);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CTransitionSite::OnStatusBitsChange
/////////////////////////////////////////////////////////////////////////////
HRESULT CTransitionSite::OnStatusBitsChange
(
    DWORD dwFlags
)
{
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IAdviseSink interface
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CTransitionSite::OnViewChange
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(void) CTransitionSite::OnViewChange(DWORD dwAspect, LONG lindex)
{
    static DWORD dwLastUpdate = 0;

    if  (
        ((GetTickCount() - dwLastUpdate) > MIN_ONVIEWCHANGE_DURATION)
        &&
        (_uState == TRSTATE_PAINTING)
        &&
        (dwAspect & DVASPECT_CONTENT)
        )
    {
        TraceMsg(TF_TRDRAW, "TRS::OnViewChange(%d)", lindex);

        _pSite->InvalidateRect(NULL, FALSE);
    }

    dwLastUpdate = GetTickCount();
}

/////////////////////////////////////////////////////////////////////////////
// IDispatch interface
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CTransitionSite::Invoke
/////////////////////////////////////////////////////////////////////////////
HRESULT CTransitionSite::Invoke
(
    DISPID          dispidMember,
    REFIID          riid,
    LCID            lcid,
    WORD            wFlags,
    DISPPARAMS *    pdispparams,
    VARIANT *       pvarResult,
    EXCEPINFO *     pexcepinfo,
    UINT *          puArgErr
)
{
    ASSERT(pdispparams != NULL);
    if (pdispparams == NULL)
        return E_INVALIDARG;

    if (!(wFlags & DISPATCH_METHOD))
        return E_INVALIDARG;

    switch(dispidMember)
    {
        case DISPID_ONTRANSITIONFINISH:
        {
            _OnComplete();
            break;
        }

        default:
            return E_INVALIDARG;
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CTransitionSitePropertyBag
/////////////////////////////////////////////////////////////////////////////
#undef CTransitionSite

CTransitionSitePropertyBag::CTransitionSitePropertyBag
(
) : _cRef(1)
{
    TraceMsg(TF_TRLIFE, "TRSPropBag::ctor called");

    // Implicit: _hdpaProperties = NULL;
}

CTransitionSitePropertyBag::~CTransitionSitePropertyBag()
{
    TraceMsg(TF_TRLIFE, "TRSPropBag::dtor called");

    if (_hdpaProperties != NULL)
    {
        DPA_DestroyCallback(_hdpaProperties, _DPA_FreeProperties, 0);
        _hdpaProperties = NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////
// _DPA_FreeProperties
/////////////////////////////////////////////////////////////////////////////
int CTransitionSitePropertyBag::_DPA_FreeProperties(void *pv, void *pData)
{
    NAMEVALUE * pnv = (NAMEVALUE *)pv;

    ASSERT(pnv != NULL);
    ASSERT(pnv->pwszName != NULL);

    LocalFree(pnv->pwszName);
    pnv->pwszName = NULL;

    VariantClear(&pnv->varValue);

    LocalFree(pnv);
    pnv = NULL;

    return 1;
}

/////////////////////////////////////////////////////////////////////////////
// _AddProperty
/////////////////////////////////////////////////////////////////////////////
HRESULT CTransitionSitePropertyBag::_AddProperty(WCHAR *wszPropName, VARIANT *pvarValue)
{
    NAMEVALUE * pnv = NULL;
    HRESULT     hrResult = E_FAIL;

    // Create the list if needed
    if (_hdpaProperties == NULL)
        _hdpaProperties = DPA_Create(TSPB_CREATE_INCR);

    for (;;)
    {
        if (_hdpaProperties == NULL)
            break;

        // Alloc a new name value pair
        pnv = (NAMEVALUE *)LocalAlloc(LPTR, SIZEOF(NAMEVALUE));
        if (pnv == NULL)
        {
            TraceMsg(TF_WARNING, "TRSPB Unable to alloc memory for property");
            break;
        }

        // Copy the name
        UINT cb = (lstrlenW(wszPropName)+1) * SIZEOF(wszPropName[0]);
        pnv->pwszName = (LPWSTR)LocalAlloc(LPTR, cb);
        if (pnv->pwszName == NULL)
        {
            TraceMsg(TF_WARNING, "TRSPB Unable to alloc memory for property");
            break;
        }

        StrCpyNW(pnv->pwszName, wszPropName, cb / sizeof(wszPropName[0]));

        // Copy the value
        if (FAILED(hrResult = VariantCopy(&pnv->varValue, pvarValue)))
        {
            TraceMsg(TF_WARNING, "TRSPB VariantCopy failed");
            break;
        }

        // Add the name value pair to the list
        if (DPA_AppendPtr(_hdpaProperties, pnv) == DPA_ERR)
            break;

#ifdef DEBUG
        TCHAR szPropName[80];
        SHUnicodeToTChar(wszPropName, szPropName, SIZEOF(szPropName));

        VARIANT vVal = { 0 };
        TCHAR   szPropVal[80];

        EVAL(SUCCEEDED(VariantChangeType(&vVal, pvarValue, 0, VT_BSTR)));
        SHUnicodeToTChar(V_BSTR(&vVal), szPropVal, SIZEOF(szPropVal));
        EVAL(SUCCEEDED(VariantClear(&vVal)));

        TraceMsg(TF_TRSPB, "TRSPB::_AddProperty added '%s = %s'", szPropName, szPropVal);
#endif  // DEBUG        

        hrResult = S_OK;
        break;
    }

    // Cleanup on error
    if (FAILED(hrResult))
    {
        if (pnv != NULL)
        {
            if (pnv->pwszName != NULL)
            {
                LocalFree(pnv->pwszName);
                pnv->pwszName = NULL;
            }

            VariantClear(&pnv->varValue);

            LocalFree(pnv);
            pnv = NULL;
        }
    }

    return hrResult;
}

ULONG CTransitionSitePropertyBag::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CTransitionSitePropertyBag::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CTransitionSitePropertyBag::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IPropertyBag))
    {
        *ppvObj = SAFECAST(this, IPropertyBag *);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPropertyBag interface
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CTransitionSitePropertyBag::Read
/////////////////////////////////////////////////////////////////////////////
HRESULT CTransitionSitePropertyBag::Read
(
    LPCOLESTR   pszPropName,
    VARIANT *   pVar,
    IErrorLog * pErrorLog
)
{
    HRESULT hrResult = E_INVALIDARG;

    if ((pszPropName == NULL) || (pVar == NULL))
        return E_POINTER;

#ifdef DEBUG
    TCHAR szPropName[80];
    SHUnicodeToTChar(pszPropName, szPropName, SIZEOF(szPropName));
    TraceMsg(TF_TRSPB, "TRSPB::Read(%s)", szPropName);
#endif  // DEBUG

    if (_hdpaProperties != NULL)
    {
        // Search for the property in the list.
        for (int i = 0; i < DPA_GetPtrCount(_hdpaProperties); i++)
        {
            NAMEVALUE * pnv = (NAMEVALUE *)DPA_GetPtr(_hdpaProperties, i);

            if (StrCmpIW(pszPropName, pnv->pwszName) == 0)
            {
                // Copy the variant property.
                hrResult = VariantChangeType(pVar, &pnv->varValue, 0, pVar->vt);
                break;
            }
        }
    }

    return hrResult;
}

/////////////////////////////////////////////////////////////////////////////
// Helper functions
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CLSIDFromTransitionName
/////////////////////////////////////////////////////////////////////////////
HRESULT CLSIDFromTransitionName
(
    LPCTSTR pszName,
    LPCLSID clsidName
)
{
    HKEY    hkeyTransitions = NULL;
    HRESULT hrResult;

    for (;;)
    {
        // Check for "{...CLSID...}"
        if (*pszName == TEXT('{'))
        {
            hrResult = SHCLSIDFromString(pszName, clsidName);
            break;
        }

        // Check for Transition Name
        if (RegCreateKey(   HKEY_LOCAL_MACHINE,
                            c_szTransitionsKey,
                            &hkeyTransitions) == ERROR_SUCCESS)
        {
            TCHAR   szCLSID[GUIDSTR_MAX];
            DWORD   cbBytes = SIZEOF(szCLSID);
            DWORD   dwType;

            if  (
                (RegQueryValueEx(   hkeyTransitions,
                                    pszName,
                                    NULL,
                                    &dwType,
                                    (BYTE *)szCLSID,
                                    &cbBytes) == ERROR_SUCCESS)
                &&
                (dwType == REG_SZ)
                )
            {
                hrResult = SHCLSIDFromString(szCLSID, clsidName);
                break;
            }
        }

        hrResult = E_FAIL;
        break;
    }

    if (hkeyTransitions != NULL)
        RegCloseKey(hkeyTransitions);

    return hrResult;
}

/////////////////////////////////////////////////////////////////////////////
// ParseTransitionInfo
//
// Purpose: Parse <META HTTP-EQUIV...> of the form:
//
//      <META
//          HTTP-EQUIV = transition-event
//          CONTENT = transition-description    
//      >
//
// where:
//
//      transition-event -> PAGE-ENTER
//                              | PAGE-EXIT
//                              | SITE-ENTER
//                              | SITE-EXIT
//
//      transition-description -> transition-name ( transition-properties ) 
//
//      transition-name -> IDENTIFIER
//                              | CLSID 
//                              | PROGID
//
//      transition-properties -> transition-property , transition-property
//      transition-properties -> transition-property
//
//      name-value-assignment -> = | :
//
//      transition-property -> NAME name-value-assignment VALUE
//
// examples:
//
//      <META
//          HTTP-EQUIV = "Page-Enter"
//          CONTENT = "Reveal(duration=500)"
//      >
//
//      <META
//          HTTP-EQUIV = "Page-Leave"
//          CONTENT = "Reveal(duration=500, type=checkerboard, size=10)"
//      >
//
/////////////////////////////////////////////////////////////////////////////
BOOL ParseTransitionInfo
(
    WCHAR *             pwz,
    TRANSITIONINFO *    pti
)
{
    enum
    {
        PTE_PARSE_TRANSITION_NAME,
        PTE_PARSE_NAME,
        PTE_PARSE_VALUE,
        PTE_FINISHED
    };

    #define MAX_TRANSITION_NAME_LEN GUIDSTR_MAX
    WCHAR wszTransitionName[MAX_TRANSITION_NAME_LEN];
    WCHAR * pwzTransitionName = wszTransitionName;

    #define MAX_PTINAME_LEN     32
    WCHAR   wszName[MAX_PTINAME_LEN];
    WCHAR * pwzName = wszName;

    #define MAX_PTIVALUE_LEN    32
    WCHAR   wszValue[MAX_PTIVALUE_LEN];
    WCHAR * pwzValue = wszValue;

    WCHAR   wch;
    UINT    cch         = 0;
    UINT    uiState     = PTE_PARSE_TRANSITION_NAME;
    BOOL    bSucceeded  = FALSE;

    ASSERT(pti != NULL);

    do
    {
        wch = *pwz;

        switch (uiState)
        {
            case PTE_PARSE_TRANSITION_NAME:
            {
                if (wch == TEXT('('))  // Open paren
                {
                    cch     = 0;
                    uiState = PTE_PARSE_NAME;

                    *pwzTransitionName = '\0';
                    pwzTransitionName = wszTransitionName;

                    TCHAR szTransitionName[MAX_TRANSITION_NAME_LEN];
                    SHUnicodeToTChar(wszTransitionName, szTransitionName, ARRAYSIZE(szTransitionName));

                    TraceMsg(DM_TRACE, "ParseTransitionInfo(%s)", szTransitionName);

                    // Resolve the Transition Name
                    EVAL(SUCCEEDED(CLSIDFromTransitionName(szTransitionName, &(pti->clsid))));
                }
                else if (
                        !ISSPACE(wch)
                        &&
                        (cch++ < (MAX_TRANSITION_NAME_LEN-1))
                        )
                {
                    *pwzTransitionName++ = wch;
                }
                else
                    ;   // Ignore
                    
                break;
            }

            case PTE_PARSE_NAME:
            {
                if  (
                    (wch == TEXT('='))  // Equal
                    ||
                    (wch == TEXT(':'))  // Semicolon
                    )
                {
                    cch     = 0;
                    uiState = PTE_PARSE_VALUE;

                    *pwzName = '\0';
                    pwzName = wszName;
                }
                else if (
                        !ISSPACE(wch)
                        &&
                        (cch++ < (MAX_PTINAME_LEN-1))
                        )
                {
                    *pwzName++ = wch;
                }
                else
                    ;   // Ignore

                break;
            }

            case PTE_PARSE_VALUE:
            {
                if  (
                    (wch == TEXT(','))  // Comma
                    ||
                    (wch == TEXT(')'))  // Close paren
                    )
                {
                    cch = 0;
                    if (wch == TEXT(','))
                        uiState = PTE_PARSE_NAME;
                    else
                        uiState = PTE_FINISHED;

                    *pwzValue = '\0';
                    pwzValue = wszValue;

                    // Initialize the property bag class
                    if (pti->pPropBag == NULL)
                        pti->pPropBag = new CTransitionSitePropertyBag;

                    if (pti->pPropBag)
                    {
                        VARIANT v;
                        if (SUCCEEDED(InitVariantFromStr(&v, wszValue)))
                        {
                            VARIANT vDuration = { 0 };
                            VARIANT* pvarToAdd = &v;

                            // Limit the duration of the transition.
                            if (StrCmpIW(wszName, c_szDurationProp) == 0)
                            {
                                if (SUCCEEDED(VariantChangeTypeEx(&vDuration, &v, MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), 0, VT_R4)))
                                {
                                    ASSERT(V_VT(&vDuration) == VT_R4);

                                    if (V_R4(&vDuration) < MIN_TRANSITION_DURATION)
                                        V_R4(&vDuration) = MIN_TRANSITION_DURATION;
                                    else if (V_R4(&vDuration) > MAX_TRANSITION_DURATION)
                                        V_R4(&vDuration) = MAX_TRANSITION_DURATION;

                                    // don't need to VariantClear() vDuration since it's VT_R4 by the above ASSERT
                                    pvarToAdd = &vDuration;
                                }
                            }

                            // Add the property to the property bag
                            pti->pPropBag->_AddProperty(wszName, pvarToAdd);

                            VariantClear(&v);
                            // vDuration is VT_EMPTY or VT_R4, neither of which nead VariantClear
                        }
                    }
                }
                else if (
                        !ISSPACE(wch)
                        &&
                        (cch++ < (MAX_PTIVALUE_LEN-1))
                        )
                {
                    *pwzValue++ = wch;
                }
                else
                    ;   // Ignore

                break;
            }

            case PTE_FINISHED:
            {
                bSucceeded = TRUE;
                break;
            }

            default:
                break;
        }

        pwz++;
    } while (wch && !bSucceeded);

    return bSucceeded;
} // ParseTransitionInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\trsite.h ===
#ifndef _TRSITE_H
#define _TRSITE_H

class CTransitionSite;
class CTransitionSitePropertyBag;

/////////////////////////////////////////////////////////////////////////////
// Typedefs and Structs
/////////////////////////////////////////////////////////////////////////////
enum TransitionEvent    // Transition Event type
{
    teFirstEvent        = 0,

    teSiteEnter         = teFirstEvent,
    tePageEnter,
    teSiteExit,
    tePageExit,

    teNumEvents,    // NOTE: Must follow last event!

    teUserDefault       = teNumEvents
};

struct TRANSITIONINFO   // Transition Event information
{
    CLSID                           clsid;
    CTransitionSitePropertyBag *    pPropBag;
};

struct NAMEVALUE
{
    WCHAR * pwszName;
    VARIANT varValue;
};

/////////////////////////////////////////////////////////////////////////////
// CTransitionSite
/////////////////////////////////////////////////////////////////////////////
class CTransitionSite : public IHTMLViewFilter,
                        public IHTMLViewFilterSite,
                        public IAdviseSink,
                        public IDispatch
{
// Construction/Destruction
public:
    CTransitionSite(IShellBrowser * pcont);
    ~CTransitionSite();

    HRESULT _SetTransitionInfo(TransitionEvent te, TRANSITIONINFO * pti);

    HRESULT _ApplyTransition(BOOL bSiteChange);
    HRESULT _StartTransition();
    HRESULT _StopTransition();

    HRESULT _UpdateEventList();

    enum TRSTATE
    {
        TRSTATE_NONE            = 0,
        TRSTATE_INITIALIZING    = 1,
        TRSTATE_STARTPAINTING   = 2,
        TRSTATE_PAINTING        = 3
    };

    TRSTATE         _uState;
    IShellView *    _psvNew;        // Valid only while we are playing
    IViewObject *   _pvoNew;
    BOOL            _fViewIsVisible;
    HWND            _hwndViewNew;
    IHTMLViewFilter *   _pTransition;
    IDispatch *     _pDispTransition;
    DWORD           _dwTransitionSink;

// Data
private:
    IShellBrowser *     _pContainer;    // CBaseBrowser container of parent
    IHTMLViewFilterSite *   _pSite;

    TRANSITIONINFO *    _ptiCurrent;
    TRANSITIONINFO      _tiEventInfo[teNumEvents];

// Internal methods
private:
    HRESULT _LoadTransition();
    HRESULT _InitWait();
    HRESULT _OnComplete();

// Interfaces
public:
    // IUnknown
    STDMETHOD(QueryInterface)   (REFIID riid, LPVOID * ppv);
    STDMETHOD_(ULONG, AddRef)   (void);
    STDMETHOD_(ULONG, Release)  (void);
    
    // IHTMLViewFilter
    STDMETHOD(SetSource)        (IHTMLViewFilter *pFilter);
    STDMETHOD(GetSource)        (IHTMLViewFilter **ppFilter);
    STDMETHOD(SetSite)          (IHTMLViewFilterSite *pSink);
    STDMETHOD(GetSite)          (IHTMLViewFilterSite **ppSink);
    STDMETHOD(SetPosition)      (LPCRECT prc);
    STDMETHOD(Draw)             (HDC hdc, LPCRECT prc);
    STDMETHOD(GetStatusBits)    (DWORD *pdwFlags);
    
    // IHTMLViewFilterSite
    STDMETHOD(GetDC)                (LPCRECT prc, DWORD dwFlags, HDC *phdc);
    STDMETHOD(ReleaseDC)            (HDC hdc);
    STDMETHOD(InvalidateRect)       (LPCRECT prc, BOOL fErase);
    STDMETHOD(InvalidateRgn)        (HRGN hrgn, BOOL fErase);
    STDMETHOD(OnStatusBitsChange)   (DWORD dwFlags);

    // IAdviseSink
    STDMETHOD_(void, OnDataChange)  (FORMATETC * pFormatetc, STGMEDIUM * pStgmed) {}
    STDMETHOD_(void, OnViewChange)  (DWORD dwAspect, LONG lindex);
    STDMETHOD_(void, OnRename)      (IMoniker * pmk) {}
    STDMETHOD_(void, OnSave)        () {}
    STDMETHOD_(void, OnClose)       () {}

    // IDispatch
    STDMETHOD(GetTypeInfoCount) (UINT * pctinfo) { return E_NOTIMPL; }
    STDMETHOD(GetTypeInfo)      (UINT itinfo, LCID lcid, ITypeInfo ** pptinfo) { return E_NOTIMPL; }
    STDMETHOD(GetIDsOfNames)    (REFIID riid, OLECHAR ** rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid) { return E_NOTIMPL; }
    STDMETHOD(Invoke)           (DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr);
};

/////////////////////////////////////////////////////////////////////////////
// CTransitionSitePropertyBag
/////////////////////////////////////////////////////////////////////////////
class CTransitionSitePropertyBag : public IPropertyBag
{
// Construction/Destruction
public:
    CTransitionSitePropertyBag();
    virtual ~CTransitionSitePropertyBag();

    HRESULT _AddProperty(WCHAR * wszPropName, VARIANT * pvarValue);

// Data
protected:
    UINT    _cRef;
    HDPA    _hdpaProperties;

// Implementation
protected:
    static int _DPA_FreeProperties(LPVOID pv, LPVOID pData);

// Interfaces
public:
    // IUnknown
    STDMETHOD(QueryInterface)   (REFIID riid, LPVOID * ppv);
    STDMETHOD_(ULONG, AddRef)   (void);
    STDMETHOD_(ULONG, Release)  (void);

    // IPropertyBag
    STDMETHOD(Read) (LPCOLESTR pszPropName, VARIANT * pVar, IErrorLog * pErrorLog);
    STDMETHOD(Write)(LPCOLESTR pszPropName, VARIANT * pVar)
    { return E_NOTIMPL; }
};

/////////////////////////////////////////////////////////////////////////////
// Helper functions
/////////////////////////////////////////////////////////////////////////////
HRESULT CLSIDFromTransitionName(LPCTSTR pszName, LPCLSID clsidName);
BOOL    ParseTransitionInfo(WCHAR * pwz, TRANSITIONINFO * pti);

#define ISSPACE(ch) (((ch) == 32) || ((unsigned)((ch) - 9)) <= 13 - 9)

#endif  // _TRSITE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\urlhook.cpp ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 
//
// File: urlhook.cpp
//
// History:
//         9-24-96  by dli
//------------------------------------------------------------------------

#include "priv.h"
#include "sccls.h"
#include "resource.h"

#include <mluisupp.h>

// CURRENT_USER
static const TCHAR c_szSearchUrl[]     = TSZIEPATH TEXT("\\SearchUrl");


#define TF_URLSEARCHHOOK 0

// structure for the character replacement in URL searches
typedef struct _SUrlCharReplace {
    TCHAR from;
    TCHAR to[10];
} SUrlCharReplace;


class CURLSearchHook : public IURLSearchHook2
{
public:
    CURLSearchHook();
    
    // *** IUnknown Methods
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IURLSearchHook
    virtual STDMETHODIMP Translate(LPWSTR lpwszSearchURL, DWORD cchBufferSize);

    // *** IURLSearchHook2
    virtual STDMETHODIMP TranslateWithSearchContext(LPWSTR lpwszSearchURL, DWORD cchBufferSize, ISearchContext * pSearchContext);
        
protected:
    // IUnknown 
    UINT _cRef;

    HRESULT _IsKeyWordSearch(LPCTSTR pcszURL);
    HRESULT _IsURLSearchable(LPTSTR pszURL, HKEY * phkeySearch, LPCTSTR * pcszQuery);
    HRESULT _ReplaceChars(HKEY hkeySearch, LPCTSTR pcszQuery, PTSTR pszReplaced, int cchReplaced);
    HRESULT _Search(HKEY hkeySearch, LPCTSTR pcszQuery, PTSTR pszTranslatedURL, DWORD cchTranslatedUrl, PTSTR pszSearchUrl, ISearchContext * pSC); 
    void    _ConvertToUtf8(LPWSTR pszQuery, int cch);

}; 


#ifdef DEBUG
#define _AddRef(psz) { ++_cRef; TraceMsg(TF_URLSEARCHHOOK, "CURLSearchHook(%x)::QI(%s) is AddRefing _cRef=%lX", this, psz, _cRef); }
#else
#define _AddRef(psz)    ++_cRef
#endif


CURLSearchHook::CURLSearchHook()
    : _cRef(1)
{
    DllAddRef();
}

HRESULT CURLSearchHook::QueryInterface(REFIID riid, LPVOID * ppvObj)
{ 
    // ppvObj must not be NULL
    ASSERT(ppvObj != NULL);
    
    if (ppvObj == NULL)
        return E_INVALIDARG;

    *ppvObj = NULL;
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IURLSearchHook) ||
        IsEqualIID(riid, IID_IURLSearchHook2))
    {
        *ppvObj = SAFECAST(this, IURLSearchHook2 *);
        TraceMsg(TF_URLSEARCHHOOK, "QI IURLSEARCHHOOK succeeded");
    } 
    else
        return E_NOINTERFACE;  // Otherwise, don't delegate to HTMLObj!!
     
    
    _AddRef(TEXT("IURLSearchHook"));
    return S_OK;
}


ULONG CURLSearchHook::AddRef()
{
    _cRef++;
    TraceMsg(TF_URLSEARCHHOOK, "CURLSearchHook(%x)::AddRef called, new _cRef=%lX", this, _cRef);
    return _cRef;
}

ULONG CURLSearchHook::Release()
{
    _cRef--;
    TraceMsg(TF_URLSEARCHHOOK, "CURLSearchHook(%x)::Release called, new _cRef=%lX", this, _cRef);
    if (_cRef > 0)
        return _cRef;

    delete this;
    DllRelease();
    return 0;
}

HRESULT CURLSearchHook::_IsKeyWordSearch(LPCTSTR pcszURL)
{
    TCHAR szAcceptedRequestKey[256];
    
    LPTSTR lpsz = szAcceptedRequestKey;
    LPTSTR lpszKey = szAcceptedRequestKey;
   
    // load the accepted request keywords and compare them with what the user typed in
    MLLoadString(IDS_URL_SEARCH_KEY, szAcceptedRequestKey, ARRAYSIZE(szAcceptedRequestKey)-1);
    
    int RequestKeyLen = 0;
    while (*lpsz) {
        if (*lpsz == TEXT(' ')){ 
            if (! StrCmpNI(pcszURL, lpszKey, RequestKeyLen+1))      
                return S_OK;        
            else {
                lpsz++;
                lpszKey = lpsz;
                RequestKeyLen = 0;
            }
        }
        else {      
            lpsz++;
            RequestKeyLen++;
        }
    }
    
    return S_FALSE;
}   


// This function determines if we will do an autosearch on the string user typed in 
//
// Priorities:
// 1  ---  Key word search: search with "go", "find" and so on
// 2  ---  possible URL address: contains '.', ':', '/' and '\\', so don't search 
// 3  ---  Space triggered search.
// 4  ---  Don't search. 
HRESULT CURLSearchHook::_IsURLSearchable(LPTSTR pszURL, HKEY * phkeySearch, LPCTSTR * ppcszQuery)
{
    BOOL fExtendedChar = FALSE;
    TCHAR szRegSearchKey[MAX_PATH];
    LPTSTR pszKey = StrChr(pszURL, TEXT(' '));
    if (pszKey == NULL)
    {
        // No keyword, but if any of the characters are non-ascii, we will default
        // to search because it's likely not a url
        fExtendedChar = HasExtendedChar(pszURL);
        if (!fExtendedChar)
            return S_FALSE;

        pszKey = pszURL;
    }
    
    StrCpyN(szRegSearchKey, c_szSearchUrl, ARRAYSIZE(szRegSearchKey));
    
    if ((_IsKeyWordSearch(pszURL) == S_FALSE) && !fExtendedChar)        
    {
        // Find the end of the default Registry Subkey and 
        // append the keyword so the regkey becomes:
        // Software\Microsoft\Internet Explorer\SearchUrl\go
        ASSERT((ARRAYSIZE(c_szSearchUrl) + 1) < ARRAYSIZE(szRegSearchKey));
        PTSTR pszEnd = &szRegSearchKey[ARRAYSIZE(c_szSearchUrl) - 1];
        *pszEnd++ = TEXT('\\');
        const int cchBuf = ARRAYSIZE(szRegSearchKey) - (ARRAYSIZE(c_szSearchUrl) + 1);
        const int cchToCopy = (int) (pszKey - pszURL + 1);
        StrCpyN(pszEnd, pszURL, min(cchBuf, cchToCopy));

        // See if this is a search keyword in the registry
        if (OpenRegUSKey(szRegSearchKey, 0, KEY_READ, phkeySearch) == ERROR_SUCCESS)
        {  
            PathRemoveBlanks(pszKey);
            *ppcszQuery = pszKey;
            return S_OK;
        }

        // No keyword so use entire "url" for the search
        pszKey = pszURL;

        if (StrCSpn(pszURL, TEXT(":/\\")) != lstrlen(pszURL))
        {
            return S_FALSE;
        }
    }
    
    // Null out the key to signal that we should use the internal hard-coded search string
    *phkeySearch = NULL;
    PathRemoveBlanks(pszKey);
    *ppcszQuery = pszKey;
    return S_OK;
}

HRESULT CURLSearchHook::_ReplaceChars(HKEY hkeySearch, LPCTSTR pcszQuery, LPTSTR pszReplaced, int cchReplaced)
{
    // The following are strings and its lengthes passed in RegEnumValue
    TCHAR szOrig[2];
    DWORD dwOrigLen;
    
    TCHAR szMatch[10];
    DWORD dwMatchLen;
    
    HDSA  hdsaReplace = NULL;
    
    // If we are using our hard-coded search url, we get the char replacements from the string table
    if (NULL == hkeySearch)
    {
        WCHAR szSub[MAX_PATH];
        if (MLLoadString(IDS_SEARCH_SUBSTITUTIONS, szSub, ARRAYSIZE(szSub)) && *szSub != NULL)
        {
            // The first char is our deliminator followed by replacement pairs (", ,+,#,%23,&,%26,?,%3F,+,%2B,=,%3d")
            WCHAR chDelim = szSub[0];
            LPWSTR pszFrom = &szSub[1];
            BOOL fDone = FALSE;
            LPWSTR pszNext;
            do
            {
                // Null terminater our source string
                LPWSTR pszTo = StrChr(pszFrom, chDelim);
                if (NULL == pszTo)
                {
                    break;
                }
                *pszTo = L'\0';

                // Null terminate the dest string
                ++pszTo;
                LPWSTR pszToEnd = StrChr(pszTo, chDelim);
                if (pszToEnd)
                {
                    *pszToEnd = L'\0';
                    pszNext = pszToEnd + 1;
                }
                else
                {
                    pszNext = NULL;
                }
        
                // If the "from" string is one char and the "to" substitution fits, store this pair
                SUrlCharReplace scr;
                if (pszFrom[1] == L'\0' && lstrlen(pszTo) < ARRAYSIZE(scr.to))
                {
                    scr.from = pszFrom[0];
                    StrCpyN(scr.to, pszTo, ARRAYSIZE(scr.to));
        
                    if (!hdsaReplace)
                        hdsaReplace = DSA_Create(SIZEOF(SUrlCharReplace), 4); 
                    if (hdsaReplace)
                        DSA_AppendItem(hdsaReplace, &scr);
                }

                pszFrom = pszNext;
            } 
            while (pszNext != NULL);
        }
    }

    // The search url is in the registry, so get the char substitutions from there
    else
    {
        DWORD dwType;
        LONG lRegEnumResult;
        DWORD dwiValue = 0; 
        do
        {
            dwOrigLen = ARRAYSIZE(szOrig);
            dwMatchLen = SIZEOF(szMatch);
            lRegEnumResult = RegEnumValue(hkeySearch, dwiValue, szOrig,
                                          &dwOrigLen, NULL, &dwType, (PBYTE)szMatch,
                                          &dwMatchLen);
            dwiValue++;         
            SUrlCharReplace         scr;
            
            if ((lRegEnumResult == ERROR_SUCCESS) && (dwType == REG_SZ) && (dwOrigLen == 1) 
                && dwMatchLen < ARRAYSIZE(scr.to))
            {
                scr.from = szOrig[0];
                StrCpyN(scr.to, szMatch, ARRAYSIZE(scr.to));
            
                if (!hdsaReplace)
                    hdsaReplace = DSA_Create(SIZEOF(SUrlCharReplace), 4); 
                if (hdsaReplace)
                    DSA_AppendItem(hdsaReplace, &scr);
            }       
        } while ((lRegEnumResult == ERROR_SUCCESS) || (lRegEnumResult == ERROR_MORE_DATA));
    }
            
            
    if (hdsaReplace)
    {
        // Replace all characters found in the registry by their matches in the search key word
        LPTSTR lpHead = pszReplaced;
        int cchHead = cchReplaced;
        int ich;
        int ihdsa;
        BOOL bCharFound;
        int querylen = lstrlen(pcszQuery);
        for (ich = 0; ich < querylen && cchHead > 1; ich++)
        {
            bCharFound = FALSE;
            // First look through the DSA array to find a match
            for (ihdsa = 0; ihdsa < DSA_GetItemCount(hdsaReplace); ihdsa++)
            {
                SUrlCharReplace *pscr;
                pscr = (SUrlCharReplace *)DSA_GetItemPtr(hdsaReplace, ihdsa);
                if (pscr && pscr->from == pcszQuery[ich])
                {
                    int szLen = lstrlen(pscr->to);
                    StrCpyN(lpHead, pscr->to, cchHead);    
                    lpHead += szLen;
                    cchHead -= szLen;
                    bCharFound = TRUE;
                    break;
                }
            }
            
            // Copy the character over if there is no replacements
            if (!bCharFound)
            {
                *lpHead = pcszQuery[ich];
                lpHead++;
                cchHead--;
            }
        }       

        if (cchHead > 0)
            *lpHead = 0;
        
        DSA_Destroy(hdsaReplace);
        hdsaReplace = NULL;
    }
    
    return S_OK;
    
}       

void  CURLSearchHook::_ConvertToUtf8(LPWSTR pszQuery, int cch)
{
    // Only need to covert if extended characters found
    if (HasExtendedChar(pszQuery))
    {
        ConvertToUtf8Escaped(pszQuery, cch);
    }
}

// pszTranslatedUrl is the output of this function
HRESULT CURLSearchHook::_Search(HKEY hkeySearch, LPCTSTR pcszQuery, PTSTR pszTranslatedUrl, DWORD cchTranslatedUrl, PTSTR pszSearchUrl, ISearchContext * pSC)
{
    HRESULT hr = E_FAIL;

    // Get the search provider from the registry 
    DWORD dwType;
    WCHAR szProvider[MAX_PATH];
    szProvider[0] = 0;
    DWORD cbProvider = sizeof(szProvider);
    if (SHRegGetUSValue(c_szSearchUrl, L"Provider", &dwType, &szProvider, &cbProvider, FALSE, NULL, 0) != ERROR_SUCCESS ||
        dwType != REG_SZ)
    {
        szProvider[0] = 0;
    }

    TCHAR szSearchPath[MAX_URL_STRING];
    DWORD dwSearchPathLen = SIZEOF(szSearchPath);        
    BOOL  fSuccess;

    if (pszSearchUrl != NULL)
    {
        StrCpyNW(szSearchPath, pszSearchUrl, ARRAYSIZE(szSearchPath));
        fSuccess = TRUE;
    }
    else
    {
        // Find the search URL in the registry or our string table
        if (hkeySearch)
        {
            fSuccess = (RegQueryValueEx(hkeySearch, NULL, NULL, NULL, (PBYTE)szSearchPath, &dwSearchPathLen) == ERROR_SUCCESS);
        }
        else
        {

            // See if we want the hardcoded intranet or internet url
            UINT ids = (StrCmpI(szProvider, L"Intranet") == 0) ? IDS_SEARCH_INTRANETURL : IDS_SEARCH_URL;

            // Use our internal hard-coded string
            fSuccess = MLLoadString(ids, szSearchPath, ARRAYSIZE(szSearchPath));
        }
    }

    if (fSuccess && lstrlen(szSearchPath) > 1)
    {
        // 1. Look in the registry and find all of the original characters and it's
        // matches and store them in the DSA arrays of SURlCharReplace
        // 2. Replace all of the occurences of the original characters in the 
        // URL search key word by their matches.
        // 3. Append the search URL and the search key words
        
        TCHAR szURLReplaced[MAX_URL_STRING];
        
        StrCpyN(szURLReplaced, pcszQuery, ARRAYSIZE(szURLReplaced));
        _ReplaceChars(hkeySearch, pcszQuery, szURLReplaced, ARRAYSIZE(szURLReplaced));

        //
        // If we are using our search engine, convert the string to UTF8 and escape it
        // so that it appears like normal ascii
        //
        if (NULL == hkeySearch)
        {
            _ConvertToUtf8(szURLReplaced, ARRAYSIZE(szURLReplaced));
        }

        // If this is an old-style url, there will be a %s in it for the search string.
        // Otherwise there will be the following parameters:
        //
        // http://whatever.com?p=%1&srch=%2&prov=%3&utf8
        //
        //  %1 = search string
        //  %2 = how to display results:
        //        "1" = just show me results in full window
        //        "2" = show results in full window, but redirect if possible
        //        "3" = show results in the search pane, and take me to the most
        //              likely site in the main window if there is one
        //  %3 = search provider name
        //
        LPWSTR pszParam1 = StrStr(szSearchPath, L"%1");
        if (NULL != pszParam1)
        {
            //
            // We can't use FormatMessage because on win95 it converts to ansi
            // using the system code page and the translation back is lossy.
            // So we'll replace the parameters ourselves. Arrrggg.
            //

            // First convert %1 to %s
            pszParam1[1] = L's';

            // Next replace %2 with the display option in %2 
            LPWSTR pszParam2 = StrStr(szSearchPath, L"%2");
            if (NULL != pszParam2)
            {
                DWORD dwValue;
                    
                if (pSC != NULL)
                {
                    hr = pSC->GetSearchStyle(&dwValue);
                }
                else
                {
                    DWORD cbValue = sizeof(dwValue);
                    if (SHRegGetUSValue(REGSTR_PATH_MAIN, L"AutoSearch", &dwType, &dwValue, &cbValue, FALSE, NULL, 0) != ERROR_SUCCESS ||
                        dwValue > 9)
                    {
                        // Default to "display results in search pane and go to most likely site"
                        dwValue = 3;
                    }
                }

                *pszParam2 = (WCHAR)dwValue + L'0';
                StrCpyN(pszParam2 + 1, pszParam2 + 2, (int)(ARRAYSIZE(szSearchPath) - ((pszParam2 + 1) - szSearchPath)));
            }

            // Finally, find the third Param and convert it to %s too
            LPWSTR pszParam3 = StrStr(szSearchPath, L"%3");
            if (pszParam3)
            {
                // Insert the provider in the third param
                WCHAR szTemp[MAX_URL_STRING];
                StrCpyN(szTemp, pszParam3 + 2, ARRAYSIZE(szTemp));
                *pszParam3 = 0;
                StrCatBuff(szSearchPath, szProvider, ARRAYSIZE(szSearchPath));
                StrCatBuff(szSearchPath, szTemp, ARRAYSIZE(szSearchPath));
            }
        }

        // Now replace the %s with the search string
        wnsprintf(pszTranslatedUrl, cchTranslatedUrl, szSearchPath, szURLReplaced);
        hr = S_OK;
    }

    if (hkeySearch)
        RegCloseKey(hkeySearch);
    return hr;
}

HRESULT CURLSearchHook::TranslateWithSearchContext(LPWSTR lpwszSearchURL, DWORD cchBufferSize, ISearchContext * pSC)
{
    HRESULT hr = E_FAIL;
    TCHAR szSearchURL[MAX_URL_STRING];

    SHUnicodeToTChar(lpwszSearchURL, szSearchURL, ARRAYSIZE(szSearchURL));
    
    HKEY hkeySearch;
    LPCTSTR pcszQuery;
    if (_IsURLSearchable(szSearchURL, &hkeySearch, &pcszQuery) == S_OK)
    {
        BSTR bstrSearchUrl = NULL;

        if (pSC != NULL)
        {
            pSC->GetSearchUrl(&bstrSearchUrl);
        }

        hr = _Search(hkeySearch, pcszQuery, szSearchURL, ARRAYSIZE(szSearchURL), bstrSearchUrl, pSC);
        if (hr == S_OK)
            SHTCharToUnicode(szSearchURL, lpwszSearchURL, cchBufferSize); 

        if (bstrSearchUrl != NULL)
        {
            SysFreeString(bstrSearchUrl);
        }
    }
    
    return hr;
}

HRESULT CURLSearchHook::Translate(LPWSTR lpwszSearchURL, DWORD cchBufferSize)
{
    return TranslateWithSearchContext(lpwszSearchURL, cchBufferSize, NULL);
}


#ifdef DEBUG
extern void remove_from_memlist(void *pv);
#endif

STDAPI CURLSearchHook_CreateInstance(IUnknown* pUnkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    HRESULT hr = E_OUTOFMEMORY;

    CURLSearchHook *pcush = new CURLSearchHook;

    if (pcush)
    {
        //
        // HACK:(dli)
        //
        //   IURLSearchHook objects are free-threaded objects, meaning that
        // they are cacheed and shared between different IEXPLORE processes, 
        // and they are only deleted when the SHDOCVW DLL ref count is 0. 
        // So, we can remove them from the SATOSHI's memlist.
        //
        // By the way, SATOSHI has Okayed this. Don't copy this code without
        // talking to SATOSHI.
        //
        *ppunk = (IUnknown *) pcush;
        hr = S_OK;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\url.cpp ===
/*
 * url.cpp - IUniformResourceLocator implementation for InternetShortcut class.
 */


/* Headers
 **********/

#include "priv.h"
#pragma hdrstop
#define INC_OLE2
#include "intshcut.h"


/* Module Constants
 *******************/

const TCHAR c_szURLPrefixesKey[]        = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\URL\\Prefixes");
const TCHAR c_szDefaultURLPrefixKey[]   = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\URL\\DefaultPrefix");

// DPA array that holds the IURLSearchHook Pointers
static HDPA g_hdpaHooks = NULL;

// CURRENT_USER
static const TCHAR c_szURLSearchHook[] = TSZIEPATH TEXT("\\URLSearchHooks");


/***************************** Private Functions *****************************/


int DPA_DestroyURLSearchHooksCallback(LPVOID p, LPVOID d)
{
    IURLSearchHook * psuh = (IURLSearchHook *)p;
    ASSERT(psuh);
    ATOMICRELEASET(psuh, IURLSearchHook);

    return 1; 
}

extern "C" {
    
void DestroyHdpaHooks()
{
    if (g_hdpaHooks)
    {
        ENTERCRITICAL;
        //---------------------------- Critical Section -------------------------
        HDPA hdpa = g_hdpaHooks;
        g_hdpaHooks = NULL;
        //-----------------------------------------------------------------------
        LEAVECRITICAL;
        if (hdpa)
        {
            DPA_DestroyCallback(hdpa, DPA_DestroyURLSearchHooksCallback, 0);
            hdpa = NULL;
        }
    }
}

}

HRESULT InvokeURLSearchHook(IURLSearchHook * pusHook, LPCTSTR pcszQuery, LPTSTR pszResult, ISearchContext * pSC)
{
    HRESULT hr = E_FAIL;
    
    ASSERT(pusHook);
    WCHAR szSearchURL[MAX_URL_STRING]; 

    SHTCharToUnicode(pcszQuery, szSearchURL, ARRAYSIZE(szSearchURL));

    // if we can get an IURLSearchHook2, we'll pass in the
    // search context, otherwise we'll just do without

    IURLSearchHook2 * pUSH2 = NULL;
    hr = pusHook->QueryInterface(IID_IURLSearchHook2, (void **)&pUSH2);
    if (SUCCEEDED(hr))
    {
        RIP(pUSH2 != NULL);
        hr = pUSH2->TranslateWithSearchContext(szSearchURL, ARRAYSIZE(szSearchURL), pSC);
        pUSH2->Release();
    }
    else
    {
        hr = pusHook->Translate(szSearchURL, ARRAYSIZE(szSearchURL));
    }
            
    // In case the URLSearchHook worked, convert result to TCHAR
    // This includes two cases: S_OK and S_FALSE
    if (SUCCEEDED(hr))
    {
        //WARNING: (dli) Assuming pszResult size = MAX_URL_STRING 
        SHUnicodeToTChar(szSearchURL, pszResult, MAX_URL_STRING);
    }

    return hr;    
}


/* 
 * Returns: 
 * S_OK         Search handled completely, pszResult has the full URL to browse to. 
 * 0x00000000   Stop running any further IURLSearchHooks and pass this URL back to 
 *              the browser for browsing.
 *
 * S_FALSE      Query has been preprocessed, pszResult has the result of the preprocess, 
 * 0x00000001   further search still needed. Go on executing the rest of the IURLSearchHooks 
 *              The preprocessing steps can be: 1. replaced certain characters
 *                                              2. added more hints 
 *
 * E_ABORT      Search handled completely, stop running any further IURLSearchHooks, 
 * 0x80004004   but NO BROWSING NEEDED as a result, pszResult is a copy of pcszQuery. 
 *              FEATURE: This is not fully implemented, yet, making IURLQualify return this
 *              involves too much change. 
 * 
 * E_FAIL       This Hook was unsuccessful. Search not handled at all, pcszQueryURL has the 
 * 0x80004005   query string. Please go on running other IURLSearchHooks. 
 * return
 */

HRESULT TryURLSearchHooks(LPCTSTR pcszQuery, LPTSTR pszResult, ISearchContext * pSC)
{
    HRESULT hr = E_FAIL;
    
    TCHAR szNewQuery[MAX_URL_STRING];
    StrCpyN(szNewQuery, pcszQuery, ARRAYSIZE(szNewQuery));

    int ihdpa;
    for (ihdpa = 0; ihdpa < (g_hdpaHooks ? DPA_GetPtrCount(g_hdpaHooks) : 0); ihdpa++)
    {
        IURLSearchHook * pusHook;
        pusHook = (IURLSearchHook *) DPA_GetPtr(g_hdpaHooks, ihdpa);
        if (!pusHook)
            return E_FAIL;
        hr = InvokeURLSearchHook(pusHook, szNewQuery, pszResult, pSC);
        if ((hr == S_OK) || (hr == E_ABORT))
            break;
        else if (hr == S_FALSE)
            StrCpyN(szNewQuery, pszResult, ARRAYSIZE(szNewQuery));
    }

    return hr;
}


void InitURLSearchHooks()
{
    HDPA hdpa = DPA_Create(4);
    
    // We need to look in LOCAL_MACHINE if this registry entry doesn't exist in CURRENT_USER.
    // The installer needs to install the values into LOCAL_MACHINE so they are accessable
    // to all users.  Then anyone wanting to modify the value, will need to determine if they
    // want to add it to a specific user's CURRENT_USER or modify the LOCAL_MACHINE value to 
    // apply the change to all users.  (bryanst - #6722)
    HUSKEY hkeyHooks;
    if ((hdpa) && (SHRegOpenUSKey(c_szURLSearchHook, KEY_READ, NULL, &hkeyHooks, FALSE) == ERROR_SUCCESS))
    {    
        TCHAR szCLSID[GUIDSTR_MAX];
        DWORD dwccCLSIDLen;
        LONG lEnumReturn;
        DWORD dwiValue = 0;
        
        do {
            dwccCLSIDLen = ARRAYSIZE(szCLSID);
            lEnumReturn = SHRegEnumUSValue(hkeyHooks, dwiValue, szCLSID, &dwccCLSIDLen, 
                                       NULL, NULL, NULL, SHREGENUM_DEFAULT);
            if (lEnumReturn == ERROR_SUCCESS)
            {
                CLSID clsidHook;
                if (SUCCEEDED(SHCLSIDFromString(szCLSID, &clsidHook)))
                {
                    IURLSearchHook * pusHook;

                    HRESULT hr = CoCreateInstance(clsidHook, NULL, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER, 
                                                  IID_IURLSearchHook, (LPVOID *)&pusHook);
        
                    if (SUCCEEDED(hr))
                        DPA_AppendPtr(hdpa, pusHook);
                }   
            }
            dwiValue++;            
        } while (lEnumReturn == ERROR_SUCCESS);
        
        SHRegCloseUSKey(hkeyHooks);
    }
    
    ENTERCRITICAL;
    //---------------------------- Critical Section --------------------------
    if (!g_hdpaHooks)
    {
        g_hdpaHooks = hdpa;
        hdpa = NULL;
    }
    //------------------------------------------------------------------------
    LEAVECRITICAL;
    
    if (hdpa)
    {
        DPA_DestroyCallback(hdpa, DPA_DestroyURLSearchHooksCallback, 0);
        hdpa = NULL;
    }
}

    
HRESULT ApplyURLSearch(LPCTSTR pcszQuery, LPTSTR pszTranslatedUrl, ISearchContext * pSC)
{
    if (!g_hdpaHooks)
        InitURLSearchHooks();
    
    return TryURLSearchHooks(pcszQuery, pszTranslatedUrl, pSC);
}

/*----------------------------------------------------------
Purpose: This function qualifies a string as a URL.  Strings
         such as "www.foo.com" would have the scheme guessed
         if the correct flags are given.  Local paths are 
         converted to "file:" URLs.

         pszTranslatedURL may point to the same buffer as 
         pcszURL.

         If the given string is already a URL (not necessarily
         canonicalized, though), this function will not touch it, 
         unless UQF_CANONICALIZE is set, in which case the string 
         will be canonicalized.

Returns: S_OK or S_FALSE means we filled in pszTranslatedURL.
         S_OK means we altered the URL to qualify it too.
         various failure codes too

Cond:    --
*/
SHDOCAPI
IURLQualifyWithContext(
    IN  LPCWSTR pcszURL, 
    IN  DWORD   dwFlags,         // UQF_*
    OUT LPWSTR  pszTranslatedURL,
    LPBOOL      pbWasSearchURL,
    LPBOOL      pbWasCorrected,
    ISearchContext *  pSC)
{
    HRESULT hres = S_FALSE;
    DWORD cchSize;

    SHSTR strOut;
    BOOL bWasCorrected = FALSE; 

    ASSERT(IS_VALID_STRING_PTR(pcszURL, -1));
    ASSERT(IS_VALID_WRITE_BUFFER(pszTranslatedURL, TCHAR, MAX_URL_STRING));

    if (pbWasSearchURL)
        *pbWasSearchURL = FALSE;

    // Special cases: URLs of the form <drive>:<filename>
    //                URLs of the form \<filename>
    // we'll assume that if the second character is a : or |, this is an url of
    // that form, and we will guess "file://" for the prefix.
    // we'll assume any url that begins with a single \ is a file: url
 
    // NOTE: We do this here because these are cases where the protocol is 
    // left off, and is likely to be incorrectly guessed, such as a 
    // relative path \data\ftp\docs, would wrongly be turned 
    // into "ftp://\data\ftp\docs".
 

    // Note: PathIsURL returns TRUE for non-canonicalized URLs too
    if (PathIsURL(pcszURL))
    {
        LPCWSTR pcszTemp = pcszURL;
        cchSize = MAX_URL_STRING;
        if (IsFlagSet(dwFlags, UQF_AUTOCORRECT))
        {
            hres = UrlFixup(pcszURL, pszTranslatedURL, cchSize);
            if (hres == S_OK)
            {
                bWasCorrected = TRUE;
                pcszTemp = pszTranslatedURL;
            }
        }

        if (dwFlags & UQF_CANONICALIZE)
            hres = UrlCanonicalize(pcszTemp, pszTranslatedURL, &cchSize, 0);
        else if (pszTranslatedURL != pcszTemp)
            StrCpyN(pszTranslatedURL, pcszTemp, MAX_URL_STRING);

        hres = S_OK;
    }
    else
    {
        // Look for file paths
        if (IsFlagClear(dwFlags, UQF_IGNORE_FILEPATHS) && (
#ifdef UNIX
            pcszURL[0] == TEXT('/') ||
#endif
            pcszURL[1] == TEXT(':') || pcszURL[1] == TEXT('|') || pcszURL[0] == TEXT('\\')))
        {
            hres = strOut.SetSize(MAX_PATH);

            if(SUCCEEDED(hres))
            {
                //  SHSTRs have a size granularity, so the size
                //  will be equal to or greater than what was set.
                //  this means we need to get it our self.
                DWORD cchOut = strOut.GetSize();
                TCHAR szCurrentDir[MAX_PATH];

                //
                //  APPCOMPAT - IE30 compatibility - zekel 8-Jan-97
                //  we need to GetCurrentDirectory() in order to
                //  put a default drive letter on the path
                //  if necessary.  
                //

                if(GetCurrentDirectory(ARRAYSIZE(szCurrentDir), szCurrentDir))
                    PathCombine(strOut.GetInplaceStr(), szCurrentDir, pcszURL);
                else
                    hres = strOut.SetStr(pcszURL);

                if(SUCCEEDED(hres))
                {
                    hres = UrlCreateFromPath(strOut, strOut.GetInplaceStr(), &cchOut, 0);
                    if (E_POINTER == hres && SUCCEEDED(hres = strOut.SetSize(cchOut)))
                    {
                        cchOut = strOut.GetSize();
                        hres = UrlCreateFromPath(strOut, strOut.GetInplaceStr(), &cchOut, 0);
                    }
                }
            }
        }
        else if (SUCCEEDED(hres = strOut.SetSize(MAX_URL_STRING)))
        {
            //  all the Apply*() below rely on MAX_URL_STRING

            // No; begin processing general-case URLs.  Try to guess the
            // protocol or resort to the default protocol.

            DWORD cchOut = strOut.GetSize();
            if (IsFlagSet(dwFlags, UQF_GUESS_PROTOCOL))
                hres = UrlApplyScheme(pcszURL, strOut.GetInplaceStr(), &cchOut, URL_APPLY_GUESSSCHEME);

            //
            // Try to auto-correct the protocol
            //
            if (hres == S_FALSE &&
                IsFlagSet(dwFlags, UQF_AUTOCORRECT))
            {
                hres = UrlFixup(pcszURL, strOut.GetInplaceStr(), strOut.GetSize());
                bWasCorrected = (hres == S_OK);
            }

            if (hres == S_FALSE &&
                IsFlagSet(dwFlags, UQF_USE_DEFAULT_PROTOCOL)) 
            {
                // run the search with or without the search context
                hres = ApplyURLSearch(pcszURL, strOut.GetInplaceStr(), pSC);
                if (SUCCEEDED(hres) && pbWasSearchURL) {
                    *pbWasSearchURL = TRUE;
                }
                
                // If that fails, then tack on the default protocol
                if (FAILED(hres) || hres == S_FALSE)
                {
                    cchOut = strOut.GetSize();
                    hres = UrlApplyScheme(pcszURL, strOut.GetInplaceStr(), &cchOut, URL_APPLY_DEFAULT);
                }
            }

            // Did the above fail?
            if (S_FALSE == hres)
            {
                // Yes; return the real reason why the URL is bad
                hres = URL_E_INVALID_SYNTAX;
            }
            else if (dwFlags & UQF_CANONICALIZE)
            {
                // No; canonicalize
                cchSize = strOut.GetSize();
                hres = UrlCanonicalize(strOut, strOut.GetInplaceStr(), &cchSize, 0);
            }
        }

        if (SUCCEEDED(hres))
        {
            StrCpyN(pszTranslatedURL, strOut, MAX_URL_STRING);
        }
    }

    if (pbWasCorrected)
        *pbWasCorrected = bWasCorrected;

    return hres;
}

SHDOCAPI
IURLQualify(
    IN  LPCWSTR pcszURL, 
    IN  DWORD   dwFlags,         // UQF_*
    OUT LPWSTR  pszTranslatedURL,
    LPBOOL      pbWasSearchURL,
    LPBOOL      pbWasCorrected)
{
    return IURLQualifyWithContext(pcszURL, dwFlags, pszTranslatedURL, pbWasSearchURL, pbWasCorrected, NULL);
}


/***************************** Exported Functions ****************************/


STDAPI
URLQualifyA(
    LPCSTR pszURL, 
    DWORD  dwFlags,         // UQF_*
    LPSTR *ppszOut)
{
    HRESULT hres;

    ASSERT(IS_VALID_STRING_PTRA(pszURL, -1));
    ASSERT(IS_VALID_WRITE_PTR(ppszOut, LPSTR));

    *ppszOut = NULL;

    WCHAR szTempTranslatedURL[MAX_URL_STRING];
    WCHAR szURL[MAX_URL_STRING];

    SHAnsiToUnicode(pszURL, szURL, ARRAYSIZE(szURL));

    hres = IURLQualify(szURL, dwFlags, szTempTranslatedURL, NULL, NULL);

    if (SUCCEEDED(hres))
    {
        CHAR szOut[MAX_URL_STRING];

        SHUnicodeToAnsi(szTempTranslatedURL, szOut, ARRAYSIZE(szOut));

        *ppszOut = StrDupA(szOut);

        if (!*ppszOut)
            hres = E_OUTOFMEMORY;
    }

    return hres;
}


STDAPI
URLQualifyW(
    LPCWSTR pszURL, 
    DWORD  dwFlags,         // UQF_*
    LPWSTR *ppszOut)
{
    HRESULT hres;

    ASSERT(IS_VALID_STRING_PTRW(pszURL, -1));
    ASSERT(IS_VALID_WRITE_PTR(ppszOut, LPWSTR));

    WCHAR szTempTranslatedURL[MAX_URL_STRING];

    hres = IURLQualify(pszURL, dwFlags, szTempTranslatedURL, NULL, NULL);

    if (SUCCEEDED(hres))
    {
        *ppszOut = StrDup(szTempTranslatedURL);

        if (!*ppszOut)
            hres = E_OUTOFMEMORY;
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\urlassoc.cpp ===
/*
 * urlassoc.c - URL Type association routines.
 */


#include "priv.h"
#include "ishcut.h"
#include <filetype.h>
#include <shlwapip.h>
#include "assocurl.h"
#include "resource.h"
#include <intshctp.h>

#include <mluisupp.h>

#define c_szURLProtocol     TEXT("URL Protocol")
#define c_szEditFlags       TEXT("EditFlags")

#define c_szMIMETypeSubKeyFmt       TEXT("MIME\\Database\\Content Type\\%s")

#define c_szShellOpenCmdSubKeyFmt       TEXT("%s\\shell\\open\\command")
#define c_szAppOpenCmdFmt       TEXT("%s %%1")
#define c_szDefaultIconSubKeyFmt        TEXT("%s\\DefaultIcon")
#define c_szDefaultProtocolIcon     TEXT("shdocvw.dll,-105")


/***************************** Private Functions *****************************/

extern "C" {




/*
** RegisterAppAsURLProtocolHandler()
**
** Under HKEY_CLASSES_ROOT\url-protocol\shell\open\command, add default value =
** "c:\foo\bar.exe %1".
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
BOOL
RegisterAppAsURLProtocolHandler(
    LPCTSTR pcszProtocol,
    LPCTSTR pcszApp)
{
    BOOL bResult = FALSE;
    DWORD cbShellOpen;
    LPTSTR pszShellOpen;

    ASSERT(IS_VALID_STRING_PTR(pcszProtocol, -1));
    ASSERT(IS_VALID_STRING_PTR(pcszApp, -1));

    /* (+ 1) for null terminator. */
    cbShellOpen = SIZEOF(c_szShellOpenCmdSubKeyFmt) +
                         CbFromCch(1 + lstrlen(pcszProtocol));

    pszShellOpen = (LPTSTR)LocalAlloc(LPTR, cbShellOpen);

    if (pszShellOpen)
    {
        DWORD cbAppOpen;
        LPTSTR pszAppOpen;

        /* FEATURE: We should quote pcszApp here only if it contains spaces. */

        /* (+ 1) for null terminator. */
        cbAppOpen = SIZEOF(c_szAppOpenCmdFmt) +
                           CbFromCch(1 + lstrlen(pcszApp));

        pszAppOpen = (LPTSTR)LocalAlloc(LPTR, cbAppOpen);

        if (pszAppOpen)
        {
            wnsprintf(pszShellOpen, cbShellOpen / sizeof(TCHAR),
                      c_szShellOpenCmdSubKeyFmt, pcszProtocol);

            wnsprintf(pszAppOpen, cbAppOpen / sizeof(TCHAR), c_szAppOpenCmdFmt,
                      pcszApp);

            /* (+ 1) for null terminator. */
            bResult = (NO_ERROR == SHSetValue(HKEY_CLASSES_ROOT, pszShellOpen, NULL,
                                              REG_SZ, pszAppOpen,
                                              CbFromCch(lstrlen(pszAppOpen) + 1)));

            LocalFree(pszAppOpen);
            pszAppOpen = NULL;
        }

        LocalFree(pszShellOpen);
        pszShellOpen = NULL;
    }

    return(bResult);
}


/*
** RegisterURLProtocolDescription()
**
** Under HKEY_CLASSES_ROOT\url-protocol, add default value =
** URL:Url-protocol Protocol.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
BOOL
RegisterURLProtocolDescription(
    LPCTSTR pcszProtocol)
{
    BOOL bResult = FALSE;
    LPTSTR pszProtocolCopy = NULL;

    ASSERT(IS_VALID_STRING_PTR(pcszProtocol, -1));

    if (Str_SetPtr(&pszProtocolCopy, pcszProtocol))
    {
        TCHAR szDescriptionFmt[MAX_PATH];

        /*
         * Convert first character of protocol to upper case for description
         * string.
         */

        *pszProtocolCopy = (TCHAR) (DWORD_PTR) CharUpper((LPTSTR)(DWORD_PTR)*pszProtocolCopy);

        if (MLLoadString(IDS_URL_DESC_FORMAT, szDescriptionFmt, SIZECHARS(szDescriptionFmt)))
        {
            TCHAR szDescription[MAX_PATH];

            if ((UINT)lstrlen(szDescriptionFmt) + (UINT)lstrlen(pszProtocolCopy)
                < SIZECHARS(szDescription))
            {
                wnsprintf(szDescription, ARRAYSIZE(szDescription), szDescriptionFmt,
                          pszProtocolCopy);

                /* (+ 1) for null terminator. */
                bResult = (NO_ERROR == SHSetValue(HKEY_CLASSES_ROOT, pcszProtocol, NULL,
                                                  REG_SZ, szDescription,
                                                  CbFromCch(lstrlen(szDescription) + 1)));
            }
        }

        Str_SetPtr(&pszProtocolCopy, NULL);
    }

    return(bResult);
}


/*
** RegisterURLProtocolFlags()
**
** Under HKEY_CLASSES_ROOT\url-protocol, add EditFlags = FTA_Show.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
BOOL
RegisterURLProtocolFlags(
    LPCTSTR pcszProtocol)
{
    DWORD dwEditFlags = FTA_Show;

    ASSERT(IS_VALID_STRING_PTR(pcszProtocol, -1));

    /* FEATURE: What about preserving any existing EditFlags here? */

    return NO_ERROR == SHSetValue(HKEY_CLASSES_ROOT, pcszProtocol, c_szEditFlags,
                                  REG_BINARY, &dwEditFlags, SIZEOF(dwEditFlags));
}


/*
** RegisterURLProtocol()
**
** Under HKEY_CLASSES_ROOT\url-protocol, add URL Protocol = "".
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
BOOL
RegisterURLProtocol(
    LPCTSTR pcszProtocol)
{
    ASSERT(IS_VALID_STRING_PTR(pcszProtocol, -1));

    // REVIEW (scotth): what does this value mean??

    /* (+ 1) for null terminator. */
    return NO_ERROR == SHSetValue(HKEY_CLASSES_ROOT, pcszProtocol, c_szURLProtocol,
                                  REG_SZ, c_szNULL, CbFromCch(1));
}


/*
** RegisterURLProtocolDefaultIcon()
**
** Under HKEY_CLASSES_ROOT\url-protocol\DefaultIcon, add default value =
** app.exe,0.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
BOOL
RegisterURLProtocolDefaultIcon(
    LPCTSTR pcszProtocol)
{
    BOOL bResult = FALSE;
    DWORD cbAlloc;
    LPTSTR pszT;

    ASSERT(IS_VALID_STRING_PTR(pcszProtocol, -1));

    /* (+ 1) for null terminator. */
    cbAlloc = SIZEOF(c_szDefaultIconSubKeyFmt) +
              CbFromCch(1 + lstrlen(pcszProtocol));

    pszT = (LPTSTR)LocalAlloc(LPTR, cbAlloc);

    if (pszT)
    {
        wnsprintf(pszT, cbAlloc / sizeof(TCHAR), c_szDefaultIconSubKeyFmt,
                  pcszProtocol);

        bResult = (NO_ERROR == SHSetValue(HKEY_CLASSES_ROOT, pszT, NULL, REG_SZ,
                                          c_szDefaultProtocolIcon,
                                          SIZEOF(c_szDefaultProtocolIcon)));

        LocalFree(pszT);
        pszT = NULL;
    }

    return(bResult);
}


BOOL
AllowedToRegisterMIMEType(
    LPCTSTR pcszMIMEContentType)
{
    BOOL bResult;

    bResult = (0 != StrCmpI(pcszMIMEContentType, TEXT("application/octet-stream")) &&
               0 != StrCmpI(pcszMIMEContentType, TEXT("application/octet-string")));

    return(bResult);
}


BOOL
RegisterMIMEAssociation(
    LPCTSTR pcszFile,
    LPCTSTR pcszMIMEContentType)
{
    BOOL bResult;
    LPCTSTR pcszExtension;

    ASSERT(IS_VALID_STRING_PTR(pcszFile, -1));
    ASSERT(IS_VALID_STRING_PTR(pcszMIMEContentType, -1));

    pcszExtension = PathFindExtension(pcszFile);

     /*
      * Don't allow association of flag unknown MIME types
      * application/octet-stream and application/octet-string.
      */

    if (EVAL(*pcszExtension) &&
        AllowedToRegisterMIMEType(pcszMIMEContentType))
    {
        bResult = (RegisterMIMETypeForExtension(pcszExtension, pcszMIMEContentType) &&
                   RegisterExtensionForMIMEType(pcszExtension, pcszMIMEContentType));
    }
    else
        bResult = FALSE;

    return(bResult);
}


BOOL
RegisterURLAssociation(
    LPCTSTR pcszProtocol,
    LPCTSTR pcszApp)
{
    ASSERT(IS_VALID_STRING_PTR(pcszProtocol, -1));
    ASSERT(IS_VALID_STRING_PTR(pcszApp, -1));

    return(RegisterAppAsURLProtocolHandler(pcszProtocol, pcszApp) &&
           RegisterURLProtocolDescription(pcszProtocol) &&
           RegisterURLProtocol(pcszProtocol) &&
           RegisterURLProtocolFlags(pcszProtocol) &&
           RegisterURLProtocolDefaultIcon(pcszProtocol));
}


HRESULT
MyMIMEAssociationDialog(
    HWND hwndParent,
    DWORD dwInFlags,
    LPCTSTR pcszFile,
    LPCTSTR pcszMIMEContentType,
    LPTSTR pszAppBuf,
    UINT cchAppBuf)
{
    HRESULT hr;
    OPENASINFO oainfo;

    ASSERT(IS_VALID_HANDLE(hwndParent, WND));
    ASSERT(FLAGS_ARE_VALID(dwInFlags, ALL_MIMEASSOCDLG_FLAGS));
    ASSERT(IS_VALID_STRING_PTR(pcszFile, -1));
    ASSERT(IS_VALID_STRING_PTR(pcszMIMEContentType, -1));
    ASSERT(IS_VALID_WRITE_BUFFER(pszAppBuf, TCHAR, cchAppBuf));

    /* Use default file name if not supplied by caller. */

    if (cchAppBuf > 0)
        *pszAppBuf = '\0';

    oainfo.pcszFile = pcszFile;
    oainfo.pcszClass = pcszMIMEContentType;
    oainfo.dwInFlags = 0;

    if (IsFlagSet(dwInFlags, MIMEASSOCDLG_FL_REGISTER_ASSOC))
    {
        SetFlag(oainfo.dwInFlags, (OAIF_ALLOW_REGISTRATION |
                                    OAIF_REGISTER_EXT));
    }

#if 0   // FEATURE (scotth): fix this
    hr = OpenAsDialog(hwndParent, &oainfo);
#else
    hr = E_FAIL;
#endif

    if (hr == S_OK &&
        IsFlagSet(dwInFlags, MIMEASSOCDLG_FL_REGISTER_ASSOC))
    {
        hr = RegisterMIMEAssociation(pcszFile, pcszMIMEContentType) ? S_OK
                                                                   : E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
        StrCpyN(pszAppBuf, oainfo.szApp, cchAppBuf);

    ASSERT(! cchAppBuf ||
           (IS_VALID_STRING_PTR(pszAppBuf, -1) &&
            EVAL((UINT)lstrlen(pszAppBuf) < cchAppBuf)));
    ASSERT(SUCCEEDED(hr) ||
           (! cchAppBuf ||
            EVAL(! *pszAppBuf)));

    return(hr);
}


HRESULT
MyURLAssociationDialog(
    HWND hwndParent,
    DWORD dwInFlags,
    LPCTSTR pcszFile,
    LPCTSTR pcszURL,
    LPTSTR pszAppBuf,
    UINT cchAppBuf)
{
    HRESULT hr;
    LPTSTR pszProtocol;

    ASSERT(IS_VALID_HANDLE(hwndParent, WND));
    ASSERT(FLAGS_ARE_VALID(dwInFlags, ALL_URLASSOCDLG_FLAGS));
    ASSERT(IsFlagSet(dwInFlags, URLASSOCDLG_FL_USE_DEFAULT_NAME) ||
           IS_VALID_STRING_PTR(pcszFile, -1));
    ASSERT(IS_VALID_STRING_PTR(pcszURL, -1));
    ASSERT(IS_VALID_WRITE_BUFFER(pszAppBuf, TCHAR, cchAppBuf));

    /* Use URL protocol as class name. */

    if (cchAppBuf > 0)
        *pszAppBuf = '\0';

    hr = CopyURLProtocol(pcszURL, &pszProtocol, NULL);

    if (hr == S_OK)
    {
        TCHAR szInternetShortcut[MAX_PATH];
        OPENASINFO oainfo;

        /* Use default file name if not supplied by caller. */

        if (IsFlagSet(dwInFlags, URLASSOCDLG_FL_USE_DEFAULT_NAME) &&
            EVAL(MLLoadString(IDS_INTERNET_SHORTCUT,
                               szInternetShortcut,
                               SIZECHARS(szInternetShortcut))))
        {
            pcszFile = szInternetShortcut;
        }

        oainfo.pcszFile = pcszFile;
        oainfo.pcszClass = pszProtocol;
        oainfo.dwInFlags = 0;

        if (IsFlagSet(dwInFlags, URLASSOCDLG_FL_REGISTER_ASSOC))
            SetFlag(oainfo.dwInFlags, OAIF_ALLOW_REGISTRATION);

#if 0   // FEATURE (scotth): fix this
        hr = OpenAsDialog(hwndParent, &oainfo);
#else
        hr = E_FAIL;
#endif

        if (hr == S_OK &&
            IsFlagSet(dwInFlags, URLASSOCDLG_FL_REGISTER_ASSOC))
        {
            hr = RegisterURLAssociation(pszProtocol, oainfo.szApp) ? S_OK
                                                                   : E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hr))
            StrCpyN(pszAppBuf, oainfo.szApp, cchAppBuf);

        LocalFree(pszProtocol);
        pszProtocol = NULL;
    }

    ASSERT(! cchAppBuf ||
           (IS_VALID_STRING_PTR(pszAppBuf, -1) &&
            EVAL((UINT)lstrlen(pszAppBuf) < cchAppBuf)));
    ASSERT(SUCCEEDED(hr) ||
           (! cchAppBuf ||
            EVAL(! *pszAppBuf)));

    return(hr);
}


#ifdef DEBUG

BOOL
IsValidPCOPENASINFO(
    POPENASINFO poainfo)
{
    return(IS_VALID_READ_PTR(poainfo, OPENASINFO) &&
           IS_VALID_STRING_PTR(poainfo->pcszFile, -1) &&
           (! poainfo->pcszClass ||
            IS_VALID_STRING_PTR(poainfo->pcszClass, -1)) &&
           FLAGS_ARE_VALID(poainfo->dwInFlags, OAIF_ALL) &&
           (! *poainfo->szApp ||
            IS_VALID_STRING_PTR(poainfo->szApp, -1)));
}

#endif   /* DEBUG */


/***************************** Exported Functions ****************************/


/*----------------------------------------------------------
Purpose: Invoke the MIME-type association dialog.

Returns: standard hresult

Cond:    This API must conform to MIMEAssociationDialog semantics as
         defined in intshcut.h.  URL.DLL auto-forwards to this API in
         Nashville.

*/
STDAPI
AssociateMIME(
    HWND hwndParent,
    DWORD dwInFlags,
    LPCTSTR pcszFile,
    LPCTSTR pcszMIMEContentType,
    LPTSTR pszAppBuf,
    UINT cchAppBuf)
{
    HRESULT hr;

    /* Verify parameters. */

#ifdef EXPV
    if (IS_VALID_HANDLE(hwndParent, WND) &&
        IS_VALID_STRING_PTR(pcszFile, -1) &&
        IS_VALID_STRING_PTR(pcszMIMEContentType, -1) &&
        IS_VALID_WRITE_BUFFER(pszAppBuf, TCHAR, cchAppBuf))
    {
        if (FLAGS_ARE_VALID(dwInFlags, ALL_MIMEASSOCDLG_FLAGS))
        {
#endif
            hr = MyMIMEAssociationDialog(hwndParent, dwInFlags, pcszFile,
                                         pcszMIMEContentType, pszAppBuf,
                                         cchAppBuf);
#ifdef EXPV
        }
        else
            hr = E_FLAGS;
    }
    else
        hr = E_POINTER;
#endif

    return(hr);
}


STDAPI
AssociateMIMEA(
    HWND hwndParent,
    DWORD dwInFlags,
    LPCSTR pcszFile,
    LPCSTR pcszMIMEContentType,
    LPSTR pszAppBuf,
    UINT cchAppBuf)
{
    HRESULT hres;
    WCHAR wszFile[MAX_PATH];
    WCHAR wszMIMEType[MAX_PATH];
    LPWSTR pwszT;

    MultiByteToWideChar(CP_ACP, 0, pcszFile, -1, wszFile, SIZECHARS(wszFile));
    MultiByteToWideChar(CP_ACP, 0, pcszMIMEContentType, -1, wszMIMEType,
                        SIZECHARS(wszMIMEType));

    *pszAppBuf = '\0';

    pwszT = (LPWSTR)LocalAlloc(LPTR, CbFromCch(cchAppBuf));
    if (pwszT)
    {
        hres = AssociateMIME(hwndParent, dwInFlags, wszFile, wszMIMEType,
                               pwszT, cchAppBuf);

        if (SUCCEEDED(hres))
        {
            WideCharToMultiByte(CP_ACP, 0, pwszT, -1, pszAppBuf, cchAppBuf, NULL, NULL);
        }

        LocalFree(pwszT);
        pwszT = NULL;
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}



/*----------------------------------------------------------
Purpose: Invoke the URL association dialog.

Returns: standard hresult

Cond:    This API must conform to URLAssociationDialog semantics as
         defined in intshcut.h.  URL.DLL auto-forwards to this API in
         Nashville.

*/
STDAPI
AssociateURL(
    HWND hwndParent,
    DWORD dwInFlags,
    LPCTSTR pcszFile,
    LPCTSTR pcszURL,
    LPTSTR pszAppBuf,
    UINT cchAppBuf)
{
    HRESULT hr;

    /* Verify parameters. */

#ifdef EXPV
    if (IS_VALID_HANDLE(hwndParent, WND) &&
        (IsFlagSet(dwInFlags, URLASSOCDLG_FL_USE_DEFAULT_NAME) ||
         IS_VALID_STRING_PTR(pcszFile, -1)) &&
        IS_VALID_STRING_PTR(pcszURL, -1) &&
        IS_VALID_WRITE_BUFFER(pszAppBuf, TCHAR, cchAppBuf))
    {
        if (FLAGS_ARE_VALID(dwInFlags, ALL_URLASSOCDLG_FLAGS))
        {
#endif
            hr = MyURLAssociationDialog(hwndParent, dwInFlags, pcszFile, pcszURL,
                                        pszAppBuf, cchAppBuf);
#ifdef EXPV
        }
        else
            hr = E_FLAGS;
    }
    else
        hr = E_POINTER;
#endif

    return(hr);
}


STDAPI
AssociateURLA(
    HWND hwndParent,
    DWORD dwInFlags,
    LPCSTR pcszFile,
    LPCSTR pcszURL,
    LPSTR pszAppBuf,
    UINT cchAppBuf)
{
    HRESULT hres;
    WCHAR wszFile[MAX_PATH];
    WCHAR wszURL[INTERNET_MAX_URL_LENGTH];
    LPWSTR pwszT;

    MultiByteToWideChar(CP_ACP, 0, pcszFile, -1, wszFile, SIZECHARS(wszFile));
    MultiByteToWideChar(CP_ACP, 0, pcszURL, -1, wszURL, SIZECHARS(wszURL));

    *pszAppBuf = '\0';

    pwszT = (LPWSTR)LocalAlloc(LPTR, CbFromCch(cchAppBuf));
    if (pwszT)
    {
        hres = AssociateURL(hwndParent, dwInFlags, wszFile, wszURL,
                              pwszT, cchAppBuf);

        if (SUCCEEDED(hres))
        {
            WideCharToMultiByte(CP_ACP, 0, pwszT, -1, pszAppBuf, cchAppBuf, NULL, NULL);
        }

        LocalFree(pwszT);
        pwszT = NULL;
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}


};  // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\urlprop.h ===
/*
 * urlprop.h - URL properties class implementation description.
 */

#ifndef _URLPROP_H_
#define _URLPROP_H_

#include "propstg.h"

#ifdef __cplusplus

// URL Property object

class URLProp : public IPropertyStorage
    {
private:
    ULONG       m_cRef;
    CLSID       m_clsid;
    FMTID       m_fmtid;
    DWORD       m_grfFlags;

    // private methods

protected:
    HPROPSTG    m_hstg;
    FILETIME    m_ftModified;
    FILETIME    m_ftCreated;
    FILETIME    m_ftAccessed;

public:
    URLProp(void);
    virtual ~URLProp(void);

    // IUnknown methods
    
    virtual STDMETHODIMP  QueryInterface(REFIID riid, PVOID *ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    
    // IPropertyStorage methods

    virtual STDMETHODIMP ReadMultiple(ULONG cpspec, const PROPSPEC rgpspec[], PROPVARIANT rgvar[]);
    virtual STDMETHODIMP WriteMultiple(ULONG cpspec, const PROPSPEC rgpspec[], const PROPVARIANT rgvar[], PROPID propidNameFirst);
    virtual STDMETHODIMP DeleteMultiple(ULONG cpspec, const PROPSPEC rgpspec[]);
    virtual STDMETHODIMP ReadPropertyNames(ULONG cpropid, const PROPID rgpropid[], LPOLESTR rglpwstrName[]);
    virtual STDMETHODIMP WritePropertyNames(ULONG cpropid, const PROPID rgpropid[], const LPOLESTR rglpwstrName[]);
    virtual STDMETHODIMP DeletePropertyNames(ULONG cpropid, const PROPID rgpropid[]);
    virtual STDMETHODIMP SetClass(REFCLSID clsid);
    virtual STDMETHODIMP Commit(DWORD grfCommitFlags);
    virtual STDMETHODIMP Revert(void);
    virtual STDMETHODIMP Enum(IEnumSTATPROPSTG** ppenm);
    virtual STDMETHODIMP Stat(STATPROPSETSTG* pstatpsstg);
    virtual STDMETHODIMP SetTimes(const FILETIME* pmtime, const FILETIME* pctime, const FILETIME* patime);

    // other methods
    
    virtual STDMETHODIMP Init(void);

    STDMETHODIMP GetProp(PROPID pid, LPTSTR pszBuf, int cchBuf);
    STDMETHODIMP GetProp(PROPID pid, int * piVal);
    STDMETHODIMP GetProp(PROPID pid, LPDWORD pdwVal);
    STDMETHODIMP GetProp(PROPID pid, WORD * pwVal);
    STDMETHODIMP GetProp(PROPID pid, IStream **ppStream);
    STDMETHODIMP SetProp(PROPID pid, LPCTSTR psz);
    STDMETHODIMP SetProp(PROPID pid, int iVal);
    STDMETHODIMP SetProp(PROPID pid, DWORD dwVal);
    STDMETHODIMP SetProp(PROPID pid, WORD wVal);
    STDMETHODIMP SetProp(PROPID pid, IStream *pStream);

    STDMETHODIMP IsDirty(void);

#ifdef DEBUG
    virtual STDMETHODIMP_(void) Dump(void);
    friend BOOL IsValidPCURLProp(const URLProp *pcurlprop);
#endif

    };

typedef URLProp * PURLProp;
typedef const URLProp CURLProp;
typedef const URLProp * PCURLProp;


// Internet Shortcut Property object

class IntshcutProp : public URLProp
    {

    typedef URLProp super;

private:
    TCHAR       m_szFile[MAX_PATH];

    // private methods

    STDMETHODIMP LoadFromFile(LPCTSTR pszFile);

public:
    IntshcutProp(void);
    ~IntshcutProp(void);

    // IPropertyStorage methods

    virtual STDMETHODIMP Commit(DWORD grfCommitFlags);

    // other methods
    
    STDMETHODIMP Init(void);
    STDMETHODIMP InitFromFile(LPCTSTR pszFile);

    STDMETHODIMP SetFileName(LPCTSTR pszFile);
    STDMETHODIMP SetURLProp(LPCTSTR pszURL, DWORD dwFlags);
    STDMETHODIMP SetIDListProp(LPCITEMIDLIST pcidl);

    STDMETHODIMP SetProp(PROPID pid, LPCTSTR psz);
    STDMETHODIMP SetProp(PROPID pid, int iVal)          { return super::SetProp(pid, iVal); }
    STDMETHODIMP SetProp(PROPID pid, DWORD dwVal)       { return super::SetProp(pid, dwVal); }
    STDMETHODIMP SetProp(PROPID pid, WORD wVal)         { return super::SetProp(pid, wVal); }
    STDMETHODIMP SetProp(PROPID pid, IStream *pStream)  { return super::SetProp(pid, pStream); }

#ifdef DEBUG
    virtual STDMETHODIMP_(void) Dump(void);
    friend BOOL IsValidPCIntshcutProp(const IntshcutProp *pcisprop);
#endif

    };

typedef IntshcutProp * PIntshcutProp;
typedef const IntshcutProp CIntshcutProp;
typedef const IntshcutProp * PCIntshcutProp;

class Intshcut;

// Internet Site Property object

class IntsiteProp : public URLProp
    {
private:
    TCHAR       m_szURL[INTERNET_MAX_URL_LENGTH];
    Intshcut *  m_pintshcut;
    BOOL        m_fPrivate;

    // private methods

    STDMETHODIMP LoadFromDB(LPCTSTR pszURL);

public:
    IntsiteProp(void);
    ~IntsiteProp(void);

    // IPropertyStorage methods

    virtual STDMETHODIMP Commit(DWORD grfCommitFlags);

    // other methods
    
    STDMETHODIMP Init(void);
    STDMETHODIMP InitFromDB(LPCTSTR pszURL, Intshcut * pintshcut, BOOL fPrivObj);

#ifdef DEBUG
    virtual STDMETHODIMP_(void) Dump(void);
    friend BOOL IsValidPCIntsiteProp(const IntsiteProp *pcisprop);
#endif

    };

typedef IntsiteProp * PIntsiteProp;
typedef const IntsiteProp CIntsiteProp;
typedef const IntsiteProp * PCIntsiteProp;


DWORD
SchemeTypeFromURL(
   LPCTSTR pszURL);

#endif  // __cplusplus


//
// Prototypes for all modules
//

#ifdef __cplusplus
extern "C" {
#endif

typedef const PARSEDURL CPARSEDURL;
typedef const PARSEDURL * PCPARSEDURL;

STDAPI
CIntshcutProp_CreateInstance(
   IN  LPUNKNOWN punkOuter, 
   IN  REFIID    riid, 
   OUT LPVOID *  ppvOut);

STDAPI
CIntsiteProp_CreateInstance(
   IN  LPUNKNOWN punkOuter, 
   IN  REFIID    riid, 
   OUT LPVOID *  ppvOut);


// Worker routines for updating the ini file corresponding to a shortcut

HRESULT 
ReadStringFromFile(IN  LPCTSTR    pszFile, 
                   IN  LPCTSTR    pszSectionName,
                   IN  LPCTSTR    pszName,
                   OUT LPWSTR *   ppwsz,
                   IN  CHAR *     pszBuf);

HRESULT 
ReadBStrFromFile(IN  LPCTSTR      pszFile, 
                 IN  LPCTSTR      pszSectionName,
                 IN  LPCTSTR      pszName,
                 OUT BSTR *       pBstr);

HRESULT
ReadUnsignedFromFile(
    IN  LPCTSTR pszFile,
    IN  LPCTSTR pszSectionName,
    IN  LPCTSTR pszName,
    OUT LPDWORD pdwVal);

HRESULT 
WriteGenericString(
    IN LPCTSTR pszFile, 
    IN LPCTSTR pszSectionName,
    IN LPCTSTR pszName,
    IN LPCWSTR pwsz);

HRESULT 
WriteSignedToFile(
    IN LPCTSTR  pszFile,
    IN LPCTSTR  pszSectionName,
    IN LPCTSTR  pszName,
    IN int      nVal);

HRESULT 
WriteUnsignedToFile(
    IN LPCTSTR  pszFile,
    IN LPCTSTR  pszSectionName,
    IN LPCTSTR  pszName,
    IN DWORD    nVal);

HRESULT 
ReadURLFromFile(
    IN  LPCTSTR  pszFile, 
    IN  LPCTSTR pszSectionName,
    OUT LPTSTR * ppsz);

HRESULT 
ReadBinaryFromFile(
   IN LPCTSTR pszFile,
   IN LPCTSTR pszSectionName,
   IN LPCTSTR pszName,
   IN LPVOID  pvData,
   IN DWORD   cbData);

HRESULT 
WriteBinaryToFile(
  IN LPCTSTR pszFile,
  IN  LPCTSTR pszSectionName,
  IN LPCTSTR pszName,
  IN LPVOID  pvData,
  IN DWORD   cbSize);

#define DeletePrivateProfileString(pszSection, pszKey, pszFile) \
WritePrivateProfileString(pszSection, pszKey, NULL, pszFile)
#define SHDeleteIniString(pszSection, pszKey, pszFile) \
           SHSetIniString(pszSection, pszKey, NULL, pszFile)
#ifdef __cplusplus
};  // extern "C"
#endif

#endif  // _URLPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\urlhist.cpp ===
//
// Copyright (c) 1996  Microsoft Corporation
//
// Module Name: Url History Interfaces
//
// Author:
//    Zeke Lucas (zekel)  10-April-96
//

// !!! Take NOTE: CUrlHistory *MUST* be thread safe! DANGER, WILL ROBINSON, DANGER!

#include "priv.h"
#include "sccls.h"
#include "ishcut.h"
#include <inetreg.h>
#include <varutil.h>
#include "iface.h"
#include "util.h"

#define DM_UHRETRIEVE   0
#define DM_URLCLEANUP   0
#define DM_HISTGENERATE 0
#define DM_HISTPROP     0
#define DM_HISTEXTRA    0
#define DM_HISTCOMMIT   0
#define DM_HISTSPLAT    0
#define DM_HISTMISS     0
#define DM_HISTNLS      0

#define DW_FOREVERLOW (0xFFFFFFFF)
#define DW_FOREVERHIGH (0x7FFFFFFF)

#ifdef UNICODE
    #define VT_LPTSTR    VT_LPWSTR
#else
    #define VT_LPTSTR    VT_LPSTR
#endif

inline UINT DW_ALIGNED(UINT i) {
    return ((i+3) & 0xfffffffc);
}

inline BOOL IS_DW_ALIGNED(UINT i) {
    return ((i & 3)==0);
}

// Old one (beta-2)
typedef struct _HISTDATAOLD
{
    WORD cbSize;
    DWORD dwFlags;
    WORD wTitleOffset;
    WORD aFragsOffset;
    WORD cFrags;            //right now the top five bits are used for Prop_MshtmlMCS
    WORD wPropNameOffset;    
    WORD wMCSIndex;
} HISTDATAOLD, *LPHISTDATAOLD;

// Forward reference
typedef struct HISTEXTRA* LPHISTEXTRA;

// Version 0.01
//
// PID_INTSITE_WHATSNEW         stored as a HISTEXTRA
// PID_INTSITE_AUTHOR           stored as a HISTEXTRA
// PID_INTSITE_LASTVISIT        from lpCEI->LastAccessTime
// PID_INTSITE_LASTMOD          from lpCEI->LastModifiedTime
// PID_INTSITE_VISITCOUNT       dwVisits
// PID_INTSITE_DESCRIPTION      stored as a HISTEXTRA
// PID_INTSITE_COMMENT          stored as a HISTEXTRA
// PID_INTSITE_FLAGS            dwFlags
// PID_INTSITE_CONTENTLEN       (never used)
// PID_INTSITE_CONTENTCODE      (never used)
// PID_INTSITE_RECURSE          (never used)
// PID_INTSITE_WATCH            dwWatch
// PID_INTSITE_SUBSCRIPTION     stored as a HISTEXTRA
// PID_INTSITE_URL              URL itself
// PID_INTSITE_TITLE            Title
// PID_INTSITE_FRAGMENT         Visited Fragment (private)
//

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// HACKHACK:  If you change this data structure, you must talk
//            to Adrian Canter (adrianc) -- we put a copy of it
//            in wininet\urlcache\401imprt.cxx to make importing
//            from old-style cache happen quick n' dirty
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
struct _HISTDATA_V001
{
    UINT  cbSize : 16;           // size of this header
    UINT  cbVer  : 16;           // version
    DWORD           dwFlags;    // PID_INTSITE_FLAGS (PIDISF_ flags)
    DWORD           dwWatch;    // PID_INTSITE_WATCH (PIDISM_ flags)
    DWORD           dwVisits;   // PID_INTSITE_VISITCOUNT
};

#define HISTDATA_VER    2

class CHistoryData : public _HISTDATA_V001
{
public:
    LPHISTEXTRA _GetExtra(void)  const {
        ASSERT( this->cbSize == sizeof(_HISTDATA_V001) );
        ASSERT( this->cbVer == HISTDATA_VER );
        return (LPHISTEXTRA)(((BYTE*)this) + this->cbSize);
    }

    const HISTEXTRA * _FindExtra(UINT idExtra) const;
    HISTEXTRA * _FindExtraForSave(UINT idExtra) {
        return (HISTEXTRA*)_FindExtra(idExtra);
    }
    void _GetTitle(LPTSTR szTitle, UINT cchMax) const;
    BOOL _HasFragment(LPCTSTR pszFragment) const;
    BOOL _IsOldHistory(void) const {
        return (cbSize==SIZEOF(HISTDATAOLD) && cbVer==0);
    };

    static CHistoryData* s_GetHistoryData(LPINTERNET_CACHE_ENTRY_INFO lpCEI);
    static CHistoryData* s_AllocateHeaderInfo(UINT cbExtra, const CHistoryData* phdPrev, ULONG* pcbTotal);

    HISTEXTRA* CopyExtra(HISTEXTRA* phextCur) const;
    UINT GetTotalExtraSize() const;
};


//
//  Right after HISTDATA (always at cbSize), we have optional (typically
// variable length) data which has following data structure. It may have
// more than one but always has a null-terimiator (cbExtra == 0).
//
struct HISTEXTRA
{
    UINT cbExtra : 16;
    UINT idExtra : 8;   // PID_INTSITE_*
    UINT vtExtra : 8;   // VT_*
    BYTE abExtra[1];    // abExtra[cbExtra-4];

    BOOL IsTerminator(void) const {
        return (this->cbExtra==0);
    }

    const HISTEXTRA* GetNextFast(void) const {
        ASSERT( ! IsTerminator() );
        return (LPHISTEXTRA)(((BYTE*)this) + this->cbExtra);
    }

    HISTEXTRA* GetNextFastForSave(void) const {
        ASSERT( ! IsTerminator() );
        return (LPHISTEXTRA)(((BYTE*)this) + this->cbExtra);
    }

    const HISTEXTRA* GetNext(void) const {
        if (this->cbExtra) {
            return (LPHISTEXTRA)(((BYTE*)this) + this->cbExtra);
        }
        return NULL;
    }
};


// We want to make sure that our history binary data is valid so
// we don't crash or something
BOOL ValidateHistoryData(LPINTERNET_CACHE_ENTRY_INFOA pcei)
{
    DWORD cb = 0;

    if (!pcei->lpHeaderInfo)
    {
        ASSERT(pcei->dwHeaderInfoSize==0);
        pcei->dwHeaderInfoSize = 0;
        return TRUE;
    }
    
    // First, let's check HISTDATA
    CHistoryData* phd = (CHistoryData*)pcei->lpHeaderInfo;
    if ((phd->cbSize!=sizeof(_HISTDATA_V001))
        ||
        (phd->cbSize > pcei->dwHeaderInfoSize))
    {
        pcei->dwHeaderInfoSize = 0;
        pcei->lpHeaderInfo = NULL;
        return FALSE;
    }

    cb += phd->cbSize;
    
    // Now, let's check HISTEXTRA
    LPHISTEXTRA phe = phd->_GetExtra();
    while (phe && !phe->IsTerminator())
    {
        cb += phe->cbExtra;
        if (cb >= pcei->dwHeaderInfoSize)
        {
            // Hmm. We're expecting more data than we got. Not good. Prune the rest off.
            // We're adding 1 for the terminator
            pcei->dwHeaderInfoSize = cb - phe->cbExtra + 4;
            phe->cbExtra = 0;
            return FALSE;
        }
        phe = phe->GetNextFastForSave();
    }

    // Add a DWORD for the terminator
    cb += sizeof(DWORD);
    // ASSERT(pcei->dwHeaderInfoSize==cb);
    return TRUE;    
}

//
//  Typically, we need 200-300 bytes to retrieve a cached entry in this
// history database. To avoid allocating memory in 99% of cases, we
// allocate 500 bytes in the stack and call LocalAlloc only if we need
// more than that. 
//
#define DEFAULT_CEI_BUFFER_SIZE         (500 * sizeof(WCHAR))

const TCHAR c_szHistoryPrefix[] = TEXT("Visited: ");

struct CEI_PREALLOC {
    LPINTERNET_CACHE_ENTRY_INFO pcei;

    LPCTSTR pszFragment;
    TCHAR szPrefixedUrl[MAX_URL_STRING + ARRAYSIZE(c_szHistoryPrefix)];

    union {
#ifdef UNIX
        double alignOn8ByteBoundary;
#endif /* UNIX */
        INTERNET_CACHE_ENTRY_INFO cei;
        BYTE ab[DEFAULT_CEI_BUFFER_SIZE];
    };

    CEI_PREALLOC() : pcei(NULL), pszFragment(NULL) {}
    ~CEI_PREALLOC() {
        if (pcei && pcei != &cei) {
            TraceMsg(DM_TRACE, "CEI_PREALLOC::dtr freeing pcei");
            LocalFree(pcei);
            pcei = NULL;
        }
    }
};

#define VER_HISTDATA    1

typedef CHistoryData HISTDATA;

typedef HISTDATA* LPHISTDATA;

//  CUrlHistory manages the other interfaces and handles alot of the basic functions
class   CUrlHistory : public IUrlHistoryPriv
{
public:
    CUrlHistory (void);
    ~CUrlHistory(void);

    // IUnknown methods

    virtual STDMETHODIMP  QueryInterface(REFIID riid, PVOID *ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // IUrlHistoryStg methods
    STDMETHODIMP AddUrl(LPCWSTR pwszUrl, LPCWSTR pwszTitle, DWORD dwFlags);
    STDMETHODIMP DeleteUrl(LPCWSTR pwszUrl, DWORD dwFlags);
    STDMETHODIMP QueryUrl(LPCWSTR pwszUrl, DWORD dwFlags, LPSTATURL lpSTATURL);
    STDMETHODIMP BindToObject(LPCWSTR pwszUrl, REFIID riid, void **ppvOut);
    STDMETHODIMP EnumUrls(IEnumSTATURL **ppEnum);

    // IUrlHistoryStg2 methods
    STDMETHODIMP AddUrlAndNotify(LPCWSTR pwszUrl, LPCWSTR pwszTitle, DWORD dwFlags, BOOL fWriteHistory, IOleCommandTarget *poctNotify, IUnknown *punkSFHistory);
    STDMETHODIMP ClearHistory();

    // IUrlHistoryPriv methods
    STDMETHOD(QueryUrlA)(LPCSTR pszUrl, DWORD dwFlags, LPSTATURL lpSTATURL);
    STDMETHOD(CleanupHistory)(void);
    STDMETHOD_(DWORD,GetDaysToKeep)(void) { return s_GetDaysToKeep(); }
    STDMETHOD(GetProperty)(LPCTSTR pszUrl, PROPID pid, PROPVARIANT* pvarOut);
    STDMETHOD(GetUserName)(LPTSTR pszUserName, DWORD cchUserName);
    STDMETHOD(AddUrlAndNotifyCP)(LPCWSTR pwszUrl, LPCWSTR pwszTitle, DWORD dwFlags, BOOL fWriteHistory, IOleCommandTarget *poctNotify, IUnknown *punkSFHistory, UINT* pcodepage);

   
    static void  s_Init();
    static DWORD   s_GetDaysToKeep(void);
#if defined(ux10) && defined(UNIX)
    static void s_SetDaysToKeep(DWORD dwDays);
#endif


protected:

    void _WriteToHistory(LPCTSTR pszPrefixedurl,
                         FILETIME& ftExpires,
                         IOleCommandTarget *poctNotify,
                         IUnknown *punkSFHistory);

    friend class CEnumSTATURL;
    // friend class CUrlHObj;
    friend class IntsiteProp;

    static HRESULT s_CleanupHistory(void);
    static HRESULT s_EnumUrls(IEnumSTATURL **ppEnum);
    static HRESULT s_DeleteUrl(LPCWSTR pwszUrl, DWORD dwFlags);
    
    static void s_ConvertToPrefixedUrlW(  
                                IN LPCWSTR pwszUrl,
                                OUT LPTSTR pszPrefixedUrl,
                                IN DWORD cchPrefixedUrl, 
                                OUT LPCTSTR *ppszFragment
                              );

    static HRESULT s_QueryUrlCommon(
                          LPCTSTR lpszPrefixedUrl,
                          LPCTSTR lpszFragment,
                          DWORD dwFlags,
                          LPSTATURL lpSTATURL
                          );

    static void s_RetrievePrefixedUrlInfo(
                LPCTSTR lpszUrl, CEI_PREALLOC* pbuf);
    static BOOL s_CommitUrlCacheEntry(LPCTSTR pszPrefixedUrl, 
                        LPINTERNET_CACHE_ENTRY_INFO pcei);

    static BOOL s_IsCached(IN LPCTSTR pszUrl)
        { return ::GetUrlCacheEntryInfoEx(pszUrl, NULL, NULL, NULL, NULL, NULL, INTERNET_CACHE_FLAG_ALLOW_COLLISIONS); }

    static HISTDATA* s_GenerateHeaderInfo(
            IN LPCTSTR pszTitle, 
            IN HISTDATA* phdPrev,
            IN LPCTSTR pszFragment,
            OUT LPDWORD pcbHeader
            );

    static HRESULT s_GenerateSTATURL(IN PCTSTR pszUrl, IN LPINTERNET_CACHE_ENTRY_INFO lpCEI, IN DWORD dwFlags, OUT LPSTATURL lpsu);
    static void s_UpdateIcon(Intshcut* pintshcut, DWORD dwFlags);

    DWORD   _cRef;
    static TCHAR   s_szUserPrefix[INTERNET_MAX_USER_NAME_LENGTH + 1];
    static DWORD   s_cchUserPrefix ;
    static DWORD   s_dwDaysToKeep;
    
};


class CEnumSTATURL      : public IEnumSTATURL
{
public:

    CEnumSTATURL() : _cRef(1) {}
    ~CEnumSTATURL();

    // IUnknown methods

    STDMETHODIMP  QueryInterface(REFIID riid, PVOID *ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //  IEnumXXXX methods

    STDMETHODIMP Next (ULONG celt, LPSTATURL rgelt, ULONG * pceltFetched) ;
    STDMETHODIMP Skip(ULONG celt) ;
    STDMETHODIMP Reset(void) ;
    STDMETHODIMP Clone(IEnumSTATURL ** ppenum) ;

    //  IEnumSTATURL methods

    STDMETHODIMP SetFilter(LPCWSTR poszFilter, DWORD dwFlags) ;

private:

    HRESULT RetrieveFirstUrlInfo(void);
    HRESULT RetrieveNextUrlInfo(void);

    DWORD _cRef;

    //  search object parameters
    LPWSTR m_poszFilter;
    DWORD  m_dwFilter;

    HANDLE m_hEnum;
    TCHAR _szPrefixedUrl[MAX_URL_STRING];
    DWORD m_cchPrefixedUrl;
    LPCTSTR m_lpszFragment;
    LPINTERNET_CACHE_ENTRY_INFO m_lpCEI;
    DWORD m_cbCEI;

};


#if defined(ux10) && defined(UNIX)
//Work around for mmap limitation in hp-ux10. Change the corresponding
//value even in inetcpl/general.cpp
#define MAX_HISTORY_DAYS        30
#endif

#define FILETIME_SEC                            10000000
#define SECS_PER_DAY                            (60 * 60 * 24)

#define CCHHISTORYPREFIX (ARRAYSIZE(c_szHistoryPrefix) - 1)
#define CLEANUP_HISTORY_INTERVAL (24 * 60 * 60 * 1000) // One day, in milliseconds

DWORD g_tCleanupHistory = 0;


#define OFFSET_TO_LPTSTR(p, o)          ( (LPTSTR) ( (LPBYTE) (p) + (o) ) )
#define OFFSET_TO_LPBYTE(p, o)          ( (LPBYTE) ( (LPBYTE) (p) + (o) ) )
#define OFFSET_TO_LPWORD(p, o)          ( (LPWORD) ( (LPBYTE) (p) + (o) ) )

#define LPTSTR_TO_OFFSET(p, s)          ( (WORD) ( (LPTSTR) (s) - (LPTSTR) (p) ) )
#define LPBYTE_TO_OFFSET(p, b)          ( (WORD) ( (LPBYTE) (b) - (LPBYTE) (p) ) )

// NOTE: REARCHITECT chrisfra 3/26/97 , ext\cachevu\priv.h has a duplicate copy of this
// structure and uses it to access cache.  this needs to be covered by procedural or
// object interface and moved to a common location.

// This structure uses the flags bits as follows: if HFL_VERSIONED is true, then
// the rest of the flags word is the version.

#define HFL_VERSIONED (0x80000000)


//
// We store binary data in the lpHeaderInfo field.  CommitUrlCacheEntryW tries
// to convert this data to ansi and messes it up.  To get around this we thunk
// through to the A version CommitUrlCacheEntry.
//

BOOL
CommitUrlCacheEntryBinary(
    IN LPCWSTR  lpszUrlName,
    IN FILETIME ExpireTime,
    IN FILETIME LastModifiedTime,
    IN DWORD CacheEntryType,
    IN LPBYTE lpHeaderInfo,
    IN DWORD dwHeaderSize
)
{
    ASSERT(lpszUrlName);

    CHAR szUrl[MAX_URL_STRING + ARRAYSIZE(c_szHistoryPrefix)];

    SHUnicodeToAnsi(lpszUrlName, szUrl, ARRAYSIZE(szUrl));

    INTERNET_CACHE_ENTRY_INFOA cei;
    cei.lpHeaderInfo = (LPSTR)lpHeaderInfo;
    cei.dwHeaderInfoSize = dwHeaderSize;
    ValidateHistoryData(&cei);

    return CommitUrlCacheEntryA(szUrl, NULL, ExpireTime, LastModifiedTime,
                                CacheEntryType, lpHeaderInfo, dwHeaderSize,
                                NULL, NULL);
}

GetUrlCacheEntryInfoBinary(
    IN LPCWSTR lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize
    )
{
    ASSERT(lpszUrlName);

    BOOL fRet;

    CHAR szUrl[MAX_URL_STRING + ARRAYSIZE(c_szHistoryPrefix)];

    SHUnicodeToAnsi(lpszUrlName, szUrl, ARRAYSIZE(szUrl));

    //
    // Warning!  This doesn't convert any of thge string parameters in
    // lpCacheEntryInfo back to unicode.  History only uses
    // lpCacheEntryInfo->lpHeaderInfo so this isn't a problem.
    //

    fRet =  GetUrlCacheEntryInfoA(szUrl,
                                 (LPINTERNET_CACHE_ENTRY_INFOA)lpCacheEntryInfo,
                                 lpdwCacheEntryInfoBufferSize);

    //
    // Set unused out paramters to NULL incase someone tries to use them
    //

    lpCacheEntryInfo->lpszSourceUrlName = NULL;
    lpCacheEntryInfo->lpszLocalFileName = NULL;
    lpCacheEntryInfo->lpszFileExtension = NULL;

    if (fRet)
    {
        ValidateHistoryData((LPINTERNET_CACHE_ENTRY_INFOA)lpCacheEntryInfo);
    }
    return fRet;
}

//
// Warning!  This function converts cei structures for use by history.  It is
// not a generic conversion.  It converts the minimum data required by history.
//
int
CacheEntryInfoAToCacheEntryInfoW(
    LPINTERNET_CACHE_ENTRY_INFOA pceiA,
    LPINTERNET_CACHE_ENTRY_INFOW pceiW,
    int cbceiW
    )
{
    int nRet;

    ASSERT(pceiA->lpszSourceUrlName);
    int cchSourceUrlName = lstrlenA(pceiA->lpszSourceUrlName) + 1;

    int cbRequired = sizeof(INTERNET_CACHE_ENTRY_INFOA) +
                     pceiA->dwHeaderInfoSize + 
                     cchSourceUrlName * sizeof(WCHAR);

    if (cbRequired <= cbceiW)
    {
        ASSERT(sizeof(*pceiA) == sizeof(*pceiW));

        // Copy the structure.
        *pceiW = *(INTERNET_CACHE_ENTRY_INFOW*)pceiA;

        // Append the binary data.  Note dwHeaderInfoSize is already copied.
        pceiW->lpHeaderInfo = (LPWSTR)(pceiW + 1);
        memcpy(pceiW->lpHeaderInfo, pceiA->lpHeaderInfo, pceiA->dwHeaderInfoSize);

        // Append the source url name.
        pceiW->lpszSourceUrlName = (LPWSTR)((BYTE*)(pceiW + 1) + pceiW->dwHeaderInfoSize);
        SHAnsiToUnicode(pceiA->lpszSourceUrlName, pceiW->lpszSourceUrlName,
                        cchSourceUrlName);

        // Null out bogus pointers so we'll fault if someone deref's them
        pceiW->lpszLocalFileName = NULL;
        pceiW->lpszFileExtension = NULL;

        nRet = 0;
    }
    else
    {
        nRet = cbRequired;
    }

    return nRet;
}

HANDLE
FindFirstUrlCacheEntryBinary(
    IN LPCWSTR lpszUrlSearchPattern,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpFirstCacheEntryInfo,
    IN OUT LPDWORD lpdwFirstCacheEntryInfoBufferSize
    )
{
    ASSERT(NULL != lpszUrlSearchPattern);
    ASSERT(NULL != lpFirstCacheEntryInfo);
    ASSERT(NULL != lpdwFirstCacheEntryInfoBufferSize);

    HANDLE hRet;

    CHAR szPattern[MAX_PATH];

    ASSERT(lstrlenW(lpszUrlSearchPattern) < ARRAYSIZE(szPattern));
    SHUnicodeToAnsi(lpszUrlSearchPattern, szPattern, ARRAYSIZE(szPattern));

    BYTE ab[MAX_CACHE_ENTRY_INFO_SIZE];
    INTERNET_CACHE_ENTRY_INFOA* pceiA = (INTERNET_CACHE_ENTRY_INFOA*)ab;
    DWORD dwSize;
    BOOL fAllocated = FALSE;

    pceiA->dwStructSize = dwSize = sizeof(ab);

    hRet = FindFirstUrlCacheEntryA(szPattern, pceiA, &dwSize);

    if (NULL == hRet && GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    {
        pceiA = (INTERNET_CACHE_ENTRY_INFOA*)LocalAlloc(LPTR, dwSize);

        if (pceiA)
        {
            fAllocated = TRUE;

            pceiA->dwStructSize = dwSize;

            hRet = FindFirstUrlCacheEntryA(szPattern, pceiA, &dwSize);
            
            ASSERT(hRet || GetLastError() != ERROR_INSUFFICIENT_BUFFER);
        }
        else
        {
            SetLastError(ERROR_OUTOFMEMORY);
        }
    }
    
    if (hRet)
    {
        int nRet;

        ValidateHistoryData(pceiA);
        nRet = CacheEntryInfoAToCacheEntryInfoW(pceiA, lpFirstCacheEntryInfo,
                                                *lpdwFirstCacheEntryInfoBufferSize);

        if (nRet)
        {
            FindCloseUrlCache(hRet);
            hRet = NULL;
            *lpdwFirstCacheEntryInfoBufferSize = nRet;
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }
    }

    if (fAllocated)
    {
        LocalFree(pceiA);
        pceiA = NULL;
    }

    return hRet;
}

BOOL
FindNextUrlCacheEntryBinary(
    IN HANDLE hEnumHandle,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpNextCacheEntryInfo,
    IN OUT LPDWORD lpdwNextCacheEntryInfoBufferSize
    )
{
    ASSERT(NULL != hEnumHandle);
    ASSERT(NULL != lpNextCacheEntryInfo);
    ASSERT(NULL != lpdwNextCacheEntryInfoBufferSize);

    BOOL fRet;

    BYTE ab[MAX_CACHE_ENTRY_INFO_SIZE];
    INTERNET_CACHE_ENTRY_INFOA* pceiA = (INTERNET_CACHE_ENTRY_INFOA*)ab;
    DWORD dwSize;
    BOOL fAllocated = FALSE;

    pceiA->dwStructSize = dwSize = sizeof(ab);

    fRet = FindNextUrlCacheEntryA(hEnumHandle, pceiA, &dwSize);
    
    if (!fRet && GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    {
        pceiA = (INTERNET_CACHE_ENTRY_INFOA*)LocalAlloc(LPTR, dwSize);

        if (pceiA)
        {
            fAllocated = TRUE;

            pceiA->dwStructSize = dwSize;

            fRet = FindNextUrlCacheEntryA(hEnumHandle, pceiA, &dwSize);
            
            ASSERT(fRet || GetLastError() != ERROR_INSUFFICIENT_BUFFER);
        }
        else
        {
            SetLastError(ERROR_OUTOFMEMORY);
        }
    }

    if (fRet)
    {
        int nRet;

        ValidateHistoryData(pceiA);
        nRet = CacheEntryInfoAToCacheEntryInfoW(pceiA, lpNextCacheEntryInfo,
                                                *lpdwNextCacheEntryInfoBufferSize);

        if (nRet)
        {
            fRet = FALSE;
            *lpdwNextCacheEntryInfoBufferSize = nRet;
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }
    }

    if (fAllocated)
    {
        LocalFree(pceiA);
        pceiA = NULL;
    }
  
    return fRet;
}

#define DEFAULT_DAYS_TO_KEEP    21
static const TCHAR c_szRegValDaysToKeep[] = TEXT("DaysToKeep");
static const TCHAR c_szRegValDirectory[] = TEXT("Directory");

#ifdef UNIX
#define DIR_SEPARATOR_CHAR  TEXT('/')
#else
#define DIR_SEPARATOR_CHAR  TEXT('\\')
#endif


// ** this has been moved to util.cpp 07.28.2000 **
// thunk to shell32.SHGetFolderPath() so this code works downlevel
// HRESULT SHGetFolderPath(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPTSTR pszPath)
// ** this has been moved to util.cpp 07.28.2000 **

HRESULT SHGetHistoryPIDL(LPITEMIDLIST *ppidlHistory)
{
    *ppidlHistory = NULL;

    TCHAR szHistory[MAX_PATH];

    szHistory[0] = 0;

    HRESULT hres = SHGetFolderPathD(NULL, CSIDL_HISTORY | CSIDL_FLAG_CREATE, NULL, 0, szHistory);
    if (hres != S_OK)
    {
        GetHistoryFolderPath(szHistory, ARRAYSIZE(szHistory));
        PathRemoveFileSpec(szHistory);  // get the trailing slash
        PathRemoveFileSpec(szHistory);  // trim the "content.ie5" junk
    }

    if (szHistory[0])
    {
        TCHAR szIniFile[MAX_PATH];
        PathCombine(szIniFile, szHistory, TEXT("desktop.ini"));

        if (GetFileAttributes(szIniFile) == -1)
        {
            DWORD dwAttrib = GetFileAttributes(szHistory);
            dwAttrib &= ~FILE_ATTRIBUTE_HIDDEN;
            dwAttrib |=  FILE_ATTRIBUTE_SYSTEM;

            // make sure system, but not hidden
            SetFileAttributes(szHistory, dwAttrib);

            WritePrivateProfileString(TEXT(".ShellClassInfo"), TEXT("ConfirmFileOp"), TEXT("0"), szIniFile);
            WritePrivateProfileString(TEXT(".ShellClassInfo"), TEXT("CLSID"), TEXT("{FF393560-C2A7-11CF-BFF4-444553540000}"), szIniFile);
        }

        IShellFolder *psfDesktop;
        hres = SHGetDesktopFolder(&psfDesktop);
        if (SUCCEEDED(hres)) 
        {
            hres = psfDesktop->ParseDisplayName(NULL, NULL, 
                                    szHistory, NULL, ppidlHistory, NULL); 
            psfDesktop->Release();
        }
    }
    else
        hres = E_FAIL;
    return hres;
}

//
// This function is called from hist/hsfolder.cpp
//
HRESULT CUrlHistory::GetUserName(LPTSTR pszUserName, DWORD cchUserName)
{
    s_Init();
    
    if (cchUserName < s_cchUserPrefix)
    {
        return E_FAIL;
    }
    CopyMemory(pszUserName, s_szUserPrefix, (s_cchUserPrefix-1) * sizeof(TCHAR));
    pszUserName[s_cchUserPrefix-1] = 0;
    return S_OK;
}

#if defined (ux10) && defined(UNIX)
void CUrlHistory::s_SetDaysToKeep(DWORD dwDays)
{
    HKEY hk;
    DWORD dwDisp;

    DWORD Error = RegCreateKeyEx(
                                 HKEY_CURRENT_USER,
                                 REGSTR_PATH_URLHISTORY,
                                 0, NULL, 0,
                                 KEY_WRITE,
                                 NULL,
                                 &hk,
                                 &dwDisp);

    if(ERROR_SUCCESS != Error)
    {
        ASSERT(FALSE);
        return;
    }

    Error = RegSetValueEx(
                          hk,
                          c_szRegValDaysToKeep,
                          0,
                          REG_DWORD,
                          (LPBYTE) &dwDays,
                          sizeof(dwDays));

    ASSERT(ERROR_SUCCESS == Error);

    RegCloseKey(hk);

    return;

}
#endif

//
// This function is called from hist/hsfolder.cpp
//
DWORD CUrlHistory::s_GetDaysToKeep(void)
{
    HKEY hk;
    DWORD cbDays = SIZEOF(DWORD);
    DWORD dwDays = DEFAULT_DAYS_TO_KEEP;
    DWORD dwType;


    DWORD Error = RegOpenKeyEx(
                               HKEY_CURRENT_USER,
                               REGSTR_PATH_URLHISTORY,
                               0,
                               KEY_READ,
                               &hk);


    if(Error)
    {
        Error = RegOpenKeyEx(
                             HKEY_LOCAL_MACHINE,
                             REGSTR_PATH_URLHISTORY,
                             0,
                             KEY_READ,
                             &hk);
    }


    if(!Error)
    {
        Error = RegQueryValueEx(
                                hk,
                                c_szRegValDaysToKeep,
                                0,
                                &dwType,
                                (LPBYTE) &dwDays,
                                &cbDays);

        RegCloseKey(hk);
    }

    return dwDays;
}

IUrlHistoryPriv* g_puhUrlHistory = NULL;

void CUrlHistory_CleanUp()
{
    // Release will clean up the global
    ENTERCRITICAL;
    if (g_puhUrlHistory)
        g_puhUrlHistory->Release();
    LEAVECRITICAL;
}

STDAPI CUrlHistory_CreateInstance(IUnknown* pUnkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    HRESULT hr = E_OUTOFMEMORY;

    *ppunk = NULL;

    // !!! Take NOTE: CUrlHistory *MUST* be thread safe!

    // aggregation checking is handled in class factory
    ENTERCRITICAL;
    
    if (!g_puhUrlHistory) 
    {
        CUrlHistory *pcuh = new CUrlHistory;
        if (pcuh) 
        {
            g_puhUrlHistory = SAFECAST(pcuh, IUrlHistoryPriv *);
            // The memory tracking code thinks this is a leak
        }
    }

    if (g_puhUrlHistory)
    {
        *ppunk = SAFECAST(g_puhUrlHistory, IUnknown*);
        g_puhUrlHistory->AddRef();
        hr = S_OK;
    }

    LEAVECRITICAL;

    return hr;
}





//
//  Public members of CUrlHistory
//

CUrlHistory::CUrlHistory(void) : _cRef(1)
{
    //
    // Update s_dwDaysToKeep for each call
    //
    s_dwDaysToKeep = s_GetDaysToKeep();
    
#if defined(ux10) && defined(UNIX)
//Work around for mmap limitation in hp-ux10
    if (s_dwDaysToKeep > MAX_HISTORY_DAYS)
    {
       s_dwDaysToKeep = MAX_HISTORY_DAYS;
       s_SetDaysToKeep(s_dwDaysToKeep);
    }
#endif

#ifdef DEBUG
    if (g_dwPrototype & 0x00000020) {
        s_CleanupHistory();
    }
#endif

    DllAddRef();
}

CUrlHistory::~CUrlHistory(void)
{
    DllRelease();
}

HRESULT LoadHistoryShellFolder(IUnknown *punk, IHistSFPrivate **ppsfpHistory)
{
    HRESULT hr;

    *ppsfpHistory = NULL;
    if (punk)
    {
        hr = punk->QueryInterface(IID_IHistSFPrivate, (void **)ppsfpHistory);
    }
    else
    {
        LPITEMIDLIST pidlHistory;

        hr = SHGetHistoryPIDL(&pidlHistory);
        if (SUCCEEDED(hr))
        {
            hr = SHBindToObject(NULL, IID_IHistSFPrivate, pidlHistory, (void **)ppsfpHistory);
            ILFree(pidlHistory);
        }
    }
    return hr;
}

//  ClearHistory on a per user basis.  moved from inetcpl to facilitate changes in
//  implementation.
HRESULT CUrlHistory::ClearHistory()
{
    HRESULT hr;
    IEnumSTATURL *penum;
    IHistSFPrivate *psfpHistory = NULL;

    hr = THR(EnumUrls(&penum));

    if (SUCCEEDED(hr))
    {
        penum->SetFilter(NULL, STATURL_QUERYFLAG_NOTITLE);

        ULONG cFetched;
        STATURL rsu[1] = {{sizeof(STATURL), NULL, NULL}};
        while (SUCCEEDED(penum->Next(1, rsu, &cFetched)) && cFetched)
        {
            ASSERT(rsu[0].pwcsUrl);

            hr = THR(DeleteUrl(rsu[0].pwcsUrl, URLFLAG_DONT_DELETE_SUBSCRIBED));

            OleFree(rsu[0].pwcsUrl);
            rsu[0].pwcsUrl = NULL;

            ASSERT(!rsu[0].pwcsTitle);
        }
        penum->Release();
    }
    hr = LoadHistoryShellFolder(NULL, &psfpHistory);
    if (SUCCEEDED(hr))
    {
        hr = psfpHistory->ClearHistory();
        psfpHistory->Release();
    }
    return hr;
}

extern void _FileTimeDeltaDays(FILETIME *pftBase, FILETIME *pftNew, int Days);

HRESULT CUrlHistory::s_CleanupHistory(void)
{
    TraceMsg(DM_URLCLEANUP, "CUH::s_CleanupHistory called");

    HRESULT hr;
    DWORD tCurrent = GetTickCount();

    if (!g_tCleanupHistory || (tCurrent > g_tCleanupHistory + CLEANUP_HISTORY_INTERVAL)) {
        g_tCleanupHistory = tCurrent;
    } else {
#ifdef DEBUG
        if (!(g_dwPrototype & 0x00000020))
#endif
        return S_OK;
    }

    SYSTEMTIME st;
    FILETIME ftNow;
    FILETIME ftOldest;
    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ftNow);
    _FileTimeDeltaDays(&ftNow, &ftOldest, -((int)s_GetDaysToKeep()));

    IEnumSTATURL * penum = NULL;
    if (SUCCEEDED(s_EnumUrls(&penum)))
    {
        STATURL rsu[1] = {{sizeof(STATURL), NULL, NULL}};
        ULONG cFetched = 0;

        penum->SetFilter(NULL, STATURL_QUERYFLAG_NOTITLE);

        while (S_OK == penum->Next(1, rsu, &cFetched))
        {
            ASSERT(cFetched);
            ASSERT(rsu[0].pwcsUrl);
            ASSERT(rsu[0].pwcsTitle==NULL);

#ifdef DEBUG
            TCHAR szUrl[MAX_URL_STRING];
            SHUnicodeToTChar(rsu[0].pwcsUrl, szUrl, ARRAYSIZE(szUrl));
#endif
            // check to see if expires is not special && ftLastUpdated is earlier
            // than we need
            if (CompareFileTime(&(rsu[0].ftLastUpdated), &ftOldest) < 0 &&
                (rsu[0].ftExpires.dwLowDateTime != DW_FOREVERLOW ||
                 rsu[0].ftExpires.dwHighDateTime != DW_FOREVERHIGH))
            {
                hr = THR(s_DeleteUrl(rsu[0].pwcsUrl, 0));
#ifdef DEBUG
                TraceMsg(DM_URLCLEANUP, "CUH::s_Cleanup deleting %s", szUrl);
#endif
            } else {
#ifdef DEBUG
                TraceMsg(DM_URLCLEANUP, "CUH::s_Cleanup keeping  %s", szUrl);
#endif
            }

            CoTaskMemFree(rsu[0].pwcsUrl);
            rsu[0].pwcsUrl = NULL;
            cFetched = 0;
            
            ASSERT(!rsu[0].pwcsTitle);
        }

        penum->Release();
    }
    else 
        ASSERT(FALSE);

    TraceMsg(DM_URLCLEANUP, "CUH::s_CleanupHistory (expensive!) just called");
    return S_OK;
}

HRESULT CUrlHistory::CleanupHistory()
{
    return CUrlHistory::s_CleanupHistory();
}


TCHAR CUrlHistory::s_szUserPrefix[INTERNET_MAX_USER_NAME_LENGTH + 1] = TEXT("");
DWORD CUrlHistory::s_cchUserPrefix = 0;
DWORD CUrlHistory::s_dwDaysToKeep = 0;


void CUrlHistory::s_Init(void)
{
    // Cache the user name only once per process
    if (!s_cchUserPrefix)
    {
        ENTERCRITICAL;
        // Maybe it changed since entering the crit sec.
        // This really happened to me (BryanSt)
        // We do it twice for perf reasons.
        if (!s_cchUserPrefix)
        {
            ASSERT(s_szUserPrefix[0] == '\0');
            s_cchUserPrefix = ARRAYSIZE(s_szUserPrefix);

            //  Get the current user or set to default
            ::GetUserName(s_szUserPrefix, &s_cchUserPrefix);

            StrCatBuff(s_szUserPrefix, TEXT("@"), ARRAYSIZE(s_szUserPrefix));
            s_cchUserPrefix = lstrlen(s_szUserPrefix);
        }

        LEAVECRITICAL;
    }

}


HRESULT CUrlHistory::QueryInterface(REFIID riid, PVOID *ppvObj)
{
    HRESULT hr = E_NOINTERFACE;


    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || 
        IsEqualIID(riid, IID_IUrlHistoryStg2) ||
        IsEqualIID(riid, IID_IUrlHistoryPriv) ||
         IsEqualIID(riid, IID_IUrlHistoryStg))
    {
        AddRef();
        *ppvObj = (LPVOID) SAFECAST(this, IUrlHistoryPriv *);
        hr = S_OK;

    }
    else if (IsEqualIID(riid, CLSID_CUrlHistory))
    {
        AddRef();
        *ppvObj = (LPVOID) this;
        hr = S_OK;
    }
    return hr;
}


ULONG CUrlHistory::AddRef(void)
{
    _cRef++;

    return _cRef;
}

ULONG CUrlHistory::Release(void)
{
    ASSERT(_cRef > 0);

    _cRef--;

    if (!_cRef)
    {
        //time to go bye bye
        ENTERCRITICAL;
        g_puhUrlHistory = NULL;
        LEAVECRITICAL;
        delete this;
        return 0;
    }

    return _cRef;
}

//
// Converts a normal URL to a URL with the correct cache prefix.     
// it also finds a fragment (local Anchor) if it exists in the URL.  
//                                                                   
// if the URL is invalid, then the returned lplpszPrefixedUrl is just
// the prefix.  this is used primarily for doing enumeration.        
//
void CUrlHistory::s_ConvertToPrefixedUrlW(
                                       IN LPCWSTR pszUrl,
                                       OUT LPTSTR pszPrefixedUrl,
                                       IN DWORD cchPrefixedUrl,
                                       OUT LPCTSTR *ppszFragment
                                       )
{
    //
    // Make it sure that s_cchUserPrefix is initialized.
    //
    s_Init();

    //  Prefix + UserPrefix + '@'

    ASSERT(pszPrefixedUrl && ppszFragment);

    //  clear the out params
    pszPrefixedUrl[0] = L'\0';
    *ppszFragment = NULL;


    //  if there is no URL, send back a default case
    //  this is just for EnumObjects
    if (!pszUrl || !*pszUrl)
    {
        wnsprintf(pszPrefixedUrl, cchPrefixedUrl, L"%s%s", c_szHistoryPrefix, s_szUserPrefix);
    }
    else
    {
        int slen;
        int nScheme;
        LPWSTR pszFragment;

        wnsprintf(pszPrefixedUrl, cchPrefixedUrl, L"%s%s", c_szHistoryPrefix, s_szUserPrefix);
        slen = lstrlen(pszPrefixedUrl);
        StrCpyN(pszPrefixedUrl + slen, pszUrl, MAX_URL_STRING-slen);

        // Only strip the anchor fragment if it's not JAVASCRIPT: or VBSCRIPT:, because a # could not an
        // anchor but a string to be evaluated by a script engine like #00ff00 for an RGB color.
        nScheme = GetUrlSchemeW(pszPrefixedUrl);      
        if (nScheme == URL_SCHEME_JAVASCRIPT || nScheme == URL_SCHEME_VBSCRIPT)
        {
            pszFragment = NULL;
        }
        else
        {
            //  locate local anchor fragment if possible
            pszFragment = StrChr(pszPrefixedUrl + slen, L'#');  // a-naghej Added " + slen" to fix WinSe bug# 13822 & 13926
        }

        if(pszFragment)     
        {
            //  kill the '#' so that lpszPrefixedUrl is isolated
            *pszFragment = L'\0';
            *ppszFragment = pszFragment+1;
        }

        //  check for trailing slash and eliminate
        LPWSTR pszT = CharPrev(pszPrefixedUrl, pszPrefixedUrl + lstrlen(pszPrefixedUrl));
        if (pszT[0] == L'/') {
            TraceMsg(DM_HISTNLS, "CUH::s_Convert removing the trailing slash of %s", pszPrefixedUrl);
            ASSERT(lstrlen(pszT)==1);
            pszT[0] = L'\0';
        }
    }
}


//
// Basically a wrapper function for RetreiveUrlCacheEntryInfo 
// meant to be called with the prefixed Url.                  
// it handles allocating the buffer and reallocating if necessary.
//
void CUrlHistory::s_RetrievePrefixedUrlInfo(
        LPCTSTR pszUrl, CEI_PREALLOC* pbuf)
{
    TraceMsg(DM_UHRETRIEVE, "CURLHistory::s_RetrievePrefixUrlInfo called (%s)", pszUrl);

    s_Init();

    DWORD cbCEI = SIZEOF(pbuf->ab);
    pbuf->pcei = &pbuf->cei;

    BOOL fSuccess = GetUrlCacheEntryInfoBinary(pszUrl, pbuf->pcei, &cbCEI);

    if (!fSuccess) {
        pbuf->pcei = NULL;
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
            TraceMsg(DM_TRACE, "CUH::s_RetrievePUI not enough buffer. Allocate! (%d)", cbCEI);
            pbuf->pcei = (LPINTERNET_CACHE_ENTRY_INFO)LocalAlloc(LPTR, cbCEI);
            if (pbuf->pcei) {
                fSuccess = GetUrlCacheEntryInfoBinary(pszUrl, pbuf->pcei, &cbCEI);
                if (!fSuccess) {
                    TraceMsg(DM_HISTMISS, "CUH::s_Retrieve (%s) failed %x (on second attempt)",
                             pszUrl, GetLastError());
                    LocalFree(pbuf->pcei);
                    pbuf->pcei = NULL;
                    SetLastError(ERROR_FILE_NOT_FOUND);
                } 
            }
        } else {
            TraceMsg(DM_HISTMISS, "CUH::s_Retrieve (%s) failed %x (on first attempt)",
                     pszUrl, GetLastError());
            SetLastError(ERROR_FILE_NOT_FOUND);
        }
    }
}

//
// Return the total of a double-null terminated string (including the
// terminating null).
//
UINT lstrzlen(LPCTSTR pszz)
{
    for (LPCTSTR psz=pszz; *psz; psz += lstrlen(psz) + 1) ;
    return (unsigned int)(psz+1-pszz);
}


    /*++

     Routine Description:

     this creates a buffer that holds a HISTDATA, and everything the HISTDATAs offsets
     point to.  it only sets those offsets that are passed in.

     Arguments:

     lpszTitle          Title to place in the buffer

     lpBase                     this is the base of the offsets in aFrags

     aFrags                     an array of offsets to the fragments to place in the buffer

     cFrags                     number of fragments in aFrags

     lpszNewFrag                this is an additional fragment to add in the new buffer

     pcbHeader                  this is a pointer to the final size of the buffer returned

     NOTE: any of the arguments except pcbHeader may be NULL.
     if lpBase is NULL, then aFrags must also be NULL. this is CALLERs responsibility!
     if a parameter is NULL, then it just isnt added to the buffer.

     Return Value:

     POINTER
     Success - a valid pointer to a buffer that must be freed.

     Failure - NULL. this only fails with ERROR_NOT_ENOUGH_MEMORY

     NOTE:  Caller must free the returned pointer.  *pcbHeader only set upon successful return.

     --*/

HISTDATA* CUrlHistory::s_GenerateHeaderInfo(
                                  IN LPCTSTR pszTitle,
                                  IN HISTDATA* phdPrev,         
                                  IN LPCTSTR pszFragment,
                                  OUT LPDWORD pcbHeader
                                  )
{
    DWORD cbHeader = 0;
    UINT cbHistExtra = 0;
    HISTEXTRA* phextPrev;

    // Get the size for title
    UINT cchTitle = 0;
    if (pszTitle[0]) {
        cchTitle = lstrlen(pszTitle) + 1;
        cbHistExtra += DW_ALIGNED(SIZEOF(HISTEXTRA) + (cchTitle * sizeof(TCHAR)));

        if (phdPrev && (phextPrev = phdPrev->_FindExtraForSave(PID_INTSITE_TITLE))!=NULL) {
            phextPrev->vtExtra = VT_EMPTY;
        }
    }

    // Get the size of fragments
    UINT cchFragsPrev = 0;
    UINT cchFragment = 0;
    if (pszFragment) {
        cchFragment = lstrlen(pszFragment) + 2;  // Double NULL terminated
        if (phdPrev && (phextPrev=phdPrev->_FindExtraForSave(PID_INTSITE_FRAGMENT))!=NULL) {
            cchFragsPrev = lstrzlen((LPCTSTR)phextPrev->abExtra) - 1; // lstrzlen includes both terminating nulls
                                                                      // -1 since cchFragment already accounts
                                                                      // for double terminating NULLs.
            ASSERT(cchFragsPrev != (UINT)-1);
            phextPrev->vtExtra = VT_EMPTY;
        }
        cbHistExtra += DW_ALIGNED(SIZEOF(HISTEXTRA) + (cchFragsPrev + cchFragment) * sizeof(TCHAR));
    }

    // Get the size of other extra
    if (phdPrev) {
        cbHistExtra += phdPrev->GetTotalExtraSize();
    }

    // Allocate it
    CHistoryData* phdNew = CHistoryData::s_AllocateHeaderInfo(
                                cbHistExtra, phdPrev,
                                &cbHeader);

    if (phdNew) {
        HISTEXTRA* phext = phdNew->_GetExtra();

        ASSERT( phext );

        // Append title
        if (pszTitle[0]) {
            phext->cbExtra = DW_ALIGNED((cchTitle * sizeof(TCHAR)) + SIZEOF(HISTEXTRA));
            phext->idExtra = PID_INTSITE_TITLE;
            phext->vtExtra = VT_LPTSTR; 
            StrCpyN((LPTSTR)phext->abExtra, pszTitle, cchTitle);
            phext = phext->GetNextFastForSave();
        }

        // Append fragment     
        if (pszFragment) {
            // Copy pszFragment to the top.
            StrCpyN((LPTSTR)phext->abExtra, pszFragment, cchFragment);
            // Double NULL terminate.  Note cchFragment = strlen + 2
            *(((LPTSTR)phext->abExtra) + cchFragment - 1) = TEXT('\0');

            // Copy existing fragments if any
            if (cchFragsPrev) {
                ASSERT(phdPrev);
                phextPrev = phdPrev->_FindExtraForSave(PID_INTSITE_FRAGMENT);
                ASSERT(phextPrev);
                if (phextPrev) {
                    ASSERT(IS_DW_ALIGNED(phextPrev->cbExtra));
                    memcpy(phext->abExtra + ((cchFragment - 1) * sizeof(TCHAR)), phextPrev->abExtra,
                           (cchFragsPrev + 1) * sizeof(TCHAR));
                }
            }

            ASSERT(lstrzlen((LPCTSTR)phext->abExtra) == cchFragsPrev + cchFragment);
            phext->cbExtra += DW_ALIGNED(SIZEOF(HISTEXTRA) + (cchFragsPrev + cchFragment) * sizeof(TCHAR));
            phext->idExtra = PID_INTSITE_FRAGMENT;
            phext->vtExtra = VT_NULL;    // HACK (means internal)
            phext = phext->GetNextFastForSave();
        }

        // Migrate extra data from previous one
        if (phdPrev) {
            phext = phdPrev->CopyExtra(phext);
        }

        ASSERT( phext->cbExtra == 0); // terminator
        ASSERT( (LPBYTE)phdNew+cbHeader == (LPBYTE)phext+SIZEOF(DWORD) );
        ASSERT( cbHistExtra == phdNew->GetTotalExtraSize() );
    }

    *pcbHeader = cbHeader;

    TraceMsg(DM_HISTGENERATE, "CUH::s_GenerateHeader allocated %d bytes (%d extra)",
             cbHeader, cbHistExtra);

    return phdNew;
}

// FEATURE: Move this to UTIL.CPP
LPWSTR AllocOleStrFromTChar(LPCTSTR psz)
{
    DWORD cch = lstrlen(psz) + 1;
    LPWSTR pwsz = (LPWSTR)CoTaskMemAlloc(cch * SIZEOF(WCHAR));
    if (pwsz) {
        SHTCharToUnicode(psz, pwsz, cch);
    }
    return pwsz;
}

HRESULT CUrlHistory::s_GenerateSTATURL(
                               IN PCTSTR pszPrefixedURL,
                               IN LPINTERNET_CACHE_ENTRY_INFO lpCEI,
                               IN DWORD dwFlags,
                               OUT LPSTATURL lpSTATURL)
{
    ASSERT(lpCEI);
    ASSERT(lpSTATURL);

    if (!lpCEI || !lpSTATURL)
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    LPHISTDATA phd =  CHistoryData::s_GetHistoryData(lpCEI);
    // I've seen lpCEI->lpszSourceUrlName be NULL with help "ms-its:" URLs. 
    LPCTSTR pszUrl = lpCEI->lpszSourceUrlName ? lpCEI->lpszSourceUrlName : pszPrefixedURL; 
    if (pszUrl && *pszUrl)
    {
       pszUrl += s_cchUserPrefix + CCHHISTORYPREFIX;
    }

    ZeroMemory(lpSTATURL, SIZEOF(STATURL));

    lpSTATURL->ftLastUpdated = lpCEI->LastModifiedTime;
    lpSTATURL->ftExpires = lpCEI->ExpireTime;
    lpSTATURL->ftLastVisited = lpCEI->LastSyncTime;

    if(dwFlags & STATURL_QUERYFLAG_ISCACHED)
    {
        if (pszUrl)
        {
            if (s_IsCached(pszUrl))
                lpSTATURL->dwFlags |= STATURLFLAG_ISCACHED;
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }

    if (dwFlags & STATURL_QUERYFLAG_TOPLEVEL)
    {
        if (phd) {
            if (phd->dwFlags & PIDISF_HISTORY)
            {
                lpSTATURL->dwFlags |= STATURLFLAG_ISTOPLEVEL;
            }
        }
    }

    if (!(dwFlags & STATFLAG_NONAME))
    {
        if (!(dwFlags & STATURL_QUERYFLAG_NOURL))
        {
            if (pszUrl)
            {
                //  set the Url
                lpSTATURL->pwcsUrl = AllocOleStrFromTChar(pszUrl);      // This will RIP if NULL is passed.
                if (lpSTATURL->pwcsUrl == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = E_UNEXPECTED;
            }
        }

        if (!(dwFlags & STATURL_QUERYFLAG_NOTITLE))
        {
            //  is there a title to set?
            if (phd)
            {
                const HISTEXTRA* phextTitle = phd->_FindExtra(PID_INTSITE_TITLE);

                if (phextTitle && phextTitle->vtExtra == VT_LPTSTR) {
                    lpSTATURL->pwcsTitle = AllocOleStrFromTChar((LPCTSTR)phextTitle->abExtra);
                    if (lpSTATURL->pwcsTitle == NULL) {
                        if (lpSTATURL->pwcsUrl)
                            CoTaskMemFree(lpSTATURL->pwcsUrl);
                        lpSTATURL->pwcsUrl = NULL;
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
        }
    }

    ASSERT(SUCCEEDED(hr) || (lpSTATURL->pwcsUrl==NULL && lpSTATURL->pwcsTitle==NULL));
    return hr;
}

    /*++

     Routine Description:

     Places the specified URL into the history.

     If it does not exist, then it is created.  If it does exist it is overwritten.

     Arguments:

     pwszUrl                    - The URL in question.

     pwszTitle  - pointer to the friendly title that should be associated
     with this URL. If NULL, no title will be added.

     dwFlags             - Sets options for storage type and durability
     Not implemented yet

     Return Value:

     HRESULT
     Success - S_OK

     Failure - E_ hresult

     --*/


HRESULT CUrlHistory::AddUrl(
                         IN LPCWSTR pwszUrl,                    // Full URL to be added
                         IN LPCWSTR pwszTitle,  
                         IN DWORD dwFlags                // Storage options
                         )              
{
    BOOL fWriteHistory = TRUE;

    if (ADDURL_ADDTOCACHE == dwFlags)
    {
        fWriteHistory = FALSE;
    }
    
    return AddUrlAndNotify(pwszUrl, pwszTitle, dwFlags, fWriteHistory, NULL, NULL);
}


BOOL CUrlHistory::s_CommitUrlCacheEntry(LPCTSTR pszPrefixedUrl, 
                        LPINTERNET_CACHE_ENTRY_INFO pcei)
{
    if (s_dwDaysToKeep==0) {
        s_dwDaysToKeep = s_GetDaysToKeep();
    }

    //
    //  prepare the expire time
    //
    SYSTEMTIME st;
    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &pcei->LastModifiedTime);

    //
    // Assume the normal expiration date ... we add 6 days to expiration date
    // to make sure when we show the oldest week, we'll still have data for days
    // that are past the s_dwDaysToKeep
    //
    LONGLONG llExpireHorizon = SECS_PER_DAY * (s_dwDaysToKeep + 6);
    llExpireHorizon *= FILETIME_SEC;
    pcei->ExpireTime.dwLowDateTime = pcei->LastModifiedTime.dwLowDateTime + (DWORD) (llExpireHorizon % 0xFFFFFFFF);
    pcei->ExpireTime.dwHighDateTime = pcei->LastModifiedTime.dwHighDateTime + (DWORD) (llExpireHorizon / 0xFFFFFFFF);

    //
    // Check if it's subscribed
    //
    CHistoryData* phd =  CHistoryData::s_GetHistoryData(pcei);
    if (phd && phd->_FindExtra(PID_INTSITE_SUBSCRIPTION)) {
        //
        // It's subscribed. Keep it forever (until unsubscribed). 
        //
        TraceMsg(DM_URLCLEANUP, "CUH::s_CommitUrlCacheEntry found subscription key %s", pszPrefixedUrl);
        pcei->ExpireTime.dwLowDateTime = DW_FOREVERLOW;
        pcei->ExpireTime.dwHighDateTime = DW_FOREVERHIGH;
    }

#ifdef DEBUG
    LPCTSTR pszTitle = TEXT("(no extra data)");
    if (phd) {
        const HISTEXTRA* phext = phd->_FindExtra(PID_INTSITE_TITLE);
        if (phext && phext->vtExtra==VT_LPTSTR) {
            pszTitle = (LPCTSTR)phext->abExtra;
        } else {
            pszTitle = TEXT("(no title property)");
        }

        TraceMsg(DM_HISTCOMMIT, "CURL::s_C calling Commit for %s with %s",
            pszPrefixedUrl, pszTitle);
    }
#endif

    return CommitUrlCacheEntryBinary(pszPrefixedUrl,    
                                     pcei->ExpireTime,  
                                     pcei->LastModifiedTime,                    
                                     pcei->CacheEntryType | URLHISTORY_CACHE_ENTRY,
                                     (LPBYTE)pcei->lpHeaderInfo,
                                     pcei->dwHeaderInfoSize);
}

void CUrlHistory::_WriteToHistory(LPCTSTR pszPrefixedUrl, FILETIME& ftExpires, IOleCommandTarget *poctNotify, IUnknown *punkSFHistory)
{
    IHistSFPrivate *psfpHistory;
    HRESULT hr = LoadHistoryShellFolder(punkSFHistory, &psfpHistory);
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlNotify = NULL;
        //
        //      prepare the local mod time
        //
        SYSTEMTIME st;
        GetLocalTime (&st);
    
        FILETIME ftLocModified; // new history written in "User Perceived Time"
        SystemTimeToFileTime(&st, &ftLocModified);
        hr = psfpHistory->WriteHistory(pszPrefixedUrl,
                                ftExpires,
                                ftLocModified,
                                poctNotify ? &pidlNotify : NULL);
        if (pidlNotify)
        {
            VARIANTARG var;
            InitVariantFromIDList(&var, pidlNotify);

            poctNotify->Exec(&CGID_Explorer, SBCMDID_SELECTHISTPIDL, OLECMDEXECOPT_PROMPTUSER, &var, NULL);

            ILFree(pidlNotify);
            VariantClear(&var);
        }
        psfpHistory->Release();
    }
    // if we made it to here, we win!
}

void CUrlHistory::s_UpdateIcon(Intshcut* pintshcut, DWORD dwFlags)
{
    TCHAR szPath[MAX_PATH];
    int niIcon = 0;
    UINT uFlags;

    // mask off the other stuff so we get consistent results.
    dwFlags &= PIDISF_RECENTLYCHANGED;
    
    // Get the old icon location 
    pintshcut->GetIconLocationFromFlags(0, szPath, SIZECHARS(szPath),
        &niIcon, &uFlags, dwFlags);
    
    // property.
//    int icachedImage = SHLookupIconIndex(PathFindFileName(szPath), niIcon, uFlags);
    int icachedImage = Shell_GetCachedImageIndex(szPath, niIcon, uFlags);

    TraceMsg(DM_HISTSPLAT, "CUH::s_UpdateIcon splat flag is changed for %s (%d)",
            szPath, icachedImage);

    SHUpdateImage(szPath, niIcon, uFlags, icachedImage );
}

HRESULT CUrlHistory::AddUrlAndNotify(
                         IN LPCWSTR pwszUrl,                    // Full URL to be added
                         IN LPCWSTR pwszTitle,  
                         IN DWORD dwFlags,                // Storage options
                         IN BOOL fWriteHistory,         // Write History ShellFolder
                         IN IOleCommandTarget *poctNotify,
                         IN IUnknown *punkSFHistory)
{
    return AddUrlAndNotifyCP(pwszUrl, pwszTitle, dwFlags, fWriteHistory,
                           poctNotify, punkSFHistory, NULL);
}




HRESULT CUrlHistory::AddUrlAndNotifyCP(
                         IN LPCWSTR pwszUrl,                    // Full URL to be added
                         IN LPCWSTR pwszTitle,  
                         IN DWORD dwFlags,                // Storage options
                         IN BOOL fWriteHistory,         // Write History ShellFolder
                         IN IOleCommandTarget *poctNotify,
                         IN IUnknown *punkSFHistory,
                         UINT* pcodepage)               
{
    if (pcodepage) {
        *pcodepage = CP_ACP;    // this is default.
    }

    HRESULT hr = S_OK;
    LPCWSTR pwszTitleToStore = pwszTitle;

    //  check to make sure we got an URL
    if (!pwszUrl || !pwszUrl[0])
    {
        TraceMsg( TF_WARNING, "CUrlHistory::AddUrlAndNotifyCP() - pwszUrl is NULL or Empty!" );
        return E_INVALIDARG;
    }

    if (pwszTitleToStore && 0 == StrCmpIW(pwszTitleToStore, pwszUrl))
    {
        //  Suppress redundant title data
        pwszTitleToStore = NULL;
    }

    CEI_PREALLOC buf;
    INTERNET_CACHE_ENTRY_INFO cei = { 0 };

    // Wininet URL cache only supports 8-bit ANSI, so we need to encode any characters
    // which can't be converted by the system code page, in order to allow Unicode
    // filenames in History.  The URLs will remain in the encoded form through most of
    // the History code paths, with only the display and navigation code needing to be
    // aware of the UTF8

    LPCTSTR pszUrlSource = pwszUrl; // points to the URL that we decide to use

    TCHAR szEncodedUrl[MAX_URL_STRING];
    BOOL bUsedDefaultChar;
    
    // Find out if any of the chars will get scrambled.  We can use our szEncodedUrl 
    // buffer to store he multibyte result because we don't actually want it
    
    WideCharToMultiByte(CP_ACP, 0, pwszUrl, -1, 
        (LPSTR) szEncodedUrl, sizeof(szEncodedUrl), NULL, &bUsedDefaultChar);
    
    StrCpyN(szEncodedUrl, pwszUrl, ARRAYSIZE(szEncodedUrl));
    SHCleanupUrlForDisplay(szEncodedUrl);
    pszUrlSource = szEncodedUrl;

    if (bUsedDefaultChar)
    {
        // one or more chars couldn't be converted, so we store the UTF8 escaped string
        ConvertToUtf8Escaped(szEncodedUrl, ARRAYSIZE(szEncodedUrl));
    }

    s_ConvertToPrefixedUrlW(pszUrlSource, buf.szPrefixedUrl, ARRAYSIZE(buf.szPrefixedUrl), &buf.pszFragment);
    s_RetrievePrefixedUrlInfo(buf.szPrefixedUrl, &buf);

    LPHISTDATA phdPrev = NULL;

    TCHAR szTitle[MAX_PATH];
    szTitle[0] = '\0';

    LPINTERNET_CACHE_ENTRY_INFO             pceiUrl = NULL;

    //
    //  if there is already an entry for this Url, then we will reuse some of the
    //  settings.  retrieve the relevant info if possible.
    //
    if (buf.pcei)
    {
        // The existing one cannot be copied since the size may vary.
        // That is, the s_RetrievePrefixedUrlInfo above may allocate a larger buffer than expected.
        pceiUrl = buf.pcei;

        phdPrev = CHistoryData::s_GetHistoryData( pceiUrl );
        if (pwszTitle==NULL && phdPrev) {
            phdPrev->_GetTitle(szTitle, ARRAYSIZE(szTitle));
        }

        if (pcodepage && phdPrev) {
            //
            // NOTES: This is the best place get the codepage stored
            //  in this URL history.
            //
            const HISTEXTRA* phextCP =phdPrev->_FindExtra(PID_INTSITE_CODEPAGE);
            if (phextCP && phextCP->vtExtra == VT_UI4) {
                *pcodepage = *(DWORD*)phextCP->abExtra;
                TraceMsg(DM_TRACE, "CUH::AddAndNotify this URL has CP=%d",
                         *pcodepage);
            }
        }

    }
    else
    {
        pceiUrl = &cei;

        cei.CacheEntryType = NORMAL_CACHE_ENTRY;
        ASSERT(cei.dwHeaderInfoSize == 0);
    }

    ASSERT( pceiUrl );

    if ( ! pceiUrl )
    {
        TraceMsg( TF_ERROR, "CUrlHistory::AddUrlAndNotifyCP() - pceiUrl is NULL!" );
        return E_FAIL;
    }

    //
    //  search for a fragment if necessary
    //
    if (buf.pszFragment && phdPrev)
    {
        if (phdPrev->_HasFragment(buf.pszFragment)) {
            buf.pszFragment = NULL;
        }
    }

    // Override the title if specified.
    if (pwszTitleToStore) {
        // GetDisplayableTitle puts szTitle[0] = '\0' if it's
        // not displayable with shell codepage
        StrCpyN(szTitle, pwszTitleToStore, ARRAYSIZE(szTitle));
    } 

    CHistoryData* phdNew = s_GenerateHeaderInfo(
               szTitle, phdPrev, buf.pszFragment, &pceiUrl->dwHeaderInfoSize);

    if (phdNew)
    {
        pceiUrl->lpHeaderInfo = (LPTSTR)phdNew;

        //
        // [alanau] Background: See IE5 Bug #110378 and related.
        //
        // For secure URLs (https:) that respond with a cache control header (pragma: no-cache or
        // cache-control: no-cache or no-store), we presume that these can contain sensitive data that
        // the site did not want retained on the client machine.  Therefore, we do not write a history entry
        // for such sites.
        //
        // Previously, a check was made in CDocObjectHost::CDOHBindStatusCallback::OnObjectAvailable(), where
        // the binding was queried for INTERNET_REQFLAG_CACHE_WRITE_DISABLED.  This flag would be set not only 
        // for https: URLs but for http: URLs that contained cache-control: no-store.  With Native Frames, however,
        // OnObjectAvailable() is no longer called (as Trident performs the bind), so SHDOCVW doesn't have access
        // to the PIB any longer.  However, all we are really interested in is whether or not the URL is in cache,
        // and we have a straightforward way to check that.
        // 
        // Note that IE 5.5 has a deliberate change of behavior to write http: (non-secure) URLs that 
        // contain cache-control: no-store to history.

        // If caller specified to write history, and the scheme is a history-enabled scheme,
        //
        if (fWriteHistory && !UrlIsNoHistoryW(pwszUrl))
        {
            // If it's https://, we have more work to do.
            //
            if (URL_SCHEME_HTTPS == GetUrlScheme(pwszUrl))
            {
                // Check the cache.  If https: and in cache, add to history.
                //
                if (UrlIsInCache(pwszUrl))
                {
                    phdNew->dwFlags |= PIDISF_HISTORY;
                }
            }
            else
            {
                // Not https:, so turn on history flag.
                //
                phdNew->dwFlags |= PIDISF_HISTORY;
            }
        }
        else
        {
            phdNew->dwFlags &= ~PIDISF_HISTORY; // clear the flag
        }

        BOOL fUpdateIcon = FALSE;
    
        if (phdNew->dwFlags & PIDISF_RECENTLYCHANGED) {
            fUpdateIcon = TRUE;
            phdNew->dwFlags &= ~PIDISF_RECENTLYCHANGED;
        }

        if ( s_CommitUrlCacheEntry( buf.szPrefixedUrl, pceiUrl ) )
        {
            if (fUpdateIcon) {
                TraceMsg(DM_HISTSPLAT, "CUH::AddAndNotify remove splat!");

                // APPCOMPAT: This is a temporary hack to make splat update
                //  work as bad as previously.
                Intshcut* pintshcut = new Intshcut();
                if (pintshcut) {
                    pintshcut->SetURL(pwszUrl ,0);
                    s_UpdateIcon(pintshcut, PIDISF_RECENTLYCHANGED);
                    pintshcut->Release();
                }
            }
    
            //
            //  When we have successfully updated the global history and
            // we have updated something in the HISTDATA, update the
            // date-based history as well.
            //
            //
            // Cache IShellFolder for the history folder if we don't have
            // it yet.
            //
            // Use the previously set PIDISF_HISTORY flag to decide whether or not to write history here too.
            if (phdNew->dwFlags & PIDISF_HISTORY)
            {
                _WriteToHistory( buf.szPrefixedUrl, pceiUrl->ExpireTime, poctNotify, punkSFHistory );
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError ());
        }

        LocalFree(phdNew);
        phdNew = NULL;
    }

#ifdef DEBUG
    if (g_dwPrototype & 0x00000020) {
        TCHAR szUrl[MAX_URL_STRING];
        SHUnicodeToTChar(pwszUrl, szUrl, ARRAYSIZE(szUrl));
        PROPVARIANT var = { 0 };
        HRESULT hrT = GetProperty(szUrl, PID_INTSITE_SUBSCRIPTION, &var);
        if (SUCCEEDED(hrT)) {
            TraceMsg(DM_TRACE, "CUH::AddAndNotify got property vt=%d lVal=%x",
                        var.vt, var.lVal);
            PropVariantClear(&var);
        } else {
            TraceMsg(DM_TRACE, "CUH::AddAndNotify failed to get property (%x)", hrT);
        }
    }
#endif

    return hr;
}


HRESULT CUrlHistory::QueryUrl(
                          IN LPCWSTR pwszUrl,
                          IN DWORD dwFlags,
                          OUT LPSTATURL lpSTATURL
                          )
{
    if (!pwszUrl || !pwszUrl[0])
    {
        return E_INVALIDARG;
    }

    if (lpSTATURL)
    {
        lpSTATURL->pwcsUrl = NULL;
        lpSTATURL->pwcsTitle = NULL;
    }

    LPCTSTR pszFragment;
    TCHAR szPrefixedUrl[MAX_URL_STRING];

    s_ConvertToPrefixedUrlW(pwszUrl, szPrefixedUrl, ARRAYSIZE(szPrefixedUrl), &pszFragment);
    return s_QueryUrlCommon(szPrefixedUrl, pszFragment, dwFlags, lpSTATURL);
}

HRESULT CUrlHistory::s_QueryUrlCommon(
                          IN LPCTSTR lpszPrefixedUrl,
                          LPCTSTR lpszFragment,
                          IN DWORD dwFlags,
                          OUT LPSTATURL lpSTATURL
                          )

    /*++

     Routine Description:

     Checks to see if Url is a valid History item

     Arguments:

     pwszUrl                    - The URL in question.

     dwFlags             - Flags on the query

     lpSTATURL           - points to a STATURL storage structure
     If this is NULL, then a S_OK means the URL was found.


     Return Value:

     HRESULT
     Success            - S_OK, Item found and STATURL filled

     Failure            - valid E_ code
     HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) indicates the URL is not available


     --*/

{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    LPHISTDATA phd = NULL;
    CEI_PREALLOC buf;

    //
    //  if there is no data required, and there are no fragments
    //  we dont need to get a copy of the CEI
    //
    if(!lpSTATURL && !lpszFragment)
    {
        if(s_IsCached(lpszPrefixedUrl))
            hr = S_OK;
        else
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

        goto quit;
    }

    s_RetrievePrefixedUrlInfo(lpszPrefixedUrl, &buf);
    if (buf.pcei)
    {
        DEBUG_CODE(DWORD cbNHI = buf.pcei->dwHeaderInfoSize;)
        phd = CHistoryData::s_GetHistoryData(buf.pcei);
        hr = S_OK;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError ());
        goto quit;
    }


    //
    //  Need to check for local anchor fragments
    //
    if (lpszFragment)
    {
        if (phd && phd->_HasFragment(lpszFragment))
        {
            hr = S_OK;
        }
    } else {
        hr = S_OK;
    }

    //  check to see if we should fill the STATURL
    if (S_OK == hr && lpSTATURL) {
        hr = s_GenerateSTATURL(lpszPrefixedUrl, buf.pcei, dwFlags, lpSTATURL);
    }

quit:

    if (S_OK != hr && lpSTATURL)
    {
        if (lpSTATURL->pwcsUrl)
        {
            LocalFree(lpSTATURL->pwcsUrl);
            lpSTATURL->pwcsUrl = NULL;
        }

        if (lpSTATURL->pwcsTitle)
        {
            LocalFree(lpSTATURL->pwcsTitle);
            lpSTATURL->pwcsTitle = NULL;
        }
    }

    return hr;
}

HRESULT CUrlHistory::QueryUrlA(LPCSTR pszUrl, DWORD dwFlags, LPSTATURL lpSTATURL)
{
    TCHAR szPrefixedUrl[MAX_URL_STRING];
    LPCTSTR lpszFragment = NULL;
    HRESULT hr = S_OK;

    if (!pszUrl || !pszUrl[0]) {
        return E_INVALIDARG;
    }

    if (lpSTATURL)
    {
        lpSTATURL->pwcsUrl = NULL;
        lpSTATURL->pwcsTitle = NULL;
    }

    TCHAR szUrl[MAX_URL_STRING];

    SHAnsiToUnicode(pszUrl, szUrl, ARRAYSIZE(szUrl));
    CUrlHistory::s_ConvertToPrefixedUrlW(szUrl, szPrefixedUrl, ARRAYSIZE(szPrefixedUrl), &lpszFragment);

    return CUrlHistory::s_QueryUrlCommon(szPrefixedUrl, lpszFragment, dwFlags, lpSTATURL);
}

HRESULT CUrlHistory::s_DeleteUrl(LPCWSTR pwszUrl, DWORD dwFlags)
{
    DWORD Error = ERROR_SUCCESS;
    TCHAR szPrefixedUrl[MAX_URL_STRING];
    LPCTSTR lpszFragment;
    BOOL  fDoDelete = TRUE;
    
    if (!pwszUrl || !pwszUrl[0]) {
        return E_INVALIDARG;
    }

    s_ConvertToPrefixedUrlW(pwszUrl, szPrefixedUrl, ARRAYSIZE(szPrefixedUrl), &lpszFragment);

    // don't delete it if its not a subscription
    if (dwFlags & URLFLAG_DONT_DELETE_SUBSCRIBED) {
        CEI_PREALLOC buf;
        // query to find out if its a subscription
        s_RetrievePrefixedUrlInfo(szPrefixedUrl, &buf);
        if (buf.pcei &&
            //  Hack alert (chrisfra) avoid deleting subscriptions, etc!
            ((buf.pcei)->ExpireTime.dwLowDateTime  == DW_FOREVERLOW) &&
            ((buf.pcei)->ExpireTime.dwHighDateTime == DW_FOREVERHIGH))
        {
            fDoDelete = FALSE;
            // re-write it as a non-history item and just a subscription
            CHistoryData *phdPrev = CHistoryData::s_GetHistoryData(buf.pcei);
            if (phdPrev) // offset into pcei structure
            {
                phdPrev->dwFlags &= ~PIDISF_HISTORY;
                s_CommitUrlCacheEntry(szPrefixedUrl, buf.pcei);
            }
            else {
                // I'd rather return ERROR_OUT_OF_PAPER...
                Error = ERROR_FILE_NOT_FOUND;
            }
        }
    }

    if (fDoDelete) {
        if(!::DeleteUrlCacheEntry(szPrefixedUrl))
            Error = GetLastError();
    }

    return HRESULT_FROM_WIN32(Error);
}

HRESULT CUrlHistory::DeleteUrl(LPCWSTR pwszUrl, DWORD dwFlags)
{
    return s_DeleteUrl(pwszUrl, dwFlags);
}

HRESULT CUrlHistory::BindToObject (LPCWSTR pwszUrl, REFIID riid, void **ppvOut)
{
    *ppvOut = NULL;
    return E_NOTIMPL;
#if 0
    HRESULT hr;

    if(!ppvOut || !pwszUrl || !*pwszUrl)
        return E_INVALIDARG;

    *ppvOut = NULL;

    CUrlHObj *pcuho = new CUrlHObj (this);
    if (!pcuho)
        return E_OUTOFMEMORY;

    hr = pcuho->QueryInterface(riid, ppvOut);
    pcuho->Release();

    if (SUCCEEDED(hr))
    {
        hr = pcuho->Init(pwszUrl);
        if (FAILED(hr))
        {
            pcuho->Release();
            *ppvOut = NULL;
        }
    }
    
    return hr;
#endif
}

HRESULT CUrlHistory::s_EnumUrls(IEnumSTATURL **ppEnum)
{
    HRESULT hres = E_OUTOFMEMORY;
    *ppEnum = NULL;
    CEnumSTATURL *penum = new CEnumSTATURL();
    if (penum)
    {
        *ppEnum = (IEnumSTATURL *)penum;
        hres = S_OK;
    }
    return hres;
}

HRESULT CUrlHistory::EnumUrls(IEnumSTATURL **ppEnum)
{
    return s_EnumUrls(ppEnum);
}

HRESULT CUrlHistory::GetProperty(LPCTSTR pszURL, PROPID pid, PROPVARIANT* pvarOut)
{
    HRESULT hres = E_FAIL;  // assume error
    PropVariantInit(pvarOut);

    CEI_PREALLOC buf;
    CUrlHistory::s_ConvertToPrefixedUrlW(pszURL, buf.szPrefixedUrl, ARRAYSIZE(buf.szPrefixedUrl), &buf.pszFragment);
    CUrlHistory::s_RetrievePrefixedUrlInfo(buf.szPrefixedUrl, &buf);
    if (buf.pcei) {
        CHistoryData* phdPrev =  CHistoryData::s_GetHistoryData(buf.pcei);
        if (phdPrev) {
            const HISTEXTRA* phextPrev;

            switch(pid) {
            case PID_INTSITE_FLAGS:
                pvarOut->vt = VT_UI4;
                pvarOut->lVal = phdPrev->dwFlags;
                hres = S_OK;
                break;
        
            case PID_INTSITE_LASTVISIT:
                pvarOut->vt = VT_FILETIME;
                pvarOut->filetime = buf.pcei->LastAccessTime;
                hres = S_OK;
                break;

            case PID_INTSITE_LASTMOD:
                pvarOut->vt = VT_FILETIME;
                pvarOut->filetime = buf.pcei->LastModifiedTime;
                hres = S_OK;
                break;

            case PID_INTSITE_WATCH:
                pvarOut->vt = VT_UI4;
                pvarOut->lVal = phdPrev->dwWatch;
                hres = S_OK;
                break;

            case PID_INTSITE_VISITCOUNT:
                pvarOut->vt   = VT_UI4;
                pvarOut->lVal = buf.pcei->dwHitRate;
                hres = S_OK;
                break;

            default:
                phextPrev = phdPrev->_FindExtra(pid);
                LPCWSTR pwsz;

                if (phextPrev) {
                    WCHAR wszBuf[MAX_URL_STRING];

                    switch(phextPrev->vtExtra) {
                    case VT_UI4:
                    case VT_I4:
                        pvarOut->vt = phextPrev->vtExtra;
                        pvarOut->lVal = *(DWORD*)phextPrev->abExtra;
                        hres = S_OK;
                        break;

                    case VT_LPSTR:
                        AnsiToUnicode((LPCSTR)phextPrev->abExtra, wszBuf, ARRAYSIZE(wszBuf));
                        pwsz = wszBuf;
                        goto Return_LPWSTR;

                    case VT_LPWSTR:
                        pwsz = (LPWSTR)phextPrev->abExtra;
Return_LPWSTR:
                        int cch = lstrlenW(pwsz)+1;
                        pvarOut->pwszVal = (LPWSTR)CoTaskMemAlloc(cch * SIZEOF(WCHAR));
                        if (pvarOut->pwszVal) {
                            StrCpyNW(pvarOut->pwszVal, pwsz, cch);
                            pvarOut->vt = VT_LPWSTR;
                            hres = S_OK;
                        } else {
                            hres = E_OUTOFMEMORY;
                        }
                        break;
                    }
                }
                break;
            }
        }
    }
    return hres;
}

//
//  IEnumSTATURL methods
//
CEnumSTATURL::~CEnumSTATURL()
{
    if(m_lpCEI)
    {
        LocalFree(m_lpCEI);
        m_lpCEI = NULL;
    }

    if(m_hEnum)
        FindCloseUrlCache(m_hEnum);

    return;
}

HRESULT CEnumSTATURL::QueryInterface(REFIID riid, PVOID *ppvObj)
{
    if (!ppvObj)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (IsEqualIID(IID_IUnknown, riid))
    {
        *ppvObj = (IUnknown *) this;
        AddRef();
        return S_OK;
    }
    else if (IsEqualIID(IID_IEnumSTATURL, riid))
    {
        *ppvObj = (IEnumSTATURL *) this;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

ULONG CEnumSTATURL::AddRef(void)
{
    _cRef++;

    return _cRef;
}


ULONG CEnumSTATURL::Release(void)
{
    _cRef--;

    if (!_cRef)
    {
        delete this;
        return 0;
    }

    return _cRef;
}



HRESULT CEnumSTATURL::RetrieveFirstUrlInfo()
{

    HRESULT hr = S_OK;

    ASSERT(!m_lpCEI);

    m_cbCEI = DEFAULT_CEI_BUFFER_SIZE;
    m_lpCEI = (LPINTERNET_CACHE_ENTRY_INFO) LocalAlloc(LPTR, DEFAULT_CEI_BUFFER_SIZE);
    if (!m_lpCEI)
    {
        hr = E_OUTOFMEMORY;
        goto quit;
    }

    while (TRUE)
    {
        m_hEnum = FindFirstUrlCacheEntryBinary(_szPrefixedUrl,
                                                   m_lpCEI,
                                                   &m_cbCEI);

        if (!m_hEnum)
        {
            DWORD Error = GetLastError ();

            LocalFree(m_lpCEI);
            m_lpCEI = NULL;

            if (Error == ERROR_INSUFFICIENT_BUFFER)
            {
                m_lpCEI = (LPINTERNET_CACHE_ENTRY_INFO) LocalAlloc(LPTR, m_cbCEI);
                if (!m_lpCEI)
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }
            }
            else
            {
                if (ERROR_NO_MORE_ITEMS == Error)
                    hr = S_FALSE;
                else
                    hr = HRESULT_FROM_WIN32(Error);
                break;
            }
        }
        else break;
    }

quit:

    m_cbCEI = (DWORD)max(m_cbCEI, DEFAULT_CEI_BUFFER_SIZE);

    return hr;
}

// This function should not becaused if the previous call failed
// and ::Reset() was never called.
HRESULT CEnumSTATURL::RetrieveNextUrlInfo()
{
    HRESULT hr = S_OK;
    BOOL ok;

    ASSERT(m_hEnum);

    while (TRUE)
    {

        ok = FindNextUrlCacheEntryBinary(m_hEnum,
                                             m_lpCEI,
                                             &m_cbCEI);

        if (!ok)
        {
            DWORD Error = GetLastError ();

            if (m_lpCEI)
            {
                LocalFree(m_lpCEI);
                m_lpCEI = NULL;
            }

            if (Error == ERROR_INSUFFICIENT_BUFFER)
            {
                m_lpCEI = (LPINTERNET_CACHE_ENTRY_INFO) LocalAlloc(LPTR, m_cbCEI);
                if (!m_lpCEI)
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }
            }
            else
            {
                if (ERROR_NO_MORE_ITEMS == Error)
                    hr = S_FALSE;
                else
                    hr = HRESULT_FROM_WIN32(Error);
                break;
            }
        }
        else break;
    }

    m_cbCEI = (DWORD)max(m_cbCEI, DEFAULT_CEI_BUFFER_SIZE);

    return hr;
}




HRESULT CEnumSTATURL::Next(ULONG celt, LPSTATURL rgelt, ULONG * pceltFetched)
    /*++

     Routine Description:

     Searches through the History looking for URLs that match the search pattern,
     and copies the STATURL into the buffer.

     Arguments:



     Return Value:



     --*/

{
    HRESULT hr = S_OK;
    BOOL found = FALSE;
    LPHISTDATA phd = NULL;

    if(pceltFetched)
        *pceltFetched = 0;

    if(!celt)
        goto quit;

    if (!m_hEnum)
    {
        //must handle new enumerator
        CUrlHistory::s_ConvertToPrefixedUrlW(m_poszFilter, _szPrefixedUrl, ARRAYSIZE(_szPrefixedUrl), &m_lpszFragment);

        //loop until we get our first handle or bag out
        hr = RetrieveFirstUrlInfo();
        if (S_OK != hr || !m_lpCEI)
            goto quit;

        m_cchPrefixedUrl = lstrlen(_szPrefixedUrl);

        while(StrCmpN(_szPrefixedUrl, m_lpCEI->lpszSourceUrlName, m_cchPrefixedUrl))
        {
            hr = RetrieveNextUrlInfo();
            if(S_OK != hr || !m_lpCEI)
                goto quit;
        }
    }
    else
    {
        do
        {
            hr = RetrieveNextUrlInfo();
            if (S_OK != hr || !m_lpCEI)
                goto quit;

        } while(StrCmpN(_szPrefixedUrl, m_lpCEI->lpszSourceUrlName, m_cchPrefixedUrl));
    }

    hr = CUrlHistory::s_GenerateSTATURL(NULL, m_lpCEI, m_dwFilter, rgelt);

    if(SUCCEEDED(hr) && pceltFetched)
        (*pceltFetched)++;



quit:
    if (pceltFetched) {
        ASSERT((0 == *pceltFetched && (S_FALSE == hr || FAILED(hr))) ||
               (*pceltFetched && S_OK == hr));
    }

    return hr;


}

HISTEXTRA* CHistoryData::CopyExtra(HISTEXTRA* phextCur) const
{
    const HISTEXTRA* phext;
    for (phext = _GetExtra();
         phext && !phext->IsTerminator();
         phext = phext->GetNextFast())
    {
        if (phext->vtExtra != VT_EMPTY) {
            TraceMsg(DM_HISTEXTRA, "CHD::CopyExtra copying vt=%d id=%d %d bytes",
                    phext->vtExtra, phext->idExtra, phext->cbExtra);
            memcpy(phextCur, phext, phext->cbExtra);
            phextCur = phextCur->GetNextFastForSave();
        } else {
            TraceMsg(DM_HISTEXTRA, "CHD::CopyExtra skipping vt=%d id=%d %d bytes",
                    phext->vtExtra, phext->idExtra, phext->cbExtra);
        }
    }

    return phextCur;
}

CHistoryData* CHistoryData::s_AllocateHeaderInfo(UINT cbExtra, const HISTDATA* phdPrev, ULONG* pcbTotal)
{
    DWORD cbTotal = SIZEOF(HISTDATA) + SIZEOF(DWORD) + cbExtra;

    LPHISTDATA phdNew = (LPHISTDATA)LocalAlloc(LPTR, cbTotal);
    if (phdNew) {
        if (phdPrev) {
            *phdNew = *phdPrev; // Copy all the field
        }
        phdNew->cbSize = SIZEOF(HISTDATA);
        phdNew->cbVer = HISTDATA_VER;
        *pcbTotal = cbTotal;
    }

    return phdNew;
}

//
// Returns the total size of extra data (exclude VT_EMPTY)
//
UINT CHistoryData::GetTotalExtraSize() const
{
    const HISTEXTRA* phext;
    UINT cbTotal = 0;
    for (phext = _GetExtra();
         phext && !phext->IsTerminator();
         phext = phext->GetNextFast())
    {
        if (phext->vtExtra != VT_EMPTY) {
            cbTotal += phext->cbExtra;
        }
    }

    return cbTotal;
}

HRESULT CEnumSTATURL::Skip(ULONG celt)
{
    return E_NOTIMPL;
}

HRESULT CEnumSTATURL::Reset(void)
{
    if(m_hEnum)
    {
        FindCloseUrlCache(m_hEnum);
        m_hEnum = NULL;
    }

    if(m_poszFilter)
    {
        LocalFree(m_poszFilter);
        m_poszFilter = NULL;
    }

    if(m_lpCEI)
    {
        LocalFree(m_lpCEI);
        m_lpCEI = NULL;
    }

    m_dwFilter = 0;


    return S_OK;
}

HRESULT CEnumSTATURL::Clone(IEnumSTATURL ** ppenum)
{
    return E_NOTIMPL;
}

//  IEnumSTATURL methods

HRESULT CEnumSTATURL::SetFilter(LPCWSTR poszFilter, DWORD dwFlags)
{
    HRESULT hr = S_OK;

    if(poszFilter)
    {
        m_poszFilter = StrDupW(poszFilter);
        if (!m_poszFilter)
        {
            hr = E_OUTOFMEMORY;
            goto quit;
        }

    }

    m_dwFilter = dwFlags;

quit:

    return hr;

}

const HISTEXTRA * CHistoryData::_FindExtra(UINT idExtra) const
{
    for (const HISTEXTRA* phext = _GetExtra();
         phext && !phext->IsTerminator();
         phext = phext->GetNextFastForSave())
    {
        if (phext->idExtra == idExtra) {
            return phext;
        }
    }

    return NULL;
}

CHistoryData* CHistoryData::s_GetHistoryData(LPINTERNET_CACHE_ENTRY_INFO lpCEI)
{
    CHistoryData* phd = (CHistoryData*)lpCEI->lpHeaderInfo;
    if (phd && phd->_IsOldHistory()) {
        TraceMsg(DM_TRACE, "CHistoryData::GetHistoryData found old header. Ignore");
        phd = NULL;
    }

    if (phd && phd->cbVer != HISTDATA_VER) {
        TraceMsg(DM_TRACE, "CHistoryData::GetHistoryData found old header (%d). Ignore",
                 phd->cbVer);
        phd = NULL;
    }

    return phd;
}

BOOL CHistoryData::_HasFragment(LPCTSTR pszFragment) const
{
    BOOL fHas = FALSE;
    const HISTEXTRA* phext = _FindExtra(PID_INTSITE_FRAGMENT);

    if (phext) {
        for (LPCTSTR psz=(LPCTSTR)(phext->abExtra); *psz ; psz += lstrlen(psz)+1) {
            if (StrCmp(psz, pszFragment)==0) {
                fHas = TRUE;
                break;
            }
        }
    }

    return fHas;
}

void CHistoryData::_GetTitle(LPTSTR szTitle, UINT cchMax) const
{
    szTitle[0] = '\0';
    const HISTEXTRA* phext = _FindExtra(PID_INTSITE_TITLE);
    if (phext && phext->vtExtra == VT_LPSTR) {
        StrCpyN(szTitle, (LPCTSTR)phext->abExtra, cchMax);
    }
}


#ifdef USE_NEW_HISTORYDATA
#include "urlprop2.cpp"
#endif // USE_NEW_HISTORYDATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\urlprop2.cpp ===
//==========================================================================================
// HISTDATA helper (should be a static member)
//==========================================================================================


#define CUrlHistoryProp IntsiteProp

//==========================================================================================
// IntsiteProp class implementation
//==========================================================================================

#ifdef DEBUG

/*----------------------------------------------------------
Purpose: Dump the properties in this object

*/
STDMETHODIMP_(void)
    CUrlHistoryProp::Dump(void)
{
    if (IsFlagSet(g_dwDumpFlags, DF_URLPROP))
    {
        TraceMsg(TF_ALWAYS, "  Intsite Property obj: %s", m_szURL);
        URLProp::Dump();
    }
}

#endif


/*----------------------------------------------------------
Purpose: Constructor for URLProp 

*/
CUrlHistoryProp::CUrlHistoryProp(void)
{
    // Don't validate this until after construction.
    
    // This object should only be allocated, not used on the stack,
    // because we don't zero-initialize the member variables.
    // Here's a sanity assertion.
    
    ASSERT(NULL == m_pintshcut);
    
    ASSERT(IS_VALID_STRUCT_PTR(this, CIntsiteProp));
    
    return;
}


/*----------------------------------------------------------
Purpose: Destructor for CUrlHistoryProp

*/
CUrlHistoryProp::~CUrlHistoryProp(void)
{
    if (m_pintshcut)
    {
        if (!m_fPrivate)
            m_pintshcut->Release();
        m_pintshcut = NULL;
    }
    
    return;
}

STDAPI CIntsiteProp_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppvOut)
{
    HRESULT hres;
    
    *ppvOut = NULL;
    
    ASSERT(punkOuter==NULL)

    IUnknown * piunk = (IUnknown *)new IntsiteProp;
    if ( !piunk ) 
    {
        hres = E_OUTOFMEMORY;
    }
    else
    {
        hres = piunk->QueryInterface(riid, ppvOut);
        piunk->Release();
    }
    
    return hres;        // S_OK or E_NOINTERFACE
}

HRESULT CUrlHistoryProp::Init(void)
{
    return URLProp::Init();
}

STDMETHODIMP CUrlHistoryProp::InitFromDB(LPCTSTR pszURL, Intshcut *pintshcut, BOOL fPrivObj)
{
    // TraceMsg(DM_HISTPROP, "CUHP::InitFromDB called for %s", pszURL);

    // Initialize the in-memory property storage from the file
    // and database
    
    HRESULT hres = Init();
    if (SUCCEEDED(hres))
    {
        if (NULL == m_pintshcut)
        {
            m_fPrivate = fPrivObj;
            if (!m_fPrivate)
                pintshcut->AddRef();
            m_pintshcut = pintshcut;
        }
        else
        {
            // We can't switch from Private->Public or visaversa.
            ASSERT(fPrivObj == m_fPrivate);
        }
        
        if (pszURL)
        {
            // Is this really a URL?? 
            PARSEDURL pu;
            
            pu.cbSize = SIZEOF(pu);
            hres = ParseURL(pszURL, &pu);
            
            if (S_OK == hres)
            {
                // Yes; go ahead and initialize
                StrCpyN(m_szURL, pszURL, SIZECHARS(m_szURL));

                hres = LoadFromDB(pszURL);
            }
        }
    }
    
    return hres;
}

HRESULT CUrlHistoryProp::LoadFromDB(
    IN LPCTSTR pszURL)
{
    TraceMsg(DM_HISTPROP, "CUHP::LoadFromDB called for %s", pszURL);

    CEI_PREALLOC buf;
    CUrlHistory::s_ConvertToPrefixedUrlW(pszURL, buf.szPrefixedUrl, ARRAYSIZE(buf.szPrefixedUrl), &buf.pszFragment);
    CUrlHistory::s_RetrievePrefixedUrlInfo(buf.szPrefixedUrl, &buf);

    //
    //	if there is already an entry for this Url, then we will reuse some of the
    //	settings.  retrieve the relevant info if possible.
    //
    if (buf.pcei) {
        CHistoryData* phdPrev =  CHistoryData::s_GetHistoryData(buf.pcei);
        if (phdPrev) {
            //
            // Initialize non-string properties first
            //
            const static PROPSPEC c_aprspec[] = {
                { PRSPEC_PROPID, PID_INTSITE_FLAGS },
                { PRSPEC_PROPID, PID_INTSITE_LASTVISIT },
                { PRSPEC_PROPID, PID_INTSITE_LASTMOD },
                { PRSPEC_PROPID, PID_INTSITE_WATCH },
            };
            PROPVARIANT apropvar[ARRAYSIZE(c_aprspec)] = { 0 };

            apropvar[0].vt = VT_UI4;
            apropvar[0].lVal = phdPrev->dwFlags;
            apropvar[1].vt = VT_FILETIME;
            apropvar[1].filetime = buf.pcei->LastAccessTime;
            apropvar[2].vt = VT_FILETIME;
            apropvar[2].filetime = buf.pcei->LastModifiedTime;
            apropvar[3].vt = VT_UI4;
            apropvar[3].lVal = phdPrev->dwWatch;

            TraceMsg(DM_HISTPROP, "CUHP::InitFromDB calling WriteMultiple (wFlags=%x)", phdPrev->dwFlags);
      	    WriteMultiple(ARRAYSIZE(c_aprspec), c_aprspec, apropvar, 0);
            PropStg_DirtyMultiple(m_hstg, ARRAYSIZE(c_aprspec), c_aprspec, FALSE);

            //
            // Then, initialize others
            //
            PROPSPEC prspec;
            prspec.ulKind = PRSPEC_PROPID;

            for (const HISTEXTRA* phextPrev = phdPrev->_GetExtra();
                 phextPrev && !phextPrev->IsTerminator();
                 phextPrev = phextPrev->GetNextFast())
            {
                TraceMsg(DM_HISTPROP, "CUHP::InitFromDB found HISTEXTRA (id=%d, vt=%d)",
                         phextPrev->idExtra, phextPrev->cbExtra);

                WCHAR wszBuf[MAX_URL_STRING]; // NOTES: scope must be right
                apropvar[0].vt = phextPrev->vtExtra;

                switch(phextPrev->vtExtra) {
                case VT_LPWSTR:
                    apropvar[0].pwszVal = (LPWSTR)phextPrev->abExtra;
                    break;

                case VT_LPSTR:
                    //
                    // Notice that we always convert it to LPWSTR
                    //
                    {
                        apropvar[0].pwszVal = wszBuf;
                        LPCSTR pszExtra = (LPCSTR)phextPrev->abExtra;
                        AnsiToUnicode(pszExtra, wszBuf, ARRAYSIZE(wszBuf));
                        apropvar[0].vt = VT_LPWSTR;
                    }
                    break;

                case VT_UI4:
                case VT_I4:
                    apropvar[0].lVal = *(DWORD*)phextPrev->abExtra;
                    break;

                case VT_NULL:
                    ASSERT(phextPrev->idExtra == PID_INTSITE_FRAGMENT);
                    continue;

                default:
                    ASSERT(0);
                    continue;
                }

                prspec.propid = phextPrev->idExtra;
                WriteMultiple(1, &prspec, apropvar, 0);
                PropStg_DirtyMultiple(m_hstg, 1, &prspec, FALSE);
            }
        } else {
            TraceMsg(DM_HISTPROP, "CUHP::LoadFromDB can't get phdPrev");
        }
    } else {
        TraceMsg(DM_HISTPROP, "CUHP::LoadFromDB can't get pcei");
    }

    return S_OK;
}


struct URLHIST_ENUMPARAM {
    CUrlHistoryProp* that;
    INTERNET_CACHE_ENTRY_INFO cei;
    LPINTERNET_CACHE_ENTRY_INFO pceiPrev;
    CHistoryData* phdPrev;
    LPHISTEXTRA phextCur;
    UINT cbHistExtra;
    BOOL fDirty;
};

STDAPI s_CommitHistItem(
    IN PROPID        propid,
    IN PROPVARIANT * ppropvar,
    IN LPARAM        lParam)
{
    URLHIST_ENUMPARAM* peparam = (URLHIST_ENUMPARAM*)lParam;
    CHistoryData* phdNew = (CHistoryData*)peparam->cei.lpHeaderInfo;

    TraceMsg(DM_HISTEXTRA, "CUHP::s_CommitHistItem called for id=%d vt=%d (phextCur=%x)",
                propid, ppropvar->vt, peparam->phextCur);

    UINT cbExtra = 0;
    UINT cbRequired;

    switch(propid) {
    case PID_INTSITE_FLAGS:
        if (ppropvar->vt == VT_UI4 && phdNew) {
            TraceMsg(DM_HISTPROP, "CUHP::s_CommitHistItem updating PID_INSITE_FLAGS (%x to %x)",
                     phdNew->dwFlags, ppropvar->lVal);
            phdNew->dwFlags = ppropvar->lVal;
            peparam->fDirty = TRUE;
        }
        break;

    case PID_INTSITE_WATCH:
        if (ppropvar->vt == VT_UI4 && phdNew) {
            TraceMsg(DM_HISTPROP, "CUHP::s_CommitHistItem updating PID_INSITE_WATCH (%x to %x)",
                     phdNew->dwFlags, ppropvar->lVal);
            phdNew->dwWatch = ppropvar->lVal;
            peparam->fDirty = TRUE;
        }
        break;

    case PID_INTSITE_LASTVISIT:
    case PID_INTSITE_LASTMOD:
        // They are read-only. We can change it if we want.
        ASSERT(0);
        break;

    default:
        switch(ppropvar->vt) {
        case VT_UI4:
        case VT_I4:
            cbExtra = DW_ALIGNED(SIZEOF(HISTEXTRA)-SIZEOF(peparam->phextCur->abExtra)+SIZEOF(UINT));
            if (peparam->phextCur) {
                peparam->phextCur->cbExtra = cbExtra;
                peparam->phextCur->idExtra = propid;
                peparam->phextCur->vtExtra = ppropvar->vt;
                *(DWORD*)peparam->phextCur->abExtra = ppropvar->lVal;
                peparam->fDirty = TRUE;
            }
            break;

        case VT_LPWSTR:
            cbRequired = WideCharToMultiByte(CP_ACP, 0, ppropvar->pwszVal, -1,
                                NULL, 0, NULL, NULL);
            cbExtra = DW_ALIGNED(SIZEOF(HISTEXTRA) + cbRequired);
            if (peparam->phextCur)
            {
                peparam->phextCur->cbExtra = cbExtra;
                peparam->phextCur->idExtra = propid;
                peparam->phextCur->vtExtra = VT_LPSTR;
                WideCharToMultiByte(CP_ACP, 0, ppropvar->pwszVal, -1, 
                    (LPSTR)peparam->phextCur->abExtra, cbRequired, NULL, NULL);
                peparam->fDirty = TRUE;
            }
            break;

        case VT_EMPTY:
            if (peparam->phextCur) {
                peparam->fDirty = TRUE;
            }
            break;

        default:
            ASSERT(0);
            break;
        }

        if (peparam->phextCur) {
            // We are saving the data, move the write pointer.
            TraceMsg(DM_HISTEXTRA, "s_CommitHistItem moving phextCur forward %d bytes",
                     peparam->phextCur->cbExtra);
            peparam->phextCur = peparam->phextCur->GetNextFastForSave();
            ASSERT(peparam->phextCur->cbExtra == 0);
        } else {
            // We are calcurating the required size, just add the size.
            TraceMsg(DM_HISTEXTRA, "s_CommitHistItem adding %d", cbExtra);
            peparam->cbHistExtra += cbExtra;

            // Remove existing one. 
            if (peparam->phdPrev) {
                // FEATURE: Bad const to non-const cast
                HISTEXTRA* phextPrev =
                    (HISTEXTRA*)peparam->phdPrev->_FindExtra(propid);
    
                if (phextPrev) {
                    TraceMsg(DM_HISTEXTRA, "s_CommitHistItem invalidate an old one id=%d %d bytes",
                              phextPrev->idExtra, phextPrev->cbExtra);
                    phextPrev->vtExtra = VT_EMPTY;
                }
            }
	}
    }
    return S_OK;
};

HRESULT CUrlHistoryProp::Commit(IN DWORD dwFlags)
{
    TraceMsg(DM_HISTPROP, "CUHP::Commit called for %s", m_szURL);

    CEI_PREALLOC buf;
    CUrlHistory::s_ConvertToPrefixedUrlW(m_szURL, buf.szPrefixedUrl, ARRAYSIZE(buf.szPrefixedUrl), &buf.pszFragment);
    CUrlHistory::s_RetrievePrefixedUrlInfo(buf.szPrefixedUrl, &buf);

    HRESULT hres;
    URLHIST_ENUMPARAM eparam = { this };
    ASSERT(eparam.fDirty == FALSE);

    eparam.pceiPrev = buf.pcei;
    if (eparam.pceiPrev) {
        eparam.cei = *eparam.pceiPrev;
        eparam.phdPrev =  CHistoryData::s_GetHistoryData(eparam.pceiPrev);
    }

    // First, enemerate once to get the size for extra. 
    eparam.cei.lpHeaderInfo = NULL;
    eparam.cbHistExtra = 0;
    hres = PropStg_Enum(m_hstg, PSTGEF_DIRTY, s_CommitHistItem, (LPARAM)&eparam);

    DWORD dwFlagsPrev = 0;
    if (eparam.phdPrev) {
        eparam.cbHistExtra += eparam.phdPrev->GetTotalExtraSize();
        dwFlagsPrev = eparam.phdPrev->dwFlags;
    }

    TraceMsg(DM_HISTEXTRA, "CUHP::Commit total size is %d", eparam.cbHistExtra);

    CHistoryData* phdNew = CHistoryData::s_AllocateHeaderInfo(
                                eparam.cbHistExtra, eparam.phdPrev,
                                &eparam.cei.dwHeaderInfoSize);

    if (phdNew) {
        eparam.cei.lpHeaderInfo = (LPTSTR)phdNew;
        eparam.phextCur = phdNew->_GetExtra();

        // Enumerate again to fill the extra data. 
        hres = PropStg_Enum(m_hstg, PSTGEF_DIRTY, s_CommitHistItem, (LPARAM)&eparam);

        if (eparam.fDirty)
        {
            if (eparam.phdPrev) {
                eparam.phdPrev->CopyExtra(eparam.phextCur);
            }

            TraceMsg(DM_HISTPROP, "CUHP::Commit It's dirty. save it (header = %d bytes)",
                     eparam.cei.dwHeaderInfoSize);

            ASSERT(eparam.cbHistExtra == phdNew->GetTotalExtraSize());

            CUrlHistory::s_CommitUrlCacheEntry(buf.szPrefixedUrl, &eparam.cei);

            if ((dwFlagsPrev & PIDISF_RECENTLYCHANGED)
                    != (phdNew->dwFlags & PIDISF_RECENTLYCHANGED))
            {
                // Yes; update the images
                CUrlHistory::s_UpdateIcon(m_pintshcut, dwFlagsPrev);
            }
        }

        LocalFree(phdNew);
        phdNew = NULL;
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\urlprop.cpp ===
/*
* urlprop.cpp - Implementation for URLProp class.
*/


#include "priv.h"
#include "ishcut.h"

STDAPI_(LPITEMIDLIST) IEILCreate(UINT cbSize);

#define MAX_BUF_INT         (1 + 10 + 1)        // -2147483647

const TCHAR c_szIntshcut[]       = ISHCUT_INISTRING_SECTION;



#ifdef DEBUG

BOOL IsValidPCURLProp(PCURLProp pcurlprop)
{
    return (IS_VALID_READ_PTR(pcurlprop, CURLProp) &&
            (NULL == pcurlprop->m_hstg ||
             IS_VALID_HANDLE(pcurlprop->m_hstg, PROPSTG)));
}


BOOL IsValidPCIntshcutProp(PCIntshcutProp pcisprop)
{
    return (IS_VALID_READ_PTR(pcisprop, CIntshcutProp) &&
            IS_VALID_STRUCT_PTR(pcisprop, CURLProp));
}

BOOL IsValidPCIntsiteProp(PCIntsiteProp pcisprop)
{
    return (IS_VALID_READ_PTR(pcisprop, CIntsiteProp) &&
            IS_VALID_STRUCT_PTR(pcisprop, CURLProp));
}


#endif


BOOL AnyMeatW(LPCWSTR pcsz)
{
    ASSERT(! pcsz || IS_VALID_STRING_PTRW(pcsz, -1));
    
    return(pcsz ? StrSpnW(pcsz, L" \t") < lstrlenW(pcsz) : FALSE);
}


BOOL AnyMeatA(LPCSTR pcsz)
{
    ASSERT(! pcsz || IS_VALID_STRING_PTRA(pcsz, -1));
    
    return(pcsz ? StrSpnA(pcsz, " \t") < lstrlenA(pcsz) : FALSE);
}


/*----------------------------------------------------------
Purpose: Read an arbitrary named string from the .ini file.

Returns: S_OK if the name exists
         S_FALSE if it doesn't

         E_OUTOFMEMORY
*/
HRESULT ReadStringFromFile(IN  LPCTSTR    pszFile, 
                           IN  LPCTSTR    pszSectionName,
                           IN  LPCTSTR    pszName,
                           OUT LPWSTR *   ppwsz,
                           IN  CHAR *     pszBuf)
{
    HRESULT hres = E_OUTOFMEMORY;
    
    ASSERT(IS_VALID_STRING_PTR(pszFile, -1));
    ASSERT(IS_VALID_STRING_PTR(pszName, -1));
    ASSERT(IS_VALID_WRITE_PTR(ppwsz, PWSTR));
    
    *ppwsz = (LPWSTR)LocalAlloc(LPTR, SIZEOF(WCHAR) * INTERNET_MAX_URL_LENGTH);
    if (*ppwsz)
    {
        DWORD cch;
        
        hres = S_OK;

        cch = SHGetIniString(pszSectionName, pszName,
            *ppwsz, INTERNET_MAX_URL_LENGTH, pszFile);
        if (0 == cch)                                
        {
            hres = S_FALSE;
            LocalFree(*ppwsz);
            *ppwsz = NULL;
        }
    }
    
    return hres;
}

/*----------------------------------------------------------
Purpose: Read an arbitrary named string from the .ini file.
         Return a BSTR

Returns: S_OK if the name exists
         S_FALSE if it doesn't

         E_OUTOFMEMORY
*/
HRESULT ReadBStrFromFile(IN  LPCTSTR      pszFile, 
                           IN  LPCTSTR    pszSectionName,
                           IN  LPCTSTR    pszName,
                           OUT BSTR *     pBStr)
{
    CHAR szTempBuf[INTERNET_MAX_URL_LENGTH];
    WCHAR *pwsz;
    HRESULT hres = E_OUTOFMEMORY;
    *pBStr = NULL;
    ASSERT(IS_VALID_STRING_PTR(pszFile, -1));
    ASSERT(IS_VALID_STRING_PTR(pszName, -1));
    ASSERT(IS_VALID_WRITE_PTR(pBStr, PWSTR));

    // (Pass in an empty string so we can determine from the return
    // value whether there is any text associated with this name.)
    hres = ReadStringFromFile(pszFile, pszSectionName, pszName, &pwsz, szTempBuf);
    if (S_OK == hres)                                
    {
        *pBStr = SysAllocString(pwsz);
        LocalFree(pwsz);
        pwsz = NULL;
    }

    return hres;
}

/*----------------------------------------------------------
Purpose: read an arbitrary named unsigend int from the .ini file. note in order to implement
         ReadSignedFromFile one'll need to use ReadStringFromFile and then StrToIntEx. this is
         because GetPrivateProfileInt can't return a negative.

Returns: S_OK if the name exists
         S_FALSE if it doesn't

         E_OUTOFMEMORY
*/
HRESULT
ReadUnsignedFromFile(
    IN LPCTSTR pszFile,
    IN LPCTSTR pszSectionName,
    IN LPCTSTR pszName,
    IN LPDWORD pdwVal)
{
    HRESULT hr;
    int     iValue;

    ASSERT(IS_VALID_STRING_PTR(pszFile,        -1));
    ASSERT(IS_VALID_STRING_PTR(pszSectionName, -1));
    ASSERT(IS_VALID_STRING_PTR(pszName,        -1));

    if (NULL == pdwVal)
        return E_INVALIDARG;
    *pdwVal = 0;

    hr     = S_OK;
    iValue = GetPrivateProfileInt(pszSectionName, pszName, 1, pszFile);
    if (1 == iValue) {
        iValue = GetPrivateProfileInt(pszSectionName, pszName, 2, pszFile);
        hr     = (2 != iValue) ? S_OK : S_FALSE;
        ASSERT(S_FALSE == hr || 1 == iValue);
    }

    if (S_OK == hr)
        *pdwVal = (DWORD)iValue;

    return hr;
}

/*----------------------------------------------------------
Purpose: Write number to URL (ini) file

*/
HRESULT WriteSignedToFile(IN LPCTSTR  pszFile,
                          IN LPCTSTR  pszSectionName,
                          IN LPCTSTR  pszName,
                          IN int      nVal)
{
    HRESULT hres;
    TCHAR szVal[MAX_BUF_INT];
    int cch;
    
    ASSERT(IS_VALID_STRING_PTR(pszFile, -1));
    ASSERT(IS_VALID_STRING_PTR(pszName, -1));
    
    cch = wnsprintf(szVal, ARRAYSIZE(szVal), TEXT("%d"), nVal);
    ASSERT(cch > 0);
    ASSERT(cch < SIZECHARS(szVal));
    ASSERT(cch == lstrlen(szVal));
    
    hres = WritePrivateProfileString(pszSectionName, pszName, szVal,
        pszFile) ? S_OK : E_FAIL;
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Write number to URL (ini) file

*/
HRESULT WriteUnsignedToFile(IN LPCTSTR  pszFile,
                            IN  LPCTSTR pszSectionName,
                            IN LPCTSTR  pszName,
                            IN DWORD    nVal)
{
    HRESULT hres;
    TCHAR szVal[MAX_BUF_INT];
    int cch;
    
    ASSERT(IS_VALID_STRING_PTR(pszFile, -1));
    ASSERT(IS_VALID_STRING_PTR(pszName, -1));
    
    cch = wnsprintf(szVal, ARRAYSIZE(szVal), TEXT("%u"), nVal);
    ASSERT(cch > 0);
    ASSERT(cch < SIZECHARS(szVal));
    ASSERT(cch == lstrlen(szVal));
    
    hres = WritePrivateProfileString(pszSectionName, pszName, szVal,
        pszFile) ? S_OK : E_FAIL;
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Write binary data to URL (ini) file

*/
HRESULT WriteBinaryToFile(IN LPCTSTR pszFile,
                          IN  LPCTSTR pszSectionName,
                          IN LPCTSTR pszName,
                          IN LPVOID  pvData,
                          IN DWORD   cbSize)
{
    HRESULT hres;
    
    ASSERT(IS_VALID_STRING_PTR(pszFile, -1));
    ASSERT(IS_VALID_STRING_PTR(pszName, -1));

    hres = (WritePrivateProfileStruct(pszSectionName, pszName, pvData, cbSize, pszFile))
        ? S_OK : E_FAIL;
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Read the hotkey from the URL (ini) file

*/
HRESULT ReadBinaryFromFile(IN LPCTSTR pszFile,
                           IN LPCTSTR pszSectionName,
                           IN LPCTSTR pszName,
                           IN LPVOID  pvData,
                           IN DWORD   cbData)
{
    HRESULT hres = S_FALSE;
    
    ASSERT(IS_VALID_STRING_PTR(pszFile, -1));
    
    memset(pvData, 0, cbData);
    
    if (GetPrivateProfileStruct(pszSectionName, pszName, pvData, cbData, pszFile))
        hres = S_OK;
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Real the URL from the URL (ini) file

*/
HRESULT 
ReadURLFromFile(
    IN  LPCTSTR  pszFile, 
    IN  LPCTSTR pszSectionName,
    OUT LPTSTR * ppsz)
{
    HRESULT hres = E_OUTOFMEMORY;
    
    *ppsz = (LPTSTR)LocalAlloc(LPTR, SIZEOF(TCHAR) * INTERNET_MAX_URL_LENGTH);
    if (*ppsz)
    {
        DWORD cch;

        cch = SHGetIniString(pszSectionName, ISHCUT_INISTRING_URL,
            *ppsz, INTERNET_MAX_URL_LENGTH, pszFile);
        if (0 != cch)
        {
            PathRemoveBlanks(*ppsz);
            hres = S_OK;
        }
        else
        {
            LocalFree(*ppsz);
            *ppsz = NULL;    
            hres = S_FALSE;     
        }
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Read the icon location from the URL (ini) file

Returns: S_OK  value was obtained from file
         S_FALSE value wasn't in file

         E_OUTOFMEMORY
*/
HRESULT 
ReadIconLocation(
    IN  LPCTSTR  pszFile,
    OUT LPWSTR * ppwsz,
    OUT int *    pniIcon,
    IN CHAR *    pszBuf)
{
    HRESULT hres = E_OUTOFMEMORY;
    DWORD cch;
    
    ASSERT(IS_VALID_STRING_PTR(pszFile, -1));
    ASSERT(IS_VALID_WRITE_PTR(ppwsz, PTSTR));
    ASSERT(IS_VALID_WRITE_PTR(pniIcon, INT));
    
    *ppwsz = NULL;
    *pniIcon = 0;
    
    *ppwsz = (LPWSTR)LocalAlloc(LPTR, SIZEOF(WCHAR) * MAX_PATH);
    if (*ppwsz)
    {
        hres = S_FALSE;     // assume no value exists in the file
        
        cch = SHGetIniString(c_szIntshcut,
           ISHCUT_INISTRING_ICONFILE, *ppwsz,
            MAX_PATH, pszFile);
        
        if (0 != cch)
        {
            TCHAR szIndex[MAX_BUF_INT];
            // The icon index is all ASCII so don't need SHGetIniString
            cch = GetPrivateProfileString(c_szIntshcut,
                ISHCUT_INISTRING_ICONINDEX, c_szNULL, 
                szIndex, SIZECHARS(szIndex),
                pszFile);
            if (0 != cch)
            {
                if (StrToIntEx(szIndex, 0, pniIcon))
                    hres = S_OK;
            }
        }
        
        if (S_OK != hres)
        {
            LocalFree(*ppwsz);
            *ppwsz = NULL;    
        }
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Write icon location to URL (ini) file

*/
HRESULT 
    WriteIconFile(
    IN LPCTSTR pszFile,
    IN LPCWSTR pszIconFile)
{
    HRESULT hres = S_OK;
    
    ASSERT(IS_VALID_STRING_PTR(pszFile, -1));
    ASSERT(! pszIconFile ||
        IS_VALID_STRING_PTRW(pszIconFile, -1));
    
    if (*pszFile)
    {
        if (AnyMeatW(pszIconFile))
        {
            hres = SHSetIniString(c_szIntshcut, ISHCUT_INISTRING_ICONFILE, pszIconFile,
                pszFile) ? S_OK : E_FAIL;
        }
        else
        {
            // NOTE: since this function removes both the file and the index
            // values, then this function must be called *after* any call 
            // to WriteIconIndex.  One way to do this is make sure 
            // PID_IS_ICONINDEX < PID_IS_ICONFILE, since the index will
            // be enumerated first.
            
            hres = (SHDeleteIniString(c_szIntshcut, ISHCUT_INISTRING_ICONFILE,
                pszFile) &&
                DeletePrivateProfileString(c_szIntshcut, ISHCUT_INISTRING_ICONINDEX,
                pszFile))
                ? S_OK : E_FAIL;
        }
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Write icon index to URL (ini) file

*/
HRESULT 
WriteIconIndex(
    IN LPCTSTR pszFile,
    IN int     niIcon)
{
    HRESULT hres;
    
    if (*pszFile)
        hres = WriteSignedToFile(pszFile, c_szIntshcut, ISHCUT_INISTRING_ICONINDEX, niIcon);
    else
        hres = S_FALSE;
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Read the hotkey from the URL (ini) file

*/
HRESULT 
ReadHotkey(
    IN LPCTSTR pszFile, 
    IN WORD *  pwHotkey)
{
    HRESULT hres = S_FALSE;
    TCHAR szHotkey[MAX_BUF_INT];
    DWORD cch;
    
    ASSERT(IS_VALID_STRING_PTR(pszFile, -1));
    ASSERT(IS_VALID_WRITE_PTR(pwHotkey, WORD));
    
    *pwHotkey = 0;
    
    cch = GetPrivateProfileString(c_szIntshcut,
        TEXT("Hotkey"), c_szNULL,
        szHotkey, SIZECHARS(szHotkey),
        pszFile);
    if (0 != cch)
    {
        int nVal;
        
        if (StrToIntEx(szHotkey, 0, &nVal))
        {
            *pwHotkey = nVal;
            hres = S_OK;
        }
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Write hotkey to URL (ini) file

*/
HRESULT 
WriteHotkey(
    IN LPCTSTR pszFile, 
    IN WORD    wHotkey)
{
    HRESULT hres = S_FALSE;
    
    ASSERT(IS_VALID_STRING_PTR(pszFile, -1));
    
    if (*pszFile)
    {
        if (wHotkey)
        {
            hres = WriteUnsignedToFile(pszFile, c_szIntshcut, TEXT("Hotkey"), wHotkey);
        }
        else
        {
            hres = DeletePrivateProfileString(c_szIntshcut, TEXT("Hotkey"), pszFile)
                ? S_OK
                : E_FAIL;
        }
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Read the working directory from the URL (ini) file

*/
HRESULT 
ReadWorkingDirectory(
    IN  LPCTSTR  pszFile,
    OUT LPWSTR * ppwsz)
{
    HRESULT hres = E_OUTOFMEMORY;
    TCHAR szPath[MAX_PATH];
    DWORD cch;
    
    ASSERT(IS_VALID_STRING_PTR(pszFile, -1));
    ASSERT(IS_VALID_WRITE_PTR(ppwsz, PWSTR));
    
    *ppwsz = NULL;
    
    *ppwsz = (LPWSTR)LocalAlloc(LPTR, SIZEOF(WCHAR) * MAX_PATH);
    if (*ppwsz)
    {
        hres = S_FALSE;
        
        cch = SHGetIniString(c_szIntshcut,
            ISHCUT_INISTRING_WORKINGDIR,
            szPath, SIZECHARS(szPath), pszFile);
        if (0 != cch)
        {
            TCHAR szFullPath[MAX_PATH];
            PTSTR pszFileName;
            
            if (0 < GetFullPathName(szPath, SIZECHARS(szFullPath), szFullPath,
                &pszFileName))
            {
                SHTCharToUnicode(szFullPath, *ppwsz, MAX_PATH);
                
                hres = S_OK;
            }
        }
        
        if (S_OK != hres)
        {
            LocalFree(*ppwsz);
            *ppwsz = NULL;    
        }
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Write the working directory to the URL (ini) file.

*/
HRESULT 
WriteGenericString(
    IN LPCTSTR pszFile, 
    IN  LPCTSTR pszSectionName,
    IN LPCTSTR pszName,
    IN LPCWSTR pwsz)          OPTIONAL
{
    HRESULT hres = S_FALSE;
    
    ASSERT(IS_VALID_STRING_PTR(pszFile, -1));
    ASSERT(IS_VALID_STRING_PTR(pszName, -1));
    ASSERT(! pwsz || IS_VALID_STRING_PTRW(pwsz, -1));
    
    if (*pszFile)
    {
        if (AnyMeatW(pwsz))
        {
            hres = (SHSetIniString(pszSectionName, pszName, pwsz,
                pszFile)) ? S_OK : E_FAIL;
        }
        else
        {
            hres = (SHDeleteIniString(pszSectionName, pszName, pszFile))
                ? S_OK : E_FAIL;
        }
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Read the show-command flag from the URL (ini) file

*/
HRESULT 
ReadShowCmd(
    IN  LPCTSTR pszFile, 
    OUT PINT    pnShowCmd)
{
    HRESULT hres = S_FALSE;
    TCHAR szT[MAX_BUF_INT];
    DWORD cch;
    
    ASSERT(IS_VALID_STRING_PTR(pszFile, -1));
    ASSERT(IS_VALID_WRITE_PTR(pnShowCmd, INT));
    
    *pnShowCmd = SW_NORMAL;
    
    cch = GetPrivateProfileString(c_szIntshcut,
        TEXT("ShowCommand"), c_szNULL, szT,
        SIZECHARS(szT), pszFile);
    if (0 != cch)
    {
        if (StrToIntEx(szT, 0, pnShowCmd))
        {
            hres = S_OK;
        }
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Write showcmd to URL (ini) file

*/
HRESULT 
WriteShowCmd(
    IN LPCTSTR pszFile, 
    IN int     nShowCmd)
{
    HRESULT hres = S_FALSE;
    
    ASSERT(IS_VALID_STRING_PTR(pszFile, -1));
    
    if (*pszFile)
    {
        if (SW_NORMAL != nShowCmd)
        {
            hres = WriteSignedToFile(pszFile, c_szIntshcut, TEXT("ShowCommand"), nShowCmd);
        }
        else
        {
            hres = DeletePrivateProfileString(c_szIntshcut, TEXT("ShowCommand"), pszFile)
                ? S_OK
                : E_FAIL;
        }
    }
    
    return hres;
}



/*----------------------------------------------------------
Purpose: Read the IDList from the URL (ini) file

*/
HRESULT 
ReadIDList(
    IN  LPCTSTR pszFile, 
    OUT LPITEMIDLIST *ppidl)
{
    HRESULT hres = S_FALSE;
    ULONG cb;

    ASSERT(ppidl);

    // Delete the old one if any.
    if (*ppidl)
    {
        ILFree(*ppidl);
        *ppidl = NULL;
    }

    // Read the size of the IDLIST
    cb = GetPrivateProfileInt(c_szIntshcut, TEXT("ILSize"), 0, pszFile);
    if (cb)
    {
        // Create a IDLIST
        LPITEMIDLIST pidl = IEILCreate(cb);
        if (pidl)
        {
            // Read its contents
            if (GetPrivateProfileStruct(c_szIntshcut, TEXT("IDList"), (LPVOID)pidl, cb, pszFile))
            {
                *ppidl = pidl;
                hres = S_OK;
            }
            else
            {
                ILFree(pidl);
                hres = E_FAIL;
            }
        }
        else
        {
           hres = E_OUTOFMEMORY;
        }
    }
    
    return hres;
}

HRESULT
WriteStream(
    IN LPCTSTR pszFile, 
    IN IStream *pStream,
    IN LPCTSTR pszStreamName,
    IN LPCTSTR pszSizeName)
{
    HRESULT hr = E_FAIL;
    ULARGE_INTEGER li = {0};
    
    if(pStream)
        IStream_Size(pStream, &li);

    if (li.LowPart)
    {
        ASSERT(!li.HighPart);
        LPVOID pv = LocalAlloc(LPTR, li.LowPart);

        if (pv && SUCCEEDED(hr = IStream_Read(pStream, pv, li.LowPart)))
        {
            //  we have loaded the data properly, time to write it out

            if (SUCCEEDED(hr = WriteUnsignedToFile(pszFile, c_szIntshcut, pszSizeName, li.LowPart)))
                hr = WriteBinaryToFile(pszFile, c_szIntshcut, pszStreamName, pv, li.LowPart);
        }

        if (pv)
        {
            LocalFree(pv);
            pv = NULL;
        }
    }
    else
    {
        // delete the keys if
        // 1. pStream is NULL, or
        // 2. pStream in empty (cbPidl == 0).
        if (DeletePrivateProfileString(c_szIntshcut, pszSizeName, pszFile) &&
            DeletePrivateProfileString(c_szIntshcut, pszStreamName, pszFile))
        {
            hr = S_OK;
        }
    }

    return hr;
}

/*----------------------------------------------------------
Purpose: Write IDList to URL (ini) file

*/
HRESULT 
WriteIDList(
    IN LPCTSTR pszFile, 
    IN IStream *pStream)
{
    return WriteStream(pszFile, pStream, TEXT("IDList"), TEXT("ILSize"));
}




/********************************** Methods **********************************/



//==========================================================================================
// URLProp class implementation 
//==========================================================================================


#ifdef DEBUG

/*----------------------------------------------------------
Purpose: Dump the properties in this object

*/
STDMETHODIMP_(void) URLProp::Dump(void)
{
    if (IsFlagSet(g_dwDumpFlags, DF_URLPROP))
    {
        PropStg_Dump(m_hstg, 0);
    }
}

#endif


/*----------------------------------------------------------
Purpose: Constructor for URLProp 

*/
URLProp::URLProp(void) : m_cRef(1)
{
    // Don't validate this until after construction.
    
    m_hstg = NULL;
    
    ASSERT(IS_VALID_STRUCT_PTR(this, CURLProp));
    
    return;
}


/*----------------------------------------------------------
Purpose: Destructor for URLProp

*/
URLProp::~URLProp(void)
{
    ASSERT(IS_VALID_STRUCT_PTR(this, CURLProp));
    
    if (m_hstg)
    {
        PropStg_Destroy(m_hstg);
        m_hstg = NULL;
    }
    
    ASSERT(IS_VALID_STRUCT_PTR(this, CURLProp));
    
    return;
}


STDMETHODIMP_(ULONG) URLProp::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) URLProp::Release()
{
    m_cRef--;
    if (m_cRef > 0)
        return m_cRef;
    
    delete this;
    return 0;
}

/*----------------------------------------------------------
Purpose: IUnknown::QueryInterface method for URLProp

*/
STDMETHODIMP URLProp::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IPropertyStorage))
    {
        *ppvObj = SAFECAST(this, IPropertyStorage *);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/*----------------------------------------------------------
Purpose: Initialize the object

Returns: S_OK
         E_OUTOFMEMORY
*/
STDMETHODIMP URLProp::Init(void)
{
    HRESULT hres = S_OK;
    
    // Don't stomp on ourselves if this has already been initialized 
    if (NULL == m_hstg)
    {
        hres = PropStg_Create(&m_hstg, PSTGF_DEFAULT);
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Helper function that retrieves the string property

*/
STDMETHODIMP
URLProp::GetProp(
    IN PROPID pid,
    IN LPTSTR pszBuf,
    IN int    cchBuf)
{
    HRESULT hres;
    PROPSPEC propspec;
    PROPVARIANT propvar;
    
    ASSERT(pszBuf);
    
    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = pid;
    
    *pszBuf = TEXT('\0');
    
    hres = ReadMultiple(1, &propspec, &propvar);
    if (SUCCEEDED(hres))
    {
        if (VT_LPWSTR == propvar.vt)
        {
            SHUnicodeToTChar(propvar.pwszVal, pszBuf, cchBuf);
            hres = S_OK;
        }
        else
        {
            if (VT_EMPTY != propvar.vt && VT_ILLEGAL != propvar.vt)
                TraceMsg(TF_WARNING, "URLProp::GetProp: expected propid %#lx to be VT_LPWSTR, but is %s", pid, Dbg_GetVTName(propvar.vt));
            hres = S_FALSE;
        }
        
        PropVariantClear(&propvar);
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Helper function that retrieves the word property

*/
STDMETHODIMP
URLProp::GetProp(
    IN PROPID pid,
    IN int * piVal)
{
    HRESULT hres;
    PROPSPEC propspec;
    PROPVARIANT propvar;
    
    ASSERT(piVal);
    
    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = pid;
    
    *piVal = 0;
    
    hres = ReadMultiple(1, &propspec, &propvar);
    if (SUCCEEDED(hres))
    {
        if (VT_I4 == propvar.vt)
        {
            *piVal = propvar.lVal;
            hres = S_OK;
        }
        else
        {
            if (VT_EMPTY != propvar.vt && VT_ILLEGAL != propvar.vt)
                TraceMsg(TF_WARNING, "URLProp::GetProp: expected propid %#lx to be VT_I4, but is %s", pid, Dbg_GetVTName(propvar.vt));
            hres = S_FALSE;
        }
        
        PropVariantClear(&propvar);
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Helper function that retrieves the word property

*/
STDMETHODIMP
URLProp::GetProp(
    IN PROPID pid,
    IN LPDWORD pdwVal)
{
    HRESULT hres;
    PROPSPEC propspec;
    PROPVARIANT propvar;
    
    ASSERT(pdwVal);
    
    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = pid;
    
    *pdwVal = 0;
    
    hres = ReadMultiple(1, &propspec, &propvar);
    if (SUCCEEDED(hres))
    {
        if (VT_UI4 == propvar.vt)
        {
            *pdwVal = propvar.ulVal;
            hres = S_OK;
        }
        else
        {
            if (VT_EMPTY != propvar.vt && VT_ILLEGAL != propvar.vt)
                TraceMsg(TF_WARNING, "URLProp::GetProp: expected propid %#lx to be VT_UI4, but is %s", pid, Dbg_GetVTName(propvar.vt));
            hres = S_FALSE;
        }
        
        PropVariantClear(&propvar);
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Helper function that retrieves the word property

*/
STDMETHODIMP
URLProp::GetProp(
    IN PROPID pid,
    IN WORD * pwVal)
{
    HRESULT hres;
    PROPSPEC propspec;
    PROPVARIANT propvar;
    
    ASSERT(pwVal);
    
    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = pid;
    
    *pwVal = 0;
    
    hres = ReadMultiple(1, &propspec, &propvar);
    if (SUCCEEDED(hres))
    {
        if (VT_UI2 == propvar.vt)
        {
            *pwVal = propvar.uiVal;
            hres = S_OK;
        }
        else
        {
            if (VT_EMPTY != propvar.vt && VT_ILLEGAL != propvar.vt)
                TraceMsg(TF_WARNING, "URLProp::GetProp: expected propid %#lx to be VT_UI2, but is %s", pid, Dbg_GetVTName(propvar.vt));
            hres = S_FALSE;
        }
        
        PropVariantClear(&propvar);
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Helper function that retrieves the IStream property

*/
STDMETHODIMP
URLProp::GetProp(
    IN PROPID pid,
    IN IStream **ppStream)
{
    HRESULT hres;
    PROPSPEC propspec;
    PROPVARIANT propvar;
    
    ASSERT(ppStream);
    
    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = pid;
    
    *ppStream = 0;
    
    hres = ReadMultiple(1, &propspec, &propvar);
    if (SUCCEEDED(hres))
    {
        if (VT_STREAM == propvar.vt)
        {
            *ppStream = propvar.pStream;
            hres = S_OK;
        }
        else
        {
            if (VT_EMPTY != propvar.vt && VT_ILLEGAL != propvar.vt && propvar.lVal != 0)
                TraceMsg(TF_WARNING, "URLProp::GetProp: expected propid %#lx to be VT_STREAM, but is %s", pid, Dbg_GetVTName(propvar.vt));
            hres = S_FALSE;
        }
        
        // Do not PropVariantClear(&propvar), because it will call pStream->Release().
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Helper function that sets the string property

*/
STDMETHODIMP
URLProp::SetProp(
    IN PROPID  pid,
    IN LPCTSTR psz)         OPTIONAL
{
    HRESULT hres;
    PROPSPEC propspec;
    PROPVARIANT propvar;

    // WARNING:: this function gets called as part of ShellExecute which can be
    // called by 16 bit apps so don't put mondo strings on stack...
    WCHAR *pwsz = NULL;
    
    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = pid;
    
    if (psz && *psz)
    {
        SHStrDup(psz, &pwsz);
        propvar.vt = VT_LPWSTR;
        propvar.pwszVal = pwsz;
    }
    else
        propvar.vt = VT_EMPTY;
    
    hres = WriteMultiple(1, &propspec, &propvar, 0);

    if (pwsz)
        CoTaskMemFree(pwsz);

    return hres;
}


/*----------------------------------------------------------
Purpose: Helper function that sets the int property

*/
STDMETHODIMP
URLProp::SetProp(
    IN PROPID  pid,
    IN int     iVal)
{
    PROPSPEC propspec;
    PROPVARIANT propvar;
    
    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = pid;
    
    propvar.vt = VT_I4;
    propvar.lVal = iVal;
    
    return WriteMultiple(1, &propspec, &propvar, 0);
}


/*----------------------------------------------------------
Purpose: Helper function that sets the dword property

*/
STDMETHODIMP
URLProp::SetProp(
    IN PROPID  pid,
    IN DWORD   dwVal)
{
    HRESULT hres;
    PROPSPEC propspec;
    PROPVARIANT propvar;
    
    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = pid;
    
    propvar.vt = VT_UI4;
    propvar.ulVal = dwVal;
    
    hres = WriteMultiple(1, &propspec, &propvar, 0);
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Helper function that sets the word property

*/
STDMETHODIMP
URLProp::SetProp(
    IN PROPID  pid,
    IN WORD    wVal)
{
    HRESULT hres;
    PROPSPEC propspec;
    PROPVARIANT propvar;
    
    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = pid;
    
    propvar.vt = VT_UI2;
    propvar.uiVal = wVal;
    
    hres = WriteMultiple(1, &propspec, &propvar, 0);
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Helper function that sets the IStream* property

*/
STDMETHODIMP
URLProp::SetProp(
    IN PROPID  pid,
    IN IStream *pStream)
{
    HRESULT hres;
    PROPSPEC propspec;
    PROPVARIANT propvar;
    
    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = pid;
    
    propvar.vt = VT_STREAM;
    propvar.pStream = pStream;
    
    hres = WriteMultiple(1, &propspec, &propvar, 0);
    
    return hres;
}


STDMETHODIMP URLProp::IsDirty(void)
{
    return PropStg_IsDirty(m_hstg);
}


STDMETHODIMP URLProp::ReadMultiple(IN ULONG         cpspec,
                                   IN const PROPSPEC rgpropspec[],
                                   IN PROPVARIANT   rgpropvar[])
{
    HRESULT hres = PropStg_ReadMultiple(m_hstg, cpspec, rgpropspec, rgpropvar);
    
    if (SUCCEEDED(hres))
    {
        // Set the accessed time
        SYSTEMTIME st;
        
        GetSystemTime(&st);
        SystemTimeToFileTime(&st, &m_ftAccessed);
    }
    
    return hres;
}


STDMETHODIMP URLProp::WriteMultiple(IN ULONG         cpspec,
                                    IN const PROPSPEC rgpropspec[],
                                    IN const PROPVARIANT rgpropvar[],
                                    IN PROPID        propidFirst)
{
    HRESULT hres = PropStg_WriteMultiple(m_hstg, cpspec, rgpropspec, 
        rgpropvar, propidFirst);
    
    if (SUCCEEDED(hres))
    {
        // Set the modified time
        SYSTEMTIME st;
        
        GetSystemTime(&st);
        SystemTimeToFileTime(&st, &m_ftModified);
    }
    
    return hres;
}

STDMETHODIMP URLProp::DeleteMultiple(ULONG cpspec, const PROPSPEC rgpropspec[])
{
    return PropStg_DeleteMultiple(m_hstg, cpspec, rgpropspec);
}


STDMETHODIMP URLProp::ReadPropertyNames(ULONG cpropid, const PROPID rgpropid[], LPWSTR rgpwszName[])
{
    return E_NOTIMPL;
}

STDMETHODIMP URLProp::WritePropertyNames(ULONG cpropid, const PROPID rgpropid[], const LPWSTR rgpwszName[])
{
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IPropertyStorage::DeletePropertyNames method for URLProp

*/
STDMETHODIMP
URLProp::DeletePropertyNames(
    IN ULONG    cpropid,
    IN const PROPID rgpropid[])
{
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IPropertyStorage::SetClass method for URLProp

*/
STDMETHODIMP
URLProp::SetClass(
    IN REFCLSID rclsid)
{
    CopyMemory(&m_clsid, &rclsid, SIZEOF(m_clsid));
    
    return S_OK;
}


/*----------------------------------------------------------
Purpose: IPropertyStorage::Commit method for URLProp

*/
STDMETHODIMP
URLProp::Commit(
    IN DWORD dwFlags)
{
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IPropertyStorage::Revert method for URLProp

*/
STDMETHODIMP URLProp::Revert(void)
{
#ifdef DEBUG
    Dump();
#endif
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IPropertyStorage::Enum method for URLProp

*/
STDMETHODIMP URLProp::Enum(IEnumSTATPROPSTG ** ppenum)
{
    *ppenum = NULL;
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IPropertyStorage::Stat method for URLProp

*/
STDMETHODIMP
URLProp::Stat(
    IN STATPROPSETSTG * pstat)
{
    HRESULT hres = STG_E_INVALIDPARAMETER;

    if (IS_VALID_WRITE_PTR(pstat, STATPROPSETSTG))
    {
        pstat->fmtid = m_fmtid;
        pstat->clsid = m_clsid;
        pstat->grfFlags = m_grfFlags;
        pstat->mtime = m_ftModified;
        pstat->ctime = m_ftCreated;
        pstat->atime = m_ftAccessed;

        hres = S_OK;
    }
    return hres;
}


/*----------------------------------------------------------
Purpose: IPropertyStorage::SetTimes method for URLProp

*/
STDMETHODIMP
URLProp::SetTimes(
    IN const FILETIME * pftModified,        OPTIONAL
    IN const FILETIME * pftCreated,         OPTIONAL
    IN const FILETIME * pftAccessed)        OPTIONAL
{
    HRESULT hres;
    
    if (pftModified && !IS_VALID_READ_PTR(pftModified, FILETIME) ||
        pftCreated && !IS_VALID_READ_PTR(pftCreated, FILETIME) ||
        pftAccessed && !IS_VALID_READ_PTR(pftAccessed, FILETIME))
    {
        hres = STG_E_INVALIDPARAMETER;
    }
    else
    {
        if (pftModified)
            m_ftModified = *pftModified;
        
        if (pftCreated)
            m_ftCreated = *pftCreated;
        
        if (pftAccessed)
            m_ftAccessed = *pftAccessed;
        
        hres = S_OK;
    }
    
    return hres;
}

#ifdef DEBUG

STDMETHODIMP_(void) IntshcutProp::Dump(void)
{
    if (IsFlagSet(g_dwDumpFlags, DF_URLPROP))
    {
        TraceMsg(TF_ALWAYS, "  IntshcutProp obj: %s", m_szFile);
        URLProp::Dump();
    }
}

#endif


IntshcutProp::IntshcutProp(void)
{
    // Don't validate this until after construction.
    
    *m_szFile = 0;
    
    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcutProp));
}

IntshcutProp::~IntshcutProp(void)
{
    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcutProp));

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcutProp));
}


// (These are not related to PID_IS_*) 
#define IPROP_ICONINDEX     0 
#define IPROP_ICONFILE      1
#define IPROP_HOTKEY        2 
#define IPROP_WORKINGDIR    3
#define IPROP_SHOWCMD       4
#define IPROP_WHATSNEW      5     
#define IPROP_AUTHOR        6 
#define IPROP_DESC          7 
#define IPROP_COMMENT       8
#define IPROP_URL           9       // these two must be the last 
#define IPROP_SCHEME        10      //  in this list.  See LoadFromFile.
#define CPROP_INTSHCUT      11      // Count of properties 

// (we don't write the URL or the scheme in the massive write sweep)
#define CPROP_INTSHCUT_WRITE    (CPROP_INTSHCUT - 2)      

/*----------------------------------------------------------
Purpose: Load the basic property info like URL.

Returns: 
Cond:    --
*/
STDMETHODIMP IntshcutProp::LoadFromFile(LPCTSTR pszFile)
{
    HRESULT hres;
    LPWSTR pwszBuf;
    LPTSTR pszBuf;
    CHAR *pszTempBuf;
    static const PROPSPEC rgpropspec[CPROP_INTSHCUT] = 
    {
        // This must be initialized in the same order as how the
        // IPROP_* values were defined.
        { PRSPEC_PROPID, PID_IS_ICONINDEX },
        { PRSPEC_PROPID, PID_IS_ICONFILE },
        { PRSPEC_PROPID, PID_IS_HOTKEY },
        { PRSPEC_PROPID, PID_IS_WORKINGDIR },
        { PRSPEC_PROPID, PID_IS_SHOWCMD },
        { PRSPEC_PROPID, PID_IS_WHATSNEW },
        { PRSPEC_PROPID, PID_IS_AUTHOR },
        { PRSPEC_PROPID, PID_IS_DESCRIPTION },
        { PRSPEC_PROPID, PID_IS_COMMENT },
        { PRSPEC_PROPID, PID_IS_URL },
        { PRSPEC_PROPID, PID_IS_SCHEME },
    };
    PROPVARIANT rgpropvar[CPROP_INTSHCUT] = { 0 };
    
    ASSERT(pszFile);

    // try to allocate a temporary buffer, don't put on stack as this may be called
    // by 16 bit apps through the shellexecute thunk
    pszTempBuf = (CHAR*)LocalAlloc(LMEM_FIXED, INTERNET_MAX_URL_LENGTH * sizeof(CHAR));
    if (!pszTempBuf)
        return E_OUTOFMEMORY;

    if (!g_fRunningOnNT)
    {
        // Flush the cache first to encourage Win95 kernel to zero-out
        // its buffer.  Kernel GP-faults with hundreds of writes made to
        // ini files.
        WritePrivateProfileString(NULL, NULL, NULL, pszFile);
    }
    
    // Get the URL 
    hres = ReadURLFromFile(pszFile, c_szIntshcut, &pszBuf);
    if (S_OK == hres)
    {
        // Call this method because it does more work before
        // setting the property 
        SetURLProp(pszBuf, (IURL_SETURL_FL_GUESS_PROTOCOL | IURL_SETURL_FL_USE_DEFAULT_PROTOCOL));
        
        LocalFree(pszBuf);
        pszBuf = NULL;
    }
    
    // Get the IDList
    LPITEMIDLIST pidl = NULL;
    hres = ReadIDList(pszFile, &pidl);
    if (S_OK == hres)
    {
        // Call this method because it does more work before
        // setting the property 
        SetIDListProp(pidl);
        
        ILFree(pidl);
    }

#ifndef UNIX

    // Get icon location
    int nVal;
    hres = ReadIconLocation(pszFile, &pwszBuf, &nVal, pszTempBuf);
    if (S_OK == hres)
    {
        rgpropvar[IPROP_ICONFILE].vt = VT_LPWSTR;
        rgpropvar[IPROP_ICONFILE].pwszVal = pwszBuf;
        
        rgpropvar[IPROP_ICONINDEX].vt = VT_I4;
        rgpropvar[IPROP_ICONINDEX].lVal = nVal;
    }
    
    // Get the hotkey 
    WORD wHotkey;
    hres = ReadHotkey(pszFile, &wHotkey);
    if (S_OK == hres)
    {
        rgpropvar[IPROP_HOTKEY].vt = VT_UI2;
        rgpropvar[IPROP_HOTKEY].uiVal = wHotkey;
    }
    
    // Get the working directory 
    hres = ReadWorkingDirectory(pszFile, &pwszBuf);
    if (S_OK == hres)
    {
        rgpropvar[IPROP_WORKINGDIR].vt = VT_LPWSTR;
        rgpropvar[IPROP_WORKINGDIR].pwszVal = pwszBuf;
    }
    
    // Get the showcmd flag 
    hres = ReadShowCmd(pszFile, &nVal);
    rgpropvar[IPROP_SHOWCMD].vt = VT_I4;
    if (S_OK == hres)
        rgpropvar[IPROP_SHOWCMD].lVal = nVal;
    else
        rgpropvar[IPROP_SHOWCMD].lVal = SW_NORMAL;
    
    
    // Get the What's New bulletin 
    hres = ReadStringFromFile(pszFile, c_szIntshcut, ISHCUT_INISTRING_WHATSNEW, &pwszBuf, pszTempBuf);
    if (S_OK == hres)
    {
        rgpropvar[IPROP_WHATSNEW].vt = VT_LPWSTR;
        rgpropvar[IPROP_WHATSNEW].pwszVal = pwszBuf;
    }
    
    // Get the Author 
    hres = ReadStringFromFile(pszFile, c_szIntshcut, ISHCUT_INISTRING_AUTHOR, &pwszBuf, pszTempBuf);
    if (S_OK == hres)
    {
        rgpropvar[IPROP_AUTHOR].vt = VT_LPWSTR;
        rgpropvar[IPROP_AUTHOR].pwszVal = pwszBuf;
    }
    
    // Get the Description 
    hres = ReadStringFromFile(pszFile, c_szIntshcut, ISHCUT_INISTRING_DESC, &pwszBuf, pszTempBuf);
    if (S_OK == hres)
    {
        rgpropvar[IPROP_DESC].vt = VT_LPWSTR;
        rgpropvar[IPROP_DESC].pwszVal = pwszBuf;
    }
    
    // Get the Comment
    hres = ReadStringFromFile(pszFile, c_szIntshcut, ISHCUT_INISTRING_COMMENT, &pwszBuf, pszTempBuf);
    if (S_OK == hres)
    {
        rgpropvar[IPROP_COMMENT].vt = VT_LPWSTR;
        rgpropvar[IPROP_COMMENT].pwszVal = pwszBuf;
    }

#endif /* !UNIX */
    
    // Write it all out to our in-memory storage.  Note we're using 
    // CPROP_INTSHCUT_WRITE, which should be the size of the array minus the
    // url and scheme propids, since they were written separately 
    // above.
    hres = WriteMultiple(CPROP_INTSHCUT_WRITE, (PROPSPEC *)rgpropspec, rgpropvar, 0);
    if (SUCCEEDED(hres))
    {
        // Unmark *all* these properties, since we're initializing from
        // the file
        PropStg_DirtyMultiple(m_hstg, ARRAYSIZE(rgpropspec), rgpropspec, FALSE);
    }
    
    // Get the times.  We don't support the Accessed time for internet
    // shortcuts updating this field would cause the shortcut to be
    // constantly written to disk to record the Accessed time simply
    // when a property is read.  A huge perf hit!

    ZeroMemory(&m_ftAccessed, sizeof(m_ftAccessed));
    
    DWORD cbData = SIZEOF(m_ftModified);
    ReadBinaryFromFile(pszFile, c_szIntshcut, ISHCUT_INISTRING_MODIFIED, &m_ftModified, cbData);
    
    // Free up the buffers that we allocated 
    int cprops;
    PROPVARIANT * ppropvar;
    for (cprops = ARRAYSIZE(rgpropvar), ppropvar = rgpropvar; 0 < cprops; cprops--)
    {
        if (VT_LPWSTR == ppropvar->vt)
        {
            ASSERT(ppropvar->pwszVal);
            LocalFree(ppropvar->pwszVal);
            ppropvar->pwszVal = NULL;
        }
        ppropvar++;
    }

    LocalFree((HLOCAL)pszTempBuf);
    pszTempBuf = NULL;
    
    return hres;
}

STDMETHODIMP IntshcutProp::Init(void)
{
    return URLProp::Init();
}

STDMETHODIMP IntshcutProp::InitFromFile(LPCTSTR pszFile)
{
    // Initialize the in-memory property storage from the file
    // and database
    HRESULT hres = Init();
    if (SUCCEEDED(hres) && pszFile)
    {
        StrCpyN(m_szFile, pszFile, SIZECHARS(m_szFile));
        hres = LoadFromFile(m_szFile);
    }
    else
        m_szFile[0] = 0;
    
    return hres;
}


typedef struct
{
    LPTSTR pszFile;
} COMMITISDATA;

/*----------------------------------------------------------
Purpose: Commit the values for any known properties to the file

         Note this callback is called only for dirty values.

Returns: S_OK if alright
         S_FALSE to skip this value
         error to stop
  
*/
STDAPI CommitISProp(
    IN PROPID        propid,
    IN PROPVARIANT * ppropvar,
    IN LPARAM        lParam)
{
    HRESULT hres = S_OK;
    COMMITISDATA * pcd = (COMMITISDATA *)lParam;
    
    ASSERT(ppropvar);
    ASSERT(pcd);
    
    LPWSTR pwsz;
    USHORT uiVal;
    LONG lVal;
    IStream *pStream;
    
    switch (propid)
    {
    case PID_IS_URL:
    case PID_IS_ICONFILE:
    case PID_IS_WORKINGDIR:
    case PID_IS_WHATSNEW:
    case PID_IS_AUTHOR:
    case PID_IS_DESCRIPTION:
    case PID_IS_COMMENT:
        if (VT_LPWSTR == ppropvar->vt)
            pwsz = ppropvar->pwszVal;
        else
            pwsz = NULL;
        
        switch (propid)
        {
        case PID_IS_URL:
            hres = WriteGenericString(pcd->pszFile, c_szIntshcut, ISHCUT_INISTRING_URL, pwsz);
            break;
            
        case PID_IS_ICONFILE:
            hres = WriteIconFile(pcd->pszFile, pwsz);
            break;
            
        case PID_IS_WORKINGDIR:
            hres = WriteGenericString(pcd->pszFile, c_szIntshcut, ISHCUT_INISTRING_WORKINGDIR, pwsz);
            break;
            
        case PID_IS_WHATSNEW:
            hres = WriteGenericString(pcd->pszFile, c_szIntshcut, ISHCUT_INISTRING_WHATSNEW, pwsz);
            break;
            
        case PID_IS_AUTHOR:
            hres = WriteGenericString(pcd->pszFile, c_szIntshcut, ISHCUT_INISTRING_AUTHOR, pwsz);
            break;
            
        case PID_IS_DESCRIPTION:
            hres = WriteGenericString(pcd->pszFile, c_szIntshcut, ISHCUT_INISTRING_DESC, pwsz);
            break;
            
        case PID_IS_COMMENT:
            hres = WriteGenericString(pcd->pszFile, c_szIntshcut, ISHCUT_INISTRING_COMMENT, pwsz);
            break;
            
        default:
            ASSERT(0);      // should never get here
            break;
        }
        break;
        
        case PID_IS_ICONINDEX:
            if (VT_I4 == ppropvar->vt)
                hres = WriteIconIndex(pcd->pszFile, ppropvar->lVal);
            break;
            
        case PID_IS_HOTKEY:
            if (VT_UI2 == ppropvar->vt)
                uiVal = ppropvar->uiVal;
            else
                uiVal = 0;
            
            hres = WriteHotkey(pcd->pszFile, uiVal);
            break;
            
        case PID_IS_SHOWCMD:
            if (VT_I4 == ppropvar->vt)
                lVal = ppropvar->lVal;
            else
                lVal = SW_NORMAL;
            
            hres = WriteShowCmd(pcd->pszFile, lVal);
            break;
            
        case PID_IS_SCHEME:
            // Don't write this one out
            break;
            
        case PID_IS_IDLIST:
            if (VT_STREAM == ppropvar->vt)
                pStream = ppropvar->pStream;
            else
                pStream = NULL;
                
            hres = WriteIDList(pcd->pszFile, pStream);
            break;
                  
                  
        default:
            TraceMsg(TF_WARNING, "Don't know how to commit url property (%#lx)", propid);
            ASSERT(0);
            break;
    }
    
#ifdef DEBUG
    if (FAILED(hres))
        TraceMsg(TF_WARNING, "Failed to save url property (%#lx) to file %s", propid, pcd->pszFile);
#endif
  
    return hres;
}


/*----------------------------------------------------------
Purpose: IPropertyStorage::Commit method for URLProp

*/
STDMETHODIMP
IntshcutProp::Commit(
    IN DWORD dwFlags)
{
    HRESULT hres;
    COMMITISDATA cd;
    
    TraceMsg(TF_INTSHCUT, "Writing properties to \"%s\"", m_szFile);

    cd.pszFile = m_szFile;
    
    // Enumerate thru the dirty property values that get saved to the
    // file
    hres = PropStg_Enum(m_hstg, PSTGEF_DIRTY, CommitISProp, (LPARAM)&cd);
    
    if (SUCCEEDED(hres))
    {
        // Now mark everything clean 
        PropStg_DirtyAll(m_hstg, FALSE);

        // Save the times.  Don't write out the Accessed time for perf.
        // See LoadFromFile.
        EVAL(SUCCEEDED(WriteBinaryToFile(m_szFile, c_szIntshcut, ISHCUT_INISTRING_MODIFIED, &m_ftModified, 
                                         SIZEOF(m_ftModified))));
    }
    
#ifdef DEBUG
    Dump();
#endif
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Helper function to set the file name.

*/
STDMETHODIMP 
IntshcutProp::SetFileName(
    IN LPCTSTR pszFile)
{
    if(pszFile)
    {
        ASSERT(IS_VALID_STRING_PTR(pszFile, -1));
        StrCpyN(m_szFile, pszFile, SIZECHARS(m_szFile));
    }
    else
    {
        *m_szFile = TEXT('\0');;
    }

    return S_OK;
}



/*----------------------------------------------------------
Purpose: Helper function that sets the URL.

*/
STDMETHODIMP
IntshcutProp::SetIDListProp(
    LPCITEMIDLIST pcidl)
{
    HRESULT hres;
    IStream *pstmPidl;
    
    if (pcidl)
    {
        // ???
        // PERF: This loads OLE. Is this OK?
        
        hres = CreateStreamOnHGlobal(NULL, TRUE, &pstmPidl);
        if (SUCCEEDED(hres))
        {
            hres = ILSaveToStream(pstmPidl, pcidl);
            
            if (SUCCEEDED(hres))
                hres = SetProp(PID_IS_IDLIST, pstmPidl);

            pstmPidl->Release();
        }
    }
    else
    {
        hres = SetProp(PID_IS_IDLIST, NULL); 
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: Helper function that sets the URL.  This function
         optionally canonicalizes the string as well.

*/
STDMETHODIMP
IntshcutProp::SetURLProp(
    IN LPCTSTR pszURL,              OPTIONAL
    IN DWORD   dwFlags)
{
    HRESULT hres;

    // Warning this function can be called as part of shellexecute which can be
    // thunked up to by a 16 bit app, so be carefull what you put on stack...
    
    BOOL bChanged;

    struct tbufs
    {
        TCHAR szUrl[INTERNET_MAX_URL_LENGTH];
        TCHAR szUrlT[INTERNET_MAX_URL_LENGTH];
    };

    struct tbufs *ptbufs;

    ptbufs = (struct tbufs *)LocalAlloc(LMEM_FIXED, sizeof(struct tbufs));
    if (!ptbufs)
        return E_OUTOFMEMORY;
    
    hres = GetProp(PID_IS_URL, ptbufs->szUrl, INTERNET_MAX_URL_LENGTH);
    
    bChanged = !(( !pszURL && S_OK != hres) ||
        (pszURL && S_OK == hres && 0 == StrCmp(pszURL, ptbufs->szUrl)));
    
    hres = S_OK;
    if (bChanged)
    {
        if (NULL == pszURL)
        {
            hres = SetProp(PID_IS_URL, pszURL);
            if (S_OK == hres)
                hres = SetProp(PID_IS_SCHEME, URL_SCHEME_UNKNOWN);
        }
        else
        {
            DWORD dwFlagsT = UQF_CANONICALIZE;
            
            // Translate the URL 
            
            if (IsFlagSet(dwFlags, IURL_SETURL_FL_GUESS_PROTOCOL))
                SetFlag(dwFlagsT, UQF_GUESS_PROTOCOL);
            
            if (IsFlagSet(dwFlags, IURL_SETURL_FL_USE_DEFAULT_PROTOCOL))
                SetFlag(dwFlagsT, UQF_USE_DEFAULT_PROTOCOL);
            
            // Translate the URL 
            hres = IURLQualify(pszURL, dwFlagsT, ptbufs->szUrlT, NULL, NULL);
            
            if (SUCCEEDED(hres))
            {
                // Is the URL different after being translated? 
                bChanged = (0 != StrCmp(ptbufs->szUrlT, ptbufs->szUrl));
                
                hres = S_OK;
                if (bChanged)
                {
                    // Yes; validate and get the scheme
                    PARSEDURL pu;
                    
                    pu.cbSize = SIZEOF(pu);
                    hres = ParseURL(ptbufs->szUrlT, &pu);
                    
                    if (S_OK == hres)
                        hres = SetProp(PID_IS_URL, ptbufs->szUrlT);
                    
                    if (S_OK == hres)
                        hres = SetProp(PID_IS_SCHEME, (DWORD)pu.nScheme);
                }
            }
        }
    }

    LocalFree((HLOCAL)ptbufs);
    ptbufs = NULL;
    
    return hres;
}

/*----------------------------------------------------------
Purpose: Helper function that sets the string property

*/
STDMETHODIMP
IntshcutProp::SetProp(
    IN PROPID  pid,
    IN LPCTSTR psz)         OPTIONAL
{
    HRESULT hr;

    // WARNING:: this function gets called as part of ShellExecute which can be
    // called by 16 bit apps so don't put mondo strings on stack...
    LPCWSTR pszUrl = psz;
    LPWSTR pszTemp = NULL;

    // For URLs, we need to check for security spoofs
    if (PID_IS_URL == pid && psz && IsSpecialUrl((LPWSTR)psz)) //FEATURE: remove cast
    {
        SHStrDup(psz, &pszTemp);

        if (NULL != pszTemp)
        {
            // Unescape the url and look for a security context delimitor
            hr = WrapSpecialUrlFlat(pszTemp, lstrlen(pszTemp)+1);
            if (E_ACCESSDENIED == hr)
            {
                // Security delimitor found, so wack it off
                SHRemoveURLTurd(pszTemp);
                pszUrl = pszTemp;
            }
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }

    hr = super::SetProp(pid, pszUrl);

    if (pszTemp)
    {
        CoTaskMemFree(pszTemp);
    }
    return hr;
}

    
STDAPI CIntshcutProp_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppvOut)
{
    HRESULT hres;
    
    *ppvOut = NULL;
    
    if (punkOuter)
    {
        // No
        hres = CLASS_E_NOAGGREGATION;
    }
    else
    {
        IUnknown * piunk = (IUnknown *)(IPropertyStorage *)new IntshcutProp;
        if ( !piunk ) 
        {
            hres = E_OUTOFMEMORY;
        }
        else
        {
            hres = piunk->QueryInterface(riid, ppvOut);
            piunk->Release();
        }
    }
    
    return hres;        // S_OK or E_NOINTERFACE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\urltrack.cpp ===
/*-------------------------------------------------------*/
//Copyright (c) 1997  Microsoft Corporation
//
//Module Name: Url Tracking Log Interfaces
//
//    Urltrack.cpp
//
//
//Author:
//
//    Pei-Hwa Lin (peihwal)  19-March-97
//
//Environment:
//
//    User Mode - Win32
//
//Revision History:
//    5/13/97   due to cache container type change, allow
//              OPEN_ALWAYS when CreateFile
//    5/14/97   remove IsOnTracking, TRACK_ALL, unused code
/*-------------------------------------------------------*/

#include "priv.h"
#include <wininet.h>
#include "basesb.h"
#include "bindcb.h"
const WCHAR c_szPropURL[] = L"HREF";
const WCHAR c_szProptagName[] = L"Item";
const TCHAR c_szLogContainer[] = TEXT("Log");

#define MY_MAX_STRING_LEN           512



//---------------------------------------------------------------------------
//
// IUnknown interfaces
//
//---------------------------------------------------------------------------
HRESULT
CUrlTrackingStg :: QueryInterface(REFIID riid, PVOID *ppvObj)
{
    HRESULT hr = E_NOINTERFACE;


    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IUrlTrackingStg))
    {
        AddRef();
        *ppvObj = (LPVOID) SAFECAST(this, IUrlTrackingStg *);
        hr = S_OK;

    }

    return hr;
}


ULONG
CUrlTrackingStg :: AddRef(void)
{
    _cRef ++;
    return _cRef;
}

ULONG
CUrlTrackingStg :: Release(void)
{

    ASSERT(_cRef > 0);

    _cRef--;

    if (!_cRef)
    {
        //time to go bye bye
        delete this;
        return 0;
    }

    return _cRef;
}

//---------------------------------------------------------------------------
//
// C'tor/D'tor
//
//---------------------------------------------------------------------------
CUrlTrackingStg :: CUrlTrackingStg()
{

    _hFile = NULL;
    _pRecords = NULL;
    _lpPfx = NULL;
}

CUrlTrackingStg :: ~CUrlTrackingStg()
{
    // browser exit
    while (_pRecords)
    {
        OnUnload(_pRecords->pthisUrl);
    };

//    DeleteAllNode();    

    if (_lpPfx)
    {
        GlobalFree(_lpPfx);
        _lpPfx = NULL;
    }

    if (_hFile)
    {
        CloseHandle(_hFile);
        _hFile = NULL;
    }
}


//---------------------------------------------------------------------------
//
// Helper functions
//
//---------------------------------------------------------------------------
LRecord *
CUrlTrackingStg :: AddNode()
{
    LRecord* pTemp;
    LRecord* pNew = NULL;
    
    pNew = (LRecord *)LocalAlloc(LPTR, sizeof(LRecord));
    if (pNew == NULL)
        return NULL;
    
    pNew->pNext = NULL;
    if (_pRecords == NULL)
    {
        //special case for first node
        _pRecords = pNew;
    }
    else
    {
        for (pTemp = _pRecords; pTemp->pNext; pTemp = pTemp->pNext);
        pTemp->pNext = pNew;
    }
    
    return pNew;
}

void 
CUrlTrackingStg :: DeleteAllNode()
{
   
    do
    {
        DeleteFirstNode();
    }
    while (_pRecords);

    return;
}

void
CUrlTrackingStg :: DeleteFirstNode()
{
    LRecord *pTemp;

    if (!_pRecords)
        return;

    pTemp = _pRecords;
    _pRecords = pTemp->pNext;
    delete [] pTemp->pthisUrl;
    LocalFree(pTemp);
    pTemp = NULL;
    return;
}

void
CUrlTrackingStg :: DeleteCurrentNode(LRecord *pThis)
{
    LRecord *pPrev;
    
    if (_pRecords == pThis)
    {
        DeleteFirstNode();
        return;
    }

    pPrev = _pRecords;
    do
    {
        if (pPrev->pNext == pThis)
        {
            pPrev->pNext = pThis->pNext;
            delete [] pThis->pthisUrl;
            LocalFree(pThis);
            pThis = NULL;
            break;
        }
        pPrev = pPrev->pNext;
    }
    while (pPrev);

    return;
}

//
// return Current node by comparing url strings
//
LRecord*
CUrlTrackingStg :: FindCurrentNode
(
    IN  LPCTSTR       lpUrl
)
{
    LRecord* pThis = NULL;

    ASSERT(_pRecords);
    if (!_pRecords)                 // missed OnLoad
        return NULL;

    pThis = _pRecords;
    do
    {
        if (!StrCmpI(lpUrl, pThis->pthisUrl))
            break;

        pThis = pThis->pNext;
    }
    while (pThis);

    return pThis;
}

void
CUrlTrackingStg :: cleanup()
{
    return;
}


void
CUrlTrackingStg :: DetermineAppModule()
{
    TCHAR   szModule[MAX_PATH];
    LPTSTR  szExt;
        
    if (GetModuleFileName(NULL, szModule, MAX_PATH))        
    {
        szExt = PathFindExtension(szModule);
        TraceMsg(0, "tracking: AppModule %s", szModule);
            
        if (StrCmpI(szExt, TEXT(".SCR")) == 0)
            _fScreenSaver = TRUE;
        else
            _fScreenSaver = FALSE;
                
    }
    else
        _fScreenSaver = FALSE;

    _fModule = TRUE;
}
            
//---------------------------------------------------------------------------
//
// OnLoad(LPTSTR lpUrl, BRMODE context, BOOL fUseCache)
//      a new page is loaded
//      this function will remember time entering this page, context browsing
//      from and page URL string.
//      (lpUrl does NOT contain "track:" prefix)
//---------------------------------------------------------------------------
HRESULT
CUrlTrackingStg :: OnLoad
(
    IN  LPCTSTR    lpUrl,
    IN  BRMODE     ContextMode,
    IN  BOOL       fUseCache
)
{
    HRESULT     hr = E_OUTOFMEMORY;
    SYSTEMTIME  st;
    LRecord*    pNewNode = NULL;

    GetLocalTime(&st);

    pNewNode = AddNode();
    if (!pNewNode)
        return hr;

    int cch = lstrlen(lpUrl)+1;
    pNewNode->pthisUrl = (LPTSTR)LocalAlloc(LPTR, cch * sizeof(TCHAR));
    if (pNewNode->pthisUrl == NULL)
        return hr;

    // store log info
    StrCpyN(pNewNode->pthisUrl, lpUrl, cch);
    
    if (!_fModule)
        DetermineAppModule();

    // if it's from SS, the fullscreen flag will be set,
    // need to override ContextMode passed in
    if (_fScreenSaver)
        pNewNode->Context = BM_SCREENSAVER;
    else
        pNewNode->Context = (ContextMode > BM_THEATER) ? BM_UNKNOWN : ContextMode;

#if 0   //do not open till urlmon support wininet query flag
    DWORD dwOptions = 0;
    DWORD dwSize;
    WCHAR wszURL[MAX_URL_STRING];

    AnsiToUnicode(lpUrl, wszURL, ARRAYSIZE(wszURL));
    if (SUCCEEDED(CoInitialize(NULL)) && 
        SUCCEEDED(CoInternetQueryInfo(wszURL, (QUERYOPTION)INTERNET_OPTION_REQUEST_FLAGS, 
                            0, &dwOptions, sizeof(DWORD), &dwSize, 0)))
    {
        pNewNode->fuseCache = dwOptions & INTERNET_REQFLAG_FROM_CACHE;
        CoUninitialize();
    }
    else
#endif
    {
        BYTE cei[MAX_CACHE_ENTRY_INFO_SIZE];
        LPINTERNET_CACHE_ENTRY_INFO pcei = (LPINTERNET_CACHE_ENTRY_INFO)cei;
        DWORD       cbcei = MAX_CACHE_ENTRY_INFO_SIZE;

        if (GetUrlCacheEntryInfo(lpUrl, pcei, &cbcei))
            pNewNode->fuseCache = (pcei->dwHitRate - 1) ? TRUE : FALSE;     // off 1 by download
        else
            pNewNode->fuseCache = 0;

    }

    SystemTimeToFileTime(&st, &(pNewNode->ftIn));

    return S_OK; 
}



//---------------------------------------------------------------------------
//
// OnUnLoad(LPTSTR lpUrl)
//      current page is unloaded
//      1)find url cache entry and get file handle
//      2)calculate total time duration visiting this page
//      3)commit delta log string to file cache entry
//      (lpUrl contains "Tracking: " prefix)
//
//---------------------------------------------------------------------------
HRESULT
CUrlTrackingStg :: OnUnload
(
    IN  LPCTSTR   lpUrl
)
{
    HRESULT     hr = E_FAIL;
    LPTSTR       lpPfxUrl = NULL;
    LRecord*    pNode = NULL;;
    SYSTEMTIME  st;
    LPINTERNET_CACHE_ENTRY_INFO pce = NULL;
    TCHAR       lpFile[MAX_PATH];
    

    // 
    GetLocalTime(&st);

    pNode = FindCurrentNode(lpUrl);
    if (!pNode)
    {
        TraceMsg(DM_ERROR, "CUrlTrackingStg: OnUnload (cannot find internal tracking log");
        return hr;
    }

    //QueryCacheEntry() and OpenLogFile() can be combined in one if CacheAPI supports
    //WriteUrlCacheEntryStream()
    ConvertToPrefixedURL(lpUrl, &lpPfxUrl);
    if (!lpPfxUrl)
    {
        return E_OUTOFMEMORY;
    }

    pce = QueryCacheEntry(lpPfxUrl);
    if (!pce)
    {
        TraceMsg(DM_ERROR, "CUrlTrackingStg: OnUnload (cannot find url cache entry)");
        DeleteCurrentNode(pNode);
    
        // free pce
        GlobalFree(lpPfxUrl);
        lpPfxUrl = NULL;
        return hr;
    }

    // work around -- begin
    hr = WininetWorkAround(lpPfxUrl, pce->lpszLocalFileName, &lpFile[0]);
    if (FAILED(hr))
    {
        TraceMsg(DM_ERROR, "CUrlTrackingStg: OnUnload (failed to work around wininet)");
        DeleteCurrentNode(pNode);
        if (_hFile)
        {
            CloseHandle(_hFile);
            _hFile = NULL;
        }
        GlobalFree(lpPfxUrl);
        lpPfxUrl = NULL;
        return hr;
    }
    
    hr = UpdateLogFile(pNode, &st);

    // commit change to cache
    if(SUCCEEDED(hr))
    {
        hr = (CommitUrlCacheEntry(lpPfxUrl, 
                lpFile,    //
                pce->ExpireTime,                    //ExpireTime
                pce->LastModifiedTime,              //LastModifiedTime
                pce->CacheEntryType,
                NULL,                               //lpHeaderInfo
                0,                                  //dwHeaderSize
                NULL,                               //lpszFileExtension
                0) ) ?                              //reserved
                S_OK : E_FAIL;
    }
    
    // work around -- end

    DeleteCurrentNode(pNode);
    
    // free pce
    GlobalFree(pce);
    pce = NULL;

    GlobalFree(lpPfxUrl);
    lpPfxUrl = NULL;

    return hr;
}

//---------------------------------------------------------------------------
// 
// Cache helper funcitons
// This is a workaround for Wininet cache
// Later when we commit change to URL cache will fail if localFile size is changed
//  [IN] lpszSourceUrlName and lpszLocalFileName remain the same when calling 
//       this routine
//  [OUT] new local file name 
//
//---------------------------------------------------------------------------
HRESULT CUrlTrackingStg :: WininetWorkAround(LPCTSTR lpszUrl, LPCTSTR lpOldFile, LPTSTR lpFile)
{
    HRESULT  hr = E_FAIL;

    ASSERT(!_hFile);

    if (!CreateUrlCacheEntry(lpszUrl, 512, TEXT("log"), lpFile, 0))
        return E_FAIL;
    
    if (lpOldFile)
    {
        if (!CopyFile(lpOldFile, lpFile, FALSE))
            return E_FAIL;

        DeleteFile(lpOldFile);
    }

    _hFile = OpenLogFile(lpFile);

	if (_hFile != INVALID_HANDLE_VALUE)
		_hFile = NULL;

    return (_hFile) ? S_OK : E_FAIL;        
}

LPINTERNET_CACHE_ENTRY_INFO
CUrlTrackingStg :: QueryCacheEntry
(
    IN  LPCTSTR     lpUrl
)
{
    // get cache entry info
    LPINTERNET_CACHE_ENTRY_INFO       lpCE = NULL;
    DWORD    dwEntrySize;
    BOOL     bret = FALSE;

    lpCE = (LPINTERNET_CACHE_ENTRY_INFO)GlobalAlloc(LPTR, MAX_CACHE_ENTRY_INFO_SIZE);
    if (lpCE)
    {
        dwEntrySize = MAX_CACHE_ENTRY_INFO_SIZE;

        while (!(bret = GetUrlCacheEntryInfo(lpUrl, lpCE, &dwEntrySize)))
        {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                GlobalFree(lpCE);

                lpCE = (LPINTERNET_CACHE_ENTRY_INFO)GlobalAlloc(LPTR, dwEntrySize);
                if (!lpCE)
                    break;
            }
            else
                break;
        }
    }

    if (!bret && lpCE)
    {
        GlobalFree(lpCE);
        lpCE = NULL;
        SetLastError(ERROR_FILE_NOT_FOUND);
    }

    return lpCE;

}


//---------------------------------------------------------------------------
// 
// File helper funcitons
//
//---------------------------------------------------------------------------

//
// 1)open log file 
// 2)move file pointer to end of file
//
HANDLE
CUrlTrackingStg :: OpenLogFile
(
    IN LPCTSTR  lpFileName
)
{
    HANDLE hFile = NULL;
    
    hFile = CreateFile(lpFileName,
            GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,
            OPEN_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,  // | FILE_FLAG_SEQUENTIAL_SCAN,  
            NULL);
    
    if (hFile == INVALID_HANDLE_VALUE)
        return NULL;        

    return hFile;
    
}

const TCHAR c_szLogFormat[] = TEXT("hh':'mm':'ss");
const LPTSTR c_szMode[] = { TEXT("N"),       // normal browsing
                            TEXT("S"),       // screen saver
                            TEXT("D"),       // desktop component
                            TEXT("T"),       // theater mode
                            TEXT("U"),       // unknown
                          };     

HRESULT
CUrlTrackingStg :: UpdateLogFile
(
    IN LRecord*     pNode,
    IN SYSTEMTIME*  pst
)
{
    FILETIME    ftOut;
    DWORD       dwWritten= 0;
    HRESULT     hr = E_FAIL;
    ULARGE_INTEGER ulIn, ulOut, ulTotal;

    ASSERT(_hFile);
    
    // calculate delta of time
    SystemTimeToFileTime(pst, &ftOut);

    // #34829: use 64-bit calculation
	ulIn.LowPart = pNode->ftIn.dwLowDateTime;
	ulIn.HighPart = pNode->ftIn.dwHighDateTime;
	ulOut.LowPart = ftOut.dwLowDateTime;
	ulOut.HighPart = ftOut.dwHighDateTime;
	QUAD_PART(ulTotal) = QUAD_PART(ulOut) - QUAD_PART(ulIn);
    
    ftOut.dwLowDateTime = ulTotal.LowPart;
    ftOut.dwHighDateTime = ulTotal.HighPart;

    // log string: timeEnter+Duration
    SYSTEMTIME  stOut, stIn;
    TCHAR   lpLogString[MY_MAX_STRING_LEN];
    TCHAR   pTimeIn[10], pTimeOut[10];
    
    FileTimeToSystemTime(&ftOut, &stOut);
    FileTimeToSystemTime(&(pNode->ftIn), &stIn);
    
    GetTimeFormat(LOCALE_SYSTEM_DEFAULT, TIME_FORCE24HOURFORMAT, &stIn, c_szLogFormat, pTimeIn, 10);
    GetTimeFormat(LOCALE_SYSTEM_DEFAULT, TIME_FORCE24HOURFORMAT, &stOut, c_szLogFormat, pTimeOut, 10);
    // #34832: add Date in logs
    // #28266: add LFCR in logs
    lpLogString[0] = '\0';
    wnsprintf(lpLogString, ARRAYSIZE(lpLogString), TEXT("%s %d %.2d-%.2d-%d %s %s\r\n"), 
                                c_szMode[pNode->Context], 
                                pNode->fuseCache, 
                                stIn.wMonth, stIn.wDay, stIn.wYear,
                                pTimeIn, pTimeOut);
    
    // move file pointer to end
    if (0xFFFFFFFF == SetFilePointer(_hFile, 0, 0, FILE_END))
    {
        CloseHandle(_hFile);
        _hFile = NULL;
        return hr;
    }
    
    // write ANSI string to file
    char szLogInfo[MY_MAX_STRING_LEN];

    SHTCharToAnsi(lpLogString, szLogInfo, ARRAYSIZE(szLogInfo));
    hr = (WriteFile(_hFile, szLogInfo, lstrlenA(szLogInfo), &dwWritten, NULL)) ?
             S_OK : E_FAIL;
       
    CloseHandle(_hFile);
    _hFile = NULL;
    return hr;  

}

//-----------------------------------------------------------------------------
//
// ReadTrackingPrefix
//
// read prefix string from registry
//-----------------------------------------------------------------------------
void
CUrlTrackingStg :: ReadTrackingPrefix(void)
{
    DWORD   cbPfx = 0;
    struct {
        INTERNET_CACHE_CONTAINER_INFO cInfo;
        TCHAR  szBuffer[MAX_PATH+MAX_PATH];
    } ContainerInfo;
    DWORD   dwModified, dwContainer;
    HANDLE  hEnum;
  
    dwContainer = sizeof(ContainerInfo);
    hEnum = FindFirstUrlCacheContainer(&dwModified,
                                       &ContainerInfo.cInfo,
                                       &dwContainer,
                                       0);

    if (hEnum)
    {

        for (;;)
        {
            if (!StrCmpI(ContainerInfo.cInfo.lpszName, c_szLogContainer))
            {
                DWORD cch = lstrlen(ContainerInfo.cInfo.lpszCachePrefix)+1;
                ASSERT(ContainerInfo.cInfo.lpszCachePrefix[0]);

                _lpPfx = (LPTSTR)GlobalAlloc(LPTR, cch * sizeof(TCHAR));
                if (!_lpPfx)
                    SetLastError(ERROR_OUTOFMEMORY);

                StrCpyN(_lpPfx, ContainerInfo.cInfo.lpszCachePrefix, cch);
                break;
            }

            dwContainer = sizeof(ContainerInfo);
            if (!FindNextUrlCacheContainer(hEnum, &ContainerInfo.cInfo, &dwContainer))
            {
                if (GetLastError() == ERROR_NO_MORE_ITEMS)
                    break;
            }

        }

        FindCloseUrlCache(hEnum);
    }
}


// caller must free lplpPrefixedUrl
BOOL 
CUrlTrackingStg :: ConvertToPrefixedURL(LPCTSTR lpszUrl, LPTSTR *lplpPrefixedUrl)
{
    BOOL    bret = FALSE;

    ASSERT(lpszUrl);
    if (!lpszUrl)
        return bret;

    //ASSERT(lplpPrefixedUrl);

    if (!_lpPfx)
        ReadTrackingPrefix();
    
    if (_lpPfx)
    {
        int len = lstrlen(lpszUrl) + lstrlen(_lpPfx) + 1;
        
        *lplpPrefixedUrl = (LPTSTR)GlobalAlloc(LPTR, len * sizeof(TCHAR));
        if (*lplpPrefixedUrl)
        {
            wnsprintf(*lplpPrefixedUrl, len, TEXT("%s%s"), _lpPfx, lpszUrl);
            bret = TRUE;
        }
    }

    return bret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\utilmenu.h ===
#ifndef _UTILMENU_H_
#define _UTILMENU_H_

// 
//  Menu utility functions
//

HRESULT CreateMenuBandFrame(IMenuPopup ** ppmp);

#endif // _UTILMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\wvtp.h ===
#ifdef __cplusplus

#include "capi.h"

// WinVerifyTrust delay load modelled on shell's urlmonp.h

#define DELAY_LOAD_WVT

class Cwvt
{
    public:
#ifdef DELAY_LOAD_WVT
#define DELAYWVTAPI(_fn, _args, _nargs) \
    HRESULT _fn _args { \
        HRESULT hres = Init(); \
        if (SUCCEEDED(hres)) { \
            hres = _pfn##_fn _nargs; \
        } \
        return hres;    } \
    HRESULT (STDAPICALLTYPE* _pfn##_fn) _args;

    HRESULT     Init(void);
    Cwvt();
    ~Cwvt();

    BOOL    m_fInited;
    HMODULE m_hMod;
#else
#define DELAYWVTAPI(_fn, _args, _nargs) \
    HRESULT _fn _args { \
            HRESULT hr = ::#_fn _nargs; \
            }

#endif

    private:
    DELAYWVTAPI(WinVerifyTrust,
    (HWND hwnd, GUID * ActionID, LPVOID ActionData),
    (hwnd, ActionID, ActionData));

    public:
    HRESULT VerifyTrust(HANDLE hFile, HWND hWnd, LPCWSTR szStatusText);

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\winlist.cpp ===
//--------------------------------------------------------------------------
// Manage the windows list, such that we can get the IDispatch for each of
// the shell windows to be marshalled to different processes
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Includes...
#include "priv.h"
#include "sccls.h"
#include <varutil.h>
#include "winlist.h"
#include "iedde.h"

#define DM_WINLIST  0

void IEInitializeClassFactoryObject(IUnknown* punkAuto);
void IERevokeClassFactoryObject(void);

class CShellWindowListCF : public IClassFactory
{
public:
    // IUnKnown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IClassFactory
    STDMETHODIMP CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObject);
    STDMETHODIMP LockServer(BOOL fLock);

    // constructor
    CShellWindowListCF();
    BOOL Init(void);

protected:
    ~CShellWindowListCF();

    // locals

    LONG            _cRef;
    IShellWindows    *_pswWinList;
};

DWORD g_dwWinListCFRegister = 0;
DWORD g_fWinListRegistered = FALSE;     // Only used in browser only mode...
IShellWindows *g_pswWinList = NULL;

// Function to get called by the tray to create the global window list and register
// it with the system

//=================================== Class Factory implemention ========================
CShellWindowListCF::CShellWindowListCF()
{
    _cRef = 1;
    DllAddRef();
}

BOOL CShellWindowListCF::Init()
{
    HRESULT hr = CSDWindows_CreateInstance(&_pswWinList);
    g_pswWinList = _pswWinList;

    // First see if there already is one defined...

    if (FAILED(hr))
    {
        TraceMsg(DM_WINLIST, "WinList_Init CoCreateInstance Failed: %x", hr);
        return FALSE;
    }

    // And register our class factory with the system...
    hr = CoRegisterClassObject(CLSID_ShellWindows, this,
                                 CLSCTX_LOCAL_SERVER | CLSCTX_INPROC_SERVER,
                                 REGCLS_MULTIPLEUSE, &g_dwWinListCFRegister);

    //  this call governs when we will call CoRevoke on the CF
    if (SUCCEEDED(hr) && g_pswWinList)
        g_pswWinList->ProcessAttachDetach(TRUE);

    // Create an instance of the underlying window list class...
    TraceMsg(DM_WINLIST, "WinList_Init CoRegisterClass: %x", hr);

    return SUCCEEDED(hr);
}

CShellWindowListCF::~CShellWindowListCF()
{
    if (_pswWinList)
    {
        g_pswWinList = NULL;
        _pswWinList->Release();
    }
    DllRelease();
}

STDMETHODIMP CShellWindowListCF::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = { 
        QITABENT(CShellWindowListCF, IClassFactory), // IID_IClassFactory
        { 0 }, 
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CShellWindowListCF::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CShellWindowListCF::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CShellWindowListCF::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    // aggregation checking is done in class factory
    // For now simply use our QueryService to get the dispatch.
    // this will do all of the things to create it and the like.
    if (!_pswWinList) 
    {
        ASSERT(0);
        return E_FAIL;
    }
    return _pswWinList->QueryInterface(riid, ppvObj);
}

STDMETHODIMP CShellWindowListCF::LockServer(BOOL fLock)
{
    return S_OK;    // we don't do anything with this...
}

// As this is marshalled over to the main shell process hopefully this will take care of
// most of the serialization problems.  Probably still need a way to handle the case better
// where a window is coming up at the same time the last one is going down...
STDAPI CWinListShellProc_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    *ppunk = NULL;
    if (g_dwWinListCFRegister)
        return CO_E_OBJISREG;

    CShellWindowListCF *pswWinList = new CShellWindowListCF;
    if (pswWinList)
    {
        pswWinList->Init(); // tell it to initialize
        *ppunk = SAFECAST(pswWinList, IUnknown *);
        return S_OK;
    }
    return E_OUTOFMEMORY;
}


BOOL WinList_Init(void)
{
    // Create our clas factory to register out there...
    TraceMsg(DM_WINLIST, "WinList_Init called");

    //
    //  If this is not a browser-only install. Register the class factory
    // object now with no instance. Otherwise, do it when the first instance
    // is created (see shbrowse.cpp).
    //
    if (!g_fBrowserOnlyProcess)
    {
        //
        //  First, register the class factory object for CLSID_InternetExplorer.
        // Note that we pass NULL indicating that subsequent CreateInstance
        // should simply create a new instance.
        //
        IEInitializeClassFactoryObject(NULL);

        CShellWindowListCF *pswWinList = new CShellWindowListCF;
        if (pswWinList)
        {
            BOOL fRetVal = pswWinList->Init(); // tell it to initialize
            pswWinList->Release(); // Release our handle hopefully init registered

            //
            // Initialize IEDDE.
            //
            if (!IsBrowseNewProcessAndExplorer())
                IEDDE_Initialize();

            return fRetVal;
        }
    }
    else
    {
        //
        // Initialize IEDDE. - Done before cocreate below for timing issues
        //
        IEDDE_Initialize();

        // All of the main processing moved to first call to WinList_GetShellWindows
        // as the creating of OLE object across processes messed up DDE timing.

        return TRUE;
    }

    return FALSE;
}

#ifdef UNIX
HRESULT CoCreateShellWindows(REFCLSID rclsid, IUnknown *pUnkOuter, DWORD dwClsContext, REFIID riid, void **ppv)
{
    HRESULT hr;

    if (!g_pswWinList)
    {
        hr = CSDWindows_CreateInstance(&g_pswWinList);

        if (FAILED(hr))
        {
            return E_FAIL;
        }
    }

    hr = g_pswWinList->QueryInterface(riid, ppv);
    if (SUCCEEDED(hr))
    {
        g_dwWinListCFRegister = 1;
    }

    return hr;
}
#endif

// Helper function to get the ShellWindows Object

IShellWindows* WinList_GetShellWindows(BOOL fForceMarshalled)
{
    IShellWindows *psw;

    if (fForceMarshalled)
        psw = NULL;
    else
        psw = g_pswWinList;

    if (psw) 
    {
        // Optimize the inter-thread case by using the global WinList,
        // this makes opening folders much faster.
        psw->AddRef();
    } 
    else 
    {
        SHCheckRegistry();

#ifndef NO_RPCSS_ON_UNIX
        HRESULT hr = CoCreateInstance(CLSID_ShellWindows, NULL,
                         CLSCTX_LOCAL_SERVER | CLSCTX_INPROC_SERVER,
                         IID_PPV_ARG(IShellWindows,  &psw));
#else
        HRESULT hr = CoCreateShellWindows(CLSID_ShellWindows, NULL,
                         CLSCTX_LOCAL_SERVER | CLSCTX_INPROC_SERVER,
                         IID_PPV_ARG(IShellWindows,  &psw));
#endif

        if ( (g_fBrowserOnlyProcess || !IsInternetExplorerApp()) && !g_fWinListRegistered)
        {
            // If it failed and we are not funning in integrated mode, and this is the
            // first time for this process, we should then register the Window List with
            // the shell process.  We moved that from WinList_Init as that caused us to
            // do interprocess send/post messages to early which caused DDE to break...
            g_fWinListRegistered = TRUE;    // only call once
            if (FAILED(hr))
            {
                SHLoadInProc(CLSID_WinListShellProc);

                hr = CoCreateInstance(CLSID_ShellWindows, NULL,
                                 CLSCTX_LOCAL_SERVER | CLSCTX_INPROC_SERVER,
                                 IID_PPV_ARG(IShellWindows,  &psw));
            }

            if (psw)
            {
                psw->ProcessAttachDetach(TRUE);
            }
        }

        // hr == REGDB_E_CLASSNOTREG when the shell process isn't running.
        // hr == RPC_E_CANTCALLOUT_ININPUTSYNCCALL happens durring DDE launch of IE.
        // should investigate, but removing assert for IE5 ship.
        if (!(SUCCEEDED(hr) || hr == REGDB_E_CLASSNOTREG || hr == RPC_E_CANTCALLOUT_ININPUTSYNCCALL))
        {
            TraceMsg(TF_WARNING, 
                     "WinList_GetShellWindows CoCreateInst(CLSID_ShellWindows) failed %x", hr);
        }
    }

    return psw;
}


// Function to terminate our use of the window list.
void WinList_Terminate(void)
{
    // Lets release everything in a thread safe way...
    TraceMsg(DM_WINLIST, "WinList_Terminate called");

    IEDDE_Uninitialize();

    // Release our usage of the object to allow the system to clean it up
    if (!g_fBrowserOnlyProcess)
    {
        //  this is the explorer process, and we control the vertical

        if (g_dwWinListCFRegister) {
            IShellWindows* psw = WinList_GetShellWindows(FALSE);
            if (psw)
            {
#ifdef DEBUG
                long cwindow = -1;
                psw->get_Count(&cwindow);
                //ASSERT(cwindow==0);
                if (cwindow != 0)
                    TraceMsg(DM_ERROR, "wl_t: cwindow=%d (!=0)", cwindow);
#endif
                psw->ProcessAttachDetach(FALSE);
                psw->Release();
            }

            //  the processattachdetach() should kill the CF in our process
            if (g_dwWinListCFRegister != 0)
                TraceMsg(DM_ERROR, "wl_t: g_dwWinListCFRegister=%d (!=0)", g_dwWinListCFRegister);

        }

        IERevokeClassFactoryObject();
        CUrlHistory_CleanUp();
    }
    else
    {
        if (g_fWinListRegistered)
        {
            // only do this if we actually registered...
            IShellWindows* psw = WinList_GetShellWindows(TRUE);
            if (psw)
            {
                psw->ProcessAttachDetach(FALSE);    // Tell it we are going away...
                psw->Release();
            }
        }
    }

#ifdef UNIX
    if (g_pswWinList)
    {
        g_pswWinList->Release();
    }
#endif
}

//  chrisfra 10/17/96 - mike schmidt needs to look at why delayed
//  register causes death in OleUnitialize accessing freed vtable
//  in winlist, under ifdef, i've also made WinList_GetShellWindows ignore
//  BOOLEAN parameter

STDAPI WinList_Revoke(long dwRegister)
{
#ifndef DELAY_REGISTER
    IShellWindows* psw = WinList_GetShellWindows(TRUE);
#else
    IShellWindows* psw = WinList_GetShellWindows(FALSE);
#endif
    HRESULT hr = E_FAIL;
    TraceMsg(DM_WINLIST, "WinList_Reevoke called on %x", dwRegister);
    if (psw)
    {
        hr = psw->Revoke((long)dwRegister);
        if (FAILED(hr))
        {
            TraceMsg(TF_WARNING, 
                     "WinList_Revoke(%x) failed. hresult = %x", dwRegister, hr);
        }
        psw->Release();
    }

    return hr;
}

STDAPI WinList_NotifyNewLocation(IShellWindows* psw, long dwRegister, LPCITEMIDLIST pidl)
{
    HRESULT hr = E_UNEXPECTED;
    if (pidl) 
    {
        VARIANT var;
        hr = InitVariantFromIDList(&var, pidl);
        if (SUCCEEDED(hr)) 
        {
            hr = psw->OnNavigate(dwRegister, &var);
            VariantClearLazy(&var);
        } 
    }
    return hr;
}

// Register with the window list that we have a pidl that we are starting up.

STDAPI WinList_RegisterPending(DWORD dwThread, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlRoot, long *pdwRegister)
{
    HRESULT hr = E_UNEXPECTED;
    ASSERT(!pidlRoot);
    if (pidl)
    {
        IShellWindows* psw = WinList_GetShellWindows(FALSE);
        if (psw)
        {
            VARIANT var;
            hr = InitVariantFromIDList(&var, pidl);
            if (SUCCEEDED(hr))
            {
                hr = psw->RegisterPending(dwThread, &var, PVAREMPTY, SWC_BROWSER, pdwRegister);
                VariantClearLazy(&var);
            }
        }
    }
    return hr;
}

/*
 * PERFORMANCE note - getting back the automation object (ppauto) is really
 * expensive due to the marshalling overhead.  Don't query for it unless you
 * absolutely need it!
 */

STDAPI WinList_FindFolderWindow(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlRoot, HWND *phwnd, IWebBrowserApp **ppauto)
{
    HRESULT hr = E_UNEXPECTED;
    ASSERT(!pidlRoot);

    if (ppauto)
        *ppauto = NULL;
    if (phwnd)
        *phwnd = NULL;

    if (pidl) 
    {
        // Try a cached psw if we don't need ppauto
        IShellWindows* psw = WinList_GetShellWindows(ppauto != NULL);
        if (psw)
        {
            VARIANT var;
            hr = InitVariantFromIDList(&var, pidl);
            if (SUCCEEDED(hr)) 
            {
                IDispatch* pdisp = NULL;
                hr = psw->FindWindowSW(&var, PVAREMPTY, SWC_BROWSER, (long *)phwnd,
                        ppauto ? (SWFO_NEEDDISPATCH | SWFO_INCLUDEPENDING) : SWFO_INCLUDEPENDING,
                        &pdisp);
                if (pdisp) 
                {
                    // if this fails it's because we are inside SendMessage loop and ole doesn't like it
                    if (ppauto)
                        hr = pdisp->QueryInterface(IID_PPV_ARG(IWebBrowserApp, ppauto));
                    pdisp->Release();
                }
                VariantClearLazy(&var);
            }
            psw->Release();
        }
    }
    return hr;
}

// Support for Being able to open a folder and get it's idispatch...
//
class CWaitForWindow
{
public:
    ULONG AddRef(void);
    ULONG Release(void);

    BOOL Init(IShellWindows *psw, LPCITEMIDLIST pidl, DWORD dwPending);
    void CleanUp(void);
    HRESULT WaitForWindowToOpen(DWORD dwTimeout);

    CWaitForWindow(void);

private:
    ~CWaitForWindow(void);
    // internal class to watch for events...
    class CWindowEvents : public DShellWindowsEvents
    {
    public:

        // IUnknown
        STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj);
        STDMETHODIMP_(ULONG) AddRef(void) ;
        STDMETHODIMP_(ULONG) Release(void);

        // IDispatch
        STDMETHOD(GetTypeInfoCount)(THIS_ UINT * pctinfo);
        STDMETHOD(GetTypeInfo)(THIS_ UINT itinfo, LCID lcid, ITypeInfo * * pptinfo);
        STDMETHOD(GetIDsOfNames)(THIS_ REFIID riid, OLECHAR * * rgszNames,
            UINT cNames, LCID lcid, DISPID * rgdispid);
        STDMETHOD(Invoke)(THIS_ DISPID dispidMember, REFIID riid,
            LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult,
            EXCEPINFO * pexcepinfo, UINT * puArgErr);

    } m_EventHandler;

    friend class CWindowEvents;

    LONG m_cRef;
    DWORD m_dwCookie;
    IShellWindows *m_psw;
    IConnectionPoint *m_picp;
    DWORD m_dwPending;
    LPITEMIDLIST m_pidl;
    HANDLE m_hevent;
    BOOL m_fAdvised;
};


ULONG CWaitForWindow::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

ULONG CWaitForWindow::Release(void)
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;
    delete this;
    return 0;
}

CWaitForWindow::CWaitForWindow(void) : m_cRef(1)
{
    ASSERT(m_psw == NULL);
    ASSERT(m_picp == NULL);
    ASSERT(m_hevent == NULL);
    ASSERT(m_dwCookie == 0);
    ASSERT(m_fAdvised == FALSE);
}

CWaitForWindow::~CWaitForWindow(void)
{
    ATOMICRELEASE(m_psw);

    CleanUp();

    if (m_hevent)
        CloseHandle(m_hevent);

    if (m_pidl)
        ILFree(m_pidl);
}

BOOL CWaitForWindow::Init(IShellWindows *psw, LPCITEMIDLIST pidl, DWORD dwPending)
{
    // First try to create an event object
    m_hevent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!m_hevent)
        return FALSE;

    // We do not have a window or it is pending...
    // first lets setup that we want to be notified of new windows.
    if (FAILED(ConnectToConnectionPoint(SAFECAST(&m_EventHandler, IDispatch*), DIID_DShellWindowsEvents, TRUE, psw, &m_dwCookie, &m_picp)))
        return FALSE;

    // Save away passed in stuff that we care about.
    m_psw = psw;
    psw->AddRef();
    m_pidl = ILClone(pidl);
    m_dwPending = dwPending;

    return TRUE;
}

void CWaitForWindow::CleanUp(void)
{
    // Don't need to listen anmore.
    if (m_dwCookie)
    {
        m_picp->Unadvise(m_dwCookie);
        m_dwCookie = 0;
    }

    ATOMICRELEASE(m_picp);
}

HRESULT CWaitForWindow::WaitForWindowToOpen(DWORD dwTimeOut)
{
    if (!m_hevent || !m_dwCookie)
        return E_FAIL;

    ENTERCRITICAL;

    if (!m_fAdvised)
        ResetEvent(m_hevent);

    LEAVECRITICAL;

    DWORD dwStart = GetTickCount();
    DWORD dwWait = dwTimeOut;
    DWORD dwWaitResult;

    do
    {
        dwWaitResult = MsgWaitForMultipleObjects(1, &m_hevent, FALSE, // fWaitAll, wait for any one
                                                 dwWait, QS_ALLINPUT);

        // Check if we are signaled for a send message.
        if (dwWaitResult != WAIT_OBJECT_0 + 1)
        {
            break;  // No. Break out of the loop.
        }

        // We may need to dispatch stuff here.
        MSG msg;
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

        // than MSEC_MAXWAIT if we wait more than that.
        dwWait = dwStart+dwTimeOut - GetTickCount();

    } while (dwWait <= dwTimeOut);

    BOOL fAdvised;
    {
        ENTERCRITICAL;
    
        fAdvised = m_fAdvised;
        m_fAdvised = FALSE;
    
        LEAVECRITICAL;
    }

    return fAdvised ? S_OK : E_FAIL;
}

STDMETHODIMP CWaitForWindow::CWindowEvents::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = { 
        QITABENTMULTI2(CWaitForWindow::CWindowEvents, DIID_DShellWindowsEvents, DShellWindowsEvents),
        QITABENTMULTI(CWaitForWindow::CWindowEvents, IDispatch, DShellWindowsEvents),
        { 0 }, 
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CWaitForWindow::CWindowEvents::AddRef(void)
{
    CWaitForWindow* pdfwait = IToClass(CWaitForWindow, m_EventHandler, this);
    return pdfwait->AddRef();
}

ULONG CWaitForWindow::CWindowEvents::Release(void)
{
    CWaitForWindow* pdfwait = IToClass(CWaitForWindow, m_EventHandler, this);
    return pdfwait->Release();
}

HRESULT CWaitForWindow::CWindowEvents::GetTypeInfoCount(UINT *pctinfo)
{
    return E_NOTIMPL;
}

HRESULT CWaitForWindow::CWindowEvents::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    return E_NOTIMPL;
}

HRESULT CWaitForWindow::CWindowEvents::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
{
    return E_NOTIMPL;
}


HRESULT CWaitForWindow::CWindowEvents::Invoke(DISPID dispid, REFIID riid,
    LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult,
    EXCEPINFO * pexcepinfo, UINT * puArgErr)
{
    CWaitForWindow* pdfwait = IToClass(CWaitForWindow, m_EventHandler, this);

    if (dispid == DISPID_WINDOWREGISTERED)
    {
        ENTERCRITICAL;
        
        // Signal the event
        pdfwait->m_fAdvised = TRUE;
        ::SetEvent(pdfwait->m_hevent);
        
        LEAVECRITICAL;
    }

    return S_OK;
}

// WARNING:: this assumes not rooted
STDAPI SHGetIDispatchForFolder(LPCITEMIDLIST pidl, IWebBrowserApp **ppauto)
{
    HRESULT hr = E_UNEXPECTED;

    if (ppauto)
        *ppauto = NULL;

    if (!pidl)
        return E_POINTER;

    // Try a cached psw if we don't need ppauto
    IShellWindows* psw = WinList_GetShellWindows(ppauto != NULL);
    if (psw)
    {
        VARIANT var;
        hr = InitVariantFromIDList(&var, pidl);
        if (SUCCEEDED(hr)) 
        {
            LONG lhwnd;
            IDispatch* pdisp;
            hr = psw->FindWindowSW(&var, PVAREMPTY, SWC_BROWSER, &lhwnd,
                    ppauto ? (SWFO_NEEDDISPATCH | SWFO_INCLUDEPENDING) : SWFO_INCLUDEPENDING,
                    &pdisp);
            if ((hr == E_PENDING) || (hr == S_FALSE))
            {
                HRESULT hrOld = hr;
                hr = E_FAIL;
                CWaitForWindow *pdfwait = new CWaitForWindow();   // Setup a wait object...
                if (pdfwait)
                {
                    if (pdfwait->Init(psw, pidl, 0))
                    {
                        if (hrOld == S_FALSE)
                        {
                            // Startup opening a new window
                            SHELLEXECUTEINFO sei = {sizeof(sei)};

                            sei.lpIDList = (void *)pidl;

                            //
                            //  WARNING - old versions of ShellExec() didnt pay attention - ZekeL - 30-DEC-98
                            //  to whether the hwnd is in the same process or not, 
                            //  and so could fault in TryDDEShortcut().
                            //  only pass the hwnd if the shell window shares 
                            //  the same process.
                            //
                            sei.hwnd = GetShellWindow();
                            DWORD idProcess;
                            GetWindowThreadProcessId(sei.hwnd, &idProcess);
                            if (idProcess != GetCurrentProcessId())
                                sei.hwnd = NULL;

                            // Everything should have been initialize to NULL(0)
                            sei.fMask = SEE_MASK_IDLIST | SEE_MASK_FLAG_DDEWAIT;
                            sei.nShow = SW_SHOWNORMAL;

                            hr = ShellExecuteEx(&sei) ? S_OK : S_FALSE;
                        }

                        while ((hr = psw->FindWindowSW(&var, PVAREMPTY, SWC_BROWSER, &lhwnd,
                                ppauto ? (SWFO_NEEDDISPATCH | SWFO_INCLUDEPENDING) : SWFO_INCLUDEPENDING,
                                &pdisp)) != S_OK)
                        {
                            if (FAILED(pdfwait->WaitForWindowToOpen(20 * 1000)))
                            {
                                hr = E_ABORT;
                                break;
                            }
                        }
                    }
                    pdfwait->CleanUp();   // No need to watch things any more...
                    pdfwait->Release(); // release our use of this object...
                }
            }
            if (hr == S_OK && ppauto) 
            {
                // if this fails this is because we are inside SendMessage loop
                hr = pdisp->QueryInterface(IID_PPV_ARG(IWebBrowserApp, ppauto));
            }
            if (pdisp)
                pdisp->Release();
            VariantClear(&var);
        }
        psw->Release();
    }
    return hr;
}

#undef VariantCopy

WINOLEAUTAPI VariantCopyLazy(VARIANTARG * pvargDest, VARIANTARG * pvargSrc)
{
    VariantClearLazy(pvargDest);

    switch(pvargSrc->vt) {
    case VT_I4:
    case VT_UI4:
    case VT_BOOL:
        // we can add more
        *pvargDest = *pvargSrc;
        return S_OK;

    case VT_UNKNOWN:
        if (pvargDest) {
            *pvargDest = *pvargSrc;
            if (pvargDest->punkVal)
                pvargDest->punkVal->AddRef();
            return S_OK;
        }
        ASSERT(0);
        return E_INVALIDARG;
    }

    return VariantCopy(pvargDest, pvargSrc);
}

//
// WARNING: This function must be placed at the end because we #undef
// VariantClear
//
#undef VariantClear

HRESULT VariantClearLazy(VARIANTARG *pvarg)
{
    switch(pvarg->vt) 
    {
        case VT_I4:
        case VT_UI4:
        case VT_EMPTY:
        case VT_BOOL:
            // No operation
            break;

        case VT_UNKNOWN:
            if(V_UNKNOWN(pvarg) != NULL)
              V_UNKNOWN(pvarg)->Release();
            break;

        case VT_DISPATCH:
            if(V_DISPATCH(pvarg) != NULL)
              V_DISPATCH(pvarg)->Release();
            break;

        case VT_SAFEARRAY:
            THR(SafeArrayDestroy(V_ARRAY(pvarg)));
            break;

        default:
            return VariantClear(pvarg);
    }

    V_VT(pvarg) = VT_EMPTY;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\winlist.h ===
//--------------------------------------------------------------------------
// Manage the windows list, such that we can get the IDispatch for each of 
// the shell windows to be marshalled to different processes
//---------------------------------------------------------------------------

HRESULT VariantClearLazy(VARIANTARG *pvarg);




extern DWORD g_dwWinListCFRegister;     // CoRegisterClassObject Registration DWORD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\util.cpp ===
#include "priv.h"
#include "sccls.h"
#include "shlobj.h"

#include <tchar.h>

#ifndef UNIX
#include <webcheck.h>
#else
#include <subsmgr.h>
#endif

#include "resource.h"
#include "mshtml.h"     // for IHTMLElement
#include "mlang.h"      // fo char conversion
#include <advpub.h>     // for IE activesetup GUID
#include "winineti.h"   // For name of a mutex used in IsWininetLoadedAnywhere()
#include "htregmng.h"
#include <ntverp.h>
#include <platform.h>
#include <mobsync.h>
#include <mobsyncp.h>
#include <winuser.h>
#include <mluisupp.h>
#include "shdocfl.h"
#include <shlwapip.h>
#include "inetnot.h"
#include <shfolder.h>

#include "..\inc\brutil.cpp"

STDAPI CDelegateMalloc_Create(void *pv, SIZE_T cbSize, WORD wOuter, IMalloc **ppmalloc);

const VARIANT c_vaEmpty = {0};

const TCHAR c_szRegKeyTypedURLs[]     = TEXT("Software\\Microsoft\\Internet Explorer\\TypedURLs");

#define DM_SESSIONCOUNT     0

int     g_cxIcon = 0;
int     g_cyIcon = 0;
int     g_cxSmIcon = 0;
int     g_cySmIcon = 0;


const DISPPARAMS c_dispparamsNoArgs = {NULL, NULL, 0, 0};
const LARGE_INTEGER c_li0 = { 0, 0 };

const ITEMIDLIST s_idlNULL = { 0 } ;

// 07.28.2000 - Moved from urlhist.cpp since its used in two places now.
#ifdef UNICODE
#define SHGETFOLDERPATH "SHGetFolderPathW"
#else
#define SHGETFOLDERPATH "SHGetFolderPathA"
#endif
#undef SHGetFolderPath
typedef HRESULT (*PFNSHGETFOLDERPATH)(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPTSTR pszPath);

PFNSHGETFOLDERPATH g_pfnGetFolderPath = NULL;

HRESULT SHGetFolderPathD(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPTSTR pszPath)
{
    if (!g_pfnGetFolderPath)
    {
        // note, this is already loaded so this LoadLibray() is fast
        HMODULE hmod = LoadLibrary(TEXT("shell32.dll"));
        g_pfnGetFolderPath = (PFNSHGETFOLDERPATH)GetProcAddress(hmod, SHGETFOLDERPATH);

        // not there, must be downlevel shell32, use shfolder.dll instead
        if (!g_pfnGetFolderPath)
        {
            hmod = LoadLibrary(TEXT("shfolder.dll"));
            g_pfnGetFolderPath = (PFNSHGETFOLDERPATH)GetProcAddress(hmod, SHGETFOLDERPATH);
        }
        // note, we leak the hmod, for shell32/shfolder that is OK
    }

    HRESULT hr;
    if (g_pfnGetFolderPath) 
        hr = g_pfnGetFolderPath(hwnd, csidl, hToken, dwFlags, pszPath);
    else
    {
        *pszPath = 0;
        hr = E_FAIL;
    }
    return hr;
}


int InitColorDepth(void)
{
    static int s_lrFlags = 0;              // Flags passed to LoadImage
    if (s_lrFlags == 0)
    {
        int nColorRes, nIconDepth = 0;
        HKEY hkey;

        // Determine the color depth so we can load the best image
        // (This code was stolen from FileIconInit in shell32)

        // Get the user preferred icon size (and color depth) from the
        // registry.
        //
        if (NO_ERROR == RegOpenKey(HKEY_CURRENT_USER, REGSTR_PATH_METRICS, &hkey))
        {
            nIconDepth = SHRegGetIntW(hkey, L"Shell Icon Bpp", nIconDepth);
            RegCloseKey(hkey);
        }

        nColorRes = GetCurColorRes();

        if (nIconDepth > nColorRes)
            nIconDepth = 0;

        if (nColorRes <= 8)
            nIconDepth = 0; // wouldn't have worked anyway

        if (nColorRes > 4 && nIconDepth <= 4)
            s_lrFlags = LR_VGACOLOR;
        else
            s_lrFlags = LR_DEFAULTCOLOR;
    }
    return s_lrFlags;
}

HICON   g_hiconSplat = NULL;
HICON   g_hiconSplatSm = NULL;      // small version

void LoadCommonIcons(void)
{
    if (NULL == g_hiconSplat)
    {
        // Use LoadLibraryEx so we don't load code pages
        HINSTANCE hinst = LoadLibrary(TEXT("url.dll"));
        if (hinst)
        {
            int lrFlags = InitColorDepth();
            g_hiconSplat   = (HICON)LoadImage(hinst, MAKEINTRESOURCE(IDI_URL_SPLAT), IMAGE_ICON, g_cxIcon, g_cyIcon, lrFlags);
            g_hiconSplatSm = (HICON)LoadImage(hinst, MAKEINTRESOURCE(IDI_URL_SPLAT), IMAGE_ICON, g_cxSmIcon, g_cySmIcon, lrFlags);

            FreeLibrary(hinst);
        }
    }
}

STDAPI_(BOOL) UrlHitsNetW(LPCWSTR pszURL)
{
    BOOL fResult;

    // Handle the easy ones on our own and call URLMON for the others.

    switch (GetUrlScheme(pszURL))
    {
    case URL_SCHEME_FILE:
    case URL_SCHEME_RES:
        fResult = FALSE;
        break;

    case URL_SCHEME_HTTP:
    case URL_SCHEME_HTTPS:
    case URL_SCHEME_FTP:
    case URL_SCHEME_GOPHER:
    case URL_SCHEME_TELNET:
    case URL_SCHEME_WAIS:
        fResult = TRUE;
        break;

    default:
        {
        DWORD fHitsNet;
        DWORD dwSize;
        fResult = SUCCEEDED(CoInternetQueryInfo(
                            pszURL, QUERY_USES_NETWORK,
                            0, &fHitsNet, sizeof(fHitsNet), &dwSize, 0)) && fHitsNet;
        }
    }

    return fResult;
}

STDAPI_(BOOL) CallCoInternetQueryInfo(LPCTSTR pszURL, QUERYOPTION QueryOption)
{
    DWORD fRetVal;
    DWORD dwSize;
    return SUCCEEDED(CoInternetQueryInfo(
                        pszURL, QueryOption,
                        0, &fRetVal, sizeof(fRetVal), &dwSize, 0)) && fRetVal;
}

// see if a given URL is in the cache
STDAPI_(BOOL) UrlIsInCache(LPCTSTR pszURL)
{
    return CallCoInternetQueryInfo(pszURL, QUERY_IS_CACHED);
}

// See if a give URL is actually present as an installed entry
STDAPI_(BOOL) UrlIsInstalledEntry(LPCTSTR pszURL)
{
    return CallCoInternetQueryInfo(pszURL, QUERY_IS_INSTALLEDENTRY);
}


// see if a given URL is in the cache OR if it is mapped

STDAPI_(BOOL) UrlIsMappedOrInCache(LPCTSTR pszURL)
{
    return CallCoInternetQueryInfo(pszURL, QUERY_IS_CACHED_OR_MAPPED);
}

BOOL IsFileUrlW(LPCWSTR pcwzUrl)
{
    return (GetUrlSchemeW(pcwzUrl) == URL_SCHEME_FILE);
}

BOOL IsFileUrl(LPCSTR psz)
{
    return (GetUrlSchemeA(psz) == URL_SCHEME_FILE);
}

BOOL PathIsFilePath(LPCWSTR lpszPath)
{
#ifdef UNIX
    if (lpszPath[0] == TEXT('/'))
#else
    if ((lpszPath[0] == TEXT('\\')) || (lpszPath[0] != TEXT('\0') && lpszPath[1] == TEXT(':')))
#endif
        return TRUE;

    return IsFileUrlW(lpszPath);
}

BOOL IsSubscribableW(LPCWSTR pszUrl)
{
    //  FEATURE: this should be method on the subscription mgr interface - zekel
    DWORD dwScheme = GetUrlSchemeW(pszUrl);
    return (dwScheme == URL_SCHEME_HTTP) || (dwScheme == URL_SCHEME_HTTPS);
}

BOOL IsSubscribableA(LPCSTR pszUrl)
{
    //  FEATURE: this should be method on the subscription mgr interface - zekel
    DWORD dwScheme = GetUrlSchemeA(pszUrl);
    return (dwScheme == URL_SCHEME_HTTP) || (dwScheme == URL_SCHEME_HTTPS);
}

DWORD SHRandom(void)
{
    GUID guid;
    DWORD dw;

    CoCreateGuid(&guid);
    HashData((LPBYTE)&guid, SIZEOF(guid), (LPBYTE)&dw, SIZEOF(dw));

    return dw;
}

// See if we are hosted by IE (explorer.exe or iexplore.exe)
BOOL IsInternetExplorerApp()
{
    if ((g_fBrowserOnlyProcess) ||                  // if in iexplore.exe process,
        (GetModuleHandle(TEXT("EXPLORER.EXE"))))        // or explorer.exe process,
    {
        return TRUE;                                // then we are IE
    }

    return FALSE;
}

BOOL IsTopFrameBrowser(IServiceProvider *psp, IUnknown *punk)
{
    IShellBrowser *psb;

    ASSERT(psp);
    ASSERT(punk);

    BOOL fRet = FALSE;
    if (SUCCEEDED(psp->QueryService(SID_STopFrameBrowser, IID_PPV_ARG(IShellBrowser, &psb))))
    {
        fRet = IsSameObject(psb, punk);
        psb->Release();
    }
    return fRet;
}

DWORD GetUrlSchemePidl(LPITEMIDLIST pidl)
{
    if (pidl && IsURLChild(pidl, TRUE))
    {
        TCHAR szUrl[MAX_URL_STRING];
        if (SUCCEEDED(IEGetDisplayName(pidl, szUrl, SHGDN_FORPARSING)))
            return GetUrlScheme(szUrl);
    }
    return URL_SCHEME_INVALID;
}


STDAPI_(BSTR) LoadBSTR(UINT uID)
{
    WCHAR wszBuf[MAX_PATH];
    if (MLLoadStringW(uID, wszBuf, ARRAYSIZE(wszBuf)))
    {
        return SysAllocString(wszBuf);
    }
    return NULL;
}

BOOL StringIsUTF8A(LPCSTR psz, DWORD cb)
{
    BOOL fRC = FALSE;
    CHAR *pb;
    CHAR b;
    DWORD dwCnt;
    DWORD dwUTF8Cnt;

    if (!psz || !(*psz) || cb == 0)
        return(FALSE);

    pb = (CHAR*)psz;
    while(cb-- && *pb)
    {
        if ((*pb & 0xc0) == 0xc0) // bit pattern starts with 11
        {
            dwCnt = dwUTF8Cnt = 0;
            b = *pb;
            while((b & 0xc0) == 0xc0)
            {
                dwCnt++;
                if ((*(pb+dwCnt) & 0xc0) == 0x80)   // bits at dwCnt bytes from current offset in str aren't 10
                    dwUTF8Cnt++;
                b = (b << 1) & 0xff;
            }
            if (dwCnt == dwUTF8Cnt)
                fRC = TRUE;       // Found UTF8 encoded chars
                
            pb += ++dwCnt;
        }
        else
        {
            pb++;
        }
    }

    return(fRC);
}


BOOL StringIsUTF8W(LPCWSTR pwz, DWORD cb)
{
    BOOL  fRC = FALSE;
    WCHAR *pb;
    WCHAR b;
    DWORD dwCnt;
    DWORD dwUTF8Cnt;

    if (!pwz || !(*pwz) || cb == 0)
        return(FALSE);

    pb = (WCHAR*)pwz;
    while(cb-- && *pb)
    {
        if (*pb > 255)   // Non ansi so bail
            return(FALSE);
            
        if ((*pb & 0xc0) == 0xc0) // bit pattern starts with 11
        {
            dwCnt = dwUTF8Cnt = 0;
            b = *pb;
            while((b & 0xc0) == 0xc0)
            {
                dwCnt++;
                if ((*(pb+dwCnt) & 0xc0) == 0x80)   // bits at dwCnt bytes from current offset in str aren't 10
                    dwUTF8Cnt++;
                b = (b << 1) & 0xff;
            }
            if (dwCnt == dwUTF8Cnt)
                fRC = TRUE;       // Found UTF8 encoded chars
                
            pb += ++dwCnt;
        }
        else
        {
            pb++;
        }
    }

    return(fRC);
}

//
//  StringContainsHighAnsi
//
//  Determine if string contains high-ANSI characters. Search is
//    stopped when we hit the first high-ANSI character, when we hit the terminator
//    or when we have decremented dwInLen to zero
//
//  Return Value:
//      TRUE    - pszIn contains one or more high-ANSI characters
//
//      FALSE   - pszIn (or substring of length dwInLen) does not contain
//                high-ANSI characters
//
BOOL StringContainsHighAnsiA(LPCSTR pszIn, DWORD dwInLen)
{
    while (dwInLen-- && *pszIn) 
    {
        if (*pszIn++ & 0x80)
            return TRUE;
    }
    return FALSE;
}

BOOL StringContainsHighAnsiW(LPCWSTR pszIn, DWORD dwInLen)
{
    while (dwInLen-- && *pszIn) 
    {
        if (*pszIn++ & 0x80)
            return TRUE;
    }
    return FALSE;
}

BOOL UTF8Enabled(void)
{
    static DWORD   dwIE = URL_ENCODING_NONE;
    DWORD dwOutLen = sizeof(DWORD);
    
    if (dwIE == URL_ENCODING_NONE)
        UrlMkGetSessionOption(URLMON_OPTION_URL_ENCODING, &dwIE, sizeof(DWORD), &dwOutLen, NULL);
    return dwIE == URL_ENCODING_ENABLE_UTF8;
}

//
// PrepareURLForDisplay
//
//     Decodes without stripping file:// prefix
//

#undef PrepareURLForDisplay
BOOL PrepareURLForDisplayW(LPCWSTR pwz, LPWSTR pwzOut, LPDWORD pcbOut)
{
    if (PathIsFilePath(pwz))
    {
        if (IsFileUrlW(pwz))
            return SUCCEEDED(PathCreateFromUrlW(pwz, pwzOut, pcbOut, 0));

        StrCpyNW(pwzOut, pwz, *pcbOut);
        *pcbOut = lstrlenW(pwzOut);
        return TRUE;
    }
    
    BOOL fRet = SUCCEEDED(UrlUnescapeW((LPWSTR)pwz, pwzOut, pcbOut, 0));
    if (fRet)
    {
        SHCleanupUrlForDisplay(pwzOut);
    }
    return fRet;
}

// ****************************************************************************
// BEGIN - MOVE TO SHLWAPI
//
// TODO (grzegorz): move this code to shlwapi.dll
// ****************************************************************************

#define QUERY       L'?'
#define POUND       L'#'
#define HEX_ESCAPE  L'%'
#define TERMSTR(pch)      *(pch) = L'\0'

BOOL IsHex(WCHAR ch)
{
    return (   (ch >= TEXT('0') && ch <= TEXT('9')) 
            || (ch >= TEXT('A') && ch <= TEXT('F'))
            || (ch >= TEXT('a') && ch <= TEXT('f')));
}

WORD HexToWord(WCHAR ch)
{
    if(ch >= TEXT('0') && ch <= TEXT('9'))
        return (WORD) ch - TEXT('0');
    if(ch >= TEXT('A') && ch <= TEXT('F'))
        return (WORD) ch - TEXT('A') + 10;
    if(ch >= TEXT('a') && ch <= TEXT('f'))
        return (WORD) ch - TEXT('a') + 10;

    ASSERT(FALSE);  //we have tried to use a non-hex number
    return (WORD) -1;
}

inline BOOL IsEscapedOctetW(LPCWSTR pch)
{
    return (pch[0] == HEX_ESCAPE && IsHex(pch[1]) && IsHex(pch[2])) ? TRUE : FALSE;
}

WCHAR TranslateEscapedOctetW(LPCWSTR pch)
{
    WCHAR ch;
    ASSERT(IsEscapedOctetW(pch));

    pch++;
    ch = (WCHAR) HexToWord(*pch++) * 16; // hi nibble
    ch += HexToWord(*pch); // lo nibble

    return ch;
}

HRESULT CopyOutW(PSHSTRW pstr, LPWSTR psz, LPDWORD pcch)
{
    HRESULT hr = S_OK;
    DWORD cch;
    ASSERT(pstr);
    ASSERT(psz);
    ASSERT(pcch);

    cch = pstr->GetLen();
    if ((*pcch > cch) && psz)
        StrCpyNW(psz, pstr->GetStr(), pstr->GetLen() + 1);
    else
        hr = E_POINTER;

    *pcch = cch + (FAILED(hr) ? 1 : 0);

    return hr;
}

HRESULT ShdocvwUrlUnescapeInplaceW(LPWSTR psz, DWORD dwFlags, UINT uiCP)
{
    WCHAR *pchSrc = psz;
    WCHAR *pchDst = psz;

    HRESULT hr = S_OK;

    while (*pchSrc)
    {
        if ((*pchSrc == POUND || *pchSrc == QUERY) && (dwFlags & URL_DONT_ESCAPE_EXTRA_INFO))
        {
            StrCpyNW(pchDst, pchSrc, lstrlenW(pchSrc));
            pchDst += lstrlenW(pchDst);
            break;
        }

        if (IsEscapedOctetW(pchSrc))
        {
            int cchAnsi = 0;
            int cchDst;
            SHSTRA strAnsi;
            LPSTR pchDstAnsi;

            hr = strAnsi.SetStr(pchDst);
            if (FAILED(hr))
                return hr;
            else
                pchDstAnsi = strAnsi.GetInplaceStr();

            while (*pchSrc && IsEscapedOctetW(pchSrc))
            {
                WCHAR ch =  TranslateEscapedOctetW(pchSrc);

                *pchDstAnsi++ = LOBYTE(ch);
                pchSrc += 3; // enuff for "%XX"
                cchAnsi++;
            }

            if (cchAnsi)
            {
                TERMSTR(pchDstAnsi);
                // we have min 2 extra chars in pchDst to use, so we can pass cchAnsi + 1
                cchDst = SHAnsiToUnicodeCP(uiCP, strAnsi, pchDst, cchAnsi + 1);
                pchDst += cchDst - 1;
            }
        }
        else
        {
            *pchDst++ = *pchSrc++;
        }
    }

    TERMSTR(pchDst);

    return hr;
}

HRESULT ShdocvwUrlUnescapeW(LPWSTR pszUrl, LPWSTR pszOut, LPDWORD pcchOut, DWORD dwFlags, UINT uiCP)
{
    RIPMSG(pszUrl && IS_VALID_STRING_PTRW(pszUrl, -1), "ShdocvwUrlUnescapeW: Caller passed invalid pszUrl");

    if (dwFlags & URL_UNESCAPE_INPLACE)
    {
        return ShdocvwUrlUnescapeInplaceW(pszUrl, dwFlags, uiCP);
    }

    RIPMSG(NULL != pcchOut && IS_VALID_WRITE_PTR(pcchOut, DWORD), "ShdocvwUrlUnescapeW: Caller passed invalid pcchOut");
    RIPMSG(pszOut && (NULL == pcchOut || IS_VALID_WRITE_BUFFER(pszOut, WCHAR, *pcchOut)), "ShdocvwUrlUnescapeW: Caller passed invalid pszOut");

    if (   !pszUrl
        || !pcchOut
        || !*pcchOut
        || !pszOut)
    {
        return E_INVALIDARG;
    }

    SHSTRW str;
    HRESULT hr = str.SetStr(pszUrl);
    if (SUCCEEDED(hr))
    {
        ShdocvwUrlUnescapeInplaceW(str.GetInplaceStr(), dwFlags, uiCP);
        hr = CopyOutW(&str, pszOut, pcchOut);
    }

    return hr;
}
// ****************************************************************************
// END - MOVE TO SHLWAPI
// ****************************************************************************

//
// PrepareURLForDisplayUTF8W
//
// pwz -          [In] UTF8 encoded string like "%e6%aa%e4%a6.doc".
// pwzOut -       [Out]  UTF8 decoded string.
// pcchOut -      [In/Out] Count of characters in pwzOut on input.  Number of chars copies to pwzOut on output
//                         including the terminating null.
// fUTF8Enabled - [In] Flag to indicated whether UTF8 is enabled.
// uiCP -         [In] Codepage used to convert escaped characters, when fUTF8Enabled is false
//
// pwz and pwzOut can be the same buffer.
//
// Returns:
//    S_OK upon success.
//    E_FAIL for failure.
//    ERROR_BUFFER_OVERFLOW if the number of converted chars is greater than the passed in size of output buffer.
//
//    Note: If UTF8 is not enabled or the string does not contain UTF8 the output string will be unescaped
//    and will return S_OK.
//
HRESULT _PrepareURLForDisplayUTF8W(LPCWSTR pwz, LPWSTR pwzOut, LPDWORD pcchOut, BOOL fUTF8Enabled, UINT uiCP)
{
    HRESULT hr = E_FAIL;
    DWORD   cch;
    DWORD   cch1;
    CHAR    szBuf[MAX_URL_STRING];
    CHAR    *pszBuf = szBuf;

    if (!pwz || !pwzOut || !pcchOut)
    {
        if (pcchOut)
            *pcchOut = 0;
        return(hr);
    }
        
    cch = *pcchOut;
    cch1 = ARRAYSIZE(szBuf);
    if (uiCP != (UINT)-1)
        hr = ShdocvwUrlUnescapeW((LPWSTR)pwz, pwzOut, pcchOut, 0, fUTF8Enabled ? CP_UTF8 : uiCP);
    else
    {
        hr = UrlUnescapeW((LPWSTR)pwz, pwzOut, pcchOut, 0);
        if (SUCCEEDED(hr))
        {
            if (fUTF8Enabled && StringIsUTF8W(pwzOut, cch))
            {
                if (*pcchOut > ARRAYSIZE(szBuf)) // Internal buffer not big enough so alloc one
                {
                    if ((pszBuf = (CHAR *)LocalAlloc(LPTR, ((*pcchOut)+1) * sizeof(CHAR))) == NULL)
                    {
                        *pcchOut = 0;
                        return(E_OUTOFMEMORY);
                    }
                    cch1 = *pcchOut;
                }

                // Compress wide string
                CHAR *pIn = (CHAR *)pwzOut;
                CHAR *pOut = pszBuf;
                while((*pIn != '\0') || (*(pIn+1) != '\0') && --cch1)
                {
                    if (*pIn != '\0')
                    {
                        *pOut = *pIn;
                        pOut++;
                    }
                    pIn++;
                }
                *pOut = '\0';

                // Convert to UTF8 wide string
                if ((cch1 = SHAnsiToUnicodeCP(CP_UTF8, pszBuf, pwzOut, cch)) != 0)
                {
                    hr = S_OK;
                    *pcchOut = cch1;
                }

                // SHAnsiToUnicode doesn't tell us if it has truncated the convertion to fit the output buffer
                RIPMSG(cch1 != cch, "_PrepareURLForDisplayUTF8W: Passed in size of out buf equal to converted size; buffer might be truncated");

                if ((pszBuf != NULL) && (pszBuf != szBuf))
                {
                    LocalFree((CHAR *)pszBuf);
                    pszBuf = NULL;
                }
            }
            else
            {
                hr = S_OK;;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        SHCleanupUrlForDisplay(pwzOut);
    }

    return(hr);
}

HRESULT PrepareURLForDisplayUTF8W(LPCWSTR pwz, LPWSTR pwzOut, LPDWORD pcchOut, BOOL fUTF8Enabled)
{
    return _PrepareURLForDisplayUTF8W(pwz, pwzOut, pcchOut, fUTF8Enabled, (UINT)-1);
}

//
// PrepareURLForExternalApp -
//
//   Decodes and strips, if needed, file:// prefix
//

//  APPCOMPAT - for IE30 compatibility reasons, we have to Unescape all Urls - zekel - 1-JUL-97
//  before passing them to an APP.  this does limit their use, but
//  people already depend on this behavior.  specifically MS Chat.
BOOL PrepareURLForExternalApp (LPCWSTR psz, LPWSTR pszOut, LPDWORD pcchOut)
{
    if (IsFileUrlW(psz))
        return SUCCEEDED(PathCreateFromUrl(psz, pszOut, pcchOut, 0));
    else
        return SUCCEEDED(UrlUnescape((LPWSTR)psz, pszOut, pcchOut, 0));

}

SHDOCAPI
IURLQualifyWithContext(
    IN  LPCWSTR pcszURL, 
    IN  DWORD   dwFlags,         // UQF_*
    OUT LPWSTR  pszTranslatedURL,
    LPBOOL      pbWasSearchURL,
    LPBOOL      pbWasCorrected,
    ISearchContext *  pSC);

BOOL ParseURLFromOutsideSourceWithContextW (LPCWSTR psz, LPWSTR pszOut, LPDWORD pcchOut, LPBOOL pbWasSearchURL, ISearchContext * pSC)
{
    // This is our hardest case.  Users and outside applications might
    // type fully-escaped, partially-escaped, or unescaped URLs at us.
    // We need to handle all these correctly.  This API will attempt to
    // determine what sort of URL we've got, and provide us a returned URL
    // that is guaranteed to be FULLY escaped.

    IURLQualifyWithContext(psz, UQF_DEFAULT, pszOut, pbWasSearchURL, NULL, pSC);

    //
    //  go ahead and canonicalize this appropriately
    //
    if (FAILED(UrlCanonicalize(pszOut, pszOut, pcchOut, URL_ESCAPE_SPACES_ONLY)))
    {
        //
        //  we cant resize from here.
        //  NOTE UrlCan will return E_POINTER if it is an insufficient buffer
        //
        TraceMsg(DM_ERROR, "sdv PUFOS:UC() failed.");
        return FALSE;
    }

    return TRUE;
} // ParseURLFromOutsideSource

BOOL ParseURLFromOutsideSourceW (LPCWSTR psz, LPWSTR pszOut, LPDWORD pcchOut, LPBOOL pbWasSearchURL)
{
    return ParseURLFromOutsideSourceWithContextW(psz, pszOut, pcchOut, pbWasSearchURL, NULL);
} // ParseURLFromOutsideSource
BOOL ParseURLFromOutsideSourceA (LPCSTR psz, LPSTR pszOut, LPDWORD pcchOut, LPBOOL pbWasSearchURL)
{
    SHSTRW strw;
    DWORD cch ;

    ASSERT(psz);
    ASSERT(pszOut);
    ASSERT(pcchOut && *pcchOut);

    //
    //  WARNING: we arent guaranteed to have the correct cch's here - zekel - 27-jan-97
    //  but for now this is adequate.
    //
    if (SUCCEEDED(strw.SetStr(psz)) && SUCCEEDED(strw.SetSize(cch = *pcchOut)) &&
        ParseURLFromOutsideSourceW(strw, strw.GetInplaceStr(), pcchOut, pbWasSearchURL))
    {
        return SHUnicodeToAnsi((LPCWSTR)strw, pszOut, cch);
    }

    return FALSE;
}

int DPA_ILFreeCallback(void * p, void * d)
{
    Pidl_Set((LPITEMIDLIST*)&p, NULL);
    return 1;
}

void _DeletePidlDPA(HDPA hdpa)
{
    DPA_DestroyCallback(hdpa, (PFNDPAENUMCALLBACK)DPA_ILFreeCallback, 0);
    hdpa = NULL;
}

BOOL _InitComCtl32()
{
    static BOOL fInitialized = FALSE;

    if (!fInitialized)
    {
        INITCOMMONCONTROLSEX icc;

        icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
        icc.dwICC = ICC_USEREX_CLASSES | ICC_COOL_CLASSES | ICC_INTERNET_CLASSES | ICC_PAGESCROLLER_CLASS | ICC_NATIVEFNTCTL_CLASS;
        fInitialized = InitCommonControlsEx(&icc);
    }
    return fInitialized;
}

#ifndef ALPHA_WARNING_IS_DUMB

#pragma message("building with alpha warning enabled")

void AlphaWarning(HWND hwnd)
{
    static BOOL fShown = FALSE;
    TCHAR szTemp[265];
    TCHAR szFull[2048];
    szFull[0] = TEXT('\0');
    int i = IDS_ALPHAWARNING;

    if (fShown)
        return;

    fShown = TRUE;

    while(MLLoadShellLangString (i++, szTemp, ARRAYSIZE(szTemp))) {
        StrCatBuff(szFull, szTemp, ARRAYSIZE(szFull));
    }

    MessageBox(hwnd, szFull, TEXT("Internet Explorer"), MB_ICONINFORMATION | MB_OK);
}
#endif


#define DM_NAV              TF_SHDNAVIGATE
#define DM_ZONE             TF_SHDNAVIGATE
#define DM_IEDDE            DM_TRACE
#define DM_CANCELMODE       0
#define DM_UIWINDOW         0
#define DM_ENABLEMODELESS   0
#define DM_EXPLORERMENU     0
#define DM_BACKFORWARD      0
#define DM_PROTOCOL         0
#define DM_ITBAR            0
#define DM_STARTUP          0
#define DM_AUTOLIFE         0
#define DM_PALETTE          0

PFNSHCHANGENOTIFYREGISTER    g_pfnSHChangeNotifyRegister = NULL;
PFNSHCHANGENOTIFYDEREGISTER  g_pfnSHChangeNotifyDeregister = NULL;

BOOL g_fNewNotify = FALSE;   // Are we using classic mode (W95 or new mode?

BOOL CALLBACK AddPropSheetPage(HPROPSHEETPAGE hpage, LPARAM lParam)
{
    PROPSHEETHEADER * ppsh = (PROPSHEETHEADER *)lParam;

    if (ppsh->nPages < MAX_PAGES)
    {
        ppsh->phpage[ppsh->nPages++] = hpage;
        return TRUE;
    }
    return FALSE;
}

BOOL SHIsRegisteredClient(LPCTSTR pszClient)
{
    LONG cbSize = 0;
    TCHAR szKey[80];

    wnsprintf(szKey, ARRAYSIZE(szKey), TEXT("Software\\Clients\\%s"), pszClient);
    return (RegQueryValue(HKEY_LOCAL_MACHINE, szKey, NULL, &cbSize) == ERROR_SUCCESS) &&
           (cbSize > sizeof(TCHAR));
}

// Exporting by ordinal is not available on UNIX.
// But we have all these symbols exported because it's UNIX default.
#ifdef UNIX
#define GET_PRIVATE_PROC_ADDRESS(_hinst, _fname, _ord) GetProcAddress(_hinst, _fname)
#else
#define GET_PRIVATE_PROC_ADDRESS(_hinst, _fname, _ord) GetProcAddress(_hinst, _ord)
#endif

ULONG RegisterNotify(HWND hwnd, UINT nMsg, LPCITEMIDLIST pidl, DWORD dwEvents, UINT uFlags, BOOL fRecursive)
{
    SHChangeNotifyEntry fsne;

    // See if we need to still figure out which version of SHChange Notify to call?
    if  (g_pfnSHChangeNotifyDeregister == NULL)
    {

        HMODULE hmodShell32 = ::GetModuleHandle(TEXT("SHELL32"));
        if (!hmodShell32)
            return 0;   // Nothing registered...

        g_pfnSHChangeNotifyRegister = (PFNSHCHANGENOTIFYREGISTER)GET_PRIVATE_PROC_ADDRESS(hmodShell32,
                                                                                          "NTSHChangeNotifyRegister",
                                                                                          (LPSTR)640);
        if (g_pfnSHChangeNotifyRegister && (WhichPlatform() == PLATFORM_INTEGRATED))
        {
            g_pfnSHChangeNotifyDeregister = (PFNSHCHANGENOTIFYDEREGISTER)GET_PRIVATE_PROC_ADDRESS(hmodShell32,
                                                                                                  "NTSHChangeNotifyDeregister",
                                                                                                  (LPSTR)641);
            g_fNewNotify = TRUE;
        }
        else
        {
            g_pfnSHChangeNotifyRegister = (PFNSHCHANGENOTIFYREGISTER)GET_PRIVATE_PROC_ADDRESS(hmodShell32,
                                                                                              "SHChangeNotifyRegister",
                                                                                              (LPSTR)2);
            g_pfnSHChangeNotifyDeregister = (PFNSHCHANGENOTIFYDEREGISTER)GET_PRIVATE_PROC_ADDRESS(hmodShell32,
                                                                                                  "SHChangeNotifyDeregister",
                                                                                                  (LPSTR)4);
        }

        if  (g_pfnSHChangeNotifyDeregister == NULL)
            return 0;   // Could not get either to work...
    }

    uFlags |= SHCNRF_ShellLevel | SHCNRF_InterruptLevel;
    if (g_fNewNotify)
        uFlags |= SHCNRF_NewDelivery;

    fsne.fRecursive = fRecursive;
    fsne.pidl = pidl;
    return g_pfnSHChangeNotifyRegister(hwnd, uFlags, dwEvents, nMsg, 1, &fsne);
}

//----------------------------------------------------------------------------
// Just like shells SHRestricted() only this put up a message if the restricion
// is in effect.
// REARCHITECT: this function is identical to shell32's SHIsRestricted
BOOL SHIsRestricted(HWND hwnd, RESTRICTIONS rest)
{
    if (SHRestricted(rest))
    {
        ULONG_PTR uCookie = 0;
        SHActivateContext(&uCookie);
        SHRestrictedMessageBox(hwnd);
        if (uCookie)
        {
            SHDeactivateContext(uCookie);
        }
        return TRUE;
    }
    return FALSE;
}

BOOL SHIsRestricted2W(HWND hwnd, BROWSER_RESTRICTIONS rest, LPCWSTR pwzUrl, DWORD dwReserved)
{
    if (SHRestricted2W(rest, pwzUrl, dwReserved))
    {
        ULONG_PTR uCookie = 0;
        SHActivateContext(&uCookie);
        SHRestrictedMessageBox(hwnd);
        if (uCookie)
        {
            SHDeactivateContext(uCookie);
        }
        return TRUE;
    }
    return FALSE;
}


BOOL bIsValidString(LPCSTR pszString, ULONG cbLen)
{
    if (cbLen == 0) return TRUE;
    while (cbLen--)
        if (*pszString++ == '\0') return TRUE;
    return FALSE;
}

BOOL ViewIDFromViewMode(UINT uViewMode, SHELLVIEWID *pvid)
{
    switch (uViewMode)
    {
    case FVM_ICON:
        *pvid = VID_LargeIcons;
        break;

    case FVM_SMALLICON:
        *pvid = VID_SmallIcons;
        break;

    case FVM_LIST:
        *pvid = VID_List;
        break;

    case FVM_DETAILS:
        *pvid = VID_Details;
        break;

    case FVM_THUMBNAIL:
        *pvid = VID_Thumbnails;
        break;

    case FVM_TILE:
        *pvid = VID_Tile;
        break;

    default:
        *pvid = VID_LargeIcons;
        return(FALSE);
    }

    return(TRUE);
}

HIMAGELIST g_himlSysSmall = NULL;
HIMAGELIST g_himlSysLarge = NULL;

void _InitSysImageLists()
{
    if (!g_himlSysSmall)
    {
        Shell_GetImageLists(&g_himlSysLarge, &g_himlSysSmall);

        ImageList_GetIconSize(g_himlSysLarge, &g_cxIcon, &g_cyIcon);
        ImageList_GetIconSize(g_himlSysSmall, &g_cxSmIcon, &g_cySmIcon);
    }
}

// Copied from shell32 (was _ILCreate), which does not export this.
// The fsmenu code needs this function.
STDAPI_(LPITEMIDLIST) IEILCreate(UINT cbSize)
{
    LPITEMIDLIST pidl = (LPITEMIDLIST)SHAlloc(cbSize);
    if (pidl)
        memset(pidl, 0, cbSize);      // needed for external task allicator

    return pidl;
}

DWORD CommonDragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt)
{
    DWORD dwEffect = DROPEFFECT_NONE;
    FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    if (pdtobj->QueryGetData(&fmte) == S_OK)
        dwEffect = DROPEFFECT_COPY | DROPEFFECT_LINK;
    else
    {
        InitClipboardFormats();

        fmte.cfFormat = g_cfHIDA;
        if (pdtobj->QueryGetData(&fmte) == S_OK)
            dwEffect = DROPEFFECT_LINK;
        else {
            fmte.cfFormat = g_cfURL;

            if (pdtobj->QueryGetData(&fmte) == S_OK)
                dwEffect = DROPEFFECT_LINK | DROPEFFECT_COPY | DROPEFFECT_MOVE;
        }
    }

    return dwEffect;
}



// MapNbspToSp
//
// Purpose:
//     Unicode character code point 0x00a0 is designated to HTML
//     entity &nbsp, but some windows code pages don't have code
//     point that can map from 0x00a0. In the most occasion in the
//     shell, NBSP is just a space when it's rendered so we can
//     replace it with 0x0020 safely.
//     This function takes lpwszIn as a string that has
//     non-displayable characters in it, and tries to translate
//     it again after removing NBSP (00a0) from it.
//     returns S_OK if this re-translation is successful.
//
#define nbsp 0x00a0
HRESULT SHMapNbspToSp(LPCWSTR lpwszIn, LPSTR lpszOut, int cbszOut)
{
    BOOL fFoundNbsp = FALSE;
    BOOL fNotDisplayable = TRUE; // assumes FAIL
    LPWSTR pwsz, p;

    if (!lpwszIn || !lpszOut || cbszOut == 0)
        return E_FAIL;

    ASSERT(IS_VALID_STRING_PTRW(lpwszIn, -1));
    ASSERT(IS_VALID_WRITE_BUFFER(lpszOut, TCHAR, cbszOut));

    int cch = lstrlenW(lpwszIn) + 1;
    pwsz = (LPWSTR)LocalAlloc(LPTR, cch * sizeof(WCHAR));
    if (pwsz)
    {
        StrCpyNW(pwsz, lpwszIn, cch);
        p = pwsz;
        while (*p)
        {
            if (*p== nbsp)
            {
                *p= 0x0020; // replace with space
                if (!fFoundNbsp)
                    fFoundNbsp = TRUE;
            }
            p++;
        }

        // don't call WC2MB unless we found Nbsp - for perf reason
        if (fFoundNbsp)
        {
            int iret = WideCharToMultiByte(CP_ACP, 0, pwsz, -1, lpszOut,
                                           cbszOut, NULL, &fNotDisplayable);

            if (!fNotDisplayable && iret == 0)
            {
                // truncated. make it dbcs safe.
                SHTruncateString(lpszOut, cbszOut);
            }
        }

        LocalFree((LOCALHANDLE)pwsz);
        pwsz = NULL;
    }

    return (fFoundNbsp && !fNotDisplayable) ? S_OK : S_FALSE;
}
#undef nbsp


int PropBag_ReadInt4(IPropertyBag* pPropBag, LPWSTR pszKey, int iDefault)
{
    SHPropertyBag_ReadInt(pPropBag, pszKey, &iDefault);
    return iDefault;
}

HRESULT _SetPreferredDropEffect(IDataObject *pdtobj, DWORD dwEffect)
{
    InitClipboardFormats();

    HRESULT hres = E_OUTOFMEMORY;
    DWORD *pdw = (DWORD *)GlobalAlloc(GPTR, sizeof(DWORD));
    if (pdw)
    {
        STGMEDIUM medium;
        FORMATETC fmte = {g_cfPreferredEffect, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        *pdw = dwEffect;

        medium.tymed = TYMED_HGLOBAL;
        medium.hGlobal = pdw;
        medium.pUnkForRelease = NULL;

        hres = pdtobj->SetData(&fmte, &medium, TRUE);

        if (FAILED(hres))
        {
            GlobalFree((HGLOBAL)pdw);
            pdw = NULL;
        }
    }
    return hres;
}

HRESULT DragDrop(HWND hwnd, IShellFolder * psfParent, LPCITEMIDLIST pidl, DWORD dwPrefEffect, DWORD *pdwEffect)
{
    HRESULT hres = E_FAIL;
    LPCITEMIDLIST pidlChild;

    if (!psfParent)
        IEBindToParentFolder(pidl, &psfParent, &pidlChild);
    else 
    {
        pidlChild = pidl;
        psfParent->AddRef();
    }

    if (psfParent)
    {
        DWORD dwAttrib = DROPEFFECT_MOVE | DROPEFFECT_COPY | DROPEFFECT_LINK;

        psfParent->GetAttributesOf(1, &pidlChild, &dwAttrib);

        IDataObject *pdtobj;
        hres = psfParent->GetUIObjectOf(NULL, 1, &pidlChild, IID_IDataObject, NULL, (void**)&pdtobj);
        if (SUCCEEDED(hres))
        {
            DWORD dwEffect = (DROPEFFECT_MOVE | DROPEFFECT_COPY | DROPEFFECT_LINK) & dwAttrib;

            if (dwPrefEffect)
            {
                //win95 shell32 doesn't know about preferred drop effect, so make it the only effect
                if (IsOS(OS_WIN95ORGREATER) && (WhichPlatform() == PLATFORM_BROWSERONLY))
                {
                    dwEffect = DROPEFFECT_LINK & dwAttrib;
                }
                else if (dwPrefEffect & dwEffect)
                {
                    _SetPreferredDropEffect(pdtobj, dwPrefEffect);
                }
            }
            ASSERT(dwEffect);

            // Win95 Browser Only - the shell32 in this process doesn't know
            // ole is loaded, even though it is.
            SHLoadOLE(SHELLNOTIFY_OLELOADED);
            IDragSourceHelper* pDragImages;

            if (SUCCEEDED(CoCreateInstance(CLSID_DragDropHelper, NULL, CLSCTX_INPROC_SERVER, IID_IDragSourceHelper, (void**)&pDragImages)))
            {
                pDragImages->InitializeFromWindow(hwnd, 0, pdtobj);
                pDragImages->Release();
            }

            hres = SHDoDragDrop(hwnd, pdtobj, NULL, dwEffect, &dwEffect);
            if (pdwEffect)
                *pdwEffect = dwEffect;

            pdtobj->Release();
        }

        psfParent->Release();
    }

    return hres;
}

#define IEICONTYPE_GETFILEINFO              0x00000001
#define IEICONTYPE_DEFAULTICON              0x00000002

typedef struct tagIEICONS
{
    int nDefaultIcon;
    int nIEIcon;
    LPCTSTR szFile;
    LPCTSTR szFileExt;
    int nIconResourceNum;
    LPCTSTR szCLSID;
    DWORD dwType;
} IEICONS;

IEICONS g_IEIcons[] = {
    {-1, -1, TEXT("MSHTML.DLL"), TEXT(".htm"), 1, NULL, IEICONTYPE_GETFILEINFO},
    {-1, -1, TEXT("URL.DLL"), TEXT("http\\DefaultIcon"), 0, TEXT("{FBF23B42-E3F0-101B-8488-00AA003E56F8}"), IEICONTYPE_DEFAULTICON}
};

//This function returns the IE icon regardless of the which browser is  default


void _GenerateIEIcons(void)
{
    int nIndex;

    for (nIndex = 0; nIndex < ARRAYSIZE(g_IEIcons); nIndex++)
    {
        SHFILEINFO sfi;
        TCHAR szModule[MAX_PATH];

        HMODULE hmod = GetModuleHandle(g_IEIcons[nIndex].szFile);
        if (hmod)
        {
            GetModuleFileName(hmod, szModule, ARRAYSIZE(szModule));
        }
        else
        {   //HACKHACK : This is a hack to get the mstml
            TCHAR   szKey[GUIDSTR_MAX * 4];
            TCHAR   szGuid[GUIDSTR_MAX];

            //The CLSID used here belongs to MS HTML Generic Page. If someone changes the guid then we
            // are  tossed.
            if (!g_IEIcons[nIndex].szCLSID)
                SHStringFromGUID(CLSID_HTMLDocument, szGuid, GUIDSTR_MAX);
            wnsprintf(szKey, ARRAYSIZE(szKey), TEXT("CLSID\\%s\\InProcServer32"), g_IEIcons[nIndex].szCLSID ? g_IEIcons[nIndex].szCLSID : szGuid);

            long cb = SIZEOF(szModule);
            RegQueryValue(HKEY_CLASSES_ROOT, szKey, szModule, &cb);

        }
        g_IEIcons[nIndex].nIEIcon = Shell_GetCachedImageIndex(szModule, g_IEIcons[nIndex].nIconResourceNum, 0);

        switch(g_IEIcons[nIndex].dwType)
        {
        case IEICONTYPE_GETFILEINFO:
            sfi.iIcon = 0;
            StrCpyN(szModule, TEXT("c:\\notexist"), ARRAYSIZE(szModule));
            StrCatBuff(szModule, g_IEIcons[nIndex].szFileExt, ARRAYSIZE(szModule));
            SHGetFileInfo(szModule, FILE_ATTRIBUTE_NORMAL, &sfi, sizeof(sfi), SHGFI_SYSICONINDEX | SHGFI_USEFILEATTRIBUTES);
            g_IEIcons[nIndex].nDefaultIcon = sfi.iIcon;
            break;

        case IEICONTYPE_DEFAULTICON:
            {
                TCHAR szPath[MAX_PATH];
                DWORD cbSize = SIZEOF(szPath);

                SHGetValue(HKEY_CLASSES_ROOT, g_IEIcons[nIndex].szFileExt, TEXT(""), NULL, szPath, &cbSize);
                g_IEIcons[nIndex].nDefaultIcon = Shell_GetCachedImageIndex(szPath, PathParseIconLocation(szPath), 0);
            }
            break;
        }
    }
}

int IEMapPIDLToSystemImageListIndex(IShellFolder *psfParent, LPCITEMIDLIST pidlChild, int *piSelectedImage)
{
    int nIndex;
    int nIcon = SHMapPIDLToSystemImageListIndex(psfParent, pidlChild, piSelectedImage);

    if (-1 == g_IEIcons[0].nDefaultIcon)
        _GenerateIEIcons();

    for (nIndex = 0; nIndex < ARRAYSIZE(g_IEIcons); nIndex++)
    {
        if ((nIcon == g_IEIcons[nIndex].nDefaultIcon) ||
            (piSelectedImage && *piSelectedImage == g_IEIcons[nIndex].nDefaultIcon))
        {
            nIcon = g_IEIcons[nIndex].nIEIcon;
            if (piSelectedImage)
                *piSelectedImage = nIcon;
            break;
        }
    }
    return nIcon;
}

void IEInvalidateImageList(void)
{
    g_IEIcons[0].nDefaultIcon = -1;
}

int _GetIEHTMLImageIndex()
{
    if (-1 == g_IEIcons[0].nDefaultIcon)
        _GenerateIEIcons();

    return g_IEIcons[0].nIEIcon;
}

// Checks to see if any process at all
// has loaded wininet
static BOOL g_fWininetLoadedSomeplace = FALSE;
BOOL IsWininetLoadedAnywhere()
{
    HANDLE hMutex = NULL;
    BOOL fRet;

    if (g_fWininetLoadedSomeplace)
        return TRUE;

    //
    // Use OpenMutexA so it works on W95.
    // wininet is ansi and created this mutex with CreateMutexA
    hMutex = OpenMutexA(SYNCHRONIZE, FALSE, WININET_STARTUP_MUTEX);

    if (hMutex)
    {
        fRet = TRUE;
        g_fWininetLoadedSomeplace = TRUE;
        CloseHandle(hMutex);
    }
    else
    {
        fRet = FALSE;
    }
    return fRet;
}



//   Checks if global state is offline
BOOL SHIsGlobalOffline(void)
{
    DWORD   dwState = 0, dwSize = sizeof(DWORD);
    BOOL    fRet = FALSE;

    if (!IsWininetLoadedAnywhere())
        return FALSE;

    // Since wininet is already loaded someplace
    // We have to load wininet to check if offline

    if (InternetQueryOptionA(NULL, INTERNET_OPTION_CONNECTED_STATE, &dwState,
        &dwSize))
    {
        if (dwState & INTERNET_STATE_DISCONNECTED_BY_USER)
            fRet = TRUE;
    }

    return fRet;
}

void SetGlobalOffline(BOOL fOffline)
{
    INTERNET_CONNECTED_INFO ci;

    memset(&ci, 0, sizeof(ci));
    if (fOffline) {
        ci.dwConnectedState = INTERNET_STATE_DISCONNECTED_BY_USER;
        ci.dwFlags = ISO_FORCE_DISCONNECTED;
    } else {
        ci.dwConnectedState = INTERNET_STATE_CONNECTED;
    }

    InternetSetOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &ci, sizeof(ci));
}

// This API is documented and is called by apps outside
// the shell such as OE
STDAPI_(void) SetShellOfflineState(BOOL fPutOffline)
{
    BOOL fWasOffline = SHIsGlobalOffline();
    if (fWasOffline != fPutOffline)
    {   
        SetGlobalOffline(fPutOffline); // Set the state
        // Tell all browser windows to update their title   
        SendShellIEBroadcastMessage(WM_WININICHANGE,0,0, 1000); 
    }
}


BOOL GetHistoryFolderPath(LPTSTR pszPath, int cchPath)
{
    INTERNET_CACHE_CONFIG_INFO cci;
    DWORD cbcci = sizeof(INTERNET_CACHE_CONFIG_INFO);

    if (GetUrlCacheConfigInfo(&cci, &cbcci, CACHE_CONFIG_HISTORY_PATHS_FC))
    {
        StrCpyN(pszPath, cci.CachePaths[0].CachePath, cchPath);
        return TRUE;
    }
    return FALSE;
}

// in:
//      pidlRoot    root part of pidl.
//      pidl        equal to or child below pidlRoot
//      pszKey      root key to store stuff under, should match pidlRoot
//      grfMode     read/write
//
// example:
//      pidlRoot = c:\win\favorites
//      pidl     = c:\win\favorites\channels
//      pszKey   = "MenuOrder\Favorites"
//      result -> stream comes from HKCU\...\MenuOrder\Favorites\channels
//

IStream * OpenPidlOrderStream(LPCITEMIDLIST pidlRoot, LPCITEMIDLIST pidl, LPCSTR pszKey, DWORD grfMode)
{
    LPITEMIDLIST pidlAlloc = NULL;
    TCHAR   szRegPath[MAX_URL_STRING];
    TCHAR szKey[MAXIMUM_SUB_KEY_LENGTH];

    SHAnsiToTChar(pszKey, szKey, ARRAYSIZE(szKey));
    StrCpyN(szRegPath, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"), ARRAYSIZE(szRegPath));
    StrCatBuff(szRegPath, szKey, ARRAYSIZE(szRegPath));

    // deal with ordinal vs true pidls
    if (HIWORD(pidlRoot) == 0)
    {
        // Sundown: coercion to int since we are assuming ordinal pidl
        SHGetSpecialFolderLocation(NULL, PtrToLong(pidlRoot), &pidlAlloc);
        pidlRoot = pidlAlloc;
    }

    // build a reg key from the names of the items below the pidlRoot folder. we do
    // this because IEGetDisplayName(SFGAO_FORPARSING) has a bug for file system
    // junctions (channel contents) that returns garbage path names.

    if (pidlRoot)
    {
        LPITEMIDLIST pidlCopy = ILClone(pidl);
        if (pidlCopy)
        {
            LPCITEMIDLIST pidlTail = ILFindChild(pidlRoot, pidlCopy);
            if (pidlTail)
            {
                LPITEMIDLIST pidlNext;
                for (pidlNext = ILGetNext(pidlTail); pidlNext; pidlNext = ILGetNext(pidlNext))
                {
                    WORD cbSave = pidlNext->mkid.cb;
                    pidlNext->mkid.cb = 0;

                    IShellFolder *psf;
                    LPCITEMIDLIST pidlChild;

                    // we do a full bind every time, we could skip this for sub items
                    // and bind from this point down but this code is simpler and binds
                    // aren't that bad...

                    if (SUCCEEDED(IEBindToParentFolder(pidlCopy, &psf, &pidlChild)))
                    {
                        LPWSTR pszName;
                        if (SUCCEEDED(DisplayNameOfAsOLESTR(psf, pidlChild, SHGDN_NORMAL, &pszName)))
                        {
                            StrCatBuff(szRegPath, TEXT("\\"), ARRAYSIZE(szRegPath));
                            StrCatBuff(szRegPath, pszName, ARRAYSIZE(szRegPath));
                            CoTaskMemFree(pszName);
                        }
                        psf->Release();
                    }
                    pidlNext->mkid.cb = cbSave;
                }
            }
            ILFree(pidlCopy);
        }
        if (pidlAlloc)
            ILFree(pidlAlloc);
        return SHOpenRegStream(HKEY_CURRENT_USER, szRegPath, TEXT("Order"), grfMode);
    }
    return NULL;
}

HRESULT GetHTMLElementID(IHTMLElement *pielem, LPTSTR pszName, DWORD cchSize)
{
    // only do this persistence thing if we're in ( or completing ) an operation
    BSTR bstrID = NULL;
    HRESULT hr;

    if (!pielem)
        hr = E_INVALIDARG;
    else if (SUCCEEDED(hr = pielem->get_id(&bstrID)))
    {
        SHUnicodeToTChar(bstrID, pszName, cchSize);
        SysFreeString(bstrID);
    }

    return hr;
}

/**********************************************************************
* SHRestricted2
*
* These are new restrictions that apply to browser only and integrated
* mode.  (Since we're not changing shell32 in browser only mode, we
* need to duplicate the functionality.)
*
* FEATURE: What window will listen to the WM_WININICHANGE
*           lParam="Policy" message and invalidate the cache?
*           Remember not to cache the per zone values.
\**********************************************************************/

// The ZAW compliant policy location.
const TCHAR c_szInfodeliveryBase[] = TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Infodelivery");
const TCHAR c_szInfodeliveryKey[] = TEXT("Restrictions");

// The normal policy location.
const TCHAR c_szExplorerBase[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies");
const TCHAR c_szExplorerKey[] = TEXT("Explorer");

// The browser policy location that SP2 used
const TCHAR c_szBrowserBase[] = TEXT("Software\\Policies\\Microsoft\\Internet Explorer");
const TCHAR c_szBrowserKey[]  = TEXT("Restrictions");
const TCHAR c_szToolbarKey[]  = TEXT("Toolbars\\Restrictions");

const SHRESTRICTIONITEMS c_rgRestrictionItems[] =
{
    // explorer restrictions
    { REST_NOTOOLBARCUSTOMIZE,      c_szExplorerKey,    TEXT("NoToolbarCustomize") },
    { REST_NOBANDCUSTOMIZE,         c_szExplorerKey,    TEXT("NoBandCustomize")    },
    { REST_SMALLICONS,              c_szExplorerKey,    TEXT("SmallIcons")        },
    { REST_LOCKICONSIZE,            c_szExplorerKey,    TEXT("LockIconSize")      },
    { REST_SPECIFYDEFAULTBUTTONS,   c_szExplorerKey,    TEXT("SpecifyDefaultButtons") },
    { REST_BTN_BACK,                c_szExplorerKey,    TEXT("Btn_Back")      },
    { REST_BTN_FORWARD,             c_szExplorerKey,    TEXT("Btn_Forward")   },
    { REST_BTN_STOPDOWNLOAD,        c_szExplorerKey,    TEXT("Btn_Stop")      },
    { REST_BTN_REFRESH,             c_szExplorerKey,    TEXT("Btn_Refresh")    },
    { REST_BTN_HOME,                c_szExplorerKey,    TEXT("Btn_Home")      },
    { REST_BTN_SEARCH,              c_szExplorerKey,    TEXT("Btn_Search")    },
    { REST_BTN_HISTORY,             c_szExplorerKey,    TEXT("Btn_History")   },
    { REST_BTN_FAVORITES,           c_szExplorerKey,    TEXT("Btn_Favorites") },
    { REST_BTN_ALLFOLDERS,          c_szExplorerKey,    TEXT("Btn_Folders")       },
    { REST_BTN_THEATER,             c_szExplorerKey,    TEXT("Btn_Fullscreen") },
    { REST_BTN_TOOLS,               c_szExplorerKey,    TEXT("Btn_Tools")     },
    { REST_BTN_MAIL,                c_szExplorerKey,    TEXT("Btn_MailNews")  },
    { REST_BTN_FONTS,               c_szExplorerKey,    TEXT("Btn_Size")      },
    { REST_BTN_PRINT,               c_szExplorerKey,    TEXT("Btn_Print")     },
    { REST_BTN_EDIT,                c_szExplorerKey,    TEXT("Btn_Edit")          },
    { REST_BTN_DISCUSSIONS,         c_szExplorerKey,    TEXT("Btn_Discussions")   },
    { REST_BTN_CUT,                 c_szExplorerKey,    TEXT("Btn_Cut")           },
    { REST_BTN_COPY,                c_szExplorerKey,    TEXT("Btn_Copy")          },
    { REST_BTN_PASTE,               c_szExplorerKey,    TEXT("Btn_Paste")         },
    { REST_BTN_ENCODING,            c_szExplorerKey,    TEXT("Btn_Encoding")          },
    { REST_BTN_PRINTPREVIEW,        c_szExplorerKey,    TEXT("Btn_PrintPreview")        },
    { REST_NoUserAssist,            c_szExplorerKey,    TEXT("NoInstrumentation"),      },
    { REST_NoWindowsUpdate,         c_szExplorerKey,    TEXT("NoWindowsUpdate"),        },
    { REST_NoExpandedNewMenu,       c_szExplorerKey,    TEXT("NoExpandedNewMenu"),      },
    { REST_BTN_MEDIABAR,            c_szExplorerKey,    TEXT("Btn_Media"),      },
    // ported from SP1
    { REST_NOFILEURL,               c_szExplorerKey,       TEXT("NoFileUrl"),          },
    // infodelivery restrictions
    { REST_NoChannelUI,             c_szInfodeliveryKey,   TEXT("NoChannelUI")        },
    { REST_NoAddingChannels,        c_szInfodeliveryKey,   TEXT("NoAddingChannels") },
    { REST_NoEditingChannels,       c_szInfodeliveryKey,   TEXT("NoEditingChannels") },
    { REST_NoRemovingChannels,      c_szInfodeliveryKey,   TEXT("NoRemovingChannels") },
    { REST_NoAddingSubscriptions,   c_szInfodeliveryKey,   TEXT("NoAddingSubscriptions") },
    { REST_NoEditingSubscriptions,  c_szInfodeliveryKey,   TEXT("NoEditingSubscriptions") },
    { REST_NoRemovingSubscriptions, c_szInfodeliveryKey,   TEXT("NoRemovingSubscriptions") },
    { REST_NoChannelLogging,        c_szInfodeliveryKey,   TEXT("NoChannelLogging")         },
    { REST_NoManualUpdates,         c_szInfodeliveryKey,   TEXT("NoManualUpdates")        },
    { REST_NoScheduledUpdates,      c_szInfodeliveryKey,   TEXT("NoScheduledUpdates")     },
    { REST_NoUnattendedDialing,     c_szInfodeliveryKey,   TEXT("NoUnattendedDialing")    },
    { REST_NoChannelContent,        c_szInfodeliveryKey,   TEXT("NoChannelContent")       },
    { REST_NoSubscriptionContent,   c_szInfodeliveryKey,   TEXT("NoSubscriptionContent")  },
    { REST_NoEditingScheduleGroups, c_szInfodeliveryKey,   TEXT("NoEditingScheduleGroups") },
    { REST_MaxChannelSize,          c_szInfodeliveryKey,   TEXT("MaxChannelSize")         },
    { REST_MaxSubscriptionSize,     c_szInfodeliveryKey,   TEXT("MaxSubscriptionSize")    },
    { REST_MaxChannelCount,         c_szInfodeliveryKey,   TEXT("MaxChannelCount")        },
    { REST_MaxSubscriptionCount,    c_szInfodeliveryKey,   TEXT("MaxSubscriptionCount")   },
    { REST_MinUpdateInterval,       c_szInfodeliveryKey,   TEXT("MinUpdateInterval")      },
    { REST_UpdateExcludeBegin,      c_szInfodeliveryKey,   TEXT("UpdateExcludeBegin")     },
    { REST_UpdateExcludeEnd,        c_szInfodeliveryKey,   TEXT("UpdateExcludeEnd")       },
    { REST_UpdateInNewProcess,      c_szInfodeliveryKey,   TEXT("UpdateInNewProcess")     },
    { REST_MaxWebcrawlLevels,       c_szInfodeliveryKey,   TEXT("MaxWebcrawlLevels")      },
    { REST_MaxChannelLevels,        c_szInfodeliveryKey,   TEXT("MaxChannelLevels")       },
    { REST_NoSubscriptionPasswords, c_szInfodeliveryKey,   TEXT("NoSubscriptionPasswords")},
    { REST_NoBrowserSaveWebComplete,c_szInfodeliveryKey,   TEXT("NoBrowserSaveWebComplete") },
    { REST_NoSearchCustomization,   c_szInfodeliveryKey,   TEXT("NoSearchCustomization"),  },
    { REST_NoSplash,                c_szInfodeliveryKey,   TEXT("NoSplash"),  },

    // browser restrictions ported from SP2
    { REST_NoFileOpen,              c_szBrowserKey,         TEXT("NoFileOpen"),             },
    { REST_NoFileNew,               c_szBrowserKey,         TEXT("NoFileNew"),              },
    { REST_NoBrowserSaveAs ,        c_szBrowserKey,         TEXT("NoBrowserSaveAs"),        },
    { REST_NoBrowserOptions,        c_szBrowserKey,         TEXT("NoBrowserOptions"),       },
    { REST_NoFavorites,             c_szBrowserKey,         TEXT("NoFavorites"),            },
    { REST_NoSelectDownloadDir,     c_szBrowserKey,         TEXT("NoSelectDownloadDir"),    },
    { REST_NoBrowserContextMenu,    c_szBrowserKey,         TEXT("NoBrowserContextMenu"),   },
    { REST_NoBrowserClose,          c_szBrowserKey,         TEXT("NoBrowserClose"),         },
    { REST_NoOpeninNewWnd,          c_szBrowserKey,         TEXT("NoOpeninNewWnd"),         },
    { REST_NoTheaterMode,           c_szBrowserKey,         TEXT("NoTheaterMode"),          },
    { REST_NoFindFiles,             c_szBrowserKey,         TEXT("NoFindFiles"),            },
    { REST_NoViewSource,            c_szBrowserKey,         TEXT("NoViewSource"),           },
    { REST_GoMenu,                  c_szBrowserKey,         TEXT("RestGoMenu"),             },
    { REST_NoToolbarOptions,        c_szToolbarKey,         TEXT("NoToolbarOptions"),       },
    { REST_AlwaysPromptWhenDownload,c_szBrowserKey,         TEXT("AlwaysPromptWhenDownload"),},

    { REST_NoHelpItem_TipOfTheDay,  c_szBrowserKey,         TEXT("NoHelpItemTipOfTheDay"),  },
    { REST_NoHelpItem_NetscapeHelp, c_szBrowserKey,         TEXT("NoHelpItemNetscapeHelp"), },
    { REST_NoHelpItem_Tutorial,     c_szBrowserKey,         TEXT("NoHelpItemTutorial"),     },
    { REST_NoHelpItem_SendFeedback, c_szBrowserKey,         TEXT("NoHelpItemSendFeedback"), },

    { REST_NoNavButtons,            c_szBrowserKey,         TEXT("NoNavButtons"),           },
    { REST_NoHelpMenu,              c_szBrowserKey,         TEXT("NoHelpMenu"),             },
    { REST_NoBrowserBars,           c_szBrowserKey,         TEXT("NoBrowserBars"),          },
    { REST_NoToolBar,               c_szToolbarKey,         TEXT("NoToolBar"),              },
    { REST_NoAddressBar,            c_szToolbarKey,         TEXT("NoAddressBar"),           },
    { REST_NoLinksBar,              c_szToolbarKey,         TEXT("NoLinksBar"),             },
    
    { REST_NoPrinting,              c_szBrowserKey,         TEXT("NoPrinting")              },

    { REST_No_LaunchMediaBar,       c_szBrowserKey,         TEXT("No_LaunchMediaBar")       },
    { REST_No_MediaBarOnlineContent, c_szBrowserKey,        TEXT("No_MediaBarOnlineContent") },

    {0, NULL, NULL},
};

typedef struct {
    BROWSER_RESTRICTIONS rest;
    DWORD dwAction;    
} ACTIONITEM;

const ACTIONITEM c_ActionItems[] = {
    { REST_NoAddingChannels,        URLACTION_INFODELIVERY_NO_ADDING_CHANNELS },
    { REST_NoEditingChannels,       URLACTION_INFODELIVERY_NO_EDITING_CHANNELS },
    { REST_NoRemovingChannels,      URLACTION_INFODELIVERY_NO_REMOVING_CHANNELS },
    { REST_NoAddingSubscriptions,   URLACTION_INFODELIVERY_NO_ADDING_SUBSCRIPTIONS },
    { REST_NoEditingSubscriptions,  URLACTION_INFODELIVERY_NO_EDITING_SUBSCRIPTIONS },
    { REST_NoRemovingSubscriptions, URLACTION_INFODELIVERY_NO_REMOVING_SUBSCRIPTIONS },
    { REST_NoChannelLogging,        URLACTION_INFODELIVERY_NO_CHANNEL_LOGGING },
};

#define REST_WITHACTION_FIRST   REST_NoAddingChannels
#define REST_WITHACTION_LAST    REST_NoChannelLogging

#define RESTRICTIONMAX (c_rgRestrictionItems[ARRAYSIZE(c_rgRestrictionItems) - 1].rest)

DWORD g_rgRestrictionItemValues[ARRAYSIZE(c_rgRestrictionItems)];

DWORD SHRestricted2W(BROWSER_RESTRICTIONS rest, LPCWSTR pwzUrl, DWORD dwReserved)
{
    // Validate restriction and dwReserved
    if (dwReserved)
    {
        RIPMSG(0, "SHRestricted2W: Invalid dwReserved");
        return 0;
    }

    if (!(InRange(rest, REST_EXPLORER_FIRST, REST_EXPLORER_LAST))
        && !(InRange(rest, REST_INFO_FIRST, REST_INFO_LAST))
        && !(InRange(rest, REST_BROWSER_FIRST, REST_BROWSER_LAST)))
    {
        RIPMSG(0, "SHRestricted2W: Invalid browser restriction");
        return 0;
    }

    // See if the restriction is in place in the URL zone
    // FEATURE: Should we assert on NULL URLs if the restriction is per zone?
    // It might be reasonable to query the global setting.
    if (pwzUrl && InRange(rest, REST_WITHACTION_FIRST, REST_WITHACTION_LAST))
    {
        // Compute the index into the table
        int index = rest - REST_WITHACTION_FIRST;

        ASSERT(c_ActionItems[index].dwAction);

        IInternetSecurityManager *pism = NULL;
        HRESULT hr;
        hr = CoCreateInstance(CLSID_InternetSecurityManager, NULL, CLSCTX_INPROC_SERVER,
                              IID_IInternetSecurityManager, (void**)&pism);
        if (SUCCEEDED(hr) && pism)
        {
            DWORD dwPolicy = 0;
            DWORD dwContext = 0;
            hr = pism->ProcessUrlAction(pwzUrl,
                                        c_ActionItems[index].dwAction,
                                        (BYTE *)&dwPolicy,
                                        sizeof(dwPolicy),
                                        (BYTE *)&dwContext,
                                        sizeof(dwContext),
                                        PUAF_NOUI,
                                        0);
            pism->Release();
            if (SUCCEEDED(hr))
            {
                if (GetUrlPolicyPermissions(dwPolicy) == URLPOLICY_ALLOW)
                    return 0;
                else
                    return 1;    // restrict for query and disallow
            }
        }
    }

    // The cache may be invalid. Check first! We have to use
    // a global named semaphore in case this function is called
    // from a process other than the shell process. (And we're
    // sharing the same count between shell32 and shdocvw.)
    static HANDLE hRestrictions = NULL;
    static long lRestrictionCount = -1;
    if (hRestrictions == NULL)
        hRestrictions = SHGlobalCounterCreate(GUID_Restrictions);
    long lGlobalCount = SHGlobalCounterGetValue(hRestrictions);
    if (lGlobalCount != lRestrictionCount)
    {
        memset((LPBYTE)g_rgRestrictionItemValues, (BYTE)-1, SIZEOF(g_rgRestrictionItemValues));

        lRestrictionCount = lGlobalCount;
    }

    LPCWSTR pszBaseKey;
    if (InRange(rest, REST_EXPLORER_FIRST, REST_EXPLORER_LAST))
        pszBaseKey = c_szExplorerBase;
    else
    {
        if (InRange(rest, REST_BROWSER_FIRST, REST_BROWSER_LAST))
            pszBaseKey = c_szBrowserBase;
        else 
            pszBaseKey = c_szInfodeliveryBase;
    }

    return SHRestrictionLookup(rest, pszBaseKey, c_rgRestrictionItems, g_rgRestrictionItemValues);
}

DWORD SHRestricted2A(BROWSER_RESTRICTIONS rest, LPCSTR pszUrl, DWORD dwReserved)
{
    if (pszUrl)
    {
        WCHAR wzUrl[MAX_URL_STRING];

        ASSERT(ARRAYSIZE(wzUrl) > lstrlenA(pszUrl));        // We only work for Urls of MAX_URL_STRING or shorter.
        AnsiToUnicode(pszUrl, wzUrl, ARRAYSIZE(wzUrl));

        return SHRestricted2W(rest, wzUrl, dwReserved);
    }
    else
    {
        return SHRestricted2W(rest, NULL, dwReserved);
    }
}

/**********************************************************************
*
\**********************************************************************/

#define MAX_SUBSTR_SIZE     100
typedef struct tagURLSub
{
    LPCTSTR szTag;
    DWORD dwType;
} URLSUB;

const static URLSUB c_UrlSub[] = {
    {TEXT("{SUB_PRD}"),     URLSUB_PRD},
    {TEXT("{SUB_PVER}"),    URLSUB_PVER},
    {TEXT("{SUB_OS}"),      URLSUB_OS},
    {TEXT("{SUB_OVER}"),    URLSUB_OVER},
    {TEXT("{SUB_OLCID}"),   URLSUB_OLCID},
    {TEXT("{SUB_CLCID}"),   URLSUB_CLCID},
    {TEXT("{SUB_CLSID}"),   URLSUB_CLCID},  // legacy support (do NOT use "SUB_CLSID" in new URLs)
    {TEXT("{SUB_RFC1766}"), URLSUB_RFC1766}
};

void GetWebLocaleAsRFC1766(LPTSTR pszLocale, int cchLocale)
{
    LCID lcid;
    TCHAR szValue[MAX_PATH];

    DWORD cbVal = sizeof(szValue);
    DWORD dwType;

    ASSERT(NULL != pszLocale);

    *pszLocale = TEXT('\0');
    
    if ((SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_INTERNATIONAL,
                    REGSTR_VAL_ACCEPT_LANGUAGE, 
                    &dwType, szValue, &cbVal) == ERROR_SUCCESS) &&
        (REG_SZ == dwType))
    {
        TCHAR *psz = szValue;

        //  Use the first one we find so terminate at the comma or semicolon
        while (*psz && (*psz != TEXT(',')) && (*psz != TEXT(';')))
        {
            psz = CharNext(psz);
        }
        *psz = TEXT('\0');

        //  If it's user defined, this will fail and we will fall back
        //  to the system default.
        if (SUCCEEDED(Rfc1766ToLcid(&lcid, szValue)))
        {
            StrCpyN(pszLocale, szValue, cchLocale);
        }
    }

    if (TEXT('\0') == *pszLocale)
    {
        //  No entry in the registry or it's a user defined header.
        //  Either way we fall back to the system default.

        LcidToRfc1766(GetUserDefaultLCID(), pszLocale, cchLocale);
    }
}

HRESULT URLSubstitution(LPCWSTR pszUrlIn, LPWSTR pszUrlOut, DWORD cchSize, DWORD dwSubstitutions)
{
    HRESULT hr = S_OK;
    DWORD dwIndex;
    WCHAR szTempUrl[MAX_URL_STRING];
    ASSERT(cchSize <= ARRAYSIZE(szTempUrl));    // We will truncate anything longer than MAX_URL_STRING

    StrCpyNW(szTempUrl, pszUrlIn, ARRAYSIZE(szTempUrl));

    for (dwIndex = 0; dwIndex < ARRAYSIZE(c_UrlSub); dwIndex++)
    {
        while (IsFlagSet(dwSubstitutions, c_UrlSub[dwIndex].dwType))
        {
            LPWSTR pszTag = StrStr(szTempUrl, c_UrlSub[dwIndex].szTag);

            if (pszTag)
            {
                TCHAR szCopyUrl[MAX_URL_STRING];
                TCHAR szSubStr[MAX_SUBSTR_SIZE];  // The Substitution

                // Copy URL Before Substitution.
                StrCpyN(szCopyUrl, szTempUrl, (int)(pszTag-szTempUrl+1));
                pszTag += lstrlen(c_UrlSub[dwIndex].szTag);

                switch (c_UrlSub[dwIndex].dwType)
                {
                case URLSUB_PRD:
                    MLLoadString(IDS_SUBSTR_PRD, szSubStr, ARRAYSIZE(szSubStr));
                    break;

                case URLSUB_PVER:
                    MLLoadString(IDS_SUBSTR_PVER, szSubStr, ARRAYSIZE(szSubStr));
                    break;

                case URLSUB_OS:
                    {
                        LPCTSTR pszWin95    = _T("95"); // Windows 95
                        LPCTSTR pszWin98    = _T("98"); // Windows 98 (Memphis)
                        LPCTSTR pszWinME    = _T("ME"); // Windows Millenium
                        LPCTSTR pszWinNT4   = _T("N4"); // Windows NT 4
                        LPCTSTR pszWinNT5   = _T("N5"); // Windows 2000
                        LPCTSTR pszWinNT6   = _T("N6"); // Windows XP (Whistler)
                        LPCTSTR pszUnknown  = _T("");   // error
                        LPCTSTR psz         = pszUnknown;

                        if (IsOS(OS_WINDOWS))
                        {
                            if (IsOS(OS_MILLENNIUMORGREATER))
                                psz = pszWinME;
                            else if (IsOS(OS_WIN98ORGREATER))
                                psz = pszWin98;
                            else if (IsOS(OS_WIN95ORGREATER))
                                psz = pszWin95;
                            else
                            {
                                ASSERT(FALSE); // What OS is this?
                            }
                        }
                        else if (IsOS(OS_NT))
                        {
                            if (IsOS(OS_WHISTLERORGREATER))
                                psz = pszWinNT6;
                            else if (IsOS(OS_WIN2000ORGREATER))
                                psz = pszWinNT5;
                            else if (IsOS(OS_NT4ORGREATER))
                                psz = pszWinNT4;
                            else
                            {
                                ASSERT(FALSE); // What OS is this?
                            }
                        }
                        else
                        {
                            ASSERT(FALSE); // What OS is this?
                        }

                        StrCpyN(szSubStr, psz, ARRAYSIZE(szSubStr));
                    }
                    break;

                case URLSUB_OVER:
                    {
                        LPCTSTR pszVersion_5_1  = _T("5.1");    // Version 5.1 (Whistler)
                        LPCTSTR pszUnknown      = _T("");       // error
                        LPCTSTR psz             = pszUnknown;

                        if (IsOS(OS_WINDOWS))
                        {
                            ASSERT(FALSE); // Not supported under Windows Millenium or lesser.
                        }
                        else if (IsOS(OS_NT))
                        {
                            if (IsOS(OS_WHISTLERORGREATER))
                                psz = pszVersion_5_1;
                            else
                            {
                                ASSERT(FALSE);  // Not supported under Windows 2000 or lesser.
                            }
                        }
                        else
                        {
                            ASSERT(FALSE);  // What OS is this?
                        }

                        StrCpyN(szSubStr, psz, ARRAYSIZE(szSubStr));
                    }
                    break;

                case URLSUB_OLCID:
                    wnsprintf(szSubStr, ARRAYSIZE(szSubStr), _T("%#04lx"), GetSystemDefaultLCID());
                    break;

                case URLSUB_CLCID:
                    wnsprintf(szSubStr, ARRAYSIZE(szSubStr), _T("%#04lx"), GetUserDefaultLCID());
                    break;

                case URLSUB_RFC1766:
                    GetWebLocaleAsRFC1766(szSubStr, ARRAYSIZE(szSubStr));
                    break;

                default:
                    szSubStr[0] = TEXT('\0');
                    ASSERT(FALSE);  // Not Impl.
                    hr = E_NOTIMPL;
                    break;
                }
                // Add the Substitution String to the end (will become the middle)
                StrCatBuff(szCopyUrl, szSubStr, ARRAYSIZE(szCopyUrl));
                // Add the rest of the URL after the substitution substring.
                StrCatBuff(szCopyUrl, pszTag, ARRAYSIZE(szCopyUrl));
                StrCpyN(szTempUrl, szCopyUrl, ARRAYSIZE(szTempUrl));
            }
            else
                break;  // This will allow us to replace all the occurances of this string.
        }
    }
    StrCpyN(pszUrlOut, szTempUrl, cchSize);

    return hr;
}


// inetcpl.cpl uses this.
STDAPI URLSubRegQueryA(LPCSTR pszKey, LPCSTR pszValue, BOOL fUseHKCU,
                           LPSTR pszUrlOut, DWORD cchSizeOut, DWORD dwSubstitutions)
{
    HRESULT hr;
    TCHAR szKey[MAX_PATH];
    TCHAR szValue[MAX_PATH];
    TCHAR szUrlOut[MAX_URL_STRING];

    AnsiToTChar(pszKey, szKey, ARRAYSIZE(szKey));
    AnsiToTChar(pszValue, szValue, ARRAYSIZE(szValue));
    hr = URLSubRegQueryW(szKey, szValue, fUseHKCU, szUrlOut, ARRAYSIZE(szUrlOut), dwSubstitutions);
    TCharToAnsi(szUrlOut, pszUrlOut, cchSizeOut);

    return hr;
}


HRESULT URLSubRegQueryW(LPCWSTR pszKey, LPCWSTR pszValue, BOOL fUseHKCU,
                           LPWSTR pszUrlOut, DWORD cchSizeOut, DWORD dwSubstitutions)
{
    HRESULT hr = E_FAIL;
    WCHAR szTempUrl[MAX_URL_STRING];
    DWORD ccbSize = sizeof(szTempUrl);
    if (ERROR_SUCCESS == SHRegGetUSValueW(pszKey, pszValue, NULL, szTempUrl,
                                &ccbSize, !fUseHKCU, NULL, NULL))
    {
        hr = URLSubstitution(szTempUrl, pszUrlOut, cchSizeOut, dwSubstitutions);
    }

    return hr;
}

// note that anyone inside shdocvw should pass hInst==NULL to
// ensure that pluggable UI works correctly. anyone outside of shdocvw
// must pass an hInst for their appropriate resource dll
HRESULT URLSubLoadString(HINSTANCE hInst, UINT idRes, LPWSTR pszUrlOut,
                         DWORD cchSizeOut, DWORD dwSubstitutions)
{
    HRESULT hr = E_FAIL;
    WCHAR   szTempUrl[MAX_URL_STRING];
    int     nStrLen;

    nStrLen = 0;

    if (hInst == NULL)
    {
        // this is for internal users who want pluggable UI to work
        nStrLen = MLLoadStringW(idRes, szTempUrl, ARRAYSIZE(szTempUrl));
    }
    else
    {
        // this is for external users who use us to load some
        // of their own resources but whom we can't change (like shell32)
        nStrLen = LoadStringWrap(hInst, idRes, szTempUrl, ARRAYSIZE(szTempUrl));
    }

    if (nStrLen > 0)
    {
        hr = URLSubstitution(szTempUrl, pszUrlOut, cchSizeOut, dwSubstitutions);
    }

    return hr;
}


/**********************************************************************\
        ILIsUrlChild() will find pidls that exist under "Desktop\The Internet"
    section of the Shell Name Space.  This function includes those items
    and file system items that have a "txt/html.
\**********************************************************************/
BOOL ILIsWeb(LPCITEMIDLIST pidl)
{
    BOOL fIsWeb = FALSE;

    if (pidl)
    {
        if (IsURLChild(pidl, TRUE))
            fIsWeb = TRUE;
        else
        {
            TCHAR szPath[MAX_PATH];

            fIsWeb = (!ILIsRooted(pidl)
            && SUCCEEDED(SHGetPathFromIDList(pidl, szPath)) 
            && (PathIsHTMLFile(szPath) ||
                 PathIsContentType(szPath, TEXT("text/xml"))));
        }
    }

    return fIsWeb;
}

//
// in:
//      pidlTo

STDAPI CreateLinkToPidl(LPCITEMIDLIST pidlTo, LPCTSTR pszDir, LPCTSTR pszTitle, LPTSTR pszOut, int cchOut)
{
    HRESULT hr = E_FAIL;
    TCHAR szPathDest[MAX_URL_STRING];
    BOOL fCopyLnk;

    if (SHGetNewLinkInfo((LPCTSTR)pidlTo, pszDir, szPathDest, &fCopyLnk, SHGNLI_PIDL))
    {
        IShellLinkA *pslA;  // Use A version for W95.
        if (SUCCEEDED(CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellLinkA, &pslA))))
        {
            TCHAR szPathSrc[MAX_URL_STRING];
            DWORD dwAttributes = SFGAO_FILESYSTEM | SFGAO_FOLDER;
            SHGetNameAndFlags(pidlTo, SHGDN_FORPARSING | SHGDN_FORADDRESSBAR, szPathSrc, ARRAYSIZE(szPathSrc), &dwAttributes);

            if (fCopyLnk) 
            {
                if (((dwAttributes & (SFGAO_FILESYSTEM | SFGAO_FOLDER)) == SFGAO_FILESYSTEM) && CopyFile(szPathSrc, szPathDest, TRUE))
                {
                    SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, szPathDest, NULL);
                    SHChangeNotify(SHCNE_FREESPACE, SHCNF_PATH, szPathDest, NULL);
                    hr = S_OK;
                }
                else
                {
                    // load the source object that will be "copied" below (with the ::Save call)
                    SAFERELEASE(pslA);
                    hr = SHGetUIObjectFromFullPIDL(pidlTo, NULL, IID_PPV_ARG(IShellLinkA, &pslA));
                    // this pslA is released at the end of the topmost if
                    if (SUCCEEDED(hr))
                    {
                        IPersistFile *ppf;
                        hr = pslA->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
                        if (SUCCEEDED(hr))
                        {
                            hr = ppf->Save(szPathDest, TRUE);
                            ppf->Release();
                        }
                    }
                }
            } 
            else 
            {
                pslA->SetIDList(pidlTo);

                // make sure the working directory is set to the same
                // directory as the app (or document).
                //
                // dont do this for non-FS pidls (ie control panel)

                if (SFGAO_FILESYSTEM == (dwAttributes & SFGAO_FILESYSTEM | SFGAO_FOLDER)) 
                {
                    ASSERT(!PathIsRelative(szPathSrc));
                    PathRemoveFileSpec(szPathSrc);
                    // Try to get the W version.
                    IShellLinkW* pslW;
                    if (SUCCEEDED(pslA->QueryInterface(IID_PPV_ARG(IShellLinkW, &pslW))))
                    {
                        pslW->SetWorkingDirectory(szPathSrc);
                        pslW->Release();
                    }
                    else
                    {
                        CHAR szPathSrcA[MAX_URL_STRING];
                        SHUnicodeToAnsi(szPathSrc, szPathSrcA, ARRAYSIZE(szPathSrcA));
                        pslA->SetWorkingDirectory(szPathSrcA);
                    }
                }

                IPersistFile *ppf;
                hr = pslA->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
                if (SUCCEEDED(hr)) 
                {
                    if (pszTitle && pszTitle[0]) 
                    {
                        PathRemoveFileSpec(szPathDest);
                        PathAppend(szPathDest, pszTitle);
                        StrCatBuff(szPathDest, TEXT(".lnk"), ARRAYSIZE(szPathDest));
                    }
                    hr = ppf->Save(szPathDest, TRUE);
                    if (pszOut)
                    {
                        StrCpyN(pszOut, szPathDest, cchOut);
                    }
                    ppf->Release();
                }
            }

            SAFERELEASE(pslA);
        }
    }

    return hr;
}

int GetColorComponent(LPTSTR *ppsz)
{
    int iColor = 0;
    if (*ppsz) {
        LPTSTR pBuf = *ppsz;
        iColor = StrToInt(pBuf);

        // find the next comma
        while(pBuf && *pBuf && *pBuf!=TEXT(','))
            pBuf++;

        // if valid and not NULL...
        if (pBuf && *pBuf)
            pBuf++;         // increment

        *ppsz = pBuf;
    }
    return iColor;
}

// Read the registry for a string (REG_SZ) of comma separated RGB values
COLORREF RegGetColorRefString( HKEY hkey, LPTSTR RegValue, COLORREF Value)
{
    TCHAR SmallBuf[80];
    TCHAR *pBuf;
    int iRed, iGreen, iBlue;

    DWORD cb = ARRAYSIZE(SmallBuf);
    if (RegQueryValueEx(hkey, RegValue, NULL, NULL, (LPBYTE)&SmallBuf, &cb)
        == ERROR_SUCCESS)
    {
        pBuf = SmallBuf;

        iRed = GetColorComponent(&pBuf);
        iGreen = GetColorComponent(&pBuf);
        iBlue = GetColorComponent(&pBuf);

        // make sure all values are valid
        iRed    %= 256;
        iGreen  %= 256;
        iBlue   %= 256;

        Value = RGB(iRed, iGreen, iBlue);
    }

    return Value;
}

#ifdef DEBUG // {
//***   SearchDW -- scan for DWORD in buffer
// ENTRY/EXIT
//  pdwBuf  buffer
//  cbBuf   size of buffer in *bytes* (*not* DWORDs)
//  dwVal   DWORD we're looking for
//  dOff    (return) byte offset in buffer; o.w. -1 if not found
//
int SearchDW(DWORD *pdwBuf, int cbBuf, DWORD dwVal)
{
    int dOff;

    for (dOff = 0; dOff < cbBuf; dOff += SIZEOF(DWORD), pdwBuf++) {
        if (*pdwBuf == dwVal)
            return dOff;
    }

    return -1;
}
#endif // }

// NOTE: These are directly copied from fsnotify.c in shell32. Please make sure
// NOTE: any changes are reflected there also.

// this is the NEW SHCNE_UPDATEIMAGE stuff, it passes renough data so that the recieving process
// has a vague chance that it can find the right index to refresh.
STDAPI_(void) _SHUpdateImageA( LPCSTR pszHashItem, int iIndex, UINT uFlags, int iImageIndex )
{
    WCHAR szWHash[MAX_PATH];

    MultiByteToWideChar( CP_ACP, 0, pszHashItem, -1, szWHash, MAX_PATH );

    _SHUpdateImageW( szWHash, iIndex, uFlags, iImageIndex );
}

STDAPI_(void) _SHUpdateImageW( LPCWSTR pszHashItem, int iIndex, UINT uFlags, int iImageIndex )
{
    SHChangeUpdateImageIDList rgPidl;
    SHChangeDWORDAsIDList rgDWord;

    int cLen = MAX_PATH - (lstrlenW( pszHashItem ) + 1);
    cLen *= sizeof( WCHAR );

    if ( cLen < 0 )
        cLen = 0;

    // make sure we send a valid index
    if ( iImageIndex == -1 )
        iImageIndex = II_DOCUMENT;

    rgPidl.dwProcessID = GetCurrentProcessId();
    rgPidl.iIconIndex = iIndex;
    rgPidl.iCurIndex = iImageIndex;
    rgPidl.uFlags = uFlags;
    StrCpyNW( rgPidl.szName, pszHashItem, MAX_PATH );
    rgPidl.cb = (USHORT)(sizeof( rgPidl ) - cLen);
    _ILNext( (LPITEMIDLIST) &rgPidl )->mkid.cb = 0;

    rgDWord.cb = (unsigned short) PtrDiff(&rgDWord.cbZero, &rgDWord);
    rgDWord.dwItem1 = (DWORD) iImageIndex;
    rgDWord.dwItem2 = 0;
    rgDWord.cbZero = 0;

    // pump it as an extended event
    SHChangeNotify( SHCNE_UPDATEIMAGE, SHCNF_IDLIST, &rgDWord, &rgPidl );
}

STDAPI_(int) _SHHandleUpdateImage( LPCITEMIDLIST pidlExtra )
{
    SHChangeUpdateImageIDList * pUs = (SHChangeUpdateImageIDList*) pidlExtra;

    if ( !pUs )
    {
        return -1;
    }

    // if in the same process, or an old style notification
    if ( pUs->dwProcessID == GetCurrentProcessId())
    {
        return (int) pUs->iCurIndex;
    }
    else
    {
        WCHAR szBuffer[MAX_PATH];
        int iIconIndex = *(int UNALIGNED *)((BYTE *)&pUs->iIconIndex);
        UINT uFlags = *(UINT UNALIGNED *)((BYTE *)&pUs->uFlags);

        ualstrcpynW( szBuffer, pUs->szName, ARRAYSIZE(szBuffer) );

        // we are in a different process, look up the hash in our index to get the right one...

        return Shell_GetCachedImageIndex( szBuffer, iIconIndex, uFlags );
    }
}

VOID CleanExploits(PWSTR psz)
{
    while (*psz)
    {
        if (*psz<L' ')
        {
            *psz = L' ';
        }
        psz++;
    }
}

HRESULT FormatUrlForDisplay(LPWSTR pwzURL, LPWSTR pwzFriendly, UINT cchBuf, LPWSTR pwzFrom, UINT cbFrom, BOOL fSeperate, DWORD dwCodePage, PWSTR pwzCachedFileName)
{
    const   DWORD       dwMaxPathLen        = 32;
    const   DWORD       dwMaxHostLen        = 32;
    const   DWORD       dwMaxTemplateLen    = 64;
    const   DWORD       dwElipsisLen        = 3;
    const   CHAR        rgchElipsis[]       = "...";
    const   WCHAR       rgwchElipsis[]       = L"...";

    HRESULT hrRC = E_FAIL;
    HRESULT hr;

    if (pwzURL==NULL || pwzFriendly==NULL)
        return E_POINTER;

    *pwzFriendly = '\0';

    if (!*pwzURL)
        return S_OK;

    if (!cchBuf)
        return E_FAIL;

    // Wininet can't deal with code pages other than CP_ACP so convert the URL ourself and call InterCrackUrlA
    URL_COMPONENTSA urlComp;
    CHAR   rgchScheme[INTERNET_MAX_SCHEME_LENGTH];
    CHAR   rgchHostName[INTERNET_MAX_HOST_NAME_LENGTH];
    CHAR   rgchUrlPath[MAX_PATH];
    CHAR   rgchCanonicalUrl[MAX_URL_STRING];
    LPSTR  pszURL;
    DWORD  dwLen;

    dwLen = MAX_URL_STRING * 2;
    if ((pszURL = (LPSTR)LocalAlloc(LPTR, dwLen * sizeof(CHAR))) != NULL)
    {
        SHUnicodeToAnsiCP(dwCodePage, pwzURL, pszURL, dwLen);

        dwLen = ARRAYSIZE(rgchCanonicalUrl);
        hr = UrlCanonicalizeA(pszURL, rgchCanonicalUrl, &dwLen, 0);
        if (SUCCEEDED(hr))
        {
            ZeroMemory(&urlComp, sizeof(urlComp));

            urlComp.dwStructSize = sizeof(urlComp);
            urlComp.lpszHostName = rgchHostName;
            urlComp.dwHostNameLength = ARRAYSIZE(rgchHostName);
            urlComp.lpszUrlPath = rgchUrlPath;
            urlComp.dwUrlPathLength = ARRAYSIZE(rgchUrlPath);
            urlComp.lpszScheme = rgchScheme;
            urlComp.dwSchemeLength = ARRAYSIZE(rgchScheme);

            hr = InternetCrackUrlA(rgchCanonicalUrl, lstrlenA(rgchCanonicalUrl), 0, &urlComp);
            if (SUCCEEDED(hr))
            {
                DWORD dwPathLen = lstrlenA(rgchUrlPath);
                DWORD dwHostLen = lstrlenA(rgchHostName);
                DWORD dwSchemeLen = lstrlenA(rgchScheme);

                CHAR   rgchHostForDisplay[INTERNET_MAX_HOST_NAME_LENGTH];
                CHAR   rgchPathForDisplay[MAX_PATH];

                ZeroMemory(rgchHostForDisplay, sizeof(rgchHostForDisplay));
                ZeroMemory(rgchPathForDisplay, sizeof(rgchPathForDisplay));

                if (dwHostLen>dwMaxHostLen)
                {
                    DWORD   dwOverFlow = dwHostLen - dwMaxHostLen + dwElipsisLen + 1;
                    wnsprintfA(rgchHostForDisplay, ARRAYSIZE(rgchHostForDisplay), "%s%s", rgchElipsis, rgchHostName+dwOverFlow);
                    dwHostLen = dwMaxHostLen;
                }
                else
                    StrCpyNA(rgchHostForDisplay, rgchHostName, ARRAYSIZE(rgchHostForDisplay));

                if (dwPathLen>dwMaxPathLen)
                {
                    DWORD   dwOverFlow = dwPathLen - dwMaxPathLen + dwElipsisLen;
                    wnsprintfA(rgchPathForDisplay, ARRAYSIZE(rgchPathForDisplay), "/%s%s", rgchElipsis, rgchUrlPath+dwOverFlow);
                    dwPathLen = dwMaxPathLen;
                }
                else
                    StrCpyNA(rgchPathForDisplay, rgchUrlPath, ARRAYSIZE(rgchPathForDisplay));

                WCHAR   rgwchScheme[INTERNET_MAX_SCHEME_LENGTH];
                WCHAR   rgwchHostForDisplay[INTERNET_MAX_HOST_NAME_LENGTH];
                WCHAR   rgwchPathForDisplay[MAX_PATH];
                WCHAR   rgwchUrlPath[MAX_PATH];

                SHAnsiToUnicodeCP(dwCodePage, rgchScheme, rgwchScheme, ARRAYSIZE(rgwchScheme));
                SHAnsiToUnicodeCP(dwCodePage, rgchHostForDisplay, rgwchHostForDisplay, ARRAYSIZE(rgwchHostForDisplay));
                SHAnsiToUnicodeCP(dwCodePage, rgchPathForDisplay, rgwchPathForDisplay, ARRAYSIZE(rgwchPathForDisplay));
                SHAnsiToUnicodeCP(dwCodePage, rgchUrlPath, rgwchUrlPath, ARRAYSIZE(rgwchUrlPath));

                if (pwzCachedFileName && *pwzCachedFileName)
                {
                    WCHAR szUrlPath[MAX_PATH];
                    DWORD cc = ARRAYSIZE(rgchUrlPath);
                    if (FAILED(_PrepareURLForDisplayUTF8W(pwzCachedFileName, szUrlPath, &cc, TRUE, dwCodePage)))
                    {
                        StrCpyNW(szUrlPath, pwzCachedFileName, ARRAYSIZE(szUrlPath));
                    }
                    CleanExploits(szUrlPath);

                    dwPathLen = lstrlenW(szUrlPath);
                    if (dwPathLen>dwMaxPathLen)
                    {
                        DWORD   dwOverFlow = dwPathLen - dwMaxPathLen + dwElipsisLen;
                        wnsprintfW(rgwchPathForDisplay, ARRAYSIZE(rgwchPathForDisplay), L"/%s%s", rgwchElipsis, szUrlPath+dwOverFlow);
                        dwPathLen = dwMaxPathLen;
                    }
                    else
                        StrCpyNW(rgwchPathForDisplay, szUrlPath, ARRAYSIZE(rgwchPathForDisplay));
                }
                
                if (fSeperate)
                {
                    // Format string as "X from Y"
                    WCHAR   rgwchTemplate[dwMaxTemplateLen];
                    WCHAR  *pwzFileName = PathFindFileNameW(rgwchPathForDisplay);
                    DWORD   dwCount;

                    //
                    // remove cache decoration goop to map ie5setup[1].exe to ie5setup.exe
                    //
                    PathUndecorateW(pwzFileName);

                    ZeroMemory(rgwchTemplate, sizeof(rgwchTemplate));
                    dwCount = MLLoadString(IDS_TARGETFILE, rgwchTemplate, ARRAYSIZE(rgwchTemplate));
                    if (dwCount > 0)
                    {
                        if (urlComp.nScheme == INTERNET_SCHEME_FILE)
                        {
                            StrCpyNW(rgwchHostForDisplay, rgwchUrlPath, ARRAYSIZE(rgwchPathForDisplay));
                            PathRemoveFileSpecW(rgwchHostForDisplay);
                        }

                        if (dwPathLen+lstrlenW(rgwchTemplate)+dwHostLen <= cchBuf)
                        {
                            //avoid formatting the string as "X from " in the event internetcrackurl fails us
                            if (rgwchHostForDisplay[0] != TEXT('\0'))  
                            {
                                // if necessary return host separately
                                if (pwzFrom && cbFrom)
                                {
                                    StrCpyNW(pwzFriendly, pwzFileName, cchBuf);
                                    StrCpyNW(pwzFrom, rgwchHostForDisplay, cbFrom);
                                }
                                else
                                    _FormatMessage(rgwchTemplate, pwzFriendly, cchBuf, pwzFileName, rgwchHostForDisplay);
                            }
                            else  //hostname is blank, just use filename
                                StrCpyNW(pwzFriendly, pwzFileName, cchBuf);
                            hrRC = S_OK;
                        }
                    }
                }
                else    // !fSeperate
                {
                    if (3+dwPathLen+dwHostLen+dwSchemeLen < cchBuf)
                    {
                        wnsprintf(pwzFriendly, cchBuf, TEXT("%ws://%ws%ws"), rgwchScheme, rgwchHostForDisplay, rgwchPathForDisplay);
                        hrRC = S_OK;
                    }
                }
            }
        }

        LocalFree(pszURL);
        pszURL = NULL;
    }
    
    return(hrRC);
}

BOOL __cdecl _FormatMessage(LPCWSTR szTemplate, LPWSTR szBuf, UINT cchBuf, ...)
{
    BOOL fRet;
    va_list ArgList;
    va_start(ArgList, cchBuf);

    fRet = FormatMessage(FORMAT_MESSAGE_FROM_STRING, szTemplate, 0, 0, szBuf, cchBuf, &ArgList);

    va_end(ArgList);
    return fRet;
}


// Navigate to a given Url (wszUrl) using IE. Returns an error if IE does not exist.
// fNewWindow = TRUE ==> A new window is compulsory
// fNewWindow = FALSE ==> Do not launch a new window if one already is open.
HRESULT NavToUrlUsingIEW(LPCWSTR wszUrl, BOOL fNewWindow)
{
    HRESULT hr = S_OK;

    if (!EVAL(wszUrl))
        return E_INVALIDARG;

    if (IsIEDefaultBrowser() && !fNewWindow)
    {
        // ShellExecute navigates to the Url using the same browser window,
        // if one is already open.

        SHELLEXECUTEINFOW sei = {0};

        sei.cbSize = sizeof(sei);
        sei.lpFile = wszUrl;
        sei.nShow  = SW_SHOWNORMAL;

        ShellExecuteExW(&sei);

    }
    else
    {
        IWebBrowser2 *pwb2;
        hr = CoCreateInstance(CLSID_InternetExplorer, NULL,
                              CLSCTX_LOCAL_SERVER, IID_PPV_ARG(IWebBrowser2, &pwb2));
        if (SUCCEEDED(hr))
        {
            LBSTR::CString          strUrl( wszUrl );

            VARIANT varURL;
            varURL.vt = VT_BSTR;
            varURL.bstrVal = strUrl;

            VARIANT varFlags;
            varFlags.vt = VT_I4;
            varFlags.lVal = 0;

            hr = pwb2->Navigate2(&varURL, &varFlags, PVAREMPTY, PVAREMPTY, PVAREMPTY);
            ASSERT(SUCCEEDED(hr)); // mikesh sez there's no way for Navigate2 to fail
            hr = pwb2->put_Visible( TRUE );
            pwb2->Release();
        }
    }
    return hr;
}

HRESULT NavToUrlUsingIEA(LPCSTR szUrl, BOOL fNewWindow)
{
    WCHAR   wszUrl[INTERNET_MAX_URL_LENGTH];

    AnsiToUnicode(szUrl, wszUrl, ARRAYSIZE(wszUrl));

    return NavToUrlUsingIEW(wszUrl, fNewWindow);
}


// MultiByteToWideChar doesn't truncate if the buffer is too small.
// these utils do.
// returns:
//      # of chars converted (WIDE chars) into out buffer (pwstr)

int _AnsiToUnicode(UINT uiCP, LPCSTR pstr, LPWSTR pwstr, int cch)
{
    int cchDst = 0;

    ASSERT(IS_VALID_STRING_PTRA(pstr, -1));
    ASSERT(NULL == pwstr || IS_VALID_WRITE_BUFFER(pwstr, WCHAR, cch));

    if (cch && pwstr)
        pwstr[0] = 0;

    switch (uiCP)
    {
        case 1200:                      // UCS-2 (Unicode)
            uiCP = 65001;
            // fall through
        case 50000:                     // "User Defined"
        case 65000:                     // UTF-7
        case 65001:                     // UTF-8
        {
            INT cchSrc, cchSrcOriginal;

            cchSrc = cchSrcOriginal = lstrlenA(pstr) + 1;
            cchDst = cch;

            if (SUCCEEDED(ConvertINetMultiByteToUnicode(NULL, uiCP, pstr,
                &cchSrc, pwstr, &cchDst)) &&
                cchSrc < cchSrcOriginal)
            {
                LPWSTR pwsz = (LPWSTR)LocalAlloc(LPTR, cchDst * SIZEOF(WCHAR));
                if (pwsz)
                {
                    if (SUCCEEDED(ConvertINetMultiByteToUnicode( NULL, uiCP, pstr,
                        &cchSrcOriginal, pwsz, &cchDst )))
                    {
                        StrCpyNW( pwstr, pwsz, cch );
                        cchDst = cch;
                    }

                    LocalFree(pwsz);
                    pwsz = NULL;
                }
            }
            break;
        }

        default:
            cchDst = MultiByteToWideChar(uiCP, 0, pstr, -1, pwstr, cch);
            if (!cchDst) {

                // failed.

                if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
                    int cchNeeded = MultiByteToWideChar(uiCP, 0, pstr, -1, NULL, 0);

                    if (cchNeeded) {
                        LPWSTR pwsz = (LPWSTR)LocalAlloc(LPTR, cchNeeded * SIZEOF(WCHAR));
                        if (pwsz) {
                            cchDst = MultiByteToWideChar(uiCP, 0, pstr, -1, pwsz, cchNeeded);
                            if (cchDst) {
                                StrCpyNW(pwstr, pwsz, cch);
                                cchDst = cch;
                            }

                            LocalFree(pwsz);
                            pwsz = NULL;
                        }
                    }
                }
            }
            break;
    }
    return cchDst;
}

UINT    g_cfURL = 0;
UINT    g_cfURLW = 0;
UINT    g_cfFileDescA = 0;
UINT    g_cfFileContents = 0;
UINT    g_cfPreferredEffect = 0;
UINT    g_cfPerformedEffect = 0;
UINT    g_cfTargetCLSID = 0;

UINT    g_cfHIDA = 0;
UINT    g_cfFileDescW = 0;

void InitClipboardFormats()
{
    if (g_cfURL == 0)
    {
        g_cfURL = RegisterClipboardFormat(CFSTR_SHELLURL);
        g_cfURLW = RegisterClipboardFormat(CFSTR_INETURLW);
        g_cfFileDescA = RegisterClipboardFormat(CFSTR_FILEDESCRIPTORA);
        g_cfFileContents = RegisterClipboardFormat(CFSTR_FILECONTENTS);
        g_cfPreferredEffect = RegisterClipboardFormat(CFSTR_PREFERREDDROPEFFECT);
        g_cfPerformedEffect = RegisterClipboardFormat(CFSTR_PERFORMEDDROPEFFECT);
        g_cfTargetCLSID = RegisterClipboardFormat(CFSTR_TARGETCLSID);
        g_cfHIDA = RegisterClipboardFormat(CFSTR_SHELLIDLIST);
        g_cfFileDescW = RegisterClipboardFormat(CFSTR_FILEDESCRIPTORW);
    }
}


// FEATURE [raymondc] use SHGlobalCounter

// We need to use a cross process browser count.
// We use a named semaphore.
//
EXTERN_C HANDLE g_hSemBrowserCount = NULL;

#define SESSION_COUNT_SEMAPHORE_NAME _T("_ie_sessioncount")

HANDLE GetSessionCountSemaphoreHandle()
{
    if (!g_hSemBrowserCount)
    {
        g_hSemBrowserCount = SHGlobalCounterCreateNamed( SESSION_COUNT_SEMAPHORE_NAME, 0 );
    }

    ASSERT( g_hSemBrowserCount );

    return g_hSemBrowserCount;
}

LONG GetSessionCount()
{
    LONG lPrevCount = 0x7FFFFFFF;
    HANDLE hSem = GetSessionCountSemaphoreHandle();

    ASSERT(hSem);
    if (hSem)
    {
        ReleaseSemaphore(hSem, 1, &lPrevCount);
        WaitForSingleObject(hSem, 0);
    }
    return lPrevCount;


}

LONG IncrementSessionCount()
{
    LONG lPrevCount = 0x7FFFFFFF;
    HANDLE hSem = GetSessionCountSemaphoreHandle();

    ASSERT(hSem);
    if (hSem)
    {
        ReleaseSemaphore(hSem, 1, &lPrevCount);
    }
    return lPrevCount;
}

LONG DecrementSessionCount()
{
    LONG lPrevCount = 0x7FFFFFFF;
    HANDLE hSem = GetSessionCountSemaphoreHandle();
    ASSERT(hSem);
    if (hSem)
    {
        ReleaseSemaphore(hSem, 1, &lPrevCount); // increment first to make sure deadlock
                                                 // never occurs
        ASSERT(lPrevCount > 0);
        if (lPrevCount > 0)
        {
            WaitForSingleObject(hSem, 0);
            WaitForSingleObject(hSem, 0);
            lPrevCount--;
        }
        else
        {
            // Oops - Looks like a bug !
            // Just return it back to normal and leave
            WaitForSingleObject(hSem, 0);
        }
    }
    return lPrevCount;
}




//
// The following is the message that autodial monitors expect to receive
// when it's a good time to hang up
//
#define WM_IEXPLORER_EXITING    (WM_USER + 103)

long SetQueryNetSessionCount(enum SessionOp Op)
{
    long lCount = 0;
    
    switch(Op) {
        case SESSION_QUERY:
            lCount = GetSessionCount();
            TraceMsg(DM_SESSIONCOUNT, "SetQueryNetSessionCount SessionCount=%d (query)", lCount);
            break;

        case SESSION_INCREMENT_NODEFAULTBROWSERCHECK:
        case SESSION_INCREMENT:
            lCount = IncrementSessionCount();
            TraceMsg(DM_SESSIONCOUNT, "SetQueryNetSessionCount SessionCount=%d (incr)", lCount);

            
            if ((PLATFORM_INTEGRATED == WhichPlatform()))
            {
                // Weird name here... But in integrated mode we make every new browser window
                // look like a new session wrt how we use the cache. Basically this is the way things appear to the
                // user. This effects the way we look for new pages vs doing an if modified
                // since.  The ie3/ie4 switch says "look for new pages on each session start"
                // but wininet folks implemented this as a end session name. Woops.
                // Note that things like authentication etc aren't reset by this, but rather
                // only when all browsers are closed via the INTERNET_OPTION_END_BROWSER_SESSION option.
                InternetSetOption(NULL, INTERNET_OPTION_RESET_URLCACHE_SESSION, NULL, 0);
            }

            if (!lCount && (Op == SESSION_INCREMENT))
            {
                // this forces a reload of the title
                DetectAndFixAssociations();
            }
            break;

        case SESSION_DECREMENT:
            lCount = DecrementSessionCount();
            TraceMsg(DM_SESSIONCOUNT, "SetQueryNetSessionCount SessionCount=%d (decr)", lCount);

            if (!lCount) {
                // if we've closed all the net browsers, we need to flush the cache
                InternetSetOption(NULL, INTERNET_OPTION_END_BROWSER_SESSION, NULL, 0);
                InternetSetOption(NULL, INTERNET_OPTION_RESET_URLCACHE_SESSION, NULL, 0);

                // flush the Java VM cache too (if the Java VM is loaded in this process
                // and we're in integrated mode)
                if (WhichPlatform() == PLATFORM_INTEGRATED)
                {
                    HMODULE hmod = GetModuleHandle(TEXT("msjava.dll"));
                    if (hmod)
                    {
                        typedef HRESULT (*PFNNOTIFYBROWSERSHUTDOWN)(void *);
                        FARPROC fp = GetProcAddress(hmod, "NotifyBrowserShutdown");
                        if (fp)
                        {
                            HRESULT hr = ((PFNNOTIFYBROWSERSHUTDOWN)fp)(NULL);
                            ASSERT(SUCCEEDED(hr));
                        }
                    }
                }

                // Inform dial monitor that it's a good time to hang up
                HWND hwndMonitorWnd = FindWindow(TEXT("MS_AutodialMonitor"),NULL);
                if (hwndMonitorWnd) {
                    PostMessage(hwndMonitorWnd,WM_IEXPLORER_EXITING,0,0);
                }
                hwndMonitorWnd = FindWindow(TEXT("MS_WebcheckMonitor"),NULL);
                if (hwndMonitorWnd) {
                    PostMessage(hwndMonitorWnd,WM_IEXPLORER_EXITING,0,0);
                }

                // reset offline mode on all platforms except Win2K.
                OSVERSIONINFOA vi;
                vi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
                GetVersionExA(&vi);
                if ( vi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS ||
                    vi.dwMajorVersion < 5)
                {
                    // wininet is loaded - tell it to go online
                    INTERNET_CONNECTED_INFO ci;
                    memset(&ci, 0, sizeof(ci));
                    ci.dwConnectedState = INTERNET_STATE_CONNECTED;
                    InternetSetOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &ci, sizeof(ci));
                }
            }
            break;
    }

    return lCount;
}


#ifdef DEBUG
//---------------------------------------------------------------------------
// Copy the exception info so we can get debug info for Raised exceptions
// which don't go through the debugger.
void _CopyExceptionInfo(LPEXCEPTION_POINTERS pep)
{
    PEXCEPTION_RECORD per;

    per = pep->ExceptionRecord;
    TraceMsg(DM_ERROR, "Exception %x at %#08x.", per->ExceptionCode, per->ExceptionAddress);

    if (per->ExceptionCode == EXCEPTION_ACCESS_VIOLATION)
    {
        // If the first param is 1 then this was a write.
        // If the first param is 0 then this was a read.
        if (per->ExceptionInformation[0])
        {
            TraceMsg(DM_ERROR, "Invalid write to %#08x.", per->ExceptionInformation[1]);
        }
        else
        {
            TraceMsg(DM_ERROR, "Invalid read of %#08x.", per->ExceptionInformation[1]);
        }
    }
}
#else
#define _CopyExceptionInfo(x) TRUE
#endif


int WELCallback(void * p, void * pData)
{
    STATURL* pstat = (STATURL*)p;
    if (pstat->pwcsUrl) {
        OleFree(pstat->pwcsUrl);
    }
    return 1;
}

int CALLBACK WELCompare(void * p1, void * p2, LPARAM lParam)
{
    HDSA hdsa = (HDSA)lParam;
    // Sundown: coercion to long because parameter is an index
    STATURL* pstat1 = (STATURL*)DSA_GetItemPtr(hdsa, PtrToLong(p1));
    STATURL* pstat2 = (STATURL*)DSA_GetItemPtr(hdsa, PtrToLong(p2));
    if (pstat1 && pstat2) {
        return CompareFileTime(&pstat2->ftLastVisited, &pstat1->ftLastVisited);
    }

    ASSERT(0);
    return 0;
}

#define MACRO_STR(x) #x
#define VERSION_HEADER_STR "Microsoft Internet Explorer 5.0 Error Log -- " \
                           MACRO_STR(VER_MAJOR_PRODUCTVER) "." \
                           MACRO_STR(VER_MINOR_PRODUCTVER) "." \
                           MACRO_STR(VER_PRODUCTBUILD) "." \
                           MACRO_STR(VER_PRODUCTBUILD_QFE) "\r\n"

SHDOCAPI_(void) IEWriteErrorLog(const EXCEPTION_RECORD* pexr)
{
    HANDLE hfile = INVALID_HANDLE_VALUE;
    _try
    {
        TCHAR szWindows[MAX_PATH];
        GetWindowsDirectory(szWindows, ARRAYSIZE(szWindows));
        PathAppend(szWindows, TEXT("IE4 Error Log.txt"));
        HANDLE hfile = CreateFile(szWindows, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

        if (hfile != INVALID_HANDLE_VALUE)
        {
            const static CHAR c_szCRLF[] = "\r\n";
            DWORD cbWritten;
            CHAR szBuf[MAX_URL_STRING];

            // Write the title and product version.
            WriteFile(hfile, VERSION_HEADER_STR, lstrlenA(VERSION_HEADER_STR), &cbWritten, NULL);

            // Write the current time.
            SYSTEMTIME st;
            FILETIME ft;
            GetSystemTime(&st);
            SystemTimeToFileTime(&st, &ft);
            SHFormatDateTimeA(&ft, NULL, szBuf, SIZECHARS(szBuf));
            const static CHAR c_szCurrentTime[] = "CurrentTime: ";
            WriteFile(hfile, c_szCurrentTime, SIZEOF(c_szCurrentTime)-1, &cbWritten, NULL);
            WriteFile(hfile, szBuf, lstrlenA(szBuf), &cbWritten, NULL);
            WriteFile(hfile, c_szCRLF, SIZEOF(c_szCRLF)-1, &cbWritten, NULL);

            if (pexr) {
                const static CHAR c_szExcCode[] = "Exception Info: Code=%x Flags=%x Address=%x\r\n";
                const static CHAR c_szExcParam[] = "Exception Param:";
                wnsprintfA(szBuf, ARRAYSIZE(szBuf), c_szExcCode, pexr->ExceptionCode, pexr->ExceptionFlags, pexr->ExceptionAddress);
                WriteFile(hfile, szBuf, lstrlenA(szBuf), &cbWritten, NULL);

                if (pexr->NumberParameters) {
                    WriteFile(hfile, c_szExcParam, SIZEOF(c_szExcParam)-1, &cbWritten, NULL);
                    for (UINT iParam=0; iParam<pexr->NumberParameters; iParam++) {
                        wnsprintfA(szBuf, ARRAYSIZE(szBuf), " %x", pexr->ExceptionInformation[iParam]);
                        WriteFile(hfile, szBuf, lstrlenA(szBuf), &cbWritten, NULL);
                    }
                }

                WriteFile(hfile, c_szCRLF, SIZEOF(c_szCRLF)-1, &cbWritten, NULL);
                WriteFile(hfile, c_szCRLF, SIZEOF(c_szCRLF)-1, &cbWritten, NULL);
            }

            IUrlHistoryStg* pUrlHistStg;
            HRESULT hres = CoCreateInstance(CLSID_CUrlHistory, NULL, CLSCTX_INPROC_SERVER,
                IID_PPV_ARG(IUrlHistoryStg, &pUrlHistStg));
            if (SUCCEEDED(hres)) 
            {
                IEnumSTATURL* penum;
                hres = pUrlHistStg->EnumUrls(&penum);
                if (SUCCEEDED(hres)) 
                {
                    // Allocate DSA for an array of STATURL
                    HDSA hdsa = DSA_Create(SIZEOF(STATURL), 32);
                    if (hdsa) 
                    {
                        // Allocate DPA for sorting
                        HDPA hdpa = DPA_Create(32);
                        if (hdpa) 
                        {
                            STATURL stat;
                            stat.cbSize = SIZEOF(stat.cbSize);
                            while(penum->Next(1, &stat, NULL)==S_OK && stat.pwcsUrl) 
                            {
                                DSA_AppendItem(hdsa, &stat);
                                DPA_AppendPtr(hdpa, IntToPtr(DSA_GetItemCount(hdsa)-1));
                            }

                            DPA_Sort(hdpa, WELCompare, (LPARAM)hdsa);
                            for (int i=0; i<10 && i<DPA_GetPtrCount(hdpa) ; i++) 
                            {
                                // Sundown: typecast to long is OK
                                STATURL* pstat = (STATURL*)DSA_GetItemPtr(hdsa, PtrToLong(DPA_GetPtr(hdpa, i)));
                                if (pstat && pstat->pwcsUrl) 
                                {
                                    SHFormatDateTimeA(&pstat->ftLastVisited, NULL, szBuf, SIZECHARS(szBuf));
                                    WriteFile(hfile, szBuf, lstrlenA(szBuf), &cbWritten, NULL);
                                    const static TCHAR c_szColumn[] = TEXT(" -- ");
                                    WriteFile(hfile, c_szColumn, SIZEOF(c_szColumn)-1, &cbWritten, NULL);

                                    WideCharToMultiByte(CP_ACP, 0, pstat->pwcsUrl, -1,
                                                        szBuf, ARRAYSIZE(szBuf), NULL, NULL);
                                    WriteFile(hfile, szBuf, lstrlenA(szBuf), &cbWritten, NULL);

                                    WriteFile(hfile, c_szCRLF, SIZEOF(c_szCRLF)-1, &cbWritten, NULL);
                                } 
                                else 
                                {
                                    ASSERT(0);
                                }
                            }

                            DPA_Destroy(hdpa);
                            hdpa = NULL;
                        }

                        DSA_DestroyCallback(hdsa, WELCallback, NULL);
                        hdsa = NULL;
                    }
                    penum->Release();
                }
                else
                {
                    ASSERT(0);
                }
                pUrlHistStg->Release();
            }
            else 
            {
                ASSERT(0);
            }

            CloseHandle( hfile );
            hfile = INVALID_HANDLE_VALUE;
        }
    }
    _except((SetErrorMode(SEM_NOGPFAULTERRORBOX),
            _CopyExceptionInfo(GetExceptionInformation()),
            UnhandledExceptionFilter(GetExceptionInformation())
            ))
    {
        // We hit an exception while handling an exception.
        // Do nothing; we have already displayed the error dialog box.
        if (hfile != INVALID_HANDLE_VALUE) {
            CloseHandle(hfile);
        }
    }
    __endexcept
}

IStream* SHGetViewStream(LPCITEMIDLIST pidl, DWORD grfMode, LPCTSTR pszName, LPCTSTR pszStreamMRU, LPCTSTR pszStreams)
{
    IStream *pstm = NULL;
    static DWORD s_dwMRUSize = 0;
    DWORD dwSize = sizeof(s_dwMRUSize);

    if ((0 == s_dwMRUSize) &&
        (ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, pszStreamMRU, TEXT("MRU Size"), NULL, (void *) &s_dwMRUSize, &dwSize)))
    {
        s_dwMRUSize = 200;          // The default.
    }

    ASSERT(pidl);

    // should be checked by caller - if this is not true we'll flush the
    // MRU cache with internet pidls!  FTP and other URL Shell Extension PIDLs
    // that act like a folder and need similar persistence and fine.  This
    // is especially true because recently the cache size was increased from
    // 30 or so to 200.
    ASSERT(ILIsEqual(pidl, c_pidlURLRoot) || !IsBrowserFrameOptionsPidlSet(pidl, BFO_BROWSER_PERSIST_SETTINGS));

    // Now lets try to save away the other information associated with view.
    IMruDataList *pmru;
    if (SUCCEEDED(SHCoCreateInstance(NULL, &CLSID_MruLongList, NULL, IID_PPV_ARG(IMruDataList, &pmru))))
    {
        if (SUCCEEDED(pmru->InitData(s_dwMRUSize, MRULISTF_USE_ILISEQUAL, HKEY_CURRENT_USER, pszStreamMRU, NULL)))
        {
            DWORD cbPidl = ILGetSize(pidl);
            //  need to walk the list
            //  and find this guy
            int iIndex;
            BOOL fFoundPidl = SUCCEEDED(pmru->FindData((const BYTE *)pidl, cbPidl, &iIndex));

            // Did we find the item?
            if (!fFoundPidl && ((grfMode & (STGM_READ|STGM_WRITE|STGM_READWRITE)) == STGM_READ))
            {
                // Do not  create the stream if it does not exist and we are
                // only reading
            }
            else
            {
                // Note that we always create the key here, since we have
                // already checked whether we are just reading and the MRU
                // thing does not exist
                HKEY hkCabStreams = SHGetShellKey(SHELLKEY_HKCU_EXPLORER, pszStreams, TRUE);
                if (hkCabStreams )
                {
                    DWORD dwSlot;
                    if (SUCCEEDED(pmru->AddData((const BYTE *)pidl, cbPidl, &dwSlot)))
                    {
                        HKEY hkValues;
                        TCHAR szValue[32], szSubVal[64];
                        wnsprintf(szValue, ARRAYSIZE(szValue), TEXT("%d"), dwSlot);

                        if (!fFoundPidl && RegOpenKey(hkCabStreams, szValue, &hkValues) == ERROR_SUCCESS)
                        {
                            // This means that we have created a new MRU
                            // item for this PIDL, so clear out any
                            // information residing at this slot
                            // Note that we do not just delete the key,
                            // since that could fail if it has any sub-keys
                            DWORD dwType, dwSize = ARRAYSIZE(szSubVal);

                            while (RegEnumValue(hkValues, 0, szSubVal, &dwSize, NULL, &dwType, NULL, NULL) == ERROR_SUCCESS)
                            {
                                if (RegDeleteValue(hkValues, szSubVal) != ERROR_SUCCESS)
                                {
                                    break;
                                }
                            }

                            RegCloseKey(hkValues);
                        }
                        pstm = OpenRegStream(hkCabStreams, szValue, pszName, grfMode);
                    }

                    RegCloseKey(hkCabStreams);
                }
            }
        }

        pmru->Release();
    }


    return pstm;
}


#define c_szExploreClass TEXT("ExploreWClass")
#define c_szIExploreClass TEXT("IEFrame")
#ifdef IE3CLASSNAME
#define c_szCabinetClass TEXT("IEFrame")
#else
#define c_szCabinetClass TEXT("CabinetWClass")
#endif


BOOL IsNamedWindow(HWND hwnd, LPCTSTR pszClass)
{
    TCHAR szClass[32];

    GetClassName(hwnd, szClass, ARRAYSIZE(szClass));
    return StrCmp(szClass, pszClass) == 0;
}

BOOL IsTrayWindow(HWND hwnd)
{
    return IsNamedWindow(hwnd, TEXT(WNDCLASS_TRAYNOTIFY));
}

BOOL IsExplorerWindow(HWND hwnd)
{
    return IsNamedWindow(hwnd, c_szExploreClass);
}

BOOL IsFolderWindow(HWND hwnd)
{
    TCHAR szClass[32];

    GetClassName(hwnd, szClass, ARRAYSIZE(szClass));
    return (StrCmp(szClass, c_szCabinetClass) == 0) || (StrCmp(szClass, c_szIExploreClass) == 0);
}

HRESULT _SendOrPostDispatchMessage(HWND hwnd, WPARAM wParam, LPARAM lParam, BOOL fPostMessage, BOOL fCheckFirst)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_BUSY);
    DWORD idProcess;

    // in case of wParam = DSID_NAVIGATEIEBROWSER, lParam is LocalAlloced structure
    // so we better make sure we are in process 'coz otherwise will fault
    GetWindowThreadProcessId(hwnd, &idProcess);
    if (idProcess == GetCurrentProcessId() && IsWindowEnabled(hwnd) && IsWindowVisible(hwnd))
    {
        if (!fPostMessage || fCheckFirst)
        {
            //  sync or we are querying the windows readiness
            ULONG_PTR result;
            if (SendMessageTimeoutA(hwnd, WMC_DISPATCH, (fCheckFirst ? DSID_NOACTION : wParam),
                lParam, SMTO_ABORTIFHUNG, 400, &result))
                hr = (HRESULT) result;
        }

        //  handle the post only if the window was ready
        if (fPostMessage && (!fCheckFirst || SUCCEEDED(hr)))
            hr = (PostMessage(hwnd, WMC_DISPATCH, wParam, lParam) ? S_OK : E_FAIL);
    }

    return hr;
}

//---------------------------------------------------------------------------

HRESULT FindBrowserWindowOfClass(LPCTSTR pszClass, WPARAM wParam, LPARAM lParam, BOOL fPostMessage, HWND* phwnd)
{
    //If there is no window, assume the user is in the process of shutting down IE, and return E_FAIL

    //Otherwise, if there is at least one window, start cycling through the windows until you find
    //one that's not busy, and give it our message.  If all are busy, return
    //HRESULT_FROM_WIN32(ERROR_BUSY)
    HWND hwnd = NULL;
    HRESULT hr = E_FAIL;

    while (FAILED(hr)
        && (hwnd = FindWindowEx(NULL, hwnd, pszClass, NULL)) != NULL)
    {
        hr = _SendOrPostDispatchMessage(hwnd, wParam, lParam, fPostMessage, fPostMessage);
    }

    *phwnd = hwnd;
    return hr;
}

//This common function gets called when the DDE engine doesn't seem to care in which window something
//happens.  It returns in which window that something happened.  0 means all windows are busy.
//
//phwnd: a pointer the hwnd to which to send the message.  <= 0 means any window will do.
//       this is also an out parameter that specifies in which window it happened.
//fPostMessage: when doing navigations, we have to do a PostMessage instead of a SendMessageTimeout
//       or a CoCreateInstance later on in CDocObjectHost::_BindFileMoniker will fail.  So when
//       this function is called from CDDEAuto_Navigate, we make this flag TRUE
HRESULT CDDEAuto_Common(WPARAM wParam, LPARAM lParam, HWND *phwnd, BOOL fPostMessage)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_BUSY);
    HWND hwnd;

    //if we're told to go to a specific window
    if (phwnd && (*phwnd != (HWND)-1))
    {
        hr = _SendOrPostDispatchMessage(*phwnd, wParam, lParam, fPostMessage, FALSE);
    }

    if (HRESULT_FROM_WIN32(ERROR_BUSY) == hr)
    {
        hr = FindBrowserWindowOfClass(c_szIExploreClass, wParam, lParam, fPostMessage, &hwnd);
        if (!hwnd)
            hr = FindBrowserWindowOfClass(c_szCabinetClass, wParam, lParam, fPostMessage, &hwnd);

        if (phwnd)
            *phwnd = hwnd;
    }
    return hr;
}

//
//  Before changing the behavior of this function look at itemmenu.cpp in
//  cdfview.
//
HRESULT CDDEAuto_Navigate(BSTR str, HWND *phwnd, long lLaunchNewWindow) // the long used to be for lTransID, but it was always ignored...
{                                                                       // so I am using it to tell us if we want to absolutely create an new window or not...
    DDENAVIGATESTRUCT *pddens = NULL;
    HRESULT hres = E_FAIL;

    if (phwnd == NULL)
        return E_INVALIDARG;

    pddens = new DDENAVIGATESTRUCT;
    if (!pddens)
        hres = E_OUTOFMEMORY;
    else
    {
        pddens->wszUrl = StrDupW(str);
        if (!pddens->wszUrl)
        {
            hres = E_OUTOFMEMORY;
        }
        else
        {
            // Don't do the navigate if *phwnd == 0, in that case we want to either
            // create a new window or activate an existing one that already is viewing
            // this URL.
            
            if ((*phwnd != NULL) && !lLaunchNewWindow)
            {
                BOOL fForceWindowReuse = FALSE;
                BSTR bstrUrl = NULL;
                // If there is even a single window with a location 
                // you are basically assured that you cannot force a 
                // reuse of windows. essentially

               // case 1 : only iexplore -nohome windows implies we want to force reuse
               // case 2 : only windows that have a location - we don't want to force reuse
               //          just follow user's preference
               // case 3: mix of iexplore -nohome windows and windows with location. we don't
               //         know what state we are in - don't force reuse
                hres = CDDEAuto_get_LocationURL(&bstrUrl, *phwnd);

                if (FAILED(hres) ||
                   (!bstrUrl)   ||
                   (SUCCEEDED(hres) && (*bstrUrl == L'\0')))
                {
                    fForceWindowReuse = TRUE;
                }
                if (bstrUrl)
                    SysFreeString(bstrUrl);
                    
                if ( !(GetAsyncKeyState(VK_SHIFT) < 0)
                    && (fForceWindowReuse || SHRegGetBoolUSValue(REGSTR_PATH_MAIN, TEXT("AllowWindowReuse"), FALSE, TRUE)))
                {
                    hres = CDDEAuto_Common(DSID_NAVIGATEIEBROWSER, (LPARAM)pddens, phwnd, FALSE);
                }
            }

            if (SUCCEEDED(hres) && (*phwnd != 0) && (*phwnd != (HWND)-1))
            {
                // We found an existing browser window and successfully sent the
                // navigate message to it. Make the window foreground.
                SetForegroundWindow(*phwnd);

                if (IsIconic(*phwnd))
                    ShowWindowAsync(*phwnd, SW_RESTORE);
            }

            //
            // If we are using whatever window and all the browser windows are busy
            // (*phwnd == 0), or if there's no browser window opened (*phwnd == -1)
            // or we are asked to create a new one, then take the official OLE automation
            // route to start a new window.
            //
            if ((*phwnd == 0) ||
                (*phwnd == (HWND)-1))
            {
                //WARNING: this route doesn't give us the ability to return the hwnd of the window
                //in which the navigation took place (while we could - it's too hard and not worth it)
                LPITEMIDLIST pidlNew;
                hres = IECreateFromPathW(str, &pidlNew);
                if (SUCCEEDED(hres))
                {
                    if (!lLaunchNewWindow)
                    {
                        // See if there is already a browser viewing this URL, if so just
                        // make him foreground otherwise create a new browser.
                        hres = WinList_FindFolderWindow(pidlNew, NULL, phwnd, NULL);
                    }
                    else
                    {
                        // we don't look in the winlist if the caller explicitly wants a new window
                        hres = S_FALSE;
                    }

                    if (S_OK == hres)
                    {
                        ILFree(pidlNew);
                        SetForegroundWindow(*phwnd);
                        ShowWindow(*phwnd, SW_SHOWNORMAL);
                    }
                    else
                    {
                        SHOpenNewFrame(pidlNew, NULL, 0, COF_IEXPLORE);
                    }
                }
            }
        }

        // It will be set to NULL if we don't need to free it.
        if (pddens)
        {
            if (pddens->wszUrl)
            {
                LocalFree(pddens->wszUrl);
                pddens->wszUrl = NULL;
            }

            delete pddens;
        }    
    }

    return hres;
}

HRESULT CDDEAuto_get_LocationURL(BSTR * pstr, HWND hwnd)
{
    return CDDEAuto_Common(DSID_GETLOCATIONURL, (LPARAM)pstr, &hwnd, FALSE);
}

HRESULT CDDEAuto_get_LocationTitle(BSTR * pstr, HWND hwnd)
{
    return CDDEAuto_Common(DSID_GETLOCATIONTITLE, (LPARAM)pstr, &hwnd, FALSE);
}

HRESULT CDDEAuto_get_HWND(long * phwnd)
{
    return CDDEAuto_Common(DSID_GETHWND, (LPARAM)phwnd, NULL, FALSE);
}

HRESULT CDDEAuto_Exit()
{
    return CDDEAuto_Common(DSID_EXIT, (LPARAM)NULL, NULL, FALSE);
}

#define DXTRACK 1
void FrameTrack(HDC hdc, LPRECT prc, UINT uFlags)
{
    COLORREF clrSave, clr;
    RECT    rc;

    // upperleft
    switch (uFlags)
    {
    case TRACKHOT:
        clr = GetSysColor(COLOR_BTNHILIGHT);
        break;
    case TRACKNOCHILD:
    case TRACKEXPAND:
        clr = GetSysColor(COLOR_BTNSHADOW);
        break;
    default:
        ASSERT(FALSE);
        clr = GetSysColor(COLOR_BTNSHADOW);
        break;
    }
    clrSave = SetBkColor(hdc, clr);
    rc = *prc;
    rc.bottom = rc.top + DXTRACK;
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
    rc.bottom = prc->bottom;
    rc.right = rc.left + DXTRACK;
    rc.top = prc->top + DXTRACK;
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
    // lowerright
    switch (uFlags)
    {
    case TRACKHOT:
        clr = GetSysColor(COLOR_BTNSHADOW);
        break;
    case TRACKNOCHILD:
    case TRACKEXPAND:
        clr = GetSysColor(COLOR_BTNHILIGHT);
        break;
    default:
        ASSERT(FALSE);
        break;
    }
    SetBkColor(hdc, clr);
    if (uFlags & (TRACKHOT | TRACKNOCHILD))
    {
        rc.right = prc->right;
        rc.top = rc.bottom - DXTRACK;
        rc.left = prc->left;
        ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
    }
    rc.right = prc->right;
    rc.left = prc->right - DXTRACK;
    rc.top = prc->top;
    rc.bottom = prc->bottom;
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
    SetBkColor(hdc, clrSave);
    return;
}


#undef new // Hack!! Need to remove this (edwardp)

class CDelagateMalloc : public IMalloc
{
public:
    // IUnknown
    virtual STDMETHODIMP QueryInterface(REFIID,void **);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // IMalloc
    virtual STDMETHODIMP_(void *)   Alloc(SIZE_T cb);
    virtual STDMETHODIMP_(void *)   Realloc(void *pv, SIZE_T cb);
    virtual STDMETHODIMP_(void)     Free(void *pv);
    virtual STDMETHODIMP_(SIZE_T)    GetSize(void *pv);
    virtual STDMETHODIMP_(int)      DidAlloc(void *pv);
    virtual STDMETHODIMP_(void)     HeapMinimize();

private:
    CDelagateMalloc(void *pv, SIZE_T cbSize, WORD wOuter);
    ~CDelagateMalloc() {}
    void* operator new(size_t cbClass, SIZE_T cbSize)
    {
        return ::operator new(cbClass + cbSize);
    }


    friend HRESULT CDelegateMalloc_Create(void *pv, SIZE_T cbSize, WORD wOuter, IMalloc **ppmalloc);

protected:
    LONG _cRef;
    WORD _wOuter;           // delegate item outer signature
    WORD _wUnused;          // to allign
#ifdef DEBUG
    UINT _cAllocs;
#endif
    SIZE_T _cb;
    BYTE _data[EMPTY_SIZE];
};

CDelagateMalloc::CDelagateMalloc(void *pv, SIZE_T cbSize, WORD wOuter)
{
    _cRef = 1;
    _wOuter = wOuter;
    _cb = cbSize;

    memcpy(_data, pv, _cb);
}

HRESULT CDelagateMalloc::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CDelagateMalloc, IMalloc),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CDelagateMalloc::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CDelagateMalloc::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

void *CDelagateMalloc::Alloc(SIZE_T cb)
{
    WORD cbActualSize = (WORD)(
                        SIZEOF(DELEGATEITEMID) - 1 +    // header (-1 sizeof(rgb[0])
                        cb +                            // inner
                        _cb);                           // outer data

    PDELEGATEITEMID pidl = (PDELEGATEITEMID)SHAlloc(cbActualSize + 2);  // +2 for pidl term
    if (pidl)
    {
        pidl->cbSize = cbActualSize;
        pidl->wOuter = _wOuter;
        pidl->cbInner = (WORD)cb;
        memcpy(&pidl->rgb[cb], _data, _cb);
        *(UNALIGNED WORD *)&(((BYTE *)pidl)[cbActualSize]) = 0;
#ifdef DEBUG
        _cAllocs++;
#endif
    }
    return pidl;
}

void *CDelagateMalloc::Realloc(void *pv, SIZE_T cb)
{
    return NULL;
}

void CDelagateMalloc::Free(void *pv)
{
    SHFree(pv);
}

SIZE_T CDelagateMalloc::GetSize(void *pv)
{
    return (SIZE_T)-1;
}

int CDelagateMalloc::DidAlloc(void *pv)
{
    return -1;
}

void CDelagateMalloc::HeapMinimize()
{
}

STDAPI CDelegateMalloc_Create(void *pv, SIZE_T cbSize, WORD wOuter, IMalloc **ppmalloc)
{
    CDelagateMalloc *pdm = new(cbSize) CDelagateMalloc(pv, cbSize, wOuter);
    if (pdm)
    {
        HRESULT hres = pdm->QueryInterface(IID_PPV_ARG(IMalloc, ppmalloc));
        pdm->Release();
        return hres;
    }
    return E_OUTOFMEMORY;
}


//+-------------------------------------------------------------------------
// This function scans the head of an html document for the desired element
// with a particular attribute.  If a match is found, the first occurance
// of that element is returned in punkDesired and S_OK is returned.
// Otherwise, E_FAIL is returned.
//
// Example:  Find the first meta element with name="ProgID":
//
//   SearchForElementInHead(pHTMLDoc, OLESTR("Name"), OLESTR("ProgId"),
//           IID_IHTMLMetaElement, (IUnknown**)&pMetaElement);
//
//--------------------------------------------------------------------------
HRESULT SearchForElementInHead
(
    IHTMLDocument2* pHTMLDocument,  // [in] document to search
    LPOLESTR        pszAttribName,  // [in] attribute to check for
    LPOLESTR        pszAttrib,      // [in] value the attribute must have
    REFIID          iidDesired,     // [in] element interface to return
    IUnknown**      ppunkDesired    // [out] returned interface
)
{
    ASSERT(NULL != pHTMLDocument);
    ASSERT(NULL != pszAttribName);
    ASSERT(NULL != pszAttrib);
    ASSERT(NULL != ppunkDesired);

    HRESULT hr = E_FAIL;
    *ppunkDesired = NULL;

    BSTR bstrAttribName = SysAllocString(pszAttribName);
    if (NULL == bstrAttribName)
    {
        return E_OUTOFMEMORY;
    }

    //
    // First get all document elements.  Note that this is very fast in
    // ie5 because the collection directly accesses the internal tree.
    //
    IHTMLElementCollection * pAllCollection;
    if (SUCCEEDED(pHTMLDocument->get_all(&pAllCollection)))
    {
        IUnknown* punk;
        IHTMLBodyElement* pBodyElement;
        IHTMLFrameSetElement* pFrameSetElement;
        IDispatch* pDispItem;

        //
        // Now we scan the document for the desired tags.  Since we're only
        // searching the head, and since Trident always creates a body tag
        // (unless there is a frameset), we can stop looking when we hit the
        // body or frameset.
        //
        // Note, the alternative of using pAllCollection->tags to return the
        // collection of desired tags is likely more expensive because it will
        // walk the whole tree (unless Trident optimizes this).
        //
        long lItemCnt;
        VARIANT vEmpty;
        V_VT(&vEmpty) = VT_EMPTY;

        VARIANT vIndex;
        V_VT(&vIndex) = VT_I4;

        EVAL(SUCCEEDED(pAllCollection->get_length(&lItemCnt)));

        for (long lItem = 0; lItem < lItemCnt; lItem++)
        {
            V_I4(&vIndex) = lItem;

            if (S_OK == pAllCollection->item(vIndex, vEmpty, &pDispItem))
            {
                //
                // First see if it's the desired element type
                //
                if (SUCCEEDED(pDispItem->QueryInterface(iidDesired, (void **)&punk)))
                {
                    //
                    // Next see if it has the desired attribute
                    //
                    IHTMLElement* pElement;

                    if (SUCCEEDED(pDispItem->QueryInterface(IID_PPV_ARG(IHTMLElement, &pElement))))
                    {
                        VARIANT varAttrib;
                        V_VT(&varAttrib) = VT_EMPTY;

                        if (SUCCEEDED(pElement->getAttribute(bstrAttribName, FALSE, &varAttrib)) &&
                            (V_VT(&varAttrib) == VT_BSTR) && varAttrib.bstrVal &&
                            (StrCmpIW(varAttrib.bstrVal, pszAttrib) == 0) )
                        {
                            // Found it!
                            *ppunkDesired = punk;
                            punk = NULL;
                            hr = S_OK;

                            // Terminate the search;
                            lItem = lItemCnt;
                        }
                        pElement->Release();

                        VariantClear(&varAttrib);
                    }

                    if (punk)
                        punk->Release();
                }
                //
                // Next check for the body tag
                //
                else if (SUCCEEDED(pDispItem->QueryInterface(IID_PPV_ARG(IHTMLBodyElement,&pBodyElement))))
                {
                    // Found a body tag, so terminate the search
                    lItem = lItemCnt;
                    pBodyElement->Release();
                }
                //
                // Finally, check for a frameset tag
                //
                else if (SUCCEEDED(pDispItem->QueryInterface(IID_PPV_ARG(IHTMLFrameSetElement, &pFrameSetElement))))
                {
                    // Found a frameset tag, so terminate the search
                    lItem = lItemCnt;
                    pFrameSetElement->Release();
                }

                pDispItem->Release();
            }
        }
        // Make sure that these don't have to be cleared (should not have been modified)
        ASSERT(vEmpty.vt == VT_EMPTY);
        ASSERT(vIndex.vt == VT_I4);

        pAllCollection->Release();
    }

    SysFreeString(bstrAttribName);

    return hr;
}


//+-------------------------------------------------------------------
//     JITCoCreateInstance
//
//  This function makes sure that the Option pack which
//  has this class id is installed.
//  It attempts to make sure that the Option pack corresponding
//  to the current IE Build.
//  If the feature does get installed correctly, it will
//  attempt to CoCreate the specified CLSID
//
//+------------------------------------------------------------------
HRESULT JITCoCreateInstance(REFCLSID rclsid, IUnknown *pUnkOuter, DWORD dwClsContext, REFIID riid, void ** ppv, HWND hwndParent, DWORD dwJitFlags)
{
    uCLSSPEC ucs;
    QUERYCONTEXT qc = { 0 };
    ucs.tyspec = TYSPEC_CLSID;
    ucs.tagged_union.clsid = rclsid;

    ASSERT((dwJitFlags & ~(FIEF_FLAG_FORCE_JITUI | FIEF_FLAG_PEEK)) == 0);

    HRESULT hr = FaultInIEFeature(hwndParent, &ucs, &qc, dwJitFlags);
    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(rclsid, pUnkOuter, dwClsContext, riid, ppv);
    }

    return hr;
}

BOOL IsFeaturePotentiallyAvailable(REFCLSID rclsid)
{
    uCLSSPEC ucs;
    QUERYCONTEXT qc = { 0 };

    ucs.tyspec = TYSPEC_CLSID;
    ucs.tagged_union.clsid = rclsid;

    return (FaultInIEFeature(NULL, &ucs, &qc, FIEF_FLAG_FORCE_JITUI | FIEF_FLAG_PEEK) != E_ACCESSDENIED);
}

BOOL CreateFromDesktop(PNEWFOLDERINFO pfi)
{
    //
    //  APPCOMPAT:HACKHACK - we need to handle differences in the way we parse the command line
    //  on IE4 integrated.  we should not be called by anybody but IE4's Explorer.exe
    //
    ASSERT(GetUIVersion() == 4);
    if (!pfi->pidl) 
    {
        if ((pfi->uFlags & (COF_ROOTCLASS | COF_NEWROOT)) || pfi->pidlRoot)
        {
            pfi->pidl = ILRootedCreateIDList(pfi->uFlags & COF_ROOTCLASS ? &pfi->clsid : NULL, pfi->pidlRoot);
            pfi->uFlags &= ~(COF_ROOTCLASS | COF_NEWROOT);
            ILFree(pfi->pidlRoot);
            pfi->pidlRoot = NULL;
            pfi->clsid = CLSID_NULL;
        }
        else if (!PathIsURLA(pfi->pszPath))
        {
           CHAR szTemp[MAX_PATH];
           GetCurrentDirectoryA(ARRAYSIZE(szTemp), szTemp);
           PathCombineA(szTemp, szTemp, pfi->pszPath);
           Str_SetPtrA(&(pfi->pszPath), szTemp);
        } 
    }

    ASSERT(!(pfi->uFlags & (COF_ROOTCLASS | COF_NEWROOT)));
    
    return SHCreateFromDesktop(pfi);
}

//***   IsVK_TABCycler -- is key a TAB-equivalent
// ENTRY/EXIT
//  dir     0 if not a TAB, non-0 if a TAB
// NOTES
//  NYI: -1 for shift+tab, 1 for tab
//
int IsVK_TABCycler(MSG *pMsg)
{
    if (!pMsg)
        return 0;

    if (pMsg->message != WM_KEYDOWN)
        return 0;
    if (! (pMsg->wParam == VK_TAB || pMsg->wParam == VK_F6))
        return 0;

    return (GetKeyState(VK_SHIFT) < 0) ? -1 : 1;
}

#ifdef DEBUG
//
// This function fully fills the input buffer, trashing stuff so we fault
// when the size is wrong :-)
//
// We should hopefully catch people passing buffers that are too small here by
// having a reproable stack corruption.
//
#define CH_BADCHARA          ((CHAR)0xCC)
#define CH_BADCHARW          ((WCHAR)0xCCCC)

#ifdef UNICODE
#define CH_BADCHAR          CH_BADCHARW
#else // UNICODE
#define CH_BADCHAR          CH_BADCHARA
#endif // UNICODE

void DebugFillInputString(LPTSTR pszBuffer, DWORD cchSize)
{
    while (cchSize--)
    {
        pszBuffer[0] = CH_BADCHAR;
        pszBuffer++;
    }
}

void DebugFillInputStringA(LPSTR pszBuffer, DWORD cchSize)
{
    while (cchSize--)
    {
        pszBuffer[0] = CH_BADCHARA;
        pszBuffer++;
    }
}


#endif // DEBUG

// Review chrisny:  this can be moved into an object easily to handle generic droptarget, dropcursor
// , autoscrool, etc. . .
void _DragEnter(HWND hwndTarget, const POINTL ptStart, IDataObject *pdtObject)
{
    RECT    rc;
    POINT   pt;

    GetWindowRect(hwndTarget, &rc);
    if (IS_WINDOW_RTL_MIRRORED(hwndTarget))
        pt.x = rc.right - ptStart.x;
    else
        pt.x = ptStart.x - rc.left;
    pt.y = ptStart.y - rc.top;
    DAD_DragEnterEx2(hwndTarget, pt, pdtObject);
    return;
}

void _DragMove(HWND hwndTarget, const POINTL ptStart)
{
    RECT rc;
    POINT pt;

    GetWindowRect(hwndTarget, &rc);
    if (IS_WINDOW_RTL_MIRRORED(hwndTarget))
        pt.x = rc.right - ptStart.x;
    else
        pt.x = ptStart.x - rc.left;
    pt.y = ptStart.y - rc.top;
    DAD_DragMove(pt);
    return;
}

STDAPI_(IBindCtx *) CreateBindCtxForUI(IUnknown * punkSite)
{
    IBindCtx * pbc = NULL;

    if (EVAL(punkSite && SUCCEEDED(CreateBindCtx(0, &pbc))))
    {
        if (FAILED(pbc->RegisterObjectParam(STR_DISPLAY_UI_DURING_BINDING, punkSite)))
        {
            // It failed
            ATOMICRELEASE(pbc);
        }
    }

    return pbc;
}

//
// Return the location of the internet cache
// HRESULT GetCacheLocation(
// dwSize          no. of chars in pszCacheLocation

STDAPI GetCacheLocation(LPTSTR pszCacheLocation, DWORD dwSize)
{
    HRESULT hr = S_OK;
    DWORD dwLastErr;
    LPINTERNET_CACHE_CONFIG_INFO lpCCI = NULL;  // init to suppress bogus C4701 warning
    DWORD dwCCISize = sizeof(INTERNET_CACHE_CONFIG_INFO);
    BOOL fOnceErrored = FALSE;

    while (TRUE)
    {
        if ((lpCCI = (LPINTERNET_CACHE_CONFIG_INFO) LocalAlloc(LPTR,
                                                        dwCCISize)) == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }

        if (!GetUrlCacheConfigInfo(lpCCI, &dwCCISize,
                                            CACHE_CONFIG_CONTENT_PATHS_FC))
        {
            if ((dwLastErr = GetLastError()) != ERROR_INSUFFICIENT_BUFFER  ||
                fOnceErrored)
            {
                hr = HRESULT_FROM_WIN32(dwLastErr);
                goto cleanup;
            }

            //
            // We have insufficient buffer size; reallocate a buffer with the
            //      new dwCCISize set by GetUrlCacheConfigInfo
            // Set fOnceErrored to TRUE so that we don't loop indefinitely
            //
            fOnceErrored = TRUE;
        }
        else
        {
            LPTSTR pszPath = lpCCI->CachePaths[0].CachePath;
            INT iLen;

            PathRemoveBackslash(pszPath);
            iLen = lstrlen(pszPath) + 1;        // + 1 is for the null char

            if ((DWORD) iLen < dwSize)
            {
                StrCpyN(pszCacheLocation, pszPath, iLen);
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            }

            break;
        }

        LocalFree(lpCCI);
        lpCCI = NULL;
    }

cleanup:
    if (lpCCI != NULL)
    {
        LocalFree(lpCCI);
        lpCCI = NULL;
    }

    return hr;
}

STDAPI_(UINT) GetWheelMsg()
{
    static UINT s_msgMSWheel = 0;
    if (s_msgMSWheel == 0)
        s_msgMSWheel = RegisterWindowMessage(TEXT("MSWHEEL_ROLLMSG"));
    return s_msgMSWheel;
}

STDAPI StringToStrRet(LPCTSTR pString, STRRET *pstrret)
{
    HRESULT hr = SHStrDup(pString, &pstrret->pOleStr);
    if (SUCCEEDED(hr))
    {
        pstrret->uType = STRRET_WSTR;
    }
    return hr;
}

// these two functions are duplicated from browseui
HINSTANCE GetComctl32Hinst()
{
    static HINSTANCE s_hinst = NULL;
    if (!s_hinst)
        s_hinst = GetModuleHandle(TEXT("comctl32.dll"));
    return s_hinst;
}

// since we don't define the proper WINVER we do this ourselves
#ifndef IDC_HAND
#define IDC_HAND            MAKEINTRESOURCE(32649)
#endif

STDAPI_(HCURSOR) LoadHandCursor(DWORD dwRes)
{
    if (g_bRunOnNT5 || g_bRunOnMemphis)
    {
        HCURSOR hcur = LoadCursor(NULL, IDC_HAND);  // from USER, system supplied
        if (hcur)
            return hcur;
    }
    return LoadCursor(GetComctl32Hinst(), IDC_HAND_INTERNAL);
}



//+-------------------------------------------------------------------------
// Returns true if this type of url may not be available when offline unless
// it is cached by wininet
//--------------------------------------------------------------------------
BOOL MayBeUnavailableOffline(LPTSTR pszUrl)
{
    BOOL fRet = FALSE;
    URL_COMPONENTS uc = {0};
    uc.dwStructSize = sizeof(uc);

    if (SUCCEEDED(InternetCrackUrl(pszUrl, 0, 0, &uc)))
    {
        fRet = uc.nScheme == INTERNET_SCHEME_HTTP ||
            uc.nScheme == INTERNET_SCHEME_HTTPS ||
            uc.nScheme == INTERNET_SCHEME_FTP ||
            uc.nScheme == INTERNET_SCHEME_GOPHER;
    }
    return fRet;
}

//+-------------------------------------------------------------------------
// If the folder is a link, the associated URL is returned.
//--------------------------------------------------------------------------
HRESULT GetNavTargetName(IShellFolder* psf, LPCITEMIDLIST pidl, LPTSTR pszUrl, UINT cMaxChars)
{
    LPITEMIDLIST pidlTarget;
    HRESULT hr = SHGetNavigateTarget(psf, pidl, &pidlTarget, NULL);
    if (SUCCEEDED(hr))
    {
        // Get the URL
        // NOTE (andrewgu): ie5.5 b#109391 - if SHGDN_FORPARSING is used the result will be
        // consitently the fully qualified path regardless of the protocol
        hr = IEGetNameAndFlags(pidlTarget, SHGDN_FORPARSING, pszUrl, cMaxChars, NULL);
        ILFree(pidlTarget);
    }
    else
        *pszUrl = 0;
    return hr;
}

//+-------------------------------------------------------------------------
// Returns info about whether this item is available offline. Returns E_FAIL
// if the item is not a link.
// if we navigate to this item
//  (true if we're online, items in the cache or otherwise available)
// if item is a sticky cache entry
//--------------------------------------------------------------------------
// FEATURE: this should use an interface to bind to this information abstractly
// psf->GetUIObjectOf(IID_IAvailablility, ...);
HRESULT GetLinkInfo(IShellFolder* psf, LPCITEMIDLIST pidlItem, BOOL* pfAvailable, BOOL* pfSticky)
{
    if (pfAvailable)
        *pfAvailable = TRUE;

    if (pfSticky)
        *pfSticky = FALSE;
    //
    // See if it is a link. If it is not, then it can't be in the wininet cache and can't
    // be pinned (sticky cache entry) or greyed (unavailable when offline)
    //
    WCHAR szUrl[MAX_URL_STRING];
    DWORD dwFlags = 0;

    HRESULT hr = GetNavTargetName(psf, pidlItem, szUrl, ARRAYSIZE(szUrl));

    if (SUCCEEDED(hr))
    {
        CHAR szUrlAnsi[MAX_URL_STRING];

        //
        // Get the cache info for this item.  Note that we use GetUrlCacheEntryInfoEx instead
        // of GetUrlCacheEntryInfo because it follows any redirects that occured.  This wacky
        // api uses a variable length buffer, so we have to guess the size and retry if the
        // call fails.
        //
        BOOL fInCache = FALSE;
        WCHAR szBuf[512];
        LPINTERNET_CACHE_ENTRY_INFOA pCE = (LPINTERNET_CACHE_ENTRY_INFOA)szBuf;
        DWORD dwEntrySize = ARRAYSIZE(szBuf);

        SHTCharToAnsi(szUrl, szUrlAnsi, ARRAYSIZE(szUrlAnsi));
        if (!(fInCache = GetUrlCacheEntryInfoExA(szUrlAnsi, pCE, &dwEntrySize, NULL, NULL, NULL, 0)))
        {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                // We guessed too small for the buffer so allocate the correct size & retry
                pCE = (LPINTERNET_CACHE_ENTRY_INFOA)LocalAlloc(LPTR, dwEntrySize);
                if (pCE)
                {
                    fInCache = GetUrlCacheEntryInfoExA(szUrlAnsi, pCE, &dwEntrySize, NULL, NULL, NULL, 0);
                }
            }
        }

        //
        // If we are offline, see if the item is in the cache.
        //
        if (pfAvailable && SHIsGlobalOffline() && MayBeUnavailableOffline(szUrl) && !fInCache)
        {
            // Not available
            *pfAvailable = FALSE;
        }

        //
        // See if it's a sticky cache entry
        //
        if (pCE)
        {
            if (pfSticky && fInCache && (pCE->CacheEntryType & STICKY_CACHE_ENTRY))
            {
                *pfSticky = TRUE;
            }

            if ((TCHAR*)pCE != szBuf)
            {
                LocalFree(pCE);
                pCE = NULL;
            }
        }
    }

    // 
    // Somebody is obviously interested in in the offline availability so listen
    // to wininet for changes to the cache and rebroadcast as a SHChangeNotify
    //
    CWinInetNotify::GlobalEnable();

    return hr;
}

//
// Get the avg char width given an hwnd
//

int GetAvgCharWidth(HWND hwnd)
{
    ASSERT(hwnd);

    int nWidth = 0;

    HFONT hfont = (HFONT)SendMessage(hwnd, WM_GETFONT, 0, 0);

    if (hfont)
    {
        HDC hdc = GetDC(NULL);

        if (hdc)
        {
            HFONT hfontOld = (HFONT)SelectObject(hdc, hfont);

            TEXTMETRIC tm;

            if (GetTextMetrics(hdc, &tm))
                nWidth = tm.tmAveCharWidth;

            SelectObject(hdc, hfontOld);

            ReleaseDC(NULL, hdc);
        }
    }

    return nWidth;
}

//
// Converts all "&" into "&&" so that they show up
// in menus
//
void FixAmpersands(LPWSTR pszToFix, UINT cchMax)
{
    ASSERT(pszToFix && cchMax > 0);

    WCHAR szBuf[MAX_URL_STRING];
    LPWSTR pszBuf = szBuf;
    LPWSTR pszSrc = pszToFix;
    UINT cch = 0;

    while (*pszSrc && cch < ARRAYSIZE(szBuf)-2)
    {
        if (*pszSrc == '&')
        {
            *pszBuf++ = '&';
            ++cch;
        }
        *pszBuf++ = *pszSrc++;
        ++cch;
    }
    *pszBuf = 0;

    StrCpyN(pszToFix, szBuf, cchMax);
}

BOOL IsInetcplRestricted(LPCWSTR pszCommand)
{
    BOOL fDisabled = FALSE;
    DWORD dwData, dwType;
    DWORD dwSize = sizeof(dwData);

    if (ERROR_SUCCESS == SHRegGetUSValue(TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Control Panel"),
        pszCommand, &dwType, (void *)&dwData, &dwSize, FALSE, NULL, 0))
    {
        fDisabled = dwData;
    }
    return fDisabled;
}

BOOL HasExtendedChar(LPCWSTR pszQuery)
{
    BOOL fNonAscii = FALSE;
    for (LPCWSTR psz = pszQuery; *psz; psz++)
    {
        if (*psz > 0x7f)
        {
            fNonAscii = TRUE;
            break;
        }
    }
    return fNonAscii;
}

void ConvertToUtf8Escaped(LPWSTR pszUrl, int cch)
{
    // Convert to utf8
    char szBuf[MAX_URL_STRING];
    SHUnicodeToAnsiCP(CP_UTF8, pszUrl, szBuf, ARRAYSIZE(szBuf));

    // Escape the string into the original buffer
    LPSTR pchIn; 
    LPWSTR pchOut = pszUrl;
    WCHAR ch;
    static const WCHAR hex[] = L"0123456789ABCDEF";

    for (pchIn = szBuf; *pchIn && cch > 3; pchIn++)
    {
        ch = *pchIn;

        if (ch > 0x7f)
        {
            cch -= 3;
            *pchOut++ = L'%';
            *pchOut++ = hex[(ch >> 4) & 15];
            *pchOut++ = hex[ch & 15];
        }
        else
        {
            --cch;
            *pchOut++ = *pchIn;
        }
    }

    *pchOut = L'\0';
}




HRESULT IExtractIcon_GetIconLocation(
    IUnknown *punk,
    IN  UINT   uInFlags,
    OUT LPTSTR pszIconFile,
    IN  UINT   cchIconFile,
    OUT PINT   pniIcon,
    OUT PUINT  puOutFlags)
{
    ASSERT(punk);
    HRESULT hr;
    
    if (g_fRunningOnNT)
    {
        IExtractIcon *pxi;
        hr = punk->QueryInterface(IID_PPV_ARG(IExtractIcon, &pxi));

        if (SUCCEEDED(hr))
        {
            hr = pxi->GetIconLocation(uInFlags, pszIconFile, cchIconFile, pniIcon, puOutFlags);

            pxi->Release();
        }
    }
    else
    {
        IExtractIconA *pxi;
        hr = punk->QueryInterface(IID_PPV_ARG(IExtractIconA, &pxi));

        if (SUCCEEDED(hr))
        {
            CHAR sz[MAX_PATH];
            hr = pxi->GetIconLocation(uInFlags, sz, SIZECHARS(sz), pniIcon, puOutFlags);

            if (SUCCEEDED(hr))
                SHAnsiToTChar(sz, pszIconFile, cchIconFile);

            pxi->Release();
        }
    }

    return hr;
}
        

HRESULT IExtractIcon_Extract(
    IUnknown *punk,
    IN  LPCTSTR pszIconFile,
    IN  UINT    iIcon,
    OUT HICON * phiconLarge,
    OUT HICON * phiconSmall,
    IN  UINT    ucIconSize)
{
    ASSERT(punk);
    HRESULT hr;
    
    if (g_fRunningOnNT)
    {
        IExtractIcon *pxi;
        hr = punk->QueryInterface(IID_PPV_ARG(IExtractIcon, &pxi));

        if (SUCCEEDED(hr))
        {
            hr = pxi->Extract(pszIconFile, iIcon, phiconLarge, phiconSmall, ucIconSize);

            pxi->Release();
        }
    }
    else
    {
        IExtractIconA *pxi;
        hr = punk->QueryInterface(IID_PPV_ARG(IExtractIconA, &pxi));

        if (SUCCEEDED(hr))
        {
            CHAR sz[MAX_PATH];
            SHTCharToAnsi(pszIconFile, sz, SIZECHARS(sz));
            hr = pxi->Extract(sz, iIcon, phiconLarge, phiconSmall, ucIconSize);

            pxi->Release();
        }
    }

    return hr;
}


typedef EXECUTION_STATE (__stdcall *PFNSTES) (EXECUTION_STATE);

EXECUTION_STATE _SetThreadExecutionState(EXECUTION_STATE esFlags)
{
    static PFNSTES _pfnSetThreadExecutionState = (PFNSTES)-1;
    
    if (_pfnSetThreadExecutionState == (PFNSTES)-1)
        _pfnSetThreadExecutionState = (PFNSTES)GetProcAddress(GetModuleHandleA("kernel32.dll"), "SetThreadExecutionState");

    if (_pfnSetThreadExecutionState != (PFNSTES)NULL)
        return(_pfnSetThreadExecutionState(esFlags));
    else
        return((EXECUTION_STATE)NULL);
}


HRESULT SHPathPrepareForWriteWrap(HWND hwnd, IUnknown *punkEnableModless, LPCTSTR pszPath, UINT wFunc, DWORD dwFlags)
{
    HRESULT hr;

    if (g_bRunOnNT5)
    {
        // NT5's version of the API is better.
        hr = SHPathPrepareForWriteW(hwnd, punkEnableModless, pszPath, dwFlags);
    }
    else
    {
        hr = SHCheckDiskForMedia(hwnd, punkEnableModless, pszPath, wFunc);
    }

    return hr;
}
void GetPathOtherFormA(LPSTR lpszPath, LPSTR lpszNewPath, DWORD dwSize)
{
    BOOL bQuotes = FALSE;
    LPSTR szStart = lpszPath;
    LPSTR szEnd = NULL;
    LPSTR szNewStart = lpszNewPath;

    ZeroMemory(lpszNewPath, dwSize);

    // Cull out the starting and ending " because GetShortPathName does not
    // like it.
    if (*lpszPath == '"')
    {
        bQuotes = TRUE;

        szStart = lpszPath + 1;
        szEnd   = lpszPath + lstrlenA(lpszPath) - 1; // Point to the last "
        *szEnd  = '\0';

        szNewStart = lpszNewPath + 1;  // So that we can insert the " in it.
        dwSize = dwSize - 2;  // for the two double quotes to be added.
    }

    if (GetShortPathNameA(szStart, szNewStart, dwSize) != 0)
    {
        if (StrCmpIA(szStart, szNewStart) == 0)
        {   // The original Path is a SFN. So NewPath needs to be LFN.
            GetLongPathNameA((LPCSTR)szStart, szNewStart, dwSize);
        }
    }
                                             
    // Now add the " to the NewPath so that it is in the expected form
    if (bQuotes)
    {
        int len = 0;

        // Fix the Original path.
        *szEnd = '"';

        // Fix the New path.
        *lpszNewPath = '"';        // Insert " in the beginning.
        len = lstrlenA(lpszNewPath);
        *(lpszNewPath + len) = '"'; // Add the " in the end.
        *(lpszNewPath + len + 1) = '\0'; // Terminate the string.
    }

    return;
}

int GetUrlSchemeFromPidl(LPCITEMIDLIST pidl)
{
    ASSERT(pidl);
    ASSERT(IsURLChild(pidl, FALSE));

    int nRet = URL_SCHEME_INVALID;

    WCHAR szUrl[MAX_URL_STRING];

    if (SUCCEEDED(IEGetNameAndFlags(pidl, SHGDN_FORPARSING, szUrl,
                                    ARRAYSIZE(szUrl), NULL)))
    {
        nRet = GetUrlScheme(szUrl);
    }

    return nRet;
}

//
// Check if it is safe to create a shortcut for the given url.  Used by add
// to favorites code.
//
BOOL IEIsLinkSafe(HWND hwnd, LPCITEMIDLIST pidl, ILS_ACTION ilsFlag)
{
    ASSERT(pidl);

    BOOL fRet = TRUE;

    if (IsURLChild(pidl, FALSE))
    {
        int nScheme = GetUrlSchemeFromPidl(pidl);

        if (URL_SCHEME_JAVASCRIPT == nScheme || URL_SCHEME_VBSCRIPT == nScheme)
        {
            WCHAR szTitle[MAX_PATH];
            WCHAR szText[MAX_PATH];

            MLLoadString(IDS_SECURITYALERT, szTitle, ARRAYSIZE(szTitle));
            MLLoadString(IDS_ADDTOFAV_WARNING + ilsFlag, szText,
                         ARRAYSIZE(szText));

            ULONG_PTR uCookie = 0;
            SHActivateContext(&uCookie);
            fRet = (IDYES == MLShellMessageBox(hwnd, szText, szTitle, MB_YESNO |
                                               MB_ICONWARNING | MB_APPLMODAL |
                                               MB_DEFBUTTON2));
            if (uCookie)
            {
                SHDeactivateContext(uCookie);
            }
        }
    }

    return fRet;
}

HRESULT GetSearchStyle(IServiceProvider * psp, LPDWORD pdwSearchStyle)
{
    RIP(pdwSearchStyle != NULL);

    HRESULT hr = E_FAIL;

    // first see if there is an ISearchContext to get this information from
    if (psp != NULL)
    {
        ISearchContext * pSC = NULL;
        hr = psp->QueryService(SID_STopWindow, IID_PPV_ARG(ISearchContext, &pSC));
        if (SUCCEEDED(hr))
        {
            RIP(pSC != NULL);

            hr = pSC->GetSearchStyle(pdwSearchStyle);
            pSC->Release();
        }
    }

    // there wasn't a viable search context, so try the reg key
    if (FAILED(hr))
    {
        DWORD dwType;
        DWORD dwAutoSearch;
        DWORD cb = sizeof(dwAutoSearch);

        if (ERROR_SUCCESS == SHRegGetUSValue(REGSTR_PATH_MAIN, L"AutoSearch", &dwType, &dwAutoSearch, &cb, FALSE, NULL, 0))
        {
            *pdwSearchStyle = dwAutoSearch;
            hr = S_OK;
        }
    }

    // return a default value
    if (FAILED(hr))
    {
        hr = S_FALSE;

        // Default to "display results in search pane and go to most likely site"
        *pdwSearchStyle = 3;
    }

    return hr;
}

BOOL AccessAllowed(LPCWSTR pwszURL1, LPCWSTR pwszURL2)
{
    BOOL fRet = FALSE;
    IInternetSecurityManager *pSecMgr = NULL;

    if (pwszURL1 && pwszURL2 && SUCCEEDED(CoCreateInstance(CLSID_InternetSecurityManager, 
                                   NULL, 
                                   CLSCTX_INPROC_SERVER,
                                   IID_PPV_ARG(IInternetSecurityManager, &pSecMgr))))
    {
        BYTE reqSid[MAX_SIZE_SECURITY_ID], docSid[MAX_SIZE_SECURITY_ID];
        DWORD cbReqSid = ARRAYSIZE(reqSid);
        DWORD cbDocSid = ARRAYSIZE(docSid);

        if (   SUCCEEDED(pSecMgr->GetSecurityId(pwszURL1, reqSid, &cbReqSid, 0))
            && SUCCEEDED(pSecMgr->GetSecurityId(pwszURL2, docSid, &cbDocSid, 0))
            && (cbReqSid == cbDocSid)
            && (memcmp(reqSid, docSid, cbReqSid) == 0))                    
        {
            fRet = TRUE;
        }
        pSecMgr->Release();
    }
    return fRet;
}

BOOL IsFrameWindow(IHTMLWindow2 * pHTMLWindow)
{
    BOOL fIsFrame = FALSE;

    HRESULT hr = E_FAIL;

    IHTMLWindow2 * pParentWindow = NULL;
    IHTMLWindow2 * pSelfWindow   = NULL;
    
    ASSERT(pHTMLWindow);

    hr = pHTMLWindow->get_self(&pSelfWindow);

    if (FAILED(hr) || (pSelfWindow == NULL))
    {
        goto cleanup;
    }

    hr = pHTMLWindow->get_parent(&pParentWindow);

    if (FAILED(hr) || (pParentWindow == NULL))
    {
        goto cleanup;
    }
    
    if (!IsSameObject(pSelfWindow, pParentWindow))
    {
        fIsFrame = TRUE;
    }

cleanup:

    if (pSelfWindow)
    {
        pSelfWindow->Release();
    }

    if (pParentWindow)
    {
        pParentWindow->Release();
    }

    return fIsFrame;
}

// For compatability with the Win2k debug SHELL32.DLL, this function needs to exist at ordinal 161.
// It's fine for it to return FALSE.
STDAPI_(BOOL) GetLeakDetectionFunctionTable(void *pTable)
{
    return FALSE;
}

STDAPI_(BOOL) IsCSIDLFolder(UINT csidl, LPCITEMIDLIST pidl)
{
    BOOL bRet = FALSE;
    TCHAR szPath[MAX_PATH];
    if (SUCCEEDED(SHGetFolderPathD(NULL, csidl, NULL, 0, szPath)))
    {
        PathRemoveBackslash(szPath);    // some platforms return version with slash on the end
        TCHAR szFolder[MAX_PATH];
        if (SUCCEEDED(SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szFolder, ARRAYSIZE(szFolder), NULL)))
        {
            bRet = (StrCmpI(szFolder, szPath) == 0);
        }
    }
    return bRet;
}

// Determines if the classic toolbar strips should be used, or the new
// Whistler toolbar strips.
//
// To use the new Whistler strips, the user must be running Whistler or later
// and have a display with greater than 256 colors.

STDAPI_(BOOL) SHUseClassicToolbarGlyphs (void)
{
    BOOL bRet = TRUE;

    if (SHGetCurColorRes() > 8)
    {
        if (GetUIVersion() > 5)
        {
            bRet = FALSE;
        }
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\wvt.cpp ===
#include "priv.h"
#include <wintrust.h>
#include "wvtp.h"

#define WINTRUST TEXT("wintrust.dll")

#ifdef DELAY_LOAD_WVT

#ifndef _WVTP_NOCODE_
Cwvt::Cwvt()
{
    m_fInited = FALSE;
}

Cwvt::~Cwvt()
{
    if (m_fInited) {
        FreeLibrary(m_hMod);
    }
}

HRESULT 
Cwvt::Init(void)
{

    if (m_fInited) {
        return S_OK;
    }

    m_hMod = LoadLibrary( WINTRUST );

    if (NULL == m_hMod) {
        return (HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND));
    }


#define CHECKAPI(_fn) \
    *(FARPROC*)&(_pfn##_fn) = GetProcAddress(m_hMod, #_fn); \
    if (!(_pfn##_fn)) { \
        FreeLibrary(m_hMod); \
        return (HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND)); \
    }

    CHECKAPI(WinVerifyTrust);

    m_fInited = TRUE;
    return S_OK;
}


#endif // _WVTP_NOCODE_
#endif // DELAY_LOAD_WVT

#define REGSTR_PATH_INFODEL_REST     TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Infodelivery\\Restrictions")
#define REGSTR_PATH_DOWNLOAD  TEXT("Software\\Microsoft\\Internet Explorer\\Download")
#define REGVAL_UI_REST        TEXT("NoWinVerifyTrustUI")

BOOL
IsUIRestricted()
{

    HKEY hkeyRest = 0;
    BOOL bUIRest = FALSE;
    DWORD dwValue = 0;
    DWORD dwLen = sizeof(DWORD);

    // per-machine UI off policy
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_INFODEL_REST, 0, KEY_READ, &hkeyRest) == ERROR_SUCCESS) {

        if (RegQueryValueEx( hkeyRest, REGVAL_UI_REST, NULL, NULL,
                      (LPBYTE)&dwValue, &dwLen) == ERROR_SUCCESS && dwValue)
            bUIRest = TRUE;

        RegCloseKey(hkeyRest);
    }

    return bUIRest;
}

// FEATURE: move these to corpolicy.h in iedev\inc!!!
// {D41E4F1F-A407-11d1-8BC9-00C04FA30A41}
#define COR_POLICY_LOCKDOWN_CHECK \
{ 0xd41e4f1f, 0xa407, 0x11d1, {0x8b, 0xc9, 0x0, 0xc0, 0x4f, 0xa3, 0xa, 0x41 } }

//--------------------------------------------------------------------
// For COR_POLICY_LOCKDOWN_CHECK:
// -----------------------------

// Structure to pass into WVT
typedef struct _COR_LOCKDOWN {
    DWORD                 cbSize;          // Size of policy provider
    DWORD                 flag;            // reserved
    BOOL                  fAllPublishers;  // Trust all publishers or just ones in the trusted data base
} COR_LOCKDOWN, *PCOR_LOCKDOWN;


HRESULT Cwvt::VerifyTrust(HANDLE hFile, HWND hWnd, LPCWSTR szStatusText) 
{
    WINTRUST_DATA           sWTD;
    WINTRUST_FILE_INFO      sWTFI;

    GUID gV2 = COR_POLICY_LOCKDOWN_CHECK;
    COR_LOCKDOWN  sCorPolicy;

    HRESULT hr = S_OK;

    memset(&sCorPolicy, 0, sizeof(COR_LOCKDOWN));
    
    sCorPolicy.cbSize = sizeof(COR_LOCKDOWN);

    if ( (hWnd == INVALID_HANDLE_VALUE) || IsUIRestricted())
        sCorPolicy.fAllPublishers = FALSE; // lockdown to only trusted pubs
    else
        sCorPolicy.fAllPublishers = TRUE; // regular behavior
    
    // Set up the winverify provider structures
    memset(&sWTD, 0x00, sizeof(WINTRUST_DATA));
    memset(&sWTFI, 0x00, sizeof(WINTRUST_FILE_INFO));
        
    sWTFI.cbStruct      = sizeof(WINTRUST_FILE_INFO);
    sWTFI.hFile         = hFile;
    sWTFI.pcwszFilePath = szStatusText;

    sWTD.cbStruct       = sizeof(WINTRUST_DATA);
    sWTD.pPolicyCallbackData = &sCorPolicy; // Add in the cor trust information!!

    //check policy to find out if we should display UI 

    if (SHRegGetBoolUSValue(REGSTR_PATH_DOWNLOAD, TEXT("CheckExeSignatures"),FALSE, FALSE))
    {
        sWTD.dwUIChoice     = WTD_UI_ALL;        // No bad UI is overridden in COR TRUST provider
        sWTD.dwUnionChoice  = WTD_CHOICE_FILE;
        sWTD.pFile          = &sWTFI;
        
        ULONG_PTR uCookie = 0;
        SHActivateContext(&uCookie);

        hr = WinVerifyTrust(hWnd, &gV2, &sWTD);
        
        if (uCookie)
        {
            SHDeactivateContext(uCookie);
        }

        // APPCOMPAT: this works around a wvt bug that returns 0x57 (success) when
        // you hit No to an usigned control
        if (SUCCEEDED(hr) && hr != S_OK) {
            hr = TRUST_E_FAIL;
        }
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\util.h ===
#ifndef _UTIL_H_
#define _UTIL_H_

#include "mshtmdid.h"
#include "shlwapi.h"
#include <htmlhelp.h>
#include "mshtml.h"     // for IHTMLElement

#ifndef UNIX
#include <webcheck.h>
#else
#include <subsmgr.h>
#endif
#include "shui.h"

#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */


extern HICON g_hiconSplat;
extern HICON g_hiconSplatSm;


void    LoadCommonIcons(void);
BOOL    ViewIDFromViewMode(UINT uViewMode, SHELLVIEWID *pvid);
void    SaveDefaultFolderSettings();
HRESULT DropOnMailRecipient(IDataObject *pdtobj, DWORD grfKeyState);
HRESULT SendDocToMailRecipient(LPCITEMIDLIST pidl, UINT uiCodePage, DWORD grfKeyState);

//
// Automation support.
//
HRESULT CDDEAuto_Navigate(BSTR str, HWND *phwnd, long lLaunchNewWindow);
HRESULT CDDEAuto_get_LocationURL(BSTR * pstr, HWND hwnd);
HRESULT CDDEAuto_get_LocationTitle(BSTR * pstr, HWND hwnd);
HRESULT CDDEAuto_get_HWND(long * phwnd);
HRESULT CDDEAuto_Exit(void);

BOOL    _InitComCtl32();

// 
//  Menu utility functions
//

void    Menu_Replace(HMENU hmenuDst, HMENU hmenuSrc);
#define  LoadMenuPopup(id) SHLoadMenuPopup(MLGetHinst(), id)
void    Menu_AppendMenu(HMENU hmenuDst, HMENU hmenuSrc);
TCHAR   StripMneumonic(LPTSTR szMenu);


DWORD   CommonDragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt);

int PropBag_ReadInt4(IPropertyBag* pPropBag, LPWSTR pszKey, int iDefault);

DWORD SHRandom(void);

STDAPI_(BOOL) UrlIsInCache(LPCTSTR pszURL);
STDAPI_(BOOL) UrlIsMappedOrInCache(LPCTSTR pszURL);
STDAPI_(BOOL) UrlIsInstalledEntry(LPCTSTR pszURL);

#ifdef UNICODE
#define IsSubscribable IsSubscribableW
#else // UNICODE
#define IsSubscribable IsSubscribableA
#endif // UNICODE

BOOL IsFileUrl(LPCSTR psz);
BOOL IsFileUrlW(LPCWSTR pcwzUrl);
BOOL IsEmptyStream(IStream* pstm);
BOOL IsInternetExplorerApp();
BOOL IsTopFrameBrowser(IServiceProvider *psp, IUnknown *punk);
BOOL IsSubscribableW(LPCWSTR psz);
BOOL IsSubscribableA(LPCSTR psz);

#define GEN_DEBUGSTRW(str)  ((str) ? (str) : L"<Null Str>")
#define GEN_DEBUGSTRA(str)  ((str) ? (str) : "<Null Str>")

#ifdef UNICODE
#define GEN_DEBUGSTR  GEN_DEBUGSTRW
#else // UNICODE
#define GEN_DEBUGSTR  GEN_DEBUGSTRA
#endif // UNICODE

HRESULT URLSubRegQueryA(LPCSTR pszKey, LPCSTR pszValue, BOOL fUseHKCU, 
                           LPSTR pszUrlOut, DWORD cchSize, DWORD dwSubstitutions);
HRESULT URLSubRegQueryW(LPCWSTR pszKey, LPCWSTR pszValue, BOOL fUseHKCU, 
                           LPWSTR pszUrlOut, DWORD cchSize, DWORD dwSubstitutions);
#ifdef UNICODE
#define URLSubRegQuery URLSubRegQueryW
#else
#define URLSubRegQuery URLSubRegQueryA
#endif

#define FillExecInfo(_info, _hwnd, _verb, _file, _params, _dir, _show) \
        (_info).hwnd            = _hwnd;        \
        (_info).lpVerb          = _verb;        \
        (_info).lpFile          = _file;        \
        (_info).lpParameters    = _params;      \
        (_info).lpDirectory     = _dir;         \
        (_info).nShow           = _show;        \
        (_info).fMask           = 0;            \
        (_info).cbSize          = sizeof(SHELLEXECUTEINFO);

void    _DeletePidlDPA(HDPA hdpa);

STDAPI_(BOOL) GetShortcutFileName(LPCTSTR pszTarget, LPCTSTR pszTitle, LPCTSTR pszDir, LPTSTR pszOut, int cchOut);
    

//-----------------------------------------------------------------------------
#define PropagateMessage SHPropagateMessage

//-----------------------------------------------------------------------------

BOOL PrepareURLForExternalApp(LPCWSTR psz, LPWSTR pszOut, LPDWORD pcchOut);


#define PrepareURLForDisplayUTF8  PrepareURLForDisplayUTF8W 
#define PrepareURLForDisplay      PrepareURLForDisplayW

STDAPI_(BOOL) PrepareURLForDisplayW(LPCWSTR pwz, LPWSTR pwzOut, LPDWORD pcbOut);
HRESULT PrepareURLForDisplayUTF8W(LPCWSTR pwz, LPWSTR pwzOut, LPDWORD pcbOut, BOOL fUTF8Enabled);
BOOL ParseURLFromOutsideSourceA (LPCSTR psz, LPSTR pszOut, LPDWORD pcchOut, LPBOOL pbWasSearchURL);
BOOL ParseURLFromOutsideSourceW (LPCWSTR psz, LPWSTR pszOut, LPDWORD pcchOut, LPBOOL pbWasSearchURL);
BOOL ParseURLFromOutsideSourceWithContextW (LPCWSTR psz, LPWSTR pszOut, LPDWORD pcchOut, LPBOOL pbWasSearchURL, ISearchContext * pSC);

BOOL UTF8Enabled();


HRESULT         FormatUrlForDisplay(LPWSTR pszURL, LPWSTR pszFriendly, UINT cbBuf, LPWSTR pszFrom, UINT cbFrom, BOOL fSeperate, DWORD dwCodePage, PWSTR pwzCachedFileName);
BOOL    __cdecl _FormatMessage(LPCWSTR szTemplate, LPWSTR szBuf, UINT cchBuf, ...);
EXECUTION_STATE _SetThreadExecutionState(EXECUTION_STATE esFlags);


//=--------------------------------------------------------------------------=
// string helpers.
//

STDAPI_(BSTR) SysAllocStringA(LPCSTR pszAnsiStr);
STDAPI_(BSTR) LoadBSTR(UINT uID);

#ifdef UNICODE
#define SysAllocStringT(psz)    SysAllocString(psz)
#else
#define SysAllocStringT(psz)    SysAllocStringA(psz)
#endif

// FEATURE:: Need to handle two different implementations of SHChangeRegister...
typedef ULONG (* PFNSHCHANGENOTIFYREGISTER)(HWND hwnd, int fSources, LONG fEvents, UINT wMsg, int cEntries, SHChangeNotifyEntry *pshcne);
typedef BOOL  (* PFNSHCHANGENOTIFYDEREGISTER)(unsigned long ulID);


extern PFNSHCHANGENOTIFYREGISTER    g_pfnSHChangeNotifyRegister;
extern PFNSHCHANGENOTIFYDEREGISTER  g_pfnSHChangeNotifyDeregister;
extern BOOL g_fNewNotify;

#define SZ_BINDCTXKEY_SITE         L"Site"

#define MAX_PAGES 16  // limit on the number of pages we can have

BOOL CALLBACK AddPropSheetPage(HPROPSHEETPAGE hpage, LPARAM lParam);

ULONG   RegisterNotify(HWND hwnd, UINT nMsg, LPCITEMIDLIST pidl, DWORD dwEvents, UINT uFlags, BOOL fRecursive);
BOOL    bIsValidString(LPCSTR pszString, ULONG cbLen);
void    Cabinet_FlagsToParams(UINT uFlags, LPTSTR pszParams);
HRESULT BindToAncesterFolder(LPCITEMIDLIST pidlAncester, LPCITEMIDLIST pidl, IShellFolder** ppsfParent, LPCITEMIDLIST *ppidlChild);

// logical defines for grfKeyState bits
#define FORCE_COPY (MK_LBUTTON | MK_CONTROL)                // means copy
#define FORCE_LINK (MK_LBUTTON | MK_CONTROL | MK_SHIFT)     // means link

HRESULT IsChildOrSelf(HWND hwndParent, HWND hwnd);

extern HIMAGELIST g_himlSysSmall;
extern HIMAGELIST g_himlSysLarge;

void    _InitSysImageLists();

extern const VARIANT c_vaEmpty;
//
// FEATURE: Remove this ugly const to non-const casting if we can
//  figure out how to put const in IDL files.
//
#define PVAREMPTY ((VARIANT*)&c_vaEmpty)

extern UINT g_cfURL;
extern UINT g_cfURLW;
extern UINT g_cfHIDA;
extern UINT g_cfFileDescA;
extern UINT g_cfFileDescW;
extern UINT g_cfFileContents;

#ifdef UNICODE
#define g_cfFileDesc    g_cfFileDescW
#else
#define g_cfFileDesc    g_cfFileDescA
#endif

void InitClipboardFormats();

void* DataObj_GetDataOfType(IDataObject* pdtobj, UINT cfType, STGMEDIUM *pstg);

LONG OpenRegUSKey(LPCTSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);       // dllreg.cpp

//-------------------------------------------------------------------------

extern int g_cxEdge;
extern int g_cyEdge;
extern int g_cxIcon;
extern int g_cyIcon;
extern int g_cxSmIcon;
extern int g_cySmIcon;

enum TRI_STATE
{
    TRI_UNKNOWN = 2,
    TRI_TRUE = TRUE,
    TRI_FALSE = FALSE
};

BOOL        IsSameObject(IUnknown* punk1, IUnknown* punk2);

#define TrimWhiteSpaceW(psz)        StrTrimW(psz, L" \t")
#define TrimWhiteSpaceA(psz)        StrTrimA(psz, " \t")

#ifdef UNICODE
#define TrimWhiteSpace      TrimWhiteSpaceW
#else
#define TrimWhiteSpace      TrimWhiteSpaceA
#endif

LPCTSTR     SkipLeadingSlashes(LPCTSTR pszURL);

extern const LARGE_INTEGER c_li0;
extern const DISPPARAMS c_dispparamsNoArgs;
#ifndef UNIX
#define g_dispparamsNoArgs ((DISPPARAMS)c_dispparamsNoArgs) // prototype was incorrect!
#else
#define g_dispparamsNoArgs c_dispparamsNoArgs // prototype was incorrect!
#endif
BOOL IsEmptyStream(IStream* pstm);

void SetParentHwnd(HWND hwnd, HWND hwndParent);
#ifndef UNICODE

#define ADJUST_TO_WCHAR_POS     0
#define ADJUST_TO_TCHAR_POS     1
int AdjustECPosition(char *psz, int iPos, int iType);

HRESULT MapNbspToSp(LPCWSTR lpwszIn, LPTSTR lpszOut, int cbszOut);
HRESULT GetDisplayableTitle(LPTSTR psz, LPCWSTR wszTitle, int cch);
#endif

LPITEMIDLIST GetTravelLogPidl(IBrowserService * pbs);

BOOL ILIsWeb(LPCITEMIDLIST pidl);

#define AnsiToUnicode(pstr, pwstr, cch)     SHAnsiToUnicode(pstr, pwstr, cch)
#define UnicodeToAnsi(pwstr, pstr, cch)     SHUnicodeToAnsi(pwstr, pstr, cch)

#define UnicodeToTChar(pwstr, pstr, cch)    SHUnicodeToTChar(pwstr, pstr, cch)
#define AnsiToTChar(pstr, ptstr, cch)       SHAnsiToTChar(pstr, ptstr, cch)
#define TCharToAnsi(ptstr, pstr, cch)       SHTCharToAnsi(ptstr, pstr, cch)

//Function for doing drag and drop given a pidl
HRESULT DragDrop(HWND hwnd, IShellFolder* psfParent, LPCITEMIDLIST pidl, DWORD dwPrefEffect, DWORD* pdwEffect);
HRESULT _SetPreferredDropEffect(IDataObject *pdtobj, DWORD dwEffect);

//Function for getting icon index corresponding to htm files
int _GetIEHTMLImageIndex();
int _GetHTMLImageIndex();
int IEMapPIDLToSystemImageListIndex(IShellFolder *psfParent, LPCITEMIDLIST pidlChild, int * piSelectedImage);
void IEInvalidateImageList(void);

extern UINT g_cfURL;
extern UINT g_cfURLW;
extern UINT g_cfFileDescA;
extern UINT g_cfFileContents;
extern UINT g_cfPreferredEffect;
extern UINT g_cfPerformedEffect;
extern UINT g_cfTargetCLSID;
#ifdef UNICODE
#define g_cfFileDesc    g_cfFileDescW
#else
#define g_cfFileDesc    g_cfFileDescA
#endif

void InitClipboardFormats();

BOOL IsExpandableFolder(IShellFolder* psf, LPCITEMIDLIST pidl);

extern BOOL IsGlobalOffline(void);
extern void SetGlobalOffline(BOOL fOffline);

BOOL GetHistoryFolderPath(LPTSTR pszPath, int cchPath);
IStream * OpenPidlOrderStream(LPCITEMIDLIST pidlRoot
                                , LPCITEMIDLIST pidl       
                                , LPCSTR pszKey
                                , DWORD   grfMode);


COLORREF RegGetColorRefString( HKEY hkey, LPTSTR RegValue, COLORREF Value);
int SearchMapInt(const int *src, const int *dst, int cnt, int val);
#ifdef DEBUG
int SearchDW(DWORD *pdwBuf, int cbBuf, DWORD dwVal);
#endif

STDAPI_(LPITEMIDLIST) IEILCreate(UINT cbSize);

// this is for the file menus recently visited list.  
//  it represents the count of entries both back and forward 
//  that should be on the menu.
#define CRECENTMENU_MAXEACH     5

BOOL VerbExists(LPCTSTR pszExtension, LPCTSTR pszVerb, LPTSTR pszCommand);

HRESULT CreateLinkToPidl(LPCITEMIDLIST pidlTo, LPCTSTR pszDir, LPCTSTR pszTitle, LPTSTR pszOut, int cchOut);

//  the shell32 implementation of ILClone is different for win95 an ie4.
//  it doesnt check for NULL in the old version, but it does in the new...
//  so we need to redefine it to always check
STDAPI_(LPITEMIDLIST) SafeILClone(LPCITEMIDLIST pidl);
#define ILClone         SafeILClone      

STDAPI_(void) _SHUpdateImageW( LPCWSTR pszHashItem, int iIndex, UINT uFlags, int iImageIndex );
STDAPI_(void) _SHUpdateImageA( LPCSTR pszHashItem, int iIndex, UINT uFlags, int iImageIndex );
STDAPI_(int)  _SHHandleUpdateImage( LPCITEMIDLIST pidlExtra );

STDAPI CActiveDesktop_InternalCreateInstance(LPUNKNOWN * ppunk, REFIID riid);

BOOL ExecItemFromFolder(HWND hwnd, LPCSTR pszVerb, IShellFolder* psf, LPCITEMIDLIST pidlItem);

HRESULT NavToUrlUsingIEA(LPCSTR szUrl, BOOL fNewWindow);
HRESULT NavToUrlUsingIEW(LPCWSTR wszUrl, BOOL fNewWindow);

#ifdef UNICODE
#define NavToUrlUsingIE             NavToUrlUsingIEW
#else // UNICODE
#define NavToUrlUsingIE             NavToUrlUsingIEA
#endif // UNICODE

DWORD WaitForSendMessageThread(HANDLE hThread, DWORD dwTimeout);
BOOL  CreateNewFolder(HWND hwndOwner, LPCITEMIDLIST pidlParent, LPTSTR szPathNew, int nSize);

#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */

STDAPI GetHTMLDoc2(IUnknown *punk, IHTMLDocument2 **ppHtmlDoc);
STDAPI_(IBindCtx *) CreateBindCtxForUI(IUnknown * punkSite);


// _FrameTrack flags
#define TRACKHOT        0x0001
#define TRACKEXPAND     0x0002
#define TRACKNOCHILD    0x0004
void FrameTrack(HDC hdc, LPRECT prc, UINT uFlags);


#ifdef DEBUG

#ifdef UNICODE
#define DebugFillInputString          DebugFillInputStringW
#else // UNICODE
#define DebugFillInputString          DebugFillInputStringA
#endif // UNICODE

void DebugFillInputStringA(LPSTR pszBuffer, DWORD cchSize);
void DebugFillInputStringW(LPWSTR pwzBuffer, DWORD cchSize);
#endif // DEBUG

void GetWebLocaleAsRFC1766(LPTSTR pszLocale, int cchLocale);

BOOL IsExplorerWindow(HWND hwnd);
BOOL IsFolderWindow(HWND hwnd);
BOOL FindBrowserWindow(void);

BOOL IsVK_TABCycler(MSG * pMsg);

// Review chrisny:  this can be moved into an object easily to handle generic droptarget, dropcursor
// , autoscrool, etc. . .
void _DragEnter(HWND hwndTarget, const POINTL ptStart, IDataObject *pdtObject);
void _DragMove(HWND hwndTarget, const POINTL ptStart);


BOOL IsFeaturePotentiallyAvailable(REFCLSID rclsid);
STDAPI IEBindToObjectWithBC(LPCITEMIDLIST pidl, IBindCtx * pbc, IShellFolder **ppsfOut);

STDAPI_(UINT) GetWheelMsg();

STDAPI GetCacheLocation(LPTSTR pszCacheLocation, DWORD dwSize);

STDAPI StringToStrRet(LPCTSTR pString, STRRET *pstrret);

STDAPI_(HCURSOR) LoadHandCursor(DWORD dwRes);

HRESULT GetNavTargetName(IShellFolder* psf, LPCITEMIDLIST pidl, LPTSTR pszUrl, UINT cMaxChars);
STDAPI GetLinkInfo(IShellFolder* psf, LPCITEMIDLIST pidlItem, BOOL* pfAvailable, BOOL* pfSticky);

int GetAvgCharWidth(HWND hwnd);
void FixAmpersands(LPWSTR pszToFix, UINT cchMax);
// PostShellIEBroadcastMessage is commented out since it is not used right now
// STDAPI_(LRESULT)  PostShellIEBroadcastMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);

BOOL IsInetcplRestricted(LPCWSTR pszCommand);
BOOL IsNamedWindow(HWND hwnd, LPCTSTR pszClass);
BOOL HasExtendedChar(LPCWSTR pszQuery);
void ConvertToUtf8Escaped(LPWSTR pszQuery, int cch);
HRESULT SHPathPrepareForWriteWrap(HWND hwnd, IUnknown *punkEnableModless, LPCTSTR pszPath, UINT wFunc, DWORD dwFlags);

BOOL SHIsRestricted2W(HWND hwnd, BROWSER_RESTRICTIONS rest, LPCWSTR pwzUrl, DWORD dwReserved);

HRESULT IExtractIcon_GetIconLocation(
    IUnknown *punk,
    IN  UINT   uInFlags,
    OUT LPTSTR pszIconFile,
    IN  UINT   cchIconFile,
    OUT PINT   pniIcon,
    OUT PUINT  puOutFlags);

HRESULT IExtractIcon_Extract(
    IUnknown *punk,
    IN  LPCTSTR pszIconFile,
    IN  UINT    iIcon,
    OUT HICON * phiconLarge,
    OUT HICON * phiconSmall,
    IN  UINT    ucIconSize);
    
// Takes in lpszPath and returns the other form (SFN or LFN).
void GetPathOtherFormA(LPSTR lpszPath, LPSTR lpszNewPath, DWORD dwSize);

STDAPI CoAllowSetForegroundWindow(IUnknown *punk, void *pvReserved);    // in > v5 headers

HRESULT GetSearchStyle(IServiceProvider * psp, LPDWORD pdwSearchStyle);

BOOL AccessAllowed(
    LPCWSTR pwszURL1,
    LPCWSTR pwszURL2);

BOOL IsFrameWindow(IHTMLWindow2 * pHTMLWindow);

STDAPI SHGetFolderPathD(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPTSTR pszPath);

STDAPI_(BOOL) IsCSIDLFolder(UINT csidl, LPCITEMIDLIST pidl);

#endif // _UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\cdfview\copyhook.cpp ===
//
// Copy Hook Handler for CDFView shell extension
//
// Description:
//     This object installs an ICopyHook handler that traps all
//     copies/movies/renames in the shell so that we can special 
//     case links to channel objects and unsubscribe them when
//     the link is deleted. The implementation is in shdocvw for
//     speed.
//
// julianj 6/16/97
// 

#include "priv.h"
#include "sccls.h"
#include "chanmgr.h"
#include "channel.h"
#include "../resource.h"

#include <mluisupp.h>

class CCDFCopyHook 
                        : public ICopyHookA
                        , public ICopyHookW
{
public:
    
    // *** IUnknown ***
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // *** ICopyHookA method ***
    STDMETHODIMP_(UINT) CopyCallback(HWND hwnd, 
        UINT wFunc, UINT wFlags, LPCSTR pszSrcFile, DWORD dwSrcAttribs, LPCSTR pszDestFile, DWORD dwDestAttribs);

    // *** ICopyHookW method ***
    STDMETHODIMP_(UINT) CopyCallback(HWND hwnd, 
        UINT wFunc, UINT wFlags, LPCWSTR pwzSrcFile, DWORD dwSrcAttribs, LPCWSTR pwzDestFile, DWORD dwDestAttribs);

private:
    CCDFCopyHook( HRESULT * pHr);
    ~CCDFCopyHook();

    BOOL IsSubscriptionFolder(LPCTSTR pszPath);

    LONG m_cRef;

    friend HRESULT CCDFCopyHook_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);    // for ctor
};

//The copyhook handler uses this function

HRESULT Channel_GetFolder(LPTSTR pszPath, int cchPath)
{
    TCHAR szChannel[MAX_PATH];
    TCHAR szFav[MAX_PATH];
    ULONG cbChannel = sizeof(szChannel);
    
    if (SHGetSpecialFolderPath(NULL, szFav, CSIDL_FAVORITES, TRUE))
    {
        //
        // Get the potentially localized name of the Channel folder from the
        // registry if it is there.  Otherwise just read it from the resource.
        // Then tack this on the favorites path.
        //

        if (ERROR_SUCCESS != SHRegGetUSValue(L"Software\\Microsoft\\Windows\\CurrentVersion",
                                             L"ChannelFolderName", NULL, (void*)szChannel,
                                             &cbChannel, TRUE, NULL, 0))
        {
            MLLoadString(IDS_CHANNEL, szChannel, ARRAYSIZE(szChannel));
        }

        PathCombine(pszPath, szFav, szChannel);

        //
        // For IE5+ use the channels dir if it exists - else use favorites
        //
        if (!PathFileExists(pszPath))
            StrCpyN(pszPath, szFav, cchPath);

        return S_OK;
    }    
    
    return E_FAIL;
}


//
// Basic CreateInstance for this object
//
HRESULT CCDFCopyHook_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    if ( pUnkOuter )
        return CLASS_E_NOAGGREGATION;

    HRESULT hr = NOERROR;
    CCDFCopyHook * pCDFCopyHook = new CCDFCopyHook( & hr );
    if ( !pCDFCopyHook )
    {
        return E_OUTOFMEMORY;
    }
    if ( FAILED( hr ))
    {
        delete pCDFCopyHook;
        return hr;
    }
    
    *ppunk = SAFECAST(pCDFCopyHook, ICopyHookA *);
    return NOERROR;
}

STDMETHODIMP CCDFCopyHook::QueryInterface( REFIID riid, LPVOID * ppvObj )
{
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IShellCopyHookA))
    {
        *ppvObj = SAFECAST(this, ICopyHookA *);
    }
    else if (IsEqualIID(riid, IID_IShellCopyHookW))
    {
        *ppvObj = SAFECAST(this, ICopyHookW *);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

STDMETHODIMP_ (ULONG) CCDFCopyHook::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_ (ULONG) CCDFCopyHook::Release()
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}

CCDFCopyHook::CCDFCopyHook( HRESULT * pHr) : m_cRef(1)
{
    *pHr = S_OK;
    DllAddRef();
}

CCDFCopyHook::~CCDFCopyHook()
{
    DllRelease();
}

////////////////////////////////////////////////////////////////////////////////
//
// ICopyHookA::CopyCallback
//
// Either allows the shell to move, copy, delete, or rename a folder or printer
// object, or disallows the shell from carrying out the operation. The shell 
// calls each copy hook handler registered for a folder or printer object until
// either all the handlers have been called or one of them returns IDCANCEL.
//
// RETURNS:
//
//  IDYES    - Allows the operation.
//  IDNO     - Prevents the operation on this file, but continues with any other
//             operations (for example, a batch copy operation).
//  IDCANCEL - Prevents the current operation and cancels any pending operations
//
////////////////////////////////////////////////////////////////////////////////
UINT CCDFCopyHook::CopyCallback(
    HWND hwnd,          // Handle of the parent window for displaying UI objects
    UINT wFunc,         // Operation to perform. 
    UINT wFlags,        // Flags that control the operation 
    LPCSTR pszSrcFile,  // Pointer to the source file 
    DWORD dwSrcAttribs, // Source file attributes 
    LPCSTR pszDestFile, // Pointer to the destination file 
    DWORD dwDestAttribs // Destination file attributes 
)
{
    WCHAR szSrcFile[MAX_PATH];
    WCHAR szDestFile[MAX_PATH];

    AnsiToUnicode(pszSrcFile, szSrcFile, ARRAYSIZE(szSrcFile));

    if (pszDestFile)    // shell32.dll can call with NULL for pszDestFile
        AnsiToUnicode(pszDestFile, szDestFile, ARRAYSIZE(szDestFile));
    else
        szDestFile[0] = L'\0';

    return CopyCallback(hwnd, wFunc, wFlags, szSrcFile, dwSrcAttribs, szSrcFile, dwDestAttribs);
}


CCDFCopyHook::IsSubscriptionFolder(LPCTSTR pszPath)
{
    TCHAR szSubsPath[MAX_PATH] = {0};
    DWORD dwSize = SIZEOF(szSubsPath);

    if (SHGetValueGoodBoot(HKEY_LOCAL_MACHINE, REGSTR_PATH_SUBSCRIPTION,
                       REGSTR_VAL_DIRECTORY, NULL, (LPBYTE)szSubsPath, &dwSize) != ERROR_SUCCESS)
    {
        TCHAR szWindows[MAX_PATH];

        GetWindowsDirectory(szWindows, ARRAYSIZE(szWindows));
        PathCombine(szSubsPath, szWindows, TEXT("Offline Web Pages"));
    }

    return 0 == StrCmpI(pszPath, szSubsPath);
}

////////////////////////////////////////////////////////////////////////////////
//
// ICopyHookW::CopyCallback
//
// Currently we just thunk to the ansi version.
//
////////////////////////////////////////////////////////////////////////////////
UINT CCDFCopyHook::CopyCallback(
    HWND hwnd,          // Handle of the parent window for displaying UI objects
    UINT wFunc,         // Operation to perform. 
    UINT wFlags,        // Flags that control the operation 
    LPCWSTR pszSrcFile,  // Pointer to the source file 
    DWORD dwSrcAttribs, // Source file attributes 
    LPCWSTR pszDestFile, // Pointer to the destination file 
    DWORD dwDestAttribs // Destination file attributes 
)
{
    HRESULT hr;
    ICopyHookA * pCDFViewCopyHookA;
    TCHAR   szPath[MAX_PATH];

    //
    // Return immediately if this isn't a system folder or if isn't a delete or
    // rename operation
    //
    if (!(wFunc == FO_DELETE || wFunc == FO_RENAME))
    {
        return IDYES;
    }

    // no rename of channels folder allowed.
    if ((wFunc == FO_RENAME) 
            && (Channel_GetFolder(szPath, ARRAYSIZE(szPath)) == S_OK) 
            && (StrCmpI(szPath, pszSrcFile) ==  0))
    {
        MessageBeep(MB_OK);
        return IDNO;
    }

    if (SHRestricted2W(REST_NoRemovingSubscriptions, NULL, 0) &&
        IsSubscriptionFolder(pszSrcFile))
    {
        MessageBeep(MB_OK);
        return IDNO;
    }

    if (!(dwSrcAttribs & FILE_ATTRIBUTE_SYSTEM))
        return IDYES;
    //
    // REVIEW could check for guid in desktop.ini matching CDFVIEW but its 
    // cleaner to have the ChannelMgr know about that
    //

    //
    // Create the channel manager object and ask it for the copy hook iface
    //
    hr = CoCreateInstance(CLSID_ChannelMgr, NULL,  CLSCTX_INPROC_SERVER, 
                          IID_IShellCopyHookA, (void**)&pCDFViewCopyHookA);
    if (SUCCEEDED(hr))
    {
        //
        // Delegate to the Copy hook handler in the channel mgr
        //
        CHAR szSrcFile[MAX_PATH];
        CHAR szDestFile[MAX_PATH] = {'\0'};

        SHUnicodeToAnsi(pszSrcFile, szSrcFile, ARRAYSIZE(szSrcFile));

        if (pszDestFile)
            SHUnicodeToAnsi(pszDestFile, szDestFile, ARRAYSIZE(szDestFile));

        UINT retValue = pCDFViewCopyHookA->CopyCallback(
                hwnd, wFunc, wFlags, szSrcFile, 
                dwSrcAttribs, szDestFile, dwDestAttribs);

        pCDFViewCopyHookA->Release();

        return retValue;
    }
    else
    {
        // Couldn't create ChannelMgr object for some reason 
        TraceMsg(TF_ERROR, "Could not CoCreateInstance CLSID_ChannelMgr");
        return IDYES;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\hist\cafitem.cpp ===
#include "local.h"
#include "../security.h"
#include "../favorite.h"
#include "resource.h"
#include "chcommon.h"
#include "cafolder.h"

#include <mluisupp.h>

#define DM_HSFOLDER 0

STDAPI  AddToFavorites(HWND hwnd, LPCITEMIDLIST pidlCur, LPCTSTR pszTitle,
                       BOOL fDisplayUI, IOleCommandTarget *pCommandTarget, IHTMLDocument2 *pDoc);

#define MAX_ITEM_OPEN 10

//////////////////////////////////////////////////////////////////////////////
//
// CCacheItem Object
//
//////////////////////////////////////////////////////////////////////////////


CCacheItem::CCacheItem() 
{
    _dwDelCookie = DEL_COOKIE_WARN;
}

CCacheItem::~CCacheItem()
{
    if (_pCFolder)
        _pCFolder->Release();          // release the pointer to the sf
}

HRESULT CCacheItem::Initialize(CCacheFolder *pCFolder, HWND hwnd, UINT cidl, LPCITEMIDLIST *ppidl)
{
    HRESULT hres = CBaseItem::Initialize(hwnd, cidl, ppidl);

    if (SUCCEEDED(hres))
    {
        _pCFolder = pCFolder;
        _pCFolder->AddRef();      // we're going to hold onto this pointer, so
    }

    return hres;
}        

HRESULT CCacheItem_CreateInstance(CCacheFolder *pCFolder, HWND hwnd,
    UINT cidl, LPCITEMIDLIST *ppidl, REFIID riid, void **ppv)
{
    HRESULT hr;

    *ppv = NULL;                 // null the out param

    CCacheItem *pHCItem = new CCacheItem;
    if (pHCItem)
    {
        hr = pHCItem->Initialize(pCFolder, hwnd, cidl, ppidl);
        if (SUCCEEDED(hr))
            hr = pHCItem->QueryInterface(riid, ppv);
        pHCItem->Release();
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

//////////////////////////////////
//
// IUnknown Methods...
//
HRESULT CCacheItem::QueryInterface(REFIID iid, void **ppv)
{
    HRESULT hres = CBaseItem::QueryInterface(iid, ppv);

    if (FAILED(hres) && iid == IID_ICache) 
    {
        *ppv = (LPVOID)this;    // for our friends
        AddRef();
        hres = S_OK;
    }
    return hres;
}

//////////////////////////////////
//
// IQueryInfo Methods
//
HRESULT CCacheItem::GetInfoTip(DWORD dwFlags, WCHAR **ppwszTip)
{
    return _pCFolder->_GetInfoTip(_ppidl[0], dwFlags, ppwszTip);
}

//////////////////////////////////
//
// IContextMenu Methods
//
HRESULT CCacheItem::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst,UINT idCmdLast, UINT uFlags)
{
    USHORT cItems;

    TraceMsg(DM_HSFOLDER, "hci - cm - QueryContextMenu() called.");
    
    if ((uFlags & CMF_VERBSONLY) || (uFlags & CMF_DVFILE))
    {
        cItems = MergePopupMenu(&hmenu, POPUP_CONTEXT_URL_VERBSONLY, 0, indexMenu, 
            idCmdFirst, idCmdLast);
    
    }
    else  // (uFlags & CMF_NORMAL)
    {
        UINT idResource = POPUP_CACHECONTEXT_URL;

        cItems = MergePopupMenu(&hmenu, idResource, 0, indexMenu, idCmdFirst, idCmdLast);

        if (IsInetcplRestricted(L"History"))
        {
            DeleteMenu(hmenu, RSVIDM_DELCACHE + idCmdFirst, MF_BYCOMMAND);
            _SHPrettyMenu(hmenu);
        }
    }
    if (hmenu)
        SetMenuDefaultItem(hmenu, indexMenu, MF_BYPOSITION);

    return ResultFromShort(cItems);    // number of menu items    
}

static BOOL CachevuWarningDlg(LPCEIPIDL pcei, UINT uIDWarning, HWND hwnd)
{
    TCHAR szFormat[MAX_PATH], szBuff[MAX_PATH], szTitle[MAX_PATH];

    _GetCacheItemTitle(pcei, szTitle, ARRAYSIZE(szTitle));
    MLLoadString(uIDWarning, szFormat, ARRAYSIZE(szFormat));
    wnsprintf(szBuff, ARRAYSIZE(szFormat), szFormat);

    return DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(DLG_HISTCACHE_WARNING),
                             hwnd, HistoryConfirmDeleteDlgProc, (LPARAM)szBuff) == IDYES;
} 

STDMETHODIMP CCacheItem::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    UINT i;
    int idCmd = _GetCmdID(pici->lpVerb);
    HRESULT hres = S_OK;
    DWORD dwAction;
    BOOL fCancelCopyAndOpen = FALSE;
    BOOL fZonesUI = FALSE;
    BOOL fMustFlushNotify = FALSE;
    BOOL fBulkDelete;

    TraceMsg(DM_HSFOLDER, "hci - cm - InvokeCommand() called.");

    // ZONES SECURITY CHECK.
    //
    // We need to cycle through each action and Zone Check the URLs.
    // We pass NOUI when zone checking the URLs because we don't want info
    // displayed to the user.  We will stop when we find the first questionable
    // URL.  We will then 
    for (i = 0; (i < _cItems) && !fZonesUI; i++)
    {
        if (_ppidl[i]) 
        {
            switch (idCmd)
            {
            case RSVIDM_OPEN:
                if ((i < MAX_ITEM_OPEN))
                {
                    if (!_ZoneCheck(i, URLACTION_SHELL_VERB))
                    {
                        fZonesUI = TRUE;
                        dwAction = URLACTION_SHELL_VERB;
                    }
                }
                break;

            case RSVIDM_COPY:
                if (!_ZoneCheck(i, URLACTION_SHELL_MOVE_OR_COPY))
                {
                    fZonesUI = TRUE;
                    dwAction = URLACTION_SHELL_MOVE_OR_COPY;
                }
                break;
            }
        }
    }

    if (fZonesUI)
    {
        LPCTSTR pszUrl = _GetUrl(i-1);  // Sub 1 because of for loop above.
        if (S_OK != ZoneCheckUrl(pszUrl, dwAction, PUAF_DEFAULT|PUAF_WARN_IF_DENIED, NULL))
        {
            // The user cannot do this or does not want to do this.
            fCancelCopyAndOpen = TRUE;
        }
    }

    i = _cItems;
    fBulkDelete = i > LOTS_OF_FILES;

    // fCancelCopyAndOpen happens if the user cannot or chose not to proceed.
    while (i && !fCancelCopyAndOpen)
    {
        i--;
        if (_ppidl[i]) 
        {

            switch (idCmd)
            {
            case RSVIDM_OPEN:
                if (i >= MAX_ITEM_OPEN)
                {
                    hres = S_FALSE;
                    goto Done;
                }

                if ((CEI_CACHEENTRYTYPE((LPCEIPIDL)_ppidl[i]) & COOKIE_CACHE_ENTRY))
                {
                    ASSERT(PathFindExtension(CEI_LOCALFILENAME((LPCEIPIDL)_ppidl[i])) && \
                        !StrCmpI(PathFindExtension(CEI_LOCALFILENAME((LPCEIPIDL)_ppidl[i])),TEXT(".txt")));
                    hres = _LaunchApp(pici->hwnd, CEI_LOCALFILENAME((LPCEIPIDL)_ppidl[i]));
                }
                else
                {
                    TCHAR szDecoded[MAX_URL_STRING];
                    LPCTSTR pszUrl = _GetUrl(i);
                    if (pszUrl)
                    {
                        ConditionallyDecodeUTF8(pszUrl, szDecoded, ARRAYSIZE(szDecoded));
                        hres = _LaunchApp(pici->hwnd, szDecoded);
                    }
                    else
                    {
                        hres = E_FAIL;
                    }
                }
                break;

            case RSVIDM_ADDTOFAVORITES:
                hres = _AddToFavorites(i);
                goto Done;
            case RSVIDM_OPEN_NEWWINDOW:
                {
                    LPCTSTR pszUrl = _GetUrl(i);
                    if (pszUrl)
                    {
                        TCHAR szDecoded[MAX_URL_STRING];
                        ConditionallyDecodeUTF8(pszUrl, szDecoded, ARRAYSIZE(szDecoded));
                        LPWSTR pwszTarget;
                    
                        if (SUCCEEDED((hres = SHStrDup(szDecoded, &pwszTarget)))) {
                            hres = NavToUrlUsingIEW(pwszTarget, TRUE);
                            CoTaskMemFree(pwszTarget);
                        }
                    }
                    else
                        hres = E_FAIL;
                    goto Done;
                }
            case RSVIDM_COPY:
                OleSetClipboard((IDataObject *)this);
                goto Done;

            case RSVIDM_DELCACHE:
                // pop warning msg for cookie only once
                if ((CEI_CACHEENTRYTYPE((LPCEIPIDL)_ppidl[i]) & COOKIE_CACHE_ENTRY) &&     
                    (_dwDelCookie == DEL_COOKIE_WARN ))
                {
                    if(CachevuWarningDlg((LPCEIPIDL)_ppidl[i], IDS_WARN_DELETE_CACHE, pici->hwnd))
                        _dwDelCookie = DEL_COOKIE_YES;
                    else
                        _dwDelCookie = DEL_COOKIE_NO;
                }

                if ((CEI_CACHEENTRYTYPE((LPCEIPIDL)_ppidl[i]) & COOKIE_CACHE_ENTRY) &&     
                    (_dwDelCookie == DEL_COOKIE_NO ))
                    continue;
          
                if (DeleteUrlCacheEntry(CPidlToSourceUrl((LPCEIPIDL)_ppidl[i])))
                {
                    if (!fBulkDelete)
                    {
                        _GenerateEvent(SHCNE_DELETE, _pCFolder->_pidl, _ppidl[i], NULL);
                    }
                    fMustFlushNotify = TRUE;
                }
                else 
                    hres = E_FAIL;
                break;

            case RSVIDM_PROPERTIES:
                // NOTE: We'll probably want to split this into two cases
                // and call a function in each case
                //
                _CreatePropSheet(pici->hwnd, _ppidl[i], DLG_CACHEITEMPROP, _sPropDlgProc,
                    CEI_SOURCEURLNAME((LPCEIPIDL)_ppidl[i]));
                goto Done;

            default:
                hres = E_FAIL;
                break;
            }
            
            ASSERT(SUCCEEDED(hres));
            if (FAILED(hres))
                TraceMsg(DM_HSFOLDER, "Cachevu failed the command at: %s", CPidlToSourceUrl((LPCEIPIDL)_ppidl[i]));
        }
    }
Done:
    if (fMustFlushNotify)
    {
        if (fBulkDelete)
        {
            _GenerateEvent(SHCNE_UPDATEDIR, _pCFolder->_pidl, NULL, NULL);
        }

        SHChangeNotifyHandleEvents();
    }
    return hres;
}

//////////////////////////////////
//
// IDataObject Methods...
//

HRESULT CCacheItem::GetData(LPFORMATETC pFEIn, LPSTGMEDIUM pSTM)
{
    HRESULT hres;

#ifdef DEBUG
    TCHAR szName[64];
    if (!GetClipboardFormatName(pFEIn->cfFormat, szName, sizeof(szName)))
        wnsprintf(szName, ARRAYSIZE(szName), TEXT("#%d"), pFEIn->cfFormat);

    TraceMsg(DM_HSFOLDER, "hci - do - GetData(%s)", szName);
#endif

    pSTM->hGlobal = NULL;
    pSTM->pUnkForRelease = NULL;

    if (pFEIn->cfFormat == CF_HDROP && (pFEIn->tymed & TYMED_HGLOBAL))
        hres = _CreateHDROP(pSTM);

    else if ((pFEIn->cfFormat == g_cfPreferredEffect) && (pFEIn->tymed & TYMED_HGLOBAL))
        hres = _CreatePrefDropEffect(pSTM);

    else
        hres = DATA_E_FORMATETC;
    
    return hres;

}

HRESULT CCacheItem::QueryGetData(LPFORMATETC pFEIn)
{
#ifdef DEBUG
    TCHAR szName[64];
    if (!GetClipboardFormatName(pFEIn->cfFormat, szName, sizeof(szName)))
        wnsprintf(szName, ARRAYSIZE(szName), TEXT("#%d"), pFEIn->cfFormat);

    TraceMsg(DM_HSFOLDER, "hci - do - QueryGetData(%s)", szName);
#endif

    if (pFEIn->cfFormat == CF_HDROP            || 
        pFEIn->cfFormat == g_cfPreferredEffect)
    {
        TraceMsg(DM_HSFOLDER, "		   format supported.");
        return NOERROR;
    }
    return S_FALSE;
}

HRESULT CCacheItem::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC *ppEnum)
{
    FORMATETC Cachefmte[] = {
        {CF_HDROP,                NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        {g_cfPreferredEffect,     NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
    };
    return SHCreateStdEnumFmtEtc(ARRAYSIZE(Cachefmte), Cachefmte, ppEnum);
}

//////////////////////////////////
//
// IExtractIconA Methods...
//
HRESULT CCacheItem::GetIconLocation(UINT uFlags, LPSTR pszIconFile, UINT ucchMax, PINT pniIcon, PUINT puFlags)
{
    if (ucchMax < 2)
        return E_FAIL;
    
    *puFlags = GIL_NOTFILENAME;
    pszIconFile[0] = '*';
    pszIconFile[1] = '\0';
    
    // "*" as the file name means iIndex is already a system icon index.
    return _pCFolder->GetIconOf(_ppidl[0], uFlags, pniIcon);
}

//////////////////////////////////////////////////////////////////////////////
//
// Helper Routines
//
//////////////////////////////////////////////////////////////////////////////

UNALIGNED const TCHAR* CCacheItem::_GetURLTitle(LPCITEMIDLIST pidl)
{
    return ::_GetURLTitle( (LPCEIPIDL) pidl);
}

LPCTSTR CCacheItem::_GetUrl(int nIndex)
{
    LPCTSTR pszUrl = NULL;
    pszUrl = CPidlToSourceUrl((LPCEIPIDL)_ppidl[nIndex]);
    return pszUrl;
}

LPCTSTR CCacheItem::_PidlToSourceUrl(LPCITEMIDLIST pidl)
{
    return CPidlToSourceUrl((LPCEIPIDL) pidl);
}


// Return value:
//               TRUE - URL is Safe.
//               FALSE - URL is questionable and needs to be re-zone checked w/o PUAF_NOUI.
BOOL CCacheItem::_ZoneCheck(int nIndex, DWORD dwUrlAction)
{
    LPCTSTR pszUrl = _GetUrl(nIndex);

    if (S_OK != ZoneCheckUrl(pszUrl, dwUrlAction, PUAF_NOUI, NULL))
        return FALSE;

    return TRUE;
}

INT_PTR CALLBACK CCacheItem::_sPropDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE) GetWindowLongPtr(hDlg, DWLP_USER);
    LPCEIPIDL pcei = lpPropSheet ? (LPCEIPIDL)lpPropSheet->lParam : NULL;

    switch(message) {

        case WM_INITDIALOG: {
            SHFILEINFO sfi;
            TCHAR szBuf[80];
            
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
            pcei = (LPCEIPIDL)((LPPROPSHEETPAGE)lParam)->lParam;

            // get the icon and file type strings

            SHGetFileInfo(CEI_LOCALFILENAME(pcei), 0, &sfi, SIZEOF(sfi), SHGFI_ICON | SHGFI_TYPENAME);

            SendDlgItemMessage(hDlg, IDD_ITEMICON, STM_SETICON, (WPARAM)sfi.hIcon, 0);

            // set the info strings
            SetDlgItemText(hDlg, IDD_HSFURL, CPidlToSourceUrl((LPCEIPIDL)pcei));
            SetDlgItemText(hDlg, IDD_FILETYPE, sfi.szTypeName);

            SetDlgItemText(hDlg, IDD_FILESIZE, StrFormatByteSize(pcei->cei.dwSizeLow, szBuf, ARRAYSIZE(szBuf)));
            SetDlgItemText(hDlg, IDD_CACHE_NAME, PathFindFileName(CEI_LOCALFILENAME(pcei)));
            FileTimeToDateTimeStringInternal(&pcei->cei.ExpireTime, szBuf, ARRAYSIZE(szBuf), FALSE);
            SetDlgItemText(hDlg, IDD_EXPIRES, szBuf);
            FileTimeToDateTimeStringInternal(&pcei->cei.LastModifiedTime, szBuf, ARRAYSIZE(szBuf), FALSE);
            SetDlgItemText(hDlg, IDD_LAST_MODIFIED, szBuf);
            FileTimeToDateTimeStringInternal(&pcei->cei.LastAccessTime, szBuf, ARRAYSIZE(szBuf), FALSE);
            SetDlgItemText(hDlg, IDD_LAST_ACCESSED, szBuf);
            
            break;
        }

        case WM_DESTROY:
            {
                HICON hIcon = (HICON)SendDlgItemMessage(hDlg, IDD_ITEMICON, STM_GETICON, 0, 0);
                if (hIcon)
                    DestroyIcon(hIcon);
            }
            break;

        case WM_COMMAND:
        case WM_HELP:
        case WM_CONTEXTMENU:
            // user can't change anything, so we don't care about any messages

            break;

        default:
            return FALSE;
            
    } // end of switch
    
    return TRUE;
}

// use CEI_LOCALFILENAME to get the file name for the HDROP, but map that
// to the final file name (store in the file system) through the "FileNameMap"
// data which uses _GetURLTitle() as the final name of the file.

HRESULT CCacheItem::_CreateHDROP(STGMEDIUM *pmedium)
{
    UINT i;
    UINT cbAlloc = sizeof(DROPFILES) + sizeof(CHAR);        // header + null terminator

    for (i = 0; i < _cItems; i++)
    {
        char szAnsiUrl[MAX_URL_STRING];
        
        SHTCharToAnsi(CEI_LOCALFILENAME((LPCEIPIDL)_ppidl[i]), szAnsiUrl, ARRAYSIZE(szAnsiUrl));
        cbAlloc += sizeof(CHAR) * (lstrlenA(szAnsiUrl) + 1);
    }

    pmedium->tymed = TYMED_HGLOBAL;
    pmedium->pUnkForRelease = NULL;
    pmedium->hGlobal = GlobalAlloc(GPTR, cbAlloc);
    if (pmedium->hGlobal)
    {
        LPDROPFILES pdf = (LPDROPFILES)pmedium->hGlobal;
        LPSTR pszFiles  = (LPSTR)(pdf + 1);
        int   cchFiles  = (cbAlloc - sizeof(DROPFILES) - sizeof(CHAR));
        pdf->pFiles = sizeof(DROPFILES);
        pdf->fWide = FALSE;

        for (i = 0; i < _cItems; i++)
        {
            LPTSTR pszPath = CEI_LOCALFILENAME((LPCEIPIDL)_ppidl[i]);
            int    cchPath = lstrlen(pszPath);

            SHTCharToAnsi(pszPath, pszFiles, cchFiles);

            pszFiles += cchPath + 1;
            cchFiles -= cchPath + 1;

            ASSERT((UINT)((LPBYTE)pszFiles - (LPBYTE)pdf) < cbAlloc);
        }
        ASSERT((LPSTR)pdf + cbAlloc - 1 == pszFiles);
        ASSERT(*pszFiles == 0); // zero init alloc

        return NOERROR;

    }
    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\hist\cachesrch.cpp ===
/**********************************************************************
  Cache Search Stuff (simple strstr)

  Marc Miller (t-marcmi) - 1998
 **********************************************************************/
#include "cachesrch.h"

DWORD CacheSearchEngine::CacheStreamWrapper::s_dwPageSize = 0;

BOOL  CacheSearchEngine::CacheStreamWrapper::_ReadNextBlock() {
    if (_fEndOfFile)
        return FALSE;

    if (!s_dwPageSize) {
        SYSTEM_INFO sysInfo;
        GetSystemInfo(&sysInfo);
        s_dwPageSize = sysInfo.dwPageSize;
    }
    BOOL fNewRead = FALSE; // is this our first look at this file?
    if (!_pbBuff) {
        // Allocate a page of memory

        // Note: find out why this returned error code #87
        //_pbBuff  = (LPBYTE)(VirtualAlloc(NULL, s_dwPageSize, MEM_COMMIT, PAGE_READWRITE));
        _pbBuff = (LPBYTE)(LocalAlloc(LPTR, s_dwPageSize));
        if (!_pbBuff) {
            //DWORD dwError = GetLastError();
            return FALSE;
        }
        fNewRead          = TRUE;
        _dwCacheStreamLoc = 0;
    }

    BOOL  fSuccess;
    DWORD dwSizeRead = s_dwPageSize;
    if ((fSuccess = ReadUrlCacheEntryStream(_hCacheStream, _dwCacheStreamLoc,
                                            _pbBuff, &dwSizeRead, 0)) && dwSizeRead)
    {
        _fEndOfFile        = (dwSizeRead < s_dwPageSize);
        
        _dwCacheStreamLoc += dwSizeRead;
        _dwBuffSize        = dwSizeRead;
        _pbBuffPos         = _pbBuff;
        _pbBuffLast        = _pbBuff + dwSizeRead;

        _dataType = ASCII_DATA; // default
        if (fNewRead) {
            // deterine data type
            if (_dwBuffSize >= sizeof(USHORT)) {
                if      (*((USHORT *)_pbBuff) == UNICODE_SIGNATURE)
                    _dataType = UNICODE_DATA;
                else if (*((USHORT *)_pbBuff) == UNICODE_SIGNATURE_BACKWARDS)
                    _dataType = UNICODE_BACKWARDS_DATA;
                
                if (s_IsUnicode(_dataType))
                    _pbBuffPos += s_Charsize(_dataType);
            }
        }
    }
    else {
        fSuccess = FALSE;
        DWORD dwError = GetLastError();
        ASSERT(dwError != ERROR_INSUFFICIENT_BUFFER);
    }
    return fSuccess;
}

CacheSearchEngine::CacheStreamWrapper::CacheStreamWrapper(HANDLE hCacheStream) {
    // this class can be allocated on the stack:
    _pbBuff       = NULL;
    _pbBuffPos    = NULL;
    _pbBuffLast   = NULL;
    _dwBuffSize   = 0;
    _hCacheStream = hCacheStream;
    _fEndOfFile   = FALSE;

    // Read in preliminary block of data --
    //  Die on next read to handle failure
    _fEndOfFile   = !(_ReadNextBlock());
}

CacheSearchEngine::CacheStreamWrapper::~CacheStreamWrapper() {
    if (_pbBuff) {
        //VirtualFree(_pbBuff);
        LocalFree(_pbBuff);;
        _pbBuff = NULL;
    }
}

// Read next byte from cache stream, reading in next block if necessary
BOOL CacheSearchEngine::CacheStreamWrapper::_GetNextByte(BYTE &b)
{
    //
    // If the initial read fails _pbBuffPos will be NULL.  Don't
    // allow it to be dereffed.
    //
    BOOL fSuccess = _pbBuffPos ? TRUE : FALSE;

    if (_pbBuffPos == _pbBuffLast)
        fSuccess = _ReadNextBlock();

    if (fSuccess)
        b = *(_pbBuffPos++);

    return fSuccess;
}

BOOL CacheSearchEngine::CacheStreamWrapper::GetNextChar(WCHAR &wc) {
    BOOL fSuccess = TRUE;
    if (s_IsUnicode(_dataType)) {
        BYTE b1, b2;
        LPBYTE bs = (LPBYTE)&wc;
        if (_GetNextByte(b1) && _GetNextByte(b2)) {
            switch (_dataType) {
            case UNICODE_DATA:
                bs[0] = b1;
                bs[1] = b2;
                break;
            case UNICODE_BACKWARDS_DATA:
                bs[0] = b2;
                bs[1] = b1;
                break;
            default: ASSERT(0);
            }
        }
        else
            fSuccess = FALSE;
    }
    else 
    {
       
        BYTE szData[2];

        if (_GetNextByte(szData[0]))
        {
            int cch = 1;
            if (IsDBCSLeadByte(szData[0]))
            {
                if (!_GetNextByte(szData[1]))
                {
                    fSuccess = FALSE;
                }
                cch++;
            }

            if (fSuccess)
            {
                fSuccess = (MultiByteToWideChar(CP_ACP, 0, (LPSTR)szData, cch, &wc, 1) > 0);
            }
        }
        else
        {
            fSuccess = FALSE;
        }

    }
    return fSuccess;
}


// Prepare a search target string for searching --
void CacheSearchEngine::StreamSearcher::_PrepareSearchTarget(LPCWSTR pwszSearchTarget)
{
    UINT uStrLen = lstrlenW(pwszSearchTarget);
    _pwszPreparedSearchTarget = ((LPWSTR)LocalAlloc(LPTR, (uStrLen + 1) * sizeof(WCHAR)));

    if (_pwszPreparedSearchTarget) {
        // Strip leading and trailing whitespace and compress adjacent whitespace characters
        //  into literal spaces
        LPWSTR pwszTemp  = _pwszPreparedSearchTarget;
        pwszSearchTarget = s_SkipWhiteSpace(pwszSearchTarget);
        BOOL   fAddWs    = FALSE;
        while(*pwszSearchTarget) {
            if (s_IsWhiteSpace(*pwszSearchTarget)) {
                fAddWs = TRUE;
                pwszSearchTarget = s_SkipWhiteSpace(pwszSearchTarget);
            }
            else {
                if (fAddWs) {
                    *(pwszTemp++) = L' ';
                    fAddWs = FALSE;
                }
                *(pwszTemp++) = *(pwszSearchTarget++);
            }
        }
        *pwszTemp = L'\0';
    }
}

// Search a character stream for a searchtarget
//  Does a simple strstr, but tries to be smart about whitespace and
//  ignores HTML where possible...
BOOL CacheSearchEngine::StreamSearcher::SearchCharStream(CacheSearchEngine::IWideSequentialReadStream &wsrs,
                                                         BOOL fIsHTML/* = FALSE*/)
{
    BOOL fFound = FALSE;
    
    if (_pwszPreparedSearchTarget && *_pwszPreparedSearchTarget)
    {
        WCHAR   wc;
        LPCWSTR pwszCurrent    = _pwszPreparedSearchTarget;
        BOOL    fMatchedWS     = FALSE;
#if 0
        BOOL    fIgnoreHTMLTag = FALSE;
#endif
        
        while(*pwszCurrent && wsrs.GetNextChar(wc)) {
#if 0
            if (fIsHTML && (wc == L'<'))
                fIgnoreHTMLTag = TRUE;
            else if (fIgnoreHTMLTag) {
                if (wc == L'>')
                    fIgnoreHTMLTag = FALSE;
            }
            else 
#endif

            if (s_IsWhiteSpace(wc)) {
                // matched whitespace in search stream, look for
                //  matching whitespace in target string
                if (!fMatchedWS) {
                    if (s_IsWhiteSpace(*pwszCurrent)) {
                        fMatchedWS = TRUE;
                        ++pwszCurrent;
                    }
                    else
                        pwszCurrent = _pwszPreparedSearchTarget;
                }
            }
            else {
                fMatchedWS = FALSE;
                if (!ChrCmpIW(*pwszCurrent, wc)) {
                    ++pwszCurrent;
                }
                else {
                    pwszCurrent = _pwszPreparedSearchTarget;
                }
            }
        }
        fFound = !*pwszCurrent;
    }
    return fFound;
}

BOOL CacheSearchEngine::SearchCacheStream(CacheSearchEngine::StreamSearcher &cse, HANDLE hCacheStream,
                                          BOOL fIsHTML/* = FALSE*/)
{
    CacheStreamWrapper csw(hCacheStream);
    return cse.SearchCharStream(csw, fIsHTML);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\hist\cafolder.cpp ===
#include "local.h"

#include "resource.h"
#include "cachesrch.h"
#include "sfview.h"
#include <shlwapi.h>
#include <limits.h>
#include "chcommon.h"
#include "cafolder.h"

#include <mluisupp.h>

#define DM_HSFOLDER 0

// these are common flags to ShChangeNotify
#ifndef UNIX
#define CHANGE_FLAGS (0)
#else
#define CHANGE_FLAGS SHCNF_FLUSH
#endif

static void _GetFileTypeInternal(LPCEIPIDL pidl, LPUTSTR pszStr, UINT cchStr);

//
// Column definition for the Cache Folder DefView
//
enum {
    ICOLC_URL_SHORTNAME = 0,
    ICOLC_URL_NAME,
    ICOLC_URL_TYPE,
    ICOLC_URL_SIZE,
    ICOLC_URL_EXPIRES,
    ICOLC_URL_MODIFIED,
    ICOLC_URL_ACCESSED,
    ICOLC_URL_LASTSYNCED,
    ICOLC_URL_MAX         // Make sure this is the last enum item
};


typedef struct _COLSPEC
{
    short int iCol;
    short int ids;        // Id of string for title
    short int cchCol;     // Number of characters wide to make column
    short int iFmt;       // The format of the column;
} COLSPEC;

const COLSPEC s_CacheFolder_cols[] = {
    {ICOLC_URL_SHORTNAME,  IDS_SHORTNAME_COL,  18, LVCFMT_LEFT},
    {ICOLC_URL_NAME,       IDS_NAME_COL,       30, LVCFMT_LEFT},
    {ICOLC_URL_TYPE,       IDS_TYPE_COL,       15, LVCFMT_LEFT},
    {ICOLC_URL_SIZE,       IDS_SIZE_COL,        8, LVCFMT_RIGHT},
    {ICOLC_URL_EXPIRES,    IDS_EXPIRES_COL,    18, LVCFMT_LEFT},
    {ICOLC_URL_MODIFIED,   IDS_MODIFIED_COL,   18, LVCFMT_LEFT},
    {ICOLC_URL_ACCESSED,   IDS_ACCESSED_COL,   18, LVCFMT_LEFT},
    {ICOLC_URL_LASTSYNCED, IDS_LASTSYNCED_COL, 18, LVCFMT_LEFT}
};

//////////////////////////////////////////////////////////////////////

LPCEIPIDL _CreateBuffCacheFolderPidl(DWORD dwSize, LPINTERNET_CACHE_ENTRY_INFO pcei)
{

    DWORD dwTotalSize = 0;
    dwTotalSize = sizeof(CEIPIDL) + dwSize - sizeof(INTERNET_CACHE_ENTRY_INFO);

#if defined(UNIX)
    dwTotalSize = ALIGN4(dwTotalSize);
#endif

    LPCEIPIDL pceip = (LPCEIPIDL)OleAlloc(dwTotalSize);
    if (pceip)
    {
        memset(pceip, 0, dwTotalSize);
        pceip->cb = (USHORT)(dwTotalSize - sizeof(USHORT));
        pceip->usSign = CEIPIDL_SIGN;
        _CopyCEI(&pceip->cei, pcei, dwSize);
    }
    return pceip;
}

HRESULT CacheFolderView_MergeMenu(UINT idMenu, LPQCMINFO pqcm)
{
    HMENU hmenu = LoadMenu(MLGetHinst(), MAKEINTRESOURCE(idMenu));
    if (hmenu)
    {
        MergeMenuHierarchy(pqcm->hmenu, hmenu, pqcm->idCmdFirst, pqcm->idCmdLast);
        DestroyMenu(hmenu);
    }
    return S_OK;
}

HRESULT CacheFolderView_DidDragDrop(IDataObject *pdo, DWORD dwEffect)
{
    if (dwEffect & DROPEFFECT_MOVE)
    {
        CCacheItem *pCItem;
        BOOL fBulkDelete;

        if (SUCCEEDED(pdo->QueryInterface(IID_ICache, (void **)&pCItem)))
        {
            fBulkDelete = pCItem->_cItems > LOTS_OF_FILES;
            for (UINT i = 0; i < pCItem->_cItems; i++)
            {
                if (DeleteUrlCacheEntry(CPidlToSourceUrl((LPCEIPIDL)pCItem->_ppidl[i])))
                {
                    if (!fBulkDelete)
                    {
                        _GenerateEvent(SHCNE_DELETE, pCItem->_pCFolder->_pidl, pCItem->_ppidl[i], NULL);
                    }
                }
            }
            if (fBulkDelete)
            {
                _GenerateEvent(SHCNE_UPDATEDIR, pCItem->_pCFolder->_pidl, NULL, NULL);
            }
            SHChangeNotifyHandleEvents();
            pCItem->Release();
            return S_OK;
        }
    }
    return E_FAIL;
}

// There are copies of exactly this function in SHELL32
// Add the File Type page
HRESULT CacheFolderView_OnAddPropertyPages(DWORD pv, SFVM_PROPPAGE_DATA * ppagedata)
{
    IShellPropSheetExt * pspse;
    HRESULT hr = CoCreateInstance(CLSID_FileTypes, NULL, CLSCTX_INPROC_SERVER,
                              IID_PPV_ARG(IShellPropSheetExt, &pspse));
    if (SUCCEEDED(hr))
    {
        hr = pspse->AddPages(ppagedata->pfn, ppagedata->lParam);
        pspse->Release();
    }
    return hr;
}

HRESULT CacheFolderView_OnGetSortDefaults(int * piDirection, int * plParamSort)
{
    *plParamSort = (int)ICOLC_URL_ACCESSED;
    if (piDirection)
        *piDirection = 1;
    return S_OK;
}

HRESULT CALLBACK CCacheFolder::_sViewCallback(IShellView *psv, IShellFolder *psf,
     HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CCacheFolder *pfolder = NULL;

    HRESULT hr = S_OK;

    switch (uMsg)
    {
    case DVM_GETHELPTEXT:
    {
        TCHAR szText[MAX_PATH];

        UINT id = LOWORD(wParam);
        UINT cchBuf = HIWORD(wParam);
        LPTSTR pszBuf = (LPTSTR)lParam;

        MLLoadString(id + IDS_MH_FIRST, szText, ARRAYSIZE(szText));

        // we know for a fact that this parameter is really a TCHAR
        if ( IsOS( OS_NT ))
        {
            SHTCharToUnicode( szText, (LPWSTR) pszBuf, cchBuf );
        }
        else
        {
            SHTCharToAnsi( szText, (LPSTR) pszBuf, cchBuf );
        }
        break;
    }

    case SFVM_GETNOTIFY:
        hr = psf->QueryInterface(CLSID_CacheFolder, (void **)&pfolder);
        if (SUCCEEDED(hr))
        {
            *(LPCITEMIDLIST*)wParam = pfolder->_pidl;   // evil alias
            pfolder->Release();
        }
        else
            wParam = 0;
        *(LONG*)lParam = SHCNE_DELETE | SHCNE_UPDATEDIR;
        break;

    case DVM_DIDDRAGDROP:
        hr = CacheFolderView_DidDragDrop((IDataObject *)lParam, (DWORD)wParam);
        break;

    case DVM_INITMENUPOPUP:
        hr = S_OK;
        break;

    case DVM_INVOKECOMMAND:
        _ArrangeFolder(hwnd, (UINT)wParam);
        break;

    case DVM_COLUMNCLICK:
        ShellFolderView_ReArrange(hwnd, (UINT)wParam);
        hr = S_OK;
        break;

    case DVM_MERGEMENU:
        hr = CacheFolderView_MergeMenu(MENU_CACHE, (LPQCMINFO)lParam);
        break;

    case DVM_DEFVIEWMODE:
        *(FOLDERVIEWMODE *)lParam = FVM_DETAILS;
        break;

    case SFVM_ADDPROPERTYPAGES:
        hr = CacheFolderView_OnAddPropertyPages((DWORD)wParam, (SFVM_PROPPAGE_DATA *)lParam);
        break;

    case SFVM_GETSORTDEFAULTS:
        hr = CacheFolderView_OnGetSortDefaults((int *)wParam, (int *)lParam);
        break;

    case SFVM_UPDATESTATUSBAR:
        ResizeStatusBar(hwnd, FALSE);
        // We did not set any text; let defview do it
        hr = E_NOTIMPL;
        break;

    case SFVM_SIZE:
        ResizeStatusBar(hwnd, FALSE);
        break;

    case SFVM_GETPANE:
        if (wParam == PANE_ZONE)
            *(DWORD*)lParam = 1;
        else
            *(DWORD*)lParam = PANE_NONE;

        break;
    case SFVM_WINDOWCREATED:
        ResizeStatusBar(hwnd, TRUE);
        break;

    case SFVM_GETZONE:
        *(DWORD*)lParam = URLZONE_INTERNET; // Internet by default
        break;

    default:
        hr = E_FAIL;
    }

    return hr;
}

HRESULT CacheFolderView_CreateInstance(CCacheFolder *pHCFolder, void **ppv)
{
    CSFV csfv;

    csfv.cbSize = sizeof(csfv);
    csfv.pshf = (IShellFolder *)pHCFolder;
    csfv.psvOuter = NULL;
    csfv.pidl = pHCFolder->_pidl;
    csfv.lEvents = SHCNE_DELETE; // SHCNE_DISKEVENTS | SHCNE_ASSOCCHANGED | SHCNE_GLOBALEVENTS;
    csfv.pfnCallback = CCacheFolder::_sViewCallback;
    csfv.fvm = (FOLDERVIEWMODE)0;         // Have defview restore the folder view mode

    return SHCreateShellFolderViewEx(&csfv, (IShellView**)ppv);
}

CCacheFolderEnum::CCacheFolderEnum(DWORD grfFlags, CCacheFolder *pHCFolder) : _cRef(1)
{
    DllAddRef();

    _grfFlags = grfFlags,
    _pCFolder = pHCFolder;
    pHCFolder->AddRef();
    ASSERT(_hEnum == NULL);
}

CCacheFolderEnum::~CCacheFolderEnum()
{
    ASSERT(_cRef == 0);         // we should always have a zero ref count here
    TraceMsg(DM_HSFOLDER, "hcfe - ~CCacheFolderEnum() called.");
    _pCFolder->Release();
    if (_pceiWorking)
    {
        LocalFree(_pceiWorking);
        _pceiWorking = NULL;
    }

    if (_hEnum)
    {
        FindCloseUrlCache(_hEnum);
        _hEnum = NULL;
    }
    DllRelease();
}


HRESULT CCacheFolderEnum_CreateInstance(DWORD grfFlags, CCacheFolder *pHCFolder, IEnumIDList **ppeidl)
{
    TraceMsg(DM_HSFOLDER, "hcfe - CreateInstance() called.");

    *ppeidl = NULL;                 // null the out param

    CCacheFolderEnum *pHCFE = new CCacheFolderEnum(grfFlags, pHCFolder);
    if (!pHCFE)
        return E_OUTOFMEMORY;

    *ppeidl = pHCFE;

    return S_OK;
}

HRESULT CCacheFolderEnum::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CCacheFolderEnum, IEnumIDList),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CCacheFolderEnum::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}

ULONG CCacheFolderEnum::Release(void)
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

//
// IEnumIDList Methods
//
HRESULT CCacheFolderEnum::Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched)
{
    HRESULT hr             = S_FALSE;
    DWORD   dwBuffSize;
    DWORD   dwError;
    LPTSTR  pszSearchPattern = NULL;

    TraceMsg(DM_HSFOLDER, "hcfe - Next() called.");

    if (0 == (SHCONTF_NONFOLDERS & _grfFlags))
    {
        dwError = 0xFFFFFFFF;
        goto exitPoint;
    }

    if (_pceiWorking == NULL)
    {
        _pceiWorking = (LPINTERNET_CACHE_ENTRY_INFO)LocalAlloc(LPTR, MAX_URLCACHE_ENTRY);
        if (_pceiWorking == NULL)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exitPoint;
        }
    }

    // Set up things to enumerate history items, if appropriate, otherwise,
    // we'll just pass in NULL and enumerate all items as before.

TryAgain:

    dwBuffSize = MAX_URLCACHE_ENTRY;
    dwError = S_OK;

    if (!_hEnum) // _hEnum maintains our state as we iterate over all the cache entries
    {
       _hEnum = FindFirstUrlCacheEntry(pszSearchPattern, _pceiWorking, &dwBuffSize);
       if (!_hEnum)
           dwError = GetLastError();
    }

    else if (!FindNextUrlCacheEntry(_hEnum, _pceiWorking, &dwBuffSize))
    {
        dwError = GetLastError();
    }

    if (S_OK == dwError)
    {
        LPCEIPIDL pcei = NULL;

        if ((_pceiWorking->CacheEntryType & URLHISTORY_CACHE_ENTRY) == URLHISTORY_CACHE_ENTRY)
            goto TryAgain;
        pcei = _CreateBuffCacheFolderPidl(dwBuffSize, _pceiWorking);
        if (pcei)
        {
            _GetFileTypeInternal(pcei, pcei->szTypeName, ARRAYSIZE(pcei->szTypeName));
            rgelt[0] = (LPITEMIDLIST)pcei;
           if (pceltFetched)
               *pceltFetched = 1;
        }
        else
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

exitPoint:

    if (dwError != S_OK)
    {
        if (_hEnum)
        {
            FindCloseUrlCache(_hEnum);
            _hEnum = NULL;
        }
        if (pceltFetched)
            *pceltFetched = 0;
        rgelt[0] = NULL;
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }
    return hr;
}

HRESULT CCacheFolderEnum::Skip(ULONG celt)
{
    TraceMsg(DM_HSFOLDER, "hcfe - Skip() called.");
    return E_NOTIMPL;
}

HRESULT CCacheFolderEnum::Reset()
{
    TraceMsg(DM_HSFOLDER, "hcfe - Reset() called.");
    return E_NOTIMPL;
}

HRESULT CCacheFolderEnum::Clone(IEnumIDList **ppenum)
{
    TraceMsg(DM_HSFOLDER, "hcfe - Clone() called.");
    return E_NOTIMPL;
}


//////////////////////////////////////////////////////////////////////////////
//
// CCacheFolder Object
//
//////////////////////////////////////////////////////////////////////////////

CCacheFolder::CCacheFolder() : _cRef(1)
{
    ASSERT(_pidl == NULL);
    DllAddRef();
}

CCacheFolder::~CCacheFolder()
{
    ASSERT(_cRef == 0);                 // should always have zero
    TraceMsg(DM_HSFOLDER, "hcf - ~CCacheFolder() called.");
    if (_pidl)
        ILFree(_pidl);
    if (_pshfSys)
        _pshfSys->Release();
    DllRelease();
}

HRESULT CCacheFolder::QueryInterface(REFIID iid, void **ppv)
{
    static const QITAB qitCache[] = {
        QITABENT(CCacheFolder, IShellFolder2),
        QITABENTMULTI(CCacheFolder, IShellFolder, IShellFolder2),
        QITABENT(CCacheFolder, IShellIcon),
        QITABENT(CCacheFolder, IPersistFolder2),
        QITABENTMULTI(CCacheFolder, IPersistFolder, IPersistFolder2),
        QITABENTMULTI(CCacheFolder, IPersist, IPersistFolder2),
        { 0 },
    };

    if (iid == CLSID_CacheFolder)
    {
        *ppv = (void *)(CCacheFolder *)this;    // unrefed
        AddRef();
        return S_OK;
    }

    HRESULT hr = QISearch(this, qitCache, iid, ppv);

    if (FAILED(hr) && !IsOS(OS_WHISTLERORGREATER))
    {
        if (iid == IID_IShellView)
        {
            // this is a total hack... return our view object from this folder
            //
            // the desktop.ini file for "Temporary Internet Files" has UICLSID={guid of this object}
            // this lets us implment only ths IShellView for this folder, leaving the IShellFolder
            // to the default file system. this enables operations on the pidls that are stored in
            // this folder that would otherwise faile since our IShellFolder is not as complete
            // as the default (this is the same thing the font folder does).
            //
            // to support this with defview we would either have to do a complete wrapper object
            // for the view implemenation, or add this hack that hands out the view object, this
            // assumes we know the order of calls that the shell makes to create this object
            // and get the IShellView implementation
            //
            hr = CacheFolderView_CreateInstance(this, ppv);
        }
    }

    return hr;
}

STDMETHODIMP CCacheFolder::_GetDetail(LPCITEMIDLIST pidl, UINT iColumn, LPTSTR pszStr, UINT cchStr)
{
    switch (iColumn) {
    case ICOLC_URL_SHORTNAME:
        _GetCacheItemTitle((LPCEIPIDL)pidl, pszStr, cchStr);
        break;

    case ICOLC_URL_NAME:
        StrCpyN(pszStr, CPidlToSourceUrl((LPCEIPIDL)pidl), cchStr);
        break;

    case ICOLC_URL_TYPE:
        ualstrcpyn(pszStr, ((LPCEIPIDL)pidl)->szTypeName, cchStr);
        break;

    case ICOLC_URL_SIZE:
        StrFormatKBSize(((LPCEIPIDL)pidl)->cei.dwSizeLow, pszStr, cchStr);
        break;

    case ICOLC_URL_EXPIRES:
        FileTimeToDateTimeStringInternal(&((LPCEIPIDL)pidl)->cei.ExpireTime, pszStr, cchStr, FALSE);
        break;

    case ICOLC_URL_ACCESSED:
        FileTimeToDateTimeStringInternal(&((LPCEIPIDL)pidl)->cei.LastAccessTime, pszStr, cchStr, FALSE);
        break;

    case ICOLC_URL_MODIFIED:
        FileTimeToDateTimeStringInternal(&((LPCEIPIDL)pidl)->cei.LastModifiedTime, pszStr, cchStr, FALSE);
        break;

    case ICOLC_URL_LASTSYNCED:
        FileTimeToDateTimeStringInternal(&((LPCEIPIDL)pidl)->cei.LastSyncTime, pszStr, cchStr, FALSE);
        break;
    }
    return S_OK;
}

HRESULT CCacheFolder::GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pdi)
{
    HRESULT hr = E_FAIL;

    if (pidl == NULL)
    {
        if (iColumn < ICOLC_URL_MAX)
        {
            TCHAR szTemp[128];

            MLLoadString(s_CacheFolder_cols[iColumn].ids, szTemp, ARRAYSIZE(szTemp));
            pdi->fmt = s_CacheFolder_cols[iColumn].iFmt;
            pdi->cxChar = s_CacheFolder_cols[iColumn].cchCol;
            hr = StringToStrRet(szTemp, &pdi->str);
        }
        else
        {
            // enum done
            hr = E_FAIL;
        }
    }
    else if (!IS_VALID_CEIPIDL(pidl))
    {
        if (_pshfSys)
        {
            // delegate to the filesystem
            hr = _pshfSys->GetDetailsOf(pidl, iColumn, pdi);
        }
    }
    else
    {
        TCHAR szTemp[MAX_URL_STRING];

        hr = _GetDetail(pidl, iColumn, szTemp, ARRAYSIZE(szTemp));
        if (SUCCEEDED(hr))
        {
            hr = StringToStrRet(szTemp, &pdi->str);
        }
    }
    return hr;
}

HRESULT CCacheFolder::_GetFileSysFolder(IShellFolder2 **ppsf)
{
    *ppsf = NULL;
    IPersistFolder *ppf;
    HRESULT hr = CoCreateInstance(CLSID_ShellFSFolder, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IPersistFolder, &ppf));
    if (SUCCEEDED(hr))
    {
        hr = ppf->Initialize(this->_pidl);
        if (SUCCEEDED(hr))
        {
            hr = ppf->QueryInterface(IID_PPV_ARG(IShellFolder2, ppsf));
        }
        ppf->Release();
    }
    return hr;
}

// IShellFolder
HRESULT CCacheFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;

    if (!IS_VALID_CEIPIDL(pidl))
    {
        if (_pshfSys)
        {
            hr = _pshfSys->BindToObject(pidl, pbc, riid, ppv);
        }
    }
    else
    {
        hr = E_NOTIMPL;
        *ppv = NULL;
    }
    return hr;
}

HRESULT CCacheFolder::ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pszDisplayName, 
                                       ULONG *pchEaten, LPITEMIDLIST *ppidl, ULONG *pdwAttributes)
{
    HRESULT hr = E_FAIL;
    if (_pshfSys)
    {
        hr = _pshfSys->ParseDisplayName(hwnd, pbc, pszDisplayName, pchEaten, ppidl, pdwAttributes);
    }
    else
        *ppidl = NULL;
    return hr;
}

// IPersist
HRESULT CCacheFolder::GetClassID(CLSID *pclsid)
{
    *pclsid = CLSID_CacheFolder;
    return S_OK;
}

STDAPI CacheFolder_CreateInstance(IUnknown* punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    *ppunk = NULL;                     // null the out param

    if (punkOuter)
        return CLASS_E_NOAGGREGATION;

    CCacheFolder *pcache = new CCacheFolder();
    if (pcache)
    {
        *ppunk = SAFECAST(pcache, IShellFolder2*);
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

ULONG CCacheFolder::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CCacheFolder::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

// IShellFolder

HRESULT CCacheFolder::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList)
{
    return CCacheFolderEnum_CreateInstance(grfFlags, this, ppenumIDList);
}

HRESULT CCacheFolder::BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    return BindToObject(pidl, pbc, riid, ppv);
}

// unalligned verison

#if defined(UNIX) || !defined(_X86_)

// defined in hsfolder.cpp
extern UINT ULCompareFileTime(UNALIGNED const FILETIME *pft1, UNALIGNED const FILETIME *pft2);

#else

#define ULCompareFileTime(pft1, pft2) CompareFileTime(pft1, pft2)

#endif


HRESULT CCacheFolder::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    BOOL fRealigned1;
    HRESULT hr = AlignPidl(&pidl1, &fRealigned1);
    if (SUCCEEDED(hr))
    {
        BOOL fRealigned2;
        hr = AlignPidl(&pidl2, &fRealigned2);

        if (SUCCEEDED(hr))
        {
            hr = _CompareAlignedIDs(lParam, (LPCEIPIDL)pidl1, (LPCEIPIDL)pidl2);

            if (fRealigned2)
                FreeRealignedPidl(pidl2);
        }

        if (fRealigned1)
            FreeRealignedPidl(pidl1);
    }

    return hr;
}

int _CompareSize(LPCEIPIDL pcei1, LPCEIPIDL pcei2)
{
    // check only the low for now
    if (pcei1->cei.dwSizeLow == pcei2->cei.dwSizeLow) 
    {
        return 0;
    } 
    else  if (pcei1->cei.dwSizeLow > pcei2->cei.dwSizeLow) 
    {
        return 1;
    }   
    return -1;
}

HRESULT CCacheFolder::_CompareAlignedIDs(LPARAM lParam, LPCEIPIDL pidl1, LPCEIPIDL pidl2)
{
    int iRet = 0;

    if (NULL == pidl1 || NULL == pidl2)
        return E_INVALIDARG;

    //  At this point, both pidls have resolved to leaf (history or cache)

    if (!IS_VALID_CEIPIDL(pidl1) || !IS_VALID_CEIPIDL(pidl2))
        return E_FAIL;

    switch (lParam & SHCIDS_COLUMNMASK) {
    case ICOLC_URL_SHORTNAME:
        iRet = StrCmpI(_FindURLFileName(CPidlToSourceUrl(pidl1)),
                        _FindURLFileName(CPidlToSourceUrl(pidl2)));
        break;

    case ICOLC_URL_NAME:
        iRet = _CompareCFolderPidl(pidl1, pidl2);
        break;

    case ICOLC_URL_TYPE:
        iRet = ualstrcmp(pidl1->szTypeName, pidl2->szTypeName);
        break;

    case ICOLC_URL_SIZE:
        iRet = _CompareSize(pidl1, pidl2);
        break;

    case ICOLC_URL_MODIFIED:
        iRet = ULCompareFileTime(&pidl1->cei.LastModifiedTime,
                               &pidl2->cei.LastModifiedTime);
        break;

    case ICOLC_URL_ACCESSED:
        iRet = ULCompareFileTime(&pidl1->cei.LastAccessTime,
                               &pidl2->cei.LastAccessTime);
        break;

    case ICOLC_URL_EXPIRES:
        iRet = ULCompareFileTime(&pidl1->cei.ExpireTime,
                               &pidl2->cei.ExpireTime);
        break;

    case ICOLC_URL_LASTSYNCED:
        iRet = ULCompareFileTime(&pidl1->cei.LastSyncTime,
                               &pidl2->cei.LastSyncTime);
        break;

    default:
        iRet = -1;
    }
    return ResultFromShort((SHORT)iRet);
}


HRESULT CCacheFolder::CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
{
    HRESULT hr = E_NOINTERFACE;

    *ppv = NULL;

    if (riid == IID_IShellView)
    {
        hr = CacheFolderView_CreateInstance(this, ppv);
    }
    else if (riid == IID_IContextMenu)
    {
        // this creates the "Arrange Icons" cascased menu in the background of folder view
        CFolderArrangeMenu *p = new CFolderArrangeMenu(MENU_CACHE);
        if (p)
        {
            hr = p->QueryInterface(riid, ppv);
            p->Release();
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else if (riid == IID_IShellDetails)
    {
        CDetailsOfFolder *p = new CDetailsOfFolder(hwnd, this);
        if (p)
        {
            hr = p->QueryInterface(riid, ppv);
            p->Release();
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}

// Right now, we will allow TIF Drag in Browser Only, even though
// it will not be Zone Checked at the Drop.
//#define BROWSERONLY_NOTIFDRAG

HRESULT CCacheFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl,
                        ULONG * prgfInOut)
{
    ULONG rgfInOut;
    HRESULT hr = E_UNEXPECTED;

    // Make sure each pidl in the array is dword aligned.
    if (apidl && IS_VALID_CEIPIDL(apidl[0]))
    {
        BOOL fRealigned;
        hr = AlignPidlArray(apidl, cidl, &apidl, &fRealigned);

        if (SUCCEEDED(hr))
        {
            rgfInOut = SFGAO_FILESYSTEM | SFGAO_CANDELETE | SFGAO_HASPROPSHEET;

#ifdef BROWSERONLY_NOTIFDRAG
            if (PLATFORM_INTEGRATED == WhichPlatform())
#endif // BROWSERONLY_NOTIFDRAG
            {
                SetFlag(rgfInOut, SFGAO_CANCOPY);
            }

            // all items can be deleted
            if (SUCCEEDED(hr))
                rgfInOut |= SFGAO_CANDELETE;
            *prgfInOut = rgfInOut;

            if (fRealigned)
                FreeRealignedPidlArray(apidl, cidl);
        }
    }
    else if (_pshfSys)
    {
        hr = _pshfSys->GetAttributesOf(cidl, apidl, prgfInOut);
    }

    if (FAILED(hr))
        *prgfInOut = 0;

    return hr;
}

HRESULT CCacheFolder::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl,
                        REFIID riid, UINT * prgfInOut, void **ppv)
{
    HRESULT hr = E_NOINTERFACE;
    *ppv = NULL;         // null the out param

    // Make sure all pidls in the array are dword aligned.

    if (apidl && IS_VALID_CEIPIDL(apidl[0]))
    {
        BOOL fRealigned;
        hr = AlignPidlArray(apidl, cidl, &apidl, &fRealigned);

        if (SUCCEEDED(hr))
        {
            if ((riid == IID_IShellLinkA)   ||
                (riid == IID_IShellLinkW)   ||
                (riid == IID_IExtractIconA) ||
                (riid == IID_IExtractIconW) ||
                (riid == IID_IQueryInfo))
            {
                LPCTSTR pszURL = CPidlToSourceUrl((LPCEIPIDL)apidl[0]);

                hr = _GetShortcut(pszURL, riid, ppv);
            }
            else if ((riid == IID_IContextMenu)     ||
                     (riid == IID_IDataObject)      ||
                     (riid == IID_IExtractIconA)    ||
                     (riid == IID_IExtractIconW))
            {
                hr = CCacheItem_CreateInstance(this, hwnd, cidl, apidl, riid, ppv);
            }
            else
            {
                hr = E_FAIL;
            }

            if (fRealigned)
                FreeRealignedPidlArray(apidl, cidl);
        }
    }
    else if (_pshfSys)
    {
        // delegate to the filesystem
        hr = _pshfSys->GetUIObjectOf(hwnd, cidl, apidl, riid, prgfInOut, ppv);
    }

    return hr;
}

HRESULT CCacheFolder::GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay)
{
    if (pSort)
    {
        *pSort = 0;
    }

    if (pDisplay)
    {
        *pDisplay = 0;
    }
    return S_OK;
}

HRESULT CCacheFolder::_GetInfoTip(LPCITEMIDLIST pidl, DWORD dwFlags, WCHAR **ppwszTip)
{
    *ppwszTip = NULL;
    return E_FAIL;
}

HRESULT CCacheFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, STRRET *pstr)
{
    BOOL fRealigned;
    HRESULT hr = E_FAIL;

    if (!IS_VALID_CEIPIDL(pidl))
    {
        if (_pshfSys)
        {
            // delegate to the filesystem
            hr = _pshfSys->GetDisplayNameOf(pidl, uFlags, pstr);
        }
    }
    else if (SUCCEEDED(AlignPidl(&pidl, &fRealigned)))
    {
        hr = GetDisplayNameOfCEI(pidl, uFlags, pstr);
    
        if (fRealigned)
            FreeRealignedPidl(pidl);
    }
    return hr;
}

HRESULT CCacheFolder::GetDisplayNameOfCEI(LPCITEMIDLIST pidl, DWORD uFlags, STRRET *pstr)
{
    TCHAR szTemp[MAX_URL_STRING];
    szTemp[0] = 0;

    LPCTSTR pszTitle = _FindURLFileName(CEI_SOURCEURLNAME((LPCEIPIDL)pidl));

    // _GetURLTitle could return the real title or just an URL.
    // We use _URLTitleIsURL to make sure we don't unescape any titles.

    if (pszTitle && *pszTitle)
    {
        StrCpyN(szTemp, pszTitle, ARRAYSIZE(szTemp));
    }
    else
    {
        LPCTSTR pszUrl = _StripHistoryUrlToUrl(CPidlToSourceUrl((LPCEIPIDL)pidl));
        if (pszUrl) 
            StrCpyN(szTemp, pszUrl, ARRAYSIZE(szTemp));
    }
    
    if (!(uFlags & SHGDN_FORPARSING))
    {
        DWORD cchBuf = ARRAYSIZE(szTemp);
        PrepareURLForDisplayUTF8(szTemp, szTemp, &cchBuf, TRUE);
    
        SHELLSTATE ss;
        SHGetSetSettings(&ss, SSF_SHOWEXTENSIONS, FALSE);
    
        if (!ss.fShowExtensions)
            PathRemoveExtension(szTemp);
    }

    return StringToStrRet(szTemp, pstr);
}

HRESULT CCacheFolder::SetNameOf(HWND hwnd, LPCITEMIDLIST pidl,
                        LPCOLESTR pszName, DWORD uFlags, LPITEMIDLIST *ppidlOut)
{
    if (ppidlOut)
        *ppidlOut = NULL;               // null the out param
    return E_FAIL;
}

//
// IShellIcon Methods...
//
HRESULT CCacheFolder::GetIconOf(LPCITEMIDLIST pidl, UINT flags, LPINT lpIconIndex)
{
    BOOL fRealigned;
    HRESULT hr = E_FAIL;

    if (!IS_VALID_CEIPIDL(pidl))
    {
        if (_pshfSys)
        {
            IShellIcon* pshi;
            hr = _pshfSys->QueryInterface(IID_PPV_ARG(IShellIcon, &pshi));
            if (SUCCEEDED(hr))
            {
                hr = pshi->GetIconOf(pidl, flags, lpIconIndex);
                pshi->Release();
            }
        }
    }
    else if (SUCCEEDED(AlignPidl(&pidl, &fRealigned)))
    {
        SHFILEINFO shfi;
        LPCTSTR pszIconFile = CEI_LOCALFILENAME((LPCEIPIDL)pidl);

        if (SHGetFileInfo(pszIconFile, 0, &shfi, sizeof(shfi),
                          SHGFI_USEFILEATTRIBUTES | SHGFI_SYSICONINDEX | SHGFI_SMALLICON))
        {
            *lpIconIndex = shfi.iIcon;
            hr = S_OK;
        }

        if (fRealigned)
            FreeRealignedPidl(pidl);
    }
    return hr;
}


// IPersist

HRESULT CCacheFolder::Initialize(LPCITEMIDLIST pidlInit)
{
    ILFree(_pidl);
    if (_pshfSys)
    {
        _pshfSys->Release();
        _pshfSys = NULL;
    }

    HRESULT hr;
    if (IsCSIDLFolder(CSIDL_INTERNET_CACHE, pidlInit))
    {
        hr = SHILClone(pidlInit, &_pidl);
        if (SUCCEEDED(hr))
        {
            hr = _GetFileSysFolder(&_pshfSys);

            // On a pre-Win2k shell, CLSID_ShellFSFolder will not be registered.  However, it does not 
            // impact the operation of the cache folder.  So rather than propogate a failure return value to 
            // the shell, we treat that case as success.
            if (FAILED(hr))
            {
                // This is a pre-Win2k shell.  Return S_OK.
                hr = S_OK;
            }
        }
    }
    else
    {
        hr = E_FAIL;
    }
    return hr;
}

//
// IPersistFolder2 Methods...
//
HRESULT CCacheFolder::GetCurFolder(LPITEMIDLIST *ppidl)
{
    if (_pidl)
        return SHILClone(_pidl, ppidl);

    *ppidl = NULL;      
    return S_FALSE; // success but empty
}

void _GetFileTypeInternal(LPCEIPIDL pidl, LPUTSTR pszuStr, UINT cchStr)
{
    SHFILEINFO shInfo;
    LPTSTR pszStr;

    if (TSTR_ALIGNED(pszuStr) == FALSE) 
    {
        //
        // If pszuStr is in fact unaligned, allocate some scratch
        // space on the stack for the output copy of this string.
        //

        pszStr = (LPTSTR)_alloca(cchStr * sizeof(TCHAR));
    }
    else 
    {
        pszStr = (LPTSTR)pszuStr;
    }

    if (SHGetFileInfo(CEI_LOCALFILENAME((LPCEIPIDL)pidl), FILE_ATTRIBUTE_NORMAL,
                      &shInfo, sizeof(shInfo),
                      SHGFI_USEFILEATTRIBUTES | SHGFI_TYPENAME)
        && shInfo.szTypeName[0])
    {
        StrCpyN(pszStr, shInfo.szTypeName, cchStr);
    }
    else 
    {
        LPTSTR psz = PathFindExtension(CEI_LOCALFILENAME((LPCEIPIDL)pidl));
        DWORD dw;
        ASSERT((pszStr && (cchStr>0)));
        *pszStr = 0;
        if (psz && *psz)
        {
            psz++;
            StrCpyN(pszStr, psz, cchStr);
            CharUpper(pszStr);
            StrCatBuff(pszStr, TEXT(" "), cchStr);
        }
        dw = lstrlen(pszStr);
        MLLoadString(IDS_FILE_TYPE, pszStr+dw, cchStr-dw);
    }

    if (TSTR_ALIGNED(pszuStr) == FALSE) 
    {
        // If pszuStr was unaligned then copy the output string from
        // the scratch space on the stack to the supplied output buffer

        ualstrcpyn(pszuStr, pszStr, cchStr);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\hist\cachesrch.h ===
/**********************************************************************
  Cache Search Stuff (simple, fast strstr)

  Marc Miller (t-marcmi) - 1998
 **********************************************************************/

#include "priv.h"

#ifndef __HISTORY_CACHE_SEARCH__
#define __HISTORY_CACHE_SEARCH__

#define UNICODE_SIGNATURE           0xFFFE
#define UNICODE_SIGNATURE_BACKWARDS 0xFEFF

namespace CacheSearchEngine {

    class IWideSequentialReadStream {
    public:
        virtual BOOL GetNextChar(WCHAR &wc) = 0;
    };
    
    class StreamSearcher {
    protected:
        LPWSTR _pwszPreparedSearchTarget;
        static inline    BOOL s_IsWhiteSpace(const WCHAR &wc) {
            return ((wc == L' ') || (wc == L'\t') || (wc == L'\n') || (wc == L'\r'));
        }
        static inline LPCWSTR s_SkipWhiteSpace(LPCWSTR pwszStr) {
            LPCWSTR pwszTemp = pwszStr;
            while(s_IsWhiteSpace(*pwszTemp))
                ++pwszTemp;
            return pwszTemp;
        }
        void _PrepareSearchTarget(LPCWSTR pwszSearchTarget);
    public:
        StreamSearcher(LPCWSTR pwszSearchTarget) { _PrepareSearchTarget(pwszSearchTarget); }
        ~StreamSearcher() { if ( _pwszPreparedSearchTarget ) { LocalFree(_pwszPreparedSearchTarget); _pwszPreparedSearchTarget = NULL; } }
        BOOL SearchCharStream(IWideSequentialReadStream &wsrs, BOOL fIsHTML = FALSE);
    };
    
    class StringStream : public IWideSequentialReadStream {
        BOOL    fCleanup; // the string we hold needs to be deallocated by us
        LPCWSTR pwszStr;
        UINT    uCurrentPos;
    public:
        StringStream(LPCWSTR pwszStr, BOOL fDuplicate = FALSE) : uCurrentPos(0), fCleanup(fDuplicate) {
            if (fDuplicate)
                SHStrDupW(pwszStr, const_cast<LPWSTR *>(&(this->pwszStr)));
            else
                this->pwszStr = pwszStr;
        }
        StringStream(LPCSTR  pszStr, BOOL fDuplicate = FALSE)  : uCurrentPos(0), fCleanup(TRUE) {
            SHStrDupA(pszStr, const_cast<LPWSTR *>(&(pwszStr)));
        }
        ~StringStream() {
            if (fCleanup)
                CoTaskMemFree(const_cast<LPWSTR>(pwszStr));
        }
        BOOL GetNextChar(WCHAR &wc) {
            wc = pwszStr[uCurrentPos];
            if (wc)
                ++uCurrentPos;
            return wc;
        }
    };
    
    class CacheStreamWrapper : public IWideSequentialReadStream {
    protected:
        HANDLE  _hCacheStream;
        DWORD   _dwCacheStreamLoc;  // our offset into the actual cache file
        BOOL    _fEndOfFile;
        
        // I can never remember which one is little endian and which is big endian
        enum DATATYPEENUM { UNICODE_DATA = 0, UNICODE_BACKWARDS_DATA, ASCII_DATA } _dataType;
        static inline BOOL s_IsUnicode(DATATYPEENUM dte) { return dte < ASCII_DATA; }
        static inline UINT s_Charsize (DATATYPEENUM dte) { return s_IsUnicode(dte) ? sizeof(USHORT) : sizeof(CHAR); }
        
        static DWORD s_dwPageSize;
        
        LPBYTE _pbBuff;      /* buffer of bytes which are type-neutral
                                _pbBuff is allocated with VirtualAlloc */
        LPBYTE _pbBuffPos;   // current position in buffer
        LPBYTE _pbBuffLast;  // last byte in buffer
        DWORD  _dwBuffSize;  // current valid buffer size (not allocated size)
        
        BOOL   _ReadNextBlock();
        BOOL   _GetNextByte(BYTE &b);
        
    public:
        CacheStreamWrapper(HANDLE hCacheStream);
        ~CacheStreamWrapper();
        BOOL GetNextChar(WCHAR &wc);
    };

    
    BOOL SearchCacheStream(StreamSearcher &cse, HANDLE hCacheStream, BOOL fIsHTML = FALSE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\hist\chcommon.cpp ===
#include "local.h"
#include "resource.h"
#include <limits.h>
#include <mluisupp.h>
#include "chcommon.h"

#define DM_HSFOLDER 0

STDAPI  AddToFavorites(HWND hwnd, LPCITEMIDLIST pidlCur, LPCTSTR pszTitle,
                       BOOL fDisplayUI, IOleCommandTarget *pCommandTarget, IHTMLDocument2 *pDoc);

/*********************************************************************
                        StrHash implementation
 *********************************************************************/

//////////////////////////////////////////////////////////////////////
// StrHashNode
StrHash::StrHashNode::StrHashNode(LPCTSTR psz, void* pv, int fCopy,
                                  StrHashNode* next) {
    ASSERT(psz);
    pszKey = (fCopy ? StrDup(psz) : psz);
    pvVal  = pv;  // don't know the size -- you'll have to destroy
    this->fCopy = fCopy;
    this->next  = next;
}

StrHash::StrHashNode::~StrHashNode() {
    if (fCopy)
    {
        LocalFree(const_cast<LPTSTR>(pszKey));
        pszKey = NULL;
    }
}

//////////////////////////////////////////////////////////////////////
// StrHash
const unsigned int StrHash::sc_auPrimes[] = {
    29, 53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593
};

const unsigned int StrHash::c_uNumPrimes     = 11;
const unsigned int StrHash::c_uFirstPrime    =  4;

// load factor is computed as (n * USHRT_MAX / t) where 'n' is #elts in table
//   and 't' is table size
const unsigned int StrHash::c_uMaxLoadFactor = ((USHRT_MAX * 100) / 95); // .95

StrHash::StrHash(int fCaseInsensitive) {
    nCurPrime = c_uFirstPrime;
    nBuckets  = sc_auPrimes[nCurPrime];

    // create an array of buckets and null out each one
    ppshnHashChain = new StrHashNode* [nBuckets];

    if (ppshnHashChain) {
        for (unsigned int i = 0; i < nBuckets; ++i)
            ppshnHashChain[i] = NULL;
    }
    nElements = 0;
    _fCaseInsensitive = fCaseInsensitive;
}

StrHash::~StrHash() {
    if (ppshnHashChain) {
        // delete all nodes first, then delete the chain
        for (unsigned int u = 0; u < nBuckets; ++u) {
            StrHashNode* pshnTemp = ppshnHashChain[u];
            while(pshnTemp) {
                StrHashNode* pshnNext = pshnTemp->next;
                delete pshnTemp;
                pshnTemp = pshnNext;
            }
        }
        delete [] ppshnHashChain;
    }
}

#ifdef DEBUG
// Needed so that this stuff doesn't show 
// up as a leak when it is freed from someother thread
void
StrHash::_RemoveHashNodesFromMemList() {
    if (ppshnHashChain) {
        // remove all hasnodes from mem list first, then delete the chain
        for (unsigned int u = 0; u < nBuckets; ++u) {
            StrHashNode* pshnTemp = ppshnHashChain[u];
            while(pshnTemp) {
                StrHashNode* pshnNext = pshnTemp->next;
                pshnTemp = pshnNext;
            }
        }
    }
}

// Needed by the thread to which this object was
// sent to add it on to the mem list to detect leaks

void
StrHash::_AddHashNodesFromMemList() {
    if (ppshnHashChain) {
        // add all nodes into mem list
        for (unsigned int u = 0; u < nBuckets; ++u) {
            StrHashNode* pshnTemp = ppshnHashChain[u];
            while(pshnTemp) {
                StrHashNode* pshnNext = pshnTemp->next;
                pshnTemp = pshnNext;
            }
        }
    }
}

#endif //DEBUG
// returns the void* value if its there and NULL if its not
void* StrHash::insertUnique(LPCTSTR pszKey, int fCopy, void* pvVal) {
    unsigned int uBucketNum = _hashValue(pszKey, nBuckets);
    StrHashNode* pshnNewElt;
    if ((pshnNewElt = _findKey(pszKey, uBucketNum)))
        return pshnNewElt->pvVal;
    if (_prepareForInsert())
        uBucketNum = _hashValue(pszKey, nBuckets);
    pshnNewElt =
        new StrHashNode(pszKey, pvVal, fCopy,
                        ppshnHashChain[uBucketNum]);
    if (pshnNewElt && ppshnHashChain)
        ppshnHashChain[uBucketNum] = pshnNewElt;
    return NULL;
}

void* StrHash::retrieve(LPCTSTR pszKey) {
    if (!pszKey) return 0;
    unsigned int uBucketNum = _hashValue(pszKey, nBuckets);
    StrHashNode* pshn = _findKey(pszKey, uBucketNum);
    return (pshn ? pshn->pvVal : NULL);
}

// dynamically grow the hash table if necessary
//   return TRUE if rehashing was done
int StrHash::_prepareForInsert() {
    ++nElements; // we'te adding an element
    if ((_loadFactor() >= c_uMaxLoadFactor) &&
        (nCurPrime++   <= c_uNumPrimes)) {
        //--- grow the hashTable by rehashing everything:
        // set up new hashTable
        unsigned int nBucketsOld = nBuckets;
        nBuckets = sc_auPrimes[nCurPrime];
        StrHashNode** ppshnHashChainOld = ppshnHashChain;
        ppshnHashChain = new StrHashNode* [nBuckets];
        if (ppshnHashChain && ppshnHashChainOld) {
            unsigned int u;
            for (u = 0; u < nBuckets; ++u)
                ppshnHashChain[u] = NULL;
            // rehash by traversing all buckets
            for (u = 0; u < nBucketsOld; ++u) {
                StrHashNode* pshnTemp = ppshnHashChainOld[u];
                while (pshnTemp) {
                    unsigned int uBucket  = _hashValue(pshnTemp->pszKey, nBuckets);
                    StrHashNode* pshnNext = pshnTemp->next;
                    pshnTemp->next = ppshnHashChain[uBucket];
                    ppshnHashChain[uBucket] = pshnTemp;
                    pshnTemp = pshnNext;
                }
            }
            delete [] ppshnHashChainOld;
        }
        return 1;
    } // if needs rehashing
    return 0;
}

/*
// this variant of Weinberger's hash algorithm was taken from
//  packager.cpp (ie source)
unsigned int _oldhashValuePJW(const char* c_pszStr, unsigned int nBuckets) {
    unsigned long h = 0L;
    while(*c_pszStr)
        h = ((h << 4) + *(c_pszStr++) + (h >> 28));
    return (h % nBuckets);
}
*/

// this variant of Weinberger's hash algorithm is adapted from
//  Aho/Sethi/Ullman (the Dragon Book) p436
// in an empircal test using hostname data, this one resulted in less
// collisions than the function listed above.
// the two constants (24 and 0xf0000000) should be recalculated for 64-bit
//   when applicable
#define DOWNCASE(x) ( (((x) >= TEXT('A')) && ((x) <= TEXT('Z')) ) ? (((x) - TEXT('A')) + TEXT('a')) : (x) )
unsigned int StrHash::_hashValue(LPCTSTR pszStr, unsigned int nBuckets) {
    if (pszStr) {
        unsigned long h = 0L, g;
        TCHAR c;
        while((c = *(pszStr++))) {
            h = (h << 4) + ((_fCaseInsensitive ? DOWNCASE(c) : c));
            if ( (g = h & 0xf0000000) )
                h ^= (g >> 24) ^ g;
        }
        return (h % nBuckets);
    }
    return 0;
}

StrHash::StrHashNode* StrHash::_findKey(LPCTSTR pszStr, unsigned int uBucketNum) {
    StrHashNode* pshnTemp = ppshnHashChain[uBucketNum];
    while(pshnTemp) {
        if (!((_fCaseInsensitive ? StrCmpI : StrCmp)(pszStr, pshnTemp->pszKey)))
            return pshnTemp;
        pshnTemp = pshnTemp->next;
    }
    return NULL;
}

unsigned int  StrHash::_loadFactor() {
    return ( (nElements * USHRT_MAX) / nBuckets );
}

/* a small driver to test the hash function
   by reading values into stdin and reporting
   if they're duplicates -- run it against this
   perl script:

   while(<>) {
        chomp;
        if ($log{$_}++) {
       ++$dups;
    }
   }

   print "$dups duplicates.\n";

void driver_to_test_strhash_module() {
    StrHash strHash;

    char  s[4096];
    int   dups = 0;

    while(cin >> s) {
        if (strHash.insertUnique(s, 1, ((void*)1)))
            ++dups;
        else
            ;//cout << s << endl;
    }
    cout << dups << " duplicates." << endl;
}
*/

/**********************************************************************
                             OrderedList
 **********************************************************************/

// pass in uSize == 0 if you want no size limit
OrderedList::OrderedList(unsigned int uSize) {
    this->uSize = uSize;
    uCount      = 0;
    peltHead    = NULL;
}

OrderedList::~OrderedList() {
    OrderedList::Element *peltTrav = peltHead;
    while (peltTrav) {
        OrderedList::Element *peltTemp = peltTrav;
        peltTrav = peltTrav->next;
        delete peltTemp;
    }
}

#ifdef DEBUG
// Needed to avoid bogus leak detection
void
OrderedList::_RemoveElementsFromMemlist(){
    OrderedList::Element *peltTrav = peltHead;
    while (peltTrav) {
        OrderedList::Element *peltTemp = peltTrav;
        peltTrav = peltTrav->next;
    }
}

void
OrderedList::_AddElementsToMemlist(){
    OrderedList::Element *peltTrav = peltHead;
    while (peltTrav) {
        OrderedList::Element *peltTemp = peltTrav;
        peltTrav = peltTrav->next;
    }
}


#endif //DEBUG
void OrderedList::insert(OrderedList::Element *pelt) {
    // find insertion point
    OrderedList::Element* peltPrev = NULL;
    OrderedList::Element* peltTemp = peltHead;

    if (pelt)
    {
        while(peltTemp && (peltTemp->compareWith(pelt) < 0)) {
            peltPrev = peltTemp;
            peltTemp = peltTemp->next;
        }
        if (peltPrev) {
            peltPrev->next = pelt;
            pelt->next     = peltTemp;
        }
        else {
            pelt->next = peltHead;
            peltHead   = pelt;
        }

        // is list too full?  erase smallest element
        if ((++uCount > uSize) && (uSize)) {
            ASSERT(peltHead);
            peltTemp = peltHead;
            peltHead = peltHead->next;
            delete peltTemp;
            --uCount;
        }
    }
}

// YOU must delete elements that come from this one
OrderedList::Element *OrderedList::removeFirst() {
    OrderedList::Element *peltRet = peltHead;
    if (peltHead) {
        --uCount;
        peltHead = peltHead->next;
    }
    return peltRet;
}


//
// AlignPidl
//
// Check if the pidl is dword aligned.  If not reallign them by reallocating the
// pidl. If the pidls do get reallocated the caller must free them via
// FreeRealignPidl.
//

HRESULT AlignPidl(LPCITEMIDLIST* ppidl, BOOL* pfRealigned)
{
    ASSERT(ppidl);
    ASSERT(pfRealigned);

    HRESULT hr = S_OK;

    *pfRealigned = (BOOL)((ULONG_PTR)*ppidl & 3);

    if (*pfRealigned)
        hr = (*ppidl = ILClone(*ppidl)) ? S_OK : E_OUTOFMEMORY;

    return hr;
}

//
// AlignPidls
//
// AlignPidls realigns pidls for methonds that receive an array of pidls
// (i.e. GetUIObjectOf).  In this case a new array of pidl pointer needs to get
// reallocated since we don't want to stomp on the callers pointer array.
//

HRESULT AlignPidlArray(LPCITEMIDLIST* apidl, int cidl, LPCITEMIDLIST** papidl,
                   BOOL* pfRealigned)
{
    ASSERT((apidl != NULL) || (cidl==0))
    ASSERT(pfRealigned);
    ASSERT(papidl);

    HRESULT hr = S_OK;

    *pfRealigned = FALSE;

    // Check if any pidl needs to be realigned.  If anyone needs realigning
    // realign all of them.

    for (int i = 0; i < cidl && !*pfRealigned; i++)
        *pfRealigned = (BOOL)((ULONG_PTR)apidl[i] & 3);

    if (*pfRealigned)
    {
        // Use a temp pointer in case apidl and papidl are aliased (the most
        // likely case).

        LPCITEMIDLIST* apidlTemp = (LPCITEMIDLIST*)LocalAlloc(LPTR,
                                                  cidl * sizeof(LPCITEMIDLIST));

        if (apidlTemp)
        {
            for (i = 0; i < cidl && SUCCEEDED(hr); i++)
            {
                apidlTemp[i] = ILClone(apidl[i]);

                if (NULL == apidlTemp[i])
                {
                    for (int j = 0; j < i; j++)
                        ILFree((LPITEMIDLIST)apidlTemp[j]);

                    LocalFree(apidlTemp);
                    apidlTemp = NULL;

                    hr = E_OUTOFMEMORY;
                }
            }

            if (SUCCEEDED(hr))
                *papidl = apidlTemp;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

void FreeRealignedPidlArray(LPCITEMIDLIST* apidl, int cidl)
{
    ASSERT(apidl)
    ASSERT(cidl > 0);

    for (int i = 0; i < cidl; i++)
        ILFree((LPITEMIDLIST)apidl[i]);

    LocalFree(apidl);
    apidl = NULL;

    return;
}

UINT MergeMenuHierarchy(HMENU hmenuDst, HMENU hmenuSrc, UINT idcMin, UINT idcMax)
{
    UINT idcMaxUsed = idcMin;
    int imi = GetMenuItemCount(hmenuSrc);
    while (--imi >= 0)
    {
        MENUITEMINFO mii = { sizeof(mii), MIIM_ID | MIIM_SUBMENU, 0, 0, 0, NULL, NULL, NULL, 0, NULL, 0 };

        if (GetMenuItemInfo(hmenuSrc, imi, TRUE, &mii))
        {
            UINT idcT = Shell_MergeMenus(GetMenuFromID(hmenuDst, mii.wID),
                    mii.hSubMenu, 0, idcMin, idcMax, MM_ADDSEPARATOR | MM_SUBMENUSHAVEIDS);
            idcMaxUsed = max(idcMaxUsed, idcT);
        }
    }
    return idcMaxUsed;
}

#undef ZONES_PANE_WIDTH
#define ZONES_PANE_WIDTH    120

void ResizeStatusBar(HWND hwnd, BOOL fInit)
{
    HWND hwndStatus = NULL;
    RECT rc = {0};
    LPSHELLBROWSER psb = FileCabinet_GetIShellBrowser(hwnd);
    UINT cx;
    int ciParts[] = {-1, -1};

    if (!psb)
        return;

    psb->GetControlWindow(FCW_STATUS, &hwndStatus);


    if (fInit)
    {
        int nParts = 0;

        psb->SendControlMsg(FCW_STATUS, SB_GETPARTS, 0, 0L, (LRESULT*)&nParts);
        for (int n = 0; n < nParts; n ++)
        {
            psb->SendControlMsg(FCW_STATUS, SB_SETTEXT, n, (LPARAM)TEXT(""), NULL);
            psb->SendControlMsg(FCW_STATUS, SB_SETICON, n, NULL, NULL);
        }
        psb->SendControlMsg(FCW_STATUS, SB_SETPARTS, 0, 0L, NULL);
    }
    GetClientRect(hwndStatus, &rc);
    cx = rc.right;

    ciParts[0] = cx - ZONES_PANE_WIDTH;

    psb->SendControlMsg(FCW_STATUS, SB_SETPARTS, ARRAYSIZE(ciParts), (LPARAM)ciParts, NULL);
}

HRESULT _ArrangeFolder(HWND hwnd, UINT uID)
{
    switch (uID) 
    {
    case IDM_SORTBYTITLE:
    case IDM_SORTBYADDRESS:
    case IDM_SORTBYVISITED:
    case IDM_SORTBYUPDATED:
        ShellFolderView_ReArrange(hwnd, uID - IDM_SORTBYTITLE);
        break;
        
    case IDM_SORTBYNAME:
    case IDM_SORTBYADDRESS2:
    case IDM_SORTBYSIZE:
    case IDM_SORTBYEXPIRES2:
    case IDM_SORTBYMODIFIED:
    case IDM_SORTBYACCESSED:
    case IDM_SORTBYCHECKED:
        ShellFolderView_ReArrange(hwnd, uID - IDM_SORTBYNAME);
        break;
        
    default:
        return E_FAIL;
    }
    return NOERROR;
}

STDMETHODIMP CDetailsOfFolder::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CDetailsOfFolder, IShellDetails),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CDetailsOfFolder::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CDetailsOfFolder::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CDetailsOfFolder::GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pdi)
{
    return _psf->GetDetailsOf(pidl, iColumn, pdi);
}

HRESULT CDetailsOfFolder::ColumnClick(UINT iColumn)
{
    ShellFolderView_ReArrange(_hwnd, iColumn);
    return NOERROR;
}

STDMETHODIMP CFolderArrangeMenu::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CFolderArrangeMenu, IContextMenu),     // IID_IContextMenu
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CFolderArrangeMenu::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFolderArrangeMenu::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CFolderArrangeMenu::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst,UINT idCmdLast, UINT uFlags)
{
    USHORT cItems = 0;
    
    if (uFlags == CMF_NORMAL)
    {
        HMENU hmenuHist = LoadMenu(MLGetHinst(), MAKEINTRESOURCE(_idMenu));
        if (hmenuHist)
        {
            cItems = MergeMenuHierarchy(hmenu, hmenuHist, idCmdFirst, idCmdLast);
            DestroyMenu(hmenuHist);
        }
    }
    SetMenuDefaultItem(hmenu, indexMenu, MF_BYPOSITION);
    return ResultFromShort(cItems);    // number of menu items
}

STDMETHODIMP CFolderArrangeMenu::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    if (HIWORD(pici->lpVerb) == 0)
        return _ArrangeFolder(pici->hwnd, LOWORD(pici->lpVerb));
    return E_INVALIDARG;
}

STDMETHODIMP CFolderArrangeMenu::GetCommandString(UINT_PTR idCmd, UINT uFlags, UINT *pwRes,
                                                  LPSTR pszName, UINT cchMax)
{
    HRESULT hres = S_OK;
    if (uFlags == GCS_HELPTEXTA)
    {
        MLLoadStringA((UINT)idCmd + IDS_MH_FIRST, pszName, cchMax);
    }
    else if (uFlags == GCS_HELPTEXTW)
    {
        MLLoadStringW((UINT)idCmd + IDS_MH_FIRST, (LPWSTR)pszName, cchMax);
    }
    else
        hres = E_FAIL;
    return hres;
}

HRESULT _GetShortcut(LPCTSTR pszUrl, REFIID riid, void **ppv)
{
    IUniformResourceLocator *purl;
    HRESULT hr = CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER,
                              IID_IUniformResourceLocator, (void **)&purl);

    if (SUCCEEDED(hr))
    {

        hr = purl->SetURL(pszUrl, TRUE);

        if (SUCCEEDED(hr))
            hr = purl->QueryInterface(riid, ppv);

        purl->Release();
    }

    return hr;
}

BOOL _TitleIsGood(LPCWSTR psz)
{
    DWORD scheme = GetUrlScheme(psz);
    return (!PathIsFilePath(psz) && (URL_SCHEME_INVALID == scheme || URL_SCHEME_UNKNOWN == scheme));
}

//////////////////////////////////////////////////////////////////////////////
//
// CBaseItem Object
//
//////////////////////////////////////////////////////////////////////////////


CBaseItem::CBaseItem() 
{
    DllAddRef();
    InitClipboardFormats();
    _cRef = 1;
}        

CBaseItem::~CBaseItem()
{
    if (_ppidl)
    {
        for (UINT i = 0; i < _cItems; i++) 
        {
            if (_ppidl[i])
                ILFree((LPITEMIDLIST)_ppidl[i]);
        }

        LocalFree((HLOCAL)_ppidl);
        _ppidl = NULL;
    }
    
    DllRelease();
}

HRESULT CBaseItem::Initialize(HWND hwnd, UINT cidl, LPCITEMIDLIST *ppidl)
{
    HRESULT hres;
    _ppidl = (LPCITEMIDLIST *)LocalAlloc(LPTR, cidl * sizeof(LPCITEMIDLIST));
    if (_ppidl)
    {
        _hwndOwner = hwnd;
        _cItems     = cidl;

        hres = S_OK;
        for (UINT i = 0; i < cidl; i++)
        {
            _ppidl[i] = ILClone(ppidl[i]);
            if (!_ppidl[i])
            {
                hres = E_OUTOFMEMORY;
                break;
            }
        }
    }
    else
        hres = E_OUTOFMEMORY;
    return hres;
}        

//////////////////////////////////
//
// IUnknown Methods...
//
HRESULT CBaseItem::QueryInterface(REFIID iid, void **ppv)
{
    HRESULT hres;
    static const QITAB qit[] = {
        QITABENT(CBaseItem, IContextMenu),
        QITABENT(CBaseItem, IDataObject),
        QITABENT(CBaseItem, IExtractIconA),
        QITABENT(CBaseItem, IExtractIconW),
        QITABENT(CBaseItem, IQueryInfo),
         { 0 },
    };
    hres = QISearch(this, qit, iid, ppv);

    if (FAILED(hres) && iid == IID_ICache) 
    {
        *ppv = (LPVOID)this;    // for our friends
        AddRef();
        hres = S_OK;
    }
    return hres;
}

ULONG CBaseItem::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CBaseItem::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;   
}


//////////////////////////////////
//
// IQueryInfo Methods
//

HRESULT CBaseItem::GetInfoFlags(DWORD *pdwFlags)
{
    LPCITEMIDLIST pidl = _ppidl[0];
    LPCTSTR pszUrl = _PidlToSourceUrl(pidl);

    *pdwFlags = QIF_CACHED; 

    if (pszUrl)
    {
        pszUrl = _StripHistoryUrlToUrl(pszUrl);

        BOOL fCached = TRUE;

        if (UrlHitsNet(pszUrl) && !UrlIsMappedOrInCache(pszUrl))
        {
            fCached = FALSE;
        }
            
        if (!fCached)
            *pdwFlags &= ~QIF_CACHED;
    }

    return S_OK;
}

//////////////////////////////////
//
// IExtractIconA Methods...
//

HRESULT CBaseItem::Extract(LPCSTR pcszFile, UINT uIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT ucIconSize)
{
    return S_FALSE;
}

//////////////////////////////////
//
// IExtractIconW Methods...
//
HRESULT CBaseItem::GetIconLocation(UINT uFlags, LPWSTR pwzIconFile, UINT ucchMax, PINT pniIcon, PUINT puFlags)
{
    CHAR szIconFile[MAX_PATH];
    HRESULT hr = GetIconLocation(uFlags, szIconFile, ARRAYSIZE(szIconFile), pniIcon, puFlags);
    if (SUCCEEDED(hr))
        AnsiToUnicode(szIconFile, pwzIconFile, ucchMax);
    return hr;
}

HRESULT CBaseItem::Extract(LPCWSTR pcwzFile, UINT uIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT ucIconSize)
{
    CHAR szFile[MAX_PATH];
    UnicodeToAnsi(pcwzFile, szFile, ARRAYSIZE(szFile));
    return Extract(szFile, uIconIndex, phiconLarge, phiconSmall, ucIconSize);
}

//////////////////////////////////
//
// IContextMenu Methods
//

HRESULT CBaseItem::_AddToFavorites(int nIndex)
{
    HRESULT hr = S_OK;
    LPITEMIDLIST pidlUrl = NULL;
    TCHAR szParsedUrl[MAX_URL_STRING];

    // NOTE: This URL came from the user, so we need to clean it up.
    //       If the user entered "yahoo.com" or "Search Get Rich Quick",
    //       it will be turned into a search URL by ParseURLFromOutsideSourceW().
    DWORD cchParsedUrl = ARRAYSIZE(szParsedUrl);
    LPCTSTR pszUrl = _GetUrl(nIndex);
    if (pszUrl && !ParseURLFromOutsideSource(pszUrl, szParsedUrl, &cchParsedUrl, NULL))
    {
        StrCpyN(szParsedUrl, pszUrl, ARRAYSIZE(szParsedUrl));
    } 

    hr = IEParseDisplayName(CP_ACP, szParsedUrl, &pidlUrl);
    if (SUCCEEDED(hr))
    {
        LPCTSTR pszTitle;
        LPCUTSTR pszuTitle = _GetURLTitle( _ppidl[nIndex]);
        if ((pszuTitle == NULL) || (ualstrlen(pszuTitle) == 0))
            pszuTitle = _GetUrl(nIndex);

	TSTR_ALIGNED_STACK_COPY(&pszTitle,pszuTitle);
        AddToFavorites(_hwndOwner, pidlUrl, pszTitle, TRUE, NULL, NULL);
        ILFree(pidlUrl);
        hr = S_OK;
    }

    return hr;
}

STDMETHODIMP CBaseItem::GetCommandString(UINT_PTR idCmd, UINT uFlags, UINT *pwReserved,
                                LPSTR pszName, UINT cchMax)
{
    HRESULT hres = E_FAIL;

    TraceMsg(DM_HSFOLDER, "hci - cm - GetCommandString() called.");

    if ((uFlags == GCS_VERBA) || (uFlags == GCS_VERBW))
    {
        LPCSTR pszSrc = NULL;

        switch(idCmd)
        {
            case RSVIDM_OPEN:
                pszSrc = c_szOpen;
                break;

            case RSVIDM_COPY:
                pszSrc = c_szCopy;
                break;

            case RSVIDM_DELCACHE:
                pszSrc = c_szDelcache;
                break;

            case RSVIDM_PROPERTIES:
                pszSrc = c_szProperties;
                break;
        }
        
        if (pszSrc)
        {
            if (uFlags == GCS_VERBA)
                StrCpyNA(pszName, pszSrc, cchMax);
            else if (uFlags == GCS_VERBW) // GCS_VERB === GCS_VERBW
                SHAnsiToUnicode(pszSrc, (LPWSTR)pszName, cchMax);
            else
                ASSERT(0);
            hres = S_OK;
        }
    }
    
    else if (uFlags == GCS_HELPTEXTA || uFlags == GCS_HELPTEXTW)
    {
        switch(idCmd)
        {
            case RSVIDM_OPEN:
            case RSVIDM_COPY:
            case RSVIDM_DELCACHE:
            case RSVIDM_PROPERTIES:
                if (uFlags == GCS_HELPTEXTA)
                {
                    MLLoadStringA(IDS_SB_FIRST+ (UINT)idCmd, pszName, cchMax);
                }
                else
                {
                    MLLoadStringW(IDS_SB_FIRST+ (UINT)idCmd, (LPWSTR)pszName, cchMax);
                }
                hres = NOERROR;
                break;

            default:
                break;
        }
    }
    return hres;
}


//////////////////////////////////
//
// IDataObject Methods...
//

HRESULT CBaseItem::GetDataHere(LPFORMATETC pFE, LPSTGMEDIUM pSTM)
{
    TraceMsg(DM_HSFOLDER, "hci - do - GetDataHere() called.");
    return E_NOTIMPL;
}

HRESULT CBaseItem::GetCanonicalFormatEtc(LPFORMATETC pFEIn, LPFORMATETC pFEOut)
{
    TraceMsg(DM_HSFOLDER, "hci - do - GetCanonicalFormatEtc() called.");
    return DATA_S_SAMEFORMATETC;
}

HRESULT CBaseItem::SetData(LPFORMATETC pFE, LPSTGMEDIUM pSTM, BOOL fRelease)
{
    TraceMsg(DM_HSFOLDER, "hci - do - SetData() called.");
    return E_NOTIMPL;
}

HRESULT CBaseItem::DAdvise(LPFORMATETC pFE, DWORD grfAdv, LPADVISESINK pAdvSink, DWORD *pdwConnection)
{
    return OLE_E_ADVISENOTSUPPORTED;
}

HRESULT CBaseItem::DUnadvise(DWORD dwConnection)
{
    return OLE_E_ADVISENOTSUPPORTED;
}

HRESULT CBaseItem::EnumDAdvise(LPENUMSTATDATA *ppEnum)
{
    return OLE_E_ADVISENOTSUPPORTED;
}

//////////////////////////////////////////////////////////////////////////////
//
// Helper Routines
//
//////////////////////////////////////////////////////////////////////////////

LPCTSTR CBaseItem::_GetDisplayUrlForPidl(LPCITEMIDLIST pidl, LPTSTR pszDisplayUrl, DWORD dwDisplayUrl)
{
    LPCTSTR pszUrl = _StripHistoryUrlToUrl(_PidlToSourceUrl(pidl));
    if (pszUrl && PrepareURLForDisplay(pszUrl, pszDisplayUrl, &dwDisplayUrl))
    {
        pszUrl = pszDisplayUrl;
    }
    return pszUrl;
}

HRESULT CBaseItem::_CreateFileDescriptorA(LPSTGMEDIUM pSTM)
{
    TCHAR urlTitleBuf[ MAX_URL_STRING ];
    LPCUTSTR ua_urlTitle;
    LPCTSTR urlTitle;
    
    pSTM->tymed = TYMED_HGLOBAL;
    pSTM->pUnkForRelease = NULL;

    FILEGROUPDESCRIPTORA *pfgd = (FILEGROUPDESCRIPTORA*)GlobalAlloc(GPTR, sizeof(FILEGROUPDESCRIPTORA) + (_cItems-1) * sizeof(FILEDESCRIPTORA));
    if (pfgd == NULL)
    {
        TraceMsg(DM_HSFOLDER, "hci -   Couldn't alloc file descriptor");
        return E_OUTOFMEMORY;
    }
    
    pfgd->cItems = _cItems;     // set the number of items

    for (UINT i = 0; i < _cItems; i++)
    {

        FILEDESCRIPTORA *pfd = &(pfgd->fgd[i]);
        UINT cchFilename;

	//
	// Derive an aligned copy of the url title
	//

	ua_urlTitle = _GetURLTitle( _ppidl[i] );
	if (TSTR_ALIGNED(ua_urlTitle) == FALSE) {
	    ualstrcpyn( urlTitleBuf, ua_urlTitle, ARRAYSIZE(urlTitleBuf));
	    urlTitle = urlTitleBuf;
	} else {
	    urlTitle = (LPCTSTR)ua_urlTitle;
	}
        
        SHTCharToAnsi(urlTitle, pfd->cFileName, ARRAYSIZE(pfd->cFileName) );
        
        MakeLegalFilenameA(pfd->cFileName);

        cchFilename = lstrlenA(pfd->cFileName);
        SHTCharToAnsi(L".URL", pfd->cFileName+cchFilename, ARRAYSIZE(pfd->cFileName)-cchFilename);

    }

    pSTM->hGlobal = pfgd;
    
    return S_OK;
}
    
// this format is explicitly ANSI, hence no TCHAR stuff

HRESULT CBaseItem::_CreateURL(LPSTGMEDIUM pSTM)
{
    DWORD cchSize;
    LPCTSTR pszURL = _StripHistoryUrlToUrl(_PidlToSourceUrl(_ppidl[0]));
    if (!pszURL)
        return E_FAIL;
    
    // render the url
    cchSize = lstrlen(pszURL) + 1;

    pSTM->tymed = TYMED_HGLOBAL;
    pSTM->pUnkForRelease = NULL;
    pSTM->hGlobal = GlobalAlloc(GPTR, cchSize * sizeof(CHAR));
    if (pSTM->hGlobal)
    {
        TCharToAnsi(pszURL, (LPSTR)pSTM->hGlobal, cchSize);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}


HRESULT CBaseItem::_CreatePrefDropEffect(LPSTGMEDIUM pSTM)
{
    pSTM->tymed = TYMED_HGLOBAL;
    pSTM->pUnkForRelease = NULL;
    
    pSTM->hGlobal = GlobalAlloc(GPTR, sizeof(DWORD));

    if (pSTM->hGlobal)
    {
        *((LPDWORD)pSTM->hGlobal) = DROPEFFECT_COPY;
        return S_OK;
    }

    return E_OUTOFMEMORY;    
}


HRESULT CBaseItem::_CreateFileContents(LPSTGMEDIUM pSTM, LONG lindex)
{
    HRESULT hr;
    
    // make sure the index is in a valid range.
    ASSERT((unsigned)lindex < _cItems);
    ASSERT(lindex >= 0);

    // here's a partial fix for when ole sometimes passes in -1 for lindex
    if (lindex == -1)
    {
        if (_cItems == 1)
            lindex = 0;
        else
            return E_FAIL;
    }
    
    pSTM->tymed = TYMED_ISTREAM;
    pSTM->pUnkForRelease = NULL;
    
    hr = CreateStreamOnHGlobal(NULL, TRUE, &pSTM->pstm);
    if (SUCCEEDED(hr))
    {
        LARGE_INTEGER li = {0L, 0L};
        IUniformResourceLocator *purl;

        hr = CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER,
            IID_IUniformResourceLocator, (void **)&purl);
        if (SUCCEEDED(hr))
        {
            TCHAR szDecoded[MAX_URL_STRING];

            ConditionallyDecodeUTF8(_GetUrlForPidl(_ppidl[lindex]), 
                szDecoded, ARRAYSIZE(szDecoded));

            hr = purl->SetURL(szDecoded, TRUE);
            if (SUCCEEDED(hr))
            {
                IPersistStream *pps;
                hr = purl->QueryInterface(IID_IPersistStream, (LPVOID *)&pps);
                if (SUCCEEDED(hr))
                {
                    hr = pps->Save(pSTM->pstm, TRUE);
                    pps->Release();
                }
            }
            purl->Release();
        }               
        pSTM->pstm->Seek(li, STREAM_SEEK_SET, NULL);
    }

    return hr;
}


HRESULT CBaseItem::_CreateHTEXT(LPSTGMEDIUM pSTM)
{
    UINT i;
    UINT cbAlloc = sizeof(TCHAR);        // null terminator
    TCHAR szDisplayUrl[INTERNET_MAX_URL_LENGTH];

    for (i = 0; i < _cItems; i++)
    {
        LPCTSTR pszUrl = _GetDisplayUrlForPidl(_ppidl[i], szDisplayUrl, ARRAYSIZE(szDisplayUrl));
        if (!pszUrl)
            return E_FAIL;
        char szAnsiUrl[MAX_URL_STRING];
        TCharToAnsi(pszUrl, szAnsiUrl, ARRAYSIZE(szAnsiUrl));

        // 2 extra for carriage return and newline
        cbAlloc += sizeof(CHAR) * (lstrlenA(szAnsiUrl) + 2);  
    }

    // render the url
    
    pSTM->tymed = TYMED_HGLOBAL;
    pSTM->pUnkForRelease = NULL;
    pSTM->hGlobal = GlobalAlloc(GPTR, cbAlloc);

    if (pSTM->hGlobal)
    {
        LPSTR  pszHTEXT = (LPSTR)pSTM->hGlobal;
        int    cchHTEXT = cbAlloc / sizeof(CHAR);

        for (i = 0; i < _cItems; i++)
        {
            if (i && cchHTEXT > 2)
            {
                *pszHTEXT++ = 0xD;
                *pszHTEXT++ = 0xA;
                cchHTEXT -= 2;
            }

            LPCTSTR pszUrl = _GetDisplayUrlForPidl(_ppidl[i], szDisplayUrl, ARRAYSIZE(szDisplayUrl));
            if (pszUrl)
            {
                int     cchUrl = lstrlen(pszUrl);

                TCharToAnsi(pszUrl, pszHTEXT, cchHTEXT);

                pszHTEXT += cchUrl;
                cchHTEXT -= cchUrl;
            }
        }
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

HRESULT CBaseItem::_CreateUnicodeTEXT(LPSTGMEDIUM pSTM)
{
    UINT i;
    UINT cbAlloc = sizeof(WCHAR);        // null terminator
    WCHAR szDisplayUrl[INTERNET_MAX_URL_LENGTH];

    for (i = 0; i < _cItems; i++)
    {
        ConditionallyDecodeUTF8(_GetUrlForPidl(_ppidl[i]), 
            szDisplayUrl, ARRAYSIZE(szDisplayUrl));

        if (!*szDisplayUrl)
            return E_FAIL;

        cbAlloc += sizeof(WCHAR) * (lstrlenW(szDisplayUrl) + 2);
    }

    // render the url
    
    pSTM->tymed = TYMED_HGLOBAL;
    pSTM->pUnkForRelease = NULL;
    pSTM->hGlobal = GlobalAlloc(GPTR, cbAlloc);

    if (pSTM->hGlobal)
    {
        LPTSTR pszHTEXT = (LPTSTR)pSTM->hGlobal;
        int    cchHTEXT = cbAlloc / sizeof(WCHAR);

        for (i = 0; i < _cItems; i++)
        {
            if (i && cchHTEXT > 2)
            {
                *pszHTEXT++ = 0xD;
                *pszHTEXT++ = 0xA;
                cchHTEXT -= 2;
            }

            ConditionallyDecodeUTF8(_GetUrlForPidl(_ppidl[i]), 
                szDisplayUrl, ARRAYSIZE(szDisplayUrl));

            int     cchUrl = lstrlenW(szDisplayUrl);

            StrCpyN(pszHTEXT, szDisplayUrl, cchHTEXT);

            pszHTEXT += cchUrl;
            cchHTEXT -= cchUrl;
        }
        return S_OK;
    }

    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\dll\makefile.inc ===
$(O)\error.dls : ..\error.dlg
    $(C_PREPROCESSOR_NAME) /EP ..\error.dlg > $@

$(O)\error.dlx : $(O)\error.dls ..\dlg.pl
    perl ..\dlg.pl < $(O)\error.dls > $@

$(O)\about.dls : ..\about.dlg
    $(C_PREPROCESSOR_NAME) /EP ..\about.dlg > $@

$(O)\about.dlx : $(O)\about.dls ..\dlg.pl
    perl ..\dlg.pl < $(O)\about.dls > $@

$(O)\findinc.dls : ..\findinc.dlg ..\dialogs.dh
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP ..\findinc.dlg > $@

$(O)\findinc.dlx : $(O)\findinc.dls ..\dlg.pl
    echo //^<SCRIPT LANGUAGE="JavaScript"^> > $@
    perl ..\dlg.pl < $(O)\findinc.dls >> $@
    echo //^</SCRIPT^> >> $@

$(O)\find.dls : ..\find.dlg ..\dialogs.dh ..\findinc.dlg
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP ..\find.dlg > $@

$(O)\find.dlx : $(O)\find.dls ..\dlg.pl
    perl ..\dlg.pl < $(O)\find.dls > $@

$(O)\privacypolicy.dls : ..\privacypolicy.dlg ..\dialogs.dh
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP ..\privacypolicy.dlg > $@

$(O)\privacypolicy.dlx : $(O)\privacypolicy.dls ..\dlg.pl
    perl ..\dlg.pl < $(O)\privacypolicy.dls > $@


$(O)\bidifind.dls : ..\bidifind.dlg ..\dialogs.dh ..\findinc.dlg
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP ..\bidifind.dlg > $@

$(O)\bidifind.dlx : $(O)\bidifind.dls ..\dlg.pl
    perl ..\dlg.pl < $(O)\bidifind.dls > $@

$(O)\orgfav.dls : ..\orgfav.dlg
    $(C_PREPROCESSOR_NAME) /EP ..\orgfav.dlg > $@

$(O)\orgfav.dlx : $(O)\orgfav.dls ..\dlg.pl
    perl ..\dlg.pl < $(O)\orgfav.dls > $@

$(O)\ieerror.dls : ..\ieerror.dlg
    $(C_PREPROCESSOR_NAME) /EP ..\ieerror.dlg > $@

$(O)\ieerror.dlx : $(O)\ieerror.dls ..\dlg.pl
    perl ..\dlg.pl < $(O)\ieerror.dls > $@

$(O)\anchbrws.pps : ..\anchbrws.ppg
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP ..\anchbrws.ppg > $@

$(O)\anchbrws.ppx: $(O)\anchbrws.pps
    perl ..\dlg.pl < $(O)\anchbrws.pps > $@

$(O)\docbrows.pps: ..\docbrows.ppg
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP ..\docbrows.ppg > $@

$(O)\docbrows.ppx : $(O)\docbrows.pps
    perl ..\dlg.pl < $(O)\docbrows.pps > $@

$(O)\imgbrows.pps : ..\imgbrows.ppg
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP ..\imgbrows.ppg > $@

$(O)\imgbrows.ppx : $(O)\imgbrows.pps
    perl ..\dlg.pl < $(O)\imgbrows.pps > $@

$(O)\analyze.dls : ..\analyze.dlg ..\dialogs.dh
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP ..\analyze.dlg > $@

$(O)\analyze.dlx : $(O)\analyze.dls ..\dlg.pl
    perl ..\dlg.pl < $(O)\analyze.dls > $@

SHDOCLCR_DEP = \
    $(O)\error.dlx      \
    $(O)\about.dlx      \
    $(O)\findinc.dlx    \
    $(O)\find.dlx       \
    $(O)\privacypolicy.dlx  \
    $(O)\bidifind.dlx   \
    $(O)\orgfav.dlx     \
    $(O)\ieerror.dlx    \
    $(O)\anchbrws.ppx   \
    $(O)\docbrows.ppx   \
    $(O)\imgbrows.ppx   \
    $(O)\analyze.dlx

!include $(CCSHELL_DIR)\makefile.inc

..\shdocvw.rc : $(SDK_LIB_PATH)\exdisp.tlb $(SELFREGNAME) $(SHDOCLCR_DEP)

..\shdoclc.rc : $(SHDOCLCR_DEP)

$(PROJECT_ROOT)\lib\$(O)\$(PRIVLIB) : $(O)\shdocvwp.lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\hist\cafolder.h ===
#ifndef CAFOLDER_H__
#define CAFOLDER_H__

#ifdef __cplusplus

#include <debug.h>
#include "iface.h"

// Forward class declarations
class CCacheFolderEnum;
class CCacheFolder;
class CCacheItem;

#define LOTS_OF_FILES (10)

// PIDL format for cache folder...
struct CEIPIDL : public BASEPIDL
{
//    USHORT cb;
//    USHORT usSign;
    TCHAR szTypeName[80];
    INTERNET_CACHE_ENTRY_INFO cei;
};
typedef UNALIGNED CEIPIDL *LPCEIPIDL;

#define IS_VALID_CEIPIDL(pidl)      ((pidl)                                     && \
                                     (((LPCEIPIDL)pidl)->cb >= sizeof(CEIPIDL)) && \
                                     (((LPCEIPIDL)pidl)->usSign == (USHORT)CEIPIDL_SIGN))
#define CEI_SOURCEURLNAME(pceipidl)    ((LPTSTR)((DWORD_PTR)(pceipidl)->cei.lpszSourceUrlName + (LPBYTE)(&(pceipidl)->cei)))
#define CEI_LOCALFILENAME(pceipidl)    ((LPTSTR)((DWORD_PTR)(pceipidl)->cei.lpszLocalFileName + (LPBYTE)(&(pceipidl)->cei)))
#define CEI_FILEEXTENSION(pceipidl)    ((LPTSTR)((DWORD_PTR)(pceipidl)->cei.lpszFileExtension + (LPBYTE)(&(pceipidl)->cei)))
#define CEI_CACHEENTRYTYPE(pcei)   ((DWORD)(pcei)->cei.CacheEntryType)

inline UNALIGNED const TCHAR* _GetURLTitle(LPCEIPIDL pcei)
{
    return _FindURLFileName(CEI_SOURCEURLNAME(pcei));
}    

inline void _GetCacheItemTitle(LPCEIPIDL pcei, LPTSTR pszTitle, DWORD cchBufferSize)
{
    int iLen;
    ualstrcpyn(pszTitle, _GetURLTitle(pcei), cchBufferSize);
    iLen = lstrlen(pszTitle) - 1;       // we want the last char
    if (pszTitle[iLen] == TEXT('/'))
        pszTitle[iLen] = TEXT('\0');
}   

inline LPCTSTR CPidlToSourceUrl(LPCEIPIDL pidl)
{
    return CEI_SOURCEURLNAME(pidl);
}

inline int _CompareCFolderPidl(LPCEIPIDL pidl1, LPCEIPIDL pidl2)
{
    return StrCmpI(CPidlToSourceUrl(pidl1), CPidlToSourceUrl(pidl2));
}

///////////////////////
//
// Warn on Cookie deletion
//
enum {
    DEL_COOKIE_WARN = 0,
    DEL_COOKIE_YES,
    DEL_COOKIE_NO
};

// Forward declarations for create instance functions 
HRESULT CCacheItem_CreateInstance(CCacheFolder *pHCFolder, HWND hwndOwner, UINT cidl, LPCITEMIDLIST *ppidl, REFIID riid, void **ppvOut);

//////////////////////////////////////////////////////////////////////////////
//
// CCacheFolderEnum Object
//
//////////////////////////////////////////////////////////////////////////////

class CCacheFolderEnum : public IEnumIDList
{
public:
    CCacheFolderEnum(DWORD grfFlags, CCacheFolder *pHCFolder);
    
    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumIDList
    STDMETHODIMP Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumIDList **ppenum);

protected:
    ~CCacheFolderEnum();

    LONG                _cRef;      // ref count
    CCacheFolder    *_pCFolder;// this is what we enumerate    
    UINT                _grfFlags;  // enumeration flags 
    UINT                _uFlags;    // local flags   
    LPINTERNET_CACHE_ENTRY_INFO _pceiWorking;        
    HANDLE              _hEnum;
};


class CCacheFolder :
    public IShellFolder2, 
    public IShellIcon, 
    public IPersistFolder2
{
    // CCacheFolder interfaces
    friend CCacheFolderEnum;
    friend CCacheItem;
    friend HRESULT CacheFolderView_CreateInstance(CCacheFolder *pHCFolder, void **ppvOut);
    friend HRESULT CacheFolderView_DidDragDrop(IDataObject *pdo, DWORD dwEffect);
        
public:
    CCacheFolder();

    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
   
    // IShellFolder methods
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pszDisplayName, 
        ULONG *pchEaten, LPITEMIDLIST *ppidl, ULONG *pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList);
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvOut);
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvObj);
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHODIMP CreateViewObject(HWND hwnd, REFIID riid, void **ppvOut);
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG *rgfInOut);
    STDMETHODIMP GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl,
            REFIID riid, UINT * prgfInOut, void **ppvOut);
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl,
            LPCOLESTR lpszName, DWORD uFlags, LPITEMIDLIST * ppidlOut);

    // IShellFolder2
    STDMETHODIMP GetDefaultSearchGUID(LPGUID lpGuid) { return E_NOTIMPL; };
    STDMETHODIMP EnumSearches(LPENUMEXTRASEARCH *ppenum) { *ppenum = NULL; return E_NOTIMPL; };
    STDMETHODIMP GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay);
    STDMETHODIMP GetDefaultColumnState(UINT iColumn, DWORD *pbState) { return E_NOTIMPL; };
    STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv) { return E_NOTIMPL; };
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails);
    STDMETHODIMP MapColumnToSCID(UINT iCol, SHCOLUMNID *pscid) { return E_NOTIMPL; };

    // IShellIcon
    STDMETHODIMP GetIconOf(LPCITEMIDLIST pidl, UINT flags, LPINT lpIconIndex);

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pClassID);
    // IPersistFolder
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);
    // IPersistFolder2 Methods
    STDMETHODIMP GetCurFolder(LPITEMIDLIST *ppidl);

protected:
    ~CCacheFolder();
    
    HRESULT GetDisplayNameOfCEI(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    HRESULT _CompareAlignedIDs(LPARAM lParam, LPCEIPIDL pidl1, LPCEIPIDL pidl2);

    HRESULT _GetInfoTip(LPCITEMIDLIST pidl, DWORD dwFlags, WCHAR **ppwszTip);
    
    STDMETHODIMP _GetDetail(LPCITEMIDLIST pidl, UINT iColumn, LPTSTR pszStr, UINT cchStr);
    HRESULT _GetFileSysFolder(IShellFolder2 **ppsf);
    static HRESULT CALLBACK _sViewCallback(IShellView *psv, IShellFolder *psf, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    LONG            _cRef;

    UINT            _uFlags;    // copied from CacheFolder struct
    LPITEMIDLIST    _pidl;      // copied from CacheFolder struct
    IShellFolder2*   _pshfSys;   // system IShellFolder
};

class CCacheItem : public CBaseItem
{
    // CCacheItem interfaces
    friend HRESULT CacheFolderView_DidDragDrop(IDataObject *pdo, DWORD dwEffect);

public:
    CCacheItem();
    HRESULT Initialize(CCacheFolder *pHCFolder, HWND hwnd, UINT cidl, LPCITEMIDLIST *ppidl);

    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID,void **);

    // IQueryInfo Methods
    STDMETHODIMP GetInfoTip(DWORD dwFlags, WCHAR **ppwszTip);

    // IContextMenu Methods
    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst,
                                  UINT idCmdLast, UINT uFlags);
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);

    // IDataObject Methods...
    STDMETHODIMP GetData(LPFORMATETC pFEIn, LPSTGMEDIUM pSTM);
    STDMETHODIMP QueryGetData(LPFORMATETC pFE);
    STDMETHODIMP EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC *ppEnum);

    // IExtractIconA Methods
    STDMETHODIMP GetIconLocation(UINT uFlags, LPSTR pszIconFile, UINT ucchMax, PINT pniIcon, PUINT puFlags);

protected:
    ~CCacheItem();

    virtual LPCTSTR _GetUrl(int nIndex);
    virtual LPCTSTR _PidlToSourceUrl(LPCITEMIDLIST pidl);
    virtual UNALIGNED const TCHAR* _GetURLTitle(LPCITEMIDLIST pcei);
    BOOL _ZoneCheck(int nIndex, DWORD dwUrlAction);
    HRESULT _CreateHDROP(STGMEDIUM *pmedium);

    CCacheFolder* _pCFolder;   // back pointer to our shell folder
    DWORD   _dwDelCookie;
    static INT_PTR CALLBACK _sPropDlgProc(HWND, UINT, WPARAM, LPARAM);
};

#endif // __cplusplus

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\hist\chcommon.h ===
#ifndef CHCOMMON_H__
#define CHCOMMON_H__

#ifdef __cplusplus

HRESULT _GetShortcut(LPCTSTR pszUrl, REFIID riid, void **ppv);
HRESULT AlignPidl(LPCITEMIDLIST* ppidl, BOOL* pfRealigned);
HRESULT AlignPidlArray(LPCITEMIDLIST* apidl, int cidl, LPCITEMIDLIST** papidl,
                          BOOL* pfRealigned);
void    FreeRealignedPidlArray(LPCITEMIDLIST* apidl, int cidl);

void inline FreeRealignedPidl(LPCITEMIDLIST pidl)
{
    ILFree((LPITEMIDLIST)pidl);
}

UINT MergeMenuHierarchy(HMENU hmenuDst, HMENU hmenuSrc, UINT idcMin, UINT idcMax);
void ResizeStatusBar(HWND hwnd, BOOL fInit);
HRESULT _ArrangeFolder(HWND hwnd, UINT uID);
BOOL _TitleIsGood(LPCWSTR psz);

//////////////////////////////////////////////////////////////////////
//  StrHash -- A generic string hasher
//             Stores (char*, void*) pairs
//  Marc Miller (t-marcmi), 1998

/*
 * TODO:
 *    provide a way to update/delete entries
 *    provice a way to specify a beginning table size
 *    provide a way to pass in a destructor function
 *      for void* values
 */
class StrHash {
public:
    StrHash(int fCaseInsensitive = 0);
    ~StrHash();
    void* insertUnique(LPCTSTR pszKey, int fCopy, void* pvVal);    
    void* retrieve(LPCTSTR pszKey);
#ifdef DEBUG
    void _RemoveHashNodesFromMemList();
    void _AddHashNodesFromMemList();
#endif // DEBUG
protected:
    class StrHashNode {
        friend class StrHash;
    protected:
        LPCTSTR pszKey;
        void*   pvVal;
        int     fCopy;
        StrHashNode* next;
    public:
        StrHashNode(LPCTSTR psz, void* pv, int fCopy, StrHashNode* next);
        ~StrHashNode();
    };
    // possible hash-table sizes, chosen from primes not close to powers of 2
    static const unsigned int   sc_auPrimes[];
    static const unsigned int   c_uNumPrimes;
    static const unsigned int   c_uFirstPrime;
    static const unsigned int   c_uMaxLoadFactor; // scaled by USHORT_MAX

    unsigned int nCurPrime; // current index into sc_auPrimes
    unsigned int nBuckets;
    unsigned int nElements;
    StrHashNode** ppshnHashChain;

    int _fCaseInsensitive;
    
    unsigned int        _hashValue(LPCTSTR, unsigned int);
    StrHashNode*        _findKey(LPCTSTR pszStr, unsigned int ubucketNum);
    unsigned int        _loadFactor();
    int                 _prepareForInsert();
private:
    // empty private copy constructor to prevent copying
    StrHash(const StrHash& strHash) { }
    // empty private assignment constructor to prevent assignment
    StrHash& operator=(const StrHash& strHash) { return *this; }
};

//////////////////////////////////////////////////////////////////////
/// OrderedList
class OrderedList {
public:
    class Element {
    public:
        friend  class OrderedList;
        virtual int   compareWith(Element *pelt) = 0;

        virtual ~Element() { }
    private:
        Element* next;
    };
    OrderedList(unsigned int uSize);
    ~OrderedList();
#if DEBUG
	void _RemoveElementsFromMemlist();
	void _AddElementsToMemlist();
#endif //DEBUg
    
    void     insert(Element *pelt);
    Element *removeFirst();
    Element *peek() { return peltHead; }

protected:
    Element       *peltHead; // points to smallest in list
    unsigned int   uSize;
    unsigned int   uCount;

public:
    // variable access functions
    unsigned int count() { return uCount; }
    BOOL         full()  { return (uSize && (uCount >= uSize)); }
private:
    OrderedList(const OrderedList& ol) { }
    OrderedList& operator=(const OrderedList& ol) { return *this; }
};

class CDetailsOfFolder : public IShellDetails
{
public:
    CDetailsOfFolder(HWND hwnd, IShellFolder2 *psf) : _cRef(1), _psf(psf), _hwnd(hwnd)
    {
        _psf->AddRef();
    }

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppv);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    // IShellDetails
    STDMETHOD(GetDetailsOf)(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pdi);
    STDMETHOD(ColumnClick)(UINT iColumn);

private:
    virtual ~CDetailsOfFolder() { _psf->Release(); }

    LONG _cRef;
    IShellFolder2 *_psf;
    HWND _hwnd;
};

class CFolderArrangeMenu : public IContextMenu
{
public:
    CFolderArrangeMenu(UINT idMenu) : _cRef(1), _idMenu(idMenu)
    {
    }

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppv);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    // IContextMenu 
    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst,
                                  UINT idCmdLast, UINT uFlags);
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);
    STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType,UINT *pwReserved,
                                  LPSTR pszName, UINT cchMax);
private:
    virtual ~CFolderArrangeMenu() { }

    LONG _cRef;
    UINT _idMenu;
};

////////////////////////////////////////////////////////////////////////////
//
// CBaseItem Object
//
////////////////////////////////////////////////////////////////////////////

class CBaseItem :
    public IContextMenu, 
    public IDataObject,
    public IExtractIconA,
    public IExtractIconW,
    public IQueryInfo
{

public:
    CBaseItem();
    HRESULT Initialize(HWND hwnd, UINT cidl, LPCITEMIDLIST *ppidl);

    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // IContextMenu Methods
//    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst,
//                                  UINT idCmdLast, UINT uFlags);

//    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);

    STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType,UINT *pwReserved,
                                  LPSTR pszName, UINT cchMax);
    

    // IQueryInfo Methods
//    STDMETHODIMP GetInfoTip(DWORD dwFlags, WCHAR **ppwszTip);
    STDMETHODIMP GetInfoFlags(DWORD *pdwFlags);
    
    // IExtractIconA Methods
    STDMETHODIMP GetIconLocation(UINT uFlags, LPSTR pszIconFile, UINT ucchMax, PINT pniIcon, PUINT puFlags) = 0;
    STDMETHODIMP Extract(LPCSTR pcszFile, UINT uIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT ucIconSize);

    // IExtractIconW Methods
    STDMETHODIMP GetIconLocation(UINT uFlags, LPWSTR pwzIconFile, UINT ucchMax, PINT pniIcon, PUINT puFlags);
    STDMETHODIMP Extract(LPCWSTR pcwzFile, UINT uIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT ucIconSize);

    // IDataObject Methods...
//    STDMETHODIMP GetData(LPFORMATETC pFEIn, LPSTGMEDIUM pSTM);
    STDMETHODIMP GetDataHere(LPFORMATETC pFE, LPSTGMEDIUM pSTM);
//    STDMETHODIMP QueryGetData(LPFORMATETC pFE);
    STDMETHODIMP GetCanonicalFormatEtc(LPFORMATETC pFEIn, LPFORMATETC pFEOut);
    STDMETHODIMP SetData(LPFORMATETC pFE, LPSTGMEDIUM pSTM, BOOL fRelease);
//    STDMETHODIMP EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC *ppEnum);
    STDMETHODIMP DAdvise(LPFORMATETC pFE, DWORD grfAdv, LPADVISESINK pAdvSink,
                            DWORD *pdwConnection);
    STDMETHODIMP DUnadvise(DWORD dwConnection);
    STDMETHODIMP EnumDAdvise(LPENUMSTATDATA *ppEnum);
    
    // IDataObject helper functions
    HRESULT _CreateHTEXT(STGMEDIUM *pmedium);
    HRESULT _CreateUnicodeTEXT(STGMEDIUM *pmedium);
    HRESULT _CreateFileDescriptorA(STGMEDIUM *pSTM);
    HRESULT _CreateFileContents(STGMEDIUM *pSTM, LONG lindex);
    HRESULT _CreateURL(STGMEDIUM *pSTM);
    HRESULT _CreatePrefDropEffect(STGMEDIUM *pSTM);

   
protected:

    virtual ~CBaseItem();

    virtual LPCTSTR _GetUrl(int nIndex) = 0;
    virtual LPCTSTR _PidlToSourceUrl(LPCITEMIDLIST pidl) = 0;
    virtual UNALIGNED const TCHAR* _GetURLTitle(LPCITEMIDLIST pcei) = 0;
    LPCTSTR _GetDisplayUrlForPidl(LPCITEMIDLIST pidl, LPTSTR pszDisplayUrl, DWORD dwDisplayUrl);
    HRESULT _AddToFavorites(int nIndex);    

    LONG              _cRef;        // reference count
    
    UINT    _cItems;                // number of items we represent
    LPCITEMIDLIST*  _ppidl;             // variable size array of items
    HWND    _hwndOwner;     
};

#endif // __cplusplus

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\hist\hsfolder.h ===
#ifndef HSFOLDER_H__
#define HSFOLDER_H__

#ifdef __cplusplus

#include <debug.h>
#include "iface.h"
#include <stralign.h>

// Forward class declarations
class CHistFolderEnum;
class CHistFolder;
class CHistItem;

#define LOTS_OF_FILES (10)

// The number of "top" sites displayed in the "Most Frequently Viewed..." history view
#define NUM_TOP_SITES  20

void _GetURLDispName(LPBASEPIDL pcei, LPTSTR pszName, UINT cchName) ;
UNALIGNED const TCHAR* _GetURLTitle(LPBASEPIDL pcei);
LPBASEPIDL _CreateBaseFolderPidl(BOOL fOleAlloc, DWORD dwSize, USHORT usSign);
LPBASEPIDL _CreateIdCacheFolderPidl(BOOL fOleAlloc, USHORT usSign, LPCTSTR szId);
LPHEIPIDL _CreateHCacheFolderPidl(BOOL fOleMalloc, LPCTSTR pszUrl, FILETIME ftModified, LPSTATURL lpStatURL,
                                  __int64 llPriority = 0, DWORD dwNumHits = 0);

#define ua_GetURLTitle(d,p) TSTR_ALIGNED_STACK_COPY(d,_GetURLTitle(p))

__inline LPCWSTR _GetURLTitleAlign(LPBASEPIDL pcei, LPTSTR szBuf, DWORD cchBuf)
{
    LPCUTSTR urlTitle;

    urlTitle = _GetURLTitle(pcei);
#if defined(UNICODE) && defined(ALIGNMENT_MACHINE)
    if (TSTR_ALIGNED(urlTitle)) {
        return (LPCTSTR)urlTitle;
    } else {
        ualstrcpyn(szBuf, _GetURLTitle(pcei), cchBuf);
        return szBuf;
    }
#else
    return urlTitle;
#endif
}

// returns TRUE if _GetURLTitle would retrieve an URL when given this PIDL
inline BOOL _URLTitleIsURL(LPBASEPIDL pcei)
{
    return ((pcei->usSign == HEIPIDL_SIGN) && (((LPHEIPIDL) pcei)->usTitle == 0));
}

inline LPCTSTR HPidlToSourceUrl(LPBASEPIDL pidl)
{
    if (pidl->usSign == (USHORT)HEIPIDL_SIGN)
    {
        LPHEIPIDL pheipidl = (LPHEIPIDL) pidl;

        return (LPCTSTR)(((BYTE*)pheipidl) + pheipidl->usUrl);
    }
    return NULL;
}

inline LPCTSTR HPidlToSourceUrl(LPCITEMIDLIST pidl)
{
    return HPidlToSourceUrl((LPBASEPIDL) pidl);
}

inline int _CompareHCURLs(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2) 
{
    LPCTSTR url1     = _StripHistoryUrlToUrl(HPidlToSourceUrl((LPBASEPIDL)pidl1));
    LPCTSTR url2     = _StripHistoryUrlToUrl(HPidlToSourceUrl((LPBASEPIDL)pidl2));

    ASSERT(url1 && url2);
    
    return StrCmpI(url1, url2);
}

inline int _CompareHFolderPidl(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    return StrCmpI(HPidlToSourceUrl((LPBASEPIDL)pidl1), HPidlToSourceUrl((LPBASEPIDL)pidl2));
}

///////////////////////
//
// Column definition for the History Folder Defview
//
enum {
    ICOLH_URL_NAME = 0,
    ICOLH_URL_TITLE,
    ICOLH_URL_LASTVISITED,
    ICOLH_URL_MAX         // Make sure this is the last enum item
};

#define INTERVAL_PREFIX_LEN (6)
#define INTERVAL_VERS_LEN (2)
#define INTERVAL_VERS (TEXT("01"))
#define OUR_VERS (1)
#define UNK_INTERVAL_VERS (0xFFFF)
#define RANGE_LEN (16)
#define INTERVAL_MIN_SIZE (RANGE_LEN+INTERVAL_PREFIX_LEN)
#define INTERVAL_SIZE (RANGE_LEN+INTERVAL_VERS_LEN+INTERVAL_PREFIX_LEN)
#define PREFIX_SIZE (RANGE_LEN+3)

//  NOTE: the interval is closed at the start but open at the end, that
//  is inclusion is time >= start and time < end
typedef struct _HSFINTERVAL
{
    FILETIME ftStart;
    FILETIME ftEnd;
    TCHAR  szPrefix[PREFIX_SIZE+1];
    USHORT usSign;
    USHORT usVers;
} HSFINTERVAL;


BOOL GetDisplayNameForTimeInterval( const FILETIME *pStartTime, const FILETIME *pEndTime,
                                    LPTSTR szBuffer, int cbBufferLength);
HRESULT _ValueToIntervalW(LPCUWSTR wzInterval, FILETIME *pftStart, FILETIME *pftEnd);

//  DeleteEntries filter callback
typedef BOOL (*PFNDELETECALLBACK)(LPINTERNET_CACHE_ENTRY_INFO pceiWorking, LPVOID pDelData, LPITEMIDLIST *ppidlNotify);

// Forward declarations for create instance functions 
HRESULT CHistItem_CreateInstance(CHistFolder *pHCFolder, HWND hwndOwner, UINT cidl, LPCITEMIDLIST *ppidl, REFIID riid, void **ppvOut);

//////////////////////////////////////////////////////////////////////////////
//
// CHistFolderEnum Object
//
//////////////////////////////////////////////////////////////////////////////

class CHistFolderEnum : public IEnumIDList
{
public:
    CHistFolderEnum(DWORD grfFlags, CHistFolder *pHCFolder);
    
    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumIDList
    STDMETHODIMP Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumIDList **ppenum);

protected:
    ~CHistFolderEnum();
    HRESULT _NextHistInterval(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    HRESULT _NextViewPart(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    HRESULT _NextViewPart_OrderToday(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    HRESULT _NextViewPart_OrderSite(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    HRESULT _NextViewPart_OrderFreq(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    HRESULT _NextViewPart_OrderSearch(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    class OrderedList* _GetMostFrequentPages();
    LPCTSTR _GetLocalHost(void);

    LONG                _cRef;      // ref count
    CHistFolder    *_pHCFolder;// this is what we enumerate    
    UINT                _grfFlags;  // enumeration flags 
    UINT                _uFlags;    // local flags   
    LPINTERNET_CACHE_ENTRY_INFO _pceiWorking;        
    HANDLE              _hEnum;
    int              _cbCurrentInterval;     //  position in enum of time intervals
    int              _cbIntervals;
    HSFINTERVAL     *_pIntervalCache;

    HSFINTERVAL       *_pIntervalCur;
    class StrHash     *_pshHashTable;     // used to keep track of what I gave out
    class OrderedList *_polFrequentPages; // used to store most frequently viewed pgs
    IEnumSTATURL      *_pstatenum;        // used in search enumerator
    TCHAR   _szLocalHost[INTERNET_MAX_HOST_NAME_LENGTH]; //  "My Computer"  cached...

    static BOOL_PTR s_DoCacheSearch(LPINTERNET_CACHE_ENTRY_INFO pcei,
                                LPTSTR pszUserName, UINT uUserNameLen, CHistFolderEnum *penum,
                                class _CurrentSearches *pcsThisThread, IUrlHistoryPriv *pUrlHistStg);
    static DWORD WINAPI s_CacheSearchThreadProc(CHistFolderEnum *penum);
};


//////////////////////////////////////////////////////////////////////////////
//
// CHistFolder Object
//
//////////////////////////////////////////////////////////////////////////////

class CHistFolder : 
    public IShellFolder2, 
    public IShellIcon, 
    public IShellFolderViewType,
    public IShellFolderSearchable,
    public IHistSFPrivate,
    public IPersistFolder2
{
    friend CHistFolderEnum;
    friend CHistItem;
    friend HRESULT HistFolderView_CreateInstance(CHistFolder *pHCFolder, void **ppvOut);
    friend HRESULT HistFolderView_DidDragDrop(IDataObject *pdo, DWORD dwEffect);
        
public:
    CHistFolder(FOLDER_TYPE FolderType);

public:
    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
   
    // IShellFolder methods
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pszDisplayName, 
        ULONG *pchEaten, LPITEMIDLIST *ppidl, ULONG *pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList);
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvOut);
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvObj);
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHODIMP CreateViewObject(HWND hwnd, REFIID riid, void **ppvOut);
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG *rgfInOut);
    STDMETHODIMP GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl,
            REFIID riid, UINT * prgfInOut, void **ppvOut);
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl,
            LPCOLESTR lpszName, DWORD uFlags, LPITEMIDLIST * ppidlOut);

    // IShellFolder2
    STDMETHODIMP GetDefaultSearchGUID(LPGUID lpGuid) { return E_NOTIMPL; };
    STDMETHODIMP EnumSearches(LPENUMEXTRASEARCH *ppenum) { *ppenum = NULL; return E_NOTIMPL; };
    STDMETHODIMP GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay);
    STDMETHODIMP GetDefaultColumnState(UINT iColumn, DWORD *pbState) { return E_NOTIMPL; };
    STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv) { return E_NOTIMPL; };
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails);
    STDMETHODIMP MapColumnToSCID(UINT iCol, SHCOLUMNID *pscid) { return E_NOTIMPL; };

    // IShellIcon
    STDMETHODIMP GetIconOf(LPCITEMIDLIST pidl, UINT flags, LPINT lpIconIndex);

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pClassID);
    // IPersistFolder
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);
    // IPersistFolder2 Methods
    STDMETHODIMP GetCurFolder(LPITEMIDLIST *ppidl);

    // IShellFolderViewType Methods
    STDMETHODIMP EnumViews(ULONG grfFlags, IEnumIDList ** ppenum);
    STDMETHODIMP GetDefaultViewName(DWORD uFlags, LPWSTR *ppwszName);
    STDMETHODIMP GetViewTypeProperties(LPCITEMIDLIST pidl, DWORD *pdwFlags);
    STDMETHODIMP TranslateViewPidl(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlView,
                                   LPITEMIDLIST *pidlOut);

    // IShellFolderSearchable Methods
    STDMETHODIMP FindString(LPCWSTR pwszTarget, DWORD *pdwFlags,
                            IUnknown *punkOnAsyncSearch, LPITEMIDLIST *ppidlOut);
    STDMETHODIMP CancelAsyncSearch(LPCITEMIDLIST pidlSearch, DWORD *pdwFlags);
    STDMETHODIMP InvalidateSearch(LPCITEMIDLIST pidlSearch, DWORD *pdwFlags);
    
    // IHistSFPrivate
    STDMETHODIMP SetCachePrefix(LPCWSTR pszCachePrefix);
    STDMETHODIMP SetDomain(LPCWSTR pszDomain);
    STDMETHODIMP WriteHistory(LPCWSTR pszPrefixedUrl, FILETIME ftExpires, 
                              FILETIME ftModified, LPITEMIDLIST * ppidlSelect);
    STDMETHODIMP ClearHistory();
    
    HRESULT _ExtractInfoFromPidl();

protected:
    ~CHistFolder();
    
    STDMETHODIMP _GetDetail(LPCITEMIDLIST pidl, UINT iColumn, LPTSTR pszStr, UINT cchStr);

    void _GetHistURLDispName(LPHEIPIDL phei, LPTSTR pszStr, UINT cchStr);

    HRESULT _CompareAlignedIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    HRESULT _CopyTSTRField(LPTSTR *ppszField, LPCTSTR pszValue);
    HRESULT _LoadIntervalCache();
    HRESULT _GetInterval(FILETIME *pftItem, BOOL fWeekOnly, HSFINTERVAL **pInterval);
    HRESULT _CreateInterval(FILETIME *pftStart, DWORD dwDays);
    HRESULT _PrefixUrl(LPCTSTR pszStrippedUrl,
                     FILETIME *pftLastModifiedTime,
                     LPTSTR pszPrefixedUrl,
                     DWORD cbPrefixedUrl);
    HRESULT _CopyEntries(LPCTSTR pszHistPrefix);
    HRESULT _DeleteEntries(LPCTSTR pszHistPrefix, PFNDELETECALLBACK pfnDeleteFilter, LPVOID pdcbData);
    HRESULT _DeleteInterval(HSFINTERVAL *pInterval);
    HRESULT _CleanUpHistory(FILETIME ftLimit, FILETIME ftTommorrow);
    HRESULT _ValidateIntervalCache();
    HRESULT _GetPrefixForInterval(LPCTSTR pszInterval, LPCTSTR *ppszCachePrefix);
    HRESULT _ViewType_NotifyEvent(LPITEMIDLIST pidlRoot,
                                  LPITEMIDLIST pidlHost,
                                  LPITEMIDLIST pidlPage,
                                  LONG         wEventId);

    HRESULT _WriteHistory(LPCTSTR pszPrefixedUrl, FILETIME ftExpires, FILETIME ftModified, 
                          BOOL fSendNotify, LPITEMIDLIST * ppidlSelect);
    HRESULT _NotifyWrite(LPTSTR pszUrl, int cchUrl, FILETIME *pftModified, LPITEMIDLIST * ppidlSelect);
    HRESULT _NotifyInterval(HSFINTERVAL *pInterval, LONG lEventID);
    IUrlHistoryPriv *_GetHistStg();
    HRESULT _EnsureHistStg();
    HRESULT _GetUserName(LPTSTR pszUserName, DWORD cchUserName);
    HRESULT _GetInfoTip(LPCITEMIDLIST pidl, DWORD dwFlags, WCHAR **ppwszTip);
    HRESULT _DeleteItems(LPCITEMIDLIST *ppidl, UINT cidl);
    LPITEMIDLIST _HostPidl(LPCTSTR pszHostUrl, HSFINTERVAL *pInterval);
    DWORD    _SearchFlatCacheForUrl(LPCTSTR pszUrl, LPINTERNET_CACHE_ENTRY_INFO pcei, DWORD *pdwBuffSize);
    
    HRESULT _ViewPidl_BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
    HRESULT _ViewType_BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
    HRESULT _ViewType_CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    int     _View_ContinueCompare(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    HRESULT _DeleteUrlFromBucket(LPCTSTR pszPrefixedUrl);
    HRESULT _ViewType_DeleteItems(LPCITEMIDLIST *ppidl, UINT cidl);
    HRESULT _ViewBySite_DeleteItems(LPCITEMIDLIST *ppidl, UINT cidl);
    HRESULT _ViewType_NotifyUpdateAll();
    HRESULT _ViewType_GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG *prgfInOut);
    HRESULT _DeleteUrlHistoryGlobal(LPCTSTR pszUrl);
    DWORD   _GetHitCount(LPCTSTR pszUrl);
    LPHEIPIDL _CreateHCacheFolderPidlFromUrl(BOOL fOleMalloc, LPCTSTR pszPrefixedUrl);

    BOOL _IsLeaf();    
    
    LPCTSTR _GetLocalHost(void);

    LONG            _cRef;
    FOLDER_TYPE     _foldertype;
    TCHAR           *_pszCachePrefix;
    TCHAR           *_pszDomain;

    DWORD           _dwIntervalCached;
    FILETIME        _ftDayCached;
    int             _cbIntervals;
    HSFINTERVAL     *_pIntervalCache;
    BOOL            _fValidatingCache;

    UINT            _uFlags;    // copied from CacheFolder struct
    LPITEMIDLIST    _pidl;      // copied from CacheFolder struct
    LPITEMIDLIST    _pidlRest;  // suffix of _pidl
    IUrlHistoryPriv *_pUrlHistStg;  // used to get extended properties of history leafs

    UINT            _uViewType; // if this shell folder is implementing a special view
    UINT            _uViewDepth; // depth of the pidl

    const static DWORD    _rdwFlagsTable[];

    TCHAR   _szLocalHost[INTERNET_MAX_HOST_NAME_LENGTH]; //  "My Computer"  cached...

    class _CurrentSearches *_pcsCurrentSearch; // for CacheSearches
    static HRESULT CALLBACK _sViewCallback(IShellView *psv, IShellFolder *psf, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

////////////////////////////////////////////////////////////////////////////
//
// CHistItem Object
//
////////////////////////////////////////////////////////////////////////////

class CHistItem : public CBaseItem
{
    // CHistItem interfaces
    friend HRESULT HistFolderView_DidDragDrop(IDataObject *pdo, DWORD dwEffect);

public:
    CHistItem();
    HRESULT Initialize(CHistFolder *pHCFolder, HWND hwnd, UINT cidl, LPCITEMIDLIST *ppidl);

    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID,void **);

    // IQueryInfo Methods
    STDMETHODIMP GetInfoTip(DWORD dwFlags, WCHAR **ppwszTip);

    // IContextMenu Methods
    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst,
                                  UINT idCmdLast, UINT uFlags);
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);

    // IDataObject Methods...
    STDMETHODIMP GetData(LPFORMATETC pFEIn, LPSTGMEDIUM pSTM);
    STDMETHODIMP QueryGetData(LPFORMATETC pFE);
    STDMETHODIMP EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC *ppEnum);

    // IExtractIconA Methods
    STDMETHODIMP GetIconLocation(UINT uFlags, LPSTR pszIconFile, UINT ucchMax, PINT pniIcon, PUINT puFlags);

protected:
    ~CHistItem();

    virtual LPCTSTR _GetUrl(int nIndex);
    virtual UNALIGNED const TCHAR* _GetURLTitle(LPCITEMIDLIST pcei);
    virtual LPCTSTR _PidlToSourceUrl(LPCITEMIDLIST pidl);
    BOOL _ZoneCheck(int nIndex, DWORD dwUrlAction);

    FOLDER_TYPE       _foldertype;  // are we a history item or cache item
    CHistFolder* _pHCFolder;   // back pointer to our shell folder
    static INT_PTR CALLBACK _sPropDlgProc(HWND, UINT, WPARAM, LPARAM);
    HRESULT _CreateFileDescriptorW(STGMEDIUM *pSTM);

};

#endif // __cplusplus

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\hist\hsfitem.cpp ===
#include "local.h"
#include "../security.h"
#include "../favorite.h"
#include "resource.h"
#include "chcommon.h"
#include "hsfolder.h"

#include <mluisupp.h>

#define DM_HSFOLDER 0

STDAPI  AddToFavorites(HWND hwnd, LPCITEMIDLIST pidlCur, LPCTSTR pszTitle,
                       BOOL fDisplayUI, IOleCommandTarget *pCommandTarget, IHTMLDocument2 *pDoc);

#define MAX_ITEM_OPEN 10

static LPCTSTR _GetURLTitleForDisplay(LPBASEPIDL pcei, LPTSTR szBuf, DWORD cchBuf);

static BOOL _ValidateIDListArray(UINT cidl, LPCITEMIDLIST *ppidl)
{
    UINT i;

    for (i = 0; i < cidl; i++)
    {
        if (!_IsValid_IDPIDL(ppidl[i])  && !_IsValid_HEIPIDL(ppidl[i]))
            return FALSE;
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
// CHistItem Object
//
//////////////////////////////////////////////////////////////////////////////


CHistItem::CHistItem() 
{
}        

CHistItem::~CHistItem()
{
    if (_pHCFolder)
        _pHCFolder->Release();          // release the pointer to the sf
}

HRESULT CHistItem::Initialize(CHistFolder *pHCFolder, HWND hwnd, UINT cidl, LPCITEMIDLIST *ppidl)
{
    HRESULT hres = CBaseItem::Initialize(hwnd, cidl, ppidl);
    if (SUCCEEDED(hres))
    {
        _pHCFolder = pHCFolder;
        _pHCFolder->AddRef();      // we're going to hold onto this pointer, so
    }
    return hres;
}        

HRESULT CHistItem_CreateInstance(CHistFolder *pHCFolder, HWND hwnd,
    UINT cidl, LPCITEMIDLIST *ppidl, REFIID riid, void **ppv)
{
    HRESULT hr;

    *ppv = NULL;                 // null the out param

    if (!_ValidateIDListArray(cidl, ppidl))
        return E_FAIL;

    CHistItem *pHCItem = new CHistItem;
    if (pHCItem)
    {
        hr = pHCItem->Initialize(pHCFolder, hwnd, cidl, ppidl);
        if (SUCCEEDED(hr))
            hr = pHCItem->QueryInterface(riid, ppv);
        pHCItem->Release();
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

//////////////////////////////////
//
// IUnknown Methods...
//
HRESULT CHistItem::QueryInterface(REFIID iid, void **ppv)
{
    HRESULT hres = CBaseItem::QueryInterface(iid, ppv);

    if (FAILED(hres) && iid == IID_IHist) 
    {
        *ppv = (LPVOID)this;    // for our friends
        AddRef();
        hres = S_OK;
    }
    return hres;
}

//////////////////////////////////
//
// IQueryInfo Methods
//
HRESULT CHistItem::GetInfoTip(DWORD dwFlags, WCHAR **ppwszTip)
{
    return _pHCFolder->_GetInfoTip(_ppidl[0], dwFlags, ppwszTip);
}

//////////////////////////////////
//
// IContextMenu Methods
//
HRESULT CHistItem::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst,UINT idCmdLast, UINT uFlags)
{
    USHORT cItems;

    TraceMsg(DM_HSFOLDER, "hci - cm - QueryContextMenu() called.");
    
    if ((uFlags & CMF_VERBSONLY) || (uFlags & CMF_DVFILE))
    {
        cItems = MergePopupMenu(&hmenu, POPUP_CONTEXT_URL_VERBSONLY, 0, indexMenu, 
            idCmdFirst, idCmdLast);
    
    }
    else  // (uFlags & CMF_NORMAL)
    {
        UINT idResource = POPUP_CACHECONTEXT_URL;

        // always use the cachecontext menu unless:
        if ( ((_pHCFolder->_uViewType == VIEWPIDL_ORDER_SITE) &&
              (_pHCFolder->_uViewDepth == 0))                      ||
             (!IsLeaf(_pHCFolder->_foldertype)) )
            idResource = POPUP_HISTORYCONTEXT_URL;

        cItems = MergePopupMenu(&hmenu, idResource, 0, indexMenu, idCmdFirst, idCmdLast);

        if (IsInetcplRestricted(L"History"))
        {
            DeleteMenu(hmenu, RSVIDM_DELCACHE + idCmdFirst, MF_BYCOMMAND);
            _SHPrettyMenu(hmenu);
        }
    }
    if (hmenu)
        SetMenuDefaultItem(hmenu, indexMenu, MF_BYPOSITION);

    return ResultFromShort(cItems);    // number of menu items    
}

STDMETHODIMP CHistItem::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    UINT i;
    int idCmd = _GetCmdID(pici->lpVerb);
    HRESULT hres = S_OK;
    DWORD dwAction;
    BOOL fCancelCopyAndOpen = FALSE;
    BOOL fZonesUI = FALSE;
    BOOL fMustFlushNotify = FALSE;
    BOOL fBulkDelete;

    TraceMsg(DM_HSFOLDER, "hci - cm - InvokeCommand() called.");

    if (idCmd == RSVIDM_DELCACHE)
    {
        TCHAR szBuff[INTERNET_MAX_URL_LENGTH+MAX_PATH];
        TCHAR szFormat[MAX_PATH];
                
        if (_cItems == 1)          
        {
            TCHAR szTitle[MAX_URL_STRING];

            if (_pHCFolder->_foldertype != FOLDER_TYPE_Hist)
            {
                _GetURLDispName((LPBASEPIDL)_ppidl[0], szTitle, ARRAYSIZE(szTitle));
            }
            else
            {
                FILETIME ftStart, ftEnd;
                LPCUTSTR pszIntervalName = _GetURLTitle(_ppidl[0]);

                if (SUCCEEDED(_ValueToIntervalW(pszIntervalName, &ftStart, &ftEnd)))
                {
                    GetDisplayNameForTimeInterval(&ftStart, &ftEnd, szTitle, ARRAYSIZE(szTitle));
                }
            }

            MLLoadString(IDS_WARN_DELETE_HISTORYITEM, szFormat, ARRAYSIZE(szFormat));
            wnsprintf(szBuff, ARRAYSIZE(szBuff), szFormat, szTitle);
        }
        else
        {
            MLLoadString(IDS_WARN_DELETE_MULTIHISTORY, szFormat, ARRAYSIZE(szFormat));
            wnsprintf(szBuff, ARRAYSIZE(szBuff), szFormat, _cItems);
        }
        if (DialogBoxParam(MLGetHinst(),
                             MAKEINTRESOURCE(DLG_HISTCACHE_WARNING),
                             pici->hwnd,
                             HistoryConfirmDeleteDlgProc,
                             (LPARAM)szBuff) != IDYES)
        {
            return S_FALSE;
        }
        return _pHCFolder->_DeleteItems(_ppidl, _cItems);
    }

    // ZONES SECURITY CHECK.
    //
    // We need to cycle through each action and Zone Check the URLs.
    // We pass NOUI when zone checking the URLs because we don't want info
    // displayed to the user.  We will stop when we find the first questionable
    // URL.  We will then 
    for (i = 0; (i < _cItems) && !fZonesUI; i++)
    {
        if (_ppidl[i]) 
        {
            switch (idCmd)
            {
            case RSVIDM_OPEN:
                if ((i < MAX_ITEM_OPEN) && _pHCFolder->_IsLeaf())
                {
                    if (!_ZoneCheck(i, URLACTION_SHELL_VERB))
                    {
                        fZonesUI = TRUE;
                        dwAction = URLACTION_SHELL_VERB;
                    }
                }
                break;

            case RSVIDM_COPY:
                if (_pHCFolder->_IsLeaf())
                {
                    if (!_ZoneCheck(i, URLACTION_SHELL_MOVE_OR_COPY))
                    {
                        fZonesUI = TRUE;
                        dwAction = URLACTION_SHELL_MOVE_OR_COPY;
                    }
                }
                break;
            }
        }
    }

    if (fZonesUI)
    {
        LPCTSTR pszUrl = _GetUrl(i-1);  // Sub 1 because of for loop above.
        if (S_OK != ZoneCheckUrl(pszUrl, dwAction, PUAF_DEFAULT|PUAF_WARN_IF_DENIED, NULL))
        {
            // The user cannot do this or does not want to do this.
            fCancelCopyAndOpen = TRUE;
        }
    }

    i = _cItems;

    // NOTE (andrewgu): ie5.5 b#108361
    // 1. on older versions of the shell, first deleting the items and then calling 
    //    SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_IDLIST, _pHCFolder->_pidl, NULL) doesn't trigger a refresh;
    // 2. but deleting an item and then calling calling
    //    SHChangeNotify(SHCNE_DELETE, SHCNF_IDLIST, ILCombine(_pHCFolder->_pidl, (LPITEMIDLIST)(_ppcei[i])), NULL) does;
    // 3. so the fix is to not set fBulkDelete on older versions of the shell.
    if (5 <= GetUIVersion())
        fBulkDelete = i > LOTS_OF_FILES;
    else
        fBulkDelete = FALSE;

    // fCancelCopyAndOpen happens if the user cannot or chose not to proceed.
    while (i && !fCancelCopyAndOpen)
    {
        i--;
        if (_ppidl[i]) 
        {

            switch (idCmd)
            {
            case RSVIDM_OPEN:
                ASSERT(!_pHCFolder->_uViewType);
                if (i >= MAX_ITEM_OPEN)
                {
                    hres = S_FALSE;
                    goto Done;
                }

                if (!IsLeaf(_pHCFolder->_foldertype))
                {
                    LPITEMIDLIST pidlOpen;
                    
                    hres = S_FALSE;
                    pidlOpen = ILCombine(_pHCFolder->_pidl, _ppidl[i]);
                    if (pidlOpen)
                    {
                        IShellBrowser *psb = FileCabinet_GetIShellBrowser(_hwndOwner);
                        if (psb)
                        {
                            psb->AddRef();
                            psb->BrowseObject(pidlOpen, 
                                        (i==_cItems-1) ? SBSP_DEFBROWSER:SBSP_NEWBROWSER);
                            psb->Release();
                            hres = S_OK;
                        }
                        else
                        {
                            hres = _LaunchAppForPidl(pici->hwnd, pidlOpen);
                        }
                        ILFree(pidlOpen);
                    }
                }
                else
                {
                    TCHAR szDecoded[MAX_URL_STRING];
                    ConditionallyDecodeUTF8(_GetUrl(i), szDecoded, ARRAYSIZE(szDecoded));

                    hres = _LaunchApp(pici->hwnd, szDecoded);
                }
                break;

            case RSVIDM_ADDTOFAVORITES:
                hres = _AddToFavorites(i);
                goto Done;
            case RSVIDM_OPEN_NEWWINDOW:
                {
                    LPCTSTR pszUrl = _GetUrl(i);
                    if (pszUrl)
                    {
                        TCHAR szDecoded[MAX_URL_STRING];
                        ConditionallyDecodeUTF8(_GetUrl(i), szDecoded, ARRAYSIZE(szDecoded));
                        LPWSTR pwszTarget;
                    
                        if (SUCCEEDED((hres = SHStrDup(szDecoded, &pwszTarget)))) {
                            hres = NavToUrlUsingIEW(pwszTarget, TRUE);
                            CoTaskMemFree(pwszTarget);
                        }
                    }
                    else
                    {
                        hres = E_FAIL;
                    }
                    goto Done;
                }
            case RSVIDM_COPY:
                if (!_pHCFolder->_IsLeaf())
                {
                    hres = E_FAIL;
                }
                else
                {
                    OleSetClipboard((IDataObject *)this);
                }
                goto Done;

            case RSVIDM_DELCACHE:
                ASSERT(!_pHCFolder->_uViewType);                
//                if (IsHistory(_pHCFolder->_foldertype))
                hres = E_FAIL;
                break;

            case RSVIDM_PROPERTIES:
                // NOTE: We'll probably want to split this into two cases
                // and call a function in each case
                //
                if (IsLeaf(_pHCFolder->_foldertype))
                {
                    // this was a bug in IE4, too:
                    //   the pidl is re-created so that it has the most up-to-date information
                    //   possible -- this way we can avoid assuming that the NSC has cached the
                    //   most up-to-date pidl (which, in most cases, it hasn't)
                    LPHEIPIDL pidlTemp =
                        _pHCFolder->_CreateHCacheFolderPidlFromUrl(FALSE,
                            HPidlToSourceUrl( (LPBASEPIDL)_ppidl[i]));
                    if (pidlTemp) {
                        TCHAR szTitle[MAX_URL_STRING];
                        _GetURLTitleForDisplay((LPBASEPIDL)pidlTemp, szTitle, ARRAYSIZE(szTitle));
                        _CreatePropSheet(pici->hwnd, (LPCITEMIDLIST)pidlTemp,
                             DLG_HISTITEMPROP, _sPropDlgProc, szTitle);
                        LocalFree(pidlTemp);
                        pidlTemp = NULL;
                    }
                }
                else
                {
                    hres = E_FAIL;
                }
                goto Done;

            default:
                hres = E_FAIL;
                break;
            }
            
            ASSERT(SUCCEEDED(hres));
            if (FAILED(hres))
                TraceMsg(DM_HSFOLDER, "Cachevu failed the command at: %s", HPidlToSourceUrl((LPBASEPIDL)_ppidl[i]));
        }
    }
Done:
    if (fMustFlushNotify)
    {
        if (fBulkDelete)
        {
            ASSERT(!_pHCFolder->_uViewType);
            _GenerateEvent(SHCNE_UPDATEDIR, _pHCFolder->_pidl, NULL, NULL);
        }

        SHChangeNotifyHandleEvents();
    }
    return hres;
}

//////////////////////////////////
//
// IDataObject Methods...
//

HRESULT CHistItem::GetData(LPFORMATETC pFEIn, LPSTGMEDIUM pSTM)
{
    HRESULT hres;

#ifdef DEBUG
    TCHAR szName[64];
    if (!GetClipboardFormatName(pFEIn->cfFormat, szName, sizeof(szName)))
        wnsprintf(szName, ARRAYSIZE(szName), TEXT("#%d"), pFEIn->cfFormat);

    TraceMsg(DM_HSFOLDER, "hci - do - GetData(%s)", szName);
#endif

    pSTM->hGlobal = NULL;
    pSTM->pUnkForRelease = NULL;

    if ((pFEIn->cfFormat == g_cfFileDescW) && (pFEIn->tymed & TYMED_HGLOBAL))
        hres = _CreateFileDescriptorW(pSTM);

    else if ((pFEIn->cfFormat == g_cfFileDescA) && (pFEIn->tymed & TYMED_HGLOBAL))
        hres = _CreateFileDescriptorA(pSTM);

    else if ((pFEIn->cfFormat == g_cfFileContents) && (pFEIn->tymed & TYMED_ISTREAM))
        hres = _CreateFileContents(pSTM, pFEIn->lindex);

    else if (pFEIn->cfFormat == CF_UNICODETEXT && (pFEIn->tymed & TYMED_HGLOBAL))
        hres = _CreateUnicodeTEXT(pSTM);

    else if (pFEIn->cfFormat == CF_TEXT && (pFEIn->tymed & TYMED_HGLOBAL))
        hres = _CreateHTEXT(pSTM);

    else if (pFEIn->cfFormat == g_cfURL && (pFEIn->tymed & TYMED_HGLOBAL))
        hres = _CreateURL(pSTM);

    else if ((pFEIn->cfFormat == g_cfPreferredEffect) && (pFEIn->tymed & TYMED_HGLOBAL))
        hres = _CreatePrefDropEffect(pSTM);

    else
        hres = DATA_E_FORMATETC;
    return hres;
}

HRESULT CHistItem::QueryGetData(LPFORMATETC pFEIn)
{
#ifdef DEBUG
    TCHAR szName[64];
    if (!GetClipboardFormatName(pFEIn->cfFormat, szName, sizeof(szName)))
        wnsprintf(szName, ARRAYSIZE(szName), TEXT("#%d"), pFEIn->cfFormat);

    TraceMsg(DM_HSFOLDER, "hci - do - QueryGetData(%s)", szName);
#endif

    if (pFEIn->cfFormat == g_cfFileDescW ||
        pFEIn->cfFormat == g_cfFileDescA ||
        pFEIn->cfFormat == g_cfFileContents   ||
        pFEIn->cfFormat == g_cfURL            ||
        pFEIn->cfFormat == CF_UNICODETEXT     ||
        pFEIn->cfFormat == CF_TEXT            ||
        pFEIn->cfFormat == g_cfPreferredEffect)
    {
        TraceMsg(DM_HSFOLDER, "		   format supported.");
        return NOERROR;
    }
    return S_FALSE;
}

HRESULT CHistItem::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC *ppEnum)
{
    FORMATETC Histfmte[] = {
        {g_cfFileDescW,       NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        {g_cfFileDescA,       NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        {g_cfFileContents,    NULL, DVASPECT_CONTENT, -1, TYMED_ISTREAM },
        {g_cfURL,             NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        {CF_UNICODETEXT,      NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        {CF_TEXT,             NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        {g_cfPreferredEffect, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
    };
    return SHCreateStdEnumFmtEtc(ARRAYSIZE(Histfmte), Histfmte, ppEnum);
}

//////////////////////////////////
//
// IExtractIconA Methods...
//
HRESULT CHistItem::GetIconLocation(UINT uFlags, LPSTR pszIconFile, UINT ucchMax, PINT pniIcon, PUINT puFlags)
{
    int cbIcon;

    if (_pHCFolder->_uViewType) {
        switch (_pHCFolder->_uViewType) {
        case VIEWPIDL_SEARCH:
        case VIEWPIDL_ORDER_FREQ:
        case VIEWPIDL_ORDER_TODAY:
            cbIcon = IDI_HISTURL;
            break;
        case VIEWPIDL_ORDER_SITE:
            switch(_pHCFolder->_uViewDepth) {
            case 0: cbIcon = (uFlags & GIL_OPENICON) ? IDI_HISTOPEN:IDI_HISTFOLDER; break;
            case 1: cbIcon = IDI_HISTURL; break;
            }
            break;
        default:
            return E_FAIL;
        }
    }
    else {
        switch (_pHCFolder->_foldertype)
        {
        case FOLDER_TYPE_Hist:
            cbIcon = IDI_HISTWEEK;
            break;
        case FOLDER_TYPE_HistInterval:
            cbIcon = (uFlags & GIL_OPENICON) ? IDI_HISTOPEN:IDI_HISTFOLDER;
            break;
        case FOLDER_TYPE_HistDomain:
            cbIcon = IDI_HISTURL;
            break;
        default:
            return E_FAIL;
        }
    }
    *puFlags = 0;
    *pniIcon = -cbIcon;
    StrCpyNA(pszIconFile, "shdocvw.dll", ucchMax);
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// Helper Routines
//
//////////////////////////////////////////////////////////////////////////////

UNALIGNED const TCHAR* _GetURLTitle(LPBASEPIDL pcei)
{
    if (pcei->usSign == HEIPIDL_SIGN)
    {
        LPHEIPIDL phei = (LPHEIPIDL) pcei;

        if (phei->usTitle == 0)
        {
            const TCHAR* psz = _StripHistoryUrlToUrl(HPidlToSourceUrl((LPBASEPIDL)pcei));

            return psz ? _FindURLFileName(psz) : TEXT("");
        }
        else
        {
            return (LPTSTR)(((BYTE*)phei)+phei->usTitle);
        }
    }
    else if (VALID_IDSIGN(pcei->usSign))
    {
        return ((LPHIDPIDL)pcei)->szID;
    }
    else 
    {
        return TEXT("");
    }
}    

static LPCTSTR _GetURLTitleForDisplay(LPBASEPIDL pcei, LPTSTR szBuf, DWORD cchBuf)
{
    TCHAR szTitle[MAX_URL_STRING];
    if (!_URLTitleIsURL(pcei) ||
        FAILED(PrepareURLForDisplayUTF8(_GetURLTitleAlign(pcei, szTitle, ARRAYSIZE(szTitle)), szBuf, &cchBuf, TRUE)))
    {
        ualstrcpyn(szBuf, _GetURLTitle(pcei), cchBuf);
    }
        
    return szBuf;
}

UNALIGNED const TCHAR* CHistItem::_GetURLTitle(LPCITEMIDLIST pidl)
{
    return ::_GetURLTitle( (LPBASEPIDL)pidl);
}

LPCTSTR CHistItem::_GetUrl(int nIndex)
{
    return _StripHistoryUrlToUrl(HPidlToSourceUrl((LPBASEPIDL)_ppidl[nIndex]));
}

LPCTSTR CHistItem::_PidlToSourceUrl(LPCITEMIDLIST pidl)
{
    return HPidlToSourceUrl((LPBASEPIDL) pidl);
}


// Return value:
//               TRUE - URL is Safe.
//               FALSE - URL is questionable and needs to be re-zone checked w/o PUAF_NOUI.
BOOL CHistItem::_ZoneCheck(int nIndex, DWORD dwUrlAction)
{
    LPCTSTR pszUrl = _GetUrl(nIndex);

    // Yes, then consider anything that is not
    // a FILE URL safe.

    int nScheme = GetUrlScheme(pszUrl);
    if (URL_SCHEME_FILE != nScheme)
        return TRUE;        // It's safe because it's not a file URL.

    if (S_OK != ZoneCheckUrl(pszUrl, dwUrlAction, PUAF_NOUI, NULL))
        return FALSE;

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
// Helper Routines
//
//////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK CHistItem::_sPropDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE) GetWindowLongPtr(hDlg, DWLP_USER);
    LPHEIPIDL phei = lpPropSheet ? (LPHEIPIDL)lpPropSheet->lParam : NULL;

    switch(message) {

        case WM_INITDIALOG:
        {
            SHFILEINFO sfi;
            TCHAR szBuf[80];
            TCHAR szDisplayUrl[INTERNET_MAX_URL_LENGTH];

            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
            phei = (LPHEIPIDL)((LPPROPSHEETPAGE)lParam)->lParam;

            SHGetFileInfo(TEXT(".url"), 0, &sfi, SIZEOF(sfi), SHGFI_ICON |
                SHGFI_USEFILEATTRIBUTES | SHGFI_SYSICONINDEX | SHGFI_TYPENAME);

            SendDlgItemMessage(hDlg, IDD_ITEMICON, STM_SETICON, (WPARAM)sfi.hIcon, 0);

            _GetURLTitleForDisplay((LPBASEPIDL)phei, szDisplayUrl, ARRAYSIZE(szDisplayUrl));
            SetDlgItemText(hDlg, IDD_TITLE, szDisplayUrl);
            
            SetDlgItemText(hDlg, IDD_FILETYPE, sfi.szTypeName);
            
            ConditionallyDecodeUTF8(_GetUrlForPidl((LPCITEMIDLIST)phei), szDisplayUrl, ARRAYSIZE(szDisplayUrl));
            SetDlgItemText(hDlg, IDD_INTERNET_ADDRESS, szDisplayUrl);

            FileTimeToDateTimeStringInternal(&phei->ftLastVisited, szBuf, ARRAYSIZE(szBuf), FALSE);
            SetDlgItemText(hDlg, IDD_LAST_VISITED, szBuf);

            // It looks like the hitcount is double what it is supposed to be
            //  (ie - navigate to a site and hitcount += 2)
            // For now, we'll just half the hitcount before we display it:

            // Above statement is no longer true -- hitcount is correct.  Removed the halving of hitcount.
            wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%d"), (phei->dwNumHits)) ;
            SetDlgItemText(hDlg, IDD_NUMHITS, szBuf);

            break;            
        }
        
        
        case WM_DESTROY:
            {
                HICON hIcon = (HICON)SendDlgItemMessage(hDlg, IDD_ITEMICON, STM_GETICON, 0, 0);
                if (hIcon)
                    DestroyIcon(hIcon);
            }
            break;

        case WM_COMMAND:
        case WM_HELP:
        case WM_CONTEXTMENU:
            // user can't change anything, so we don't care about any messages

            break;

        default:
            return FALSE;
            
    } // end of switch
    
    return TRUE;
}

HRESULT CHistItem::_CreateFileDescriptorW(LPSTGMEDIUM pSTM)
{
    
    pSTM->tymed = TYMED_HGLOBAL;
    pSTM->pUnkForRelease = NULL;
    
    FILEGROUPDESCRIPTORW *pfgd = (FILEGROUPDESCRIPTORW*)GlobalAlloc(GPTR, sizeof(FILEGROUPDESCRIPTORW) + (_cItems-1) * sizeof(FILEDESCRIPTORW));
    if (pfgd == NULL)
    {
        TraceMsg(DM_HSFOLDER, "hci -   Couldn't alloc file descriptor");
        return E_OUTOFMEMORY;
    }
    
    pfgd->cItems = _cItems;     // set the number of items

    for (UINT i = 0; i < _cItems; i++)
    {
        FILEDESCRIPTORW *pfd = &(pfgd->fgd[i]);
        
        _GetURLTitleForDisplay((LPBASEPIDL)_ppidl[i], pfd->cFileName, ARRAYSIZE(pfd->cFileName));
        
        MakeLegalFilenameW(pfd->cFileName);

        UINT cchFilename = lstrlenW(pfd->cFileName);
        SHTCharToUnicode(L".URL", pfd->cFileName+cchFilename, ARRAYSIZE(pfd->cFileName)-cchFilename);
    }

    pSTM->hGlobal = pfgd;
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\hist\hsfolder.cpp ===
#include "local.h"

#include "resource.h"
#include "cachesrch.h"
#include "sfview.h"
#include <shlwapi.h>
#include <limits.h>
#include "chcommon.h"
#include "hsfolder.h"

#include <mluisupp.h>

#define DM_HSFOLDER 0

#define DM_CACHESEARCH 0x40000000

const TCHAR c_szRegKeyTopNSites[] = TEXT("HistoryTopNSitesView");
#define REGKEYTOPNSITESLEN (ARRAYSIZE(c_szRegKeyTopNSites) - 1)

const TCHAR c_szHistPrefix[] = TEXT("Visited: ");
#define HISTPREFIXLEN (ARRAYSIZE(c_szHistPrefix)-1)
const TCHAR c_szHostPrefix[] = TEXT(":Host: ");
#define HOSTPREFIXLEN (ARRAYSIZE(c_szHostPrefix)-1)
const CHAR c_szIntervalPrefix[] = "MSHist";
#define INTERVALPREFIXLEN (ARRAYSIZE(c_szIntervalPrefix)-1)
const TCHAR c_szTextHeader[] = TEXT("Content-type: text/");
#define TEXTHEADERLEN (ARRAYSIZE(c_szTextHeader) - 1)
const TCHAR c_szHTML[] = TEXT("html");
#define HTMLLEN (ARRAYSIZE(c_szHTML) - 1)
#define TYPICAL_INTERVALS (4+7)


#define ALL_CHANGES (SHCNE_DELETE|SHCNE_MKDIR|SHCNE_RMDIR|SHCNE_CREATE|SHCNE_UPDATEDIR)

#define FORMAT_PARAMS (FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY|FORMAT_MESSAGE_MAX_WIDTH_MASK)

DWORD     _DaysInInterval(HSFINTERVAL *pInterval);
void      _KeyForInterval(HSFINTERVAL *pInterval, LPTSTR pszInterval, int cchInterval);
void      _FileTimeDeltaDays(FILETIME *pftBase, FILETIME *pftNew, int Days);

//  BEGIN OF JCORDELL CODE
#define QUANTA_IN_A_SECOND  10000000
#define SECONDS_IN_A_DAY    60 * 60 * 24
#define QUANTA_IN_A_DAY     ((__int64) QUANTA_IN_A_SECOND * SECONDS_IN_A_DAY)
#define INT64_VALUE(pFT)    ((((__int64)(pFT)->dwHighDateTime) << 32) + (__int64) (pFT)->dwLowDateTime)
#define DAYS_DIFF(s,e)      ((int) (( INT64_VALUE(s) - INT64_VALUE(e) ) / QUANTA_IN_A_DAY))

BOOL      GetDisplayNameForTimeInterval( const FILETIME *pStartTime, const FILETIME *pEndTime,
                                         TCHAR *szBuffer, int cbBufferLength );
BOOL      GetTooltipForTimeInterval( const FILETIME *pStartTime, const FILETIME *pEndTime,
                                     TCHAR *szBuffer, int cbBufferLength );
//  END OF JCORDELL CODE


//////////////////////////////////////////////////////////////////////////////
//
// CHistFolderView Functions and Definitions
//
//////////////////////////////////////////////////////////////////////////////


////////////////////////
//
// Column definition for the Cache Folder DefView
//
enum {
    ICOLC_URL_SHORTNAME = 0,
    ICOLC_URL_NAME,
    ICOLC_URL_TYPE,
    ICOLC_URL_SIZE,
    ICOLC_URL_EXPIRES,
    ICOLC_URL_MODIFIED,
    ICOLC_URL_ACCESSED,
    ICOLC_URL_LASTSYNCED,
    ICOLC_URL_MAX         // Make sure this is the last enum item
};


typedef struct _COLSPEC
{
    short int iCol;
    short int ids;        // Id of string for title
    short int cchCol;     // Number of characters wide to make column
    short int iFmt;       // The format of the column;
} COLSPEC;

const COLSPEC s_HistIntervalFolder_cols[] = {
    {ICOLH_URL_NAME,          IDS_TIMEPERIOD_COL,           30, LVCFMT_LEFT},
};

const COLSPEC s_HistHostFolder_cols[] = {
    {ICOLH_URL_NAME,          IDS_HOSTNAME_COL,           30, LVCFMT_LEFT},
};

const COLSPEC s_HistFolder_cols[] = {
    {ICOLH_URL_NAME,          IDS_NAME_COL,           30, LVCFMT_LEFT},
    {ICOLH_URL_TITLE,         IDS_TITLE_COL,          30, LVCFMT_LEFT},
    {ICOLH_URL_LASTVISITED,   IDS_LASTVISITED_COL,    18, LVCFMT_LEFT},
};

//////////////////////////////////////////////////////////////////////

HRESULT CreateSpecialViewPidl(USHORT usViewType, LPITEMIDLIST* ppidlOut, UINT cbExtra = 0, LPBYTE *ppbExtra = NULL);

HRESULT ConvertStandardHistPidlToSpecialViewPidl(LPCITEMIDLIST pidlStandardHist,
                                                 USHORT        usViewType,
                                                 LPITEMIDLIST *ppidlOut);

#define IS_DIGIT_CHAR(x) (((x) >= '0') && ((x) <= '9'))
#define MIN_MM(x, y)     (((x) < (y)) ? (x) : (y))
// _GetHostImportantPart:
//     IN:   pszHost -- a domain: for example, "www.wisc.edu"
//  IN/      puLen    -- the length of pszHost
//     OUT:  puLen    -- the length of the new string
// RETURNS:  The "important part" of a hostname (e.g. wisc)
//
// Another example:  "www.foo.co.uk" ==> "foo"

LPTSTR _GetHostImportantPart(LPTSTR pszHost, UINT *puLen) 
{
    LPTSTR pszCurEndHostStr = pszHost + (*puLen - 1);
    LPTSTR pszDomainBegin   = pszHost;
    LPTSTR pszSuffix, pszSuffix2;
    UINT  uSuffixLen;
    BOOL  fIsIP = FALSE;
    LPTSTR pszTemp;
    
    ASSERT(((UINT)lstrlen(pszHost)) == *puLen);
    if (*puLen == 0)
        return pszHost;

    // Filter out IP Addresses
    // Heurisitc: Everything after the last "dot"
    //  has to be a number.
    for (pszTemp = (pszHost + *puLen - 1);
         pszTemp >= pszHost; --pszTemp)
    {
        if (*pszTemp == '.')
            break;
        if (IS_DIGIT_CHAR(*pszTemp))
            fIsIP = TRUE;
        else
            break;
    }

    if (!fIsIP) {
        // Now that we have the url we can strip 
        if ( ((StrCmpNI(TEXT("www."), pszHost, 4)) == 0) ||
             ((StrCmpNI(TEXT("ftp."), pszHost, 4)) == 0) )
            pszDomainBegin += 4;
        
        // try to strip out the suffix by finding the last "dot"
        if ((pszSuffix = StrRChr(pszHost, pszCurEndHostStr, '.')) &&
            (pszSuffix > pszDomainBegin)                          &&
            ((uSuffixLen = (UINT)(pszCurEndHostStr - pszSuffix)) <= 3)) {
            // if it is before a two character country code then try
            //  to rip off some more.
            if ( (uSuffixLen <= 2)                                          &&
                 (pszSuffix2 = StrRChr(pszDomainBegin, pszSuffix - 1, '.')) &&
                 (pszSuffix2 > pszDomainBegin)                              &&
                 ((pszSuffix - pszSuffix2) <= 4) )
                pszSuffix = pszSuffix2;
        }
        else
            pszSuffix = pszCurEndHostStr + 1;
        
        *puLen = (UINT)(pszSuffix-pszDomainBegin);
    }
    return pszDomainBegin;
}

// a utility function for CHistFolder::GetDisplayNameOf
void _GetURLDispName(LPBASEPIDL pcei, LPTSTR pszName, UINT cchName) 
{
    TCHAR szStr[MAX_PATH];
    UINT uHostLen, uImportantPartLen;
    static TCHAR szBracketFmt[8] = TEXT("");  // " (%s)" with room for 0253 complex script marker char

    ualstrcpyn(szStr, _GetURLTitle(pcei), ARRAYSIZE(szStr));

    uImportantPartLen = uHostLen = lstrlen(szStr);

    StrCpyN(pszName, _GetHostImportantPart(szStr, &uImportantPartLen), MIN_MM(uImportantPartLen + 1, cchName));

    // don't add extra bit on the end if we haven't modified the string
    if (uImportantPartLen != uHostLen) 
    {
        if (!szBracketFmt[0]) 
        {
            MLLoadString(IDS_HISTHOST_FMT, szBracketFmt, ARRAYSIZE(szBracketFmt));
        }
        
        wnsprintf(pszName + uImportantPartLen, cchName - uImportantPartLen, szBracketFmt, szStr);
    }
}


HRESULT HistFolderView_MergeMenu(UINT idMenu, LPQCMINFO pqcm)
{
    HMENU hmenu = LoadMenu(MLGetHinst(), MAKEINTRESOURCE(idMenu));
    if (hmenu)
    {
        MergeMenuHierarchy(pqcm->hmenu, hmenu, pqcm->idCmdFirst, pqcm->idCmdLast);
        DestroyMenu(hmenu);
    }
    return S_OK;
}

HRESULT HistFolderView_DidDragDrop(IDataObject *pdo, DWORD dwEffect)
{
    if (dwEffect & DROPEFFECT_MOVE)
    {
        CHistItem *pHCItem;
        BOOL fBulkDelete;

        if (SUCCEEDED(pdo->QueryInterface(IID_IHist, (void **)&pHCItem)))
        {
            fBulkDelete = pHCItem->_cItems > LOTS_OF_FILES;
            for (UINT i = 0; i < pHCItem->_cItems; i++)
            {
                if (DeleteUrlCacheEntry(HPidlToSourceUrl((LPBASEPIDL)pHCItem->_ppidl[i])))
                {
                    if (!fBulkDelete)
                    {
                        _GenerateEvent(SHCNE_DELETE, pHCItem->_pHCFolder->_pidl, pHCItem->_ppidl[i], NULL);
                    }
                }
            }
            if (fBulkDelete)
            {
                _GenerateEvent(SHCNE_UPDATEDIR, pHCItem->_pHCFolder->_pidl, NULL, NULL);
            }
            SHChangeNotifyHandleEvents();
            pHCItem->Release();
            return S_OK;
        }
    }
    return E_FAIL;
}

// There are copies of exactly this function in SHELL32
// Add the File Type page
HRESULT HistFolderView_OnAddPropertyPages(DWORD pv, SFVM_PROPPAGE_DATA * ppagedata)
{
    IShellPropSheetExt * pspse;
    HRESULT hr = CoCreateInstance(CLSID_FileTypes, NULL, CLSCTX_INPROC_SERVER,
                              IID_PPV_ARG(IShellPropSheetExt, &pspse));
    if (SUCCEEDED(hr))
    {
        hr = pspse->AddPages(ppagedata->pfn, ppagedata->lParam);
        pspse->Release();
    }
    return hr;
}

HRESULT HistFolderView_OnGetSortDefaults(FOLDER_TYPE FolderType, int * piDirection, int * plParamSort)
{
    *plParamSort = (int)ICOLH_URL_LASTVISITED;
    *piDirection = 1;
    return S_OK;
}

HRESULT CALLBACK CHistFolder::_sViewCallback(IShellView *psv, IShellFolder *psf,
     HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHistFolder *pfolder = NULL;

    HRESULT hr = S_OK;

    switch (uMsg)
    {
    case DVM_GETHELPTEXT:
    {
        TCHAR szText[MAX_PATH];

        UINT id = LOWORD(wParam);
        UINT cchBuf = HIWORD(wParam);
        LPTSTR pszBuf = (LPTSTR)lParam;

        MLLoadString(id + IDS_MH_FIRST, szText, ARRAYSIZE(szText));

        // we know for a fact that this parameter is really a TCHAR
        if ( IsOS( OS_NT ))
        {
            SHTCharToUnicode( szText, (LPWSTR) pszBuf, cchBuf );
        }
        else
        {
            SHTCharToAnsi( szText, (LPSTR) pszBuf, cchBuf );
        }
        break;
    }

    case SFVM_GETNOTIFY:
        hr = psf->QueryInterface(CLSID_HistFolder, (void **)&pfolder);
        if (SUCCEEDED(hr))
        {
            *(LPCITEMIDLIST*)wParam = pfolder->_pidl;   // evil alias
            pfolder->Release();
        }
        else
            wParam = 0;
        *(LONG*)lParam = ALL_CHANGES;
        break;

    case DVM_DIDDRAGDROP:
        hr = HistFolderView_DidDragDrop((IDataObject *)lParam, (DWORD)wParam);
        break;

    case DVM_INITMENUPOPUP:
        hr = S_OK;
        break;

    case DVM_INVOKECOMMAND:
        _ArrangeFolder(hwnd, (UINT)wParam);
        break;

    case DVM_COLUMNCLICK:
        ShellFolderView_ReArrange(hwnd, (UINT)wParam);
        hr = S_OK;
        break;

    case DVM_MERGEMENU:
        hr = HistFolderView_MergeMenu(MENU_HISTORY, (LPQCMINFO)lParam);
        break;

    case DVM_DEFVIEWMODE:
        *(FOLDERVIEWMODE *)lParam = FVM_DETAILS;
        break;

    case SFVM_ADDPROPERTYPAGES:
        hr = HistFolderView_OnAddPropertyPages((DWORD)wParam, (SFVM_PROPPAGE_DATA *)lParam);
        break;

    case SFVM_GETSORTDEFAULTS:
        hr = psf->QueryInterface(CLSID_HistFolder, (void **)&pfolder);
        if (SUCCEEDED(hr))
        {
            hr = HistFolderView_OnGetSortDefaults(pfolder->_foldertype, (int *)wParam, (int *)lParam);
            pfolder->Release();
        }
        else
        {
            wParam = 0;
            lParam = 0;
        }
        break;

    case SFVM_UPDATESTATUSBAR:
        ResizeStatusBar(hwnd, FALSE);
        // We did not set any text; let defview do it
        hr = E_NOTIMPL;
        break;

    case SFVM_SIZE:
        ResizeStatusBar(hwnd, FALSE);
        break;

    case SFVM_GETPANE:
        if (wParam == PANE_ZONE)
            *(DWORD*)lParam = 1;
        else
            *(DWORD*)lParam = PANE_NONE;

        break;
    case SFVM_WINDOWCREATED:
        ResizeStatusBar(hwnd, TRUE);
        break;

    case SFVM_GETZONE:
        *(DWORD*)lParam = URLZONE_LOCAL_MACHINE; // Internet by default
        break;

    default:
        hr = E_FAIL;
    }

    return hr;
}

HRESULT HistFolderView_CreateInstance(CHistFolder *pHCFolder, void **ppv)
{
    CSFV csfv;

    csfv.cbSize = sizeof(csfv);
    csfv.pshf = (IShellFolder *)pHCFolder;
    csfv.psvOuter = NULL;
    csfv.pidl = pHCFolder->_pidl;
    csfv.lEvents = SHCNE_DELETE; // SHCNE_DISKEVENTS | SHCNE_ASSOCCHANGED | SHCNE_GLOBALEVENTS;
    csfv.pfnCallback = CHistFolder::_sViewCallback;
    csfv.fvm = (FOLDERVIEWMODE)0;         // Have defview restore the folder view mode

    return SHCreateShellFolderViewEx(&csfv, (IShellView**)ppv);
}



//////////////////////////////////////////////////////////////////////////////
//
// CHistFolderEnum Object
//
//////////////////////////////////////////////////////////////////////////////

CHistFolderEnum::CHistFolderEnum(DWORD grfFlags, CHistFolder *pHCFolder)
{
    TraceMsg(DM_HSFOLDER, "hcfe - CHistFolderEnum() called");
    _cRef = 1;
    DllAddRef();

    _grfFlags = grfFlags,
    _pHCFolder = pHCFolder;
    pHCFolder->AddRef();
    ASSERT(_hEnum             == NULL &&
           _cbCurrentInterval == 0    &&
           _cbIntervals       == 0    &&
           _pshHashTable      == NULL &&
           _polFrequentPages  == NULL &&
           _pIntervalCache    == NULL);

}

CHistFolderEnum::~CHistFolderEnum()
{
    ASSERT(_cRef == 0);         // we should always have a zero ref count here
    TraceMsg(DM_HSFOLDER, "hcfe - ~CHistFolderEnum() called.");
    _pHCFolder->Release();
    if (_pceiWorking)
    {
        LocalFree(_pceiWorking);
        _pceiWorking = NULL;
    }
    if (_pIntervalCache)
    {
        LocalFree(_pIntervalCache);
        _pIntervalCache = NULL;
    }

    if (_hEnum)
    {
        FindCloseUrlCache(_hEnum);
        _hEnum = NULL;
    }
    if (_pshHashTable)
        delete _pshHashTable;
    if (_polFrequentPages)
        delete _polFrequentPages;
    if (_pstatenum)
        _pstatenum->Release();
    DllRelease();
}


HRESULT CHistFolderEnum_CreateInstance(DWORD grfFlags, CHistFolder *pHCFolder, IEnumIDList **ppeidl)
{
    TraceMsg(DM_HSFOLDER, "hcfe - CreateInstance() called.");

    *ppeidl = NULL;                 // null the out param

    CHistFolderEnum *pHCFE = new CHistFolderEnum(grfFlags, pHCFolder);
    if (!pHCFE)
        return E_OUTOFMEMORY;

    *ppeidl = pHCFE;

    return S_OK;
}

HRESULT CHistFolderEnum::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CHistFolderEnum, IEnumIDList),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CHistFolderEnum::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}

ULONG CHistFolderEnum::Release(void)
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CHistFolderEnum::_NextHistInterval(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched)
{
    HRESULT hr = S_OK;
    LPBASEPIDL pcei = NULL;
    TCHAR szCurrentInterval[INTERVAL_SIZE+1];

    //  chrisfra 3/27/97 on NT cache files are per user, not so on win95.  how do
    //  we manage containers on win95 if different users are specified different history
    //  intervals

    if (0 == _cbCurrentInterval)
    {
        hr = _pHCFolder->_ValidateIntervalCache();
        if (SUCCEEDED(hr))
        {
            hr = S_OK;
            ENTERCRITICAL;
            if (_pIntervalCache)
            {
                LocalFree(_pIntervalCache);
                _pIntervalCache = NULL;
            }
            if (_pHCFolder->_pIntervalCache)
            {
                _pIntervalCache = (HSFINTERVAL *)LocalAlloc(LPTR,
                                                            _pHCFolder->_cbIntervals*sizeof(HSFINTERVAL));
                if (_pIntervalCache == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    _cbIntervals = _pHCFolder->_cbIntervals;
                    CopyMemory(_pIntervalCache,
                               _pHCFolder->_pIntervalCache,
                               _cbIntervals*sizeof(HSFINTERVAL));
                }
            }
            LEAVECRITICAL;
        }
    }

    if (_pIntervalCache && _cbCurrentInterval < _cbIntervals)
    {
        _KeyForInterval(&_pIntervalCache[_cbCurrentInterval], szCurrentInterval,
                        ARRAYSIZE(szCurrentInterval));
        pcei = _CreateIdCacheFolderPidl(TRUE,
                                        _pIntervalCache[_cbCurrentInterval].usSign,
                                        szCurrentInterval);
        _cbCurrentInterval++;
    }
    if (pcei)
    {
        rgelt[0] = (LPITEMIDLIST)pcei;
        if (pceltFetched) *pceltFetched = 1;
    }
    else
    {
        if (pceltFetched) *pceltFetched = 0;
        rgelt[0] = NULL;
        hr = S_FALSE;
    }
    return hr;
}

// This function dispatches the different "views" on History that are possible
HRESULT CHistFolderEnum::_NextViewPart(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched)
{
    switch(_pHCFolder->_uViewType) {
    case VIEWPIDL_SEARCH:
        return _NextViewPart_OrderSearch(celt, rgelt, pceltFetched);
    case VIEWPIDL_ORDER_TODAY:
        return _NextViewPart_OrderToday(celt, rgelt, pceltFetched);
    case VIEWPIDL_ORDER_SITE:
        return _NextViewPart_OrderSite(celt, rgelt, pceltFetched);
    case VIEWPIDL_ORDER_FREQ:
        return _NextViewPart_OrderFreq(celt, rgelt, pceltFetched);
    default:
        return E_NOTIMPL;
    }
}

LPITEMIDLIST _Combine_ViewPidl(USHORT usViewType, LPITEMIDLIST pidl);

// This function wraps wininet's Find(First/Next)UrlCacheEntry API
// returns DWERROR code or zero if successful
DWORD _FindURLCacheEntry(IN LPCTSTR                          pszCachePrefix,
                         IN OUT LPINTERNET_CACHE_ENTRY_INFO  pcei,
                         IN OUT HANDLE                      &hEnum,
                         IN OUT LPDWORD                      pdwBuffSize)
{
    if (!hEnum)
    {
        if (! (hEnum = FindFirstUrlCacheEntry(pszCachePrefix, pcei, pdwBuffSize)) )
            return GetLastError();
    }
    else if (!FindNextUrlCacheEntry(hEnum, pcei, pdwBuffSize))
        return GetLastError();
    return S_OK;
}

// Thie function provides an iterator over all entries in all (MSHIST-type) buckets
//   in the cache
DWORD _FindURLFlatCacheEntry(IN HSFINTERVAL *pIntervalCache,
                             IN LPTSTR       pszUserName,       // filter out cache entries owned by user
                             IN BOOL         fHostEntry,        // retrieve host entries only (FALSE), or no host entries (TRUE)
                             IN OUT int     &cbCurrentInterval, // should begin at the maximum number of intervals
                             IN OUT LPINTERNET_CACHE_ENTRY_INFO  pcei,
                             IN OUT HANDLE  &hEnum,
                             IN OUT LPDWORD  pdwBuffSize
                             )
{
    DWORD dwStoreBuffSize = *pdwBuffSize;
    DWORD dwResult        = ERROR_NO_MORE_ITEMS;
    while (cbCurrentInterval >= 0) 
    {
        if ((dwResult = _FindURLCacheEntry(pIntervalCache[cbCurrentInterval].szPrefix,
                                           pcei, hEnum, pdwBuffSize)) != S_OK)
        {
            if (dwResult == ERROR_NO_MORE_ITEMS) 
            {
                // This bucket is done, now go get the next one
                FindCloseUrlCache(hEnum);
                hEnum = NULL;
                --cbCurrentInterval;
            }
            else
                break;
        }
        else
        {
            // Do requested filtering...
            BOOL fIsHost = (StrStr(pcei->lpszSourceUrlName, c_szHostPrefix) == NULL);
            if ( ((!pszUserName) ||  // if requested, filter username
                  _FilterUserName(pcei, pIntervalCache[cbCurrentInterval].szPrefix, pszUserName)) &&
                 ((!fHostEntry && !fIsHost) ||  // filter for host entries
                  (fHostEntry  && fIsHost))    )
            {
                break;
            }
        }
        // reset for next iteration
        *pdwBuffSize = dwStoreBuffSize;
    }
    return dwResult;
}

// This guy will search the flat cache (MSHist buckets) for a particular URL
//  * This function assumes that the Interval cache is good and loaded
// RETURNS: Windows Error code
DWORD CHistFolder::_SearchFlatCacheForUrl(LPCTSTR pszUrl, LPINTERNET_CACHE_ENTRY_INFO pcei, LPDWORD pdwBuffSize)
{
    TCHAR szUserName[INTERNET_MAX_USER_NAME_LENGTH + 1];      // username of person logged on
    DWORD dwUserNameLen = ARRAYSIZE(szUserName);

    if (FAILED(_GetUserName(szUserName, dwUserNameLen)))
        szUserName[0] = TEXT('\0');

    UINT   uSuffixLen     = lstrlen(pszUrl) + lstrlen(szUserName) + 1; // extra 1 for '@'
    LPTSTR pszPrefixedUrl = ((LPTSTR)LocalAlloc(LPTR, (PREFIX_SIZE + uSuffixLen + 1) * sizeof(TCHAR)));
    DWORD  dwError        = ERROR_FILE_NOT_FOUND;

    if (pszPrefixedUrl != NULL)
    {
        // pszPrefixedUrl will have the format of "PREFIX username@
        wnsprintf(pszPrefixedUrl + PREFIX_SIZE, uSuffixLen + 1, TEXT("%s@%s"), szUserName, pszUrl);

        for (int i =_cbIntervals - 1; i >= 0; --i) 
        {
            // memcpy doesn't null terminate
            memcpy(pszPrefixedUrl, _pIntervalCache[i].szPrefix, PREFIX_SIZE * sizeof(TCHAR));
            if (GetUrlCacheEntryInfo(pszPrefixedUrl, pcei, pdwBuffSize)) 
            {
                dwError = ERROR_SUCCESS;
                break;
            }
            else if ( ((dwError = GetLastError()) != ERROR_FILE_NOT_FOUND) ) 
            {
                break;
            }
        }

        LocalFree(pszPrefixedUrl);
        pszPrefixedUrl = NULL;
    }
    else
    {
        dwError = ERROR_OUTOFMEMORY;
    }
    
    return dwError;
}

//////////////////////////////////////////////////////////////////////
//  Most Frequently Visited Sites;

// this structure is used by the enumeration of the cache
//   to get the most frequently seen sites
class OrderList_CacheElement : public OrderedList::Element 
{
public:
    LPTSTR    pszUrl;
    DWORD     dwHitRate;
    __int64   llPriority;
    int       nDaysSinceLastHit;
    LPSTATURL lpSTATURL;

    static   FILETIME ftToday;
    static   BOOL     fInited;

    OrderList_CacheElement(LPTSTR pszStr, DWORD dwHR, LPSTATURL lpSU) 
    {
        s_initToday();
        ASSERT(pszStr);
        pszUrl         = (pszStr ? StrDup(pszStr) : StrDup(TEXT("")));
        dwHitRate      = dwHR;
        lpSTATURL      = lpSU;

        nDaysSinceLastHit = DAYS_DIFF(&ftToday, &(lpSTATURL->ftLastVisited));

        // prevent division by zero
        if (nDaysSinceLastHit < 0)
            nDaysSinceLastHit = 0;
        // scale division up by a little less than half of the __int64
        llPriority  = ((((__int64)dwHitRate) * LONG_MAX) /
                       ((__int64)(nDaysSinceLastHit + 1)));
        //dPriority  = ((double)dwHitRate / (double)(nDaysSinceLastHit + 1));
    }

    virtual int compareWith(OrderedList::Element *pelt) 
    {
        OrderList_CacheElement *polce;
        if (pelt) 
        {
            polce = reinterpret_cast<OrderList_CacheElement *>(pelt);
            // we're cheating here a bit by returning 1 instead of testing
            //   for equality, but that's ok...
            //            return ( (dwHitRate < polce->dwHitRate) ? -1 : 1 );
            return ( (llPriority < polce->llPriority) ? -1 : 1 );
        }
        return 0;
    }

    virtual ~OrderList_CacheElement() 
    {
        if (pszUrl)
        {
            LocalFree(pszUrl);
            pszUrl = NULL;
        }

        if (lpSTATURL) 
        {
            if (lpSTATURL->pwcsUrl)
                OleFree(lpSTATURL->pwcsUrl);
            if (lpSTATURL->pwcsTitle)
                OleFree(lpSTATURL->pwcsTitle);
            delete lpSTATURL;
        }
    }

    /*
    friend ostream& operator<<(ostream& os, OrderList_CacheElement& olce) {
        os << " (" << olce.dwHitRate << "; " << olce.nDaysSinceLastHit
           << " days; pri=" << olce.llPriority << ") " << olce.pszUrl;
        return os;
    }
    */

    static void s_initToday() 
    {
        if (!fInited) 
        {
            SYSTEMTIME sysTime;
            GetLocalTime(&sysTime);
            SystemTimeToFileTime(&sysTime, &ftToday);
            fInited = TRUE;
        }
    }
};

FILETIME OrderList_CacheElement::ftToday;
BOOL OrderList_CacheElement::fInited = FALSE;

// caller must delete OrderedList
OrderedList* CHistFolderEnum::_GetMostFrequentPages()
{
    TCHAR      szUserName[INTERNET_MAX_USER_NAME_LENGTH + 1];      // username of person logged on
    DWORD      dwUserNameLen = INTERNET_MAX_USER_NAME_LENGTH + 1;
    if (FAILED(_pHCFolder->_GetUserName(szUserName, dwUserNameLen)))
        szUserName[0] = TEXT('\0');
    UINT       uUserNameLen = lstrlen(szUserName);

    // reinit the current time
    OrderList_CacheElement::fInited = FALSE;
    IUrlHistoryPriv *pUrlHistStg = _pHCFolder->_GetHistStg();
    OrderedList     *pol         = NULL;

    if (pUrlHistStg)
    {
        IEnumSTATURL *penum = NULL;
        if (SUCCEEDED(pUrlHistStg->EnumUrls(&penum)) && penum)
        {
            DWORD dwSites = -1;
            DWORD dwType  = REG_DWORD;
            DWORD dwSize  = sizeof(DWORD);

            EVAL(SHRegGetUSValue(REGSTR_PATH_MAIN, c_szRegKeyTopNSites, &dwType,
                                 (void *)&dwSites, &dwSize, FALSE,
                                 (void *)&dwSites, dwSize) == ERROR_SUCCESS);

            if ( (dwType != REG_DWORD)     ||
                 (dwSize != sizeof(DWORD)) ||
                 ((int)dwSites < 0) )
            {
                dwSites = NUM_TOP_SITES;
                SHRegSetUSValue(REGSTR_PATH_MAIN, c_szRegKeyTopNSites, REG_DWORD,
                                (void *)&dwSites, dwSize, SHREGSET_HKCU);

                dwSites = NUM_TOP_SITES;
            }

            pol = new OrderedList(dwSites);
            if (pol)
            {
                STATURL *psuThis = new STATURL;
                if (psuThis)
                {
                    penum->SetFilter(NULL, STATURL_QUERYFLAG_TOPLEVEL);

                    while (pol) {
                        psuThis->cbSize    = sizeof(STATURL);
                        psuThis->pwcsUrl   = NULL;
                        psuThis->pwcsTitle = NULL;

                        ULONG   cFetched;

                        if (SUCCEEDED(penum->Next(1, psuThis, &cFetched)) && cFetched)
                        {
                            // test: the url (taken from the VISITED history bucket) is a "top-level"
                            //  url that would be in the MSHIST (displayed to user) history bucket
                            //  things ommitted will be certain error urls and frame children pages etc...
                            if ( (psuThis->dwFlags & STATURLFLAG_ISTOPLEVEL) &&
                                 (psuThis->pwcsUrl)                          &&
                                 (!IsErrorUrl(psuThis->pwcsUrl)) )
                            {
                                UINT   uUrlLen        = lstrlenW(psuThis->pwcsUrl);
                                UINT   uPrefixLen     = HISTPREFIXLEN + uUserNameLen + 1; // '@' and '\0'
                                LPTSTR pszPrefixedUrl =
                                    ((LPTSTR)LocalAlloc(LPTR, (uUrlLen + uPrefixLen + 1) * sizeof(TCHAR)));
                                if (pszPrefixedUrl)
                                {
                                    wnsprintf(pszPrefixedUrl, uPrefixLen + 1 , TEXT("%s%s@"), c_szHistPrefix, szUserName);

                                    StrCpyN(pszPrefixedUrl + uPrefixLen, psuThis->pwcsUrl, uUrlLen + 1);

                                    PROPVARIANT vProp = {0};
                                    if (SUCCEEDED(pUrlHistStg->GetProperty(pszPrefixedUrl + uPrefixLen,
                                                                           PID_INTSITE_VISITCOUNT, &vProp)) &&
                                        (vProp.vt == VT_UI4))
                                    {
                                        pol->insert(new OrderList_CacheElement(pszPrefixedUrl,
                                                                               vProp.lVal,
                                                                               psuThis));
                                        // OrderList now owns this -- he'll free it
                                        psuThis = new STATURL;
                                        if (psuThis)
                                        {
                                            psuThis->cbSize    = sizeof(STATURL);
                                            psuThis->pwcsUrl   = NULL;
                                            psuThis->pwcsTitle = NULL;
                                        }
                                        else if (pol) {
                                            delete pol;
                                            pol = NULL;
                                        }
                                    }

                                    LocalFree(pszPrefixedUrl);
                                    pszPrefixedUrl = NULL;
                                }
                                else if (pol)
                                { // couldn't allocate
                                    delete pol;
                                    pol = NULL;
                                }
                            }
                            if (psuThis && psuThis->pwcsUrl)
                                OleFree(psuThis->pwcsUrl);

                            if (psuThis && psuThis->pwcsTitle)
                                OleFree(psuThis->pwcsTitle);
                        }
                        else // nothing more from the enumeration...
                            break;
                    } //while
                    if (psuThis)
                        delete psuThis;
                }
                else if (pol) { //allocation failed
                    delete pol;
                    pol = NULL;
                }
            }
            penum->Release();
        }
        /*    DWORD dwBuffSize = MAX_URLCACHE_ENTRY;
              DWORD dwError; */

        // This commented-out code does the same thing WITHOUT going through
        //  the IUrlHistoryPriv interface, but, instead going directly
        //  to wininet
        /*
          while ((dwError = _FindURLCacheEntry(c_szHistPrefix, _pceiWorking,
          _hEnum, &dwBuffSize)) == S_OK) {
          // if its a top-level history guy && is cache entry to valid username
          if ( (((HISTDATA *)_pceiWorking->lpHeaderInfo)->dwFlags & PIDISF_HISTORY) && //top-level
          (_FilterUserName(_pceiWorking, c_szHistPrefix, szUserName)) ) // username is good
          {
          // perf:  we can avoid needlessly creating new cache elements if we're less lazy
          pol->insert(new OrderList_CacheElement(_pceiWorking->lpszSourceUrlName,
          _pceiWorking->dwHitRate,
          _pceiWorking->LastModifiedTime));
          }
          dwBuffSize = MAX_URLCACHE_ENTRY;
          }
          ASSERT(dwError == ERROR_NO_MORE_ITEMS);
          */
        pUrlHistStg->Release();
    } // no storage

    return pol;
}

HRESULT CHistFolderEnum::_NextViewPart_OrderFreq(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched)
{
    HRESULT hr = E_INVALIDARG;

    if ( (!_polFrequentPages) && (!(_polFrequentPages = _GetMostFrequentPages())) )
        return E_FAIL;

    if (rgelt && pceltFetched) {
        // loop to fetch as many elements as requested.
        for (*pceltFetched = 0; *pceltFetched < celt;) {
            // contruct a pidl out of the first element in the orderedlist cache
            OrderList_CacheElement *polce = reinterpret_cast<OrderList_CacheElement *>
                (_polFrequentPages->removeFirst());
            if (polce) {
                if (!(rgelt[*pceltFetched] =
                      reinterpret_cast<LPITEMIDLIST>
                      (_CreateHCacheFolderPidl(TRUE,
                                               polce->pszUrl, polce->lpSTATURL->ftLastVisited,
                                               polce->lpSTATURL,
                                               polce->llPriority,
                                               polce->dwHitRate))))
                {
                    delete polce;
                    hr = E_OUTOFMEMORY;
                    break;
                }
                ++(*pceltFetched);
                delete polce;
                hr = S_OK;
            }
            else {
                hr = S_FALSE; // no more...
                break;
            }
        }
    }
    return hr;
}

// The Next method for view -- Order by Site
HRESULT CHistFolderEnum::_NextViewPart_OrderSite(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched)
{
    DWORD      dwError         = S_OK;
    TCHAR      szUserName[INTERNET_MAX_USER_NAME_LENGTH + 1];      // username of person logged on
    DWORD      dwUserNameLen   = INTERNET_MAX_USER_NAME_LENGTH + 1;  // len of this buffer
    LPCTSTR    pszStrippedUrl, pszHost, pszCachePrefix = NULL;
    LPITEMIDLIST  pcei         = NULL;
    LPCTSTR    pszHostToMatch  = NULL;
    UINT       nHostToMatchLen = 0;

    if (FAILED(_pHCFolder->_GetUserName(szUserName, dwUserNameLen)))
        szUserName[0] = TEXT('\0');

    if ((!_pceiWorking) &&
        (!(_pceiWorking = (LPINTERNET_CACHE_ENTRY_INFO)LocalAlloc(LPTR, MAX_URLCACHE_ENTRY))))
        return E_OUTOFMEMORY;

    DWORD dwBuffSize = MAX_URLCACHE_ENTRY;

    // load all the intervals and do some cache maintenance:
    if (FAILED(_pHCFolder->_ValidateIntervalCache()))
        return E_OUTOFMEMORY;

    /* To get all sites, we will search all the history buckets
       for "Host"-type entries.  These entries will be put into
       a hash table as we enumerate so that redundant results are
       not returned.                                               */

    if (!_pshHashTable)
    {
        // start a new case-insensitive hash table
        _pshHashTable = new StrHash(TRUE);
        if (_pshHashTable == NULL)
        {
            return E_OUTOFMEMORY;
        }
    }

    // if we are looking for individual pages within a host,
    //  then we must find which host to match...
    if (_pHCFolder->_uViewDepth == 1) {
        LPCITEMIDLIST pidlHost = ILFindLastID(_pHCFolder->_pidl);
        ASSERT(_IsValid_IDPIDL(pidlHost) &&
               EQUIV_IDSIGN(((LPBASEPIDL)pidlHost)->usSign, IDDPIDL_SIGN));
        ua_GetURLTitle( &pszHostToMatch, (LPBASEPIDL)pidlHost );
        nHostToMatchLen = (pszHostToMatch ? lstrlen(pszHostToMatch) : 0);

    }

    // iterate backwards through containers so most recent
    //  information gets put into the final pidl
    if (!_hEnum)
        _cbCurrentInterval = (_pHCFolder->_cbIntervals - 1);

    while((dwError = _FindURLFlatCacheEntry(_pHCFolder->_pIntervalCache, szUserName,
                                            (_pHCFolder->_uViewDepth == 1),
                                            _cbCurrentInterval,
                                            _pceiWorking, _hEnum, &dwBuffSize)) == S_OK)
    {
        // reset for next iteration
        dwBuffSize = MAX_CACHE_ENTRY_INFO_SIZE;

        // this guy takes out the "t-marcmi@" part of the URL
        pszStrippedUrl = _StripHistoryUrlToUrl(_pceiWorking->lpszSourceUrlName);
        if (_pHCFolder->_uViewDepth == 0) {
            if ((DWORD)lstrlen(pszStrippedUrl) > HOSTPREFIXLEN) {
                pszHost = &pszStrippedUrl[HOSTPREFIXLEN];
                // insertUnique returns non-NULL if this key already exists
                if (_pshHashTable->insertUnique(pszHost, TRUE, reinterpret_cast<void *>(1)))
                    continue; // already given out
                pcei = (LPITEMIDLIST)_CreateIdCacheFolderPidl(TRUE, IDDPIDL_SIGN, pszHost);
            }
            break;
        }
        else if (_pHCFolder->_uViewDepth == 1) {
            TCHAR szHost[INTERNET_MAX_HOST_NAME_LENGTH+1];
            // is this entry a doc from the host we're looking for?
            _GetURLHost(_pceiWorking, szHost, INTERNET_MAX_HOST_NAME_LENGTH, _GetLocalHost());

            if ( (!StrCmpI(szHost, pszHostToMatch)) &&
                 (!_pshHashTable->insertUnique(pszStrippedUrl,
                                               TRUE, reinterpret_cast<void *>(1))) )
            {
                STATURL suThis;
                HRESULT hrLocal            = E_FAIL;
                IUrlHistoryPriv *pUrlHistStg = _pHCFolder->_GetHistStg();

                if (pUrlHistStg) {
                    hrLocal = pUrlHistStg->QueryUrl(pszStrippedUrl, STATURL_QUERYFLAG_NOURL, &suThis);
                    pUrlHistStg->Release();
                }

                pcei = (LPITEMIDLIST)
                    _CreateHCacheFolderPidl(TRUE, _pceiWorking->lpszSourceUrlName,
                                            _pceiWorking->LastModifiedTime,
                                            (SUCCEEDED(hrLocal) ? &suThis : NULL), 0,
                                            _pHCFolder->_GetHitCount(_StripHistoryUrlToUrl(_pceiWorking->lpszSourceUrlName)));
                if (SUCCEEDED(hrLocal) && suThis.pwcsTitle)
                    OleFree(suThis.pwcsTitle);
                break;
            }
        }
    }

    if (pcei && rgelt) {
        rgelt[0] = (LPITEMIDLIST)pcei;
        if (pceltFetched)
            *pceltFetched = 1;
    }
    else {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (dwError != S_OK) {
        if (pceltFetched)
            *pceltFetched = 0;
        if (_hEnum)
            FindCloseUrlCache(_hEnum);
        return S_FALSE;
    }
    return S_OK;
}

// "Next" method for View by "Order seen today"
HRESULT CHistFolderEnum::_NextViewPart_OrderToday(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched)
{
    DWORD      dwError    = S_OK;
    TCHAR      szUserName[INTERNET_MAX_USER_NAME_LENGTH + 1];      // username of person logged on
    DWORD      dwUserNameLen = INTERNET_MAX_USER_NAME_LENGTH + 1;  // len of this buffer
    LPCTSTR    pszStrippedUrl, pszHost;
    LPBASEPIDL  pcei = NULL;

    if (FAILED(_pHCFolder->_GetUserName(szUserName, dwUserNameLen)))
        szUserName[0] = TEXT('\0');

    if ((!_pceiWorking) &&
        (!(_pceiWorking = (LPINTERNET_CACHE_ENTRY_INFO)LocalAlloc(LPTR, MAX_URLCACHE_ENTRY))))
        return E_OUTOFMEMORY;

    if (!_hEnum) {
        // load all the intervals and do some cache maintenance:
        if (FAILED(_pHCFolder->_ValidateIntervalCache()))
            return E_OUTOFMEMORY;
        // get only entries for TODAY (important part)
        SYSTEMTIME   sysTime;
        FILETIME     fileTime;
        GetLocalTime(&sysTime);
        SystemTimeToFileTime(&sysTime, &fileTime);
        if (FAILED(_pHCFolder->_GetInterval(&fileTime, FALSE, &_pIntervalCur)))
            return E_FAIL; // couldn't get interval for Today
    }

    DWORD dwBuffSize = MAX_CACHE_ENTRY_INFO_SIZE;

    while ( (dwError = _FindURLCacheEntry(_pIntervalCur->szPrefix, _pceiWorking, _hEnum,
                                          &dwBuffSize)) == S_OK )
    {
        dwBuffSize = MAX_CACHE_ENTRY_INFO_SIZE;

        // Make sure that his cache entry belongs to szUserName
        if (_FilterUserName(_pceiWorking, _pIntervalCur->szPrefix, szUserName)) {
            // this guy takes out the "t-marcmi@" part of the URL
            pszStrippedUrl = _StripHistoryUrlToUrl(_pceiWorking->lpszSourceUrlName);
            if ((DWORD)lstrlen(pszStrippedUrl) > HOSTPREFIXLEN) {
                pszHost = &pszStrippedUrl[HOSTPREFIXLEN];
                if (StrCmpNI(c_szHostPrefix, pszStrippedUrl, HOSTPREFIXLEN) == 0)
                    continue; // this is a HOST placeholder, not a real doc
            }

            IUrlHistoryPriv *pUrlHistStg = _pHCFolder->_GetHistStg();
            STATURL suThis;
            HRESULT hrLocal = E_FAIL;

            if (pUrlHistStg) {
                hrLocal = pUrlHistStg->QueryUrl(pszStrippedUrl, STATURL_QUERYFLAG_NOURL, &suThis);
                pUrlHistStg->Release();
            }
            pcei = (LPBASEPIDL) _CreateHCacheFolderPidl(TRUE, _pceiWorking->lpszSourceUrlName,
                                                       _pceiWorking->LastModifiedTime,
                                                       (SUCCEEDED(hrLocal) ? &suThis : NULL), 0,
                                                       _pHCFolder->_GetHitCount(_StripHistoryUrlToUrl(_pceiWorking->lpszSourceUrlName)));
            if (SUCCEEDED(hrLocal) && suThis.pwcsTitle)
                OleFree(suThis.pwcsTitle);
            break;
        }
    }

    if (pcei && rgelt) {
        rgelt[0] = (LPITEMIDLIST)pcei;
        if (pceltFetched)
            *pceltFetched = 1;
    }

    if (dwError == ERROR_NO_MORE_ITEMS) {
        if (pceltFetched)
            *pceltFetched = 0;
        if (_hEnum)
            FindCloseUrlCache(_hEnum);
        return S_FALSE;
    }
    else if (dwError == S_OK)
        return S_OK;
    else
        return E_FAIL;
}

/***********************************************************************
  Search Mamagement Stuff:

  In order to maintian state between binds to the IShellFolder from
  the desktop, we base our state information for the searches off a
  global database (linked list) that is keyed by a timestamp generated
  when the search begins.

  This FILETIME is in the pidl for the search.
  ********************************************************************/

class _CurrentSearches {
public:
    LONG      _cRef;
    FILETIME  _ftSearchKey;
    LPWSTR    _pwszSearchTarget;
    IShellFolderSearchableCallback *_psfscOnAsyncSearch;

    CacheSearchEngine::StreamSearcher _streamsearcher;

    // Currently doing async search
    BOOL      _fSearchingAsync;

    // On next pass, kill this search
    BOOL      _fKillSwitch;

    // WARNING: DO NOT access these elements without a critical section!
    _CurrentSearches  *_pcsNext;
    _CurrentSearches  *_pcsPrev;

    static _CurrentSearches* s_pcsCurrentCacheSearchThreads;

    _CurrentSearches(FILETIME &ftSearchKey, LPCWSTR pwszSrch,
                     IShellFolderSearchableCallback *psfsc,
                     _CurrentSearches *pcsNext = s_pcsCurrentCacheSearchThreads) :
        _streamsearcher(pwszSrch),
        _fSearchingAsync(FALSE), _fKillSwitch(FALSE), _cRef(1)
    {
        _ftSearchKey      = ftSearchKey;
        _pcsNext          = pcsNext;
        _pcsPrev          = NULL;

        if (psfsc)
            psfsc->AddRef();

        _psfscOnAsyncSearch = psfsc;
        SHStrDupW(pwszSrch, &_pwszSearchTarget);
    }

    ULONG AddRef() {
        return InterlockedIncrement(&_cRef);
    }

    ULONG Release() {
        if (InterlockedDecrement(&_cRef))
            return _cRef;
        delete this;
        return 0;
    }

    // this will increment the refcount to be decremented by s_RemoveSearch
    static void s_NewSearch(_CurrentSearches *pcsNew,
                            _CurrentSearches *&pcsHead = s_pcsCurrentCacheSearchThreads)
    {
        ENTERCRITICAL;
        // make sure we're inserting at the front of the list
        ASSERT(pcsNew->_pcsNext == pcsHead);
        ASSERT(pcsNew->_pcsPrev == NULL);

        pcsNew->AddRef();
        if (pcsHead)
            pcsHead->_pcsPrev = pcsNew;
        pcsHead = pcsNew;
        LEAVECRITICAL;
    }

    static void s_RemoveSearch(_CurrentSearches *pcsRemove,
                               _CurrentSearches *&pcsHead = s_pcsCurrentCacheSearchThreads);

    // This searches for the search.
    // To find this search searcher, use the search searcher searcher :)
    static _CurrentSearches *s_FindSearch(const FILETIME &ftSearchKey,
                                          _CurrentSearches *pcsHead = s_pcsCurrentCacheSearchThreads);

protected:
    ~_CurrentSearches() {
        if (_psfscOnAsyncSearch)
            _psfscOnAsyncSearch->Release();
        CoTaskMemFree(_pwszSearchTarget);
    }
};

// A linked list of current cache searchers:
//  For multiple entries to occur in this list, the user would have to be
//  searching the cache on two or more separate queries simultaneously
_CurrentSearches *_CurrentSearches::s_pcsCurrentCacheSearchThreads = NULL;

void _CurrentSearches::s_RemoveSearch(_CurrentSearches *pcsRemove, _CurrentSearches *&pcsHead)
{
    ENTERCRITICAL;
    if (pcsRemove->_pcsPrev)
        pcsRemove->_pcsPrev->_pcsNext = pcsRemove->_pcsNext;
    else
        pcsHead = pcsRemove->_pcsNext;

    if (pcsRemove->_pcsNext)
        pcsRemove->_pcsNext->_pcsPrev = pcsRemove->_pcsPrev;

    pcsRemove->Release();
    LEAVECRITICAL;
}

// Caller: Remember to Release() the returned data!!
_CurrentSearches *_CurrentSearches::s_FindSearch(const FILETIME &ftSearchKey,
                                                 _CurrentSearches *pcsHead)
{
    ENTERCRITICAL;
    _CurrentSearches *pcsTemp = pcsHead;
    _CurrentSearches *pcsRet  = NULL;
    while (pcsTemp) {
        if (((pcsTemp->_ftSearchKey).dwLowDateTime  == ftSearchKey.dwLowDateTime) &&
            ((pcsTemp->_ftSearchKey).dwHighDateTime == ftSearchKey.dwHighDateTime))
        {
            pcsRet = pcsTemp;
            break;
        }
        pcsTemp = pcsTemp->_pcsNext;
    }
    if (pcsRet)
        pcsRet->AddRef();
    LEAVECRITICAL;
    return pcsRet;
}
/**********************************************************************/

HRESULT CHistFolderEnum::_NextViewPart_OrderSearch(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched) {
    HRESULT hr      = E_FAIL;
    ULONG   uFetched  = 0;

    TCHAR   szUserName[INTERNET_MAX_USER_NAME_LENGTH + 1];
    DWORD   dwUserNameLen = INTERNET_MAX_USER_NAME_LENGTH + 1;
    if (FAILED(_pHCFolder->_GetUserName(szUserName, dwUserNameLen)))
        szUserName[0] = TEXT('\0');
    UINT    uUserNameLen = lstrlen(szUserName);

    if (_pstatenum == NULL) {
        // This hashtable will eventually be passed off to the background
        //  cache search thread so that it doesn't return duplicates.
        ASSERT(NULL == _pshHashTable)  // don't leak a _pshHashTable
        _pshHashTable = new StrHash(TRUE);
        if (_pshHashTable) {
            IUrlHistoryPriv *pUrlHistStg = _pHCFolder->_GetHistStg();
            if (pUrlHistStg) {
                if (SUCCEEDED((hr = pUrlHistStg->EnumUrls(&_pstatenum))))
                    _pstatenum->SetFilter(NULL, STATURL_QUERYFLAG_TOPLEVEL);
                pUrlHistStg->Release();
            }
        }
    }
    else
        hr = S_OK;

    if (SUCCEEDED(hr)) {
        ASSERT(_pstatenum && _pshHashTable);

        for (uFetched; uFetched < celt;) {
            STATURL staturl = { 0 };
            staturl.cbSize = sizeof(staturl);
            ULONG   celtFetched = 0;
            if (SUCCEEDED((hr = _pstatenum->Next(1, &staturl, &celtFetched)))) {
                if (celtFetched) {
                    ASSERT(celtFetched == 1);
                    if (staturl.pwcsUrl && (staturl.dwFlags & STATURLFLAG_ISTOPLEVEL)) {
                        BOOL fMatch = FALSE;

                        // all this streamsearcher stuff is just like a 'smart' StrStr
                        CacheSearchEngine::StringStream ssUrl(staturl.pwcsUrl);
                        if ((!(fMatch =
                               (_pHCFolder->_pcsCurrentSearch->_streamsearcher).SearchCharStream(ssUrl))) &&
                            staturl.pwcsTitle)
                        {
                            CacheSearchEngine::StringStream ssTitle(staturl.pwcsTitle);
                            fMatch = (_pHCFolder->_pcsCurrentSearch->_streamsearcher).SearchCharStream(ssTitle);
                        }

                        if (fMatch){ // MATCH!
                            // Now, we have to convert the url to a prefixed (ansi, if necessary) url
                            UINT   uUrlLen        = lstrlenW(staturl.pwcsUrl);
                            UINT   uPrefixLen     = HISTPREFIXLEN + uUserNameLen + 1; // '@' and '\0'
                            LPTSTR pszPrefixedUrl =
                                ((LPTSTR)LocalAlloc(LPTR, (uUrlLen + uPrefixLen + 1) * sizeof(TCHAR)));
                            if (pszPrefixedUrl){
                                wnsprintf(pszPrefixedUrl, uPrefixLen + uUrlLen + 1,
                                          TEXT("%s%s@%ls"), c_szHistPrefix, szUserName,
                                          staturl.pwcsUrl);
                                LPHEIPIDL pheiTemp =
                                    _CreateHCacheFolderPidl(TRUE,
                                                            pszPrefixedUrl, staturl.ftLastVisited,
                                                            &staturl, 0,
                                                            _pHCFolder->_GetHitCount(pszPrefixedUrl + uPrefixLen));
                                if (pheiTemp) {
                                    _pshHashTable->insertUnique(pszPrefixedUrl + uPrefixLen, TRUE,
                                                                reinterpret_cast<void *>(1));
                                    rgelt[uFetched++] = (LPITEMIDLIST)pheiTemp;
                                    hr = S_OK;
                                }

                                LocalFree(pszPrefixedUrl);
                                pszPrefixedUrl = NULL;
                            }
                        }
                    }
                    if (staturl.pwcsUrl)
                        OleFree(staturl.pwcsUrl);

                    if (staturl.pwcsTitle)
                        OleFree(staturl.pwcsTitle);
                }
                else {
                    hr = S_FALSE;
                    // Addref this for the ThreadProc who then frees it...
                    AddRef();
                    SHQueueUserWorkItem((LPTHREAD_START_ROUTINE)s_CacheSearchThreadProc,
                                        (void *)this,
                                        0,
                                        (DWORD_PTR)NULL,
                                        (DWORD_PTR *)NULL,
                                        "shdocvw.dll",
                                        0
                                        );
                    break;
                }
            } // succeeded getnext url
        } //for

        if (pceltFetched)
            *pceltFetched = uFetched;
    } // succeeded initalising
    return hr;
}

// helper function for s_CacheSearchThreadProc
BOOL_PTR CHistFolderEnum::s_DoCacheSearch(LPINTERNET_CACHE_ENTRY_INFO pcei,
                                           LPTSTR pszUserName, UINT uUserNameLen,
                                           CHistFolderEnum *penum,
                                           _CurrentSearches *pcsThisThread, IUrlHistoryPriv *pUrlHistStg)
{
    BOOL_PTR   fFound = FALSE;
    LPTSTR pszTextHeader;

    // The header contains "Content-type: text/*"
    if (pcei->lpHeaderInfo && (pszTextHeader = StrStrI(pcei->lpHeaderInfo, c_szTextHeader)))
    {
        // in some cases, urls in the cache differ from urls in the history
        //  by only the trailing slash -- we strip it out and test both
        UINT uUrlLen = lstrlen(pcei->lpszSourceUrlName);
        if (uUrlLen && (pcei->lpszSourceUrlName[uUrlLen - 1] == TEXT('/')))
        {
            pcei->lpszSourceUrlName[uUrlLen - 1] = TEXT('\0');
            fFound = (BOOL_PTR)(penum->_pshHashTable->retrieve(pcei->lpszSourceUrlName));
            pcei->lpszSourceUrlName[uUrlLen - 1] = TEXT('/');
        }

        DWORD dwSize = MAX_URLCACHE_ENTRY;
        // see if its already been found and added...
        if ((!fFound) && !(penum->_pshHashTable->retrieve(pcei->lpszSourceUrlName)))
        {
            BOOL fIsHTML = !StrCmpNI(pszTextHeader + TEXTHEADERLEN, c_szHTML, HTMLLEN);
            // Now, try to find the url in history...

            STATURL staturl;
            HRESULT hrLocal;
            hrLocal = pUrlHistStg->QueryUrl(pcei->lpszSourceUrlName, STATFLAG_NONAME, &staturl);
            if (hrLocal == S_OK)
            {
                HANDLE hCacheStream;

                hCacheStream = RetrieveUrlCacheEntryStream(pcei->lpszSourceUrlName, pcei, &dwSize, FALSE, 0);
                if (hCacheStream)
                {
                    if (CacheSearchEngine::SearchCacheStream(pcsThisThread->_streamsearcher,
                                                             hCacheStream, fIsHTML)) {
                        EVAL(UnlockUrlCacheEntryStream(hCacheStream, 0));

                        // Prefix the url so that we can create a pidl out of it -- for now, we will
                        //  prefix it with "Visited: ", but "Bogus: " may be more appropriate.
                        UINT uUrlLen    = lstrlen(pcei->lpszSourceUrlName);
                        UINT uPrefixLen = HISTPREFIXLEN + uUserNameLen + 1; // '@' and '\0'
                        UINT uBuffSize  = uUrlLen + uPrefixLen + 1;
                        LPTSTR pszPrefixedUrl =
                            ((LPTSTR)LocalAlloc(LPTR, uBuffSize * sizeof(TCHAR)));
                        if (pszPrefixedUrl)
                        {
                            wnsprintf(pszPrefixedUrl, uBuffSize, TEXT("%s%s@%s"), c_szHistPrefix, pszUserName,
                                      pcei->lpszSourceUrlName);

                            // Create a pidl for this url
                            LPITEMIDLIST pidlFound = (LPITEMIDLIST) 
                                penum->_pHCFolder->_CreateHCacheFolderPidlFromUrl(FALSE, pszPrefixedUrl);
                            if (pidlFound)
                            {
                                LPITEMIDLIST pidlNotify = ILCombine(penum->_pHCFolder->_pidl, pidlFound);
                                if (pidlNotify) 
                                {
                                    // add the item to the results list...
                                    /* without the flush, the shell will coalesce these and turn
                                       them info SHChangeNotify(SHCNE_UPDATEDIR,..), which will cause nsc
                                       to do an EnumObjects(), which will start the search up again and again...
                                       */
                                    SHChangeNotify(SHCNE_CREATE, SHCNF_IDLIST | SHCNF_FLUSH, pidlNotify, NULL);
                                    ILFree(pidlNotify);
                                    fFound = TRUE;
                                }

                                LocalFree(pidlFound);
                                pidlFound = NULL;
                            }

                            LocalFree(pszPrefixedUrl);
                            pszPrefixedUrl = NULL;
                        }
                    }
                    else
                        EVAL(UnlockUrlCacheEntryStream(hCacheStream, 0));
                }
            }
            else
                TraceMsg(DM_CACHESEARCH, "In Cache -- Not In History: %s", pcei->lpszSourceUrlName);
        }
    }
    return fFound;
}

DWORD WINAPI CHistFolderEnum::s_CacheSearchThreadProc(CHistFolderEnum *penum)
{
    TCHAR   szUserName[INTERNET_MAX_USER_NAME_LENGTH + 1];
    DWORD   dwUserNameLen = INTERNET_MAX_USER_NAME_LENGTH + 1;

    if (FAILED(penum->_pHCFolder->_GetUserName(szUserName, dwUserNameLen)))
        szUserName[0] = TEXT('\0');
    UINT    uUserNameLen = lstrlen(szUserName);

    BOOL    fNoConflictingSearch = TRUE;

    _CurrentSearches *pcsThisThread = NULL;

    IUrlHistoryPriv *pUrlHistStg = penum->_pHCFolder->_GetHistStg();

    if (pUrlHistStg)
    {

        pcsThisThread = _CurrentSearches::s_FindSearch(penum->_pHCFolder->_pcsCurrentSearch->_ftSearchKey);

        if (pcsThisThread)
        {
            // if no one else is doing the same search
            if (FALSE == InterlockedExchange((LONG *)&(pcsThisThread->_fSearchingAsync), TRUE))
            {
                if (pcsThisThread->_psfscOnAsyncSearch)
                    pcsThisThread->_psfscOnAsyncSearch->RunBegin(0);

                BYTE ab[MAX_URLCACHE_ENTRY];
                LPINTERNET_CACHE_ENTRY_INFO pcei = (LPINTERNET_CACHE_ENTRY_INFO)(&ab);

                DWORD dwSize = MAX_URLCACHE_ENTRY;
                HANDLE hCacheEnum = FindFirstUrlCacheEntry(NULL, pcei, &dwSize);
                if (hCacheEnum)
                {
                    while(!(pcsThisThread->_fKillSwitch))
                    {
                        s_DoCacheSearch(pcei, szUserName, uUserNameLen, penum, pcsThisThread, pUrlHistStg);
                        dwSize = MAX_URLCACHE_ENTRY;
                        if (!FindNextUrlCacheEntry(hCacheEnum, pcei, &dwSize))
                        {
                            ASSERT(GetLastError() == ERROR_NO_MORE_ITEMS);
                            break;
                        }
                    }
                    FindCloseUrlCache(hCacheEnum);
                }

                if (pcsThisThread->_psfscOnAsyncSearch)
                    pcsThisThread->_psfscOnAsyncSearch->RunEnd(0);

                pcsThisThread->_fSearchingAsync = FALSE; // It's been removed - no chance of
                                                         // a race condition
            }
            pcsThisThread->Release();
        }
        ATOMICRELEASE(pUrlHistStg);
    }
    ATOMICRELEASE(penum);
    return 0;
}


//
//  this gets the local host name as known by the shell
//  by default assume "My Computer" or whatever
//
void _GetLocalHost(LPTSTR psz, DWORD cch)
{
    *psz = 0;

    IShellFolder* psf;
    if (SUCCEEDED(SHGetDesktopFolder(&psf)))
    {
        WCHAR sz[GUIDSTR_MAX + 3];

        sz[0] = sz[1] = TEXT(':');
        SHStringFromGUIDW(CLSID_MyComputer, sz+2, SIZECHARS(sz)-2);

        LPITEMIDLIST pidl;
        if (SUCCEEDED(psf->ParseDisplayName(NULL, NULL, sz, NULL, &pidl, NULL)))
        {
            STRRET sr;
            if (SUCCEEDED(psf->GetDisplayNameOf(pidl, SHGDN_NORMAL, &sr)))
                StrRetToBuf(&sr, pidl, psz, cch);
            ILFree(pidl);
        }

        psf->Release();
    }

    if (!*psz)
        MLLoadString(IDS_NOTNETHOST, psz, cch);
}

LPCTSTR CHistFolderEnum::_GetLocalHost(void)
{
    if (!*_szLocalHost)
        ::_GetLocalHost(_szLocalHost, SIZECHARS(_szLocalHost));

    return _szLocalHost;
}

//////////////////////////////////
//
// IEnumIDList Methods
//
HRESULT CHistFolderEnum::Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched)
{
    HRESULT hr             = S_FALSE;
    DWORD   dwBuffSize;
    DWORD   dwError;
    LPTSTR  pszSearchPattern = NULL;
    TCHAR   szUserName[INTERNET_MAX_USER_NAME_LENGTH + 1];      // username of person logged on
    DWORD   dwUserNameLen = INTERNET_MAX_USER_NAME_LENGTH + 1;  // len of this buffer
    TCHAR   szHistSearchPattern[PREFIX_SIZE + 1];               // search pattern for history items
    TCHAR   szHost[INTERNET_MAX_HOST_NAME_LENGTH+1];

    TraceMsg(DM_HSFOLDER, "hcfe - Next() called.");

    if (_pHCFolder->_uViewType)
        return _NextViewPart(celt, rgelt, pceltFetched);

    if ((IsLeaf(_pHCFolder->_foldertype) && 0 == (SHCONTF_NONFOLDERS & _grfFlags)) ||
        (!IsLeaf(_pHCFolder->_foldertype) && 0 == (SHCONTF_FOLDERS & _grfFlags)))
    {
        dwError = 0xFFFFFFFF;
        goto exitPoint;
    }

    if (FOLDER_TYPE_Hist == _pHCFolder->_foldertype)
    {
        return _NextHistInterval(celt, rgelt, pceltFetched);
    }

    if (_pceiWorking == NULL)
    {
        _pceiWorking = (LPINTERNET_CACHE_ENTRY_INFO)LocalAlloc(LPTR, MAX_URLCACHE_ENTRY);
        if (_pceiWorking == NULL)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exitPoint;
        }
    }

    // Set up things to enumerate history items, if appropriate, otherwise,
    // we'll just pass in NULL and enumerate all items as before.

    if (!_hEnum)
    {
        if (FAILED(_pHCFolder->_ValidateIntervalCache()))
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exitPoint;
        }
    }

    if (FAILED(_pHCFolder->_GetUserName(szUserName, dwUserNameLen)))
        szUserName[0] = TEXT('\0');

    StrCpyN(szHistSearchPattern, _pHCFolder->_pszCachePrefix, ARRAYSIZE(szHistSearchPattern));

    // We can't pass in the whole search pattern that we want,
    // because FindFirstUrlCacheEntry is busted.  It will only look at the
    // prefix if there is a cache container for that prefix.  So, we can
    // pass in "Visited: " and enumerate all the history items in the cache,
    // but then we need to pull out only the ones with the correct username.

    // StrCpy(szHistSearchPattern, szUserName);

    pszSearchPattern = szHistSearchPattern;

TryAgain:

    dwBuffSize = MAX_URLCACHE_ENTRY;
    dwError = S_OK;

    if (!_hEnum) // _hEnum maintains our state as we iterate over all the cache entries
    {
       _hEnum = FindFirstUrlCacheEntry(pszSearchPattern, _pceiWorking, &dwBuffSize);
       if (!_hEnum)
           dwError = GetLastError();
    }

    else if (!FindNextUrlCacheEntry(_hEnum, _pceiWorking, &dwBuffSize))
    {
        dwError = GetLastError();
    }

    if (S_OK == dwError)
    {
        LPBASEPIDL pcei = NULL;

        TCHAR szTempStrippedUrl[MAX_URL_STRING];
        LPCTSTR pszStrippedUrl;
        BOOL fIsHost;
        LPCTSTR pszHost;

    //mm:  Make sure that this cache entry belongs to szUserName (relevant to Win95)
        if (!_FilterUserName(_pceiWorking, _pHCFolder->_pszCachePrefix, szUserName))
            goto TryAgain;

        StrCpyN(szTempStrippedUrl, _pceiWorking->lpszSourceUrlName, ARRAYSIZE(szTempStrippedUrl));
        pszStrippedUrl = _StripHistoryUrlToUrl(szTempStrippedUrl);
        if ((DWORD)lstrlen(pszStrippedUrl) > HOSTPREFIXLEN)
        {
            pszHost = &pszStrippedUrl[HOSTPREFIXLEN];
            fIsHost = !StrCmpNI(c_szHostPrefix, pszStrippedUrl, HOSTPREFIXLEN);
        }
        else
        {
            fIsHost = FALSE;
        }
    //mm:  this is most likely domains:
        if (FOLDER_TYPE_HistInterval == _pHCFolder->_foldertype) // return unique domains
        {
            if (!fIsHost)
                goto TryAgain;

            pcei = _CreateIdCacheFolderPidl(TRUE, IDDPIDL_SIGN, pszHost);
        }
        else if (NULL != _pHCFolder->_pszDomain) //mm: this must be docs
        {
            TCHAR szSourceUrl[MAX_URL_STRING];
            STATURL suThis;
            HRESULT hrLocal = E_FAIL;
            IUrlHistoryPriv *pUrlHistStg = NULL;

            if (fIsHost)
                goto TryAgain;

            //  Filter domain in history view!
            _GetURLHost(_pceiWorking, szHost, INTERNET_MAX_HOST_NAME_LENGTH, _GetLocalHost());

            if (StrCmpI(szHost, _pHCFolder->_pszDomain)) //mm: is this in our domain?!
                goto TryAgain;

            pUrlHistStg = _pHCFolder->_GetHistStg();
            if (pUrlHistStg)
            {
                CHAR szTempUrl[MAX_URL_STRING];

                SHTCharToAnsi(pszStrippedUrl, szTempUrl, ARRAYSIZE(szTempUrl));
                hrLocal = pUrlHistStg->QueryUrlA(szTempUrl, STATURL_QUERYFLAG_NOURL, &suThis);
                pUrlHistStg->Release();
            }

            StrCpyN(szSourceUrl, _pceiWorking->lpszSourceUrlName, ARRAYSIZE(szSourceUrl));
            pcei = (LPBASEPIDL) _CreateHCacheFolderPidl(TRUE,
                                                       szSourceUrl,
                                                       _pceiWorking->LastModifiedTime,
                                                       (SUCCEEDED(hrLocal) ? &suThis : NULL), 0,
                                                       _pHCFolder->_GetHitCount(_StripHistoryUrlToUrl(szSourceUrl)));

            if (SUCCEEDED(hrLocal) && suThis.pwcsTitle)
                OleFree(suThis.pwcsTitle);
        }
        if (pcei)
        {
            rgelt[0] = (LPITEMIDLIST)pcei;
           if (pceltFetched)
               *pceltFetched = 1;
        }
        else
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

exitPoint:

    if (dwError != S_OK)
    {
        if (_hEnum)
        {
            FindCloseUrlCache(_hEnum);
            _hEnum = NULL;
        }
        if (pceltFetched)
            *pceltFetched = 0;
        rgelt[0] = NULL;
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }
    return hr;
}

HRESULT CHistFolderEnum::Skip(ULONG celt)
{
    TraceMsg(DM_HSFOLDER, "hcfe - Skip() called.");
    return E_NOTIMPL;
}

HRESULT CHistFolderEnum::Reset()
{
    TraceMsg(DM_HSFOLDER, "hcfe - Reset() called.");
    return E_NOTIMPL;
}

HRESULT CHistFolderEnum::Clone(IEnumIDList **ppenum)
{
    TraceMsg(DM_HSFOLDER, "hcfe - Clone() called.");
    return E_NOTIMPL;
}


//////////////////////////////////////////////////////////////////////////////
//
// CHistFolder Object
//
//////////////////////////////////////////////////////////////////////////////

CHistFolder::CHistFolder(FOLDER_TYPE FolderType)
{
    TraceMsg(DM_HSFOLDER, "hcf - CHistFolder() called.");
    _cRef = 1;
    _foldertype = FolderType;
    ASSERT( _uViewType  == 0 &&
            _uViewDepth  == 0 &&
            _pszCachePrefix == NULL &&
            _pszDomain == NULL &&
            _cbIntervals == 0 &&
            _pIntervalCache == NULL &&
            _fValidatingCache == FALSE &&
            _dwIntervalCached == 0 &&
            _ftDayCached.dwHighDateTime == 0 &&
            _ftDayCached.dwLowDateTime == 0 &&
            _pidl == NULL );
    DllAddRef();
}

CHistFolder::~CHistFolder()
{
    ASSERT(_cRef == 0);                 // should always have zero
    TraceMsg(DM_HSFOLDER, "hcf - ~CHistFolder() called.");
    if (_pIntervalCache)
    {
        LocalFree(_pIntervalCache);
        _pIntervalCache = NULL;
    }
    if (_pszCachePrefix)
    {
        LocalFree(_pszCachePrefix);
        _pszCachePrefix = NULL;
    }
    if (_pszDomain)
    {
        LocalFree(_pszDomain);
        _pszDomain = NULL;
    }
    if (_pidl)
        ILFree(_pidl);
    if (_pUrlHistStg)
    {
        _pUrlHistStg->Release();
        _pUrlHistStg = NULL;
    }
    if (_pcsCurrentSearch)
        _pcsCurrentSearch->Release();

    DllRelease();
}

LPITEMIDLIST _Combine_ViewPidl(USHORT usViewType, LPITEMIDLIST pidl)
{
    LPITEMIDLIST pidlResult = NULL;
    LPVIEWPIDL pviewpidl = (LPVIEWPIDL)SHAlloc(sizeof(VIEWPIDL) + sizeof(USHORT));
    if (pviewpidl)
    {
        memset(pviewpidl, 0, sizeof(VIEWPIDL) + sizeof(USHORT));
        pviewpidl->cb         = sizeof(VIEWPIDL);
        pviewpidl->usSign     = VIEWPIDL_SIGN;
        pviewpidl->usViewType = usViewType;
        ASSERT(pviewpidl->usExtra == 0);//pcei->usSign;
        if (pidl) 
        {
            pidlResult = ILCombine((LPITEMIDLIST)pviewpidl, pidl);
            SHFree(pviewpidl);
        }
        else
            pidlResult = (LPITEMIDLIST)pviewpidl;
    }
    return pidlResult;
}

STDMETHODIMP CHistFolder::_GetDetail(LPCITEMIDLIST pidl, UINT iColumn, LPTSTR pszStr, UINT cchStr)
{
    *pszStr = 0;

    switch (iColumn)
    {
    case ICOLH_URL_NAME:
        if (_IsLeaf())
            StrCpyN(pszStr, _StripHistoryUrlToUrl(HPidlToSourceUrl((LPBASEPIDL)pidl)), cchStr);
        else
            _GetURLDispName((LPBASEPIDL)pidl, pszStr, cchStr);
        break;

    case ICOLH_URL_TITLE:
        _GetHistURLDispName((LPHEIPIDL)pidl, pszStr, cchStr);
        break;

    case ICOLH_URL_LASTVISITED:
        FileTimeToDateTimeStringInternal(&((LPHEIPIDL)pidl)->ftModified, pszStr, cchStr, TRUE);
        break;
    }
    return S_OK;
}

HRESULT CHistFolder::GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pdi)
{
    HRESULT hr;

    const COLSPEC *pcol;
    UINT nCols;

    if (_foldertype == FOLDER_TYPE_Hist)
    {
        pcol = s_HistIntervalFolder_cols;
        nCols = ARRAYSIZE(s_HistIntervalFolder_cols);
    }
    else if (_foldertype == FOLDER_TYPE_HistInterval)
    {
        pcol = s_HistHostFolder_cols;
        nCols = ARRAYSIZE(s_HistHostFolder_cols);
    }
    else
    {
        pcol = s_HistFolder_cols;
        nCols = ARRAYSIZE(s_HistFolder_cols);
    }

    if (pidl == NULL)
    {
        if (iColumn < nCols)
        {
            TCHAR szTemp[128];
            pdi->fmt = pcol[iColumn].iFmt;
            pdi->cxChar = pcol[iColumn].cchCol;
            MLLoadString(pcol[iColumn].ids, szTemp, ARRAYSIZE(szTemp));
            hr = StringToStrRet(szTemp, &pdi->str);
        }
        else
            hr = E_FAIL;  // enum done
    }
    else
    {
        // Make sure the pidl is dword aligned.

        if(iColumn >= nCols)
            hr = E_FAIL;
        else
        {
            BOOL fRealigned;
            hr = AlignPidl(&pidl, &fRealigned);

            if (SUCCEEDED(hr) )
            {
                TCHAR szTemp[MAX_URL_STRING];
                hr = _GetDetail(pidl, iColumn, szTemp, ARRAYSIZE(szTemp));
                if (SUCCEEDED(hr))
                    hr = StringToStrRet(szTemp, &pdi->str);

            }
            if (fRealigned)
                FreeRealignedPidl(pidl);
        }
    }
    return hr;
}

STDAPI HistFolder_CreateInstance(IUnknown* punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    *ppunk = NULL;                     // null the out param

    if (punkOuter)
        return CLASS_E_NOAGGREGATION;

    CHistFolder *phist = new CHistFolder(FOLDER_TYPE_Hist);
    if (!phist)
        return E_OUTOFMEMORY;

    *ppunk = SAFECAST(phist, IShellFolder2*);
    return S_OK;
}

HRESULT CHistFolder::QueryInterface(REFIID iid, void **ppv)
{
    static const QITAB qitHist[] = {
        QITABENT(CHistFolder, IShellFolder2),
        QITABENTMULTI(CHistFolder, IShellFolder, IShellFolder2),
        QITABENT(CHistFolder, IShellIcon),
        QITABENT(CHistFolder, IPersistFolder2),
        QITABENTMULTI(CHistFolder, IPersistFolder, IPersistFolder2),
        QITABENTMULTI(CHistFolder, IPersist, IPersistFolder2),
        QITABENT(CHistFolder, IHistSFPrivate),
        QITABENT(CHistFolder, IShellFolderViewType),
        QITABENT(CHistFolder, IShellFolderSearchable),
        { 0 },
    };

    if (iid == IID_IPersistFolder)
    {
        if (FOLDER_TYPE_Hist != _foldertype)
        {
            *ppv = NULL;
            return E_NOINTERFACE;
        }
    }
    else if (iid == CLSID_HistFolder)
    {
        *ppv = (void *)(CHistFolder *)this;
        AddRef();
        return S_OK;
    }

    return QISearch(this, qitHist, iid, ppv);
}

ULONG CHistFolder::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CHistFolder::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CHistFolder::_ExtractInfoFromPidl()
{
    LPITEMIDLIST pidlThis;
    LPITEMIDLIST pidlLast = NULL;
    LPITEMIDLIST pidlSecondLast = NULL;

    ASSERT(!_uViewType);

    pidlThis = _pidl;
    while (pidlThis->mkid.cb)
    {
        pidlSecondLast = pidlLast;
        pidlLast = pidlThis;
        pidlThis = _ILNext(pidlThis);
    }
    switch (_foldertype)
    {
    case FOLDER_TYPE_Hist:
        _pidlRest = pidlThis;
        break;
    case FOLDER_TYPE_HistInterval:
        _pidlRest = pidlLast;
        break;
    case FOLDER_TYPE_HistDomain:
        _pidlRest = pidlSecondLast;
        break;
    default:
        _pidlRest = NULL;
    }

    HRESULT hr = NULL == _pidlRest ? E_FAIL : S_OK;

    pidlThis = _pidlRest;
    while (SUCCEEDED(hr) && pidlThis->mkid.cb)
    {
        if (_IsValid_IDPIDL(pidlThis))
        {
            LPBASEPIDL pcei = (LPBASEPIDL)pidlThis;
            TCHAR szUrlTitle[MAX_URL_STRING];
            PCTSTR pszUrlTitle = _GetURLTitleAlign((LPBASEPIDL)pidlThis, szUrlTitle, ARRAYSIZE(szUrlTitle));

            if (EQUIV_IDSIGN(pcei->usSign, IDIPIDL_SIGN)) // This is our interval, it implies prefix
            {
                LPCTSTR pszCachePrefix;

                if (_foldertype == FOLDER_TYPE_Hist) 
                    _foldertype = FOLDER_TYPE_HistInterval;

                hr = _LoadIntervalCache();
                if (SUCCEEDED(hr))
                {
                    hr = _GetPrefixForInterval(pszUrlTitle, &pszCachePrefix);
                    if (SUCCEEDED(hr))
                    {
                        hr = SetCachePrefix(pszCachePrefix);
                    }
                }
            }
            else                              // This is our domain
            {
                if (_foldertype == FOLDER_TYPE_HistInterval)
                    _foldertype = FOLDER_TYPE_HistDomain;
                SetDomain(pszUrlTitle);
            }
        }
        pidlThis = _ILNext(pidlThis);
    }

    if (SUCCEEDED(hr))
    {
        switch (_foldertype)
        {
        case FOLDER_TYPE_HistDomain:
            if (_pszDomain == NULL)
                hr = E_FAIL;
            //FALL THROUGH INTENDED
        case FOLDER_TYPE_HistInterval:
            if (_pszCachePrefix == NULL)
                hr = E_FAIL;
            break;
        }
    }
    return hr;
}

void _SetValueSign(HSFINTERVAL *pInterval, FILETIME ftNow)
{
    if (_DaysInInterval(pInterval) == 1 && !CompareFileTime(&(pInterval->ftStart), &ftNow))
    {
        pInterval->usSign = IDTPIDL_SIGN;
    }
    else
    {
        pInterval->usSign = IDIPIDL_SIGN;
    }
}

void _SetVersion(HSFINTERVAL *pInterval, LPCSTR szInterval)
{
    USHORT usVers = 0;
    int i;
    DWORD dwIntervalLen = lstrlenA(szInterval);

    //  Unknown versions are 0
    if (dwIntervalLen == INTERVAL_SIZE)
    {
        for (i = INTERVAL_PREFIX_LEN; i < INTERVAL_PREFIX_LEN+INTERVAL_VERS_LEN; i++)
        {
            if ('0' > szInterval[i] || '9' < szInterval[i])
            {
                usVers = UNK_INTERVAL_VERS;
                break;
            }
            usVers = usVers * 10 + (szInterval[i] - '0');
        }
    }
    pInterval->usVers = usVers;
}

#ifdef UNICODE
#define _ValueToInterval           _ValueToIntervalW
#else // UNICODE
#define _ValueToInterval           _ValueToIntervalA
#endif // UNICODE

HRESULT _ValueToIntervalA(LPCSTR szInterval, FILETIME *pftStart, FILETIME *pftEnd)
{
    int i;
    int iBase;
    HRESULT hr = E_FAIL;
    SYSTEMTIME sysTime;
    unsigned int digits[RANGE_LEN];

    iBase = lstrlenA(szInterval)-RANGE_LEN;
    for (i = 0; i < RANGE_LEN; i++)
    {
        digits[i] = szInterval[i+iBase] - '0';
        if (digits[i] > 9) goto exitPoint;
    }

    ZeroMemory(&sysTime, sizeof(sysTime));
    sysTime.wYear = digits[0]*1000 + digits[1]*100 + digits[2] * 10 + digits[3];
    sysTime.wMonth = digits[4] * 10 + digits[5];
    sysTime.wDay = digits[6] * 10 + digits[7];
    if (!SystemTimeToFileTime(&sysTime, pftStart)) goto exitPoint;

    ZeroMemory(&sysTime, sizeof(sysTime));
    sysTime.wYear = digits[8]*1000 + digits[9]*100 + digits[10] * 10 + digits[11];
    sysTime.wMonth = digits[12] * 10 + digits[13];
    sysTime.wDay = digits[14] * 10 + digits[15];
    if (!SystemTimeToFileTime(&sysTime, pftEnd)) goto exitPoint;

    //  Intervals are open on the end, so end should be strictly > start
    if (CompareFileTime(pftStart, pftEnd) >= 0) goto exitPoint;

    hr = S_OK;

exitPoint:
    return hr;
}

HRESULT _ValueToIntervalW(LPCUWSTR wzInterval, FILETIME *pftStart, FILETIME *pftEnd)
{
    CHAR szInterval[MAX_PATH];
    LPCWSTR wzAlignedInterval;

    WSTR_ALIGNED_STACK_COPY( &wzAlignedInterval,
                             wzInterval );

    ASSERT(lstrlenW(wzAlignedInterval) < ARRAYSIZE(szInterval));
    UnicodeToAnsi(wzAlignedInterval, szInterval, ARRAYSIZE(szInterval));
    return _ValueToIntervalA((LPCSTR) szInterval, pftStart, pftEnd);
}

HRESULT CHistFolder::_LoadIntervalCache()
{
    HRESULT hr;
    DWORD dwLastModified;
    DWORD dwValueIndex;
    DWORD dwPrefixIndex;
    HSFINTERVAL     *pIntervalCache = NULL;
    struct {
        INTERNET_CACHE_CONTAINER_INFOA cInfo;
        char szBuffer[MAX_PATH+MAX_PATH];
    } ContainerInfo;
    DWORD dwContainerInfoSize;
    CHAR chSave;
    HANDLE hContainerEnum;
    BOOL fContinue = TRUE;
    FILETIME ftNow;
    SYSTEMTIME st;
    DWORD dwOptions;

    GetLocalTime (&st);
    SystemTimeToFileTime(&st, &ftNow);
    _FileTimeDeltaDays(&ftNow, &ftNow, 0);

    dwLastModified = _dwIntervalCached;
    dwContainerInfoSize = sizeof(ContainerInfo);
    if (_pIntervalCache == NULL || CompareFileTime(&ftNow, &_ftDayCached))
    {
        dwOptions = 0;
    }
    else
    {
        dwOptions = CACHE_FIND_CONTAINER_RETURN_NOCHANGE;
    }
    hContainerEnum = FindFirstUrlCacheContainerA(&dwLastModified,
                            &ContainerInfo.cInfo,
                            &dwContainerInfoSize,
                            dwOptions);
    if (hContainerEnum == NULL)
    {
        DWORD err = GetLastError();

        if (err == ERROR_NO_MORE_ITEMS)
        {
            fContinue = FALSE;
        }
        else if (err == ERROR_INTERNET_NO_NEW_CONTAINERS)
        {
            hr = S_OK;
            goto exitPoint;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(err);
            goto exitPoint;
        }
    }

    //  Guarantee we return S_OK we have _pIntervalCache even if we haven't
    //  yet created the interval registry keys.
    dwPrefixIndex = 0;
    dwValueIndex = TYPICAL_INTERVALS;
    pIntervalCache = (HSFINTERVAL *) LocalAlloc(LPTR, dwValueIndex*sizeof(HSFINTERVAL));
    if (!pIntervalCache)
    {
        hr = E_OUTOFMEMORY;
        goto exitPoint;
    }

    //  All of our intervals map to cache containers starting with
    //  c_szIntervalPrefix followed by YYYYMMDDYYYYMMDD
    while (fContinue)
    {
        chSave = ContainerInfo.cInfo.lpszName[INTERVAL_PREFIX_LEN];
        ContainerInfo.cInfo.lpszName[INTERVAL_PREFIX_LEN] = '\0';
        if (!StrCmpIA(ContainerInfo.cInfo.lpszName, c_szIntervalPrefix))
        {
            ContainerInfo.cInfo.lpszName[INTERVAL_PREFIX_LEN] = chSave;
            DWORD dwCNameLen;

            if (dwPrefixIndex >= dwValueIndex)
            {
                HSFINTERVAL     *pIntervalCacheNew;

                pIntervalCacheNew = (HSFINTERVAL *) LocalReAlloc(pIntervalCache,
                    (dwValueIndex*2)*sizeof(HSFINTERVAL),
                    LMEM_ZEROINIT|LMEM_MOVEABLE);
                if (pIntervalCacheNew == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto exitPoint;
                }
                pIntervalCache = pIntervalCacheNew;
                dwValueIndex *= 2;
            }

            dwCNameLen = lstrlenA(ContainerInfo.cInfo.lpszName);
            if (dwCNameLen <= INTERVAL_SIZE && dwCNameLen >= INTERVAL_MIN_SIZE &&
                lstrlenA(ContainerInfo.cInfo.lpszCachePrefix) == PREFIX_SIZE)
            {
                _SetVersion(&pIntervalCache[dwPrefixIndex], ContainerInfo.cInfo.lpszName);
                if (pIntervalCache[dwPrefixIndex].usVers != UNK_INTERVAL_VERS)
                {
                    AnsiToTChar(ContainerInfo.cInfo.lpszCachePrefix, pIntervalCache[dwPrefixIndex].szPrefix, ARRAYSIZE(pIntervalCache[dwPrefixIndex].szPrefix));
                    hr = _ValueToIntervalA( ContainerInfo.cInfo.lpszName,
                                             &pIntervalCache[dwPrefixIndex].ftStart,
                                             &pIntervalCache[dwPrefixIndex].ftEnd);
                    if (FAILED(hr)) 
                        goto exitPoint;
                    _SetValueSign(&pIntervalCache[dwPrefixIndex], ftNow);
                    dwPrefixIndex++;
                }
                else
                {
                    pIntervalCache[dwPrefixIndex].usVers = 0;
                }
            }
            //
            // HACK! IE5 bld 807 created containers with prefix length PREFIX_SIZE - 1.
            // Delete these entries so history shows up for anyone upgrading over this
            // build.  Delete this code!  (edwardp 8/8/98)
            //
            else if (dwCNameLen <= INTERVAL_SIZE && dwCNameLen >= INTERVAL_MIN_SIZE &&
                     lstrlenA(ContainerInfo.cInfo.lpszCachePrefix) == PREFIX_SIZE - 1)
            {
                DeleteUrlCacheContainerA(ContainerInfo.cInfo.lpszName, 0);
            }
        }
        dwContainerInfoSize = sizeof(ContainerInfo);
        fContinue = FindNextUrlCacheContainerA(hContainerEnum,
                            &ContainerInfo.cInfo,
                            &dwContainerInfoSize);
    }

    hr = S_OK;
    _dwIntervalCached = dwLastModified;
    _ftDayCached = ftNow;

    {
        ENTERCRITICAL;
        if (_pIntervalCache)
        {
            LocalFree(_pIntervalCache);
            _pIntervalCache = NULL;
        }
        _pIntervalCache = pIntervalCache;
        LEAVECRITICAL;
    }
    _cbIntervals = dwPrefixIndex;
    // because it will be freed by our destructor
    pIntervalCache  = NULL;

exitPoint:
    if (hContainerEnum) FindCloseUrlCache(hContainerEnum);
    if (pIntervalCache)
    {
        LocalFree(pIntervalCache);
        pIntervalCache = NULL;
    }

    return hr;
}

//  Returns true if *pftItem falls in the days *pftStart..*pftEnd inclusive
BOOL _InInterval(FILETIME *pftStart, FILETIME *pftEnd, FILETIME *pftItem)
{
    return (CompareFileTime(pftStart,pftItem) <= 0 && CompareFileTime(pftItem,pftEnd) < 0);
}

//  Truncates filetime increments beyond the day and then deltas by Days and converts back
//  to FILETIME increments
void _FileTimeDeltaDays(FILETIME *pftBase, FILETIME *pftNew, int Days)
{
    _int64 i64Base;

    i64Base = (((_int64)pftBase->dwHighDateTime) << 32) | pftBase->dwLowDateTime;
    i64Base /= FILE_SEC_TICKS;
    i64Base /= DAY_SECS;
    i64Base += Days;
    i64Base *= FILE_SEC_TICKS;
    i64Base *= DAY_SECS;
    pftNew->dwHighDateTime = (DWORD) ((i64Base >> 32) & 0xFFFFFFFF);
    pftNew->dwLowDateTime = (DWORD) (i64Base & 0xFFFFFFFF);
}

DWORD _DaysInInterval(HSFINTERVAL *pInterval)
{
    _int64 i64Start;
    _int64 i64End;

    i64Start = (((_int64)pInterval->ftStart.dwHighDateTime) << 32) | pInterval->ftStart.dwLowDateTime;
    i64Start /= FILE_SEC_TICKS;
    i64Start /= DAY_SECS;
    i64End = (((_int64)pInterval->ftEnd.dwHighDateTime) << 32) | pInterval->ftEnd.dwLowDateTime;
    i64End /= FILE_SEC_TICKS;
    i64End /= DAY_SECS;
    // NOTE: the lower bound is closed, upper is open (ie first tick of next day)
    return (DWORD) (i64End - i64Start);
}

//  Returns S_OK if found, S_FALSE if not, error on error
//  finds weekly interval in preference to daily if both exist
HRESULT CHistFolder::_GetInterval(FILETIME *pftItem, BOOL fWeekOnly, HSFINTERVAL **ppInterval)
{
    HRESULT hr = E_FAIL;
    HSFINTERVAL *pReturn = NULL;
    int i;
    HSFINTERVAL *pDailyInterval = NULL;

    if (NULL == _pIntervalCache) goto exitPoint;

    for (i = 0; i < _cbIntervals; i ++)
    {
        if (_pIntervalCache[i].usVers == OUR_VERS)
        {
            if (_InInterval(&_pIntervalCache[i].ftStart,
                            &_pIntervalCache[i].ftEnd,
                            pftItem))
            {
                if (7 != _DaysInInterval(&_pIntervalCache[i]))
                {
                    if (!fWeekOnly)
                    {
                        pDailyInterval = &_pIntervalCache[i];
                    }
                    continue;
                }
                else
                {
                    pReturn = &_pIntervalCache[i];
                    hr = S_OK;
                    goto exitPoint;
                }
            }
        }
    }

    pReturn = pDailyInterval;
    hr = pReturn ? S_OK : S_FALSE;

exitPoint:
    if (ppInterval) *ppInterval = pReturn;
    return hr;
}

HRESULT CHistFolder::_GetPrefixForInterval(LPCTSTR pszInterval, LPCTSTR *ppszCachePrefix)
{
    HRESULT hr = E_FAIL;
    int i;
    LPCTSTR pszReturn = NULL;
    FILETIME ftStart;
    FILETIME ftEnd;

    if (NULL == _pIntervalCache) goto exitPoint;

    hr = _ValueToInterval(pszInterval, &ftStart, &ftEnd);
    if (FAILED(hr)) 
        goto exitPoint;

    for (i = 0; i < _cbIntervals; i ++)
    {
        if(_pIntervalCache[i].usVers == OUR_VERS)
        {
            if (CompareFileTime(&_pIntervalCache[i].ftStart,&ftStart) == 0 &&
                CompareFileTime(&_pIntervalCache[i].ftEnd,&ftEnd) == 0)
            {
                pszReturn = _pIntervalCache[i].szPrefix;
                hr = S_OK;
                break;
            }
        }
    }

    hr = pszReturn ? S_OK : S_FALSE;

exitPoint:
    if (ppszCachePrefix) *ppszCachePrefix = pszReturn;
    return hr;
}

void _KeyForInterval(HSFINTERVAL *pInterval, LPTSTR pszInterval, int cchInterval)
{
    SYSTEMTIME stStart;
    SYSTEMTIME stEnd;
    CHAR szVers[3];
#ifndef UNIX
    CHAR szTempBuff[MAX_PATH];
#else
    CHAR szTempBuff[INTERVAL_SIZE+1];
#endif

    ASSERT(pInterval->usVers!=UNK_INTERVAL_VERS && pInterval->usVers < 100);

    if (pInterval->usVers)
    {
        wnsprintfA(szVers, ARRAYSIZE(szVers), "%02lu", (ULONG) (pInterval->usVers));
    }
    else
    {
        szVers[0] = '\0';
    }
    FileTimeToSystemTime(&pInterval->ftStart, &stStart);
    FileTimeToSystemTime(&pInterval->ftEnd, &stEnd);
    wnsprintfA(szTempBuff, ARRAYSIZE(szTempBuff),
             "%s%s%04lu%02lu%02lu%04lu%02lu%02lu",
             c_szIntervalPrefix,
             szVers,
             (ULONG) stStart.wYear,
             (ULONG) stStart.wMonth,
             (ULONG) stStart.wDay,
             (ULONG) stEnd.wYear,
             (ULONG) stEnd.wMonth,
             (ULONG) stEnd.wDay);

    AnsiToTChar(szTempBuff, pszInterval, cchInterval);
}

LPITEMIDLIST CHistFolder::_HostPidl(LPCTSTR pszHostUrl, HSFINTERVAL *pInterval)
{
    ASSERT(!_uViewType)
    LPITEMIDLIST pidlReturn;
    LPITEMIDLIST pidl;
    struct _HOSTIDL
    {
        USHORT cb;
        USHORT usSign;
        TCHAR szHost[INTERNET_MAX_HOST_NAME_LENGTH+1];
    } HostIDL;
    struct _INTERVALIDL
    {
        USHORT cb;
        USHORT usSign;
        TCHAR szInterval[INTERVAL_SIZE+1];
        struct _HOSTIDL hostIDL;
        USHORT cbTrail;
    } IntervalIDL;
    LPBYTE pb;
    USHORT cbSave;

    ASSERT(_pidlRest);
    pidl = _pidlRest;
    cbSave = pidl->mkid.cb;
    pidl->mkid.cb = 0;

    ZeroMemory(&IntervalIDL, sizeof(IntervalIDL));
    IntervalIDL.usSign = pInterval->usSign;
    _KeyForInterval(pInterval, IntervalIDL.szInterval, ARRAYSIZE(IntervalIDL.szInterval));
    IntervalIDL.cb = (USHORT)(2*sizeof(USHORT)+ (lstrlen(IntervalIDL.szInterval) + 1) * sizeof(TCHAR));

    pb = ((LPBYTE) (&IntervalIDL)) + IntervalIDL.cb;
    StrCpyN((LPTSTR)(pb+2*sizeof(USHORT)), pszHostUrl,
            (sizeof(IntervalIDL) - (IntervalIDL.cb + (3 * sizeof(USHORT)))) / sizeof(TCHAR));

    HostIDL.usSign = (USHORT)IDDPIDL_SIGN;
    HostIDL.cb = (USHORT)(2*sizeof(USHORT)+(lstrlen((LPTSTR)(pb+2*sizeof(USHORT))) + 1) * sizeof(TCHAR));

    memcpy(pb, &HostIDL, 2*sizeof(USHORT));
    *(USHORT *)(&pb[HostIDL.cb]) = 0;  // terminate the HostIDL ItemID

    pidlReturn = ILCombine(_pidl, (LPITEMIDLIST) (&IntervalIDL));
    pidl->mkid.cb = cbSave;
    return pidlReturn;
}

// Notify that an event has occured that affects a specific element in
//  history for special viewtypes
HRESULT CHistFolder::_ViewType_NotifyEvent(IN LPITEMIDLIST pidlRoot,
                                                IN LPITEMIDLIST pidlHost,
                                                IN LPITEMIDLIST pidlPage,
                                                IN LONG         wEventId)
{
    HRESULT hr = S_OK;

    ASSERT(pidlRoot && pidlHost && pidlPage);

    // VIEPWIDL_ORDER_TODAY
    LPITEMIDLIST pidlToday = _Combine_ViewPidl(VIEWPIDL_ORDER_TODAY, pidlPage);
    if (pidlToday) 
    {
        LPITEMIDLIST pidlNotify = ILCombine(pidlRoot, pidlToday);
        if (pidlNotify) 
        {
            SHChangeNotify(wEventId, SHCNF_IDLIST, pidlNotify, NULL);
            ILFree(pidlNotify);
        }
        ILFree(pidlToday);
    }

    // VIEWPIDL_ORDER_SITE
    LPITEMIDLIST pidlSite = _Combine_ViewPidl(VIEWPIDL_ORDER_SITE, pidlHost);
    if (pidlSite) 
    {
        LPITEMIDLIST pidlSitePage = ILCombine(pidlSite, pidlPage);
        if (pidlSitePage) 
        {
            LPITEMIDLIST pidlNotify = ILCombine(pidlRoot, pidlSitePage);
            if (pidlNotify) 
            {
                SHChangeNotify(wEventId, SHCNF_IDLIST, pidlNotify, NULL);
                ILFree(pidlNotify);
            }
            ILFree(pidlSitePage);
        }
        ILFree(pidlSite);
    }

    return hr;
}

LPCTSTR CHistFolder::_GetLocalHost(void)
{
    if (!*_szLocalHost)
        ::_GetLocalHost(_szLocalHost, SIZECHARS(_szLocalHost));

    return _szLocalHost;
}

//  NOTE: modifies pszUrl.
HRESULT CHistFolder::_NotifyWrite(LPTSTR pszUrl, int cchUrl, FILETIME *pftModified,  LPITEMIDLIST * ppidlSelect)
{
    HRESULT hr = S_OK;
    DWORD dwBuffSize = MAX_URLCACHE_ENTRY;
    USHORT cbSave;
    LPITEMIDLIST pidl;
    LPITEMIDLIST pidlNotify;
    LPITEMIDLIST pidlTemp;
    LPITEMIDLIST pidlHost;
    LPHEIPIDL    phei = NULL;
    HSFINTERVAL *pInterval;
    FILETIME ftExpires = {0,0};
    BOOL fNewHost;
    LPCTSTR pszStrippedUrl = _StripHistoryUrlToUrl(pszUrl);
    LPCTSTR pszHostUrl = pszStrippedUrl + HOSTPREFIXLEN;
    DWORD cchFree = cchUrl - (DWORD)(pszStrippedUrl-pszUrl);
    CHAR szAnsiUrl[MAX_URL_STRING];

    ASSERT(_pidlRest);
    pidl = _pidlRest;
    cbSave = pidl->mkid.cb;
    pidl->mkid.cb = 0;

    ///  Should also be able to get hitcount
    STATURL suThis;
    HRESULT hrLocal = E_FAIL;
    IUrlHistoryPriv *pUrlHistStg = _GetHistStg();
    if (pUrlHistStg) 
    {
        hrLocal = pUrlHistStg->QueryUrl(_StripHistoryUrlToUrl(pszUrl),
                                          STATURL_QUERYFLAG_NOURL, &suThis);
        pUrlHistStg->Release();
    }

    phei = _CreateHCacheFolderPidl(FALSE, pszUrl, *pftModified,
                                   (SUCCEEDED(hrLocal) ? &suThis : NULL), 0,
                                   _GetHitCount(_StripHistoryUrlToUrl(pszUrl)));

    if (SUCCEEDED(hrLocal) && suThis.pwcsTitle)
        OleFree(suThis.pwcsTitle);

    if (phei == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exitPoint;
    }

    if (cchFree <= HOSTPREFIXLEN)
    {
        hr = E_OUTOFMEMORY;
        goto exitPoint;
    }

    StrCpyN((LPTSTR)pszStrippedUrl, c_szHostPrefix, cchFree);    // whack on the PIDL!
    cchFree -= HOSTPREFIXLEN;

    _GetURLHostFromUrl(HPidlToSourceUrl((LPBASEPIDL)phei),
                       (LPTSTR)pszHostUrl, cchFree, _GetLocalHost());

    //  chrisfra 4/9/97 we could take a small performance hit here and always
    //  update host entry.  this would allow us to efficiently sort domains by most
    //  recent access.

    fNewHost = FALSE;
    dwBuffSize = MAX_URLCACHE_ENTRY;
    SHTCharToAnsi(pszUrl, szAnsiUrl, ARRAYSIZE(szAnsiUrl));

    if (!GetUrlCacheEntryInfoA(szAnsiUrl, NULL, 0))
    {
        fNewHost = TRUE;
        if (!CommitUrlCacheEntryA(szAnsiUrl, NULL, ftExpires, *pftModified,
                          URLHISTORY_CACHE_ENTRY|STICKY_CACHE_ENTRY,
                          NULL, 0, NULL, 0))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        if (FAILED(hr))
            goto exitPoint;
    }


    hr = _GetInterval(pftModified, FALSE, &pInterval);
    if (FAILED(hr))
        goto exitPoint;

    pidlTemp = _HostPidl(pszHostUrl, pInterval);
    if (pidlTemp == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exitPoint;
    }

    // Get just the host part of the pidl
    pidlHost = ILFindLastID(pidlTemp);
    ASSERT(pidlHost);

    if (fNewHost)
    {
        SHChangeNotify(SHCNE_MKDIR, SHCNF_IDLIST, pidlTemp, NULL);

        // We also need to notify special history views if they are listening:
        // For now, just "View by Site" is relevant...
        LPITEMIDLIST pidlViewSuffix = _Combine_ViewPidl(VIEWPIDL_ORDER_SITE, pidlHost);
        if (pidlViewSuffix) 
        {
            LPITEMIDLIST pidlNotify = ILCombine(_pidl, pidlViewSuffix);
            if (pidlNotify) 
            {
                SHChangeNotify(SHCNE_MKDIR, SHCNF_IDLIST, pidlNotify, NULL);
                ILFree(pidlNotify);
            }
            ILFree(pidlViewSuffix);
        }
    }

    pidlNotify = ILCombine(pidlTemp, (LPITEMIDLIST) phei);
    if (pidlNotify == NULL)
    {
        ILFree(pidlTemp);
        hr = E_OUTOFMEMORY;
        goto exitPoint;
    }
    // Create (if its not there already) and Rename (if its there)
    //  Sending both notifys will be faster than trying to figure out
    //  which one is appropriate
    SHChangeNotify(SHCNE_CREATE, SHCNF_IDLIST, pidlNotify, NULL);

    // Also notify events for specail viewpidls!
    _ViewType_NotifyEvent(_pidl, pidlHost, (LPITEMIDLIST)phei, SHCNE_CREATE);

    if (ppidlSelect)
    {
        *ppidlSelect = pidlNotify;
    }
    else
    {
        ILFree(pidlNotify);
    }

    ILFree(pidlTemp);
exitPoint:
    if (phei)
    {
        LocalFree(phei);
        phei = NULL;
    }

    pidl->mkid.cb = cbSave;
    return hr;
}

HRESULT CHistFolder::_NotifyInterval(HSFINTERVAL *pInterval, LONG lEventID)
{
    // special history views are not relevant here...
    if (_uViewType)
        return S_FALSE;

    USHORT cbSave = 0;
    LPITEMIDLIST pidl;
    LPITEMIDLIST pidlNotify = NULL;
    LPITEMIDLIST pidlNotify2 = NULL;
    LPITEMIDLIST pidlNotify3 = NULL;
    HRESULT hr = S_OK;
    struct _INTERVALIDL
    {
        USHORT cb;
        USHORT usSign;
        TCHAR szInterval[INTERVAL_SIZE+1];
        USHORT cbTrail;
    } IntervalIDL,IntervalIDL2;

    ASSERT(_pidlRest);
    pidl = _pidlRest;
    cbSave = pidl->mkid.cb;
    pidl->mkid.cb = 0;

    ZeroMemory(&IntervalIDL, sizeof(IntervalIDL));
    IntervalIDL.usSign = pInterval->usSign;
    _KeyForInterval(pInterval, IntervalIDL.szInterval, ARRAYSIZE(IntervalIDL.szInterval));
    IntervalIDL.cb = (USHORT)(2*sizeof(USHORT) + (lstrlen(IntervalIDL.szInterval) + 1)*sizeof(TCHAR));

    if (lEventID&SHCNE_RENAMEFOLDER ||  // was TODAY, now is a weekday
        (lEventID&SHCNE_RMDIR && 1 == _DaysInInterval(pInterval)) ) // one day, maybe TODAY
    {
        memcpy(&IntervalIDL2, &IntervalIDL, sizeof(IntervalIDL));
        IntervalIDL2.usSign = (USHORT)IDTPIDL_SIGN;
        pidlNotify2 = ILCombine(_pidl, (LPITEMIDLIST) (&IntervalIDL));
        pidlNotify = ILCombine(_pidl, (LPITEMIDLIST) (&IntervalIDL2));
        if (pidlNotify2 == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto exitPoint;
        }
        if (lEventID&SHCNE_RMDIR)
        {
            pidlNotify3 = pidlNotify2;
            pidlNotify2 = NULL;
        }
    }
    else
    {
        pidlNotify = ILCombine(_pidl, (LPITEMIDLIST) (&IntervalIDL));
    }
    if (pidlNotify == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exitPoint;
    }
    SHChangeNotify(lEventID, SHCNF_IDLIST, pidlNotify, pidlNotify2);
    if (pidlNotify3) SHChangeNotify(lEventID, SHCNF_IDLIST, pidlNotify3, NULL);

exitPoint:
    ILFree(pidlNotify);
    ILFree(pidlNotify2);
    ILFree(pidlNotify3);
    if (cbSave) pidl->mkid.cb = cbSave;
    return hr;
}

HRESULT CHistFolder::_CreateInterval(FILETIME *pftStart, DWORD dwDays)
{
    HSFINTERVAL interval;
    TCHAR szInterval[INTERVAL_SIZE+1];
    UINT err;
    FILETIME ftNow;
    SYSTEMTIME stNow;
    CHAR szIntervalAnsi[INTERVAL_SIZE+1], szCachePrefixAnsi[INTERVAL_SIZE+1];

#define CREATE_OPTIONS (INTERNET_CACHE_CONTAINER_AUTODELETE |  \
                        INTERNET_CACHE_CONTAINER_NOSUBDIRS  |  \
                        INTERNET_CACHE_CONTAINER_NODESKTOPINIT)

    //  _FileTimeDeltaDays guarantees times just at the 0th tick of the day
    _FileTimeDeltaDays(pftStart, &interval.ftStart, 0);
    _FileTimeDeltaDays(pftStart, &interval.ftEnd, dwDays);
    interval.usVers = OUR_VERS;
    GetLocalTime(&stNow);
    SystemTimeToFileTime(&stNow, &ftNow);
    _FileTimeDeltaDays(&ftNow, &ftNow, 0);
    _SetValueSign(&interval, ftNow);

    _KeyForInterval(&interval, szInterval, ARRAYSIZE(szInterval));

    interval.szPrefix[0] = ':';
    StrCpyN(&interval.szPrefix[1], &szInterval[INTERVAL_PREFIX_LEN+INTERVAL_VERS_LEN],
            ARRAYSIZE(interval.szPrefix) - 1);
    StrCatBuff(interval.szPrefix, TEXT(": "), ARRAYSIZE(interval.szPrefix));

    SHTCharToAnsi(szInterval, szIntervalAnsi, ARRAYSIZE(szIntervalAnsi));
    SHTCharToAnsi(interval.szPrefix, szCachePrefixAnsi, ARRAYSIZE(szCachePrefixAnsi));

    if (CreateUrlCacheContainerA(szIntervalAnsi,   // Name
                                szCachePrefixAnsi, // CachePrefix
                                NULL,              // Path
                                0,                 // Cache Limit
                                0,                 // Container Type
                                CREATE_OPTIONS,    // Create Options
                                NULL,              // Create Buffer
                                0))                // Create Buffer size
    {
        _NotifyInterval(&interval, SHCNE_MKDIR);
        err = ERROR_SUCCESS;
    }
    else
    {
        err = GetLastError();
    }
    return ERROR_SUCCESS == err ? S_OK : HRESULT_FROM_WIN32(err);
}

HRESULT CHistFolder::_PrefixUrl(LPCTSTR pszStrippedUrl,
                                     FILETIME *pftLastModifiedTime,
                                     LPTSTR pszPrefixedUrl,
                                     DWORD cchPrefixedUrl)
{
    HRESULT hr;
    HSFINTERVAL *pInterval;

    hr = _GetInterval(pftLastModifiedTime, FALSE, &pInterval);
    if (S_OK == hr)
    {
        if ((DWORD)((lstrlen(pszStrippedUrl) + lstrlen(pInterval->szPrefix) + 1) * sizeof(TCHAR)) > cchPrefixedUrl)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            StrCpyN(pszPrefixedUrl, pInterval->szPrefix, cchPrefixedUrl);
            StrCatBuff(pszPrefixedUrl, pszStrippedUrl, cchPrefixedUrl);
        }
    }
    return hr;
}


HRESULT CHistFolder::_WriteHistory(LPCTSTR pszPrefixedUrl, FILETIME ftExpires, FILETIME ftModified, 
                                        BOOL fSendNotify, LPITEMIDLIST * ppidlSelect)
{
    TCHAR szNewPrefixedUrl[INTERNET_MAX_URL_LENGTH+1];
    HRESULT hr = E_INVALIDARG;
    LPCTSTR pszUrlMinusContainer;

    pszUrlMinusContainer = _StripContainerUrlUrl(pszPrefixedUrl);

    if (pszUrlMinusContainer)
    {
        hr = _PrefixUrl(pszUrlMinusContainer,
                          &ftModified,
                          szNewPrefixedUrl,
                          ARRAYSIZE(szNewPrefixedUrl));
        if (S_OK == hr)
        {
            CHAR szAnsiUrl[MAX_URL_STRING+1];

            SHTCharToAnsi(szNewPrefixedUrl, szAnsiUrl, ARRAYSIZE(szAnsiUrl));
            if (!CommitUrlCacheEntryA(
                          szAnsiUrl,
                          NULL,
                          ftExpires,
                          ftModified,
                          URLHISTORY_CACHE_ENTRY|STICKY_CACHE_ENTRY,
                          NULL,
                          0,
                          NULL,
                          0))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
            else
            {
                if (fSendNotify) 
                    _NotifyWrite(szNewPrefixedUrl, ARRAYSIZE(szNewPrefixedUrl),
                                 &ftModified, ppidlSelect);
            }
        }
    }
    return hr;
}

// This function will update any shell that might be listening to us
//  to redraw the directory.
// It will do this by generating a SHCNE_UPDATE for all possible pidl roots
//  that the shell could have.  Hopefully, this should be sufficient...
// Specifically, this is meant to be called by ClearHistory.
HRESULT CHistFolder::_ViewType_NotifyUpdateAll() 
{
    LPITEMIDLIST pidlHistory;
    if (SUCCEEDED(SHGetHistoryPIDL(&pidlHistory)))
    {
        for (USHORT us = 1; us <= VIEWPIDL_ORDER_MAX; ++us) 
        {
            LPITEMIDLIST pidlView;
            if (SUCCEEDED(CreateSpecialViewPidl(us, &pidlView))) 
            {
                LPITEMIDLIST pidlTemp = ILCombine(pidlHistory, pidlView);
                if (pidlTemp) 
                {
                    SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_IDLIST, pidlTemp, NULL);
                    ILFree(pidlTemp);
                }
                ILFree(pidlView);
            }
        }
        ILFree(pidlHistory);
        SHChangeNotifyHandleEvents();
    }
    return S_OK;
}

//  On a per user basis.
//  chrisfra 6/11/97. _DeleteItems of a Time Interval deletes the entire interval.
//  ClearHistory should probably work the same. Pros of _DeleteEntries is on non-profile,
//  multi-user machine, other user's history is preserved.  Cons is that on profile based
//  machine, empty intervals are created.
HRESULT CHistFolder::ClearHistory()
{
    HRESULT hr = S_OK;
    int i;

    hr = _ValidateIntervalCache();
    if (SUCCEEDED(hr))
    {
        for (i = 0; i < _cbIntervals; i++)
        {
#if 0
            if (_DeleteEntries(_pIntervalCache[i].szPrefix, NULL, NULL))
                hr = S_FALSE;
            _NotifyInterval(&_pIntervalCache[i], SHCNE_UPDATEDIR);
#else
            _DeleteInterval(&_pIntervalCache[i]);
#endif
        }
    }
#ifndef UNIX
    _ViewType_NotifyUpdateAll();
#endif
    return hr;
}


//  ftModified is in "User Perceived", ie local time
//  stuffed into FILETIME as if it were UNC.  ftExpires is in normal UNC time.
HRESULT CHistFolder::WriteHistory(LPCTSTR pszPrefixedUrl,
                                  FILETIME ftExpires, FILETIME ftModified,
                                  LPITEMIDLIST * ppidlSelect)
{
    HRESULT hr;

    hr = _ValidateIntervalCache();
    if (SUCCEEDED(hr))
    {
        hr = _WriteHistory(pszPrefixedUrl, ftExpires, ftModified, TRUE, ppidlSelect);
    }
    return hr;
}

//  Makes best efforts attempt to copy old style history items into new containers
HRESULT CHistFolder::_CopyEntries(LPCTSTR pszHistPrefix)
{
    HANDLE              hEnum = NULL;
    HRESULT             hr;
    BOOL                fNotCopied = FALSE;
    LPINTERNET_CACHE_ENTRY_INFO pceiWorking;
    DWORD               dwBuffSize;
    LPTSTR              pszSearchPattern = NULL;
    TCHAR               szHistSearchPattern[65];    // search pattern for history items


    StrCpyN(szHistSearchPattern, pszHistPrefix, ARRAYSIZE(szHistSearchPattern));

    // We can't pass in the whole search pattern that we want,
    // because FindFirstUrlCacheEntry is busted.  It will only look at the
    // prefix if there is a cache container for that prefix.  So, we can
    // pass in "Visited: " and enumerate all the history items in the cache,
    // but then we need to pull out only the ones with the correct username.

    // StrCpy(szHistSearchPattern, szUserName);

    pszSearchPattern = szHistSearchPattern;

    pceiWorking = (LPINTERNET_CACHE_ENTRY_INFO)LocalAlloc(LPTR, MAX_URLCACHE_ENTRY);
    if (NULL == pceiWorking)
    {
        hr = E_OUTOFMEMORY;
        goto exitPoint;
    }
    hr = _ValidateIntervalCache();
    if (FAILED(hr)) 
        goto exitPoint;

    while (SUCCEEDED(hr))
    {
        dwBuffSize = MAX_URLCACHE_ENTRY;
        if (!hEnum)
        {
            hEnum = FindFirstUrlCacheEntry(pszSearchPattern, pceiWorking, &dwBuffSize);
            if (!hEnum)
            {
                goto exitPoint;
            }
        }
        else if (!FindNextUrlCacheEntry(hEnum, pceiWorking, &dwBuffSize))
        {
            //  chrisfra 4/3/97 should we distinquish eod vs hard errors?
            //  old code for cachevu doesn't (see above in enum code)
            hr = S_OK;
            goto exitPoint;
        }

        if (SUCCEEDED(hr) &&
            ((pceiWorking->CacheEntryType & URLHISTORY_CACHE_ENTRY) == URLHISTORY_CACHE_ENTRY) &&
            _FilterPrefix(pceiWorking, (LPTSTR) pszHistPrefix))
        {
            hr = _WriteHistory(pceiWorking->lpszSourceUrlName,
                                 pceiWorking->ExpireTime,
                                 pceiWorking->LastModifiedTime,
                                 FALSE,
                                 NULL);
            if (S_FALSE == hr) fNotCopied = TRUE;
        }
    }
exitPoint:
    if (pceiWorking)
    {
        LocalFree(pceiWorking);
        pceiWorking = NULL;
    }

    if (hEnum)
    {
        FindCloseUrlCache(hEnum);
    }
    return SUCCEEDED(hr) ? (fNotCopied ? S_FALSE : S_OK) : hr;
}

HRESULT CHistFolder::_GetUserName(LPTSTR pszUserName, DWORD cchUserName)
{
    HRESULT hr = _EnsureHistStg();
    if (SUCCEEDED(hr))
    {
        hr = _pUrlHistStg->GetUserName(pszUserName, cchUserName);
    }
    return hr;
}


//  Makes best efforts attempt to delete old history items in container on a per
//  user basis.  if we get rid of per user - can just empty whole container
HRESULT CHistFolder::_DeleteEntries(LPCTSTR pszHistPrefix, PFNDELETECALLBACK pfnDeleteFilter, void * pDelData)
{
    HANDLE              hEnum = NULL;
    HRESULT             hr = S_OK;
    BOOL                fNotDeleted = FALSE;
    LPINTERNET_CACHE_ENTRY_INFO pceiWorking;
    DWORD               dwBuffSize;
    LPTSTR   pszSearchPattern = NULL;
    TCHAR   szUserName[INTERNET_MAX_USER_NAME_LENGTH + 1];      // username of person logged on
    DWORD   dwUserNameLen = INTERNET_MAX_USER_NAME_LENGTH + 1;   // len of this buffer
    TCHAR    szHistSearchPattern[PREFIX_SIZE+1];                 // search pattern for history items
    LPITEMIDLIST pidlNotify;

    StrCpyN(szHistSearchPattern, pszHistPrefix, ARRAYSIZE(szHistSearchPattern));
    if (FAILED(_GetUserName(szUserName, dwUserNameLen)))
        szUserName[0] = TEXT('\0');

    // We can't pass in the whole search pattern that we want,
    // because FindFirstUrlCacheEntry is busted.  It will only look at the
    // prefix if there is a cache container for that prefix.  So, we can
    // pass in "Visited: " and enumerate all the history items in the cache,
    // but then we need to pull out only the ones with the correct username.

    // StrCpy(szHistSearchPattern, szUserName);

    pszSearchPattern = szHistSearchPattern;

    pceiWorking = (LPINTERNET_CACHE_ENTRY_INFO)LocalAlloc(LPTR, MAX_URLCACHE_ENTRY);
    if (NULL == pceiWorking)
    {
        hr = E_OUTOFMEMORY;
        goto exitPoint;
    }

    while (SUCCEEDED(hr))
    {
        dwBuffSize = MAX_URLCACHE_ENTRY;
        if (!hEnum)
        {
            hEnum = FindFirstUrlCacheEntry(pszSearchPattern, pceiWorking, &dwBuffSize);
            if (!hEnum)
            {
                goto exitPoint;
            }
        }
        else if (!FindNextUrlCacheEntry(hEnum, pceiWorking, &dwBuffSize))
        {
            //  chrisfra 4/3/97 should we distinquish eod vs hard errors?
            //  old code for cachevu doesn't (see above in enum code)
            hr = S_OK;
            goto exitPoint;
        }

        pidlNotify = NULL;
        if (SUCCEEDED(hr) &&
            ((pceiWorking->CacheEntryType & URLHISTORY_CACHE_ENTRY) == URLHISTORY_CACHE_ENTRY) &&
            _FilterUserName(pceiWorking, pszHistPrefix, szUserName) &&
            (NULL == pfnDeleteFilter || pfnDeleteFilter(pceiWorking, pDelData, &pidlNotify)))
        {
            //if (!DeleteUrlCacheEntryA(pceiWorking->lpszSourceUrlName))
            if (FAILED(_DeleteUrlFromBucket(pceiWorking->lpszSourceUrlName)))
            {
                fNotDeleted = TRUE;
            }
            else if (pidlNotify)
            {
                SHChangeNotify(SHCNE_DELETE, SHCNF_IDLIST, pidlNotify, NULL);
            }
        }
        ILFree(pidlNotify);
    }
exitPoint:
    if (pceiWorking)
    {
        LocalFree(pceiWorking);
        pceiWorking = NULL;
    }

    if (hEnum)
    {
        FindCloseUrlCache(hEnum);
    }
    return SUCCEEDED(hr) ? (fNotDeleted ? S_FALSE : S_OK) : hr;
}

HRESULT CHistFolder::_DeleteInterval(HSFINTERVAL *pInterval)
{
    UINT err = S_OK;
    TCHAR szInterval[INTERVAL_SIZE+1];
    CHAR szAnsiInterval[INTERVAL_SIZE+1];

    _KeyForInterval(pInterval, szInterval, ARRAYSIZE(szInterval));

    SHTCharToAnsi(szInterval, szAnsiInterval, ARRAYSIZE(szAnsiInterval));
    if (!DeleteUrlCacheContainerA(szAnsiInterval, 0))
    {
        err = GetLastError();
    }
    else
    {
        _NotifyInterval(pInterval, SHCNE_RMDIR);
    }
    return S_OK == err ? S_OK : HRESULT_FROM_WIN32(err);
}

//  Returns S_OK if no intervals we're deleted, S_FALSE if at least
//  one interval was deleted.
HRESULT CHistFolder::_CleanUpHistory(FILETIME ftLimit, FILETIME ftTommorrow)
{
    HRESULT hr;
    BOOL fChangedRegistry = FALSE;
    int i;

    //  _CleanUpHistory does two things:
    //
    //  If we have any stale weeks destroy them and flag the change
    //
    //  If we have any days that should be in cache but not in dailies
    //  copy them to the relevant week then destroy those days
    //  and flag the change

    hr = _LoadIntervalCache();
    if (FAILED(hr)) 
        goto exitPoint;

    for (i = 0; i < _cbIntervals; i++)
    {
        //  Delete old intervals or ones which start at a day in the future
        //  (due to fooling with the clock)
        if (CompareFileTime(&_pIntervalCache[i].ftEnd, &ftLimit) < 0 ||
            CompareFileTime(&_pIntervalCache[i].ftStart, &ftTommorrow) >= 0)
        {
            fChangedRegistry = TRUE;
            hr = _DeleteInterval(&_pIntervalCache[i]);
            if (FAILED(hr)) 
                goto exitPoint;
        }
        else if (1 == _DaysInInterval(&_pIntervalCache[i]))
        {
            HSFINTERVAL *pWeek;

            //  NOTE: at this point we have guaranteed, we've built weeks
            //  for all days outside of current week
            if (S_OK == _GetInterval(&_pIntervalCache[i].ftStart, TRUE, &pWeek))
            {
                fChangedRegistry = TRUE;
                hr = _CopyEntries(_pIntervalCache[i].szPrefix);
                if (FAILED(hr)) 
                    goto exitPoint;
                _NotifyInterval(pWeek, SHCNE_UPDATEDIR);

                hr = _DeleteInterval(&_pIntervalCache[i]);
                if (FAILED(hr)) 
                    goto exitPoint;
            }
        }
    }

exitPoint:
    if (S_OK == hr && fChangedRegistry) hr = S_FALSE;
    return hr;
}

typedef struct _HSFDELETEDATA
{
    UINT cidl;
    LPCITEMIDLIST *ppidl;
    LPCITEMIDLIST pidlParent;
} HSFDELETEDATA,*LPHSFDELETEDATA;

//  delete if matches any host on list
BOOL fDeleteInHostList(LPINTERNET_CACHE_ENTRY_INFO pceiWorking, void * pDelData, LPITEMIDLIST *ppidlNotify)
{
    LPHSFDELETEDATA phsfd = (LPHSFDELETEDATA)pDelData;
    TCHAR szHost[INTERNET_MAX_HOST_NAME_LENGTH+1];
    TCHAR szLocalHost[INTERNET_MAX_HOST_NAME_LENGTH+1];

    UINT i;

    _GetLocalHost(szLocalHost, SIZECHARS(szLocalHost));
    _GetURLHost(pceiWorking, szHost, INTERNET_MAX_HOST_NAME_LENGTH, szLocalHost);
    for (i = 0; i < phsfd->cidl; i++)
    {
        if (!ualstrcmpi(szHost, _GetURLTitle((LPBASEPIDL)(phsfd->ppidl[i]))))
        {
            return TRUE;
        }
    }
    return FALSE;
}


// Will attempt to hunt down all occurrances of this url in any of the
//   various history buckets...
// This is a utility function for _ViewType_DeleteItems -- it may
//  be used in other contexts providing these preconditions
//  are kept in mind:
//
//   *The URL passed in should be prefixed ONLY with the username portion
//    such that this function can prepend prefixes to these urls
//   *WARNING: This function ASSUMES that _ValidateIntervalCache
//    has been called recently!!!!  DANGER DANGER!
//
// RETURNS: S_OK if at least one entry was found and deleted
//
HRESULT CHistFolder::_DeleteUrlHistoryGlobal(LPCTSTR pszUrl) {
    HRESULT hr = E_FAIL;
    if (pszUrl) {
        IUrlHistoryPriv *pUrlHistStg = _GetHistStg();
        if (pUrlHistStg) {
            LPCTSTR pszStrippedUrl = _StripHistoryUrlToUrl(pszUrl);
            if (pszStrippedUrl)
            {
                UINT   cchwTempUrl  = lstrlen(pszStrippedUrl) + 1;
                LPWSTR pwszTempUrl = ((LPWSTR)LocalAlloc(LPTR, cchwTempUrl * sizeof(WCHAR)));
                if (pwszTempUrl)
                {
                    SHTCharToUnicode(pszStrippedUrl, pwszTempUrl, cchwTempUrl);
                    hr = pUrlHistStg->DeleteUrl(pwszTempUrl, URLFLAG_DONT_DELETE_SUBSCRIBED);
                    for (int i = 0; i < _cbIntervals; ++i) {
                        // should this length be constant? (bucket sizes shouldn't vary)
                        UINT   cchTempUrl   = (PREFIX_SIZE +
                                                lstrlen(pszUrl) + 1);
                        LPTSTR pszTempUrl = ((LPTSTR)LocalAlloc(LPTR, cchTempUrl * sizeof(TCHAR)));
                        if (pszTempUrl) {
                            // StrCpy null terminates
                            StrCpyN(pszTempUrl, _pIntervalCache[i].szPrefix, cchTempUrl);
                            StrCpyN(pszTempUrl + PREFIX_SIZE, pszUrl, cchTempUrl - PREFIX_SIZE);
                            if (DeleteUrlCacheEntry(pszTempUrl))
                                hr = S_OK;

                            LocalFree(pszTempUrl);
                            pszTempUrl = NULL;
                        }
                        else {
                            hr = E_OUTOFMEMORY;
                            break;
                        }
                    }

                    LocalFree(pwszTempUrl);
                    pwszTempUrl = NULL;
                }
                else {
                    hr = E_OUTOFMEMORY;
                }
            }
            pUrlHistStg->Release();
        }
    }
    else
        hr = E_INVALIDARG;
    return hr;
}

// WARNING: assumes ppidl
HRESULT CHistFolder::_ViewBySite_DeleteItems(LPCITEMIDLIST *ppidl, UINT cidl)
{
    HRESULT hr = E_INVALIDARG;
    TCHAR szUserName[INTERNET_MAX_USER_NAME_LENGTH + 1];
    if (FAILED(_GetUserName(szUserName, ARRAYSIZE(szUserName))))
        szUserName[0] = TEXT('\0');

    IUrlHistoryPriv *pUrlHistStg = _GetHistStg();

    if (pUrlHistStg)
    {
        IEnumSTATURL *penum;
        if (SUCCEEDED(pUrlHistStg->EnumUrls(&penum)) &&
            penum) {

            for (UINT i = 0; i < cidl; ++i)
            {
                LPCUTSTR pszHostName  = _GetURLTitle((LPBASEPIDL)ppidl[i]);
                UINT    uUserNameLen = lstrlen(szUserName);
                UINT    uBuffLen     = (USHORT)((HOSTPREFIXLEN + uUserNameLen +
                                        ualstrlen(pszHostName) + 2)); // insert '@' and '\0'
                LPTSTR  pszUrl =
                    ((LPTSTR)LocalAlloc(LPTR, (uBuffLen) * sizeof(TCHAR)));
                if (pszUrl) {
                    // get rid of ":Host: " prefixed entires in the cache
                    // Generates "username@:Host: hostname" -- wnsprintf null terminates
                    wnsprintf(pszUrl, uBuffLen, TEXT("%s@%s%s"), szUserName,
                              c_szHostPrefix, pszHostName);
                    hr = _DeleteUrlHistoryGlobal(pszUrl);

                    // enumerate over all urls in history

                    ULONG cFetched;
                    // don't retrieve TITLE information (too much overhead)
                    penum->SetFilter(NULL, STATURL_QUERYFLAG_NOTITLE);
                    STATURL statUrl;
                    statUrl.cbSize = sizeof(STATURL);
                    while(SUCCEEDED(penum->Next(1, &statUrl, &cFetched)) && cFetched) {
                        if (statUrl.pwcsUrl) {
                            // these next few lines painfully constructs a string
                            //  that is of the form "username@url"
                            LPTSTR pszStatUrlUrl;
                            UINT uStatUrlUrlLen = lstrlenW(statUrl.pwcsUrl);
                            pszStatUrlUrl = statUrl.pwcsUrl;
                            TCHAR  szHost[INTERNET_MAX_HOST_NAME_LENGTH + 1];
                            _GetURLHostFromUrl_NoStrip(pszStatUrlUrl, szHost, INTERNET_MAX_HOST_NAME_LENGTH + 1, _GetLocalHost());

                            if (!ualstrcmpi(szHost, pszHostName)) {
                                LPTSTR pszDelUrl; // url to be deleted
                                UINT uUrlLen = uUserNameLen + 1 + uStatUrlUrlLen; // +1 for '@'
                                pszDelUrl = ((LPTSTR)LocalAlloc(LPTR, (uUrlLen + 1) * sizeof(TCHAR)));
                                if (pszDelUrl) {
                                    wnsprintf(pszDelUrl, uUrlLen + 1, TEXT("%s@%s"), szUserName, pszStatUrlUrl);
                                    // finally, delete all all occurrances of that URL in all history buckets
                                    hr =  _DeleteUrlHistoryGlobal(pszDelUrl);

                                    // 
                                    //  Is is really safe to delete *during* an enumeration like this, or should
                                    //  we cache all of the URLS and delete at the end?  I'd rather do it this
                                    //  way if possible -- anyhoo, no docs say its bad to do -- 'course there are no docs ;)
                                    //  Also, there is an example of code later that deletes during an enumeration
                                    //  and seems to work...
                                    LocalFree(pszDelUrl);
                                    pszDelUrl = NULL;
                                }
                                else
                                    hr = E_OUTOFMEMORY;
                            }
                            OleFree(statUrl.pwcsUrl);
                        }
                    }
                    penum->Reset();
                    LocalFree(pszUrl);
                    pszUrl = NULL;
                }
                else
                    hr = E_OUTOFMEMORY;

                LPITEMIDLIST pidlTemp = ILCombine(_pidl, ppidl[i]);
                if (pidlTemp) {
                    SHChangeNotify(SHCNE_RMDIR, SHCNF_IDLIST, pidlTemp, NULL);
                    ILFree(pidlTemp);
                }
                else
                    hr = E_OUTOFMEMORY;

                if (hr == E_OUTOFMEMORY)
                    break;
            } // for
            penum->Release();
        } // if penum
        else
            hr = E_FAIL;
        pUrlHistStg->Release();
    } // if purlHistStg
    else
        hr = E_FAIL;

    return hr;
}


// This guy will delete an URL from one history (MSHIST-type) bucket
//  and then try to find it in other (MSHIST-type) buckets.
//  If it can't be found, then the URL will be removed from the main
//  history (Visited-type) bucket.
// NOTE: Only the url will be deleted and not any of its "frame-children"
//       This is probably not the a great thing...
// ASSUMES that _ValidateIntervalCache has been called recently
HRESULT CHistFolder::_DeleteUrlFromBucket(LPCTSTR pszPrefixedUrl) {
    HRESULT hr = E_FAIL;
    if (DeleteUrlCacheEntry(pszPrefixedUrl)) {
        //   check if we need to delete this url from the main Visited container, too
        //   we make sure that url exists in at least one other bucket
        LPCTSTR pszUrl = _StripHistoryUrlToUrl(pszPrefixedUrl);
        if (pszUrl)
        {
            DWORD  dwError = _SearchFlatCacheForUrl(pszUrl, NULL, NULL);
            if (dwError == ERROR_FILE_NOT_FOUND)
            {
                IUrlHistoryPriv *pUrlHistStg = _GetHistStg();
                if (pUrlHistStg)
                {
                    pUrlHistStg->DeleteUrl(pszUrl, 0);
                    pUrlHistStg->Release();
                    hr = S_OK;
                }
            }
            else
                hr = S_OK;
        }
    }
    return hr;
}

// Tries to delete as many as possible, and returns E_FAIL if the last one could not
//   be deleted.
// <RATIONALIZATION>not usually called with more than one pidl</RATIONALIZATION>
// ASSUMES that _ValidateIntervalCache has been called recently
HRESULT CHistFolder::_ViewType_DeleteItems(LPCITEMIDLIST *ppidl, UINT cidl)
{
    ASSERT(_uViewType);

    HRESULT hr = E_INVALIDARG;

    if (ppidl) {
        switch(_uViewType) {
        case VIEWPIDL_ORDER_SITE:
            if (_uViewDepth == 0) {
                hr = _ViewBySite_DeleteItems(ppidl, cidl);
                break;
            }
            ASSERT(_uViewDepth == 1);
            // FALLTHROUGH INTENTIONAL!!
        case VIEWPIDL_SEARCH:
        case VIEWPIDL_ORDER_FREQ: {
            for (UINT i = 0; i < cidl; ++i) {
                LPCTSTR pszPrefixedUrl = HPidlToSourceUrl(ppidl[i]);
                if (pszPrefixedUrl) {
                    if (SUCCEEDED((hr =
                        _DeleteUrlHistoryGlobal(_StripContainerUrlUrl(pszPrefixedUrl)))))
                    {
                        LPITEMIDLIST pidlTemp = ILCombine(_pidl, ppidl[i]);
                        if (pidlTemp) {
                            SHChangeNotify(SHCNE_DELETE, SHCNF_IDLIST, pidlTemp, NULL);
                            ILFree(pidlTemp);
                        }
                        else
                            hr = E_OUTOFMEMORY;
                    }
                }
                else
                    hr = E_FAIL;
            }
            break;
        }
        case VIEWPIDL_ORDER_TODAY: {
            // find the entry in the cache and delete it:
            for (UINT i = 0; i < cidl; ++i)
            {
                if (_IsValid_HEIPIDL(ppidl[i]))
                {
                    hr = _DeleteUrlFromBucket(HPidlToSourceUrl(ppidl[i]));
                    if (SUCCEEDED(hr))
                    {
                        LPITEMIDLIST pidlTemp = ILCombine(_pidl, ppidl[i]);
                        if (pidlTemp)
                        {
                            SHChangeNotify(SHCNE_DELETE, SHCNF_IDLIST, pidlTemp, NULL);
                            ILFree(pidlTemp);
                        }
                        else
                            hr = E_OUTOFMEMORY;
                    }
                }
                else
                    hr = E_FAIL;
            }
            break;
        }
        default:
            hr = E_NOTIMPL;
            ASSERT(0);
            break;
        }
    }
    return hr;
}


HRESULT CHistFolder::_DeleteItems(LPCITEMIDLIST *ppidl, UINT cidl)
{
    UINT i;
    HSFDELETEDATA hsfDeleteData = {cidl, ppidl, _pidl};
    HSFINTERVAL *pDelInterval;
    FILETIME ftStart;
    FILETIME ftEnd;
    LPCUTSTR pszIntervalName;

    HRESULT hr = _ValidateIntervalCache();
    if (FAILED(hr)) 
        goto exitPoint;

    if (_uViewType) 
    {
        hr = _ViewType_DeleteItems(ppidl, cidl);
        goto exitPoint; // when in rome...
    }

    switch(_foldertype)
    {
    case FOLDER_TYPE_Hist:
        for (i = 0; i < cidl; i++)
        {
            pszIntervalName = _GetURLTitle((LPBASEPIDL)ppidl[i]);

            hr = _ValueToInterval(pszIntervalName, &ftStart, &ftEnd);
            if (FAILED(hr)) 
                goto exitPoint;

            if (S_OK == _GetInterval(&ftStart, FALSE, &pDelInterval))
            {
                hr = _DeleteInterval(pDelInterval);
                if (FAILED(hr)) 
                    goto exitPoint;
            }
        }
        break;
    case FOLDER_TYPE_HistInterval:
        //  last id of of _pidl is name of interval, which implies start and end
        pszIntervalName = _GetURLTitle((LPBASEPIDL)ILFindLastID(_pidl));
        hr = _ValueToInterval(pszIntervalName, &ftStart, &ftEnd);
        if (FAILED(hr)) 
            goto exitPoint;
        if (S_OK == _GetInterval(&ftStart, FALSE, &pDelInterval))
        {
            //  It's important to delete the host: <HOSTNAME> url's first so that
            //  an interleaved _NotityWrite() will not leave us inserting a pidl
            //  but the the host: directory.  it is a conscious performance tradeoff
            //  we're making here to not MUTEX this operation (rare) with _NotifyWrite
            for (i = 0; i < cidl; i++)
            {
                LPCTSTR pszHost;
                LPITEMIDLIST pidlTemp;
                TCHAR szNewPrefixedUrl[INTERNET_MAX_URL_LENGTH+1];
                TCHAR szUrlMinusContainer[INTERNET_MAX_URL_LENGTH+1];

                ua_GetURLTitle( &pszHost, (LPBASEPIDL)ppidl[i] );
                DWORD cbHost = lstrlen(pszHost);

                //  Compose the prefixed URL for the host cache entry, then
                //  use it to delete host entry
                hr = _GetUserName(szUrlMinusContainer, ARRAYSIZE(szUrlMinusContainer));
                if (FAILED(hr)) 
                    goto exitPoint;
                DWORD cbUserName = lstrlen(szUrlMinusContainer);

                if ((cbHost + cbUserName + 1)*sizeof(TCHAR) + HOSTPREFIXLEN > INTERNET_MAX_URL_LENGTH)
                {
                    hr = E_FAIL;
                    goto exitPoint;
                }
                StrCatBuff(szUrlMinusContainer, TEXT("@"), ARRAYSIZE(szUrlMinusContainer));
                StrCatBuff(szUrlMinusContainer, c_szHostPrefix, ARRAYSIZE(szUrlMinusContainer));
                StrCatBuff(szUrlMinusContainer, pszHost, ARRAYSIZE(szUrlMinusContainer));
                hr = _PrefixUrl(szUrlMinusContainer,
                      &ftStart,
                      szNewPrefixedUrl,
                      ARRAYSIZE(szNewPrefixedUrl));
                if (FAILED(hr))
                    goto exitPoint;

                if (!DeleteUrlCacheEntry(szNewPrefixedUrl))
                {
                    hr = E_FAIL;
                    goto exitPoint;
                }
                pidlTemp = _HostPidl(pszHost, pDelInterval);
                if (pidlTemp == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto exitPoint;
                }
                SHChangeNotify(SHCNE_RMDIR, SHCNF_IDLIST, pidlTemp, NULL);
                ILFree(pidlTemp);
            }
            hr = _DeleteEntries(_pszCachePrefix , fDeleteInHostList, &hsfDeleteData);
        }
        break;
    case FOLDER_TYPE_HistDomain:
        for (i = 0; i < cidl; ++i)
        {
            if (_IsValid_HEIPIDL(ppidl[i]))
            {
                hr = _DeleteUrlFromBucket(HPidlToSourceUrl(ppidl[i]));
                if (SUCCEEDED(hr))
                {
                    LPITEMIDLIST pidlTemp = ILCombine(_pidl, ppidl[i]);
                    if (pidlTemp)
                    {
                        SHChangeNotify(SHCNE_DELETE, SHCNF_IDLIST, pidlTemp, NULL);
                        ILFree(pidlTemp);
                    }
                }
            }
            else
                hr = E_FAIL;
        }
        break;
    }
exitPoint:

    if (SUCCEEDED(hr))
        SHChangeNotifyHandleEvents();

    return hr;
}

IUrlHistoryPriv *CHistFolder::_GetHistStg()
{
    _EnsureHistStg();
    if (_pUrlHistStg)
    {
        _pUrlHistStg->AddRef();
    }
    return _pUrlHistStg;
}

HRESULT CHistFolder::_EnsureHistStg()
{
    HRESULT hr = S_OK;

    if (_pUrlHistStg == NULL)
    {
        hr = CoCreateInstance(CLSID_CUrlHistory, NULL, CLSCTX_INPROC_SERVER, IID_IUrlHistoryPriv, (void **)&_pUrlHistStg);
    }
    return hr;
}

HRESULT CHistFolder::_ValidateIntervalCache()
{
    HRESULT hr = S_OK;
    SYSTEMTIME stNow;
    SYSTEMTIME stThen;
    FILETIME ftNow;
    FILETIME ftTommorrow;
    FILETIME ftMonday;
    FILETIME ftDayOfWeek;
    FILETIME ftLimit;
    BOOL fChangedRegistry = FALSE;
    DWORD dwWaitResult = WAIT_TIMEOUT;
    HSFINTERVAL *pWeirdWeek;
    HSFINTERVAL *pPrevDay;
    long compareResult;
    BOOL fCleanupVisitedDB = FALSE;
    int i;
    int daysToKeep;

    //  Check for reentrancy
    if (_fValidatingCache) return S_OK;

    _fValidatingCache = TRUE;

    // IE6 RAID 2031
    // Is this mutex necessary?
    // In IE4 days, this mutex was named _!MSFTHISTORY!_, the same as that in wininet.
    // As a consequence, sometimes you got into one-minute timeouts that caused the entire
    // browser to hang. (Since one thread could be cleaning up the history while another thread is
    // trying to access the cache for non-history purposes.)

    // I've changed the name of the mutex to prevent shdocvw from locking wininet, but we need 
    // to understand exactly what purpose this mutex serves, and if none, remove it.

    if (g_hMutexHistory == NULL)
    {
        ENTERCRITICAL;

        if (g_hMutexHistory == NULL)
        {
            //
            // Use the "A" version for W95 compatability.
            //
            g_hMutexHistory = OpenMutexA(SYNCHRONIZE, FALSE, "_!SHMSFTHISTORY!_");
            if (g_hMutexHistory  == NULL && (GetLastError() == ERROR_FILE_NOT_FOUND 
                || GetLastError() == ERROR_INVALID_NAME))
            {
                g_hMutexHistory = CreateMutexA(CreateAllAccessSecurityAttributes(NULL, NULL, NULL), FALSE, "_!SHMSFTHISTORY!_");
            }
        }
        LEAVECRITICAL;
    }

    // Note that if multiple processes are trying to clean up the history, we're still going to 
    // hang the other processes for a minute. Oops.

    if (g_hMutexHistory) 
        dwWaitResult = WaitForSingleObject(g_hMutexHistory, FAILSAFE_TIMEOUT);

    if ((dwWaitResult!=WAIT_OBJECT_0) && (dwWaitResult!=WAIT_ABANDONED))
    {
        ASSERT(FALSE);
        goto exitPoint;
    }

    hr = _LoadIntervalCache();
    if (FAILED(hr)) 
        goto exitPoint;

    //  All history is maintained using "User Perceived Time", which is the
    //  local time when navigate was made.
    GetLocalTime(&stNow);
    SystemTimeToFileTime(&stNow, &ftNow);
    _FileTimeDeltaDays(&ftNow, &ftNow, 0);
    _FileTimeDeltaDays(&ftNow, &ftTommorrow, 1);

    hr = _EnsureHistStg();
    if (FAILED(hr))
        goto exitPoint;

    //  Compute ftLimit as first instant of first day to keep in history
    //  _FileTimeDeltaDays truncates to first FILETIME incr of day before computing
    //  earlier/later, day.
    daysToKeep = (int)_pUrlHistStg->GetDaysToKeep();
    if (daysToKeep < 0) daysToKeep = 0;
    _FileTimeDeltaDays(&ftNow, &ftLimit, 1-daysToKeep);

    FileTimeToSystemTime(&ftNow, &stThen);
    //  We take monday as day 0 of week, and adjust it for file time
    //  tics per day (100ns per tick
    _FileTimeDeltaDays(&ftNow, &ftMonday, stThen.wDayOfWeek ? 1-stThen.wDayOfWeek: -6);

    //  Delete old version intervals so prefix matching in wininet isn't hosed

    for (i = 0; i < _cbIntervals; i++)
    {
        if (_pIntervalCache[i].usVers < OUR_VERS)
        {
            fChangedRegistry = TRUE;
            hr = _DeleteInterval(&_pIntervalCache[i]);
            if (FAILED(hr)) 
                goto exitPoint;
        }
    }

    //  If someone set their clock forward and then back, we could have
    //  a week that shouldn't be there.  delete it.  they will lose that week
    //  of history, c'est la guerre! quel domage!
    if (S_OK == _GetInterval(&ftMonday, TRUE, &pWeirdWeek))
    {
        hr = _DeleteInterval(pWeirdWeek);
        fCleanupVisitedDB = TRUE;
        if (FAILED(hr)) 
            goto exitPoint;
        fChangedRegistry = TRUE;
    }

    //  Create weeks as needed to house days that are within "days to keep" limit
    //  but are not in the same week at today
    for (i = 0; i < _cbIntervals; i++)
    {
        FILETIME ftThisDay = _pIntervalCache[i].ftStart;
        if (_pIntervalCache[i].usVers >= OUR_VERS &&
            1 == _DaysInInterval(&_pIntervalCache[i]) &&
            CompareFileTime(&ftThisDay, &ftLimit) >= 0 &&
            CompareFileTime(&ftThisDay, &ftMonday) < 0)
        {
            if (S_OK != _GetInterval(&ftThisDay, TRUE, NULL))
            {
                int j;
                BOOL fProcessed = FALSE;
                FILETIME ftThisMonday;
                FILETIME ftNextMonday;

                FileTimeToSystemTime(&ftThisDay, &stThen);
                //  We take monday as day 0 of week, and adjust it for file time
                //  tics per day (100ns per tick
                _FileTimeDeltaDays(&ftThisDay, &ftThisMonday, stThen.wDayOfWeek ? 1-stThen.wDayOfWeek: -6);
                _FileTimeDeltaDays(&ftThisMonday, &ftNextMonday, 7);

                //  Make sure we haven't already done this week
                for (j = 0; j < i; j++)
                {
                     if (_pIntervalCache[j].usVers >= OUR_VERS &&
                         CompareFileTime(&_pIntervalCache[j].ftStart, &ftLimit) >= 0 &&
                        _InInterval(&ftThisMonday,
                                    &ftNextMonday,
                                    &_pIntervalCache[j].ftStart))
                    {
                         fProcessed = TRUE;
                         break;
                    }
                }
                if (!fProcessed)
                {
                    hr = _CreateInterval(&ftThisMonday, 7);
                    if (FAILED(hr)) 
                        goto exitPoint;
                    fChangedRegistry = TRUE;
                }
            }
        }
    }

    //  Guarantee today is created and old TODAY is renamed to Day of Week
    ftDayOfWeek = ftMonday;
    pPrevDay = NULL;
    while ((compareResult = CompareFileTime(&ftDayOfWeek, &ftNow)) <= 0)
    {
        HSFINTERVAL *pFound;

        if (S_OK != _GetInterval(&ftDayOfWeek, FALSE, &pFound))
        {
            if (0 == compareResult)
            {
                if (pPrevDay) // old today's name changes
                {
                    _NotifyInterval(pPrevDay, SHCNE_RENAMEFOLDER);
                }
                hr = _CreateInterval(&ftDayOfWeek, 1);
                if (FAILED(hr)) 
                    goto exitPoint;
                fChangedRegistry = TRUE;
            }
        }
        else
        {
            pPrevDay = pFound;
        }
        _FileTimeDeltaDays(&ftDayOfWeek, &ftDayOfWeek, 1);
    }

    //  On the first time through, we do not migrate history, wininet
    //  changed cache file format so users going to 4.0B2 from 3.0 or B1
    //  will lose their history anyway

    //  _CleanUpHistory does two things:
    //
    //  If we have any stale weeks destroy them and flag the change
    //
    //  If we have any days that should be in cache but not in dailies
    //  copy them to the relevant week then destroy those days
    //  and flag the change

    hr = _CleanUpHistory(ftLimit, ftTommorrow);

    if (S_FALSE == hr)
    {
        hr = S_OK;
        fChangedRegistry = TRUE;
        fCleanupVisitedDB = TRUE;
    }

    if (fChangedRegistry)
        hr = _LoadIntervalCache();

exitPoint:
    if ((dwWaitResult == WAIT_OBJECT_0)
        || (dwWaitResult == WAIT_ABANDONED))
        ReleaseMutex(g_hMutexHistory);

    if (fCleanupVisitedDB)
    {
        if (SUCCEEDED(_EnsureHistStg()))
        {
            HRESULT hrLocal = _pUrlHistStg->CleanupHistory();
            ASSERT(SUCCEEDED(hrLocal));
        }
    }
    _fValidatingCache = FALSE;
    return hr;
}

HRESULT CHistFolder::_CopyTSTRField(LPTSTR *ppszField, LPCTSTR pszValue)
{
    if (*ppszField)
    {
        LocalFree(*ppszField);
        *ppszField = NULL;
    }
    if (pszValue)
    {
        int cchField = lstrlen(pszValue) + 1;
        *ppszField = (LPTSTR)LocalAlloc(LPTR, cchField * sizeof(TCHAR));
        if (*ppszField)
        {
            StrCpyN(*ppszField, pszValue, cchField);
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }
    return S_OK;
}

//
// IHistSFPrivate methods...
//
HRESULT CHistFolder::SetCachePrefix(LPCTSTR pszCachePrefix)
{
    return _CopyTSTRField(&_pszCachePrefix, pszCachePrefix);
}

HRESULT CHistFolder::SetDomain(LPCTSTR pszDomain)
{
    return _CopyTSTRField(&_pszDomain, pszDomain);
}


//
// IShellFolder
//
HRESULT CHistFolder::ParseDisplayName(HWND hwnd, LPBC pbc,
                        LPOLESTR pszDisplayName, ULONG *pchEaten,
                        LPITEMIDLIST *ppidl, ULONG *pdwAttributes)
{
    *ppidl = NULL; 
    return E_FAIL;
}

HRESULT CHistFolder::EnumObjects(HWND hwnd, DWORD grfFlags,
                                      IEnumIDList **ppenumIDList)
{
    return CHistFolderEnum_CreateInstance(grfFlags, this, ppenumIDList);
}

HRESULT CHistFolder::_ViewPidl_BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;

    switch(((LPVIEWPIDL)pidl)->usViewType) 
    {
    case VIEWPIDL_SEARCH:
    case VIEWPIDL_ORDER_TODAY:
    case VIEWPIDL_ORDER_SITE:
    case VIEWPIDL_ORDER_FREQ:

        CHistFolder *phsf = new CHistFolder(FOLDER_TYPE_HistDomain);
        if (phsf)
        {
            // initialize?
            phsf->_uViewType = ((LPVIEWPIDL)pidl)->usViewType;

            LPITEMIDLIST pidlLeft = ILCloneFirst(pidl);
            if (pidlLeft)
            {
                hr = S_OK;
                if (((LPVIEWPIDL)pidl)->usViewType == VIEWPIDL_SEARCH) 
                {
                    // find this search in the global database
                    phsf->_pcsCurrentSearch =
                        _CurrentSearches::s_FindSearch(((LPSEARCHVIEWPIDL)pidl)->ftSearchKey);

                    // search not found -- do not proceed
                    if (!phsf->_pcsCurrentSearch)
                        hr = E_FAIL;
                }

                if (SUCCEEDED(hr)) 
                {
                    if (phsf->_pidl)
                        ILFree(phsf->_pidl);
                    phsf->_pidl = ILCombine(_pidl, pidlLeft);

                    LPCITEMIDLIST pidlNext = _ILNext(pidl);
                    if (pidlNext->mkid.cb) 
                    {
                        CHistFolder *phsf2;
                        hr = phsf->BindToObject(pidlNext, pbc, riid, (void **)&phsf2);
                        if (SUCCEEDED(hr))
                        {
                            phsf->Release();
                            phsf = phsf2;
                        }
                        else 
                        {
                            phsf->Release();
                            phsf = NULL;
                            break;
                        }
                    }
                    hr = phsf->QueryInterface(riid, ppv);
                }

                ILFree(pidlLeft);
            }
            ASSERT(phsf);
            phsf->Release();
        }
        else
            hr = E_OUTOFMEMORY;
        break;
    }
    return hr;
}

HRESULT CHistFolder::_ViewType_BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;
    switch (_uViewType) 
    {
    case VIEWPIDL_ORDER_SITE:
        if (_uViewDepth++ < 1)
        {
            LPITEMIDLIST pidlNext = _ILNext(pidl);
            if (!(ILIsEmpty(pidlNext))) 
            {
                hr = BindToObject(pidlNext, pbc, riid, ppv);
            }
            else 
            {
                *ppv = (void *)this;
                LPITEMIDLIST pidlOld = _pidl;
                if (pidlOld) 
                {
                    _pidl = ILCombine(_pidl, pidl);
                    ILFree(pidlOld);
                }
                else 
                {
                    _pidl = ILClone(pidl);
                }
                AddRef();
                hr = S_OK;
            }
        }
        break;

    case VIEWPIDL_ORDER_FREQ:
    case VIEWPIDL_ORDER_TODAY:
    case VIEWPIDL_SEARCH:
        hr = E_NOTIMPL;
        break;
    }
    return hr;
}

HRESULT CHistFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    *ppv = NULL;

    BOOL fRealignedPidl;
    HRESULT hr = AlignPidl(&pidl, &fRealignedPidl);

    if (SUCCEEDED(hr))
    {
        if (IS_VALID_VIEWPIDL(pidl)) 
        {
            hr = _ViewPidl_BindToObject(pidl, pbc, riid, ppv);
        }
        else if (_uViewType)
        {
            hr = _ViewType_BindToObject(pidl, pbc, riid, ppv);
        }
        else
        {
            FOLDER_TYPE ftNew = _foldertype;
            LPCITEMIDLIST pidlNext = pidl;

            while (pidlNext->mkid.cb && SUCCEEDED(hr))
            {
                LPHIDPIDL phid = (LPHIDPIDL)pidlNext;
                switch (ftNew)
                {
                case FOLDER_TYPE_Hist:
                    if (phid->usSign != IDIPIDL_SIGN && phid->usSign != IDTPIDL_SIGN)
                        hr = E_FAIL;
                    else
                        ftNew = FOLDER_TYPE_HistInterval;
                    break;

                case FOLDER_TYPE_HistDomain:
                    if (phid->usSign != HEIPIDL_SIGN)
                        hr = E_FAIL;
                    break;

                case FOLDER_TYPE_HistInterval:
                    if (phid->usSign != IDDPIDL_SIGN)
                        hr = E_FAIL;
                    else
                        ftNew = FOLDER_TYPE_HistDomain;
                    break;

                default:
                    hr = E_FAIL;
                }

                if (SUCCEEDED(hr))
                    pidlNext = _ILNext(pidlNext);
            }

            if (SUCCEEDED(hr))
            {
                CHistFolder *phsf = new CHistFolder(ftNew);
                if (phsf)
                {
                    //  If we're binding to a Domain from an Interval, pidl will not contain the
                    //  interval, so we've got to do a SetCachePrefix.
                    hr = phsf->SetCachePrefix(_pszCachePrefix);
                    if (SUCCEEDED(hr))
                    {
                        LPITEMIDLIST pidlNew;
                        hr = SHILCombine(_pidl, pidl, &pidlNew);
                        if (SUCCEEDED(hr))
                        {
                            hr = phsf->Initialize(pidlNew);
                            if (SUCCEEDED(hr))
                            {
                                hr = phsf->QueryInterface(riid, ppv);
                            }
                            ILFree(pidlNew);
                        }
                    }
                    phsf->Release();
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }

        if (fRealignedPidl)
            FreeRealignedPidl(pidl);
    }

    return hr;
}

HRESULT CHistFolder::BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    *ppv = NULL;
    return E_NOTIMPL;
}

// A Successor to the IsLeaf
BOOL CHistFolder::_IsLeaf()
{
    BOOL fRet = FALSE;

    switch(_uViewType) {
    case 0:
        fRet = IsLeaf(_foldertype);
        break;
    case VIEWPIDL_ORDER_FREQ:
    case VIEWPIDL_ORDER_TODAY:
    case VIEWPIDL_SEARCH:
        fRet = TRUE;
        break;
    case VIEWPIDL_ORDER_SITE:
        fRet = (_uViewDepth == 1);
        break;
    }
    return fRet;
}

// coroutine for CompaireIDs -- makes recursive call
int CHistFolder::_View_ContinueCompare(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2) 
{
    int iRet = 0;
    if ( (pidl1 = _ILNext(pidl1)) && (pidl2 = _ILNext(pidl2)) ) 
    {
        BOOL fEmpty1 = ILIsEmpty(pidl1);
        BOOL fEmpty2 = ILIsEmpty(pidl2);
        if (fEmpty1 || fEmpty2) 
        {
            if (fEmpty1 && fEmpty2)
                iRet = 0;
            else
                iRet = (fEmpty1 ? -1 : 1);
        }
        else 
        {
            IShellFolder *psf;
            if (SUCCEEDED(BindToObject(pidl1, NULL, IID_PPV_ARG(IShellFolder, &psf))))
            {
                iRet = psf->CompareIDs(0, pidl1, pidl2);
                psf->Release();
            }
        }
    }
    return iRet;
}

int _CompareTitles(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    int iRet = 0;
    LPCTSTR pszTitle1;
    LPCTSTR pszTitle2;
    LPCTSTR pszUrl1   = _StripHistoryUrlToUrl(HPidlToSourceUrl(pidl1));
    LPCTSTR pszUrl2   = _StripHistoryUrlToUrl(HPidlToSourceUrl(pidl2));

    ua_GetURLTitle( &pszTitle1, (LPBASEPIDL)pidl1 );
    ua_GetURLTitle( &pszTitle2, (LPBASEPIDL)pidl2 );

    // CompareIDs has to check for equality, also -- two URLs are only equal when
    //   they have the same URL (not title)
    int iUrlCmp;
    if (!(iUrlCmp = StrCmpI(pszUrl1, pszUrl2)))
        iRet = 0;
    else 
    {
        iRet = StrCmpI( (pszTitle1 ? pszTitle1 : pszUrl1),
                        (pszTitle2 ? pszTitle2 : pszUrl2) );

        // this says:  if two docs have the same Title, but different URL
        //             we then sort by url -- the last thing we want to do
        //             is return that they're equal!!  Ay Caramba!
        if (iRet == 0)
            iRet = iUrlCmp;
    }
    return iRet;
}


// unalligned verison

#if defined(UNIX) || !defined(_X86_)

UINT ULCompareFileTime(UNALIGNED const FILETIME *pft1, UNALIGNED const FILETIME *pft2)
{
    FILETIME tmpFT1, tmpFT2;
    CopyMemory(&tmpFT1, pft1, sizeof(tmpFT1));
    CopyMemory(&tmpFT2, pft2, sizeof(tmpFT1));
    return CompareFileTime( &tmpFT1, &tmpFT2 );
}

#else

#define ULCompareFileTime(pft1, pft2) CompareFileTime(pft1, pft2)

#endif


HRESULT CHistFolder::_ViewType_CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    ASSERT(_uViewType);

    int iRet = -1;

    if (pidl1 && pidl2)
    {
        switch (_uViewType) {
        case VIEWPIDL_ORDER_FREQ:
            ASSERT(_IsValid_HEIPIDL(pidl1) && _IsValid_HEIPIDL(pidl2));
            // need to strip because freq pidls are "Visited: " and
            //  all others come from our special bucket
            if (!_CompareHCURLs(pidl1, pidl2))
                iRet = 0;
            else
                iRet = ((((LPHEIPIDL)pidl2)->llPriority < ((LPHEIPIDL)pidl1)->llPriority) ? -1 : +1);
            break;
        case VIEWPIDL_SEARCH:
            iRet = _CompareTitles(pidl1, pidl2);
            break;
        case VIEWPIDL_ORDER_TODAY:  // view by order visited today
            {
                int iNameDiff;
                ASSERT(_IsValid_HEIPIDL(pidl1) && _IsValid_HEIPIDL(pidl2));
                // must do this comparison because CompareIDs is not only called for Sorting
                //  but to see if some pidls are equal

                if ((iNameDiff = _CompareHCURLs(pidl1, pidl2)) == 0)
                    iRet = 0;
                else
                {
                    iRet = ULCompareFileTime(&(((LPHEIPIDL)pidl2)->ftModified), &(((LPHEIPIDL)pidl1)->ftModified));
                    // if the file times are equal, they're still not the same url -- so
                    //   they have to be ordered on url
                    if (iRet == 0)
                        iRet = iNameDiff;
                }
                break;
            }
        case VIEWPIDL_ORDER_SITE:
            if (_uViewDepth == 0)
            {
                TCHAR szName1[MAX_PATH], szName2[MAX_PATH];

                _GetURLDispName((LPBASEPIDL)pidl1, szName1, ARRAYSIZE(szName1));
                _GetURLDispName((LPBASEPIDL)pidl2, szName2, ARRAYSIZE(szName2));

                iRet = StrCmpI(szName1, szName2);
            }
            else if (_uViewDepth == 1) {
                iRet = _CompareTitles(pidl1, pidl2);
            }
            break;
        }
        if (iRet == 0)
            iRet = _View_ContinueCompare(pidl1, pidl2);
    }
    else {
        iRet = -1;
    }

    return ResultFromShort((SHORT)iRet);
}

HRESULT CHistFolder::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    BOOL fRealigned1;
    HRESULT hr = AlignPidl(&pidl1, &fRealigned1);
    if (SUCCEEDED(hr))
    {
        BOOL fRealigned2;
        hr = AlignPidl(&pidl2, &fRealigned2);
        if (SUCCEEDED(hr))
        {
            hr = _CompareAlignedIDs(lParam, pidl1, pidl2);

            if (fRealigned2)
                FreeRealignedPidl(pidl2);
        }

        if (fRealigned1)
            FreeRealignedPidl(pidl1);
    }

    return hr;
}

HRESULT CHistFolder::_CompareAlignedIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    int iRet = 0;
    USHORT usSign;
    FOLDER_TYPE FolderType = _foldertype;
    LPHEIPIDL phei1 = NULL;
    LPHEIPIDL phei2 = NULL;

    if (NULL == pidl1 || NULL == pidl2)
        return E_INVALIDARG;

    if (_uViewType)
    {
        return _ViewType_CompareIDs(lParam, pidl1, pidl2);
    }

    if (IS_VALID_VIEWPIDL(pidl1) && IS_VALID_VIEWPIDL(pidl2))
    {
        if ((((LPVIEWPIDL)pidl1)->usViewType == ((LPVIEWPIDL)pidl2)->usViewType) &&
            (((LPVIEWPIDL)pidl1)->usExtra    == ((LPVIEWPIDL)pidl2)->usExtra))
        {
            iRet = _View_ContinueCompare(pidl1, pidl2);
        }
        else
        {
            iRet = ((((LPVIEWPIDL)pidl1)->usViewType < ((LPVIEWPIDL)pidl2)->usViewType) ? -1 : 1);
        }
        goto exitPoint;
    }

    if (!IsLeaf(_foldertype))
    {
        //  We try to avoid unneccessary BindToObjs to compare partial paths
        usSign = FOLDER_TYPE_Hist == FolderType  ? IDIPIDL_SIGN : IDDPIDL_SIGN;
        while (TRUE)
        {
            LPBASEPIDL pceip1 = (LPBASEPIDL) pidl1;
            LPBASEPIDL pceip2 = (LPBASEPIDL) pidl2;

            if (pidl1->mkid.cb == 0 || pidl2->mkid.cb == 0)
            {
                iRet = pidl1->mkid.cb == pidl2->mkid.cb ? 0 : 1;
                goto exitPoint;
            }

            if (!_IsValid_IDPIDL(pidl1) || !_IsValid_IDPIDL(pidl2))
                return E_FAIL;

            if (!EQUIV_IDSIGN(pceip1->usSign,usSign) || !EQUIV_IDSIGN(pceip2->usSign,usSign))
                return E_FAIL;

            if (_foldertype == FOLDER_TYPE_HistInterval)
            {
                TCHAR szName1[MAX_PATH], szName2[MAX_PATH];

                _GetURLDispName((LPBASEPIDL)pidl1, szName1, ARRAYSIZE(szName1));
                _GetURLDispName((LPBASEPIDL)pidl2, szName2, ARRAYSIZE(szName2));

                iRet = StrCmpI(szName1, szName2);
                goto exitPoint;
            }
            else
            {
                iRet = ualstrcmpi(_GetURLTitle((LPBASEPIDL)pidl1), _GetURLTitle((LPBASEPIDL)pidl2));
                if (iRet != 0)
                    goto exitPoint;
            }

            if (pceip1->usSign != pceip2->usSign)
            {
                iRet = -1;
                goto exitPoint;
            }

            pidl1 = _ILNext(pidl1);
            pidl2 = _ILNext(pidl2);
            if (IDIPIDL_SIGN == usSign)
            {
                usSign = IDDPIDL_SIGN;
            }
        }
    }

    //  At this point, both pidls have resolved to leaf (history or cache)

    phei1 = _IsValid_HEIPIDL(pidl1);
    phei2 = _IsValid_HEIPIDL(pidl2);
    if (!phei1 || !phei2)
        return E_FAIL;

    switch (lParam & SHCIDS_COLUMNMASK) 
    {
    case ICOLH_URL_TITLE:
        {
            TCHAR szStr1[MAX_PATH], szStr2[MAX_PATH];
            _GetHistURLDispName(phei1, szStr1, ARRAYSIZE(szStr1));
            _GetHistURLDispName(phei2, szStr2, ARRAYSIZE(szStr2));

            iRet = StrCmpI(szStr1, szStr2);
        }
        break;

    case ICOLH_URL_NAME:
        iRet = _CompareHFolderPidl(pidl1, pidl2);
        break;

    case ICOLH_URL_LASTVISITED:
        iRet = ULCompareFileTime(&((LPHEIPIDL)pidl2)->ftModified, &((LPHEIPIDL)pidl1)->ftModified);
        break;

    default:
        // The high bit on means to compare absolutely, ie: even if only filetimes
        // are different, we rule file pidls to be different

        if (lParam & SHCIDS_ALLFIELDS)
        {
            iRet = CompareIDs(ICOLH_URL_NAME, pidl1, pidl2);
            if (iRet == 0)
            {
                iRet = CompareIDs(ICOLH_URL_TITLE, pidl1, pidl2);
                if (iRet == 0)
                {
                    iRet = CompareIDs(ICOLH_URL_LASTVISITED, pidl1, pidl2);
                }
            }
        }
        else
        {
            iRet = -1;
        }
        break;
    }
exitPoint:

    return ResultFromShort((SHORT)iRet);
}


HRESULT CHistFolder::CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
{
    HRESULT hr = E_NOINTERFACE;

    *ppv = NULL;

    if (riid == IID_IShellView)
    {
        ASSERT(!_uViewType);
        hr = HistFolderView_CreateInstance(this, ppv);
    }
    else if (riid == IID_IContextMenu)
    {
        // this creates the "Arrange Icons" cascased menu in the background of folder view
        if (IsLeaf(_foldertype))
        {
            CFolderArrangeMenu *p = new CFolderArrangeMenu(MENU_HISTORY);
            if (p)
            {
                hr = p->QueryInterface(riid, ppv);
                p->Release();
            }
            else
                hr = E_OUTOFMEMORY;
        }
    }
    else if (riid == IID_IShellDetails)
    {
        CDetailsOfFolder *p = new CDetailsOfFolder(hwnd, this);
        if (p)
        {
            hr = p->QueryInterface(riid, ppv);
            p->Release();
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CHistFolder::_ViewType_GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG *prgfInOut)
{
    ASSERT(_uViewType);

    if (!prgfInOut || !apidl)
        return E_INVALIDARG;

    HRESULT hr       = S_OK;
    int     cGoodPidls = 0;

    if (*prgfInOut & SFGAO_VALIDATE) 
    {
        for (UINT u = 0; SUCCEEDED(hr) && (u < cidl); ++u) 
        {
            switch(_uViewType) 
            {
            case VIEWPIDL_ORDER_TODAY: 
                _EnsureHistStg();
                if (_IsValid_HEIPIDL(apidl[u]) &&
                    SUCCEEDED(_pUrlHistStg->QueryUrl(_StripHistoryUrlToUrl(HPidlToSourceUrl(apidl[u])),
                               STATURL_QUERYFLAG_NOURL, NULL)))
                {
                    ++cGoodPidls;
                }
                else
                    hr = E_FAIL;
                break;

            case VIEWPIDL_SEARCH:
            case VIEWPIDL_ORDER_FREQ:
                // this is a temporary fix to get the behaviour of the namespace
                //  control correct -- the long-term fix involves cacheing a
                //  generated list of these items and validating that list
                break;

            case VIEWPIDL_ORDER_SITE:
                {
                    ASSERT(_uViewDepth == 1);
                    _ValidateIntervalCache();
                    LPCWSTR psz = _StripHistoryUrlToUrl(HPidlToSourceUrl(apidl[u]));
                    if (psz && _SearchFlatCacheForUrl(psz, NULL, NULL) == ERROR_SUCCESS)
                    {
                        ++cGoodPidls;
                    }
                    else
                        hr = E_FAIL;
                }
                break;

            default:
                hr = E_FAIL;
            }
        }
    }

    if (SUCCEEDED(hr)) 
    {
        if (_IsLeaf())
            *prgfInOut = SFGAO_CANCOPY | SFGAO_HASPROPSHEET;
        else
            *prgfInOut = SFGAO_FOLDER;
    }

    return hr;
}

// Right now, we will allow TIF Drag in Browser Only, even though
// it will not be Zone Checked at the Drop.
//#define BROWSERONLY_NOTIFDRAG

HRESULT CHistFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl, ULONG * prgfInOut)
{
    ULONG rgfInOut;
    FOLDER_TYPE FolderType = _foldertype;

    // Make sure each pidl in the array is dword aligned.

    BOOL fRealigned;
    HRESULT hr = AlignPidlArray(apidl, cidl, &apidl, &fRealigned);
    if (SUCCEEDED(hr))
    {
        // For view types, we'll map FolderType to do the right thing...
        if (_uViewType)
        {
            hr = _ViewType_GetAttributesOf(cidl, apidl, prgfInOut);
        }
        else
        {
            switch (FolderType)
            {
            case FOLDER_TYPE_Hist:
                rgfInOut = SFGAO_FOLDER | SFGAO_HASSUBFOLDER;
                break;

            case FOLDER_TYPE_HistInterval:
                rgfInOut = SFGAO_FOLDER;
                break;

            case FOLDER_TYPE_HistDomain:
                {
                    UINT cGoodPidls;

                    if (SFGAO_VALIDATE & *prgfInOut)
                    {
                        cGoodPidls = 0;
                        if (SUCCEEDED(_EnsureHistStg()))
                        {
                            for (UINT i = 0; i < cidl; i++)
                            {
                                //  NOTE: QueryUrlA checks for NULL URL and returns E_INVALIDARG
                                if (!_IsValid_HEIPIDL(apidl[i]) ||
                                    FAILED(_pUrlHistStg->QueryUrl(_StripHistoryUrlToUrl(HPidlToSourceUrl(apidl[i])),
                                                STATURL_QUERYFLAG_NOURL, NULL)))
                                {
                                    break;
                                }
                                cGoodPidls++;
                            }
                        }
                    }
                    else
                        cGoodPidls = cidl;

                    if (cidl == cGoodPidls)
                    {
                        rgfInOut = SFGAO_CANCOPY | SFGAO_HASPROPSHEET;
                        break;
                    }
                    // FALL THROUGH INTENDED!
                }

            default:
                rgfInOut = 0;
                hr = E_FAIL;
                break;
            }

            // all items can be deleted
            if (SUCCEEDED(hr))
                rgfInOut |= SFGAO_CANDELETE;
            *prgfInOut = rgfInOut;
        }

        if (fRealigned)
            FreeRealignedPidlArray(apidl, cidl);
    }

    return hr;
}

HRESULT CHistFolder::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl,
                        REFIID riid, UINT * prgfInOut, void **ppv)
{
    *ppv = NULL;         // null the out param

    // Make sure all pidls in the array are dword aligned.

    BOOL fRealigned;
    HRESULT hr = AlignPidlArray(apidl, cidl, &apidl, &fRealigned);
    if (SUCCEEDED(hr))
    {
        if ((riid == IID_IShellLinkA ||
             riid == IID_IShellLinkW ||
             riid == IID_IExtractIconA ||
             riid == IID_IExtractIconW) &&
             _IsLeaf())
        {
            LPCTSTR pszURL = HPidlToSourceUrl(apidl[0]);

            pszURL = _StripHistoryUrlToUrl(pszURL);

            hr = _GetShortcut(pszURL, riid, ppv);
       }
        else if ((riid == IID_IContextMenu) ||
                 (riid == IID_IDataObject) ||
                 (riid == IID_IExtractIconA) ||
                 (riid == IID_IExtractIconW) ||
                 (riid == IID_IQueryInfo))
        {
            hr = CHistItem_CreateInstance(this, hwnd, cidl, apidl, riid, ppv);
        }
        else
        {
            hr = E_FAIL;
        }

        if (fRealigned)
            FreeRealignedPidlArray(apidl, cidl);
    }

    return hr;
}

HRESULT CHistFolder::GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay)
{
    if (pSort)
    {
        if (_uViewType == 0 && _foldertype == FOLDER_TYPE_HistDomain)
            *pSort = ICOLH_URL_TITLE;
        else
            *pSort = 0;
    }

    if (pDisplay)
    {
        if (_uViewType == 0 && _foldertype == FOLDER_TYPE_HistDomain)
            *pDisplay = ICOLH_URL_TITLE;
        else
            *pDisplay = 0;
    }
    return S_OK;
}

LPCTSTR _GetUrlForPidl(LPCITEMIDLIST pidl)
{
    LPCTSTR pszUrl = _StripHistoryUrlToUrl(HPidlToSourceUrl(pidl));
    
    return pszUrl ? pszUrl : TEXT("");
}

HRESULT CHistFolder::_GetInfoTip(LPCITEMIDLIST pidl, DWORD dwFlags, WCHAR **ppwszTip)
{
    HRESULT hr;
    TCHAR szTip[MAX_URL_STRING + 100], szPart2[MAX_URL_STRING];

    szTip[0] = szPart2[0] = 0;

    FOLDER_TYPE FolderType = _foldertype;

    // For special views, map FolderType to do the right thing
    if (_uViewType)
    {
        switch(_uViewType) {
        case VIEWPIDL_SEARCH:
        case VIEWPIDL_ORDER_FREQ:
        case VIEWPIDL_ORDER_TODAY:
            FolderType = FOLDER_TYPE_HistDomain;
            break;
        case VIEWPIDL_ORDER_SITE:
            if (_uViewDepth == 0)
                FolderType = FOLDER_TYPE_HistInterval;
            else
                FolderType = FOLDER_TYPE_HistDomain;
            break;
        }
    }

    switch (FolderType)
    {
    case FOLDER_TYPE_HistDomain:
        {
            _GetHistURLDispName((LPHEIPIDL)pidl, szTip, ARRAYSIZE(szTip));
            DWORD cchPart2 = ARRAYSIZE(szPart2);
            PrepareURLForDisplayUTF8(_GetUrlForPidl(pidl), szPart2, &cchPart2, TRUE);
        }
        break;


    case FOLDER_TYPE_Hist:
        {
            FILETIME ftStart, ftEnd;
            LPCTSTR pszIntervalName;
            
            ua_GetURLTitle(&pszIntervalName, (LPBASEPIDL)pidl);

            if (SUCCEEDED(_ValueToInterval(pszIntervalName, &ftStart, &ftEnd)))
            {
                GetTooltipForTimeInterval(&ftStart, &ftEnd, szTip, ARRAYSIZE(szTip));
            }
            break;
        }

    case FOLDER_TYPE_HistInterval:
        {
            TCHAR szFmt[64];

            MLLoadString(IDS_SITETOOLTIP, szFmt, ARRAYSIZE(szFmt));
            wnsprintf(szTip, ARRAYSIZE(szTip), szFmt, _GetURLTitle((LPBASEPIDL)pidl));
            break;
        }
    }

    if (szTip[0])
    {
        // Only combine the 2 parts if the second part exists, and if
        // the 2 parts are not equal.
        if (szPart2[0] && StrCmpI(szTip, szPart2) != 0)
        {
            StrCatBuff(szTip, TEXT("\r\n"), ARRAYSIZE(szTip));
            StrCatBuff(szTip, szPart2, ARRAYSIZE(szTip));
        }
        hr = SHStrDup(szTip, ppwszTip);
    }
    else
    {
        hr = E_FAIL;
        *ppwszTip = NULL;
    }

    return hr;
}

//
// _GetFriendlyUrlDispName -- compute the "friendly name" of an URL
//
// in:  A UTF8 encoded URL.  For example, ftp://ftp.nsca.uiuc.edu/foo.bar
//
// out: A "friendly name" for the URL with the path stripped if necessary
//      (ie   ftp://ftp.ncsa.uiuc.edu   ==> ftp.ncsa.uiuc.edu
//        and ftp://www.foo.bar/foo.bar ==> foo -or- foo.bar depeneding on
//                                whether file xtnsn hiding is on or off
//
// NOTE: pszUrl and pszOut may be the same buffer -- this is allowed
//
HRESULT _GetFriendlyUrlDispName(LPCTSTR pszUrl, LPTSTR pszOut, DWORD cchBuf)
{
    HRESULT hr = E_FAIL;

    PrepareURLForDisplayUTF8(pszUrl, pszOut, &cchBuf, TRUE);

    TCHAR szUrlPath[MAX_PATH];
    TCHAR szUrlHost[MAX_PATH];

    // Set up InternetCrackUrl parameter block
    SHURL_COMPONENTSW urlcomponents  = { 0 };
    urlcomponents.dwStructSize    = sizeof(URL_COMPONENTS);
    urlcomponents.lpszUrlPath     = szUrlPath;
    urlcomponents.dwUrlPathLength = ARRAYSIZE(szUrlPath);
    urlcomponents.lpszHostName    = szUrlHost;
    urlcomponents.dwHostNameLength = ARRAYSIZE(szUrlHost);
                        
    if (UrlCrackW(pszOut, cchBuf, ICU_DECODE, &urlcomponents))
    {
        SHELLSTATE ss;
        SHGetSetSettings(&ss, SSF_SHOWEXTENSIONS, FALSE);

        // eliminate trailing slash
        if ((urlcomponents.dwUrlPathLength > 0) &&
            (urlcomponents.lpszUrlPath[urlcomponents.dwUrlPathLength - 1] == TEXT('/')))
        {
            urlcomponents.lpszUrlPath[urlcomponents.dwUrlPathLength - 1] = TEXT('\0');
            --urlcomponents.dwUrlPathLength;
        }
        
        if (urlcomponents.dwUrlPathLength > 0)
        {
            // LPCTSTR _FindURLFileName(LPCTSTR) --> const_cast is OK
            LPTSTR pszFileName = const_cast<LPTSTR>(_FindURLFileName(urlcomponents.lpszUrlPath));
            
            if (!ss.fShowExtensions)
            {
                PathRemoveExtension(pszFileName);
            }
            StrCpyN(pszOut, pszFileName, cchBuf);
        }
        else
        {
            StrCpyN(pszOut, urlcomponents.lpszHostName, cchBuf);
        }

        hr = S_OK;
    }

    return hr;
}


void CHistFolder::_GetHistURLDispName(LPHEIPIDL phei, LPTSTR pszStr, UINT cchStr)
{
    *pszStr = 0;

    if ((phei->usFlags & HISTPIDL_VALIDINFO) && phei->usTitle)
    {
        StrCpyN(pszStr, (LPTSTR)((BYTE*)phei + phei->usTitle), cchStr);
    }
    else if (SUCCEEDED(_EnsureHistStg()))
    {
        LPCTSTR pszUrl = _StripHistoryUrlToUrl(HPidlToSourceUrl((LPCITEMIDLIST)phei));
        if (pszUrl)
        {
            STATURL suThis;
            if (SUCCEEDED(_pUrlHistStg->QueryUrl(pszUrl, STATURL_QUERYFLAG_NOURL, &suThis)) && suThis.pwcsTitle)
            {
                // sometimes the URL is stored in the title
                // avoid using those titles.
                if (_TitleIsGood(suThis.pwcsTitle))
                    SHUnicodeToTChar(suThis.pwcsTitle, pszStr, cchStr);

                OleFree(suThis.pwcsTitle);
            }

            //  if we havent got anything yet
            if (!*pszStr) 
            {
                if (FAILED(_GetFriendlyUrlDispName(pszUrl, pszStr, cchStr)))
                {
                    // last resort: display the whole URL
                    StrCpyN(pszStr, pszUrl, cchStr);
                }
            }
        }
    }
}

HRESULT CHistFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, STRRET *lpName)
{
    TCHAR szTemp[MAX_URL_STRING];

    szTemp[0] = 0;

    // Make sure the pidl is dword aligned.

    BOOL fRealigned;

    if (SUCCEEDED(AlignPidl(&pidl, &fRealigned)))
    {
        if (IS_VALID_VIEWPIDL(pidl))
        {
            UINT idRsrc;
            switch(((LPVIEWPIDL)pidl)->usViewType) {
            case VIEWPIDL_ORDER_SITE:  idRsrc = IDS_HISTVIEW_SITE;      break;
            case VIEWPIDL_ORDER_TODAY: idRsrc = IDS_HISTVIEW_TODAY;     break;
            case VIEWPIDL_ORDER_FREQ:
            default:
                idRsrc = IDS_HISTVIEW_FREQUENCY; break;
            }

            MLLoadString(idRsrc, szTemp, ARRAYSIZE(szTemp));
        }
        else
        {
            if (_uViewType  == VIEWPIDL_ORDER_SITE &&
                _uViewDepth  == 0)
            {
                _GetURLDispName((LPBASEPIDL)pidl, szTemp, ARRAYSIZE(szTemp));
            }
            else if (_IsLeaf())
            {
                LPCTSTR pszTitle;
                BOOL fDoUnescape;  

                ua_GetURLTitle(&pszTitle, (LPBASEPIDL)pidl);
                // _GetURLTitle could return the real title or just an URL.
                // We use _URLTitleIsURL to make sure we don't unescape any titles.

                if (pszTitle && *pszTitle)
                {
                    StrCpyN(szTemp, pszTitle, ARRAYSIZE(szTemp));
                    fDoUnescape = _URLTitleIsURL((LPBASEPIDL)pidl);
                }
                else
                {
                    LPCTSTR pszUrl = _StripHistoryUrlToUrl(HPidlToSourceUrl(pidl));
                    if (pszUrl) 
                        StrCpyN(szTemp, pszUrl, ARRAYSIZE(szTemp));
                    fDoUnescape = TRUE;
                }
                
                if (fDoUnescape)
                {
                    // at this point, szTemp contains part of an URL
                    //  we will crack (smoke) the URL
                    LPCTSTR pszUrl = HPidlToSourceUrl(pidl);

                    // Is this pidl a history entry?
                    if (((LPBASEPIDL)pidl)->usSign == (USHORT)HEIPIDL_SIGN)
                    {
                        pszUrl = _StripHistoryUrlToUrl(pszUrl);
                    }                  

                    if (pszUrl)
                    {
                        if (FAILED(_GetFriendlyUrlDispName(pszUrl, szTemp, ARRAYSIZE(szTemp))))
                        {
                            StrCpyN(szTemp, pszUrl, ARRAYSIZE(szTemp));
                        }
                    }
                }
            }
            else
            {
                // for the history, we'll use the title if we have one, otherwise we'll use
                // the url filename.
                switch (_foldertype)
                {
                case FOLDER_TYPE_HistDomain:
                    _GetHistURLDispName((LPHEIPIDL)pidl, szTemp, ARRAYSIZE(szTemp));
                    break;

                case FOLDER_TYPE_Hist:
                    {
                        FILETIME ftStart, ftEnd;

                        _ValueToInterval(_GetURLTitle((LPBASEPIDL)pidl), &ftStart, &ftEnd);
                        GetDisplayNameForTimeInterval(&ftStart, &ftEnd, szTemp, ARRAYSIZE(szTemp));
                    }
                    break;

                case FOLDER_TYPE_HistInterval:
                    _GetURLDispName((LPBASEPIDL)pidl, szTemp, ARRAYSIZE(szTemp));
                    break;
                }
            }
        }

        if (fRealigned)
            FreeRealignedPidl(pidl);
    }

    return StringToStrRet(szTemp, lpName);
}

HRESULT CHistFolder::SetNameOf(HWND hwnd, LPCITEMIDLIST pidl,
                        LPCOLESTR pszName, DWORD uFlags, LPITEMIDLIST *ppidlOut)
{
    if (ppidlOut)
        *ppidlOut = NULL;               // null the out param
    return E_FAIL;
}

//////////////////////////////////
//
// IShellIcon Methods...
//
HRESULT CHistFolder::GetIconOf(LPCITEMIDLIST pidl, UINT flags, LPINT lpIconIndex)
{
    return S_FALSE;
}

// IPersist
HRESULT CHistFolder::GetClassID(CLSID *pclsid)
{
    *pclsid = CLSID_HistFolder;
    return S_OK;
}

HRESULT CHistFolder::Initialize(LPCITEMIDLIST pidlInit)
{
    HRESULT hr = S_OK;
    ILFree(_pidl);

    if ((FOLDER_TYPE_Hist == _foldertype) && !IsCSIDLFolder(CSIDL_HISTORY, pidlInit))
        hr = E_FAIL;
    else
    {
        hr = SHILClone(pidlInit, &_pidl);
        if (SUCCEEDED(hr))
            hr = _ExtractInfoFromPidl();
    }
    return hr;
}

//////////////////////////////////
//
// IPersistFolder2 Methods...
//
HRESULT CHistFolder::GetCurFolder(LPITEMIDLIST *ppidl)
{
    if (_pidl)
        return SHILClone(_pidl, ppidl);

    *ppidl = NULL;      
    return S_FALSE; // success but empty
}

//////////////////////////////////////////////////
// IShellFolderViewType Methods
//
// but first, the enumerator class...
class CHistViewTypeEnum : public IEnumIDList
{
    friend class CHistFolder;
public:
    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumIDList Methods
    STDMETHODIMP Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt) { _uCurViewType += celt; return S_OK; }
    STDMETHODIMP Reset()          { _uCurViewType =     1; return S_OK; }
    STDMETHODIMP Clone(IEnumIDList **ppenum);

private:
    ~CHistViewTypeEnum() {}
    CHistViewTypeEnum() : _cRef(1), _uCurViewType(1) {}

    LONG  _cRef;
    UINT  _uCurViewType;
};

STDMETHODIMP CHistViewTypeEnum::QueryInterface(REFIID riid, void **ppv) 
{
    static const QITAB qit[] = {
        QITABENT(CHistViewTypeEnum, IEnumIDList),                        // IID_IEnumIDList
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CHistViewTypeEnum::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}

ULONG CHistViewTypeEnum::Release(void)
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CHistViewTypeEnum::Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched)
{
    HRESULT hr = S_FALSE;

    if (rgelt && (pceltFetched || 1 == celt))
    {
        ULONG i = 0;

        while (i < celt)
        {
            if (_uCurViewType <= VIEWPIDL_ORDER_MAX)
            {
                hr = CreateSpecialViewPidl(_uCurViewType, &(rgelt[i]));

                if (SUCCEEDED(hr))
                {
                    ++i;
                    ++_uCurViewType;
                }
                else
                {
                    while (i)
                        ILFree(rgelt[--i]);

                    break;
                }
            }
            else
            {
                break;
            }
        }

        if (pceltFetched)
            *pceltFetched = i;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP CHistViewTypeEnum::Clone(IEnumIDList **ppenum)
{
    CHistViewTypeEnum* phvte = new CHistViewTypeEnum();
    if (phvte) 
    {
        phvte->_uCurViewType = _uCurViewType;
        *ppenum = phvte;
        return S_OK;
    }
    else
        return E_OUTOFMEMORY;
}

// Continuing with the CHistFolder::IShellFolderViewType
STDMETHODIMP CHistFolder::EnumViews(ULONG grfFlags, IEnumIDList **ppenum) 
{
    *ppenum = new CHistViewTypeEnum();
    return *ppenum ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP CHistFolder::GetDefaultViewName(DWORD uFlags, LPWSTR *ppwszName) 
{
    TCHAR szName[MAX_PATH];

    MLLoadString(IDS_HISTVIEW_DEFAULT, szName, ARRAYSIZE(szName));
    return SHStrDup(szName, ppwszName);
}

// Remember that these *MUST* be in order so that
//  the array can be accessed by VIEWPIDL type
const DWORD CHistFolder::_rdwFlagsTable[] = {
    SFVTFLAG_NOTIFY_CREATE,                          // Date
    SFVTFLAG_NOTIFY_CREATE,                          // site
    0,                                               // freq
    SFVTFLAG_NOTIFY_CREATE | SFVTFLAG_NOTIFY_RESORT  // today
};

STDMETHODIMP CHistFolder::GetViewTypeProperties(LPCITEMIDLIST pidl, DWORD *pdwFlags) 
{
    HRESULT hr = S_OK;
    UINT uFlagTableIndex = 0;

    if ((pidl != NULL) && !ILIsEmpty(pidl)) // default view
    {
        // Make sure the pidl is dword aligned.

        BOOL fRealigned;
        hr = AlignPidl(&pidl, &fRealigned);

        if (SUCCEEDED(hr))
        {
            if (IS_VALID_VIEWPIDL(pidl))
            {
                uFlagTableIndex = ((LPVIEWPIDL)pidl)->usViewType;
                ASSERT(uFlagTableIndex <= VIEWPIDL_ORDER_MAX);
            }
            else
            {
                hr =  E_INVALIDARG;
            }

            if (fRealigned)
                FreeRealignedPidl(pidl);
        }
    }

    *pdwFlags = _rdwFlagsTable[uFlagTableIndex];

    return hr;
}

HRESULT CHistFolder::TranslateViewPidl(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlView,
                                            LPITEMIDLIST *ppidlOut)
{
    HRESULT hr;

    if (pidl && IS_VALID_VIEWPIDL(pidlView))
    {
        if (!IS_VALID_VIEWPIDL(pidl))
        {
            hr = ConvertStandardHistPidlToSpecialViewPidl(pidl,
                                 ((LPVIEWPIDL)pidlView)->usViewType,
                                 ppidlOut);
        }
        else
        {
            hr = E_NOTIMPL;
        }

    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//////////////////////////////////////////////////
//
// IShellFolderSearchable Methods
//
// For more information about how this search stuff works,
//  please see the comments for _CurrentSearches above
STDMETHODIMP CHistFolder::FindString(LPCWSTR pwszTarget, LPDWORD pdwFlags,
                                          IUnknown *punkOnAsyncSearch,
                                          LPITEMIDLIST *ppidlOut)
{
    HRESULT hr = E_INVALIDARG;
    if (ppidlOut)
    {
        *ppidlOut = NULL;
        if (pwszTarget)
        {
            LPITEMIDLIST pidlView;

            SYSTEMTIME systime;
            FILETIME   ftNow;
            GetLocalTime(&systime);
            SystemTimeToFileTime(&systime, &ftNow);

            hr = CreateSpecialViewPidl(VIEWPIDL_SEARCH, &pidlView, sizeof(SEARCHVIEWPIDL) - sizeof(VIEWPIDL));
            if (SUCCEEDED(hr))
            {
                ((LPSEARCHVIEWPIDL)pidlView)->ftSearchKey = ftNow;

                IShellFolderSearchableCallback *psfscOnAsyncSearch = NULL;
                if (punkOnAsyncSearch)
                    punkOnAsyncSearch->QueryInterface(IID_PPV_ARG(IShellFolderSearchableCallback, &psfscOnAsyncSearch));

                // Insert this search into the global database
                //  This constructor will AddRef psfscOnAsyncSearch
                _CurrentSearches *pcsNew = new _CurrentSearches(ftNow, pwszTarget, psfscOnAsyncSearch);

                if (pcsNew) 
                {
                    if (psfscOnAsyncSearch)
                        psfscOnAsyncSearch->Release();  // _CurrentSearches now holds the ref

                    // This will AddRef pcsNew 'cause its going in the list
                    _CurrentSearches::s_NewSearch(pcsNew);
                    pcsNew->Release();
                    *ppidlOut = pidlView;
                    hr = S_OK;
                }
                else 
                {
                    ILFree(pidlView);
                    hr = E_OUTOFMEMORY;
                }
            }
        }
    }

    return hr;
}

STDMETHODIMP CHistFolder::CancelAsyncSearch(LPCITEMIDLIST pidlSearch, LPDWORD pdwFlags)
{
    HRESULT hr = E_INVALIDARG;

    if (IS_VALID_VIEWPIDL(pidlSearch) &&
        (((LPVIEWPIDL)pidlSearch)->usViewType == VIEWPIDL_SEARCH))
    {
        hr = S_FALSE;
        _CurrentSearches *pcs = _CurrentSearches::s_FindSearch(((LPSEARCHVIEWPIDL)pidlSearch)->ftSearchKey);
        if (pcs) {
            pcs->_fKillSwitch = TRUE;
            hr = S_OK;
            pcs->Release();
        }
    }
    return hr;
}

STDMETHODIMP CHistFolder::InvalidateSearch(LPCITEMIDLIST pidlSearch, LPDWORD pdwFlags)
{
    HRESULT hr = E_INVALIDARG;
    if (IS_VALID_VIEWPIDL(pidlSearch) &&
        (((LPVIEWPIDL)pidlSearch)->usViewType == VIEWPIDL_SEARCH))
    {
        hr = S_FALSE;
        _CurrentSearches *pcs = _CurrentSearches::s_FindSearch(((LPSEARCHVIEWPIDL)pidlSearch)->ftSearchKey);
        if (pcs) {
            _CurrentSearches::s_RemoveSearch(pcs);
            pcs->Release();
        }
    }
    return hr;
}

//////////////////////////////////////////////////

DWORD CHistFolder::_GetHitCount(LPCTSTR pszUrl)
{
    DWORD dwHitCount = 0;
    IUrlHistoryPriv *pUrlHistStg = _GetHistStg();

    if (pUrlHistStg)
    {
        PROPVARIANT vProp = {0};
        if (SUCCEEDED(pUrlHistStg->GetProperty(pszUrl, PID_INTSITE_VISITCOUNT, &vProp)) &&
            (vProp.vt == VT_UI4))
        {
            dwHitCount = vProp.lVal;
        }
        pUrlHistStg->Release();
    }
    return dwHitCount;
}

// pidl should be freed by caller
// URL must have some sort of cache container prefix
LPHEIPIDL CHistFolder::_CreateHCacheFolderPidlFromUrl(BOOL fOleMalloc, LPCTSTR pszPrefixedUrl)
{
    LPHEIPIDL pheiRet;
    HRESULT   hrLocal = E_FAIL;
    STATURL   suThis;
    LPCTSTR pszStrippedUrl = _StripHistoryUrlToUrl(pszPrefixedUrl);
    IUrlHistoryPriv *pUrlHistStg = _GetHistStg();
    if (pUrlHistStg)
    {
        hrLocal = pUrlHistStg->QueryUrl(pszStrippedUrl, STATURL_QUERYFLAG_NOURL, &suThis);
        pUrlHistStg->Release();
    }

    FILETIME ftLastVisit = { 0 };
    DWORD    dwNumHits   = 0;

    if (FAILED(hrLocal)) { // maybe the cache knows...
        BYTE ab[MAX_URLCACHE_ENTRY];
        LPINTERNET_CACHE_ENTRY_INFO pcei = (LPINTERNET_CACHE_ENTRY_INFO)(&ab);
        DWORD dwSize = MAX_URLCACHE_ENTRY;
        if (GetUrlCacheEntryInfo(_StripHistoryUrlToUrl(pszPrefixedUrl), pcei, &dwSize)) {
            ftLastVisit = pcei->LastAccessTime;
            dwNumHits   = pcei->dwHitRate;
        }
    }

    pheiRet = _CreateHCacheFolderPidl(fOleMalloc, pszPrefixedUrl,
                                      SUCCEEDED(hrLocal) ? suThis.ftLastVisited : ftLastVisit,
                                      SUCCEEDED(hrLocal) ? &suThis : NULL, 0,
                                      SUCCEEDED(hrLocal) ? _GetHitCount(pszStrippedUrl) : dwNumHits);
    if (SUCCEEDED(hrLocal) && suThis.pwcsTitle)
        OleFree(suThis.pwcsTitle);
    return pheiRet;
}


UINT _CountPidlParts(LPCITEMIDLIST pidl) {
    LPCITEMIDLIST pidlTemp = pidl;
    UINT          uParts   = 0;

    if (pidl)
    {
        for (uParts = 0; pidlTemp->mkid.cb; pidlTemp = _ILNext(pidlTemp))
            ++uParts;
    }
    return uParts;
}

// you must dealloc (LocalFree) the ppidl returned
LPITEMIDLIST* _SplitPidl(LPCITEMIDLIST pidl, UINT& uSizeInOut) {
    LPCITEMIDLIST  pidlTemp  = pidl;
    LPITEMIDLIST*  ppidlList =
        reinterpret_cast<LPITEMIDLIST *>(LocalAlloc(LPTR,
                                                    sizeof(LPITEMIDLIST) * uSizeInOut));
    if (pidlTemp && ppidlList) {
        UINT uCount;
        for (uCount = 0; ( (uCount < uSizeInOut) && (pidlTemp->mkid.cb) );
             ++uCount, pidlTemp = _ILNext(pidlTemp))
            ppidlList[uCount] = const_cast<LPITEMIDLIST>(pidlTemp);
    }
    return ppidlList;
}

LPITEMIDLIST* _SplitPidlEasy(LPCITEMIDLIST pidl, UINT& uSizeOut) {
    uSizeOut = _CountPidlParts(pidl);
    return _SplitPidl(pidl, uSizeOut);
}

// caller LocalFree's *ppidlOut
//  returned pidl should be combined with the history folder location
HRESULT _ConvertStdPidlToViewPidl_OrderSite(LPCITEMIDLIST pidlSecondLast,
                                            LPCITEMIDLIST pidlLast,
                                            LPITEMIDLIST *ppidlOut) {
    HRESULT hr = E_FAIL;

    // painfully construct the final pidl by concatenating the little
    //   peices  [special_viewpidl, iddpidl, heipidl]
    if ( _IsValid_IDPIDL(pidlSecondLast)                                     &&
         EQUIV_IDSIGN(IDDPIDL_SIGN,
                      (reinterpret_cast<LPBASEPIDL>
                       (const_cast<LPITEMIDLIST>(pidlSecondLast)))->usSign)  &&
         (_IsValid_HEIPIDL(pidlLast)) )
    {
        LPITEMIDLIST pidlViewTemp = NULL;
        hr = CreateSpecialViewPidl(VIEWPIDL_ORDER_SITE, &pidlViewTemp);
        if (SUCCEEDED(hr) && pidlViewTemp) 
        {
            hr = SHILCombine(pidlViewTemp, pidlSecondLast, ppidlOut);
            ILFree(pidlViewTemp);
        }
    }
    else
        hr = E_INVALIDARG;
    return hr;
}

// caller LocalFree's *ppidlOut
//  returned pidl should be combined with the history folder location
HRESULT _ConvertStdPidlToViewPidl_OrderToday(LPITEMIDLIST pidlLast,
                                             LPITEMIDLIST *ppidlOut,
                                             USHORT usViewType = VIEWPIDL_ORDER_TODAY)
{
    HRESULT hr = E_FAIL;

    // painfully construct the final pidl by concatenating the little
    //   peices  [special_viewpidl, heipidl]
    if (_IsValid_HEIPIDL(pidlLast)) 
    {
        LPHEIPIDL    phei         = reinterpret_cast<LPHEIPIDL>(pidlLast);
        LPITEMIDLIST pidlViewTemp = NULL;
        hr = CreateSpecialViewPidl(usViewType, &pidlViewTemp);
        if (SUCCEEDED(hr) && pidlViewTemp) 
        {
            hr = SHILCombine(pidlViewTemp, reinterpret_cast<LPITEMIDLIST>(phei), ppidlOut);
            ILFree(pidlViewTemp);
        }
    }
    else
        hr = E_INVALIDARG;
    return hr;
}

// remember to ILFree pidl
HRESULT ConvertStandardHistPidlToSpecialViewPidl(LPCITEMIDLIST pidlStandardHist,
                                                 USHORT        usViewType,
                                                 LPITEMIDLIST *ppidlOut) {
    if (!pidlStandardHist || !ppidlOut) 
    {
        return E_FAIL;
    }
    HRESULT hr = E_FAIL;

    UINT          uPidlCount;
    LPITEMIDLIST *ppidlSplit = _SplitPidlEasy(pidlStandardHist, uPidlCount);
    /* Standard Hist Pidl should be in this form:
     *          [IDIPIDL, IDDPIDL, HEIPIDL]
     *  ex:     [Today,   foo.com, http://foo.com/bar.html]
     */
    if (ppidlSplit) 
    {
        if (uPidlCount >= 3) 
        {
            LPITEMIDLIST pidlTemp = NULL;
            switch(usViewType) 
            {
            case VIEWPIDL_ORDER_FREQ:
            case VIEWPIDL_ORDER_TODAY:
                hr = _ConvertStdPidlToViewPidl_OrderToday(ppidlSplit[uPidlCount - 1],
                                                            &pidlTemp, usViewType);
                break;
            case VIEWPIDL_ORDER_SITE:
                hr = _ConvertStdPidlToViewPidl_OrderSite(ppidlSplit[uPidlCount - 2],
                                                           ppidlSplit[uPidlCount - 1],
                                                           &pidlTemp);
                break;
            default:
                hr = E_INVALIDARG;
            }
            if (SUCCEEDED(hr) && pidlTemp) 
            {
                *ppidlOut = pidlTemp;
                hr      = (*ppidlOut ? S_OK : E_OUTOFMEMORY);
            }
        }
        else {
            hr = E_INVALIDARG;
        }

        LocalFree(ppidlSplit);
        ppidlSplit = NULL;
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

// START OF JCORDELL CODE

#ifdef DEBUG
BOOL ValidBeginningOfDay( const SYSTEMTIME *pTime )
{
    return pTime->wHour == 0 && pTime->wMinute == 0 && pTime->wSecond == 0 && pTime->wMilliseconds == 0;
}

BOOL ValidBeginningOfDay( const FILETIME *pTime )
{
    SYSTEMTIME sysTime;

    FileTimeToSystemTime( pTime, &sysTime );
    return ValidBeginningOfDay( &sysTime);
}
#endif

void _CommonTimeFormatProcessing(const FILETIME *pStartTime, const FILETIME *pEndTime,
                                    int *pdays_delta,
                                    int *pdays_delta_from_today,
                                    TCHAR *szStartDateBuffer,
                                    DWORD dwStartDateBuffer,
                                    SYSTEMTIME *pSysStartTime,
                                    SYSTEMTIME *pSysEndTime,
                                    LCID lcidUI)
{
    SYSTEMTIME sysStartTime, sysEndTime, sysLocalTime;
    FILETIME fileLocalTime;

    // ASSERTS
    ASSERT(ValidBeginningOfDay( pStartTime ));
    ASSERT(ValidBeginningOfDay( pEndTime ));

    // Get times in SYSTEMTIME format
    FileTimeToSystemTime( pStartTime, &sysStartTime );
    FileTimeToSystemTime( pEndTime, &sysEndTime );

    // Get string date of start time
    GetDateFormat(lcidUI, DATE_SHORTDATE, &sysStartTime, NULL, szStartDateBuffer, dwStartDateBuffer);

    // Get FILETIME of the first instant of today
    GetLocalTime( &sysLocalTime );
    sysLocalTime.wHour = sysLocalTime.wMinute = sysLocalTime.wSecond = sysLocalTime.wMilliseconds = 0;
    SystemTimeToFileTime( &sysLocalTime, &fileLocalTime );

    *pdays_delta = DAYS_DIFF(pEndTime, pStartTime);
    *pdays_delta_from_today = DAYS_DIFF(&fileLocalTime, pStartTime);
    *pSysEndTime = sysEndTime;
    *pSysStartTime = sysStartTime;
}

// this wrapper allows the FormatMessage wrapper to make use of FormatMessageLite, which
// does not require a code page for correct operation on Win9x.  The original FormatMessage calls
// used the FORMAT_MESSAGE_MAX_WIDTH_MASK (which is not relevant to our strings), and used an array
// of arguments.  Now we make the call compatible with FormatMessageLite.

DWORD FormatMessageLiteWrapperW(LPCWSTR lpSource, LPWSTR lpBuffer, DWORD nSize, ...)
{
    va_list arguments;
    va_start(arguments, nSize);
    DWORD dwRet = FormatMessage(FORMAT_MESSAGE_FROM_STRING, lpSource, 0, 0, lpBuffer, nSize, &arguments);
    va_end(arguments);
    return dwRet;
}

BOOL GetTooltipForTimeInterval( const FILETIME *pStartTime, const FILETIME *pEndTime,
                                    TCHAR *szBuffer, int cbBufferLength )
{
    SYSTEMTIME sysStartTime, sysEndTime;
    int days_delta;                     // number of days between start and end time
    int days_delta_from_today;          // number of days between today and start time
    TCHAR szStartDateBuffer[64];
    TCHAR szDayBuffer[64];
    TCHAR szEndDateBuffer[64];
    TCHAR *args[2];
    TCHAR szFmt[64];
    int idFormat;
    LANGID  lidUI;
    LCID    lcidUI;

    lidUI = MLGetUILanguage();
    lcidUI = MAKELCID(lidUI, SORT_DEFAULT);

    _CommonTimeFormatProcessing(pStartTime,
                                pEndTime,
                                &days_delta,
                                &days_delta_from_today,
                                szStartDateBuffer,
                                ARRAYSIZE(szStartDateBuffer),
                                &sysStartTime,
                                &sysEndTime,
                                lcidUI);
    if ( days_delta == 1 ) {
        args[0] = &szDayBuffer[0];
        idFormat = IDS_DAYTOOLTIP;

        // day sized bucket
        if ( days_delta_from_today == 0 ) {
            // today
            szDayBuffer[0] = 0;
            idFormat = IDS_TODAYTOOLTIP;
        }
        else if  ( days_delta_from_today > 0 && days_delta_from_today < 7 )
        {
            // within the last week, put day of week
            GetDateFormat(lcidUI, 0, &sysStartTime, TEXT("dddd"), szDayBuffer, ARRAYSIZE(szDayBuffer));
        }
        else {
            // just a plain day bucket
            StrCpyN( szDayBuffer, szStartDateBuffer, ARRAYSIZE(szDayBuffer) );
        }
    }
    else if ( days_delta == 7 && sysStartTime.wDayOfWeek == 1 ) {
        // week-size bucket starting on a Monday
        args[0] = &szStartDateBuffer[0];

        // make is point to the first string for safety sake. This will be ignored by wsprintf
        args[1] = args[0];
        idFormat = IDS_WEEKTOOLTIP;
    }
    else {
        // non-standard bucket (not exactly a week and not exactly a day)

        args[0] = &szStartDateBuffer[0];
        args[1] = &szEndDateBuffer[0];
        idFormat = IDS_MISCTOOLTIP;

        GetDateFormat(lcidUI, DATE_SHORTDATE, &sysEndTime, NULL, szEndDateBuffer, ARRAYSIZE(szEndDateBuffer) );
    }

    MLLoadString(idFormat, szFmt, ARRAYSIZE(szFmt));

    // NOTE, if the second parameter is not needed by the szFMt, then it will be ignored by wnsprintf
    if (idFormat == IDS_DAYTOOLTIP)
        wnsprintf(szBuffer, cbBufferLength, szFmt, args[0]);
    else
        FormatMessageLiteWrapperW(szFmt, szBuffer, cbBufferLength, args[0], args[1]);
    return TRUE;
}

BOOL GetDisplayNameForTimeInterval( const FILETIME *pStartTime, const FILETIME *pEndTime,
                                    LPTSTR szBuffer, int cbBufferLength)
{
    SYSTEMTIME sysStartTime, sysEndTime;
    int days_delta;                     // number of days between start and end time
    int days_delta_from_today;          // number of days between today and start time
    TCHAR szStartDateBuffer[64];
    LANGID lidUI;
    LCID lcidUI;

    lidUI = MLGetUILanguage();
    lcidUI = MAKELCID(lidUI, SORT_DEFAULT);

    _CommonTimeFormatProcessing(pStartTime,
                                pEndTime,
                                &days_delta,
                                &days_delta_from_today,
                                szStartDateBuffer,
                                ARRAYSIZE(szStartDateBuffer),
                                &sysStartTime,
                                &sysEndTime,
                                lcidUI);
    if ( days_delta == 1 ) {
        // day sized bucket
        if ( days_delta_from_today == 0 ) {
            // today
            MLLoadString(IDS_TODAY, szBuffer, cbBufferLength/sizeof(TCHAR));
        }
        else if  ( days_delta_from_today > 0 && days_delta_from_today < 7 )
        {
            // within the last week, put day of week
            int nResult = GetDateFormat(lcidUI, 0, &sysStartTime, TEXT("dddd"), szBuffer, cbBufferLength);


            ASSERT(nResult);
        }
        else {
            // just a plain day bucket
            StrCpyN( szBuffer, szStartDateBuffer, cbBufferLength );
        }
    }
    else if ( days_delta == 7 && sysStartTime.wDayOfWeek == 1 ) {
        // week-size bucket starting on a Monday
        TCHAR szFmt[64];

        int nWeeksAgo = days_delta_from_today / 7;

        if (nWeeksAgo == 1) {
            // print "Last Week"
            MLLoadString(IDS_LASTWEEK, szBuffer, cbBufferLength/sizeof(TCHAR));
        }
        else {
            // print "n Weeks Ago"
            MLLoadString(IDS_WEEKSAGO, szFmt, ARRAYSIZE(szFmt));
            wnsprintf(szBuffer, cbBufferLength, szFmt, nWeeksAgo);
        }
    }
    else {
        // non-standard bucket (not exactly a week and not exactly a day)
        TCHAR szFmt[64];
        TCHAR szEndDateBuffer[64];
        TCHAR *args[2];

        args[0] = &szStartDateBuffer[0];
        args[1] = &szEndDateBuffer[0];


        GetDateFormat(lcidUI, DATE_SHORTDATE, &sysEndTime, NULL, szEndDateBuffer, ARRAYSIZE(szEndDateBuffer) );

        MLLoadString(IDS_FROMTO, szFmt, ARRAYSIZE(szFmt));
        FormatMessageLiteWrapperW(szFmt, szBuffer, cbBufferLength, args[0], args[1]);
    }

    return TRUE;
}

//  END OF JCORDELL CODE

//  if !fOleMalloc, use LocalAlloc for speed  // ok to pass in NULL for lpStatURL
LPHEIPIDL _CreateHCacheFolderPidl(BOOL fOleMalloc, LPCTSTR pszUrl, FILETIME ftModified, LPSTATURL lpStatURL,
                                  __int64 llPriority/* = 0*/, DWORD dwNumHits/* = 0*/) // used in freqnecy view
{
    USHORT usUrlSize = (USHORT)((lstrlen(pszUrl) + 1) * sizeof(TCHAR));
    DWORD  dwSize = sizeof(HEIPIDL) + usUrlSize;
    USHORT usTitleSize = 0;
    BOOL fUseTitle = (lpStatURL && lpStatURL->pwcsTitle && _TitleIsGood(lpStatURL->pwcsTitle));
    if (fUseTitle)
        usTitleSize = (USHORT)((lstrlen(lpStatURL->pwcsTitle) + 1) * sizeof(WCHAR));

    dwSize += usTitleSize;

#if defined(UNIX)
    dwSize = ALIGN4(dwSize);
#endif

    LPHEIPIDL pheip = (LPHEIPIDL)_CreateBaseFolderPidl(fOleMalloc, dwSize, HEIPIDL_SIGN);

    if (pheip)
    {
        pheip->usUrl      = sizeof(HEIPIDL);
        pheip->usFlags    = lpStatURL ? HISTPIDL_VALIDINFO : 0;
        pheip->usTitle    = fUseTitle ? pheip->usUrl+usUrlSize :0;
        pheip->ftModified = ftModified;
        pheip->llPriority = llPriority;
        pheip->dwNumHits  = dwNumHits;
        if (lpStatURL)
        {
            pheip->ftLastVisited = lpStatURL->ftLastVisited;
#ifndef UNIX
            if (fUseTitle)
                StrCpyN((LPTSTR)(((BYTE*)pheip)+pheip->usTitle), lpStatURL->pwcsTitle, usTitleSize / sizeof(TCHAR));
#else
            // IEUNIX : BUG BUG _CreateBaseFolderPidl() uses lstrlenA
            // while creating the pidl.
            if (fUseTitle)
                StrCpyN((LPTSTR)(((BYTE*)pheip)+pheip->usTitle), lpStatURL->pwcsTitle, usTitleSize / sizeof(TCHAR));
#endif
        }
        else {
            //mm98: not so sure about the semantics on this one -- but this call
            //  with lpstaturl NULL (called from _NotifyWrite<--_WriteHistory<--WriteHistory<--CUrlHistory::_WriteToHistory
            //  makes for an uninitialised "Last Visited Member" which wreaks havoc
            //  when we want to order URLs by last visited
            pheip->ftLastVisited = ftModified;
        }
        StrCpyN((LPTSTR)(((BYTE*)pheip)+pheip->usUrl), pszUrl, usUrlSize / sizeof(TCHAR));
    }
    return pheip;
}

//  if !fOleMalloc, use LocalAlloc for speed
LPBASEPIDL _CreateIdCacheFolderPidl(BOOL fOleMalloc, USHORT usSign, LPCTSTR szId)
{
    DWORD  cch = lstrlen(szId) + 1;
    DWORD  dwSize = cch * sizeof(TCHAR);
    dwSize += sizeof(BASEPIDL);
    LPBASEPIDL pceip = _CreateBaseFolderPidl(fOleMalloc, dwSize, usSign);
    if (pceip)
    {
        // dst <- src
        // since pcei is ID type sign, _GetURLTitle points into correct place in pcei
        StrCpyN((LPTSTR)_GetURLTitle(pceip), szId, cch);
    }
    return pceip;
}

//  if !fOleAlloc, use LocalAlloc for speed
LPBASEPIDL _CreateBaseFolderPidl(BOOL fOleAlloc, DWORD dwSize, USHORT usSign)
{
    LPBASEPIDL pcei;
    DWORD dwTotalSize;

    //  Note: the buffer size returned by wininet includes INTERNET_CACHE_ENTRY_INFO
    dwTotalSize = sizeof(BASEPIDL) + dwSize;

#if defined(UNIX)
    dwTotalSize = ALIGN4(dwTotalSize);
#endif

    if (fOleAlloc)
    {
        pcei = (LPBASEPIDL)OleAlloc(dwTotalSize);
        if (pcei != NULL)
        {
            memset(pcei, 0, dwTotalSize);
        }
    }
    else
    {
        pcei = (LPBASEPIDL) LocalAlloc(GPTR, dwTotalSize);
        //  LocalAlloc zero inits
    }
    if (pcei)
    {
        pcei->cb = (USHORT)(dwTotalSize - sizeof(USHORT));
        pcei->usSign = usSign;
    }
    return pcei;
}

// returns a pidl (viewpidl)
//  You must free the pidl with ILFree

// cbExtra   -  count of how much to allocate at the end of the pidl
// ppbExtra  -  pointer to buffer at end of pidl that is cbExtra big
HRESULT CreateSpecialViewPidl(USHORT usViewType, LPITEMIDLIST* ppidlOut, UINT cbExtra /* = 0*/, LPBYTE *ppbExtra /* = NULL*/)
{
    HRESULT hr;

    if (ppidlOut) {
        *ppidlOut = NULL;

        ASSERT((usViewType > 0) &&
               ((usViewType <= VIEWPIDL_ORDER_MAX) ||
                (usViewType  == VIEWPIDL_SEARCH)));

        //   Tack another ITEMIDLIST on the end to be the empty "null terminating" pidl
        USHORT cbSize = sizeof(VIEWPIDL) + cbExtra + sizeof(ITEMIDLIST);
        // use the shell's allocator because folks will want to free it with ILFree
        VIEWPIDL *viewpidl = ((VIEWPIDL *)SHAlloc(cbSize));
        if (viewpidl) {
            // this should also make the "next" pidl empty
            memset(viewpidl, 0, cbSize);
            viewpidl->cb         = (USHORT)(sizeof(VIEWPIDL) + cbExtra);
            viewpidl->usSign     = VIEWPIDL_SIGN;
            viewpidl->usViewType = usViewType;
            viewpidl->usExtra    = 0;  // currently unused

            if (ppbExtra)
                *ppbExtra = ((LPBYTE)viewpidl) + sizeof(VIEWPIDL);

            *ppidlOut = (LPITEMIDLIST)viewpidl;
            hr = S_OK;
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else
        hr = E_INVALIDARG;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\hist\hsfutils.c ===
#include "local.h"

#include "resource.h"

#include <mluisupp.h>

#ifdef _HSFOLDER
#define LODWORD(_qw)    (DWORD)(_qw)

// Invoke Command verb strings
const CHAR c_szOpen[]       = "open";
const CHAR c_szDelcache[]   = "delete";
const CHAR c_szProperties[] = "properties";
const CHAR c_szCopy[]       = "copy";


void FileTimeToDateTimeStringInternal(FILETIME UNALIGNED *ulpft, LPTSTR pszText, int cchText, BOOL fUsePerceivedTime)
{
    FILETIME ft;
    FILETIME aft;
    LPFILETIME lpft;

    aft = *ulpft;
    lpft = &aft;

    if (!fUsePerceivedTime && (FILETIMEtoInt64(*lpft) != FT_NTFS_UNKNOWNGMT))
        FileTimeToLocalFileTime(lpft, &ft);
    else
        ft = *lpft;

    if (FILETIMEtoInt64(ft) == FT_NTFS_UNKNOWNGMT ||
        FILETIMEtoInt64(ft) == FT_FAT_UNKNOWNLOCAL)
    {
        static TCHAR szNone[40] = {0};
        if (szNone[0] == 0)
            MLLoadString(IDS_HSFNONE, szNone, ARRAYSIZE(szNone));

        StrCpyN(pszText, szNone, cchText);
    }
    else
    {
        TCHAR szTempStr[MAX_PATH];
        LPTSTR pszTempStr = szTempStr;
        SYSTEMTIME st;
    
        FileTimeToSystemTime(&ft, &st);

        if (GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &st, NULL, szTempStr, ARRAYSIZE(szTempStr)) > 0)
        {
            int iLen = lstrlen(szTempStr);
            ASSERT(TEXT('\0') == szTempStr[iLen]);  // Make sure multi-byte isn't biting us.
            pszTempStr = (LPTSTR)(pszTempStr + iLen);
            *pszTempStr++ = ' ';
            GetTimeFormat(LOCALE_USER_DEFAULT, TIME_NOSECONDS, &st, NULL, pszTempStr, ARRAYSIZE(szTempStr)-(iLen+1));
            StrCpyN(pszText, szTempStr, cchText);
        }
    }
}


HMENU LoadPopupMenu(UINT id, UINT uSubOffset)
{
    HMENU hmParent, hmPopup;

    HINSTANCE hinst = MLLoadShellLangResources();
    hmParent = LoadMenu_PrivateNoMungeW(hinst, MAKEINTRESOURCEW(id));
    if (!hmParent)
    {
        long error = GetLastError();
        return NULL;
    }

    hmPopup = GetSubMenu(hmParent, uSubOffset);
    RemoveMenu(hmParent, uSubOffset, MF_BYPOSITION);
    DestroyMenu(hmParent);

    MLFreeLibrary(hinst);

    return hmPopup;
}

UINT MergePopupMenu(HMENU *phMenu, UINT idResource, UINT uSubOffset, UINT indexMenu,  UINT idCmdFirst, UINT idCmdLast)
{
    HMENU hmMerge;

    if (*phMenu == NULL)
    {
        *phMenu = CreatePopupMenu();
        if (*phMenu == NULL)
            return 0;

        indexMenu = 0;    // at the bottom
    }

    hmMerge = LoadPopupMenu(idResource, uSubOffset);
    if (!hmMerge)
        return 0;

    idCmdLast = Shell_MergeMenus(*phMenu, hmMerge, indexMenu, idCmdFirst, idCmdLast, MM_ADDSEPARATOR);
    
    DestroyMenu(hmMerge);
    return idCmdLast;
}

///////////////////////////////////////////////////////////////////////////////
//
// Helper Fuctions for item.cpp and folder.cpp
//
///////////////////////////////////////////////////////////////////////////////

// copy and flatten the CACHE_ENTRY_INFO data

void _CopyCEI(UNALIGNED INTERNET_CACHE_ENTRY_INFO *pdst, LPINTERNET_CACHE_ENTRY_INFO psrc, DWORD dwBuffSize)
{
    // This assumes how urlcache does allocation
    memcpy(pdst, psrc, dwBuffSize);

    // convert pointers to offsets
    pdst->lpszSourceUrlName = (LPTSTR) PtrDifference(psrc->lpszSourceUrlName, psrc);
    pdst->lpszLocalFileName = (LPTSTR) PtrDifference(psrc->lpszLocalFileName, psrc);
    pdst->lpszFileExtension = (LPTSTR) PtrDifference(psrc->lpszFileExtension, psrc);
    pdst->lpHeaderInfo      = psrc->lpHeaderInfo ? (TCHAR*) PtrDifference(psrc->lpHeaderInfo, psrc) : NULL;
}

INT g_fProfilesEnabled = -1;

BOOL IsProfilesEnabled();

BOOL _FilterUserName(LPINTERNET_CACHE_ENTRY_INFO pcei, LPCTSTR pszCachePrefix, LPTSTR pszUserName)
{
    TCHAR szTemp[MAX_URL_STRING];
    LPCTSTR pszTemp = szTemp;
    
    // chrisfra 3/27/97, more constant crapola.  this all needs to be fixed.
    TCHAR szPrefix[80];
    BOOL fRet = 0;
    
    if (g_fProfilesEnabled==-1)
    {
        g_fProfilesEnabled = IsProfilesEnabled();
    }

    if (g_fProfilesEnabled)
    {
        return TRUE;
    }

    StrCpyN(szTemp, pcei->lpszSourceUrlName, ARRAYSIZE(szTemp));
    StrCpyN(szPrefix, pszCachePrefix, ARRAYSIZE(szPrefix));
    StrCatBuff(szPrefix, pszUserName, ARRAYSIZE(szPrefix));

    // find the '@' character if it exists
    pszTemp = StrChr(pszTemp, TEXT('@'));
    
    if ( (pszTemp) && (*pszTemp == TEXT('@')) )
    {
        fRet = (StrCmpNI(szTemp, szPrefix, lstrlen(szPrefix)) == 0);
    }
    else
    {
        fRet = (*pszUserName == TEXT('\0'));
    }

    return fRet;
}


BOOL _FilterPrefix(LPINTERNET_CACHE_ENTRY_INFO pcei, LPCTSTR pszCachePrefix)
{
#define MAX_PREFIX (80)
    TCHAR szTemp[MAX_URL_STRING];
    LPCTSTR pszStripped;
    BOOL fRet = 0;
    
    StrCpyN(szTemp, pcei->lpszSourceUrlName, ARRAYSIZE(szTemp));
    pszStripped = _StripContainerUrlUrl(szTemp);

    if (pszStripped && pszStripped-szTemp < MAX_PREFIX)
    {
        fRet = (StrCmpNI(szTemp, pszCachePrefix, ((int) (pszStripped-szTemp))/sizeof(TCHAR)) == 0);
    }
    return fRet;
}

LPCTSTR _StripContainerUrlUrl(LPCTSTR pszHistoryUrl)
{
    //  NOTE: for our purposes, we don't want a history URL if we can't detect our
    //  prefix, so we return NULL.

    LPCTSTR pszTemp = pszHistoryUrl;
    LPCTSTR pszCPrefix;
    LPCTSTR pszReturn = NULL;
    
    //  Check for "Visited: "
    pszCPrefix = c_szHistPrefix;
    while (*pszTemp == *pszCPrefix && *pszTemp != TEXT('\0'))
    {
         pszTemp = CharNext(pszTemp); 
         pszCPrefix = CharNext(pszCPrefix);
    }
        
    if (*pszCPrefix == TEXT('\0'))
    {
        //  Found "Visited: "
        pszReturn = pszTemp;
    }
    else if (pszTemp == (LPTSTR) pszHistoryUrl)
    {
        //  Check for ":YYYYMMDDYYYYMMDD: "
        pszCPrefix = TEXT(":nnnnnnnnnnnnnnnn: ");
        while (*pszTemp != TEXT('\0'))
        {
            if (*pszCPrefix == TEXT('n'))
            {
                if (*pszTemp < TEXT('0') || *pszTemp > TEXT('9')) break;
            }
            else if (*pszCPrefix != *pszTemp) break;
            pszTemp = CharNext(pszTemp); 
            pszCPrefix = CharNext(pszCPrefix);
        }
    }
    return (*pszCPrefix == TEXT('\0')) ? pszTemp : pszReturn;
}

LPCTSTR _StripHistoryUrlToUrl(LPCTSTR pszHistoryUrl)
{
    LPCTSTR pszTemp = pszHistoryUrl;

    if (!pszHistoryUrl)
        return NULL;

    pszTemp = StrChr(pszHistoryUrl, TEXT('@'));
    if (pszTemp && *pszTemp)
        return CharNext(pszTemp);
    
    pszTemp = StrChr(pszHistoryUrl, TEXT(' '));
    if (pszTemp && *pszTemp)
        return CharNext(pszTemp);
    else
        return NULL;    // error, the URL passed in wasn't a history url
}

// assumes this is a real URL and not a "history" url
void _GetURLHostFromUrl_NoStrip(LPCTSTR lpszUrl, LPTSTR szHost, DWORD dwHostSize, LPCTSTR pszLocalHost)
{
    DWORD cch = dwHostSize;
    if (S_OK != UrlGetPart(lpszUrl, szHost, &cch, URL_PART_HOSTNAME, 0) 
        || !*szHost)
    {
        //  default to the local host name.
        StrCpyN(szHost, pszLocalHost, dwHostSize);
    }
}

void _GetURLHost(LPINTERNET_CACHE_ENTRY_INFO pcei, LPTSTR szHost, DWORD dwHostSize, LPCTSTR pszLocalHost)
{  
    TCHAR szSourceUrl[MAX_URL_STRING];

    ASSERT(ARRAYSIZE(szSourceUrl) > lstrlen(pcei->lpszSourceUrlName))
    StrCpyN(szSourceUrl, pcei->lpszSourceUrlName, ARRAYSIZE(szSourceUrl));

    _GetURLHostFromUrl(szSourceUrl, szHost, dwHostSize, pszLocalHost);
}

LPHEIPIDL _IsValid_HEIPIDL(LPCITEMIDLIST pidl)
{
    LPHEIPIDL phei = (LPHEIPIDL)pidl;

    if (phei && ((phei->cb > sizeof(HEIPIDL)) && (phei->usSign == (USHORT)HEIPIDL_SIGN)) &&
        (phei->usUrl == 0 || phei->usUrl < phei->cb) &&
        (phei->usTitle == 0 || (phei->usTitle + sizeof(WCHAR)) <= phei->cb))
    {
        return phei;
    }
    return NULL;
}

LPBASEPIDL _IsValid_IDPIDL(LPCITEMIDLIST pidl)
{
    LPBASEPIDL pcei = (LPBASEPIDL)pidl;

    if (pcei && VALID_IDSIGN(pcei->usSign) && pcei->cb > 0)
    {
        return pcei;
    }
    return NULL;
}

LPCTSTR _FindURLFileName(LPCTSTR pszURL)
{
    LPCTSTR psz, pszRet = pszURL;   // need to set to pszURL in case no '/'
    LPCTSTR pszNextToLast = NULL;
    
    for (psz = pszURL; *psz; psz = CharNext(psz))
    {
        if ((*psz == TEXT('\\') || *psz == TEXT('/')))
        {
            pszNextToLast = pszRet;
            pszRet = CharNext(psz);
        }
    }
    return *pszRet ? pszRet : pszNextToLast;   
}

int _LaunchApp(HWND hwnd, LPCTSTR pszPath)
{
    SHELLEXECUTEINFO ei = { 0 };

    ei.cbSize           = sizeof(SHELLEXECUTEINFO);
    ei.hwnd             = hwnd;
    ei.lpFile           = pszPath;
    ei.nShow            = SW_SHOWNORMAL;

    return ShellExecuteEx(&ei);
}


int _LaunchAppForPidl(HWND hwnd, LPITEMIDLIST pidl)
{
    SHELLEXECUTEINFO ei = { 0 };

    ei.cbSize           = sizeof(SHELLEXECUTEINFO);
    ei.fMask            = SEE_MASK_IDLIST;
    ei.hwnd             = hwnd;
    ei.lpIDList         = pidl;
    ei.nShow            = SW_SHOWNORMAL;

    return ShellExecuteEx(&ei);
}

void _GenerateEvent(LONG lEventId, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlIn, LPCITEMIDLIST pidlNewIn)
{
    LPITEMIDLIST pidl;
    if (pidlIn)
    {
        pidl = ILCombine(pidlFolder, pidlIn);
    }
    else
    {   
        pidl = ILClone(pidlFolder);
    }
    if (pidl)
    {
        if (pidlNewIn)
        {
            LPITEMIDLIST pidlNew = ILCombine(pidlFolder, pidlNewIn);
            if (pidlNew)
            {
                SHChangeNotify(lEventId, SHCNF_IDLIST, pidl, pidlNew);
                ILFree(pidlNew);
            }
        }
        else
        {
            SHChangeNotify(lEventId, SHCNF_IDLIST, pidl, NULL);
        }
        ILFree(pidl);
    }
}

const struct {
    LPCSTR pszVerb;
    UINT idCmd;
} rgcmds[] = {
    { c_szOpen,         RSVIDM_OPEN },
    { c_szCopy,         RSVIDM_COPY },
    { c_szDelcache,     RSVIDM_DELCACHE },
    { c_szProperties,   RSVIDM_PROPERTIES }
};

int _GetCmdID(LPCSTR pszCmd)
{
    if (HIWORD(pszCmd))
    {
        int i;

        for (i = 0; i < ARRAYSIZE(rgcmds); i++)
        {
            if (StrCmpIA(rgcmds[i].pszVerb, pszCmd) == 0)
            {
                return rgcmds[i].idCmd;
            }
        }

        return -1;  // unknown
    }
    return (int)LOWORD(pszCmd);
}

HRESULT _CreatePropSheet(HWND hwnd, LPCITEMIDLIST pidl, int iDlg, DLGPROC pfnDlgProc, LPCTSTR pszTitle)
{
    PROPSHEETPAGE psp = { 0 };
    PROPSHEETHEADER psh = { 0 } ;

    // initialize propsheet page.
    psp.dwSize          = sizeof(PROPSHEETPAGE);
    psp.dwFlags         = 0;
    psp.hInstance       = MLGetHinst();
    psp.DUMMYUNION_MEMBER(pszTemplate)     = MAKEINTRESOURCE(iDlg);
    psp.DUMMYUNION2_MEMBER(pszIcon)        = NULL;
    psp.pfnDlgProc      = pfnDlgProc;
    psp.pszTitle        = NULL;
    psp.lParam          = (LPARAM)pidl; // send it the cache entry struct

    // initialize propsheet header.
    psh.dwSize      = sizeof(PROPSHEETHEADER);
    psh.dwFlags     = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW | PSH_PROPTITLE;
    psh.hwndParent  = hwnd;
    psh.pszCaption  = pszTitle;
    psh.nPages      = 1;
    psh.DUMMYUNION2_MEMBER(nStartPage)  = 0;
    psh.DUMMYUNION3_MEMBER(ppsp)        = (LPCPROPSHEETPAGE)&psp;

    // invoke the property sheet
    PropertySheet(&psh);
    
    return NOERROR;
}

INT_PTR CALLBACK HistoryConfirmDeleteDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch(message) {
        
    case WM_INITDIALOG:
        SetDlgItemText(hDlg, IDD_TEXT4, (LPCTSTR)lParam);
        break;            
        
    case WM_DESTROY:
        break;
        
    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDYES:
        case IDNO:
        case IDCANCEL:
            EndDialog(hDlg, wParam);
            break;
        }
        break;
        
        default:
            return FALSE;
    }
    return TRUE;
}

// This function restores the Unicode characters from file system URLs
//
// If the URL isn't a file URL, it is copied directly to pszBuf.  Otherwise, any 
// UTF8-escaped parts of the URL are converted into Unicode, and the result is 
// stored in pszBuf.  This should be the same as the string we received in 
// History in the first place
//
// The return value is always pszBuf.  
// The input and output buffers may be the same.


LPCTSTR ConditionallyDecodeUTF8(LPCTSTR pszUrl, LPTSTR pszBuf, DWORD cchBuf)
{
    BOOL fDecoded  = FALSE;

    if (PathIsFilePath(pszUrl))
    {
        TCHAR szDisplayUrl[MAX_URL_STRING];
        DWORD cchDisplayUrl = ARRAYSIZE(szDisplayUrl);
        DWORD cchBuf2 = cchBuf; // we may need the old cchBuf later

        // After PrepareUrlForDisplayUTF8, we have a fully unescaped URL.  If we 
        // ShellExec this, then Shell will unescape it again, so we need to re-escape
        // it to preserve any real %dd sequences that might be in the string. 

        if (SUCCEEDED(PrepareURLForDisplayUTF8(pszUrl, szDisplayUrl, &cchDisplayUrl, TRUE)) &&
            SUCCEEDED(UrlCanonicalize(szDisplayUrl, pszBuf, &cchBuf2, URL_ESCAPE_UNSAFE | URL_ESCAPE_PERCENT)))
        {
            fDecoded = TRUE;
        }
    }

    if (!fDecoded && (pszUrl != pszBuf))
    {
        StrCpyN(pszBuf, pszUrl, cchBuf);
    }

    return pszBuf;
}

//
// These routines make a string into a legal filename by replacing
// all invalid characters with spaces.
//
// The list of invalid characters was obtained from the NT error
// message you get when you try to rename a file to an invalid name.
//

#ifndef UNICODE
#error The MakeLegalFilename code only works when it's part of a UNICODE build
#endif

//
// This function takes a string and makes it into a
// valid filename (by calling PathCleanupSpec).
//
// The PathCleanupSpec function wants to know what
// directory the file will live in.  But it's going
// on the clipboard, so we don't know.  We just
// guess the desktop.
//
// It only uses this path to decide if the filesystem
// supports long filenames or not, and to check for
// MAX_PATH overflow.
//
void MakeLegalFilenameW(LPWSTR pszFilename)
{
    WCHAR szDesktopPath[MAX_PATH];

    GetWindowsDirectoryW(szDesktopPath,MAX_PATH);
    PathCleanupSpec(szDesktopPath,pszFilename);

}

//
// ANSI wrapper for above function
//
void MakeLegalFilenameA(LPSTR pszFilename)
{
    WCHAR szFilenameW[MAX_PATH];

    SHAnsiToUnicode(pszFilename, szFilenameW, MAX_PATH);

    MakeLegalFilenameW(szFilenameW);

    SHUnicodeToAnsi(szFilenameW, pszFilename, MAX_PATH);

}

#endif  // _HSFOLDER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\hist\local.h ===
//
// Local private header file

#ifndef _LOCAL_H_
#define _LOCAL_H_

#include "priv.h"

#define CONST_VTABLE

// Max urlcache entry we will deal with.

//#define MAX_URLCACHE_ENTRY  4096
#define MAX_URLCACHE_ENTRY  MAX_CACHE_ENTRY_INFO_SIZE  // from wininet.h

// PIDL format for cache folder...
typedef struct
{
    USHORT cb;
    USHORT usSign;
} BASEPIDL;
typedef UNALIGNED BASEPIDL *LPBASEPIDL;

// If TITLE, etc in LPHEIPIDL is good, vs we have to QueryUrl for it
#define HISTPIDL_VALIDINFO    (0x1)

// PIDL format for history leaf folder...
typedef struct
{
    USHORT cb;
    USHORT usSign;
    USHORT usUrl;
    USHORT usFlags;
    USHORT usTitle;
    FILETIME ftModified;
    FILETIME ftLastVisited;
    DWORD    dwNumHits;
    __int64  llPriority;
} HEIPIDL;
typedef UNALIGNED HEIPIDL *LPHEIPIDL;

// PIDL format for history non leaf items...
typedef struct
{
    USHORT cb;
    USHORT usSign;
    TCHAR szID[MAX_PATH];
} HIDPIDL;
typedef UNALIGNED HIDPIDL *LPHIDPIDL;

// PIDL format for "views"
typedef struct
{
    USHORT cb;
    USHORT usSign;
    USHORT usViewType;
    USHORT usExtra; // reserved for later use.
} VIEWPIDL;
typedef UNALIGNED VIEWPIDL *LPVIEWPIDL;

typedef struct /* : VIEWPIDL*/
{
    // histpidl
    USHORT   cb;
    USHORT   usSign; /* must be == VIEWPIDL_SEARCH */
    // viewpidl
    USHORT   usViewType;
    USHORT   usExtra;
    // viewpidl_search
    FILETIME ftSearchKey;
} SEARCHVIEWPIDL;
typedef UNALIGNED SEARCHVIEWPIDL *LPSEARCHVIEWPIDL;

// VIEWPIDL types
#define VIEWPIDL_ORDER_SITE   1//0x2
#define VIEWPIDL_ORDER_FREQ   2//0x3
#define VIEWPIDL_ORDER_TODAY  3//0x1
#define VIEWPIDL_ORDER_MAX    3 // highest VIEWPIDL

// Search View > VIEWPIDL_ORDER_MAX because its
//   not enumerated with the rest of the views
//   (esentially its not a "view" to the caller,
//    but this is how its implemented under the hood)
#define VIEWPIDL_SEARCH 0x4C44

// FILETIME secticks
#define FILE_SEC_TICKS (10000000)
// SECS PER DAY
#define DAY_SECS (24*60*60)

// Due hack used in shdocvw for recognizing LOCATION pidl, make sure neither byte
// has 4's and 1's bit set (ie 0x50 & value == 0 for both bytes)
#define CEIPIDL_SIGN        0x6360  //cP
#define IDIPIDL_SIGN         0x6369  //ci interval id
#define IDTPIDL_SIGN         0x6364  //cd interval id (TODAY)
#define IDDPIDL_SIGN         0x6365  //ce domain id
#define HEIPIDL_SIGN         0x6368  //ch history leaf pidl
#define VIEWPIDL_SIGN        0x6366  /*mm: this is a "history view" pidl to allow
                                           multiple 'views' on the history        */
#define FSWPIDL_SIGN         0x6367

#define VALID_IDSIGN(usSign) ((usSign) == IDIPIDL_SIGN || (usSign) == IDTPIDL_SIGN || (usSign) == IDDPIDL_SIGN)
#define EQUIV_IDSIGN(usSign1,usSign2) ((usSign1)==(usSign2)|| \
((usSign1)==IDIPIDL_SIGN && (usSign2)==IDTPIDL_SIGN)|| \
((usSign2)==IDIPIDL_SIGN && (usSign1)==IDTPIDL_SIGN))

#define IS_VALID_VIEWPIDL(pidl)     ( (((LPBASEPIDL)pidl)->cb >= sizeof(VIEWPIDL)) && \
                                      (((LPBASEPIDL)pidl)->usSign == (USHORT)VIEWPIDL_SIGN) )
#define IS_EQUAL_VIEWPIDL(pidl1,pidl2)  ((IS_VALID_VIEWPIDL(pidl1)) && (IS_VALID_VIEWPIDL(pidl2)) && \
                                         (((LPVIEWPIDL)pidl1)->usViewType == ((LPVIEWPIDL)pidl2)->usViewType) && \
                                         (((LPVIEWPIDL)pidl1)->usExtra    == ((LPVIEWPIDL)pidl2)->usExtra))
    
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))


#define _ILSkip(pidl, cb)       ((LPITEMIDLIST)(((BYTE*)(pidl))+cb))
#define _ILNext(pidl)           _ILSkip(pidl, (pidl)->mkid.cb)

#ifdef __cplusplus
extern "C" {
#endif

    //  Abandon mutex after 2 minutes of waiting
#define FAILSAFE_TIMEOUT (120000)

extern HANDLE g_hMutexHistory;
extern const CHAR c_szOpen[];
extern const CHAR c_szDelcache[];
extern const CHAR c_szProperties[];
extern const CHAR c_szCopy[];
extern const TCHAR c_szHistPrefix[];



#ifdef __cplusplus
};
#endif

    
typedef enum
{
    FOLDER_TYPE_Hist = 1,
    FOLDER_TYPE_HistInterval,
    FOLDER_TYPE_HistDomain,
    FOLDER_TYPE_HistItem
} FOLDER_TYPE;

#define IsLeaf(x) (x == FOLDER_TYPE_HistDomain)
#define IsHistoryFolder(x) (x==FOLDER_TYPE_Hist||x==FOLDER_TYPE_HistInterval||x==FOLDER_TYPE_HistDomain)

//IE64 compatible pointer difference
#define PtrDifference(x,y)      ((LPBYTE)(x)-(LPBYTE)(y))

//BOOL DeleteUrlCacheEntry(LPCSTR lpszUrlName);

#include "hsfutils.h"  // NOTE: must come at end to get all the definitions

#endif // _LOCAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\hist\hsfutils.h ===
#ifndef HSFUTILS_H__
#define HSFUTILS_H__

#ifdef __cplusplus
extern "C" {
#endif

UINT    MergePopupMenu(HMENU *phMenu, UINT idResource, UINT uSubOffset, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast);

void    _StringFromStatus(LPTSTR lpszBuff, unsigned cbSize, unsigned uStatus, DWORD dwAttributes);

void    _CopyCEI(UNALIGNED INTERNET_CACHE_ENTRY_INFO * pdst, LPINTERNET_CACHE_ENTRY_INFO psrc, DWORD dwBuffSize);

LPCTSTR _StripContainerUrlUrl(LPCTSTR pszHistoryUrl);
LPCTSTR _StripHistoryUrlToUrl(LPCTSTR pszHistoryUrl);
LPCTSTR _FindURLFileName(LPCTSTR pszURL);
LPBASEPIDL _IsValid_IDPIDL(LPCITEMIDLIST pidl);
LPHEIPIDL _IsValid_HEIPIDL(LPCITEMIDLIST pidl);
LPCTSTR _GetUrlForPidl(LPCITEMIDLIST pidl);
LPCTSTR _FindURLFileName(LPCTSTR pszURL);

void _GetURLHostFromUrl_NoStrip(LPCTSTR lpszUrl, LPTSTR szHost, DWORD dwHostSize, LPCTSTR pszLocalHost);
void _GetURLHost(LPINTERNET_CACHE_ENTRY_INFO pcei, LPTSTR szHost, DWORD dwHostSize, LPCTSTR pszLocalHost);
#define _GetURLHostFromUrl(lpszUrl, szHost, dwHostSize, pszLocalHost) \
        _GetURLHostFromUrl_NoStrip(_StripHistoryUrlToUrl(lpszUrl), szHost, dwHostSize, pszLocalHost)

// Forward declarations IContextMenu of helper functions
void    _GenerateEvent(LONG lEventId, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlNew);
int     _LaunchApp(HWND hwnd, LPCTSTR lpszPath);
int     _LaunchAppForPidl(HWND hwnd, LPITEMIDLIST pidl);
int     _GetCmdID(LPCSTR pszCmd);
HRESULT _CreatePropSheet(HWND hwnd, LPCITEMIDLIST pidl, int iDlg, DLGPROC pfnDlgProc, LPCTSTR pszTitle);

// Forward declarations of IDataObject helper functions
LPCTSTR _FindURLFileName(LPCTSTR pszURL);
BOOL    _FilterUserName(LPINTERNET_CACHE_ENTRY_INFO pcei, LPCTSTR pszCachePrefix, LPTSTR pszUserName);
BOOL    _FilterPrefix(LPINTERNET_CACHE_ENTRY_INFO pcei, LPCTSTR pszCachePrefix);

LPCTSTR ConditionallyDecodeUTF8(LPCTSTR pszUrl, LPTSTR pszBuf, DWORD cchBuf);

INT_PTR CALLBACK HistoryConfirmDeleteDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

void    FileTimeToDateTimeStringInternal(UNALIGNED FILETIME * lpft, LPTSTR pszText, int cchText, BOOL fUsePerceivedTime);

void MakeLegalFilenameA(LPSTR pszFilename);
void MakeLegalFilenameW(LPWSTR pszFilename);

#ifdef __cplusplus
};
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\util\local.h ===
//
// Local private header file

#include "priv.h"
#include "util.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\actdesk.h ===
/*
 * actdesk.h - active desktop prop sheet extension
 */

#ifndef _ACTDESK_H_
#define _ACTDESK_H_

#ifdef __cplusplus


#define REGSTR_ACTIVEDESKTOP   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ActiveDesktop")
#define REGVAL_NOTICKERDISPLAY TEXT("NoTickerDisplay")
#define REGVAL_TICKERINTERVAL  TEXT("TickerInterval")
#define REGVAL_TICKERSPEED     TEXT("TickerSpeed")
#define REGVAL_NONEWSDISPLAY   TEXT("NoNewsDisplay")
#define REGVAL_NEWSINTERVAL    TEXT("NewsInterval")
#define REGVAL_NEWSUPDATE      TEXT("NewsUpdate")
#define REGVAL_NEWSSPEED       TEXT("NewsSpeed")

#define MAX_NEWS_INTERVAL     120
#define MAX_TICKER_INTERVAL   120
#define MAX_NEWS_UPDATE       120

typedef struct _ActiveDesktopInfo
{
    BOOL fTicker;
    int  iTickerInterval;       // 30sec, e.g.
    int  iTickerSpeed;          // Stop -- Fast

    BOOL fNews;
    int  iNewsInterval;         // 30sec, e.g.
    int  iNewsUpdate;           // 30min, e.
    int  iNewsSpeed;            // Stop -- Fast
} ACTIVEDESKTOPINFO, *LPACTIVEDESKTOPINFO;

BOOL_PTR CALLBACK CActDesktopExt_DlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);


class CActDesktopExt : IShellPropSheetExt
{    
public:

    CActDesktopExt();
   ~CActDesktopExt();
   
    // IUnknon methods...
    STDMETHODIMP            QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG)    AddRef(void);
    STDMETHODIMP_(ULONG)    Release(void);

    // IShellPropSheetExt methods...
    STDMETHODIMP AddPages(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);
    STDMETHODIMP ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE pfnReplaceWith, LPARAM lParam);

protected:
    HRESULT _CreateActiveDesktopPage(HPROPSHEETPAGE* phpsp, LPVOID pvReserved);    
    UINT _cRef;    
};


#endif  // __cplusplus


//
// Prototypes for all modules
//
#ifdef __cplusplus
extern "C" {
#endif
    
STDAPI CActDesktopExt_CreateInstance(LPUNKNOWN punkOuter, REFIID riid,  OUT void **ppvOut);

#ifdef __cplusplus
};
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\util\menu.cpp ===
//
//  Menu- and menuband- related utility functions
//

#include "local.h"
#include "dochost.h"

// this goes away when the split is done **and** dochost goes away


/*----------------------------------------------------------
Purpose: Replace the contents of hmenuDst with hmenuSrc.  Note any
         submenus in hmenuDst will be deleted.  

         Call Menu_RemoveAllSubMenus if you don't want this to 
         happen.
*/
void Menu_Replace(HMENU hmenuDst, HMENU hmenuSrc)
{
    int cItems = GetMenuItemCount(hmenuDst);
    int i;

    for (i=0; i<cItems; i++)
        DeleteMenu(hmenuDst, 0, MF_BYPOSITION);

    cItems = GetMenuItemCount(hmenuSrc);
    for (i=0; i<cItems; i++)
    {
        MENUITEMINFO mii;
        TCHAR szText[MAX_PATH];
        mii.cbSize = SIZEOF(MENUITEMINFO);
        mii.dwTypeData = szText;
        mii.fMask = MIIM_TYPE | MIIM_ID | MIIM_SUBMENU | MIIM_DATA | MIIM_STATE;
        mii.cch = ARRAYSIZE(szText);
        mii.fType = MFT_SEPARATOR;
        mii.hSubMenu = NULL;
        mii.dwItemData = 0;
        if (GetMenuItemInfo(hmenuSrc, i, TRUE, &mii))
        {
            HMENU hMenuOldSub = NULL;
            if (mii.hSubMenu != NULL)
            {
                hMenuOldSub = mii.hSubMenu;
                mii.hSubMenu = CreateMenu();
                Menu_Replace(mii.hSubMenu, hMenuOldSub);
            }
            InsertMenuItem(hmenuDst, i, TRUE, &mii);
        }
    }
}


#ifndef POSTPOSTSPLIT
//----------------------------------------------------------------------
//
// CMenuList
//
//----------------------------------------------------------------------


typedef struct
{
    HMENU   hmenu;
    BITBOOL bObject:1;              // TRUE: menu belongs to object
} MLITEM;       // CMenuList item


CMenuList::CMenuList(void)
{
    ASSERT(NULL == _hdsa);
}


CMenuList::~CMenuList(void)
{
    if (_hdsa)
    {
        DSA_Destroy(_hdsa);
        _hdsa = NULL;
    }
}    


/*----------------------------------------------------------
Purpose: Set the menu list (comparable to HOLEMENU) so we can
         dispatch commands to the frame or the object correctly.
         We do this since menu bands bypass OLE's FrameFilterWndProc.

         We build the menu list by comparing the given hmenuShared
         with hmenuFrame.  Anything in hmenuShared that is not
         in hmenuFrame belongs to the object.

*/
void CMenuList::Set(HMENU hmenuShared, HMENU hmenuFrame)
{
    ASSERT(NULL == hmenuShared || IS_VALID_HANDLE(hmenuShared, MENU));
    ASSERT(NULL == hmenuFrame || IS_VALID_HANDLE(hmenuFrame, MENU));

    if (_hdsa)
    {
        ASSERT(IS_VALID_HANDLE(_hdsa, DSA));

        DSA_DeleteAllItems(_hdsa);
    }
    else
        _hdsa = DSA_Create(sizeof(MLITEM), 10);

    if (_hdsa && hmenuShared && hmenuFrame)
    {
        int i;
        int iFrame = 0;
        int cmenu = GetMenuItemCount(hmenuShared);
        int cmenuFrame = GetMenuItemCount(hmenuFrame);
        BOOL bMatched;
        int iSaveFrame;
        int iHaveFrame = -1;

        TCHAR sz[64];
        TCHAR szFrame[64];
        MENUITEMINFO miiFrame;
        MENUITEMINFO mii;
        MLITEM mlitem;

        miiFrame.cbSize = sizeof(miiFrame);
        mii.cbSize = sizeof(mii);

        for (i = 0; i < cmenu; i++)
        {

            mii.cch = SIZECHARS(sz);
            mii.fMask  = MIIM_SUBMENU | MIIM_TYPE;
            mii.dwTypeData = sz;
            EVAL(GetMenuItemInfo(hmenuShared, i, TRUE, &mii));

            ASSERT(IS_VALID_HANDLE(mii.hSubMenu, MENU));
            
            mlitem.hmenu = mii.hSubMenu;

            iSaveFrame = iFrame;
            bMatched = FALSE;

            //  DocObject might have dropped some of our menus, like edit and view
            //  Need to be able to skip over dropped frame menus
            while (1)
            {
                if (iHaveFrame != iFrame)
                {
                    iHaveFrame = iFrame;
                    if (iFrame < cmenuFrame)
                    {
                        miiFrame.cch = SIZECHARS(szFrame);
                        miiFrame.fMask  = MIIM_SUBMENU | MIIM_TYPE;
                        miiFrame.dwTypeData = szFrame;
                        EVAL(GetMenuItemInfo(hmenuFrame, iFrame, TRUE, &miiFrame));
                    }
                    else
                    {
                        // Make it so it won't compare
                        miiFrame.hSubMenu = NULL;
                        *szFrame = 0;
                    }

                }
                ASSERT(iFrame >= cmenuFrame || IS_VALID_HANDLE(miiFrame.hSubMenu, MENU));
                
                // The browser may have a menu that was not merged into
                // the shared menu because the object put one in with 
                // the same name.  Have we hit this case? Check by comparing
                // sz and szFrame

                if (mii.hSubMenu == miiFrame.hSubMenu || 0 == StrCmp(sz, szFrame))
                {
                    bMatched = TRUE;
                    break;
                }
                else
                {
                    if (iFrame >= cmenuFrame) 
                    {
                        break;
                    }
                    iFrame++;
                }
            }

            // Is this one of our menus?
            mlitem.bObject = (mii.hSubMenu == miiFrame.hSubMenu) ? FALSE:TRUE;
            if (bMatched)
            {
                iFrame++;
            }
            else
            {
                iFrame = iSaveFrame;
            }
            DSA_SetItem(_hdsa, i, &mlitem);
        }
    }
}   


/*----------------------------------------------------------
Purpose: Adds the given hmenu to the list.

*/
void CMenuList::AddMenu(HMENU hmenu)
{
    ASSERT(NULL == hmenu || IS_VALID_HANDLE(hmenu, MENU));

    if (_hdsa && hmenu)
    {
        MLITEM mlitem;

        mlitem.hmenu = hmenu;
        mlitem.bObject = TRUE;
        
        DSA_AppendItem(_hdsa, &mlitem);
    }
}     


/*----------------------------------------------------------
Purpose: Removes the given hmenu from the list.

*/
void CMenuList::RemoveMenu(HMENU hmenu)
{
    ASSERT(NULL == hmenu || IS_VALID_HANDLE(hmenu, MENU));

    if (_hdsa && hmenu)
    {
        int i = DSA_GetItemCount(_hdsa) - 1;

        for (; i >= 0; i--)
        {
            MLITEM * pmlitem = (MLITEM *)DSA_GetItemPtr(_hdsa, i);
            ASSERT(pmlitem);

            if (hmenu == pmlitem->hmenu)
            {
                DSA_DeleteItem(_hdsa, i);
                break;
            }
        }
    }
}     


/*----------------------------------------------------------
Purpose: Returns TRUE if the given hmenu belongs to the object.

*/
BOOL CMenuList::IsObjectMenu(HMENU hmenu)
{
    BOOL bRet = FALSE;

    ASSERT(NULL == hmenu || IS_VALID_HANDLE(hmenu, MENU));

    if (_hdsa && hmenu)
    {
        int i;

        for (i = 0; i < DSA_GetItemCount(_hdsa); i++)
        {
            MLITEM * pmlitem = (MLITEM *)DSA_GetItemPtr(_hdsa, i);
            ASSERT(pmlitem);

            if (hmenu == pmlitem->hmenu)
            {
                bRet = pmlitem->bObject;
                break;
            }
        }
    }
    return bRet;
}     


#ifdef DEBUG

void CMenuList::Dump(LPCTSTR pszMsg)
{
    if (IsFlagSet(g_dwDumpFlags, DF_DEBUGMENU))
    {
        TraceMsg(TF_ALWAYS, "CMenuList: Dumping menus for %#08x %s", (LPVOID)this, pszMsg);
        
        if (_hdsa)
        {
            int i;

            for (i = 0; i < DSA_GetItemCount(_hdsa); i++)
            {
                MLITEM * pmlitem = (MLITEM *)DSA_GetItemPtr(_hdsa, i);
                ASSERT(pmlitem);

                TraceMsg(TF_ALWAYS, "   [%d] = %x", i, pmlitem->hmenu);
            }
        }
    }
}

#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\apdlg.cpp ===
#include "shellprv.h"
#include "ids.h"

#include "apdlg.h"
#include "hwcmmn.h"

#include "mtpt.h"

static const DWORD s_rgdwHelpIDsArray[] =
{
    IDC_AP_TOPTEXT,               IDH_SELECT_CONTENT_TYPE,
    IDC_AP_LIST,                  IDH_SELECT_CONTENT_TYPE,
    IDC_AP_DEFAULTHANDLER,        IDH_SELECT_ACTION,
    IDC_AP_LIST_ACTIONS,          IDH_SELECT_ACTION,
    IDC_AP_PROMPTEACHTIME,        IDH_PROMPT_ME_EACH_TIME,
    IDC_AP_NOACTION,              IDH_TAKE_NO_ACTION,
    0, 0
};

static const DWORD g_rgdwContentTypes[] =
{
    CT_AUTOPLAYMUSIC   ,
    CT_AUTOPLAYPIX     ,
    CT_AUTOPLAYMOVIE   ,
    CT_AUTOPLAYMIXEDCONTENT ,
    CT_CDAUDIO         ,
    CT_DVDMOVIE        ,
    CT_BLANKCDR        , // could also have been: CT_BLANKCDRW
};

#define COL_ACTION      0
#define COL_PROVIDER    1

const UINT c_auTileColumns[] = {COL_ACTION, COL_PROVIDER};
const UINT c_auTileSubItems[] = {COL_PROVIDER};

HRESULT CAutoPlayDlg::_InitListViewActions()
{
    HWND hwndList = GetDlgItem(_hwnd, IDC_AP_LIST_ACTIONS);

    HRESULT hr = _uilListViewActions.Init(hwndList);

    if (SUCCEEDED(hr))
    {
        hr = _uilListViewActions.InitTileInfo(c_auTileSubItems, ARRAYSIZE(c_auTileSubItems));

        if (SUCCEEDED(hr))
        {
            RECT rc = {0};
            LVTILEVIEWINFO lvtvi = {0};
            HIMAGELIST himagelist;

            ListView_SetView(hwndList, LV_VIEW_TILE);

            for (int i = 0; i < ARRAYSIZE(c_auTileColumns); ++i)
            {
                LVCOLUMN lvcolumn = {0};

                lvcolumn.mask = LVCF_SUBITEM;
                lvcolumn.iSubItem = c_auTileColumns[i];
                ListView_InsertColumn(hwndList, i, &lvcolumn);
            }

            GetClientRect(hwndList, &rc);

            lvtvi.cbSize = sizeof(lvtvi);
            lvtvi.dwMask = LVTVIM_TILESIZE | LVTVIM_COLUMNS;
            lvtvi.dwFlags = LVTVIF_FIXEDWIDTH;
    
            // Leave room for the scroll bar when setting tile sizes or listview gets screwed up.
            lvtvi.sizeTile.cx = ((rc.right - rc.left) - GetSystemMetrics(SM_CXVSCROLL));
            lvtvi.cLines = ARRAYSIZE(c_auTileSubItems);
            ListView_SetTileViewInfo(hwndList, &lvtvi);

            Shell_GetImageLists(&himagelist, NULL);

            if (himagelist)
            {
                ListView_SetImageList(hwndList, himagelist, LVSIL_NORMAL);
                hr = S_OK;
            }
        }
    }

    return hr;
}

HRESULT CAutoPlayDlg::_FillListViewActions(CContentTypeData* pdata)
{
    HRESULT hr = _uilListViewActions.ResetContent();
    if (SUCCEEDED(hr))
    {
        int c = pdata->GetHandlerCount();
        if (c)
        {
            for (int i = 0; SUCCEEDED(hr) && (i < c); ++i)
            {
                CHandlerData* phandlerdata = pdata->GetHandlerData(i);

                if (phandlerdata)
                {
                    CHandlerLVItem* puidata = new CHandlerLVItem();

                    if (puidata)
                    {
                        hr = puidata->InitData(phandlerdata);

                        if (SUCCEEDED(hr))
                        {
                            hr = _uilListViewActions.AddItem(puidata);

                            if (FAILED(hr))
                            {
                                delete puidata;
                            }
                        }
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }

                    phandlerdata->Release();
                }
            }

            _fAtLeastOneAction = TRUE;
        }
        else
        {
            // disable the listview and its radio button
            _fAtLeastOneAction = FALSE;
        }
    }

    return hr;
}

HRESULT CAutoPlayDlg::_UpdateRestoreButton(BOOL fPromptEachTime)
{
    BOOL fEnable;

    if (fPromptEachTime)
    {
        fEnable = FALSE;
    }
    else
    {
        fEnable = TRUE;
    }

    EnableWindow(GetDlgItem(_hwnd, IDC_AP_RESTOREDEFAULTS), fEnable);

    return fEnable;
}

HRESULT CAutoPlayDlg::_UpdateLowerPane()
{
    CContentTypeData* pdata;
    HRESULT hr = _uilListView.GetSelectedItemData(&pdata);

    _fIgnoreListViewItemStateChanges = TRUE;

    if (SUCCEEDED(hr))
    {
        BOOL fPromptEachTime = !lstrcmpi(pdata->_pszHandlerDefault, TEXT("MSPromptEachTime"));

        if (!fPromptEachTime)
        {
            if (!(pdata->_dwHandlerDefaultFlags & HANDLERDEFAULT_USERCHOSENDEFAULT))
            {
                // There *NO* User Chosen Default
                fPromptEachTime = TRUE;
            }
            else
            {
                // There is a User Chosen Default
                if (pdata->_dwHandlerDefaultFlags &
                    HANDLERDEFAULT_MORERECENTHANDLERSINSTALLED)
                {
                    // But there's also more recent apps
                    fPromptEachTime = TRUE;
                }
            }
        }

        hr = _FillListViewActions(pdata);

        if (SUCCEEDED(hr))
        {
            hr = _SelectListViewActionsItem(pdata->_pszHandlerDefault);
        }

        if (SUCCEEDED(hr))
        {
            hr = _SelectRadioButton(fPromptEachTime);
        }

        if (SUCCEEDED(hr))
        {
            hr = _UpdateRestoreButton(fPromptEachTime);
        }

        pdata->Release();
    }

    _fIgnoreListViewItemStateChanges = FALSE;

    return hr;
}

HRESULT CAutoPlayDlg::_UpdateApplyButton()
{
    if (_dlmanager.IsDirty())
    {
        PropSheet_Changed(GetParent(_hwnd), _hwnd);
    }
    else
    {
        PropSheet_UnChanged(GetParent(_hwnd), _hwnd);
    }

    return S_OK;
}

HRESULT _SetHandlerDefault(LPWSTR* ppszHandlerDefault, LPCWSTR pszHandler)
{
    LPWSTR pszHandlerNew;
    HRESULT hr = SHStrDup(pszHandler, &pszHandlerNew);

    if (SUCCEEDED(hr))
    {
        if (*ppszHandlerDefault)
        {
            CoTaskMemFree(*ppszHandlerDefault);
        }

        *ppszHandlerDefault = pszHandlerNew;
    }

    return hr;
}

HRESULT CAutoPlayDlg::_SelectRadioButton(BOOL fPromptEachTime)
{
    CContentTypeData* pdata;
    HRESULT hr = _uilListView.GetSelectedItemData(&pdata);

    if (SUCCEEDED(hr))
    {
        int iCtrl;
        BOOL fEnableListView = FALSE;

        if (fPromptEachTime)
        {
            _SetHandlerDefault(&(pdata->_pszHandlerDefault), TEXT("MSPromptEachTime"));

            iCtrl = IDC_AP_PROMPTEACHTIME;
        }
        else
        {
            fEnableListView = TRUE;

            CHandlerData* phandlerdata;
            hr = _uilListViewActions.GetSelectedItemData(&phandlerdata);

            if (SUCCEEDED(hr))
            {
                _SetHandlerDefault(&(pdata->_pszHandlerDefault), phandlerdata->_pszHandler);

                phandlerdata->Release();
            }

            iCtrl = IDC_AP_DEFAULTHANDLER;
        }

        Button_SetCheck(GetDlgItem(_hwnd, IDC_AP_DEFAULTHANDLER), (IDC_AP_DEFAULTHANDLER == iCtrl));
        Button_SetCheck(GetDlgItem(_hwnd, IDC_AP_PROMPTEACHTIME), (IDC_AP_PROMPTEACHTIME == iCtrl));

        EnableWindow(GetDlgItem(_hwnd, IDC_AP_LIST_ACTIONS), fEnableListView);

        pdata->Release();

        hr = _UpdateApplyButton();
    }

    return hr;
}

HRESULT CAutoPlayDlg::_SelectListViewActionsItem(LPCWSTR pszHandlerDefault)
{
    HRESULT hr = S_FALSE;
    LVITEM lvitem = {0};
    int iItemToSelect = 0;
    HWND hwndList = GetDlgItem(_hwnd, IDC_AP_LIST_ACTIONS);

    if (pszHandlerDefault)
    {
        int c = ListView_GetItemCount(hwndList);

        if (c)
        {
            int i;

            for (i = 0; i < c; ++i)
            {
                lvitem.mask = LVIF_PARAM;
                lvitem.iItem = i;
        
                if (ListView_GetItem(hwndList, &lvitem))
                {
                    CHandlerLVItem* phandleruidata = (CHandlerLVItem*)lvitem.lParam;

                    if (phandleruidata)
                    {
                        CHandlerData* phandlerdata = phandleruidata->GetData();

                        if (phandlerdata)
                        {
                            if (!lstrcmp(phandlerdata->_pszHandler,
                                pszHandlerDefault))
                            {
                                break;                
                            }

                            phandlerdata->Release();
                        }
                    }
                }
            }

            if (i == c)
            {
                i = 0;
            }
            else
            {
                hr = S_OK;
            }

            iItemToSelect = i;
        }
    }
    else
    {
        // Select first one
        hr = S_OK;
    }

    lvitem.mask = LVIF_STATE;
    lvitem.iItem = iItemToSelect;
    lvitem.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
    lvitem.state = LVIS_SELECTED | LVIS_FOCUSED;

    ListView_SetItem(hwndList, &lvitem);
    ListView_EnsureVisible(hwndList, lvitem.iItem, FALSE);

    return hr;
}

void _SetCtrlTextFromResourceText(HWND hwndDlg, int iCtrl, int iResourceText)
{
    // We use 256, even if we would use a bigger buffer, the ctrl where we'll
    // put the text would probably not be able to take it anyway (would be
    // truncated).
    WCHAR sz[256];

    if (LoadString(HINST_THISDLL, iResourceText, sz, ARRAYSIZE(sz)))
    {
        SetDlgItemText(hwndDlg, iCtrl, sz);
    }
}

LRESULT CAutoPlayDlg::_OnApply()
{
    if (_dlmanager.IsDirty())
    {
        // Should we get the return value, and if so, why?
        _dlmanager.Commit();
    }

    return PSNRET_NOERROR;
}

// Listview Actions
HRESULT CAutoPlayDlg::_OnListViewActionsSelChange()
{
    CHandlerData* phandlerdata;
    HRESULT hr = _uilListViewActions.GetSelectedItemData(&phandlerdata);

    if (SUCCEEDED(hr))
    {
        CContentTypeData* pdata;
        hr = _uilListView.GetSelectedItemData(&pdata);

        if (SUCCEEDED(hr))
        {
            _SetHandlerDefault(&(pdata->_pszHandlerDefault), phandlerdata->_pszHandler);

            pdata->Release();
        }

        phandlerdata->Release();
    }

    if (SUCCEEDED(hr))
    {
        hr = _UpdateApplyButton();
    }

    return hr;
}

// Radio buttons
HRESULT CAutoPlayDlg::_OnRestoreDefault()
{
    CContentTypeData* pdata;
    HRESULT hr = _uilListView.GetSelectedItemData(&pdata);

    if (SUCCEEDED(hr))
    {
        _SetHandlerDefault(&(pdata->_pszHandlerDefault), TEXT("MSPromptEachTime"));

        _SelectRadioButton(TRUE);

        hr = _UpdateApplyButton();

        if (SUCCEEDED(hr))
        {
            _UpdateRestoreButton(TRUE);
        }

        pdata->Release();

        SetFocus(GetNextDlgTabItem(_hwnd, GetDlgItem(_hwnd, IDC_AP_RESTOREDEFAULTS), FALSE /*next ctrl*/));
    }
    
    return hr;
}

HRESULT CAutoPlayDlg::_OnRadio(int iButton)
{
    CContentTypeData* pdata;
    HRESULT hr = _uilListView.GetSelectedItemData(&pdata);

    if (SUCCEEDED(hr))
    {
        HWND hwndList = GetDlgItem(_hwnd, IDC_AP_LIST_ACTIONS);

        if (IDC_AP_DEFAULTHANDLER == iButton)
        {
            CHandlerData* phandlerdata;

            EnableWindow(hwndList, TRUE);

            hr = _uilListViewActions.GetSelectedItemData(&phandlerdata);

            if (SUCCEEDED(hr))
            {
                _SetHandlerDefault(&(pdata->_pszHandlerDefault), phandlerdata->_pszHandler);

                phandlerdata->Release();
            }
        }
        else
        {
            _SetHandlerDefault(&(pdata->_pszHandlerDefault), TEXT("MSPromptEachTime"));

            EnableWindow(hwndList, FALSE);
        }

        hr = _UpdateApplyButton();

        if (SUCCEEDED(hr))
        {
            _UpdateRestoreButton(!lstrcmpi(pdata->_pszHandlerDefault, TEXT("MSPromptEachTime")));
        }

        pdata->Release();
    }
    
    return hr;
}

LRESULT CAutoPlayDlg::OnInitDialog(WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = _InitDataObjects();

    _fIgnoreListViewItemStateChanges = TRUE;

    if (SUCCEEDED(hr))
    {
        hr = _InitListView();

        if (SUCCEEDED(hr))
        {
            hr = _FillListView();

            if (SUCCEEDED(hr))
            {
                hr = _InitListViewActions();

                if (SUCCEEDED(hr))
                {
                    hr = _uilListView.SelectFirstItem();

                    if (SUCCEEDED(hr))
                    {
                        hr = _UpdateLowerPane();
                    }
                }
            }
        }
    }

    _fIgnoreListViewItemStateChanges = FALSE;

    return TRUE;
}

LRESULT CAutoPlayDlg::OnNotify(WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = FALSE;
    
    LPNMHDR pNMHDR = (LPNMHDR)lParam;
    UINT_PTR idFrom = pNMHDR->idFrom;
    UINT uCode = pNMHDR->code;
    
    switch (uCode) 
    {
    case PSN_APPLY:
        lRes = _OnApply();
        
        CBaseDlg::OnNotify(wParam, lParam);
        break;
        
    default:
        switch (idFrom)
        {
        case IDC_AP_LIST_ACTIONS:
            
            if (!_fIgnoreListViewItemStateChanges)
            {
                NMLISTVIEW* pNMLV = (NMLISTVIEW*)pNMHDR;
                
                if (LVN_ITEMCHANGED == uCode)
                {
                    // Is a new item being selected?
                    if ((pNMLV->uChanged & LVIF_STATE) &&
                        pNMLV->uNewState & LVIS_SELECTED)
                    {
                        _OnListViewActionsSelChange();
                    }
                }
            }
            
            lRes = CBaseDlg::OnNotify(wParam, lParam);
            break;
            
        default:
            lRes = CBaseDlg::OnNotify(wParam, lParam);
            break;
        }
        break;
    }
    
    return lRes;    
}

LRESULT CAutoPlayDlg::OnCommand(WPARAM wParam, LPARAM lParam)
{
    int iCtl = LOWORD(wParam);
    int iNot = HIWORD(wParam);
    
    switch (iCtl)
    {
    case IDC_AP_DEFAULTHANDLER:
    case IDC_AP_PROMPTEACHTIME:
        if (BN_CLICKED == iNot)
        {
            _OnRadio(iCtl);
        }
        break;
        
    case IDC_AP_LIST:
        if (HIWORD(wParam) == CBN_SELCHANGE)
        {
            _UpdateLowerPane();
        }
        
        break;
        
    case IDC_AP_RESTOREDEFAULTS:
        if (BN_CLICKED == iNot)
        {
            _OnRestoreDefault();
        }
        break;
    }
    
    return CBaseDlg::OnCommand(wParam, lParam);
}

LRESULT CAutoPlayDlg::OnDestroy(WPARAM wParam, LPARAM lParam)
{
    _uilListView.ResetContent();
    _uilListViewActions.ResetContent();

    return CBaseDlg::OnDestroy(wParam, lParam);
}

LRESULT CAutoPlayDlg::OnHelp(WPARAM wParam, LPARAM lParam)
{
    HWND hwndItem = (HWND)((LPHELPINFO)lParam)->hItemHandle;
    BOOL ret = WinHelp(hwndItem, TEXT("filefold.hlp"), HELP_WM_HELP, (ULONG_PTR)(LPTSTR)s_rgdwHelpIDsArray);
    if (!ret)
    {
        return CBaseDlg::OnHelp(wParam, lParam);
    }

    return ret;
}

LRESULT CAutoPlayDlg::OnContextMenu(WPARAM wParam, LPARAM lParam)
{
    BOOL lRes=FALSE;
    
    if (HTCLIENT == (int)SendMessage(_hwnd, WM_NCHITTEST, 0, lParam))
    {
        POINT pt;
        HWND hwndItem = NULL;
        int iCtrlID = 0;
        
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);
        ScreenToClient(_hwnd, &pt);
        
        hwndItem = ChildWindowFromPoint(_hwnd, pt);
        iCtrlID = GetDlgCtrlID(hwndItem);

        lRes = WinHelp((HWND)wParam, TEXT("filefold.hlp"), HELP_CONTEXTMENU, (ULONG_PTR)(LPTSTR)s_rgdwHelpIDsArray);
        if (!lRes)
        {
          return CBaseDlg::OnContextMenu(wParam, lParam);
        }
    }
    else
    {
        lRes = FALSE;
    }

    return lRes;
}

CAutoPlayDlg::CAutoPlayDlg() : CBaseDlg((ULONG_PTR)s_rgdwHelpIDsArray)
{
    ASSERT(ARRAYSIZE(_rgpContentTypeData) >= ARRAYSIZE(g_rgdwContentTypes));
}
      
HRESULT CAutoPlayDlg::Init(LPWSTR pszDrive, int iDriveType)
{
    lstrcpyn(_szDrive, pszDrive, ARRAYSIZE(_szDrive));
    _iDriveType = iDriveType;

    return S_OK;
}

HRESULT CAutoPlayDlg::_InitDataObjects()
{
    HRESULT hr = S_FALSE;
    BOOL fIsCDDrive = FALSE;
    DWORD dwDriveCapabilities = HWDDC_CDROM;
    DWORD dwMediaCapabilities = HWDMC_CDROM;

    CMountPoint* pmtpt = CMountPoint::GetMountPoint(_szDrive);

    if (pmtpt)
    {
        fIsCDDrive = pmtpt->IsCDROM();

        if (fIsCDDrive)
        {
            hr = pmtpt->GetCDInfo(&dwDriveCapabilities, &dwMediaCapabilities);
        }

        pmtpt->Release();
    }

    for (DWORD dw = 0; SUCCEEDED(hr) && (dw < ARRAYSIZE(g_rgdwContentTypes));
        ++dw)
    {   
        BOOL fAddOption = TRUE;

        if (fIsCDDrive)
        {
            if ((g_rgdwContentTypes[dw] & CT_DVDMOVIE) &&
                !(dwDriveCapabilities & (HWDDC_DVDROM | HWDDC_DVDRECORDABLE | HWDDC_DVDREWRITABLE)))
            {
                fAddOption = FALSE;
            }
            else if ((g_rgdwContentTypes[dw] & CT_BLANKCDR) &&
                !(dwDriveCapabilities & (HWDDC_CDRECORDABLE | HWDDC_CDREWRITABLE)))
            {
                fAddOption = FALSE;
            }
        }
        else
        {
            if (g_rgdwContentTypes[dw] &
                (CT_CDAUDIO | CT_DVDMOVIE | CT_BLANKCDR))
            {
                fAddOption = FALSE;
            }
        }

        if (fAddOption)
        {
            _rgpContentTypeData[dw] = new CContentTypeData();

            if (_rgpContentTypeData[dw])
            {
                hr = (_rgpContentTypeData[dw])->Init(_szDrive, g_rgdwContentTypes[dw]);
                if (SUCCEEDED(hr))
                {
                    hr = _dlmanager.AddDataObject(_rgpContentTypeData[dw]);
                }
                else
                {
                    // Let's just skip this one, do not go out of the loop and
                    // abort the whole initialization.
                    hr = S_FALSE;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
}

HRESULT CAutoPlayDlg::_InitListView()
{    
    HWND hwndList = GetDlgItem(_hwnd, IDC_AP_LIST);
    HRESULT hr = _uilListView.Init(hwndList);

    if (SUCCEEDED(hr))
    {
        Shell_GetImageLists(NULL, &_himagelist);

        if (_himagelist)
        {
            SendMessage(hwndList, CBEM_SETIMAGELIST, 0, (LPARAM)_himagelist);

            hr = S_OK;
        }
    }

    return hr;
}

HRESULT CAutoPlayDlg::_FillListView()
{
    HRESULT hr = S_FALSE;

    for (DWORD dw = 0; SUCCEEDED(hr) && (dw < ARRAYSIZE(_rgpContentTypeData));
        ++dw)
    {
        if (_rgpContentTypeData[dw])
        {
            CContentTypeCBItem* pctlvitem = new CContentTypeCBItem();

            if (pctlvitem)
            {
                hr = pctlvitem->InitData(_rgpContentTypeData[dw]);

                if (SUCCEEDED(hr))
                {
                    hr = _uilListView.AddItem(pctlvitem);
                }

                if (FAILED(hr))
                {
                    delete pctlvitem;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
}

CAutoPlayDlg::~CAutoPlayDlg()
{
    for (DWORD dw = 0; dw < ARRAYSIZE(_rgpContentTypeData); ++dw)
    {
        if (_rgpContentTypeData[dw])
        {
            (_rgpContentTypeData[dw])->Release();
        }
    }
    
#ifdef AUTOPLAYDLG_LEAKPARANOIA
    // If this is on, you cannot open two Autoplay dialogs (e.g.: Autoplay
    // proppage and Autoplay prompt) at the same time and then close one.
    // It will assert for sure when you close the first one.
    ASSERT(!_DbgLocalAllocCount);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\about.c ===
//
// about.c
//
//
// common about dialog for File Manager, Program Manager, Control Panel
//

#include "shellprv.h"
#pragma  hdrstop

#include <common.ver>   // for VER_LEGALCOPYRIGHT_YEARS
#include "ids.h"        // for IDD_EULA
#include <xpsp1res.h>   // for added XPSP1 resources
#include <winbrand.h>   // for added branding resources

#define STRING_SEPARATOR TEXT('#')
#define MAX_REG_VALUE   256

#define BytesToK(pDW)   (*(pDW) = (*(pDW) + 512) / 1024)        // round up

typedef struct {
        HICON   hIcon;
        LPCTSTR szApp;
        LPCTSTR szOtherStuff;
} ABOUT_PARAMS, *LPABOUT_PARAMS;

#define REG_SETUP   TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion")

BOOL_PTR CALLBACK AboutDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);

int WINAPI ShellAboutW(HWND hWnd, LPCTSTR szApp, LPCTSTR szOtherStuff, HICON hIcon)
{
    ABOUT_PARAMS ap;
    static HMODULE s_hmodXPSP1Res = (HMODULE)-1;
    
    if (s_hmodXPSP1Res == (HMODULE)-1)
    {
        s_hmodXPSP1Res = LoadLibraryExA("xpsp1res.dll", NULL, LOAD_LIBRARY_AS_DATAFILE);
    }
       
    ap.hIcon = hIcon;
    ap.szApp = (LPWSTR)szApp;
    ap.szOtherStuff = szOtherStuff;

    return (int)DialogBoxParam(s_hmodXPSP1Res ? s_hmodXPSP1Res : HINST_THISDLL,
                               (LPTSTR)MAKEINTRESOURCE(DLG_ABOUT),
                               hWnd,
                               AboutDlgProc,
                               (LPARAM)&ap);
}

INT  APIENTRY ShellAboutA( HWND hWnd, LPCSTR szApp, LPCSTR szOtherStuff, HICON hIcon)
{
   DWORD cchLen;
   DWORD dwRet;
   LPWSTR lpszAppW;
   LPWSTR lpszOtherStuffW;

   if (szApp)
   {
      cchLen = lstrlenA(szApp)+1;
      if (!(lpszAppW = (LPWSTR)LocalAlloc(LMEM_FIXED, (cchLen * sizeof(WCHAR)))))
      {
         return(0);
      }
      else
      {
         MultiByteToWideChar(CP_ACP, 0, (LPSTR)szApp, -1,
            lpszAppW, cchLen);

      }
   }
   else
   {
      lpszAppW = NULL;
   }

   if (szOtherStuff)
   {
      cchLen = lstrlenA(szOtherStuff)+1;
      if (!(lpszOtherStuffW = (LPWSTR)LocalAlloc(LMEM_FIXED,
            (cchLen * sizeof(WCHAR)))))
      {
         if (lpszAppW)
         {
            LocalFree(lpszAppW);
         }
         return(0);
      }
      else
      {
         MultiByteToWideChar(CP_ACP, 0, (LPSTR)szOtherStuff, -1,
            lpszOtherStuffW, cchLen);

      }
   }
   else
   {
      lpszOtherStuffW = NULL;
   }

   dwRet=ShellAboutW(hWnd, lpszAppW, lpszOtherStuffW, hIcon);


   if (lpszAppW)
   {
      LocalFree(lpszAppW);
   }

   if (lpszOtherStuffW)
   {
      LocalFree(lpszOtherStuffW);
   }

   return(dwRet);
}

DWORD RegGetStringAndRealloc( HKEY hkey, LPCTSTR lpszValue, LPTSTR *lplpsz, LPDWORD lpSize )
{
    DWORD       err;
    DWORD       dwSize;
    DWORD       dwType;
    LPTSTR      lpszNew;

    *lplpsz[0] = TEXT('\0');        // In case of error

    dwSize = *lpSize;
    err = SHQueryValueEx(hkey, (LPTSTR)lpszValue, 0, &dwType,
                          (LPBYTE)*lplpsz, &dwSize);

    if (err == ERROR_MORE_DATA)
    {
        lpszNew = (LPTSTR)LocalReAlloc((HLOCAL)*lplpsz, dwSize, LMEM_MOVEABLE);

        if (lpszNew)
        {
            *lplpsz = lpszNew;
            *lpSize = dwSize;
            err = SHQueryValueEx(hkey, (LPTSTR)lpszValue, 0, &dwType,
                                  (LPBYTE)*lplpsz, &dwSize);
        }
    }
    return err;
}


// Some Static strings that we use to read from the registry
// const char c_szAboutCurrentBuild[] = "CurrentBuild";
const TCHAR c_szAboutRegisteredUser[] = TEXT("RegisteredOwner");
const TCHAR c_szAboutRegisteredOrganization[] = TEXT("RegisteredOrganization");
const TCHAR c_szAboutProductID[] = TEXT("ProductID");
const TCHAR c_szAboutOEMID[] = TEXT("OEMID");


void _InitAboutDlg(HWND hDlg, LPABOUT_PARAMS lpap)
{
    HKEY        hkey;
    TCHAR       szldK[16];
    TCHAR       szBuffer[64];
    TCHAR       szTemp[64];
    TCHAR       szTitle[64];
    TCHAR       szMessage[200];
    TCHAR       szNumBuf1[32];
    LPTSTR      lpTemp;
    LPTSTR      lpszValue = NULL;
    DWORD       cb;
    DWORD       err;

    /*
     * Display app title
     */

    // REVIEW Note the const ->nonconst cast here

    for (lpTemp = (LPTSTR)lpap->szApp; 1 ; lpTemp = CharNext(lpTemp))
    {
        if (*lpTemp == TEXT('\0'))
        {
            GetWindowText(hDlg, szBuffer, ARRAYSIZE(szBuffer));
            wsprintf(szTitle, szBuffer, (LPTSTR)lpap->szApp);
            SetWindowText(hDlg, szTitle);
            break;
        }
        if (*lpTemp == STRING_SEPARATOR)
        {
            *lpTemp++ = TEXT('\0');
            SetWindowText(hDlg, lpap->szApp);
            lpap->szApp = lpTemp;
            break;
        }
    }

    GetDlgItemText(hDlg, IDD_APPNAME, szBuffer, ARRAYSIZE(szBuffer));
    wsprintf(szTitle, szBuffer, lpap->szApp);
    SetDlgItemText(hDlg, IDD_APPNAME, szTitle);

    // other stuff goes here...

    SetDlgItemText(hDlg, IDD_OTHERSTUFF, lpap->szOtherStuff);

    SendDlgItemMessage(hDlg, IDD_ICON, STM_SETICON, (WPARAM)lpap->hIcon, 0L);
    if (!lpap->hIcon)
        ShowWindow(GetDlgItem(hDlg, IDD_ICON), SW_HIDE);

    GetDlgItemText(hDlg, IDD_COPYRIGHTSTRING, szTemp, ARRAYSIZE(szTemp));
    wnsprintf(szBuffer, ARRAYSIZE(szBuffer), szTemp, TEXT(VER_LEGALCOPYRIGHT_YEARS));
    SetDlgItemText(hDlg, IDD_COPYRIGHTSTRING, szBuffer);

    /*
     * Display memory statistics
     */
    {
        MEMORYSTATUSEX MemoryStatus;
        DWORDLONG ullTotalPhys;

        MemoryStatus.dwLength = sizeof(MEMORYSTATUSEX);
        GlobalMemoryStatusEx(&MemoryStatus);
        ullTotalPhys = MemoryStatus.ullTotalPhys;

        BytesToK(&ullTotalPhys);

        LoadString(HINST_THISDLL, IDS_LDK, szldK, ARRAYSIZE(szldK));
        wsprintf(szBuffer, szldK, AddCommas64(ullTotalPhys, szNumBuf1, ARRAYSIZE(szNumBuf1)));
        SetDlgItemText(hDlg, IDD_CONVENTIONAL, szBuffer);
    }

    // Lets get the version and user information from the registry
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_SETUP, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        cb = MAX_REG_VALUE;

        if (NULL != (lpszValue = (LPTSTR)LocalAlloc(LPTR, cb)))
        {
            /*
             * Determine version information
             */
            OSVERSIONINFO Win32VersionInformation;

            Win32VersionInformation.dwOSVersionInfoSize = sizeof(Win32VersionInformation);
            if (!GetVersionEx(&Win32VersionInformation))
            {
                Win32VersionInformation.dwMajorVersion = 0;
                Win32VersionInformation.dwMinorVersion = 0;
                Win32VersionInformation.dwBuildNumber  = 0;
                Win32VersionInformation.szCSDVersion[0] = TEXT('\0');
            }

            LoadString(HINST_THISDLL, IDS_VERSIONMSG, szBuffer, ARRAYSIZE(szBuffer));

            szTitle[0] = TEXT('\0');
            if (Win32VersionInformation.szCSDVersion[0] != TEXT('\0'))
            {
                wsprintf(szTitle, TEXT(": %s"), Win32VersionInformation.szCSDVersion);
            }

            // Extra Whistler code to get the VBL version info
            {
                DWORD dwSize;
                DWORD dwType;

                // save off the current szTitle string
                lstrcpy(szTemp, szTitle);

                dwSize = sizeof(szTitle);
                if ((SHGetValue(HKEY_LOCAL_MACHINE,
                                TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion"),
                                TEXT("BuildLab"),
                                &dwType,
                                szTitle,
                                &dwSize) == ERROR_SUCCESS) && (dwType == REG_SZ))
                {
                    // Now szTitle contains the buildnumber in the format: "2204.reinerf.010700"
                    // Since we are sprintf'ing the buildnumber again below, we remove it first
                    memmove((void*)szTitle, (void*)&szTitle[4], (lstrlen(szTitle) + 1) * sizeof(TCHAR));
                    
                    if (szTemp[0] != TEXT('\0'))
                    {
                        // add back on the Service Pack version string
                        lstrcatn(szTitle, TEXT(" "), ARRAYSIZE(szTitle));
                        lstrcatn(szTitle, szTemp, ARRAYSIZE(szTitle));
                    }
                }
            }

            szNumBuf1[0] = TEXT('\0');
            if (GetSystemMetrics(SM_DEBUG))
            {
                szNumBuf1[0] = TEXT(' ');
                LoadString(HINST_THISDLL, IDS_DEBUG, &szNumBuf1[1], ARRAYSIZE(szNumBuf1) - 1);
            }
            wnsprintf(szMessage,
                      ARRAYSIZE(szMessage),
                      szBuffer,
                      Win32VersionInformation.dwMajorVersion,
                      Win32VersionInformation.dwMinorVersion,
                      Win32VersionInformation.dwBuildNumber,
                      (LPTSTR)szTitle,
                      (LPTSTR)szNumBuf1);
            SetDlgItemText(hDlg, IDD_VERSION, szMessage);

            /*
             * Display the User name.
             */
            err = RegGetStringAndRealloc(hkey, c_szAboutRegisteredUser, &lpszValue, &cb);
            if (!err)
                SetDlgItemText(hDlg, IDD_USERNAME, lpszValue);

            /*
             * Display the Organization name.
             */
            err = RegGetStringAndRealloc(hkey, c_szAboutRegisteredOrganization, &lpszValue, &cb);
            if (!err)
                SetDlgItemText(hDlg, IDD_COMPANYNAME, lpszValue);

            /*
             * Display the OEM or Product ID.
             */
            err = RegGetStringAndRealloc(hkey, c_szAboutOEMID, &lpszValue, &cb);
            if (!err)
            {
                /*
                 * We have an OEM ID, so hide the product ID controls,
                 * and display the text.
                 */
                ShowWindow (GetDlgItem(hDlg, IDD_PRODUCTID), SW_HIDE);
                ShowWindow (GetDlgItem(hDlg, IDD_SERIALNUM), SW_HIDE);
                SetDlgItemText(hDlg, IDD_OEMID, lpszValue);
            }
            else if (err == ERROR_FILE_NOT_FOUND)
            {
                /*
                 * OEM ID didn't exist, so look for the Product ID
                 */
                ShowWindow (GetDlgItem(hDlg, IDD_OEMID), SW_HIDE);
                err = RegGetStringAndRealloc(hkey, c_szAboutProductID, &lpszValue, &cb);
                if (!err)
                {
                    SetDlgItemText(hDlg, IDD_SERIALNUM, lpszValue);
                }
            }

            LocalFree(lpszValue);
        }

        RegCloseKey(hkey);
    }
}


BOOL_PTR CALLBACK AboutDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL_PTR bReturn = TRUE;

    switch (wMsg)
    {
    case WM_INITDIALOG:
        _InitAboutDlg(hDlg, (LPABOUT_PARAMS)lParam);
        break;

    case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hDlg, &ps);

            // We draw the product banner and a blue strip.  In order to support high DPI monitors
            // and scaled fonts we must scale the image and the strip to the proportions of the dialog.
            //
            // +-----------------------------+
            // | Product Banner (413x72)     |
            // |                             |
            // +-----------------------------+
            // | Blue Strip (413x5)          |
            // +-----------------------------+

            HDC hdcMem = CreateCompatibleDC(hdc);
            int cxDlg;

            {
                RECT rc;
                GetClientRect(hDlg, &rc);
                cxDlg = rc.right;
            }

            if (hdcMem)
            {
                BOOL fDeep = (SHGetCurColorRes() > 8);
                HBITMAP hbmBand, hbmAbout;
                int cxDest = MulDiv(413,cxDlg,413);
                int cyDest = MulDiv(72,cxDlg,413);
                UINT uID;
                UINT uXpSpLevel = 0;
                HMODULE hResourceDll = HINST_THISDLL;

                if (IsOS(OS_PERSONAL))
                {
                    uID = (fDeep ? IDB_ABOUTPERSONAL256 : IDB_ABOUTPERSONAL16);
                }
#ifndef _WIN64
                else if (IsOS(OS_EMBEDDED))
                {
                    uID = (fDeep ? IDB_ABOUTEMBEDDED256 : IDB_ABOUTEMBEDDED16);
                }
                else if (IsOS(OS_TABLETPC))
                {
                    uXpSpLevel = 1;
                    uID = (fDeep ? IDB_ABOUTTABLETPC256_SHELL32_DLL : IDB_ABOUTTABLETPC16_SHELL32_DLL);
                }
                else if (IsOS(OS_MEDIACENTER))
                {
                    uXpSpLevel = 1;
                    uID = (fDeep ? IDB_ABOUTMEDIACENTER256_SHELL32_DLL : IDB_ABOUTMEDIACENTER16_SHELL32_DLL);
                }
#endif // !_WIN64
                else
                {
                    uID = (fDeep ? IDB_ABOUT256 : IDB_ABOUT16);
                }

                // If this bitmap was added for a Windows XP service pack,
                // and lives in a special resource DLL, attempt to load it
                // now. If this fails, revert to the Professional bitmaps.
                
                if (uXpSpLevel > 0)
                {
                    hResourceDll = LoadLibraryEx(TEXT("winbrand.dll"),
                                                 NULL,
                                                 LOAD_LIBRARY_AS_DATAFILE);

                    if (hResourceDll == NULL)
                    {
                        hResourceDll = HINST_THISDLL;
                        uID = (fDeep ? IDB_ABOUT256 : IDB_ABOUT16);
                    }
                }
                            
                // paint the bitmap for the windows product

                hbmAbout = LoadImage(hResourceDll,
                                     MAKEINTRESOURCE(uID),
                                     IMAGE_BITMAP, 
                                     0, 0, 
                                     LR_LOADMAP3DCOLORS);
                            
                if (hResourceDll != HINST_THISDLL)
                {
                    FreeLibrary(hResourceDll);
                }
                
                if ( hbmAbout )
                {
                    HBITMAP hbmOld = SelectObject(hdcMem, hbmAbout);
                    if (hbmOld)
                    {
                        StretchBlt(hdc, 0, 0, cxDest, cyDest, hdcMem, 0,0,413,72, SRCCOPY);
                        SelectObject(hdcMem, hbmOld);
                    }
                    DeleteObject(hbmAbout);
                }

                // paint the blue band below it

                hbmBand = LoadImage(HINST_THISDLL,  
                                    MAKEINTRESOURCE(fDeep ? IDB_ABOUTBAND256:IDB_ABOUTBAND16),
                                    IMAGE_BITMAP, 
                                    0, 0, 
                                    LR_LOADMAP3DCOLORS);
                if ( hbmBand )
                {
                    HBITMAP hbmOld = SelectObject(hdcMem, hbmBand);
                    if (hbmOld)
                    {
                        StretchBlt(hdc, 0, cyDest, cxDest, MulDiv(5,cxDlg,413), hdcMem, 0,0,413,5, SRCCOPY);
                        SelectObject(hdcMem, hbmOld);
                    }
                    DeleteObject(hbmBand);
                }

                DeleteDC(hdcMem);
            }

            EndPaint(hDlg, &ps);
            break;
        }

    case WM_COMMAND:
        EndDialog(hDlg, TRUE);
        break;

    case WM_NOTIFY:
        if ((IDD_EULA == (int)wParam) &&
            (NM_CLICK == ((LPNMHDR)lParam)->code))
        {
            SHELLEXECUTEINFO sei = { 0 };
            sei.cbSize = sizeof(SHELLEXECUTEINFO);
            sei.fMask = SEE_MASK_DOENVSUBST;
            sei.hwnd = hDlg;
            sei.nShow = SW_SHOWNORMAL;
            sei.lpFile = TEXT("%windir%\\system32\\eula.txt");

            ShellExecuteEx(&sei);
        }
        else
        {
            // WM_NOTIFY not handled.
            bReturn = FALSE;
        }
        break;

    default:
        // Not handled.
        bReturn = FALSE;
    }
    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\apdlglog.cpp ===
#include "shellprv.h"
#include "ids.h"

#include "hwcmmn.h"
#include "apdlglog.h"
#include "mtptl.h"

BOOL _AreHandlersDifferent(LPCWSTR pszOriginal, LPCWSTR pszNew)
{
    return TRUE;
}

CHandlerDataArray::~CHandlerDataArray()
{
    if (IsDPASet())
    {
        DestroyCallback(_ReleaseHandler, NULL);
    }
}

BOOL CHandlerDataArray::_IsDemotedHandler(PCWSTR pszHandler)
{
    return ((0 == StrCmpIW(pszHandler, L"MSTakeNoAction"))
        ||  (0 == StrCmpIW(pszHandler, L"MSOpenFolder")));
}
    
HRESULT CHandlerDataArray::AddHandler(CHandlerData *pdata)
{
    //  always insert ahead of TakeNoAction and OpenFolder
    int iInsert;
    if (!_IsDemotedHandler(pdata->_pszHandler))
    {
        int c = GetPtrCount();
        for (iInsert = 0; iInsert < c; iInsert++)
        {
            if (_IsDemotedHandler(GetPtr(iInsert)->_pszHandler))
            {
                //  insert here
                break;
            }
        }
        iInsert = InsertPtr(iInsert, pdata);
    }
    else
    {
        iInsert = AppendPtr(pdata);
    }

    return DPA_ERR != iInsert ? S_OK : E_OUTOFMEMORY;
}

BOOL CHandlerDataArray::IsDuplicateCommand(PCWSTR pszCommand)
{
    WCHAR sz[MAX_PATH * 2];
    BOOL fRet = FALSE;
    int c = GetPtrCount();
    for (int i = 0; i < c; i++)
    {
        CHandlerData *pdata = GetPtr(i);
        if (SUCCEEDED(pdata->_GetCommand(sz, ARRAYSIZE(sz))))
        {
            fRet = (0 == StrCmpIW(pszCommand, sz));
            if (fRet)
                break;
        }
    }
    return fRet;
}

// We are erring on the side of safety here by giving FALSE positives
// sometimes.  This could be optimized to consider if we have diff handler
// just because one is missing.
void CContentTypeData::UpdateDirty()
{
    BOOL fDirty = _AreHandlersDifferent(_pszHandlerDefault, _pszHandlerDefaultOriginal) ||
        (HANDLERDEFAULT_DEFAULTSAREDIFFERENT & _dwHandlerDefaultFlags);

    _SetDirty(fDirty);
}

#define SOFTPREFIX TEXT("[soft]")

HRESULT CContentTypeData::CommitChangesToStorage()
{
    HRESULT hr = S_OK;

    if (_AreHandlersDifferent(_pszHandlerDefault, _pszHandlerDefaultOriginal) ||
        (HANDLERDEFAULT_DEFAULTSAREDIFFERENT & _dwHandlerDefaultFlags))
    {
        // Yep, changed
        IAutoplayHandler* piah;

        hr = _GetAutoplayHandler(_szDrive, TEXT("ContentArrival"), _szContentTypeHandler, &piah);
        if (SUCCEEDED(hr))
        {
            if (!_fSoftCommit)
            {
                hr = piah->SetDefaultHandler(_pszHandlerDefault);
            }
            else
            {
                WCHAR szHandler[MAX_HANDLER + ARRAYSIZE(SOFTPREFIX)];

                lstrcpyn(szHandler, SOFTPREFIX, ARRAYSIZE(szHandler));
                StrCatBuff(szHandler, _pszHandlerDefault, ARRAYSIZE(szHandler));

                hr = piah->SetDefaultHandler(szHandler);
            }

            piah->Release();
        }
    }

    if (SUCCEEDED(hr))
    {
        _SetHandlerDefault(&_pszHandlerDefaultOriginal, _pszHandlerDefault);
    }

    return hr;
}

CContentTypeData::~CContentTypeData()
{
    if (_pszHandlerDefaultOriginal)
    {
        CoTaskMemFree(_pszHandlerDefaultOriginal);
    }

    if (_pszHandlerDefault)
    {
        CoTaskMemFree(_pszHandlerDefault);
    }
}

HRESULT _MakeActionString(LPCWSTR pszAction, LPWSTR* ppszAction2)
{
    *ppszAction2 = NULL;

    WCHAR szAction[250];
    HRESULT hr = SHLoadIndirectString(pszAction, szAction, ARRAYSIZE(szAction), NULL);
    if (SUCCEEDED(hr))
    {
        hr = SHStrDup(szAction, ppszAction2);
    }

    return hr;
}

HRESULT _MakeProviderString(LPCWSTR pszProvider, LPWSTR* ppszProvider2)
{
    WCHAR szProviderNonMUI[250];
    HRESULT hr = SHLoadIndirectString(pszProvider, szProviderNonMUI, ARRAYSIZE(szProviderNonMUI), NULL);

    if (SUCCEEDED(hr))
    {
        WCHAR szUsing[50];

        if (LoadString(g_hinst, IDS_AP_USING, szUsing, ARRAYSIZE(szUsing)))
        {
            WCHAR szProvider2[250];

            wnsprintf(szProvider2, ARRAYSIZE(szProvider2), szUsing, szProviderNonMUI);

            if (SUCCEEDED(SHStrDup(szProvider2, ppszProvider2)))
            {
                hr = S_OK;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

inline void _CoTaskMemFree(void* pv)
{
    if (pv)
    {
        CoTaskMemFree(pv);
    }
}

HRESULT _CreateHandlerData( PCWSTR pszAction, 
                            PCWSTR pszProvider, 
                            PWSTR *ppszHandler, //  IN/OUT
                            PWSTR *ppszIcon, //  IN/OUT
                            CHandlerData **ppdata)
{
    *ppdata = 0;
    LPWSTR pszAction2 = NULL;
    HRESULT hr = _MakeActionString(pszAction, &pszAction2);
    if (SUCCEEDED(hr))
    {
        LPWSTR pszProvider2 = NULL;
        // Special case this guy, we don't want to say:
        // "Take no action, using Microsoft Windows"
        if (lstrcmp(*ppszHandler, TEXT("MSTakeNoAction")))
        {
            hr = _MakeProviderString(pszProvider, &pszProvider2);
        }
        //  else this is NULL, and ignored

        if (SUCCEEDED(hr))
        {
            *ppdata = new CHandlerData();
            if (*ppdata)
            {
                //  give away ownership of these allocations
                (*ppdata)->Init(*ppszHandler, pszAction2,
                    *ppszIcon, pszProvider2);

                *ppszHandler = NULL;
                *ppszIcon = NULL;
                pszAction2 = NULL;
                pszProvider2 = NULL;
            }
            else
            {
                hr = E_OUTOFMEMORY;
                CoTaskMemFree(pszProvider2);
            }
            
        }
        CoTaskMemFree(pszAction2);
    }

    return hr;
}

HRESULT CContentBase::_EnumHandlerHelper(IAutoplayHandler* piah)
{
    IEnumAutoplayHandler* penum;
    if (S_OK == piah->EnumHandlers(&penum))
    {
        LPWSTR pszHandler;
        LPWSTR pszAction;
        LPWSTR pszProvider;
        LPWSTR pszIconLocation;
        while (S_OK == penum->Next(&pszHandler, &pszAction, &pszProvider,
            &pszIconLocation))
        {
            // Do not free the strings from EnumHandlers
            // CHandlerData will free them in its destructor
            CHandlerData *pdata;
            HRESULT hr = _CreateHandlerData(pszAction, pszProvider, &pszHandler, &pszIconLocation, &pdata);
            if (SUCCEEDED(hr))
            {
                hr = _dpaHandlerData.AddHandler(pdata);
                if (FAILED(hr))
                {
                    pdata->Release();
                }
            }
            else
            {
                CoTaskMemFree(pszHandler);
                CoTaskMemFree(pszIconLocation);
            }
            CoTaskMemFree(pszProvider);
            CoTaskMemFree(pszAction);
        }

        penum->Release();
    }

    return S_OK;
}

HRESULT _CreateLegacyHandler(IAssociationElement *pae, PCWSTR pszAction, CHandlerData **ppdata)
{
    *ppdata = 0;
    PWSTR pszIcon;
    HRESULT hr = pae->QueryString(AQVS_APPLICATION_PATH, NULL, &pszIcon);
    if(SUCCEEDED(hr))
    {
        PWSTR pszFriendly;
        hr = pae->QueryString(AQVS_APPLICATION_FRIENDLYNAME, NULL, &pszFriendly);
        if(SUCCEEDED(hr))
        {
            PWSTR pszHandler;
            hr = SHStrDup(TEXT("AutoplayLegacyHandler"), &pszHandler);
            if (SUCCEEDED(hr))
            {
                hr = _CreateHandlerData(pszAction, pszFriendly, &pszHandler, &pszIcon, ppdata);
                CoTaskMemFree(pszHandler);
            }
            CoTaskMemFree(pszFriendly);
        }
        CoTaskMemFree(pszIcon);
    }

    return hr;
}

CHandlerData* CContentBase::GetHandlerData(int i)
{
    CHandlerData* phandlerdata = _dpaHandlerData.GetPtr(i);

    if (phandlerdata)
    {
        phandlerdata->AddRef();
    }

    return phandlerdata;
}

HRESULT CContentBase::_AddLegacyHandler(DWORD dwContentType)
{
    HRESULT hr = S_FALSE;

    if (dwContentType & (CT_CDAUDIO | CT_DVDMOVIE))
    {
        LPCWSTR pszProgID;
        LPCWSTR pszAction;

        if (dwContentType & CT_CDAUDIO)
        {
            pszProgID = TEXT("AudioCD");
            pszAction = TEXT("@%SystemRoot%\\system32\\shell32.dll,-17171");
        }
        else
        {
            ASSERT(dwContentType & CT_DVDMOVIE);
            pszProgID = TEXT("DVD");
            pszAction = TEXT("@%SystemRoot%\\system32\\shell32.dll,-17172");
        }

        IAssociationElement * pae;
        hr = AssocElemCreateForClass(&CLSID_AssocProgidElement, pszProgID, &pae);
        if (SUCCEEDED(hr))
        {
            PWSTR pszCommand;
            hr = pae->QueryString(AQVS_COMMAND, NULL, &pszCommand);
            if (SUCCEEDED(hr))
            {
                //  legacy guys have a command or we dont add them
                //  we expect new guys to be responsible and add themselves 
                //  to the autoplay handlers key
                if (!_dpaHandlerData.IsDuplicateCommand(pszCommand))
                {
                    LPWSTR pszPath;
                    hr = pae->QueryString(AQVS_APPLICATION_PATH, NULL, &pszPath);

                    if (SUCCEEDED(hr))
                    {
                        DWORD dwAttrib = GetFileAttributes(pszPath);

                        // We do not want to show legacy handler if their exe
                        // is hidden
                        if ((0xFFFFFFFF != dwAttrib) &&
                            !(FILE_ATTRIBUTE_HIDDEN & dwAttrib))
                        {
                            CHandlerData* pdata;
                            hr = _CreateLegacyHandler(pae, pszAction, &pdata);
                            if (SUCCEEDED(hr))
                            {
                                hr = _dpaHandlerData.AddHandler(pdata);
                                if (FAILED(hr))
                                {
                                    pdata->Release();
                                }
                            }
                        }

                        CoTaskMemFree(pszPath);
                    }
                }
                
                CoTaskMemFree(pszCommand);
            }
            pae->Release();
        }

    }

    return hr;
}

HRESULT CContentTypeData::Init(LPCWSTR pszDrive, DWORD dwContentType)
{
    HRESULT hr;

    _dwContentType = dwContentType;

    hr = _GetContentTypeHandler(_dwContentType, _szContentTypeHandler,
        ARRAYSIZE(_szContentTypeHandler));

    if (SUCCEEDED(hr))
    {
        hr = _GetContentTypeInfo(_dwContentType, _szIconLabel, ARRAYSIZE(_szIconLabel),
                _szIconLocation, ARRAYSIZE(_szIconLocation));

        lstrcpyn(_szDrive, pszDrive, ARRAYSIZE(_szDrive));

        if (SUCCEEDED(hr))
        {
            IAutoplayHandler* piah;

            hr = _GetAutoplayHandler(_szDrive, TEXT("ContentArrival"),
                    _szContentTypeHandler, &piah);

            if (SUCCEEDED(hr))
            {
                hr = piah->GetDefaultHandler(&_pszHandlerDefaultOriginal);

                if (SUCCEEDED(hr))
                {
                    if (S_FALSE != hr)
                    {
                        _dwHandlerDefaultFlags = HANDLERDEFAULT_GETFLAGS(hr);
                    }

                    // SHStrDup (we want CoTaskMemAlloc)
                    hr = SHStrDup(_pszHandlerDefaultOriginal, &_pszHandlerDefault);
                }

                if (SUCCEEDED(hr))
                {
                    if (_dpaHandlerData.Create(4))
                    {
                        hr = _EnumHandlerHelper(piah);
                        if (SUCCEEDED(hr))
                        {
                            _AddLegacyHandler(dwContentType);
                        }
                    }
                }

                piah->Release();
            }
        }
    }

    return hr;
}

HRESULT CContentTypeLVItem::GetText(LPWSTR pszText, DWORD cchText)
{
    HRESULT hr;
    CContentTypeData* pdata = GetData();
    if (pdata)
    {
        lstrcpyn(pszText, pdata->_szIconLabel, cchText);
        pdata->Release();
        hr = S_OK;
    }
    else
    {
        *pszText = NULL;
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CContentTypeLVItem::GetIconLocation(LPWSTR pszIconLocation,
    DWORD cchIconLocation)
{
    HRESULT hr;
    CContentTypeData* pdata = GetData();
    if (pdata)
    {
        lstrcpyn(pszIconLocation, pdata->_szIconLocation, cchIconLocation);
        pdata->Release();
        hr = S_OK;
    }
    else
    {
        *pszIconLocation = NULL;
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CContentTypeCBItem::GetText(LPWSTR pszText, DWORD cchText)
{
    HRESULT hr;
    CContentTypeData* pdata = GetData();
    if (pdata)
    {
        lstrcpyn(pszText, pdata->_szIconLabel, cchText);
        pdata->Release();
        hr = S_OK;
    }
    else
    {
        *pszText = NULL;
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CContentTypeCBItem::GetIconLocation(LPWSTR pszIconLocation, DWORD cchIconLocation)
{
    HRESULT hr;
    CContentTypeData* pdata = GetData();
    if (pdata)
    {
        lstrcpyn(pszIconLocation, pdata->_szIconLocation, cchIconLocation);
        pdata->Release();
        hr = S_OK;
    }
    else
    {
        *pszIconLocation = NULL;
        hr = S_FALSE;
    }

    return hr;
}

CHandlerData::~CHandlerData()
{
    if (_pszHandler)
    {
        CoTaskMemFree((void*)_pszHandler);
    }
    if (_pszHandlerFriendlyName)
    {
        CoTaskMemFree((void*)_pszHandlerFriendlyName);
    }
    if (_pszIconLocation)
    {
        CoTaskMemFree((void*)_pszIconLocation);
    }
    if (_pszTileText)
    {
        CoTaskMemFree(_pszTileText);
    }
}

void CHandlerData::Init(PWSTR pszHandler, PWSTR pszHandlerFriendlyName,
    PWSTR pszIconLocation, PWSTR pszTileText)
{
    _pszHandler = pszHandler;
    _pszHandlerFriendlyName = pszHandlerFriendlyName;
    _pszIconLocation = pszIconLocation;
    _pszTileText = pszTileText;
    //  WE CANT FAIL
}

void CHandlerData::UpdateDirty()
{
    // nothing to do
}
    
HRESULT CHandlerCBItem::GetText(LPWSTR pszText, DWORD cchText)
{
    HRESULT hr;
    CHandlerData* pdata = GetData();
    if (pdata)
    {
        lstrcpyn(pszText, pdata->_pszHandlerFriendlyName, cchText);
        pdata->Release();
        hr = S_OK;
    }
    else
    {
        *pszText = NULL;
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CHandlerLVItem::GetText(LPWSTR pszText, DWORD cchText)
{
    HRESULT hr;
    CHandlerData* pdata = GetData();
    if (pdata)
    {
        lstrcpyn(pszText, pdata->_pszHandlerFriendlyName, cchText);
        pdata->Release();
        hr = S_OK;
    }
    else
    {
        *pszText = NULL;
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CHandlerLVItem::GetIconLocation(LPWSTR pszIconLocation, DWORD cchIconLocation)
{
    HRESULT hr;
    CHandlerData* pdata = GetData();
    if (pdata)
    {
        lstrcpyn(pszIconLocation, pdata->_pszIconLocation, cchIconLocation);
        pdata->Release();
        hr = S_OK;
    }
    else
    {
        *pszIconLocation = NULL;
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CHandlerLVItem::GetTileText(int i, LPWSTR pszTileText, DWORD cchTileText)
{
    HRESULT hr = S_FALSE;
    CHandlerData* pdata = GetData();

    *pszTileText = NULL;
    hr = S_FALSE;

    // we dont support anything but zero
    ASSERT(0 == i);
    if (pdata)
    {
        if (pdata->_pszTileText)
        {
            lstrcpyn(pszTileText, pdata->_pszTileText, cchTileText);
            hr = S_OK;
        }
        pdata->Release();
    }

    return hr;
}

// We are erring on the side of safety here by giving FALSE positives
// sometimes.  This could be optimized to consider if we have diff handler
// just because one is missing.
void CNoContentData::UpdateDirty()
{
    BOOL fDirty = _AreHandlersDifferent(_pszHandlerDefault, _pszHandlerDefaultOriginal) ||
        (HANDLERDEFAULT_DEFAULTSAREDIFFERENT & _dwHandlerDefaultFlags);

    _SetDirty(fDirty);
}

HRESULT CNoContentData::CommitChangesToStorage()
{
    HRESULT hr = S_OK;

    if (_AreHandlersDifferent(_pszHandlerDefault, _pszHandlerDefaultOriginal) ||
        (HANDLERDEFAULT_DEFAULTSAREDIFFERENT & _dwHandlerDefaultFlags))
    {
        // Yep, changed
        IAutoplayHandler* piah;

        hr = _GetAutoplayHandlerNoContent(_szDeviceID, TEXT("DeviceArrival"), &piah);
        if (SUCCEEDED(hr))
        {
            if (!_fSoftCommit)
            {
                hr = piah->SetDefaultHandler(_pszHandlerDefault);
            }
            else
            {
                WCHAR szHandler[MAX_HANDLER + ARRAYSIZE(SOFTPREFIX)];

                lstrcpyn(szHandler, SOFTPREFIX, ARRAYSIZE(szHandler));
                StrCatBuff(szHandler, _pszHandlerDefault, ARRAYSIZE(szHandler));

                hr = piah->SetDefaultHandler(szHandler);
            }

            piah->Release();
        }
    }

    if (SUCCEEDED(hr))
    {
        _SetHandlerDefault(&_pszHandlerDefaultOriginal, _pszHandlerDefault);
    }

    return hr;
}

CNoContentData::~CNoContentData()
{
    if (_pszHandlerDefaultOriginal)
    {
        CoTaskMemFree(_pszHandlerDefaultOriginal);
    }

    if (_pszHandlerDefault)
    {
        CoTaskMemFree(_pszHandlerDefault);
    }

    if (_pszIconLabel)
    {
        CoTaskMemFree((void*)_pszIconLabel);
    }

    if (_pszIconLocation)
    {
        CoTaskMemFree((void*)_pszIconLocation);
    }
}

HRESULT _MakeDeviceLabel(LPCWSTR pszSource, LPWSTR* ppszDest)
{
    WCHAR szDeviceName[250];

    HRESULT hr = SHLoadIndirectString(pszSource, szDeviceName, ARRAYSIZE(szDeviceName), NULL);
    if (SUCCEEDED(hr))
    {
        hr = SHStrDup(szDeviceName, ppszDest);
    }

    return hr;
}

HRESULT CNoContentData::Init(LPCWSTR pszDeviceID)
{
    lstrcpyn(_szDeviceID, pszDeviceID, ARRAYSIZE(_szDeviceID));

    IAutoplayHandler* piah;
    HRESULT hr = _GetAutoplayHandlerNoContent(_szDeviceID, TEXT("DeviceArrival"), &piah);
    if (SUCCEEDED(hr))
    {
        hr = piah->GetDefaultHandler(&_pszHandlerDefaultOriginal);

        if (SUCCEEDED(hr))
        {
            if (S_FALSE != hr)
            {
                _dwHandlerDefaultFlags = HANDLERDEFAULT_GETFLAGS(hr);
            }

            // SHStrDup (we want CoTaskMemAlloc)
            hr = SHStrDup(_pszHandlerDefaultOriginal, &_pszHandlerDefault);
        }

        if (SUCCEEDED(hr))
        {
            if (_dpaHandlerData.Create(4))
            {
                hr = _EnumHandlerHelper(piah);
            }
        }

        piah->Release();
    }

    if (SUCCEEDED(hr))
    {
        IHWDeviceCustomProperties* pihwdevcp;
        hr = GetDeviceProperties(_szDeviceID, &pihwdevcp);
        if (SUCCEEDED(hr))
        {
            LPWSTR pszIconLabel;
            hr = pihwdevcp->GetStringProperty(TEXT("Label"), &pszIconLabel);
            if (SUCCEEDED(hr))
            {
                hr = _MakeDeviceLabel(pszIconLabel, &_pszIconLabel);
                if (SUCCEEDED(hr))
                {
                    WORD_BLOB* pblob;

                    hr = pihwdevcp->GetMultiStringProperty(TEXT("Icons"), TRUE, &pblob);
                    if (SUCCEEDED(hr))
                    {
                        hr = SHStrDup(pblob->asData, &_pszIconLocation);

                        CoTaskMemFree(pblob);
                    }

                    CoTaskMemFree(pszIconLabel);
                }
            }

            pihwdevcp->Release();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\apdlg.h ===
#ifndef APDLG_H
#define APDLG_H

#include "basedlg.h"
#include "ctllogic.h"

#include "apdlglog.h"

#define SETTINGSCURRENTPAGECOUNT    5

#define IDH_SELECT_CONTENT_TYPE 10110
#define IDH_SELECT_ACTION       10111
#define IDH_PROMPT_ME_EACH_TIME 10112
#define IDH_TAKE_NO_ACTION      10113

class CAutoPlayDlg : public CBaseDlg
{
public:
    CAutoPlayDlg();
    ~CAutoPlayDlg();

    HRESULT Init(LPWSTR pszDrive, int iDriveType);

protected:
    LRESULT OnInitDialog(WPARAM wParam, LPARAM lParam);
    LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    LRESULT OnCommand(WPARAM wParam, LPARAM lParam);
    LRESULT OnDestroy(WPARAM wParam, LPARAM lParam);
    LRESULT OnHelp(WPARAM wParam, LPARAM lParam);
    LRESULT OnContextMenu(WPARAM wParam, LPARAM lParam);

private:
    LRESULT _OnApply();

private:

    HRESULT _UpdateLowerPane();
    HRESULT _UpdateRestoreButton(BOOL fPromptEachTime);
    HRESULT _SelectRadioButton(BOOL fPromptEachTime);
    HRESULT _SelectListViewActionsItem(LPCWSTR pszHandlerDefault);

    HRESULT _OnListViewActionsSelChange();

    HRESULT _UpdateApplyButton();

    HRESULT _OnRadio(int i);
    HRESULT _OnRestoreDefault();

    HRESULT _InitDataObjects();
    HRESULT _InitListView();
    HRESULT _FillListView();

    HRESULT _InitListViewActions();
    HRESULT _FillListViewActions(CContentTypeData* pdata);

private:
    CContentTypeData*                   _rgpContentTypeData[7];

    int                                 _iDriveType;
    WCHAR                               _szDrive[MAX_PATH];

    HIMAGELIST                          _himagelist;
    BOOL                                _fAtLeastOneAction;
    BOOL                                _fIgnoreListViewItemStateChanges;

    CUILComboBoxEx<CContentTypeData>    _uilListView;
    CUILListView<CHandlerData>          _uilListViewActions;
    
    CDLManager<CContentTypeData>        _dlmanager;
};

#endif //APDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\apdlglog.h ===
#ifndef APDLGLOG_H
#define APDLGLOG_H

#include "dlglogic.h"
#include "ctllogic.h"

#include <dpa.h>

#define MAX_CONTENTTYPEHANDLER                  64
#define MAX_CONTENTTYPEHANDLERFRIENDLYNAME      128

#define MAX_DEVICENAME                          50
#define MAX_HANDLER                             64

class CHandlerData : public CDataImpl
{
public:
    // from CDataImpl
    void UpdateDirty();

    // from CHandlerData
    void Init(PWSTR pszHandler, PWSTR pszHandlerFriendlyName, 
        PWSTR pszIconLocation, PWSTR pszTileText);

    HRESULT _GetCommand(PWSTR pszCommand, DWORD cchCommand)
    {
        WCHAR szProgid[260];
        WCHAR szVerb[CCH_KEYMAX];
        HRESULT hr = _GetHandlerInvokeProgIDAndVerb(_pszHandler, 
                            szProgid, ARRAYSIZE(szProgid),
                            szVerb, ARRAYSIZE(szVerb));
        if (SUCCEEDED(hr))
        {
            hr = AssocQueryStringW(0, ASSOCSTR_COMMAND, szProgid, szVerb, pszCommand, &cchCommand);
        }
        return hr;
    }

    HRESULT Compare(LPCWSTR pszHandler, int* piResult)
    {
        (*piResult) = StrCmpW(pszHandler, _pszHandler);

        return S_OK;
    };

    ~CHandlerData();

public:
    PWSTR          _pszHandler;
    PWSTR          _pszHandlerFriendlyName;
    PWSTR          _pszIconLocation;
    PWSTR          _pszTileText;
};

class CHandlerDataArray : public CDPA<CHandlerData>
{
public:
    static int CALLBACK _ReleaseHandler(CHandlerData *pdata, void *)
    {
        pdata->Release();
        return 1;
    }
    
    ~CHandlerDataArray();

    HRESULT AddHandler(CHandlerData *pdata);
    BOOL IsDuplicateCommand(PCWSTR pszCommand);

protected:
    BOOL _IsDemotedHandler(PCWSTR pszHandler);
    
};

class CContentBase : public CDataImpl
{
public:
    CHandlerData* GetHandlerData(int i);
    int GetHandlerCount() { return _dpaHandlerData.IsDPASet() ? _dpaHandlerData.GetPtrCount() : 0; }
    void RemoveHandler(int i)
    {
        CHandlerData *pdata = _dpaHandlerData.DeletePtr(i);
        if (pdata)
            pdata->Release();
    }

            
protected:
    HRESULT _AddLegacyHandler(DWORD dwContentType);
    HRESULT _EnumHandlerHelper(IAutoplayHandler* piah);

public:  // members
    CHandlerDataArray     _dpaHandlerData;
};

class CNoContentData : public CContentBase
{
public:
    // from CDataImpl
    void UpdateDirty();
    HRESULT CommitChangesToStorage();

    // from CNoContentData
    HRESULT Init(LPCWSTR pszDeviceID);

public:
    CNoContentData() : _dwHandlerDefaultFlags(0) {}
    ~CNoContentData();

    // MAX_DEVICE_ID_LEN == 200
    WCHAR                   _szDeviceID[200];

    LPWSTR                  _pszIconLabel; // e.g.: "Compaq iPaq"
    LPWSTR                  _pszIconLocation;

    // Latest settings (potentially modified by user)
    //     Current selection in ComboBox
    LPWSTR                  _pszHandlerDefault;

    // Original settings (unmodified)
    //     Current selection in ComboBox
    LPWSTR                  _pszHandlerDefaultOriginal;

    DWORD                   _dwHandlerDefaultFlags;
    BOOL                    _fSoftCommit;
};

class CContentTypeData : public CContentBase
{
public:
    // from CDataImpl
    void UpdateDirty();
    HRESULT CommitChangesToStorage();

    // from CContentTypeData
    HRESULT Init(LPCWSTR pszDrive, DWORD dwContentType);

public:
    CContentTypeData() : _dwHandlerDefaultFlags(0) {}
    ~CContentTypeData();

    DWORD                   _dwContentType;

    WCHAR                   _szContentTypeHandler[MAX_CONTENTTYPEHANDLER];
    WCHAR                   _szDrive[MAX_PATH];

    // For ListView
    WCHAR                   _szIconLabel[MAX_CONTENTTYPEHANDLERFRIENDLYNAME]; // e.g.: "Pictures"
    WCHAR                   _szIconLocation[MAX_ICONLOCATION];

    // Latest settings (potentially modified by user)
    //     Current selection in ComboBox
    LPWSTR                  _pszHandlerDefault;

    // Original settings (unmodified)
    //     Current selection in ComboBox
    LPWSTR                  _pszHandlerDefaultOriginal;

    DWORD                   _dwHandlerDefaultFlags;
    BOOL                    _fSoftCommit;
};

class CContentTypeLVItem : public CDLUIDataLVItem<CContentTypeData>
{
public:
    HRESULT GetText(LPWSTR pszText, DWORD cchText);
    HRESULT GetIconLocation(LPWSTR pszIconLocation,
        DWORD cchIconLocation);
};

class CContentTypeCBItem : public CDLUIDataCBItem<CContentTypeData>
{
public:
    HRESULT GetText(LPWSTR pszText, DWORD cchText);
    HRESULT GetIconLocation(LPWSTR pszIconLocation,
        DWORD cchIconLocation);
};

class CHandlerCBItem : public CDLUIDataCBItem<CHandlerData>
{
    HRESULT GetText(LPWSTR pszText, DWORD cchText);
};

class CHandlerLVItem : public CDLUIDataLVItem<CHandlerData>
{
public:
    HRESULT GetText(LPWSTR pszText, DWORD cchText);
    HRESULT GetIconLocation(LPWSTR pszIconLocation,
        DWORD cchIconLocation);
    HRESULT GetTileText(int i, LPWSTR pszTileText,
        DWORD cchTileText);
};

HRESULT _SetHandlerDefault(LPWSTR* ppszHandlerDefault, LPCWSTR pszHandler);

#endif // APDLGLOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shdocvw\resdll\makefile.inc ===
$(O)\error.dls : ..\error.dlg
    $(C_PREPROCESSOR_NAME) /EP ..\error.dlg > $@

$(O)\error.dlx : $(O)\error.dls ..\dlg.pl
    perl ..\dlg.pl < $(O)\error.dls > $@

$(O)\about.dls : ..\about.dlg
    $(C_PREPROCESSOR_NAME) /EP ..\about.dlg > $@

$(O)\about.dlx : $(O)\about.dls ..\dlg.pl
    perl ..\dlg.pl < $(O)\about.dls > $@

$(O)\findinc.dls : ..\findinc.dlg ..\dialogs.dh
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP ..\findinc.dlg > $@

$(O)\findinc.dlx : $(O)\findinc.dls ..\dlg.pl
    echo //^<SCRIPT LANGUAGE="JavaScript"^> > $@
    perl ..\dlg.pl < $(O)\findinc.dls >> $@
    echo //^</SCRIPT^> >> $@

$(O)\find.dls : ..\find.dlg ..\dialogs.dh ..\findinc.dlg
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP ..\find.dlg > $@

$(O)\find.dlx : $(O)\find.dls ..\dlg.pl
    perl ..\dlg.pl < $(O)\find.dls > $@

$(O)\privacypolicy.dls : ..\privacypolicy.dlg ..\dialogs.dh
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP ..\privacypolicy.dlg > $@

$(O)\privacypolicy.dlx : $(O)\privacypolicy.dls ..\dlg.pl
    perl ..\dlg.pl < $(O)\privacypolicy.dls > $@

$(O)\bidifind.dls : ..\bidifind.dlg ..\dialogs.dh ..\findinc.dlg
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP ..\bidifind.dlg > $@

$(O)\bidifind.dlx : $(O)\bidifind.dls ..\dlg.pl
    perl ..\dlg.pl < $(O)\bidifind.dls > $@

$(O)\orgfav.dls : ..\orgfav.dlg
    $(C_PREPROCESSOR_NAME) /EP ..\orgfav.dlg > $@

$(O)\ieerror.dls : ..\ieerror.dlg
    $(C_PREPROCESSOR_NAME) /EP ..\ieerror.dlg > $@

$(O)\ieerror.dlx : $(O)\ieerror.dls ..\dlg.pl
    perl ..\dlg.pl < $(O)\ieerror.dls > $@

$(O)\anchbrws.pps : ..\anchbrws.ppg
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP ..\anchbrws.ppg > $@

$(O)\anchbrws.ppx: $(O)\anchbrws.pps
    perl ..\dlg.pl < $(O)\anchbrws.pps > $@

$(O)\docbrows.pps: ..\docbrows.ppg
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP ..\docbrows.ppg > $@

$(O)\docbrows.ppx : $(O)\docbrows.pps
    perl ..\dlg.pl < $(O)\docbrows.pps > $@

$(O)\imgbrows.pps : ..\imgbrows.ppg
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP ..\imgbrows.ppg > $@

$(O)\imgbrows.ppx : $(O)\imgbrows.pps
    perl ..\dlg.pl < $(O)\imgbrows.pps > $@

$(O)\analyze.dls : ..\analyze.dlg ..\dialogs.dh
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP ..\analyze.dlg > $@

$(O)\analyze.dlx : $(O)\analyze.dls ..\dlg.pl
    perl ..\dlg.pl < $(O)\analyze.dls > $@

$(O)\preview.dls : ..\preview.dlg ..\preview.h
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP ..\preview.dlg > $@

$(O)\preview.dlx : $(O)\preview.dls ..\dlg.pl
    perl ..\dlg.pl < $(O)\preview.dls > $@

$(O)\pstemplate.dls : ..\pstemplate.dlg
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP ..\pstemplate.dlg > $@

$(0)\PrivacyPolicyTransform.xsl : ..\PrivacyPolicyTransform.xsl

$(0)\PolicyLooking.htm : ..\PolicyLooking.htm

$(0)\PolicyNone.htm : ..\PolicyNone.htm

$(0)\PolicyError.htm : ..\PolicyError.htm

$(0)\PolicySyntaxError.htm : ..\PolicySyntaxError.htm

$(O)\pstemplate.dlx : $(O)\pstemplate.dls ..\dlg.pl
    perl ..\dlg.pl < $(O)\pstemplate.dls > $@

SHDOCLCR_DEP = \
    $(O)\error.dlx      \
    $(O)\about.dlx      \
    $(O)\findinc.dlx    \
    $(O)\find.dlx       \
    $(O)\privacypolicy.dlx  \
    $(O)\bidifind.dlx   \
    $(O)\orgfav.dls     \
    $(O)\ieerror.dlx    \
    $(O)\anchbrws.ppx   \
    $(O)\docbrows.ppx   \
    $(O)\imgbrows.ppx   \
    $(O)\analyze.dlx    \
    $(O)\preview.dlx    \
    $(0)\PrivacyPolicyTransform.xsl \
    $(0)\PolicyLooking.htm \
    $(0)\PolicyNone.htm \
    $(0)\PolicyError.htm \
    $(0)\PolicySyntaxError.htm \
    $(O)\pstemplate.dlx


..\shdoclc.rc : $(SHDOCLCR_DEP)

!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\apprmdlg.h ===
#ifndef HWPROMPT_H
#define HWPROMPT_H

#include "basedlg.h"
#include "apdlglog.h"

#include <dpa.h>

class CBaseContentDlg : public CBaseDlg
{
public:
    CBaseContentDlg();
    HRESULT Init(LPCWSTR pszDeviceID, LPCWSTR pszDeviceIDAlt,
        DWORD dwContentType, BOOL fCheckAlwaysDoThis);

    LPWSTR                          _pszDeviceID;
    WCHAR                           _szDeviceIDAlt[MAX_PATH];
    BOOL                            _fCheckAlwaysDoThis;

    WCHAR                           _szHandler[MAX_HANDLER];
    WCHAR                           _szContentTypeHandler[MAX_CONTENTTYPEHANDLER];
    HINSTANCE                       _hinst;
    int                             _iResource;
    HWND                            _hwndParent;
    DWORD                           _dwContentType;

protected:
    virtual ~CBaseContentDlg();
    LRESULT OnInitDialog(WPARAM wParam, LPARAM lParam);
    LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    LRESULT OnDestroy(WPARAM wParam, LPARAM lParam);

    virtual LRESULT OnOK(WORD wNotif);
    LRESULT OnCancel(WORD wNotif);

    virtual HRESULT _FillListView() PURE;
    virtual HRESULT _InitStatics() PURE;
    virtual HRESULT _InitSelections() PURE;
    virtual HRESULT _OnListSelChange() PURE;

    HRESULT _InitDeviceName();
    HRESULT _SetHandler();

    CUILListViewSelect<CHandlerData, LPCWSTR>   _uilListView;

    WCHAR                                       _szDeviceName[MAX_DEVICENAME];
    HICON                                       _hiconInfo;
    HICON                                       _hiconTop;

private:
    HRESULT _InitListView();
    HRESULT _InitStaticsCommon();

    HIMAGELIST                                  _himagelist;
};

///////////////////////////////////////////////////////////////////////////////
// Dialog to show when there is a dominant content and current setting is
// "prompt each time"
class CHWContentPromptDlg : public CBaseContentDlg
{
public:
    CHWContentPromptDlg();
    virtual ~CHWContentPromptDlg();

protected:
    // From CBaseContentDlg
    HRESULT _FillListView();
    HRESULT _InitStatics();
    HRESULT _InitSelections();
    HRESULT _OnListSelChange();

private:
    LRESULT OnOK(WORD wNotif);

    HRESULT _InitDataObjects();
    HRESULT _InitDominantContent();

    HRESULT _InitExistingSettings();
    HRESULT _SaveSettings(BOOL fSoftCommit);

    HRESULT _UpdateHandlerSettings();

    CContentTypeData                _data;
    CDLManager<CContentTypeData>    _dlmanager;
};

///////////////////////////////////////////////////////////////////////////////
// Dialog to show when there is mixed content and current setting is "prompt
// each time"
class CMixedContentDlg : public CBaseContentDlg
{
public:
    CMixedContentDlg();
    virtual ~CMixedContentDlg();

protected:
    LRESULT OnOK(WORD wNotif);

    // From CBaseContentDlg
    HRESULT _FillListView();
    HRESULT _InitStatics();
    HRESULT _InitSelections();
    HRESULT _OnListSelChange();

private:
    HRESULT _InitDataObjects();

    CDPA<CContentTypeData> _dpaContentTypeData;
};


///////////////////////////////////////////////////////////////////////////////
// Dialog to show when there is no content and current setting is "prompt
// each time"
class CNoContentDlg : public CBaseContentDlg
{
public:
    CNoContentDlg();
    virtual ~CNoContentDlg();

protected:
    // From CBaseContentDlg
    HRESULT _FillListView();
    HRESULT _InitStatics();
    HRESULT _InitSelections();
    HRESULT _OnListSelChange();

private:
    LRESULT OnOK(WORD wNotif);

    HRESULT _InitDataObjects();

    HRESULT _InitExistingSettings();
    HRESULT _SaveSettings(BOOL fSoftCommit);

    HRESULT _UpdateHandlerSettings();

    CNoContentData                  _data;
    CDLManager<CNoContentData>      _dlmanager;
};

#endif //HWPROMPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\ascstr.h ===
#ifndef ASCSTR_H
#define ASCSTR_H

#include "ftcmmn.h"

#define ASENUM                          DWORD
#define ASENUM_NONE                     0x00000000
#define ASENUM_EXT                      0x00000001
#define ASENUM_PROGID                   0x00000002
#define ASENUM_ACTION                   0x00000004
#define ASENUM_ASSOC_YES                0x10000000
#define ASENUM_ASSOC_NO                 0x20000000
#define ASENUM_ASSOC_ALL                (ASENUM_ASSOC_YES | ASENUM_ASSOC_NO)
#define ASENUM_NOEXCLUDED               0x40000000
#define ASENUM_NOEXPLORERSHELLACTION    0x80000000
#define ASENUM_NOEXE                    0x01000000
#define ASENUM_SHOWONLY                 0x02000000

#define ASENUM_MAINMASK                 0x00000007


#define AIINIT                          DWORD
#define AIINIT_NONE                     0x00000000
#define AIINIT_EXT                      0x00000001
#define AIINIT_PROGID                   0x00000002
#define AIINIT_ACTION                   0x00000004

// Watch out! Begin
// All flags in this section can be OR'ed with the other flags AIBOOL, AISTR, ...
// so keep these values "globally" unique.
#define AIALL                           DWORD
#define AIALL_NONE                      0x00000000
#define AIALL_PERUSER                   0x10000000
// Watch out! End

#define AISTR                           DWORD
#define AISTR_NONE                      0x00000000
// This returns an extension WITHOUT the dot
#define AISTR_EXT                       0x00000001 
// This returns an extension WITH the dot
#define AISTR_DOTEXT                    0x00000002
#define AISTR_PROGID                    0x00000004
#define AISTR_PROGIDDESCR               0x00000008
#define AISTR_APPPATH                   0x00000010
#define AISTR_APPFRIENDLY               0x00000020
#define AISTR_ACTION                    0x00000040
#define AISTR_PROGIDDEFAULTACTION       0x00000080
#define AISTR_ICONLOCATION              0x00000100
#define AISTR_ACTIONFRIENDLY            0x00000200

#define AIDWORD                         DWORD
#define AIDWORD_NONE                    0x00000000
#define AIDWORD_APPSMALLICON            0x00000001
#define AIDWORD_APPLARGEICON            0x00000002
#define AIDWORD_DOCSMALLICON            0x00000004
#define AIDWORD_DOCLARGEICON            0x00000008
#define AIDWORD_PROGIDEDITFLAGS         0x00000010
#define AIDWORD_ACTIONATTRIBUTES        0x00000020

#define AIBOOL                          DWORD
#define AIBOOL_CONFIRMOPEN              0x00000001
// removed quick view constant - dsheldon
#define AIBOOL_ALWAYSSHOWEXT            0x00000004
#define AIBOOL_BROWSEINPLACE            0x00000008
#define AIBOOL_BROWSEINPLACEENABLED     0x00000010
#define AIBOOL_EDITDESCR                0x00000020
#define AIBOOL_EDITDOCICON              0x00000040
#define AIBOOL_EDIT                     0x00000080
#define AIBOOL_EDITREMOVE               0x00000100
#define AIBOOL_EXTASSOCIATED            0x00000200
#define AIBOOL_EXTEXIST                 0x00000400
#define AIBOOL_EXCLUDE                  0x00000800
#define AIBOOL_SHOW                     0x00001000
#define AIBOOL_PERUSERINFOAVAILABLE     0x00002000
#define AIBOOL_PROGIDHASNOEXT           0x00004000

#define AIDATA                          DWORD
#define AIDATA_PROGIDACTION             0x00000001

class IAssocInfo : public IUnknown
{
public:
    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, PVOID* ppv) PURE;
    STDMETHOD_(ULONG, AddRef)() PURE;
    STDMETHOD_(ULONG,Release)() PURE;

    // IAssocInfo methods
    //  Init
    STDMETHOD(Init)(AIINIT aiinitFlags, LPTSTR pszStr) PURE;
    STDMETHOD(InitComplex)(AIINIT aiinitFlags1, LPTSTR pszStr1,
        AIINIT aiinitFlags2, LPTSTR pszStr2) PURE;
    //  Get
    STDMETHOD(GetString)(AISTR aistrFlags, LPTSTR pszStr, DWORD* cchStr) PURE;
    STDMETHOD(GetDWORD)(AIDWORD aidwordFlags, DWORD* pdwdata) PURE;
    STDMETHOD(GetBOOL)(AIDWORD aiboolFlags, BOOL* pfBool) PURE;
    STDMETHOD(GetData)(AIDWORD aidataFlags, PBYTE pbData, DWORD* pcbData) PURE;
    //  Set
    STDMETHOD(SetString)(AISTR aistrFlags, LPTSTR pszStr) PURE;
    STDMETHOD(SetDWORD)(AIDWORD aidwordFlags, DWORD dwData) PURE;
    STDMETHOD(SetBOOL)(AIDWORD aiboolFlags, BOOL fBool) PURE;
    STDMETHOD(SetData)(AIDWORD aidataFlags, PBYTE pbData, DWORD cbData) PURE;
    //  Create
    STDMETHOD(Create)() PURE;
    //  Delete
    STDMETHOD(DelString)(AISTR aistrFlags) PURE;
    STDMETHOD(Delete)(AIALL aiallFlags) PURE;
};

class IEnumAssocInfo : public IUnknown
{
public:
    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, PVOID* ppv) PURE;
    STDMETHOD_(ULONG, AddRef)() PURE;
    STDMETHOD_(ULONG, Release)() PURE;

    // IEnumAssocInfo methods
    //  Initialization
    STDMETHOD(Init)(ASENUM asenumFlags, LPTSTR pszStr,
        AIINIT aiinitFlags) PURE;

    //  Standard IEnum methods
    STDMETHOD(Next)(IAssocInfo** ppAI) PURE;
    STDMETHOD(Skip)(DWORD dwSkip) PURE;
    STDMETHOD(Reset)() PURE;
    STDMETHOD(Clone)(IEnumAssocInfo* pEnum) PURE;
};

class IAssocStore : public IUnknown
{
public:
    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, PVOID* ppv) PURE;
    STDMETHOD_(ULONG, AddRef)() PURE;
    STDMETHOD_(ULONG,Release)() PURE;

    // IAssocStore methods
    //  Enum
    STDMETHOD(EnumAssocInfo)(ASENUM asenumFlags, LPTSTR pszStr, 
        AIINIT aiinitFlags, IEnumAssocInfo** ppEnum) PURE;
    //  Get/Set
    STDMETHOD(GetAssocInfo)(LPTSTR pszStr, AIINIT aiinitFlags, 
        IAssocInfo** ppAI) PURE;
    STDMETHOD(GetComplexAssocInfo)(LPTSTR pszStr1, AIINIT aiinitFlags1, 
        LPTSTR pszStr2, AIINIT aiinitFlags2, IAssocInfo** ppAI) PURE;
    // 
    STDMETHOD(CheckAccess)() PURE;
};

#endif //ASCSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\apithk.c ===
// this file should not be needed anymore as we now compile for versions of NT > 500

#include "shellprv.h"
#include <appmgmt.h>
#include <userenv.h>
#include <devguid.h>
#include <dbt.h>

LPTSTR GetEnvBlock(HANDLE hUserToken)
{
    LPTSTR pszRet = NULL;
    if (hUserToken)
        CreateEnvironmentBlock(&pszRet, hUserToken, TRUE);
    else
        pszRet = (LPTSTR) GetEnvironmentStrings();
    return pszRet;
}

void FreeEnvBlock(HANDLE hUserToken, LPTSTR pszEnv)
{
    if (pszEnv)
    {
        if (hUserToken)
            DestroyEnvironmentBlock(pszEnv);
        else
            FreeEnvironmentStrings(pszEnv);
    }
}

STDAPI_(BOOL) GetAllUsersDirectory(LPTSTR pszPath)
{
    DWORD cbData = MAX_PATH;
    BOOL fRet = FALSE;

    // This is delay loaded. It can fail.
    __try 
    {
        fRet = GetAllUsersProfileDirectoryW(pszPath, &cbData);
    } 
    __except(EXCEPTION_EXECUTE_HANDLER)
    { 
        pszPath[0] = 0;
    }

    return fRet;
}


BOOL IsColorKey(RGBQUAD rgbPixel, COLORREF crKey)
{
    // COLORREF is backwards to RGBQUAD
    return InRange( rgbPixel.rgbBlue,  ((crKey & 0xFF0000) >> 16) - 5, ((crKey & 0xFF0000) >> 16) + 5) &&
           InRange( rgbPixel.rgbGreen, ((crKey & 0x00FF00) >>  8) - 5, ((crKey & 0x00FF00) >>  8) + 5) &&
           InRange( rgbPixel.rgbRed,   ((crKey & 0x0000FF) >>  0) - 5, ((crKey & 0x0000FF) >>  0) + 5);
}


typedef BOOL (* PFNUPDATELAYEREDWINDOW)
    (HWND hwnd, 
    HDC hdcDest,
    POINT *pptDst,
    SIZE *psize,
    HDC hdcSrc,
    POINT *pptSrc,
    COLORREF crKey,
    BLENDFUNCTION *pblend,
    DWORD dwFlags);

BOOL NT5_UpdateLayeredWindow(HWND hwnd, HDC hdcDest, POINT* pptDest, SIZE* psize, 
                        HDC hdcSrc, POINT* pptSrc, COLORREF crKey, BLENDFUNCTION* pblend, DWORD dwFlags)
{
    BOOL bRet = FALSE;
    static PFNUPDATELAYEREDWINDOW pfn = NULL;

    if (NULL == pfn)
    {
        HMODULE hmod = GetModuleHandle(TEXT("USER32"));
        
        if (hmod)
            pfn = (PFNUPDATELAYEREDWINDOW)GetProcAddress(hmod, "UpdateLayeredWindow");
    }

    if (pfn)
    {
        // The user implementation is poor and does not implement this functionality
        BITMAPINFO      bmi;
        HDC             hdcRGBA;
        HBITMAP         hbmRGBA;
        VOID*           pBits;
        LONG            i;
        BLENDFUNCTION   blend;
        ULONG*          pul;
        POINT           ptSrc;
 
        hdcRGBA = NULL;
 
        if ((dwFlags & (ULW_ALPHA | ULW_COLORKEY)) == (ULW_ALPHA | ULW_COLORKEY))
        {
            if (hdcSrc)
            {
                RtlZeroMemory(&bmi, sizeof(bmi));
        
                bmi.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
                bmi.bmiHeader.biWidth       = psize->cx;
                bmi.bmiHeader.biHeight      = psize->cy;
                bmi.bmiHeader.biPlanes      = 1;
                bmi.bmiHeader.biBitCount    = 32;
                bmi.bmiHeader.biCompression = BI_RGB;
        
                hbmRGBA = CreateDIBSection(hdcDest,
                                           &bmi,
                                           DIB_RGB_COLORS,
                                           &pBits,
                                           NULL,
                                           0);
                if (!hbmRGBA)
                    return FALSE;
    
                hdcRGBA = CreateCompatibleDC(hdcDest);
                if (!hdcRGBA)
                {
                    DeleteObject(hbmRGBA);
                    return FALSE;
                }
    
                SelectObject(hdcRGBA, hbmRGBA);
    
                BitBlt(hdcRGBA, 0, 0, psize->cx, psize->cy,
                       hdcSrc, pptSrc->x, pptSrc->y, SRCCOPY);
    
                pul = pBits;
    
                for (i = psize->cx * psize->cy; i != 0; i--)
                {
                    if (IsColorKey(*(RGBQUAD*)pul, crKey))
                    {
                        // Write a pre-multiplied value of 0:
 
                        *pul = 0;
                    }
                    else
                    {
                        // Where the bitmap is not the transparent color, change the
                        // alpha value to opaque:
    
                        ((RGBQUAD*) pul)->rgbReserved = 0xff;
                    }
    
                    pul++;
                }
 
                // Change the parameters to account for the fact that we're now
                // providing only a 32-bit per-pixel alpha source:
 
                ptSrc.x = 0;
                ptSrc.y = 0;
                pptSrc = &ptSrc;
                hdcSrc = hdcRGBA;
            }
 
            blend = *pblend;
            blend.AlphaFormat = AC_SRC_ALPHA;   
 
            pblend = &blend;
            dwFlags = ULW_ALPHA;
        }

        bRet = pfn(hwnd, hdcDest, pptDest, psize, hdcSrc, pptSrc, crKey, pblend, dwFlags);

        if (hdcRGBA)
        {
            DeleteObject(hdcRGBA);
            DeleteObject(hbmRGBA);
        }
    }
    return bRet;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\argvw.c ===
#define UNICODE 1

#include "shellprv.h"
#pragma  hdrstop

/***
*Purpose:
*       Parses the command line and sets up the Unicode argv[] array.
*       On entry, cmdstart should point to the command line,
*       argv should point to memory for the argv array, lpstr
*       points to memory to place the text of the arguments.
*       If these are NULL, then no storing (only counting)
*       is done.  On exit, *numargs has the number of
*       arguments (plus one for a final NULL argument),
*       and *numbytes has the number of bytes used in the buffer
*       pointed to by args.
*
*Entry:
*       LPWSTR cmdstart - pointer to command line of the form
*           <progname><nul><args><nul>
*       TCHAR **argv - where to build argv array; NULL means don't
*                      build array
*       LPWSTR lpstr - where to place argument text; NULL means don't
*                      store text
*
*Exit:
*       no return value
*       INT *numargs - returns number of argv entries created
*       INT *numbytes - number of bytes used in args buffer
*
*Exceptions:
*
*******************************************************************************/

void Parse_Cmdline (
    LPWSTR cmdstart,
    LPWSTR*argv,
    LPWSTR lpstr,
    INT *numargs,
    INT *numbytes
    )
{
    LPWSTR p;
    WCHAR c;
    INT inquote;                    /* 1 = inside quotes */
    INT copychar;                   /* 1 = copy char to *args */
    WORD numslash;                  /* num of backslashes seen */

    *numbytes = 0;
    *numargs = 1;                   /* the program name at least */

    /* first scan the program name, copy it, and count the bytes */
    p = cmdstart;
    if (argv)
        *argv++ = lpstr;

    /* A quoted program name is handled here. The handling is much
       simpler than for other arguments. Basically, whatever lies
       between the leading double-quote and next one, or a terminal null
       character is simply accepted. Fancier handling is not required
       because the program name must be a legal NTFS/HPFS file name.
       Note that the double-quote characters are not copied, nor do they
       contribute to numbytes. */
    if (*p == TEXT('\"'))
    {
        /* scan from just past the first double-quote through the next
           double-quote, or up to a null, whichever comes first */
        while ((*(++p) != TEXT('\"')) && (*p != TEXT('\0')))
        {
            *numbytes += sizeof(WCHAR);
            if (lpstr)
                *lpstr++ = *p;
        }
        /* append the terminating null */
        *numbytes += sizeof(WCHAR);
        if (lpstr)
            *lpstr++ = TEXT('\0');

        /* if we stopped on a double-quote (usual case), skip over it */
        if (*p == TEXT('\"'))
            p++;
    }
    else
    {
        /* Not a quoted program name */
        do {
            *numbytes += sizeof(WCHAR);
            if (lpstr)
                *lpstr++ = *p;

            c = (WCHAR) *p++;

        } while (c > TEXT(' '));

        if (c == TEXT('\0'))
        {
            p--;
        }
        else
        {
            if (lpstr)
                *(lpstr - 1) = TEXT('\0');
        }
    }

    inquote = 0;

    /* loop on each argument */
    for ( ; ; )
    {
        if (*p)
        {
            while (*p == TEXT(' ') || *p == TEXT('\t'))
                ++p;
        }

        if (*p == TEXT('\0'))
            break;                  /* end of args */

        /* scan an argument */
        if (argv)
            *argv++ = lpstr;         /* store ptr to arg */
        ++*numargs;

        /* loop through scanning one argument */
        for ( ; ; )
        {
            copychar = 1;
            /* Rules: 2N backslashes + " ==> N backslashes and begin/end quote
                      2N+1 backslashes + " ==> N backslashes + literal "
                      N backslashes ==> N backslashes */
            numslash = 0;
            while (*p == TEXT('\\'))
            {
                /* count number of backslashes for use below */
                ++p;
                ++numslash;
            }
            if (*p == TEXT('\"'))
            {
                /* if 2N backslashes before, start/end quote, otherwise
                   copy literally */
                if (numslash % 2 == 0)
                {
                    if (inquote)
                        if (p[1] == TEXT('\"'))
                            p++;    /* Double quote inside quoted string */
                        else        /* skip first quote char and copy second */
                            copychar = 0;
                    else
                        copychar = 0;       /* don't copy quote */

                    inquote = !inquote;
                }
                numslash /= 2;          /* divide numslash by two */
            }

            /* copy slashes */
            while (numslash--)
            {
                if (lpstr)
                    *lpstr++ = TEXT('\\');
                *numbytes += sizeof(WCHAR);
            }

            /* if at end of arg, break loop */
            if (*p == TEXT('\0') || (!inquote && (*p == TEXT(' ') || *p == TEXT('\t'))))
                break;

            /* copy character into argument */
            if (copychar)
            {
                if (lpstr)
                        *lpstr++ = *p;
                *numbytes += sizeof(WCHAR);
            }
            ++p;
        }

        /* null-terminate the argument */

        if (lpstr)
            *lpstr++ = TEXT('\0');         /* terminate string */
        *numbytes += sizeof(WCHAR);
    }

}


/***
*CommandLineToArgvW - set up Unicode "argv" for C programs
*
*Purpose:
*       Read the command line and create the argv array for C
*       programs.
*
*Entry:
*       Arguments are retrieved from the program command line
*
*Exit:
*       "argv" points to a null-terminated list of pointers to UNICODE
*       strings, each of which is an argument from the command line.
*       The list of pointers is also located on the heap or stack.
*
*Exceptions:
*       Terminates with out of memory error if no memory to allocate.
*
*******************************************************************************/

LPWSTR * CommandLineToArgvW (LPCWSTR lpCmdLine, int*pNumArgs)
{
    LPWSTR*argv_U;
    LPWSTR  cmdstart;                 /* start of command line to parse */
    INT     numbytes;
    WCHAR   pgmname[MAX_PATH];

    if (pNumArgs == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    /* Get the program name pointer from Win32 Base */

    GetModuleFileName (NULL, pgmname, sizeof(pgmname) / sizeof(WCHAR));

    /* if there's no command line at all (won't happen from cmd.exe, but
       possibly another program), then we use pgmname as the command line
       to parse, so that argv[0] is initialized to the program name */
    cmdstart = (*lpCmdLine == TEXT('\0')) ? pgmname : (LPWSTR) lpCmdLine;

    /* first find out how much space is needed to store args */
    Parse_Cmdline (cmdstart, NULL, NULL, pNumArgs, &numbytes);

    /* allocate space for argv[] vector and strings */
    argv_U = (LPWSTR*) LocalAlloc( LMEM_ZEROINIT,
                                   (*pNumArgs+1) * sizeof(LPWSTR) + numbytes);
    if (!argv_U) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return (NULL);
    }

    /* store args and argv ptrs in just allocated block */
    Parse_Cmdline (cmdstart, argv_U,
                   (LPWSTR) (((LPBYTE)argv_U) + *pNumArgs * sizeof(LPWSTR)),
                   pNumArgs, &numbytes);

    return (argv_U);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\apithk.h ===
#ifndef _APITHK_H_
#define _APITHK_H_

#include <appmgmt.h>
#include <aclapi.h>
#include <userenv.h>

LPTSTR GetEnvBlock(HANDLE hUserToken);
void FreeEnvBlock(HANDLE hUserToken, LPTSTR pszEnv);
STDAPI_(BOOL) GetAllUsersDirectory(LPTSTR pszPath);

#define PrivateVOLUME_UPGRADE_SCHEDULED         (0x00000002)

#define KEYBOARDCUES
#ifdef KEYBOARDCUES
#define PrivateWM_CHANGEUISTATE     0x0127
#define PrivateWM_UPDATEUISTATE     0x0128
#define PrivateWM_QUERYUISTATE      0x0129
#define PrivateUIS_SET              1
#define PrivateUIS_CLEAR            2
#define PrivateUIS_INITIALIZE       3
#define PrivateUISF_HIDEFOCUS       0x1
#define PrivateUISF_HIDEACCEL       0x2
#endif //KEYBOARDCUES

#define PrivateULW_COLORKEY            0x00000001
#define PrivateULW_ALPHA               0x00000002
#define PrivateULW_OPAQUE              0x00000004
#define PrivateWS_EX_LAYERED           0x00080000

#if (_WIN32_WINNT >= 0x0500)

// for files in nt5api dirs, use the definition in sdk include.
// And make sure our private define is in sync with winuser.h.

#if WS_EX_LAYERED != PrivateWS_EX_LAYERED
#error inconsistant WS_EX_LAYERED in winuser.h
#endif

#else   // (_WIN32_WINNT >= 0x0500)

#define WS_EX_LAYERED           PrivateWS_EX_LAYERED
#define UpdateLayeredWindow     NT5_UpdateLayeredWindow 
#define ULW_COLORKEY            PrivateULW_COLORKEY
#define ULW_ALPHA               PrivateULW_ALPHA
#define ULW_OPAQUE              PrivateULW_OPAQUE
#define WM_CHANGEUISTATE        PrivateWM_CHANGEUISTATE 
#define WM_UPDATEUISTATE        PrivateWM_UPDATEUISTATE 
#define WM_QUERYUISTATE         PrivateWM_QUERYUISTATE  
#define UIS_SET                 PrivateUIS_SET          
#define UIS_CLEAR               PrivateUIS_CLEAR        
#define UIS_INITIALIZE          PrivateUIS_INITIALIZE   
#define UISF_HIDEFOCUS          PrivateUISF_HIDEFOCUS
#define UISF_HIDEACCEL          PrivateUISF_HIDEACCEL   

#endif  // (_WIN32_WINNT >= 0x0500)

// These functions add value in addition to delayloading
STDAPI_(BOOL) NT5_UpdateLayeredWindow(HWND hwnd, HDC hdcDest, POINT* pptDest, SIZE* psize, 
                        HDC hdcSrc, POINT* pptSrc, COLORREF crKey, BLENDFUNCTION* pbf, DWORD dwFlags);


#endif // _APITHK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\apprmdlg.cpp ===
#include "shellprv.h"
#include "ids.h"

#include "apprmdlg.h"

#include "mtpt.h"
#include "hwcmmn.h"

#include "mixctnt.h"

static DWORD s_rgdwHelpIDsArray[] =
{  // Context Help IDs
    IDC_AP_MXCT_TOPICON,              NO_HELP,
    IDC_AP_MXCT_TOPTEXT,              NO_HELP,
    IDC_AP_MXCT_TOPTEXT2,              NO_HELP,
    IDC_AP_MXCT_LIST,              NO_HELP,
    IDC_AP_MXCT_CHECKBOX,              NO_HELP,
    0, 0
};

CBaseContentDlg::CBaseContentDlg() : CBaseDlg((ULONG_PTR)s_rgdwHelpIDsArray),
    _pszDeviceID(NULL), _hiconInfo(NULL), _hiconTop(NULL)
{}

CBaseContentDlg::~CBaseContentDlg()
{
    if (_pszDeviceID)
    {
        LocalFree((HLOCAL)_pszDeviceID);
    }

    if (_hiconInfo)
    {
        DestroyIcon(_hiconInfo);
    }

    if (_hiconTop)
    {
        DestroyIcon(_hiconTop);
    }
}

HRESULT CBaseContentDlg::_SetHandler()
{
    CHandlerData* phandlerdata;
    HRESULT hr = _uilListView.GetSelectedItemData(&phandlerdata);

    if (SUCCEEDED(hr))
    {
        lstrcpyn(_szHandler, phandlerdata->_pszHandler,
            ARRAYSIZE(_szHandler));

        phandlerdata->Release();
    }

    return hr;
}   

HRESULT CBaseContentDlg::Init(LPCWSTR pszDeviceID, LPCWSTR pszDeviceIDAlt,
    DWORD dwContentType, BOOL fCheckAlwaysDoThis)
{
    HRESULT hr = E_INVALIDARG;

    _fCheckAlwaysDoThis = fCheckAlwaysDoThis;

    if (pszDeviceID)
    {
        _pszDeviceID = StrDup(pszDeviceID);

        if (_pszDeviceID)
        {
            _szDeviceIDAlt[0] = 0;

            if (pszDeviceIDAlt)
            {
                if (InRange(*pszDeviceIDAlt, 'a', 'z') ||
                    InRange(*pszDeviceIDAlt, 'A', 'Z'))
                {
                    lstrcpyn(_szDeviceIDAlt, pszDeviceIDAlt,
                        ARRAYSIZE(_szDeviceIDAlt));

                    _dwContentType = dwContentType;

                    hr = _GetContentTypeHandler(dwContentType, _szContentTypeHandler,
                        ARRAYSIZE(_szContentTypeHandler));
                }
            }

            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }    
    }
        
    return hr;
}

#define COL_ACTION      0
#define COL_PROVIDER    1

const UINT c_auTileColumns[] = {COL_ACTION, COL_PROVIDER};
const UINT c_auTileSubItems[] = {COL_PROVIDER};

HRESULT CBaseContentDlg::_InitListView()
{
    HWND hwndList = GetDlgItem(_hwnd, IDC_AP_MXCT_LIST);

    HRESULT hr = _uilListView.Init(hwndList);

    if (SUCCEEDED(hr))
    {
        hr = _uilListView.InitTileInfo(c_auTileSubItems, ARRAYSIZE(c_auTileSubItems));

        if (SUCCEEDED(hr))
        {
            RECT rc = {0};
            LVTILEVIEWINFO lvtvi = {0};
            HIMAGELIST himagelist;

            ListView_SetView(hwndList, LV_VIEW_TILE);

            for (int i = 0; i < ARRAYSIZE(c_auTileColumns); ++i)
            {
                LVCOLUMN lvcolumn = {0};

                lvcolumn.mask = LVCF_SUBITEM;
                lvcolumn.iSubItem = c_auTileColumns[i];
                ListView_InsertColumn(hwndList, i, &lvcolumn);
            }

            GetClientRect(hwndList, &rc);

            lvtvi.cbSize = sizeof(LVTILEVIEWINFO);
            lvtvi.dwMask = LVTVIM_TILESIZE | LVTVIM_COLUMNS;
            lvtvi.dwFlags = LVTVIF_FIXEDWIDTH;
    
            // Leave room for the scroll bar when setting tile sizes or listview gets screwed up.
            lvtvi.sizeTile.cx = ((rc.right - rc.left) - GetSystemMetrics(SM_CXVSCROLL));
            lvtvi.cLines = ARRAYSIZE(c_auTileSubItems);
            ListView_SetTileViewInfo(hwndList, &lvtvi);

            Shell_GetImageLists(&himagelist, NULL);

            if (himagelist)
            {
                ListView_SetImageList(hwndList, himagelist, LVSIL_NORMAL);
                hr = S_OK;
            }
        }
    }

    return hr;
}

LRESULT CBaseContentDlg::OnInitDialog(WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = _InitListView();

    if (SUCCEEDED(hr))
    {
        hr = _FillListView();

        if (SUCCEEDED(hr))
        {
            hr = _InitStaticsCommon();

            if (SUCCEEDED(hr))
            {
                hr = _InitStatics();

                if (SUCCEEDED(hr))
                {
                    hr = _InitSelections();
                }
            }
        }
    }

    if (_szDeviceIDAlt[0])
    {
        _SetAutoplayPromptHWND(_szDeviceIDAlt, _hwnd);
    }

    return TRUE;
}

LRESULT CBaseContentDlg::OnNotify(WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = FALSE;

    LPNMHDR pNMHDR = (NMHDR *)lParam;
    UINT_PTR idFrom = pNMHDR->idFrom;
    UINT uCode = pNMHDR->code;

    switch (idFrom)
    {
    case IDC_AP_MXCT_LIST:

        if (LVN_ITEMCHANGED == uCode)
        {
            NMLISTVIEW* pNMLV = (NMLISTVIEW*)pNMHDR;

            // Is a new item being selected/unselected?
            if (pNMLV->uChanged & LVIF_STATE)
            {
                // Yes
                _OnListSelChange();
            }
        }
        else if (NM_DBLCLK == uCode)
        {
            OnOK(0);
        }

        lRes = CBaseDlg::OnNotify(wParam, lParam);
        break;

    default:
        lRes = CBaseDlg::OnNotify(wParam, lParam);
        break;
    }

    return lRes;    
}

LRESULT CBaseContentDlg::OnDestroy(WPARAM wParam, LPARAM lParam)
{
    _uilListView.ResetContent();

    return CBaseDlg::OnDestroy(wParam, lParam);
}

LRESULT CBaseContentDlg::OnOK(WORD wNotif)
{
    // Wait cursor...  
    EndDialog(_hwnd, IDOK);
    
    return FALSE;
}

LRESULT CBaseContentDlg::OnCancel(WORD wNotif)
{
    EndDialog(_hwnd, IDCANCEL);

    return FALSE;
}

HRESULT CBaseContentDlg::_InitStaticsCommon()
{
    // Initialize _szDeviceName to something
    HRESULT hr = _InitDeviceName();

    if (SUCCEEDED(hr))
    {
        SetWindowText(_hwnd, _szDeviceName);
    }

    if (_fCheckAlwaysDoThis)
    {
        Button_SetCheck(GetDlgItem(_hwnd, IDC_AP_MXCT_CHECKBOX), _fCheckAlwaysDoThis);
    }

    if (_szDeviceIDAlt[0])
    {
        // Initialize _szDeviceName to something
        CMountPoint* pmtpt = CMountPoint::GetMountPoint(_szDeviceIDAlt);

        if (pmtpt)
        {
            WCHAR szIconLocation[MAX_PATH + 12];
            int iIcon = pmtpt->GetIcon(szIconLocation, ARRAYSIZE(szIconLocation));

            if (SUCCEEDED(hr))
            {
                if (!szIconLocation[0])
                {
                    lstrcpy(szIconLocation, TEXT("shell32.dll"));
                }

                int iImage = Shell_GetCachedImageIndex(szIconLocation, iIcon, 0);

                HIMAGELIST himagelist;

                if ((-1 != iImage) && Shell_GetImageLists(&himagelist, NULL))
                {
                    _hiconTop = ImageList_GetIcon(himagelist, iImage, ILD_TRANSPARENT);

                    SendDlgItemMessage(_hwnd, IDC_AP_MXCT_TOPICON, STM_SETIMAGE,
                        IMAGE_ICON, (LPARAM)_hiconTop);
                }
            }

            pmtpt->Release();
        }
    }

    return hr;
}

HRESULT CBaseContentDlg::_InitDeviceName()
{
    HRESULT hr = E_FAIL;

    if (_szDeviceIDAlt[0])
    {
        CMountPoint* pmtpt = CMountPoint::GetMountPoint(_szDeviceIDAlt);

        if (pmtpt)
        {
            hr = pmtpt->GetDisplayName(_szDeviceName, ARRAYSIZE(_szDeviceName));

            pmtpt->Release();
        }
    }
    
    if (FAILED(hr))
    {
        GetWindowText(_hwnd, _szDeviceName, ARRAYSIZE(_szDeviceName));
        hr = S_FALSE;
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
CHWContentPromptDlg::CHWContentPromptDlg() : CBaseContentDlg()
{}
      
CHWContentPromptDlg::~CHWContentPromptDlg()
{}

HRESULT CHWContentPromptDlg::_InitDataObjects()
{
    HRESULT hr = _data.Init(_pszDeviceID, _dwContentType);

    if (SUCCEEDED(hr))
    {
        hr = _dlmanager.AddDataObject(&_data);
    }

    return hr;
}

HRESULT CHWContentPromptDlg::_FillListView()
{
    HRESULT hr = _InitDataObjects();

    if (SUCCEEDED(hr))
    {
        int c = _data.GetHandlerCount();
        for (int i = 0; SUCCEEDED(hr) && (i < c); ++i)
        {
            CHandlerData* phandlerdata = _data.GetHandlerData(i);
            if (phandlerdata)
            {
                CHandlerLVItem* puidata = new CHandlerLVItem();

                if (puidata)
                {
                    hr = puidata->InitData(phandlerdata);

                    if (SUCCEEDED(hr))
                    {
                        hr = _uilListView.AddItem(puidata);
                    }

                    if (FAILED(hr))
                    {
                        delete puidata;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                phandlerdata->Release();
            }
        }
    }

    return hr;
}

HRESULT CHWContentPromptDlg::_InitStatics()
{
    // Set content icon
    if (_hiconTop)
    {
        DestroyIcon(_hiconTop);
    }

    _hiconTop = _GetIconFromIconLocation(_data._szIconLocation, FALSE);

    SendDlgItemMessage(_hwnd, IDC_AP_MXCT_CONTENTICON, STM_SETIMAGE,
        IMAGE_ICON, (LPARAM)_hiconTop);

    // Set content name
    SetDlgItemText(_hwnd, IDC_AP_MXCT_CONTENTTYPE, _data._szIconLabel);

    return S_OK;
}

HRESULT CHWContentPromptDlg::_InitSelections()
{
    HRESULT hr;
    
    if (_data._pszHandlerDefaultOriginal && *(_data._pszHandlerDefaultOriginal))
    {
        hr = _uilListView.SelectItem(_data._pszHandlerDefaultOriginal);
    }
    else
    {
        hr = _uilListView.SelectFirstItem();
    }

    if (SUCCEEDED(hr))
    {
        CHandlerData* phandlerdata;

        hr = _uilListView.GetSelectedItemData(&phandlerdata);

        if (SUCCEEDED(hr))
        {
            lstrcpyn(_szHandler, phandlerdata->_pszHandler,
                ARRAYSIZE(_szHandler));

            _SetHandlerDefault(&(_data._pszHandlerDefault), phandlerdata->_pszHandler);

            phandlerdata->Release();
        }
    }

    Button_SetCheck(GetDlgItem(_hwnd, IDC_AP_MXCT_CHECKBOX), _fCheckAlwaysDoThis);

    return hr;
}

HRESULT CHWContentPromptDlg::_UpdateHandlerSettings()
{
    CHandlerData* phandlerdata;
    HRESULT hr = _uilListView.GetSelectedItemData(&phandlerdata);

    if (SUCCEEDED(hr))
    {
        _SetHandlerDefault(&(_data._pszHandlerDefault), phandlerdata->_pszHandler);

        phandlerdata->Release();
    }

    return hr;
}

HRESULT CHWContentPromptDlg::_OnListSelChange()
{
    return _UpdateHandlerSettings();
}

LRESULT CHWContentPromptDlg::OnOK(WORD wNotif)
{
    if (BST_CHECKED == Button_GetCheck(GetDlgItem(_hwnd, IDC_AP_MXCT_CHECKBOX)))
    {
        _SaveSettings(FALSE);

        // return value????
    }
    else
    {
        _SaveSettings(TRUE);
    }

    _SetHandler();

    // Do default processing
    return CBaseContentDlg::OnOK(wNotif);
}

HRESULT CHWContentPromptDlg::_SaveSettings(BOOL fSoftCommit)
{
    _data._fSoftCommit = fSoftCommit;

    return _dlmanager.Commit();
}

CMixedContentDlg::CMixedContentDlg() : _dpaContentTypeData(NULL)
{
}
      
CMixedContentDlg::~CMixedContentDlg()
{
    if (_dpaContentTypeData)
    {
        int c = _dpaContentTypeData.GetPtrCount();

        for (int i = 0; i < c; ++i)
        {
            CContentTypeData* pdata = _dpaContentTypeData.GetPtr(i);
            pdata->Release();
        }

        _dpaContentTypeData.Destroy();
    }
}

const DWORD c_rgdwContentTypeAutoplay[] =
{
    CT_AUTOPLAYMUSIC,
    CT_AUTOPLAYPIX,
    CT_AUTOPLAYMOVIE,
};

HRESULT CMixedContentDlg::_InitDataObjects()
{
    HRESULT hr = _dpaContentTypeData.Create(4) ? S_OK : E_OUTOFMEMORY;
    if (SUCCEEDED(hr))
    {
        for (DWORD dw = 0; dw < ARRAYSIZE(c_rgdwContentTypeAutoplay); ++dw)
        {
            if (_dwContentType & c_rgdwContentTypeAutoplay[dw])
            {
                CContentTypeData* pdata = new CContentTypeData();

                if (pdata)
                {
                    hr = pdata->Init(_pszDeviceID, _dwContentType & c_rgdwContentTypeAutoplay[dw]);

                    if (SUCCEEDED(hr))
                    {
                        if (-1 == _dpaContentTypeData.AppendPtr(pdata))
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }

                    if (FAILED(hr))
                    {
                        pdata->Release();
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            // Eliminate the duplicates.  Go thru all the content types
            // and then thru all their handlers and see if their would
            // not be two duplicate handlers that were brought by two diff
            // content type.  E.g.: Open folder is registered for music,
            // pictures and video
            int cContentType = _dpaContentTypeData.GetPtrCount();

            for (int iContentType = 0; iContentType < cContentType; ++iContentType)
            {
                CContentTypeData* pdata = _dpaContentTypeData.GetPtr(iContentType);

                if (pdata)
                {
                    int cHandler = pdata->GetHandlerCount();
                    for (int iHandler = 0; iHandler < cHandler; ++iHandler)
                    {
                        CHandlerData* phandlerdata = pdata->GetHandlerData(iHandler);
                        if (phandlerdata)
                        {
                            for (int iContentTypeInner = 0;
                                iContentTypeInner < cContentType;
                                ++iContentTypeInner)
                            {
                                BOOL fExitInnerLoop = FALSE;

                                // Cannot have duplicate handler within same content type
                                if (iContentTypeInner != iContentType)
                                {
                                    CContentTypeData* pdataInner = _dpaContentTypeData.GetPtr(iContentTypeInner);
                                    if (pdataInner)
                                    {
                                        int cHandlerInner = pdataInner->GetHandlerCount();
                                        for (int iHandlerInner = 0;
                                            !fExitInnerLoop && (iHandlerInner < cHandlerInner);
                                            ++iHandlerInner)
                                        {
                                            CHandlerData* phandlerdataInner = pdataInner->GetHandlerData(iHandlerInner);
                                            if (phandlerdataInner)
                                            {
                                                if (!lstrcmp(phandlerdataInner->_pszHandler,
                                                    phandlerdata->_pszHandler))
                                                {
                                                    pdataInner->RemoveHandler(iHandlerInner);
                                                    // Can be only one duplicate for a
                                                    // handler within another content type
                                                    fExitInnerLoop = TRUE;
                                                }
                                                phandlerdataInner->Release();
                                            }
                                        }
                                    }
                                }
                            }
                            phandlerdata->Release();
                        }
                    }
                }
            }
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CMixedContentDlg::_FillListView()
{
    HRESULT hr = _InitDataObjects();

    if (SUCCEEDED(hr))
    {
        if (_dpaContentTypeData)
        {
            int c = _dpaContentTypeData.GetPtrCount();

            for (int i = 0; SUCCEEDED(hr) && (i < c); ++i)
            {
                CContentTypeData* pdata = _dpaContentTypeData.GetPtr(i);

                if (pdata)
                {
                    pdata->AddRef();

                    int cHandler = pdata->GetHandlerCount();
                    for (int j = 0; SUCCEEDED(hr) && (j < cHandler); ++j)
                    {
                        CHandlerData* phandlerdata = pdata->GetHandlerData(j);
                        if (phandlerdata)
                        {
                            CHandlerLVItem* puidata = new CHandlerLVItem();

                            if (puidata)
                            {
                                hr = puidata->InitData(phandlerdata);

                                if (SUCCEEDED(hr))
                                {
                                    hr = _uilListView.AddItem(puidata);
                                }

                                if (FAILED(hr))
                                {
                                    delete puidata;
                                }
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                            }

                            phandlerdata->Release();
                        }
                    }

                    pdata->Release();
                }
            }
        }
    }

    return hr;
}

HRESULT CMixedContentDlg::_InitStatics()
{
    return S_OK;
}

HRESULT CMixedContentDlg::_InitSelections()
{
    HRESULT hr = _uilListView.SelectFirstItem();

    if (SUCCEEDED(hr))
    {
        CHandlerData* phandlerdata;

        hr = _uilListView.GetSelectedItemData(&phandlerdata);

        if (SUCCEEDED(hr))
        {
            lstrcpyn(_szHandler, phandlerdata->_pszHandler,
                ARRAYSIZE(_szHandler));

            phandlerdata->Release();
        }
    }

    return hr;
}

HRESULT CMixedContentDlg::_OnListSelChange()
{
    return S_OK;
}

LRESULT CMixedContentDlg::OnOK(WORD wNotif)
{
    _SetHandler();

    if (_dpaContentTypeData)
    {
        BOOL fFound = FALSE;
        int c = _dpaContentTypeData.GetPtrCount();

        for (int i = 0; !fFound && (i < c); ++i)
        {
            CContentTypeData* pdata = _dpaContentTypeData.GetPtr(i);

            if (pdata)
            {
                pdata->AddRef();
                int cHandler = pdata->GetHandlerCount();
                for (int j = 0; !fFound && (j < cHandler); ++j)
                {
                    CHandlerData* phandlerdata = pdata->GetHandlerData(j);
                    if (phandlerdata)
                    {
                        if (!lstrcmp(phandlerdata->_pszHandler,
                            _szHandler))
                        {
                            lstrcpyn(_szContentTypeHandler,
                                pdata->_szContentTypeHandler,
                                ARRAYSIZE(_szContentTypeHandler));

                            fFound = TRUE;
                        }

                        phandlerdata->Release();
                    }
                }

                pdata->Release();
            }
        }
    }
    
    // Do default processing
    return CBaseContentDlg::OnOK(wNotif);
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
CNoContentDlg::CNoContentDlg() : CBaseContentDlg()
{}
      
CNoContentDlg::~CNoContentDlg()
{}

HRESULT CNoContentDlg::_InitDataObjects()
{
    HRESULT hr = _data.Init(_pszDeviceID);

    if (SUCCEEDED(hr))
    {
        hr = _dlmanager.AddDataObject(&_data);
    }

    _SetAutoplayPromptHWND(_pszDeviceID, _hwnd);

    return hr;
}

HRESULT CNoContentDlg::_FillListView()
{
    HRESULT hr = _InitDataObjects();

    if (SUCCEEDED(hr))
    {
        int c = _data.GetHandlerCount();
        for (int i = 0; SUCCEEDED(hr) && (i < c); ++i)
        {
            CHandlerData* phandlerdata = _data.GetHandlerData(i);
            if (phandlerdata)
            {
                CHandlerLVItem* puidata = new CHandlerLVItem();

                if (puidata)
                {
                    hr = puidata->InitData(phandlerdata);

                    if (SUCCEEDED(hr))
                    {
                        hr = _uilListView.AddItem(puidata);
                    }

                    if (FAILED(hr))
                    {
                        delete puidata;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                phandlerdata->Release();
            }
        }
    }

    return hr;
}

HRESULT CNoContentDlg::_InitStatics()
{
    if (_hiconTop)
    {
        DestroyIcon(_hiconTop);
    }

    // Set device icon
    _hiconTop = _GetIconFromIconLocation(_data._pszIconLocation, TRUE);

    SendDlgItemMessage(_hwnd, IDC_AP_MXCT_TOPICON, STM_SETIMAGE,
        IMAGE_ICON, (LPARAM)_hiconTop);
    
    // Set device name
    SetWindowText(_hwnd, _data._pszIconLabel);

    return S_OK;
}

HRESULT CNoContentDlg::_InitSelections()
{
    HRESULT hr;
    
    if (_data._pszHandlerDefaultOriginal && *(_data._pszHandlerDefaultOriginal))
    {
        hr = _uilListView.SelectItem(_data._pszHandlerDefaultOriginal);
    }
    else
    {
        hr = _uilListView.SelectFirstItem();
    }

    if (SUCCEEDED(hr))
    {
        CHandlerData* phandlerdata;

        hr = _uilListView.GetSelectedItemData(&phandlerdata);

        if (SUCCEEDED(hr))
        {
            lstrcpyn(_szHandler, phandlerdata->_pszHandler,
                ARRAYSIZE(_szHandler));

            _SetHandlerDefault(&(_data._pszHandlerDefault), phandlerdata->_pszHandler);

            phandlerdata->Release();
        }
    }

    Button_SetCheck(GetDlgItem(_hwnd, IDC_AP_MXCT_CHECKBOX), _fCheckAlwaysDoThis);

    return hr;
}

HRESULT CNoContentDlg::_UpdateHandlerSettings()
{
    CHandlerData* phandlerdata;
    HRESULT hr = _uilListView.GetSelectedItemData(&phandlerdata);

    if (SUCCEEDED(hr))
    {
        _SetHandlerDefault(&(_data._pszHandlerDefault), phandlerdata->_pszHandler);

        phandlerdata->Release();
    }

    return hr;
}

HRESULT CNoContentDlg::_OnListSelChange()
{
    return _UpdateHandlerSettings();
}

LRESULT CNoContentDlg::OnOK(WORD wNotif)
{
    if (BST_CHECKED == Button_GetCheck(GetDlgItem(_hwnd, IDC_AP_MXCT_CHECKBOX)))
    {
        _SaveSettings(FALSE);

        // return value????
    }
    else
    {
        _SaveSettings(TRUE);
    }

    _SetHandler();

    // Do default processing
    return CBaseContentDlg::OnOK(wNotif);
}

HRESULT CNoContentDlg::_SaveSettings(BOOL fSoftCommit)
{
    _data._fSoftCommit = fSoftCommit;

    return _dlmanager.Commit();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\assocarray.cpp ===
#include "shellprv.h"
#include <dpa.h>
#include <enumt.h>

typedef HRESULT (*PFNELEMCREATE)(const CLSID *pclsid, PCWSTR pszClass, IAssociationElement **ppae);

typedef struct _AEINFO
{
    ASSOCELEM_MASK mask;
    const CLSID *pclsid;
    PCWSTR pszClass;       //  NULL indicates to use the _pszClass
    PFNELEMCREATE pfnCreate;
    IAssociationElement *pae;
} AEINFO;

typedef enum
{
    GETELEM_RETRY       = -2,
    GETELEM_DONE        = -1,
    GETELEM_TRYNEXT     = 0,
    GETELEM_SUCCEEDED   = 1,
}GETELEMRESULT;

#define TRYNEXT(gr)     ((gr) >= GETELEM_TRYNEXT)


HRESULT _QueryString(IAssociationElement *pae, ASSOCQUERY query, PCWSTR pszCue, PWSTR *ppsz, const IID *piid)
{
    return pae->QueryString(query, pszCue, ppsz);
}

HRESULT _QueryDirect(IAssociationElement *pae, ASSOCQUERY query, PCWSTR pszCue, FLAGGED_BYTE_BLOB **ppblob, const IID *piid)
{
    return pae->QueryDirect(query, pszCue, ppblob);
}

HRESULT _QueryDword(IAssociationElement *pae, ASSOCQUERY query, PCWSTR pszCue, DWORD *pdw, const IID *piid)
{
    return pae->QueryDword(query, pszCue, pdw);
}

HRESULT _QueryExists(IAssociationElement *pae, ASSOCQUERY query, PCWSTR pszCue, void *pv, const IID *piid)
{
    return pae->QueryExists(query, pszCue);
}

HRESULT _QueryObject(IAssociationElement *pae, ASSOCQUERY query, PCWSTR pszCue, void **ppv, const IID *piid)
{
    return pae->QueryObject(query, pszCue, *piid, ppv);
}


class CAssocArray : public IAssociationArray,
                    public IAssociationArrayInitialize,
                    public IQueryAssociations

{
public:
    CAssocArray() : _cRef(1), _hrInit(-1), _maskInclude(-1) {}
    ~CAssocArray() { _Reset(); }
    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef()
    {
       return ++_cRef;
    }

    STDMETHODIMP_(ULONG) Release()
    {
        if (--_cRef > 0)
            return _cRef;

        delete this;
        return 0;    
    }

    //  IAssociationArrayInitialize
    STDMETHODIMP InitClassElements(
        ASSOCELEM_MASK maskBase, 
        PCWSTR pszClass);
        
    STDMETHODIMP InsertElements(
        ASSOCELEM_MASK mask, 
        IEnumAssociationElements *peae);

    STDMETHODIMP FilterElements(ASSOCELEM_MASK maskInclude)
        { _maskInclude = maskInclude; return S_OK; }
        
    //  IAssociationArray
    STDMETHODIMP EnumElements(
        ASSOCELEM_MASK mask, 
        IEnumAssociationElements **ppeae);

    STDMETHODIMP QueryString(
        ASSOCELEM_MASK mask, 
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        PWSTR *ppsz)
        {
            return _QueryElementAny(_QueryString, mask, query, pszCue, ppsz, NULL);
        }

    STDMETHODIMP QueryDword(
        ASSOCELEM_MASK mask, 
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        DWORD *pdw)
        {
            return _QueryElementAny(_QueryDword, mask, query, pszCue, pdw, NULL);
        }

    STDMETHODIMP QueryDirect(
        ASSOCELEM_MASK mask, 
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        FLAGGED_BYTE_BLOB **ppblob)
        {
            return _QueryElementAny(_QueryDirect, mask, query, pszCue, ppblob, NULL);
        }

    STDMETHODIMP QueryExists(
        ASSOCELEM_MASK mask, 
        ASSOCQUERY query, 
        PCWSTR pszCue)
        {
            return _QueryElementAny(_QueryExists, mask, query, pszCue, (void*)NULL, NULL);
        }

    STDMETHODIMP QueryObject(
        ASSOCELEM_MASK mask, 
        ASSOCQUERY query, 
        PCWSTR pszCue, 
        REFIID riid,
        void **ppv)
        {
            return _QueryElementAny(_QueryObject, mask, query, pszCue, ppv, &riid);
        }

    // IQueryAssociations methods
    STDMETHODIMP Init(ASSOCF flags, LPCTSTR pszAssoc, HKEY hkProgid, HWND hwnd);
    STDMETHODIMP GetString(ASSOCF flags, ASSOCSTR str, LPCWSTR pszExtra, LPWSTR pszOut, DWORD *pcchOut);
    STDMETHODIMP GetKey(ASSOCF flags, ASSOCKEY, LPCWSTR pszExtra, HKEY *phkeyOut);
    STDMETHODIMP GetData(ASSOCF flags, ASSOCDATA data, LPCWSTR pszExtra, LPVOID pvOut, DWORD *pcbOut);
    STDMETHODIMP GetEnum(ASSOCF flags, ASSOCENUM assocenum, LPCWSTR pszExtra, REFIID riid, LPVOID *ppvOut)
        { return E_NOTIMPL; }


    GETELEMRESULT GetElement(int i, ASSOCELEM_MASK mask, IAssociationElement **ppae);

protected:  // methods
    void _Reset();
    HRESULT _InsertSingleElement(IAssociationElement *pae);
    HRESULT _GetCachedVerbElement(ASSOCELEM_MASK mask, PCWSTR pszVerb, IAssociationElement **ppaeVerb, IAssociationElement **ppaeElem);
    void _SetCachedVerbElement(ASSOCELEM_MASK mask, PCWSTR pszVerb, IAssociationElement *paeVerb, IAssociationElement *paeVerbParent);
    GETELEMRESULT _GetElement(int i, ASSOCELEM_MASK mask, IAssociationElement **ppae);
    BOOL _FirstElement(ASSOCELEM_MASK mask, IAssociationElement **ppae);
    HRESULT _GetVerbElement(ASSOCELEM_MASK mask, PCWSTR pszVerb, IAssociationElement **ppaeVerb, IAssociationElement **ppaeElem);
    void _InitDelayedElements(int i, ASSOCELEM_MASK mask);
    template<class T> HRESULT _QueryElementAny(HRESULT (CALLBACK *pfnAny)(IAssociationElement *pae, ASSOCQUERY query, PCWSTR pszCue, T pData, const IID *piid), ASSOCELEM_MASK mask, ASSOCQUERY query, PCWSTR pszCue, T pData, const IID *piid)
    {
        mask &= _maskInclude;
        IAssociationElement *pae;        
        HRESULT hr = E_FAIL;
        if ((AQF_CUEIS_SHELLVERB & query) && _CacheVerb(query))
        {
            //  delegate to the verb object if the cue is a verb
            //  except for AQVS_APPLICATION_FRIENDLYNAME which
            //  has some funky delegation issues.
            IAssociationElement *paeParent;        
            hr = _GetVerbElement(mask, pszCue, &pae, &paeParent);
            if (SUCCEEDED(hr))
            {
                if (query == AQVS_APPLICATION_FRIENDLYNAME)
                    hr = pfnAny(paeParent, query, pszCue, pData, piid);
                else
                    hr = pfnAny(pae, query, NULL, pData, piid);
                pae->Release();
                paeParent->Release();
            }
        }
        else
        {
            for (int i = 0; FAILED(hr) && TRYNEXT(GetElement(i, mask, &pae)); i++)
            {
                if (pae)
                {
                    hr = pfnAny(pae, query, pszCue, pData, piid);
                    pae->Release();
                    if (SUCCEEDED(hr))
                        break;
                }
            }
        }

        return hr;
    }

    BOOL _CacheVerb(ASSOCQUERY query)
    {
        //  if we are init'd with an app element and
        //  querying for app specific values dont request the verb element
        return !_fUsingAppElement || (query != AQVS_APPLICATION_PATH && query != AQVS_APPLICATION_FRIENDLYNAME && query != AQVO_APPLICATION_DELEGATE);
    }
    
private:  // members
    LONG _cRef;
    HRESULT _hrInit;
    PWSTR _pszClass;
    ASSOCELEM_MASK _maskInclude;
    BOOL _fUsingAppElement;
    CDSA<AEINFO> _dsaElems;
    IEnumAssociationElements *_penumData;
    ASSOCELEM_MASK _maskData;
    IEnumAssociationElements *_penumExtra;
    ASSOCELEM_MASK _maskExtra;
    IAssociationElement *_paeVerb;
    PWSTR _pszVerb;
    ASSOCELEM_MASK _maskVerb;
    IAssociationElement *_paeVerbParent;
};

int CALLBACK _AeinfoDelete(AEINFO *paei, void *pv)
{
    if (paei->pae)
        paei->pae->Release();
    return 1;        
}

void CAssocArray::_Reset()
{
    if (_hrInit != -1)
    {
        if (_dsaElems)
            _dsaElems.DestroyCallbackEx(_AeinfoDelete, (void*)NULL);
        if (_pszClass)
        {
            CoTaskMemFree(_pszClass);
            _pszClass = NULL;
        }
            
        ATOMICRELEASE(_penumData);
        ATOMICRELEASE(_penumExtra);
        ATOMICRELEASE(_paeVerb);
        if (_pszVerb)
        {
            LocalFree(_pszVerb);
            _pszVerb;
        }
        ATOMICRELEASE(_paeVerbParent);
        _fUsingAppElement = FALSE;
        _hrInit = -1;
    }
}

HRESULT CAssocArray::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CAssocArray, IAssociationArray),
        QITABENT(CAssocArray, IQueryAssociations),
        QITABENT(CAssocArray, IAssociationArrayInitialize),
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}


#define AEINFOPROGID(m, s)  { m, &CLSID_AssocProgidElement, s, AssocElemCreateForClass, NULL}
#define MAKEAEINFO(m, c, s, p)  { m, c, s, p, NULL}
HRESULT AssocElemCreateForUser(const CLSID *pclsid, PCWSTR pszClass, IAssociationElement **ppae)
{
    WCHAR sz[64];
    DWORD cb = sizeof(sz);
    HRESULT hr = SKGetValue(SHELLKEY_HKCU_FILEEXTS, pszClass, L"Progid", NULL, sz, &cb);
    if(SUCCEEDED(hr))
    {
        hr = AssocElemCreateForClass(&CLSID_AssocProgidElement, sz, ppae);
    }

    if (FAILED(hr))
    {
        cb = sizeof(sz);
        hr = SKGetValue(SHELLKEY_HKCU_FILEEXTS, pszClass, L"Application", NULL, sz, &cb);
        if (SUCCEEDED(hr))
        {
            hr = AssocElemCreateForClass(&CLSID_AssocApplicationElement, sz, ppae);
        }
    }

    return hr;
}

static const AEINFO s_rgaeinfoProgid[] =
{
    AEINFOPROGID(ASSOCELEM_DEFAULT, NULL),
};

static const AEINFO s_rgaeinfoExtension[] = 
{
    MAKEAEINFO(ASSOCELEM_USER, NULL, NULL, AssocElemCreateForUser),        //  app or progid
    AEINFOPROGID(ASSOCELEM_DEFAULT, NULL),
    MAKEAEINFO(ASSOCELEM_SYSTEM_EXT, &CLSID_AssocSystemElement, NULL, AssocElemCreateForClass),
    MAKEAEINFO(ASSOCELEM_SYSTEM_PERCEIVED, &CLSID_AssocPerceivedElement, NULL, AssocElemCreateForClass),
};

static const AEINFO s_rgaeinfoClsid[] = 
{
//    MAKEAEINFO(UserClsid),      //  clsid
    MAKEAEINFO(ASSOCELEM_DEFAULT, &CLSID_AssocClsidElement, NULL, AssocElemCreateForClass),
//    AEINFOPROGID(ASSOCELEM_PROGID, NULL),         //  progid
};

static const AEINFO s_aeinfoFolder = MAKEAEINFO(ASSOCELEM_BASEIS_FOLDER, &CLSID_AssocFolderElement, NULL, AssocElemCreateForClass);
static const AEINFO s_aeinfoStar = MAKEAEINFO(ASSOCELEM_BASEIS_STAR, &CLSID_AssocStarElement, NULL, AssocElemCreateForClass);

BOOL CAssocArray::_FirstElement(ASSOCELEM_MASK mask, IAssociationElement **ppae)
{
    GETELEMRESULT res = GETELEM_TRYNEXT;
    int cTrys = 0;
    while (res == GETELEM_TRYNEXT)
    {
        //  if it fails or succeeds we are done
        //  but if it calls TRYNEXT we loop
        res = GetElement(cTrys++, mask, ppae);
    }
    return res == GETELEM_SUCCEEDED;
}

HRESULT CAssocArray::InitClassElements(ASSOCELEM_MASK maskBase, PCWSTR pszClass)
{
    _Reset();
    //  depending on what we think this is, 
    //  we do things a little differently
    ASSERT(*pszClass);
    HRESULT hr = SHStrDup(pszClass, &_pszClass);
    if (SUCCEEDED(hr))
    {
        //  6 is the most that we will need
        //  in InitClassElements()
        hr = _dsaElems.Create(6) ? S_OK : E_OUTOFMEMORY;
        if (SUCCEEDED(hr))
        {
            const AEINFO *rgAeinfo;
            DWORD cAeinfo;
            if (*_pszClass == L'.')
            {
                rgAeinfo = s_rgaeinfoExtension;
                cAeinfo = ARRAYSIZE(s_rgaeinfoExtension);
            }
            else if (*_pszClass == L'{')
            {
                rgAeinfo = s_rgaeinfoClsid;
                cAeinfo = ARRAYSIZE(s_rgaeinfoClsid);
            }
            else
            {
                rgAeinfo = s_rgaeinfoProgid;
                cAeinfo = ARRAYSIZE(s_rgaeinfoProgid);
            }

            for (DWORD i = 0; i < cAeinfo; i++)
            {
                _dsaElems.AppendItem((AEINFO *)&rgAeinfo[i]);
            }

            if (ASSOCELEM_BASEIS_FOLDER & maskBase)
                _dsaElems.AppendItem((AEINFO *)&s_aeinfoFolder);
            
            if (ASSOCELEM_BASEIS_STAR & maskBase)
                _dsaElems.AppendItem((AEINFO *)&s_aeinfoStar);

            //  we return S_FALSE if there is no default or user 
            //  association.  we treat this as an unknown type
            IAssociationElement *pae;
            if (_FirstElement(ASSOCELEM_USER | ASSOCELEM_DEFAULT, &pae))
            {
                pae->Release();
                hr = S_OK;
            }
            else
                hr = S_FALSE;
        }
    }

    _hrInit = hr;
    return hr;
}
                
HRESULT CAssocArray::InsertElements(ASSOCELEM_MASK mask, IEnumAssociationElements *peae)
{
    HRESULT hr = E_UNEXPECTED;
    if (!_penumData && (mask & ASSOCELEM_DATA))
    {
        _penumData = peae;
        peae->AddRef();
        _maskData = mask;
            
        hr = S_OK;
    }
    if (!_penumExtra && (mask & ASSOCELEM_EXTRA))
    {
        _penumExtra = peae;
        peae->AddRef();
        _maskExtra = mask;
        hr = S_OK;
    }
    return hr;
}

class CEnumAssocElems : public CEnumAssociationElements 
{
public:
    CEnumAssocElems(CAssocArray *paa, ASSOCELEM_MASK mask) : _mask(mask), _paa(paa)
        {   _paa->AddRef(); }
        
    ~CEnumAssocElems()  { _paa->Release(); }
    
protected: // methods
    virtual BOOL _Next(IAssociationElement **ppae);

protected:    
    ASSOCELEM_MASK _mask;
    CAssocArray *_paa;
};

HRESULT CAssocArray::EnumElements(ASSOCELEM_MASK mask, IEnumAssociationElements **ppeae)
{
    mask &= _maskInclude;
    *ppeae = new CEnumAssocElems(this, mask);
    return *ppeae ? S_OK : E_OUTOFMEMORY;
}

void CAssocArray::_InitDelayedElements(int i, ASSOCELEM_MASK mask)
{
    ULONG c;
    IAssociationElement *pae;
    if (i == 0 && _penumData && ((mask & _maskData) == _maskData))
    {
        //  init the DSA with the data
        int iInsert = 0;
        while (S_OK == _penumData->Next(1, &pae, &c))
        {
            AEINFO ae = {ASSOCELEM_DATA, NULL, NULL, NULL, pae};
            if (DSA_ERR != _dsaElems.InsertItem(iInsert++, &ae))
            {
                pae->AddRef();
            }
            pae->Release();
        }

        ATOMICRELEASE(_penumData);
    }

    if (_penumExtra && (mask & ASSOCELEM_EXTRA) && i == _dsaElems.GetItemCount())
    {
        //  init the DSA with the data
        while (S_OK == _penumExtra->Next(1, &pae, &c))
        {
            AEINFO ae = {ASSOCELEM_EXTRA, NULL, NULL, NULL, pae};
            if (DSA_ERR != _dsaElems.AppendItem(&ae))
            {
                pae->AddRef();
            }
            pae->Release();
        }

        ATOMICRELEASE(_penumExtra);
    }
}

GETELEMRESULT CAssocArray::_GetElement(int i, ASSOCELEM_MASK mask, IAssociationElement **ppae)
{
    GETELEMRESULT res = GETELEM_DONE;
    AEINFO *paei = _dsaElems.GetItemPtr(i);
    if (paei)
    {
        //  if this is one that we want to use
        //  please do
        if (paei->mask & mask)
        {
            if (!paei->pae)
            {
                //  try to create only once
                PCWSTR pszClass = paei->pszClass ? paei->pszClass : _pszClass;
                //  make sure we dont query again
                //  if we dont need to
                HRESULT hr = paei->pfnCreate(paei->pclsid, pszClass, &paei->pae);
                if (FAILED(hr))
                {
                    _dsaElems.DeleteItem(i);
                    //  retry the current index
                    res = GETELEM_RETRY;
                }
                else if (hr == S_FALSE)
                {
                    //  this is returned when the element
                    //  is valid but points to an alternate location
                    //  specifically the HKCR\Progid falls back to HKCR\.ext
                    //  which is kind of weird.  maybe we should move this
                    //  to ASSOCELEM_EXTRA???
                }
                    
            }

            if (paei->pae)
            {
                *ppae = paei->pae;
                paei->pae->AddRef();
                res = GETELEM_SUCCEEDED;
            }
        }
        else
        {
            res = GETELEM_TRYNEXT;
        }
    }
    return res;
}

GETELEMRESULT CAssocArray::GetElement(int i, ASSOCELEM_MASK mask, IAssociationElement **ppae)
{
    GETELEMRESULT res = GETELEM_RETRY;
    *ppae = 0;
    if (_dsaElems)
    {
        _InitDelayedElements(i, mask);
        while (GETELEM_RETRY == res && i < _dsaElems.GetItemCount())
        {
            res = _GetElement(i, mask, ppae);
        } 
    }
    return res;
}

BOOL CEnumAssocElems::_Next(IAssociationElement **ppae)
{
    GETELEMRESULT res = GETELEM_TRYNEXT;
    UINT cTrys = 0;
    while (res == GETELEM_TRYNEXT)
    {
        //  if it fails or succeeds we are done
        //  but if it calls TRYNEXT we loop
        res = _paa->GetElement(_cNext + cTrys++, _mask, ppae);
    }
    //  fix up _cNext when we skip
    _cNext += cTrys - 1;
    return res == GETELEM_SUCCEEDED;
}

typedef struct
{
    ASSOCQUERY query;
    PCWSTR pszCue;
} AQXLATE;

#define MAKEAQX(a, q, s)    { q, s }

static const AQXLATE s_rgaqxStrings[] = 
{
    MAKEAQX(ASSOCSTR_COMMAND, AQVS_COMMAND, NULL),
    MAKEAQX(ASSOCSTR_EXECUTABLE, AQVS_APPLICATION_PATH, NULL),
    MAKEAQX(ASSOCSTR_FRIENDLYDOCNAME, AQS_FRIENDLYTYPENAME, , NULL),   //  friendly name of the document type
    MAKEAQX(ASSOCSTR_FRIENDLYAPPNAME, AQVS_APPLICATION_FRIENDLYNAME, NULL),
    MAKEAQX(ASSOCSTR_NOOPEN, AQNS_NAMED_MUI_STRING, L"NoOpen"),
    MAKEAQX(ASSOCSTR_SHELLNEWVALUE, (ASSOCQUERY)0, NULL),
    MAKEAQX(ASSOCSTR_DDECOMMAND, AQVS_DDECOMMAND, NULL),
    MAKEAQX(ASSOCSTR_DDEIFEXEC, AQVS_DDEIFEXEC, NULL),
    MAKEAQX(ASSOCSTR_DDEAPPLICATION, AQVS_DDEAPPLICATION, NULL),
    MAKEAQX(ASSOCSTR_DDETOPIC, AQVS_DDETOPIC, NULL),
    MAKEAQX(ASSOCSTR_INFOTIP, AQNS_NAMED_MUI_STRING, L"InfoTip"),
    MAKEAQX(ASSOCSTR_QUICKTIP, AQNS_NAMED_MUI_STRING, L"QuickTip"),
    MAKEAQX(ASSOCSTR_TILEINFO, AQNS_NAMED_MUI_STRING, L"TileInfo"),
    MAKEAQX(ASSOCSTR_CONTENTTYPE, AQS_CONTENTTYPE, NULL),
    MAKEAQX(ASSOCSTR_DEFAULTICON, AQS_DEFAULTICON, NULL),
    MAKEAQX(ASSOCSTR_SHELLEXTENSION, AQNS_SHELLEX_HANDLER, NULL),
};

HRESULT _CopyOut(BOOL fNoTruncate, PCWSTR pszIn, PWSTR psz, DWORD *pcch)
{
    //  if caller doesnt want any return size, 
    //  the incoming pointer is actually the size of the buffer
    
    ASSERT(pcch);
    ASSERT(psz || !IS_INTRESOURCE(pcch));
    
    HRESULT hr;
    DWORD cch = IS_INTRESOURCE(pcch) ? PtrToUlong(pcch) : *pcch;
    DWORD cchStr = lstrlenW(pszIn);

    if (psz)
    {
        if (!fNoTruncate || cch > cchStr)
        {
            StrCpyNW(psz, pszIn, cch);
            hr = S_OK;
        }
        else
            hr = E_POINTER;
    }
    else
        hr = S_FALSE;
    
    //  return the number of chars written/required
    if (!IS_INTRESOURCE(pcch))
        *pcch = (hr == S_OK) ? lstrlen(psz) + 1 : cchStr + 1;

    return hr;
}

ASSOCELEM_MASK _MaskFromFlags(ASSOCF flags)
{
    ASSOCELEM_MASK mask = ASSOCELEM_MASK_QUERYNORMAL;

    if (flags & ASSOCF_IGNOREBASECLASS)
        mask &= (ASSOCELEM_USER | ASSOCELEM_DEFAULT);

    if (flags & ASSOCF_NOUSERSETTINGS)
        mask &= ~ASSOCELEM_USER;

    return mask;
}

HRESULT CAssocArray::GetString(ASSOCF flags, ASSOCSTR str, LPCTSTR pszCue, LPTSTR pszOut, DWORD *pcchOut)
{
    HRESULT hr = E_UNEXPECTED;
    if (str && str < ASSOCSTR_MAX && pcchOut && (pszOut || !IS_INTRESOURCE(pcchOut)))
    {
        //  subtract the first one to make a zero based offset
        int index = str - ASSOCSTR_COMMAND;
        if (!pszCue)
            pszCue = s_rgaqxStrings[index].pszCue;            

        if (s_rgaqxStrings[index].query)
        {
            PWSTR psz;
            hr = QueryString(_MaskFromFlags(flags), s_rgaqxStrings[index].query, pszCue, &psz);
            if (SUCCEEDED(hr))
            {
                hr = _CopyOut(flags & ASSOCF_NOTRUNCATE, psz, pszOut, pcchOut);
                CoTaskMemFree(psz);
            }
        }
        //  else call win2k code for shellnew?
        //  
    }
    
    return hr; 
}

static const AQXLATE s_rgaqxDatas[] = 
{
    MAKEAQX(ASSOCDATA_MSIDESCRIPTOR, AQVD_MSIDESCRIPTOR, NULL),
    MAKEAQX(ASSOCDATA_NOACTIVATEHANDLER, AQV_NOACTIVATEHANDLER, NULL),
    MAKEAQX(ASSOCDATA_QUERYCLASSSTORE, AQN_NAMED_VALUE, L"QueryClassStore"),
    MAKEAQX(ASSOCDATA_HASPERUSERASSOC, (ASSOCQUERY)0, NULL),
    MAKEAQX(ASSOCDATA_EDITFLAGS, AQN_NAMED_VALUE, L"EditFlags"),
    MAKEAQX(ASSOCDATA_VALUE, AQN_NAMED_VALUE, NULL),
};

HRESULT _CopyDataOut(BOOL fNoTruncate, FLAGGED_BYTE_BLOB *pblob, void *pv, DWORD *pcb)
{
    //  if caller doesnt want any return size, 
    //  the incoming pointer is actually the size of the buffer
    ASSERT(pcb);
    ASSERT(pv || !IS_INTRESOURCE(pcb));
    
    HRESULT hr;
    DWORD cb = IS_INTRESOURCE(pcb) ? PtrToUlong(pcb) : *pcb;
    if (pv)
    {
        if (!fNoTruncate || cb >= pblob->clSize)
        {
            //  copy the smaller of the src or dst
            cb = min(cb, pblob->clSize);
            memcpy(pv, pblob->abData, cb);
            hr = S_OK;
        }
        else
            hr = E_POINTER;
    }
    else
        hr = S_FALSE;
    
    //  return the number of chars written/required
    if (!IS_INTRESOURCE(pcb))
        *pcb = pblob->clSize;

    return hr;
}

HRESULT CAssocArray::GetData(ASSOCF flags, ASSOCDATA data, PCWSTR pszCue, LPVOID pvOut, DWORD *pcbOut)
{
    HRESULT hr = E_INVALIDARG;
    if (data && data < ASSOCDATA_MAX)
    {
        //  subtract the first one to make a zero based offset
        int index = data - ASSOCDATA_MSIDESCRIPTOR;
        if (!pszCue)
            pszCue = s_rgaqxDatas[index].pszCue;            

        if (s_rgaqxDatas[index].query)
        {
            if (pcbOut)
            {
                FLAGGED_BYTE_BLOB *pblob;            
                hr = QueryDirect(_MaskFromFlags(flags), s_rgaqxDatas[index].query, pszCue, &pblob);
                if (SUCCEEDED(hr))
                {
                    hr = _CopyDataOut(flags & ASSOCF_NOTRUNCATE, pblob, pvOut, pcbOut);
                    CoTaskMemFree(pblob);
                }
            }
            else
            {
                hr = QueryExists(_MaskFromFlags(flags), s_rgaqxDatas[index].query, pszCue);
            }
        }
        else
        {
            if (data == ASSOCDATA_HASPERUSERASSOC)
            {
                IAssociationElement *pae;
                if (_FirstElement(ASSOCELEM_USER, &pae))
                {
                    pae->Release();
                    hr = S_OK;
                }
                else
                    hr = S_FALSE;
            }
        }
                
            
    }
    
    return hr;
}

BOOL _IsSameVerb(PCWSTR pszV1, PCWSTR pszV2)
{
    if (!pszV1 && !pszV2)
        return TRUE;
    else if (pszV1 && pszV2 && 0 == StrCmpIW(pszV1, pszV2))
        return TRUE;
    return FALSE;
}

HRESULT CAssocArray::_GetCachedVerbElement(ASSOCELEM_MASK mask, PCWSTR pszVerb, IAssociationElement **ppaeVerb, IAssociationElement **ppaeElem)
{
    if (_paeVerb
    && mask == _maskVerb
    && _IsSameVerb(pszVerb, _pszVerb))
    {
        *ppaeVerb = _paeVerb;
        _paeVerb->AddRef();

        if (ppaeElem)
        {
            *ppaeElem = _paeVerbParent;
            _paeVerbParent->AddRef();
        }
        return S_OK;
    }
    else
    {
        *ppaeVerb = NULL;

        if (ppaeElem)
            *ppaeElem = NULL;
        return E_FAIL;
    }
}

void CAssocArray::_SetCachedVerbElement(ASSOCELEM_MASK mask, PCWSTR pszVerb, IAssociationElement *paeVerb, IAssociationElement *paeVerbParent)
{
    if (_paeVerb)
    {
        ATOMICRELEASE(_paeVerb);
        ATOMICRELEASE(_paeVerbParent);
        if (_pszVerb)
            LocalFree(_pszVerb);
    }

    if (pszVerb)
        _pszVerb = StrDupW(pszVerb);
    else
        _pszVerb = NULL;

    if (_pszVerb || !pszVerb)
    {
        _paeVerb = paeVerb;
        _paeVerb->AddRef();
        _paeVerbParent = paeVerbParent;
        _paeVerbParent->AddRef();
        _maskVerb = mask;
    }
}
        
HRESULT CAssocArray::_GetVerbElement(ASSOCELEM_MASK mask, PCWSTR pszVerb, IAssociationElement **ppaeVerb, IAssociationElement **ppaeElem)
{
    HRESULT hr = _GetCachedVerbElement(mask, pszVerb, ppaeVerb, ppaeElem);
    IAssociationElement *pae;
    for (int i = 0; FAILED(hr) && TRYNEXT(GetElement(i, mask, &pae)); i++)
    {
        if (pae)
        {
            hr = pae->QueryObject(AQVO_SHELLVERB_DELEGATE, pszVerb, IID_PPV_ARG(IAssociationElement, ppaeVerb));
            if (SUCCEEDED(hr))
            {
                _SetCachedVerbElement(mask, pszVerb, *ppaeVerb, pae);
                if (ppaeElem)
                {
                    pae->AddRef();
                    *ppaeElem = pae;
                }
            }
            pae->Release();
        }
    }
    return hr;
}

HRESULT CAssocArray::GetKey(ASSOCF flags, ASSOCKEY key, LPCTSTR pszCue, HKEY *phkey)
{
    HRESULT hr = E_INVALIDARG;
    *phkey = NULL;

    if (key && key < ASSOCKEY_MAX)
    {
        IAssociationElement *pae;
        switch (key)
        {
        case ASSOCKEY_SHELLEXECCLASS:    
            {
                IAssociationElement *paeVerb;
                hr = _GetVerbElement(_MaskFromFlags(flags) & _maskInclude, pszCue, &paeVerb, &pae);
                if (SUCCEEDED(hr))
                {
                    //  we dont use the verb element
                    paeVerb->Release();
                }
            }
            break;

        case ASSOCKEY_APP:
            //  get app element
            hr = QueryObject(ASSOCELEM_MASK_QUERYNORMAL, AQVO_APPLICATION_DELEGATE, pszCue, IID_PPV_ARG(IAssociationElement, &pae));
            break;
            
        case ASSOCKEY_CLASS:
            {
                hr = _FirstElement(_MaskFromFlags(flags) & _maskInclude, &pae) == GETELEM_SUCCEEDED ? S_OK : E_FAIL;
            }
            break;

        case ASSOCKEY_BASECLASS:
            hr = _FirstElement(ASSOCELEM_BASE & _maskInclude, &pae) == GETELEM_SUCCEEDED ? S_OK : E_FAIL;
            break;
        }

        if (SUCCEEDED(hr))
        {
            hr = AssocKeyFromElement(pae, phkey);
            pae->Release();
        }
    }
    return hr;
}            

HRESULT CAssocArray::_InsertSingleElement(IAssociationElement *pae)
{
    AEINFO ae = {ASSOCELEM_DEFAULT, NULL, NULL, NULL, pae};
    ASSERT(!_dsaElems);
    if (_dsaElems.Create(1) && (DSA_ERR != _dsaElems.AppendItem(&ae)))
    {
        pae->AddRef();
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

HRESULT CAssocArray::Init(ASSOCF flags, LPCTSTR pszAssoc, HKEY hkProgid, HWND hwnd)
{
    IAssociationElement *pae;
    HRESULT hr = (pszAssoc || hkProgid) ? S_OK : E_INVALIDARG;
    if (SUCCEEDED(hr))
    {
        _Reset();
        _fUsingAppElement = flags & ASSOCF_INIT_BYEXENAME;
        
        if (hkProgid)
        {
            const CLSID *pclsid;
            if (_fUsingAppElement)
                pclsid = &CLSID_AssocApplicationElement;
            else if (flags & ASSOCF_INIT_NOREMAPCLSID)
                pclsid = &CLSID_AssocClsidElement;
            else
                pclsid = &CLSID_AssocProgidElement;
            
            hr = AssocElemCreateForKey(pclsid, hkProgid, &pae);
            if (SUCCEEDED(hr))
            {
                hr = _InsertSingleElement(pae);
                pae->Release();
            }
        }
        else if (_fUsingAppElement)
        {
            ASSERT(pszAssoc);
            hr = AssocElemCreateForClass(&CLSID_AssocApplicationElement, pszAssoc, &pae);
            if (SUCCEEDED(hr))
            {
                hr = _InsertSingleElement(pae);
                pae->Release();
            }
        }
        else
        {
            ASSERT(pszAssoc);
            ASSOCELEM_MASK maskBase = 0;
            if (flags & ASSOCF_INIT_DEFAULTTOFOLDER)
                maskBase |= ASSOCELEM_BASEIS_FOLDER;
            if (flags & ASSOCF_INIT_DEFAULTTOSTAR)
                maskBase |= ASSOCELEM_BASEIS_STAR;

            if (StrChr(pszAssoc, TEXT('\\')))
                pszAssoc = PathFindExtension(pszAssoc);

            if (*pszAssoc)
                hr = InitClassElements(maskBase, pszAssoc);
            else
                hr = E_INVALIDARG;
        }
    }
    _hrInit = hr;
    return hr;
}

STDAPI CQueryAssociations_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{

    HRESULT hr = E_INVALIDARG;

    if (ppv)
    {
        *ppv = NULL;

        if (punkOuter)
            return CLASS_E_NOAGGREGATION;        

        CAssocArray *passoc = new CAssocArray();

        if (passoc)
        {
            hr = passoc->QueryInterface(riid, ppv);
            passoc->Release();
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\atldisp.h ===
#ifndef __ATL_IDISPATCH_H__
#define __ATL_IDISPATCH_H__

#include "unicpp/stdafx.h"

extern LCID g_lcidLocale;


#pragma pack(push, _ATL_PACKING)

#ifndef ATL_NO_NAMESPACE
namespace ATL
{
#endif // ATL_NO_NAMESPACE



template <class T, const GUID* pclsid, const IID* piid, const GUID* plibid, WORD wMajor = 1, WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
class ATL_NO_VTABLE CShell32AtlIDispatch
                    : public IOleObjectImpl<T>
{
public:
    CShell32AtlIDispatch();
    ~CShell32AtlIDispatch();

    // *** IDispatch ***
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr);
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid);

    // *** IProvideClassInfo ***
    virtual STDMETHODIMP GetClassInfo(ITypeInfo** pptinfo);

    // *** IOleObject ***
    virtual STDMETHODIMP GetMiscStatus(DWORD dwAspect, DWORD *pdwStatus);

    virtual STDMETHODIMP DoVerbUIActivate(LPCRECT prcPosRect, HWND hwndParent, HWND hwnd);
    virtual STDMETHODIMP TranslateAcceleratorPriv(T * pThis, MSG *pMsg, IOleClientSite * pocs);

    virtual STDMETHODIMP PrivateQI(REFIID iid, void ** ppvObject) = 0;

protected:
    // Helper functions;
    ITypeInfo *         _pClassTypeInfo;             // ITypeInfo of class
    IFileSearchBand *   _pdisp;                      // This will not contain a ref because it's equal to 'this'.
};


template <class T, const GUID* pclsid, const IID* piid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
CShell32AtlIDispatch<T, pclsid, piid, plibid, 1, 0, tihclass>::CShell32AtlIDispatch()
{
    // This allocator should have zero inited the memory, so assert the member variables are empty.
    ASSERT(!_pClassTypeInfo);
}

template <class T, const GUID* pclsid, const IID* piid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
CShell32AtlIDispatch<T, pclsid, piid, plibid, 1, 0, tihclass>::~CShell32AtlIDispatch()
{
    if (_pClassTypeInfo)
        _pClassTypeInfo->Release();

    // _pdisp doesn't have a ref so it's OK if it's not NULL.
}


// *** IProvideClassInfo ***
template <class T, const GUID* pclsid, const IID* piid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
HRESULT CShell32AtlIDispatch<T, pclsid, piid, plibid, 1, 0, tihclass>::GetClassInfo(ITypeInfo ** ppTI)
{
    if (!_pClassTypeInfo) 
        GetTypeInfoFromLibId(LANGIDFROMLCID(g_lcidLocale), LIBID_Shell32, 1, 0, *pclsid, &_pClassTypeInfo);

    if (_pClassTypeInfo)
    {
        _pClassTypeInfo->AddRef();
        *ppTI = _pClassTypeInfo;
        return S_OK;
    }

    *ppTI = NULL;
    return E_FAIL;
}


// *** IDispatch ***
template <class T, const GUID* pclsid, const IID* piid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
HRESULT CShell32AtlIDispatch<T, pclsid, piid, plibid, 1, 0, tihclass>::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** ppITypeInfo)
{
    HRESULT hr = S_OK;

    *ppITypeInfo = NULL;

    if (0 != itinfo)
        return(TYPE_E_ELEMENTNOTFOUND);

    //Load a type lib if we don't have the information already.
    if (NULL == *ppITypeInfo)
    {
        ITypeInfo * pITIDisp;

        hr = GetTypeInfoFromLibId(lcid, LIBID_Shell32, 1, 0, *piid, &pITIDisp);

        if (SUCCEEDED(hr))
        {
            HRESULT hrT;
            HREFTYPE hrefType;

            // All our IDispatch implementations are DUAL. GetTypeInfoOfGuid
            // returns the ITypeInfo of the IDispatch-part only. We need to
            // find the ITypeInfo for the dual interface-part.
            //
            hrT = pITIDisp->GetRefTypeOfImplType(0xffffffff, &hrefType);
            if (SUCCEEDED(hrT))
                hrT = pITIDisp->GetRefTypeInfo(hrefType, ppITypeInfo);

            ASSERT(SUCCEEDED(hrT));
            pITIDisp->Release();
        }
    }

    return hr;
}


template <class T, const GUID* pclsid, const IID* piid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
HRESULT CShell32AtlIDispatch<T, pclsid, piid, plibid, 1, 0, tihclass>::GetIDsOfNames(REFIID // riid
    , LPOLESTR* rgszNames, UINT cNames, LCID lcid, DISPID* rgdispid)
{
    ITypeInfo* pInfo;
    HRESULT hr = GetTypeInfo(0, lcid, &pInfo);

    if (pInfo != NULL)
    {
        hr = pInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
        pInfo->Release();
    }

    return hr;
}

template <class T, const GUID* pclsid, const IID* piid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
HRESULT CShell32AtlIDispatch<T, pclsid, piid, plibid, 1, 0, tihclass>::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
{
    HRESULT hr = E_FAIL;
    DISPPARAMS dispparams = {0};

    if (!pdispparams)
        pdispparams = &dispparams;  // otherwise OLE Fails when passed NULL.

    // make sure we have an interface to hand off to Invoke
    if (NULL == _pdisp)
    {
        hr = PrivateQI(*piid, (LPVOID*)&_pdisp);
        ASSERT(SUCCEEDED(hr));

        // don't hold a refcount on ourself
        _pdisp->Release();
    }

    ITypeInfo * pITypeInfo;
    hr = GetTypeInfo(0, lcid, &pITypeInfo);
    if (SUCCEEDED(hr))
    {
        //Clear exceptions
        SetErrorInfo(0L, NULL);

        hr = pITypeInfo->Invoke(_pdisp, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
        pITypeInfo->Release();
    }

    return hr;
}


#define DW_MISC_STATUS (OLEMISC_SETCLIENTSITEFIRST | OLEMISC_ACTIVATEWHENVISIBLE | OLEMISC_RECOMPOSEONRESIZE | \
                        OLEMISC_CANTLINKINSIDE | OLEMISC_INSIDEOUT)

template <class T, const GUID* pclsid, const IID* piid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
HRESULT CShell32AtlIDispatch<T, pclsid, piid, plibid, 1, 0, tihclass>::GetMiscStatus(DWORD dwAspect, DWORD *pdwStatus)
{
    *pdwStatus = DW_MISC_STATUS;
    return S_OK;
}


template <class T, const GUID* pclsid, const IID* piid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
HRESULT CShell32AtlIDispatch<T, pclsid, piid, plibid, 1, 0, tihclass>::DoVerbUIActivate(LPCRECT prcPosRect, HWND hwndParent, HWND hwnd)
{
    HRESULT hr = IOleObjectImpl<T>::DoVerbUIActivate(prcPosRect, hwndParent);
    
    if (hwnd)
        ::SetFocus(hwnd);

    return hr;
}


template <class T, const GUID* pclsid, const IID* piid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
HRESULT CShell32AtlIDispatch<T, pclsid, piid, plibid, 1, 0, tihclass>::TranslateAcceleratorPriv(T * pThis, MSG *pMsg, IOleClientSite * pocs)
{
    HRESULT hr = S_FALSE;

    if (!EVAL(pMsg))
        return E_INVALIDARG;

    hr = pThis->T::TranslateAcceleratorInternal(pMsg, pocs);
    if (FAILED(hr))
    {
        if (WM_KEYDOWN == pMsg->message)
        {
            switch (pMsg->wParam)
            {
            // We can't handle RETURN because the script wants that
            // for post and other reasons
            //case VK_RETURN:
            case VK_ESCAPE:
            case VK_END:
            case VK_HOME:
            case VK_LEFT:
            case VK_UP:
            case VK_RIGHT:
            case VK_DOWN:
            case VK_DELETE:
                if (TranslateMessage(pMsg))
                {
                    DispatchMessage(pMsg);
                    hr = S_OK;
                }
                break;
            case VK_TAB:
                {
                    CComQIPtr <IOleControlSite, &IID_IOleControlSite> spSite(pocs);
                    if (EVAL(spSite))
                        hr = spSite->TranslateAccelerator(pMsg, 0);
                }
                break;
            default:
                break;
            }
        }

        if (S_OK != hr)
        {
            // We didn't handle it so give our base class a chances.
            hr = pThis->IOleInPlaceActiveObjectImpl<T>::TranslateAccelerator(pMsg);
        }
    }

    return hr;
}


#ifndef ATL_NO_NAMESPACE
}; //namespace ATL
#endif // ATL_NO_NAMESPACE


#endif // __ATL_IDISPATCH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\balmsg.h ===
#ifndef _BALLOON_MSG_H
#define _BALLOON_MSG_H

typedef struct {
    DWORD dwSize;           // sizeof(BALLOON_MESSAGE) for versioning
    LPCTSTR pszTitle;       // title of the balloon, also used in the tooltip
    LPCTSTR pszText;        // body text of the balloon
    HICON hIcon;            // optional icon for tray
    DWORD dwInfoFlags;      // the icon in the balloon (NIIF_INFO, NIIF_WARNING, NIIF_ERROR)
    UINT cRetryCount;       // retry 0 for only one, -1 for infinite
} BALLOON_MESSAGE;

// returns:
//      S_OK        user confirmed the message (clicked on the balloon or icon)
//      S_FALSE     user ignored the message and it timed out
//      FAILED()    other failures

STDAPI SHBalloonMessage(const BALLOON_MESSAGE *pbm);

#endif // _BALLOON_MSG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\basedlg.h ===
#ifndef BASEDLG_H
#define BASEDLG_H

class CBaseDlg
{
public:
    CBaseDlg(ULONG_PTR ulpAHelpIDsArray);
    LONG AddRef();
    LONG Release();

public:
    INT_PTR DoModal(HINSTANCE hinst, LPTSTR pszResource, HWND hwndParent);

protected:
    virtual ~CBaseDlg();
    virtual LRESULT OnCommand(WPARAM wParam, LPARAM lParam);
    virtual LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    virtual LRESULT OnInitDialog(WPARAM wParam, LPARAM lParam) = 0;
    virtual LRESULT OnDestroy(WPARAM wParam, LPARAM lParam);
    virtual LRESULT OnHelp(WPARAM wParam, LPARAM lParam);
    virtual LRESULT OnContextMenu(WPARAM wParam, LPARAM lParam);

    virtual LRESULT OnOK(WORD wNotif);
    virtual LRESULT OnCancel(WORD wNotif);

    virtual LRESULT WndProc(UINT uMsg, WPARAM wParam, LPARAM lParam);

    ULONG_PTR GetHelpIDsArray();

// Misc
    void SetHWND(HWND hwnd) { _hwnd = hwnd; }
    void ResetHWND() { _hwnd = NULL; }

protected:
    HWND            _hwnd;
    HCURSOR         _hcursorWait;
    HCURSOR         _hcursorOld;

    ULONG_PTR       _rgdwHelpIDsArray;

private:
    LONG                _cRef;
public:
    static BOOL_PTR CALLBACK BaseDlgWndProc(HWND hwnd, UINT uMsg, 
        WPARAM wParam, LPARAM lParam);
    static UINT CALLBACK BaseDlgPropSheetCallback( HWND hwnd, 
        UINT uMsg, LPPROPSHEETPAGE ppsp);

};

#endif //BASEDLG_H}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\basedlg.cpp ===
#include "shellprv.h"
#include "ids.h"

#include "basedlg.h"

CBaseDlg::CBaseDlg(ULONG_PTR ulpAHelpIDsArray) :
     _cRef(1), _rgdwHelpIDsArray(ulpAHelpIDsArray)
{}

CBaseDlg::~CBaseDlg()
{}


LONG CBaseDlg::AddRef()
{
    return (InterlockedIncrement(&_cRef));
}

LONG CBaseDlg::Release()
{
    LONG cr;
    if (cr = InterlockedDecrement(&_cRef))
        return cr;
    else
    {
        delete this;
        return 0;
    }
}

INT_PTR CBaseDlg::DoModal(HINSTANCE hinst, LPTSTR pszResource, HWND hwndParent)
{
    PROPSHEETPAGE psp;
    psp.lParam = (LPARAM)this;
    return DialogBoxParam(hinst, pszResource, hwndParent,
        CBaseDlg::BaseDlgWndProc, (LPARAM)&psp);
}

ULONG_PTR CBaseDlg::GetHelpIDsArray()
{
    return _rgdwHelpIDsArray;
}

///////////////////////////////////////////////////////////////////////////////
// Windows boiler plate code
LRESULT CBaseDlg::WndProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = FALSE;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            lRes = OnInitDialog(wParam, lParam);
            break;

        case WM_COMMAND:
            lRes = OnCommand(wParam, lParam);
            break;

        case WM_NOTIFY:
            lRes = OnNotify(wParam, lParam);
            break;

        case WM_DESTROY:
            lRes = OnDestroy(wParam, lParam);
            break;

        case WM_HELP:
        {
            lRes = OnHelp(wParam, lParam);
            break;
        }
        case WM_CONTEXTMENU:
        {
            lRes = OnContextMenu(wParam, lParam);
            break;
        }
        default:
            break;
    }

    return lRes;
}

LRESULT CBaseDlg::OnCommand(WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = FALSE;

    switch (GET_WM_COMMAND_ID(wParam, lParam))
    {
        case IDOK:
            lRes = OnOK(GET_WM_COMMAND_CMD(wParam, lParam));
            break;

        case IDCANCEL:
            lRes = OnCancel(GET_WM_COMMAND_CMD(wParam, lParam));
            break;

        default:
            break;
    }

    return lRes;    
}

LRESULT CBaseDlg::OnNotify(WPARAM wParam, LPARAM lParam)
{
    return 0;
}

LRESULT CBaseDlg::OnHelp(WPARAM wParam, LPARAM lParam)
{
    HWND hwndItem = (HWND)((LPHELPINFO)lParam)->hItemHandle;
    int iCtrlID = GetDlgCtrlID(hwndItem);

    WinHelp(hwndItem, NULL, HELP_WM_HELP, GetHelpIDsArray());

    return TRUE;
}

LRESULT CBaseDlg::OnContextMenu(WPARAM wParam, LPARAM lParam)
{
    BOOL lRes=FALSE;
    
    if (HTCLIENT == (int)SendMessage(_hwnd, WM_NCHITTEST, 0, lParam))
    {
        POINT pt;
        HWND hwndItem = NULL;
        int iCtrlID = 0;
        
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);
        ScreenToClient(_hwnd, &pt);
        
        hwndItem = ChildWindowFromPoint(_hwnd, pt);
        iCtrlID = GetDlgCtrlID(hwndItem);

        WinHelp((HWND)wParam, NULL, HELP_CONTEXTMENU, GetHelpIDsArray());
        
        lRes = TRUE;
    }
    else
    {
        lRes = FALSE;
    }

    return lRes;
}


LRESULT CBaseDlg::OnDestroy(WPARAM wParam, LPARAM lParam)
{
    ResetHWND();

    SetWindowLongPtr(_hwnd, GWLP_USERDATA, NULL);
    Release();
    
    return FALSE;
}


//static
BOOL_PTR CALLBACK CBaseDlg::BaseDlgWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CBaseDlg* pThis = (CBaseDlg*)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    if (WM_INITDIALOG == uMsg)
    {
        pThis = (CBaseDlg*)(((PROPSHEETPAGE*)lParam)->lParam);

        if (pThis)
        {
            pThis->SetHWND(hwnd);

            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pThis);
            pThis->AddRef();

            SetForegroundWindow(hwnd);
        }
    }

    if (pThis)
    {
        return pThis->WndProc(uMsg, wParam, lParam);
    }
    else
        return 0;
}


UINT CALLBACK CBaseDlg::BaseDlgPropSheetCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    UINT    uResult = 0;
    CBaseDlg* pThis = (CBaseDlg*)ppsp->lParam;
    
    switch (uMsg)
    {
        case PSPCB_CREATE:
        {
            uResult = 1;
            break;
        }
        case PSPCB_RELEASE:
        {
            if (pThis)
                pThis->Release();
            break;
        }
    }
    
    return uResult;
}

LRESULT CBaseDlg::OnOK(WORD wNotif)
{
    return FALSE;
}

LRESULT CBaseDlg::OnCancel(WORD wNotif)
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\balmsg.cpp ===
#include "shellprv.h"
#include "balmsg.h"

#define BALLOON_SHOW_TIME       15000   // 15 sec
#define BALLOON_REPEAT_DELAY    10000   // 10 sec

#define WM_NOTIFY_MESSAGE   (WM_USER + 100)

#define IDT_REMINDER    1
#define IDT_DESTROY     2
#define IDT_QUERYCANCEL 3
#define IDT_NOBALLOON   4

class CUserNotification : public IUserNotification
{
public:
    CUserNotification();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IUserNotification
    STDMETHODIMP SetBalloonInfo(LPCWSTR pszTitle, LPCWSTR pszText, DWORD dwInfoFlags);
    STDMETHODIMP SetBalloonRetry(DWORD dwShowTime, DWORD dwInterval, UINT cRetryCount);
    STDMETHODIMP SetIconInfo(HICON hIcon, LPCWSTR pszToolTip);
    STDMETHODIMP Show(IQueryContinue *pqc, DWORD dwContinuePollInterval);
    STDMETHODIMP PlaySound(LPCWSTR pszSoundName);

private:
    ~CUserNotification();
    static LRESULT CALLBACK s_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT CALLBACK _WndProc(UINT uMsg, WPARAM wParam, LPARAM lParam);
    HRESULT _GetWindow();
    BOOL _SyncInfo();
    BOOL _SyncIcon();
    void _DelayDestroy(HRESULT hrDone);
    void _Timeout();
    void _RemoveNotifyIcon();

    LONG _cRef;
    HWND _hwnd;
    HICON _hicon;
    DWORD _dwShowTime;
    DWORD _dwInterval;
    UINT _cRetryCount;
    HRESULT _hrDone;
    DWORD _dwContinuePollInterval;
    IQueryContinue *_pqc;

    DWORD _dwInfoFlags;
    WCHAR *_pszTitle;
    WCHAR *_pszText;
    WCHAR *_pszToolTip;
};

CUserNotification::CUserNotification()
    : _cRef(1), _cRetryCount(-1), _dwShowTime(BALLOON_SHOW_TIME),
      _dwInterval(BALLOON_REPEAT_DELAY), _dwInfoFlags(NIIF_NONE)
{
}

CUserNotification::~CUserNotification()
{
    Str_SetPtrW(&_pszToolTip, NULL);
    Str_SetPtrW(&_pszTitle, NULL);
    Str_SetPtrW(&_pszText, NULL);

    if (_hwnd)
    {
        _RemoveNotifyIcon();
        DestroyWindow(_hwnd);
    }

    if (_hicon)
        DestroyIcon(_hicon);
}

STDMETHODIMP_(ULONG) CUserNotification::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CUserNotification::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CUserNotification::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CUserNotification, IUserNotification),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

HRESULT CUserNotification::SetBalloonInfo(LPCWSTR pszTitle, LPCWSTR pszText, DWORD dwInfoFlags)
{
    Str_SetPtrW(&_pszTitle, pszTitle);
    Str_SetPtrW(&_pszText, pszText);
    _dwInfoFlags = dwInfoFlags;
    _SyncInfo();    // may fail if balloon _hwnd has not been created yet

    return S_OK;
}

HRESULT CUserNotification::SetBalloonRetry(DWORD dwShowTime, DWORD dwInterval, UINT cRetryCount)
{
    if (-1 != dwShowTime)
        _dwShowTime = dwShowTime;

    if (-1 != dwInterval)
        _dwInterval = dwInterval;

    _cRetryCount = cRetryCount;
    return S_OK;
}

HRESULT CUserNotification::SetIconInfo(HICON hIcon, LPCWSTR pszToolTip)
{
    if (_hicon)
        DestroyIcon(_hicon);

    if (hIcon == NULL)
    {
        _hicon = NULL;
        switch(_dwInfoFlags & NIIF_ICON_MASK)
        {
            case NIIF_INFO:
                _hicon = LoadIcon(NULL, IDI_INFORMATION);
                break;
            case NIIF_WARNING:
                _hicon = LoadIcon(NULL, IDI_WARNING);
                break;
            case NIIF_ERROR:
                _hicon = LoadIcon(NULL, IDI_ERROR);
                break;
        }
    }
    else
    {
        _hicon = CopyIcon(hIcon);
    }

    Str_SetPtrW(&_pszToolTip, pszToolTip);
    _SyncIcon();

    return S_OK;
}

// returns:
//      S_OK        
//          user clicked on the balloon or icon
//      S_FALSE     
//          query continue callback (pcq) cancelled the notification UI
//      HRESULT_FROM_WIN32(ERROR_CANCELLED)
//          timeouts expired (user ignored the UI)
HRESULT CUserNotification::Show(IQueryContinue *pqc, DWORD dwContinuePollInterval)
{
    HRESULT hr = _GetWindow();
    if (SUCCEEDED(hr))
    {
        if (pqc)
        {
            _pqc = pqc; // don't need a ref since we don't return from here
            _dwContinuePollInterval = dwContinuePollInterval > 100 ? dwContinuePollInterval : 500;
            SetTimer(_hwnd, IDT_QUERYCANCEL, _dwContinuePollInterval, NULL);
        }

        // if there is no balloon info specified then there won't be a "balloon timeout" event
        // thus we need to do this ourselves. this lets people use this object for non balloon
        // notification icons
        if ((NULL == _pszTitle) && (NULL == _pszText))
        {
            SetTimer(_hwnd, IDT_NOBALLOON, _dwShowTime, NULL);
        }

        MSG msg;
        while (GetMessage(&msg, NULL, 0, 0))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
        hr = _hrDone;
        if (pqc)
        {
            KillTimer(_hwnd, IDT_QUERYCANCEL);  // in case any are in the queue
            _pqc = NULL;    // to avoid possible problems
        }
    }
    return hr;
}

HRESULT CUserNotification::PlaySound(LPCWSTR pszSoundName)
{
    SHPlaySound(pszSoundName);
    return S_OK;
}

// take down our notification icon
void CUserNotification::_RemoveNotifyIcon()
{
    NOTIFYICONDATA nid = { sizeof(nid), _hwnd, 0 };
    Shell_NotifyIcon(NIM_DELETE, &nid);
}

// the balloon related data (title, body test, dwInfoFlags, timeout
BOOL CUserNotification::_SyncInfo()
{
    BOOL bRet = FALSE;
    if (_hwnd)
    {
        NOTIFYICONDATA nid = { sizeof(nid), _hwnd, 0, NIF_INFO };
        if (_pszTitle)
            lstrcpyn(nid.szInfoTitle, _pszTitle, ARRAYSIZE(nid.szInfoTitle));
        if (_pszText)
            lstrcpyn(nid.szInfo, _pszText, ARRAYSIZE(nid.szInfo));
        nid.dwInfoFlags = _dwInfoFlags;
        nid.uTimeout = _dwShowTime;

        bRet = Shell_NotifyIcon(NIM_MODIFY, &nid);
    }
    return bRet;
}

BOOL CUserNotification::_SyncIcon()
{
    BOOL bRet = FALSE;
    if (_hwnd)
    {
        NOTIFYICONDATA nid = { sizeof(nid), _hwnd, 0, NIF_ICON | NIF_TIP};
        nid.hIcon = _hicon ? _hicon : LoadIcon(NULL, IDI_WINLOGO);
        if (_pszToolTip)
            lstrcpyn(nid.szTip, _pszToolTip, ARRAYSIZE(nid.szTip));

        bRet = Shell_NotifyIcon(NIM_MODIFY, &nid);
    }
    return bRet;
}

HRESULT CUserNotification::_GetWindow()
{
    HRESULT hr = S_OK;
    if (NULL == _hwnd)
    {
        _hwnd = SHCreateWorkerWindow(s_WndProc, NULL, 0, 0, NULL, this);
        if (_hwnd)
        {
            NOTIFYICONDATA nid = { sizeof(nid), _hwnd, 0, NIF_MESSAGE, WM_NOTIFY_MESSAGE };

            if (Shell_NotifyIcon(NIM_ADD, &nid))
            {
                _SyncIcon();
                _SyncInfo();
            }
            else
            {
                DestroyWindow(_hwnd);
                _hwnd = NULL;
                hr = E_FAIL;
            }
        }
    }
    return hr;
}

void CUserNotification::_DelayDestroy(HRESULT hrDone)
{
    _hrDone = hrDone;
    SetTimer(_hwnd, IDT_DESTROY, 250, NULL);
}

void CUserNotification::_Timeout()
{
    if (_cRetryCount)
    {
        _cRetryCount--;
        SetTimer(_hwnd, IDT_REMINDER, _dwInterval, NULL);
    }
    else
    {
        // timeout, same HRESULT as user cancel
        _DelayDestroy(HRESULT_FROM_WIN32(ERROR_CANCELLED)); 
    }
}

LRESULT CALLBACK CUserNotification::_WndProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;

    switch (uMsg)
    {
    case WM_NCDESTROY:
        SetWindowLongPtr(_hwnd, 0, NULL);
        _hwnd = NULL;
        break;

    case WM_TIMER:
        KillTimer(_hwnd, wParam);    // make all timers single shot
        switch (wParam)
        {
        case IDT_REMINDER:
            _SyncInfo();
            break;

        case IDT_DESTROY:
            _RemoveNotifyIcon();
            PostQuitMessage(0); // exit our msg loop
            break;

        case IDT_QUERYCANCEL:
            if (_pqc && (S_OK == _pqc->QueryContinue()))
                SetTimer(_hwnd, IDT_QUERYCANCEL, _dwContinuePollInterval, NULL);
            else
                _DelayDestroy(S_FALSE); // callback cancelled
            break;

        case IDT_NOBALLOON:
            _Timeout();
            break;
        }
        break;

    case WM_NOTIFY_MESSAGE:
        switch (lParam)
        {
        case NIN_BALLOONSHOW:
        case NIN_BALLOONHIDE:
            break;

        case NIN_BALLOONTIMEOUT:
            _Timeout();
            break;

        case NIN_BALLOONUSERCLICK:
        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
            _DelayDestroy(S_OK);    // user click
            break;

        default:
            break;
        }
        break;

    default:
        lres = DefWindowProc(_hwnd, uMsg, wParam, lParam);
        break;
    }
    return lres;
}

LRESULT CALLBACK CUserNotification::s_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CUserNotification *pun = (CUserNotification *)GetWindowLongPtr(hwnd, 0);

    if (WM_CREATE == uMsg)
    {
        CREATESTRUCT *pcs = (CREATESTRUCT *)lParam;
        pun = (CUserNotification *)pcs->lpCreateParams;
        pun->_hwnd = hwnd;
        SetWindowLongPtr(hwnd, 0, (LONG_PTR)pun);
    }

    return pun ? pun->_WndProc(uMsg, wParam, lParam) : DefWindowProc(hwnd, uMsg, wParam, lParam);
}

STDAPI CUserNotification_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr;
    CUserNotification* p = new CUserNotification();
    if (p)
    {
        hr = p->QueryInterface(riid, ppv);
        p->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *ppv = NULL;
    }
    return hr;
}

STDAPI SHBalloonMessage(const BALLOON_MESSAGE *pbm)
{
    HRESULT hr;

    if (sizeof(*pbm) == pbm->dwSize)
    {
        IUserNotification *pun;
        hr = CoCreateInstance(CLSID_UserNotification, NULL, CLSCTX_ALL,
                         IID_PPV_ARG(IUserNotification, &pun));
        if (SUCCEEDED(hr))
        {
            pun->SetBalloonRetry(-1, -1, pbm->cRetryCount);
            pun->SetIconInfo(pbm->hIcon ? pbm->hIcon : LoadIcon(NULL, IDI_WINLOGO), pbm->pszTitle);
            pun->SetBalloonInfo(pbm->pszTitle, pbm->pszText, pbm->dwInfoFlags);

            hr = pun->Show(NULL, 0);

            pun->Release();
        }
    }
    else
        hr = E_INVALIDARG;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\autocm.cpp ===
#include "shellprv.h"
#include "clsobj.h"
#include "dpa.h"
#include "ids.h"
#include "ole2dup.h"

/////////////////////////////////////////////////////////////////////////////
// CAutomationCM

class CAutomationCM :
    public IContextMenu,
    public IShellExtInit,
    public IPersistPropertyBag
{

public:

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    // *** IContextMenu methods ***
    STDMETHOD(QueryContextMenu)(THIS_
                                HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags);
    STDMETHOD(InvokeCommand)(THIS_
                             LPCMINVOKECOMMANDINFO pici);
    STDMETHOD(GetCommandString)(THIS_
                                UINT_PTR    idCmd,
                                UINT        uType,
                                UINT      * pwReserved,
                                LPSTR       pszName,
                                UINT        cchMax);

    // *** IShellExtInit methods ***
    STDMETHOD(Initialize)(THIS_
                          LPCITEMIDLIST pidlFolder,
                          IDataObject *pdtobj,
                          HKEY hkeyProgID) { return S_OK; }

    // *** IPersist methods ***
    STDMETHOD(GetClassID)(THIS_
                    CLSID *pclsid);


    // *** IPersistPropertyBag methods ***
    STDMETHOD(InitNew)(THIS);
    STDMETHOD(Load)(THIS_
                    IPropertyBag *pbg,
                    IErrorLog *plog);
    STDMETHOD(Save)(THIS_
                    IPropertyBag *pbg,
                    BOOL fClearDirty,
                    BOOL FSaveAllProperties) { return E_NOTIMPL; }

public:
    CAutomationCM() : _cRef(1) { }
private:
    ~CAutomationCM();

    static BOOL _DestroyVARIANTARG(VARIANTARG *pvarg, LPVOID)
    {
        ::VariantClear(pvarg);
        return TRUE;
    }

    enum {
        // Any method with more than MAXPARAMS parameters should be taken
        // outside and shot.
        // Note: If you change MAXPARAMS, make sure that szParamN[] is
        // big enough in IPersistPropertyBag::Load.
        MAXPARAMS = 1000,
    };

    LONG        _cRef;
    IDispatch * _pdisp;
    BSTR        _bsProperties;
    DISPID      _dispid;
    BOOL        _fInitialized;
    DISPPARAMS  _dp;
    CDSA<VARIANTARG> _dsaVarg;
    TCHAR       _szCommandName[MAX_PATH];
    TCHAR       _szMenuItem[MAX_PATH];
};

STDAPI CAutomationCM_CreateInstance(IUnknown * punkOuter, REFIID riid, void ** ppvOut)
{
    // clsobj.c should've filtered out the aggregated scenario already
    ASSERT(punkOuter == NULL);

    *ppvOut = NULL;
    CAutomationCM *pauto = new CAutomationCM;
    if (!pauto)
        return E_OUTOFMEMORY;

    HRESULT hr = pauto->QueryInterface(riid, ppvOut);
    pauto->Release();
    return hr;
}

CAutomationCM::~CAutomationCM()
{
    InitNew();
    ASSERT(!_dsaVarg);
}

// *** IUnknown::QueryInterface ***
HRESULT CAutomationCM::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =  {
        QITABENT(CAutomationCM, IContextMenu),          // IID_IContextMenu
        QITABENT(CAutomationCM, IShellExtInit),         // IID_IShellExtInit
        QITABENT(CAutomationCM, IPersist),              // IID_IPersist (base for IPersistPropertyBag)
        QITABENT(CAutomationCM, IPersistPropertyBag),   // IID_IPersistPropertyBag
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

// *** IUnknown::AddRef ***
STDMETHODIMP_(ULONG) CAutomationCM::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

// *** IUnknown::Release ***
STDMETHODIMP_(ULONG) CAutomationCM::Release()
{
    ULONG cRef = InterlockedDecrement(&_cRef);
    if (cRef)
        return cRef;

    delete this;
    return 0;
}

// *** IPersist::GetClassID ***
HRESULT CAutomationCM::GetClassID(CLSID *pclsid)
{
    *pclsid = CLSID_AutomationCM;
    return S_OK;
}

// *** IPersistPropertyBag::InitNew ***
HRESULT CAutomationCM::InitNew()
{
    ATOMICRELEASE(_pdisp);

    ::SysFreeString(_bsProperties);
    _bsProperties = NULL;

    // Free the DISPPARAMs
    if (_dsaVarg)
    {
        _dsaVarg.DestroyCallback(_DestroyVARIANTARG, 0);
    }
    _dp.cArgs = 0;

    _fInitialized = FALSE;

    return S_OK;
}

//
//  Property bag items:
//
//  CLSID = object to CoCreate(IID_IDispatch)
//  command = display name of command
//  method = name of method (GetIDsOfNames)
//  param1 .. paramN = parameters (up to MAXPARAMS)
//
//  Parameters are passed as BSTRs (or whatever type SHPropertyBagOnRegKey
//  returns.)
//
//  It is the responsibility of the target IDispatch to coerce the types
//  as appropriate.
//

// *** IPersistPropertyBag::Load ***
HRESULT CAutomationCM::Load(IPropertyBag *pbag, IErrorLog *plog)
{
    HRESULT hr;

    // Erase any old state
    InitNew();

    // Get the CLSID we are dispatching through
    CLSID clsid;
    hr = SHPropertyBag_ReadGUID(pbag, L"CLSID", &clsid);
    if (SUCCEEDED(hr))
    {
        // Must use SHExCoCreateInstance to go through the approval/app compat layer
        hr = SHExtCoCreateInstance(NULL, &clsid, NULL, IID_PPV_ARG(IDispatch, &_pdisp));
    }

    // Map the method to a DISPID
    if (SUCCEEDED(hr))
    {
        BSTR bs;
        hr = SHPropertyBag_ReadBSTR(pbag, L"method", &bs);
        if (SUCCEEDED(hr))
        {
            LPOLESTR pname = bs;
            hr = _pdisp->GetIDsOfNames(IID_NULL, &pname, 1, 0, &_dispid);
            ::SysFreeString(bs);
        }
    }

    // Read in the parameters
    if (SUCCEEDED(hr))
    {
        if (_dsaVarg.Create(4))
        {
            WCHAR szParamN[16]; // worst-case: "param1000"
            VARIANT var;

            while (_dsaVarg.GetItemCount() < MAXPARAMS)
            {
                wnsprintfW(szParamN, ARRAYSIZE(szParamN), L"param%d",
                           _dsaVarg.GetItemCount()+1);
                VariantInit(&var);
                var.vt = VT_BSTR;
                if (FAILED(pbag->Read(szParamN, &var, NULL)))
                {
                    // No more parameters
                    break;
                }
                if (_dsaVarg.AppendItem((VARIANTARG*)&var) < 0)
                {
                    ::VariantClear(&var);
                    hr =  E_OUTOFMEMORY;
                    break;
                }
            }
        }
        else
        {
            // Could not create _dsaVarg
            hr = E_OUTOFMEMORY;
        }
    }

    // Get the command name
    if (SUCCEEDED(hr))
    {
        hr = SHPropertyBag_ReadStr(pbag, L"command", _szCommandName, ARRAYSIZE(_szCommandName));
        if (SUCCEEDED(hr))
        {
            hr = SHLoadIndirectString(_szCommandName, _szCommandName, ARRAYSIZE(_szCommandName), NULL);
        }
    }

    // Get the properties string (optional)
    if (SUCCEEDED(hr))
    {
        if (SUCCEEDED(SHPropertyBag_ReadBSTR(pbag, L"properties", &_bsProperties)))
        {
            ASSERT(_bsProperties);

            // Ignore failure here; we'll detect it later
            SHPropertyBag_ReadStr(pbag, L"propertiestext", _szMenuItem, ARRAYSIZE(_szMenuItem));
            SHLoadIndirectString(_szMenuItem, _szMenuItem, ARRAYSIZE(_szMenuItem), NULL);
        }
    }

    _fInitialized = SUCCEEDED(hr);
    return hr;
}

// *** IContextMenu::QueryContextMenu ***
HRESULT CAutomationCM::QueryContextMenu(
                                HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags)
{
    if (!_fInitialized) return E_FAIL;

    HRESULT hr;

    // Must have room for two items (the command and possibly also Properties)
    if (idCmdFirst + 1 <= idCmdLast)
    {
        if (InsertMenuW(hmenu, indexMenu, MF_BYPOSITION | MF_STRING,
                        idCmdFirst, _szCommandName))
        {
            if (_szMenuItem[0])
            {
                InsertMenuW(hmenu, indexMenu+1, MF_BYPOSITION | MF_STRING,
                            idCmdFirst+1, _szMenuItem);
            }
        }
        hr = ResultFromShort(2); // number of items added
    }
    else
    {
        hr = E_FAIL; // unable to add items
    }

    return hr;
}

const LPCSTR c_rgAutoCMCommands[] = {
    "open",                     // command 0
    "properties",               // command 1 - optional
};

// *** IContextMenu::InvokeCommand ***
HRESULT CAutomationCM::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    if (!_fInitialized) return E_FAIL;

    HRESULT hr;

    int iCmd;

    if (!IS_INTRESOURCE(pici->lpVerb))
    {
        // If this loop fails to find a match, iCmd will be out of range
        // and will hit the "default:" in the switch statement below.
        for (iCmd = 0; iCmd < ARRAYSIZE(c_rgAutoCMCommands) - 1; iCmd++)
        {
            if (lstrcmpiA(pici->lpVerb, c_rgAutoCMCommands[iCmd]) == 0)
            {
                break;
            }
        }
    }
    else
    {
        iCmd = PtrToLong(pici->lpVerb);
    }

    switch (iCmd)
    {
    case 0:                     // open
        _dp.cArgs = _dsaVarg.GetItemCount();
        _dp.rgvarg = _dp.cArgs ? _dsaVarg.GetItemPtr(0) : NULL;
        hr = _pdisp->Invoke(_dispid, IID_NULL, 0, DISPATCH_METHOD, &_dp, NULL, NULL, NULL);
        break;

    case 1:
        if (_bsProperties)
        {
            hr = ShellExecCmdLine(pici->hwnd, _bsProperties,
                                  NULL, SW_SHOWNORMAL, NULL, 0) ? S_OK : E_FAIL;
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;

    default:
        hr = E_INVALIDARG;
        break;
    }

    return hr;
}

// *** IContextMenu::GetCommandString ***
HRESULT CAutomationCM::GetCommandString(
                                UINT_PTR    idCmd,
                                UINT        uType,
                                UINT      * pwReserved,
                                LPSTR       pszName,
                                UINT        cchMax)
{
    if (!_fInitialized) return E_FAIL;
    switch (uType)
    {
    case GCS_VERBA:
        if (idCmd < ARRAYSIZE(c_rgAutoCMCommands))
        {
            SHAnsiToAnsi(c_rgAutoCMCommands[idCmd], (LPSTR)pszName, cchMax);
            return S_OK;
        }
        break;

    case GCS_VERBW:
        if (idCmd < ARRAYSIZE(c_rgAutoCMCommands))
        {
            SHAnsiToUnicode(c_rgAutoCMCommands[idCmd], (LPWSTR)pszName, cchMax);
            return S_OK;
        }
        break;
    }

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\basefvcb.h ===
#ifndef _BASEFVCB_
#define _BASEFVCB_

#include <cowsite.h>

// base shell folder view callback to derive from

class CBaseShellFolderViewCB : public IShellFolderViewCB, 
                               public IServiceProvider, 
                               public CObjectWithSite
{
public:
    CBaseShellFolderViewCB(LPCITEMIDLIST pidl, LONG lEvents);
    STDMETHOD(RealMessage)(UINT uMsg, WPARAM wParam, LPARAM lParam) PURE;

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IShellFolderViewCB
    STDMETHODIMP MessageSFVCB(UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv) { *ppv = NULL; return E_NOTIMPL; };

protected:
    virtual ~CBaseShellFolderViewCB();

    HRESULT _BrowseObject(LPCITEMIDLIST pidlFull, UINT uFlags = 0)
    {
        IShellBrowser* psb;
        HRESULT hr = IUnknown_QueryService(_punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psb));
        if (SUCCEEDED(hr))
        {
            hr = psb->BrowseObject(pidlFull, uFlags);
            psb->Release();
        }
        return hr;
    }

    HWND _hwndMain;
    LONG _cRef;
    LPITEMIDLIST _pidl;
    LONG _lEvents;
};


// view callback helpers

typedef struct {
    ULONGLONG cbBytes;      // total size of items selected
    int nItems;             // number of items selected

    int cFiles;             // # of files
    int cHiddenFiles;       // # of hiddenf iles
    ULONGLONG cbSize;       // total size of selected files

    int cNonFolders;        // how many non-folders we have

    TCHAR szDrive[MAX_PATH];// drive info (if in explorer mode)
    ULONGLONG cbFree;       // drive free space
} FSSELCHANGEINFO;

// status bar helpers to be used from the view callback
STDAPI ViewUpdateStatusBar(IUnknown *psite, LPCITEMIDLIST pidlFolder, FSSELCHANGEINFO *pfssci);
STDAPI_(void) ViewInsertDeleteItem(IShellFolder2 *psf, FSSELCHANGEINFO *pfssci, LPCITEMIDLIST pidl, int iMul);
STDAPI_(void) ViewSelChange(IShellFolder2 *psf, SFVM_SELCHANGE_DATA* pdvsci, FSSELCHANGEINFO *pfssci);
STDAPI_(void) ResizeStatus(IUnknown *psite, UINT cx);
STDAPI_(void) InitializeStatus(IUnknown *psite);
STDAPI_(void) SetStatusText(IUnknown *psite, LPCTSTR *ppszText, int iStart, int iEnd);

// view callback helpers
STDAPI DefaultGetWebViewTemplateFromHandler(LPCTSTR pszKey, SFVM_WEBVIEW_TEMPLATE_DATA* pvi);
STDAPI DefaultGetWebViewTemplateFromClsid(REFCLSID clsid, SFVM_WEBVIEW_TEMPLATE_DATA* pvi);
STDAPI DefaultGetWebViewTemplateFromPath(LPCTSTR pszDir, SFVM_WEBVIEW_TEMPLATE_DATA* pvi);

#endif // _BASEFVCB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\bldtrack.h ===
//
// NT5 tracking is compiled into all NT builds, but only runs on
// NT5 by honoring the g_RunOnNT5 bool.
//

#if defined(WINNT)

#define ENABLE_TRACK 1
#define DM_TRACK 0x0100

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\bookmk.h ===
#ifndef _BOOKMK_H_
#define _BOOKMK_H_

#include "idlcomm.h"

STDAPI SHCreateStdEnumFmtEtc(UINT cfmt, const FORMATETC afmt[], IEnumFORMATETC **ppenumFormatEtc);
STDAPI SHCreateStdEnumFmtEtcEx(UINT cfmt, const FORMATETC afmt[], IDataObject *pdtInner, IEnumFORMATETC **ppenumFormatEtc);
STDAPI SHCreateBookMark(HWND hwnd, LPCTSTR pszPath, IDataObject *pDataObj, POINTL pt, DWORD *pdwEffect);

#endif // _BOOKMK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\bbckfldr.cpp ===
#include "shellprv.h"
#pragma hdrstop

#include "bitbuck.h"
#include "util.h"
#include "copy.h"
#include "prop.h" // for COLUMN_INFO
#include "propsht.h"
#include "datautil.h"
#include "vdate.h"      // for VDATEINPUTBUF
#include "views.h"
#include "defview.h"    // for WM_DSV_FSNOTIFY
#include "fsdata.h"
#include "idldrop.h"
#include "clsobj.h"
#include "basefvcb.h"
#include "idlcomm.h" // for HIDA
#include "filefldr.h"
#include <idhidden.h>
#include "enumidlist.h"
#include "contextmenu.h"

class CBitBucket;
class CBitBucketViewCB;
class CBitBucketEnum;
class CBitBucketDropTarget;
class CBitBucketData;

typedef struct  {
    CBitBucket *pbb;
    HWND hwnd;
    IDataObject *pdtobj;
    IStream *pstmDataObj;
    ULONG_PTR idCmd;
    POINT ptDrop;
    BOOL fSameHwnd;
    BOOL fDragDrop;
} BBTHREADDATA;


class CBitBucket :
    public IPersistFolder2,
    public IShellFolder2,
    public IContextMenu,
    public IShellPropSheetExt,
    public IShellExtInit
{
    friend CBitBucketEnum;
    friend CBitBucketViewCB;
    friend CBitBucketDropTarget;
    friend CBitBucketData;

public:
    CBitBucket();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    // IPersist
    STDMETHOD(GetClassID)(CLSID *pclsid);

    // IPersistFolder
    STDMETHOD(Initialize)(LPCITEMIDLIST pidl);

    // IPersistFolder2
    STDMETHOD(GetCurFolder)(LPITEMIDLIST *ppidl);

    // IShellFolder
    STDMETHOD(ParseDisplayName)(HWND hwnd, IBindCtx *pbc, LPOLESTR pszDisplayName, ULONG *pchEaten, LPITEMIDLIST *ppidl, ULONG *pdwAttributes);
    STDMETHOD(EnumObjects)(HWND hwnd, SHCONTF grfFlags, IEnumIDList **ppenumIDList);
    STDMETHOD(BindToObject)(LPCITEMIDLIST pidl, IBindCtx *pbc, REFIID riid, void **ppv);
    STDMETHOD(BindToStorage)(LPCITEMIDLIST pidl, IBindCtx *pbc, REFIID riid, void **ppv);
    STDMETHOD(CompareIDs)(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHOD(CreateViewObject)(HWND hwnd, REFIID riid, void **ppv);
    STDMETHOD(GetAttributesOf)(UINT cidl, LPCITEMIDLIST *apidl, SFGAOF *rgfInOut);
    STDMETHOD(GetUIObjectOf)(HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl, REFIID riid, UINT *rgfReserved, void **ppv);
    STDMETHOD(GetDisplayNameOf)(LPCITEMIDLIST pidl, SHGDNF dwFlags, LPSTRRET lpName);
    STDMETHOD(SetNameOf)(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, SHGDNF dwFlags, LPITEMIDLIST *ppidlOut);

    // IShellFolder2
    STDMETHOD(GetDefaultSearchGUID)(GUID *pguid);
    STDMETHOD(EnumSearches)(IEnumExtraSearch **ppenum);
    STDMETHOD(GetDefaultColumn)(DWORD dwRes, ULONG *pSort, ULONG *pDisplay);
    STDMETHOD(GetDefaultColumnState)(UINT iColumn, SHCOLSTATEF *pdwFlags);
    STDMETHOD(GetDetailsEx)(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv);
    STDMETHOD(GetDetailsOf)(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *psd);
    STDMETHOD(MapColumnToSCID)(UINT iColumn, SHCOLUMNID *pscid);

    // IContextMenu
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);
    STDMETHOD(GetCommandString)(UINT_PTR idCmd, UINT uType, UINT *pwReserved, LPSTR pszName, UINT cchMax);

    // IShellPropSheetExt
    STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);
    STDMETHOD(ReplacePage)(UINT uPageID, LPFNADDPROPSHEETPAGE pfnReplaceWith, LPARAM lParam);

    // IShellExtInit
    STDMETHOD(Initialize)(LPCITEMIDLIST pidlFolder, IDataObject *pdobj, HKEY hkeyProgID);

protected:
    LPITEMIDLIST DataEntryToIDList(BBDATAENTRYW *pbbde);
    LPITEMIDLIST PathToIDList(LPCTSTR pszPath);
    HGLOBAL BuildDestSpecs(LPIDA pida);

private:
    ~CBitBucket();

    static HRESULT CALLBACK _ItemMenuCallBack(IShellFolder *psf, HWND hwnd,
                IDataObject * pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static HRESULT CALLBACK _BackgroundMenuCallBack(IShellFolder *psf, HWND hwnd,
                IDataObject * pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static UINT CALLBACK _GlobalSettingsCalback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);
    static BOOL_PTR CALLBACK _FilePropDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static BOOL_PTR CALLBACK _DriveDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static BOOL_PTR CALLBACK _GlobalPropDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static DWORD CALLBACK _DispatchThreadProc(void *pv);
    static BOOL CALLBACK _AddPagesCallback(HPROPSHEETPAGE psp, LPARAM lParam);
    static DWORD WINAPI _DropThreadInit(BBTHREADDATA *pbbtd);
    static void _GlobalPropOnCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify);
    static CBitBucket *_FromFolder(IShellFolder *psf);
    
    HRESULT _LaunchThread(HWND hwnd, IDataObject *pdtobj, WPARAM idCmd);
    void _GetDeletedFileTime(LPCITEMIDLIST pidl, FILETIME *pft);
    DWORD _GetDeletedSize(LPCITEMIDLIST pidl);
    void _FileProperties(IDataObject *pdtobj);
    void _DefaultProperties();
    int _CompareOriginal(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    int _DriveIDFromIDList(LPCITEMIDLIST pidl);
    HRESULT _FolderFromIDList(LPCITEMIDLIST pidl, REFIID riid, void **ppv);
    HRESULT _FolderFromDrive(int idDrive, REFIID riid, void **ppv);
    HRESULT _InitBindCtx();
    BOOL _MapColIndex(UINT *piColumn);
    PUBBDATAENTRYA _IsValid(LPCITEMIDLIST pidl);
    HRESULT _OriginalPath(LPCITEMIDLIST pidl, TCHAR *pszOrig, UINT cch);
    HRESULT _OriginalDirectory(LPCITEMIDLIST pidl, TCHAR *pszOrig, UINT cch);

    void _RestoreFileList(HWND hwnd, IDataObject * pdtobj);
    void _NukeFileList(HWND hwnd, IDataObject * pdtobj);
    int _DataObjToFileOpString(IDataObject *pdtobj, LPTSTR *ppszSrc, LPTSTR *ppszDest);
    void _GetDriveDisplayName(int idDrive, LPTSTR pszName, UINT cchSize);
    HRESULT _Compare(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    LPITEMIDLIST _DriveInfoToIDList(int idDrive, int iIndex);
    DWORD _IsFolder(LPCITEMIDLIST pidl);
    UINT _SizeColumn();

    LONG _cRef;
    LPITEMIDLIST _pidl;
    UINT _uiColumnSize;

    IUnknown *_rgFolders[MAX_BITBUCKETS];
};

class CBitBucketViewCB : public CBaseShellFolderViewCB
{
public:
    STDMETHODIMP RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    friend HRESULT Create_CBitBucketViewCB(CBitBucket* psf, IShellFolderViewCB **ppsfvcb);
    CBitBucketViewCB(CBitBucket *pbbf) : CBaseShellFolderViewCB(pbbf->_pidl, 0), _pbbf(pbbf)
    { 
        ZeroMemory(&_fssci, sizeof(_fssci));
        _pbbf->AddRef();
    }
    ~CBitBucketViewCB()
    {
        _pbbf->Release();
    }

    HRESULT _HandleFSNotify(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);

    HRESULT OnBACKGROUNDENUM(DWORD pv)
    {
        return S_OK;
    }

    HRESULT OnGetCCHMax(DWORD pv, LPCITEMIDLIST wP, UINT *lP)
    {
        return S_OK;
    }

    HRESULT OnSelChange(DWORD pv, UINT wPl, UINT wPh, SFVM_SELCHANGE_DATA*lP)
    {
        ViewSelChange(_pbbf, lP, &_fssci);
        return S_OK;
    }

    HRESULT OnFSNotify(DWORD pv, LPCITEMIDLIST *ppidl, LPARAM lP)
    {
        return _HandleFSNotify((LONG)lP, ppidl[0], ppidl[1]);
    }

    HRESULT OnUpdateStatusBar(DWORD pv, BOOL wP)
    {
        return ViewUpdateStatusBar(_punkSite, _pidl, &_fssci);
    }

    HRESULT OnWindowCreated(DWORD pv, HWND hwnd)
    {
        for (int i = 0; i < MAX_BITBUCKETS; i++)
        {
            SHChangeNotifyEntry fsne = {0};

            ASSERT(FALSE == fsne.fRecursive);

            // make it if it's there so that we'll get any events
            if (MakeBitBucket(i))
            {
                fsne.pidl = g_pBitBucket[i]->pidl;
                UINT u = SHChangeNotifyRegister(hwnd, SHCNRF_NewDelivery | SHCNRF_ShellLevel | SHCNRF_InterruptLevel,
                                           SHCNE_DISKEVENTS, WM_DSV_FSNOTIFY,  1,  &fsne);
            }
        }

        // _fssci.szDrive[0] == '\0'   // no drive specific stuff
        InitializeStatus(_punkSite);
        return S_OK;
    }

    HRESULT OnInsertDeleteItem(int iMul, LPCITEMIDLIST pidl)
    {
        ViewInsertDeleteItem(_pbbf, &_fssci, pidl, iMul);
        //since recycle bin doesn't receive shcne_xxx
        //defview doesn't update status bar
        OnUpdateStatusBar(0, FALSE);
        return S_OK;
    }

    HRESULT OnWindowDestroy(DWORD pv, HWND hwnd)
    {
        SHChangeNotifyDeregisterWindow(hwnd);   // deregister all
        return S_OK;
    }

    HRESULT OnSize(DWORD pv, UINT cx, UINT cy)
    {
        ResizeStatus(_punkSite, cx);
        return S_OK;
    }

    HRESULT OnEnumeratedItems(DWORD pv, UINT celt, LPCITEMIDLIST *rgpidl)
    {
        _cItems = celt;
        return S_OK;
    }

    HRESULT OnDefViewMode(DWORD pv, FOLDERVIEWMODE*lP)
    {
        if (_cItems < DEFVIEW_FVM_MANY_CUTOFF)
            *lP = FVM_TILE;
        else
            *lP = FVM_ICON;
        return S_OK;
    }

    HRESULT OnGetHelpTopic(DWORD pv, SFVM_HELPTOPIC_DATA *phtd)
    {
        if (IsOS(OS_ANYSERVER))
        {
            StrCpyW(phtd->wszHelpFile, L"recycle.chm > windefault");
        }
        else
        {
            StrCpyW(phtd->wszHelpTopic, L"hcp://services/subsite?node=Unmapped/Recycle_Bin");
        }
        return S_OK;
    }

    FSSELCHANGEINFO _fssci;
    CBitBucket *_pbbf;
    UINT _cItems;

    // Web View implementation
    HRESULT OnGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData);
    HRESULT OnGetWebViewContent(DWORD pv, SFVM_WEBVIEW_CONTENT_DATA* pData);
    HRESULT OnGetWebViewTasks(DWORD pv, SFVM_WEBVIEW_TASKSECTION_DATA* pTasks);
public:
    static HRESULT _OnEmptyRecycleBin(IUnknown* pv,IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnRestore(IUnknown* pv,IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _HaveDeletedItems(IUnknown* pv,IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
};

HRESULT Create_CBitBucketViewCB(CBitBucket* psf, IShellFolderViewCB **ppsfvcb)
{
    HRESULT hr;
    CBitBucketViewCB* psfvcb = new CBitBucketViewCB(psf);
    if (psfvcb)
    {
        *ppsfvcb = SAFECAST(psfvcb, IShellFolderViewCB*);
        hr = S_OK;
    }
    else
    {
        *ppsfvcb = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CBitBucketViewCB::OnGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData)
{
    ZeroMemory(pData, sizeof(*pData));
    pData->dwLayout = SFVMWVL_NORMAL;
    return S_OK;
}

HRESULT CBitBucketViewCB::_OnEmptyRecycleBin(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CBitBucketViewCB* pThis = (CBitBucketViewCB*)(void*)pv;

    HRESULT hr = SHInvokeCommandOnPidl(pThis->_hwndMain, NULL, pThis->_pidl, 0, "empty");

    if (S_FALSE == hr)
        MessageBeep(0); // let the user know the click was processed, but nothing was there to delete

    return hr;
}

HRESULT CBitBucketViewCB::_OnRestore(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    IDataObject *pdo;
    CBitBucketViewCB* pThis = (CBitBucketViewCB*)(void*)pv;
    HRESULT hr = S_OK;

    if (!psiItemArray)
    {
        hr = E_FAIL;

        IFolderView* pfv;
        if (pThis->_punkSite && SUCCEEDED(pThis->_punkSite->QueryInterface(IID_PPV_ARG(IFolderView, &pfv))))
        {
            hr = pfv->Items(SVGIO_ALLVIEW, IID_PPV_ARG(IDataObject, &pdo));
            pfv->Release();
        }
    }
    else
    {
        hr = psiItemArray->BindToHandler(NULL,BHID_DataObject,IID_PPV_ARG(IDataObject,&pdo));
    }


    if (SUCCEEDED(hr))
    {
        hr = SHInvokeCommandOnDataObject(pThis->_hwndMain, NULL, pdo, 0, "undelete");
        ATOMICRELEASE(pdo);
    }

    return hr;
}

HRESULT CBitBucketViewCB::_HaveDeletedItems(IUnknown* /*pv*/,IShellItemArray * /* psiItemArray */, BOOL /*fOkToBeSlow*/, UISTATE* puisState)
{
    *puisState = IsRecycleBinEmpty() ? UIS_DISABLED : UIS_ENABLED;
    return S_OK;
}

const WVTASKITEM c_BitBucketTaskHeader = WVTI_HEADER(L"shell32.dll", IDS_HEADER_BITBUCKET, IDS_HEADER_BITBUCKET_TT);
const WVTASKITEM c_BitBucketTaskList[] =
{
    WVTI_ENTRY_ALL(CLSID_NULL, L"shell32.dll", IDS_TASK_EMPTYRECYCLEBIN, IDS_TASK_EMPTYRECYCLEBIN_TT, IDI_TASK_EMPTYRECYCLEBIN, CBitBucketViewCB::_HaveDeletedItems, CBitBucketViewCB::_OnEmptyRecycleBin),
    WVTI_ENTRY_ALL_TITLE(CLSID_NULL, L"shell32.dll", IDS_TASK_RESTORE_ALL, IDS_TASK_RESTORE_ITEM, IDS_TASK_RESTORE_ITEM, IDS_TASK_RESTORE_ITEMS, IDS_TASK_RESTORE_TT, IDI_TASK_RESTOREITEMS, CBitBucketViewCB::_HaveDeletedItems, CBitBucketViewCB::_OnRestore),
};

HRESULT CBitBucketViewCB::OnGetWebViewContent(DWORD pv, SFVM_WEBVIEW_CONTENT_DATA* pData)
{
    ZeroMemory(pData, sizeof(*pData));

    Create_IUIElement(&c_BitBucketTaskHeader, &(pData->pFolderTaskHeader));

    LPCTSTR rgcsidl[] = { MAKEINTRESOURCE(CSIDL_DESKTOP), MAKEINTRESOURCE(CSIDL_PERSONAL), MAKEINTRESOURCE(CSIDL_DRIVES), MAKEINTRESOURCE(CSIDL_NETWORK) };
    CreateIEnumIDListOnCSIDLs(NULL, rgcsidl, ARRAYSIZE(rgcsidl), &(pData->penumOtherPlaces));

    return S_OK;
}

HRESULT CBitBucketViewCB::OnGetWebViewTasks(DWORD pv, SFVM_WEBVIEW_TASKSECTION_DATA* pTasks)
{
    ZeroMemory(pTasks, sizeof(*pTasks));

    pTasks->dwUpdateFlags = SFVMWVTSDF_CONTENTSCHANGE;
    Create_IEnumUICommand((IUnknown*)(void*)this, c_BitBucketTaskList, ARRAYSIZE(c_BitBucketTaskList), &pTasks->penumFolderTasks);

    return S_OK;
}




HRESULT CBitBucketViewCB::_HandleFSNotify(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    HRESULT hr = S_OK;
    TCHAR szPath[MAX_PATH];

    // pidls must be child of drives or network
    // (actually only drives work for right now)
    // that way we won't get duplicate events
    if ((!ILIsParent((LPCITEMIDLIST)&c_idlDrives, pidl1, FALSE) && !ILIsParent((LPCITEMIDLIST)&c_idlNet, pidl1, FALSE)) ||
        (pidl2 && !ILIsParent((LPCITEMIDLIST)&c_idlDrives, pidl2, FALSE) && !ILIsParent((LPCITEMIDLIST)&c_idlNet, pidl2, FALSE)))
    {
        return S_FALSE;
    }

    SHGetPathFromIDList(pidl1, szPath);
    LPTSTR pszFileName = PathFindFileName(szPath);

    if (!lstrcmpi(pszFileName, c_szInfo2) ||
        !lstrcmpi(pszFileName, c_szInfo) ||
        !lstrcmpi(pszFileName, c_szDesktopIni))
    {
        // we ignore changes to these files because they mean we were simply doing bookeeping 
        // (eg updating the info file, re-creating the desktop.ini, etc)
        return S_FALSE;
    }

    switch (lEvent)
    {
    case SHCNE_RENAMEFOLDER:
    case SHCNE_RENAMEITEM:
        {
            // if the rename's target is in a bitbucket, then do a create.
            // otherwise, return S_OK..

            int idDrive = DriveIDFromBBPath(szPath);

            if (MakeBitBucket(idDrive) && ILIsParent(g_pBitBucket[idDrive]->pidl, pidl1, TRUE))
            {
                hr = _HandleFSNotify((lEvent == SHCNE_RENAMEITEM) ? SHCNE_DELETE : SHCNE_RMDIR, pidl1, NULL);
            }
        }
        break;

    case SHCNE_CREATE:
    case SHCNE_MKDIR:
        {
            LPITEMIDLIST pidl = _pbbf->PathToIDList(szPath);
            if (pidl)
            {
                ShellFolderView_AddObject(_hwndMain, pidl);
                hr = S_FALSE;
            }
        }
        break;

    case SHCNE_DELETE:
    case SHCNE_RMDIR: 
        // if this was a delete into the recycle bin, pidl2 will exist
        if (pidl2)
        {
            hr = _HandleFSNotify((lEvent == SHCNE_DELETE) ? SHCNE_CREATE : SHCNE_MKDIR, pidl2, NULL);
        }
        else
        {
            ShellFolderView_RemoveObject(_hwndMain, ILFindLastID(pidl1));
            hr = S_FALSE;
        }
        break;

    case SHCNE_UPDATEDIR:
        // we recieved an updatedir, which means we probably had more than 10 fsnotify events come in,
        // so we just refresh our brains out.
        ShellFolderView_RefreshAll(_hwndMain);
        break;

    default:
        hr = S_FALSE;   // didn't handle this message
        break;
    }

    return hr;
}



STDMETHODIMP CBitBucketViewCB::RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    HANDLE_MSG(0, SFVM_GETHELPTOPIC, OnGetHelpTopic);
    HANDLE_MSG(0, SFVM_GETCCHMAX, OnGetCCHMax);
    HANDLE_MSG(0, SFVM_SELCHANGE, OnSelChange);
    HANDLE_MSG(0, SFVM_FSNOTIFY, OnFSNotify);
    HANDLE_MSG(0, SFVM_UPDATESTATUSBAR, OnUpdateStatusBar);
    HANDLE_MSG(0, SFVM_WINDOWCREATED, OnWindowCreated);
    HANDLE_MSG(1 , SFVM_INSERTITEM, OnInsertDeleteItem);
    HANDLE_MSG(-1, SFVM_DELETEITEM, OnInsertDeleteItem);
    HANDLE_MSG(0, SFVM_WINDOWDESTROY, OnWindowDestroy);
    HANDLE_MSG(0, SFVM_ENUMERATEDITEMS, OnEnumeratedItems);
    HANDLE_MSG(0, SFVM_DEFVIEWMODE, OnDefViewMode);
    HANDLE_MSG(0, SFVM_SIZE, OnSize);
    HANDLE_MSG(0, SFVM_BACKGROUNDENUM, OnBACKGROUNDENUM);
    HANDLE_MSG(0, SFVM_GETWEBVIEWLAYOUT, OnGetWebViewLayout);
    HANDLE_MSG(0, SFVM_GETWEBVIEWCONTENT, OnGetWebViewContent);
    HANDLE_MSG(0, SFVM_GETWEBVIEWTASKS, OnGetWebViewTasks);

    default:
        return E_FAIL;
    }

    return S_OK;
}

typedef struct _bbpropsheetinfo
{
    PROPSHEETPAGE psp;

    int idDrive;

    BOOL fNukeOnDelete;
    BOOL fOriginalNukeOnDelete;

    int iPercent;
    int iOriginalPercent;

    // the following two fields are valid only for the "global" tab, where they represent the state
    // of the "Configure drives independently" / "Use one setting for all drives" checkbox
    BOOL fUseGlobalSettings;
    BOOL fOriginalUseGlobalSettings;

    // the following fields are for policy overrides
    BOOL fPolicyNukeOnDelete;
    BOOL fPolicyPercent;

    // this is a pointer to the global property sheet page after it has been copied somewhere by the 
    // CreatePropertySheetPage(), we use this to get to the global state of the % slider and fNukeOnDelete
    // from the other tabs
    struct _bbpropsheetinfo* pGlobal;
} BBPROPSHEETINFO;


const static DWORD aBitBucketPropHelpIDs[] = {  // Context Help IDs
    IDD_ATTR_GROUPBOX,  IDH_COMM_GROUPBOX,
    IDC_INDEPENDENT,    IDH_RECYCLE_CONFIG_INDEP,
    IDC_GLOBAL,         IDH_RECYCLE_CONFIG_ALL,
    IDC_DISKSIZE,       IDH_RECYCLE_DRIVE_SIZE,
    IDC_DISKSIZEDATA,   IDH_RECYCLE_DRIVE_SIZE,
    IDC_BYTESIZE,       IDH_RECYCLE_BIN_SIZE,
    IDC_BYTESIZEDATA,   IDH_RECYCLE_BIN_SIZE,
    IDC_NUKEONDELETE,   IDH_RECYCLE_PURGE_ON_DEL,
    IDC_BBSIZE,         IDH_RECYCLE_MAX_SIZE,
    IDC_BBSIZETEXT,     IDH_RECYCLE_MAX_SIZE,
    IDC_CONFIRMDELETE,  IDH_DELETE_CONFIRM_DLG,
    IDC_TEXT,           NO_HELP,
    0, 0
};

const static DWORD aBitBucketHelpIDs[] = {  // Context Help IDs
    IDD_LINE_1,        NO_HELP,
    IDD_LINE_2,        NO_HELP,
    IDD_ITEMICON,      IDH_FPROP_GEN_ICON,
    IDD_NAME,          IDH_FPROP_GEN_NAME,
    IDD_FILETYPE_TXT,  IDH_FPROP_GEN_TYPE,
    IDD_FILETYPE,      IDH_FPROP_GEN_TYPE,
    IDD_FILESIZE_TXT,  IDH_FPROP_GEN_SIZE,
    IDD_FILESIZE,      IDH_FPROP_GEN_SIZE,
    IDD_LOCATION_TXT,  IDH_FCAB_DELFILEPROP_LOCATION,
    IDD_LOCATION,      IDH_FCAB_DELFILEPROP_LOCATION,
    IDD_DELETED_TXT,   IDH_FCAB_DELFILEPROP_DELETED,
    IDD_DELETED,       IDH_FCAB_DELFILEPROP_DELETED,
    IDD_CREATED_TXT,   IDH_FPROP_GEN_DATE_CREATED,
    IDD_CREATED,       IDH_FPROP_GEN_DATE_CREATED,
    IDD_READONLY,      IDH_FCAB_DELFILEPROP_READONLY,
    IDD_HIDDEN,        IDH_FCAB_DELFILEPROP_HIDDEN,
    IDD_ARCHIVE,       IDH_FCAB_DELFILEPROP_ARCHIVE,
    IDD_ATTR_GROUPBOX, IDH_COMM_GROUPBOX,
    0, 0
};

CBitBucket::CBitBucket() : _cRef(1), _pidl(NULL), _uiColumnSize(-1)
{
}

CBitBucket::~CBitBucket()
{
    for (int i = 0; i < ARRAYSIZE(_rgFolders); i++)
    {
        if (_rgFolders[i])
            _rgFolders[i]->Release();
    }

    ILFree(_pidl);
}

STDMETHODIMP CBitBucket::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CBitBucket, IPersistFolder2),                      // IID_IPersistFolder2
        QITABENTMULTI(CBitBucket, IPersistFolder, IPersistFolder2), // IID_IPersistFolder
        QITABENT(CBitBucket, IShellFolder2),                        // IID_IShellFolder2
        QITABENTMULTI(CBitBucket, IShellFolder, IShellFolder2),     // IID_IShellFolder
        QITABENT(CBitBucket, IContextMenu),                         // IID_IContextMenu
        QITABENT(CBitBucket, IShellPropSheetExt),                   // IID_IShellPropSheetExt
        QITABENT(CBitBucket, IShellExtInit),                        // IID_IShellExtInit
        { 0 },                             
    };
    HRESULT hr = QISearch(this, qit, riid, ppv);
    if (FAILED(hr) && riid == CLSID_RecycleBin)
    {
        *ppv = this;                // not ref counted
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP_(ULONG) CBitBucket::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CBitBucket::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;
    delete this;
    return 0;
}

#pragma pack(1)
typedef struct {
    HIDDENITEMID hid;
    BBDATAENTRYA bbde;
} HIDDENRECYCLEBINDATA;
#pragma pack()
    
typedef HIDDENRECYCLEBINDATA UNALIGNED *PUHIDDENRECYCLEBINDATA;
#define HRBD_CURRENTVERSION 0

PUBBDATAENTRYA CBitBucket::_IsValid(LPCITEMIDLIST pidl)
{
    if (pidl)
    {
        PUHIDDENRECYCLEBINDATA phrbd = (PUHIDDENRECYCLEBINDATA)ILFindHiddenID(pidl, IDLHID_RECYCLEBINDATA);
        if (phrbd && phrbd->hid.wVersion >= HRBD_CURRENTVERSION)
            return &phrbd->bbde;
    }
    return NULL;
}

HRESULT CBitBucket::_OriginalPath(LPCITEMIDLIST pidl, TCHAR *pszOrig, UINT cch)
{
    ASSERT(pidl == ILFindLastID(pidl));

    *pszOrig = 0;
    HRESULT hr;
    PUBBDATAENTRYA pbbde = _IsValid(pidl);
    if (pbbde)
    {
        if (!ILGetHiddenString(pidl, IDLHID_RECYCLEBINORIGINAL, pszOrig, cch))
        {
            SHAnsiToTChar(pbbde->szOriginal, pszOrig, cch);
        }
        hr = *pszOrig ? S_OK : S_FALSE;
    }
    else
    {
        ASSERTMSG(pbbde != NULL, "_OriginalPath: caller needs to call _IsValid on the pidl passed to us!");
        hr = E_FAIL;
    }
    return hr;
}

HRESULT CBitBucket::_OriginalDirectory(LPCITEMIDLIST pidl, TCHAR *pszOrig, UINT cch)
{
    HRESULT hr = _OriginalPath(pidl, pszOrig, cch);
    if (SUCCEEDED(hr))
        PathRemoveFileSpec(pszOrig);
    return hr;
}

// subclass member function to support CF_HDROP and CF_NETRESOURCE
// in:
//      hida    bitbucket id array
//
// out:
//      HGLOBAL with double NULL terminated string list of destination names
//

HGLOBAL CBitBucket::BuildDestSpecs(LPIDA pida)
{
    LPCITEMIDLIST pidl;
    TCHAR szTemp[MAX_PATH];
    UINT cbAlloc = sizeof(TCHAR);    // for double NULL termination

    for (UINT i = 0; pidl = IDA_GetIDListPtr(pida, i); i++)
    {
        _OriginalPath(pidl, szTemp, ARRAYSIZE(szTemp));

        cbAlloc += lstrlen(PathFindFileName(szTemp)) * sizeof(TCHAR) + sizeof(TCHAR);
    }
    LPTSTR pszRet = (LPTSTR) LocalAlloc(LPTR, cbAlloc);
    if (pszRet)
    {
        LPTSTR pszDest = pszRet;
        for (i = 0; pidl = IDA_GetIDListPtr(pida, i); i++)
        {
            _OriginalPath(pidl, szTemp, ARRAYSIZE(szTemp));
            lstrcpy(pszDest, PathFindFileName(szTemp));
            pszDest += lstrlen(pszDest) + 1;

            ASSERT((ULONG_PTR)((LPBYTE)pszDest - (LPBYTE)pszRet) < cbAlloc);
            ASSERT(*(pszDest) == 0);    // zero init alloc
        }
        ASSERT((LPTSTR)((LPBYTE)pszRet + cbAlloc - sizeof(TCHAR)) == pszDest);
        ASSERT(*pszDest == 0);  // zero init alloc
    }
    return pszRet;
}

class CBitBucketData : public CFSIDLData
{
public:
    CBitBucketData(CBitBucket *pbbf, UINT cidl, LPCITEMIDLIST apidl[]): CFSIDLData(pbbf->_pidl, cidl, apidl, NULL), _pbbf(pbbf) 
    { 
        _pbbf->AddRef();
    }

    // IDataObject methods overwrite
    STDMETHODIMP GetData(FORMATETC *pFmtEtc, STGMEDIUM *pstm);
    STDMETHODIMP QueryGetData(FORMATETC *pFmtEtc);

private:
    ~CBitBucketData()
    {
        _pbbf->Release();
    }

    CBitBucket *_pbbf;
};

STDMETHODIMP CBitBucketData::QueryGetData(FORMATETC * pformatetc)
{
    ASSERT(g_cfFileNameMap);

    if (pformatetc->cfFormat == g_cfFileNameMap && (pformatetc->tymed & TYMED_HGLOBAL))
    {
        return S_OK; // same as S_OK
    }
    return CFSIDLData::QueryGetData(pformatetc);
}

STDMETHODIMP CBitBucketData::GetData(FORMATETC * pformatetcIn, STGMEDIUM * pmedium)
{
    HRESULT hr = E_INVALIDARG;

    ASSERT(g_cfFileNameMap);

    if (pformatetcIn->cfFormat == g_cfFileNameMap && (pformatetcIn->tymed & TYMED_HGLOBAL))
    {
        STGMEDIUM medium;

        LPIDA pida = DataObj_GetHIDA(this, &medium);
        if (medium.hGlobal)
        {
            pmedium->hGlobal = _pbbf->BuildDestSpecs(pida);
            pmedium->tymed = TYMED_HGLOBAL;
            pmedium->pUnkForRelease = NULL;

            HIDA_ReleaseStgMedium(pida, &medium);

            hr = pmedium->hGlobal ? S_OK : E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = CFSIDLData::GetData(pformatetcIn, pmedium);
    }

    return hr;
}

//
// We need to be able to compare the names of two bbpidls.  Since either of
// them could be a unicode name, we might have to convert both to unicode.
//
int CBitBucket::_CompareOriginal(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    TCHAR szOrig1[MAX_PATH], szOrig2[MAX_PATH];
    
    if (SUCCEEDED(_OriginalPath(pidl1, szOrig1, ARRAYSIZE(szOrig1))) &&
        SUCCEEDED(_OriginalPath(pidl2, szOrig2, ARRAYSIZE(szOrig2))))
    {
        PathRemoveFileSpec(szOrig1);
        PathRemoveFileSpec(szOrig2);
        return lstrcmpi(szOrig1,szOrig2);
    }
    
    return -1;  // failure, say 2 > 1
}

// we are cheating here passing pidl1 and pidl2 to one folder when
// the could have come from different folders. but since these are
// file system we can get away with this, see findfldr.cpp for the
// code to deal with this in the general case

HRESULT CBitBucket::_Compare(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    IShellFolder *psf;
    HRESULT hr = _FolderFromIDList(pidl1, IID_PPV_ARG(IShellFolder, &psf));
    if (SUCCEEDED(hr))
    {
        hr = psf->CompareIDs(lParam, pidl1, pidl2);
        psf->Release();
    }
    return hr;
}

enum
{
    ICOL_NAME = 0,
    ICOL_ORIGINAL = 1,
    ICOL_DATEDELETED = 2,
};

const COLUMN_INFO c_bb_cols[] = 
{
    DEFINE_COL_STR_ENTRY(SCID_NAME,             30, IDS_NAME_COL),
    DEFINE_COL_STR_ENTRY(SCID_DELETEDFROM,      30, IDS_DELETEDFROM_COL),
    DEFINE_COL_DATE_ENTRY(SCID_DATEDELETED,         IDS_DATEDELETED_COL),
};

STDMETHODIMP CBitBucket::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    HRESULT hr = E_INVALIDARG;

    ASSERT(pidl1 == ILFindLastID(pidl1));

    UINT iColumn = ((DWORD)lParam & SHCIDS_COLUMNMASK);

    PUBBDATAENTRYA pbbde1 = _IsValid(pidl1);    // both may be NULL for pure FS pidl
    PUBBDATAENTRYA pbbde2 = _IsValid(pidl2);    // generated by change notify

    if (_MapColIndex(&iColumn))
    {
        switch (iColumn)
        {
        case ICOL_NAME:
            // compare the real filenames first, if they are different,
            // try comparing the display name
            hr = _Compare(lParam, pidl1, pidl2);
            if (0 == hr)
                return hr;  // fs pidl comapre says they are the same
            else
            {
                TCHAR sz1[MAX_PATH], sz2[MAX_PATH];
                DisplayNameOf(this, pidl1, SHGDN_INFOLDER, sz1, ARRAYSIZE(sz1));
                DisplayNameOf(this, pidl2, SHGDN_INFOLDER, sz2, ARRAYSIZE(sz2));
                int iRes = StrCmpLogicalRestricted(sz1, sz2);
                if (iRes)
                    return ResultFromShort(iRes);

                if (pbbde1 && pbbde2)
                    return ResultFromShort(pbbde1->idDrive - pbbde2->idDrive);
            }
            break;

        case ICOL_ORIGINAL:
            {
                int iRes = _CompareOriginal(pidl1, pidl2);
                if (iRes)
                    return ResultFromShort(iRes);
            }
            break;

        case ICOL_DATEDELETED:
            {
                FILETIME ft1, ft2;
                _GetDeletedFileTime(pidl1, &ft1);
                _GetDeletedFileTime(pidl2, &ft2);
                int iRes = CompareFileTime(&ft1, &ft2);
                if (iRes)
                    return ResultFromShort(iRes);
            }
            break;
        }
        lParam &= ~SHCIDS_COLUMNMASK;   // fall thorugh to sort on name...
    }
    else if (pbbde1 && pbbde2 && (_SizeColumn() == iColumn))
    {
        if (pbbde1->dwSize < pbbde2->dwSize)
            return ResultFromShort(-1);
        if (pbbde1->dwSize > pbbde2->dwSize)
            return ResultFromShort(1);
        lParam &= ~SHCIDS_COLUMNMASK;   // fall thorugh to sort on name...
    }
    else
    {
        lParam = (lParam & ~SHCIDS_COLUMNMASK) | iColumn;
    }

    return _Compare(lParam, pidl1, pidl2);
}

STDMETHODIMP CBitBucket::GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG *rgfOut)
{
    HRESULT hr;
    if (IsSelf(cidl, apidl))
    {
        // asking about folder as a whole
        *rgfOut = SFGAO_FOLDER | SFGAO_DROPTARGET | SFGAO_HASPROPSHEET;

        if (SHRestricted(REST_BITBUCKNOPROP))
        {
            *rgfOut &= ~SFGAO_HASPROPSHEET;
        }

        hr = S_OK;
    }
    else
    {
        IShellFolder *psf;
        hr = _FolderFromIDList(apidl[0], IID_PPV_ARG(IShellFolder, &psf));
        if (SUCCEEDED(hr))
        {
            hr = psf->GetAttributesOf(cidl, apidl, rgfOut);
            psf->Release();
            // only allow these attributes to be returned
            *rgfOut &= (SFGAO_CANMOVE | SFGAO_CANDELETE | SFGAO_HASPROPSHEET | SFGAO_FILESYSANCESTOR | SFGAO_FILESYSTEM | SFGAO_LINK);
        }
    }
    return hr;
}

int CBitBucket::_DataObjToFileOpString(IDataObject *pdtobj, LPTSTR *ppszSrc, LPTSTR *ppszDest)
{
    int cItems = 0;
    STGMEDIUM medium;
    LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);

    *ppszSrc = NULL;
    *ppszDest = NULL;

    if (pida)
    {
        cItems = pida->cidl;

        // start with null terminated strings
        int cchSrc = 1, cchDest = 1;
        
        LPTSTR pszSrc = (LPTSTR)LocalAlloc(LPTR, cchSrc * sizeof(TCHAR));
        LPTSTR pszDest = (LPTSTR)LocalAlloc(LPTR, cchDest * sizeof(TCHAR));

        if (!pszSrc || !pszDest)
        {
            // skip the loop and fail
            cItems = 0;
        }

        for (int i = 0 ; i < cItems; i++) 
        {
            LPITEMIDLIST pidl = IDA_FullIDList(pida, i);
            if (pidl)
            {
                TCHAR szTemp[MAX_PATH];

                // src
                SHGetPathFromIDList(pidl, szTemp);

                // Done with this already. Free now in case we exit early.
                ILFree(pidl);

                int cchSrcFile = lstrlen(szTemp) + 1;
                LPTSTR psz = (LPTSTR)LocalReAlloc((HLOCAL)pszSrc, (cchSrc + cchSrcFile) * sizeof(TCHAR), LMEM_MOVEABLE | LMEM_ZEROINIT);
                if (psz)
                {
                    pszSrc = psz;
                    lstrcpy(pszSrc + cchSrc - 1, szTemp);
                    cchSrc += cchSrcFile;
                }
                else
                {
                    cItems = 0;
                    break;
                }

                // dest
                _OriginalPath(IDA_GetIDListPtr(pida, i), szTemp, ARRAYSIZE(szTemp));

                int cchDestFile = lstrlen(szTemp) + 1;
                psz = (LPTSTR)LocalReAlloc((HLOCAL)pszDest, (cchDest + cchDestFile) * sizeof(TCHAR), LMEM_MOVEABLE | LMEM_ZEROINIT);
                if (psz)
                {
                    pszDest = psz;
                    lstrcpy(pszDest + cchDest - 1, szTemp);
                    cchDest += cchDestFile;
                }
                else
                {
                    // out of memory!
                    cItems = 0;
                    break;
                }
            }
        }

        if (0 == cItems)
        {
            // ok to pass NULL here
            LocalFree((HLOCAL)pszSrc);
            LocalFree((HLOCAL)pszDest);
        }
        else
        {
            *ppszSrc = pszSrc;
            *ppszDest = pszDest;
        }

        HIDA_ReleaseStgMedium(pida, &medium);
    }
    return cItems;
}


//
// restores the list of files in the IDataObject
//
void CBitBucket::_RestoreFileList(HWND hwnd, IDataObject * pdtobj)
{
    LPTSTR pszSrc, pszDest;

    if (_DataObjToFileOpString(pdtobj, &pszSrc, &pszDest))
    {
        // now do the actual restore.
        SHFILEOPSTRUCT sFileOp = { hwnd, FO_MOVE, pszSrc, pszDest,
                                   FOF_MULTIDESTFILES | FOF_SIMPLEPROGRESS | FOF_NOCONFIRMMKDIR,
                                   FALSE, NULL, MAKEINTRESOURCE(IDS_BB_RESTORINGFILES)};

        DECLAREWAITCURSOR;

        SetWaitCursor();

        if (SHFileOperation(&sFileOp) == ERROR_SUCCESS)
        {
            SHChangeNotifyHandleEvents();
            BBCheckRestoredFiles(pszSrc);
        }

        LocalFree((HLOCAL)pszSrc);
        LocalFree((HLOCAL)pszDest);

        ResetWaitCursor();
    }
}


//
// nukes the list of files in the IDataObject
//
void CBitBucket::_NukeFileList(HWND hwnd, IDataObject * pdtobj)
{
    LPTSTR pszSrc, pszDest;
    int nFiles = _DataObjToFileOpString(pdtobj, &pszSrc, &pszDest);
    if (nFiles)
    {
        // now do the actual nuke.
        WIN32_FIND_DATA fd;
        CONFIRM_DATA cd = {CONFIRM_DELETE_FILE | CONFIRM_DELETE_FOLDER | CONFIRM_PROGRAM_FILE | CONFIRM_MULTIPLE, 0};
        SHFILEOPSTRUCT sFileOp = { hwnd, FO_DELETE, pszSrc, NULL, FOF_NOCONFIRMATION | FOF_SIMPLEPROGRESS, 
                                   FALSE, NULL, MAKEINTRESOURCE(IDS_BB_DELETINGWASTEBASKETFILES)};

        DECLAREWAITCURSOR;

        SetWaitCursor();

        fd.dwFileAttributes = FILE_ATTRIBUTE_NORMAL;
        if (ConfirmFileOp(hwnd, NULL, &cd, nFiles, 0, CONFIRM_DELETE_FILE | CONFIRM_WASTEBASKET_PURGE, pszDest, &fd, NULL, &fd, NULL) == IDYES)
        {
            SHFileOperation(&sFileOp);
            
            SHChangeNotifyHandleEvents();

            // update the icon if there are objects left in the list
            int iItems = (int) ShellFolderView_GetObjectCount(hwnd);
            UpdateIcon(iItems);
        }

        LocalFree((HLOCAL)pszSrc);
        LocalFree((HLOCAL)pszDest);

        ResetWaitCursor();
    }
}

void EnableTrackbarAndFamily(HWND hDlg, BOOL f)
{
    EnableWindow(GetDlgItem(hDlg, IDC_BBSIZE), f);
    EnableWindow(GetDlgItem(hDlg, IDC_BBSIZETEXT), f);
    EnableWindow(GetDlgItem(hDlg, IDC_TEXT), f);
}

void CBitBucket::_GlobalPropOnCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify)
{
    BBPROPSHEETINFO *ppsi = (BBPROPSHEETINFO *)GetWindowLongPtr(hDlg, DWLP_USER);
    BOOL fNukeOnDelete;
    
    switch (id)
    {
    case IDC_GLOBAL:
    case IDC_INDEPENDENT:
        fNukeOnDelete = IsDlgButtonChecked(hDlg, IDC_NUKEONDELETE);
        
        ppsi->fUseGlobalSettings = (IsDlgButtonChecked(hDlg, IDC_GLOBAL) == BST_CHECKED) ? TRUE : FALSE;
        EnableWindow(GetDlgItem(hDlg, IDC_NUKEONDELETE), ppsi->fUseGlobalSettings && !ppsi->fPolicyNukeOnDelete);
        EnableTrackbarAndFamily(hDlg, ppsi->fUseGlobalSettings && !fNukeOnDelete && !ppsi->fPolicyPercent);
        
        SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
        break;
        
    case IDC_NUKEONDELETE:
        fNukeOnDelete = IsDlgButtonChecked(hDlg, IDC_NUKEONDELETE);
        if (fNukeOnDelete)
        {                
            // In order to help protect users, when they turn on "Remove files immedately" we also
            // check the "show delete confimation" box automatically for them. Thus, they will have
            // to explicitly uncheck it if they do not want confimation that their files will be nuked.
            CheckDlgButton(hDlg, IDC_CONFIRMDELETE, BST_CHECKED);
        }

        ppsi->fNukeOnDelete = fNukeOnDelete;
        EnableTrackbarAndFamily(hDlg, !fNukeOnDelete && !ppsi->fPolicyPercent);
        // fall through
    case IDC_CONFIRMDELETE:
        SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
        break;
    }
}

void RelayMessageToChildren(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    for (HWND hwndChild = GetWindow(hwnd, GW_CHILD); hwndChild != NULL; hwndChild = GetWindow(hwndChild, GW_HWNDNEXT))
    {
        SendMessage(hwndChild, uMessage, wParam, lParam);
    }
}

//
// This is the dlg proc for the "Global" tab on the recycle bin
//
BOOL_PTR CALLBACK CBitBucket::_GlobalPropDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BBPROPSHEETINFO *ppsi = (BBPROPSHEETINFO *)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg) 
    {
    HANDLE_MSG(hDlg, WM_COMMAND, _GlobalPropOnCommand);

    case WM_INITDIALOG: 
    {
        HWND hwndTrack = GetDlgItem(hDlg, IDC_BBSIZE);
    	SHELLSTATE ss;

        // make sure the info we have is current
        RefreshAllBBDriveSettings();

        ppsi = (BBPROPSHEETINFO *)lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);

        SendMessage(hwndTrack, TBM_SETTICFREQ, 10, 0);
        SendMessage(hwndTrack, TBM_SETRANGE, FALSE, MAKELONG(0, 100));
        SendMessage(hwndTrack, TBM_SETPOS, TRUE, ppsi->iOriginalPercent);

        EnableWindow(GetDlgItem(hDlg, IDC_NUKEONDELETE), ppsi->fUseGlobalSettings && !ppsi->fPolicyNukeOnDelete);
        EnableTrackbarAndFamily(hDlg, ppsi->fUseGlobalSettings && !ppsi->fNukeOnDelete && !ppsi->fPolicyPercent);
        CheckDlgButton(hDlg, IDC_NUKEONDELETE, ppsi->fNukeOnDelete);
        CheckRadioButton(hDlg, IDC_INDEPENDENT, IDC_GLOBAL, ppsi->fUseGlobalSettings ? IDC_GLOBAL : IDC_INDEPENDENT);
        EnableWindow(GetDlgItem(hDlg, IDC_INDEPENDENT), !ppsi->fPolicyNukeOnDelete);

        SHGetSetSettings(&ss, SSF_NOCONFIRMRECYCLE, FALSE);
        CheckDlgButton(hDlg, IDC_CONFIRMDELETE, !ss.fNoConfirmRecycle);
        EnableWindow(GetDlgItem(hDlg, IDC_CONFIRMDELETE), !SHRestricted(REST_BITBUCKCONFIRMDELETE));
    }
    // fall through to set iGlobalPercent
    case WM_HSCROLL: 
        {
            TCHAR szPercent[20];
            HWND hwndTrack = GetDlgItem(hDlg, IDC_BBSIZE);
            
            ppsi->iPercent = (int) SendMessage(hwndTrack, TBM_GETPOS, 0, 0);
            wsprintf(szPercent, TEXT("%d%%"), ppsi->iPercent);
            SetDlgItemText(hDlg, IDC_BBSIZETEXT, szPercent);
            
            if (ppsi->iPercent != ppsi->iOriginalPercent)
            {
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                
                if (ppsi->iPercent == 0)
                {
                    // In order to help protect users, when they set the % slider to zero we also
                    // check the "show delete confimation" box automatically for them. Thus, they will have
                    // to explicitly uncheck it if they do not want confimation that their files will be nuked.
                    CheckDlgButton(hDlg, IDC_CONFIRMDELETE, BST_CHECKED);
                }
            }
            
            return TRUE;
        }

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL,
            HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aBitBucketPropHelpIDs);
        return TRUE;

    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU,
            (ULONG_PTR)(void *) aBitBucketPropHelpIDs);
        return TRUE;

    case WM_WININICHANGE:
    case WM_SYSCOLORCHANGE:
    case WM_DISPLAYCHANGE:
        RelayMessageToChildren(hDlg, uMsg, wParam, lParam);
        break;

    case WM_DESTROY:
        CheckCompactAndPurge();
        SHUpdateRecycleBinIcon();
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code)
        {
        case PSN_APPLY:
            {
                SHELLSTATE ss;

                ss.fNoConfirmRecycle = !IsDlgButtonChecked(hDlg, IDC_CONFIRMDELETE);
                SHGetSetSettings(&ss, SSF_NOCONFIRMRECYCLE, TRUE);
                
                ppsi->fNukeOnDelete = (IsDlgButtonChecked(hDlg, IDC_NUKEONDELETE) == BST_CHECKED) ? TRUE : FALSE;
                ppsi->fUseGlobalSettings = (IsDlgButtonChecked(hDlg, IDC_INDEPENDENT) == BST_CHECKED) ? FALSE : TRUE;

		// if anything on the global tab changed, update all the drives
        	if (ppsi->fUseGlobalSettings != ppsi->fOriginalUseGlobalSettings    ||
                    ppsi->fNukeOnDelete != ppsi->fOriginalNukeOnDelete              ||
                    ppsi->iPercent != ppsi->iOriginalPercent)
                {
                    // NOTE: We get a PSN_APPLY after all the drive tabs. This has to be this way so that
                    // if global settings change, then the global tab will re-apply all the most current settings
                    // bassed on the global variables that get set above.

                    // this sets the new global settings in the registry
                    if (!PersistGlobalSettings(ppsi->fUseGlobalSettings, ppsi->fNukeOnDelete, ppsi->iPercent))
                    {
                        // we failed, so show the error dialog and bail
                        ShellMessageBox(HINST_THISDLL,
                                        hDlg,
                                        MAKEINTRESOURCE(IDS_BB_CANNOTCHANGESETTINGS),
                                        MAKEINTRESOURCE(IDS_WASTEBASKET),
                                        MB_OK | MB_ICONEXCLAMATION);

                        SetDlgMsgResult(hDlg, WM_NOTIFY, PSNRET_INVALID_NOCHANGEPAGE);
                        return TRUE;
                    }

                    for (int i = 0; i < MAX_BITBUCKETS; i++)
                    {
                        if (MakeBitBucket(i))
                        {
                            BOOL bPurge = TRUE;

                            // we need to purge all the drives in this case
                            RegSetValueEx(g_pBitBucket[i]->hkeyPerUser, TEXT("NeedToPurge"), 0, REG_DWORD, (LPBYTE)&bPurge, sizeof(bPurge));

                            RefreshBBDriveSettings(i);
                        }
                    }

                    ppsi->fOriginalUseGlobalSettings = ppsi->fUseGlobalSettings;
                    ppsi->fOriginalNukeOnDelete = ppsi->fNukeOnDelete; 
                    ppsi->iOriginalPercent = ppsi->iPercent;
                }
            }
        }
        break;

        SetDlgMsgResult(hDlg, WM_NOTIFY, 0);
        return TRUE;
    }

    return FALSE;
}

BOOL_PTR CALLBACK CBitBucket::_DriveDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BBPROPSHEETINFO *ppsi = (BBPROPSHEETINFO *)GetWindowLongPtr(hDlg, DWLP_USER);
    TCHAR szDiskSpace[40];

    switch (uMsg) 
    {
    case WM_INITDIALOG: 
    {
        HWND hwndTrack = GetDlgItem(hDlg, IDC_BBSIZE);

        ppsi = (BBPROPSHEETINFO *)lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);

        SendMessage(hwndTrack, TBM_SETTICFREQ, 10, 0);
        SendMessage(hwndTrack, TBM_SETRANGE, FALSE, MAKELONG(0, 100));
        SendMessage(hwndTrack, TBM_SETPOS, TRUE, ppsi->iPercent);
        CheckDlgButton(hDlg, IDC_NUKEONDELETE, ppsi->fNukeOnDelete);

        // set the disk space info
        StrFormatByteSize64(g_pBitBucket[ppsi->idDrive]->qwDiskSize, szDiskSpace, ARRAYSIZE(szDiskSpace));
        SetDlgItemText(hDlg, IDC_DISKSIZEDATA, szDiskSpace);
        wParam = 0;
    }
    // fall through

    case WM_HSCROLL:
    {
        ULARGE_INTEGER ulBucketSize;
        HWND hwndTrack = GetDlgItem(hDlg, IDC_BBSIZE);
        ppsi->iPercent = (int)SendMessage(hwndTrack, TBM_GETPOS, 0, 0);

        wsprintf(szDiskSpace, TEXT("%d%%"), ppsi->iPercent);
        SetDlgItemText(hDlg, IDC_BBSIZETEXT, szDiskSpace);
                   
        if (ppsi->iPercent != ppsi->iOriginalPercent) 
        {
            SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
        }

        // we peg the max size of the recycle bin to 4 gig
        ulBucketSize.QuadPart = (ppsi->pGlobal->fUseGlobalSettings ? ppsi->pGlobal->iPercent : ppsi->iPercent) * (g_pBitBucket[ppsi->idDrive]->qwDiskSize / 100);
        StrFormatByteSize64(ulBucketSize.HighPart ? (DWORD)-1 : ulBucketSize.LowPart, szDiskSpace, ARRAYSIZE(szDiskSpace));
        SetDlgItemText(hDlg, IDC_BYTESIZEDATA, szDiskSpace);
        return TRUE;
    }

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL,
            HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aBitBucketPropHelpIDs);
        return TRUE;

    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU,
            (ULONG_PTR)(void *) aBitBucketPropHelpIDs);
        return TRUE;

    case WM_COMMAND:
        {
            WORD wCommandID = GET_WM_COMMAND_ID(wParam, lParam);
            if (wCommandID == IDC_NUKEONDELETE)
            {
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                EnableTrackbarAndFamily(hDlg, !IsDlgButtonChecked(hDlg, IDC_NUKEONDELETE) && !ppsi->fPolicyPercent);
                EnableWindow(GetDlgItem(hDlg, IDC_BYTESIZE), !IsDlgButtonChecked(hDlg, IDC_NUKEONDELETE));
                EnableWindow(GetDlgItem(hDlg, IDC_BYTESIZEDATA), !IsDlgButtonChecked(hDlg, IDC_NUKEONDELETE));
            }
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code) 
        {
        case PSN_APPLY:
            {
                ppsi->fNukeOnDelete = (IsDlgButtonChecked(hDlg, IDC_NUKEONDELETE) == BST_CHECKED) ? TRUE : FALSE;

                // update the info in the registry
                if (!PersistBBDriveSettings(ppsi->idDrive, ppsi->iPercent, ppsi->fNukeOnDelete))
                {
                    // we failed, so show the error dialog and bail
                    ShellMessageBox(HINST_THISDLL, hDlg,
                                    MAKEINTRESOURCE(IDS_BB_CANNOTCHANGESETTINGS),
                                    MAKEINTRESOURCE(IDS_WASTEBASKET),
                                    MB_OK | MB_ICONEXCLAMATION);

                    SetDlgMsgResult(hDlg, WM_NOTIFY, PSNRET_INVALID_NOCHANGEPAGE);
                    return TRUE;
                }
            
                // only purge this drive if the user set the slider to a smaller value       
                if (ppsi->iPercent < ppsi->iOriginalPercent)
                {
                    BOOL bPurge = TRUE;

                    // since this drive just shrunk, we need to purge the files in it
                    RegSetValueEx(g_pBitBucket[ppsi->idDrive]->hkeyPerUser, TEXT("NeedToPurge"), 0, REG_DWORD, (LPBYTE)&bPurge, sizeof(bPurge));
                }

                ppsi->iOriginalPercent = ppsi->iPercent;
                ppsi->fOriginalNukeOnDelete = ppsi->fNukeOnDelete;
            
                // update the g_pBitBucket[] for this drive

                // NOTE: We get a PSN_APPLY before the global tab does. This has to be this way so that
                // if global settings change, then the global tab will re-apply all the most current settings
                // bassed on the global variables that get set in his tab.
                RefreshBBDriveSettings(ppsi->idDrive);
            }
            break;

        case PSN_SETACTIVE:
            {   
                BOOL fNukeOnDelete;
                fNukeOnDelete = ppsi->pGlobal->fUseGlobalSettings ? ppsi->pGlobal->fNukeOnDelete :
                                                                    IsDlgButtonChecked(hDlg, IDC_NUKEONDELETE);

                EnableWindow(GetDlgItem(hDlg, IDC_NUKEONDELETE), !ppsi->pGlobal->fUseGlobalSettings && !ppsi->fPolicyNukeOnDelete);
                EnableTrackbarAndFamily(hDlg, !ppsi->pGlobal->fUseGlobalSettings && !fNukeOnDelete && !ppsi->fPolicyPercent);
                EnableWindow(GetDlgItem(hDlg, IDC_BYTESIZE), !fNukeOnDelete);
                EnableWindow(GetDlgItem(hDlg, IDC_BYTESIZEDATA), !fNukeOnDelete);

                // send this to make sure that the "space reserved" field is accurate when using global settings
                SendMessage(hDlg, WM_HSCROLL, 0, 0);
            }
            break;
        }

        SetDlgMsgResult(hDlg, WM_NOTIFY, 0);
        return TRUE;
    }

    return FALSE;
}


typedef struct {
    PROPSHEETPAGE psp;
    LPITEMIDLIST pidl;
    FILETIME ftDeleted;
    DWORD dwSize;
    TCHAR szOriginal[MAX_PATH];
} BBFILEPROPINFO;


// property sheet page for a file/folder in the bitbucket

BOOL_PTR CALLBACK CBitBucket::_FilePropDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BBFILEPROPINFO * pbbfpi = (BBFILEPROPINFO *)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            pbbfpi = (BBFILEPROPINFO *)lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
            
            SHFILEINFO sfi = {0};
            SHGetFileInfo((LPTSTR)pbbfpi->pidl, 0, &sfi, sizeof(sfi), 
                SHGFI_PIDL | SHGFI_TYPENAME | SHGFI_ICON | SHGFI_LARGEICON | SHGFI_ADDOVERLAYS | SHGFI_DISPLAYNAME);
            
            // icon
            ReplaceDlgIcon(hDlg, IDD_ITEMICON, sfi.hIcon);
            
            // Type
            SetDlgItemText(hDlg, IDD_FILETYPE, sfi.szTypeName);
            
            TCHAR szTemp[MAX_PATH];
            StrCpyN(szTemp, pbbfpi->szOriginal, ARRAYSIZE(szTemp));
            PathRemoveExtension(szTemp);
            SetDlgItemText(hDlg, IDD_NAME, PathFindFileName(szTemp));
            
            // origin
            PathRemoveFileSpec(szTemp);
            SetDlgItemText(hDlg, IDD_LOCATION, PathFindFileName(szTemp));
            
            // deleted time
            SetDateTimeText(hDlg, IDD_DELETED, &pbbfpi->ftDeleted);
            
            // Size
            StrFormatByteSize64(pbbfpi->dwSize, szTemp, ARRAYSIZE(szTemp));
            SetDlgItemText(hDlg, IDD_FILESIZE, szTemp);
                
            if (SHGetPathFromIDList(pbbfpi->pidl, szTemp))
            {
                WIN32_FIND_DATA fd;
                HANDLE hfind = FindFirstFile(szTemp, &fd);
                if (hfind != INVALID_HANDLE_VALUE)
                {
                    SetDateTimeText(hDlg, IDD_CREATED, &fd.ftCreationTime);
                    FindClose(hfind);

                    // We don't allow user to change compression attribute on a deleted file
                    // but we do show the current compressed state
                    TCHAR szRoot[MAX_PATH], szFSName[12];
            
                    // If file's volume doesn't support compression, don't show
                    // "Compressed" checkbox.
                    // If compression is supported, show the checkbox and check/uncheck
                    // it to indicate compression state of the file.
                    lstrcpy(szRoot, szTemp);
                    PathStripToRoot(szRoot);
                    PathAddBackslash(szRoot);    // for UNC (MyDocs) case

                    DWORD dwVolumeFlags;
                    if (GetVolumeInformation(szRoot, NULL, 0, NULL, NULL, &dwVolumeFlags, szFSName, ARRAYSIZE(szFSName)))
                    {
                        if (dwVolumeFlags & FS_FILE_COMPRESSION)
                        {
                            if (fd.dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED)
                                CheckDlgButton(hDlg, IDD_COMPRESS, 1);
                            ShowWindow(GetDlgItem(hDlg, IDD_COMPRESS), SW_SHOW);
                        }
                
                        if (dwVolumeFlags & FS_FILE_ENCRYPTION)
                        {
                            if (fd.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED)
                                CheckDlgButton(hDlg, IDD_ENCRYPT, 1);
                            ShowWindow(GetDlgItem(hDlg, IDD_ENCRYPT), SW_SHOW);
                        }
                    }
                
                    // file attributes
                    if (fd.dwFileAttributes & FILE_ATTRIBUTE_READONLY)
                        CheckDlgButton(hDlg, IDD_READONLY, 1);
                    if (fd.dwFileAttributes & FILE_ATTRIBUTE_ARCHIVE)
                        CheckDlgButton(hDlg, IDD_ARCHIVE, 1);
                    if (fd.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN)
                        CheckDlgButton(hDlg, IDD_HIDDEN, 1);
                }
            }
        }
        break;

    case WM_WININICHANGE:
    case WM_SYSCOLORCHANGE:
    case WM_DISPLAYCHANGE:
        RelayMessageToChildren(hDlg, uMsg, wParam, lParam);
        break;

    case WM_DESTROY:
        ReplaceDlgIcon(hDlg, IDD_ITEMICON, NULL);
        break;

    case WM_COMMAND:
        {
            UINT id = GET_WM_COMMAND_ID(wParam, lParam);
            switch (id)
            {
            case IDD_RESTORE:
                if (S_OK == SHInvokeCommandOnPidl(hDlg, NULL, pbbfpi->pidl, 0, "undelete"))
                {
                    // We succeeded, so disable the button (invoking again will fail)
                    EnableWindow(GetDlgItem(hDlg, IDD_RESTORE), FALSE);
                }
                break;
            }
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code) 
        {
        case PSN_APPLY:
        case PSN_SETACTIVE:
        case PSN_KILLACTIVE:
            return TRUE;
        }
        break;

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL,
            HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aBitBucketHelpIDs);
        return TRUE;

    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU,
            (ULONG_PTR)(void *) aBitBucketHelpIDs);
        return TRUE;
    }

    return FALSE;
}

void CBitBucket::_GetDriveDisplayName(int idDrive, LPTSTR pszName, UINT cchSize)
{
    TCHAR szDrive[MAX_PATH];

    DriveIDToBBRoot(idDrive, szDrive);

    SHFILEINFO sfi;
    if (SHGetFileInfo(szDrive, FILE_ATTRIBUTE_DIRECTORY, &sfi, sizeof(sfi), SHGFI_USEFILEATTRIBUTES | SHGFI_DISPLAYNAME))
    {
        lstrcpyn(pszName, sfi.szDisplayName, cchSize);
    }
    
    // If SERVERDRIVE, attempt to overwrite the default display name with the display
    // name for the mydocs folder on the desktop, since SERVERDRIVE==mydocs for now
    if (idDrive == SERVERDRIVE) 
    {
        GetMyDocumentsDisplayName(pszName, cchSize);
    }
}

BOOL CALLBACK CBitBucket::_AddPagesCallback(HPROPSHEETPAGE psp, LPARAM lParam)
{
    LPPROPSHEETHEADER ppsh = (LPPROPSHEETHEADER)lParam;
    ppsh->phpage[ppsh->nPages++] = psp;
    return TRUE;
}

// properties for recycle bin
void CBitBucket::_DefaultProperties()
{
    UNIQUESTUBINFO usi;
    if (EnsureUniqueStub(_pidl, STUBCLASS_PROPSHEET, NULL, &usi))
    {
        HPROPSHEETPAGE ahpage[MAXPROPPAGES];
        PROPSHEETHEADER psh = {0};

        psh.dwSize = sizeof(psh);
        psh.dwFlags = PSH_PROPTITLE;
        psh.hInstance = HINST_THISDLL;
        psh.phpage = ahpage;

        AddPages(_AddPagesCallback, (LPARAM)&psh);

        psh.pszCaption = MAKEINTRESOURCE(IDS_WASTEBASKET);

        psh.hwndParent = usi.hwndStub;
        PropertySheet(&psh);
        FreeUniqueStub(&usi);
    }
}

// deals with alignment and pidl validation for you
void CBitBucket::_GetDeletedFileTime(LPCITEMIDLIST pidl, FILETIME *pft)
{
    ZeroMemory(pft, sizeof(*pft));
    PUBBDATAENTRYA pbbde = _IsValid(pidl);
    if (pbbde)
        *pft = pbbde->ft;
}

DWORD CBitBucket::_GetDeletedSize(LPCITEMIDLIST pidl)
{
    PUBBDATAENTRYA pbbde = _IsValid(pidl);
    return pbbde ? pbbde->dwSize : 0;
}

// recycled items properties
// note: we only show the proeprties for the first file if there is a multiple selection
void CBitBucket::_FileProperties(IDataObject *pdtobj)
{
    STGMEDIUM medium;
    LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
    if (pida)
    {
        BBFILEPROPINFO bbfpi = {0};
        bbfpi.pidl = IDA_FullIDList(pida, 0);
        if (bbfpi.pidl)
        {
            UNIQUESTUBINFO usi;
            if (EnsureUniqueStub(bbfpi.pidl, STUBCLASS_PROPSHEET, NULL, &usi)) 
            {
                HPROPSHEETPAGE ahpage[MAXPROPPAGES];
                TCHAR szTitle[80];

                bbfpi.psp.dwSize = sizeof(bbfpi);
                bbfpi.psp.hInstance = HINST_THISDLL;
                bbfpi.psp.pszTemplate = MAKEINTRESOURCE(DLG_DELETEDFILEPROP);
                bbfpi.psp.pfnDlgProc = _FilePropDlgProc;
                bbfpi.psp.pszTitle = szTitle;

                _OriginalPath(IDA_GetIDListPtr(pida, 0), bbfpi.szOriginal, ARRAYSIZE(bbfpi.szOriginal));
                bbfpi.dwSize = _GetDeletedSize(IDA_GetIDListPtr(pida, 0));

                _GetDeletedFileTime(IDA_GetIDListPtr(pida, 0), &bbfpi.ftDeleted);

                lstrcpyn(szTitle, PathFindFileName(bbfpi.szOriginal), ARRAYSIZE(szTitle));
                PathRemoveExtension(szTitle);

                PROPSHEETHEADER psh = {0};
                psh.dwSize = sizeof(psh);
                psh.dwFlags = PSH_PROPTITLE;
                psh.hInstance = HINST_THISDLL;
                psh.phpage = ahpage;

                psh.phpage[0] = CreatePropertySheetPage(&bbfpi.psp);
                if (psh.phpage[0])
                {
                    psh.nPages = 1;
                    psh.pszCaption = szTitle;

                    psh.hwndParent = usi.hwndStub;
                    PropertySheet(&psh);
                }

                FreeUniqueStub(&usi);
            }
            ILFree(bbfpi.pidl);
        }
        HIDA_ReleaseStgMedium(pida, &medium);
    }
    return;
}

DWORD WINAPI CBitBucket::_DropThreadInit(BBTHREADDATA *pbbtd)
{
    STGMEDIUM medium;
    FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    if (SUCCEEDED(pbbtd->pdtobj->GetData(&fmte, &medium))) 
    {
        // call delete here so that files will be moved in
        // their respective bins, not necessarily this one.
        DRAGINFO di;

        di.uSize = sizeof(DRAGINFO);

        if (DragQueryInfo((HDROP) medium.hGlobal, &di))
        {
            // Since BBWillRecycle() can return true even when the file will NOT be
            // recycled (eg the file will be nuked), we want to warn the user when we 
            // are going to nuke something that they initiall thought that it would
            // be recycled
            UINT fOptions = SD_WARNONNUKE; 

            if (!BBWillRecycle(di.lpFileList, NULL) ||
                (di.lpFileList && (di.lpFileList[lstrlen(di.lpFileList)+1] == 0)
                 && PathIsShortcutToProgram(di.lpFileList)))
                fOptions = SD_USERCONFIRMATION; 

            if (IsFileInBitBucket(di.lpFileList)) 
            {
                LPITEMIDLIST *ppidl = NULL;
                int cidl = CreateMoveCopyList((HDROP)medium.hGlobal, NULL, &ppidl);
                if (ppidl) 
                {
                    // Bug#163533 (edwardp 8/15/00) Change this to use PositionItems.
                    PositionItems_DontUse(pbbtd->hwnd, cidl, ppidl, pbbtd->pdtobj, &pbbtd->ptDrop, pbbtd->fDragDrop, FALSE);
                    FreeIDListArray(ppidl, cidl);
                }
            } 
            else 
            {
                TransferDelete(pbbtd->hwnd, (HDROP) medium.hGlobal, fOptions);
            }

            SHChangeNotifyHandleEvents();
            SHFree(di.lpFileList);
        }
        ReleaseStgMedium(&medium);
    }
    return 0;
}


DWORD CALLBACK CBitBucket::_DispatchThreadProc(void *pv)
{
    BBTHREADDATA *pbbtd = (BBTHREADDATA *)pv;

    if (pbbtd->pstmDataObj)
    {
        CoGetInterfaceAndReleaseStream(pbbtd->pstmDataObj, IID_PPV_ARG(IDataObject, &pbbtd->pdtobj));
        pbbtd->pstmDataObj = NULL;  // this is dead
    }

    switch (pbbtd->idCmd)
    {
    case DFM_CMD_MOVE:
        if (pbbtd->pdtobj)
            _DropThreadInit(pbbtd);
        break;

    case DFM_CMD_PROPERTIES:
    case FSIDM_PROPERTIESBG:
        if (pbbtd->pdtobj)
            pbbtd->pbb->_FileProperties(pbbtd->pdtobj);
        else
            pbbtd->pbb->_DefaultProperties();   // no data object for the background
        break;

    case DFM_CMD_DELETE:
        if (pbbtd->pdtobj)
            pbbtd->pbb->_NukeFileList(pbbtd->hwnd, pbbtd->pdtobj);
        break;

    case FSIDM_RESTORE:
        if (pbbtd->pdtobj)
            pbbtd->pbb->_RestoreFileList(pbbtd->hwnd, pbbtd->pdtobj);
        break;
    }

    if (pbbtd->pdtobj)
        pbbtd->pdtobj->Release();

    pbbtd->pbb->Release();

    LocalFree((HLOCAL)pbbtd);
    return 0;
}

HRESULT CBitBucket::_LaunchThread(HWND hwnd, IDataObject *pdtobj, WPARAM idCmd)
{
    HRESULT hr = E_OUTOFMEMORY;
    BBTHREADDATA *pbbtd = (BBTHREADDATA *)LocalAlloc(LPTR, sizeof(*pbbtd));
    if (pbbtd)
    {
        pbbtd->hwnd = hwnd;
        pbbtd->idCmd = idCmd;
        pbbtd->pbb = this;
        pbbtd->pbb->AddRef();

        if (idCmd == DFM_CMD_MOVE)
            pbbtd->fDragDrop = (BOOL)ShellFolderView_GetDropPoint(hwnd, &pbbtd->ptDrop);

        if (pdtobj)
            CoMarshalInterThreadInterfaceInStream(IID_IDataObject, (IUnknown *)pdtobj, &pbbtd->pstmDataObj);

        if (SHCreateThread(_DispatchThreadProc, pbbtd, CTF_COINIT, NULL))
        {
            hr = S_OK;
        }
        else
        {
            if (pbbtd->pstmDataObj)
                pbbtd->pstmDataObj->Release();

            pbbtd->pbb->Release();
            LocalFree((HLOCAL)pbbtd);
        }
    }
    return hr;
}

HRESULT GetVerb(UINT_PTR idCmd, LPSTR pszName, UINT cchMax, BOOL bUnicode)
{
    HRESULT hr;
    LPCTSTR psz;

    switch (idCmd)
    {
    case FSIDM_RESTORE:
        psz = TEXT("undelete");
        break;

    case FSIDM_PURGEALL:
        psz = TEXT("empty");
        break;

    default:
        return E_NOTIMPL;
    }

    if (bUnicode)
        hr = SHTCharToUnicode(psz, (LPWSTR)pszName, cchMax);
    else
        hr = SHTCharToAnsi(psz, (LPSTR)pszName, cchMax);

    return hr;
}

CBitBucket *CBitBucket::_FromFolder(IShellFolder *psf)
{
    CBitBucket *pbbf = NULL;
    if (psf)
        psf->QueryInterface(CLSID_RecycleBin, (void **)&pbbf);
    return pbbf;
}

// item context menu callback
HRESULT CALLBACK CBitBucket::_ItemMenuCallBack(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, 
                                               UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CBitBucket *pbbf = _FromFolder(psf);
    HRESULT hr = S_OK;     // assume no error

    switch (uMsg)
    {
    case DFM_MERGECONTEXTMENU:
        CDefFolderMenu_MergeMenu(HINST_THISDLL, POPUP_BITBUCKET_ITEM, 0, (QCMINFO *)lParam);
        hr = S_OK;
        break;
        
    case DFM_GETDEFSTATICID:
        *(WPARAM *)lParam = DFM_CMD_PROPERTIES;
        hr = S_OK;
        break;
        
    case DFM_MAPCOMMANDNAME:
        if (lstrcmpi((LPCTSTR)lParam, TEXT("undelete")) == 0)
        {
            *(UINT_PTR *)wParam = FSIDM_RESTORE;
        }
        else
        {
            hr = E_FAIL;    // command not found
        }
        break;

    case DFM_INVOKECOMMAND:
        switch (wParam) 
        {
        case FSIDM_RESTORE:
        case DFM_CMD_DELETE:
        case DFM_CMD_PROPERTIES:
            hr = pbbf->_LaunchThread(hwnd, pdtobj, wParam);
            break;

        default:
            hr = S_FALSE;
            break;
        }
        break;

    case DFM_GETHELPTEXT:
        LoadStringA(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPSTR)lParam, HIWORD(wParam));;
        break;

    case DFM_GETHELPTEXTW:
        LoadStringW(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPWSTR)lParam, HIWORD(wParam));;
        break;

    case DFM_GETVERBA:
    case DFM_GETVERBW:
        hr = GetVerb((UINT_PTR)(LOWORD(wParam)), (LPSTR)lParam, (UINT)(HIWORD(wParam)), uMsg == DFM_GETVERBW);
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }

    return hr;
}

class CBitBucketDropTarget : public CIDLDropTarget
{
public:
    CBitBucketDropTarget(HWND hwnd, CBitBucket *pbbf) : CIDLDropTarget(hwnd), _pbbf(pbbf) 
    { 
        _pbbf->AddRef();
    }

    // IDropTarget (override base class)
    STDMETHODIMP DragEnter(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP Drop(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

private:
    ~CBitBucketDropTarget()
    {
        _pbbf->Release();
    }

    CBitBucket *_pbbf;
};

//
//  This function puts DROPEFFECT_LINK in *pdwEffect, only if the data object
//  contains one or more net resource.
//
STDMETHODIMP CBitBucketDropTarget::DragEnter(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    TraceMsg(TF_BITBUCKET, "Bitbucket: CBitBucketDropTarget::DragEnter");

    // Call the base class first
    CIDLDropTarget::DragEnter(pDataObj, grfKeyState, pt, pdwEffect);

    // we don't really care what is in the data object, as long as move
    // is supported by the source we say you can move it to the wastbasket
    // in the case of files we will do the regular recycle bin stuff, if
    // it is not files we will just say it is moved and let the source delete it
    *pdwEffect &= DROPEFFECT_MOVE;

    m_dwEffectLastReturned = *pdwEffect;

    return S_OK;
}


// This function creates a connection to a dropped net resource object.
STDMETHODIMP CBitBucketDropTarget::Drop(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    BOOL fWebFoldersHack = FALSE;
    HRESULT hr;

    // only move operation is allowed
    *pdwEffect &= DROPEFFECT_MOVE;

    if (*pdwEffect)
    {
        hr = CIDLDropTarget::DragDropMenu(DROPEFFECT_MOVE, pDataObj,
                pt, pdwEffect, NULL, NULL, POPUP_NONDEFAULTDD, grfKeyState);

        if (hr == S_FALSE)
        {
            // let callers know where this is about to go
            // Defview cares where it went so it can handle non-filesys items
            // SHScrap cares because it needs to close the file so we can delete it
            DataObj_SetDropTarget(pDataObj, &CLSID_RecycleBin);

            if (DataObj_GetDWORD(pDataObj, g_cfNotRecyclable, 0))
            {
                if (ShellMessageBox(HINST_THISDLL, NULL,
                                    MAKEINTRESOURCE(IDS_CONFIRMNOTRECYCLABLE),
                                    MAKEINTRESOURCE(IDS_RECCLEAN_NAMETEXT),
                                    MB_SETFOREGROUND | MB_ICONQUESTION | MB_YESNO) == IDNO)
                {
                    *pdwEffect = DROPEFFECT_NONE;
                    goto lCancel;
                }
            }

            if (m_dwData & DTID_HDROP)  // CF_HDROP
            {
                _pbbf->_LaunchThread(_GetWindow(), pDataObj, DFM_CMD_MOVE);

                // since we will move the file ourself, known as an optimised move, 
                // we return zero here. this is per the OLE spec

                *pdwEffect = DROPEFFECT_NONE;
            }
            else
            {
                // if it was not files, we just say we moved the data, letting the
                // source deleted it. lets hope they support undo...

                *pdwEffect = DROPEFFECT_MOVE;

                // HACK: Put up a "you can't undo this" warning for web folders.
                {
                    STGMEDIUM stgmed;
                    LPIDA pida = DataObj_GetHIDA(pDataObj, &stgmed);
                    if (pida)
                    {
                        LPCITEMIDLIST pidl = IDA_GetIDListPtr(pida, -1);
                        if (pidl)
                        {
                            IPersist *pPers;
                            hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IPersist, &pPers), NULL);
                            if (SUCCEEDED(hr))
                            {
                                CLSID clsidSource;
                                hr = pPers->GetClassID(&clsidSource);
                                if (SUCCEEDED(hr) &&
                                    IsEqualGUID(clsidSource, CLSID_WebFolders))
                                {
                                    if (ShellMessageBox(HINST_THISDLL, NULL,
                                                        MAKEINTRESOURCE(IDS_CONFIRMNOTRECYCLABLE),
                                                        MAKEINTRESOURCE(IDS_RECCLEAN_NAMETEXT),
                                                        MB_SETFOREGROUND | MB_ICONQUESTION | MB_YESNO) == IDNO)
                                    {
                                        *pdwEffect = DROPEFFECT_NONE;
                                        pPers->Release();
                                        HIDA_ReleaseStgMedium (pida, &stgmed);
                                        goto lCancel;
                                    }
                                    else
                                    {
                                        fWebFoldersHack = TRUE;
                                    }
                                }
                                pPers->Release();
                            }
                        }
                        HIDA_ReleaseStgMedium(pida, &stgmed);
                    }
                }
            }
lCancel:
            if (!fWebFoldersHack)
            {
                DataObj_SetDWORD(pDataObj, g_cfPerformedDropEffect, *pdwEffect);
                DataObj_SetDWORD(pDataObj, g_cfLogicalPerformedDropEffect, DROPEFFECT_MOVE);
            }
            else
            {
                // Make web folders really delete its source file.
                DataObj_SetDWORD (pDataObj, g_cfPerformedDropEffect, 0);
            }
        }
    }

    CIDLDropTarget::DragLeave();

    return S_OK;
}

HRESULT CALLBACK CBitBucket::_BackgroundMenuCallBack(IShellFolder *psf, HWND hwnd,
                IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CBitBucket *pbbf = _FromFolder(psf);
    HRESULT hr = S_OK;

    switch (uMsg)
    {
    case DFM_MERGECONTEXTMENU_BOTTOM:
        if (!(wParam & (CMF_VERBSONLY | CMF_DVFILE)))
        {
            QCMINFO *pqcm = (QCMINFO*)lParam;
            UINT idFirst = pqcm->idCmdFirst;

            CDefFolderMenu_MergeMenu(HINST_THISDLL, POPUP_PROPERTIES_BG, 0, (QCMINFO *)lParam);

            if (SHRestricted(REST_BITBUCKNOPROP))
            {
                // Disable the Properties menu item
                EnableMenuItem(pqcm->hmenu, idFirst + FSIDM_PROPERTIESBG, MF_GRAYED | MF_BYCOMMAND);
            }
        }
        break;

    case DFM_GETHELPTEXT:
        LoadStringA(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPSTR)lParam, HIWORD(wParam));
        break;

    case DFM_GETHELPTEXTW:
        LoadStringW(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPWSTR)lParam, HIWORD(wParam));
        break;

    case DFM_INVOKECOMMAND:
        switch (wParam)
        {
        case FSIDM_PROPERTIESBG:
            hr = pbbf->_LaunchThread(hwnd, NULL, FSIDM_PROPERTIESBG);
            break;

        case DFM_CMD_PASTE:
        case DFM_CMD_PROPERTIES:
            hr = S_FALSE;   // do this for me
            break;

        default:
            hr = E_FAIL;
            break;
        }
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }

    return hr;
}

STDMETHODIMP CBitBucket::CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
{
    HRESULT hr;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IShellView))
    {
        IShellFolderViewCB* psfvcb;
        hr = Create_CBitBucketViewCB(this, &psfvcb);
        if (SUCCEEDED(hr))
        {
            SFV_CREATE sSFV = {0};
            sSFV.cbSize   = sizeof(sSFV);
            sSFV.pshf     = SAFECAST(this, IShellFolder *);
            sSFV.psfvcb   = psfvcb;

            hr = SHCreateShellFolderView(&sSFV, (IShellView**)ppv);

            psfvcb->Release();
        }
    }
    else if (IsEqualIID(riid, IID_IDropTarget))
    {
        CBitBucketDropTarget *pbbdt = new CBitBucketDropTarget(hwnd, this);
        if (pbbdt)
        {
            hr = pbbdt->_Init(_pidl);
            if (SUCCEEDED(hr))
                hr = pbbdt->QueryInterface(riid, ppv);
            pbbdt->Release();
        }
        else
            hr = E_OUTOFMEMORY;

    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        IContextMenu* pcmBase;
        hr = CDefFolderMenu_Create(NULL, hwnd, 0, NULL, SAFECAST(this, IShellFolder *), _BackgroundMenuCallBack,
                                   NULL, NULL, &pcmBase);
        if (SUCCEEDED(hr))
        {
            IContextMenu* pcmFolder = SAFECAST(this, IContextMenu*);
            IContextMenu* rgpcm[] = { pcmFolder, pcmBase };

            hr = Create_ContextMenuOnContextMenuArray(rgpcm, ARRAYSIZE(rgpcm), riid, ppv);

            pcmBase->Release();
        }
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }
    return hr;
}

// search the database on idDrive for file with index iIndex

LPITEMIDLIST CBitBucket::_DriveInfoToIDList(int idDrive, int iIndex)
{
    LPITEMIDLIST pidl = NULL;
    HANDLE hFile = OpenBBInfoFile(idDrive, OPENBBINFO_WRITE, 0);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        // read records until we find an index match
        BBDATAENTRYW bbdew;

        while (ReadNextDataEntry(hFile, &bbdew, TRUE, idDrive))
        {
            if (bbdew.iIndex == iIndex)
            {
                ASSERT(idDrive == bbdew.idDrive);
                pidl = DataEntryToIDList(&bbdew);
                break;
            }
        }
        CloseBBInfoFile(hFile, idDrive);
    }
    return pidl;
}

// we implement this supporting D<drive_id><index>.ext

STDMETHODIMP CBitBucket::ParseDisplayName(HWND hwnd, IBindCtx *pbc, LPOLESTR pwszDisplayName, 
                                          ULONG *pchEaten, LPITEMIDLIST *ppidl, ULONG *pdwAttributes)
{
    if (!ppidl)
        return E_INVALIDARG;

    *ppidl = NULL;
    
    if (!pwszDisplayName)
        return E_INVALIDARG;

    int idDrive, iIndex;
    HRESULT hr = BBFileNameToInfo(pwszDisplayName, &idDrive, &iIndex);
    if (SUCCEEDED(hr))
    {
        // since anyone can call us with a path that is under the recycled directory,
        // we need to check to make sure that we have inited this drive:
        if (MakeBitBucket(idDrive))
        {
            *ppidl = _DriveInfoToIDList(idDrive, iIndex);
            hr = *ppidl ? S_OK : E_FAIL;
        }
        else
        {
            hr = E_FAIL;
        }
    }
    return hr;
}

// takes a full path to a file in a recycle bin storage folder and creates a 
// single level bitbucket pidl

LPITEMIDLIST CBitBucket::PathToIDList(LPCTSTR pszPath)
{
    LPITEMIDLIST pidl = NULL;
    int idDrive = DriveIDFromBBPath(pszPath);

    ASSERT(idDrive >= 0);       // general UNC case will generate -1

    int iIndex = BBPathToIndex(pszPath);
    if (iIndex != -1)
    {
        pidl = _DriveInfoToIDList(idDrive, iIndex);
    }
    return pidl;
}

STDMETHODIMP CBitBucket::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl,
                                       REFIID riid, UINT *prgfInOut, void **ppv)
{
    HRESULT hr;

    *ppv = NULL;

    if (cidl && IsEqualIID(riid, IID_IDataObject))
    {
        CBitBucketData *pbbd = new CBitBucketData(this, cidl, apidl);
        if (pbbd)
        {
            hr = pbbd->QueryInterface(riid, ppv);
            pbbd->Release();
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        hr = CDefFolderMenu_Create(_pidl, hwnd, cidl, apidl,
            SAFECAST(this, IShellFolder *), _ItemMenuCallBack, NULL, NULL, (IContextMenu**)ppv);
    }
    else if (IsEqualIID(riid, IID_IDropTarget))
    {
        hr = E_FAIL; // You can't drop on internal items of the bitbucket!
    }
    else if (cidl == 1)
    {
        // blindly delegate unknown riid's to folder!
        IShellFolder *psf;
        hr = _FolderFromIDList(apidl[0], IID_PPV_ARG(IShellFolder, &psf));
        if (SUCCEEDED(hr))
        {
            hr = psf->GetUIObjectOf(hwnd, cidl, apidl, riid, prgfInOut, ppv);
            if (SUCCEEDED(hr) && IsEqualIID(riid, IID_IQueryInfo))
            {
                WrapInfotip(SAFECAST(this, IShellFolder2 *), apidl[0], &SCID_DELETEDFROM, (IUnknown *)*ppv);
            }
            psf->Release();
        }
    }
    else
    {
        hr = E_NOTIMPL;
    }

    return hr;
}

HRESULT CBitBucket::_FolderFromDrive(int idDrive, REFIID riid, void **ppv)
{
    *ppv = NULL;

    ASSERT(idDrive < ARRAYSIZE(_rgFolders));

    if (NULL == _rgFolders[idDrive])
    {
        PERSIST_FOLDER_TARGET_INFO pfti = {0};

        DriveIDToBBPath(idDrive, pfti.szTargetParsingName);
        pfti.dwAttributes = FILE_ATTRIBUTE_DIRECTORY;
        pfti.csidl = -1;

        CFSFolder_CreateFolder(NULL, NULL, _pidl, &pfti, IID_PPV_ARG(IUnknown, &_rgFolders[idDrive]));
    }

    return _rgFolders[idDrive] ? _rgFolders[idDrive]->QueryInterface(riid, ppv) : E_FAIL;
}

// accepts NULL, or undecorated recycle bin pidl (raw file system pidl).
// in these cases computes the default recycle bin file system folder
// index so we will defer to that.

int CBitBucket::_DriveIDFromIDList(LPCITEMIDLIST pidl)
{
    int iDrive = 0;

    PUBBDATAENTRYA pbbde = _IsValid(pidl);
    if (pbbde)
    {
        iDrive = pbbde->idDrive;
    }
    else
    {
        // unknown, compute the default recycle bin folder index
        TCHAR szPath[MAX_PATH];
        if (GetWindowsDirectory(szPath, ARRAYSIZE(szPath)))
        {
            iDrive = PathGetDriveNumber(szPath);
            if (iDrive < 0)
                iDrive = 0;
        }
    }
    ASSERT(iDrive >= 0 && iDrive < ARRAYSIZE(_rgFolders));
    return iDrive;
}

// in:
//      pidl of item, or NULL for default folder (base recycle bin)

HRESULT CBitBucket::_FolderFromIDList(LPCITEMIDLIST pidl, REFIID riid, void **ppv)
{
    return _FolderFromDrive(_DriveIDFromIDList(pidl), riid, ppv);
}

// create a bitbucket pidl, start with the file system pidl, then add the extra data sections as needed

LPITEMIDLIST CBitBucket::DataEntryToIDList(BBDATAENTRYW *pbbde)
{
    LPITEMIDLIST pidl = NULL;

    WCHAR szFile[MAX_PATH];
    GetDeletedFileName(szFile, pbbde);

    IShellFolder *psf;
    if (SUCCEEDED(_FolderFromDrive(pbbde->idDrive, IID_PPV_ARG(IShellFolder, &psf))))
    {
        if (SUCCEEDED(psf->ParseDisplayName(NULL, NULL, szFile, NULL, &pidl, NULL)))
        {
            HIDDENRECYCLEBINDATA hrbd = { {sizeof(hrbd), HRBD_CURRENTVERSION, IDLHID_RECYCLEBINDATA}};
            hrbd.bbde = *((LPBBDATAENTRYA)pbbde);

            pidl = ILAppendHiddenID(pidl, &hrbd.hid);
            if (pidl)
            {
                if (g_pBitBucket[pbbde->idDrive]->fIsUnicode && 
                    !DoesStringRoundTrip(pbbde->szOriginal, NULL, 0))
                {
                    pidl = ILAppendHiddenStringW(pidl, IDLHID_RECYCLEBINORIGINAL, pbbde->szOriginal);
                }
            }
        }
        psf->Release();
    }
    return pidl;
}

class CBitBucketEnum : public IEnumIDList
{
public:
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    // IEnumIDList
    STDMETHOD(Next)(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    STDMETHOD(Skip)(ULONG celt);
    STDMETHOD(Reset)();
    STDMETHOD(Clone)(IEnumIDList **ppenum);
    
    CBitBucketEnum(CBitBucket *pbbf, DWORD grfFlags);

private:
    HRESULT _BuildEnumDPA();
    ~CBitBucketEnum();

    LONG _cRef;
    CBitBucket *_pbbf;
    HDPA _hdpa;
    int _nItem;
    DWORD _grfFlags;
};

CBitBucketEnum::CBitBucketEnum(CBitBucket *pbbf, DWORD grfFlags) : 
    _cRef(1), _pbbf(pbbf), _grfFlags(grfFlags)
{
    _pbbf->AddRef();
}

CBitBucketEnum::~CBitBucketEnum()
{
    Reset();
    _pbbf->Release();
}

STDMETHODIMP CBitBucketEnum::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CBitBucketEnum, IEnumIDList),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CBitBucketEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CBitBucketEnum::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}


#ifdef DEBUG
#define BB_DELETED_ENTRY_MAX 10     // smaller to force compaction more often
#else
#define BB_DELETED_ENTRY_MAX 100
#endif

// on the first ::Next() call snapshot the data needed to do the enum

HRESULT CBitBucketEnum::_BuildEnumDPA()
{
    HRESULT hr = S_OK;

    if (NULL == _hdpa)
    {
        _hdpa = DPA_CreateEx(0, NULL);
        if (_hdpa)
        {
            if (_grfFlags & SHCONTF_NONFOLDERS) //if they asked for folders we have none so leave DPA empty
            {
                // loop through the bitbucket drives to find an info file
                for (int iBitBucket = 0; iBitBucket < MAX_BITBUCKETS; iBitBucket++)
                {
                    if (MakeBitBucket(iBitBucket)) 
                    {
                        int cDeleted = 0;
                        HANDLE hFile = OpenBBInfoFile(iBitBucket, OPENBBINFO_WRITE, 0);
                        if (INVALID_HANDLE_VALUE != hFile)
                        {
                            BBDATAENTRYW bbdew;

                            while (ReadNextDataEntry(hFile, &bbdew, FALSE, iBitBucket))
                            {
                                if (IsDeletedEntry(&bbdew))
                                    cDeleted++;
                                else
                                {
                                    ASSERT(iBitBucket == bbdew.idDrive);

                                    LPITEMIDLIST pidl = _pbbf->DataEntryToIDList(&bbdew);
                                    if (pidl)
                                    {
                                        if (-1 == DPA_AppendPtr(_hdpa, pidl))
                                            ILFree(pidl);
                                    }
                                }
                            }

                            if (cDeleted > BB_DELETED_ENTRY_MAX)
                            {
                                BOOL bTrue = TRUE;

                                // set the registry key so that we will compact the info file after the next delete operation
                                RegSetValueEx(g_pBitBucket[iBitBucket]->hkeyPerUser, TEXT("NeedToCompact"), 0, REG_DWORD, (LPBYTE)&bTrue, sizeof(bTrue));
                            }
                            CloseBBInfoFile(hFile, iBitBucket);
                        }
                    }
                }
            }    
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

STDMETHODIMP CBitBucketEnum::Next(ULONG celt, LPITEMIDLIST *ppidl, ULONG *pceltFetched)
{
    *ppidl = NULL;
    
    HRESULT hr = _BuildEnumDPA();
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidl = (LPITEMIDLIST)DPA_GetPtr(_hdpa, _nItem);
        if (pidl)
        {
            hr = SHILClone(pidl, ppidl);    
            _nItem++;
        }
        else
        {
            hr = S_FALSE; // no more items
        }
    }

    if (pceltFetched)
        *pceltFetched = (hr == S_OK) ? 1 : 0;

    return hr;
}

STDMETHODIMP CBitBucketEnum::Skip(ULONG celt) 
{
    HRESULT hr = E_FAIL;
    if (_hdpa)
    {
        _nItem += celt;
        if (_nItem >= DPA_GetPtrCount(_hdpa))
        {
            _nItem = DPA_GetPtrCount(_hdpa);
            hr = S_FALSE;
        }
        else
        {
            hr = S_OK;
        }
    }
        
    return hr;
}

STDMETHODIMP CBitBucketEnum::Reset()
{
    DPA_FreeIDArray(_hdpa);
    _hdpa = NULL;
    _nItem = 0;
    return S_OK;
}

STDMETHODIMP CBitBucketEnum::Clone(IEnumIDList **ppenum) 
{
    *ppenum = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CBitBucket::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenum)
{
    *ppenum = NULL;

    HRESULT hr;
    CBitBucketEnum *penum = new CBitBucketEnum(this, grfFlags);
    if (penum)
    {
        hr = penum->QueryInterface(IID_PPV_ARG(IEnumIDList, ppenum));
        penum->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

STDMETHODIMP CBitBucket::BindToObject(LPCITEMIDLIST pidl, IBindCtx *pbc, REFIID riid, void **ppv)
{
    *ppv = NULL;
    HRESULT hr = E_NOTIMPL;
    if (riid != IID_IShellFolder && riid != IID_IShellFolder2)
    {
        // let IPropertySetStorage/IStream/etc binds go through
        IShellFolder *psf;
        hr = _FolderFromIDList(pidl, IID_PPV_ARG(IShellFolder, &psf));
        if (SUCCEEDED(hr))
        {
            hr = psf->BindToObject(pidl, pbc, riid, ppv);
            psf->Release();
        }
    }
    return hr;
}

STDMETHODIMP CBitBucket::BindToStorage(LPCITEMIDLIST pidl, IBindCtx *pbc, REFIID riid, void **ppv)
{
    return BindToObject(pidl, pbc, riid, ppv);
}

DWORD CBitBucket::_IsFolder(LPCITEMIDLIST pidl)
{
    DWORD dwAttributes = SFGAO_FOLDER;
    HRESULT hr = GetAttributesOf(1, &pidl, &dwAttributes);
    return (SUCCEEDED(hr) && (SFGAO_FOLDER & dwAttributes)) ? FILE_ATTRIBUTE_DIRECTORY : 0;
}

STDMETHODIMP CBitBucket::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD dwFlags, STRRET *psr)
{
    HRESULT hr;
    // on change notifications we can get file system pidls that don't have our
    // extra data in them. in this case we need to delegate to the file system
    // folder
    if ((0 == (dwFlags & SHGDN_FORPARSING)) && _IsValid(pidl))
    {
        TCHAR szTemp[MAX_PATH];
        hr = _OriginalPath(pidl, szTemp, ARRAYSIZE(szTemp));
        if (SUCCEEDED(hr))
        {
            if (dwFlags & SHGDN_INFOLDER)
            {
                SHFILEINFO sfi;
                if (SHGetFileInfo(szTemp, _IsFolder(pidl), &sfi, sizeof(sfi), SHGFI_USEFILEATTRIBUTES | SHGFI_DISPLAYNAME))
                {
                    hr = StringToStrRet(sfi.szDisplayName, psr);
                }
                else
                {
                    hr = E_FAIL;
                }
            }
            else
            {
                hr = StringToStrRet(szTemp, psr);
            }
        }
    }
    else
    {
        IShellFolder *psf;
        hr = _FolderFromIDList(pidl, IID_PPV_ARG(IShellFolder, &psf));
        if (SUCCEEDED(hr))
        {
            hr = psf->GetDisplayNameOf(pidl, dwFlags, psr);
            psf->Release();
        }
    }
    return hr;
}

STDMETHODIMP CBitBucket::SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, DWORD dwRes, LPITEMIDLIST *ppidlOut)
{
    return E_FAIL;
}

STDMETHODIMP CBitBucket::GetDefaultSearchGUID(GUID *pguid)
{
    return DefaultSearchGUID(pguid);
}

STDMETHODIMP CBitBucket::EnumSearches(IEnumExtraSearch **ppenum)
{
    *ppenum = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CBitBucket::GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay)
{
    return E_NOTIMPL;
}

STDMETHODIMP CBitBucket::GetDefaultColumnState(UINT iColumn, DWORD *pdwState)
{
    HRESULT hr;
    if (_MapColIndex(&iColumn))
    {
        *pdwState = c_bb_cols[iColumn].csFlags | SHCOLSTATE_PREFER_VARCMP;
        hr = S_OK;
    }
    else
    {
        IShellFolder2 *psf;
        hr = _FolderFromIDList(NULL, IID_PPV_ARG(IShellFolder2, &psf));
        if (SUCCEEDED(hr))
        {
            hr = psf->GetDefaultColumnState(iColumn, pdwState);
            psf->Release();
        }
    }
    return hr;
}

STDMETHODIMP CBitBucket::GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv)
{
    HRESULT hr;
    if (IsEqualSCID(*pscid, SCID_DELETEDFROM))
    {
        TCHAR szTemp[MAX_PATH];
        hr = _OriginalDirectory(pidl, szTemp, ARRAYSIZE(szTemp));
        if (SUCCEEDED(hr))
            hr = InitVariantFromStr(pv, szTemp);
    }
    else if (IsEqualSCID(*pscid, SCID_DATEDELETED))
    {
        FILETIME ft;
        _GetDeletedFileTime(pidl, &ft);
        hr = InitVariantFromFileTime(&ft, pv);
    }
    else if (IsEqualSCID(*pscid, SCID_DIRECTORY))
    {
        // don't let this get through to file folder as we want to hide
        // the real file system folder from callers
        VariantInit(pv);
        hr = E_FAIL;
    }
    else if (IsEqualSCID(*pscid, SCID_SIZE))
    {
        pv->ullVal = _GetDeletedSize(pidl);
        pv->vt = VT_UI8;
        hr = S_OK;
    }
    else 
    {
        IShellFolder2 *psf;
        hr = _FolderFromIDList(pidl, IID_PPV_ARG(IShellFolder2, &psf));
        if (SUCCEEDED(hr))
        {
            hr = psf->GetDetailsEx(pidl, pscid, pv);
            psf->Release();
        }
    }
    return hr;
}

BOOL CBitBucket::_MapColIndex(UINT *piColumn)
{
    switch (*piColumn)
    {
    case ICOL_NAME:             // 0
    case ICOL_ORIGINAL:         // 1
    case ICOL_DATEDELETED:      // 2
        return TRUE;

    default:                    // >= 3
        *piColumn -= ICOL_DATEDELETED;
        return FALSE;
    }
}

STDMETHODIMP CBitBucket::GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pdi)
{
    HRESULT hr;
    if (_MapColIndex(&iColumn))
    {
        if (pidl)
        {
            TCHAR szTemp[MAX_PATH];
            szTemp[0] = 0;

            switch (iColumn)
            {
            case ICOL_NAME:
                DisplayNameOf(this, pidl, SHGDN_INFOLDER, szTemp, ARRAYSIZE(szTemp));
                break;

            case ICOL_ORIGINAL:
                _OriginalDirectory(pidl, szTemp, ARRAYSIZE(szTemp));
                break;

            case ICOL_DATEDELETED:
                {
                    FILETIME ft;
                    _GetDeletedFileTime(pidl, &ft);
                    DWORD dwFlags = FDTF_DEFAULT;

                    switch (pdi->fmt)
                    {
                    case LVCFMT_LEFT_TO_RIGHT:
                        dwFlags |= FDTF_LTRDATE;
                        break;

                    case LVCFMT_RIGHT_TO_LEFT:
                        dwFlags |= FDTF_RTLDATE;
                        break;
                    }

                    SHFormatDateTime(&ft, &dwFlags, szTemp, ARRAYSIZE(szTemp));
                }
                break;
            }
            hr = StringToStrRet(szTemp, &pdi->str);
        }
        else
        {
            hr = GetDetailsOfInfo(c_bb_cols, ARRAYSIZE(c_bb_cols), iColumn, pdi);
        }
    }
    else
    {
        if (pidl && (_SizeColumn() == iColumn))
        {
            TCHAR szTemp[64];
            StrFormatKBSize(_GetDeletedSize(pidl), szTemp, ARRAYSIZE(szTemp));
            hr = StringToStrRet(szTemp, &pdi->str);
        }
        else
        {
            IShellFolder2 *psf;
            hr = _FolderFromIDList(pidl, IID_PPV_ARG(IShellFolder2, &psf));
            if (SUCCEEDED(hr))
            {
                hr = psf->GetDetailsOf(pidl, iColumn, pdi);
                psf->Release();
            }
        }
    }
    return hr;
}

UINT CBitBucket::_SizeColumn()
{
    if (-1 == _uiColumnSize)
    {
        _uiColumnSize = MapSCIDToColumn(SAFECAST(this, IShellFolder2 *), &SCID_SIZE);
        _MapColIndex(&_uiColumnSize);    // map to other folder index space
    }
    return _uiColumnSize;
}

STDMETHODIMP CBitBucket::MapColumnToSCID(UINT iColumn, SHCOLUMNID *pscid)
{
    HRESULT hr;
    if (_MapColIndex(&iColumn))
    {
        hr = MapColumnToSCIDImpl(c_bb_cols, ARRAYSIZE(c_bb_cols), iColumn, pscid);
    }
    else
    {
        IShellFolder2 *psf;
        hr = _FolderFromIDList(NULL, IID_PPV_ARG(IShellFolder2, &psf));
        if (SUCCEEDED(hr))
        {
            hr = psf->MapColumnToSCID(iColumn, pscid);
            psf->Release();
        }
    }
    return hr;
}


// IPersist
STDMETHODIMP CBitBucket::GetClassID(CLSID *pclsid)
{
    *pclsid = CLSID_RecycleBin;
    return S_OK;
}

// IPersistFolder
STDMETHODIMP CBitBucket::Initialize(LPCITEMIDLIST pidl)
{
    return Pidl_Set(&_pidl, pidl) ? S_OK : E_OUTOFMEMORY;
}

// IPersistFolder2
STDMETHODIMP CBitBucket::GetCurFolder(LPITEMIDLIST *ppidl)
{
    return GetCurFolderImpl(_pidl, ppidl);
}

// IShellExtInit
STDMETHODIMP CBitBucket::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID)
{
    return S_OK;
}

// IContextMenu
STDMETHODIMP CBitBucket::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    int idMax = idCmdFirst;
    HMENU hmMerge = SHLoadPopupMenu(HINST_THISDLL, POPUP_BITBUCKET_POPUPMERGE);
    if (hmMerge)
    {
        if (IsRecycleBinEmpty())
        {
            EnableMenuItem(hmMerge, FSIDM_PURGEALL, MF_GRAYED | MF_BYCOMMAND);
        }
        
        idMax = Shell_MergeMenus(hmenu, hmMerge, indexMenu, idCmdFirst, idCmdLast, 0);

        DestroyMenu(hmMerge);
    }

    return ResultFromShort(idMax - idCmdFirst);
}

const ICIVERBTOIDMAP c_sBBCmdInfo[] = {
    { L"empty", "empty", FSIDM_PURGEALL, FSIDM_PURGEALL, },
};

STDMETHODIMP CBitBucket::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    UINT idCmd;
    HRESULT hr = SHMapICIVerbToCmdID(pici, c_sBBCmdInfo, ARRAYSIZE(c_sBBCmdInfo), &idCmd);
    if (SUCCEEDED(hr))
    {
        switch (idCmd)
        {
        case FSIDM_PURGEALL:
            hr = BBPurgeAll(pici->hwnd, 0);

            // command is ours, let caller know we processed it (but we want the right success code)
            if (FAILED(hr))
                hr = S_FALSE;
            break;

        default:
            hr = E_FAIL;
            break;
        }
    }

    return hr;
}

STDMETHODIMP CBitBucket::GetCommandString(UINT_PTR idCmd, UINT  wFlags, UINT * pwReserved, LPSTR pszName, UINT cchMax)
{
    switch (wFlags)
    {
    case GCS_VERBA:
    case GCS_VERBW:
        return SHMapCmdIDToVerb(idCmd, c_sBBCmdInfo, ARRAYSIZE(c_sBBCmdInfo), pszName, cchMax, wFlags == GCS_VERBW);

    case GCS_HELPTEXTA:
        return LoadStringA(HINST_THISDLL,
                          (UINT)(idCmd + IDS_MH_FSIDM_FIRST),
                          pszName, cchMax) ? S_OK : E_OUTOFMEMORY;
    case GCS_HELPTEXTW:
        return LoadStringW(HINST_THISDLL,
                          (UINT)(idCmd + IDS_MH_FSIDM_FIRST),
                          (LPWSTR)pszName, cchMax) ? S_OK : E_OUTOFMEMORY;
    default:
        return E_NOTIMPL;
    }
}

//
//  Callback function that saves the location of the HPROPSHEETPAGE's
//  LPPROPSHEETPAGE so we can pass it to other propsheet pages.
//
UINT CALLBACK CBitBucket::_GlobalSettingsCalback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    switch (uMsg)
    {
    case PSPCB_ADDREF:
        {
            // we save off the address of the "real" ppsi in the pGlobal param of the
            // the template, so that the other drives can get to the global page information
            BBPROPSHEETINFO *ppsiGlobal = (BBPROPSHEETINFO *)ppsp;
            BBPROPSHEETINFO *ppsiTemplate = (BBPROPSHEETINFO *)ppsp->lParam;
            ppsiTemplate->pGlobal = ppsiGlobal;
            ppsiGlobal->pGlobal = ppsiGlobal;
        }
        break;

    case PSPCB_CREATE:
        return TRUE;                    // Yes, please create me
    }
    return 0;
}

STDMETHODIMP CBitBucket::AddPages(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam)
{
    BBPROPSHEETINFO bbpsp;
    TCHAR szTitle[MAX_PATH];
    
    if (SHRestricted(REST_BITBUCKNOPROP))
    {
        return E_ACCESSDENIED;
    }

    // read in the global settings
    DWORD dwSize1 = sizeof(bbpsp.fUseGlobalSettings);
    DWORD dwSize2 = sizeof(bbpsp.iOriginalPercent);
    DWORD dwSize3 = sizeof(bbpsp.fOriginalNukeOnDelete);
    if (RegQueryValueEx(g_hkBitBucket, TEXT("UseGlobalSettings"), NULL, NULL, (LPBYTE)&bbpsp.fOriginalUseGlobalSettings, &dwSize1) != ERROR_SUCCESS ||
        RegQueryValueEx(g_hkBitBucket, TEXT("Percent"), NULL, NULL, (LPBYTE)&bbpsp.iOriginalPercent, &dwSize2) != ERROR_SUCCESS ||
        RegQueryValueEx(g_hkBitBucket, TEXT("NukeOnDelete"), NULL, NULL, (LPBYTE)&bbpsp.fOriginalNukeOnDelete, &dwSize3) != ERROR_SUCCESS)
    {
        ASSERTMSG(FALSE, "Bitbucket: could not read global settings from the registry, re-regsvr32 shell32.dll!!");
        bbpsp.fUseGlobalSettings = TRUE;
        bbpsp.iOriginalPercent = 10;
        bbpsp.fOriginalNukeOnDelete = FALSE;
    }

    // Check policies

    bbpsp.fPolicyNukeOnDelete = SHRestricted(REST_BITBUCKNUKEONDELETE);
    if (bbpsp.fPolicyNukeOnDelete)
    {
        bbpsp.fOriginalNukeOnDelete = TRUE;
        bbpsp.fOriginalUseGlobalSettings = TRUE;
    }

    bbpsp.fPolicyPercent = (ReadPolicySetting(NULL,
                                              L"Explorer",
                                              L"RecycleBinSize",
                                              (LPBYTE)&bbpsp.iPercent,
                                              sizeof(bbpsp.iPercent)) == ERROR_SUCCESS);
    if (bbpsp.fPolicyPercent)
    {
        bbpsp.iOriginalPercent = bbpsp.iPercent;
    }
    else
    {
        bbpsp.iPercent = bbpsp.iOriginalPercent;
    }

    bbpsp.fUseGlobalSettings = bbpsp.fOriginalUseGlobalSettings;
    bbpsp.fNukeOnDelete = bbpsp.fOriginalNukeOnDelete;

    bbpsp.psp.dwSize = sizeof(bbpsp);
    bbpsp.psp.dwFlags = PSP_DEFAULT | PSP_USECALLBACK;
    bbpsp.psp.hInstance = HINST_THISDLL;
    bbpsp.psp.pszTemplate = MAKEINTRESOURCE(DLG_BITBUCKET_GENCONFIG);
    bbpsp.psp.pfnDlgProc = _GlobalPropDlgProc;
    bbpsp.psp.lParam = (LPARAM)&bbpsp;
    // the callback will fill the bbpsp.pGlobal with the pointer to the "real" psp after it has been copied
    // so that the other drive pages can get to the global information
    bbpsp.psp.pfnCallback = _GlobalSettingsCalback;

    // add the "Global" settings page
    HPROPSHEETPAGE hpage = CreatePropertySheetPage(&bbpsp.psp);

#ifdef UNICODE
    // If this assertion fires, it means that comctl32 lost
    // backwards-compatibility with Win95 shell, WinNT4 shell,
    // and IE4 shell, all of which relied on this undocumented
    // behavior.
    ASSERT(bbpsp.pGlobal == (BBPROPSHEETINFO *)((LPBYTE)hpage + 2 * sizeof(void *)));
#else
    ASSERT(bbpsp.pGlobal == (BBPROPSHEETINFO *)hpage);
#endif

    pfnAddPage(hpage, lParam);

    // now create the pages for the individual drives
    bbpsp.psp.dwFlags = PSP_USETITLE;
    bbpsp.psp.pszTemplate = MAKEINTRESOURCE(DLG_BITBUCKET_CONFIG);
    bbpsp.psp.pfnDlgProc = _DriveDlgProc;
    bbpsp.psp.pszTitle = szTitle;

    int idDrive, iPage;
    for (idDrive = 0, iPage = 1; (idDrive < MAX_BITBUCKETS) && (iPage < MAXPROPPAGES); idDrive++)
    {
        if (MakeBitBucket(idDrive))
        {
            dwSize1 = sizeof(bbpsp.iOriginalPercent);
            dwSize2 = sizeof(bbpsp.fOriginalNukeOnDelete);
            if (RegQueryValueEx(g_pBitBucket[idDrive]->hkey, TEXT("Percent"), NULL, NULL, (LPBYTE)&bbpsp.iOriginalPercent, &dwSize1) != ERROR_SUCCESS ||
                RegQueryValueEx(g_pBitBucket[idDrive]->hkey, TEXT("NukeOnDelete"), NULL, NULL, (LPBYTE)&bbpsp.fOriginalNukeOnDelete, &dwSize2) != ERROR_SUCCESS)
            {
                TraceMsg(TF_BITBUCKET, "Bitbucket: could not read settings from the registry for drive %d, using lame defaults", idDrive);
                bbpsp.iOriginalPercent = 10;
                bbpsp.fOriginalNukeOnDelete = FALSE;
            }

            if (bbpsp.fPolicyNukeOnDelete)
            {
                bbpsp.fOriginalNukeOnDelete = TRUE;
            }

            if (bbpsp.fPolicyPercent)
            {
                bbpsp.iOriginalPercent = bbpsp.iPercent;
            }

            bbpsp.iPercent = bbpsp.iOriginalPercent;
            bbpsp.fNukeOnDelete = bbpsp.fOriginalNukeOnDelete;

            bbpsp.idDrive = idDrive;

            _GetDriveDisplayName(idDrive, szTitle, ARRAYSIZE(szTitle));
            hpage = CreatePropertySheetPage(&bbpsp.psp);
            pfnAddPage(hpage, lParam);
        }
    }

    return S_OK;
}

STDMETHODIMP CBitBucket::ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE pfnReplaceWith, LPARAM lParam)
{
    return E_NOTIMPL;
}

STDAPI CBitBucket_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv)
{
    *ppv = NULL;
    HRESULT hr = E_OUTOFMEMORY;
    CBitBucket *pbb = new CBitBucket();
    if (pbb)
    {
        if (InitBBGlobals())
            hr = pbb->QueryInterface(riid, ppv);
        pbb->Release();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\bitbuck.c ===
#include "shellprv.h"
#pragma hdrstop

#include <regstr.h>     // REGSTR_PATH_POLICIES
#include "bitbuck.h"
#include "fstreex.h"
#include "copy.h"
#include "filetbl.h"
#include "propsht.h"
#include "datautil.h"
#include "cscuiext.h"

// mtpt.cpp
STDAPI_(BOOL) CMtPt_IsSecure(int iDrive);

// copy.c
void FOUndo_AddInfo(LPUNDOATOM lpua, LPTSTR pszSrc, LPTSTR pszDest, DWORD dwAttributes);
void FOUndo_FileReallyDeleted(LPTSTR pszFile);
void CALLBACK FOUndo_Release(LPUNDOATOM lpua);
void FOUndo_FileRestored(LPCTSTR pszFile);

// drivesx.c
DWORD PathGetClusterSize(LPCTSTR pszPath);

// bitbcksf.c
int DataObjToFileOpString(IDataObject * pdtobj, LPTSTR * ppszSrc, LPTSTR * ppszDest);


//
// per-process global bitbucket data
//
BOOL g_fBBInited = FALSE;                           // have we initialized our global data yet?
BOOL g_bIsProcessExplorer = FALSE;                  // are we the main explorer process? (if so, we persist the state info in the registry)
BBSYNCOBJECT *g_pBitBucket[MAX_BITBUCKETS] = {0};   // our array of bbso's that protect each bucket
HANDLE g_hgcGlobalDirtyCount = INVALID_HANDLE_VALUE;// a global counter to tell us if the global settings have changed and we need to re-read them
LONG g_lProcessDirtyCount = 0;                      // out current dirty count; we compare this to hgcDirtyCount to see if we need to update the settings from the registry
HANDLE g_hgcNumDeleters= INVALID_HANDLE_VALUE;      // a global counter that indicates the total # of people who are currently doing recycle bin file operations
HKEY g_hkBitBucket = NULL;                          // reg key that points to HKLM\Software\Microsoft\Windows\CurrentVersion\Explorer\BitBucket
HKEY g_hkBitBucketPerUser = NULL;                   // reg key that points to HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\BitBucket


//
// prototypes
//
void PersistBBDriveInfo(int idDrive);
BOOL IsFileDeletable(LPCTSTR pszFile);
BOOL CreateRecyclerDirectory(int idDrive);
void PurgeOneBitBucket(HWND hwnd, int idDrive, DWORD dwFlags);
int CountDeletedFilesOnDrive(int idDrive, LPDWORD pdwSize, int iMaxFiles);
BOOL GetBBDriveSettings(int idDrive, ULONGLONG *pcbDiskSpace);
void DeleteOldBBRegInfo(int idDrive);
BOOL IsBitBucketInited(int idDrive);
void FreeBBInfo(BBSYNCOBJECT *pbbso);
SECURITY_DESCRIPTOR* CreateRecycleBinSecurityDescriptor();


#define MAX_DELETE_ATTEMPTS  5
#define SLEEP_DELETE_ATTEMPT 1000

int DriveIDFromBBPath(LPCTSTR pszPath)
{
    TCHAR szNetHomeDir[MAX_PATH];
    LPCTSTR pszTempPath = pszPath;

    // NOTE: If we want to make recycle bin support recycling paths under mounted volumes
    // we need to modify this to sniff the path for mounted volume junction points
    int idDrive = PathGetDriveNumber(pszTempPath);

    if ((idDrive == -1) && GetNetHomeDir(szNetHomeDir))
    {
        int iLen = lstrlen(szNetHomeDir);

        // NOTE: we don't want to let you recycle the nethomedir itself, so
        // insure that pszPath is larger than the nethomedir path
        // (neither is trailed with a backslash)
        if ((iLen < lstrlen(pszTempPath)) &&
            (PathCommonPrefix(szNetHomeDir, pszTempPath, NULL) == iLen))
        {
            // this is a subdir of the nethomedir, so we recycle it to the net home server
            // which is drive 26
            return SERVERDRIVE;
        }
    }

    return idDrive;
}


void DriveIDToBBRoot(int idDrive, LPTSTR szPath)
{
    ASSERT(idDrive >= 0);
    
    if (SERVERDRIVE == idDrive) 
    {
        // nethomedir case
        if (!GetNetHomeDir(szPath))
        {
            ASSERT(szPath[0] == 0);
            TraceMsg(TF_BITBUCKET, "BitBucket: Machine does NOT have a NETHOMEDIR");
        }
        else
        {
            // use the nethomedir
            ASSERT(szPath[0] != 0);
        }
    }
    else
    {
        // build up the "C:\" string
        PathBuildRoot(szPath, idDrive);
    }
}

void DriveIDToBBVolumeRoot(int idDrive, LPTSTR szPath)
{
    DriveIDToBBRoot(idDrive, szPath);
    PathStripToRoot(szPath);
    PathAddBackslash(szPath);
}

void DriveIDToBBPath(int idDrive, LPTSTR pszPath)
{
    DriveIDToBBRoot(idDrive, pszPath);

    // NOTE: always append the SID for the SERVERDRIVE case
    if ((SERVERDRIVE == idDrive) || (CMtPt_IsSecure(idDrive)))
    {
        // NTRAID 196426-03/16/2001-isaacs
        // GetUserSid can fail and retun NULL.  We should fix the
        // 21 callers to DriveIDToBBPath in Blackcomb.  I have 
        // removed the assert and we will fall into the 
        // "non-secured" recycle bin processing.
        
        LPTSTR pszInmate = GetUserSid(NULL);
        if (pszInmate)
        {
            PathAppend(pszPath, TEXT("RECYCLER"));
            PathAppend(pszPath, pszInmate);
            LocalFree((HLOCAL)pszInmate);
            return;
        }
    }
    PathAppend(pszPath, TEXT("Recycled"));
}

TCHAR DriveChar(int idDrive)
{
    TCHAR chDrive = (SERVERDRIVE == idDrive) ? TEXT('@') : TEXT('a') + idDrive;

    ASSERT(idDrive >= 0 && idDrive < MAX_BITBUCKETS);
    return chDrive;
}

//
// converts "c:\recycled\whatver"  to "c"
//          \\nethomedir\share  to "@"
//
void DriveIDToBBRegKey(int idDrive, LPTSTR pszValue)
{
    pszValue[0] = DriveChar(idDrive);
    pszValue[1] = 0;
}


// Finds out if the given UNC path points to a real netware server,
// since netware in the recycle bin don't play well together.
//
// NOTE:  We cache the last passed value because the MyDocs almost *never* changes so
//        we don't have to hit the net if the path is the same as last time.
BOOL CheckForBBOnNovellServer(LPCTSTR pszUNCPath)
{
    static TCHAR s_szLastServerQueried[MAX_PATH] = {0};
    static BOOL s_bLastRet;
    BOOL bRet = FALSE;

    if (pszUNCPath && pszUNCPath[0])
    {
        BOOL bIsCached;
        
        ENTERCRITICAL;
        bIsCached = (lstrcmpi(pszUNCPath, s_szLastServerQueried) == 0);
        if (bIsCached)
        {
            // use the cached retval
            bRet = s_bLastRet;
        }
        LEAVECRITICAL;

        if (!bIsCached)
        {
            TCHAR szNetwareProvider[MAX_PATH];
            DWORD cchNetwareProvider = ARRAYSIZE(szNetwareProvider);

            ASSERT(PathIsUNC(pszUNCPath));

            // is the netware provider installed?
            if (WNetGetProviderName(WNNC_NET_NETWARE, szNetwareProvider, &cchNetwareProvider) == NO_ERROR)
            {
                NETRESOURCE nr = {0};
                TCHAR szServerName[MAX_PATH];

                // reduce the UNC path to \\server\share
                lstrcpyn(szServerName, pszUNCPath, ARRAYSIZE(szServerName));
                PathStripToRoot(szServerName);

                nr.dwType = RESOURCETYPE_DISK;
                nr.lpLocalName = NULL;              // don't map a drive
                nr.lpRemoteName = szServerName;
                nr.lpProvider = szNetwareProvider;  // use netware provider only

                if (WNetAddConnection3(NULL, &nr, NULL, NULL, 0) == NO_ERROR)
                {
                    bRet = TRUE;

                    // delete the connection (will fail if still in use)
                    WNetCancelConnection2(szServerName, 0, FALSE);
                }
            }

            ENTERCRITICAL;
            // update the last queried path
            lstrcpyn(s_szLastServerQueried, pszUNCPath, ARRAYSIZE(s_szLastServerQueried));

            // update cacehed retval
            s_bLastRet = bRet;
            LEAVECRITICAL;
        }
    }

    return bRet;
}


/*
 Network home drive code (from win95 days) is being used to support the recycle bin
 for users with mydocs redirected to a UNC path

 "Drive 26" specifies the network homedir

 This can return "" = (no net home dir, unknown setup, etc.)
                 or a string ( global ) pointing to the homedir (lfn)
*/
BOOL GetNetHomeDir(LPTSTR pszNetHomeDir)
{
    static TCHAR s_szCachedMyDocs[MAX_PATH] = {0};
    static DWORD s_dwCachedTickCount = 0;
    DWORD dwCurrentTickCount = GetTickCount();
    DWORD dwTickDelta;

    if (dwCurrentTickCount >= s_dwCachedTickCount)
    {
        dwTickDelta = dwCurrentTickCount - s_dwCachedTickCount;
    }
    else
    {
        // protect against 49.7 day rollover by forcing refresh
        dwTickDelta = (11 * 1000);
    }

    // is our cache more than 10 seconds old?
    if (dwTickDelta > (10 * 1000))
    {
        // update our cache time
        s_dwCachedTickCount = dwCurrentTickCount;

        if (SHGetSpecialFolderPath(NULL, pszNetHomeDir, CSIDL_PERSONAL, FALSE))
        {
            TCHAR szOldBBDir[MAX_PATH];

            if (PathIsUNC(pszNetHomeDir))
            {
                // Remove the trailing backslash (if present)
                // because this string will be passed to PathCommonPrefix()
                PathRemoveBackslash(pszNetHomeDir);

                // If mydocs is redirected to a UNC path on a Novell server, we need to return FALSE when 
                // IsFileDeletable is called, or the call to NtSetInformationFile with Disposition.DeleteFile=TRUE
                // will delete the file instantly even though there are open handles.
                if (CheckForBBOnNovellServer(pszNetHomeDir))
                {
                    pszNetHomeDir[0] = TEXT('\0');
                }
            }
            else
            {
                pszNetHomeDir[0] = TEXT('\0');
            }

            // check to see if the mydocs path has changed
            if (g_pBitBucket[SERVERDRIVE]                           &&
                (g_pBitBucket[SERVERDRIVE] != (BBSYNCOBJECT *)-1)   &&
                g_pBitBucket[SERVERDRIVE]->pidl                     &&
                SHGetPathFromIDList(g_pBitBucket[SERVERDRIVE]->pidl, szOldBBDir))
            {
                // we should always find "\RECYCLER\" because this is an old recycle bin directory.
                LPTSTR pszTemp = StrRStrI(szOldBBDir, NULL, TEXT("\\RECYCLER\\"));
                ASSERT(pszTemp);

                // cut the string off before the "\RECYCLER\<SID>" part so we can compare it to the current mydocs path
                *pszTemp = TEXT('\0');

                if (lstrcmpi(szOldBBDir, pszNetHomeDir) != 0)
                {   
                    if (*pszNetHomeDir)
                    {
                        TCHAR szNewBBDir[MAX_PATH];
                        LPITEMIDLIST pidl;
                        WIN32_FIND_DATA fd = {0};

                        // mydocs was redirected to a different UNC path, so update the bbsyncobject for the SERVERDRIVE

                        // copy the new mydocs location and add the "\RECYCLER\<SID>" part back on
                        lstrcpyn(szNewBBDir, pszNetHomeDir, ARRAYSIZE(szNewBBDir));
                        PathAppend(szNewBBDir, pszTemp + 1);

                        // create a simple pidl since "RECYCLER\<SID>" subdirectory might not exist yet
                        fd.dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
                        lstrcpyn(fd.cFileName, szNewBBDir, ARRAYSIZE(fd.cFileName));
                    
                        if (SUCCEEDED(SHSimpleIDListFromFindData(szNewBBDir, &fd, &pidl)))
                        {
                            LPITEMIDLIST pidlOld;
                            ULARGE_INTEGER ulFreeUser, ulTotal, ulFree;
                            DWORD dwClusterSize;
                            BOOL bUpdateSize = FALSE;

                            if (SHGetDiskFreeSpaceEx(pszNetHomeDir, &ulFreeUser, &ulTotal, &ulFree))
                            {
                                dwClusterSize = PathGetClusterSize(pszNetHomeDir);
                                bUpdateSize = TRUE;
                            }

                            ENTERCRITICAL;
                            // swap in the new pidl
                            pidlOld = g_pBitBucket[SERVERDRIVE]->pidl;
                            g_pBitBucket[SERVERDRIVE]->pidl = pidl;
                            ILFree(pidlOld);

                            // set the cchBBDir
                            g_pBitBucket[SERVERDRIVE]->cchBBDir = lstrlen(szNewBBDir);

                            g_pBitBucket[SERVERDRIVE]->fInited = TRUE;

                            // update the size fields
                            if (bUpdateSize)
                            {
                                ULARGE_INTEGER ulMaxSize;

                                g_pBitBucket[SERVERDRIVE]->dwClusterSize = dwClusterSize;
                                g_pBitBucket[SERVERDRIVE]->qwDiskSize = ulTotal.QuadPart;

                                // we limit the max size of the recycle bin to ~4 gig
                                ulMaxSize.QuadPart = min(((ulTotal.QuadPart / 100) * g_pBitBucket[SERVERDRIVE]->iPercent), (DWORD)-1);
                                ASSERT(ulMaxSize.HighPart == 0);
                                g_pBitBucket[SERVERDRIVE]->cbMaxSize = ulMaxSize.LowPart;
                            }
                            LEAVECRITICAL;
                        }
                    }
                    else
                    {
                        // mydocs was redireced back to a local path, so flag this drive as not inited so we wont do any more
                        // recycle bin operations on it.
                        ENTERCRITICAL;
                        g_pBitBucket[SERVERDRIVE]->fInited = FALSE;
                        LEAVECRITICAL;
                    }
                }
                else
                {
                    // the mydocs previously to pointed to \\foo\bar, and the user has set it back to that path again.
                    // so flag the drive as inited so we can start using it again.
                    if (g_pBitBucket[SERVERDRIVE]->fInited == FALSE)
                    {
                        ENTERCRITICAL;
                        g_pBitBucket[SERVERDRIVE]->fInited = TRUE;
                        LEAVECRITICAL;
                    }
                }
            }
        }
        else
        {
            pszNetHomeDir[0] = TEXT('\0');
        }

        ENTERCRITICAL;
        // update the cached value
        lstrcpyn(s_szCachedMyDocs, pszNetHomeDir, ARRAYSIZE(s_szCachedMyDocs));
        LEAVECRITICAL;
    }
    else
    {
        ENTERCRITICAL;
        // cache is still good
        lstrcpyn(pszNetHomeDir, s_szCachedMyDocs, MAX_PATH);
        LEAVECRITICAL;
    }

    return (BOOL)pszNetHomeDir[0];
}


STDAPI_(BOOL) IsBitBucketableDrive(int idDrive)
{
    BOOL bRet = FALSE;
    TCHAR szBBRoot[MAX_PATH];
    TCHAR szFileSystem[MAX_PATH];
    TCHAR szPath[4];
    DWORD dwAllowBitBuck = SHRestricted(REST_ALLOWBITBUCKDRIVES);
    
    if ((idDrive < 0)               ||
        (idDrive >= MAX_BITBUCKETS) ||
        (g_pBitBucket[idDrive] == (BBSYNCOBJECT *)-1))
    {
        // we dont support recycle bin for the general UNC case or we have 
        // flagged this drive as not having a recycle bin for one reason or another.
        return FALSE;
    }

    if (IsBitBucketInited(idDrive))
    {
        // the struct is allready allocated and inited, so this is a bitbucketable drive
        return TRUE;
    }

    if (idDrive == SERVERDRIVE)
    {
        bRet = GetNetHomeDir(szBBRoot);
    }
    else if ((GetDriveType(PathBuildRoot(szPath, idDrive)) == DRIVE_FIXED) ||
             (dwAllowBitBuck & (1 << idDrive)))
    {
        bRet = TRUE;
    }

    if (bRet && (idDrive != SERVERDRIVE))
    {
        // also check to make sure that the drive isint RAW (unformatted)
        DriveIDToBBRoot(idDrive, szBBRoot);
        
        if (!GetVolumeInformation(szBBRoot, NULL, 0, NULL, NULL, NULL, szFileSystem, ARRAYSIZE(szFileSystem)) ||
            lstrcmpi(szFileSystem, TEXT("RAW")) == 0)
        {
            bRet = FALSE;
        }
        else
        {
            // the drive better be NTFS, FAT or FAT32, else we need to know about it and handle it properly
            ASSERT((lstrcmpi(szFileSystem, TEXT("NTFS")) == 0)  || 
                   (lstrcmpi(szFileSystem, TEXT("FAT")) == 0)   ||
                   (lstrcmpi(szFileSystem, TEXT("FAT32")) == 0));
        }
    }

    return bRet;
}


// c:\recycled => c:\recycled\info2 (the new IE4/NT5/Win98 info file)
__inline void GetBBInfo2FileSpec(LPTSTR pszBBPath, LPTSTR pszInfo)
{
    PathCombine(pszInfo, pszBBPath, c_szInfo2);
}


// c:\recycled => c:\recycled\info (the old win95/NT4 info file)
__inline void GetBBInfoFileSpec(LPTSTR pszBBPath, LPTSTR pszInfo)
{
    PathCombine(pszInfo, pszBBPath, c_szInfo);
}


__inline BOOL IsBitBucketInited(int idDrive)
{
    BOOL bRet;

    // InitBBDriveInfo could fail and we free and set g_pBitBucket[idDrive] = -1. So there
    // is a small window between when we check g_pBitBucket[idDrive] and when we deref 
    // g_pBitBucket[idDrive]->fInited, to protect against g_pBitBucket[idDrive] being freed 
    // in this window we use the crit sec.
    ENTERCRITICAL;
    bRet = (g_pBitBucket[idDrive]                           &&
            (g_pBitBucket[idDrive] != (BBSYNCOBJECT *)-1)    && 
            g_pBitBucket[idDrive]->fInited);
    LEAVECRITICAL;

    return bRet;
}


BOOL RevOldBBInfoFileHeader(HANDLE hFile, BBDATAHEADER *pbbdh)
{
    // Verify that this is a valid info file
    if (pbbdh->cbDataEntrySize == sizeof(BBDATAENTRYW)) 
    {
        if (pbbdh->idVersion == BITBUCKET_WIN95_VERSION ||
            pbbdh->idVersion == BITBUCKET_NT4_VERSION   ||
            pbbdh->idVersion == BITBUCKET_WIN98IE4INT_VERSION)
        {
            DWORD dwBytesWritten;

            // now seek back to 0 and write in the new stuff
            pbbdh->idVersion = BITBUCKET_FINAL_VERSION;
            SetFilePointer(hFile, 0, NULL, FILE_BEGIN); // go to the beginning
            WriteFile(hFile, (LPBYTE)pbbdh, sizeof(BBDATAHEADER), &dwBytesWritten, NULL);
            
            ASSERT(dwBytesWritten == sizeof(BBDATAHEADER));
        }

        return (pbbdh->idVersion == BITBUCKET_FINAL_VERSION);
    }
    return FALSE;
}


//
// We need to update the cCurrent and cFiles in the info file header
// for compat with win98/IE4 machines.
//
BOOL UpdateBBInfoFileHeader(int idDrive)
{
    BBDATAHEADER bbdh = {0, 0, 0, sizeof(BBDATAENTRYW), 0}; // defaults
    HANDLE hFile;
    BOOL bRet = FALSE; // assume failure;

    // Pass 1 for the # of retry attempts since we are called during shutdown and if another process
    // is using the recycle bin we will hang and get the "End Task" dialog (bad!).
    hFile = OpenBBInfoFile(idDrive, OPENBBINFO_WRITE, 1);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        BBDATAENTRYW bbdew;
        DWORD dwBytesRead;

        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
        bRet = ReadFile(hFile, &bbdh, sizeof(BBDATAHEADER), &dwBytesRead, NULL);
        if (bRet && dwBytesRead == sizeof(BBDATAHEADER))
        {
            DWORD dwSize;
            DWORD dwBytesWritten;

            bbdh.idVersion = BITBUCKET_FINAL_VERSION;
            bbdh.cCurrent = SHGlobalCounterGetValue(g_pBitBucket[idDrive]->hgcNextFileNum);
            bbdh.cFiles = CountDeletedFilesOnDrive(idDrive, &dwSize, 0);
            bbdh.dwSize = dwSize;
            
            SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
            WriteFile(hFile, (LPBYTE)&bbdh, sizeof(BBDATAHEADER), &dwBytesWritten, NULL);
            
            ASSERT(dwBytesWritten == sizeof(BBDATAHEADER));
            bRet = TRUE;
        }

        ASSERT((g_pBitBucket[idDrive]->fIsUnicode && (sizeof(BBDATAENTRYW) == bbdh.cbDataEntrySize)) ||
               (!g_pBitBucket[idDrive]->fIsUnicode && (sizeof(BBDATAENTRYA) == bbdh.cbDataEntrySize)));

        // Since we dont flag entries that were deleted in the info file as deleted 
        // immeadeately, we need to go through and mark them as such now
        while (ReadNextDataEntry(hFile, &bbdew, TRUE, idDrive))
        {
            // do nothing
        }

        CloseBBInfoFile(hFile, idDrive);
    }

    if (!bRet)
    {
        TraceMsg(TF_BITBUCKET, "Bitbucket: failed to update drive %d for win98/NT4 compat!!", idDrive);
    }

    return bRet;
}

BOOL ResetInfoFileHeader(HANDLE hFile, BOOL fIsUnicode)
{
    DWORD dwBytesWritten;
    BBDATAHEADER bbdh = { BITBUCKET_FINAL_VERSION, 0, 0,
             fIsUnicode ? sizeof(BBDATAENTRYW) : sizeof(BBDATAENTRYA), 0};
    BOOL  fSuccess = FALSE;

    ASSERT(INVALID_HANDLE_VALUE != hFile);

    if (-1 != SetFilePointer(hFile, 0, NULL, FILE_BEGIN))
    {
        if (WriteFile(hFile, (LPBYTE)&bbdh, sizeof(BBDATAHEADER), &dwBytesWritten, NULL) &&
            dwBytesWritten == sizeof(BBDATAHEADER))
        {
            if (SetEndOfFile(hFile))
            {
                fSuccess = TRUE;
            }
        }
    }

    return fSuccess;    
}

BOOL CreateInfoFile(idDrive)
{
    TCHAR szBBPath[MAX_PATH];
    TCHAR szInfoFile[MAX_PATH];
    HANDLE hFile;
    BOOL   fSuccess = FALSE;

    DriveIDToBBPath(idDrive, szBBPath);
    GetBBInfo2FileSpec(szBBPath, szInfoFile);

    hFile = OpenBBInfoFile(idDrive, OPENBBINFO_CREATE, 0);

    if (hFile != INVALID_HANDLE_VALUE)
    {
        fSuccess = ResetInfoFileHeader(hFile, TRUE);
        CloseHandle(hFile);

        if (fSuccess)
        {
            // We explicitly call SHChangeNotify so that we can generate a change specifically
            // for the info file. The recycle bin shell folder will then ignore any updates to
            // the info file.
            SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, szInfoFile, NULL);
        }
    }
    
    if (!fSuccess)
    {
        TraceMsg(TF_WARNING, "Bitbucket: faild to create file info file!!");
    }
    return fSuccess;
}

//  GetNT4BBAcl() - Creates a ACL structure for allowing access for 
//                  only the current user,the administrators group, or the system.
//                  Returns a pointer to an access control list 
//                  structure in the local heap; it can be
//                  free'd with LocalFree.
//
// !! HACKHACK !! - This code was basically taken right out of NT4 so that we can
//                  compare against the old NT4 recycle bin ACL. The new helper function
//                  GetShellSecurityDescriptor puts the ACE's in a different order
//                  than this function, and so we memcmp the ACL against botht this
//                  one and the new win2k one.
PACL GetNT4BBAcl()
{
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    PACL         pAcl = NULL;
    PTOKEN_USER  pUser = NULL;
    PSID         psidSystem = NULL;
    PSID         psidAdmin = NULL;
    DWORD        cbAcl;
    DWORD        aceIndex;
    ACE_HEADER * lpAceHeader;
    UINT         nCnt = 2;  // inheritable; so two ACE's for each user
    BOOL         bSuccess = FALSE;


    //
    // Get the USER token so we can grab its SID for the DACL.
    //
    pUser = GetUserToken(NULL);
    if (!pUser)
    {
        TraceMsg(TF_BITBUCKET, "GetNT4BBAcl: Failed to get user.  Error = %d", GetLastError());
        goto Exit;
    }

    //
    // Get the system sid
    //
    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem)) {
         TraceMsg(TF_BITBUCKET, "GetNT4BBAcl: Failed to initialize system sid.  Error = %d", GetLastError());
         goto Exit;
    }


    //
    // Get the Admin sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &psidAdmin)) {
         TraceMsg(TF_BITBUCKET, "GetNT4BBAcl: Failed to initialize admin sid.  Error = %d", GetLastError());
         goto Exit;
    }


    //
    // Allocate space for the DACL
    //
    cbAcl = sizeof(ACL) +
            (nCnt * GetLengthSid(pUser->User.Sid)) +
            (nCnt * GetLengthSid(psidSystem)) +
            (nCnt * GetLengthSid(psidAdmin)) +
            (nCnt * 3 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));

    pAcl = (PACL)LocalAlloc(LPTR, cbAcl);
    if (!pAcl) {
        TraceMsg(TF_BITBUCKET, "GetNT4BBAcl: Failed to allocate acl.  Error = %d", GetLastError());
        goto Exit;
    }

    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
        TraceMsg(TF_BITBUCKET, "GetNT4BBAcl: Failed to initialize acl.  Error = %d", GetLastError());
        goto Exit;
    }

    //
    // Add Aces for User, System, and Admin.  Non-inheritable ACEs first
    //
    aceIndex = 0;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, pUser->User.Sid)) {
        TraceMsg(TF_BITBUCKET, "GetNT4BBAcl: Failed to add ace (%d).  Error = %d", aceIndex, GetLastError());
        goto Exit;
    }

    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidSystem)) {
        TraceMsg(TF_BITBUCKET, "GetNT4BBAcl: Failed to add ace (%d).  Error = %d", aceIndex, GetLastError());
        goto Exit;
    }

    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidAdmin)) {
        TraceMsg(TF_BITBUCKET, "GetNT4BBAcl: Failed to add ace (%d).  Error = %d", aceIndex, GetLastError());
        goto Exit;
    }

    //
    // Now the inheritable ACEs
    //

    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, pUser->User.Sid)) {
        TraceMsg(TF_BITBUCKET, "GetNT4BBAcl: Failed to add ace (%d).  Error = %d", aceIndex, GetLastError());
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
        TraceMsg(TF_BITBUCKET, "GetNT4BBAcl: Failed to get ace (%d).  Error = %d", aceIndex, GetLastError());
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);

    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidSystem)) {
        TraceMsg(TF_BITBUCKET, "GetNT4BBAcl: Failed to add ace (%d).  Error = %d", aceIndex, GetLastError());
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
        TraceMsg(TF_BITBUCKET, "GetNT4BBAcl: Failed to get ace (%d).  Error = %d", aceIndex, GetLastError());
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);

    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidAdmin)) {
        TraceMsg(TF_BITBUCKET, "GetNT4BBAcl: Failed to add ace (%d).  Error = %d", aceIndex, GetLastError());
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
        TraceMsg(TF_BITBUCKET, "GetNT4BBAcl: Failed to get ace (%d).  Error = %d", aceIndex, GetLastError());
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);

    bSuccess = TRUE;
    
Exit:
    if (pUser)
        LocalFree(pUser);

    if (psidSystem)
        FreeSid(psidSystem);

    if (psidAdmin)
        FreeSid(psidAdmin);

    if (!bSuccess && pAcl)
    {
        LocalFree(pAcl);
        pAcl = NULL;
    }

    return pAcl;
}


//
// this checks to make sure that the users recycle bin directory is properly acl'ed
//
BOOL CheckRecycleBinAcls(idDrive)
{
    BOOL bIsSecure = TRUE;
    TCHAR szBBPath[MAX_PATH];
    PSECURITY_DESCRIPTOR psdCurrent = NULL;
    PSID psidOwner;
    PACL pdaclCurrent;
    DWORD dwLengthNeeded = 0;

    if ((idDrive == SERVERDRIVE) || !CMtPt_IsSecure(idDrive))
    {
        // either redirected mydocs case (assume mydocs is already secured) or it 
        // is not an NTFS drive, so no ACL's to check
        return TRUE;
    }

    DriveIDToBBPath(idDrive, szBBPath);

    if (!GetFileSecurity(szBBPath,
                         DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION,
                         NULL,
                         0,
                         &dwLengthNeeded) &&
        (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
    {
        psdCurrent = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, dwLengthNeeded);
    }

    if (psdCurrent)    
    {
        BOOL bDefault = FALSE;
        BOOL bPresent = FALSE;

        if (GetFileSecurity(szBBPath,
                            DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION,
                            psdCurrent,
                            dwLengthNeeded,
                            &dwLengthNeeded) &&
            GetSecurityDescriptorOwner(psdCurrent, &psidOwner, &bDefault) && psidOwner &&
            GetSecurityDescriptorDacl(psdCurrent, &bPresent, &pdaclCurrent, &bDefault) && pdaclCurrent)
        {
            PTOKEN_USER pUser = GetUserToken(NULL);
        
            if (pUser)
            {
                if (!EqualSid(psidOwner, pUser->User.Sid))
                {
                    // the user is not the owner of the dir, check to see if the owner is the Administrators group or the System
                    // (we consider the directory to be secure if the owner is either of these two)
                    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
                    PSID psidAdministrators = NULL;
                    PSID psidSystem = NULL;

                    if (AllocateAndInitializeSid(&sia, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &psidAdministrators) && 
                        AllocateAndInitializeSid(&sia, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, &psidSystem))
                    {
                        if (!EqualSid(psidOwner, psidAdministrators) && !EqualSid(psidOwner, psidSystem))
                        {
                            // directory is not owned by the user, or the Administrators group or the system, we thus consider it unsecure.
                            TraceMsg(TF_BITBUCKET, "CheckRecycleBinAcls: dir %s has possibly unsecure owner!", szBBPath);
                            bIsSecure = FALSE;
                        }

                        if (psidAdministrators)
                            FreeSid(psidAdministrators);

                        if (psidSystem)
                            FreeSid(psidSystem);
                    }
                    else
                    {
                        TraceMsg(TF_BITBUCKET, "CheckRecycleBinAcls: AllocateAndInitializeSid failed, assuming %s is unsecure", szBBPath);
                        bIsSecure = FALSE;
                    }
                }

                if (bIsSecure)
                {
                    // directory owner checked out ok, lets see if the acl is what we expect...
                    SECURITY_DESCRIPTOR* psdRecycle = CreateRecycleBinSecurityDescriptor();

                    if (psdRecycle)
                    {
                        // to compare acls, we do a size check and then a memcmp (aclui code does the same)
                        if ((psdRecycle->Dacl->AclSize != pdaclCurrent->AclSize) ||
                            (memcmp(psdRecycle->Dacl, pdaclCurrent, pdaclCurrent->AclSize) != 0))
                        {
                            // acl sizes were different or they didn't memcmp, so check against the old NT4 style acl
                            // (in NT4 we added the ACE's in a different order which causes the memcmp to fail, even 
                            // though the ACL is equivilant)
                            PACL pAclNT4 = GetNT4BBAcl();

                            if (pAclNT4)
                            {
                                // do the same size / memcmp check
                                if ((pAclNT4->AclSize != pdaclCurrent->AclSize) ||
                                    (memcmp(pAclNT4, pdaclCurrent, pdaclCurrent->AclSize) != 0))
                                {
                                    // acl sizes were different or they didn't memcmp, so assume the dir is unsecure
                                    bIsSecure = FALSE;
                                }

                                LocalFree(pAclNT4);
                            }
                            else
                            {
                                TraceMsg(TF_BITBUCKET, "CheckRecycleBinAcls: GetNT4BBSecurityAttributes failed, assuming %s is unsecure", szBBPath);
                                bIsSecure = FALSE;
                            }
                        }

                        LocalFree(psdRecycle);
                    }
                    else
                    {
                        TraceMsg(TF_BITBUCKET, "CheckRecycleBinAcls: CreateRecycleBinSecurityDescriptor failed, assuming %s is unsecure", szBBPath);
                        bIsSecure = FALSE;
                    }

                }

                LocalFree(pUser);
            }
            else
            {
                // couldnt' get the users sid, so assume the dir is unsecure
                TraceMsg(TF_BITBUCKET, "CheckRecycleBinAcls: failed to get the users sid, assuming %s is unsecure", szBBPath);
                bIsSecure = FALSE;
            }
        }
        else
        {
            // GetFileSecurity failed, assume the dir is unsecure
            TraceMsg(TF_BITBUCKET, "CheckRecycleBinAcls: GetFileSecurity failed, assuming %s is unsecure", szBBPath);
            bIsSecure = FALSE;
        }

        LocalFree(psdCurrent);
    }
    else
    {
        // GetFileSecurity failed, assume the dir is unsecure
        TraceMsg(TF_BITBUCKET, "CheckRecycleBinAcls: GetFileSecurity failed or memory allocation failed, assume %s is unsecure", szBBPath);
        bIsSecure = FALSE;
    }
    
    if (!bIsSecure)
    {
        TCHAR szDriveName[MAX_PATH];

        DriveIDToBBRoot(idDrive, szDriveName);

        if (ShellMessageBox(HINST_THISDLL, 
                            NULL,
                            MAKEINTRESOURCE(IDS_RECYCLEBININVALIDFORMAT),
                            MAKEINTRESOURCE(IDS_WASTEBASKET),
                            MB_YESNO | MB_ICONEXCLAMATION | MB_SETFOREGROUND,
                szDriveName) == IDYES)
        {
            TCHAR szBBPathToNuke[MAX_PATH+1];
            SHFILEOPSTRUCT fo = {NULL,
                                 FO_DELETE,
                                 szBBPathToNuke,
                                 NULL,
                                 FOF_NOCONFIRMATION | FOF_SILENT,
                                 FALSE,
                                 NULL,
                                 NULL};

            lstrcpyn(szBBPathToNuke, szBBPath, MAX_PATH);
            szBBPathToNuke[lstrlen(szBBPathToNuke) + 1] = 0; // double null terminate

            // try to nuke the old recycle bin for this drive
            if (SHFileOperation(&fo) == ERROR_SUCCESS)
            {
                // now create the new secure one
                bIsSecure = CreateRecyclerDirectory(idDrive);
            }
        }
    }
   
    return bIsSecure;
}


//
// this verifies the info file header infomation
//
BOOL VerifyBBInfoFileHeader(int idDrive)
{
    BBDATAHEADER bbdh = {0, 0, 0, sizeof(BBDATAENTRYW), 0}; // defaults
    HANDLE hFile;
    TCHAR szBBPath[MAX_PATH];
    TCHAR szInfo[MAX_PATH];
    BOOL fSuccess = FALSE;

    // check for the the old win95 INFO file
    DriveIDToBBPath(idDrive, szBBPath);

    GetBBInfoFileSpec(szBBPath, szInfo);

    hFile = CreateFile(szInfo, GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL, OPEN_EXISTING, FILE_ATTRIBUTE_HIDDEN | FILE_FLAG_RANDOM_ACCESS, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        DWORD dwBytesRead;

        if (ReadFile(hFile, &bbdh, sizeof(BBDATAHEADER), &dwBytesRead, NULL) &&
            (dwBytesRead == sizeof(BBDATAHEADER)))
        {
            TraceMsg(TF_BITBUCKET, "Bitbucket: migrating info in old database file %s", szInfo);
            fSuccess = RevOldBBInfoFileHeader(hFile, &bbdh);
        }

        CloseHandle(hFile);

        if (fSuccess) 
        {
            // rename from INFO -> INFO2
            TCHAR szInfoNew[MAX_PATH];

            GetBBInfo2FileSpec(szBBPath, szInfoNew);
            TraceMsg(TF_BITBUCKET, "Bitbucket: renaming %s to %s !!", szInfo, szInfoNew);
            SHMoveFile(szInfo, szInfoNew, SHCNE_RENAMEITEM);
        }
        else
        {
            goto bad_info_file;
        }
    }

    // Failed to open or rev the old info file. Next, we check for the existance of the new info2 file
    // to see if the drive has a bitbucket format that is greater than what we can handle
    if (!fSuccess)
    {
        hFile = OpenBBInfoFile(idDrive, OPENBBINFO_READ, 0);

        if (hFile != INVALID_HANDLE_VALUE)
        {
            BOOL bRet;
            DWORD dwBytesRead;

            SetFilePointer(hFile, 0, NULL, FILE_BEGIN); // go to the beginning
            bRet = ReadFile(hFile, &bbdh, sizeof(BBDATAHEADER), &dwBytesRead, NULL);
            CloseBBInfoFile(hFile, idDrive);

            if ((bRet == 0)                                 ||
                (dwBytesRead != sizeof(BBDATAHEADER))       ||
                (bbdh.idVersion > BITBUCKET_FINAL_VERSION)  ||
                (bbdh.cbDataEntrySize != sizeof(BBDATAENTRYA) && bbdh.cbDataEntrySize != sizeof(BBDATAENTRYW)))
            {
                TCHAR szDriveName[MAX_PATH];

                // either we had a corrupt win95 info file, or an info2 file whose version is greater than ours
                // so we just empy the recycle bin.
bad_info_file:
                // since we failed to read the existing header, assume the native format
                g_pBitBucket[idDrive]->fIsUnicode = TRUE;

                // find out which drive it is that is corrupt
                DriveIDToBBRoot(idDrive, szDriveName);

                if (ShellMessageBox(HINST_THISDLL, 
                                    NULL,
                                    MAKEINTRESOURCE(IDS_RECYCLEBININVALIDFORMAT),
                                    MAKEINTRESOURCE(IDS_WASTEBASKET),
                                    MB_YESNO | MB_ICONEXCLAMATION | MB_SETFOREGROUND,
                    szDriveName) == IDYES)
                {
                    // nuke this bucket since it is hosed
                    PurgeOneBitBucket(NULL, idDrive, SHERB_NOCONFIRMATION);
                    return TRUE;
                }

                hFile = OpenBBInfoFile(idDrive, OPENBBINFO_WRITE, 0);

                if (hFile != INVALID_HANDLE_VALUE)
                {
                    DWORD dwBytesWritten;

                    bbdh.idVersion = BITBUCKET_FINAL_VERSION;

                    if (bbdh.cbDataEntrySize != sizeof(BBDATAENTRYW) &&
                        bbdh.cbDataEntrySize != sizeof(BBDATAENTRYA))
                    {
                        // assume the native data entry size
                        bbdh.cbDataEntrySize = sizeof(BBDATAENTRYW);
                    }

                    g_pBitBucket[idDrive]->fIsUnicode = (bbdh.cbDataEntrySize == sizeof(BBDATAENTRYW));
            
                    SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
                    WriteFile(hFile, (LPBYTE)&bbdh, sizeof(BBDATAHEADER), &dwBytesWritten, NULL);
                    ASSERT(dwBytesWritten == sizeof(BBDATAHEADER));
            
                    CloseBBInfoFile(hFile, idDrive);
                    fSuccess = TRUE;
                }
                else
                {

                    fSuccess = FALSE;
                }
            }
            else if (bbdh.idVersion != BITBUCKET_FINAL_VERSION)
            {
                // old info2 information
                fSuccess = RevOldBBInfoFileHeader(hFile, &bbdh);
            }
            else
            {
                // the header info is current
                fSuccess = TRUE;
            }
        }
        else
        {
            // brand spanking new drive, so go create the info file now.
            fSuccess = CreateInfoFile(idDrive);
        }
    }

    // get the only relevant thing in the header, whether it is unicode or not 
    g_pBitBucket[idDrive]->fIsUnicode = (bbdh.cbDataEntrySize == sizeof(BBDATAENTRYW));

    return fSuccess;
}


LONG FindInitialNextFileNum(idDrive)
{
    int iRet = 0;
    TCHAR szBBFileSpec[MAX_PATH];
    WIN32_FIND_DATA fd;
    HANDLE hFind;

    DriveIDToBBPath(idDrive, szBBFileSpec);
    PathAppend(szBBFileSpec, TEXT("D*.*"));

    hFind = FindFirstFile(szBBFileSpec, &fd);
    if (hFind != INVALID_HANDLE_VALUE)
    {
        do
        {
            if (!PathIsDotOrDotDot(fd.cFileName) && lstrcmpi(fd.cFileName, c_szDesktopIni))
            {
                int iCurrent = BBPathToIndex(fd.cFileName);
                if (iCurrent > iRet)
                {
                    iRet = iCurrent;
                }
            }
        } while (FindNextFile(hFind, &fd));

        FindClose(hFind);
    }

    ASSERT(iRet >= 0);
    
    return (LONG)iRet;
}

BOOL InitBBDriveInfo(int idDrive)
{
    TCHAR szName[MAX_PATH];
    DWORD dwDisp;
    LONG lInitialCount = 0;
    
    // build up the string "BitBucket.<drive letter>"
    lstrcpy(szName, TEXT("BitBucket.")); 
    DriveIDToBBRegKey(idDrive, &szName[10]);

    lstrcpy(&szName[11], TEXT(".DirtyCount"));
    g_pBitBucket[idDrive]->hgcDirtyCount = SHGlobalCounterCreateNamed(szName, 0); // BitBucket.<drive letter>.DirtyCount

    if (g_pBitBucket[idDrive]->hgcDirtyCount == INVALID_HANDLE_VALUE)
    {
        ASSERTMSG(FALSE, "BitBucket: failed to create hgcDirtyCount for drive %d !!", idDrive);
        return FALSE;
    }

    // now create the subkey for this drive
    DriveIDToBBRegKey(idDrive, szName);

    // the per-user key is volatile since we only use this for temporary bookeeping (eg need to purge / compact).
    // the exception to this rule is the SERVERDRIVE case, because this is the users "My Documents" so we let it 
    // and we also need to store the path under that key (it has to roam with the user)
    if (RegCreateKeyEx(g_hkBitBucketPerUser, szName, 0, NULL,
                       (SERVERDRIVE == idDrive) ? REG_OPTION_NON_VOLATILE : REG_OPTION_VOLATILE,
                       KEY_SET_VALUE | KEY_QUERY_VALUE,
                       NULL, &g_pBitBucket[idDrive]->hkeyPerUser,
                       &dwDisp) != ERROR_SUCCESS)
    {
        ASSERTMSG(FALSE, "BitBucket: Could not create HKCU BitBucket registry key for drive %s", szName);
        g_pBitBucket[idDrive]->hkeyPerUser = NULL;
        return FALSE;
    }

    if (RegCreateKeyEx(g_hkBitBucket, szName, 0, NULL, REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED,
                       NULL, &g_pBitBucket[idDrive]->hkey, &dwDisp) != ERROR_SUCCESS)
    {
        TraceMsg(TF_BITBUCKET, "BitBucket: Could not create HKLM BitBucket registry key for drive %s, falling back to HKLM global key! ", szName);
        if (RegOpenKeyEx(g_hkBitBucket, NULL, 0, MAXIMUM_ALLOWED, &g_pBitBucket[idDrive]->hkey) != ERROR_SUCCESS)
        {
            ASSERTMSG(FALSE, "BitBucket: Could not duplicate HKLM Global Bitbucket key!");
            return FALSE;
        }
    }

    // load the rest of the settings (hgcNextFileNum, fIsUnicode, iPercent, cbMaxSize, dwClusterSize, and fNukeOnDelete)
    return GetBBDriveSettings(idDrive, NULL);
}


BOOL AllocBBDriveInfo(int idDrive)
{
    TCHAR szBBPath[MAX_PATH];
    LPITEMIDLIST pidl;
    BOOL bRet = FALSE; // assume failure

    DriveIDToBBPath(idDrive, szBBPath);
    pidl = ILCreateFromPath(szBBPath);

    if (!pidl && !PathFileExists(szBBPath))
    {
        if (CreateRecyclerDirectory(idDrive))
        {
            pidl = ILCreateFromPath(szBBPath);
        }
    }

    if (pidl)
    {
        BBSYNCOBJECT *pbbso = LocalAlloc(LPTR, sizeof(*pbbso));
        if (pbbso)
        {
            if (SHInterlockedCompareExchange(&g_pBitBucket[idDrive], pbbso, NULL))
            {
                DWORD dwInitialTickCount = GetTickCount();
                BOOL bKeepWaiting = TRUE;

                // Some other thread beat us to creating this bitbucket.
                // We can't return until that thread has inited the bitbucket
                // since some of the members might not be valid yet.
                LocalFree(pbbso);
                ILFree(pidl);

                do
                {
                    if (g_pBitBucket[idDrive] == (BBSYNCOBJECT *)-1)
                    {
                        // this volume is flagged as not being recycleable for some reason...
                        break;
                    }

                    // Spin until the bitbucket struct is inited
                    Sleep(50);
                    
                    bKeepWaiting = !IsBitBucketInited(idDrive);

                    // we should never spin more than ~15 seconds
                    if (((GetTickCount() - dwInitialTickCount) >= (60 * 1000))  && bKeepWaiting)
                    {
                        ASSERTMSG(FALSE, "AllocBBDriveInfo: other thread took longer that 1 minute to init a bitbucket?!?");
                        break;
                    }

                } while (bKeepWaiting);

                return ((g_pBitBucket[idDrive] != NULL) && 
                        (g_pBitBucket[idDrive] != (BBSYNCOBJECT *)-1));
            }

            ASSERT(g_pBitBucket[idDrive] && (g_pBitBucket[idDrive] != (BBSYNCOBJECT *)-1));
            g_pBitBucket[idDrive]->pidl = pidl;
            g_pBitBucket[idDrive]->cchBBDir = lstrlen(szBBPath);

            if (InitBBDriveInfo(idDrive))
            {
                // Success!!
                g_pBitBucket[idDrive]->fInited = TRUE;
                bRet = TRUE;
            }
            else
            {
                // we failed for some weird reason
                TraceMsg(TF_WARNING, "Bitbucket: InitBBDriveInfo() failed on drive %d", idDrive);
                ILFree(pidl);
                
                ENTERCRITICAL;
                // take the critical section to protect people who call IsBitBucketInited()
                FreeBBInfo(g_pBitBucket[idDrive]);

                if (idDrive == SERVERDRIVE)
                {
                    // We set it to null in the serverdrive case so we will always retry. This allows 
                    // the user to re-direct and try to recycle on a new location.
                    g_pBitBucket[idDrive] = NULL;
                }
                else
                {
                    // set it to -1 here so we dont try any future recycle operations on this volume
                    g_pBitBucket[idDrive] = (BBSYNCOBJECT *)-1;
                }
                LEAVECRITICAL;
            }
        }
        else
        {
            ILFree(pidl);
        }
    }

    return bRet;
}


BOOL InitBBGlobals()
{
    if (!g_fBBInited)
    {
        // Save this now beceause at shutdown the desktop window will already be gone,
        // so we need to find out if we are the main explorer process now.
        if (!g_bIsProcessExplorer)
        {
            g_bIsProcessExplorer = IsWindowInProcess(GetShellWindow());
        }

        // do we have our global hkey that points to HKLM\Software\Microsoft\Windows\CurrentVersion\BitBucket yet?
        if (!g_hkBitBucket)
        {
            g_hkBitBucket = SHGetShellKey(SHELLKEY_HKLM_EXPLORER, TEXT("BitBucket"), TRUE);
            if (!g_hkBitBucket)
            {
                TraceMsg(TF_WARNING, "Bitbucket: Could not create g_hkBitBucket!");
                return FALSE;
            }
        }

        // do we have our global hkey that points to HKCU\Software\Microsoft\Windows\CurrentVersion\BitBucket yet?
        if (!g_hkBitBucketPerUser)
        {
            g_hkBitBucketPerUser = SHGetShellKey(SHELLKEY_HKCU_EXPLORER, TEXT("BitBucket"), TRUE);
            if (!g_hkBitBucketPerUser)
            {
                TraceMsg(TF_WARNING, "Bitbucket: Could not create g_hkBitBucketPerUser!");
                return FALSE;
            }
        }

        // have we initialized the global settings dirty counter yet
        if (g_hgcGlobalDirtyCount == INVALID_HANDLE_VALUE)
        {
            g_hgcGlobalDirtyCount = SHGlobalCounterCreateNamed(TEXT("BitBucket.GlobalDirtyCount"), 0);

            if (g_hgcGlobalDirtyCount == INVALID_HANDLE_VALUE)
            {
                TraceMsg(TF_WARNING, "Bitbucket: failed to create g_hgcGlobalDirtyCount!");
                return FALSE;
            }

            g_lProcessDirtyCount = SHGlobalCounterGetValue(g_hgcGlobalDirtyCount);
        }

        // have we initialized the global # of people doing recycle bin file operations?
        if (g_hgcNumDeleters == INVALID_HANDLE_VALUE)
        {
            g_hgcNumDeleters = SHGlobalCounterCreateNamed(TEXT("BitBucket.NumDeleters"), 0);

            if (g_hgcGlobalDirtyCount == INVALID_HANDLE_VALUE)
            {
                TraceMsg(TF_WARNING, "Bitbucket: failed to create g_hgcGlobalDirtyCount!");
                return FALSE;
            }
        }

        // we inited everything!!
        g_fBBInited = TRUE;
    }

    return g_fBBInited;
}


void FreeBBInfo(BBSYNCOBJECT *pbbso)
{
    if (pbbso->hgcNextFileNum)
        CloseHandle(pbbso->hgcNextFileNum);

    if (pbbso->hgcDirtyCount)
        CloseHandle(pbbso->hgcDirtyCount);

    if (pbbso->hkey)
        RegCloseKey(pbbso->hkey);
    
    if (pbbso->hkeyPerUser)
        RegCloseKey(pbbso->hkeyPerUser);

    LocalFree(pbbso);
}


//
// This function is exported from shell32 so that explorer can call us during WM_ENDSESSION
// and we can go save a bunch of state and free all the semaphores. 
STDAPI_(void) SaveRecycleBinInfo()
{
    if (g_bIsProcessExplorer)
    {
        LONG lGlobalDirtyCount;
        BOOL bGlobalUpdate = FALSE; // did global settings change?
        int i;

        // We are going to persist the info to the registry, so check to see if we need to 
        // update our info now
        lGlobalDirtyCount = SHGlobalCounterGetValue(g_hgcGlobalDirtyCount);
        if (g_lProcessDirtyCount < lGlobalDirtyCount)
        {
            g_lProcessDirtyCount = lGlobalDirtyCount;
            RefreshAllBBDriveSettings();
            bGlobalUpdate = TRUE;
        }

        for (i = 0; i < MAX_BITBUCKETS ; i++)
        {
            if (IsBitBucketInited(i))
            {
                LONG lBucketDirtyCount = SHGlobalCounterGetValue(g_pBitBucket[i]->hgcDirtyCount);

                // if we didnt do a global update, check this bucket specifically to see if it is dirty
                // and we need to update it
                if (!bGlobalUpdate && g_pBitBucket[i]->lCurrentDirtyCount < lBucketDirtyCount)
                {
                    g_pBitBucket[i]->lCurrentDirtyCount = lBucketDirtyCount;
                    RefreshBBDriveSettings(i);
                }

                // save all of the volume serial # and whether the drive is unicode to the registry
                PersistBBDriveInfo(i);

                // we also update the header for win98/IE4 compat
                UpdateBBInfoFileHeader(i);
            }
        }
    }
}


void BitBucket_Terminate()
{
    int i;

    // free the global recycle bin structs
    for (i = 0; i < MAX_BITBUCKETS ; i++)
    {
        if ((g_pBitBucket[i]) && (g_pBitBucket[i] != (BBSYNCOBJECT *)-1))
        {
            ENTERCRITICAL;
            FreeBBInfo(g_pBitBucket[i]);
            g_pBitBucket[i] = NULL;
            LEAVECRITICAL;
        }
    }

    if (g_hgcGlobalDirtyCount != INVALID_HANDLE_VALUE)
        CloseHandle(g_hgcGlobalDirtyCount);

    if (g_hgcNumDeleters != INVALID_HANDLE_VALUE)
        CloseHandle(g_hgcNumDeleters);

    if (g_hkBitBucketPerUser != NULL)
        RegCloseKey(g_hkBitBucketPerUser);

    if (g_hkBitBucket != NULL)
        RegCloseKey(g_hkBitBucket);
}

//
// refreshes g_pBitBucket with new global settings
//
BOOL RefreshAllBBDriveSettings()
{
    int i;

    // since global settings changes affect all the drives, update all the drives
    for (i = 0; i < MAX_BITBUCKETS; i++)
    {
        if ((g_pBitBucket[i]) && (g_pBitBucket[i] != (BBSYNCOBJECT *)-1))
        {
            RefreshBBDriveSettings(i);
        }
    }
    
    return TRUE;
}


BOOL ReadBBDriveSetting(HKEY hkey, LPTSTR pszValue, LPBYTE pbData, DWORD cbData)
{
    DWORD dwSize;

retry:

    dwSize = cbData;
    if (RegQueryValueEx(hkey, pszValue, NULL, NULL, pbData, &dwSize) != ERROR_SUCCESS)
    {
        if (hkey == g_hkBitBucket)
        {
            ASSERTMSG(FALSE, "Missing global bitbucket data: run regsvr32 on shell32.dll !!");
            return FALSE;
        }
        else
        {
            // we are missing the per-bitbuckt information, so fall back to the global stuff
            hkey = g_hkBitBucket;
            goto retry;
        }
    }

    return TRUE;
}

//
// Same as SHGetRestriction, except you can tell the difference between
// "policy not set" and "policy set with value=0"
//
DWORD ReadPolicySetting(LPCWSTR pszBaseKey, LPCWSTR pszGroup, LPCWSTR pszRestriction, LPBYTE pbData, DWORD cbData)
{
    // Make sure the string is long enough to hold longest one...
    WCHAR szSubKey[MAX_PATH];
    DWORD dwSize;
    DWORD dwRet;

    //
    // This restriction hasn't been read yet.
    //
    if (!pszBaseKey)
    {
        pszBaseKey = REGSTR_PATH_POLICIES;
    }
#ifndef UNIX
    PathCombineW(szSubKey, pszBaseKey, pszGroup);
#else
    wsprintfW(szSubKey, L"%s\\%s", pszBaseKey, pszGroup);
#endif

    // Check local machine first and let it override what the
    // HKCU policy has done.
    dwSize = cbData;
    dwRet = SHGetValueW(HKEY_LOCAL_MACHINE, szSubKey, pszRestriction, NULL, pbData, &dwSize);
    if (ERROR_SUCCESS != dwRet)
    {
        // Check current user if we didn't find anything for the local machine.
        dwSize = cbData;
        dwRet = SHGetValueW(HKEY_CURRENT_USER, szSubKey, pszRestriction, NULL, pbData, &dwSize);
    }

    return dwRet;
}

BOOL RefreshBBDriveSettings(int idDrive)
{
    HKEY hkey;
    ULARGE_INTEGER ulMaxSize;
    BOOL fUseGlobalSettings = TRUE;
    DWORD dwSize = sizeof(fUseGlobalSettings);

    ASSERT(g_pBitBucket[idDrive] && (g_pBitBucket[idDrive] != (BBSYNCOBJECT *)-1));

    RegQueryValueEx(g_hkBitBucket, TEXT("UseGlobalSettings"), NULL, NULL, (LPBYTE)&fUseGlobalSettings, &dwSize);
    
    if (fUseGlobalSettings)
    {
        hkey = g_hkBitBucket;
    }
    else
    {
        hkey = g_pBitBucket[idDrive]->hkey;
    }

    // read the iPercent value

    if (ERROR_SUCCESS == ReadPolicySetting(NULL, L"Explorer", L"RecycleBinSize", (LPBYTE)&g_pBitBucket[idDrive]->iPercent, sizeof(g_pBitBucket[idDrive]->iPercent)))
    {
        // Make sure it's not too big or too small
        g_pBitBucket[idDrive]->iPercent = max(0, min(100, g_pBitBucket[idDrive]->iPercent));
    }
    else if (!ReadBBDriveSetting(hkey, TEXT("Percent"), (LPBYTE)&g_pBitBucket[idDrive]->iPercent, sizeof(g_pBitBucket[idDrive]->iPercent)))
    {
        // default
        g_pBitBucket[idDrive]->iPercent = 10;
    }

    // read the fNukeOnDelete value

    if (SHRestricted(REST_BITBUCKNUKEONDELETE))
    {
        g_pBitBucket[idDrive]->fNukeOnDelete = TRUE;
    }
    else if (!ReadBBDriveSetting(hkey, TEXT("NukeOnDelete"), (LPBYTE)&g_pBitBucket[idDrive]->fNukeOnDelete, sizeof(g_pBitBucket[idDrive]->fNukeOnDelete)))
    {
        // default
        g_pBitBucket[idDrive]->fNukeOnDelete = FALSE;
    }

    // re-calculate cbMaxSize based on the new iPercent
    ulMaxSize.QuadPart = min((g_pBitBucket[idDrive]->qwDiskSize / 100) * g_pBitBucket[idDrive]->iPercent, (DWORD)-1);
    ASSERT(ulMaxSize.HighPart == 0);
    g_pBitBucket[idDrive]->cbMaxSize = ulMaxSize.LowPart;

    // since we just refreshed the settings from the registry, we are now up to date
    g_pBitBucket[idDrive]->lCurrentDirtyCount = SHGlobalCounterGetValue(g_pBitBucket[idDrive]->hgcDirtyCount);

    return TRUE;
}


//
// this function is used to compact the bitbucked INFO files.
//
// we do a lazy delete (just mark the entries as deleted) and when we hit a
// certain number of bogus entries in the info file, we need to go through and clean up the
// garbage and compact the file.
//
DWORD CALLBACK CompactBBInfoFileThread(void *pData)
{
    int idDrive = PtrToLong(pData);

    //
    // PERF (reinerf) - as an optimization, we might want to check here to see
    // if someone is waiting to empty the bitbucket since if we are going to empty
    // this bucket there is no point in wasting time compacting it.
    //

    HANDLE hFile = OpenBBInfoFile(idDrive, OPENBBINFO_WRITE, 0);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        // work in chunks of 10
        BBDATAENTRYW bbdewArray[10]; // use a unicode array, but it might end up holding BBDATAENTRYA stucts
        LPBBDATAENTRYW pbbdew = bbdewArray;
        int iNumEntries = 0;
        DWORD dwDataEntrySize = g_pBitBucket[idDrive]->fIsUnicode ? sizeof(BBDATAENTRYW) : sizeof(BBDATAENTRYA);
        DWORD dwReadPos = 0;
        DWORD dwBytesWritten;

        // save off the inital write pos
        DWORD dwWritePos = SetFilePointer(hFile, 0, NULL, FILE_CURRENT);

        while (ReadNextDataEntry(hFile, pbbdew, TRUE, idDrive))
        {
            ASSERT(!IsDeletedEntry(pbbdew));

            iNumEntries++;

            // do we have 10 entries yet?
            if (iNumEntries == ARRAYSIZE(bbdewArray))
            {
                iNumEntries = 0;

                TraceMsg(TF_BITBUCKET, "Bitbucket: Compacting drive %d: dwRead = %d, dwWrite = %d, writing 10 entries", idDrive, dwReadPos, dwWritePos);

                // save where we are for reading
                dwReadPos = SetFilePointer(hFile, 0, NULL, FILE_CURRENT);

                // then go to where we are for writing
                SetFilePointer(hFile, dwWritePos, NULL, FILE_BEGIN);

                // write it out
                if (!WriteFile(hFile, (LPBYTE)bbdewArray, dwDataEntrySize * ARRAYSIZE(bbdewArray), &dwBytesWritten, NULL) || dwBytesWritten != (dwDataEntrySize * ARRAYSIZE(bbdewArray)))
                {
                    // we're in big trouble if this happens.
                    // bail completely so that at worst, we only have a few bad records.
                    // if we keep trying to write from this point, but the write point is
                    // we'll nuke all the records
                    ASSERTMSG(FALSE, "Bitbucket: we were compacting drive %d and it is totally messed up", idDrive);
                    break;
                }

                // sucess! move our write pos to the end of were we finished writing
                dwWritePos += (dwDataEntrySize * ARRAYSIZE(bbdewArray));
                
                // go back to were we left off reading
                SetFilePointer(hFile, dwReadPos, NULL, FILE_BEGIN);

                // reset our lparray pointer
                pbbdew = bbdewArray;
            }
            else
            {
                // dont have 10 entries yet, so keep going
                pbbdew = (LPBBDATAENTRYW)((LPBYTE)pbbdew + dwDataEntrySize);
            }
        }

        TraceMsg(TF_BITBUCKET, "Bitbucket: Compacting drive %d: dwRead = %d, dwWrite = %d, writing last %d entries", idDrive, dwReadPos, dwWritePos, iNumEntries);

        // write whatever we have left over
        SetFilePointer(hFile, dwWritePos, NULL, FILE_BEGIN);
        WriteFile(hFile, (LPBYTE)bbdewArray, dwDataEntrySize * iNumEntries, &dwBytesWritten, NULL);
        ASSERT(dwBytesWritten == (dwDataEntrySize * iNumEntries));
        SetEndOfFile(hFile);
        CloseBBInfoFile(hFile, idDrive);
    }

    return 0;
}

void CompactBBInfoFile(int idDrive)
{
    HANDLE hThread;
    DWORD idThread;

    // try to spin up a background thread to do the work for us
    hThread = CreateThread(NULL, 0, CompactBBInfoFileThread, IntToPtr(idDrive), 0, &idThread);

    if (hThread)
    {
        // let the background thread do the work
        CloseHandle(hThread);
    }
    else
    {
        TraceMsg(TF_BITBUCKET, "BBCompact - failed to create backgound thread! Doing work on this thread");
        CompactBBInfoFileThread(IntToPtr(idDrive));
    }
}

void GetDeletedFileNameFromParts(LPTSTR pszFileName, int idDrive, int iIndex, LPCTSTR pszOriginal)
{
    wnsprintf(pszFileName, MAX_PATH, TEXT("D%c%d%s"), DriveChar(idDrive), iIndex, PathFindExtension(pszOriginal));
}

void GetDeletedFileName(LPTSTR pszFileName, const BBDATAENTRYW *pbbdew)
{
    GetDeletedFileNameFromParts(pszFileName, pbbdew->idDrive, pbbdew->iIndex, pbbdew->szOriginal);
}

// get the full path to the file/folder in the recycle bin location

void GetDeletedFilePath(LPTSTR pszPath, const BBDATAENTRYW *pbbdew)
{
    TCHAR szFileName[MAX_PATH];
    DriveIDToBBPath(pbbdew->idDrive, pszPath);
    GetDeletedFileName(szFileName, pbbdew);
    PathAppend(pszPath, szFileName);
}


void UpdateIcon(BOOL fFull)
{
    LONG    cbData;
    DWORD   dwType;
    HKEY    hkeyCLSID = NULL;
    HKEY    hkeyUserCLSID = NULL;
    TCHAR   szTemp[MAX_PATH];
    TCHAR   szNewValue[MAX_PATH];
    TCHAR   szValue[MAX_PATH];

    TraceMsg(TF_BITBUCKET, "BitBucket: UpdateIcon %s", fFull ? TEXT("Full") : TEXT("Empty"));

    szValue[0] = 0;
    szNewValue[0] = 0;

    // get the HKCR CLSID key (HKCR\CLSID\CLSID_RecycleBin\DefaultIcon)
    if (FAILED(SHRegGetCLSIDKey(&CLSID_RecycleBin, c_szDefaultIcon, FALSE, FALSE, &hkeyCLSID)))
        goto error;

    // get the per-user CLSID
    // HKCU
    //      NT: Software\Microsoft\Windows\CurrentVersion\Explorer\CLSID
    //      9x: Software\Classes\CLSID
    if (FAILED(SHRegGetCLSIDKey(&CLSID_RecycleBin, c_szDefaultIcon, TRUE, FALSE, &hkeyUserCLSID)))
    {
        // it most likely failed because the reg key dosent exist, so create it now
        if (FAILED(SHRegGetCLSIDKey(&CLSID_RecycleBin, c_szDefaultIcon, TRUE, TRUE, &hkeyUserCLSID)))
            goto error;

        // now that we created it, lets copy the stuff from HKLM there
        
        // get the local machine default icon
        cbData = sizeof(szTemp);
        if (RegQueryValueEx(hkeyCLSID, NULL, 0, &dwType, (LPBYTE)szTemp, &cbData) != ERROR_SUCCESS)
            goto error;

        // set the per-user default icon
        RegSetValueEx(hkeyUserCLSID, NULL, 0, dwType, (LPBYTE)szTemp, (lstrlen(szTemp) + 1) * sizeof(TCHAR));
        
        // get the local machine full icon
        cbData = sizeof(szTemp);
        if (RegQueryValueEx(hkeyCLSID, TEXT("Full"), 0, &dwType, (LPBYTE)szTemp, &cbData) != ERROR_SUCCESS)
            goto error;

        // set the per-user full icon
        RegSetValueEx(hkeyUserCLSID, TEXT("Full"), 0, dwType, (LPBYTE)szTemp, (lstrlen(szTemp) + 1) * sizeof(TCHAR));

        // get the local machine empty icon
        cbData = sizeof(szTemp);
        if (RegQueryValueEx(hkeyCLSID, TEXT("Empty"), 0, &dwType, (LPBYTE)szTemp, &cbData) != ERROR_SUCCESS)
            goto error;

        // set the per-user empty icon
        RegSetValueEx(hkeyUserCLSID, TEXT("Empty"), 0, dwType, (LPBYTE)szTemp, (lstrlen(szTemp) + 1) * sizeof(TCHAR));
    }

    // try the per user first, if we dont find it, then copy the information from HKCR\CLSID\etc...
    // to the per-user location
    cbData = sizeof(szTemp);
    if (RegQueryValueEx(hkeyUserCLSID, NULL, 0, &dwType, (LPBYTE)szTemp, &cbData) != ERROR_SUCCESS)
    {
        // get the local machine default icon
        cbData = sizeof(szTemp);
        if (RegQueryValueEx(hkeyCLSID, NULL, 0, &dwType, (LPBYTE)szTemp, &cbData) != ERROR_SUCCESS)
            goto error;

        // set the per-user default icon
        RegSetValueEx(hkeyUserCLSID, NULL, 0, dwType, (LPBYTE)szTemp, (lstrlen(szTemp) + 1) * sizeof(TCHAR));
    }
    lstrcpy(szValue, szTemp);

    cbData = sizeof(szTemp);
    if (RegQueryValueEx(hkeyUserCLSID, fFull ? TEXT("Full") : TEXT("Empty"), 0, &dwType, (LPBYTE)szTemp, &cbData) != ERROR_SUCCESS)
    {
        cbData = sizeof(szTemp);
        if (RegQueryValueEx(hkeyCLSID, fFull ? TEXT("Full") : TEXT("Empty"), 0, &dwType, (LPBYTE)szTemp, &cbData) != ERROR_SUCCESS)
            goto error;

        // set the per-user full/empty icon
        RegSetValueEx(hkeyUserCLSID, fFull ? TEXT("Full") : TEXT("Empty"), 0, dwType, (LPBYTE)szTemp, (lstrlen(szTemp) + 1) * sizeof(TCHAR));
    }
    lstrcpy(szNewValue, szTemp);

    if (lstrcmpi(szNewValue, szValue) != 0)
    {
        TCHAR szExpandedValue[MAX_PATH];
        LPTSTR szIconIndex;

        cbData = sizeof(szTemp);
        TW32(RegQueryValueEx(hkeyUserCLSID, fFull ? TEXT("Full") : TEXT("Empty"), 0, &dwType, (LPBYTE)szTemp, &cbData));
        // we always update the per user default icon, because recycle bins are per user on NTFS
        RegSetValueEx(hkeyUserCLSID, NULL, 0, dwType, (LPBYTE)szTemp, (lstrlen(szTemp) + 1) * sizeof(TCHAR));

        if (SHExpandEnvironmentStrings(szValue, szExpandedValue, ARRAYSIZE(szExpandedValue)))
        {
            szIconIndex = StrRChr(szExpandedValue, NULL, TEXT(','));

            if (szIconIndex)  
            {
                int id;
                int iNum = StrToInt(szIconIndex + 1);

                *szIconIndex = 0; // end szValue after the dll name

                // ..and tell anyone viewing this image index to update
                id = LookupIconIndex(szExpandedValue, iNum, 0);
                SHUpdateImage(szExpandedValue, iNum, 0, id);
                SHChangeNotifyHandleEvents();
            }
        }
    }

error:
    if (hkeyCLSID)
        RegCloseKey(hkeyCLSID);
    
    if (hkeyUserCLSID)
        RegCloseKey(hkeyUserCLSID);
}


//
// this loads the settings for this drive.  it obeys the "use global" bit
//
BOOL GetBBDriveSettings(int idDrive, ULONGLONG *pcbDiskSpace)
{
    TCHAR szDrive[MAX_PATH];
    TCHAR szName[MAX_PATH];
    TCHAR szVolume[MAX_PATH];
    TCHAR szPath[MAX_PATH];
    DWORD dwSizePath = ARRAYSIZE(szPath);
    ULARGE_INTEGER ulFreeUser, ulTotal, ulFree;
    DWORD dwSize1;
    DWORD dwSerialNumber, dwSerialNumberFromRegistry;
    LONG lInitialCount;
    BOOL bHaveCachedRegInfo = FALSE;
    BOOL bRet = TRUE;
    HKEY hkey;

    // Get volume root since we are going to call GetVolumeInformation()
    DriveIDToBBVolumeRoot(idDrive, szVolume);

    DriveIDToBBPath(idDrive, szDrive);
    GetBBInfo2FileSpec(szDrive, szName);

    if (idDrive == SERVERDRIVE)
    {
        // in the SERVERDRIVE case everything is under HKCU, so use the per-user key
        hkey = g_pBitBucket[idDrive]->hkeyPerUser;
    }
    else
    {
        hkey = g_pBitBucket[idDrive]->hkey;
    }

    // first we need to check to see we have cached registry info for this drive, or if this 
    // is a new drive
    dwSize1 = sizeof(dwSerialNumber);

    if (PathFileExists(szName)                                  &&
        (RegQueryValueEx(hkey,
                         TEXT("VolumeSerialNumber"),
                         NULL,
                         NULL,
                         (LPBYTE)&dwSerialNumberFromRegistry,
                         &dwSize1) == ERROR_SUCCESS)            &&
        GetVolumeInformation(szVolume,
                             NULL,
                             0,
                             &dwSerialNumber,
                             NULL,
                             NULL,
                             NULL,
                             0)                                 &&
        (dwSerialNumber == dwSerialNumberFromRegistry))
    {
        // we were able to read the drive serial number and it matched the regsitry, so
        // assume that the cached reg info is valid
        bHaveCachedRegInfo = TRUE;
    }
    
    // do some extra checks in the SERVERDRIVE case to make sure that the path matches in addition to the volume serial number.
    // (eg nethomedir could be on the same volume but a different path)
    if (bHaveCachedRegInfo && (SERVERDRIVE == idDrive))
    {
        if ((RegQueryValueEx(hkey, TEXT("Path"), NULL, NULL, (LPBYTE) szPath, &dwSizePath) != ERROR_SUCCESS) ||
            (lstrcmpi(szPath, szDrive) != 0))
        {
            // couldn't read the path or it didnt match, so no we can't use the cacehed info
            bHaveCachedRegInfo = FALSE;
        }
    }

 
    if (!bHaveCachedRegInfo)
    {
        TraceMsg(TF_BITBUCKET, "Bitbucket: new drive %s detected!!!", szDrive);
        // this is a new volume, so delete any old registry info we had
        DeleteOldBBRegInfo(idDrive);
        
        // And also migrate the win95 info if it exists
        // NOTE: this also fills in the g_pBitBucket[idDrive]->fIsUnicode
        VerifyBBInfoFileHeader(idDrive);
    }
    else
    {
        // set g_pBitBucket[idDrive]->fIsUnicode based on the registry info
        dwSize1 = sizeof(g_pBitBucket[idDrive]->fIsUnicode);
        if (RegQueryValueEx(hkey, TEXT("IsUnicode"), NULL, NULL, (LPBYTE)&g_pBitBucket[idDrive]->fIsUnicode, &dwSize1) != ERROR_SUCCESS)
        {
            TraceMsg(TF_BITBUCKET, "Bitbucket: IsUnicode missing from registry for drive %s !!", szDrive);
            
            // instead, try to get this out of the header
            VerifyBBInfoFileHeader(idDrive);
        }
    }

    // we need to check to make sure that the Recycle Bin folder is properly secured
    if (!CheckRecycleBinAcls(idDrive))
    {
        // we return false if this fails (meaning we detected an unsecure directory and were unable to 
        // fix it or the user didnt want to fix it). This will effectively disable all recycle bin operations
        // on this volume for this session.
        return FALSE;
    }

    // calculate the next file num index
    lInitialCount = FindInitialNextFileNum(idDrive);

    // create the hgcNextFileNume global counter
    ASSERT(lInitialCount >= 0);
    lstrcpy(szName, TEXT("BitBucket.")); 
    DriveIDToBBRegKey(idDrive, &szName[10]);
    lstrcpy(&szName[11], TEXT(".NextFileNum"));
    g_pBitBucket[idDrive]->hgcNextFileNum = SHGlobalCounterCreateNamed(szName, lInitialCount); // BitBucket.<drive letter>.NextFileNum

    if (g_pBitBucket[idDrive]->hgcNextFileNum == INVALID_HANDLE_VALUE)
    {
        ASSERTMSG(FALSE, "BitBucket: failed to create hgcNextFileNum for drive %s !!", szDrive);
        return FALSE;
    }

    // we call SHGetDiskFreeSpaceEx so we can respect quotas on NTFS
    DriveIDToBBRoot(idDrive, szDrive);
    if (SHGetDiskFreeSpaceEx(szDrive, &ulFreeUser, &ulTotal, &ulFree))
    {
        g_pBitBucket[idDrive]->dwClusterSize = PathGetClusterSize(szDrive);
        g_pBitBucket[idDrive]->qwDiskSize = ulTotal.QuadPart;
    }
    else
    {
        if (idDrive == SERVERDRIVE)
        {
            g_pBitBucket[idDrive]->dwClusterSize = 2048;
            g_pBitBucket[idDrive]->qwDiskSize = 0x7FFFFFFF;
        }
        else
        {
            ASSERTMSG(FALSE, "Bitbucket: SHGetDiskFreeSpaceEx failed on %s !!", szDrive);
            
            g_pBitBucket[idDrive]->dwClusterSize = 0;
            g_pBitBucket[idDrive]->qwDiskSize = 0;
        }
    }

    if (pcbDiskSpace)
    {
        *pcbDiskSpace = g_pBitBucket[idDrive]->qwDiskSize;
    }

    // Read the Percent and NukeOnDelete settings, and recalculate cbMaxSize.
    RefreshBBDriveSettings(idDrive);

    TraceMsg(TF_BITBUCKET,
             "GetBBDriveSettings: Drive %s, fIsUnicode=%d, iPercent=%d, cbMaxSize=%d, fNukeOnDelete=%d, NextFileNum=%d",
             szDrive,
             g_pBitBucket[idDrive]->fIsUnicode,
             g_pBitBucket[idDrive]->iPercent,
             g_pBitBucket[idDrive]->cbMaxSize,
             g_pBitBucket[idDrive]->fNukeOnDelete,
             SHGlobalCounterGetValue(g_pBitBucket[idDrive]->hgcNextFileNum));

    return TRUE;
}


//
// cleans up old iPercent and fNukeOnDelete registry keys when we dectect a new drive
//
void DeleteOldBBRegInfo(idDrive)
{
    RegDeleteValue(g_pBitBucket[idDrive]->hkey, TEXT("Percent"));
    RegDeleteValue(g_pBitBucket[idDrive]->hkey, TEXT("NukeOnDelete"));
    RegDeleteValue(g_pBitBucket[idDrive]->hkey, TEXT("IsUnicode"));
}


//
// This gets called when explorer exits to persist the volume serial # and
// whether the drive is unicode for the specified drive.
//
void PersistBBDriveInfo(int idDrive)
{
    TCHAR szVolume[MAX_PATH];
    DWORD dwSerialNumber;
    HKEY hkey;

    if (SERVERDRIVE == idDrive)
    {
        TCHAR szPath[MAX_PATH];

        // in the SERVERDRIVE case everything is under HKCU, so use the per-user key
        hkey = g_pBitBucket[idDrive]->hkeyPerUser;

        DriveIDToBBPath(idDrive, szPath);
        RegSetValueEx(hkey, TEXT("Path"), 0, REG_SZ, (LPBYTE) szPath, sizeof(TCHAR) * (lstrlen(szPath) + 1));
    }
    else
    {
        hkey = g_pBitBucket[idDrive]->hkey;
    }

    DriveIDToBBVolumeRoot(idDrive, szVolume);

    // write out the volume serial # so we can detect when a new drive comes along and give it the default settings
    // NOTE: we will fail to write out the volume serial # if we are a normal user and HKLM is locked down. Oh well.
    if (GetVolumeInformation(szVolume, NULL, 0, &dwSerialNumber, NULL, NULL, NULL, 0))
    {
        RegSetValueEx(hkey, TEXT("VolumeSerialNumber"), 0, REG_DWORD, (LPBYTE)&dwSerialNumber, sizeof(dwSerialNumber));
    }

    // save off fIsUnicode as well
    RegSetValueEx(hkey, TEXT("IsUnicode"), 0, REG_DWORD, (LPBYTE)&g_pBitBucket[idDrive]->fIsUnicode, sizeof(g_pBitBucket[idDrive]->fIsUnicode));
}


//
// This is what gets called when the user tweaks the drive settings for all the drives (the global settings)
//
BOOL PersistGlobalSettings(BOOL fUseGlobalSettings, BOOL fNukeOnDelete, int iPercent)
{
    ASSERT(g_hkBitBucket);

    if (RegSetValueEx(g_hkBitBucket, TEXT("Percent"), 0, REG_DWORD, (LPBYTE)&iPercent, sizeof(iPercent)) != ERROR_SUCCESS ||
        RegSetValueEx(g_hkBitBucket, TEXT("NukeOnDelete"), 0, REG_DWORD, (LPBYTE)&fNukeOnDelete, sizeof(fNukeOnDelete)) != ERROR_SUCCESS ||
        RegSetValueEx(g_hkBitBucket, TEXT("UseGlobalSettings"), 0, REG_DWORD, (LPBYTE)&fUseGlobalSettings, sizeof(fUseGlobalSettings)) != ERROR_SUCCESS)        
    {
         TraceMsg(TF_BITBUCKET, "Bitbucket: failed to update global bitbucket data in the registry!!");
         return FALSE;
    }

    // since we just updated the global drive settings, we need to increment the dirty count and set our own
    g_lProcessDirtyCount = SHGlobalCounterIncrement(g_hgcGlobalDirtyCount);

    return TRUE;
}

//
// This is what gets called when the user tweaks the drive settings for a drive via the
// Recycle Bin property sheet page. The only thing we care about is the % slider and the
// "Do not move files to the recycle bin" settings.
// 
BOOL PersistBBDriveSettings(int idDrive, int iPercent, BOOL fNukeOnDelete)
{
    if (RegSetValueEx(g_pBitBucket[idDrive]->hkey, TEXT("Percent"), 0, REG_DWORD, (LPBYTE)&iPercent, sizeof(iPercent)) != ERROR_SUCCESS ||
        RegSetValueEx(g_pBitBucket[idDrive]->hkey, TEXT("NukeOnDelete"), 0, REG_DWORD, (LPBYTE)&fNukeOnDelete, sizeof(fNukeOnDelete)) != ERROR_SUCCESS)
    {
        TraceMsg(TF_BITBUCKET, "Bitbucket: unable to persist drive settings for drive %d", idDrive);
        return FALSE;
    }

    // since we just updated the drive settings, we need to increment the dirty count for this drive
    g_pBitBucket[idDrive]->lCurrentDirtyCount = SHGlobalCounterIncrement(g_pBitBucket[idDrive]->hgcDirtyCount);

    return TRUE;
}


//
// walks the multi-string pszSrc and sets up the undo info
//
void BBCheckRestoredFiles(LPCTSTR pszSrc)
{
    if (pszSrc && IsFileInBitBucket(pszSrc)) 
    {
        LPCTSTR pszTemp = pszSrc;

        while (*pszTemp) 
        {
            FOUndo_FileRestored(pszTemp);
            pszTemp += (lstrlen(pszTemp) + 1);
        }

        SHUpdateRecycleBinIcon();
    }
}


//
// This is the quick and efficent way to tell if the Recycle Bin is empty or not
//
STDAPI_(BOOL) IsRecycleBinEmpty()
{
    int i;
    
    for (i = 0; i < MAX_BITBUCKETS; i++) 
    {
        if (CountDeletedFilesOnDrive(i, NULL, 1))
            return FALSE;
    }

    return TRUE;
}


//
// Finds out how many files are deleted on this drive, and optionally the total size of those files.
// Also, stop counting if the total # of files equals iMaxFiles.
//
// NOTE: if you pass iMaxFiles = 0, then we ignore the parameter and count up all the files/sizes
// 
int CountDeletedFilesOnDrive(int idDrive, LPDWORD pdwSize, int iMaxFiles)
{
    int cFiles = 0;
    HANDLE hFile;
    WIN32_FIND_DATA wfd;
    TCHAR szBBPath[MAX_PATH];
    TCHAR szBBFileSpec[MAX_PATH];

    if (pdwSize)
        *pdwSize = 0;
    
    if (!IsBitBucketableDrive(idDrive))
        return 0;

    DriveIDToBBPath(idDrive, szBBPath);
    PathCombine(szBBFileSpec, szBBPath, TEXT("D*.*"));

    hFile = FindFirstFile(szBBFileSpec, &wfd);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        return 0;
    }

    do
    {
        if (PathIsDotOrDotDot(wfd.cFileName) || lstrcmpi(wfd.cFileName, c_szDesktopIni) == 0)
        {
            continue;
        }

        cFiles++;

        if (pdwSize)
        {
            if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                FOLDERCONTENTSINFO fci = {0};
                TCHAR szDir[MAX_PATH];
                fci.bContinue = TRUE;

                // PERF (reinerf) - for perf we should try to avoid
                // calling FolderSize here. Perhaps we could encode the size
                // as part of the extension?
                lstrcpyn(szDir, szBBPath, ARRAYSIZE(szDir));
                PathAppend(szDir, wfd.cFileName);
                FolderSize(szDir, &fci);
                *pdwSize += (DWORD)(fci.cbSize);
            }
            else
            {
                // simple file case
                *pdwSize += wfd.nFileSizeLow;
            }
        }

        if (iMaxFiles > 0 && cFiles >= iMaxFiles)
            break;

    } while (FindNextFile(hFile, &wfd));

    FindClose(hFile);

    return cFiles;
}


//
// Returns the number of files in the Recycle Bin, and optionally the drive id
// if there's only one file, and optionally the total size of all the stuff.
//
// We also stop counting if iMaxFiles is nonzero and we find that many
// files. This helps perf by having a cutoff point where we use a generic error
// message instead of the exact # of files. If iMaxFiles is zero, we give the true
// count of files.
//
// NOTE: don't use this if you just want to check to see if the recycle bin is 
// empty or full!! Use IsRecycleBinEmpty() instead
//
int BBTotalCount(LPINT pidDrive, LPDWORD pdwSize, int iMaxFiles)
{
    int i;
    int idDrive;
    int nFiles = 0;
    DWORD dwSize;

    if (pdwSize)
        *pdwSize = 0;

    for (i = 0; i < MAX_BITBUCKETS; i++) 
    {
        int nFilesOld = nFiles;

        nFiles += CountDeletedFilesOnDrive(i, pdwSize ? &dwSize : NULL, iMaxFiles > 0 ? iMaxFiles - nFilesOld : 0);
     
        if (pdwSize)
            *pdwSize += dwSize;
        
        if (nFilesOld == 0 && nFiles == 1)
        {
            // if just one file, set the drive id
            idDrive = i;
        }

        if (iMaxFiles > 0 && nFiles >= iMaxFiles)
            break;
    }

    if (pidDrive)
        *pidDrive = (nFiles == 1) ? idDrive : 0;

    return nFiles;
}


//
// gets the number of files and and size of the bitbucket for the given drive
//
SHSTDAPI SHQueryRecycleBin(LPCTSTR pszRootPath, LPSHQUERYRBINFO pSHQueryInfo)
{
    DWORD dwSize = 0;
    DWORD dwNumItems = 0;

    // since this fn is exported, we need to check to see if we need to 
    // init our global data first
    if (!InitBBGlobals())
    {
        return E_OUTOFMEMORY;
    }

    if (!pSHQueryInfo  ||
        (pSHQueryInfo->cbSize < sizeof(SHQUERYRBINFO)))
    {
        return E_INVALIDARG;
    }

    if (pszRootPath && pszRootPath[0] != TEXT('\0'))
    {
        int idDrive = DriveIDFromBBPath(pszRootPath);
        if (MakeBitBucket(idDrive))
        {
            dwNumItems = CountDeletedFilesOnDrive(idDrive, &dwSize, 0);
        }
    }
    else
    {
        //
        // NTRAID#NTBUG9-146905-2001/03/15-jeffreys
        //
        // This is a public API, documented to return the totals for all
        // recycle bins when no path is given. This was broken in Windows
        // 2000 and Millennium.
        //
        dwNumItems = BBTotalCount(NULL, &dwSize, 0);
    }

    pSHQueryInfo->i64Size = (__int64)dwSize;
    pSHQueryInfo->i64NumItems = (__int64)dwNumItems;

    return S_OK;
}

SHSTDAPI SHQueryRecycleBinA(LPCSTR pszRootPath, LPSHQUERYRBINFO pSHQueryRBInfo)
{
    WCHAR wszPath[MAX_PATH];

    SHAnsiToUnicode(pszRootPath, wszPath, ARRAYSIZE(wszPath));
    return SHQueryRecycleBin(wszPath, pSHQueryRBInfo);
}

//
// Empty the given drive or all drives
//
SHSTDAPI SHEmptyRecycleBin(HWND hWnd, LPCTSTR pszRootPath, DWORD dwFlags)
{
    // since this fn is exported, we need to check to see if we need to 
    // init our global data first
    if (!InitBBGlobals())
    {
        // this could happen in low memory situations, we have no choice but
        // to abort the empty
        return E_OUTOFMEMORY;
    }

    if ((pszRootPath == NULL) || (*pszRootPath == 0))
    {
        BBPurgeAll(hWnd, dwFlags);
    }
    else
    {
        int idDrive = DriveIDFromBBPath(pszRootPath);

        // note: we include MAX_DRIVES(26) which is SERVERDRIVE case!
        if ((idDrive < 0) || (idDrive > MAX_DRIVES))
        {
            return E_INVALIDARG;
        }

        if (MakeBitBucket(idDrive))
        {
            PurgeOneBitBucket(hWnd, idDrive, dwFlags);
        }
    }

    return S_OK;
}

SHSTDAPI SHEmptyRecycleBinA(HWND hWnd, LPCSTR pszRootPath, DWORD dwFlags)
{
    WCHAR wszPath[MAX_PATH];

    SHAnsiToUnicode(pszRootPath, wszPath, ARRAYSIZE(wszPath));
    return SHEmptyRecycleBin(hWnd, wszPath, dwFlags);
}

void MarkBBPurgeAllTime(BOOL bStart)
{
    TCHAR szText[64];
    
    if (g_dwStopWatchMode == 0xffffffff)
        g_dwStopWatchMode = StopWatchMode();    // Since the stopwatch funcs live in shdocvw, delay this call so we don't load shdocvw until we need to

    if (g_dwStopWatchMode)
    {
        lstrcpy((LPTSTR)szText, TEXT("Shell Empty Recycle"));
        if (bStart)
        {
            lstrcat((LPTSTR)szText, TEXT(": Start"));
            StopWatch_Start(SWID_BITBUCKET, (LPCTSTR)szText, SPMODE_SHELL | SPMODE_DEBUGOUT);
        }
        else
        {
            lstrcat((LPTSTR)szText, TEXT(": Stop"));
            StopWatch_Stop(SWID_BITBUCKET, (LPCTSTR)szText, SPMODE_SHELL | SPMODE_DEBUGOUT);
        }
    }
}

HRESULT BBPurgeAll(HWND hwndOwner, DWORD dwFlags)
{
    TCHAR szPath[MAX_PATH * 2 + 3]; // null space and double null termination
    int nFiles;
    int idDrive;
    BOOL fConfirmed;
    SHFILEOPSTRUCT sFileOp ={hwndOwner,
                             FO_DELETE,
                             szPath,
                             NULL,
                             FOF_NOCONFIRMATION | FOF_SIMPLEPROGRESS,
                             FALSE,
                             NULL,
                             MAKEINTRESOURCE(IDS_BB_EMPTYINGWASTEBASKET)};

    // check to see if we need to init our global data first
    if (!InitBBGlobals())
    {
        // this could happen in low memory situations, we have no choice but
        // to fail the empty
        return E_OUTOFMEMORY;
    }

    if (g_dwStopWatchMode)   // If the shell perf mode is enabled, time the empty operation
    {
        MarkBBPurgeAllTime(TRUE);
    }

    fConfirmed = (dwFlags & SHERB_NOCONFIRMATION);

    if (!fConfirmed) 
    {
        // find out how many files we have...
        BBDATAENTRYW bbdew;
        TCHAR szSrcName[MAX_PATH];

        WIN32_FIND_DATA fd;
        CONFIRM_DATA cd = {CONFIRM_DELETE_FILE | CONFIRM_DELETE_FOLDER | CONFIRM_PROGRAM_FILE | CONFIRM_MULTIPLE, 0};

        nFiles = BBTotalCount(&idDrive, NULL, MAX_EMPTY_FILES);
        if (!nFiles)
        {
            if (g_dwStopWatchMode)
            {
                MarkBBPurgeAllTime(FALSE);
            }
            return S_FALSE;   // no files to delete
        }

        // first do the confirmation thing
        fd.dwFileAttributes = FILE_ATTRIBUTE_NORMAL;

        // We have to call IsBitBucketInited() here since we could be in BBPurgeAll as a result
        // of a corrupt bitbucket. In this case, the g_pBitBucket[idDrive] has not been inited and
        // therefore we can't use it yet
        if (nFiles == 1 && IsBitBucketInited(idDrive)) 
        {
            HANDLE hFile = OpenBBInfoFile(idDrive, OPENBBINFO_READ, 0);
            if (hFile != INVALID_HANDLE_VALUE)
            {
                ReadNextDataEntry(hFile, &bbdew, TRUE, idDrive);
                CloseBBInfoFile(hFile, idDrive);
                StrCpyNW(szSrcName, bbdew.szOriginal, ARRAYSIZE(szSrcName));
            }
            else
            {
                if (g_dwStopWatchMode)
                {
                    MarkBBPurgeAllTime(FALSE);
                }
                return S_FALSE; // no files to delete
            }
        }
        else
        {
            // If we haven't inited this bucket yet or there are MAX_EMPTY_FILES or more files,
            // then use the generic empty message
            if (nFiles == 1 || nFiles >= MAX_EMPTY_FILES)
            {
                // counting up the total # of files in the bitbucket scales as
                // the # of files (duh!). This can get pretty expensive, so if there
                // are MAX_EMPTY_FILES or more files in the bin, we just give a generic
                // error message
                
                // set this so ConfirmFileOp knows to use the generic message
                nFiles = -1;
            }
            
            szSrcName[0] = 0;
        }
        
        if (ConfirmFileOp(hwndOwner, NULL, &cd, nFiles, 0, CONFIRM_DELETE_FILE | CONFIRM_WASTEBASKET_PURGE, 
            szSrcName, &fd, NULL, &fd, NULL) == IDYES)
        {
            fConfirmed = TRUE;
        }
    }

    if (fConfirmed)
    {
        DECLAREWAITCURSOR;
        SetWaitCursor();
        
        if (dwFlags & SHERB_NOPROGRESSUI)
        {
            sFileOp.fFlags |= FOF_SILENT;
        }

        for (idDrive = 0; (idDrive < MAX_BITBUCKETS) && !sFileOp.fAnyOperationsAborted; idDrive++)
        {
            if (MakeBitBucket(idDrive))
            {
                HANDLE hFile;
                
                // nuke all the BB files (d*.*)
                DriveIDToBBPath(idDrive, szPath);
                PathAppend(szPath, c_szDStarDotStar);
                szPath[lstrlen(szPath) + 1] = 0; // double null terminate

                // turn off redraw for now.
                ShellFolderView_SetRedraw(hwndOwner, FALSE);

                hFile = OpenBBInfoFile(idDrive, OPENBBINFO_WRITE, 0);

                if (INVALID_HANDLE_VALUE != hFile)
                {
                    // now do the actual delete.
                    if (SHFileOperation(&sFileOp) || sFileOp.fAnyOperationsAborted) 
                    {
                        TraceMsg(TF_BITBUCKET, "Bitbucket: emptying bucket on %s failed or user aborted", szPath);

                        // NOTE: the info file may point to some files that have been deleted,
                        // it will be cleaned up later
                    }
                    else
                    {
                        // reset the info file since we deleted it as part of the empty operation
                        ResetInfoFileHeader(hFile, g_pBitBucket[idDrive]->fIsUnicode);
                    }

                    // we always reset the desktop.ini
                    CreateRecyclerDirectory(idDrive);

                    CloseBBInfoFile(hFile, idDrive);
                }

                ShellFolderView_SetRedraw(hwndOwner, TRUE);
            }
        }

        if (!(dwFlags & SHERB_NOSOUND))
        {
            SHPlaySound(TEXT("EmptyRecycleBin"));
        }

        SHUpdateRecycleBinIcon();
        ResetWaitCursor();
    }
    
    if (g_dwStopWatchMode)
    {
        MarkBBPurgeAllTime(FALSE);
    }

    return S_OK;
}


BOOL BBNukeFile(LPCTSTR pszPath, DWORD dwAttribs)
{
    if (Win32DeleteFile(pszPath))
    {
        FOUndo_FileReallyDeleted((LPTSTR)pszPath);
        return TRUE;
    }

    return FALSE;
}


BOOL BBNukeFolder(LPCTSTR pszDir)
{
    TCHAR szPath[MAX_PATH];
    BOOL fRet;

    if (PathCombine(szPath, pszDir, c_szStarDotStar))
    {
        WIN32_FIND_DATA fd;
        HANDLE hfind = FindFirstFile(szPath, &fd);
        if (hfind != INVALID_HANDLE_VALUE)
        {
            do
            {
                LPTSTR pszFile = fd.cAlternateFileName[0] ? fd.cAlternateFileName : fd.cFileName;

                if (pszFile[0] != TEXT('.'))
                {
                    // use the short path name so that we
                    // don't have to worry about max path
                    PathCombine(szPath, pszDir, pszFile);

                    if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    {
                        // even if this fails, we keep going.
                        // we want to delete as much as possible
                        BBNukeFolder(szPath);
                    }
                    else
                    {
                        BBNukeFile(szPath, fd.dwFileAttributes);
                    }
                }
            } while (FindNextFile(hfind, &fd));

            FindClose(hfind);
        }
    }
    
    fRet = Win32RemoveDirectory(pszDir);
    
    // if everything was successful, we need to notify any undo stuff about this
    if (fRet)
    {
        FOUndo_FileReallyDeleted((LPTSTR)szPath);
    }

    return fRet;
}


BOOL BBNuke(LPCTSTR pszPath)
{
    BOOL fRet = FALSE;
    // verify that the file exists
    DWORD dwAttribs = GetFileAttributes(pszPath);

    TraceMsg(TF_BITBUCKET, "Bitbucket: BBNuke called on %s ", pszPath);
    
    if (dwAttribs != (UINT)-1)
    {
        // this was a directory, we need to recurse in and delete everything inside
        if (dwAttribs & FILE_ATTRIBUTE_DIRECTORY)
        {
            fRet = BBNukeFolder(pszPath);
        }
        else
        {
            fRet = BBNukeFile(pszPath, dwAttribs);
        }
    }

    return fRet;
}

DWORD PurgeBBFiles(int idDrive)
{
    DWORD dwCurrentSize;

    CountDeletedFilesOnDrive(idDrive, &dwCurrentSize, 0);

    if (dwCurrentSize > g_pBitBucket[idDrive]->cbMaxSize)
    {
        DWORD dwDataEntrySize = g_pBitBucket[idDrive]->fIsUnicode ? sizeof(BBDATAENTRYW) : sizeof(BBDATAENTRYA);
        HANDLE hFile = OpenBBInfoFile(idDrive, OPENBBINFO_WRITE, 0);
        if (hFile != INVALID_HANDLE_VALUE)
        {
            BBDATAENTRYW bbdew;
            TCHAR szBBPath[MAX_PATH];
            DriveIDToBBPath(idDrive, szBBPath);

            // while we're too big, find something to delete
            while (dwCurrentSize > g_pBitBucket[idDrive]->cbMaxSize && ReadNextDataEntry(hFile, &bbdew, TRUE, idDrive))
            {
                TCHAR szPath[MAX_PATH], szDeletedFile[MAX_PATH];

                GetDeletedFileName(szDeletedFile, &bbdew);
                PathCombine(szPath, szBBPath, szDeletedFile);

                BBNuke(szPath);
                NukeFileInfoBeforePoint(hFile, &bbdew, dwDataEntrySize);

                // subtract the size of what we just nuked
                dwCurrentSize -= bbdew.dwSize;

                TraceMsg(TF_BITBUCKET, "Bitbucket: purging drive %d, curent size = %d, max size = %d", idDrive, dwCurrentSize, g_pBitBucket[idDrive]->cbMaxSize);
            }

            CloseBBInfoFile(hFile, idDrive);
        }
    }

    return dwCurrentSize;
}

STDAPI BBFileNameToInfo(LPCTSTR pszFileName, int *pidDrive, int *piIndex)
{
    HRESULT hr = E_FAIL;

    if (lstrcmpi(pszFileName, c_szInfo)         &&
        lstrcmpi(pszFileName, c_szInfo2)        &&
        lstrcmpi(pszFileName, c_szDesktopIni)   &&
        lstrcmpi(pszFileName, TEXT("Recycled")) &&
        (StrChr(pszFileName, TEXT('\\')) == NULL))   // recycle bin dosen't support multi-level paths
    {
        if ((pszFileName[0] == TEXT('D')) || (pszFileName[0] == TEXT('d')))
        {
            if (pszFileName[1])
            {
                if (pidDrive)
                {
                    hr = S_OK;

                    if (pszFileName[1] == TEXT('@'))
                        *pidDrive = SERVERDRIVE;
                    else if (InRange(pszFileName[1], TEXT('a'), TEXT('z')))
                        *pidDrive = pszFileName[1] - TEXT('a');
                    else if (InRange(pszFileName[1], TEXT('A'), TEXT('Z')))
                        *pidDrive = pszFileName[1] - TEXT('A');
                    else
                        hr = E_FAIL;
                }

                if (piIndex)
                {
                    // this depends on StrToInt stoping is parsing when it hits the file extension
                    *piIndex = StrToInt(&pszFileName[2]);
                    hr = S_OK;
                }
            }
        }
    }

    return hr;
}

// converts C:\RECYCLED\Dc19.foo to 19
int BBPathToIndex(LPCTSTR pszPath)
{
    int iIndex;
    LPTSTR pszFileName = PathFindFileName(pszPath);

    if (SUCCEEDED(BBFileNameToInfo(pszFileName, NULL, &iIndex)))
    {
        return iIndex;
    }

    return -1;
}

BOOL ReadNextDataEntry(HANDLE hFile, LPBBDATAENTRYW pbbdew, BOOL fSkipDeleted, int idDrive)
{
    DWORD dwBytesRead;
    DWORD dwDataEntrySize = g_pBitBucket[idDrive]->fIsUnicode ? sizeof(BBDATAENTRYW) : sizeof(BBDATAENTRYA);

    ZeroMemory(pbbdew, sizeof(*pbbdew));

TryAgain:
    if (ReadFile(hFile, pbbdew, dwDataEntrySize, &dwBytesRead, NULL) && 
        (dwBytesRead == dwDataEntrySize))
    {
        TCHAR szDeleteFileName[MAX_PATH], szOldPath[MAX_PATH];

        if (fSkipDeleted && IsDeletedEntry(pbbdew))
        {
            goto TryAgain;
        }

        // for ansi entries fill out the unicode version of the original
        if (!g_pBitBucket[idDrive]->fIsUnicode)
        {
            BBDATAENTRYA *pbbdea = (BBDATAENTRYA *)pbbdew;
            SHAnsiToUnicode(pbbdea->szOriginal, pbbdew->szOriginal, ARRAYSIZE(pbbdew->szOriginal));
        }

        // We check for a drive that has had its letter changed since this record was added.
        // In this case, we want to restore the files that were deleted on this volume to this volume.
        if (pbbdew->idDrive != idDrive)
        {
            TCHAR szNewPath[MAX_PATH];

            DriveIDToBBPath(idDrive, szOldPath);
            lstrcpyn(szNewPath, szOldPath, ARRAYSIZE(szNewPath));

            GetDeletedFileName(szDeleteFileName, pbbdew);
            PathAppend(szOldPath, szDeleteFileName);

            GetDeletedFileNameFromParts(szDeleteFileName, idDrive, pbbdew->iIndex, pbbdew->szOriginal);
            PathAppend(szNewPath, szDeleteFileName);

            TraceMsg(TF_BITBUCKET, "Bitbucket: found entry %s corospoinding to old drive letter, whacking it to be on drive %d !!", szOldPath, idDrive);

            // we need to rename the file from d?0.txt to d<idDrive>0.txt
            if (!Win32MoveFile(szOldPath, szNewPath, GetFileAttributes(szOldPath) & FILE_ATTRIBUTE_DIRECTORY))
            {
                TraceMsg(TF_BITBUCKET, "Bitbucket: failed to rename %s to %s, getlasterror = %d", szOldPath, szNewPath, GetLastError());
                goto DeleteEntry;
            }

            // whack the rest of the information about this entry to match the new drive ID
            pbbdew->idDrive = idDrive;
            pbbdew->szShortName[0] = 'A' + (CHAR)idDrive;
            if (g_pBitBucket[idDrive]->fIsUnicode)
            {
                // for unicode volumes we need to whack the first letter of the long name as well
                pbbdew->szOriginal[0] = L'A' + (WCHAR)idDrive;
            }
        }
        else
        {
            // Starting with NT5, when we delete or restore items, we dont bother updating the info file.
            // So we need to make sure that the entry we have has not been restored or really nuked.
            GetDeletedFilePath(szOldPath, pbbdew);

            if (!PathFileExists(szOldPath))
            {
DeleteEntry:
                // this entry is really deleted, so mark it as such now
                NukeFileInfoBeforePoint(hFile, pbbdew, dwDataEntrySize);
        
                if (fSkipDeleted)
                {
                    goto TryAgain;
                }
            }
        }
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//
// the file pointer is RIGHT AFTER the entry that we want to delete.
//
// back the file pointer up one record and mark it deleted
//
void NukeFileInfoBeforePoint(HANDLE hFile, LPBBDATAENTRYW pbbdew, DWORD dwDataEntrySize)
{
    DWORD dwBytesWritten;
    LONG lPos = SetFilePointer(hFile, 0, NULL, FILE_CURRENT);

    ASSERT((DWORD)lPos >= dwDataEntrySize + sizeof(BBDATAHEADER));
    
    if ((DWORD)lPos >= dwDataEntrySize + sizeof(BBDATAHEADER))
    {
        // found the entry.. back up the file pointer to the beginning
        // of this record and mark it as deleted
        lPos -= dwDataEntrySize;
        SetFilePointer(hFile, lPos, NULL, FILE_BEGIN);
        
        MarkEntryDeleted(pbbdew);
        
        if (WriteFile(hFile, pbbdew, dwDataEntrySize, &dwBytesWritten, NULL))
        {
            ASSERT(dwDataEntrySize == dwBytesWritten);
        }
        else
        {
            TraceMsg(TF_BITBUCKET, "Bitbucket: couldn't nuke file info");
            // move the file pointer back to where it was when we entered this function
            SetFilePointer(hFile, lPos + dwDataEntrySize, NULL, FILE_BEGIN);
        }
    }
}


//
// This closes the hFile and sends out an SHCNE_UPDATEITEM for the info file on
// drive idDrive
//
void CloseBBInfoFile(HANDLE hFile, int idDrive)
{
    TCHAR szInfoFile[MAX_PATH];

    ASSERT(hFile != INVALID_HANDLE_VALUE);

    DriveIDToBBPath(idDrive, szInfoFile);
    PathAppend(szInfoFile, c_szInfo2);

    CloseHandle(hFile);

    SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, szInfoFile, NULL);
}

// One half second (500 ms = 0.5 s)
#define BBINFO_OPEN_RETRY_PERIOD        500
// Retry 30 times (at least 20 s)
#define BBINFO_OPEN_MAX_RETRIES         40

//
// This opens up a handle to the bitbucket info file.
// 
// NOTE: use CloseBBInfoFile so that we generate the proper 
//       SHChangeNotify event for the info file.
//
HANDLE OpenBBInfoFile(int idDrive, DWORD dwFlags, int iRetryCount)
{
    HANDLE hFile;
    TCHAR szBBPath[MAX_PATH];
    TCHAR szInfo[MAX_PATH];
    int nAttempts = 0;
    DWORD dwLastErr;
    DECLAREWAITCURSOR;

    if ((iRetryCount == 0) || (iRetryCount > BBINFO_OPEN_MAX_RETRIES))
    {
        // zero retry count means that the caller wants the max # of retries
        iRetryCount = BBINFO_OPEN_MAX_RETRIES;
    }

    DriveIDToBBPath(idDrive, szBBPath);
    GetBBInfo2FileSpec(szBBPath, szInfo);
    // If we are hitting a sharing violation, retry many times
    do
    {
        nAttempts++;
        hFile = CreateFile(szInfo,
                           GENERIC_READ | ((OPENBBINFO_WRITE & dwFlags) ? GENERIC_WRITE : 0),
                           (OPENBBINFO_WRITE & dwFlags) ? 0 : FILE_SHARE_READ,
                           NULL,
                           (OPENBBINFO_CREATE & dwFlags) ? OPEN_ALWAYS : OPEN_EXISTING,
                           FILE_ATTRIBUTE_HIDDEN | FILE_FLAG_RANDOM_ACCESS,
                           NULL);
        if (INVALID_HANDLE_VALUE != hFile)
        {
            // success!
            break;
        }

        dwLastErr = GetLastError();
        if (ERROR_SHARING_VIOLATION != dwLastErr)
        {
            break;
        }

        TraceMsg(TF_BITBUCKET, "Bitbucket: sharing violation on info file (retry %d)", nAttempts - 1);

        if (nAttempts < iRetryCount)
        {
            SetWaitCursor();
            Sleep(BBINFO_OPEN_RETRY_PERIOD);
            ResetWaitCursor();
        }

    } while (nAttempts < iRetryCount);
    
    if (hFile == INVALID_HANDLE_VALUE)
    {
        TraceMsg(TF_BITBUCKET, "Bitbucket: could not open a handle to %s - error 0x%08x!!", szInfo, dwLastErr);
        return INVALID_HANDLE_VALUE;
    }

    // set the file pointer to just after the dataheader
    SetFilePointer(hFile, sizeof(BBDATAHEADER), NULL, FILE_BEGIN);

    return hFile;
}

void BBAddDeletedFileInfo(LPCTSTR pszOriginal, LPCTSTR pszShortName, int iIndex, int idDrive, DWORD dwSize, HDPA *phdpaDeletedFiles)
{
    BBDATAENTRYW *pbbdew;
    BOOL fSuccess = FALSE; // assume failure

    // Flush the cache regularly
    if (*phdpaDeletedFiles && DPA_GetPtrCount(*phdpaDeletedFiles) >= 1)
    {
        pbbdew = (BBDATAENTRYW *)DPA_FastGetPtr(*phdpaDeletedFiles, 0);
        
        // Flush the cache before we start deleting files on a different drive, or
        // when it's too full
        if (pbbdew->idDrive != idDrive || DPA_GetPtrCount(*phdpaDeletedFiles) >= 128)
        {
            BBFinishDelete(*phdpaDeletedFiles);
            *phdpaDeletedFiles = NULL;
        }
    }

    pbbdew = NULL;

    if (!*phdpaDeletedFiles)
    {
        *phdpaDeletedFiles = DPA_Create(0); // Use default growth value
    }

    if (*phdpaDeletedFiles)
    {
        pbbdew = (BBDATAENTRYW *)LocalAlloc(LPTR, sizeof(*pbbdew));
        if (pbbdew)
        {
            SYSTEMTIME st;

            if (g_pBitBucket[idDrive]->fIsUnicode)
            {
                // Create a BBDATAENTRYW from a unicode name
                lstrcpy(pbbdew->szOriginal, pszOriginal);
        
                if (!DoesStringRoundTrip(pszOriginal, pbbdew->szShortName, ARRAYSIZE(pbbdew->szShortName)))
                    SHUnicodeToAnsi(pszShortName, pbbdew->szShortName, ARRAYSIZE(pbbdew->szShortName));
            }
            else
            {
                BBDATAENTRYA *pbbdea = (BBDATAENTRYA *)pbbdew;
                // Create a BBDATAENTRYA from a unicode name
                if (!DoesStringRoundTrip(pszOriginal, pbbdea->szOriginal, ARRAYSIZE(pbbdea->szOriginal)))
                    SHUnicodeToAnsi(pszShortName, pbbdea->szOriginal, ARRAYSIZE(pbbdea->szOriginal));
            }

            pbbdew->iIndex = iIndex;
            pbbdew->idDrive = idDrive;
            pbbdew->dwSize = ROUND_TO_CLUSTER(dwSize, g_pBitBucket[idDrive]->dwClusterSize);

            GetSystemTime(&st);             // Get time of deletion
            SystemTimeToFileTime(&st, &pbbdew->ft);

            if (DPA_AppendPtr(*phdpaDeletedFiles, pbbdew) != -1)
            {
                fSuccess = TRUE;
            }
        }
    }

    if (!fSuccess)
    {
        TCHAR szBBPath[MAX_PATH];
        TCHAR szFileName[MAX_PATH];
        
        ASSERTMSG(FALSE, "BitBucket: failed to record deleted file %s , have to nuke it!!", pszOriginal);

        LocalFree(pbbdew);
        // get the recycled dir and tack on the file name
        DriveIDToBBPath(idDrive, szBBPath);
        GetDeletedFileNameFromParts(szFileName, idDrive, iIndex, pszOriginal);
        PathAppend(szBBPath, szFileName);

        // now delete it
        BBNuke(szBBPath);
    }
}

BOOL BBFinishDelete(HDPA hdpaDeletedFiles)
{
    BOOL fSuccess = TRUE; // assume success
    int iDeletedFiles = hdpaDeletedFiles ? DPA_GetPtrCount(hdpaDeletedFiles) : 0;
    if (iDeletedFiles > 0)
    {
        int iCurrentFile = 0;
        BBDATAENTRYW *pbbdew = (BBDATAENTRYW *)DPA_FastGetPtr(hdpaDeletedFiles, iCurrentFile);

        // now write it to the file
        int idDrive = pbbdew->idDrive;
        HANDLE hFile = OpenBBInfoFile(idDrive, OPENBBINFO_WRITE, 0);
        if (hFile != INVALID_HANDLE_VALUE)
        {
            DWORD dwDataEntrySize = g_pBitBucket[idDrive]->fIsUnicode ? sizeof(BBDATAENTRYW) : sizeof(BBDATAENTRYA);

            SetFilePointer(hFile, 0, NULL, FILE_END);

            while (iCurrentFile < iDeletedFiles)
            {
                DWORD dwBytesWritten;
                pbbdew = (BBDATAENTRYW *)DPA_FastGetPtr(hdpaDeletedFiles, iCurrentFile);

                // All deletes should be in the same drive for each batch.
                ASSERT(idDrive == pbbdew->idDrive);

                if (!WriteFile(hFile, pbbdew, dwDataEntrySize, &dwBytesWritten, NULL) ||
                    (dwDataEntrySize != dwBytesWritten))
                {
                    fSuccess = FALSE;
                    break;
                }
                LocalFree(pbbdew);
                iCurrentFile++;
            }

            CloseBBInfoFile(hFile, idDrive);
        }
        else
        {
            fSuccess = FALSE;
        }

        if (!fSuccess)
        {
            TCHAR szBBPath[MAX_PATH];
            int iFilesToNuke;

            for (iFilesToNuke = iCurrentFile; iFilesToNuke < iDeletedFiles; iFilesToNuke++)
            {
                pbbdew = DPA_FastGetPtr(hdpaDeletedFiles, iFilesToNuke);
                GetDeletedFilePath(szBBPath, pbbdew);

                // now delete it
                BBNuke(szBBPath);
                LocalFree(pbbdew);
            }
        }

        if (iCurrentFile != 0)
        {
            BOOL bPurge = TRUE;
        
            // since we sucessfully deleted a file, we set this so at the end of the last SHFileOperation call on this drive
            // we will go back and make sure that there isint too much stuff in the bucket.
            RegSetValueEx(g_pBitBucket[idDrive]->hkeyPerUser, TEXT("NeedToPurge"), 0, REG_DWORD, (LPBYTE)&bPurge, sizeof(bPurge));
        }
    }

    if (hdpaDeletedFiles)
        DPA_Destroy(hdpaDeletedFiles);

    return fSuccess;
}


// creates the proper SECURITY_DESCRIPTOR for securing the recycle bin
//
// NOTE: if return value is non-null, the caller must LocalFree it
//
SECURITY_DESCRIPTOR* CreateRecycleBinSecurityDescriptor()
{
    SHELL_USER_PERMISSION supLocalUser;
    SHELL_USER_PERMISSION supSystem;
    SHELL_USER_PERMISSION supAdministrators;
    PSHELL_USER_PERMISSION aPerms[3] = {&supLocalUser, &supSystem, &supAdministrators};

    // we want the current user to have full control
    supLocalUser.susID = susCurrentUser;
    supLocalUser.dwAccessType = ACCESS_ALLOWED_ACE_TYPE;
    supLocalUser.dwAccessMask = FILE_ALL_ACCESS;
    supLocalUser.fInherit = TRUE;
    supLocalUser.dwInheritMask = (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);
    supLocalUser.dwInheritAccessMask = GENERIC_ALL;

    // we want the SYSTEM to have full control
    supSystem.susID = susSystem;
    supSystem.dwAccessType = ACCESS_ALLOWED_ACE_TYPE;
    supSystem.dwAccessMask = FILE_ALL_ACCESS;
    supSystem.fInherit = TRUE;
    supSystem.dwInheritMask = (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);
    supSystem.dwInheritAccessMask = GENERIC_ALL;

    // we want the Administrators to have full control
    supAdministrators.susID = susAdministrators;
    supAdministrators.dwAccessType = ACCESS_ALLOWED_ACE_TYPE;
    supAdministrators.dwAccessMask = FILE_ALL_ACCESS;
    supAdministrators.fInherit = TRUE;
    supAdministrators.dwInheritMask = (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);
    supAdministrators.dwInheritAccessMask = GENERIC_ALL;

    return GetShellSecurityDescriptor(aPerms, ARRAYSIZE(aPerms));
}

//
// Creates the secure recycle bin directory (eg one with ACL's that protect it)
// for recycle bins on NTFS volumes.
//
BOOL CreateSecureRecyclerDirectory(LPCTSTR pszPath)
{
    BOOL fSuccess = FALSE;      // assume failure
    SECURITY_DESCRIPTOR* psd = CreateRecycleBinSecurityDescriptor();

    if (psd)
    {
        DWORD cbSA = GetSecurityDescriptorLength(psd);
        SECURITY_DESCRIPTOR* psdSelfRelative;

        psdSelfRelative = LocalAlloc(LPTR, cbSA);

        if (psdSelfRelative)
        {
            if (MakeSelfRelativeSD(psd, psdSelfRelative, &cbSA))
            {
                SECURITY_ATTRIBUTES sa;

                // Build the security attributes structure
                sa.nLength = sizeof(SECURITY_ATTRIBUTES);
                sa.lpSecurityDescriptor = psdSelfRelative;
                sa.bInheritHandle = FALSE;

                fSuccess = (SHCreateDirectoryEx(NULL, pszPath, &sa) == ERROR_SUCCESS);
            }

            LocalFree(psdSelfRelative);
        }

        LocalFree(psd);
    }

    return fSuccess;
}

BOOL CreateRecyclerDirectory(int idDrive)
{
    TCHAR szPath[MAX_PATH];
    TCHAR szRoot[MAX_PATH];
    BOOL bResult = FALSE;
    BOOL bExists;

    // NOTE: we currently do not to check for FAT/FAT32 drives that have been 
    // upgraded to NTFS and migrate the recycle bin info over
    
    DriveIDToBBPath(idDrive, szPath);
    DriveIDToBBRoot(idDrive, szRoot);

    bExists = PathIsDirectory(szPath);

    if (!bExists)
    {
        if (CMtPt_IsSecure(idDrive))
        {
            bExists = CreateSecureRecyclerDirectory(szPath);
        }
        else
        {
            bExists = (SHCreateDirectoryEx(NULL, szPath, NULL) == ERROR_SUCCESS);
        }
    }

    if (bExists) 
    {
        PathAppend(szPath, c_szDesktopIni);
        // CLSID_RecycleBin
        WritePrivateProfileString(STRINI_CLASSINFO, TEXT("CLSID"), TEXT("{645FF040-5081-101B-9F08-00AA002F954E}"), szPath);
        SetFileAttributes(szPath, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);   // desktop.ini

        PathRemoveFileSpec(szPath);
        // Hide all of the directories along the way until we hit the BB root
        do
        {
            SetFileAttributes(szPath, FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN);

            PathRemoveFileSpec(szPath);
        } while (0 != lstrcmpi(szPath, szRoot));

        // everything's set.  let's add it in
        // try to load the and initalize 
        bResult = TRUE;
    }

    return bResult;
}


//
// this sets up the bitbucket directory and allocs the internal structures
//
BOOL MakeBitBucket(int idDrive)
{
    BOOL bRet = FALSE;

    if (IsBitBucketableDrive(idDrive))
    {
        if (IsBitBucketInited(idDrive))
        {
            LONG lBucketDirtyCount = SHGlobalCounterGetValue(g_pBitBucket[idDrive]->hgcDirtyCount);
            LONG lGlobalDirtyCount = SHGlobalCounterGetValue(g_hgcGlobalDirtyCount);

            // check to see if we need to refresh the settings for this bucket
            if (lGlobalDirtyCount > g_lProcessDirtyCount)
            {
                // global settings change, so refresh all buckets
                g_lProcessDirtyCount = lGlobalDirtyCount;
                RefreshAllBBDriveSettings();
            }
            else if (lBucketDirtyCount > g_pBitBucket[idDrive]->lCurrentDirtyCount)
            {
                // just this buckets settings changed, so refresh only this one
                g_pBitBucket[idDrive]->lCurrentDirtyCount = lBucketDirtyCount;
                RefreshBBDriveSettings(idDrive);
            }
            
            bRet = TRUE;
        }
        else
        {
            bRet = AllocBBDriveInfo(idDrive);
        }
    }

    return bRet;
}


// Tells if a file will *likely* be recycled...
// this could be wrong if:
//
//      * disk is full
//      * file is really a folder
//      * file greater than the allocated size for the recycle directory
//      * file is in use or no ACLS to move or delete it
//
BOOL BBWillRecycle(LPCTSTR pszFile, INT* piRet)
{
    INT iRet = BBDELETE_SUCCESS;
    int idDrive = DriveIDFromBBPath(pszFile);

    // MakeBitBucket will ensure that the global & per-bucket settings we have are current
    if (!MakeBitBucket(idDrive) || g_pBitBucket[idDrive]->fNukeOnDelete || (g_pBitBucket[idDrive]->iPercent == 0))
    {
        iRet = BBDELETE_FORCE_NUKE;
    }
    else if (SERVERDRIVE == idDrive)
    {
        // Check to see if the serverdrive is offline (don't recycle while offline to prevent
        // synchronization conflicts when coming back online):
        TCHAR szVolume[MAX_PATH];
        LONG lStatus;
        DriveIDToBBVolumeRoot(idDrive, szVolume);

        lStatus = GetOfflineShareStatus(szVolume);
        if ((CSC_SHARESTATUS_OFFLINE == lStatus) || (CSC_SHARESTATUS_SERVERBACK == lStatus))
        {
            iRet = BBDELETE_NUKE_OFFLINE;
        }
    }

    if (piRet)
    {
        *piRet = iRet;
    }
    return (BBDELETE_SUCCESS == iRet);
}


//
// This is called at the end of the last pending SHFileOperation that involves deletes.
// We wait till there arent any more people deleteing before we go try to compact the info
// file or purge entries and make the bitbucket respect its cbMaxSize.
//
void CheckCompactAndPurge()
{
    int i;
    TCHAR szBBKey[MAX_PATH];
    HKEY hkBBPerUser;

    for (i = 0; i < MAX_BITBUCKETS ; i++)
    {
        DriveIDToBBRegKey(i, szBBKey);
        
        // NOTE: these function needs to manually construct the key because it would like to avoid calling MakeBitBucket()
        // for drives that it has yet to look at (this is a performance optimization)
        if (RegOpenKeyEx(g_hkBitBucketPerUser, szBBKey, 0, KEY_QUERY_VALUE |  KEY_SET_VALUE, &hkBBPerUser) == ERROR_SUCCESS)
        {
            BOOL bCompact = FALSE;
            BOOL bPurge = FALSE;
            DWORD dwSize;

            dwSize = sizeof(bCompact);
            if (RegQueryValueEx(hkBBPerUser, TEXT("NeedToCompact"), NULL, NULL, (LPBYTE)&bCompact, &dwSize) == ERROR_SUCCESS && bCompact == TRUE)
            {
                // reset this key so no one else tries to compact this bitbucket
                RegDeleteValue(hkBBPerUser, TEXT("NeedToCompact"));
            }

            dwSize = sizeof(bPurge);
            if (RegQueryValueEx(hkBBPerUser, TEXT("NeedToPurge"), NULL, NULL, (LPBYTE)&bPurge, &dwSize) == ERROR_SUCCESS && bPurge == TRUE)
            {
                // reset this key so no one else tries to purge this bitbucket
                RegDeleteValue(hkBBPerUser, TEXT("NeedToPurge"));
            }
  
            if (MakeBitBucket(i))
            {
                if (bCompact)
                {
                    TraceMsg(TF_BITBUCKET, "Bitbucket: compacting drive %d",i);
                    CompactBBInfoFile(i);
                }

                if (bPurge)
                {
                    TraceMsg(TF_BITBUCKET, "Bitbucket: purging drive %d", i);
                    PurgeBBFiles(i);
                }
            }

            RegCloseKey(hkBBPerUser);
        }
    }

    SHUpdateRecycleBinIcon();
    SHChangeNotify(0, SHCNF_FLUSH | SHCNF_FLUSHNOWAIT, NULL, NULL);
}



// Initialization to call prior to BBDeleteFile
BOOL BBDeleteFileInit(LPTSTR pszFile, INT* piRet)
{
    // check to see if we need to init our global data first
    if (!InitBBGlobals())
    {
        // this could happen in low memory situations, we have no choice but
        // to really nuke the file
        *piRet = BBDELETE_FORCE_NUKE;
        return FALSE;
    }

    if (!BBWillRecycle(pszFile, piRet))
    {
        // We failed to create the recycler directory on the volume, or
        // this is the case where the user has "delete files immeadately" set, or 
        // % max size=0, etc.
        return FALSE;
    }

    return TRUE;
}

// return:
//
//      TRUE    - The file/folder was sucessfully moved to the recycle bin. We set lpiReturn = BBDELETE_SUCCESS for this case.
//
//      FALSE   - The file/folder could not be moved to the recycle bin
//                In this case, the piRet value tells WHY the file/folder could not be recycled:
//                
//                BBDELETE_FORCE_NUKE       - User has "delete file immeadately" set, or % max size=0, or we failed to 
//                                            create the recycler directory.
//
//                BBDELETE_CANNOT_DELETE    - The file/folder is non-deletable because a file under it cannot be deleted.
//                                            This is an NT only case, and it could be caused by acls or the fact that the
//                                            folder or a file in it is currently in use.
//
//                BBDELETE_SIZE_TOO_BIG     - The file/folder is bigger than the max allowable size of the recycle bin.
//
//                BBDELETE_PATH_TOO_LONG    - The path would be too long ( > MAX_PATH), if the file were to be moved to the
//                                            the recycle bin directory at the root of the drive
//
//                BBDELETE_UNKNOWN_ERROR    - Some other error occured, GetLastError() should explain why we failed.
//                            
//
BOOL BBDeleteFile(LPTSTR pszFile, INT* piRet, LPUNDOATOM lpua, BOOL fIsDir, HDPA *phdpaDeletedFiles, ULARGE_INTEGER ulSize)
{
    int iRet;
    TCHAR szBitBucket[MAX_PATH];
    TCHAR szFileName[MAX_PATH];
    TCHAR szShortFileName[MAX_PATH];
    DWORD dwLastError;
    int iIndex;
    int idDrive = DriveIDFromBBPath(pszFile);
    int iAttempts = 0;

    TraceMsg(TF_BITBUCKET, "BBDeleteFile (%s)", pszFile);
    // Before we move the file we save off the "short" name. This is in case we have 
    // a unicode path and we need the ansi short path in case a win95 machine later tries to
    // restore this file. We can't do this later because GetShortPathName relies on the 
    // file actually exising.
    if (!GetShortPathName(pszFile, szShortFileName, ARRAYSIZE(szShortFileName)))
    {
        lstrcpyn(szShortFileName, pszFile, ARRAYSIZE(szShortFileName));
    }

TryMoveAgain:

    // get the target name and move it
    iIndex = SHGlobalCounterIncrement(g_pBitBucket[idDrive]->hgcNextFileNum);
    GetDeletedFileNameFromParts(szFileName, idDrive, iIndex, pszFile);
    DriveIDToBBPath(idDrive, szBitBucket);

    if (PathAppend(szBitBucket, szFileName))
    {
        iRet = SHMoveFile(pszFile, szBitBucket, fIsDir ? SHCNE_RMDIR : SHCNE_DELETE);

        // do GetLastError here so that we don't get the last error from the PathFileExists
        dwLastError = (iRet ? ERROR_SUCCESS : GetLastError());

        if (!iRet) 
        {
            TraceMsg(TF_BITBUCKET, "BBDeleteFile : Error(%x) moving file (%s)", dwLastError, pszFile);
            if (ERROR_ALREADY_EXISTS == dwLastError)
            {
                TraceMsg(TF_BITBUCKET, "Bitbucket: BBDeleteFile found a file of the same name (%s) - skipping", szBitBucket);
                // generate a new filename and retry
                goto TryMoveAgain;
            }
            // Since we are moving files that may be temporarily in use (e.g. for thumbnail extraction)
            // we may get a transient error (sharing violation is obvious but we also can get access denied
            // for some reason) so we end up trying this again after a short nap.
            else if (((ERROR_ACCESS_DENIED == dwLastError) || (ERROR_SHARING_VIOLATION == dwLastError)) && 
                     (iAttempts < MAX_DELETE_ATTEMPTS))
            {
                TraceMsg(TF_BITBUCKET, "BBDeleteFile : sleeping a bit to try again");
                iAttempts++;
                Sleep(SLEEP_DELETE_ATTEMPT);  // wait a bit
                goto TryMoveAgain;
            }
            else
            {
                // is our recycled directory still there?
                TCHAR szTemp[MAX_PATH];
                SHGetPathFromIDList(g_pBitBucket[idDrive]->pidl, szTemp);
                // if it already exists or there was some error in creating it, bail
                // else try again
                if (!PathIsDirectory(szTemp) && CreateRecyclerDirectory(idDrive))
                {
                    // if we did just re-create the directory, we need to reset the info
                    // file or the drive will get corrupted.
                    VerifyBBInfoFileHeader(idDrive);
                    goto TryMoveAgain;
                }
            }
        }
        else 
        {
            // success!
            BBAddDeletedFileInfo(pszFile, szShortFileName, iIndex, idDrive, ulSize.LowPart, phdpaDeletedFiles);
    
            if (lpua)
                FOUndo_AddInfo(lpua, pszFile, szBitBucket, 0);
            *piRet = BBDELETE_SUCCESS;
            return TRUE;
        }
    }
    else
    {
        // if path append fails, it probably means that the path is too long
        *piRet = BBDELETE_PATH_TOO_LONG;
        return FALSE;
    }

    // set back the correct last error
    SetLastError(dwLastError);
    
    // something bad happened, we dont know what it is
    *piRet = BBDELETE_UNKNOWN_ERROR;

    return FALSE;
}


// Basically it understands how we the trash is layed out which is fine
// as we are in the bitbucket code file... So we skip the first 3
// characters for the root of the name: c:\ and we truncate off the
// last part of the name and the rest should match our deathrow name...
BOOL IsFileInBitBucket(LPCTSTR pszPath)
{
    TCHAR szPath[MAX_PATH];
    int idDrive = DriveIDFromBBPath(pszPath);

    if (IsBitBucketableDrive(idDrive))
    {
        DriveIDToBBPath(idDrive, szPath);

        return(PathCommonPrefix(szPath, pszPath, NULL) == lstrlen(szPath));
    }

    return FALSE;
}


//
// This is called by the copy engine when a user selects "undo".
//
// NOTE: takes two multistrings (seperated/double null terminated file lists)
void UndoBBFileDelete(LPCTSTR pszOriginal, LPCTSTR pszDelFile)
{
    SHFILEOPSTRUCT sFileOp = {NULL,
                              FO_MOVE,
                              pszDelFile,
                              pszOriginal,
                              FOF_NOCONFIRMATION | FOF_MULTIDESTFILES | FOF_SIMPLEPROGRESS};

    SHFileOperation(&sFileOp);

    SHUpdateRecycleBinIcon();
}


STDAPI_(void) SHUpdateRecycleBinIcon()
{
    UpdateIcon(!IsRecycleBinEmpty());
}


void PurgeOneBitBucket(HWND hwnd, int idDrive, DWORD dwFlags)
{
    TCHAR szPath[MAX_PATH];
    HANDLE hFile;
    SHFILEOPSTRUCT sFileOp = {hwnd,
                              FO_DELETE,
                              szPath,
                              NULL,
                              FOF_SIMPLEPROGRESS,
                              FALSE,
                              NULL,
                              MAKEINTRESOURCE(IDS_BB_EMPTYINGWASTEBASKET)};

    ASSERT(g_pBitBucket[idDrive] && (g_pBitBucket[idDrive] != (BBSYNCOBJECT *)-1));

    if (dwFlags & SHERB_NOCONFIRMATION)
    {
        sFileOp.fFlags |= FOF_NOCONFIRMATION;
    }

    if (dwFlags & SHERB_NOPROGRESSUI)
    {
        sFileOp.fFlags |= FOF_SILENT;
    }

    DriveIDToBBPath(idDrive, szPath);
    PathAppend(szPath, c_szDStarDotStar);
    szPath[lstrlen(szPath) + 1] = 0; // double null terminate

    hFile = OpenBBInfoFile(idDrive, OPENBBINFO_WRITE, 0);

    if (INVALID_HANDLE_VALUE != hFile)
    {
        // now do the actual delete.
        if (SHFileOperation(&sFileOp) || sFileOp.fAnyOperationsAborted)
        {
            TraceMsg(TF_BITBUCKET, "Bitbucket: emptying bucket on %s failed", szPath);

            // NOTE: the info file may point to some files that have been deleted,
            // it will be cleaned up later
        }
        else
        {
            // reset the info file since we just emptied this bucket.
            ResetInfoFileHeader(hFile, g_pBitBucket[idDrive]->fIsUnicode);
        }

        // we always re-create the desktop.ini
        CreateRecyclerDirectory(idDrive);

        CloseBBInfoFile(hFile, idDrive);
    }
    
    SHUpdateRecycleBinIcon();
}


// This function checks to see if an local NT directory is delete-able
//
// returns:
//      TRUE   yes, the dir can be nuked
//      FALSE  for UNC dirs or dirs on network drives, or
//             if the user does not have enough privlidges
//             to delete the file (acls).
//
// NOTE: this code is largely stolen from the RemoveDirectoryW API (windows\base\client\dir.c). if
//       you think that there is a bug in it, then diff it against the DeleteFileW and see it something
//       there changed.
//
// also sets the last error to explain why
//
BOOL IsDirectoryDeletable(LPCTSTR pszDir)
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_DISPOSITION_INFORMATION Disposition;
    FILE_ATTRIBUTE_TAG_INFORMATION FileTagInformation;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME RelativeName;
    void *FreeBuffer;
    DWORD dwAttributes;
    BOOL fChangedAttribs = FALSE;

    // return false for any network drives (allow UNC)
    if (IsNetDrive(PathGetDriveNumber(pszDir)))
    {
        return FALSE;
    }

    if (PathIsUNC(pszDir) && PathIsDirectoryEmpty(pszDir))
    {
        // HACKACK - (reinerf) the rdr will nuke the file when we call
        // NtSetInformationFile to set the deleted bit on an empty directory even
        // though we pass READ_CONTROL and we still have a handle to the object.
        // So, to work around this, we just assume we can always delete empty
        // directories (ha!)
        return TRUE;
    }

    // check to see if the dir is readonly
    dwAttributes = GetFileAttributes(pszDir);
    if ((dwAttributes != -1) && (dwAttributes & FILE_ATTRIBUTE_READONLY))
    {
        fChangedAttribs = TRUE;

        if (!SetFileAttributes(pszDir, dwAttributes & ~FILE_ATTRIBUTE_READONLY))
        {
            return FALSE;
        }
    }

    TranslationStatus = RtlDosPathNameToNtPathName_U(pszDir,
                                                     &FileName,
                                                     NULL,
                                                     &RelativeName);
    if (!TranslationStatus)
    {
        if (fChangedAttribs)
        {
            // set the attribs back
            SetFileAttributes(pszDir, dwAttributes);
        }

        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
    }

    FreeBuffer = FileName.Buffer;

    if (RelativeName.RelativeName.Length)
    {
        FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
    }
    else
    {
        RelativeName.ContainingDirectory = NULL;
    }

    InitializeObjectAttributes(&Obja,
                               &FileName,
                               OBJ_CASE_INSENSITIVE,
                               RelativeName.ContainingDirectory,
                               NULL);

    //
    // Open the directory for delete access.
    // Inhibit the reparse behavior using FILE_OPEN_REPARSE_POINT.
    //
    Status = NtOpenFile(&Handle,
                        DELETE | SYNCHRONIZE | FILE_READ_ATTRIBUTES | READ_CONTROL,
                        &Obja,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT);

    if (!NT_SUCCESS(Status))
    {
        //
        // Back level file systems may not support reparse points and thus not
        // support symbolic links.
        // We infer this is the case when the Status is STATUS_INVALID_PARAMETER.
        //

        if (Status == STATUS_INVALID_PARAMETER)
        {
            //   
            // Re-open not inhibiting the reparse behavior and not needing to read the attributes.
            //
            Status = NtOpenFile(&Handle,
                                DELETE | SYNCHRONIZE | READ_CONTROL,
                                &Obja,
                                &IoStatusBlock,
                                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT);

            if (!NT_SUCCESS(Status))
            {
                RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

                if (fChangedAttribs)
                {
                    // set the attribs back
                    SetFileAttributes(pszDir, dwAttributes);
                }

                SetLastError(RtlNtStatusToDosError(Status));
                return FALSE;
            }
        }
        else
        {
            RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

            if (fChangedAttribs)
            {
                // set the attribs back
                SetFileAttributes(pszDir, dwAttributes);
            }
            
            SetLastError(RtlNtStatusToDosError(Status));
            return FALSE;
        }
    }
    else
    {
        //
        // If we found a reparse point that is not a name grafting operation,
        // either a symbolic link or a mount point, we re-open without 
        // inhibiting the reparse behavior.
        //
        Status = NtQueryInformationFile(Handle,
                                        &IoStatusBlock,
                                        (void *) &FileTagInformation,
                                        sizeof(FileTagInformation),
                                        FileAttributeTagInformation);
    
        if (!NT_SUCCESS(Status))
        {
            //
            // Not all File Systems implement all information classes.
            // The value STATUS_INVALID_PARAMETER is returned when a non-supported
            // information class is requested to a back-level File System. As all the
            // parameters to NtQueryInformationFile are correct, we can infer that
            // we found a back-level system.
            //
            // If FileAttributeTagInformation is not implemented, we assume that
            // the file at hand is not a reparse point.
            //

            if ((Status != STATUS_NOT_IMPLEMENTED) && (Status != STATUS_INVALID_PARAMETER))
            {
                RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                NtClose(Handle);

                if (fChangedAttribs)
                {
                    // set the attribs back
                    SetFileAttributes(pszDir, dwAttributes);
                }

                SetLastError(RtlNtStatusToDosError(Status));
                return FALSE;
            }
        }

        if (NT_SUCCESS(Status) && (FileTagInformation.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT))
        {
            if (FileTagInformation.ReparseTag == IO_REPARSE_TAG_MOUNT_POINT)
            {
                //
                // We want to make sure that we return FALSE for mounted volumes. This will cause BBDeleteFile
                // to return BBDELETE_CANNOT_DELETE so that we will actuall delete the mountpoint and not try to
                // move the mount point to the recycle bin or walk into it.
                //
                RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                NtClose(Handle);

                if (fChangedAttribs)
                {
                     // set the attribs back
                    SetFileAttributes(pszDir, dwAttributes);
                }

                // hmmm... lets pull ERROR_NOT_A_REPARSE_POINT out of our butt and return that error code!
                SetLastError(ERROR_NOT_A_REPARSE_POINT);
                return FALSE;
            }
        }
    
        if (NT_SUCCESS(Status) && (FileTagInformation.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT))
        {
            //
            // Re-open without inhibiting the reparse behavior and not needing to 
            // read the attributes.
            //
            NtClose(Handle);
            Status = NtOpenFile(&Handle,
                                DELETE | SYNCHRONIZE | READ_CONTROL,
                                &Obja,
                                &IoStatusBlock,
                                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT);

            if (!NT_SUCCESS(Status))
            {
                //
                // When the FS Filter is absent, delete it any way.
                //
                if (Status == STATUS_IO_REPARSE_TAG_NOT_HANDLED)
                {
                    //
                    // We re-open (possible 3rd open) for delete access inhibiting the reparse behavior.
                    //
                    Status = NtOpenFile(&Handle,
                                        DELETE | SYNCHRONIZE | READ_CONTROL,
                                        &Obja,
                                        &IoStatusBlock,
                                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                        FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT);
                }

                if (!NT_SUCCESS(Status))
                {
                    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                    
                    if (fChangedAttribs)
                    {
                        // set the attribs back
                        SetFileAttributes(pszDir, dwAttributes);
                    }

                    SetLastError(RtlNtStatusToDosError(Status));
                    return FALSE;
                }
            }
        }
    }
    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

    //
    // Attempt to set the delete bit
    //
#undef DeleteFile
    Disposition.DeleteFile = TRUE;

    Status = NtSetInformationFile(Handle,
                                  &IoStatusBlock,
                                  &Disposition,
                                  sizeof(Disposition),
                                  FileDispositionInformation);

    if (NT_SUCCESS(Status)) 
    {
        //
        // yep, we were able to set the bit, now unset it so its not delted!
        //
        Disposition.DeleteFile = FALSE;
        Status = NtSetInformationFile(Handle,
                                      &IoStatusBlock,
                                      &Disposition,
                                      sizeof(Disposition),
                                      FileDispositionInformation);
        NtClose(Handle);
        
        if (fChangedAttribs)
        {
            // set the attribs back
            SetFileAttributes(pszDir, dwAttributes);
        }
        return TRUE;
    }
    else
    {
        //
        // nope couldnt set the del bit. can't be deleted
        //
        TraceMsg(TF_BITBUCKET, "IsDirectoryDeletable: NtSetInformationFile failed, status=0x%08x", Status);

        NtClose(Handle);

        if (fChangedAttribs)
        {
             // set the attribs back
            SetFileAttributes(pszDir, dwAttributes);
        }

        SetLastError(RtlNtStatusToDosError(Status));
        return FALSE;
    }
    return TRUE;
}


// This function checks to see if a local NT file is delete-able
//
// returns:
//      TRUE   yes, the file can be nuked
//      FALSE  for UNC files or files on network drives
//      FALSE  if the file is in use
//
// NOTE: this code is largely stolen from the DeleteFileW API (windows\base\client\filemisc.c). if
//       you think that there is a bug in it, then diff it against the DeleteFileW and see it something
//       there changed.
//
// also sets the last error to explain why
//
BOOL IsFileDeletable(LPCTSTR pszFile)
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_DISPOSITION_INFORMATION Disposition;
    FILE_ATTRIBUTE_TAG_INFORMATION FileTagInformation;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME RelativeName;
    void *FreeBuffer;
    BOOLEAN fIsSymbolicLink = FALSE;
    DWORD dwAttributes;
    BOOL fChangedAttribs = FALSE;

    // return false for any network drives
    if (IsNetDrive(PathGetDriveNumber(pszFile)))
    {
        return FALSE;
    }

    // check to see if the file is readonly or system
    dwAttributes = GetFileAttributes(pszFile);
    if (dwAttributes != -1)
    {
        if (dwAttributes & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM))
        {
            fChangedAttribs = TRUE;

            if (!SetFileAttributes(pszFile, dwAttributes & ~(FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM)))
            {
                return FALSE;
            }
        }
    }

    TranslationStatus = RtlDosPathNameToNtPathName_U(pszFile,
                                                     &FileName,
                                                     NULL,
                                                     &RelativeName);

    if (!TranslationStatus)
    {
        if (fChangedAttribs)
        {
             // set the attribs back
            SetFileAttributes(pszFile, dwAttributes);
        }

        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
    }

    FreeBuffer = FileName.Buffer;

    if (RelativeName.RelativeName.Length)
    {
        FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
    }
    else
    {
        RelativeName.ContainingDirectory = NULL;
    }

    InitializeObjectAttributes(&Obja,
                               &FileName,
                               OBJ_CASE_INSENSITIVE,
                               RelativeName.ContainingDirectory,
                               NULL);

    // Open the file for delete access
    Status = NtOpenFile(&Handle,
                        (ACCESS_MASK)DELETE | FILE_READ_ATTRIBUTES | READ_CONTROL,
                        &Obja,
                        &IoStatusBlock,
                        FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT);

    if (!NT_SUCCESS(Status))
    {
        //
        // Back level file systems may not support reparse points and thus not
        // support symbolic links.
        // We infer this is the case when the Status is STATUS_INVALID_PARAMETER.
        //

        if (Status == STATUS_INVALID_PARAMETER)
        {
            //
            // Open without inhibiting the reparse behavior and not needing to
            // read the attributes.
            //

            Status = NtOpenFile(&Handle,
                                (ACCESS_MASK)DELETE | READ_CONTROL,
                                &Obja,
                                &IoStatusBlock,
                                FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                                FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT);

            if (!NT_SUCCESS(Status))
            {
                RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

                if (fChangedAttribs)
                {
                     // set the attribs back
                    SetFileAttributes(pszFile, dwAttributes);
                }

                SetLastError(RtlNtStatusToDosError(Status));
                return FALSE;
            }
        }
        else
        {
            RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

            if (fChangedAttribs)
            {
                 // set the attribs back
                SetFileAttributes(pszFile, dwAttributes);
            }

            SetLastError(RtlNtStatusToDosError(Status));
            return FALSE;
        }
    }
    else
    {
        //
        // If we found a reparse point that is not a symbolic link, we re-open
        // without inhibiting the reparse behavior.
        //
        Status = NtQueryInformationFile(Handle,
                                        &IoStatusBlock,
                                        (void *) &FileTagInformation,
                                        sizeof(FileTagInformation),
                                        FileAttributeTagInformation);
        if (!NT_SUCCESS(Status))
        {
            //
            // Not all File Systems implement all information classes.
            // The value STATUS_INVALID_PARAMETER is returned when a non-supported
            // information class is requested to a back-level File System. As all the
            // parameters to NtQueryInformationFile are correct, we can infer that
            // we found a back-level system.
            //
            // If FileAttributeTagInformation is not implemented, we assume that
            // the file at hand is not a reparse point.
            //

            if ((Status != STATUS_NOT_IMPLEMENTED) && (Status != STATUS_INVALID_PARAMETER))
            {
                RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                NtClose(Handle);

                if (fChangedAttribs)
                {
                     // set the attribs back
                    SetFileAttributes(pszFile, dwAttributes);
                }

                SetLastError(RtlNtStatusToDosError(Status));
                return FALSE;
            }
        }

        if (NT_SUCCESS(Status) && (FileTagInformation.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT))
        {
            if (FileTagInformation.ReparseTag == IO_REPARSE_TAG_MOUNT_POINT)
            {
                fIsSymbolicLink = TRUE;
            }
        }

        if (NT_SUCCESS(Status)                                                 &&
            (FileTagInformation.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) &&
            !fIsSymbolicLink)
        {
            //
            // Re-open without inhibiting the reparse behavior and not needing to
            // read the attributes.
            //

            NtClose(Handle);
            Status = NtOpenFile(&Handle,
                                (ACCESS_MASK)DELETE | READ_CONTROL,
                                &Obja,
                                &IoStatusBlock,
                                FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                                FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT);

            if (!NT_SUCCESS(Status))
            {
                //
                // When the FS Filter is absent, delete it any way.
                //

                if (Status == STATUS_IO_REPARSE_TAG_NOT_HANDLED)
                {
                    //
                    // We re-open (possible 3rd open) for delete access inhibiting the reparse behavior.
                    //

                    Status = NtOpenFile(&Handle,
                                        (ACCESS_MASK)DELETE | READ_CONTROL,
                                        &Obja,
                                        &IoStatusBlock,
                                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                        FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT);
                }

                if (!NT_SUCCESS(Status))
                {
                    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

                    if (fChangedAttribs)
                    {
                         // set the attribs back
                        SetFileAttributes(pszFile, dwAttributes);
                    }

                    SetLastError(RtlNtStatusToDosError(Status));
                    return FALSE;
                }
            }
        }
    }

    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

    //
    // Attempt to set the delete bit
    //
#undef DeleteFile
    Disposition.DeleteFile = TRUE;

    Status = NtSetInformationFile(Handle,
                                  &IoStatusBlock,
                                  &Disposition,
                                  sizeof(Disposition),
                                  FileDispositionInformation);

    if (NT_SUCCESS(Status)) 
    {
        //
        // yep, we were able to set the bit, now unset it so its not delted!
        //
        Disposition.DeleteFile = FALSE;
        Status = NtSetInformationFile(Handle,
                                      &IoStatusBlock,
                                      &Disposition,
                                      sizeof(Disposition),
                                      FileDispositionInformation);
        NtClose(Handle);
        
        if (fChangedAttribs)
        {
            // set the attribs back
            SetFileAttributes(pszFile, dwAttributes);
        }
        return TRUE;
    }
    else
    {
        //
        // nope couldnt set the del bit. can't be deleted
        //
        TraceMsg(TF_BITBUCKET, "IsFileDeletable: NtSetInformationFile failed, status=0x%08x", Status);

        NtClose(Handle);

        if (fChangedAttribs)
        {
             // set the attribs back
            SetFileAttributes(pszFile, dwAttributes);
        }

        SetLastError(RtlNtStatusToDosError(Status));
        return FALSE;
    }
    return TRUE;
}

BOOL BBCheckDeleteFileSize(int idDrive, ULARGE_INTEGER ulSize)
{
    return (!ulSize.HighPart && g_pBitBucket[idDrive]->cbMaxSize > ulSize.LowPart);
}

int BBRecyclePathLength(int idDrive)
{
    return g_pBitBucket[idDrive]->cchBBDir;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\bookmk.c ===
#include "shellprv.h"
#pragma  hdrstop

#include "fstreex.h"
#include "bookmk.h"


// *** WARNING *** 
//
// Scrap_CreateFromDataObject is a TCHAR export from SHSCRAP.DLL, if you change its calling convention, you
// must modify PFNSCRAPCREATEFROMDATAOBJECT and the wrapper fn. below 
//
// *** WARNING ***
typedef HRESULT (CALLBACK *PFNSCRAPCREATEFROMDATAOBJECT)(LPCTSTR pszPath, IDataObject *pDataObj, BOOL fLink, LPTSTR pszNewFile);


STDAPI Scrap_CreateFromDataObject(LPCTSTR pszPath, IDataObject *pDataObj, BOOL fLink, LPTSTR pszNewFile)
{
    static PFNSCRAPCREATEFROMDATAOBJECT pfn = (PFNSCRAPCREATEFROMDATAOBJECT)-1;

    if (pfn == (PFNSCRAPCREATEFROMDATAOBJECT)-1)
    {
        HINSTANCE hinst = LoadLibrary(TEXT("shscrap.dll"));

        if (hinst)
        {
            pfn = (PFNSCRAPCREATEFROMDATAOBJECT)GetProcAddress(hinst, "Scrap_CreateFromDataObject");
        }
        else
        {
            pfn = NULL;
        }
    }

    if (pfn)
    {
        return pfn(pszPath, pDataObj, fLink, pszNewFile);
    }

    // for failure cases just return E_UNEXPECTED;
    return E_UNEXPECTED;
}


//
// Parameters:
//  pDataObj    -- The data object passed from the drag source.
//  pt          -- Dropped position (in screen coordinate).
//  pdwEffect   -- Pointer to dwEffect variable to be returned to the drag source.
//
STDAPI SHCreateBookMark(HWND hwnd, LPCTSTR pszPath, IDataObject *pDataObj, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hres;
    TCHAR szNewFile[MAX_PATH];
    DECLAREWAITCURSOR;

    // We should have only one bit set.
    ASSERT(*pdwEffect==DROPEFFECT_COPY || *pdwEffect==DROPEFFECT_LINK || *pdwEffect==DROPEFFECT_MOVE);

    SetWaitCursor();
    hres = Scrap_CreateFromDataObject(pszPath, pDataObj, *pdwEffect == DROPEFFECT_LINK, szNewFile);
    ResetWaitCursor();

    if (SUCCEEDED(hres)) 
    {
        SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, szNewFile, NULL);
        SHChangeNotify(SHCNE_FREESPACE, SHCNF_PATH, szNewFile, NULL);
        PositionFileFromDrop(hwnd, szNewFile, NULL);
    } 
    else 
    {
        *pdwEffect = 0;
    }

    return hres;
}


#define MAX_FORMATS     20

typedef struct
{
    IEnumFORMATETC efmt;
    LONG         cRef;
    UINT         ifmt;
    UINT         cfmt;
    FORMATETC    afmt[1];
} CStdEnumFmt;

// forward
extern const IEnumFORMATETCVtbl c_CStdEnumFmtVtbl;

//===========================================================================
// CStdEnumFmt : Constructor
//===========================================================================
STDAPI SHCreateStdEnumFmtEtc(UINT cfmt, const FORMATETC afmt[], IEnumFORMATETC **ppenumFormatEtc)
{
    CStdEnumFmt * this = (CStdEnumFmt*)LocalAlloc( LPTR, SIZEOF(CStdEnumFmt) + (cfmt-1)*SIZEOF(FORMATETC));
    if (this)
    {
        this->efmt.lpVtbl = &c_CStdEnumFmtVtbl;
        this->cRef = 1;
        this->cfmt = cfmt;
        memcpy(this->afmt, afmt, cfmt * SIZEOF(FORMATETC));
        *ppenumFormatEtc = &this->efmt;
        return S_OK;
    }
    *ppenumFormatEtc = NULL;
    return E_OUTOFMEMORY;
}

STDAPI SHCreateStdEnumFmtEtcEx(UINT cfmt, const FORMATETC afmt[],
                               IDataObject *pdtInner, IEnumFORMATETC **ppenumFormatEtc)
{
    HRESULT hres;
    FORMATETC *pfmt;
    UINT cfmtTotal;

    if (pdtInner)
    {
        IEnumFORMATETC *penum;
        hres = pdtInner->lpVtbl->EnumFormatEtc(pdtInner, DATADIR_GET, &penum);
        if (SUCCEEDED(hres))
        {
            UINT cfmt2, cGot;
            FORMATETC fmte;

            for (cfmt2 = 0; penum->lpVtbl->Next(penum, 1, &fmte, &cGot) == S_OK; cfmt2++) 
            {
                // count up the number of FormatEnum in cfmt2
                SHFree(fmte.ptd);
            }

            penum->lpVtbl->Reset(penum);
            cfmtTotal = cfmt + cfmt2;

            // Allocate the buffer for total
            pfmt = (FORMATETC *)LocalAlloc(LPTR, SIZEOF(FORMATETC) * cfmtTotal);
            if (pfmt)
            {
                UINT i;
                // Get formatetcs from the inner object
                for (i = 0; i < cfmt2; i++) 
                {
                    penum->lpVtbl->Next(penum, 1, &pfmt[i], &cGot);
                    // NOTE!  We do not support inner objects with non-NULL ptd
                    ASSERT(pfmt[i].ptd == NULL);
                    SHFree(pfmt[i].ptd);
                    pfmt[i].ptd = NULL;
                }

                // Copy the rest
                if (cfmt)
                {
#ifdef DEBUG
                    UINT ifmt;
                    for (ifmt = 0; ifmt < cfmt; ifmt++) {
                        // NOTE!  We do not support non-NULL ptd
                        ASSERT(afmt[ifmt].ptd == NULL);
                    }
#endif
                    memcpy(&pfmt[cfmt2], afmt, SIZEOF(FORMATETC) * cfmt);
                }
            }
            else
            {
                hres = E_OUTOFMEMORY;
            }

            penum->lpVtbl->Release(penum);
        }
    }
    else
    {
        hres = E_FAIL;  // ptInner == NULL
    }

    if (FAILED(hres) && hres != E_OUTOFMEMORY)
    {
        //
        // Ignore none fatal error from pdtInner::EnumFormatEtc
        // We'll come here if
        //  1. pdtInner == NULL or
        //  2. pdtInner->EnumFormatEtc failed (except E_OUTOFMEMORY)
        //
        hres = NOERROR;
        pfmt = (FORMATETC *)afmt;       // safe const -> non const cast
        cfmtTotal = cfmt;
    }

    if (SUCCEEDED(hres)) 
    {
        hres = SHCreateStdEnumFmtEtc(cfmtTotal, pfmt, ppenumFormatEtc);
        if (pfmt != afmt)
            LocalFree((HLOCAL)pfmt);
    }

    return hres;
}

STDMETHODIMP CStdEnumFmt_QueryInterface(IEnumFORMATETC *pefmt, REFIID riid, void **ppvObj)
{
    CStdEnumFmt *this = IToClass(CStdEnumFmt, efmt, pefmt);

    if (IsEqualIID(riid, &IID_IEnumFORMATETC) || IsEqualIID(riid, &IID_IUnknown))
    {
        *ppvObj = &this->efmt;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    this->cRef++;
    return NOERROR;
}

STDMETHODIMP_(ULONG) CStdEnumFmt_AddRef(IEnumFORMATETC *pefmt)
{
    CStdEnumFmt *this = IToClass(CStdEnumFmt, efmt, pefmt);
    return ++this->cRef;
}

STDMETHODIMP_(ULONG) CStdEnumFmt_Release(IEnumFORMATETC *pefmt)
{
    CStdEnumFmt *this = IToClass(CStdEnumFmt, efmt, pefmt);
    this->cRef--;
    if (this->cRef > 0)
        return this->cRef;

    LocalFree((HLOCAL)this);
    return 0;
}

STDMETHODIMP CStdEnumFmt_Next(IEnumFORMATETC *pefmt, ULONG celt, FORMATETC *rgelt, ULONG *pceltFethed)
{
    CStdEnumFmt *this = IToClass(CStdEnumFmt, efmt, pefmt);
    UINT cfetch;
    HRESULT hres = S_FALSE;     // assume less numbers

    if (this->ifmt < this->cfmt)
    {
        cfetch = this->cfmt - this->ifmt;
        if (cfetch>=celt) 
        {
            cfetch = celt;
            hres = S_OK;
        }

        memcpy(rgelt, &this->afmt[this->ifmt], cfetch*SIZEOF(FORMATETC));
        this->ifmt += cfetch;
    }
    else
    {
        cfetch = 0;
    }

    if (pceltFethed)
        *pceltFethed = cfetch;

    return hres;
}

STDMETHODIMP CStdEnumFmt_Skip(IEnumFORMATETC *pefmt, ULONG celt)
{
    CStdEnumFmt *this = IToClass(CStdEnumFmt, efmt, pefmt);
    this->ifmt += celt;
    if (this->ifmt > this->cfmt) {
        this->ifmt = this->cfmt;
        return S_FALSE;
    }
    return S_OK;
}

STDMETHODIMP CStdEnumFmt_Reset(IEnumFORMATETC *pefmt)
{
    CStdEnumFmt *this = IToClass(CStdEnumFmt, efmt, pefmt);
    this->ifmt = 0;
    return S_OK;
}

STDMETHODIMP CStdEnumFmt_Clone(IEnumFORMATETC *pefmt, IEnumFORMATETC ** ppenum)
{
    CStdEnumFmt *this = IToClass(CStdEnumFmt, efmt, pefmt);
    return SHCreateStdEnumFmtEtc(this->cfmt, this->afmt, ppenum);
}

const IEnumFORMATETCVtbl c_CStdEnumFmtVtbl = {
    CStdEnumFmt_QueryInterface, CStdEnumFmt_AddRef, CStdEnumFmt_Release,
    CStdEnumFmt_Next,
    CStdEnumFmt_Skip,
    CStdEnumFmt_Reset,
    CStdEnumFmt_Clone,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\brfcase.h ===
#include <brfcasep.h>

STDAPI CreateBrfStgFromIDList(LPCITEMIDLIST pidl, HWND hwnd, IBriefcaseStg **ppbs);
STDAPI CreateBrfStgFromPath(LPCTSTR pszPath, HWND hwnd, IBriefcaseStg **ppbs);

STDAPI CBrfData_CreateDataObj(LPCITEMIDLIST pidl, UINT cidl, LPCITEMIDLIST *apidl, IDataObject **ppdtobj);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\bitbuck.h ===
#ifndef _BITBUCK_INC
#define _BITBUCK_INC

#include "ids.h"
#include "undo.h"

// whacky #defines

#define DELETEMAX 100000
#define MAX_BITBUCKETS 27
#define MAX_DRIVES 26
#define OPENFILERETRYTIME 500
#define OPENFILERETRYCOUNT 10
#define SERVERDRIVE 26
#define MAX_EMPTY_FILES     100     // if we have MAX_EMPTY_FILES or more then we use the generic "do you want to empty" message.  

#define TF_BITBUCKET 0x10000000
// #define TF_BITBUCKET TF_ERROR

//
// NOTE: The on-disk format of the recycle bin should never have to change again.
//       If you think you need to change it, then you are wrong.
//
#define BITBUCKET_WIN95_VERSION         0       // (info)  Ansi Win95, OSR2 wastebasket
#define BITBUCKET_NT4_VERSION           2       // (info)  Unicode NT4 wastebasket
#define BITBUCKET_WIN98IE4INT_VERSION   4       // (info2) win9x+IE4 integrated, and win98 wastebasket       
#define BITBUCKET_FINAL_VERSION         5       // (info2) NT4+IE4 integraged, win2k, millenium, every future os wastebasket

#define OPENBBINFO_READ                 0x00000000
#define OPENBBINFO_WRITE                0x00000001
#define OPENBBINFO_CREATE               0x00000003

#define IsDeletedEntry(pbbde) (! (((BBDATAENTRYA*)pbbde)->szOriginal[0]) )
#define MarkEntryDeleted(pbbde) ((BBDATAENTRYA*)pbbde)->szOriginal[0] = '\0';

// this is the old (win95) data header.  it's maintained in the info file
// but only used for verification.  for current stuff look at the driveinfo,
// which is kept in the registry.
typedef struct {
    int idVersion;
    int cFiles;                     // the # of items in this drive's recycle bin
    int cCurrent;                   // the current file number.
    UINT cbDataEntrySize;           // size of each entry
    DWORD dwSize;                   // total size of this recycle bin drive
} BBDATAHEADER;

// The bitbucket datafile (INFO on win95, INFO2 on IE4/NT5, etc...) format is as follows:
//
// (binary writes)
//
//      BBDATAHEADER        // header
//      BBDATAENTRY[X]      // array of BBDATAENTRYies
//

typedef struct {
    CHAR szOriginal[MAX_PATH];  // original filename (if szOriginal[0] is 0, then it's a deleted entry)
    int  iIndex;                // index (key to name)
    int idDrive;                // which drive bucket it's currently in
    FILETIME ft;
    DWORD dwSize;
    // shouldn't need file attributes because we did a move file
    // which should have preserved them.
} BBDATAENTRYA, *LPBBDATAENTRYA;

typedef struct {
    CHAR szShortName[MAX_PATH]; // original filename, shortened (if szOriginal[0] is 0, then it's a deleted entry)
    int iIndex;                 // index (key to name)
    int idDrive;                // which drive bucket it's currently in
    FILETIME ft;
    DWORD dwSize;
    WCHAR szOriginal[MAX_PATH]; // original filename
} BBDATAENTRYW, *LPBBDATAENTRYW;

typedef BBDATAENTRYA UNALIGNED *PUBBDATAENTRYA;

// On NT5 we are finally going to have cross-process syncrhonization to 
// the Recycle Bin. We replaced the global LPBBDRIVEINFO array with an
// array of the following structures:
typedef struct {
    BOOL fInited;               // is this particular BBSYNCOBJECT fully inited (needed when we race to create it)
    HANDLE hgcNextFileNum;      // a global counter that garuntees unique deleted file names
    HANDLE hgcDirtyCount;       // a global counter to tell us if we need to re-read the bitbucket settings from the registry (percent, max size, etc)
    LONG lCurrentDirtyCount;    // out current dirty count; we compare this to hgcDirtyCount to see if we need to update the settings from the registry
    HKEY hkey;                  // HKLM reg key, under which we store the settings for this specific bucket (iPercent and fNukeOnDelete).
    HKEY hkeyPerUser;           // HKCU reg key, under which we have volital reg values indicatiog if there is a need to purge or compact this bucket

    BOOL fIsUnicode;            // is this a bitbucket on a drive whose INFO2 file uses BBDATAENTRYW structs?
    int iPercent;               // % of the drive to use for the bitbucket
    DWORD cbMaxSize;            // maximum size of bitbucket (in bytes), NOTE: we use a dword because the biggest the BB can ever grow to is 4 gigabytes.
    DWORD dwClusterSize;        // cluster size of this volume, needed to round all the file sizes
    ULONGLONG qwDiskSize;       // total size of the disk - takes into account quotas on NTFS
    BOOL fNukeOnDelete;         // I love the smell of napalm in the morning.

    LPITEMIDLIST pidl;          // pidl = bitbucket dir for this drive
    int cchBBDir;               // # of characters that makes up the bitbucket directory.

} BBSYNCOBJECT;

#define c_szInfo2           TEXT("INFO2")    // version 2 of the db file (used in IE4, win98, NT5, ...)
#define c_szInfo            TEXT("INFO")     // version 1 of the db file (used in win95, osr2, NT4)
#define c_szDStarDotStar    TEXT("D*.*")

// globals

EXTERN_C BBSYNCOBJECT *g_pBitBucket[MAX_BITBUCKETS];
EXTERN_C HKEY g_hkBitBucket;
EXTERN_C HANDLE g_hgcNumDeleters;

// prototypes by bitbuck.c, bbckfldr.cpp

STDAPI_(BOOL) InitBBGlobals();
STDAPI_(void) BitBucket_Terminate();
STDAPI_(BOOL) IsBitBucketableDrive(int idDrive);
STDAPI_(int) DriveIDFromBBPath(LPCTSTR pszPath);
STDAPI_(void) UpdateIcon(BOOL fFull);
STDAPI_(void) NukeFileInfoBeforePoint(HANDLE hfile, LPBBDATAENTRYW pbbdew, DWORD dwDataEntrySize);
STDAPI_(BOOL) ReadNextDataEntry(HANDLE hfile, LPBBDATAENTRYW pbbde, BOOL fSkipDeleted, int idDrive);
STDAPI_(void) CloseBBInfoFile(HANDLE hFile, int idDrive);
STDAPI_(HANDLE) OpenBBInfoFile(int idDrive, DWORD dwFlags, int iRetryCount);
STDAPI_(int) BBPathToIndex(LPCTSTR pszPath);
STDAPI BBFileNameToInfo(LPCTSTR pszFileName, int *pidDrive, int *piIndex);
STDAPI_(void) GetDeletedFileName(LPTSTR pszFileName, const BBDATAENTRYW *pbbdew);
STDAPI_(void) DriveIDToBBPath(int idDrive, LPTSTR pszPath);
STDAPI_(void) DriveIDToBBRoot(int idDrive, LPTSTR szPath);
STDAPI_(void) DriveIDToBBVolumeRoot(int idDrive, LPTSTR szPath);
STDAPI_(BOOL) GetNetHomeDir(LPTSTR pszPath);
STDAPI_(BOOL) PersistBBDriveSettings(int idDrive, int iPercent, BOOL fNukeOnDelete);
STDAPI_(BOOL) MakeBitBucket(int idDrive);
STDAPI_(DWORD) PurgeBBFiles(int idDrive);
STDAPI_(BOOL) PersistGlobalSettings(BOOL fUseGlobalSettings, BOOL fNukeOnDelete, int iPercent);
STDAPI_(BOOL) RefreshAllBBDriveSettings();
STDAPI_(BOOL) RefreshBBDriveSettings(int idDrive);
STDAPI_(void) CheckCompactAndPurge();
STDAPI        BBPurgeAll(HWND hwndOwner, DWORD dwFlags);
STDAPI_(BOOL) BBDeleteFileInit(LPTSTR pszFile, INT* piRet);
STDAPI_(BOOL) BBDeleteFile(LPTSTR pszFile, INT* piRet, LPUNDOATOM lpua, BOOL fIsDir, HDPA *phdpaDeletedFiles, ULARGE_INTEGER ulSize);
STDAPI_(BOOL) BBFinishDelete(HDPA hdpaDeletedFiles);
STDAPI_(BOOL) IsFileInBitBucket(LPCTSTR pszPath);
STDAPI_(void) UndoBBFileDelete(LPCTSTR pszOriginal, LPCTSTR pszDelFile);
STDAPI_(BOOL) BBWillRecycle(LPCTSTR pszFile, INT* piRet);
STDAPI_(void) BBCheckRestoredFiles(LPCTSTR pszSrc);
STDAPI_(BOOL) BBCheckDeleteFileSize(int idDrive, ULARGE_INTEGER ulSize);
STDAPI_(BOOL) IsFileDeletable(LPCTSTR pszFile);
STDAPI_(BOOL) IsDirectoryDeletable(LPCTSTR pszDir);
STDAPI_(int)  BBRecyclePathLength(int idDrive);


STDAPI_(BOOL) IsRecycleBinEmpty();
STDAPI_(void) SHUpdateRecycleBinIcon();
STDAPI_(void) SaveRecycleBinInfo();

STDAPI_(void) SetDateTimeText(HWND hdlg, int id, const FILETIME *pftUTC);

STDAPI_(DWORD) ReadPolicySetting(LPCWSTR pszBaseKey, LPCWSTR pszGroup, LPCWSTR pszRestriction, LPBYTE pbData, DWORD cbData);

#endif // _BITBUCK_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\brffldr.cpp ===
#include "shellprv.h"

#include <brfcasep.h>
#include "filefldr.h"
#include "brfcase.h"
#include "datautil.h"
#include "prop.h"
#include "ids.h"
#include "defview.h"    // for WM_DSV_FSNOTIFY
#include "basefvcb.h"
#include "views.h"

#define MAX_NAME    32

#define HACK_IGNORETYPE     0x04000000

TCHAR g_szDetailsUnknown[MAX_NAME] = TEXT("");

// Values for CBriefcase::_FindNextState
#define FNS_UNDETERMINED   1
#define FNS_STALE          2
#define FNS_DELETED        3

typedef struct
{
    TCHAR    szOrigin[MAX_PATH];
    TCHAR    szStatus[MAX_NAME];
    BOOL    bDetermined:1;
    BOOL    bUpToDate:1;
    BOOL    bDeleted:1;
} BRFINFO;

typedef struct
{
    LPITEMIDLIST    pidl;       // Indexed value
    BRFINFO         bi;
} BRFINFOHDR;

class CBriefcaseViewCB;

class CBriefcase : public CFSFolder
{
    friend CBriefcaseViewCB;

public:
    CBriefcase(IUnknown *punkOuter);

    // IShellFolder
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHODIMP CreateViewObject (HWND hwndOwner, REFIID riid, void **ppv);
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl, ULONG *rgfInOut);
    STDMETHODIMP GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl, REFIID riid, UINT * prgfInOut, void **ppv);

    // IShellFolder2
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails);
    STDMETHOD (MapColumnToSCID)(UINT iColumn, SHCOLUMNID *pscid);

private:
    ~CBriefcase();

    static DWORD CALLBACK _CalcDetailsThreadProc(void *pv);
    DWORD _CalcDetailsThread();

    void _EnterCS();
    void _LeaveCS();
    static int CALLBACK _CompareIDCallBack(void *pv1, void *pv2, LPARAM lParam);
    BOOL _CreateDetailsThread();
    BOOL _InitDetailsInfoAndThread(IBriefcaseStg *pbrfstg, HWND hwndMain, HANDLE hMutexDelay);
    void _Free();
    void _Reset();
    BOOL _FindCachedName(LPCITEMIDLIST pidl, BRFINFO *pbi);
    BOOL _DeleteCachedName(LPCITEMIDLIST pidl);
    BOOL _FindNextState(UINT uState, BRFINFOHDR *pbihdrOut);
    void _CalcCachedName(LPCITEMIDLIST pidl, BRFINFO *pbi);
    void _CachedNameIsStale(LPCITEMIDLIST pidl, BOOL bDeleted);
    void _AllNamesAreStale();
    BOOL _AddCachedName(LPCITEMIDLIST pidl, BRFINFO *pbi);
    HRESULT _CreateView(HWND hwnd, IShellView **ppsv);

    HWND                _hwndMain;      // evil, view related state
    IBriefcaseStg       *_pbrfstg;      // evil, view related state

    // accessed by background thread
    HDPA                _hdpa;          
    int                 _idpaStaleCur;
    int                 _idpaUndeterminedCur;
    int                 _idpaDeletedCur;
    HANDLE              _hSemPending;    // Pending semaphore
    CRITICAL_SECTION    _cs;
    HANDLE              _hEventDie;
    HANDLE              _hThreadCalcDetails;
    HANDLE              _hMutexDelay;    // alias given out by the _pbrfstg
    BOOL                _bFreePending;
#ifdef DEBUG
    UINT                _cUndetermined;
    UINT                _cStale;
    UINT                _cDeleted;
    UINT                _cCSRef;
#endif
};

class CBriefcaseViewCB : public CBaseShellFolderViewCB
{
public:
    CBriefcaseViewCB(CBriefcase *pfolder);
    HRESULT _InitStgForDetails();

    STDMETHODIMP RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    ~CBriefcaseViewCB();
    LPCITEMIDLIST _FolderPidl() { return _pfolder->_pidl; }

    HRESULT OnWINDOWCREATED(DWORD pv, HWND hwndView);
    HRESULT OnWINDOWDESTROY(DWORD pv, HWND wP);
    HRESULT OnMergeMenu(DWORD pv, QCMINFO*lP);
    HRESULT OnINVOKECOMMAND(DWORD pv, UINT wP);
    HRESULT OnGetHelpOrTooltipText(BOOL bHelp, UINT wPl, UINT cch, LPTSTR psz);
    HRESULT OnINITMENUPOPUP(DWORD pv, UINT wPl, UINT wPh, HMENU lP);
    HRESULT OnGETBUTTONINFO(DWORD pv, TBINFO* ptbinfo);
    HRESULT OnGETBUTTONS(DWORD pv, UINT wPl, UINT wPh, TBBUTTON*lP);
    HRESULT OnSELCHANGE(DWORD pv, UINT wPl, UINT wPh, SFVM_SELCHANGE_DATA*lP);
    HRESULT OnQUERYFSNOTIFY(DWORD pv, SHChangeNotifyEntry*lP);
    HRESULT OnFSNOTIFY(DWORD pv, LPCITEMIDLIST*wP, LPARAM lP);
    HRESULT OnQUERYCOPYHOOK(DWORD pv);
    HRESULT OnNOTIFYCOPYHOOK(DWORD pv, COPYHOOKINFO*lP);
    HRESULT OnINSERTITEM(DWORD pv, LPCITEMIDLIST wP);
    HRESULT OnDEFVIEWMODE(DWORD pv, FOLDERVIEWMODE *lP);
    HRESULT OnSupportsIdentity(DWORD pv);
    HRESULT OnGetHelpTopic(DWORD pv, SFVM_HELPTOPIC_DATA * phtd);
    HRESULT OnDELAYWINDOWCREATE(DWORD pv, HWND hwnd);
    HRESULT _GetSelectedObjects(IDataObject **ppdtobj);
    HRESULT _HandleFSNotifyForDefView(LPARAM lEvent, LPCITEMIDLIST * ppidl, LPTSTR pszBuf);
    int _GetSelectedCount();

    CBriefcase *_pfolder;

    IBriefcaseStg       *_pbrfstg;
    LPITEMIDLIST        _pidlRoot;       // Root of briefcase
    HANDLE              _hMutexDelay;
    ULONG               _uSCNRExtra;     // Extra SHChangeNotifyRegister for our pidl...
    TCHAR               _szDBName[MAX_PATH];

    // Web View implementation
    HRESULT OnGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData);
    HRESULT OnGetWebViewContent(DWORD pv, SFVM_WEBVIEW_CONTENT_DATA* pData);
    HRESULT OnGetWebViewTasks(DWORD pv, SFVM_WEBVIEW_TASKSECTION_DATA* pTasks);
public:
    static HRESULT _OnUpdate(IUnknown* pv,IShellItemArray *psiItemArray, IBindCtx *pbc);
};

CBriefcase::CBriefcase(IUnknown *punkOuter) : CFSFolder(punkOuter)
{
    _clsidBind = CLSID_BriefcaseFolder; // in CFSFolder

    InitializeCriticalSection(&_cs);
}

CBriefcase::~CBriefcase()
{
    DeleteCriticalSection(&_cs);
}

enum
{
    ICOL_BRIEFCASE_NAME = 0,
    ICOL_BRIEFCASE_ORIGIN,
    ICOL_BRIEFCASE_STATUS,
    ICOL_BRIEFCASE_SIZE,
    ICOL_BRIEFCASE_TYPE,
    ICOL_BRIEFCASE_MODIFIED,
};

const COLUMN_INFO s_briefcase_cols[] = 
{
    DEFINE_COL_STR_ENTRY(SCID_NAME,                 30, IDS_NAME_COL),
    DEFINE_COL_STR_ENTRY(SCID_SYNCCOPYIN,           24, IDS_SYNCCOPYIN_COL),
    DEFINE_COL_STR_ENTRY(SCID_STATUS,               18, IDS_STATUS_COL),
    DEFINE_COL_SIZE_ENTRY(SCID_SIZE,                    IDS_SIZE_COL),
    DEFINE_COL_STR_ENTRY(SCID_TYPE,                 18, IDS_TYPE_COL),
    DEFINE_COL_STR_ENTRY(SCID_WRITETIME,            18, IDS_MODIFIED_COL),
};


#ifdef DEBUG

#define _AssertInCS()     ASSERT(0 < (this)->_cCSRef)
#define _AssertNotInCS()  ASSERT(0 == (this)->_cCSRef)

#else

#define _AssertInCS()
#define _AssertNotInCS()

#endif


void CBriefcase::_EnterCS()
{
    EnterCriticalSection(&_cs);
#ifdef DEBUG
    _cCSRef++;
#endif
}

void CBriefcase::_LeaveCS()
{
    _AssertInCS();
#ifdef DEBUG
    _cCSRef--;
#endif
    LeaveCriticalSection(&_cs);
}


//---------------------------------------------------------------------------
// Brfview functions:    Expensive cache stuff
//---------------------------------------------------------------------------


// Comparison function for the DPA list

int CALLBACK CBriefcase::_CompareIDCallBack(void *pv1, void *pv2, LPARAM lParam)
{
    BRFINFOHDR *pbihdr1 = (BRFINFOHDR *)pv1;
    BRFINFOHDR *pbihdr2 = (BRFINFOHDR *)pv2;
    CBriefcase *pfolder = (CBriefcase *)lParam;
    HRESULT hr = pfolder->CompareIDs(HACK_IGNORETYPE, pbihdr1->pidl, pbihdr2->pidl);
    
    ASSERT(SUCCEEDED(hr));
    return (short)SCODE_CODE(GetScode(hr));   // (the short cast is important!)
}

// Create the secondary thread for the expensive cache

BOOL CBriefcase::_CreateDetailsThread()
{
    BOOL bRet = FALSE;
    
    // The semaphore is used to determine whether anything
    // needs to be refreshed in the cache.
    _hSemPending = CreateSemaphore(NULL, 0, MAXLONG, NULL);
    if (_hSemPending)
    {
#ifdef DEBUG
        _cStale = 0;
        _cUndetermined = 0;
        _cDeleted = 0;
#endif
        ASSERT(NULL == _hEventDie);
        
        _hEventDie = CreateEvent(NULL, FALSE, FALSE, NULL);
        
        if (_hEventDie)
        {
            // Create the thread that will calculate expensive data
            DWORD idThread;
            _hThreadCalcDetails = CreateThread(NULL, 0, _CalcDetailsThreadProc, this, CREATE_SUSPENDED, &idThread);
            if (_hThreadCalcDetails)
            {
                ResumeThread(_hThreadCalcDetails);
                bRet = TRUE;
            }
            else
            {
                CloseHandle(_hEventDie);
                _hEventDie = NULL;
                
                CloseHandle(_hSemPending);
                _hSemPending = NULL;
            }
        }
        else
        {
            CloseHandle(_hSemPending);
            _hSemPending = NULL;
        }
    }
    
    return bRet;
}

// view callback inits the folder with data it needs to run the GetDetailsOf() stuff
// on a background thread

BOOL CBriefcase::_InitDetailsInfoAndThread(IBriefcaseStg *pbrfstg, HWND hwndMain, HANDLE hMutexDelay)
{
    BOOL bRet = FALSE;

    ASSERT(pbrfstg && hwndMain && hMutexDelay);   // from the init call
    
    _EnterCS();
    {
        if (_hdpa)
        {
            bRet = TRUE;
        }
        else
        {
            LoadString(HINST_THISDLL, IDS_DETAILSUNKNOWN, g_szDetailsUnknown, ARRAYSIZE(g_szDetailsUnknown));
            
            _hwndMain = hwndMain;
            _hMutexDelay = hMutexDelay;
            _idpaStaleCur = 0;
            _idpaUndeterminedCur = 0;
            _idpaDeletedCur = 0;
            
            _hdpa = DPA_Create(8);
            if (_hdpa)
            {
                bRet = _CreateDetailsThread();
                if (bRet)
                {
                    ASSERT(NULL == _pbrfstg);
                    _pbrfstg = pbrfstg;
                    pbrfstg->AddRef();
                }
                else
                {
                    // Failed
                    DPA_Destroy(_hdpa);
                    _hdpa = NULL;
                }
            }
        }
    }
    _LeaveCS();
    
    return bRet;
}

// Clean up the cache of expensive data

void CBriefcase::_Free()
{
    _EnterCS();
    {
        if (_hEventDie)
        {
            if (_hThreadCalcDetails)
            {
                HANDLE hThread = _hThreadCalcDetails;
                
                SetThreadPriority(hThread, THREAD_PRIORITY_HIGHEST);
                
                // Signal the secondary thread to end
                SetEvent(_hEventDie);
                
                // Make sure we are not in the critical section when
                // we wait for the secondary thread to exit.  Without
                // this check, hitting F5 twice in a row could deadlock.
                _LeaveCS();
                {
                    // Wait for the threads to exit
                    _AssertNotInCS();
                    
                    WaitForSendMessageThread(hThread, INFINITE);
                }
                _EnterCS();
                
                DebugMsg(DM_TRACE, TEXT("Briefcase Secondary thread ended"));
                
                CloseHandle(_hThreadCalcDetails);
                _hThreadCalcDetails = NULL;
            }
            
            CloseHandle(_hEventDie);
            _hEventDie = NULL;
        }
        
        if (_hdpa)
        {
            int idpa = DPA_GetPtrCount(_hdpa);
            while (--idpa >= 0)
            {
                BRFINFOHDR *pbihdr = (BRFINFOHDR *)DPA_FastGetPtr(_hdpa, idpa);
                ILFree(pbihdr->pidl);
                LocalFree((HLOCAL)pbihdr);
            }
            DPA_Destroy(_hdpa);
            _hdpa = NULL;
        }
        
        if (_hSemPending)
        {
            CloseHandle(_hSemPending);
            _hSemPending = NULL;
        }
        
        if (_pbrfstg)
        {
            _pbrfstg->Release();
            _pbrfstg = NULL;

            _hMutexDelay = NULL;    // invalidate our alias
        }
    }
    _LeaveCS();
}

// Resets the expensive data cache
void CBriefcase::_Reset()
{
    _AssertNotInCS();
    
    _EnterCS();
    {
        IBriefcaseStg *pbrfstg = _pbrfstg;
        
        if (!_bFreePending && pbrfstg)
        {
            HWND hwndMain = _hwndMain;
            HANDLE hMutex = _hMutexDelay;
            
            pbrfstg->AddRef();
            
            // Since we won't be in the critical section when we
            // wait for the paint thread to exit, set this flag to
            // avoid nasty re-entrant calls.
            _bFreePending = TRUE;
            
            // Reset by freeing and reinitializing.
            _LeaveCS();
            {
                _Free();
                // whacky re-init of ourselevs
                _InitDetailsInfoAndThread(pbrfstg, hwndMain, hMutex);
            }
            _EnterCS();
            
            _bFreePending = FALSE;
            
            pbrfstg->Release();
        }
    }
    _LeaveCS();
}

// Finds a cached name structure and returns a copy of it in *pbi.
BOOL CBriefcase::_FindCachedName(LPCITEMIDLIST pidl, BRFINFO *pbi)
{
    BOOL bRet = FALSE;
    
    _EnterCS();
    {
        if (_hdpa)
        {
            BRFINFOHDR bihdr = {0};
            
            bihdr.pidl = (LPITEMIDLIST)pidl;    // const -> non const
            int idpa = DPA_Search(_hdpa, &bihdr, 0, _CompareIDCallBack, (LPARAM)this, DPAS_SORTED);
            if (DPA_ERR != idpa)
            {
                // Yes
                BRFINFOHDR *pbihdr = (BRFINFOHDR *)DPA_FastGetPtr(_hdpa, idpa);
                ASSERT(pbihdr);
                
                *pbi = pbihdr->bi;
                bRet = TRUE;
            }
        }
    }
    _LeaveCS();
    
    return bRet;
}

// Deletes a cached name structure.

BOOL CBriefcase::_DeleteCachedName(LPCITEMIDLIST pidl)
{
    BOOL bRet = FALSE;
    
    _EnterCS();
    {
        if (_hdpa)
        {
            BRFINFOHDR bihdr = {0};
            
            bihdr.pidl = (LPITEMIDLIST)pidl;    // const -> non const
            int idpa = DPA_Search(_hdpa, &bihdr, 0, _CompareIDCallBack, (LPARAM)this, DPAS_SORTED);
            if (DPA_ERR != idpa)
            {
#ifdef DEBUG
                BRFINFOHDR *pbihdr = (BRFINFOHDR *)DPA_FastGetPtr(_hdpa, idpa);
                ASSERT(pbihdr);
                
                _cDeleted--;
                
                if (!pbihdr->bi.bDetermined)
                    _cUndetermined--;
                else if (!pbihdr->bi.bUpToDate)
                    _cStale--;
#endif
                // Keep index pointers current
                if (_idpaStaleCur >= idpa)
                    _idpaStaleCur--;
                if (_idpaUndeterminedCur >= idpa)
                    _idpaUndeterminedCur--;
                if (_idpaDeletedCur >= idpa)
                    _idpaDeletedCur--;
                
                DPA_DeletePtr(_hdpa, idpa);
                bRet = TRUE;
            }
        }
    }
    _LeaveCS();
    
    return bRet;
}


// Finds the next cached name structure that matches the requested state.

BOOL CBriefcase::_FindNextState(UINT uState, BRFINFOHDR *pbihdrOut)
{
    BOOL bRet = FALSE;
    
    ASSERT(pbihdrOut);
    
    _EnterCS();
    {
        if (_hdpa)
        {
            HDPA hdpa = _hdpa;
            int idpaCur;
            int idpa;
            BRFINFOHDR *pbihdr;
            
            int cdpaMax = DPA_GetPtrCount(hdpa);
            
            switch (uState)
            {
            case FNS_UNDETERMINED:
                // Iterate thru the entire list starting at idpa.  We roll this
                // loop out to be two loops: the first iterates the last portion
                // of the list, the second iterates the first portion if the former
                // failed to find anything.
                idpaCur = _idpaUndeterminedCur + 1;
                for (idpa = idpaCur; idpa < cdpaMax; idpa++)
                {
                    pbihdr = (BRFINFOHDR *)DPA_FastGetPtr(hdpa, idpa);
                    if (!pbihdr->bi.bDetermined)
                    {
                        goto Found;     // Found it
                    }
                }
                ASSERT(idpaCur <= cdpaMax);
                for (idpa = 0; idpa < idpaCur; idpa++)
                {
                    pbihdr = (BRFINFOHDR *)DPA_FastGetPtr(hdpa, idpa);
                    if (!pbihdr->bi.bDetermined)
                    {
                        goto Found;     // Found it
                    }
                }
                ASSERT(0 == _cUndetermined);
                break;
                
            case FNS_STALE:
                // Iterate thru the entire list starting at idpa.  We roll this
                // loop out to be two loops: the first iterates the last portion
                // of the list, the second iterates the first portion if the former
                // failed to find anything.
                idpaCur = _idpaStaleCur + 1;
                for (idpa = idpaCur; idpa < cdpaMax; idpa++)
                {
                    pbihdr = (BRFINFOHDR *)DPA_FastGetPtr(hdpa, idpa);
                    if (!pbihdr->bi.bUpToDate)
                    {
                        goto Found;     // Found it
                    }
                }
                ASSERT(idpaCur <= cdpaMax);
                for (idpa = 0; idpa < idpaCur; idpa++)
                {
                    pbihdr = (BRFINFOHDR *)DPA_FastGetPtr(hdpa, idpa);
                    if (!pbihdr->bi.bUpToDate)
                    {
                        goto Found;     // Found it
                    }
                }
                ASSERT(0 == _cStale);
                break;
                
            case FNS_DELETED:
                // Iterate thru the entire list starting at idpa.  We roll this
                // loop out to be two loops: the first iterates the last portion
                // of the list, the second iterates the first portion if the former
                // failed to find anything.
                idpaCur = _idpaDeletedCur + 1;
                for (idpa = idpaCur; idpa < cdpaMax; idpa++)
                {
                    pbihdr = (BRFINFOHDR *)DPA_FastGetPtr(hdpa, idpa);
                    if (pbihdr->bi.bDeleted)
                    {
                        goto Found;     // Found it
                    }
                }
                ASSERT(idpaCur <= cdpaMax);
                for (idpa = 0; idpa < idpaCur; idpa++)
                {
                    pbihdr = (BRFINFOHDR *)DPA_FastGetPtr(hdpa, idpa);
                    if (pbihdr->bi.bDeleted)
                    {
                        goto Found;     // Found it
                    }
                }
                ASSERT(0 == _cDeleted);
                break;
                
            default:
                ASSERT(0);      // should never get here
                break;
            }
            goto Done;
            
Found:
            ASSERT(0 <= idpa && idpa < cdpaMax);
            
            // Found the next item of the requested state
            switch (uState)
            {
            case FNS_UNDETERMINED:
                _idpaUndeterminedCur = idpa;
                break;
                
            case FNS_STALE:
                _idpaStaleCur = idpa;
                break;
                
            case FNS_DELETED:
                _idpaDeletedCur = idpa;
                break;
            }
            
            *pbihdrOut = *pbihdr;
            pbihdrOut->pidl = ILClone(pbihdr->pidl);
            if (pbihdrOut->pidl)
                bRet = TRUE;
        }
Done:;
    }
    _LeaveCS();
    return bRet;
}
    
// Recalculates a cached name structure.  This can be an expensive operation
void CBriefcase::_CalcCachedName(LPCITEMIDLIST pidl, BRFINFO *pbi)
{
    _EnterCS();
    
    if (_hdpa && _pbrfstg)
    {
        LPCIDFOLDER pidf = (LPCIDFOLDER)pidl;
        IBriefcaseStg *pbrfstg = _pbrfstg;
        
        pbrfstg->AddRef();
        
        // Make sure we're out of the critical section when we call
        // the expensive functions!
        _LeaveCS();
        {
            TCHAR szTmp[MAX_PATH];
            _CopyName(pidf, szTmp, ARRAYSIZE(szTmp));
            
            pbrfstg->GetExtraInfo(szTmp, GEI_ORIGIN, (WPARAM)ARRAYSIZE(pbi->szOrigin), (LPARAM)pbi->szOrigin);
            pbrfstg->GetExtraInfo(szTmp, GEI_STATUS, (WPARAM)ARRAYSIZE(pbi->szStatus), (LPARAM)pbi->szStatus);
        }
        _EnterCS();
        
        pbrfstg->Release();
        
        // Check again if we are valid
        if (_hdpa)
        {
            // Is the pidl still around so we can update it?
            BRFINFOHDR bihdr = {0};
            bihdr.pidl = (LPITEMIDLIST)pidf;
            int idpa = DPA_Search(_hdpa, &bihdr, 0, _CompareIDCallBack, (LPARAM)this, DPAS_SORTED);
            if (DPA_ERR != idpa)
            {
                // Yes; update it
                BRFINFOHDR * pbihdr = (BRFINFOHDR *)DPA_FastGetPtr(_hdpa, idpa);
                
                ASSERT(!pbihdr->bi.bUpToDate || !pbihdr->bi.bDetermined)
                    
                // This entry may have been marked for deletion while the
                // expensive calculations were in process above.  Check for
                // it now.
                if (pbihdr->bi.bDeleted)
                {
                    _DeleteCachedName(pidl);
                }
                else
                {
                    pbihdr->bi = *pbi;
                    pbihdr->bi.bUpToDate = TRUE;
                    pbihdr->bi.bDetermined = TRUE;
                    
#ifdef DEBUG
                    if (!pbi->bDetermined)
                        _cUndetermined--;
                    else if (!pbi->bUpToDate)
                        _cStale--;
                    else
                        ASSERT(0);
#endif
                }
            }
        }
    }
    _LeaveCS();
}

// Finds a cached name structure and marks it stale
// WARNING: pidl can be a fully qualified pidl that is comming through as a change notify

void CBriefcase::_CachedNameIsStale(LPCITEMIDLIST pidl, BOOL bDeleted)
{
    _EnterCS();
    {
        if (_hdpa)
        {
            BRFINFOHDR bihdr = {0};
            
            bihdr.pidl = ILFindLastID(pidl);    // hope this is all ours
            int idpa = DPA_Search(_hdpa, &bihdr, 0, _CompareIDCallBack, (LPARAM)this, DPAS_SORTED);
            if (DPA_ERR != idpa)
            {
                // Yes; mark it stale
                BRFINFOHDR *pbihdr = (BRFINFOHDR *)DPA_FastGetPtr(_hdpa, idpa);
            
                // Is this cached name pending calculation yet?
                if (pbihdr->bi.bDetermined && pbihdr->bi.bUpToDate &&
                    !pbihdr->bi.bDeleted)
                {
                    // No; signal the calculation thread
                    if (bDeleted)
                    {
                        pbihdr->bi.bDeleted = TRUE;
#ifdef DEBUG
                        _cDeleted++;
#endif
                    }
                    else
                    {
                        pbihdr->bi.bUpToDate = FALSE;
#ifdef DEBUG
                        _cStale++;
#endif
                    }
                
                    // Notify the calculating thread of an item that is pending
                    // calculation
                    ReleaseSemaphore(_hSemPending, 1, NULL);
                }
                else if (bDeleted)
                {
                    // Yes; but mark for deletion anyway
                    pbihdr->bi.bDeleted = TRUE;
#ifdef DEBUG
                    _cDeleted++;
#endif
                }
            }
        }
    }
    _LeaveCS();
}
  
// Marks all cached name structures stale
void CBriefcase::_AllNamesAreStale()
{
    _EnterCS();
    {
        if (_pbrfstg)
        {
            UINT uFlags;
            // Dirty the briefcase storage cache
            _pbrfstg->Notify(NULL, NOE_DIRTYALL, &uFlags, NULL);
        }
    }
    _LeaveCS();
    
    // (It is important that we call CBriefcase::_Reset outside of the critical
    // section.  Otherwise, we can deadlock when this function is called
    // while the secondary thread is calculating (hit F5 twice in a row).)
    
    // Clear the entire expensive data cache
    _Reset();
}

// Adds a new item with default values to the extra info list
BOOL CBriefcase::_AddCachedName(LPCITEMIDLIST pidl, BRFINFO *pbi)
{
    BOOL bRet = FALSE;
    
    ASSERT(_pbrfstg && _hwndMain && _hMutexDelay);
    
    _EnterCS();
    {
        if (_hdpa)
        {
            BRFINFOHDR * pbihdr = (BRFINFOHDR *)LocalAlloc(LPTR, sizeof(*pbihdr));
            if (pbihdr)
            {
                pbihdr->pidl = ILClone(pidl);
                if (pbihdr->pidl)
                {
                    int idpa = DPA_AppendPtr(_hdpa, pbihdr);
                    if (DPA_ERR != idpa)
                    {
                        pbihdr->bi.bUpToDate = FALSE;
                        pbihdr->bi.bDetermined = FALSE;
                        pbihdr->bi.bDeleted = FALSE;
                        lstrcpy(pbihdr->bi.szOrigin, g_szDetailsUnknown);
                        lstrcpy(pbihdr->bi.szStatus, g_szDetailsUnknown);
#ifdef DEBUG
                        _cUndetermined++;
#endif
                        DPA_Sort(_hdpa, _CompareIDCallBack, (LPARAM)this);
                        
                        // Notify the calculating thread of an item that is pending
                        // calculation
                        ReleaseSemaphore(_hSemPending, 1, NULL);
                        
                        *pbi = pbihdr->bi;
                        bRet = TRUE;
                    }
                    else
                    {
                        // Failed. Cleanup
                        ILFree(pbihdr->pidl);
                        LocalFree((HLOCAL)pbihdr);
                    }
                }
                else
                {
                    // Failed.  Cleanup
                    LocalFree((HLOCAL)pbihdr);
                }
            }
        }
    }
    _LeaveCS();
    
    return bRet;
}

DWORD CBriefcase::_CalcDetailsThread()
{
    HANDLE rghObjPending[2] = {_hEventDie, _hSemPending};
    HANDLE rghObjDelay[2] = {_hEventDie, _hMutexDelay};
    
    while (TRUE)
    {
        // Wait for an end event or for a job to do
        DWORD dwRet = WaitForMultipleObjects(ARRAYSIZE(rghObjPending), rghObjPending, FALSE, INFINITE);
        if (WAIT_OBJECT_0 == dwRet)
        {
            // Exit thread
            break;
        }
        else
        {
#ifdef DEBUG
            _EnterCS();
            {
                ASSERT(0 < _cUndetermined ||
                    0 < _cStale ||
                    0 < _cDeleted);
            }
            _LeaveCS();
#endif
            // Now wait for an end event or for the delay-calculation mutex
            dwRet = WaitForMultipleObjects(ARRAYSIZE(rghObjDelay), rghObjDelay, FALSE, INFINITE);
            if (WAIT_OBJECT_0 == dwRet)
            {
                // Exit thread
                break;
            }
            else
            {
                // Address deleted entries first
                BRFINFOHDR bihdr;
                if (_FindNextState(FNS_DELETED, &bihdr))
                {
                    _DeleteCachedName(bihdr.pidl);
                    ILFree(bihdr.pidl);
                }
                // Calculate undetermined entries before stale entries
                // to fill the view as quickly as possible
                else if (_FindNextState(FNS_UNDETERMINED, &bihdr) ||
                         _FindNextState(FNS_STALE, &bihdr))
                {
                    _CalcCachedName(bihdr.pidl, &bihdr.bi);
#if 1
                    // ugly way
                    ShellFolderView_RefreshObject(_hwndMain, &bihdr.pidl);
#else
                    // right way, but we don't have _punkSite, here, that is on another thread!
                    IShellFolderView *psfv;
                    if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_SFolderView, IID_PPV_ARG(IShellFolderView, &psfv))))
                    {
                        UINT uScratch;
                        psfv->RefreshObject(&bihdr.pidl, &uScratch);
                        psfv->Release();
                    }
#endif
                    ILFree(bihdr.pidl);
                }
                else
                {
                    ASSERT(0);      // Should never get here
                }
                
                ReleaseMutex(_hMutexDelay);
            }
        }
    }
    return 0;
}

DWORD CALLBACK CBriefcase::_CalcDetailsThreadProc(void *pv)
{
    return ((CBriefcase *)pv)->_CalcDetailsThread();
}

// IShellFolder2::GetDetailsOf

STDMETHODIMP CBriefcase::GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails)
{
    HRESULT hr = S_OK;
    TCHAR szTemp[MAX_PATH];
    LPCIDFOLDER pidf = _IsValidID(pidl);

    pDetails->str.uType = STRRET_CSTR;
    pDetails->str.cStr[0] = 0;
    
    if (!pidf)
    {
        return GetDetailsOfInfo(s_briefcase_cols, ARRAYSIZE(s_briefcase_cols), iColumn, pDetails);
    }
    
    switch (iColumn)
    {
    case ICOL_BRIEFCASE_NAME:
        _CopyName(pidf, szTemp, ARRAYSIZE(szTemp));
        hr = StringToStrRet(szTemp, &pDetails->str);
        break;
        
    case ICOL_BRIEFCASE_ORIGIN:
    case ICOL_BRIEFCASE_STATUS: 
        // only works if the view callback has set us up for this
        if (_pbrfstg)
        {
            BRFINFO bi;

            // Did we find extra info for this file or
            // was the new item added to the extra info list?
            if (_FindCachedName(pidl, &bi) ||
                _AddCachedName(pidl, &bi))
            {
                LPTSTR psz = ICOL_BRIEFCASE_ORIGIN == iColumn ? bi.szOrigin : bi.szStatus;
                hr = StringToStrRet(psz, &pDetails->str);
            }
        }
        break;
        
    case ICOL_BRIEFCASE_SIZE:
        if (!_IsFolder(pidf))
        {
            StrFormatKBSize(pidf->dwSize, szTemp, ARRAYSIZE(szTemp));
            hr = StringToStrRet(szTemp, &pDetails->str);
        }
        break;
        
    case ICOL_BRIEFCASE_TYPE:
        _GetTypeNameBuf(pidf, szTemp, ARRAYSIZE(szTemp));
        hr = StringToStrRet(szTemp, &pDetails->str);
        break;
        
    case ICOL_BRIEFCASE_MODIFIED:
        DosTimeToDateTimeString(pidf->dateModified, pidf->timeModified, szTemp, ARRAYSIZE(szTemp), pDetails->fmt & LVCFMT_DIRECTION_MASK);
        hr = StringToStrRet(szTemp, &pDetails->str);
        break;
    }
    return hr;
}

// IShellFolder2::MapColumnToSCID

STDMETHODIMP CBriefcase::MapColumnToSCID(UINT iColumn, SHCOLUMNID *pscid)
{
    return MapColumnToSCIDImpl(s_briefcase_cols, ARRAYSIZE(s_briefcase_cols), iColumn, pscid);
}

// IShellFolder::CompareIDs

STDMETHODIMP CBriefcase::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    LPCIDFOLDER pidf1 = _IsValidID(pidl1);
    LPCIDFOLDER pidf2 = _IsValidID(pidl2);
    
    if (!pidf1 || !pidf2)
    {
        ASSERT(0);
        return E_INVALIDARG;
    }
    
    HRESULT hr = _CompareFolderness(pidf1, pidf2);
    if (hr != ResultFromShort(0))
        return hr;
    
    switch (lParam & SHCIDS_COLUMNMASK)
    {
    case ICOL_BRIEFCASE_SIZE:
        if (pidf1->dwSize < pidf2->dwSize)
            return ResultFromShort(-1);
        if (pidf1->dwSize > pidf2->dwSize)
            return ResultFromShort(1);
        goto DoDefault;
        
    case ICOL_BRIEFCASE_TYPE:
        hr = _CompareFileTypes(pidf1, pidf2);
        if (!hr)
            goto DoDefault;
        break;
        
    case ICOL_BRIEFCASE_MODIFIED:
        hr = _CompareModifiedDate(pidf1, pidf2);
        if (!hr)
            goto DoDefault;
        break;
        
    case ICOL_BRIEFCASE_NAME:
        // We need to treat this differently from others bacause
        // pidf1/2 might not be simple.
        hr = CFSFolder::_CompareNames(pidf1, pidf2, TRUE, FALSE);
        
        // REVIEW: (Possible performance gain with some extra code)
        //   We should probably avoid bindings by walking down
        //  the IDList here instead of calling this helper function.
        //
        if (hr == ResultFromShort(0))
        {
            hr = ILCompareRelIDs((IShellFolder *)this, pidl1, pidl2, lParam);
        }
        goto DoDefaultModification;
        
    case ICOL_BRIEFCASE_ORIGIN:
    case ICOL_BRIEFCASE_STATUS: 
        {
            BRFINFO bi1, bi2;
        
            BOOL bVal1 = _FindCachedName(pidl1, &bi1);
            BOOL bVal2 = _FindCachedName(pidl2, &bi2);
            // Do we have this info in our cache?
            if (!bVal1 || !bVal2)
            {
                // No; one or both of them are missing.  Have unknowns gravitate
                // to the bottom of the list.
                // (Don't bother adding them)
            
                if (!bVal1 && !bVal2)
                    hr = ResultFromShort(0);
                else if (!bVal1)
                    hr = ResultFromShort(1);
                else
                    hr = ResultFromShort(-1);
            }
            else
            {
                // Found the info; do a comparison
                if (ICOL_BRIEFCASE_ORIGIN == (lParam & SHCIDS_COLUMNMASK))
                {
                    hr = ResultFromShort(lstrcmp(bi1.szOrigin, bi2.szOrigin));
                }
                else
                {
                    ASSERT(ICOL_BRIEFCASE_STATUS == (lParam & SHCIDS_COLUMNMASK));
                    hr = ResultFromShort(lstrcmp(bi1.szStatus, bi2.szStatus));
                }
            }
        }
        break;
        
    default:
DoDefault:
        // Sort it based on the primary (long) name -- ignore case.
        {
            TCHAR szName1[MAX_PATH], szName2[MAX_PATH];

            _CopyName(pidf1, szName1, ARRAYSIZE(szName1));
            _CopyName(pidf2, szName2, ARRAYSIZE(szName2));

            hr = ResultFromShort(lstrcmpi(szName1, szName2));
        }

DoDefaultModification:
        if (hr == S_OK && (lParam & SHCIDS_ALLFIELDS)) 
        {
            // Must sort by modified date to pick up any file changes!
            hr = _CompareModifiedDate(pidf1, pidf2);
            if (!hr)
                hr = _CompareAttribs(pidf1, pidf2);
        }
    }
    
    return hr;
}


// This function creates an instance of IShellView.

HRESULT CBriefcase::_CreateView(HWND hwnd, IShellView **ppsv)
{
    *ppsv = NULL;     // assume failure

    HRESULT hr;
    CBriefcaseViewCB *pvcb = new CBriefcaseViewCB(this);
    if (pvcb)
    {
        hr = pvcb->_InitStgForDetails();
        if (SUCCEEDED(hr))
        {
            SFV_CREATE sSFV = {0};

            hr = pvcb->QueryInterface(IID_PPV_ARG(IShellFolderViewCB, &sSFV.psfvcb));
            if (SUCCEEDED(hr))
            {
                sSFV.cbSize = sizeof(sSFV);
                sSFV.pshf   = (IShellFolder *)this;

                hr = SHCreateShellFolderView(&sSFV, ppsv);
            }
        }
        pvcb->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

// IShellFolder::CreateViewObject

STDMETHODIMP CBriefcase::CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
{
    HRESULT hr;

    if (IsEqualIID(riid, IID_IShellView))
    {
        hr = _CreateView(hwnd, (IShellView **)ppv);
    }
    else
    {
        // delegate to base class
        hr = CFSFolder::CreateViewObject(hwnd, riid, ppv);
    }

    ASSERT(FAILED(hr) ? (NULL == *ppv) : TRUE);
    return hr;
}


// IShellFolder::GetAttributesOf

STDMETHODIMP CBriefcase::GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG * prgfInOut)
{
    // Validate this pidl?
    if (*prgfInOut & SFGAO_VALIDATE)
    {
        // Yes; dirty the briefcase storage entry by sending an update
        // notification
        DebugMsg(DM_TRACE, TEXT("Briefcase: Receiving F5, dirty entire briefcase storage"));
        
        _AllNamesAreStale();
    }
    
    // delegate to base
    return CFSFolder::GetAttributesOf(cidl, apidl, prgfInOut);
}

// IShellFolder::GetUIObjectOf

STDMETHODIMP CBriefcase::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl, 
                                       REFIID riid, UINT *prgfInOut, void **ppv)
{
    HRESULT hr;

    if (cidl > 0 && IsEqualIID(riid, IID_IDataObject))
    {
        // Create an IDataObject interface instance with our
        // own vtable because we support the CFSTR_BRIEFOBJECT clipboard format
        hr = CBrfData_CreateDataObj(_pidl, cidl, (LPCITEMIDLIST *)apidl, (IDataObject **)ppv);
    }
    else
    {
        // delegate to base class
        hr = CFSFolder::GetUIObjectOf(hwnd, cidl, apidl, riid, prgfInOut, ppv);
    }
    return hr;
}

// CFSBrfFolder constructor
STDAPI CFSBrfFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr;
    CBriefcase *pbf = new CBriefcase(punkOuter);
    if (pbf)
    {
        hr = pbf->QueryInterface(riid, ppv);
        pbf->Release();
    }
    else
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}

const TBBUTTON c_tbBrfCase[] = {
    { 0, FSIDM_UPDATEALL,       TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0L, -1 },
    { 1, FSIDM_UPDATESELECTION, 0,               TBSTYLE_BUTTON, {0,0}, 0L, -1 },
    { 0,  0,                    TBSTATE_ENABLED, TBSTYLE_SEP   , {0,0}, 0L, -1 },
    };


#define BRFVIEW_EVENTS \
    SHCNE_DISKEVENTS | \
    SHCNE_ASSOCCHANGED | \
    SHCNE_GLOBALEVENTS

HRESULT CBriefcaseViewCB::OnWINDOWCREATED(DWORD pv, HWND hwndView)
{
    SHChangeNotifyEntry fsne;

    ASSERT(_pbrfstg && _hwndMain && _hMutexDelay);   // from the init call

    // view hands folder info needed to details (status, sync path)
    _pfolder->_InitDetailsInfoAndThread(_pbrfstg, _hwndMain, _hMutexDelay);

    // Register an extra SHChangeNotifyRegister for our pidl to try to catch things
    // like UpdateDir 
    fsne.pidl = _FolderPidl();
    fsne.fRecursive = FALSE;
    _uSCNRExtra = SHChangeNotifyRegister(hwndView, SHCNRF_NewDelivery | SHCNRF_ShellLevel | SHCNRF_InterruptLevel,
                                         SHCNE_DISKEVENTS, WM_DSV_FSNOTIFY, 1, &fsne);
    return S_OK;
}

HRESULT CBriefcaseViewCB::OnWINDOWDESTROY(DWORD pv, HWND wP)
{
    _pfolder->_Free();

    // need to release pbrfstg as well
    if (_pbrfstg)
    {
        _pbrfstg->Release();
        _pbrfstg = NULL;

        _hMutexDelay = NULL;    // invalidate our alias
    }

    if (_uSCNRExtra)
    {
        SHChangeNotifyDeregister(_uSCNRExtra);
        _uSCNRExtra = 0;
    }

    return S_OK;
}

HRESULT CBriefcaseViewCB::OnMergeMenu(DWORD pv, QCMINFO *pinfo)
{
    // Merge the briefcase menu onto the menu that CDefView created.
    if (pinfo->hmenu)
    {
        HMENU hmSync = LoadMenu(HINST_THISDLL, MAKEINTRESOURCE(POPUP_BRIEFCASE));
        if (hmSync)
        {
            Shell_MergeMenus(pinfo->hmenu, hmSync, pinfo->indexMenu,
                pinfo->idCmdFirst, pinfo->idCmdLast, MM_SUBMENUSHAVEIDS);
            DestroyMenu(hmSync);
        }
    }
    
    return S_OK;
}

HRESULT CBriefcaseViewCB::_GetSelectedObjects(IDataObject **ppdtobj)
{
    IFolderView *pfv;
    HRESULT hr = IUnknown_QueryService(_punkSite, SID_SFolderView, IID_PPV_ARG(IFolderView, &pfv));
    if (SUCCEEDED(hr))
    {
        hr = pfv->Items(SVGIO_SELECTION, IID_PPV_ARG(IDataObject, ppdtobj));
        pfv->Release();
    }
    return hr;
}

HRESULT CBriefcaseViewCB::OnINVOKECOMMAND(DWORD pv, UINT uID)
{
    IDataObject *pdtobj;
    
    switch (uID)
    {
    case FSIDM_UPDATEALL:
        // Update the entire briefcase
        
        if (SUCCEEDED(SHGetUIObjectFromFullPIDL(_pidlRoot, NULL, IID_PPV_ARG(IDataObject, &pdtobj))))
        {
            _pbrfstg->UpdateObject(pdtobj, _hwndMain);
            pdtobj->Release();
        }
        break;
        
    case FSIDM_UPDATESELECTION:
        // Update the selected objects
        if (SUCCEEDED(_GetSelectedObjects(&pdtobj)))
        {
            _pbrfstg->UpdateObject(pdtobj, _hwndMain);
            pdtobj->Release();
        }
        break;
        
    case FSIDM_SPLIT:
        // Split the selected objects
        if (SUCCEEDED(_GetSelectedObjects(&pdtobj)))
        {
            _pbrfstg->ReleaseObject(pdtobj, _hwndMain);
            pdtobj->Release();
        }
        break;
    }
    return S_OK;
}

HRESULT CBriefcaseViewCB::OnGetHelpOrTooltipText(BOOL bHelp, UINT wPl, UINT cch, LPTSTR psz)
{
    LoadString(HINST_THISDLL, wPl + (bHelp ? IDS_MH_FSIDM_FIRST : IDS_TT_FSIDM_FIRST), psz, cch);
    return S_OK;
}

int CBriefcaseViewCB::_GetSelectedCount()
{
    int cItems = 0;
    IFolderView *pfv;
    if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_SFolderView, IID_PPV_ARG(IFolderView, &pfv))))
    {
        pfv->ItemCount(SVGIO_SELECTION, &cItems);
        pfv->Release();
    }
    return cItems;
}

HRESULT CBriefcaseViewCB::OnINITMENUPOPUP(DWORD pv, UINT idCmdFirst, UINT nIndex, HMENU hmenu)
{
    BOOL bEnabled = _GetSelectedCount() > 0;
    EnableMenuItem(hmenu, idCmdFirst+FSIDM_UPDATESELECTION, bEnabled ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(hmenu, idCmdFirst+FSIDM_SPLIT, bEnabled ? MF_ENABLED : MF_GRAYED);    
    return S_OK;
}

HRESULT CBriefcaseViewCB::OnGETBUTTONINFO(DWORD pv, TBINFO* ptbinfo)
{
    ptbinfo->cbuttons = ARRAYSIZE(c_tbBrfCase);
    ptbinfo->uFlags = TBIF_PREPEND;
    return S_OK;
}

HRESULT CBriefcaseViewCB::OnGETBUTTONS(DWORD pv, UINT idCmdFirst, UINT wPh, TBBUTTON *ptbbutton)
{
    IShellBrowser* psb;
    HRESULT hr = IUnknown_QueryService(_punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psb));
    if (SUCCEEDED(hr))
    {
        LRESULT iBtnOffset;
        TBADDBITMAP ab;
    
        // add the toolbar button bitmap, get it's offset
        ab.hInst = HINST_THISDLL;
        ab.nID   = IDB_BRF_TB_SMALL;        // std bitmaps
        psb->SendControlMsg(FCW_TOOLBAR, TB_ADDBITMAP, 2, (LPARAM)&ab, &iBtnOffset);
    
        for (int i = 0; i < ARRAYSIZE(c_tbBrfCase); i++)
        {
            ptbbutton[i] = c_tbBrfCase[i];
        
            if (!(c_tbBrfCase[i].fsStyle & TBSTYLE_SEP))
            {
                ptbbutton[i].idCommand += idCmdFirst;
                ptbbutton[i].iBitmap += (int) iBtnOffset;
            }
        }
        psb->Release();
    }
    return S_OK;
}

HRESULT CBriefcaseViewCB::OnSELCHANGE(DWORD pv, UINT idCmdFirst, UINT wPh, SFVM_SELCHANGE_DATA*lP)
{
    IShellBrowser* psb;
    HRESULT hr = IUnknown_QueryService(_punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psb));
    if (SUCCEEDED(hr))
    {
        psb->SendControlMsg(FCW_TOOLBAR, TB_ENABLEBUTTON,
            idCmdFirst + FSIDM_UPDATESELECTION,
            (LPARAM)(_GetSelectedCount() > 0), NULL);
        psb->Release();
    }
    return E_FAIL;     // (we did not update the status area)
}

HRESULT CBriefcaseViewCB::OnQUERYFSNOTIFY(DWORD pv, SHChangeNotifyEntry *pfsne)
{
    // Register to receive global events
    pfsne->pidl = NULL;
    pfsne->fRecursive = TRUE;
    
    return NOERROR;
}

HRESULT CBriefcaseViewCB::_HandleFSNotifyForDefView(LPARAM lEvent, LPCITEMIDLIST * ppidl, LPTSTR pszBuf)
{
    HRESULT hr;
    
    switch (lEvent)
    {
    case SHCNE_RENAMEITEM:
    case SHCNE_RENAMEFOLDER:
        if (!ILIsParent(_FolderPidl(), ppidl[0], TRUE))
        {
            // move to this folder
            hr = _HandleFSNotifyForDefView(SHCNE_CREATE, &ppidl[1], pszBuf);
        }
        else if (!ILIsParent(_FolderPidl(), ppidl[1], TRUE))
        {
            // move from this folder
            hr = _HandleFSNotifyForDefView(SHCNE_DELETE, &ppidl[0], pszBuf);
        }
        else
        {
            // have the defview handle it
            _pfolder->_CachedNameIsStale(ppidl[0], TRUE);
            hr = NOERROR;
        }
        break;
        
    case SHCNE_DELETE:
    case SHCNE_RMDIR:
        _pfolder->_CachedNameIsStale(ppidl[0], TRUE);
        hr = NOERROR;
        break;
        
    default:
        hr = NOERROR;
        break;
    }
    
    return hr;
}

// Converts a shell change notify event to a briefcase storage event.
LONG NOEFromSHCNE(LPARAM lEvent)
{
    switch (lEvent)
    {
    case SHCNE_RENAMEITEM:      return NOE_RENAME;
    case SHCNE_RENAMEFOLDER:    return NOE_RENAMEFOLDER;
    case SHCNE_CREATE:          return NOE_CREATE;
    case SHCNE_MKDIR:           return NOE_CREATEFOLDER;
    case SHCNE_DELETE:          return NOE_DELETE;
    case SHCNE_RMDIR:           return NOE_DELETEFOLDER;
    case SHCNE_UPDATEITEM:      return NOE_DIRTY;
    case SHCNE_UPDATEDIR:       return NOE_DIRTYFOLDER;
    default:                    return 0;
    }
}

HRESULT CBriefcaseViewCB::OnFSNOTIFY(DWORD pv, LPCITEMIDLIST *ppidl, LPARAM lEvent)
{
    HRESULT hr;
    TCHAR szPath[MAX_PATH * 2];
    
    // we are in the process of being freed, but changenotify's can still come in because we are not freed atomically
    if (!_pbrfstg)
    {
        return S_FALSE;
    }

    if (lEvent == SHCNE_UPDATEIMAGE || lEvent == SHCNE_FREESPACE)
    {
        return S_FALSE;
    }
    
    if (ppidl && !ILIsEmpty(ppidl[0]) && SHGetPathFromIDList(ppidl[0], szPath))
    {
        UINT uFlags;
        LONG lEventNOE;
        
        if ((SHCNE_RENAMEFOLDER == lEvent) || (SHCNE_RENAMEITEM == lEvent))
        {
            ASSERT(ppidl[1]);
            ASSERT(ARRAYSIZE(szPath) >= lstrlen(szPath)*2);    // rough estimate
            
            // Tack the new name after the old name, separated by the null
            SHGetPathFromIDList(ppidl[1], &szPath[lstrlen(szPath)+1]);
        }
        
        // Tell the briefcase the path has potentially changed
        lEventNOE = NOEFromSHCNE(lEvent);
        _pbrfstg->Notify(szPath, lEventNOE, &uFlags, _hwndMain);
        
        // Was this item marked?
        if (uFlags & NF_ITEMMARKED)
        {
            // Yes; mark it stale in the expensive cache
            _pfolder->_CachedNameIsStale(ppidl[0], FALSE);
        }
        
        // Does the window need to be refreshed?
        if (uFlags & NF_REDRAWWINDOW)
        {
            // Yes
            IShellView *psv;
            if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_SFolderView, IID_PPV_ARG(IShellView, &psv))))
            {
                psv->Refresh();
                psv->Release();
            }
        }
        
        // Did this event occur in this folder?
        if (NULL == ppidl ||
            ILIsParent(_FolderPidl(), ppidl[0], TRUE) ||
            (((SHCNE_RENAMEITEM == lEvent) || (SHCNE_RENAMEFOLDER == lEvent)) && ILIsParent(_FolderPidl(), ppidl[1], TRUE)) ||
            (SHCNE_UPDATEDIR == lEvent && ILIsEqual(_FolderPidl(), ppidl[0])))
        {
            // Yes; deal with it
            hr = _HandleFSNotifyForDefView(lEvent, ppidl, szPath);
        }
        else
        {
            // No
            hr = S_FALSE;
        }
    }
    else
    {
        // ASSERT(0);
        hr = S_FALSE;
    }
    return hr;
}

HRESULT CBriefcaseViewCB::OnQUERYCOPYHOOK(DWORD pv)
{
    return S_OK;
}

HRESULT CBriefcaseViewCB::OnNOTIFYCOPYHOOK(DWORD pv, COPYHOOKINFO *pchi)
{
    HRESULT hr = NOERROR;
    
    // Is this a pertinent operation?
    if (FO_MOVE == pchi->wFunc ||
        FO_RENAME == pchi->wFunc ||
        FO_DELETE == pchi->wFunc)
    {
        // Yes; don't allow the briefcase root or a parent folder to get moved
        // while the briefcase is still open.  (The database is locked while
        // the briefcase is open, and will fail the move/rename operation
        // in an ugly way.)
        LPITEMIDLIST pidl = ILCreateFromPath(pchi->pszSrcFile);
        if (pidl)
        {
            // Is the folder that is being moved or renamed a parent or equal
            // of the Briefcase root?
            if (ILIsParent(pidl, _pidlRoot, FALSE) ||
                ILIsEqual(pidl, _pidlRoot))
            {
                // Yes; don't allow it until the briefcase is closed.
                int ids;
                
                if (FO_MOVE == pchi->wFunc ||
                    FO_RENAME == pchi->wFunc)
                {
                    ids = IDS_MOVEBRIEFCASE;
                }
                else
                {
                    ASSERT(FO_DELETE == pchi->wFunc);
                    ids = IDS_DELETEBRIEFCASE;
                }
                
                ShellMessageBox(HINST_THISDLL, _hwndMain,
                    MAKEINTRESOURCE(ids), NULL, MB_OK | MB_ICONINFORMATION);
                hr = IDCANCEL;
            }
            ILFree(pidl);
        }
    }
    return hr;
}

HRESULT CBriefcaseViewCB::OnINSERTITEM(DWORD pv, LPCITEMIDLIST pidl)
{
    HRESULT hr;
    TCHAR szPath[MAX_PATH];
    
    if (SHGetPathFromIDList(pidl, szPath))
    {
        // Always hide the desktop.ini and the database file.
        LPTSTR pszName = PathFindFileName(szPath);
        
        if (0 == lstrcmpi(pszName, c_szDesktopIni) ||
            0 == lstrcmpi(pszName, _szDBName))
            hr = S_FALSE; // don't add
        else
            hr = S_OK;
    }
    else
        hr = S_OK;        // Let it be added...
    
    return hr;
}

HRESULT CBriefcaseViewCB::OnDEFVIEWMODE(DWORD pv, FOLDERVIEWMODE*lP)
{
    *lP = FVM_DETAILS;
    return S_OK;
}

HRESULT CBriefcaseViewCB::OnGetHelpTopic(DWORD pv, SFVM_HELPTOPIC_DATA * phtd)
{
    if (IsOS(OS_ANYSERVER))
    {
        StrCpyW(phtd->wszHelpFile, L"brief.chm");
    }
    else
    {
        StrCpyW(phtd->wszHelpTopic, L"hcp://services/subsite?node=Unmapped/Briefcase");
    }
    return S_OK;
}

CBriefcaseViewCB::CBriefcaseViewCB(CBriefcase *pfolder) : CBaseShellFolderViewCB(pfolder->_pidl, BRFVIEW_EVENTS), _pfolder(pfolder)
{ 
    _pfolder->AddRef();
}

CBriefcaseViewCB::~CBriefcaseViewCB()
{
    if (_pbrfstg)
        _pbrfstg->Release();

    if (_pidlRoot)
        ILFree(_pidlRoot);

    _pfolder->Release();
}

HRESULT CBriefcaseViewCB::_InitStgForDetails()
{
    ASSERT(NULL == _pbrfstg);

    HRESULT hr = CreateBrfStgFromIDList(_FolderPidl(), _hwndMain, &_pbrfstg);
    if (SUCCEEDED(hr))
    {
        ASSERT(NULL == _hMutexDelay);
        _pbrfstg->GetExtraInfo(NULL, GEI_DELAYHANDLE, 0, (LPARAM)&_hMutexDelay);
        ASSERT(0 == _szDBName[0]);
        _pbrfstg->GetExtraInfo(NULL, GEI_DATABASENAME, ARRAYSIZE(_szDBName), (LPARAM)_szDBName);

        TCHAR szPath[MAX_PATH];
        hr = _pbrfstg->GetExtraInfo(NULL, GEI_ROOT, (WPARAM)ARRAYSIZE(szPath), (LPARAM)szPath);
        if (SUCCEEDED(hr))
            hr = SHILCreateFromPath(szPath, &_pidlRoot, NULL);
    }
    return hr;
}

STDMETHODIMP CBriefcaseViewCB::RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    HANDLE_MSG(0, SFVM_WINDOWCREATED, OnWINDOWCREATED);
    HANDLE_MSG(0, SFVM_WINDOWDESTROY, OnWINDOWDESTROY);
    HANDLE_MSG(0, SFVM_MERGEMENU, OnMergeMenu);
    HANDLE_MSG(0, SFVM_INVOKECOMMAND, OnINVOKECOMMAND);
    HANDLE_MSG(TRUE , SFVM_GETHELPTEXT   , OnGetHelpOrTooltipText);
    HANDLE_MSG(FALSE, SFVM_GETTOOLTIPTEXT, OnGetHelpOrTooltipText);
    HANDLE_MSG(0, SFVM_INITMENUPOPUP, OnINITMENUPOPUP);
    HANDLE_MSG(0, SFVM_GETBUTTONINFO, OnGETBUTTONINFO);
    HANDLE_MSG(0, SFVM_GETBUTTONS, OnGETBUTTONS);
    HANDLE_MSG(0, SFVM_SELCHANGE, OnSELCHANGE);
    HANDLE_MSG(0, SFVM_QUERYFSNOTIFY, OnQUERYFSNOTIFY);
    HANDLE_MSG(0, SFVM_FSNOTIFY, OnFSNOTIFY);
    HANDLE_MSG(0, SFVM_QUERYCOPYHOOK, OnQUERYCOPYHOOK);
    HANDLE_MSG(0, SFVM_NOTIFYCOPYHOOK, OnNOTIFYCOPYHOOK);
    HANDLE_MSG(0, SFVM_INSERTITEM, OnINSERTITEM);
    HANDLE_MSG(0, SFVM_DEFVIEWMODE, OnDEFVIEWMODE);
    HANDLE_MSG(0, SFVM_ADDPROPERTYPAGES, SFVCB_OnAddPropertyPages);
    HANDLE_MSG(0, SFVM_GETHELPTOPIC, OnGetHelpTopic);
    HANDLE_MSG(0, SFVM_GETWEBVIEWLAYOUT, OnGetWebViewLayout);
    HANDLE_MSG(0, SFVM_GETWEBVIEWCONTENT, OnGetWebViewContent);
    HANDLE_MSG(0, SFVM_GETWEBVIEWTASKS, OnGetWebViewTasks);
    HANDLE_MSG(0, SFVM_DELAYWINDOWCREATE, OnDELAYWINDOWCREATE);

    default:
        return E_FAIL;
    }

    return NOERROR;
}


STDAPI CreateBrfStgFromPath(LPCTSTR pszPath, HWND hwnd, IBriefcaseStg **ppbs)
{
    IBriefcaseStg *pbrfstg;
    HRESULT hr = CoCreateInstance(CLSID_Briefcase, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IBriefcaseStg, &pbrfstg));
    if (SUCCEEDED(hr))
    {
        hr = pbrfstg->Initialize(pszPath, hwnd);
        if (SUCCEEDED(hr))
        {
            hr = pbrfstg->QueryInterface(IID_PPV_ARG(IBriefcaseStg, ppbs));
        }
        pbrfstg->Release();
    }
    return hr;
}

STDAPI CreateBrfStgFromIDList(LPCITEMIDLIST pidl, HWND hwnd, IBriefcaseStg **ppbs)
{
    HRESULT hr = E_FAIL;
    
    // Create an instance of IBriefcaseStg
    TCHAR szFolder[MAX_PATH];
    if (SHGetPathFromIDList(pidl, szFolder))
    {
        hr = CreateBrfStgFromPath(szFolder, hwnd, ppbs);
    }
    return hr;
}

HRESULT CBriefcaseViewCB::OnGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData)
{
    ZeroMemory(pData, sizeof(*pData));
    pData->dwLayout = SFVMWVL_NORMAL | SFVMWVL_FILES;
    return S_OK;
}

HRESULT CBriefcaseViewCB::_OnUpdate(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CBriefcaseViewCB* pThis = (CBriefcaseViewCB*)(void*)pv;
    IDataObject *pdo;
    HRESULT hr = S_OK;

    if (!psiItemArray)
    {
        IFolderView *pfv;
        hr = IUnknown_QueryService(pThis->_punkSite, SID_SFolderView, IID_PPV_ARG(IFolderView, &pfv));
        if (SUCCEEDED(hr))
        {
            hr = pfv->Items(SVGIO_ALLVIEW, IID_PPV_ARG(IDataObject, &pdo));
            pfv->Release();
        }
    }
    else
    {
        hr = psiItemArray->BindToHandler(NULL, BHID_DataObject, IID_PPV_ARG(IDataObject, &pdo));
    }

    if (SUCCEEDED(hr))
    {
        hr = SHInvokeCommandOnDataObject(pThis->_hwndMain, NULL, pdo, 0, "update");
        pdo->Release();
    }

    return hr;
}

const WVTASKITEM c_BriefcaseTaskHeader = WVTI_HEADER(L"shell32.dll", IDS_HEADER_BRIEFCASE, IDS_HEADER_BRIEFCASE_TT);
const WVTASKITEM c_BriefcaseTaskList[] =
{
    WVTI_ENTRY_ALL_TITLE(CLSID_NULL, L"shell32.dll", IDS_TASK_UPDATE_ALL, IDS_TASK_UPDATE_ITEM, IDS_TASK_UPDATE_ITEM, IDS_TASK_UPDATE_ITEMS, IDS_TASK_UPDATE_ITEM_TT, IDI_TASK_UPDATEITEMS, NULL, CBriefcaseViewCB::_OnUpdate),
};

HRESULT CBriefcaseViewCB::OnGetWebViewContent(DWORD pv, SFVM_WEBVIEW_CONTENT_DATA* pData)
{
    ZeroMemory(pData, sizeof(*pData));

    Create_IUIElement(&c_BriefcaseTaskHeader, &(pData->pSpecialTaskHeader));

    return S_OK;
}

HRESULT CBriefcaseViewCB::OnGetWebViewTasks(DWORD pv, SFVM_WEBVIEW_TASKSECTION_DATA* pTasks)
{
    ZeroMemory(pTasks, sizeof(*pTasks));

    Create_IEnumUICommand((IUnknown*)(void*)this, c_BriefcaseTaskList, ARRAYSIZE(c_BriefcaseTaskList), &pTasks->penumSpecialTasks);

    return S_OK;
}

HRESULT CBriefcaseViewCB::OnDELAYWINDOWCREATE(DWORD pv, HWND hwnd)
{
    TCHAR szPath[MAX_PATH];

    _pfolder->_GetPath(szPath);
    PathAppend(szPath, c_szDesktopIni);
    BOOL bRunWizard = GetPrivateProfileInt(STRINI_CLASSINFO, TEXT("RunWizard"), 0, szPath);
    
    // Run the wizard?
    if (bRunWizard)
    {
        // work around old bug where FILE_ATTRIBUTE_READONLY was set
        SetFileAttributes(szPath, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);

        // Delete the .ini entry
        WritePrivateProfileString(STRINI_CLASSINFO, TEXT("RunWizard"), NULL, szPath);

        SHRunDLLThread(hwnd, TEXT("SYNCUI.DLL,Briefcase_Intro"), SW_SHOW);
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\category.cpp ===
#include "shellprv.h"
#include "category.h"
#include "prop.h"
#include "ids.h"
#include "clsobj.h"
#include "comcat.h" // for IEnumGUID
#include "ole2dup.h"

#define GROUPID_UNSPECIFIED (-10)
#define GROUPID_FOLDER      (-11)
#define GROUPID_OTHER       (-12)

#define STRINGID_FROM_GROUPID(id)  ((id) == GROUPID_UNSPECIFIED)? IDS_UNSPECIFIED : (((id) == GROUPID_FOLDER)?IDS_GROUPFOLDERS: IDS_GROUPOTHERCHAR)

typedef struct tagCATCACHE
{
    GUID guid;
    SHCOLUMNID scid;
    IUnknown* punk;
} CATCACHE;

// {3E373E22-DA99-4cb7-A886-754EAE984CB4}
static const GUID CLSID_DetailCategorizer = 
{ 0x3e373e22, 0xda99, 0x4cb7, { 0xa8, 0x86, 0x75, 0x4e, 0xae, 0x98, 0x4c, 0xb4 } };



class CTimeCategorizer : public ICategorizer,
                         public IShellExtInit
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ICategorizer
    STDMETHODIMP GetDescription(LPWSTR pszDesc, UINT cch);
    STDMETHODIMP GetCategory(UINT cidl, LPCITEMIDLIST * apidl, DWORD* rgCategoryIds);
    STDMETHODIMP GetCategoryInfo(DWORD dwCategoryId, CATEGORY_INFO* pci);
    STDMETHODIMP CompareCategory(CATSORT_FLAGS csfFlags, DWORD dwCategoryId1, DWORD dwCategoryId2);

    // IShellExtInit
    STDMETHODIMP Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdobj, HKEY hkeyProgID);

    CTimeCategorizer(const SHCOLUMNID* pscid, IShellFolder2* psf);
    CTimeCategorizer();
private:
    ~CTimeCategorizer();
    long _cRef;
    IShellFolder2* _psf;
    SHCOLUMNID     _scid;
};

class CSizeCategorizer : public ICategorizer,
                         public IShellExtInit
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ICategorizer
    STDMETHODIMP GetDescription(LPWSTR pszDesc, UINT cch);
    STDMETHODIMP GetCategory(UINT cidl, LPCITEMIDLIST * apidl, DWORD* rgCategoryIds);
    STDMETHODIMP GetCategoryInfo(DWORD dwCategoryId, CATEGORY_INFO* pci);
    STDMETHODIMP CompareCategory(CATSORT_FLAGS csfFlags, DWORD dwCategoryId1, DWORD dwCategoryId2);

    // IShellExtInit
    STDMETHODIMP Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdobj, HKEY hkeyProgID);

    CSizeCategorizer(IShellFolder2* psf);
    CSizeCategorizer(BOOL fLarge);
private:
    ~CSizeCategorizer();
    long _cRef;
    IShellFolder2* _psf;
    BOOL _fLarge;
};

class CDriveTypeCategorizer : public ICategorizer,
                              public IShellExtInit
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ICategorizer
    STDMETHODIMP GetDescription(LPWSTR pszDesc, UINT cch);
    STDMETHODIMP GetCategory(UINT cidl, LPCITEMIDLIST * apidl, DWORD* rgCategoryIds);
    STDMETHODIMP GetCategoryInfo(DWORD dwCategoryId, CATEGORY_INFO* pci);
    STDMETHODIMP CompareCategory(CATSORT_FLAGS csfFlags, DWORD dwCategoryId1, DWORD dwCategoryId2);

    // IShellExtInit
    STDMETHODIMP Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdobj, HKEY hkeyProgID);

    CDriveTypeCategorizer(IShellFolder2* psf);
    CDriveTypeCategorizer();
private:
    ~CDriveTypeCategorizer();
    long _cRef;
    IShellFolder2* _psf;
};

class CAlphaCategorizer : public ICategorizer
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ICategorizer
    STDMETHODIMP GetDescription(LPWSTR pszDesc, UINT cch);
    STDMETHODIMP GetCategory(UINT cidl, LPCITEMIDLIST * apidl, DWORD* rgCategoryIds);
    STDMETHODIMP GetCategoryInfo(DWORD dwCategoryId, CATEGORY_INFO* pci);
    STDMETHODIMP CompareCategory(CATSORT_FLAGS csfFlags, DWORD dwCategoryId1, DWORD dwCategoryId2);

    CAlphaCategorizer(IShellFolder2* psf);
private:
    ~CAlphaCategorizer();
    long _cRef;
    IShellFolder2* _psf;
};

class CFreeSpaceCategorizer : public ICategorizer,
                              public IShellExtInit
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ICategorizer
    STDMETHODIMP GetDescription(LPWSTR pszDesc, UINT cch);
    STDMETHODIMP GetCategory(UINT cidl, LPCITEMIDLIST * apidl, DWORD* rgCategoryIds);
    STDMETHODIMP GetCategoryInfo(DWORD dwCategoryId, CATEGORY_INFO* pci);
    STDMETHODIMP CompareCategory(CATSORT_FLAGS csfFlags, DWORD dwCategoryId1, DWORD dwCategoryId2);

    // IShellExtInit
    STDMETHODIMP Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdobj, HKEY hkeyProgID);

    CFreeSpaceCategorizer();
private:
    ~CFreeSpaceCategorizer();
    long _cRef;
    IShellFolder2* _psf;
};


class CDetailCategorizer : public ICategorizer
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ICategorizer
    STDMETHODIMP GetDescription(LPWSTR pszDesc, UINT cch);
    STDMETHODIMP GetCategory(UINT cidl, LPCITEMIDLIST * apidl, DWORD* rgCategoryIds);
    STDMETHODIMP GetCategoryInfo(DWORD dwCategoryId, CATEGORY_INFO* pci);
    STDMETHODIMP CompareCategory(CATSORT_FLAGS csfFlags, DWORD dwCategoryId1, DWORD dwCategoryId2);

    CDetailCategorizer(IShellFolder2* psf, const SHCOLUMNID& scid);
private:
    ~CDetailCategorizer();
    long _cRef;
    IShellFolder2*  _psf;
    SHCOLUMNID      _scid;
    HHASHTABLE      _hash;
    HDPA            _hdpaKeys;
};


class CEnumCategoryGUID : public IEnumGUID
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumIDList
    STDMETHODIMP Next(ULONG celt, GUID *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt) { return E_NOTIMPL; }
    STDMETHODIMP Reset()    { _iIndex = 0; return S_OK;}
    STDMETHODIMP Clone(IEnumGUID **ppenum) { return E_NOTIMPL; };

    CEnumCategoryGUID(HDSA hdsa);
private:

    long            _cRef;
    HDSA            _hda;
    int             _iIndex;
};

CEnumCategoryGUID::CEnumCategoryGUID(HDSA hda): _cRef(1)
{
    _hda = hda;
}

HRESULT CEnumCategoryGUID::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CEnumCategoryGUID, IEnumGUID),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CEnumCategoryGUID::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CEnumCategoryGUID::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CEnumCategoryGUID::Next(ULONG celt, GUID *rgelt, ULONG *pceltFetched)
{
    HRESULT hr = S_FALSE;
    if (celt > 1)
        return E_INVALIDARG;

    if (_hda == NULL)
        return hr;

    while (hr != S_OK &&
           _iIndex < DSA_GetItemCount(_hda))
    {
        CATCACHE* pcat = (CATCACHE*)DSA_GetItemPtr(_hda, _iIndex);

        // Is this a scid map entry instead of an external categorizer?
        if (pcat->scid.fmtid == GUID_NULL)
        {
            // Nope. then we can enum it.
            if (pceltFetched)
                *pceltFetched = 1;

            *rgelt = pcat->guid;

            hr = S_OK;
        }
        _iIndex++;
    }

    return hr;

}

class CCategoryProvider : public ICategoryProvider, public IDefCategoryProvider
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ICategoryProvider
    STDMETHODIMP CanCategorizeOnSCID(SHCOLUMNID* pscid);
    STDMETHODIMP GetDefaultCategory(GUID* pguid, SHCOLUMNID* pscid);
    STDMETHODIMP GetCategoryForSCID(SHCOLUMNID* pscid, GUID* pguid);
    STDMETHODIMP EnumCategories(IEnumGUID** penum);
    STDMETHODIMP GetCategoryName(GUID* pguid, LPWSTR pszName, UINT cch);
    STDMETHODIMP CreateCategory(GUID* pguid, REFIID riid, void** ppv);

    // IDefCategoryProvider
    STDMETHODIMP Initialize(const GUID* pguid, const SHCOLUMNID* pscid, const SHCOLUMNID* pscidExlude, HKEY hkey, const CATLIST* pcl, IShellFolder* psf);

    CCategoryProvider();
private:
    ~CCategoryProvider();
    BOOL            _BuildCategoryList(HKEY hkey, const CATLIST* pcl);
    friend int      DestroyCache(void *pv, void *unused);
    HRESULT CreateInstance(GUID* pguid, REFIID riid, void** ppv);


    long            _cRef;
    LPITEMIDLIST    _pidlFolder;
    IShellFolder2*  _psf;
    HDSA            _hdaCat;

    GUID            _guidDefault;
    SHCOLUMNID      _scidDefault;
    HDSA            _hdaExcludeSCIDs;

};

STDAPI CCategoryProvider_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CCategoryProvider* p = new CCategoryProvider();
    if (p)
    {
        hr = p->QueryInterface(riid, ppv);
        p->Release();
    }

    return hr;
}


BOOL CCategoryProvider::_BuildCategoryList(HKEY hkey, const CATLIST* pcl)
{
    int i = 0;
    _hdaCat = DSA_Create(sizeof(CATCACHE), 3);

    if (!_hdaCat)
        return FALSE;

    // Enumerate static
    while(!IsEqualGUID(*pcl[i].pguid, GUID_NULL))
    {
        CATCACHE cc = {0};
        cc.guid = *pcl[i].pguid;
        if (pcl[i].pscid)
        {
            cc.scid = *pcl[i].pscid;
        }

        DSA_AppendItem(_hdaCat, (void*)&cc);
        i++;
    }

    // Enumerate hkey
    TCHAR szHandlerCLSID[GUIDSTR_MAX];
    int iHandler = 0;

    while (ERROR_SUCCESS == RegEnumKey(hkey, iHandler++, szHandlerCLSID, ARRAYSIZE(szHandlerCLSID)))
    {
        CLSID clsid;
        if (SUCCEEDED(SHCLSIDFromString(szHandlerCLSID, &clsid)))
        {
            CATCACHE cc = {0};
            cc.guid = clsid;

            DSA_AppendItem(_hdaCat, (void*)&cc);
            i++;
        }
    }

    return TRUE;
}


CCategoryProvider::CCategoryProvider() : _cRef(1)
{
    DllAddRef();
}

int DestroyCache(void *pv, void *unused)
{
    CATCACHE* pcat = (CATCACHE*)pv;
    ATOMICRELEASE(pcat->punk);
    return 1;
}

CCategoryProvider::~CCategoryProvider()
{
    ATOMICRELEASE(_psf);
    ILFree(_pidlFolder);
    if (_hdaExcludeSCIDs)
    {
        DSA_Destroy(_hdaExcludeSCIDs);
    }

    if (_hdaCat)
    {
        DSA_DestroyCallback(_hdaCat, DestroyCache, NULL);
    }
    DllRelease();
}


HRESULT CCategoryProvider::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CCategoryProvider, IDefCategoryProvider),
        QITABENT(CCategoryProvider, ICategoryProvider),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CCategoryProvider::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CCategoryProvider::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CCategoryProvider::Initialize(const GUID* pguid, const SHCOLUMNID* pscid, const SHCOLUMNID* pscidExclude, HKEY hkey, const CATLIST* pcl, IShellFolder* psf)
{
    if (!psf)
        return E_INVALIDARG;

    HRESULT hr = SHGetIDListFromUnk(psf, &_pidlFolder);

    if (SUCCEEDED(hr))
    {
        if (pcl && !_BuildCategoryList(hkey, pcl))
            return E_OUTOFMEMORY;

        if (pguid)
            _guidDefault = *pguid;

        if (pscid)
            _scidDefault = *pscid;

        if (pscidExclude)
        {
            _hdaExcludeSCIDs = DSA_Create(sizeof(SHCOLUMNID), 3);
            if (_hdaExcludeSCIDs)
            {
                int i = 0;
                while(pscidExclude[i].fmtid != GUID_NULL)
                {
                    DSA_AppendItem(_hdaExcludeSCIDs, (void*)&pscidExclude[i]);
                    i++;
                }

            }
        }

        hr = psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &_psf));
    }

    return hr;
}

STDMETHODIMP CCategoryProvider::CanCategorizeOnSCID(SHCOLUMNID* pscid)
{
    if (_hdaExcludeSCIDs)
    {
        for (int i=0; i < DSA_GetItemCount(_hdaExcludeSCIDs); i++)
        {
            SHCOLUMNID* pscidExclude = (SHCOLUMNID*)DSA_GetItemPtr(_hdaExcludeSCIDs, i);
            if (IsEqualSCID(*pscidExclude, *pscid))
                return S_FALSE;
        }

    }
    return S_OK;
}

STDMETHODIMP CCategoryProvider::GetDefaultCategory(GUID* pguid, SHCOLUMNID* pscid)
{
    *pguid = _guidDefault;
    *pscid = _scidDefault;

    if (_guidDefault == GUID_NULL && _scidDefault.fmtid == GUID_NULL)
        return S_FALSE;

    return S_OK;
}

STDMETHODIMP CCategoryProvider::GetCategoryForSCID(SHCOLUMNID* pscid, GUID* pguid)
{
    HRESULT hr = S_FALSE;
    if (_hdaCat == NULL || pscid == NULL)
        return hr;

    int c = DSA_GetItemCount(_hdaCat);
    for (int i = 0; i < c; i++)
    {
        CATCACHE* pcc = (CATCACHE*)DSA_GetItemPtr(_hdaCat, i);
        ASSERT(pcc != NULL);

        if (IsEqualSCID(pcc->scid, *pscid))
        {
            *pguid = pcc->guid;
            hr = S_OK;
            break;
        }
    }

    return hr;
}


STDMETHODIMP CCategoryProvider::EnumCategories(IEnumGUID** penum)
{
    HRESULT hr = E_NOINTERFACE;
    if (_hdaCat)
    {
        *penum = (IEnumGUID*)new CEnumCategoryGUID(_hdaCat);

        if (!*penum)
            hr = E_OUTOFMEMORY;

        hr = S_OK;
    }

    return hr;
}

STDMETHODIMP CCategoryProvider::GetCategoryName(GUID* pguid, LPWSTR pszName, UINT cch)
{
    ICategorizer* pcat;
    HRESULT hr = CreateCategory(pguid, IID_PPV_ARG(ICategorizer, &pcat));
    
    if (SUCCEEDED(hr))
    {
        hr = pcat->GetDescription(pszName, cch);
        pcat->Release();
    }

    return hr;

}

HRESULT CCategoryProvider::CreateInstance(GUID* pguid, REFIID riid, void** ppv)
{
    IShellExtInit* psei;
    // These come from HKCR hence must go through approval
    HRESULT hr = SHExtCoCreateInstance(NULL, pguid, NULL, IID_PPV_ARG(IShellExtInit, &psei));
    if (SUCCEEDED(hr))
    {
        psei->Initialize(_pidlFolder, NULL, NULL);
        hr = psei->QueryInterface(riid, ppv);
        psei->Release();
    }

    return hr;
}


STDMETHODIMP CCategoryProvider::CreateCategory(GUID* pguid, REFIID riid, void** ppv)
{
    HRESULT hr = E_NOINTERFACE;
    if (_hdaCat != NULL)
    {
        int c = DSA_GetItemCount(_hdaCat);
        for (int i = 0; i < c; i++)
        {
            CATCACHE* pcc = (CATCACHE*)DSA_GetItemPtr(_hdaCat, i);
            ASSERT(pcc != NULL);

            if (IsEqualGUID(pcc->guid, *pguid))
            {
                if (!pcc->punk)
                {
                    hr = CreateInstance(pguid, IID_PPV_ARG(IUnknown, &pcc->punk));
                }

                if (pcc->punk)
                {
                    hr = pcc->punk->QueryInterface(riid, ppv);
                }
                break;
            }
        }
    }

    if (FAILED(hr))
    {
        // Not in the cache? Just try a create
        hr = CreateInstance(pguid, riid, ppv);
    }

    return hr;
}

STDAPI CCategoryProvider_Create(const GUID* pguid, const SHCOLUMNID* pscid, HKEY hkey, const CATLIST* pcl, IShellFolder* psf, REFIID riid, void **ppv)
{
    HRESULT hr;
    CCategoryProvider *pdext = new CCategoryProvider();
    if (pdext)
    {
        hr = pdext->Initialize(pguid, pscid, NULL, hkey, pcl, psf);
        if (SUCCEEDED(hr))
            hr = pdext->QueryInterface(riid, ppv);

        pdext->Release();
    }
    else
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}


/////////////////////////////////////////////////////////
//  Time Categorizer

STDAPI CTimeCategorizer_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CTimeCategorizer* p = new CTimeCategorizer();
    if (p)
    {
        hr = p->QueryInterface(riid, ppv);
        p->Release();
    }

    return hr;
}

STDAPI CTimeCategorizer_Create(IShellFolder2* psf2, const SHCOLUMNID* pscid, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CTimeCategorizer* p = new CTimeCategorizer(pscid, psf2);
    if (p)
    {
        hr = p->QueryInterface(riid, ppv);
        p->Release();
    }

    return hr;
}


CTimeCategorizer::CTimeCategorizer(const SHCOLUMNID* pscid, IShellFolder2* psf) : _cRef(1)
{
    _psf = psf;
    ASSERT(psf);
    psf->AddRef();
    _scid = *pscid;
}

CTimeCategorizer::CTimeCategorizer() : _cRef(1)
{
    _scid = SCID_WRITETIME;
}

CTimeCategorizer::~CTimeCategorizer()
{
    ATOMICRELEASE(_psf);

}

HRESULT CTimeCategorizer::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CTimeCategorizer, ICategorizer),
        QITABENT(CTimeCategorizer, IShellExtInit),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CTimeCategorizer::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CTimeCategorizer::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CTimeCategorizer::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdobj, HKEY hkeyProgID)
{
    ATOMICRELEASE(_psf);
    return SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder2, pidlFolder, &_psf));
}

HRESULT CTimeCategorizer::GetDescription(LPWSTR pszDesc, UINT cch)
{
    LoadString(HINST_THISDLL, IDS_GROUPBYTIME, pszDesc, cch);
    return S_OK;
}



static const int mpcdymoAccum[13] = { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 };

int GetDaysForMonth(int yr, int mo)
{
    int cdy;

    if (yr == 1752 && mo == 9)
        return 19;

    cdy = mpcdymoAccum[mo] - mpcdymoAccum[mo - 1];
    if (mo == 2 && (yr & 03) == 0 && (yr <= 1750 || yr % 100 != 0 || yr % 400 == 0))
        cdy++;

    return cdy;
}

int GetDaysForLastMonth(int year, int month)
{
    if (month == 1)
    {
        year--;
        month = 12;
    }
    else
        month--;

    return GetDaysForMonth(year, month);

}

HRESULT CTimeCategorizer::GetCategory(UINT cidl, LPCITEMIDLIST * apidl, DWORD* rgCategoryIds)
{
    SYSTEMTIME stCur;
    GetLocalTime(&stCur);

    for (UINT i = 0; i < cidl; i++)
    {
        FILETIME ft;

        // Get the time data
        if (SUCCEEDED(GetDateProperty(_psf, apidl[i], &_scid, &ft)))
        {
            // Convert it to a usable format
            SYSTEMTIME stFile;
            FileTimeToLocalFileTime(&ft, &ft);
            FileTimeToSystemTime(&ft, &stFile);

            if (stFile.wYear == stCur.wYear)
            {
                if (stFile.wMonth > stCur.wMonth)
                {
                    if (stFile.wMonth == stCur.wMonth + 1)
                    {
                        rgCategoryIds[i] = IDS_NEXTMONTH;
                    }
                    else
                    {
                        rgCategoryIds[i] = IDS_LATERTHISYEAR;
                    }
                }
                else if (stFile.wMonth == stCur.wMonth)
                {
                    if (stFile.wDay == stCur.wDay + 1)
                    {
                        rgCategoryIds[i] = IDS_TOMORROW;
                    }
                    else if (stFile.wDay == stCur.wDay + 2)
                    {
                        rgCategoryIds[i] = IDS_TWODAYSFROMNOW;
                    }
                    else if (stFile.wDay == stCur.wDay)
                    {
                        rgCategoryIds[i] = IDS_TODAY;
                    }
                    else if (stFile.wDay == stCur.wDay - 1)
                    {
                        rgCategoryIds[i] = IDS_YESTERDAY;
                    }
                    else if (stFile.wDayOfWeek < stCur.wDayOfWeek && 
                             stFile.wDay < stCur.wDay &&
                             stCur.wDay - stCur.wDayOfWeek > 0 &&
                             stFile.wDay >= stCur.wDay - stCur.wDayOfWeek)
                    {
                        rgCategoryIds[i] = IDS_EARLIERTHISWEEK;
                    }
                    else if (stFile.wDayOfWeek > stCur.wDayOfWeek && 
                             stFile.wDay > stCur.wDay &&
                             stFile.wDay <= stCur.wDay + (7 - stCur.wDayOfWeek))
                    {
                        rgCategoryIds[i] = IDS_LATERTHISWEEK;
                    }
                    else if (stFile.wDay > stCur.wDay)
                    {
                        rgCategoryIds[i] = IDS_LATERTHISMONTH;
                    }
                    else
                    {
                        int fileDays = GetDaysForLastMonth(stFile.wYear, stFile.wMonth - 1) + stFile.wDay;
                        int curDays = GetDaysForLastMonth(stCur.wYear, stCur.wMonth - 1) + stCur.wDay;

                        if (fileDays < (curDays - stCur.wDayOfWeek) && 
                            fileDays > (curDays - stCur.wDayOfWeek - 7))
                        {
                            rgCategoryIds[i] = IDS_LASTWEEK;
                        }
                        else if (fileDays < (curDays - stCur.wDayOfWeek - 7) && 
                                 fileDays > (curDays - stCur.wDayOfWeek - 14))
                        {
                            rgCategoryIds[i] = IDS_TWOWEEKSAGO;
                        }
                        else
                        {
                            rgCategoryIds[i] = IDS_EARLIERTHISMONTH;
                        }
                    }
                }
                else if (stFile.wMonth == stCur.wMonth - 1 || 
                         (stFile.wMonth == 12 && 
                          stCur.wMonth == 1))
                {
                    rgCategoryIds[i] = IDS_LASTMONTH;
                }
                else if (stFile.wMonth == stCur.wMonth - 2 || 
                    (stFile.wMonth == 12 && stCur.wMonth == 2) || 
                    (stFile.wMonth == 11 && stCur.wMonth == 1))
                {
                    rgCategoryIds[i] = IDS_TWOMONTHSAGO;
                }
                else
                {
                    rgCategoryIds[i] = IDS_EARLIERTHISYEAR;
                }
            }
            else if (stFile.wYear == stCur.wYear - 1)
            {
                rgCategoryIds[i] = IDS_LASTYEAR;
            }
            else if (stFile.wYear == stCur.wYear - 2)
            {
                rgCategoryIds[i] = IDS_TWOYEARSAGO;
            }
            else if (stFile.wYear < stCur.wYear - 2)
            {
                rgCategoryIds[i] = IDS_LONGTIMEAGO;
            }
            else if (stFile.wYear == stCur.wYear + 1)
            {
                rgCategoryIds[i] = IDS_NEXTYEAR;
            }
            else if (stFile.wYear > stCur.wYear + 2)
            {
                rgCategoryIds[i] = IDS_SOMETIMETHISMILLENNIA;
            }
            else if (stFile.wYear > (stCur.wYear / 1000) * 1000 + 1000) // 2050 / 1000 = 2. 2 * 1000 = 2000. 2000 + 1000 = 3000 i.e. next millennium
            {
                rgCategoryIds[i] = IDS_SOMEFUTUREDATE;
            }
        }
        else
        {
            rgCategoryIds[i] = IDS_UNSPECIFIED;
        }
    }

    return S_OK;
}

HRESULT CTimeCategorizer::GetCategoryInfo(DWORD dwCategoryId, CATEGORY_INFO* pci)
{
    LoadString(HINST_THISDLL, dwCategoryId, pci->wszName, ARRAYSIZE(pci->wszName));
    return S_OK;
}

HRESULT CTimeCategorizer::CompareCategory(CATSORT_FLAGS csfFlags, DWORD dwCategoryId1, DWORD dwCategoryId2)
{
    if (dwCategoryId1 == dwCategoryId2)
        return ResultFromShort(0);
    else if (dwCategoryId1 == IDS_GROUPFOLDERS)
        return ResultFromShort(-1);
    else if (dwCategoryId2 == IDS_GROUPFOLDERS)
        return ResultFromShort(1);
    else if (dwCategoryId1 < dwCategoryId2)
        return ResultFromShort(-1);
    else
        return ResultFromShort(1);
}



/////////////////////////////////////////////////////////
//  Size Categorizer

STDAPI CDriveSizeCategorizer_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CSizeCategorizer* p = new CSizeCategorizer(TRUE);
    if (p)
    {
        hr = p->QueryInterface(riid, ppv);
        p->Release();
    }

    return hr;
}

STDAPI CSizeCategorizer_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CSizeCategorizer* p = new CSizeCategorizer(FALSE);
    if (p)
    {
        hr = p->QueryInterface(riid, ppv);
        p->Release();
    }

    return hr;
}

STDAPI CSizeCategorizer_Create(IShellFolder2* psf2, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CSizeCategorizer* p = new CSizeCategorizer(psf2);
    if (p)
    {
        hr = p->QueryInterface(riid, ppv);
        p->Release();
    }

    return hr;
}

CSizeCategorizer::CSizeCategorizer(IShellFolder2* psf) : _cRef(1)
{
    _psf = psf;
    ASSERT(psf);
    psf->AddRef();
}

CSizeCategorizer::CSizeCategorizer(BOOL fLarge) : _cRef(1), _fLarge(fLarge)
{
}

CSizeCategorizer::~CSizeCategorizer()
{
    ATOMICRELEASE(_psf);

}

HRESULT CSizeCategorizer::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CSizeCategorizer, ICategorizer),
        QITABENT(CSizeCategorizer, IShellExtInit),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CSizeCategorizer::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CSizeCategorizer::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CSizeCategorizer::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdobj, HKEY hkeyProgID)
{
    ATOMICRELEASE(_psf);
    return SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder2, pidlFolder, &_psf));
}

HRESULT CSizeCategorizer::GetDescription(LPWSTR pszDesc, UINT cch)
{
    LoadString(HINST_THISDLL, IDS_GROUPBYSIZE, pszDesc, cch);
    return S_OK;
}

const static ULONGLONG s_rgSizesSmall[] = 
{
    // 130mb      16mb         1mb        100k         10l
    134217728,   16777216,    1048576,    131072,     32768,     0
};

const static ULONGLONG s_rgSizesLarge[] = 
{
    // 80gig      25gig        10gig        2gig        500mb
    80000000000, 25000000000, 10000000000, 2000000000, 500000000, 0
};


HRESULT CSizeCategorizer::GetCategory(UINT cidl, LPCITEMIDLIST * apidl, DWORD* rgCategoryIds)
{
    if (_psf == NULL)
        return E_ACCESSDENIED;  // Not initialized yet.

    for (UINT i = 0; i < cidl; i++)
    {
        const ULONGLONG* pll = _fLarge? s_rgSizesLarge : s_rgSizesSmall;

        // Get the size data
        ULONGLONG ullSize;
        if (SUCCEEDED(GetLongProperty(_psf, apidl[i], _fLarge?&SCID_CAPACITY:&SCID_SIZE, &ullSize)))
        {
            if (ullSize >= pll[0])      
                rgCategoryIds[i] = IDS_GIGANTIC;
            if (ullSize < pll[0])
                rgCategoryIds[i] = IDS_HUGE;
            if (ullSize < pll[1])        // Under 16mb
                rgCategoryIds[i] = IDS_LARGE;
            if (ullSize < pll[2])         // Under 1mb
                rgCategoryIds[i] = IDS_MEDIUM;
            if (ullSize < pll[3])          // Under 100k
                rgCategoryIds[i] = IDS_SMALL;
            if (ullSize < pll[4])           // Under 10k
                rgCategoryIds[i] = IDS_TINY;
            if (ullSize == pll[5])              // Zero sized files
            {
                if (SHGetAttributes(_psf, apidl[i], SFGAO_FOLDER))
                {
                    rgCategoryIds[i] = IDS_FOLDERS;
                }
                else
                {
                    rgCategoryIds[i] = IDS_ZERO;
                }
            }
        }
        else
        {
            rgCategoryIds[i] = IDS_UNSPECIFIED;
        }        
    }

    return S_OK;
}

HRESULT CSizeCategorizer::GetCategoryInfo(DWORD dwCategoryId, CATEGORY_INFO* pci)
{
    LoadString(HINST_THISDLL, dwCategoryId, pci->wszName, ARRAYSIZE(pci->wszName));
    return S_OK;
}

HRESULT CSizeCategorizer::CompareCategory(CATSORT_FLAGS csfFlags, DWORD dwCategoryId1, DWORD dwCategoryId2)
{
    if (dwCategoryId1 == dwCategoryId2)
        return ResultFromShort(0);
    else if (dwCategoryId1 == IDS_GROUPFOLDERS)
        return ResultFromShort(-1);
    else if (dwCategoryId2 == IDS_GROUPFOLDERS)
        return ResultFromShort(1);
    else if (dwCategoryId1 < dwCategoryId2)
        return ResultFromShort(-1);
    else
        return ResultFromShort(1);
}

/////////////////////////////////////////////////////////
//  Type Categorizer

STDAPI CDriveTypeCategorizer_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    CDriveTypeCategorizer *p = new CDriveTypeCategorizer();
    if (!p)
        return E_OUTOFMEMORY;

    HRESULT hr = p->QueryInterface(riid, ppv);
    p->Release();
    return hr;
}

CDriveTypeCategorizer::CDriveTypeCategorizer(IShellFolder2* psf) : 
    _cRef(1)
{
    _psf = psf;
    ASSERT(psf);
    psf->AddRef();
}

CDriveTypeCategorizer::CDriveTypeCategorizer() : 
    _cRef(1)
{
}

CDriveTypeCategorizer::~CDriveTypeCategorizer()
{
    ATOMICRELEASE(_psf);
}

HRESULT CDriveTypeCategorizer::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CDriveTypeCategorizer, ICategorizer),
        QITABENT(CDriveTypeCategorizer, IShellExtInit),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CDriveTypeCategorizer::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CDriveTypeCategorizer::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CDriveTypeCategorizer::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdobj, HKEY hkeyProgID)
{
    ATOMICRELEASE(_psf);
    return SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder2, pidlFolder, &_psf));
}

HRESULT CDriveTypeCategorizer::GetDescription(LPWSTR pszDesc, UINT cch)
{
    LoadString(HINST_THISDLL, IDS_GROUPBYDRIVETYPE, pszDesc, cch);
    return S_OK;
}

const struct { DWORD dwDescriptionId; UINT uIDGroup; } c_drives_mapping[] = 
{
    { SHDID_COMPUTER_FIXED     , IDS_DRIVES_FIXED_GROUP     },
    { SHDID_COMPUTER_DRIVE35   , IDS_DRIVES_REMOVABLE_GROUP },
    { SHDID_COMPUTER_REMOVABLE , IDS_DRIVES_REMOVABLE_GROUP },
    { SHDID_COMPUTER_CDROM     , IDS_DRIVES_REMOVABLE_GROUP },
    { SHDID_COMPUTER_NETDRIVE  , IDS_DRIVES_NETDRIVE_GROUP  },
    { SHDID_COMPUTER_OTHER     , IDS_DRIVES_OTHER_GROUP     },
    { SHDID_COMPUTER_DRIVE525  , IDS_DRIVES_REMOVABLE_GROUP },
    { SHDID_COMPUTER_RAMDISK   , IDS_DRIVES_OTHER_GROUP     },
    { SHDID_COMPUTER_IMAGING   , IDS_DRIVES_IMAGING_GROUP   },
    { SHDID_COMPUTER_AUDIO     , IDS_DRIVES_AUDIO_GROUP     },
    { SHDID_COMPUTER_SHAREDDOCS, IDS_DRIVES_SHAREDDOCS_GROUP},
};

HRESULT CDriveTypeCategorizer::GetCategory(UINT cidl, LPCITEMIDLIST * apidl, DWORD* rgCategoryIds)
{
    HRESULT hr;

    if (_psf == NULL)
    {
        hr = E_ACCESSDENIED;  // Not initialized yet.
    }
    else
    {
        for (UINT i = 0; i < cidl; i++)
        {
            rgCategoryIds[i] = IDS_DRIVES_OTHER_GROUP;

            VARIANT v;
            // Get the type data
            hr = _psf->GetDetailsEx(apidl[i], &SCID_DESCRIPTIONID, &v);
            if (SUCCEEDED(hr))
            {
                SHDESCRIPTIONID did;
                if (VariantToBuffer(&v, &did, sizeof(did)))
                {
                    for (int j = 0; j < ARRAYSIZE(c_drives_mapping); j++)
                    {
                        if (did.dwDescriptionId == c_drives_mapping[j].dwDescriptionId)
                        {
                            rgCategoryIds[i] = c_drives_mapping[j].uIDGroup;
                            break;
                        }
                    }
                }
                VariantClear(&v);
            }            
        }

        hr = S_OK;
    }

    return hr;
}

HRESULT CDriveTypeCategorizer::GetCategoryInfo(DWORD dwCategoryId, CATEGORY_INFO* pci)
{
    LoadString(HINST_THISDLL, dwCategoryId, pci->wszName, ARRAYSIZE(pci->wszName));
    return S_OK;
}

HRESULT CDriveTypeCategorizer::CompareCategory(CATSORT_FLAGS csfFlags, DWORD dwCategoryId1, DWORD dwCategoryId2)
{
    if (dwCategoryId1 == dwCategoryId2)
        return ResultFromShort(0);
    else if (dwCategoryId1 < dwCategoryId2)
        return ResultFromShort(-1);
    else
        return ResultFromShort(1);
}

/////////////////////////////////////////////////////////
//  FreeSpace Categorizer

CFreeSpaceCategorizer::CFreeSpaceCategorizer() : _cRef(1)
{
}

CFreeSpaceCategorizer::~CFreeSpaceCategorizer()
{
    ATOMICRELEASE(_psf);

}

HRESULT CFreeSpaceCategorizer::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CFreeSpaceCategorizer, ICategorizer),
        QITABENT(CFreeSpaceCategorizer, IShellExtInit),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CFreeSpaceCategorizer::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CFreeSpaceCategorizer::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CFreeSpaceCategorizer::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdobj, HKEY hkeyProgID)
{
    ATOMICRELEASE(_psf);
    return SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder2, pidlFolder, &_psf));
}

HRESULT CFreeSpaceCategorizer::GetDescription(LPWSTR pszDesc, UINT cch)
{
    LoadString(HINST_THISDLL, IDS_GROUPBYFREESPACE, pszDesc, cch);
    return S_OK;
}

HRESULT CFreeSpaceCategorizer::GetCategory(UINT cidl, LPCITEMIDLIST* apidl, DWORD* rgCategoryIds)
{
    if (_psf == NULL)
        return E_ACCESSDENIED;  // Not initialized yet.

    for (UINT i = 0; i < cidl; i++)
    {
        rgCategoryIds[i] = IDS_UNSPECIFIED;

        // Get the total size and free space
        ULONGLONG ullSize;
        if (SUCCEEDED(GetLongProperty(_psf, apidl[i], &SCID_CAPACITY, &ullSize)))
        {
            ULONGLONG ullFree;
            if (SUCCEEDED(GetLongProperty(_psf, apidl[i], &SCID_FREESPACE, &ullFree)))
            {
                // Prevent divide by zero
                if (ullSize == 0)
                {
                    rgCategoryIds[i] = IDS_UNSPECIFIED;
                }
                else
                {
                    // Turning this into a percent. DWORD cast is ok.
                    rgCategoryIds[i] = (static_cast<DWORD>((ullFree * 100) / ullSize)  / 10) * 10;
                }
            }
        }
    }

    return S_OK;
}

HRESULT CFreeSpaceCategorizer::GetCategoryInfo(DWORD dwCategoryId, CATEGORY_INFO* pci)
{
    if (dwCategoryId == IDS_UNSPECIFIED)
    {
        LoadString(HINST_THISDLL, IDS_UNSPECIFIED, pci->wszName, ARRAYSIZE(pci->wszName));
        return S_OK;
    }
    else 
    {
        TCHAR szName[MAX_PATH];
        LoadString(HINST_THISDLL, IDS_FREESPACEPERCENT, szName, ARRAYSIZE(szName));
        wnsprintf(pci->wszName, ARRAYSIZE(pci->wszName), szName, dwCategoryId);
        return S_OK;
    }

    return E_FAIL;
}

HRESULT CFreeSpaceCategorizer::CompareCategory(CATSORT_FLAGS csfFlags, DWORD dwCategoryId1, DWORD dwCategoryId2)
{
    if (dwCategoryId1 == IDS_UNSPECIFIED)
        return ResultFromShort(1);
    else if (dwCategoryId2 == IDS_UNSPECIFIED)
        return ResultFromShort(-1);
    else if (dwCategoryId1 == dwCategoryId2)
        return ResultFromShort(0);
    else if (dwCategoryId1 < dwCategoryId2)
        return ResultFromShort(-1);
    else
        return ResultFromShort(1);
}

STDAPI CFreeSpaceCategorizer_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CFreeSpaceCategorizer* p = new CFreeSpaceCategorizer();
    if (p)
    {
        hr = p->QueryInterface(riid, ppv);
        p->Release();
    }

    return hr;
}


/////////////////////////////////////////////////////////
//  Detail Categorizer
STDAPI CDetailCategorizer_Create(const SHCOLUMNID& pscid, IShellFolder2* psf2, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CDetailCategorizer* p = new CDetailCategorizer(psf2, pscid);
    if (p)
    {
        hr = p->QueryInterface(riid, ppv);
        p->Release();
    }

    return hr;
}

CDetailCategorizer::CDetailCategorizer(IShellFolder2* psf, const SHCOLUMNID& scid) : _cRef(1)
{
    _psf = psf;
    psf->AddRef();
    _scid = scid;

    _hash = CreateHashItemTable(10, sizeof(DWORD));
    _hdpaKeys = DPA_Create(10);

}

CDetailCategorizer::~CDetailCategorizer()
{
    _psf->Release();
    DestroyHashItemTable(_hash);
    DPA_Destroy(_hdpaKeys);
}

HRESULT CDetailCategorizer::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CDetailCategorizer, ICategorizer),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CDetailCategorizer::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CDetailCategorizer::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CDetailCategorizer::GetDescription(LPWSTR pszDesc, UINT cch)
{
    return E_FAIL;
}

HRESULT CDetailCategorizer::GetCategory(UINT cidl, LPCITEMIDLIST * apidl, DWORD* rgCategoryIds)
{
    if (!_hash || !_hdpaKeys)
        return E_OUTOFMEMORY;

    for (UINT i = 0; i < cidl; i++)
    {
        VARIANT v;

        rgCategoryIds[i] = GROUPID_UNSPECIFIED;

        HRESULT hr = _psf->GetDetailsEx(apidl[i], &_scid, &v);
        if (hr == S_OK)     // GetDetails returns S_FALSE for failure.
        {
            WCHAR szValue[MAX_PATH];
            if (SUCCEEDED(SHFormatForDisplay(_scid.fmtid, _scid.pid, (PROPVARIANT*)&v, PUIFFDF_DEFAULT, szValue, ARRAYSIZE(szValue))))
            {
                LPCTSTR pszKey = FindHashItem(_hash, szValue);
                if (pszKey)
                {
                    rgCategoryIds[i] = (DWORD)GetHashItemData(_hash, pszKey, 0);
                }
                else
                {
                    pszKey = AddHashItem(_hash, szValue);
                    if (pszKey)
                    {
                        rgCategoryIds[i] = DPA_AppendPtr(_hdpaKeys, (void*)pszKey);
                        SetHashItemData(_hash, pszKey, 0, rgCategoryIds[i]);
                    }
                }
            }

            VariantClear(&v);
        }
    }
    return S_OK;
}

HRESULT CDetailCategorizer::GetCategoryInfo(DWORD dwCategoryId, CATEGORY_INFO* pci)
{
    HRESULT hr = E_OUTOFMEMORY;
    if (_hash|| _hdpaKeys)
    {
        if (dwCategoryId == GROUPID_UNSPECIFIED || dwCategoryId == GROUPID_FOLDER)
        {
            LoadString(HINST_THISDLL, STRINGID_FROM_GROUPID(dwCategoryId), pci->wszName, ARRAYSIZE(pci->wszName));
            hr = S_OK;
        }
        else
        {
            LPCTSTR pszKey = (LPCTSTR)DPA_FastGetPtr(_hdpaKeys, dwCategoryId);
            if (pszKey)
            {
                LPCTSTR psz = FindHashItem(_hash, pszKey);
                if (psz)
                {
                    StrCpyN(pci->wszName, psz, ARRAYSIZE(pci->wszName));
                    hr =  S_OK;
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }
    }
    return hr;
}

HRESULT CDetailCategorizer::CompareCategory(CATSORT_FLAGS csfFlags, DWORD dwCategoryId1, DWORD dwCategoryId2)
{
    if (dwCategoryId1 == dwCategoryId2)
    {
        return ResultFromShort(0);
    }
    else if (dwCategoryId1 == GROUPID_UNSPECIFIED ||
        dwCategoryId2 == GROUPID_UNSPECIFIED)
    {
        return ResultFromShort((dwCategoryId1 == GROUPID_UNSPECIFIED)? 1 : -1);
    }
    else if (dwCategoryId1 == GROUPID_FOLDER)
    {
        return ResultFromShort(-1);
    }
    else if (dwCategoryId2 == GROUPID_FOLDER)
    {
        return ResultFromShort(1);
    }
    else
    {
        LPCTSTR pszKey1 = (LPCTSTR)DPA_FastGetPtr(_hdpaKeys, dwCategoryId1);
        LPCTSTR pszKey2 = (LPCTSTR)DPA_FastGetPtr(_hdpaKeys, dwCategoryId2);
        LPCTSTR psz1 = FindHashItem(_hash, pszKey1);
        LPCTSTR psz2 = FindHashItem(_hash, pszKey2);

        return ResultFromShort(lstrcmpi(psz1, psz2));
    }
}


/////////////////////////////////////////////////////////
//  Alphanumeric Categorizer

STDAPI CAlphaCategorizer_Create(IShellFolder2* psf2, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CAlphaCategorizer* p = new CAlphaCategorizer(psf2);
    if (p)
    {
        hr = p->QueryInterface(riid, ppv);
        p->Release();
    }

    return hr;
}

CAlphaCategorizer::CAlphaCategorizer(IShellFolder2* psf) : _cRef(1)
{
    _psf = psf;
    ASSERT(psf);
    psf->AddRef();
}

CAlphaCategorizer::~CAlphaCategorizer()
{
    _psf->Release();

}

HRESULT CAlphaCategorizer::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CAlphaCategorizer, ICategorizer),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CAlphaCategorizer::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CAlphaCategorizer::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CAlphaCategorizer::GetDescription(LPWSTR pszDesc, UINT cch)
{
    LoadString(HINST_THISDLL, IDS_GROUPALPHABETICALLY, pszDesc, cch);
    return S_OK;
}

HRESULT CAlphaCategorizer::GetCategory(UINT cidl, LPCITEMIDLIST * apidl, DWORD* rgCategoryIds)
{
    if (_psf == NULL)
        return E_ACCESSDENIED;  // Not initialized yet.

    for (UINT i = 0; i < cidl; i++)
    {
        TCHAR szName[MAX_PATH];
        HRESULT hr = DisplayNameOf(_psf, apidl[i], SHGDN_INFOLDER, szName, ARRAYSIZE(szName));
        if (SUCCEEDED(hr))
        {
            if (StrChr(TEXT("~`!@#$%^&*()_-+=1234567890<,>.;:'[]{}|"), szName[0]) != NULL)
            {
                rgCategoryIds[i] = GROUPID_OTHER;

            }
            else
            {
                CharUpperBuff(szName, 1);
                rgCategoryIds[i]  = (DWORD)szName[0];
            }
        }

        if (FAILED(hr))
            rgCategoryIds[i] = GROUPID_UNSPECIFIED;
    }

    return S_OK;
}

HRESULT CAlphaCategorizer::GetCategoryInfo(DWORD dwCategoryId, CATEGORY_INFO* pci)
{
    if (GROUPID_UNSPECIFIED == dwCategoryId || 
        GROUPID_OTHER == dwCategoryId       || 
        GROUPID_FOLDER == dwCategoryId)
    {
        LoadString(HINST_THISDLL, STRINGID_FROM_GROUPID(dwCategoryId), pci->wszName, ARRAYSIZE(pci->wszName));
        return S_OK;
    }
    else
    {
        pci->wszName[0] = (WCHAR)dwCategoryId;
        pci->wszName[1] = 0;

        return S_OK;
    }
}

HRESULT CAlphaCategorizer::CompareCategory(CATSORT_FLAGS csfFlags, DWORD dwCategoryId1, DWORD dwCategoryId2)
{
    if (dwCategoryId1 == dwCategoryId2)
    {
        return ResultFromShort(0);
    }
    else if (IDS_UNSPECIFIED == dwCategoryId1 || IDS_GROUPOTHERCHAR == dwCategoryId1)
    {
        return ResultFromShort(1);
    }
    else if (IDS_UNSPECIFIED == dwCategoryId2 || IDS_GROUPOTHERCHAR == dwCategoryId2)
    {
        return ResultFromShort(-1);
    }
    else if (dwCategoryId1 == IDS_GROUPFOLDERS)
        return ResultFromShort(-1);
    else if (dwCategoryId2 == IDS_GROUPFOLDERS)
        return ResultFromShort(1);
    else
    {
        TCHAR szName1[2] = {(WCHAR)dwCategoryId1, 0};
        TCHAR szName2[2] = {(WCHAR)dwCategoryId2, 0};

        return ResultFromShort(lstrcmpi(szName1, szName2));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\cabstate.c ===
/*----------------------------------------------------------------------------
/ Title;
/   cabstate.c => cabinet state i/o
/
/ Purpose:
/   Provides a clean API to fill out the cabinet state from the registry, if the
/   relevent keys cannot be found then we set the relevant defaults.  This is
/   called by the explorer.
/
/ History:
/   23apr96 daviddv New API which passes the structure size in
/   18mar96 daviddv Bug fix; Added colour state to FALSE when state structure not read
/    7feb96 daviddv Tweeked cabinet state writing
/   30jan96 daviddv Created
/
/----------------------------------------------------------------------------*/
#include "shellprv.h"
#include "regstr.h"
#include "cstrings.h"
#pragma hdrstop


TCHAR const c_szCabinetState[] = REGSTR_PATH_EXPLORER TEXT( "\\CabinetState");
TCHAR const c_szSettings[]     = TEXT("Settings");
TCHAR const c_szFullPath[]     = TEXT("FullPath");

/*----------------------------------------------------------------------------
/   Read in the CABINETSTATE structure from the registry and attempt to validate it.
/
/ Notes:
/   -
/
/ In:
/   lpCabinetState => pointer to CABINETSTATE structure to be filled.
/   cLength = size of structure to be filled
/
/ Out:
/   [lpState] filled in with data
/   fReadFromRegistry == indicates if the structure was actually read from the registry
/                        or if we are giviing the client a default one.
/----------------------------------------------------------------------------*/
STDAPI_(BOOL) ReadCabinetState( CABINETSTATE *lpState, int cLength )
{
    DWORD cbData = SIZEOF(CABINETSTATE);
    BOOL fReadFromRegistry = FALSE;
    CABINETSTATE state;
    SHELLSTATE ss;
    DWORD dwType;
    HKEY hKey;

    ASSERT( lpState );

    SHGetSetSettings(&ss, SSF_WIN95CLASSIC, FALSE);

    if ( lpState && cLength )
    {
        BOOL fReadFullPath = FALSE;
        //
        // Setup the default state of the structure and read in the current state
        // from the registry (over our freshly initialised structure).
        //

        state.cLength                   = SIZEOF(CABINETSTATE);
        state.nVersion                  = CABINETSTATE_VERSION;

        state.fSimpleDefault            = TRUE;
        state.fFullPathTitle            = FALSE;
        state.fSaveLocalView            = TRUE;
        state.fNotShell                 = FALSE;
        state.fNewWindowMode            = BOOLIFY(ss.fWin95Classic);
        state.fShowCompColor            = FALSE;
        state.fDontPrettyNames          = FALSE;
        state.fAdminsCreateCommonGroups = TRUE;
        state.fUnusedFlags              = 0;
        state.fMenuEnumFilter           = SHCONTF_FOLDERS | SHCONTF_NONFOLDERS;

        if ( !GetSystemMetrics( SM_CLEANBOOT ) &&
             ERROR_SUCCESS == RegOpenKeyEx( HKEY_CURRENT_USER, c_szCabinetState, 0L, KEY_READ, &hKey ) )
        {
            DWORD dwFullPath=0;
            DWORD cbFullPath=SIZEOF(dwFullPath);
            
            fReadFromRegistry = ( ERROR_SUCCESS == SHQueryValueEx( hKey,
                                                                    c_szSettings,
                                                                    NULL,
                                                                    &dwType,
                                                                    (PVOID) &state, &cbData ) );
            
            if (ERROR_SUCCESS == SHQueryValueEx(hKey, c_szFullPath, NULL, NULL, (LPVOID)&dwFullPath, &cbFullPath))
            {
                fReadFullPath = TRUE;
                state.fFullPathTitle = (BOOL)dwFullPath ? TRUE : FALSE;
            }
            
            RegCloseKey( hKey );
        }

        //
        // Fix the structure if it is an early version and write back into the registry
        // to avoid having to do it again.
        //

        if ( fReadFromRegistry && state.nVersion < CABINETSTATE_VERSION )
        {
            // NT4 and IE4x had the same value for state.nVersion (1), and we have to stomp some of the flags
            // depending on whether we are pre-IE4x or not. To differentiate, we see if c_szFullPath was present.
            // This reg key was introduced only in IE40.
            if ( (state.nVersion < 1) || ((state.nVersion == 1) && !fReadFullPath) )
            {
                state.fNewWindowMode            = BOOLIFY(ss.fWin95Classic);
                state.fAdminsCreateCommonGroups = TRUE;              // Moved post BETA 2 SUR!
                state.fUnusedFlags              = 0;
                state.fMenuEnumFilter           = SHCONTF_FOLDERS | SHCONTF_NONFOLDERS;
            }

            state.cLength = SIZEOF(CABINETSTATE);
            state.nVersion = CABINETSTATE_VERSION;

            WriteCabinetState( &state );
        }

        //
        // Copy only the requested data back to the caller.
        //

        state.cLength = (int) min( SIZEOF(CABINETSTATE), cLength );
        memcpy( lpState, &state, cLength );
    }

    return fReadFromRegistry;
}

// old export
STDAPI_(BOOL) OldReadCabinetState( LPCABINETSTATE lpState, int cLength )
{
   return ReadCabinetState(lpState, sizeof(CABINETSTATE));
}



/*----------------------------------------------------------------------------
/   Writes a CABINETSTATE structure back into the registry.
/
/ Notes:
/   Attempt to do the right thing when given a small structure to write
/   back so that we don't mess up the users settings.
/
/ In:
/   lpState -> structure to be written
/
/ Out:
/    fSuccess = TRUE / FALSE indicating if state has been seralised
/----------------------------------------------------------------------------*/
STDAPI_(BOOL) WriteCabinetState(CABINETSTATE *lpState)
{
    BOOL fSuccess = FALSE;
    if (lpState)
    {
        CABINETSTATE state;
        HKEY hKey;

        // Check to see if the structure is the right size, if its too small
        // then we must merge it with a real one before writing back!
        if (lpState->cLength < SIZEOF(CABINETSTATE))
        {
            ReadCabinetState(&state, SIZEOF(state));

            memcpy(&state, lpState, lpState->cLength);
            state.cLength = SIZEOF(CABINETSTATE);
            lpState = &state;
        }

        if ( ERROR_SUCCESS == RegCreateKey( HKEY_CURRENT_USER, c_szCabinetState, &hKey ) )
        {
            DWORD dwFullPath = lpState->fFullPathTitle ? TRUE : FALSE;

            fSuccess = ERROR_SUCCESS == RegSetValueEx( hKey,
                                                       c_szSettings,
                                                       0,
                                                       REG_BINARY,
                                                       (LPVOID)lpState, (DWORD)SIZEOF(CABINETSTATE) );

            // NOTE: We have to continue writing this key. One of the uses for it is to decide
            // whether we are pre-IE4 or not. See ReadCabinetState()...
            RegSetValueEx(hKey, c_szFullPath, 0, REG_DWORD, (LPVOID)&dwFullPath, sizeof(dwFullPath));
            RegCloseKey( hKey );
        }
    }

    if (fSuccess) 
    {
        // Notify anybody who is listening
        HANDLE hChange = SHGlobalCounterCreate(&GUID_FolderSettingsChange);
        SHGlobalCounterIncrement(hChange);
        SHGlobalCounterDestroy(hChange);
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\buytasks.h ===
#ifndef __BUYTASKS_H__
#define __BUYTASKS_H__

// used for the shopping tasks.
typedef struct
{
    LPCWSTR szURLKey;
    LPCWSTR szURLPrefix;
    BOOL bUseDefault;   // If there is no szURLKey, do we navigate with URLPrefix anyway?
} SHOP_INFO;

extern const SHOP_INFO c_BuySampleMusic;
extern const SHOP_INFO c_BuyMusic;
extern const SHOP_INFO c_BuySamplePictures;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\cdburnfldr.cpp ===
#include "shellprv.h"
#pragma  hdrstop
#include "basefvcb.h"
#include "mergfldr.h"
#include "enumidlist.h"
#include "ids.h"
#include "cdburn.h"
#include "contextmenu.h"
#include "datautil.h"

STDAPI CCDBurnFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);

class CCDBurnFolder;
HRESULT CCDBurnFolder_CreateSFVCB(CCDBurnFolder* pcdsf, IShellFolderViewCB** ppsfvcb);

class CCDBurnFolder : public CMergedFolder
{
public:
    // IUnknown
    STDMETHOD (QueryInterface)(REFIID riid, void **ppv) { return CMergedFolder::QueryInterface(riid,ppv); }
    STDMETHOD_(ULONG, AddRef)() { return CMergedFolder::AddRef(); }
    STDMETHOD_(ULONG, Release)() { return CMergedFolder::Release(); }

    // IShellFolder
    STDMETHOD(CreateViewObject)(HWND hwndOwner, REFIID riid, void **ppvOut);

    // IItemNameLimits
    STDMETHOD(GetValidCharacters)(LPWSTR *ppwszValidChars, LPWSTR *ppwszInvalidChars);
    STDMETHOD(GetMaxLength)(LPCWSTR pszName, int *piMaxNameLen);

protected:
    CCDBurnFolder(CMergedFolder *pmfParent) : CMergedFolder(pmfParent, CLSID_CDBurnFolder) {};
    friend HRESULT CCDBurnFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
    virtual HRESULT _CreateWithCLSID(CLSID clsid, CMergedFolder **ppmf);
    virtual BOOL _ShouldSuspend(REFGUID rguid);

private:
    HRESULT _CreateContextMenu(IContextMenu **ppcm);
};


STDAPI CCDBurnFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    // class factory enforces non-aggregation for us
    HRESULT hr = E_OUTOFMEMORY;
    CCDBurnFolder *p = new CCDBurnFolder(NULL);
    if (p)
    {
        hr = p->QueryInterface(riid, ppv);
        p->Release();
    }
    return hr;
}

HRESULT CCDBurnFolder::_CreateContextMenu(IContextMenu **ppcm)
{
    IShellExtInit *psei;
    HRESULT hr = CoCreateInstance(CLSID_CDBurn, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellExtInit, &psei));
    if (SUCCEEDED(hr))
    {
        IDataObject *pdo;
        hr = SHGetUIObjectOf(_pidl, NULL, IID_PPV_ARG(IDataObject, &pdo));
        if (SUCCEEDED(hr))
        {
            hr = psei->Initialize(NULL, pdo, NULL);
            if (SUCCEEDED(hr))
            {
                hr = psei->QueryInterface(IID_PPV_ARG(IContextMenu, ppcm));
            }
            pdo->Release();
        }
        psei->Release();
    }
    return hr;
}

STDMETHODIMP CCDBurnFolder::CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
{
    HRESULT hr;
    
    if (IsEqualIID(riid, IID_IShellView))
    {
        IShellFolderViewCB* psfvcb;
        hr = CCDBurnFolder_CreateSFVCB(this, &psfvcb);
        if (SUCCEEDED(hr))
        {
            SFV_CREATE csfv = {0};
            csfv.cbSize = sizeof(csfv);
            csfv.pshf = SAFECAST(this, IAugmentedShellFolder2*);
            csfv.psfvcb = psfvcb;

            hr = SHCreateShellFolderView(&csfv, (IShellView **)ppv);

            psfvcb->Release();
        }
    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        IContextMenu *pcmBase;
        hr = CMergedFolder::CreateViewObject(hwnd, IID_PPV_ARG(IContextMenu, &pcmBase));
        if (SUCCEEDED(hr))
        {
            IContextMenu *pcmCD;
            hr = _CreateContextMenu(&pcmCD);
            if (SUCCEEDED(hr))
            {
                IContextMenu* rgpcm[] = { pcmCD, pcmBase };
                hr = Create_ContextMenuOnContextMenuArray(rgpcm, ARRAYSIZE(rgpcm), riid, ppv);
                pcmCD->Release();
            }
            pcmBase->Release();
        }
    }
    else
    {
        hr = CMergedFolder::CreateViewObject(hwnd, riid, ppv);
    }

    return hr;
}


// IItemNameLimits

HRESULT CCDBurnFolder::GetValidCharacters(LPWSTR *ppwszValidChars, LPWSTR *ppwszInvalidChars)
{
    *ppwszValidChars = NULL;
    return SHStrDup(INVALID_JOLIETNAME_CHARS, ppwszInvalidChars);
}

HRESULT CCDBurnFolder::GetMaxLength(LPCWSTR pszName, int *piMaxNameLen)
{
    *piMaxNameLen = 64;
    return S_OK;
}

HRESULT CCDBurnFolder::_CreateWithCLSID(CLSID clsid, CMergedFolder **ppmf)
{
    *ppmf = new CCDBurnFolder(this);
    return *ppmf ? S_OK : E_OUTOFMEMORY;
}

HRESULT _CDGetState(DWORD *pdwCaps, BOOL *pfUDF, BOOL *pfInStaging, BOOL *pfOnMedia)
{
    ICDBurnPriv *pcdbp;
    HRESULT hr = SHCoCreateInstance(NULL, &CLSID_CDBurn, NULL, IID_PPV_ARG(ICDBurnPriv, &pcdbp));
    if (SUCCEEDED(hr))
    {
        hr = pcdbp->GetMediaCapabilities(pdwCaps, pfUDF);
        if (SUCCEEDED(hr))
        {
            hr = pcdbp->GetContentState(pfInStaging, pfOnMedia);
        }
        pcdbp->Release();
    }
    return hr;
}

BOOL CCDBurnFolder::_ShouldSuspend(REFGUID rguid)
{
    BOOL fShouldSuspend = FALSE;
    if (IsEqualGUID(rguid, CLSID_StagingFolder))
    {
        // this gets called a lot, short circuit the cocreate and go direct to the data.
        CDBurn_GetUDFState(&fShouldSuspend);
    }
    return fShouldSuspend;
}

class CCDBurnFolderViewCB : public CMergedFolderViewCB
{
public:
    STDMETHODIMP RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv) { return CMergedFolderViewCB::QueryInterface(riid,ppv); }
    STDMETHODIMP_(ULONG) AddRef(void) { return CMergedFolderViewCB::AddRef(); }
    STDMETHODIMP_(ULONG) Release(void) { return CMergedFolderViewCB::Release(); }

private:
    CCDBurnFolderViewCB(CCDBurnFolder* pcdsf);
    ~CCDBurnFolderViewCB();
    friend HRESULT CCDBurnFolder_CreateSFVCB(CCDBurnFolder* pcdsf, IShellFolderViewCB** ppsfvcb);

    CCDBurnFolder* _pcdsf;

    HRESULT OnGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData);
    HRESULT OnGetWebViewContent(DWORD pv, SFVM_WEBVIEW_CONTENT_DATA* pData);
    HRESULT OnGetWebViewTasks(DWORD pv, SFVM_WEBVIEW_TASKSECTION_DATA* pTasks);
    HRESULT OnGetWorkingDir(DWORD pv, UINT cch, PWSTR pszDir);

public:
    // Web View Task implementations
    static HRESULT _CanBurn(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanClear(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanErase(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);

    static HRESULT _OnCDBurn(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnCDClearStaging(IUnknown* pv,IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnCDErase(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
};

CCDBurnFolderViewCB::CCDBurnFolderViewCB(CCDBurnFolder* pcdsf) : CMergedFolderViewCB((CMergedFolder*)pcdsf)
{
    _pcdsf = pcdsf;
    _pcdsf->AddRef();
}

CCDBurnFolderViewCB::~CCDBurnFolderViewCB()
{
    _pcdsf->Release();
}

HRESULT CCDBurnFolder_CreateSFVCB(CCDBurnFolder* pcdsf, IShellFolderViewCB** ppsfvcb)
{
    HRESULT hr;
    CCDBurnFolderViewCB* p = new CCDBurnFolderViewCB(pcdsf);
    if (p)
    {
        *ppsfvcb = SAFECAST(p, IShellFolderViewCB*);
        hr = S_OK;
    }
    else
    {
        *ppsfvcb = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP CCDBurnFolderViewCB::RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    HANDLE_MSG(0, SFVM_GETWEBVIEWLAYOUT, OnGetWebViewLayout);
    HANDLE_MSG(0, SFVM_GETWEBVIEWCONTENT, OnGetWebViewContent);
    HANDLE_MSG(0, SFVM_GETWEBVIEWTASKS, OnGetWebViewTasks);
    HANDLE_MSG(0, SFVM_GETWORKINGDIR, OnGetWorkingDir);

    default:
        return CMergedFolderViewCB::RealMessage(uMsg, wParam, lParam);
    }

    return S_OK;
}

HRESULT CCDBurnFolderViewCB::OnGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData)
{
    ZeroMemory(pData, sizeof(*pData));
    pData->dwLayout = SFVMWVL_NORMAL | SFVMWVL_FILES;
    return S_OK;
}

HRESULT CCDBurnFolderViewCB::_CanBurn(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    *puisState = UIS_DISABLED;

    BOOL fUDF;
    if (SUCCEEDED(_CDGetState(NULL, &fUDF, NULL, NULL)))
    {
        // UDF is the only thing we check for now, we allow burn wizard to kick off without media or files
        if (!fUDF)
        {
            *puisState = UIS_ENABLED;
        }
    }
    return S_OK;
}

HRESULT CCDBurnFolderViewCB::_CanClear(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    *puisState = UIS_DISABLED;

    BOOL fInStaging, fUDF;
    if (SUCCEEDED(_CDGetState(NULL, &fUDF, &fInStaging, NULL)))
    {
        if (fInStaging && !fUDF)
        {
            *puisState = UIS_ENABLED;
        }
    }
    return S_OK;
}

HRESULT CCDBurnFolderViewCB::_CanErase(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    *puisState = UIS_DISABLED;

    DWORD dwCaps;
    BOOL fOnMedia, fUDF;
    if (SUCCEEDED(_CDGetState(&dwCaps, &fUDF, NULL, &fOnMedia)))
    {
        if ((dwCaps & HWDMC_CDREWRITABLE) && (fOnMedia || fUDF))
        {
            *puisState = UIS_ENABLED;
        }
    }
    return S_OK;
}

HRESULT _InvokeVerbOnCDBurn(HWND hwnd, LPCSTR pszVerb)
{
    IContextMenu *pcm;
    HRESULT hr = CoCreateInstance(CLSID_CDBurn, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IContextMenu, &pcm));
    if (SUCCEEDED(hr))
    {
        hr = SHInvokeCommandOnContextMenu(hwnd, NULL, pcm, 0, pszVerb);
        pcm->Release();
    }
    return hr;
}

HRESULT CCDBurnFolderViewCB::_OnCDBurn(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CCDBurnFolderViewCB* pThis = (CCDBurnFolderViewCB*)(void*)pv;
    return _InvokeVerbOnCDBurn(pThis->_hwndMain, "burn");
}
HRESULT CCDBurnFolderViewCB::_OnCDClearStaging(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CCDBurnFolderViewCB* pThis = (CCDBurnFolderViewCB*)(void*)pv;
    return _InvokeVerbOnCDBurn(pThis->_hwndMain, "cleanup");
}
HRESULT CCDBurnFolderViewCB::_OnCDErase(IUnknown* pv,IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CCDBurnFolderViewCB* pThis = (CCDBurnFolderViewCB*)(void*)pv;
    return _InvokeVerbOnCDBurn(pThis->_hwndMain, "erase");
}

const WVTASKITEM c_CDBurnTaskHeader = WVTI_HEADER(L"shell32.dll", IDS_HEADER_CDBURN, IDS_HEADER_CDBURN_TT);
const WVTASKITEM c_CDBurnTaskList[] =
{
    WVTI_ENTRY_ALL(CLSID_NULL, L"shell32.dll", IDS_TASK_BURNCD,        IDS_TASK_BURNCD_TT,        IDI_TASK_BURNCD,        CCDBurnFolderViewCB::_CanBurn,  CCDBurnFolderViewCB::_OnCDBurn),
    WVTI_ENTRY_ALL(CLSID_NULL, L"shell32.dll", IDS_TASK_CLEARBURNAREA, IDS_TASK_CLEARBURNAREA_TT, IDI_TASK_CLEARBURNAREA, CCDBurnFolderViewCB::_CanClear, CCDBurnFolderViewCB::_OnCDClearStaging),
    WVTI_ENTRY_ALL(CLSID_NULL, L"shell32.dll", IDS_TASK_ERASECDFILES,  IDS_TASK_ERASECDFILES_TT,  IDI_TASK_ERASECDFILES,  CCDBurnFolderViewCB::_CanErase, CCDBurnFolderViewCB::_OnCDErase),
};

HRESULT CCDBurnFolderViewCB::OnGetWebViewContent(DWORD pv, SFVM_WEBVIEW_CONTENT_DATA* pData)
{
    ZeroMemory(pData, sizeof(*pData));
    Create_IUIElement(&c_CDBurnTaskHeader, &(pData->pSpecialTaskHeader));
    return S_OK;
}

HRESULT CCDBurnFolderViewCB::OnGetWebViewTasks(DWORD pv, SFVM_WEBVIEW_TASKSECTION_DATA* pTasks)
{
    ZeroMemory(pTasks, sizeof(*pTasks));
    pTasks->dwUpdateFlags = SFVMWVTSDF_CONTENTSCHANGE;
    Create_IEnumUICommand((IUnknown*)(void*)this, c_CDBurnTaskList, ARRAYSIZE(c_CDBurnTaskList), &pTasks->penumSpecialTasks);
    return S_OK;
}

HRESULT CCDBurnFolderViewCB::OnGetWorkingDir(DWORD pv, UINT cch, PWSTR pszDir)
{
    HRESULT hr = E_FAIL;
    DWORD dwNSId;
    GUID guid;
    IShellFolder *psf;
    BOOL fDone = FALSE;
    for (DWORD dwIndex = 0; 
         !fDone && SUCCEEDED(_pmf->EnumNameSpace(dwIndex, &dwNSId)) && SUCCEEDED(_pmf->QueryNameSpace(dwNSId, &guid, &psf));
         dwIndex++)
    {
        if (IsEqualGUID(guid, CLSID_CDBurn))
        {
            LPITEMIDLIST pidl;
            hr = SHGetIDListFromUnk(psf, &pidl);
            if (SUCCEEDED(hr))
            {
                WCHAR sz[MAX_PATH];
                hr = SHGetPathFromIDList(pidl, sz) ? S_OK : E_FAIL;
                if (SUCCEEDED(hr))
                {
                    lstrcpyn(pszDir, sz, cch);
                }
                ILFree(pidl);
            }
            fDone = TRUE;
        }                
        psf->Release();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\cdburn.h ===
#ifndef __CDBURN_H__
#define __CDBURN_H__


#define INVALID_JOLIETNAME_CHARS L"\\/:*?|<>;"

EXTERN_C const CLSID CLSID_StagingFolder;

HRESULT CDBurn_GetCDInfo(LPCTSTR pszVolume, DWORD *pdwDriveCapabilities, DWORD *pdwMediaCapabilities);

HRESULT CDBurn_OnDeviceChange(BOOL fAdd, LPCWSTR pszDrive);
HRESULT CDBurn_OnMediaChange(BOOL fInsert, LPCWSTR pszDrive);
HRESULT CDBurn_OnEject(HWND hwnd, INT iDrive);

HRESULT CDBurn_GetExtensionObject(DWORD dwType, IDataObject *pdo, REFIID riid, void **ppv);
STDAPI CheckStagingArea();
STDAPI CDBurn_GetRecorderDriveLetter(LPWSTR pszDrive, UINT cch);
void CDBurn_GetUDFState(BOOL *pfUDF);


#endif // __CDBURN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\category.h ===
#ifndef CATEGORY_H
#define CATEGORY_H

#define BEGIN_CATEGORY_LIST(name)   const CATLIST name[] = {
#define CATEGORY_ENTRY_GUID(guid)  {(const GUID*)&guid, (const SHCOLUMNID*)NULL},
#define CATEGORY_ENTRY_SCIDMAP(scid, guid)  {(const GUID*)&guid, (const SHCOLUMNID*)&scid},
#define END_CATEGORY_LIST()     {(const GUID*)&GUID_NULL, (const SHCOLUMNID*)NULL}};

STDAPI CCategoryProvider_Create(const GUID* pguid, const SHCOLUMNID* pscid, HKEY hkey, const CATLIST* pcl, IShellFolder* psf, REFIID riid, void **ppv);
STDAPI CDetailCategorizer_Create(const SHCOLUMNID& pscid, IShellFolder2* psf2, REFIID riid, void **ppv);
STDAPI CSizeCategorizer_Create(IShellFolder2* psf2, REFIID riid, void **ppv);
STDAPI CTimeCategorizer_Create(IShellFolder2* psf2, const SHCOLUMNID* pscid, REFIID riid, void **ppv);
STDAPI CAlphaCategorizer_Create(IShellFolder2* psf2, REFIID riid, void **ppv);

EXTERN_C const GUID CLSID_DetailCategorizer;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\cdburn.cpp ===
#include "shellprv.h"
#include "ids.h"
#include "views.h"
#include "stgutil.h"
#include "imapi.h"
#include "propsht.h"
#include "mtpt.h"
#include "shcombox.h"
#include "datautil.h"
#include "fstreex.h"
#include "balmsg.h"
#include <imapierror.h>
#include <imapi/imapiregistry.h>
#include "cowsite.h"
#include <cfgmgr32.h>
#include "cdmedia.h"
#include <lmcons.h>
#include "prop.h"
#include "clsobj.h"
#include "filetbl.h"
#include "cdburn.h"
#include "setupapi.h"
#include "isproc.h"
#include "ole2dup.h"
#include "copy.h"
#pragma hdrstop

#define REGSTR_PATH_CDBURNING   REGSTR_PATH_EXPLORER   TEXT("\\CD Burning")
#define REGSTR_PATH_DRIVES      REGSTR_PATH_CDBURNING  TEXT("\\Drives")
#define REGSTR_PATH_HANDLERS    REGSTR_PATH_CDBURNING  TEXT("\\Extensions")
#define REGSTR_PATH_PERMEDIA    REGSTR_PATH_CDBURNING  TEXT("\\Current Media")
#define REGSTR_PATH_EXCLUDE     REGSTR_PATH_CDBURNING  TEXT("\\ExcludedFS")

#define REGSTR_PATH_AUDIOEXTS   REGSTR_PATH_CDBURNING  TEXT("\\AudioBurnHandlers")
#define REGVALUE_FILEEXTS       TEXT("SupportedFileTypes")

#define REGSTR_PATH_IMAPI       TEXT(IMAPI_PRODUCT_REGPATH) TEXT(IMAPI_REGKEY_STASHFILE)

#define REGVALUE_CURRENTDRIVE   TEXT("CD Recorder Drive")
#define REGVALUE_AUTOEJECT      TEXT("Auto Eject")
#define REGVALUE_AUTOCLOSE      TEXT("Auto Close")
#define REGVALUE_FIRSTHANDLER   TEXT("FirstHandler")
#define REGVALUE_CLSID          TEXT("CLSID")
#define REGVALUE_VERB           TEXT("verb")
#define REGVALUE_CACHEDINDEX    TEXT("DriveIndex")

#define REGVALUE_DRIVETYPE      TEXT("Drive Type")
#define REGVALUE_CURRENTSPEED   TEXT("CurrentCDWriteSpeed")
#define REGVALUE_MAXSPEED       TEXT("MaxCDWriteSpeed")
#define REGVALUE_TOTALBYTES     TEXT("TotalBytes")
#define REGVALUE_FREEBYTES      TEXT("FreeBytes")
#define REGVALUE_MEDIATYPE      TEXT("Media Type")
#define REGVALUE_UDF            TEXT("UDF")
#define REGVALUE_DISCLABEL      TEXT("Disc Label")
#define REGVALUE_SET            TEXT("Set")

#define REGVALUE_ERASETIME      TEXT("Erase Time")
#define REGVALUE_STAGERATE      TEXT("Stage Rate")
#define REGVALUE_BURNRATE       TEXT("Burn Rate")
#define REGVALUE_CLOSEFACTOR    TEXT("Close Factor")

#define WRITESPEED_FASTEST      0xFFFFFFFF
#define STASH_FILENAME          TEXT("CD Burning Stash File.bin")
#define JOLIET_MAX_LABEL        16

#define PROPSTR_EJECT           TEXT("Eject")
#define PROPSTR_ERASE           TEXT("Erase")
#define PROPSTR_HR              TEXT("HR")
#define PROPSTR_DISCLABEL       REGVALUE_DISCLABEL
#define PROPSTR_AUTOCLOSE       REGVALUE_AUTOCLOSE
#define PROPSTR_DISCFULLTEXT    TEXT("DiscFullText")
#define PROPSTR_CURRENTEXT      TEXT("CurrentExt")
#define PROPSTR_FAILSILENTLY    TEXT("FailSilently")
#define PROPSTR_STATUSTEXT      TEXT("StatusText")

#define INDEX_DLG_BURNWIZ_MAX   30

#define PROGRESS_INCREMENTS 1000

enum {
    DRIVE_USEEXISTING = 0,
    DRIVE_CDR = RECORDER_CDR,
    DRIVE_CDRW = RECORDER_CDRW,
    DRIVE_NOTSUPPORTED
};

#define SUPPORTED(x) ((x) && !((x) == DRIVE_NOTSUPPORTED))

typedef struct
{
    INT idPage;
    INT idHeading;
    INT idSubHeading;
    DWORD dwFlags;
    DLGPROC dlgproc;
} WIZPAGE;

typedef struct
{
    DWORD dwSecStaging, dwTickStagingStart, dwTickStagingEnd;
    DWORD dwSecBurn, dwTickBurnStart, dwTickBurnEnd;
    DWORD dwSecClose, dwTickCloseStart, dwTickCloseEnd;
    DWORD dwSecErase, dwTickEraseStart, dwTickEraseEnd;
    DWORD dwSecRemaining, dwSecTotal;
} TIMESTATS;

class CCDBurn;
typedef struct
{
    CCDBurn *pcdb;
    IStream *pstmDataObj;
    BOOL     fMove;
} CDDROPPARAMS;

// CLSIDs used for merged namespace for CD mastering

/* 00da2f99-f2a6-40c2-b770-a920f8e44abc */
const CLSID CLSID_StagingFolder = {0x00da2f99, 0xf2a6, 0x40c2, {0xb7, 0x70, 0xa9, 0x20, 0xf8, 0xe4, 0x4a, 0xbc}};

// CDBurn - object which performs the CDBurning and displaying the progress etc.
class CCDBurn : public CObjectWithSite,
                public IShellExtInit,
                public IContextMenu,
                public IShellPropSheetExt,
                public IDiscMasterProgressEvents,
                public IDropTarget,
                public IPersistFile,
                public IOleCommandTarget,
                public ICDBurn,
                public ICDBurnPriv,
                public IPersistPropertyBag,
                public IDriveFolderExt,
                public INamespaceWalkCB,
                public IWizardSite,
                public IServiceProvider,
                public ITransferAdviseSink,
                public IQueryCancelAutoPlay
{
public:
    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IPersist methods
    STDMETHOD(GetClassID)(CLSID *pClassID)
        { *pClassID = CLSID_CDBurn; return S_OK; };

    // IPersistFile methods
    STDMETHOD(IsDirty)(void)
        { return S_FALSE; };
    STDMETHOD(Load)(LPCOLESTR pszFileName, DWORD dwMode)
        { return S_OK; };
    STDMETHOD(Save)(LPCOLESTR pszFileName, BOOL fRemember)
        { return S_OK; };
    STDMETHOD(SaveCompleted)(LPCOLESTR pszFileName)
        { return S_OK; };
    STDMETHOD(GetCurFile)(LPOLESTR *ppszFileName)
        { *ppszFileName = NULL; return S_OK; };

    // IDropTarget methods
    STDMETHOD(DragEnter)(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHOD(DragOver)(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHOD(DragLeave)(void);
    STDMETHOD(Drop)(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // IShellExtInit methods
    STDMETHOD(Initialize)(LPCITEMIDLIST pidlFolder, LPDATAOBJECT lpdobj, HKEY hkeyProgID);

    // IContextMenu methods
    STDMETHOD(QueryContextMenu)(HMENU hMenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(GetCommandString)(UINT_PTR idCommand, UINT uFlags, LPUINT lpReserved, LPSTR pszName, UINT uMaxNameLen);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpcmi);

    // IShellPropSheetExt methods
    STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE pAddPageProc, LPARAM lParam);
    STDMETHOD(ReplacePage)(UINT uPageID, LPFNADDPROPSHEETPAGE pReplacePageFunc, LPARAM lParam)
        { return S_OK; };

    // IDiscMasterProgressEvents methods
    STDMETHOD(QueryCancel)(boolean *pbCancel);
    STDMETHOD(NotifyPnPActivity)();
    STDMETHOD(NotifyAddProgress)(long nCompletedSteps, long nTotalSteps);
    STDMETHOD(NotifyBlockProgress)(long nCompleted, long nTotal);
    STDMETHOD(NotifyTrackProgress)(long nCurrentTrack, long nTotalTracks);
    STDMETHOD(NotifyPreparingBurn)(long nEstimatedSeconds);
    STDMETHOD(NotifyClosingDisc)(long nEstimatedSeconds);
    STDMETHOD(NotifyBurnComplete)(HRESULT status);
    STDMETHOD(NotifyEraseComplete)(HRESULT status);

    // IOleCommandTarget methods
    STDMETHOD(QueryStatus)(const GUID* pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT* pCmdText);
    STDMETHOD(Exec)(const GUID* pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG* pvaIn, VARIANTARG* pvaOut);

    // ICDBurn methods
    STDMETHOD(GetRecorderDriveLetter)(LPWSTR pszDrive, UINT cch);
    STDMETHOD(Burn)(HWND hwnd);
    STDMETHOD(HasRecordableDrive)(BOOL *pfHasRecorder);

    // ICDBurnPriv methods
    STDMETHOD(GetMediaCapabilities)(DWORD *pdwCaps, BOOL *pfUDF);
    STDMETHOD(GetContentState)(BOOL *pfStagingHasFiles, BOOL *pfDiscHasFiles);
    STDMETHOD(IsWizardUp)();

    // IPersistPropertyBag methods
    STDMETHOD(InitNew)();
    STDMETHOD(Load)(IPropertyBag *ppb, IErrorLog *pErr);
    STDMETHOD(Save)(IPropertyBag *ppb, BOOL fClearDirty, BOOL fSaveAll)
        { return E_NOTIMPL; }

    // IDriveFolderExt methods
    STDMETHOD(DriveMatches)(int iDrive);
    STDMETHOD(Bind)(LPCITEMIDLIST pidl, IBindCtx *pbc, REFIID riid, void **ppv);
    STDMETHOD(GetSpace)(ULONGLONG *pcbTotal, ULONGLONG *pcbFree);

    // INamespaceWalkCB methods
    STDMETHOD(FoundItem)(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHOD(EnterFolder)(IShellFolder *psf, LPCITEMIDLIST pidl)
        { return S_OK; }
    STDMETHOD(LeaveFolder)(IShellFolder *psf, LPCITEMIDLIST pidl)
        { return S_OK; }
    STDMETHOD(InitializeProgressDialog)(LPWSTR *ppszTitle, LPWSTR *ppszCancel)
        { *ppszTitle = NULL; *ppszCancel = NULL; return E_NOTIMPL; }

    // IWizardSite methods
    STDMETHOD(GetNextPage)(HPROPSHEETPAGE *phPage);
    STDMETHOD(GetPreviousPage)(HPROPSHEETPAGE *phPage);
    STDMETHOD(GetCancelledPage)(HPROPSHEETPAGE *phPage)
        { return E_NOTIMPL; }

    // IServiceProvider methods
    STDMETHOD(QueryService)(REFGUID guidService, REFIID riid, void **ppv);

    // IQueryCancelAutoPlay methods
    STDMETHOD(AllowAutoPlay)(LPCWSTR pszPath, DWORD dwContentType, LPCWSTR pszLabel, DWORD dwSerialNumber);

    // ITransferAdviseSink methods
    STDMETHOD(PreOperation)(const STGOP op, IShellItem *psiItem, IShellItem *psiDest)
        { return S_OK; }
    STDMETHOD(ConfirmOperation)(IShellItem *psiSource, IShellItem *psiDest, STGTRANSCONFIRMATION stc, LPCUSTOMCONFIRMATION pcc);
    STDMETHOD(OperationProgress)(const STGOP op, IShellItem *psiItem, IShellItem *psiDest, ULONGLONG ullTotal, ULONGLONG ullComplete)
        { return S_OK; }
    STDMETHOD(PostOperation)(const STGOP op, IShellItem *psiItem, IShellItem *psiDest, HRESULT hrResult)
        { return S_OK; }
    STDMETHOD(QueryContinue)()
        { return S_OK; }

    // exposed for the static tables 
    static INT_PTR s_WelcomeDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CCDBurn *pcdb = s_GetCDBurn(hwnd, uMsg, lParam); return pcdb->_WelcomeDlgProc(hwnd, uMsg, wParam, lParam); }
    static INT_PTR s_EjectDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CCDBurn *pcdb = s_GetCDBurn(hwnd, uMsg, lParam); return pcdb->_EjectDlgProc(hwnd, uMsg, wParam, lParam); }
    static INT_PTR s_ProgressDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CCDBurn *pcdb = s_GetCDBurn(hwnd, uMsg, lParam); return pcdb->_ProgressDlgProc(hwnd, uMsg, wParam, lParam); }
    static INT_PTR s_DoneDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CCDBurn *pcdb = s_GetCDBurn(hwnd, uMsg, lParam); return pcdb->_DoneDlgProc(hwnd, uMsg, wParam, lParam); }
    static INT_PTR s_WaitForMediaDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CCDBurn *pcdb = s_GetCDBurn(hwnd, uMsg, lParam); return pcdb->_WaitForMediaDlgProc(hwnd, uMsg, wParam, lParam); }
    static INT_PTR s_StartEraseDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CCDBurn *pcdb = s_GetCDBurn(hwnd, uMsg, lParam); return pcdb->_StartEraseDlgProc(hwnd, uMsg, wParam, lParam); }
    static INT_PTR s_DiskFullDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CCDBurn *pcdb = s_GetCDBurn(hwnd, uMsg, lParam); return pcdb->_DiskFullDlgProc(hwnd, uMsg, wParam, lParam); }
    static INT_PTR s_EarlyExitDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CCDBurn *pcdb = s_GetCDBurn(hwnd, uMsg, lParam); return pcdb->_EarlyExitDlgProc(hwnd, uMsg, wParam, lParam); }
    static INT_PTR s_HDFullDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CCDBurn *pcdb = s_GetCDBurn(hwnd, uMsg, lParam); return pcdb->_HDFullDlgProc(hwnd, uMsg, wParam, lParam); }
    static INT_PTR s_NoFilesDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CCDBurn *pcdb = s_GetCDBurn(hwnd, uMsg, lParam); return pcdb->_NoFilesDlgProc(hwnd, uMsg, wParam, lParam); }

private:
    CCDBurn();
    ~CCDBurn();

    LONG _cRef;
    TCHAR _szVolumeName[MAX_PATH];  // device path of the drive that we were invoked on

    IDataObject *_pdo;              // IDataObject (from IShellExtInit::Initialize)
    LPITEMIDLIST _pidl;             // pidl we're sited on (only for droptarget, through IShellExtInit::Initialize)

    BOOL _fCancelled;
    BOOL _fRecording;
    BOOL _fIsRecordingDrive;        // if this is the current recording drive (on init)
    BOOL _fPropSheetDirty;

    IDropTarget *_pdt;              // IDropTarget object that we wrap
    DWORD _dwDropEffect;            // drop effect chosen in dragenter

    IPropertyBag *_ppb;             // propertybag to track state in wizard
    HWND _hwndWizardPage;           // hwnd of the wizard page (used in progress)
    HWND _hwndBrowser;              // browser hwnd, used to parent error dialogs
    
    ULONGLONG _cbStagedSize;        // total size of staged files
    DWORD _dwCurSpeed;              // current burning speed
    DWORD _dwTimeSet, _dwLastTime;  // state variables for showing estimated time remaining
    TIMESTATS _ts;

    HDPA _hdpaExts;                 // pointers to the extensibility objects
    HPROPSHEETPAGE _rgWizPages[INDEX_DLG_BURNWIZ_MAX];

    HANDLE _hMutexBurning;          // this tells us if we're burning or not.
    static HWND s_hwndWiz;          // we can call SetForegroundWindow on this to bring up the wizard if its already up
    static BOOL s_fDriveInUse;

    DWORD _dwROTRegister;           // DWORD to track our moniker stuff for autoplay cancellation

    // namespace
    static HRESULT _GetPidlForDriveIndex(int iDrive, LPITEMIDLIST *ppidl);
    static HRESULT _GetPidlForVolumeName(LPCTSTR pszVolume, LPITEMIDLIST *ppidl);
    static HRESULT _GetFolderPidl(LPITEMIDLIST *ppidl);
    static HRESULT _GetBurnStagingPath(LPTSTR pszPath, UINT cchBuf);
    static HRESULT _GetPlainCDPidl(LPITEMIDLIST *ppidl);
    static BOOL _HasFiles(LPCITEMIDLIST pidl);
    static BOOL _StagingAreaHasFiles();
    static BOOL _DiscHasFiles();
    static HRESULT _GetStagingFolder(LPCITEMIDLIST pidlDrive, REFIID riid, void **ppv);

    // drop / transfer engine
    HRESULT _EnsureDropTarget();
    static void _FreeDropParams(CDDROPPARAMS *pcddp);
    static DWORD WINAPI _DropThread(void *pv);
    HRESULT _GetDropPidl(LPITEMIDLIST *ppidl);
    HRESULT _StorageDrop(IDataObject *pdtobj, BOOL fMove);
    BOOL    _IsStagingAreaSource(IDataObject *pdtobj, LPCITEMIDLIST pidlDrop);
    HRESULT _StagingPidlFromMerged(LPCITEMIDLIST pidlDrop, LPITEMIDLIST *ppidlDest);

    static HRESULT _LockCurrentDrive(BOOL fLock, BOOL fForce = FALSE);

    // initialization helpers
    static DWORD WINAPI _ExecThread(void *pv);

    // registry and cached info management
    static HRESULT _GetCurrentBurnVolumeName(LPTSTR pszVolumeName, UINT cchBuf);
    static HRESULT _SetCurrentBurnVolumeName(LPCTSTR pszVolumeName, BOOL fDelete);
    static BOOL _BurningIsEnabled();
    static HRESULT _GetStashFile(LPTSTR pszFile, UINT cchBuf);
    static HRESULT _GetCurrentStashDrive(LPTSTR pszDrive, UINT cchBuf);
    static HRESULT _SetCurrentStashDrive(LPCTSTR pszDrive);
    static HRESULT _DumpDiscInfo();
    static HRESULT _GetDiscInfoUsingIMAPI(IJolietDiscMaster *pjdm, IDiscRecorder *pdr, ULONGLONG *pcbFree);
    static HRESULT _GetDiscInfoUsingFilesystem(ULONGLONG *pcbTotal, ULONGLONG *pcbFree, BOOL *pfUDF);
    static HRESULT _StoreDiscInfo();
    static HRESULT _GetDiscRecorderInfo(IDiscRecorder *pdr, DWORD *pdwCurrentWriteSpeed, DWORD *pdwMaxWriteSpeed, DWORD *pdwDriveType);
    HRESULT _SetRecorderProps(IDiscRecorder *pdr, DWORD dwWriteSpeed);
    HRESULT _SetJolietProps(IJolietDiscMaster *pjdm);
    static HRESULT _GetCachedDriveInfo(LPCTSTR pszVolumeName, DWORD *pdwDriveType, DWORD *pdwCurWrite, DWORD *pdwMaxWrite);
    static HRESULT _SetCachedDriveInfo(LPCTSTR pszVolumeName, DWORD dwDriveType, DWORD dwCurWrite, DWORD dwMaxWrite);
    HRESULT _GetEjectSetting(BOOL *pfEject);
    HRESULT _SetEjectSetting(BOOL fEject);
    static HRESULT _GetRecorderPath(IDiscRecorder *pdr, LPTSTR pszPath, UINT cchBuf);
    static void _PruneRemovedDevices();

    // drive helpers
    static HRESULT _GetMediaCapabilities(DWORD *pdwCaps, BOOL *pfUDF);
    static HRESULT _GetVolumeNameForDriveIndex(int iDrive, LPTSTR pszVolumeName, UINT cchBuf);
    static HRESULT _GetDriveIndexForVolumeName(LPCTSTR pszVolumeName, int *piDrive);
    static HRESULT _GetCurrentDriveIndex(int *piDrive);
    static HRESULT _GetVolumeNameForDevicePath(LPCTSTR pszDevice, LPTSTR pszVolumeName, UINT cchBuf);
    static BOOL _DevicePathMatchesVolumeName(LPCTSTR pszDevice, LPCTSTR pszVolumeName);
    static DWORD _ExecSyncIoctl(HANDLE hDriver, DWORD dwIoctl, void *pbuf, DWORD cbBuf);
    static BOOL _CouldPossiblySupport(LPCWSTR pszVolume);
    HRESULT _GetVolumeNameFromDataObject(BOOL fCheckIsConfiguredDrive, LPTSTR pszVolumeName, UINT cchBuf);
    HRESULT _CheckTotal();
    HRESULT _Validate();
    static BOOL _HasMedia();

    // main IMAPI helpers
    HRESULT _GetDriveInfo(LPCTSTR pszVolumeName, DWORD *pdwDriveType, DWORD *pdwCurWrite, DWORD *pdwMaxWrite);
    HRESULT _GetDiscMasters(IDiscMaster **ppdm, IJolietDiscMaster **ppjdm);
    HRESULT _GetDiscRecorderForDrive(IDiscMaster *pdm, LPCTSTR pszVolumeName, IDiscRecorder **ppdr);
    HRESULT _FindAndSetRecorder(LPCTSTR pszVolumeName, IDiscMaster *pdm, BOOL fSetActive, IDiscRecorder **ppdr);
    HRESULT _FindAndSetDefaultRecorder(IDiscMaster *pdm, BOOL fSetActive, IDiscRecorder **ppdr);
    HRESULT _AddData(IJolietDiscMaster *pjdm);
    static BOOL _IsBurningNow();
    BOOL _EnterExclusiveBurning();
    void _LeaveExclusiveBurning();
    static void _HandleBookkeeping();

    // property sheet stuff
    void _MarkDirty(HWND hDlg);
    static BOOL_PTR CALLBACK s_DlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
    void _EnableRecordingDlgArea(HWND hwnd, BOOL fEnable);
    void _RecordingPrshtInit(HWND hDlg);
    BOOL _HandleApply(HWND hDlg);

    // UI
    HRESULT _Balloon();
    static BOOL CALLBACK _EnumProc(HWND hwnd, LPCITEMIDLIST pidl, LPARAM lParam);
    static BOOL _BurningFolderOpen();
    static DWORD CALLBACK _NotifyThreadProc(void *pv);
    void _CheckStagingArea();

    // wizard
    void _SetStatus(UINT uID);
    HRESULT _CreateDefaultPropBag(REFIID riid, void **ppv);
    static CCDBurn* s_GetCDBurn(HWND hwnd, UINT uMsg, LPARAM lParam);
    void _SetupFirstPage(HWND hwnd, BOOL fSubclass);
    static LRESULT CALLBACK _WizSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uID, DWORD_PTR dwRefData);
    HRESULT _GetBurnHR();
    void _ShowRoxio();
    INT_PTR _WelcomeDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _EjectDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _ProgressDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _DoneDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _WaitForMediaDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _StartEraseDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _DiskFullDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _EarlyExitDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _HDFullDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _NoFilesDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _HDFullSetText(HWND hwnd);
    void _InitProgressPage(HWND hwnd);
    void _SetEstimatedTime(DWORD dwSeconds);
    void _ConstructTimeString(DWORD dwEstTime, LPTSTR psz, UINT cch);
    void _DisplayEstimatedTime(HWND hwnd);
    void _InitTimeStats(BOOL fErase);
    void _SaveTimeStats(BOOL fErase);
    void _SetUpStartPage(HWND hwnd);
    void _LeaveStartPage(HWND hwnd);
    void _DisplayMediaErrorOnNext(HWND hwnd, UINT idMsg, UINT idMsgInsert);
    void _SetNextPage(HWND hwnd, int iIndex);
    HRESULT _PostOperation();
    HRESULT _ShowWizard();
    HRESULT _ShowWizardOnSeparateThread();
    static DWORD WINAPI _WizardThreadWrapper(void *pv);
    HRESULT _WizardThreadProc();
    void _RegisterAutoplayCanceller();
    void _UnregisterAutoplayCanceller();

    // verbs
    HRESULT _GetVerb(UINT_PTR idCmd, LPSTR pszName, UINT cchMax, BOOL bUnicode);
    static INT_PTR CALLBACK _ConfirmDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    HRESULT _CleanUp(LPCMINVOKECOMMANDINFO lpcmi, BOOL fRecycle);
    HRESULT _PrepWiz(LPCMINVOKECOMMANDINFO lpcmi, BOOL fErase, BOOL fFailSilently);
    static DWORD WINAPI _BurnThread(void *pv);
    static DWORD WINAPI _EraseThread(void *pv);
    
    // extensibility
    void _PruneExts();
    static HRESULT _TryCLSID(REFCLSID clsid, DWORD dwExtType, REFIID riid, void **ppv);
    static HRESULT _TryKey(LPTSTR pszKey, DWORD dwExtType, REFIID riid, void **ppv);
    static HRESULT _TestDropEffect(IDropTarget *pdt, IDataObject *pdo, REFIID riid, void **ppv);
    static HRESULT _TryCLSIDWithDropEffect(REFCLSID clsid, DWORD dwExtType, IDataObject *pdo, REFIID riid, void **ppv);
    static HRESULT _TryKeyWithDropEffect(LPTSTR pszKey, DWORD dwExtType, IDataObject *pdo, REFIID riid, void **ppv);
    void _AddExtensionToDPA(IWizardExtension *pwe, HPROPSHEETPAGE *rgPages, UINT cNumPages, UINT *pcPagesAdded);
    HRESULT _FillExtensionDPA(HPROPSHEETPAGE *rgPages, UINT cNumPages, UINT *pcPagesAdded);
    HRESULT _GetExtPage(int nExt, BOOL fNext, HPROPSHEETPAGE *phpage);
    HRESULT _GetExtPageFromPropBag(BOOL fNext, HPROPSHEETPAGE *phpage);
    void _SetExtPageFromPropBag(HWND hwnd, BOOL fNext);

    // "exports"
    friend HRESULT CCDBurn_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
    friend HRESULT CDBurn_OnEject(HWND hwnd, INT iDrive);
    friend HRESULT CDBurn_OnDeviceAdded(DWORD dwDriveMask, BOOL fFullRefresh, BOOL fPickNewDrive);
    friend HRESULT CDBurn_OnDeviceRemoved(DWORD dwDriveMask);
    friend HRESULT CDBurn_GetCDInfo(LPCTSTR pszVolume, DWORD *pdwDriveCapabilities, DWORD *pdwMediaCapabilities);
    friend HRESULT CDBurn_OnMediaChange(BOOL fInsert, LPCWSTR pszDrive);
    friend HRESULT CDBurn_GetExtensionObject(DWORD dwExtType, IDataObject *pdo, REFIID riid, void **ppv);
    friend HRESULT CheckStagingArea();
};
HWND CCDBurn::s_hwndWiz = NULL;
BOOL CCDBurn::s_fDriveInUse = FALSE;

const static DWORD aPrshtHelpIDs[] = 
{
    IDC_RECORD_ENABLE,     IDH_CDMEDIA_ENABLERECORDING,
    IDC_RECORD_TEXTIMAGE,  IDH_CDMEDIA_STOREDISCIMAGE,
    IDC_RECORD_IMAGELOC,   IDH_CDMEDIA_STOREDISCIMAGE,
    IDC_RECORD_TEXTWRITE,  IDH_CDMEDIA_WRITESPEED,
    IDC_RECORD_WRITESPEED, IDH_CDMEDIA_WRITESPEED,
    IDC_RECORD_EJECT,      IDH_CDMEDIA_EJECT,
    0, 0
};


CCDBurn::CCDBurn() :
    _cRef(1)
{
    DllAddRef();
}

CCDBurn::~CCDBurn()
{
    if (_pdo)
    {
        _pdo->Release();
    }
    if (_pdt)
    {
        _pdt->Release();
    }
    ILFree(_pidl);
    if (_hMutexBurning)
    {
        CloseHandle(_hMutexBurning);
    }
    DllRelease();
}

// IUnknown

STDMETHODIMP_(ULONG) CCDBurn::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CCDBurn::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CCDBurn::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CCDBurn, IObjectWithSite),
        QITABENT(CCDBurn, IContextMenu),
        QITABENT(CCDBurn, IShellExtInit),
        QITABENT(CCDBurn, IShellPropSheetExt),
        QITABENT(CCDBurn, IDiscMasterProgressEvents),
        QITABENT(CCDBurn, IDropTarget),
        QITABENT(CCDBurn, IPersistFile),
        QITABENT(CCDBurn, IOleCommandTarget),
        QITABENT(CCDBurn, ICDBurn),
        QITABENT(CCDBurn, ICDBurnPriv),
        QITABENT(CCDBurn, IPersistPropertyBag),
        QITABENT(CCDBurn, IDriveFolderExt),
        QITABENT(CCDBurn, INamespaceWalkCB),
        QITABENT(CCDBurn, IWizardSite),
        QITABENT(CCDBurn, IServiceProvider),
        QITABENT(CCDBurn, IQueryCancelAutoPlay),
        QITABENT(CCDBurn, ITransferAdviseSink),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDAPI CCDBurn_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv)
{
    if (punkOuter)
        return CLASS_E_NOAGGREGATION;

    if (SHRestricted(REST_NOCDBURNING))
        return E_FAIL;

    CCDBurn *pcdb = new CCDBurn();
    if (!pcdb)
        return E_OUTOFMEMORY;

    HRESULT hr = pcdb->QueryInterface(riid, ppv);
    pcdb->Release();
    return hr;
}


// IShellExtInit

STDMETHODIMP CCDBurn::Initialize(LPCITEMIDLIST pidlFolder, IDataObject* pdo, HKEY hkeyProgID)
{
    if (!pdo && !pidlFolder)
        return E_INVALIDARG;

    IUnknown_Set((IUnknown **)&_pdo, (IUnknown *)pdo);
    Pidl_Set(&_pidl, pidlFolder);

    return (_pidl || _pdo) ? S_OK : E_FAIL;
}

HRESULT CCDBurn::_GetVolumeNameFromDataObject(BOOL fCheckIsConfiguredDrive, LPTSTR pszVolumeName, UINT cchBuf)
{
    HRESULT hr = E_FAIL;
    if (!SHRestricted(REST_NOCDBURNING) && _pdo)
    {
        STGMEDIUM medium;
        LPIDA pida = DataObj_GetHIDA(_pdo, &medium);
        if (pida)
        {
            // we only display the page if there is a single item selected
            if (pida->cidl == 1)
            {
                // get the IDLIST an try to determine the drive we are showing this for
                LPITEMIDLIST pidl = IDA_ILClone(pida, 0);
                if (pidl)
                {
                    TCHAR szPath[MAX_PATH];
                    SHGetPathFromIDList(pidl, szPath);

                    // only go farther if the drive is a CD ROM
                    if ((GetDriveType(szPath) == DRIVE_CDROM) &&
                        (GetVolumeNameForVolumeMountPoint(szPath, pszVolumeName, cchBuf)))
                    {
                        hr = S_OK;
                        if (fCheckIsConfiguredDrive)
                        {
                            TCHAR szCurrent[MAX_PATH];
                            hr = _GetCurrentBurnVolumeName(szCurrent, ARRAYSIZE(szCurrent));
                            if (SUCCEEDED(hr))
                            {
                                hr = (lstrcmpi(szCurrent, pszVolumeName) == 0) ? S_OK : E_FAIL;
                            }
                        }
                    }
                    ILFree(pidl);
                }
            }
            HIDA_ReleaseStgMedium(pida, &medium);       
        }
    }
    return hr;
}


// Property sheet code (for configuring the burnable drive)

HRESULT CCDBurn::_GetCurrentBurnVolumeName(LPTSTR pszVolumeName, UINT cchBuf)
{
    HRESULT hr = E_FAIL;            // failed == no drive.
    if (!SHRestricted(REST_NOCDBURNING))
    {
        ULONG cb = cchBuf * sizeof(*pszVolumeName);
        if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_CURRENTDRIVE, NULL, pszVolumeName, &cb))
        {
            // we encode an empty string as a special failure case as well.
            hr = (lstrlen(pszVolumeName) > 0) ? S_OK : E_UNEXPECTED;
        }
    }
    return hr;
}

BOOL CCDBurn::_BurningIsEnabled()
{
    TCHAR szDummy[MAX_PATH];
    return SUCCEEDED(_GetCurrentBurnVolumeName(szDummy, ARRAYSIZE(szDummy)));
}

HRESULT CCDBurn::_SetCurrentBurnVolumeName(LPCTSTR pszVolumeName, BOOL fDelete)
{
    // setcurrentburnvolumename is called when the burning drive is getting switched,
    // whether because were turning off burning or moving it to a different drive.
    // whenever this changes, that means drivefolder's Parse() and Enum() will start returning
    // different stuff for the affected drive letters.
    // so we issue SHCNE_DRIVEADD and SHCNE_DRIVEREMOVED for the changes.
    LPITEMIDLIST pidlBeforeOld = NULL, pidlBeforeNew = NULL, pidlAfterOld = NULL, pidlAfterNew = NULL;

    DWORD dwDriveOld = 0, cb = sizeof(dwDriveOld);
    if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_CACHEDINDEX, NULL, &dwDriveOld, &cb))
    {
        _GetPidlForDriveIndex(dwDriveOld, &pidlBeforeOld);
    }
    _GetPidlForVolumeName(pszVolumeName, &pidlAfterOld);

    SHDeleteValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_CACHEDINDEX);
    DWORD dwRet;
    if (!fDelete)
    {
        cb = (lstrlen(pszVolumeName) + 1) * sizeof(TCHAR);
        dwRet = SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_CURRENTDRIVE, REG_SZ, pszVolumeName, cb);

        int iDrive;
        if ((ERROR_SUCCESS == dwRet) && SUCCEEDED(_GetDriveIndexForVolumeName(pszVolumeName, &iDrive)))
        {
            dwRet = SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_CACHEDINDEX, REG_DWORD, &iDrive, sizeof(iDrive));
        }
    }
    else
    {
        dwRet = SHDeleteValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_CURRENTDRIVE);
    }
    
    HRESULT hr = (ERROR_SUCCESS == dwRet) ? S_OK : E_FAIL;
    if (SUCCEEDED(hr))
    {
        if (dwDriveOld)
        {
            _GetPidlForDriveIndex(dwDriveOld, &pidlBeforeNew);
        }
        _GetPidlForVolumeName(pszVolumeName, &pidlAfterNew);
        if (pidlBeforeOld && pidlBeforeNew && !ILIsEqual(pidlBeforeOld, pidlBeforeNew))
        {
            SHChangeNotify(SHCNE_DRIVEREMOVED, SHCNF_IDLIST, pidlBeforeOld, NULL);
            SHChangeNotify(SHCNE_DRIVEADD, SHCNF_IDLIST, pidlBeforeNew, NULL);
        }
        if (pidlAfterOld && pidlAfterNew && !ILIsEqual(pidlAfterOld, pidlAfterNew))
        {
            SHChangeNotify(SHCNE_DRIVEREMOVED, SHCNF_IDLIST, pidlAfterOld, NULL);
            SHChangeNotify(SHCNE_DRIVEADD, SHCNF_IDLIST, pidlAfterNew, NULL);
        }
    }

    ILFree(pidlBeforeOld);
    ILFree(pidlBeforeNew);
    ILFree(pidlAfterOld);
    ILFree(pidlAfterNew);
    return hr;
}

HRESULT CCDBurn::_GetBurnStagingPath(LPTSTR pszPath, UINT cchBuf)
{
    ASSERTMSG(cchBuf >= MAX_PATH, "caller needs to pass bigger buffer");
    return SHGetFolderPath(NULL, CSIDL_CDBURN_AREA | CSIDL_FLAG_CREATE, NULL, SHGFP_TYPE_CURRENT, pszPath);
}

HRESULT CCDBurn::_GetStashFile(LPTSTR pszFile, UINT cchBuf)
{
    TCHAR szPath[MAX_PATH];
    ULONG cb = sizeof(szPath);
    DWORD dwRet = SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_IMAPI, TEXT(IMAPI_REGVAL_NEWPATH), NULL, szPath, &cb);
    if ((dwRet != ERROR_SUCCESS) || (lstrlen(szPath) == 0))
    {
        cb = sizeof(szPath);
        dwRet = SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_IMAPI, TEXT(IMAPI_REGVAL_PATH), NULL, szPath, &cb);
    }

    HRESULT hr = E_FAIL;
    if (dwRet == ERROR_SUCCESS)
    {
        lstrcpyn(pszFile, szPath, cchBuf);
        hr = S_OK;
    }
    return hr;
}

HRESULT CCDBurn::_GetCurrentStashDrive(LPTSTR pszDrive, UINT cchBuf)
{
    TCHAR szPath[MAX_PATH];
    HRESULT hr = _GetStashFile(szPath, ARRAYSIZE(szPath));
    if (SUCCEEDED(hr) && PathStripToRoot(szPath))
    {
        lstrcpyn(pszDrive, szPath, cchBuf);
        hr = S_OK;
    }
    return hr;
}

HRESULT CCDBurn::_SetCurrentStashDrive(LPCTSTR pszDrive)
{
    TCHAR szStashFile[MAX_PATH];

    // we're using a fixed filename at the root of the hard drive.
    lstrcpyn(szStashFile, pszDrive, ARRAYSIZE(szStashFile));
    PathAppend(szStashFile, STASH_FILENAME);

    UINT cbStashFile = (lstrlen(szStashFile) + 1) * sizeof(TCHAR);
    DWORD dwRet = SHSetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_IMAPI, TEXT(IMAPI_REGVAL_NEWPATH), REG_SZ, szStashFile, cbStashFile);
    return (dwRet == ERROR_SUCCESS) ? S_OK : E_FAIL;
}

HRESULT CCDBurn::_GetEjectSetting(BOOL *pfEject)
{
    DWORD dwEject, cb = sizeof(dwEject);
    DWORD dwRet = SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_AUTOEJECT, NULL, &dwEject, &cb);

    HRESULT hr = E_FAIL;
    if (dwRet == ERROR_SUCCESS)
    {
        *pfEject = dwEject;
        hr = S_OK;
    }
    return hr;
}

HRESULT CCDBurn::_SetEjectSetting(BOOL fEject)
{
    DWORD dwEject = fEject;
    DWORD dwRet = SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_AUTOEJECT, REG_DWORD, &dwEject, sizeof(dwEject));
    return (dwRet == ERROR_SUCCESS) ? S_OK : E_FAIL;
}

HRESULT CCDBurn::_GetCachedDriveInfo(LPCTSTR pszVolumeName, DWORD *pdwDriveType, DWORD *pdwCurrentWriteSpeed, DWORD *pdwMaxWriteSpeed)
{
    HRESULT hr = S_OK;
    
    TCHAR szRegPath[MAX_PATH];
    lstrcpyn(szRegPath, REGSTR_PATH_DRIVES, ARRAYSIZE(szRegPath));
    StrCatBuff(szRegPath, TEXT("\\"), ARRAYSIZE(szRegPath));
    StrCatBuff(szRegPath, PathFindFileName(pszVolumeName), ARRAYSIZE(szRegPath));

    if (pdwDriveType)
    {
        DWORD dwTemp;
        ULONG cb = sizeof(dwTemp);
        DWORD dwRet = SHGetValue(HKEY_CURRENT_USER, szRegPath, REGVALUE_DRIVETYPE, NULL, &dwTemp, &cb);
        if (dwRet == ERROR_SUCCESS)
        {
            *pdwDriveType = dwTemp;
        }
        else
        {
            // this is the one value that should always be present if the key is there,
            // so fail if it's not there yet.
            hr = E_FAIL;
        }
    }

    if (pdwCurrentWriteSpeed)
    {
        DWORD dwTemp;
        ULONG cb = sizeof(dwTemp);
        DWORD dwRet = SHGetValue(HKEY_CURRENT_USER, szRegPath, REGVALUE_CURRENTSPEED, NULL, &dwTemp, &cb);
        if (dwRet == ERROR_SUCCESS)
        {
            *pdwCurrentWriteSpeed = dwTemp;
        }
    }

    if (pdwMaxWriteSpeed)
    {
        DWORD dwTemp;
        ULONG cb = sizeof(dwTemp);
        DWORD dwRet = SHGetValue(HKEY_CURRENT_USER, szRegPath, REGVALUE_MAXSPEED, NULL, &dwTemp, &cb);
        if (dwRet == ERROR_SUCCESS)
        {
            *pdwMaxWriteSpeed = dwTemp;
        }
    }
    return hr;
}

HRESULT CCDBurn::_SetCachedDriveInfo(LPCTSTR pszVolumeName, DWORD dwDriveType, DWORD dwWriteSpeed, DWORD dwMaxWriteSpeed)
{
    TCHAR szRegPath[MAX_PATH];
    lstrcpyn(szRegPath, REGSTR_PATH_DRIVES, ARRAYSIZE(szRegPath));
    StrCatBuff(szRegPath, TEXT("\\"), ARRAYSIZE(szRegPath));
    StrCatBuff(szRegPath, PathFindFileName(pszVolumeName), ARRAYSIZE(szRegPath));

    if (dwDriveType > 0)
    {
        SHSetValue(HKEY_CURRENT_USER, szRegPath, REGVALUE_DRIVETYPE, REG_DWORD, &dwDriveType, sizeof(dwDriveType));
    }

    if (dwWriteSpeed > 0)
    {
        SHSetValue(HKEY_CURRENT_USER, szRegPath, REGVALUE_CURRENTSPEED, REG_DWORD, &dwWriteSpeed, sizeof(dwWriteSpeed));
    }

    if (dwMaxWriteSpeed > 0)
    {
        SHSetValue(HKEY_CURRENT_USER, szRegPath, REGVALUE_MAXSPEED, REG_DWORD, &dwMaxWriteSpeed, sizeof(dwMaxWriteSpeed));
    }
    return S_OK;
}

HRESULT CCDBurn::_GetDiscRecorderInfo(IDiscRecorder *pdr, DWORD *pdwCurrentWriteSpeed, DWORD *pdwMaxWriteSpeed, DWORD *pdwDriveType)
{
    IPropertyStorage *pps;
    HRESULT hr = pdr->GetRecorderProperties(&pps);
    if (SUCCEEDED(hr))
    {
        PROPSPEC rgpspec[2];

        rgpspec[0].ulKind = PRSPEC_LPWSTR;
        rgpspec[0].lpwstr = L"WriteSpeed";

        rgpspec[1].ulKind = PRSPEC_LPWSTR;
        rgpspec[1].lpwstr = L"MaxWriteSpeed";

        PROPVARIANT rgvar[2];
        hr = pps->ReadMultiple(2, rgpspec, rgvar);
        if (SUCCEEDED(hr))
        {
            if ((V_VT(&rgvar[0]) == VT_I4) &&
                (V_VT(&rgvar[1]) == VT_I4))
            {
                if (pdwCurrentWriteSpeed)
                    *pdwCurrentWriteSpeed = rgvar[0].lVal;
                if (pdwMaxWriteSpeed)
                    *pdwMaxWriteSpeed = rgvar[1].lVal;
            }
            else
            {
                hr = E_FAIL;
            }
        }
        pps->Release();
    }

    if (SUCCEEDED(hr) && pdwDriveType)
    {
        long lType;
        hr = pdr->GetRecorderType(&lType);
        if (SUCCEEDED(hr))
        {
            *pdwDriveType = lType;
        }
    }

    return hr;
}

HRESULT CCDBurn::_SetRecorderProps(IDiscRecorder *pdr, DWORD dwWriteSpeed)
{
    IPropertyStorage *pps;
    HRESULT hr = pdr->GetRecorderProperties(&pps);
    if (SUCCEEDED(hr))
    {
        PROPSPEC rgpspec[1];
        PROPVARIANT rgvar[1];

        rgpspec[0].ulKind = PRSPEC_LPWSTR;
        rgpspec[0].lpwstr = L"WriteSpeed";

        rgvar[0].vt       = VT_I4;
        rgvar[0].lVal     = dwWriteSpeed;

        hr = pps->WriteMultiple(1, rgpspec, rgvar, PID_FIRST_USABLE);
        if (SUCCEEDED(hr))
        {
            // commit propertystorage to the discrecorder
            hr = pdr->SetRecorderProperties(pps);
        }

        pps->Release();
    }
    return hr;
}

HRESULT CCDBurn::_SetJolietProps(IJolietDiscMaster *pjdm)
{
    IPropertyStorage *pps;
    HRESULT hr = pjdm->GetJolietProperties(&pps);
    if (SUCCEEDED(hr))
    {
        WCHAR szLabel[JOLIET_MAX_LABEL + 1];
        szLabel[0] = 0;
        SHPropertyBag_ReadStr(_ppb, PROPSTR_DISCLABEL, szLabel, ARRAYSIZE(szLabel));

        PROPSPEC rgpspec[1];
        PROPVARIANT rgvar[1];

        rgpspec[0].ulKind = PRSPEC_LPWSTR;
        rgpspec[0].lpwstr = L"VolumeName";

        rgvar[0].vt       = VT_BSTR;
        rgvar[0].bstrVal  = SysAllocString(szLabel);

        hr = pps->WriteMultiple(1, rgpspec, rgvar, PID_FIRST_USABLE);
        if (SUCCEEDED(hr))
        {
            // commit propertystorage to the joliet disc master
            hr = pjdm->SetJolietProperties(pps);
        }

        PropVariantClear(&rgvar[0]);

        pps->Release();
    }
    return hr;
}

HRESULT CCDBurn::_GetDriveInfo(LPCTSTR pszVolumeName, DWORD *pdwDriveType, DWORD *pdwCurWrite, DWORD *pdwMaxWrite)
{
    HRESULT hr = _GetCachedDriveInfo(pszVolumeName, pdwDriveType, pdwCurWrite, pdwMaxWrite);
    if (FAILED(hr))
    {
        IDiscMaster *pdm;
        IJolietDiscMaster *pjdm;
        hr = _GetDiscMasters(&pdm, &pjdm);
        if (SUCCEEDED(hr))
        {
            IDiscRecorder *pdr;
            hr = _GetDiscRecorderForDrive(pdm, pszVolumeName, &pdr);
            if (SUCCEEDED(hr))
            {
                if (S_OK == hr)
                {
                    DWORD dwMaxWrite, dwDriveType;
                    hr = _GetDiscRecorderInfo(pdr, NULL, &dwMaxWrite, &dwDriveType);
                    if (SUCCEEDED(hr))
                    {
                        // default to fastest speed
                        _SetCachedDriveInfo(pszVolumeName, dwDriveType, WRITESPEED_FASTEST, dwMaxWrite);
                        if (pdwMaxWrite)
                        {
                            *pdwMaxWrite = dwMaxWrite;
                        }
                        if (pdwCurWrite)
                        {
                            *pdwCurWrite = dwMaxWrite;
                        }
                        if (pdwDriveType)
                        {
                            *pdwDriveType = dwDriveType;
                        }
                    }
                    pdr->Release();
                }
                else
                {
                    if (pdwDriveType)
                    {
                        *pdwDriveType = DRIVE_NOTSUPPORTED;
                    }
                    _SetCachedDriveInfo(pszVolumeName, DRIVE_NOTSUPPORTED, 0, 0);
                }
            }
            pdm->Release();
            pjdm->Release();
        }
    }
    return hr;
}

STDMETHODIMP CCDBurn::AddPages(LPFNADDPROPSHEETPAGE pAddPageProc, LPARAM lParam)
{
    // get the destination burn drive from the IDataObject we recieved during initialization
    HRESULT hr = _GetVolumeNameFromDataObject(FALSE, _szVolumeName, ARRAYSIZE(_szVolumeName));
    if (SUCCEEDED(hr))
    {
        DWORD dwDriveType;
        // only add page if we're supported by IMAPI.
        if (SUCCEEDED(_GetDriveInfo(_szVolumeName, &dwDriveType, NULL, NULL)) && SUPPORTED(dwDriveType))
        {
            // is this drive configured to be the recording drive?
            _fIsRecordingDrive = FALSE;
            TCHAR szCurrent[MAX_PATH];
            if (SUCCEEDED(_GetCurrentBurnVolumeName(szCurrent, ARRAYSIZE(szCurrent))))
            {
                _fIsRecordingDrive = (lstrcmpi(szCurrent, _szVolumeName) == 0);
            }

            PROPSHEETPAGE psp = { 0 };
            psp.dwSize = sizeof(psp);    // extra data
            psp.dwFlags = PSP_DEFAULT;
            psp.hInstance = HINST_THISDLL;
            psp.pszTemplate = MAKEINTRESOURCE(DLG_DRV_RECORDINGTAB);
            psp.pfnDlgProc = s_DlgProc;

            psp.lParam = (LPARAM)this;          // pass out a reference to our object
            AddRef();

            // create the page, and add it using the cb function they gave us
            hr = E_OUTOFMEMORY;
            HPROPSHEETPAGE hPage = CreatePropertySheetPage(&psp);
            if (hPage)
            {
                if (!pAddPageProc(hPage, lParam))
                {
                    DestroyPropertySheetPage(hPage);
                }
                else
                {
                    hr = S_OK;              // success
                }
            }

            if (FAILED(hr))
            {
                Release();
            }
        }
    }
    return hr;
}

void CCDBurn::_EnableRecordingDlgArea(HWND hwnd, BOOL fEnable)
{
    EnableWindow(GetDlgItem(hwnd, IDC_RECORD_IMAGELOC), IsUserAnAdmin() ? fEnable : FALSE);
    EnableWindow(GetDlgItem(hwnd, IDC_RECORD_WRITESPEED), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_RECORD_TEXTIMAGE), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_RECORD_TEXTWRITE), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_RECORD_EJECT), fEnable);
}

void CCDBurn::_RecordingPrshtInit(HWND hDlg)
{
    DECLAREWAITCURSOR;
    SetWaitCursor();

    HWND hwndWriteSpeed = GetDlgItem(hDlg, IDC_RECORD_WRITESPEED);
    HWND hwndImageLoc = GetDlgItem(hDlg, IDC_RECORD_IMAGELOC);
    TCHAR szTemp[MAX_PATH];

    // get the icon for the drive
    HICON hIcon = LoadIcon(HINST_THISDLL, MAKEINTRESOURCE(IDI_DRIVECD));
    ReplaceDlgIcon(hDlg, IDC_RECORD_ICON, hIcon);

    // set the "we are the recording drive" flag

    CheckDlgButton(hDlg, IDC_RECORD_ENABLE, _fIsRecordingDrive);
    _EnableRecordingDlgArea(hDlg, _fIsRecordingDrive);

    BOOL fAutoEject = TRUE;
    _GetEjectSetting(&fAutoEject);
    CheckDlgButton(hDlg, IDC_RECORD_EJECT, fAutoEject);

    // populate the controls for the write speed

    LoadString(HINST_THISDLL, IDS_BURN_WRITESPEED_NX, szTemp, ARRAYSIZE(szTemp));

    // if the registry info is missing
    // then default to 1x.
    DWORD dwMaxSpeed = 1;
    DWORD dwCurSpeed = 1;
    _GetDriveInfo(_szVolumeName, NULL, &dwCurSpeed, &dwMaxSpeed);

    int iCurSel = 0, iSelIndex = 0;

    TCHAR szSpeed[20];
    LoadString(HINST_THISDLL, IDS_BURN_WRITESPEED_FASTEST, szSpeed, ARRAYSIZE(szSpeed));
    ComboBox_AddString(hwndWriteSpeed, szSpeed);
    ComboBox_SetItemData(hwndWriteSpeed, iSelIndex, WRITESPEED_FASTEST);
    iSelIndex++;

    // we want the following:
    // 8x drive: 8, 4, 2, 1
    // 10x drive: 10, 8, 4, 2, 1
    for (DWORD dwSpeed = dwMaxSpeed; dwSpeed >= 1; iSelIndex++)
    {
        if (dwSpeed == dwCurSpeed)
        {
            iCurSel = iSelIndex;
        }

        _sntprintf(szSpeed, ARRAYSIZE(szSpeed), szTemp, dwSpeed);
        ComboBox_AddString(hwndWriteSpeed, szSpeed);
        ComboBox_SetItemData(hwndWriteSpeed, iSelIndex, dwSpeed);

        // so if we just added the max speed, set dwSpeed to the lowest
        // power of two greater than the max speed.
        // then divide by two.
        // thus 10->8, 8->4, etc.
        if (dwSpeed == dwMaxSpeed)
        {
            for (dwSpeed = 1; dwSpeed < dwMaxSpeed; dwSpeed *= 2);
        }
        dwSpeed /= 2;
    }
    ComboBox_SetCurSel(hwndWriteSpeed, iCurSel);

    // populate the staging drive information, and try and set the drive

    SendMessage(hwndImageLoc, CBEM_SETIMAGELIST, 0, (LPARAM)GetSystemImageListSmallIcons());
    PopulateLocalDrivesCombo(hwndImageLoc, NULL, (LPARAM)hwndImageLoc);

    BOOL fSetAlready = FALSE;
    if (SUCCEEDED(_GetCurrentStashDrive(szTemp, ARRAYSIZE(szTemp))))
    {
        for (int i = 0; (i < ComboBox_GetCount(hwndImageLoc)) && !fSetAlready; i++)
        {
            LPTSTR pszData = (LPTSTR)ComboBox_GetItemData(hwndImageLoc, i);
            if (lstrcmpi(szTemp, pszData) == 0)
            {
                ComboBox_SetCurSel(hwndImageLoc, i);
                fSetAlready = TRUE;
            }
        }
    }

    if (!fSetAlready)
        ComboBox_SetCurSel(hwndImageLoc, 0);

    // if we're not an admin, the user wont be able to change the stash location due to kernel security
    // issues.  thus disable that part.
    if (!IsUserAnAdmin())
    {
        EnableWindow(hwndImageLoc, FALSE);
        WCHAR szText[200];
        LoadString(HINST_THISDLL, IDS_BURN_USERBLOCK, szText, ARRAYSIZE(szText));
        SetWindowText(GetDlgItem(hDlg, IDC_RECORD_TEXTIMAGE), szText);
    }

    _fPropSheetDirty = FALSE;

    ResetWaitCursor();
}

BOOL CCDBurn::_HandleApply(HWND hDlg)
{
    BOOL fGoAhead = TRUE;
    if (_fPropSheetDirty)
    {
        if (IsDlgButtonChecked(hDlg, IDC_RECORD_ENABLE) == BST_CHECKED)
        {
            _fIsRecordingDrive = TRUE;

            // get the stash drive setup
            HWND hwndStash = GetDlgItem(hDlg, IDC_RECORD_IMAGELOC);
            int iItem = ComboBox_GetCurSel(hwndStash);
            if (iItem != (int)CB_ERR)
            {
                LPTSTR pszStashDrive = (LPTSTR)ComboBox_GetItemData(hwndStash, iItem);

                // set the stash drive
                _SetCurrentStashDrive(pszStashDrive);
            
                // mark the drive we are going to burn to
                _SetCurrentBurnVolumeName(_szVolumeName, FALSE);

                // set speed
                HWND hwndSpeed = GetDlgItem(hDlg, IDC_RECORD_WRITESPEED);
                iItem = ComboBox_GetCurSel(hwndSpeed);
                if (iItem != (int)CB_ERR)
                {
                    DWORD dwSpeed = (DWORD)ComboBox_GetItemData(hwndSpeed, iItem);
                    _SetCachedDriveInfo(_szVolumeName, DRIVE_USEEXISTING, dwSpeed, 0);
                }

                // set autoeject
                BOOL fAutoEject = (IsDlgButtonChecked(hDlg, IDC_RECORD_EJECT) == BST_CHECKED);
                _SetEjectSetting(fAutoEject);

                // redo free space
                _HandleBookkeeping();
            }
            _fPropSheetDirty = FALSE;
        }
        else if (_fIsRecordingDrive)
        {
            if (!_StagingAreaHasFiles() ||
                (IDYES == ShellMessageBox(HINST_THISDLL, hDlg, MAKEINTRESOURCE(IDS_BURN_CONFIRM_DISABLE), MAKEINTRESOURCE(IDS_BURN),
                                          MB_YESNO | MB_ICONQUESTION)))
            {
                // clear out any trash, we're disabling the cd burning now.
                _SetCurrentBurnVolumeName(TEXT(""), FALSE); // there is no recording drive now

                TCHAR szStash[MAX_PATH];
                if (SUCCEEDED(_GetStashFile(szStash, ARRAYSIZE(szStash))))
                {
                    DeleteFile(szStash);
                }
                _fPropSheetDirty = FALSE;
            }
            else
            {
                fGoAhead = FALSE;
            }
        }
    }
    return fGoAhead;
}

void CCDBurn::_MarkDirty(HWND hDlg)
{
    PropSheet_Changed(GetParent(hDlg), hDlg);
    _fPropSheetDirty = TRUE;
}

BOOL_PTR CCDBurn::s_DlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    if (uMessage == WM_INITDIALOG)
    {
        PROPSHEETPAGE *psp = (PROPSHEETPAGE*)lParam;
        CCDBurn *pcdb = (CCDBurn*)psp->lParam;
        SetWindowLongPtr(hDlg, GWLP_USERDATA, psp->lParam);
        pcdb->_RecordingPrshtInit(hDlg);
    }
    else
    {
        CCDBurn *pcdb = (CCDBurn*)GetWindowLongPtr(hDlg, GWLP_USERDATA);
        switch (uMessage) 
        {
            case WM_DESTROY:
                ReplaceDlgIcon(hDlg, IDC_RECORD_ICON, NULL);
                SetWindowLongPtr(hDlg, GWLP_USERDATA, 0x0);
                pcdb->Release();
                break;

            case WM_HELP:
                WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, CDBURN_HELPFILE, HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aPrshtHelpIDs);
                break;

            case WM_CONTEXTMENU:
                WinHelp((HWND)wParam, CDBURN_HELPFILE, HELP_CONTEXTMENU, (ULONG_PTR)(void *)aPrshtHelpIDs);
                break;

            case WM_COMMAND:
                switch (GET_WM_COMMAND_ID(wParam, lParam))
                {
                    case IDC_RECORD_ENABLE:
                        {
                            BOOL fRecordingEnabled = (IsDlgButtonChecked(hDlg, IDC_RECORD_ENABLE) == BST_CHECKED);
                            pcdb->_EnableRecordingDlgArea(hDlg, fRecordingEnabled);
                            pcdb->_MarkDirty(hDlg);
                        }
                        break;

                    case IDC_RECORD_IMAGELOC:
                    case IDC_RECORD_WRITESPEED:
                        if (GET_WM_COMMAND_CMD(wParam, lParam) == LBN_SELCHANGE)
                        {
                            pcdb->_MarkDirty(hDlg);
                        }
                        break;

                    case IDC_RECORD_EJECT:
                        pcdb->_MarkDirty(hDlg);
                        break;

                    default:
                        return TRUE;
                }
                break;

            case WM_NOTIFY:
                switch (((NMHDR *)lParam)->code) 
                {
                    case PSN_SETACTIVE:
                        break;

                    case PSN_APPLY:
                        if (!pcdb->_HandleApply(hDlg))
                        {
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                        }
                        else
                        {
                            PropSheet_UnChanged(GetParent(hDlg), hDlg);
                        }
                        return TRUE;

                    default:
                        return FALSE;
                }
                break;

            default:
                return FALSE;
        }
    }
    return TRUE;
}


// IContextMenu

STDMETHODIMP CCDBurn::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    INT idMax = idCmdFirst;

    // only display this if we are invoked on the currently configured burn drive
    TCHAR szDummy[MAX_PATH];
    if (SUCCEEDED(_GetVolumeNameFromDataObject(TRUE, szDummy, ARRAYSIZE(szDummy))))
    {
        // load and merge the context menu with the current menu
        HMENU hmMerge = SHLoadPopupMenu(HINST_THISDLL, POPUP_BURN_POPUPMERGE);
        if (hmMerge)
        {
            idMax = Shell_MergeMenus(hmenu, hmMerge, indexMenu, idCmdFirst, idCmdLast, 0);

            BOOL fInStaging, fOnMedia;
            if (SUCCEEDED(GetContentState(&fInStaging, &fOnMedia)))
            {
                DWORD dwCaps = 0;
                BOOL fUDF = FALSE;
                _GetMediaCapabilities(&dwCaps, &fUDF); // this will fail if there is no media in the drive.

                // delete write to cd if it's UDF
                if (fUDF)
                    DeleteMenu(hmenu, idCmdFirst + FSIDM_BURN, MF_BYCOMMAND);

                // delete clear staging area if no files to burn or it's UDF
                if (!fInStaging || fUDF)
                    DeleteMenu(hmenu, idCmdFirst + FSIDM_CLEANUP, MF_BYCOMMAND);

                // delete erase if it's not UDF and no cd-rw or no files on disc
                if (!(dwCaps & HWDMC_CDREWRITABLE) || (!fOnMedia && !fUDF))
                    DeleteMenu(hmenu, idCmdFirst + FSIDM_ERASE, MF_BYCOMMAND);
            }
            DestroyMenu(hmMerge);
        }
    }

    return ResultFromShort(idMax - idCmdFirst);
}

const ICIVERBTOIDMAP c_CDBurnMap[] =
{
    { L"burn",    "burn",    FSIDM_BURN,    FSIDM_BURN,    },
    { L"cleanup", "cleanup", FSIDM_CLEANUP, FSIDM_CLEANUP, },
    { L"erase",   "erase",   FSIDM_ERASE,   FSIDM_ERASE,   },
};

STDMETHODIMP CCDBurn::GetCommandString(UINT_PTR idCmd, UINT uFlags, LPUINT lpReserved, LPSTR pszName, UINT cchMax)
{
    HRESULT hr;
    
    switch(uFlags)
    {
        case GCS_VERBA:
        case GCS_VERBW:
            hr = SHMapCmdIDToVerb(idCmd, c_CDBurnMap, ARRAYSIZE(c_CDBurnMap), pszName, cchMax, uFlags == GCS_VERBW);
            break;
   
        default:
            hr = E_NOTIMPL;
            break; 
    }
    return hr;
}

STDMETHODIMP CCDBurn::InvokeCommand(LPCMINVOKECOMMANDINFO lpcmi)
{
    UINT uID;
    HRESULT hr = SHMapICIVerbToCmdID(lpcmi, c_CDBurnMap, ARRAYSIZE(c_CDBurnMap), &uID);
    if (SUCCEEDED(hr))
    {
        switch (uID)
        {
            case FSIDM_BURN:
            case FSIDM_ERASE:
                hr = InitNew();
                if (SUCCEEDED(hr))
                {
                    hr = _PrepWiz(lpcmi, (uID == FSIDM_ERASE), FALSE);
                }
                break;

            case FSIDM_CLEANUP:
                hr = _CleanUp(lpcmi, TRUE);
                break;

            default:
                hr = E_FAIL;
                break;
        }
    }
    return hr;
} 


// IMAPI Advise Sink

STDMETHODIMP CCDBurn::QueryCancel(boolean *pbCancel)
{
    *pbCancel = (boolean)_fCancelled;
    return S_OK;
}

STDMETHODIMP CCDBurn::NotifyPnPActivity()
{
    return E_NOTIMPL;
}

STDMETHODIMP CCDBurn::NotifyAddProgress(long nCompletedSteps, long nTotalSteps)
{
    if (nTotalSteps != 0)
    {
        _SetEstimatedTime((DWORD)((float) _ts.dwSecStaging * (nTotalSteps - nCompletedSteps) / nTotalSteps + _ts.dwSecBurn + _ts.dwSecClose));
    }
    return S_OK;
}

STDMETHODIMP CCDBurn::NotifyBlockProgress(long nCompleted, long nTotal)
{
    // Unfortunately we need to set the "burning" text here,
    // because we get this notification immediately after the NotifyPreparingBurn.
    if (!_fRecording)
    {
        _SetStatus(IDS_BURN_RECORDING);
        _ts.dwTickBurnStart = GetTickCount();
        _fRecording = TRUE;
    }
    if (nTotal != 0)
    {
        _SetEstimatedTime((DWORD)((float) _ts.dwSecBurn * (nTotal - nCompleted) / nTotal + _ts.dwSecClose));
    }
    return S_OK;
}

STDMETHODIMP CCDBurn::NotifyTrackProgress(long nCurrentTrack, long nTotalTracks)
{
    // audio cd only
    return E_NOTIMPL;
}

STDMETHODIMP CCDBurn::NotifyPreparingBurn(long nEstimatedSeconds)
{
    _SetStatus(IDS_BURN_PREPARINGBURN);
    return S_OK;
}

STDMETHODIMP CCDBurn::NotifyClosingDisc(long nEstimatedSeconds)
{
    _ts.dwTickBurnEnd = _ts.dwTickCloseStart = GetTickCount();
    _SetEstimatedTime(_ts.dwSecClose);
    _SetStatus(IDS_BURN_CLOSINGDISC);
    return S_OK;
}

STDMETHODIMP CCDBurn::NotifyBurnComplete(HRESULT status)
{
    _ts.dwTickCloseEnd = GetTickCount();
    _SetEstimatedTime(0);
    _SetStatus(IDS_BURN_COMPLETE);
    return S_OK;
}

STDMETHODIMP CCDBurn::NotifyEraseComplete(HRESULT status)
{
    _ts.dwTickEraseEnd = GetTickCount();
    _SetEstimatedTime(0);
    _SetStatus(IDS_BURN_COMPLETE);
    return S_OK;
}

HRESULT CCDBurn::_LockCurrentDrive(BOOL fLock, BOOL fForce)
{
    HRESULT hr = S_OK;
    // fForce defaults to FALSE
    if (fForce || (fLock != s_fDriveInUse))
    {
        TCHAR szVolume[MAX_PATH];
        hr = _GetCurrentBurnVolumeName(szVolume, ARRAYSIZE(szVolume));
        if (SUCCEEDED(hr))
        {
            // strip trailing backslash (always there)
            ASSERT(szVolume[lstrlen(szVolume) - 1] == TEXT('\\'));
            szVolume[lstrlen(szVolume) - 1] = 0;

            hr = E_FAIL;
            HANDLE hDevice = CreateFile(szVolume, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, 0, NULL);
            if (hDevice != INVALID_HANDLE_VALUE)
            {
                PREVENT_MEDIA_REMOVAL pmr = {0};
                pmr.PreventMediaRemoval = BOOLIFY(fLock);

                DWORD dwDummy;
                if (DeviceIoControl(hDevice, IOCTL_STORAGE_MEDIA_REMOVAL, &pmr, sizeof(pmr), NULL, 0, &dwDummy, NULL))
                {
                    // we're sealed up tight now, set the state var.
                    s_fDriveInUse = fLock;
                    hr = S_OK;
                }
                CloseHandle(hDevice);
            }
        }
    }
    return hr;
}

BOOL CCDBurn::_HasFiles(LPCITEMIDLIST pidl)
{
    BOOL fHasFiles = FALSE;

    IBindCtx *pbc;
    HRESULT hr = SHCreateSkipBindCtx(NULL, &pbc);
    if (SUCCEEDED(hr))
    {
        IStorage *pstg;
        hr = SHBindToObjectEx(NULL, pidl, pbc, IID_PPV_ARG(IStorage, &pstg));
        if (SUCCEEDED(hr))
        {
            IEnumSTATSTG *penum;
            hr = pstg->EnumElements(0, NULL, 0, &penum);
            if (SUCCEEDED(hr))
            {
                STATSTG stat;
                hr = penum->Next(1, &stat, NULL);
                if (hr == S_OK)
                {
                    fHasFiles = TRUE;
                    CoTaskMemFree(stat.pwcsName);
                }
                penum->Release();
            }
            pstg->Release();
        }
        pbc->Release();
    }
    return fHasFiles;
}

BOOL CCDBurn::_StagingAreaHasFiles()
{
    BOOL fHasFiles = FALSE;
    LPITEMIDLIST pidl;
    if (SUCCEEDED(SHGetFolderLocation(NULL, CSIDL_CDBURN_AREA, NULL, 0, &pidl)))
    {
        fHasFiles = _HasFiles(pidl);
        ILFree(pidl);
    }
    return fHasFiles;
}

BOOL CCDBurn::_DiscHasFiles()
{
    BOOL fHasFiles = FALSE;
    LPITEMIDLIST pidl;
    if (SUCCEEDED(_GetPlainCDPidl(&pidl)))
    {
        fHasFiles = _HasFiles(pidl);
        ILFree(pidl);
    }
    return fHasFiles;
}

HRESULT CCDBurn::GetContentState(BOOL *pfStagingHasFiles, BOOL *pfDiscHasFiles)
{
    if (pfStagingHasFiles)
        *pfStagingHasFiles = _StagingAreaHasFiles();
    if (pfDiscHasFiles)
        *pfDiscHasFiles = _DiscHasFiles();

    return S_OK;
}

HRESULT CCDBurn::IsWizardUp()
{
    HRESULT hr;
    CCDBurn *pcdb = new CCDBurn();
    if (pcdb)
    {
        // check if the wizard is currently running.
        // the reason why we have to do both the s_hwndWiz and the exclusive mutex check is that
        // there could be other explorer.exe's that are running.  the s_hwndWiz is a shortcut for
        // the typical case where we're the only one.
        if (!pcdb->s_hwndWiz && pcdb->_EnterExclusiveBurning())
        {
            // if we could get the exclusive mutex, we werent up yet, so release it.
            pcdb->_LeaveExclusiveBurning();
            hr = S_FALSE;
        }
        else
        {
            // the window is up or we couldn't get the mutex so we're definitely burning now.
            hr = S_OK;
        }
        pcdb->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CCDBurn::_GetRecorderPath(IDiscRecorder *pdr, LPTSTR pszPath, UINT cchBuf)
{
    BSTR bstr;
    HRESULT hr = pdr->GetPath(&bstr);
    if (SUCCEEDED(hr))
    {
        lstrcpyn(pszPath, bstr, cchBuf);
        SysFreeString(bstr);
    }
    return hr;
}

HRESULT CCDBurn::_GetVolumeNameForDriveIndex(int iDrive, LPTSTR pszVolumeName, UINT cchBuf)
{
    HRESULT hr = E_FAIL;
    TCHAR szDriveLetter[4];
    if (PathBuildRoot(szDriveLetter, iDrive) &&
        GetVolumeNameForVolumeMountPoint(szDriveLetter, pszVolumeName, cchBuf))
    {
        hr = S_OK;
    }
    return hr;
}

HRESULT CCDBurn::_GetDriveIndexForVolumeName(LPCTSTR pszVolumeName, int *piDrive)
{
    HRESULT hr = E_FAIL;
    DWORD dwLen;
    BOOL fRet = GetVolumePathNamesForVolumeName(pszVolumeName, NULL, 0, &dwLen);
    if (fRet || (GetLastError() == ERROR_MORE_DATA))
    {
        LPWSTR pszBuf = new WCHAR[dwLen];
        if (pszBuf)
        {
            hr = E_FAIL;
            if (GetVolumePathNamesForVolumeName(pszVolumeName, pszBuf, dwLen, NULL))
            {
                for (PWSTR pszPath = pszBuf; *pszPath; pszPath += lstrlenW(pszPath) + 1)
                {
                    // if it's mounted at more than one root, take the first one.
                    if (PathIsRoot(pszPath))
                    {
                        *piDrive = PathGetDriveNumber(pszBuf);
                        hr = S_OK;
                        break;
                    }
                }
            }
            delete [] pszBuf;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

HRESULT CCDBurn::_GetCurrentDriveIndex(int *piDrive)
{
    TCHAR szCurrent[MAX_PATH];
    HRESULT hr = _GetCurrentBurnVolumeName(szCurrent, ARRAYSIZE(szCurrent));
    if (SUCCEEDED(hr))
    {
        hr = _GetDriveIndexForVolumeName(szCurrent, piDrive);
    }
    return hr;
}

HRESULT CCDBurn::_GetVolumeNameForDevicePath(LPCTSTR pszDevice, LPTSTR pszVolumeName, UINT cchBuf)
{
    TCHAR szMountPoint[MAX_PATH];
    lstrcpyn(szMountPoint, TEXT("\\\\?\\GLOBALROOT"), ARRAYSIZE(szMountPoint));
    StrCatBuff(szMountPoint, pszDevice, ARRAYSIZE(szMountPoint));
    StrCatBuff(szMountPoint, TEXT("\\"), ARRAYSIZE(szMountPoint));
    return GetVolumeNameForVolumeMountPoint(szMountPoint, pszVolumeName, cchBuf) ? S_OK : E_FAIL;
}

BOOL CCDBurn::_DevicePathMatchesVolumeName(LPCTSTR pszDevice, LPCTSTR pszVolumeName)
{
    BOOL fRet = FALSE;

    TCHAR szVolumeNameTest[MAX_PATH];
    if (SUCCEEDED(_GetVolumeNameForDevicePath(pszDevice, szVolumeNameTest, ARRAYSIZE(szVolumeNameTest))))
    {
        fRet = (lstrcmpi(pszVolumeName, szVolumeNameTest) == 0);
    }
    return fRet;
}

// can return S_FALSE and not fill up ppdr
HRESULT CCDBurn::_GetDiscRecorderForDrive(IDiscMaster *pdm, LPCTSTR pszVolumeName, IDiscRecorder **ppdr)
{
    IEnumDiscRecorders *penumdr;
    HRESULT hr = pdm->EnumDiscRecorders(&penumdr);
    if (SUCCEEDED(hr))
    {
        BOOL fDone = FALSE;
        do
        {
            ULONG celt;
            IDiscRecorder *pdr;
            hr = penumdr->Next(1, &pdr, &celt);
            if (hr == S_OK)
            {
                TCHAR szPath[MAX_PATH];
                hr = _GetRecorderPath(pdr, szPath, ARRAYSIZE(szPath));
                if (SUCCEEDED(hr))
                {
                    if (_DevicePathMatchesVolumeName(szPath, pszVolumeName))
                    {
                        if (ppdr)
                        {
                            pdr->AddRef();
                            *ppdr = pdr;
                        }
                        fDone = TRUE;
                    }
                }
                pdr->Release();
            }
            else
            {
                fDone = TRUE;
            }
        } while (!fDone);
        penumdr->Release();
    }
    return hr;
}

HRESULT CCDBurn::_FindAndSetRecorder(LPCTSTR pszVolumeName, IDiscMaster *pdm, BOOL fSetActive, IDiscRecorder **ppdr)
{
    IDiscRecorder *pdr;
    HRESULT hr = _GetDiscRecorderForDrive(pdm, pszVolumeName, &pdr);
    if (S_OK == hr)
    {
        DWORD dwCurSpeed = 1, dwMaxSpeed = 1;
        _GetCachedDriveInfo(pszVolumeName, NULL, &dwCurSpeed, &dwMaxSpeed);
        if (fSetActive)
        {
            hr = pdm->SetActiveDiscRecorder(pdr);
            if (SUCCEEDED(hr))
            {
                hr = _SetRecorderProps(pdr, dwCurSpeed);
            }
        }
        // _dwCurSpeed is used only for timing, so if it's 0xFFFFFFFF we need to scale
        // it back down to what we think is the max speed.
        // this may be incorrect for certain drives that have an actual speed different
        // from what they report but it's the best we can do (and it'll be compensated for
        // in the next burn).
        _dwCurSpeed = (WRITESPEED_FASTEST == dwCurSpeed) ? dwMaxSpeed : dwCurSpeed;

        if (SUCCEEDED(hr))
        {
            *ppdr = pdr;
            pdr->AddRef();
        }
        pdr->Release();
    }
    else
    {
        // munge S_FALSE into E_FAIL (i.e. we got through the whole enumerator without
        // finding a match, so that's bad)
        if (hr == S_FALSE)
        {
            hr = E_FAIL;
        }
    }
    return hr;
}

HRESULT CCDBurn::_FindAndSetDefaultRecorder(IDiscMaster *pdm, BOOL fSetActive, IDiscRecorder **ppdr)
{
    TCHAR szCurrent[MAX_PATH];
    HRESULT hr = _GetCurrentBurnVolumeName(szCurrent, ARRAYSIZE(szCurrent));
    if (SUCCEEDED(hr))
    {
        hr = _FindAndSetRecorder(szCurrent, pdm, fSetActive, ppdr);
    }
    return hr;
}

INT_PTR CALLBACK CCDBurn::_ConfirmDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            {
                LPITEMIDLIST pidl;
                if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_BITBUCKET, &pidl)))
                {
                    SHFILEINFO fi;
                    if (SHGetFileInfo((LPCTSTR)pidl, 0, &fi, sizeof(fi), SHGFI_PIDL | SHGFI_ICON | SHGFI_LARGEICON))
                    {
                        ReplaceDlgIcon(hwndDlg, IDD_ICON, fi.hIcon);
                    }
                    ILFree(pidl);
                }
            }
            break;

        case WM_DESTROY:
            ReplaceDlgIcon(hwndDlg, IDD_ICON, NULL);
            break;

        case WM_COMMAND:        
            switch (GET_WM_COMMAND_ID(wParam, lParam)) 
            {
                case IDNO:
                    EndDialog(hwndDlg, IDNO);
                    break;

                case IDYES:
                    EndDialog(hwndDlg, IDYES);
                    break;
            }
            break;

        default:
            return FALSE;
    }
    return TRUE;
}

HRESULT CCDBurn::_CleanUp(LPCMINVOKECOMMANDINFO lpcmi, BOOL fRecycle)
{
    // delete the files in the staging area, by deleting the entire staging area

    TCHAR szStaging[MAX_PATH + 1]; // a little room for double-null
    HRESULT hr = _GetBurnStagingPath(szStaging, MAX_PATH);
    if (SUCCEEDED(hr) && PathFileExists(szStaging))
    {
        // cant use shfileop confirmation because its too hacky.
        if ((lpcmi->fMask & CMIC_MASK_FLAG_NO_UI) ||
            (IDYES == DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_DELETE_STAGING), lpcmi->hwnd, _ConfirmDialogProc, NULL)))
        {
            PathAppend(szStaging, c_szStarDotStar);
            // double-null
            szStaging[lstrlen(szStaging) + 1] = 0;

            SHFILEOPSTRUCT fo = {0};
            fo.wFunc = FO_DELETE;
            fo.pFrom = szStaging;
            fo.fFlags = FOF_NOCONFIRMATION;
            if (fRecycle)
            {
                fo.fFlags |= FOF_ALLOWUNDO;
            }
            fo.hwnd = lpcmi->hwnd;

            hr = (SHFileOperation(&fo) == ERROR_SUCCESS) ? S_OK : E_FAIL;
        }
    }
    return hr;
}

HRESULT CCDBurn::_CreateDefaultPropBag(REFIID riid, void **ppv)
{
    IPropertyBag *ppb;
    HRESULT hr = SHCreatePropertyBagOnMemory(STGM_READWRITE, IID_PPV_ARG(IPropertyBag, &ppb));
    if (SUCCEEDED(hr))
    {
        // default to think we didn't hit eject
        SHPropertyBag_WriteBOOL(ppb, PROPSTR_EJECT, FALSE);

        // do volume name
        TCHAR szDiscLabel[JOLIET_MAX_LABEL + 1];
        ULONG cb = sizeof(szDiscLabel);
        if (ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_PERMEDIA, REGVALUE_DISCLABEL, NULL, szDiscLabel, &cb))
        {
            // make a default string like "Feb 02 2001"
            TCHAR szFormat[JOLIET_MAX_LABEL + 1];
            LoadString(HINST_THISDLL, IDS_BURN_FORMAT_DISCLABEL, szFormat, ARRAYSIZE(szFormat));
            if (!GetDateFormat(LOCALE_USER_DEFAULT, 0, NULL, szFormat, szDiscLabel, ARRAYSIZE(szDiscLabel)))
            {
                szDiscLabel[0] = 0;
            }
        }
        SHPropertyBag_WriteStr(ppb, PROPSTR_DISCLABEL, szDiscLabel);

        // do autoclose
        DWORD dwClose;
        cb = sizeof(dwClose);
        if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_AUTOCLOSE, NULL, &dwClose, &cb) && dwClose)
        {
            SHPropertyBag_WriteBOOL(ppb, PROPSTR_AUTOCLOSE, TRUE);
        }

        hr = ppb->QueryInterface(riid, ppv);

        ppb->Release();
    }
    return hr;
}

HRESULT CCDBurn::_PrepWiz(LPCMINVOKECOMMANDINFO lpcmi, BOOL fErase, BOOL fFailSilently)
{
    HRESULT hr = E_FAIL;
    if (s_hwndWiz)
    {
        // if we know the shell is burning and we have an hwnd to the wizard, pop it up.
        SetForegroundWindow(s_hwndWiz);
        hr = S_OK;
    }
    else
    {
        SHPropertyBag_WriteBOOL(_ppb, PROPSTR_ERASE, fErase);
        SHPropertyBag_WriteBOOL(_ppb, PROPSTR_FAILSILENTLY, fFailSilently);
        hr = _ShowWizardOnSeparateThread();
    }
    return hr;
}

void CCDBurn::_SetStatus(UINT uID)
{
    TCHAR szBuf[MAX_PATH];
    LoadString(HINST_THISDLL, uID, szBuf, ARRAYSIZE(szBuf));
    SetDlgItemText(_hwndWizardPage, IDC_BURNWIZ_STATUSTEXT, szBuf);
}

HRESULT CCDBurn::_GetDiscMasters(IDiscMaster **ppdm, IJolietDiscMaster **ppjdm)
{
    *ppdm = NULL;
    *ppjdm = NULL;

    HRESULT hr = CoCreateInstance(CLSID_MSDiscMasterObj, NULL, CLSCTX_ALL, IID_PPV_ARG(IDiscMaster, ppdm));
    if (SUCCEEDED(hr))
    {
        // open() takes some time, so set up the progress dialog
        _SetStatus(IDS_BURN_INITIALIZESTASH);
        hr = (*ppdm)->Open();
        if (SUCCEEDED(hr))
        {
            hr = (*ppdm)->SetActiveDiscMasterFormat(IID_PPV_ARG(IJolietDiscMaster, ppjdm));
        }

        // clean up if we couldn't get the joliet disc master.
        if (FAILED(hr))
        {
            ATOMICRELEASE(*ppdm);
        }
    }

    ASSERT(SUCCEEDED(hr) ? ((*ppdm != NULL) && (*ppjdm != NULL)) : ((*ppdm == NULL) && (*ppjdm == NULL)));
    return hr;
}


HRESULT CCDBurn::_AddData(IJolietDiscMaster *pjdm)
{
    _SetStatus(IDS_BURN_ADDDATA);

    LPITEMIDLIST pidl;
    HRESULT hr = SHGetFolderLocation(NULL, CSIDL_CDBURN_AREA, NULL, 0, &pidl);
    if (SUCCEEDED(hr))
    {
        IStorage *pstg;
        hr = SHBindToObjectEx(NULL, pidl, NULL, IID_PPV_ARG(IStorage, &pstg));
        if (SUCCEEDED(hr))
        {
            _ts.dwTickStagingStart = GetTickCount();
            hr = pjdm->AddData(pstg, 1);
            _ts.dwTickStagingEnd = GetTickCount();
            pstg->Release();
        }
        ILFree(pidl);
    }
    return hr;
}

BOOL CCDBurn::_IsBurningNow()
{
    BOOL fBurning = TRUE;
    CCDBurn *pcdb = new CCDBurn();
    if (pcdb)
    {
        // if the shell is burning, we know it for sure.  otherwise we have to check imapi to see if any other
        // process is using imapi to burn.
        if (!pcdb->s_hwndWiz && pcdb->_EnterExclusiveBurning())
        {
            pcdb->_LeaveExclusiveBurning();
            // if we can get the mutex, we're not burning.
            fBurning = FALSE;

            IDiscMaster *pdm;
            IJolietDiscMaster *pjdm;
            if (SUCCEEDED(pcdb->_GetDiscMasters(&pdm, &pjdm)))
            {
                IDiscRecorder *pdr;
                if (SUCCEEDED(pcdb->_FindAndSetDefaultRecorder(pdm, FALSE, &pdr)))
                {
                    ULONG ulState;
                    if (SUCCEEDED(pdr->GetRecorderState(&ulState)))
                    {
                        fBurning = (ulState & (RECORDER_BURNING | RECORDER_OPENED));
                    }
                    pdr->Release();
                }
                pdm->Release();
                pjdm->Release();
            }
        }
        pcdb->Release();
    }
    return fBurning;
}

// handy stuff from lowdisk
BOOL CCDBurn::_EnterExclusiveBurning()
{
    if (NULL == _hMutexBurning)
    {
        // since imapi runs in the system context and only one client can use it at a time,
        // make the mutex in the global namespace.
        _hMutexBurning = CreateMutex(CreateAllAccessSecurityAttributes(NULL, NULL, NULL), FALSE, L"Global\\CDBurnExclusive");
        if (!_hMutexBurning)
        {
            // we'll get here if we're running as a limited user.
            // we don't have access to the global namespace so create it in the current session.
            // this will look normal within the session but across users it'll be more bogus since we'll let the
            // user start the burn from the wizard but we'll fail later.  that's good enough.
            _hMutexBurning = CreateMutex(CreateAllAccessSecurityAttributes(NULL, NULL, NULL), FALSE, L"CDBurnExclusive");
        }
    }
    return _hMutexBurning && (WAIT_OBJECT_0 == WaitForSingleObject(_hMutexBurning, 0));    // zero timeout
}

void CCDBurn::_LeaveExclusiveBurning()
{
    ASSERT(_hMutexBurning);
    ReleaseMutex(_hMutexBurning);
}

HRESULT CCDBurn::_Balloon()
{
    WCHAR szTitle[50];
    LoadString(HINST_THISDLL, IDS_BURN_NOTIFY_TITLE, szTitle, ARRAYSIZE(szTitle));
    WCHAR szMsg[100];
    LoadString(HINST_THISDLL, IDS_BURN_NOTIFY, szMsg, ARRAYSIZE(szMsg));

    HICON hIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_DRIVECD));

    IUserNotification *pun;
    HRESULT hr = CoCreateInstance(CLSID_UserNotification, NULL, CLSCTX_ALL, IID_PPV_ARG(IUserNotification, &pun));
    if (SUCCEEDED(hr))
    {
        pun->SetBalloonRetry(30 * 1000, -1, 0);
        pun->SetIconInfo(hIcon, szTitle);
        pun->SetBalloonInfo(szTitle, szMsg, NIIF_INFO);

        hr = pun->Show(NULL, 0);

        pun->Release();
    }

    if (hIcon)
    {
        DestroyIcon(hIcon);
    }

    return hr;
}

typedef struct
{
    LPCITEMIDLIST pidlFolder;
    BOOL fRet;
} CDBURNENUMSTRUCT;

BOOL CALLBACK CCDBurn::_EnumProc(HWND hwnd, LPCITEMIDLIST pidl, LPARAM lParam)
{
    CDBURNENUMSTRUCT *pes = (CDBURNENUMSTRUCT*)lParam;

    if (ILIsParent(pes->pidlFolder, pidl, FALSE))
    {
        pes->fRet = TRUE;
        return FALSE;  // stop enumerating, we know we got it.
    }
    return TRUE;
}

BOOL CCDBurn::_BurningFolderOpen()
{
    BOOL fRet = FALSE;

    LPITEMIDLIST pidlFolder;
    if (SUCCEEDED(_GetFolderPidl(&pidlFolder)))
    {
        CDBURNENUMSTRUCT es = { 0 };
        es.pidlFolder = pidlFolder;

        EnumShellWindows(_EnumProc, (LPARAM)&es);
        fRet = es.fRet;

        ILFree(pidlFolder);
    }
    return fRet;
}

DWORD CALLBACK CCDBurn::_NotifyThreadProc(void *pv)
{
    CCDBurn *pcdb = (CCDBurn *)pv;
    HANDLE hMutexNotify = CreateMutex(CreateAllAccessSecurityAttributes(NULL, NULL, NULL), FALSE, L"CDBurnNotify");
    if (hMutexNotify)
    {
        if (WAIT_OBJECT_0 == WaitForSingleObject(hMutexNotify, 0))
        {
            if (!_BurningFolderOpen() && !_IsBurningNow())
            {
                if (S_OK == pcdb->_Balloon())
                {
                    LPITEMIDLIST pidl;
                    if (SUCCEEDED(_GetFolderPidl(&pidl)))
                    {
                        // Use shellexecuteex to open a view folder
                        SHELLEXECUTEINFO sei = { 0 };
                        sei.cbSize = sizeof(sei);
                        sei.lpIDList = pidl;
                        sei.fMask = SEE_MASK_FLAG_NO_UI | SEE_MASK_IDLIST;
                        sei.nShow = SW_SHOWNORMAL;
                        sei.lpVerb = c_szOpen;

                        ShellExecuteEx(&sei);

                        ILFree(pidl);
                    }
                }
            }
            ReleaseMutex(hMutexNotify);
        }
        CloseHandle(hMutexNotify);
    }
    pcdb->Release();
    return 0;
}

void CCDBurn::_CheckStagingArea()
{
    // only do stuff if we're enabled.
    int iCurrent;
    if (SUCCEEDED(_GetCurrentDriveIndex(&iCurrent)) && _StagingAreaHasFiles())
    {
        AddRef();
        if (!SHCreateThread(_NotifyThreadProc, this, CTF_COINIT, NULL))
        {
            Release();
        }
    }
}

STDAPI CheckStagingArea()
{
    CCDBurn *pcdb = new CCDBurn();
    if (pcdb)
    {
        pcdb->_CheckStagingArea();
        pcdb->Release();
    }
    return S_OK;
}

HRESULT _CreateDataObject(IDataObject **ppdo)
{
    LPITEMIDLIST pidl;
    HRESULT hr = SHGetFolderLocation(NULL, CSIDL_CDBURN_AREA, NULL, 0, &pidl);
    if (SUCCEEDED(hr))
    {
        hr = SHGetUIObjectOf(pidl, NULL, IID_PPV_ARG(IDataObject, ppdo));
        ILFree(pidl);
    }
    return hr;
}

// this will eventually put up confirmation UI.  for now just tally size.
HRESULT CCDBurn::FoundItem(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    IShellFolder2 *psf2;
    if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2))))
    {
        ULONGLONG cbItemSize;
        if (SUCCEEDED(GetLongProperty(psf2, pidl, &SCID_SIZE, &cbItemSize)))
        {
            _cbStagedSize += cbItemSize;
        }
        psf2->Release();
    }
    return S_OK;
}

HRESULT CCDBurn::_CheckTotal()
{
    ULONGLONG cbTotal, cbFree;
    HRESULT hr = GetSpace(&cbTotal, &cbFree);
    if (SUCCEEDED(hr))
    {
        if (_cbStagedSize > cbFree)
        {
            hr = HRESULT_FROM_WIN32(ERROR_DISK_FULL);

            TCHAR szStaged[40], szFree[40], szOver[40];
            StrFormatByteSize64(_cbStagedSize, szStaged, ARRAYSIZE(szStaged));
            StrFormatByteSize64(cbFree, szFree, ARRAYSIZE(szFree));
            StrFormatByteSize64(_cbStagedSize - cbFree, szOver, ARRAYSIZE(szOver));

            LPTSTR pszMessage = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_BURN_DISCFULLTEXT), szFree, szStaged, szOver);
            if (pszMessage)
            {
                SHPropertyBag_WriteStr(_ppb, PROPSTR_DISCFULLTEXT, pszMessage);
                LocalFree(pszMessage);
            }
        }
    }
    return hr;
}

HRESULT CCDBurn::_Validate()
{
    INamespaceWalk *pnsw;
    HRESULT hr = CoCreateInstance(CLSID_NamespaceWalker, NULL, CLSCTX_INPROC, IID_PPV_ARG(INamespaceWalk, &pnsw));
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlStaging;
        hr = SHGetFolderLocation(NULL, CSIDL_CDBURN_AREA, NULL, 0, &pidlStaging);
        if (SUCCEEDED(hr))
        {
            IShellFolder *psf;
            hr = SHBindToObjectEx(NULL, pidlStaging, NULL, IID_PPV_ARG(IShellFolder, &psf));
            if (SUCCEEDED(hr))
            {
                _cbStagedSize = 0;
                // walk 15 levels deep, TODO figure out what Joliet's limitations are.
                hr = pnsw->Walk(psf, NSWF_DONT_TRAVERSE_LINKS, 15, this);
                if (SUCCEEDED(hr))
                {
                    hr = _CheckTotal();
                }
                psf->Release();
            }
            ILFree(pidlStaging);
        }
        pnsw->Release();
    }
    return hr;
}

DWORD WINAPI CCDBurn::_BurnThread(void *pv)
{
    CCDBurn *pcdb = (CCDBurn *) pv;

    HRESULT hr = pcdb->_Validate();
    if (SUCCEEDED(hr))
    {
        IDiscMaster *pdm;
        IJolietDiscMaster *pjdm;
        hr = pcdb->_GetDiscMasters(&pdm, &pjdm);
        if (SUCCEEDED(hr))
        {
            hr = pcdb->_SetJolietProps(pjdm);
            if (SUCCEEDED(hr))
            {
                UINT_PTR lCookie;
                hr = pdm->ProgressAdvise(pcdb, &lCookie);
                if (SUCCEEDED(hr))
                {
                    IDiscRecorder *pdr;
                    hr = pcdb->_FindAndSetDefaultRecorder(pdm, TRUE, &pdr);
                    if (SUCCEEDED(hr))
                    {
                        pcdb->_InitTimeStats(FALSE);
                        // TODO ISSUE BUGBUG: import previous session here!
                        hr = pcdb->_AddData(pjdm);
                        // TODO ISSUE BUG: AddData doesn't call QueryCancel, we do it manually for now
                        boolean bCancelled;
                        pcdb->QueryCancel(&bCancelled);
                        if (SUCCEEDED(hr) && !bCancelled)
                        {
                            BOOL fAutoEject = TRUE;
                            pcdb->_GetEjectSetting(&fAutoEject);

                            // false is to make a real recording instead of a simulated one
                            hr = pdm->RecordDisc(FALSE, (boolean)fAutoEject);
                            if (SUCCEEDED(hr))
                            {
                                // bug: recorddisc doesnt call back into NotifyBurnComplete so this has to be done here
                                pcdb->_ts.dwTickCloseEnd = GetTickCount();
                                pcdb->_SaveTimeStats(FALSE);
                            }
                        }
                        pdr->Release();
                    }
                    pdm->ProgressUnadvise(lCookie);
                }
            }
            pdm->Release();
            pjdm->Release();
        }
    }

    _LockCurrentDrive(FALSE);

    if (!pcdb->_fCancelled)
    {
        SHPropertyBag_WriteDWORD(pcdb->_ppb, PROPSTR_HR, hr);
        PropSheet_SetWizButtons(GetParent(pcdb->_hwndWizardPage), PSWIZB_NEXT);
        PropSheet_PressButton(GetParent(pcdb->_hwndWizardPage), PSBTN_NEXT);
    }

    pcdb->Release();
    return 0;
}

DWORD WINAPI CCDBurn::_EraseThread(void *pv)
{
    CCDBurn *pcdb = (CCDBurn *) pv;

    IDiscMaster *pdm;
    IJolietDiscMaster *pjdm;
    HRESULT hr = pcdb->_GetDiscMasters(&pdm, &pjdm);
    if (SUCCEEDED(hr))
    {
        IDiscRecorder *pdr;
        hr = pcdb->_FindAndSetDefaultRecorder(pdm, FALSE, &pdr);
        if (SUCCEEDED(hr))
        {
            pcdb->_SetStatus(IDS_BURN_ERASEDISC);
            hr = pdr->OpenExclusive();
            if (SUCCEEDED(hr))
            {
                pcdb->_InitTimeStats(TRUE);
                pcdb->_ts.dwTickEraseStart = GetTickCount();
                hr = pdr->Erase(FALSE);   // do quick erase
                if (SUCCEEDED(hr))
                {
                    hr = pdr->Close();
                    // bug: this is here only because Erase doesn't call NotifyEraseComplete
                    pcdb->_ts.dwTickEraseEnd = GetTickCount();
                    pcdb->_SaveTimeStats(TRUE);
                }
            }
            pdr->Release();
        }
        pdm->Release();
        pjdm->Release();
    }

    _LockCurrentDrive(FALSE);

    if (!pcdb->_fCancelled)
    {
        SHPropertyBag_WriteDWORD(pcdb->_ppb, PROPSTR_HR, hr);
        PropSheet_SetWizButtons(GetParent(pcdb->_hwndWizardPage), PSWIZB_NEXT);
        PropSheet_PressButton(GetParent(pcdb->_hwndWizardPage), PSBTN_NEXT);
    }

    pcdb->Release();
    return 0;
}

HRESULT CCDBurn::_GetPidlForDriveIndex(int iDrive, LPITEMIDLIST *ppidl)
{
    HRESULT hr = E_FAIL;

    TCHAR szPath[4];
    if (PathBuildRoot(szPath, iDrive))
    {
        hr = SHILCreateFromPath(szPath, ppidl, NULL);
    }
    return hr;
}

HRESULT CCDBurn::_GetPidlForVolumeName(LPCTSTR pszVolume, LPITEMIDLIST *ppidl)
{
    int iDrive;
    HRESULT hr = _GetDriveIndexForVolumeName(pszVolume, &iDrive);
    if (SUCCEEDED(hr))
    {
        WCHAR szRoot[4];
        hr = PathBuildRoot(szRoot, iDrive) ? S_OK : E_FAIL;
        if (SUCCEEDED(hr))
        {
            hr = SHILCreateFromPath(szRoot, ppidl, NULL);
        }
    }
    return hr;
}

HRESULT CCDBurn::_GetFolderPidl(LPITEMIDLIST *ppidl)
{
    TCHAR szCurrent[MAX_PATH];
    HRESULT hr = _GetCurrentBurnVolumeName(szCurrent, ARRAYSIZE(szCurrent));
    if (SUCCEEDED(hr))
    {
        hr = _GetPidlForVolumeName(szCurrent, ppidl);
    }
    return hr;
}

void CCDBurn::_HandleBookkeeping()
{
    _DumpDiscInfo();
    _StoreDiscInfo();
}

// IDropTarget handling
//  This code forwards to drop target folder for the currently configured burn drive.

// merged folder hands off to ccdburn because otherwise it'd be doing too much
// cd burning specific stuff (media detection on drop, etc.)

HRESULT CCDBurn::_EnsureDropTarget()
{
    HRESULT hr = S_OK;
    if (!_pdt)
    {
        if (_BurningIsEnabled())
        {
            TCHAR szStaging[MAX_PATH];
            hr = _GetBurnStagingPath(szStaging, ARRAYSIZE(szStaging));
            if (SUCCEEDED(hr))
            {
                LPITEMIDLIST pidl;
                hr = SHILCreateFromPath(szStaging, &pidl, NULL);
                if (SUCCEEDED(hr))
                {
                    IShellFolder *psf;
                    hr = SHBindToObjectEx(NULL, pidl, NULL, IID_PPV_ARG(IShellFolder, &psf));
                    if (SUCCEEDED(hr))
                    {
                        hr = psf->CreateViewObject(NULL, IID_PPV_ARG(IDropTarget, &_pdt));
                        psf->Release();
                    }
                    ILFree(pidl);
                }
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }
    return hr;
}

HRESULT CCDBurn::_GetDropPidl(LPITEMIDLIST *ppidl)
{
    HRESULT hr;
    if (!_pidl)
    {
        // in the sendto case we aren't called through Initialize, so get default root pidl.
        hr = _GetFolderPidl(ppidl);
    }
    else
    {
        hr = SHILClone(_pidl, ppidl);
    }
    return hr;
}

HRESULT CCDBurn::_StagingPidlFromMerged(LPCITEMIDLIST pidlDrop, LPITEMIDLIST *ppidlDest)
{
    IAugmentedShellFolder *pasf;
    HRESULT hr = SHBindToObjectEx(NULL, pidlDrop, NULL, IID_PPV_ARG(IAugmentedShellFolder, &pasf));
    if (SUCCEEDED(hr))
    {
        hr = E_FAIL;
        
        DWORD dwNSId;
        GUID guid;
        IShellFolder *psf;
        BOOL fDone = FALSE;
        for (DWORD dwIndex = 0; 
             !fDone && SUCCEEDED(pasf->EnumNameSpace(dwIndex, &dwNSId)) && SUCCEEDED(pasf->QueryNameSpace(dwNSId, &guid, &psf));
             dwIndex++)
        {
            if (IsEqualGUID(guid, CLSID_StagingFolder))
            {
                IPersistFolder3 *ppf3;
                hr = psf->QueryInterface(IID_PPV_ARG(IPersistFolder3, &ppf3));
                if (SUCCEEDED(hr))
                {
                    PERSIST_FOLDER_TARGET_INFO pfti = {0};
                    hr = ppf3->GetFolderTargetInfo(&pfti);
                    if (SUCCEEDED(hr))
                    {
                        *ppidlDest = pfti.pidlTargetFolder;
                    }
                    ppf3->Release();
                }
                fDone = TRUE;
            }                
            psf->Release();
        }
        pasf->Release();
    }
    return hr;
}

BOOL CCDBurn::_IsStagingAreaSource(IDataObject *pdtobj, LPCITEMIDLIST pidlDrop)
{
    BOOL fParent = FALSE; //source is parent of destination
    BOOL fSame = FALSE; //source and destination are the same
    // in UDF case we skip staging area so no need to do this work
    BOOL fUDF = FALSE;
    _GetMediaCapabilities(NULL, &fUDF);
    if (!fUDF)
    {
        LPITEMIDLIST pidlDest;
        if (SUCCEEDED(_StagingPidlFromMerged(pidlDrop, &pidlDest)))
        {
            STGMEDIUM medium;
            LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
            if (pida)
            {
                LPCITEMIDLIST pidlSource = IDA_GetIDListPtr(pida, -1);
                if (pidlSource)
                {
                    if (!ILIsEmpty(pidlSource))
                    {
                        fSame = ILIsEqual(pidlSource, pidlDest);
                        if (!fSame && ILIsParent(pidlSource, pidlDest, FALSE))
                        {
                            LPCITEMIDLIST pidl;
                            for (UINT i = 0; !fSame && !fParent && (pidl = IDA_GetIDListPtr(pida, i)); i++)
                            {
                                LPITEMIDLIST pidlFull = ILCombine(pidlSource, pidl);
                                if (pidlFull)
                                {
                                    fSame = ILIsEqual(pidlFull, pidlDest);
                                    if (!fSame)
                                        fParent = ILIsParent(pidlFull, pidlDest, FALSE);
                                    ILFree(pidlFull);
                                }
                            }
                        }                        
                    }
                    else //find folder has full pidls and empty one for a source
                    {
                        LPCITEMIDLIST pidl;
                        for (UINT i = 0; !fSame && !fParent && (pidl = IDA_GetIDListPtr(pida, i)); i++)
                        {
                            LPITEMIDLIST pidlParent = ILCloneParent(pidl);
                            if (pidlParent)
                            {
                                fSame = ILIsEqual(pidlParent, pidlDest) || ILIsEqual(pidl, pidlDest);
                                if (!fSame)
                                    fParent = ILIsParent(pidl, pidlDest, FALSE);
                                ILFree(pidlParent);
                            }
                        }
                    }
                }
                HIDA_ReleaseStgMedium(pida, &medium);
            }
            ILFree(pidlDest);
        }
    }

    if (fSame || fParent)
    {
        UINT idMessage = fSame ? IDS_REASONS_DESTSAMETREE : IDS_REASONS_DESTSUBTREE;
        ShellMessageBox(g_hinst, _hwndBrowser, MAKEINTRESOURCE(idMessage), MAKEINTRESOURCE(IDS_BURN), MB_ICONEXCLAMATION | MB_OK);
    }
    return (fSame || fParent);
}

HRESULT CCDBurn::_StorageDrop(IDataObject *pdtobj, BOOL fMove)
{
    LPITEMIDLIST pidlDrop;
    HRESULT hr = _GetDropPidl(&pidlDrop);
    if (SUCCEEDED(hr))
    {
        if (!_IsStagingAreaSource(pdtobj, pidlDrop))
        {
            IShellItem *psiDest;
            hr = SHCreateShellItem(NULL, NULL, pidlDrop, &psiDest);
            if (SUCCEEDED(hr))
            {
                hr = TransferDataObject(pdtobj, psiDest, fMove ? STGOP_MOVE : STGOP_COPY_PREFERHARDLINK, 0, this);
                psiDest->Release();
            }
        }
        else
        {
            hr = E_FAIL;
        }
        ILFree(pidlDrop);
    }
    return hr;
}

HRESULT CCDBurn::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    // lets get the drop object for the folder that is configured for the
    // burn drive.  to do this we need to get the staging folder.

    // this also determines if we show up in sendto or not.
    HRESULT hr = _EnsureDropTarget();
    if (SUCCEEDED(hr) && _pdt)
    {
        hr = _pdt->DragEnter(pdtobj, grfKeyState, pt, pdwEffect);
    }
    else
    {
        // there was no drop target, therefore there is no burn drive, therefore we shouldn't
        // offer the ability to drag drop onto our object.
        *pdwEffect = DROPEFFECT_NONE;
    }
    _dwDropEffect = *pdwEffect;
    return hr;
}

HRESULT CCDBurn::DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hr = E_FAIL;
    if (_pdt)
    {
        hr = _pdt->DragOver(grfKeyState, pt, pdwEffect);
        _dwDropEffect = *pdwEffect;
    }
    return hr;
}

HRESULT CCDBurn::DragLeave(void)
{
    if (!_pdt)
        return E_FAIL;

    return _pdt->DragLeave();
}

void CCDBurn::_FreeDropParams(CDDROPPARAMS *pcddp)
{
    pcddp->pcdb->Release();
    ATOMICRELEASE(pcddp->pstmDataObj);
    delete pcddp;
}

DWORD WINAPI CCDBurn::_DropThread(void *pv)
{
    CDDROPPARAMS *pcddp = (CDDROPPARAMS*)pv;

    IDataObject *pdtobj;
    if (SUCCEEDED(CoGetInterfaceAndReleaseStream(pcddp->pstmDataObj, IID_PPV_ARG(IDataObject, &pdtobj))))
    {
        pcddp->pcdb->_StorageDrop(pdtobj, pcddp->fMove);
        pdtobj->Release();
    }
    pcddp->pstmDataObj = NULL; // released by CoGetInterfaceAndReleaseStream

    _FreeDropParams(pcddp);
    return 0;
}

HRESULT CCDBurn::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hr = E_OUTOFMEMORY;
    CDDROPPARAMS *pcddp = new CDDROPPARAMS;
    if (pcddp)
    {
        // get the hwnd from the site while we're on this thread so that we
        // don't get SetSite(NULL) before we check it later.
        IOleWindow *pow;
        if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IOleWindow, &pow))))
        {
            pow->GetWindow(&_hwndBrowser);
            pow->Release();
        }

        pcddp->pcdb = this;
        AddRef();

        CoMarshalInterThreadInterfaceInStream(IID_IDataObject, pdtobj, &pcddp->pstmDataObj);

        pcddp->fMove = (_dwDropEffect == DROPEFFECT_MOVE);
        if (pcddp->fMove)
        {
            _dwDropEffect = DROPEFFECT_NONE; // other thread will take care of move, so caller should take no action
        }
        *pdwEffect = _dwDropEffect;

        if (SHCreateThread(_DropThread, pcddp, CTF_COINIT, NULL))
        {
            hr = S_OK;
        }
        else
        {
            _FreeDropParams(pcddp);
            hr = E_OUTOFMEMORY;
        }
    }
    DragLeave();
    return hr;
}

// Helper function to get an IShellFolder object for the staging folder

HRESULT CCDBurn::_GetStagingFolder(LPCITEMIDLIST pidlDrive, REFIID riid, void **ppv)
{
    TCHAR szPath[MAX_PATH];
    HRESULT hr = CCDBurn::_GetBurnStagingPath(szPath, ARRAYSIZE(szPath));
    if (SUCCEEDED(hr))
    {
        // fake up a directory object simple IDLIST          
        WIN32_FIND_DATA fd = {0};
        fd.dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;        

        LPITEMIDLIST pidlStg;
        hr = SHSimpleIDListFromFindData(szPath, &fd, &pidlStg);
        if (SUCCEEDED(hr))
        {
            // now initialize the folder with it
            PERSIST_FOLDER_TARGET_INFO pfti = {0};

            pfti.pidlTargetFolder = (LPITEMIDLIST)pidlStg;
            SHTCharToUnicode(szPath, pfti.szTargetParsingName, ARRAYSIZE(pfti.szTargetParsingName));
            pfti.dwAttributes = FILE_ATTRIBUTE_DIRECTORY; // maybe add system?
            pfti.csidl = -1;

            hr = CFSFolder_CreateFolder(NULL, NULL, pidlDrive, &pfti, riid, ppv);
            ILFree(pidlStg);
        }
    }
    return hr;
}

// ripped from IMAPI.
DWORD CCDBurn::_ExecSyncIoctl(HANDLE hDriver, DWORD dwIoctl, void *pbuf, DWORD cbBuf)
{
    DWORD dwResult = NO_ERROR;
    OVERLAPPED ol = { 0 };
    ol.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (ol.hEvent)
    {
        DWORD dwBytes;
        BOOL bStatus = DeviceIoControl(hDriver, dwIoctl, pbuf, cbBuf, pbuf, cbBuf, &dwBytes, &ol);
        if (!bStatus)
        {
            dwResult = GetLastError();
            if (ERROR_IO_PENDING == dwResult)
            {
                bStatus = GetOverlappedResult(hDriver, &ol, &dwBytes, TRUE);
                dwResult = bStatus ? NO_ERROR : GetLastError();
            }
        }
        CloseHandle(ol.hEvent);
    }
    else
    {
        dwResult = ERROR_OUTOFMEMORY;
    }
    return dwResult;
}

// {1186654D-47B8-48b9-BEB9-7DF113AE3C67}
static const GUID IMAPIDeviceInterfaceGUID = { 0x1186654d, 0x47b8, 0x48b9, { 0xbe, 0xb9, 0x7d, 0xf1, 0x13, 0xae, 0x3c, 0x67 } };
// this is a first approximation to see if the drive is supported or not to avoid loading imapi at boot
// whenever possible.  if this passes, then we still have to use imapi to make sure, but if this returns
// false, theres no way imapi will support it.
// note that this mimics the logic in imapi's CMSEnumDiscRecordersObj::Next enumerator function.
BOOL CCDBurn::_CouldPossiblySupport(LPCWSTR pszVolume)
{
    // if the user isnt an admin, then these checks wont work.
    // just assume that we could support it, and let imapi do the privileged stuff since its a service.
    // perfwise this isnt such a big hit since the admin home user is the main scenario.
    if (!IsUserAnAdmin())
        return TRUE;

    BOOL fSupported = FALSE;
    HDEVINFO hDevInfo = SetupDiGetClassDevs(&IMAPIDeviceInterfaceGUID, NULL, NULL, DIGCF_PRESENT | DIGCF_INTERFACEDEVICE);
    if (INVALID_HANDLE_VALUE != hDevInfo)
    {
        SP_DEVICE_INTERFACE_DATA did = { 0 };
        did.cbSize = sizeof(did);
        for (int i = 0; !fSupported && SetupDiEnumDeviceInterfaces(hDevInfo, 0, &IMAPIDeviceInterfaceGUID, i, &did); i++)
        {
            ULONG cbRequired = 0;
            SetupDiGetDeviceInterfaceDetail(hDevInfo, &did, NULL, 0, &cbRequired, NULL);
            if (cbRequired > 0)
            {
                cbRequired += sizeof(WCHAR);
                PSP_DEVICE_INTERFACE_DETAIL_DATA pdidd = (PSP_DEVICE_INTERFACE_DETAIL_DATA)LocalAlloc(LPTR, cbRequired);
                if (pdidd)
                {
                    pdidd->cbSize = sizeof(*pdidd);
                    SP_DEVINFO_DATA dd = { 0 };
                    dd.cbSize = sizeof(dd);
                    if (SetupDiGetDeviceInterfaceDetail(hDevInfo, &did, pdidd, cbRequired, NULL, &dd))
                    {
                        WCHAR szLower[100];
                        BOOL fHasFilter = FALSE;
                        if (SetupDiGetDeviceRegistryProperty(hDevInfo, &dd, SPDRP_LOWERFILTERS, NULL, (BYTE*)szLower, sizeof(szLower), NULL))
                        {
                            PCWSTR psz = szLower;
                            while (*psz && !fHasFilter)
                            {
                                if (StrCmpI(psz, L"imapi") == 0)
                                {
                                    fHasFilter = TRUE;
                                }
                                psz += lstrlenW(psz) + 1;
                            }
                        }

                        if (fHasFilter)
                        {
                            HANDLE hDriver = CreateFile(pdidd->DevicePath, GENERIC_READ | GENERIC_WRITE,
                                                        FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                                                        FILE_FLAG_OVERLAPPED, NULL);
                            if (INVALID_HANDLE_VALUE != hDriver)
                            {
                                STORAGE_DEVICE_NUMBER sdn = { 0 };
                                if (NO_ERROR == _ExecSyncIoctl(hDriver, IOCTL_STORAGE_GET_DEVICE_NUMBER, &sdn, sizeof(sdn)))
                                {
                                    WCHAR szDevicePath[50];
                                    wnsprintf(szDevicePath, ARRAYSIZE(szDevicePath), L"\\Device\\CdRom%d", sdn.DeviceNumber);
                                    fSupported = _DevicePathMatchesVolumeName(szDevicePath, pszVolume);
                                }
                                CloseHandle(hDriver);
                            }
                        }
                    }
                    LocalFree(pdidd);
                }
            }
        }
        SetupDiDestroyDeviceInfoList(hDevInfo);
    }
    return fSupported;
}

HRESULT CDBurn_OnDeviceAdded(DWORD dwDriveMask, BOOL fFullRefresh, BOOL fPickNewDrive)
{
    HRESULT hr = S_OK;

    // only do stuff if the user doesn't have a drive configured already
    TCHAR szDummy[MAX_PATH];
    HRESULT hrCheck = CCDBurn::_GetCurrentBurnVolumeName(szDummy, ARRAYSIZE(szDummy));
    // if hr == E_UNEXPECTED, then there's already a empty string in the registry for the current
    // burn drive.  that means the user disabled the functionality so don't put it back.
    if (fFullRefresh || (FAILED(hrCheck) && (hrCheck != E_UNEXPECTED)))
    {
        hr = E_OUTOFMEMORY;
        CCDBurn *pcdb = new CCDBurn();
        if (pcdb)
        {
            // keep track of the fastest drive in the system to default to.
            DWORD dwBestWrite = 0;
            TCHAR szNewBurnVolume[MAX_PATH];

            // only run through this if the device that just got added is a cd.
            // this drive letter stuff is weak but it's what comes from base's notification.
            BOOL fCheck = FALSE;
            for (int i = 0; i < 26; i++)
            {
                TCHAR szDriveLetter[4];
                if (PathBuildRoot(szDriveLetter, i) &&
                    (GetDriveType(szDriveLetter) == DRIVE_CDROM))
                {
                    TCHAR szVolumeName[MAX_PATH];
                    if (SUCCEEDED(CCDBurn::_GetVolumeNameForDriveIndex(i, szVolumeName, ARRAYSIZE(szVolumeName))))
                    {
                        DWORD dwMaxWrite, dwDriveType;
                        // if we already have info on the drive, we don't need to worry about it.
                        // if we dont have info, check it.
                        // if we're doing a full refresh then always recheck if it wasnt supported before --
                        // this could happen if a driver update across a reboot caused a drive to get supported.
                        if (FAILED(CCDBurn::_GetCachedDriveInfo(szVolumeName, &dwDriveType, NULL, &dwMaxWrite)) ||
                            (fFullRefresh && !SUPPORTED(dwDriveType)))
                        {
                            if (CCDBurn::_CouldPossiblySupport(szVolumeName))
                            {
                                // all new cd-rom drives need to be checked with IMAPI.
                                fCheck = TRUE;
                            }
                            // default to unsupported.  this is so we don't have to hit IMAPI on
                            // the property sheet later.
                            CCDBurn::_SetCachedDriveInfo(szVolumeName, DRIVE_NOTSUPPORTED, 0, 0);
                        }
                        else
                        {
                            if (SUPPORTED(dwDriveType) && (dwMaxWrite > dwBestWrite))
                            {
                                // we'll always take the fastest one
                                dwBestWrite = dwMaxWrite;
                                lstrcpyn(szNewBurnVolume, szVolumeName, ARRAYSIZE(szNewBurnVolume));
                            }
                        }
                    }
                }
            }

            // okay we have to enumerate through IMAPI.
            if (fCheck)
            {
                IDiscMaster *pdm;
                IJolietDiscMaster *pjdm;
                hr = pcdb->_GetDiscMasters(&pdm, &pjdm);
                if (SUCCEEDED(hr))
                {
                    IEnumDiscRecorders *penumdr;
                    hr = pdm->EnumDiscRecorders(&penumdr);
                    if (SUCCEEDED(hr))
                    {
                        ULONG celt;
                        IDiscRecorder *pdr;
                        while (S_OK == penumdr->Next(1, &pdr, &celt))
                        {
                            TCHAR szDevicePath[MAX_PATH];
                            if (SUCCEEDED(pcdb->_GetRecorderPath(pdr, szDevicePath, ARRAYSIZE(szDevicePath))))
                            {
                                DWORD dwMaxWrite, dwDriveType;
                                if (SUCCEEDED(pcdb->_GetDiscRecorderInfo(pdr, NULL, &dwMaxWrite, &dwDriveType)))
                                {
                                    TCHAR szVolumeName[MAX_PATH];
                                    if (SUCCEEDED(pcdb->_GetVolumeNameForDevicePath(szDevicePath, szVolumeName, ARRAYSIZE(szVolumeName))))
                                    {
                                        if (dwMaxWrite > dwBestWrite)
                                        {
                                            // we'll always take the fastest one
                                            dwBestWrite = dwMaxWrite;
                                            lstrcpyn(szNewBurnVolume, szVolumeName, ARRAYSIZE(szNewBurnVolume));
                                        }
                                        // default to fastest speed for the drive
                                        pcdb->_SetCachedDriveInfo(szVolumeName, dwDriveType, WRITESPEED_FASTEST, dwMaxWrite);
                                    }
                                }
                            }
                            pdr->Release();
                        }
                        penumdr->Release();
                    }
                    pdm->Release();
                    pjdm->Release();
                }
            }

            if (fPickNewDrive && (dwBestWrite > 0))
            {
                pcdb->_SetCurrentBurnVolumeName(szNewBurnVolume, FALSE);
            }
            pcdb->Release();
        }
    }
    return hr;
}

void CCDBurn::_PruneRemovedDevices()
{
    HKEY hk;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_CURRENT_USER, REGSTR_PATH_DRIVES, &hk))
    {
        // since we're deleting as we're moving along, walk backwards.
        DWORD dwLast;
        if (ERROR_SUCCESS == RegQueryInfoKey(hk, NULL, NULL, NULL, &dwLast, NULL, NULL, NULL, NULL, NULL, NULL, NULL))
        {
            TCHAR szVolKey[MAX_PATH];
            for (int i = dwLast - 1; (i >= 0) && ERROR_SUCCESS == RegEnumKey(hk, i, szVolKey, ARRAYSIZE(szVolKey)); i--)
            {
                TCHAR szCachedVol[MAX_PATH];
                lstrcpyn(szCachedVol, L"\\\\?\\", ARRAYSIZE(szCachedVol));
                StrCatBuff(szCachedVol, szVolKey, ARRAYSIZE(szCachedVol));
                StrCatBuff(szCachedVol, L"\\", ARRAYSIZE(szCachedVol));

                int iDrive;
                if (FAILED(CCDBurn::_GetDriveIndexForVolumeName(szCachedVol, &iDrive)))
                {
                    // this drive is dead, remove its cached info
                    TCHAR szRegPath[MAX_PATH];
                    lstrcpyn(szRegPath, REGSTR_PATH_DRIVES, ARRAYSIZE(szRegPath));
                    StrCatBuff(szRegPath, L"\\", ARRAYSIZE(szRegPath));
                    StrCatBuff(szRegPath, szVolKey, ARRAYSIZE(szRegPath));
                    SHDeleteKey(HKEY_CURRENT_USER, szRegPath);
                }
            }
        }
        RegCloseKey(hk);
    }
}

HRESULT CDBurn_OnDeviceRemoved(DWORD dwDriveMask)
{
    HRESULT hr = S_OK;

    // see if the selected drive just got removed.
    TCHAR szVolumeName[MAX_PATH];
    HRESULT hrCheck = CCDBurn::_GetCurrentBurnVolumeName(szVolumeName, ARRAYSIZE(szVolumeName));

    CCDBurn::_PruneRemovedDevices();

    BOOL fFound = FALSE;
    HKEY hk;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_CURRENT_USER, REGSTR_PATH_DRIVES, &hk))
    {
        TCHAR szVolKey[MAX_PATH];
        for (int i = 0; ERROR_SUCCESS == RegEnumKey(hk, i, szVolKey, ARRAYSIZE(szVolKey)); i++)
        {
            TCHAR szCachedVol[MAX_PATH];
            lstrcpyn(szCachedVol, L"\\\\?\\", ARRAYSIZE(szCachedVol));
            StrCatBuff(szCachedVol, szVolKey, ARRAYSIZE(szCachedVol));
            StrCatBuff(szCachedVol, L"\\", ARRAYSIZE(szCachedVol));

            int iDrive;
            if (SUCCEEDED(CCDBurn::_GetDriveIndexForVolumeName(szCachedVol, &iDrive)) &&
                SUCCEEDED(hrCheck) && (lstrcmpi(szCachedVol, szVolumeName) == 0))
            {
                // we found the drive that's currently enabled.
                // this means it's still currently mounted.

                // now check if either we dont have a cached index, or if the cached index is still the
                // same as it is now.  then we really didn't change.
                DWORD dwIndex, cb = sizeof(dwIndex);
                if ((ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_CACHEDINDEX, NULL, &dwIndex, &cb)) ||
                    (dwIndex == iDrive))
                {
                    fFound = TRUE;
                }
            }
        }
        RegCloseKey(hk);
    }

    if (SUCCEEDED(hrCheck) && !fFound)
    {
        // zonk the currently selected drive, we'll pick a new one from the rest.
        // this is all because the drive letter scheme doesn't let us get back to the volume name
        // since the drive letter is gone at this point.
        CCDBurn::_SetCurrentBurnVolumeName(TEXT(""), TRUE);
        hr = CDBurn_OnDeviceAdded(0, FALSE, TRUE);
    }
    return hr;
}

HRESULT CDBurn_OnDeviceChange(BOOL fAdd, LPCWSTR pszDrive)
{
    int iDriveIndex = PathGetDriveNumber(pszDrive);
    if (fAdd)
        CDBurn_OnDeviceAdded(1 << iDriveIndex, FALSE, TRUE);
    else
        CDBurn_OnDeviceRemoved(1 << iDriveIndex);
    return S_OK;
}

BOOL CCDBurn::_HasMedia()
{
    // unfortunately we have to assume there's media unless we find otherwise.
    BOOL fHasMedia = TRUE;

    CCDBurn *pcdb = new CCDBurn();
    if (pcdb)
    {
        IDiscMaster *pdm;
        IJolietDiscMaster *pjdm;
        if (SUCCEEDED(pcdb->_GetDiscMasters(&pdm, &pjdm)))
        {
            IDiscRecorder *pdr;
            if (SUCCEEDED(pcdb->_FindAndSetDefaultRecorder(pdm, FALSE, &pdr)))
            {
                if (SUCCEEDED(pdr->OpenExclusive()))
                {
                    long lMediaType, lMediaFlags;
                    if (SUCCEEDED(pdr->QueryMediaType(&lMediaType, &lMediaFlags)))
                    {
                        if (!lMediaType && !lMediaFlags)
                        {
                            fHasMedia = FALSE;
                        }
                    }
                    pdr->Close();
                }
                pdr->Release();
            }
            pdm->Release();
            pjdm->Release();
        }
        pcdb->Release();
    }
    return fHasMedia;
}

// this is called by mountpoint code BEFORE sending off the SHCNE_MEDIA events
// checking stuff on the media has to be done synchronously because it uses
// IMAPI and IMAPI can only have one caller at a time.
// autorun and things responding to SHCNE_MEDIA may also use IMAPI so we need to
// get this out of the way ASAP when media is inserted.
HRESULT CDBurn_OnMediaChange(BOOL fInsert, LPCWSTR pszDrive)
{
    int iCurrent;
    HRESULT hr = CCDBurn::_GetCurrentDriveIndex(&iCurrent);
    if (SUCCEEDED(hr) && (PathGetDriveNumber(pszDrive) == iCurrent))
    {
        if (fInsert)
        {
            CCDBurn::_HandleBookkeeping();
        }
        else if (!CCDBurn::_HasMedia())
        {
            CDBurn_OnEject(NULL, iCurrent);
        }
    }
    return hr;
}

HRESULT CDBurn_OnEject(HWND hwnd, INT iDrive)
{
    int iCurrent;
    HRESULT hr = CCDBurn::_GetCurrentDriveIndex(&iCurrent);
    if (SUCCEEDED(hr))
    {
        CCDBurn *pcdb = new CCDBurn();
        if (pcdb)
        {
            // we need to know whether to put up the dialog or not based on if the last
            // media was writable.  we cant check the media now since in the non-MMC2 case
            // the media is already ejected at this point, so we hit up our cache.
            DWORD dwMediaCap;
            DWORD cb = sizeof(dwMediaCap);
            if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_PERMEDIA, REGVALUE_MEDIATYPE, NULL, &dwMediaCap, &cb) &&
                (dwMediaCap & HWDMC_CDRECORDABLE))
            {
                pcdb->_DumpDiscInfo();
                if ((iDrive == iCurrent) && CCDBurn::_StagingAreaHasFiles())
                {
                    IPropertyBag *ppb;
                    hr = pcdb->_CreateDefaultPropBag(IID_PPV_ARG(IPropertyBag, &ppb));
                    if (SUCCEEDED(hr))
                    {
                        SHPropertyBag_WriteBOOL(ppb, PROPSTR_EJECT, TRUE);
                        hr = pcdb->Load(ppb, NULL);
                        if (SUCCEEDED(hr))
                        {
                            CMINVOKECOMMANDINFO cmi = { 0 };
                            hr = pcdb->_PrepWiz(&cmi, FALSE, TRUE);
                        }
                        ppb->Release();
                    }
                }
            }
            else
            {
                pcdb->_DumpDiscInfo();
                hr = S_OK;
            }
            pcdb->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

// IOleCommandTarget implementation

HRESULT CCDBurn::QueryStatus(const GUID* pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT* pCmdText)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;

    if (*pguidCmdGroup == CGID_ShellServiceObject)
    {
        // We like Shell Service Object notifications...
        hr = S_OK;
    }

    return hr;
}

DWORD WINAPI CCDBurn::_ExecThread(void *pv)
{
    CCDBurn *pcdb = (CCDBurn *)pv;

    // just in case explorer AV'd while holding the lock, unlock the next time we come up.
    // there's no way to guard against this.
    pcdb->_LockCurrentDrive(FALSE, TRUE);

    // hardware may have been added while we were powered down, and it won't generate
    // a notification event so we have to assume that anything could have changed
    // (inf registration for existing drives too, usually ones that require reboot to update).

    pcdb->_PruneRemovedDevices();

    // save off the currently selected drive and its write speed
    TCHAR szCurrent[MAX_PATH];
    DWORD dwCurWrite;
    HRESULT hrName = pcdb->_GetCurrentBurnVolumeName(szCurrent, ARRAYSIZE(szCurrent));
    if (SUCCEEDED(hrName))
    {
        DWORD dwType;
        hrName = pcdb->_GetCachedDriveInfo(szCurrent, &dwType, &dwCurWrite, NULL);
        // if the drive has become unsupported, we need to drop our currently selected
        // drive.
        if (SUCCEEDED(hrName) && !SUPPORTED(dwType))
        {
            hrName = E_FAIL;
        }
    }

    BOOL fSet = SUCCEEDED(hrName);
    // if it's E_UNEXPECTED then the user has disabled the burning feature completely.
    BOOL fDisabled = (hrName == E_UNEXPECTED);

    // readd devices, syncro
    CDBurn_OnDeviceAdded(0xFFFFFFFF, TRUE, !fSet);

    DWORD dwDriveType;
    if (fDisabled)
    {
        // if we're disabled, stay disabled
        pcdb->_SetCurrentBurnVolumeName(L"", FALSE);
    }
    else if (fSet && SUCCEEDED(pcdb->_GetCachedDriveInfo(szCurrent, &dwDriveType, NULL, NULL)) && SUPPORTED(dwDriveType))
    {
        // if the device we were using before is still supported, use the previous write speed
        pcdb->_SetCachedDriveInfo(szCurrent, DRIVE_USEEXISTING, dwCurWrite, 0);
    }

    if (pcdb->_BurningIsEnabled())
    {
        pcdb->_HandleBookkeeping();

        int iDrive;
        if (SUCCEEDED(pcdb->_GetCurrentDriveIndex(&iDrive)))
        {
            SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_CACHEDINDEX, REG_DWORD, &iDrive, sizeof(iDrive));
        }
        else
        {
            SHDeleteValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_CACHEDINDEX);
        }
    }

    pcdb->Release();
    return 0;
}

HRESULT CCDBurn::Exec(const GUID* pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG* pvaIn, VARIANTARG* pvaOut)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;

    if (*pguidCmdGroup == CGID_ShellServiceObject)
    {
        hr = S_OK; // Any ol' notification is ok with us
        // Handle Shell Service Object notifications here.
        switch (nCmdID)
        {
            case SSOCMDID_OPEN:
                // we're on the tray's thread as a service object so lets create our own thread.
                // this is fine since our thread is bound by IOCTLs to the CD-R etc.
                AddRef();
                if (SHCreateThread(_ExecThread, this, CTF_COINIT, NULL))
                    break;

                Release();
                break;

            default:
                break;
        }
    }

    return hr;
}

HRESULT CCDBurn::GetRecorderDriveLetter(LPWSTR pszDrive, UINT cch)
{
    if (cch < 4)
        return E_INVALIDARG;

    int iDrive;
    HRESULT hr = _GetCurrentDriveIndex(&iDrive);
    if (SUCCEEDED(hr))
    {
        // pathbuildroot assumes cch >= 4
        hr = PathBuildRoot(pszDrive, iDrive) ? S_OK : E_FAIL;
    }
    return hr;
}

// helper for lazy callers within shell32
STDAPI CDBurn_GetRecorderDriveLetter(LPWSTR pszDrive, UINT cch)
{
    ICDBurn *pcdb;
    HRESULT hr = CoCreateInstance(CLSID_CDBurn, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(ICDBurn, &pcdb));
    if (SUCCEEDED(hr))
    {
        hr = pcdb->GetRecorderDriveLetter(pszDrive, cch);
        pcdb->Release();
    }
    return hr;
}

HRESULT CCDBurn::Burn(HWND hwnd)
{
    HRESULT hr = InitNew();
    if (SUCCEEDED(hr))
    {
        // do this synchronously, callers will handle putting it on a separate thread.
        // this is easier than making a callback to tell them when its done.
        hr = _WizardThreadProc();
    }
    return hr;
}

HRESULT CCDBurn::HasRecordableDrive(BOOL *pfHasRecorder)
{
    *pfHasRecorder = FALSE;

    HKEY hk;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_CURRENT_USER, REGSTR_PATH_DRIVES, &hk))
    {
        TCHAR szVolKey[MAX_PATH];
        for (int i = 0; !*pfHasRecorder && (ERROR_SUCCESS == RegEnumKey(hk, i, szVolKey, ARRAYSIZE(szVolKey))); i++)
        {
            TCHAR szRegPath[MAX_PATH];
            lstrcpyn(szRegPath, REGSTR_PATH_DRIVES, ARRAYSIZE(szRegPath));
            StrCatBuff(szRegPath, L"\\", ARRAYSIZE(szRegPath));
            StrCatBuff(szRegPath, szVolKey, ARRAYSIZE(szRegPath));

            DWORD dwType;
            ULONG cb = sizeof(dwType);
            if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, szRegPath, REGVALUE_DRIVETYPE, NULL, &dwType, &cb))
            {
                *pfHasRecorder = SUPPORTED(dwType);
            }
        }
        RegCloseKey(hk);
    }
    return S_OK;
}

HRESULT CCDBurn::_DumpDiscInfo()
{
    SHDeleteKey(HKEY_CURRENT_USER, REGSTR_PATH_PERMEDIA);
    return S_OK;
}

HRESULT CCDBurn::_GetDiscInfoUsingIMAPI(IJolietDiscMaster *pjdm, IDiscRecorder *pdr, ULONGLONG *pcbFree)
{
    HRESULT hr = E_FAIL;
    BYTE bSessions, bLastTrack;
    LONG nBlockBytes;
    ULONG ulStartAddress, ulNextWritable, ulFreeBlocks;
    if (SUCCEEDED(pjdm->GetDataBlockSize(&nBlockBytes)) &&
        SUCCEEDED(pdr->QueryMediaInfo(&bSessions, &bLastTrack, &ulStartAddress, &ulNextWritable, &ulFreeBlocks)))
    {
        hr = S_OK;
        *pcbFree = (ULONGLONG) ulFreeBlocks * nBlockBytes;
    }
    return hr;
}

HRESULT CCDBurn::_GetDiscInfoUsingFilesystem(ULONGLONG *pcbTotal, ULONGLONG *pcbFree, BOOL *pfUDF)
{
    int iCurrent;
    HRESULT hr = _GetCurrentDriveIndex(&iCurrent);
    if (SUCCEEDED(hr))
    {
        *pcbTotal = 0;
        *pcbFree = 0;
        ULARGE_INTEGER ulTotal, ulFree;
        TCHAR szRoot[4];
        if (PathBuildRoot(szRoot, iCurrent) && SHGetDiskFreeSpace(szRoot, &ulFree, &ulTotal, NULL))
        {
            *pcbTotal = ulTotal.QuadPart;
            *pcbFree = ulFree.QuadPart;
        }

        *pfUDF = FALSE;
        TCHAR szFilesystem[30];
        if (GetVolumeInformation(szRoot, NULL, 0, NULL, NULL, NULL, szFilesystem, ARRAYSIZE(szFilesystem)))
        {
            HUSKEY huskeyExclude;
            if (ERROR_SUCCESS == SHRegOpenUSKey(REGSTR_PATH_EXCLUDE, KEY_READ, NULL, &huskeyExclude, FALSE))
            {
                DWORD dwIndex = 0;
                TCHAR szKey[30];
                DWORD cchKey = ARRAYSIZE(szKey);
                while (!*pfUDF && (ERROR_SUCCESS == SHRegEnumUSValue(huskeyExclude, dwIndex, szKey, &cchKey, NULL, NULL, NULL, SHREGENUM_DEFAULT)))
                {
                    *pfUDF = (lstrcmpi(szFilesystem, szKey) == 0);

                    dwIndex++;
                    cchKey = ARRAYSIZE(szKey);
                }
                SHRegCloseUSKey(huskeyExclude);
            }
        }
    }
    return hr;
}

HRESULT CDBurn_GetCDInfo(LPCTSTR pszVolume, DWORD *pdwDriveCapabilities, DWORD *pdwMediaCapabilities)
{
    *pdwDriveCapabilities = 0;
    *pdwMediaCapabilities = 0;

    DWORD dwDriveType;
    HRESULT hr = CCDBurn::_GetCachedDriveInfo(pszVolume, &dwDriveType, NULL, NULL);
    if (SUCCEEDED(hr))
    {
        switch (dwDriveType)
        {
        case RECORDER_CDR:
            *pdwDriveCapabilities = HWDDC_CDROM | HWDDC_CDRECORDABLE;
            break;
        case RECORDER_CDRW:
            *pdwDriveCapabilities = HWDDC_CDROM | HWDDC_CDRECORDABLE | HWDDC_CDREWRITABLE;
            break;
        default:
            *pdwDriveCapabilities = HWDDC_CDROM;
            break;
        }

        DWORD dwMediaCap;
        DWORD cb = sizeof(dwMediaCap);
        if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_PERMEDIA, REGVALUE_MEDIATYPE, NULL, &dwMediaCap, &cb))
        {
            *pdwMediaCapabilities = dwMediaCap;
        }
    }
    return hr;
}

void CDBurn_GetUDFState(BOOL *pfUDF)
{
    *pfUDF = FALSE;

    DWORD dw, cb = sizeof(dw);
    if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_PERMEDIA, REGVALUE_UDF, NULL, &dw, &cb))
    {
        *pfUDF = dw;
    }
}

HRESULT CCDBurn::_GetMediaCapabilities(DWORD *pdwCap, BOOL *pfUDF)
{
    HRESULT hr = S_OK;

    if (pfUDF)
    {
        CDBurn_GetUDFState(pfUDF);
    }

    if (pdwCap)
    {
        *pdwCap = 0;

        TCHAR szVolumeName[MAX_PATH];
        hr = CCDBurn::_GetCurrentBurnVolumeName(szVolumeName, ARRAYSIZE(szVolumeName));
        if (SUCCEEDED(hr))
        {
            DWORD dwDriveCap;
            CDBurn_GetCDInfo(szVolumeName, &dwDriveCap, pdwCap);
        }
    }
    return hr;
}

HRESULT CCDBurn::GetMediaCapabilities(DWORD *pdwCap, BOOL *pfUDF)
{
    return _GetMediaCapabilities(pdwCap, pfUDF);
}

HRESULT CCDBurn::_StoreDiscInfo()
{
    HRESULT hr = E_FAIL;
    BOOL fDone = FALSE;
    int iRetryCount = 0;
    // retry up to a max of 5 times.
    // we can get into a state where we failed to pick up the disc information, if IMAPI
    // is around and in use by somebody else.  in that case just wait and loop around until we can
    // get it.
    while (!fDone && (iRetryCount < 5))
    {
        iRetryCount++;

        // these are the values we're going to pick up.
        ULONGLONG cbTotal, cbFree;
        DWORD dwMediaCaps;
        BOOL fUDF;

        hr = E_OUTOFMEMORY;
        CCDBurn *pcdb = new CCDBurn();
        if (pcdb)
        {
            IDiscMaster *pdm;
            IJolietDiscMaster *pjdm;
            hr = pcdb->_GetDiscMasters(&pdm, &pjdm);
            if (SUCCEEDED(hr))
            {
                IDiscRecorder *pdr;
                // dont call SetActiveDiscRecorder unless absolutely necessary -- it returns random errors
                // if there's UDF media.
                hr = pcdb->_FindAndSetDefaultRecorder(pdm, FALSE, &pdr);
                if (SUCCEEDED(hr))
                {
                    hr = pdr->OpenExclusive();
                    if (SUCCEEDED(hr))
                    {
                        // don't use the mountpoint layer to determine capabilities.
                        dwMediaCaps = HWDMC_CDROM;

                        long lMediaType, lMediaFlags;
                        hr = pdr->QueryMediaType(&lMediaType, &lMediaFlags);
                        if (SUCCEEDED(hr) && !lMediaType && !lMediaFlags)
                        {
                            hr = E_FAIL;
                        }
                        if (SUCCEEDED(hr))
                        {
                            if (lMediaFlags & MEDIA_WRITABLE)
                            {
                                dwMediaCaps |= HWDMC_CDRECORDABLE;
                            }
                            if (lMediaFlags & MEDIA_RW)
                            {
                                dwMediaCaps |= HWDMC_CDREWRITABLE;
                            }

                            hr = _GetDiscInfoUsingFilesystem(&cbTotal, &cbFree, &fUDF);

                            // also adjust the fUDF bit to include unusable media.
                            if (lMediaFlags & MEDIA_FORMAT_UNUSABLE_BY_IMAPI)
                            {
                                fUDF = TRUE;
                            }

                            if (SUCCEEDED(hr) && (dwMediaCaps & (HWDMC_CDRECORDABLE | HWDMC_CDREWRITABLE)) && !fUDF)
                            {
                                ULONGLONG cbFreeIMAPI;
                                hr = _GetDiscInfoUsingIMAPI(pjdm, pdr, &cbFreeIMAPI);
                                if (SUCCEEDED(hr))
                                {
                                    cbTotal += cbFreeIMAPI;
                                    cbFree += cbFreeIMAPI;
                                }
                            }
                        }
                        pdr->Close();
                    }

                    // pick up the write speed, it might have changed.  don't worry about
                    // failure since this is a bonus perk anyway.
                    DWORD dwMaxWrite;
                    TCHAR szDevicePath[MAX_PATH], szVolumeName[MAX_PATH];
                    if (SUCCEEDED(_GetDiscRecorderInfo(pdr, NULL, &dwMaxWrite, NULL)) &&
                        SUCCEEDED(_GetRecorderPath(pdr, szDevicePath, ARRAYSIZE(szDevicePath))) &&
                        SUCCEEDED(_GetVolumeNameForDevicePath(szDevicePath, szVolumeName, ARRAYSIZE(szVolumeName))))
                    {
                        // update max speed
                        _SetCachedDriveInfo(szVolumeName, DRIVE_USEEXISTING, 0, dwMaxWrite);
                    }
                    pdr->Release();
                }
                pdm->Release();
                pjdm->Release();
            }
            pcdb->Release();
        }

        if (SUCCEEDED(hr))
        {
            SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_PERMEDIA, REGVALUE_TOTALBYTES, REG_BINARY, &cbTotal, sizeof(cbTotal));
            SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_PERMEDIA, REGVALUE_FREEBYTES, REG_BINARY, &cbFree, sizeof(cbFree));
            SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_PERMEDIA, REGVALUE_MEDIATYPE, REG_DWORD, &dwMediaCaps, sizeof(dwMediaCaps));
            DWORD dw = fUDF;
            SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_PERMEDIA, REGVALUE_UDF, REG_DWORD, &dw, sizeof(dw));

            int iCurrent;
            if (SUCCEEDED(_GetCurrentDriveIndex(&iCurrent)))
            {
                TCHAR szRoot[4];
                TCHAR szVolName[MAX_PATH];
                if (PathBuildRoot(szRoot, iCurrent) &&
                    GetVolumeInformation(szRoot, szVolName, ARRAYSIZE(szVolName), NULL, NULL, NULL, NULL, 0))
                {
                    UINT cb = (lstrlen(szVolName) + 1) * sizeof(TCHAR);
                    SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_PERMEDIA, REGVALUE_DISCLABEL, REG_SZ, szVolName, cb);
                }
            }

            DWORD dwSet = 1;
            SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_PERMEDIA, REGVALUE_SET, REG_DWORD, &dwSet, sizeof(dwSet));

            LPITEMIDLIST pidl;
            if (SUCCEEDED(_GetFolderPidl(&pidl)))
            {
                SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_IDLIST, pidl, NULL);
                ILFree(pidl);
            }
            fDone = TRUE;
        }
        else if ((IMAPI_E_STASHINUSE == hr) ||         // IMAPI is being used by somebody else.
                 (IMAPI_E_DEVICE_NOTACCESSIBLE == hr)) // CD has not spun up.
        {
            // wait and try again.
            SHProcessMessagesUntilEvent(NULL, NULL, 5 * 1000); // 5 seconds
        }
        else
        {
            // there was some other error, bail out anyway.
            fDone = TRUE;
        }
    }

    return hr;
}

HRESULT CCDBurn::GetSpace(ULONGLONG *pcbTotal, ULONGLONG *pcbFree)
{
    HRESULT hr = E_FAIL;
    ULONGLONG cbTotal, cbFree;
    DWORD cbReg1 = sizeof(cbTotal), cbReg2 = sizeof(cbFree);
    if ((ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_PERMEDIA, REGVALUE_TOTALBYTES, NULL, &cbTotal, &cbReg1)) &&
        (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_PERMEDIA, REGVALUE_FREEBYTES, NULL, &cbFree, &cbReg2)))
    {
        if (pcbTotal)
            *pcbTotal = cbTotal;
        if (pcbFree)
            *pcbFree = cbFree;
        hr = S_OK;
    }
    return hr;
}

HRESULT CCDBurn::InitNew()
{
    IPropertyBag *ppb;
    // load up the default property bag for peruser perfolder
    // may have problems down the line with thumbs.db being alluser.
    HRESULT hr = _CreateDefaultPropBag(IID_PPV_ARG(IPropertyBag, &ppb));
    if (SUCCEEDED(hr))
    {
        IUnknown_Set((IUnknown**)&_ppb, ppb);
        ppb->Release();
    }
    return hr;
}

HRESULT CCDBurn::Load(IPropertyBag *ppb, IErrorLog *pErr)
{
    IUnknown_Set((IUnknown**)&_ppb, ppb);
    return S_OK;
}

STDAPI SHCreateQueryCancelAutoPlayMoniker(IMoniker** ppmoniker); // mtptarun2.cpp

void CCDBurn::_RegisterAutoplayCanceller()
{
    IMoniker *pmoniker;
    if (SUCCEEDED(SHCreateQueryCancelAutoPlayMoniker(&pmoniker)))
    {
        IRunningObjectTable *prot;
        if (SUCCEEDED(GetRunningObjectTable(0, &prot)))
        {
            IUnknown *punkThis;
            if (SUCCEEDED(QueryInterface(IID_PPV_ARG(IUnknown, &punkThis))))
            {
                prot->Register(ROTFLAGS_REGISTRATIONKEEPSALIVE, punkThis, pmoniker, &_dwROTRegister);
                punkThis->Release();
            }
            prot->Release();
        }
        pmoniker->Release();
    }
}

void CCDBurn::_UnregisterAutoplayCanceller()
{
    if (_dwROTRegister)
    {
        IRunningObjectTable *prot;
        if (SUCCEEDED(GetRunningObjectTable(0, &prot)))
        {
            prot->Revoke(_dwROTRegister);
            _dwROTRegister = 0;
            prot->Release();
        }
    }
}

HRESULT CCDBurn::_WizardThreadProc()
{
    HRESULT hr = E_FAIL;
    BOOL fWizardShown = FALSE;
    // the burningnow check does an additional call into IMAPI -- this may be slow so do it while
    // we're on the background thread instead of the duiview one.
    if (!_IsBurningNow())
    {
        if (_EnterExclusiveBurning())
        {
            _RegisterAutoplayCanceller();
            hr = _ShowWizard();

            if (SUCCEEDED(_GetBurnHR()) && SHPropertyBag_ReadBOOLDefRet(_ppb, PROPSTR_AUTOCLOSE, FALSE))
            {
                // if we auto-closed the wizard, leave this thread going for a few more seconds
                // to cancel any spurious autoplays that come in.
                SHProcessMessagesUntilEvent(NULL, NULL, 3 * 1000);
            }

            _UnregisterAutoplayCanceller();

            fWizardShown = TRUE;
            _LeaveExclusiveBurning();
        }
    }

    if (!fWizardShown && !SHPropertyBag_ReadBOOLDefRet(_ppb, PROPSTR_FAILSILENTLY, FALSE))
    {
        // put up UI so we dont silently fail.
        ShellMessageBox(HINST_THISDLL, NULL, MAKEINTRESOURCE(IDS_BURN_CANTBURN), MAKEINTRESOURCE(IDS_BURN),
                        MB_OK | MB_ICONEXCLAMATION);
    }

    return hr;
}

DWORD WINAPI CCDBurn::_WizardThreadWrapper(void *pv)
{
    CCDBurn *pcdb = (CCDBurn*)pv;
    pcdb->_WizardThreadProc();
    pcdb->Release();
    return 0;
}

HRESULT CCDBurn::_ShowWizardOnSeparateThread()
{
    HRESULT hr = S_OK;
    AddRef();
    if (!SHCreateThread(_WizardThreadWrapper, this, CTF_COINIT, NULL))
    {
        Release();
        hr = E_FAIL;
    }
    return hr;
}


// match this with below
#define INDEX_DLG_BURNWIZ_WELCOME        0
#define INDEX_DLG_BURNWIZ_EJECT          1
#define INDEX_DLG_BURNWIZ_BURN_PROGRESS  2
#define INDEX_DLG_BURNWIZ_BURN_SUCCESS   3
#define INDEX_DLG_BURNWIZ_BURN_FAILURE   4
#define INDEX_DLG_BURNWIZ_WAITFORMEDIA   5
#define INDEX_DLG_BURNWIZ_STARTERASE     6
#define INDEX_DLG_BURNWIZ_ERASE_PROGRESS 7
#define INDEX_DLG_BURNWIZ_ERASE_SUCCESS  8
#define INDEX_DLG_BURNWIZ_ERASE_FAILURE  9
#define INDEX_DLG_BURNWIZ_DISCFULL       10
#define INDEX_DLG_BURNWIZ_EARLYEXIT      11
#define INDEX_DLG_BURNWIZ_HDFULL         12
#define INDEX_DLG_BURNWIZ_NOFILES        13

const WIZPAGE c_wpPages[] =
{
    {DLG_BURNWIZ_WELCOME,        0,                               0,                              PSP_HIDEHEADER, CCDBurn::s_WelcomeDlgProc},
    {DLG_BURNWIZ_EJECT,          0,                               0,                              PSP_HIDEHEADER, CCDBurn::s_EjectDlgProc},
    {DLG_BURNWIZ_PROGRESS,       IDS_BURNWIZ_PROGRESS_BURN_HEAD,  IDS_BURNWIZ_PROGRESS_BURN_SUB,  0,              CCDBurn::s_ProgressDlgProc},
    {DLG_BURNWIZ_BURN_SUCCESS,   0,                               0,                              PSP_HIDEHEADER, CCDBurn::s_DoneDlgProc},
    {DLG_BURNWIZ_BURN_FAILURE,   0,                               0,                              PSP_HIDEHEADER, CCDBurn::s_DoneDlgProc},
    {DLG_BURNWIZ_WAITFORMEDIA,   IDS_BURNWIZ_WAIT_HEAD,           IDS_BURNWIZ_WAIT_SUB,           0,              CCDBurn::s_WaitForMediaDlgProc},
    {DLG_BURNWIZ_STARTERASE,     0,                               0,                              PSP_HIDEHEADER, CCDBurn::s_StartEraseDlgProc},
    {DLG_BURNWIZ_PROGRESS,       IDS_BURNWIZ_PROGRESS_ERASE_HEAD, IDS_BURNWIZ_PROGRESS_ERASE_SUB, 0,              CCDBurn::s_ProgressDlgProc},
    {DLG_BURNWIZ_ERASE_SUCCESS,  0,                               0,                              PSP_HIDEHEADER, CCDBurn::s_DoneDlgProc},
    {DLG_BURNWIZ_ERASE_FAILURE,  0,                               0,                              PSP_HIDEHEADER, CCDBurn::s_DoneDlgProc},
    {DLG_BURNWIZ_DISCFULL,       0,                               0,                              PSP_HIDEHEADER, CCDBurn::s_DiskFullDlgProc},
    {DLG_BURNWIZ_PROGRESS,       0,                               0,                              PSP_HIDEHEADER, CCDBurn::s_EarlyExitDlgProc},
    {DLG_BURNWIZ_HDFULL,         0,                               0,                              PSP_HIDEHEADER, CCDBurn::s_HDFullDlgProc},
    {DLG_BURNWIZ_NOFILES,        0,                               0,                              PSP_HIDEHEADER, CCDBurn::s_NoFilesDlgProc},
};

HPROPSHEETPAGE _CreatePropPageFromInfo(const WIZPAGE *pwp, LPARAM lParam)
{
    PROPSHEETPAGE psp = { 0 };
    psp.dwSize = sizeof(psp);
    psp.hInstance = HINST_THISDLL;
    psp.lParam = lParam;
    psp.dwFlags = PSP_USETITLE | PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE | pwp->dwFlags;
    psp.pszTemplate = MAKEINTRESOURCE(pwp->idPage);
    psp.pfnDlgProc = pwp->dlgproc;
    psp.pszTitle = MAKEINTRESOURCE(IDS_BURN_WIZTITLE);
    psp.pszHeaderTitle = MAKEINTRESOURCE(pwp->idHeading);
    psp.pszHeaderSubTitle = MAKEINTRESOURCE(pwp->idSubHeading);
    return CreatePropertySheetPage(&psp);
}

int ReleaseCallback(void *pv, void *)
{
    IWizardExtension *pwe = (IWizardExtension*)pv;
    IUnknown_SetSite(pwe, NULL);
    pwe->Release();
    return 1;
}

HRESULT CCDBurn::_ShowWizard()
{
    LinkWindow_RegisterClass();

    _fCancelled = FALSE;

    // create the page array

    int nStartPage;
    if (SHPropertyBag_ReadBOOLDefRet(_ppb, PROPSTR_EJECT, FALSE))
    {
        // we want the eject page
        nStartPage = INDEX_DLG_BURNWIZ_EJECT;
    }
    else
    {
        // normal entry point
        if (SHPropertyBag_ReadBOOLDefRet(_ppb, PROPSTR_ERASE, FALSE))
        {
            nStartPage = INDEX_DLG_BURNWIZ_STARTERASE;
        }
        else
        {
            nStartPage = _StagingAreaHasFiles() ? INDEX_DLG_BURNWIZ_WELCOME : INDEX_DLG_BURNWIZ_NOFILES;
        }
    }

    // wtf?  if i dont include a propsheet without PSP_HIDEHEADER the sizing gets messed up.
    for (int i = 0; i < ARRAYSIZE(c_wpPages); i++)
    {
        _rgWizPages[i] = _CreatePropPageFromInfo(&c_wpPages[i], (LPARAM)this);
    }

    UINT cTotalExtPages;
    HRESULT hr = _FillExtensionDPA(_rgWizPages + ARRAYSIZE(c_wpPages), ARRAYSIZE(_rgWizPages) - ARRAYSIZE(c_wpPages), &cTotalExtPages);
    if (SUCCEEDED(hr))
    {
        PROPSHEETHEADER psh = { 0 };
        psh.dwSize = sizeof(psh);
        psh.hInstance = HINST_THISDLL;
        psh.dwFlags = PSH_WIZARD | PSH_WIZARD97 | PSH_WATERMARK | PSH_STRETCHWATERMARK | PSH_HEADER | PSH_USEICONID;
        psh.pszbmHeader = MAKEINTRESOURCE(IDB_BURNWIZ_HEADER);
        psh.pszbmWatermark = MAKEINTRESOURCE(IDB_BURNWIZ_WATERMARK);
        psh.pszIcon = MAKEINTRESOURCE(IDI_DRIVECD);
        psh.phpage = _rgWizPages;
        psh.nPages = ARRAYSIZE(c_wpPages) + cTotalExtPages;
        psh.nStartPage = nStartPage;
        PropertySheet(&psh);
        
        HRESULT hrOp = E_FAIL;
        DWORD dwHR;
        if (SUCCEEDED(SHPropertyBag_ReadDWORD(_ppb, PROPSTR_HR, &dwHR)))
        {
            hrOp = dwHR;
        }

        hr = SUCCEEDED(hrOp) ? S_OK : S_FALSE;
    }

    if (_hdpaExts)
    {
        DPA_DestroyCallback(_hdpaExts, ReleaseCallback, 0);
    }

    s_hwndWiz = NULL;
    // the drive could have been locked after the wait for media page.
    _LockCurrentDrive(FALSE);

    return hr;
}

CCDBurn* CCDBurn::s_GetCDBurn(HWND hwnd, UINT uMsg, LPARAM lParam)
{
    if (uMsg == WM_INITDIALOG)
    {
        PROPSHEETPAGE *ppsp = (PROPSHEETPAGE*)lParam;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, ppsp->lParam);
        return (CCDBurn*)ppsp->lParam;
    }
    return (CCDBurn*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
}

HFONT GetIntroFont(HWND hwnd)
{
    static HFONT _hfontIntro = NULL;

    if (!_hfontIntro)
    {
        TCHAR szBuffer[64];
        NONCLIENTMETRICS ncm = { 0 };
        LOGFONT lf;

        ncm.cbSize = sizeof(ncm);
        SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

        lf = ncm.lfMessageFont;
        LoadString(g_hinst, IDS_BURNWIZ_TITLEFONTNAME, lf.lfFaceName, ARRAYSIZE(lf.lfFaceName));
        lf.lfWeight = FW_BOLD;

        LoadString(g_hinst, IDS_BURNWIZ_TITLEFONTSIZE, szBuffer, ARRAYSIZE(szBuffer));
        lf.lfHeight = 0 - (GetDeviceCaps(NULL, LOGPIXELSY) * StrToInt(szBuffer) / 72);

        _hfontIntro = CreateFontIndirect(&lf);
    }

    return _hfontIntro;
}

void CCDBurn::_SetNextPage(HWND hwnd, int iIndex)
{
    PropSheet_SetCurSel(GetParent(hwnd), _rgWizPages[iIndex], -1);
    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)-1);
}

void CCDBurn::_SetUpStartPage(HWND hwnd)
{
    TCHAR szDiscLabel[JOLIET_MAX_LABEL + 1];
    szDiscLabel[0] = 0;
    SHPropertyBag_ReadStr(_ppb, PROPSTR_DISCLABEL, szDiscLabel, ARRAYSIZE(szDiscLabel));
    SetDlgItemText(hwnd, IDC_BURNWIZ_DISCLABEL, szDiscLabel);
    Edit_LimitText(GetDlgItem(hwnd, IDC_BURNWIZ_DISCLABEL), JOLIET_MAX_LABEL);
    SHLimitInputEditChars(GetDlgItem(hwnd, IDC_BURNWIZ_DISCLABEL), NULL, INVALID_JOLIETNAME_CHARS);

    BOOL fClose = SHPropertyBag_ReadBOOLDefRet(_ppb, PROPSTR_AUTOCLOSE, FALSE);
    Button_SetCheck(GetDlgItem(hwnd, IDC_BURNWIZ_AUTOCLOSEWIZ), fClose ? BST_CHECKED : BST_UNCHECKED);
}

void CCDBurn::_LeaveStartPage(HWND hwnd)
{
    BOOL fClose = (IsDlgButtonChecked(hwnd, IDC_BURNWIZ_AUTOCLOSEWIZ) == BST_CHECKED);
    SHPropertyBag_WriteBOOL(_ppb, PROPSTR_AUTOCLOSE, fClose);
    DWORD dwClose = fClose;
    SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_AUTOCLOSE, REG_DWORD, &dwClose, sizeof(dwClose));
}

#define CDBURNWM_SHOWSHUTDOWNMESSAGE WM_APP

LRESULT CALLBACK CCDBurn::_WizSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uID, DWORD_PTR dwRefData)
{
    LRESULT lres;

    switch (uMsg)
    {
        case WM_NCDESTROY:
            // Clean up subclass
            RemoveWindowSubclass(hwnd, _WizSubclassProc, 0);
            lres = DefSubclassProc(hwnd, uMsg, wParam, lParam);
            break;

        case WM_QUERYENDSESSION:
            lres = TRUE;
            if (s_fDriveInUse)
            {
                // post so we return to user quickly
                PostMessage(hwnd, CDBURNWM_SHOWSHUTDOWNMESSAGE, 0, 0);
                // always bail if the drive is in use.
                lres = FALSE;
            }
            break;

        case CDBURNWM_SHOWSHUTDOWNMESSAGE:
            ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_BURN_CANTSHUTDOWN), MAKEINTRESOURCE(IDS_BURN),
                            MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND);
            lres = TRUE;
            break;

        default:
            lres = DefSubclassProc(hwnd, uMsg, wParam, lParam);
            break;
    }

    return lres;
}

void CCDBurn::_SetupFirstPage(HWND hwnd, BOOL fSubclass)
{
    s_hwndWiz = GetParent(hwnd);
    SendDlgItemMessage(hwnd, IDC_BURNWIZ_TITLE, WM_SETFONT, (WPARAM)GetIntroFont(hwnd), 0);
    if (fSubclass)
    {
        SetWindowSubclass(s_hwndWiz, _WizSubclassProc, 0, 0);
    }
}

INT_PTR CCDBurn::_WelcomeDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet = FALSE;
    switch (uMsg)
    {
        case WM_INITDIALOG:
            _SetupFirstPage(hwnd, TRUE);
            fRet = TRUE;
            break;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_NEXT);
                    _SetUpStartPage(hwnd);
                    fRet = TRUE;
                    break;

                case PSN_WIZNEXT:
                    TCHAR szDiscLabel[JOLIET_MAX_LABEL + 1];
                    szDiscLabel[0] = 0;
                    // GetDlgItemText helpfully returns 0 for error and 0 for the empty string, so dont use
                    // its return value.
                    GetDlgItemText(hwnd, IDC_BURNWIZ_DISCLABEL, szDiscLabel, ARRAYSIZE(szDiscLabel));
                    SHPropertyBag_WriteStr(_ppb, PROPSTR_DISCLABEL, szDiscLabel);
                    _SetNextPage(hwnd, INDEX_DLG_BURNWIZ_WAITFORMEDIA);
                    fRet = TRUE;
                    break;

                case PSN_KILLACTIVE:
                    _LeaveStartPage(hwnd);
                    break;
            }
            break;
        }
    }
    return fRet;
}

INT_PTR CCDBurn::_StartEraseDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet = FALSE;
    switch (uMsg)
    {
        case WM_INITDIALOG:
            _SetupFirstPage(hwnd, TRUE);
            fRet = TRUE;
            break;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_NEXT);
                    _SetUpStartPage(hwnd);
                    fRet = TRUE;
                    break;

                case PSN_WIZNEXT:
                    // the erase progress page will almost immediately lock the drive -- this call is for
                    // consistency and to set the state variable used in shutdown prevention.
                    _LockCurrentDrive(TRUE);
                    _SetNextPage(hwnd, INDEX_DLG_BURNWIZ_ERASE_PROGRESS);
                    fRet = TRUE;
                    break;

                case PSN_KILLACTIVE:
                    _LeaveStartPage(hwnd);
                    break;
            }
            break;
        }
    }
    return fRet;
}

INT_PTR CCDBurn::_EjectDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet = FALSE;
    switch (uMsg)
    {
        case WM_INITDIALOG:
            _SetupFirstPage(hwnd, TRUE);
            fRet = TRUE;
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDC_BURNWIZ_BURNDATA:
                case IDC_BURNWIZ_CLEAR:
                case IDC_BURNWIZ_EJECT:
                    if (IsDlgButtonChecked(hwnd, IDC_BURNWIZ_BURNDATA) == BST_CHECKED)
                    {
                        PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_NEXT);
                    }
                    else
                    {
                        PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_FINISH);
                    }
                    break;
            }
            break;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_NEXT);
                    _SetUpStartPage(hwnd);
                    Button_SetCheck(GetDlgItem(hwnd, IDC_BURNWIZ_BURNDATA), BST_CHECKED);
                    fRet = TRUE;
                    break;

                case PSN_WIZNEXT:
                {
                    TCHAR szDiscLabel[JOLIET_MAX_LABEL + 1];
                    if (GetDlgItemText(hwnd, IDC_BURNWIZ_DISCLABEL, szDiscLabel, ARRAYSIZE(szDiscLabel)))
                    {
                        SHPropertyBag_WriteStr(_ppb, PROPSTR_DISCLABEL, szDiscLabel);
                    }
                    _SetNextPage(hwnd, INDEX_DLG_BURNWIZ_WAITFORMEDIA);
                    fRet = TRUE;
                    break;
                }

                case PSN_WIZFINISH:
                    if (IsDlgButtonChecked(hwnd, IDC_BURNWIZ_CLEAR) == BST_CHECKED)
                    {
                        CMINVOKECOMMANDINFO cmi = {0};
                        cmi.fMask = CMIC_MASK_FLAG_NO_UI;
                        _CleanUp(&cmi, TRUE);
                    }
                    fRet = TRUE;
                    break;

                case PSN_KILLACTIVE:
                    _LeaveStartPage(hwnd);
                    break;
            }
            break;
        }
    }
    return fRet;
}

void CCDBurn::_InitTimeStats(BOOL fErase)
{
    ZeroMemory(&_ts, sizeof(_ts));

    DWORD cb;
    if (fErase)
    {
        DWORD dwEraseTime;
        cb = sizeof(dwEraseTime);
        if (ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_ERASETIME, NULL, &dwEraseTime, &cb))
        {
            // default to 3 minutes or so.
            dwEraseTime = 180;
        }
        _ts.dwSecErase = dwEraseTime / _dwCurSpeed;
        _ts.dwSecTotal = _ts.dwSecErase;
    }
    else
    {
        _fRecording = FALSE;

        ULONGLONG ullStageRate;
        cb = sizeof(ullStageRate);
        if ((ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_STAGERATE, NULL, &ullStageRate, &cb)) ||
            (0 == ullStageRate))
        {
            // default to staging approx. 2MB/s.
            ullStageRate = 2000000;
        }
        _ts.dwSecStaging = (DWORD) (_cbStagedSize / ullStageRate);

        ULONGLONG ullBurnRate;
        cb = sizeof(ullBurnRate);
        if ((ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_BURNRATE, NULL, &ullBurnRate, &cb)) ||
            (0 == ullBurnRate))
        {
            // default, single speed.
            ullBurnRate = 150000;
        }
        _ts.dwSecBurn = (DWORD) (_cbStagedSize / (ullBurnRate * _dwCurSpeed));

        DWORD dwCloseFactor;
        cb = sizeof(dwCloseFactor);
        if (ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_CLOSEFACTOR, NULL, &dwCloseFactor, &cb))
        {
            // default to ~2 min, single speed.
            dwCloseFactor = 120;
        }
        _ts.dwSecClose = dwCloseFactor / _dwCurSpeed;

        _ts.dwSecTotal = _ts.dwSecStaging + _ts.dwSecBurn + _ts.dwSecClose;
    }
    if (0 == _ts.dwSecTotal)
        _ts.dwSecTotal = 1;
    _dwLastTime = 0;
    _SetEstimatedTime(_ts.dwSecTotal);
}

void CCDBurn::_SaveTimeStats(BOOL fErase)
{
    if (fErase)
    {
        // if we didnt fill in one of our timing fields, IMAPI called us wrong and we throw out all our data.
        if (_ts.dwTickEraseStart && _ts.dwTickEraseEnd)
        {
            DWORD dwEraseTime = (_ts.dwTickEraseEnd - _ts.dwTickEraseStart) / 1000 * _dwCurSpeed;
            SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_ERASETIME, REG_DWORD, &dwEraseTime, sizeof(dwEraseTime));
        }
    }
    else
    {
        // if we didnt fill in one of our timing fields, IMAPI called us wrong and we throw out all our data.
        if (_ts.dwTickStagingStart && _ts.dwTickStagingEnd &&
            _ts.dwTickBurnStart && _ts.dwTickBurnEnd &&
            _ts.dwTickCloseStart && _ts.dwTickCloseEnd)
        {
            // only tally results from burns of more than 1MB (arbitrary, but good enough).
            // 1MB is about 8s on a 1x drive and 1s on an 8x drive.
            // the main danger is people burning a few text files that total 1k, then the burn phase takes 1 second
            // (rather, the time between our IMAPI notifications is 1s) and we get stuck with some measly transfer rate
            // that doesnt make any sense and makes the next burn's estimated time up in the gazillions of minutes.
            if (_cbStagedSize > 1000000)
            {
                ULONGLONG ullStageRate = _cbStagedSize * 1000 / (_ts.dwTickStagingEnd - _ts.dwTickStagingStart);
                SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_STAGERATE, REG_BINARY, &ullStageRate, sizeof(ullStageRate));

                ULONGLONG ullBurnRate = _cbStagedSize * 1000 / (_ts.dwTickBurnEnd - _ts.dwTickBurnStart) / _dwCurSpeed;
                SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_BURNRATE, REG_BINARY, &ullBurnRate, sizeof(ullBurnRate));
            }

            DWORD dwCloseFactor = (_ts.dwTickCloseEnd - _ts.dwTickCloseStart) / 1000 * _dwCurSpeed;
            SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_CLOSEFACTOR, REG_DWORD, &dwCloseFactor, sizeof(dwCloseFactor));
        }
    }
}

void CCDBurn::_ConstructTimeString(DWORD dwEstTime, LPTSTR psz, UINT cch)
{
    TCHAR szBuf[100];
    if (dwEstTime >= 60)
    {
        LoadString(HINST_THISDLL, IDS_TIMEEST_MINUTES2, szBuf, ARRAYSIZE(szBuf));
        wnsprintf(psz, cch, szBuf, dwEstTime / 60 + 1);
    }
    else
    {
        LoadString(HINST_THISDLL, IDS_TIMEEST_SECONDS2, szBuf, ARRAYSIZE(szBuf));
        wnsprintf(psz, cch, szBuf, (dwEstTime / 5 + 1) * 5); // round off to 5sec increments
    }
}

void CCDBurn::_SetEstimatedTime(DWORD dwSeconds)
{
    _ts.dwSecRemaining = dwSeconds;
    _dwTimeSet = GetTickCount();
}

void CCDBurn::_DisplayEstimatedTime(HWND hwnd)
{
    if (_ts.dwSecRemaining)
    {
        // we know when we last made an estimate, so show time based on that.
        // however, our estimate could have easily been wrong, so skew it so it never quite reaches 0,
        // and instead sit at a few seconds remaining (hopefully for not too long).

        DWORD dwElapsedTime = (GetTickCount() - _dwTimeSet) / 1000;
        DWORD dwEstTime = 0;
        if (_ts.dwSecRemaining > dwElapsedTime + 5)
        {
            dwEstTime = _ts.dwSecRemaining - dwElapsedTime;
        }

        if (!_dwLastTime || (dwEstTime < _dwLastTime))
        {
            TCHAR szTime[100];
            _ConstructTimeString(dwEstTime, szTime, ARRAYSIZE(szTime));
            SetDlgItemText(hwnd, IDC_BURNWIZ_ESTTIME, szTime);

            SendMessage(GetDlgItem(_hwndWizardPage, IDC_BURNWIZ_PROGRESS), PBM_SETPOS, (WPARAM) (PROGRESS_INCREMENTS * (_ts.dwSecTotal - dwEstTime) / _ts.dwSecTotal), 0);
            _dwLastTime = dwEstTime;
        }
    }
}

void CCDBurn::_InitProgressPage(HWND hwnd)
{
    SendMessage(GetDlgItem(hwnd, IDC_BURNWIZ_PROGRESS), PBM_SETRANGE, (WPARAM)0, MAKELPARAM(0, PROGRESS_INCREMENTS));
    SendMessage(GetDlgItem(hwnd, IDC_BURNWIZ_PROGRESS), PBM_SETPOS, (WPARAM)0, 0);
    SetDlgItemText(hwnd, IDC_BURNWIZ_ESTTIME, L"");
    SetDlgItemText(hwnd, IDC_BURNWIZ_STATUSTEXT, L"");
}

#define IDT_SHOWTIME 1

INT_PTR CCDBurn::_ProgressDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet = FALSE;
    switch (uMsg)
    {
        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                    _InitProgressPage(hwnd);
                    _hwndWizardPage = hwnd;
                    PropSheet_SetWizButtons(pnmh->hwndFrom, 0);

                    // start up a timer to periodically refresh the time remaining
                    _ts.dwSecRemaining = 0;
                    SetTimer(hwnd, IDT_SHOWTIME, 1000, NULL);

                    AddRef();
                    if (!SHCreateThread(SHPropertyBag_ReadBOOLDefRet(_ppb, PROPSTR_ERASE, FALSE) ? _EraseThread : _BurnThread,
                                        this, CTF_COINIT, NULL))
                    {
                        Release();
                    }
                    fRet = TRUE;
                    break;

                case PSN_QUERYCANCEL:
                    if (IDYES == ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_BURN_CONFIRM_CANCEL), MAKEINTRESOURCE(IDS_BURN),
                                                 MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2))
                    {
                        _fCancelled = TRUE;
                    }
                    else
                    {
                        // TRUE means don't cancel
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, TRUE);
                        fRet = TRUE;
                    }
                    break;

                case PSN_WIZNEXT:
                    _PostOperation();
                    fRet = TRUE;
                    break;

                case PSN_KILLACTIVE:
                    KillTimer(hwnd, IDT_SHOWTIME);
                    break;
            }
            break;
        }

        case WM_TIMER:
            switch (wParam)
            {
                case IDT_SHOWTIME:
                    _DisplayEstimatedTime(hwnd);
                    break;
            }
            break;
    }
    return fRet;
}

void CCDBurn::_DisplayMediaErrorOnNext(HWND hwnd, UINT idMsg, UINT idMsgInsert)
{
    WCHAR sz[100];
    LoadString(HINST_THISDLL, idMsg, sz, ARRAYSIZE(sz));
    SetDlgItemText(hwnd, IDC_BURNWIZ_STATUSTEXT, sz);

    int iIndex;
    if (SUCCEEDED(_GetCurrentDriveIndex(&iIndex)) && PathBuildRoot(sz, iIndex))
    {
        LPWSTR pszInsertDisc = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(idMsgInsert), sz);
        if (pszInsertDisc)
        {
            SetDlgItemText(hwnd, IDC_BURNWIZ_PLEASEINSERT, pszInsertDisc);
            LocalFree(pszInsertDisc);
        }
    }

    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, -1);
}

// to make the wizard happy, we load all of the extensions' pages at the beginning.
// however, not all will be used, since some behavior is dependent on the media that's
// inserted -- which can only be known AFTER _WaitForMediaDlgProc.
void CCDBurn::_PruneExts()
{
    IDataObject *pdo;
    if (SUCCEEDED(_CreateDataObject(&pdo)))
    {
        int i = DPA_GetPtrCount(_hdpaExts);
        // count down and remove from the end of the DPA.
        while (i--)
        {
            BOOL fKeep = FALSE;

            IWizardExtension *pwe = (IWizardExtension*)DPA_GetPtr(_hdpaExts, i);
            ASSERT(pwe);
            IDropTarget *pdt;
            if (SUCCEEDED(pwe->QueryInterface(IID_PPV_ARG(IDropTarget, &pdt))))
            {
                DWORD dwEffect;
                POINTL pt = { 0 };
                if (SUCCEEDED(pdt->DragEnter(pdo, 0, pt, &dwEffect)))
                {
                    if (DROPEFFECT_NONE != dwEffect)
                    {
                        fKeep = TRUE;
                    }
                    pdt->DragLeave();
                }
                pdt->Release();
            }

            if (!fKeep)
            {
                DPA_DeletePtr(_hdpaExts, i);
                IUnknown_SetSite(pwe, NULL);
                pwe->Release();
            }
        }
        pdo->Release();
    }
}

// timer for our retries
#define IDT_CLICKNEXT 1

INT_PTR CCDBurn::_WaitForMediaDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet = FALSE;
    switch (uMsg)
    {
        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                    {
                        PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_BACK | PSWIZB_NEXT);

                        // kick off a trial to see if media is here already
                        PropSheet_PressButton(GetParent(hwnd), PSBTN_NEXT);

                        // start up a timer too -- we could also register the window for notification
                        // but this is a cheap operation and its less code
                        SetTimer(hwnd, IDT_CLICKNEXT, 250, NULL);
                        fRet = TRUE;
                    }
                    break;

                case PSN_WIZBACK:
                    _SetNextPage(hwnd, SHPropertyBag_ReadBOOLDefRet(_ppb, PROPSTR_EJECT, FALSE) ? INDEX_DLG_BURNWIZ_EJECT : INDEX_DLG_BURNWIZ_WELCOME);
                    fRet = TRUE;
                    break;

                case PSN_WIZNEXT:
                {
                    // used to check if our media-insert thread is done with using IMAPI.
                    DWORD dwDummy, cb = sizeof(dwDummy);
                    if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_PERMEDIA, REGVALUE_SET, NULL, &dwDummy, &cb))
                    {
                        DWORD dwCaps;
                        BOOL fUDF;
                        if (SUCCEEDED(_GetMediaCapabilities(&dwCaps, &fUDF)) && (dwCaps & HWDMC_CDRECORDABLE) && !fUDF)
                        {
                            _LockCurrentDrive(TRUE);
                            _PruneExts();
                            SHPropertyBag_WriteDWORD(_ppb, PROPSTR_CURRENTEXT, 1);
                            _SetExtPageFromPropBag(hwnd, TRUE);
                        }
                        else
                        {
                            _DisplayMediaErrorOnNext(hwnd, IDS_BURN_FAILURE_MEDIUM_INVALIDTYPE, IDS_BURN_INSERTDISCFULL);
                        }
                    }
                    else
                    {
                        _DisplayMediaErrorOnNext(hwnd, IDS_BURN_FAILURE_MEDIUM_NOTPRESENT, IDS_BURN_INSERTDISC);
                    }
                    fRet = TRUE;
                    break;
                }

                case PSN_KILLACTIVE:
                    KillTimer(hwnd, IDT_CLICKNEXT);
                    break;
            }
            break;
        }

        case WM_TIMER:
            switch (wParam)
            {
                case IDT_CLICKNEXT:
                    PropSheet_PressButton(GetParent(hwnd), PSBTN_NEXT);
                    break;
            }
            break;
    }
    return fRet;
}

HRESULT CCDBurn::_PostOperation()
{
    HRESULT hrOp = E_FAIL;
    DWORD dwHR;
    if (SUCCEEDED(SHPropertyBag_ReadDWORD(_ppb, PROPSTR_HR, &dwHR)))
    {
        hrOp = dwHR;
    }

    if (SHPropertyBag_ReadBOOLDefRet(_ppb, PROPSTR_ERASE, FALSE))
    {
        _SetNextPage(_hwndWizardPage, SUCCEEDED(hrOp) ? INDEX_DLG_BURNWIZ_ERASE_SUCCESS : INDEX_DLG_BURNWIZ_ERASE_FAILURE);
    }
    else
    {
        switch (hrOp)
        {
            case IMAPI_E_DISCFULL:
            {
                TCHAR szDiscFull[200];
                LoadString(HINST_THISDLL, IDS_BURN_DISCFULL, szDiscFull, ARRAYSIZE(szDiscFull));
                SHPropertyBag_WriteStr(_ppb, PROPSTR_DISCFULLTEXT, szDiscFull);
                _SetNextPage(_hwndWizardPage, INDEX_DLG_BURNWIZ_DISCFULL);
                break;
            }

            case IMAPI_E_NOTENOUGHDISKFORSTASH:
                _SetNextPage(_hwndWizardPage, INDEX_DLG_BURNWIZ_HDFULL);
                break;

            case HRESULT_FROM_WIN32(ERROR_DISK_FULL):
                // diskfulltext has already been set by _CheckTotal.
                _SetNextPage(_hwndWizardPage, INDEX_DLG_BURNWIZ_DISCFULL);
                break;

            case IMAPI_E_LOSS_OF_STREAMING:
            {
                // slow down the speed by one step
                TCHAR szVolume[MAX_PATH];
                if (SUCCEEDED(_GetCurrentBurnVolumeName(szVolume, ARRAYSIZE(szVolume))))
                {
                    DWORD dwCurSpeed, dwMaxSpeed;
                    if (SUCCEEDED(_GetCachedDriveInfo(szVolume, NULL, &dwCurSpeed, &dwMaxSpeed)))
                    {
                        if (WRITESPEED_FASTEST == dwCurSpeed)
                        {
                            // if we're set at the fastest speed, tone down to dwMaxSpeed
                            dwCurSpeed = dwMaxSpeed;
                        }

                        DWORD dwNewSpeed = 1;
                        // find the highest power of 2 smaller than dwSpeed
                        while (dwNewSpeed * 2 < dwCurSpeed)
                        {
                            dwNewSpeed *= 2;
                        }
                        _SetCachedDriveInfo(szVolume, DRIVE_USEEXISTING, dwNewSpeed, 0);
                    }
                }
                _SetNextPage(_hwndWizardPage, INDEX_DLG_BURNWIZ_BURN_FAILURE);
                break;
            }

            case IMAPI_E_CANNOT_WRITE_TO_MEDIA:
            {
                WCHAR szText[300];
                LoadString(HINST_THISDLL, IDS_BURN_CANTWRITETOMEDIA, szText, ARRAYSIZE(szText));
                SHPropertyBag_WriteStr(_ppb, PROPSTR_STATUSTEXT, szText);
                _SetNextPage(_hwndWizardPage, INDEX_DLG_BURNWIZ_BURN_FAILURE);
            }

            default:
                _SetNextPage(_hwndWizardPage, SUCCEEDED(hrOp) ? INDEX_DLG_BURNWIZ_BURN_SUCCESS : INDEX_DLG_BURNWIZ_BURN_FAILURE);
                break;
        }
    }

    return S_OK;
}

HRESULT CCDBurn::_GetBurnHR()
{
    HRESULT hrBurn = E_FAIL;
    DWORD dwHR;
    if (SUCCEEDED(SHPropertyBag_ReadDWORD(_ppb, PROPSTR_HR, &dwHR)))
    {
        hrBurn = dwHR;
    }
    return hrBurn;
}

void CCDBurn::_ShowRoxio()
{
    SHELLEXECUTEINFO sei = {0};
    sei.cbSize = sizeof(sei);
    sei.lpFile = L"http://go.microsoft.com/fwlink/?LinkId=932"; // http://www.roxio.com/
    ShellExecuteEx(&sei);
}

INT_PTR CCDBurn::_DoneDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet = FALSE;
    switch (uMsg)
    {
        case WM_INITDIALOG:
            SendDlgItemMessage(hwnd, IDC_BURNWIZ_TITLE, WM_SETFONT, (WPARAM)GetIntroFont(hwnd), 0);
            fRet = TRUE;
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDC_BURNWIZ_BURNAGAIN:
                case IDC_BURNWIZ_CLEAR:
                case IDC_BURNWIZ_EXIT:
                    if (IsDlgButtonChecked(hwnd, IDC_BURNWIZ_BURNAGAIN) == BST_CHECKED)
                    {
                        PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_NEXT);
                    }
                    else
                    {
                        PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_FINISH);
                    }
                    break;
            }
            break;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                    EnableWindow(GetDlgItem(GetParent(hwnd), IDCANCEL), FALSE);
                    Button_SetCheck(GetDlgItem(hwnd, IDC_BURNWIZ_BURNAGAIN), BST_UNCHECKED);
                    PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_FINISH);

                    WCHAR szStatus[300];
                    if (SUCCEEDED(SHPropertyBag_ReadStr(_ppb, PROPSTR_STATUSTEXT, szStatus, ARRAYSIZE(szStatus))))
                    {
                        SetDlgItemText(hwnd, IDC_BURNWIZ_STATUSTEXT, szStatus);
                    }

                    if (SUCCEEDED(_GetBurnHR()))
                    {
                        if (SHPropertyBag_ReadBOOLDefRet(_ppb, PROPSTR_AUTOCLOSE, FALSE))
                        {
                            PropSheet_PressButton(GetParent(hwnd), PSBTN_FINISH);
                        }
                    }
                    else
                    {
                        Button_SetCheck(GetDlgItem(hwnd, IDC_BURNWIZ_BURNAGAIN), BST_UNCHECKED);
                        Button_SetCheck(GetDlgItem(hwnd, IDC_BURNWIZ_CLEAR), BST_UNCHECKED);
                        Button_SetCheck(GetDlgItem(hwnd, IDC_BURNWIZ_EXIT), BST_CHECKED);

                        if (IMAPI_E_LOSS_OF_STREAMING != _GetBurnHR())
                        {
                            ShowWindow(GetDlgItem(hwnd, IDC_BURNWIZ_LOWERED), FALSE);
                        }
                    }
                    fRet = TRUE;
                    break;

                case PSN_WIZNEXT:
                {
                    // dump stored info since we're ejecting
                    _DumpDiscInfo();
                    // eject media
                    int iCurrent;
                    if (SUCCEEDED(CCDBurn::_GetCurrentDriveIndex(&iCurrent)))
                    {
                        CMountPoint *pmtpt = CMountPoint::GetMountPoint(iCurrent);
                        if (pmtpt)
                        {
                            pmtpt->Eject(hwnd);
                            pmtpt->Release();
                        }
                    }
                    // go back to the beginning
                    EnableWindow(GetDlgItem(GetParent(hwnd), IDCANCEL), TRUE);
                    _SetNextPage(hwnd, INDEX_DLG_BURNWIZ_WAITFORMEDIA);
                    fRet = TRUE;
                    break;
                }

                case PSN_WIZFINISH:
                    if (!SHPropertyBag_ReadBOOLDefRet(_ppb, PROPSTR_ERASE, FALSE))
                    {
                        if (SUCCEEDED(_GetBurnHR()) ||
                            (pnmh->code == PSN_WIZFINISH) && (IsDlgButtonChecked(hwnd, IDC_BURNWIZ_CLEAR) == BST_CHECKED))
                        {
                            // clean up staging area, the files are already on the cd.
                            CMINVOKECOMMANDINFO cmi = {0};
                            cmi.fMask = CMIC_MASK_FLAG_NO_UI;
                            _CleanUp(&cmi, FAILED(_GetBurnHR()));
                        }
                    }
                    fRet = TRUE;
                    break;

                case NM_CLICK:
                case NM_RETURN:
                    switch (pnmh->idFrom)
                    {
                    case IDC_BURNWIZ_LOWERED:
                        {
                            SHELLEXECUTEINFO sei = {0};
                            sei.cbSize = sizeof(sei);
                            sei.lpFile = L"hcp://services/subsite?node=TopLevelBucket_4/Hardware&topic=MS-ITS%3A%25HELP_LOCATION%25%5Ccdmedia.chm%3A%3A/cdmedia_fail2_moreinfo_buffer_underrun.htm&select=TopLevelBucket_4/Hardware/CDs_and_other_storage_devices";
                            ShellExecuteEx(&sei);
                            fRet = TRUE;
                        }
                        break;

                    case IDC_BURNWIZ_ATTRIB:
                        _ShowRoxio();
                        fRet = TRUE;
                        break;
                    }
                    break;
            }
            break;
        }
    }
    return fRet;
}

INT_PTR CCDBurn::_DiskFullDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet = FALSE;
    switch (uMsg)
    {
        case WM_INITDIALOG:
            SendDlgItemMessage(hwnd, IDC_BURNWIZ_TITLE, WM_SETFONT, (WPARAM)GetIntroFont(hwnd), 0);
            fRet = TRUE;
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDC_BURNWIZ_BURNAGAIN:
                case IDC_BURNWIZ_EXIT:
                    if (IsDlgButtonChecked(hwnd, IDC_BURNWIZ_BURNAGAIN) == BST_CHECKED)
                    {
                        PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_NEXT);
                    }
                    else
                    {
                        PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_FINISH);
                    }
                    break;
            }
            break;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                {
                    EnableWindow(GetDlgItem(GetParent(hwnd), IDCANCEL), FALSE);
                    PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_FINISH);
                    Button_SetCheck(GetDlgItem(hwnd, IDC_BURNWIZ_BURNAGAIN), BST_UNCHECKED);
                    Button_SetCheck(GetDlgItem(hwnd, IDC_BURNWIZ_EXIT), BST_CHECKED);

                    TCHAR szText[200];
                    if (SUCCEEDED(SHPropertyBag_ReadStr(_ppb, PROPSTR_DISCFULLTEXT, szText, ARRAYSIZE(szText))))
                    {
                        SetDlgItemText(hwnd, IDC_BURNWIZ_STATUSTEXT, szText);
                    }
                    fRet = TRUE;
                    break;
                }

                case PSN_WIZNEXT:
                    EnableWindow(GetDlgItem(GetParent(hwnd), IDCANCEL), TRUE);
                    _SetNextPage(hwnd, INDEX_DLG_BURNWIZ_WAITFORMEDIA);
                    fRet = TRUE;
                    break;

                case NM_CLICK:
                case NM_RETURN:
                    if (IDC_BURNWIZ_ATTRIB == pnmh->idFrom)
                    {
                        _ShowRoxio();
                        fRet = TRUE;
                    }
                    break;
            }
            break;
        }
    }
    return fRet;
}

// a stub page just to bail on the wizard when an extension says "dont run any more".
INT_PTR CCDBurn::_EarlyExitDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet = FALSE;
    switch (uMsg)
    {
        case WM_INITDIALOG:
            PropSheet_PressButton(GetParent(hwnd), PSBTN_CANCEL);
            fRet = TRUE;
            break;
    }
    return fRet;
}

void CCDBurn::_HDFullSetText(HWND hwnd)
{
    TCHAR szStashDrive[4];
    if (SUCCEEDED(_GetCurrentStashDrive(szStashDrive, ARRAYSIZE(szStashDrive))))
    {
        LPTSTR pszMessage1 = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_BURN_HDFULL1), szStashDrive);
        if (pszMessage1)
        {
            SetDlgItemText(hwnd, IDC_BURNWIZ_STATUSTEXT, pszMessage1);
            LocalFree(pszMessage1);
        }

        // 50 MB overhead fudge factor.  this is the best estimate we have.
        ULONGLONG cbStash = _cbStagedSize + 50 * 1024 * 1024;

        ULARGE_INTEGER ulFree;
        if (SHGetDiskFreeSpaceEx(szStashDrive, &ulFree, NULL, NULL) &&
            (ulFree.QuadPart < cbStash))
        {
            TCHAR szNeed[40], szToDelete[40];
            StrFormatByteSize64(cbStash, szNeed, ARRAYSIZE(szNeed));
            StrFormatByteSize64(cbStash - ulFree.QuadPart, szToDelete, ARRAYSIZE(szToDelete));

            LPTSTR pszMessage2 = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_BURN_HDFULL2), szNeed, szStashDrive, szToDelete);
            if (pszMessage2)
            {
                SetDlgItemText(hwnd, IDC_BURNWIZ_STATUSTEXT2, pszMessage2);
                LocalFree(pszMessage2);
            }
        }
    }
}

INT_PTR CCDBurn::_HDFullDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet = FALSE;
    switch (uMsg)
    {
        case WM_INITDIALOG:
            SendDlgItemMessage(hwnd, IDC_BURNWIZ_TITLE, WM_SETFONT, (WPARAM)GetIntroFont(hwnd), 0);
            fRet = TRUE;
            break;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                {
                    EnableWindow(GetDlgItem(GetParent(hwnd), IDCANCEL), FALSE);
                    PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_FINISH);
                    Button_SetCheck(GetDlgItem(hwnd, IDC_BURNWIZ_CLEAR), BST_UNCHECKED);
                    Button_SetCheck(GetDlgItem(hwnd, IDC_BURNWIZ_EXIT), BST_CHECKED);

                    _HDFullSetText(hwnd);

                    fRet = TRUE;
                    break;
                }

                case PSN_WIZFINISH:
                    if (IsDlgButtonChecked(hwnd, IDC_BURNWIZ_CLEAR) == BST_CHECKED)
                    {
                        TCHAR szStash[4];
                        if (SUCCEEDED(_GetCurrentStashDrive(szStash, ARRAYSIZE(szStash))))
                        {
                            LaunchDiskCleanup(NULL, DRIVEID(szStash), DISKCLEANUP_NOFLAG);
                        }
                    }
                    fRet = TRUE;
                    break;

                case NM_CLICK:
                case NM_RETURN:
                    switch (pnmh->idFrom)
                    {
                    case IDC_BURNWIZ_STATUSTEXT:
                        {
                            SHELLEXECUTEINFO sei = {0};
                            sei.cbSize = sizeof(sei);
                            sei.lpFile = L"hcp://services/subsite?node=TopLevelBucket_4/Hardware&topic=MS-ITS%3A%25HELP_LOCATION%25%5Ccdmedia.chm%3A%3A/cdmedia_fail3_moreinfo_disk_full.htm&select=TopLevelBucket_4/Hardware/CDs_and_other_storage_devices";
                            ShellExecuteEx(&sei);
                            fRet = TRUE;
                        }
                        break;

                    case IDC_BURNWIZ_ATTRIB:
                        _ShowRoxio();
                        fRet = TRUE;
                        break;
                    }
                    break;
            }
            break;
        }
    }
    return fRet;
}

INT_PTR CCDBurn::_NoFilesDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet = FALSE;
    switch (uMsg)
    {
        case WM_INITDIALOG:
            _SetupFirstPage(hwnd, FALSE);
            fRet = TRUE;
            break;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                {
                    EnableWindow(GetDlgItem(GetParent(hwnd), IDCANCEL), FALSE);
                    PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_FINISH);
                    fRet = TRUE;
                    break;
                }

                case PSN_WIZFINISH:
                    fRet = TRUE;
                    break;
            }
            break;
        }
    }
    return fRet;
}

HRESULT CCDBurn::DriveMatches(int iDrive)
{
    HRESULT hr = E_FAIL;

    // check if the drive index matches what we stored off last time.
    // this lets us keep parsing the drive correctly if its been recently unmounted.
    DWORD dwDrive, cb = sizeof(dwDrive);
    if ((ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_CDBURNING, REGVALUE_CACHEDINDEX, NULL, &dwDrive, &cb)) &&
        (iDrive == dwDrive))
    {
        hr = S_OK;
    }
    return hr;
}

HRESULT CCDBurn::_GetPlainCDPidl(LPITEMIDLIST *ppidl)
{
    *ppidl = NULL;
    HRESULT hr = E_FAIL;

    WCHAR szDrive[4];
    int iCurrent;
    if (SUCCEEDED(_GetCurrentDriveIndex(&iCurrent)) &&
        PathBuildRoot(szDrive, iCurrent))
    {
        hr = ILCreateFromPathEx(szDrive, NULL, ILCFP_FLAG_SKIPJUNCTIONS, ppidl, NULL);
    }
    return hr;
}

HRESULT CCDBurn::Bind(LPCITEMIDLIST pidl, IBindCtx *pbc, REFIID riid, void **ppv)
{
    IShellFolder *psfStg;
    HRESULT hr = _GetStagingFolder(pidl, IID_PPV_ARG(IShellFolder, &psfStg));
    if (SUCCEEDED(hr))
    {
        IAugmentedShellFolder *pasf;
        hr = SHCoCreateInstance(NULL, &CLSID_CDBurnFolder, NULL, IID_PPV_ARG(IAugmentedShellFolder, &pasf));
        if (SUCCEEDED(hr))
        {
            // initialize with its point in the shell namespace
            // NOTE: worry about IPersistFolder3?

            IPersistFolder *ppf;
            hr = pasf->QueryInterface(IID_PPV_ARG(IPersistFolder, &ppf));
            if (SUCCEEDED(hr))
            {
                hr = ppf->Initialize(pidl);
                ppf->Release();
            }

            if (SUCCEEDED(hr))
            {
                IBindCtx *pbcNoForce;
                if (pbc)
                {
                    // tack on to existing bind context if available
                    pbcNoForce = pbc;
                    pbc->AddRef();
                }
                else
                {
                    // otherwise make a new one
                    hr = CreateBindCtx(0, &pbcNoForce);
                }

                if (SUCCEEDED(hr))
                {
                    // this is the drive shellfolder for cd burning --
                    // in this case we want to ensure that new files specified by comdlg are created
                    // in the staging area, so we tell the drive shellfolder that it can't
                    // succeed on parsedisplayname if the file doesnt exist.
                    hr = pbcNoForce->RegisterObjectParam(STR_DONT_FORCE_CREATE, psfStg); // just need a non-null object to register
                    if (SUCCEEDED(hr))
                    {
                        LPITEMIDLIST pidlCD;
                        hr = _GetPlainCDPidl(&pidlCD);
                        if (SUCCEEDED(hr))
                        {
                            IShellFolder *psf;
                            hr = CFSFolder_CreateFolder(NULL, pbcNoForce, pidlCD, NULL, IID_PPV_ARG(IShellFolder, &psf));
                            if (SUCCEEDED(hr))
                            {
                                hr = pasf->AddNameSpace(&CLSID_CDBurn, psf, NULL, ASFF_COMMON);
                                psf->Release();
                            }
                            ILFree(pidlCD);
                        }

                        // clean up after ourselves
                        pbcNoForce->RevokeObjectParam(STR_DONT_FORCE_CREATE);
                    }
                    pbcNoForce->Release();
                }
            }


            // lets add the namespace that represents the storage

            if (SUCCEEDED(hr))
            {
                hr = pasf->AddNameSpace(&CLSID_StagingFolder, psfStg, NULL, ASFF_DEFNAMESPACE_ALL);
            }

            // tell the namespace its CLSID so we can get the correct views of the
            // web view etc.

            if (SUCCEEDED(hr))
            {
                IPropertyBag *ppb;
                hr = SHCreatePropertyBagOnMemory(STGM_READWRITE, IID_PPV_ARG(IPropertyBag, &ppb));
                if (SUCCEEDED(hr))
                {
                    // store the class ID for the CD mastering folder
                    SHPropertyBag_WriteGUID(ppb, L"MergedFolder\\CLSID", &CLSID_CDBurn);                    

                    // store the default effect for this folder.
                    SHPropertyBag_WriteInt(ppb, L"MergedFolder\\DropEffect", DROPEFFECT_COPY);       // sets the default

                    // say it's in a shellview.
                    SHPropertyBag_WriteBOOL(ppb, L"MergedFolder\\ShellView", TRUE);

                    SHLoadFromPropertyBag(pasf, ppb);

                    ppb->Release();
                }
            }

            if (SUCCEEDED(hr))
                hr = pasf->QueryInterface(riid, ppv);

            pasf->Release();
        }
        psfStg->Release();
    }
    return hr;
}

// IWizardSite

// note: these two methods change state -- the alternative is to have the
// extensions themselves manage which extension goes next.  we have to track
// which extension we're in with state because we dont get ownership of the
// wizard back until the extensions are done.
STDMETHODIMP CCDBurn::GetNextPage(HPROPSHEETPAGE *phPage)
{
    DWORD dwExtNum;
    if (SUCCEEDED(SHPropertyBag_ReadDWORD(_ppb, PROPSTR_CURRENTEXT, &dwExtNum)))
    {
        SHPropertyBag_WriteDWORD(_ppb, PROPSTR_CURRENTEXT, dwExtNum + 1);
    }
    return _GetExtPageFromPropBag(FALSE, phPage);
}

STDMETHODIMP CCDBurn::GetPreviousPage(HPROPSHEETPAGE *phPage)
{
    DWORD dwExtNum;
    if (SUCCEEDED(SHPropertyBag_ReadDWORD(_ppb, PROPSTR_CURRENTEXT, &dwExtNum)))
    {
        SHPropertyBag_WriteDWORD(_ppb, PROPSTR_CURRENTEXT, dwExtNum - 1);
    }
    return _GetExtPageFromPropBag(FALSE, phPage);
}

HRESULT CCDBurn::_GetExtPage(int nExt, BOOL fNext, HPROPSHEETPAGE *phpage)
{
    HRESULT hr = E_FAIL;
    // nExt is 1-based
    IWizardExtension *pwe = (IWizardExtension*)DPA_GetPtr(_hdpaExts, nExt - 1);
    if (pwe)
    {
        if (fNext)
        {
            hr = pwe->GetFirstPage(phpage);
        }
        else
        {
            hr = pwe->GetLastPage(phpage);
        }
    }
    return hr;
}

HRESULT CCDBurn::_GetExtPageFromPropBag(BOOL fNext, HPROPSHEETPAGE *phpage)
{
    HRESULT hr = S_OK;
    *phpage = NULL;

    // an extension could have completed, in which case check its return state to see if
    // we should be running more of them.
    DWORD dwState;
    if (SUCCEEDED(SHPropertyBag_ReadDWORD(_ppb, PROPSTR_EXTENSIONCOMPLETIONSTATE, &dwState)))
    {
        if (dwState & CDBE_RET_STOPWIZARD)
        {
            // leave the wizard.
            *phpage = _rgWizPages[INDEX_DLG_BURNWIZ_EARLYEXIT];
        }
        else if (dwState & CDBE_RET_DONTRUNOTHEREXTS)
        {
            // we're done with extensions, go to the burn.
            *phpage = _rgWizPages[INDEX_DLG_BURNWIZ_BURN_PROGRESS];
        }
    }
    
    if (!*phpage)
    {
        DWORD dwExt;
        hr = SHPropertyBag_ReadDWORD(_ppb, PROPSTR_CURRENTEXT, &dwExt);
        if (SUCCEEDED(hr))
        {
            if ((int)dwExt > DPA_GetPtrCount(_hdpaExts))
            {
                // we're done with extensions, go to the burn.
                *phpage = _rgWizPages[INDEX_DLG_BURNWIZ_BURN_PROGRESS];
            }
            else if (dwExt == 0)
            {
                // we went 'back' through all extensions, put us at the start page.
                int nIndex = SHPropertyBag_ReadBOOLDefRet(_ppb, PROPSTR_ERASE, FALSE) ? INDEX_DLG_BURNWIZ_STARTERASE : INDEX_DLG_BURNWIZ_WELCOME;
                *phpage = _rgWizPages[nIndex];
            }
            else
            {
                hr = _GetExtPage(dwExt, fNext, phpage);
            }
        }
    }
    return hr;
}

void CCDBurn::_SetExtPageFromPropBag(HWND hwnd, BOOL fNext)
{
    HPROPSHEETPAGE hpage;
    if (SUCCEEDED(_GetExtPageFromPropBag(fNext, &hpage)))
    {
        PropSheet_SetCurSel(GetParent(hwnd), hpage, -1);
        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)-1);
    }
}

HRESULT CCDBurn::_TryCLSID(REFCLSID clsid, DWORD dwExtType, REFIID riid, void **ppv)
{
    *ppv = NULL;

    ICDBurnExt *pcdbe;
    // Use SHExtCoCreateInstance to go through approval checking and app compat checking
    HRESULT hr = SHExtCoCreateInstance2(NULL, &clsid, NULL, CLSCTX_ALL, IID_PPV_ARG(ICDBurnExt, &pcdbe));
    if (SUCCEEDED(hr))
    {
        DWORD dw;
        hr = pcdbe->GetSupportedActionTypes(&dw);
        if (SUCCEEDED(hr))
        {
            if (dw & dwExtType)
            {
                hr = pcdbe->QueryInterface(riid, ppv);
            }
            else
            {
                hr = E_NOTIMPL;
            }
        }
        pcdbe->Release();
    }
    ASSERT(SUCCEEDED(hr) ? (*ppv != NULL) : (*ppv == NULL));
    return hr;
}

HRESULT CCDBurn::_TryKey(LPTSTR pszKey, DWORD dwExtType, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;
    *ppv = NULL;

    TCHAR szFullKey[MAX_PATH];
    lstrcpyn(szFullKey, REGSTR_PATH_HANDLERS, ARRAYSIZE(szFullKey));
    PathAppend(szFullKey, pszKey);

    TCHAR szCLSID[MAX_GUID_STRING_LEN];
    DWORD cbCLSID = sizeof(szCLSID);
    CLSID clsid;
    if ((ERROR_SUCCESS == SHRegGetUSValue(szFullKey, REGVALUE_CLSID, NULL, szCLSID, &cbCLSID, FALSE, NULL, 0)) &&
        GUIDFromString(szCLSID, &clsid))
    {
        hr = _TryCLSID(clsid, dwExtType, riid, ppv);
    }
    ASSERT(SUCCEEDED(hr) ? (*ppv != NULL) : (*ppv == NULL));
    return hr;
}

HRESULT CCDBurn::_TestDropEffect(IDropTarget *pdt, IDataObject *pdo, REFIID riid, void **ppv)
{
    *ppv = NULL;

    DWORD dwEffect;
    POINTL pt = {0};
    HRESULT hr = pdt->DragEnter(pdo, 0, pt, &dwEffect);
    if (SUCCEEDED(hr))
    {
        if (dwEffect != DROPEFFECT_NONE)
        {
            hr = pdt->QueryInterface(riid, ppv);
        }
        else
        {
            hr = E_FAIL;
        }
        pdt->DragLeave();
    }
    ASSERT(SUCCEEDED(hr) ? (*ppv != NULL) : (*ppv == NULL));
    return hr;
}

HRESULT CCDBurn::_TryKeyWithDropEffect(LPTSTR pszKey, DWORD dwExtType, IDataObject *pdo, REFIID riid, void **ppv)
{
    *ppv = NULL;

    IDropTarget *pdt;
    HRESULT hr = _TryKey(pszKey, dwExtType, IID_PPV_ARG(IDropTarget, &pdt));
    if (SUCCEEDED(hr))
    {
        hr = _TestDropEffect(pdt, pdo, riid, ppv);
        pdt->Release();
    }
    ASSERT(SUCCEEDED(hr) ? (*ppv != NULL) : (*ppv == NULL));
    return hr;
}

HRESULT CCDBurn::_TryCLSIDWithDropEffect(REFCLSID clsid, DWORD dwExtType, IDataObject *pdo, REFIID riid, void **ppv)
{
    *ppv = NULL;

    IDropTarget *pdt;
    HRESULT hr = _TryCLSID(clsid, dwExtType, IID_PPV_ARG(IDropTarget, &pdt));
    if (SUCCEEDED(hr))
    {
        hr = _TestDropEffect(pdt, pdo, riid, ppv);
        pdt->Release();
    }
    ASSERT(SUCCEEDED(hr) ? (*ppv != NULL) : (*ppv == NULL));
    return hr;
}

void CCDBurn::_AddExtensionToDPA(IWizardExtension *pwe, HPROPSHEETPAGE *rgPages, UINT cNumPages, UINT *pcPagesAdded)
{
    IUnknown_SetSite(pwe, SAFECAST(this, IWizardSite *));

    BOOL fAdded = FALSE;
    UINT cExtPages;
    if (SUCCEEDED(pwe->AddPages(rgPages + *pcPagesAdded, cNumPages - *pcPagesAdded, &cExtPages)) && cExtPages)
    {
        if (-1 != DPA_AppendPtr(_hdpaExts, pwe))
        {
            fAdded = TRUE;
            *pcPagesAdded += cExtPages;
            pwe->AddRef();
        }
        else
        {
            for (UINT i = 0; i < cExtPages; i++)
            {
                DestroyPropertySheetPage(rgPages[*pcPagesAdded + i]);
            }
        }
    }

    if (!fAdded)
    {
        // if it's in the dpa, it gets the setsite(NULL) later.
        IUnknown_SetSite(pwe, NULL);
    }
}

// does the enumRegFlags == SHREGENUM_BOTH case.
DWORD MySHRegEnumUSKey(HUSKEY hUSKey, DWORD dwIndex, LPWSTR pszName, DWORD *pcchName)
{
    // start with HKCU if possible.
    DWORD cKeys;
    DWORD dwRet = SHRegQueryInfoUSKey(hUSKey, &cKeys, NULL, NULL, NULL, SHREGENUM_HKCU);
    if (ERROR_SUCCESS == dwRet)
    {
        // HKCU is present.
        if (dwIndex < cKeys)
        {
            // enum from HKCU first
            dwRet = SHRegEnumUSKey(hUSKey, dwIndex, pszName, pcchName, SHREGENUM_HKCU);
        }
        else
        {
            // and next, HKLM
            dwRet = SHRegEnumUSKey(hUSKey, dwIndex - cKeys, pszName, pcchName, SHREGENUM_HKLM);
        }
    }
    else
    {
        // go only with HKLM.
        dwRet = SHRegEnumUSKey(hUSKey, dwIndex, pszName, pcchName, SHREGENUM_HKLM);
    }
    return dwRet;
}

HRESULT CCDBurn::_FillExtensionDPA(HPROPSHEETPAGE *rgPages, UINT cNumPages, UINT *pcPagesAdded)
{
    _hdpaExts = DPA_Create(4);
    HRESULT hr = _hdpaExts ? S_OK : E_OUTOFMEMORY;
    if (SUCCEEDED(hr))
    {
        *pcPagesAdded = 0;
        // first up is the burn audio cd extension
        IWizardExtension *pwe;
        if (SUCCEEDED(_TryCLSID(CLSID_BurnAudioCDExtension, CDBE_TYPE_ALL, IID_PPV_ARG(IWizardExtension, &pwe))))
        {
            _AddExtensionToDPA(pwe, rgPages, cNumPages, pcPagesAdded);
            pwe->Release();
        }

        HUSKEY huskeyHandlers;
        if (ERROR_SUCCESS == SHRegOpenUSKey(REGSTR_PATH_HANDLERS, KEY_READ, NULL, &huskeyHandlers, FALSE))
        {
            DWORD dwIndex = 0;
            TCHAR szKey[50];
            DWORD cchKey = ARRAYSIZE(szKey);
            while (ERROR_SUCCESS == SHRegEnumUSKey(huskeyHandlers, dwIndex, szKey, &cchKey, SHREGENUM_DEFAULT))
            {
                if (SUCCEEDED(_TryKey(szKey, CDBE_TYPE_ALL, IID_PPV_ARG(IWizardExtension, &pwe))))
                {
                    _AddExtensionToDPA(pwe, rgPages, cNumPages, pcPagesAdded);
                    pwe->Release();
                }
                dwIndex++;
                cchKey = ARRAYSIZE(szKey);
            }
            SHRegCloseUSKey(huskeyHandlers);
        }
    }
    return hr;
}

HRESULT CDBurn_GetExtensionObject(DWORD dwExtType, IDataObject *pdo, REFIID riid, void **ppv)
{
    *ppv = NULL;

    TCHAR szDefault[50];
    DWORD cb = sizeof(szDefault);
    HRESULT hr = (ERROR_SUCCESS == SHRegGetUSValue(REGSTR_PATH_HANDLERS, REGVALUE_FIRSTHANDLER,
                                                   NULL, szDefault, &cb, FALSE, NULL, 0)) ? S_OK : E_FAIL;
    if (SUCCEEDED(hr))
    {
        hr = CCDBurn::_TryKeyWithDropEffect(szDefault, dwExtType, pdo, riid, ppv);
    }
    else
    {
        szDefault[0] = 0;
    }

    // if we're not overridden by the FIRSTHANDLER value, try the burn audio cd extension.
    if (FAILED(hr))
    {
        hr = CCDBurn::_TryCLSIDWithDropEffect(CLSID_BurnAudioCDExtension, dwExtType, pdo, riid, ppv);
    }

    if (FAILED(hr))
    {
        HUSKEY huskeyHandlers;
        if (ERROR_SUCCESS == SHRegOpenUSKey(REGSTR_PATH_HANDLERS, KEY_READ, NULL, &huskeyHandlers, FALSE))
        {
            DWORD dwIndex = 0;
            TCHAR szKey[50];
            DWORD cchKey = ARRAYSIZE(szKey);
            while (FAILED(hr) && (ERROR_SUCCESS == MySHRegEnumUSKey(huskeyHandlers, dwIndex, szKey, &cchKey)))
            {
                if (StrCmpI(szDefault, szKey) != 0)
                {
                    hr = CCDBurn::_TryKeyWithDropEffect(szKey, dwExtType, pdo, riid, ppv);
                }

                dwIndex++;
                cchKey = ARRAYSIZE(szKey);
            }
            SHRegCloseUSKey(huskeyHandlers);
        }
    }
    return hr;
}

STDMETHODIMP CCDBurn::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    *ppv = NULL;
    HRESULT hr = E_FAIL;
    if (IsEqualGUID(guidService, SID_CDWizardHost))
    {
        if (IsEqualIID(riid, IID_IPropertyBag) && _ppb)
        {
            hr = _ppb->QueryInterface(riid, ppv);
        }
    }
    return hr;
}

STDMETHODIMP CCDBurn::AllowAutoPlay(LPCWSTR pszPath, DWORD dwContentType, LPCWSTR pszLabel, DWORD dwSerialNumber)
{
    HRESULT hr = S_OK; // default to allow autoplay
    int iDrive;
    if (SUCCEEDED(_GetCurrentDriveIndex(&iDrive)) &&
        (iDrive == DRIVEID(pszPath)))
    {
        // while we're registered in the running object table the wizard is always running, so dont autoplay.
        hr = S_FALSE;
    }
    return hr;
}

HRESULT CCDBurn::ConfirmOperation(IShellItem *psiSource, IShellItem *psiDest, STGTRANSCONFIRMATION stc, LPCUSTOMCONFIRMATION pcc)
{
    HRESULT hr = STRESPONSE_CONTINUE;  // use default postop handling.

    // null psiitem means this is postop for the entire operation.
    if (psiSource && IsEqualGUID(STCONFIRM_ACCESS_DENIED, stc))
    {
        DWORD dwCaps;
        BOOL fUDF;
        if (SUCCEEDED(_GetMediaCapabilities(&dwCaps, &fUDF)) && fUDF)
        {
            int id = (dwCaps & HWDMC_CDREWRITABLE) ? IDS_BURN_CANTWRITEMEDIACDRW : IDS_BURN_CANTWRITEMEDIACDR;
            ShellMessageBox(HINST_THISDLL, NULL, MAKEINTRESOURCE(id),
                            MAKEINTRESOURCE(IDS_BURN), MB_OK | MB_ICONSTOP);
            hr = E_FAIL; // stop the operation
        }
    }
    return hr;
}

typedef struct
{
    WCHAR szExts[MAX_PATH]; // PathMatchSpec list ("*.wma;*.mp3")
} FILE_EXTS;

// handles the audio cd burner extensions
class CBurnAudioCDExtension : public CObjectWithSite,
                              public ICDBurnExt,
                              public IDropTarget,
                              public IWizardExtension,
                              public INamespaceWalkCB
{
public:
    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // ICDBurnExt methods
    STDMETHOD(GetSupportedActionTypes)(DWORD *pdwActions);

    // IDropTarget methods
    STDMETHOD(DragEnter)(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHOD(DragOver)(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
        { return E_NOTIMPL; }
    STDMETHOD(DragLeave)(void)
        { return E_NOTIMPL; }
    STDMETHOD(Drop)(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // IWizardExtension
    STDMETHOD(AddPages)(HPROPSHEETPAGE *aPages, UINT cPages, UINT *pnPages);
    STDMETHOD(GetFirstPage)(HPROPSHEETPAGE *phPage);
    STDMETHOD(GetLastPage)(HPROPSHEETPAGE *phPage);

    // INamespaceWalkCB
    STDMETHOD(FoundItem)(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHOD(EnterFolder)(IShellFolder *psf, LPCITEMIDLIST pidl)
        { return S_OK; }
    STDMETHOD(LeaveFolder)(IShellFolder *psf, LPCITEMIDLIST pidl)
        { return S_OK; }
    STDMETHOD(InitializeProgressDialog)(LPWSTR *ppszTitle, LPWSTR *ppszCancel)
        { *ppszTitle = NULL; *ppszCancel = NULL; return E_NOTIMPL; }

    static INT_PTR s_MusicDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CBurnAudioCDExtension *pwe = s_GetBurnAudioCDExtension(hwnd, uMsg, lParam); return pwe->_MusicDlgProc(hwnd, uMsg, wParam, lParam); }

private:
    CBurnAudioCDExtension();
    ~CBurnAudioCDExtension();

    LONG _cRef;

    DWORD _cFiles, _cAudioFiles, _cNonAudioFiles; // state vars for walk callback
    BOOL _fBreakOnNonAudioFiles;
    HPROPSHEETPAGE _hpage;

    BOOL _fSelectMusic;
    HDSA _hdsaExtensions;  // bunch of FILE_EXTS.  we keep them individually for each extension and don't strcat them all
                           // together so if one registry entry is hopelessly bad it wont hurt everyone else.

    // hook stuff
    void _AddFileExtsForCLSID(REFCLSID clsid);
    void _AddFileExtsForKey(PCWSTR pszKey);
    void _AddAllExts();
    BOOL _HasAudioExtension(LPCTSTR pszName);
    BOOL _DataObjectHasAllAudioFiles(IDataObject *pdo);
    DWORD _CountOfAudioFilesForHandler(IDataObject *pdo, REFCLSID clsid);
    CLSID _GetDefaultCLSID();
    HRESULT _GetVerbForCLSID(REFCLSID clsid, PWSTR psz, UINT cch);
    BOOL _CanCreate(REFCLSID clsid);
    HRESULT _DropOnHandler(REFCLSID clsid, IDataObject *pdo);
    HRESULT _PickHandler(IDataObject *pdo, CLSID *pclsid);

    // wizard page
    static CBurnAudioCDExtension* s_GetBurnAudioCDExtension(HWND hwnd, UINT uMsg, LPARAM lParam);
    INT_PTR _MusicDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _SetCompletionState();

    // "exports"
    friend HRESULT CBurnAudioCDExtension_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
};

CBurnAudioCDExtension::CBurnAudioCDExtension() :
    _cRef(1)
{
    _fSelectMusic = TRUE;
}

CBurnAudioCDExtension::~CBurnAudioCDExtension()
{
    ASSERT(!_punkSite);
    DSA_Destroy(_hdsaExtensions);
}

// IUnknown

STDMETHODIMP_(ULONG) CBurnAudioCDExtension::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CBurnAudioCDExtension::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CBurnAudioCDExtension::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CBurnAudioCDExtension, ICDBurnExt),
        QITABENT(CBurnAudioCDExtension, IDropTarget),
        QITABENT(CBurnAudioCDExtension, IWizardExtension),
        QITABENT(CBurnAudioCDExtension, IObjectWithSite),
        QITABENT(CBurnAudioCDExtension, INamespaceWalkCB),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDAPI CBurnAudioCDExtension_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv)
{
    if (punkOuter)
        return CLASS_E_NOAGGREGATION; 

    CBurnAudioCDExtension *pbe = new CBurnAudioCDExtension();
    if (!pbe)
        return E_OUTOFMEMORY;

    HRESULT hr = pbe->QueryInterface(riid, ppv);
    pbe->Release();
    return hr;
}

CBurnAudioCDExtension* CBurnAudioCDExtension::s_GetBurnAudioCDExtension(HWND hwnd, UINT uMsg, LPARAM lParam)
{
    if (uMsg == WM_INITDIALOG)
    {
        PROPSHEETPAGE *ppsp = (PROPSHEETPAGE*)lParam;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, ppsp->lParam);
        return (CBurnAudioCDExtension*)ppsp->lParam;
    }
    return (CBurnAudioCDExtension*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
}

HRESULT CBurnAudioCDExtension::GetSupportedActionTypes(DWORD *pdwActions)
{
    *pdwActions = CDBE_TYPE_MUSIC;
    return S_OK;
}

void CBurnAudioCDExtension::_AddFileExtsForKey(PCWSTR pszKey)
{
    ASSERT(_hdsaExtensions);

    FILE_EXTS fileexts;
    DWORD cb = sizeof(fileexts.szExts);
    if (ERROR_SUCCESS == SHRegGetUSValue(pszKey, REGVALUE_FILEEXTS, NULL, fileexts.szExts, &cb, FALSE, NULL, 0))
    {
        DSA_AppendItem(_hdsaExtensions, &fileexts);
    }
}

void CBurnAudioCDExtension::_AddFileExtsForCLSID(REFCLSID clsid)
{
    ASSERT(_hdsaExtensions);

    if (_CanCreate(clsid))
    {
        WCHAR szCLSID[GUIDSTR_MAX];
        SHStringFromGUID(clsid, szCLSID, ARRAYSIZE(szCLSID));

        WCHAR szExtKey[MAX_PATH];
        StrCpyN(szExtKey, REGSTR_PATH_AUDIOEXTS, ARRAYSIZE(szExtKey));
        PathAppend(szExtKey, szCLSID);

        _AddFileExtsForKey(szExtKey);
    }
}

void CBurnAudioCDExtension::_AddAllExts()
{
    HUSKEY huskeyExts;
    if (ERROR_SUCCESS == SHRegOpenUSKey(REGSTR_PATH_AUDIOEXTS, KEY_READ, NULL, &huskeyExts, FALSE))
    {
        DWORD dwIndex = 0;
        WCHAR szCLSID[GUIDSTR_MAX];
        DWORD cchCLSID = ARRAYSIZE(szCLSID);
        while (ERROR_SUCCESS == MySHRegEnumUSKey(huskeyExts, dwIndex, szCLSID, &cchCLSID))
        {
            CLSID clsid;
            if (GUIDFromString(szCLSID, &clsid))
            {
                _AddFileExtsForCLSID(clsid);
            }

            cchCLSID = ARRAYSIZE(szCLSID);
            dwIndex++;
        }
        SHRegCloseUSKey(huskeyExts);
    }
}

BOOL CBurnAudioCDExtension::_HasAudioExtension(LPCTSTR pszName)
{
    // this list of extensions is based on what files the extension can BURN, not just play.
    // (so we cant do a check for generic audio type.)
    BOOL fRet = FALSE;
    if (_hdsaExtensions)
    {
        for (int i = 0; !fRet && (i < DSA_GetItemCount(_hdsaExtensions)); i++)
        {
            FILE_EXTS *pfileexts = (FILE_EXTS *)DSA_GetItemPtr(_hdsaExtensions, i);
            fRet = PathMatchSpec(pszName, pfileexts->szExts);
        }
    }
    return fRet;
}

HRESULT CBurnAudioCDExtension::FoundItem(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    // early-out if we are checking that ALL files are audio files and we've found one that's not.
    if (_fBreakOnNonAudioFiles && (_cNonAudioFiles > 0))
        return E_FAIL;

    // break if we've seen enough files.
    if (_cFiles > 50)
        return E_FAIL;

    _cFiles++;

    TCHAR szName[MAX_PATH];
    HRESULT hr = DisplayNameOf(psf, pidl, SHGDN_INFOLDER | SHGDN_FORPARSING, szName, ARRAYSIZE(szName));
    if (SUCCEEDED(hr))
    {
        if (_HasAudioExtension(szName))
        {
            _cAudioFiles++;
        }
        else
        {
            _cNonAudioFiles++;
        }
    }
    return hr;
}

BOOL CBurnAudioCDExtension::_DataObjectHasAllAudioFiles(IDataObject *pdo)
{
    _cFiles = _cAudioFiles = _cNonAudioFiles = 0;
    _fBreakOnNonAudioFiles = TRUE;

    if (_hdsaExtensions)
        DSA_Destroy(_hdsaExtensions);
    _hdsaExtensions = DSA_Create(sizeof(FILE_EXTS), 4);
    if (_hdsaExtensions)
    {
        _AddAllExts();

        INamespaceWalk *pnsw;
        if (SUCCEEDED(CoCreateInstance(CLSID_NamespaceWalker, NULL, CLSCTX_INPROC, IID_PPV_ARG(INamespaceWalk, &pnsw))))
        {
            pnsw->Walk(pdo, NSWF_DONT_ACCUMULATE_RESULT, 4, this);
            pnsw->Release();
        }
    }

    return ((_cFiles > 0) && (_cNonAudioFiles == 0));
}

DWORD CBurnAudioCDExtension::_CountOfAudioFilesForHandler(IDataObject *pdo, REFCLSID clsid)
{
    _cFiles = _cAudioFiles = _cNonAudioFiles = 0;
    if (pdo)
    {
        _fBreakOnNonAudioFiles = FALSE;

        if (_hdsaExtensions)
            DSA_Destroy(_hdsaExtensions);
        _hdsaExtensions = DSA_Create(sizeof(FILE_EXTS), 4);
        if (_hdsaExtensions)
        {
            _AddFileExtsForCLSID(clsid);

            INamespaceWalk *pnsw;
            if (SUCCEEDED(CoCreateInstance(CLSID_NamespaceWalker, NULL, CLSCTX_INPROC, IID_PPV_ARG(INamespaceWalk, &pnsw))))
            {
                pnsw->Walk(pdo, NSWF_DONT_ACCUMULATE_RESULT, 4, this);
                pnsw->Release();
            }
        }
    }
    else
    {
        // if we're not given a data object, we're being polled just to see if we can create
        if (_CanCreate(clsid))
        {
            _cAudioFiles = 1;
        }
    }
    return _cAudioFiles;
}

BOOL CBurnAudioCDExtension::_CanCreate(REFCLSID clsid)
{
    // Use SHExtCoCreateInstance to go through approval checking and app compat checking
    IUnknown *punk;
    HRESULT hr = SHExtCoCreateInstance2(NULL, &clsid, NULL, CLSCTX_ALL, IID_PPV_ARG(IUnknown, &punk));
    if (SUCCEEDED(hr))
    {
        punk->Release();
    }
    return SUCCEEDED(hr);
}

// if pdo is NULL, only test which extensions can be cocreated.
HRESULT CBurnAudioCDExtension::_PickHandler(IDataObject *pdo, CLSID *pclsid)
{
    HRESULT hr;

    *pclsid = _GetDefaultCLSID();
    if (_CountOfAudioFilesForHandler(pdo, *pclsid) > 0)
    {
        // if the default handler supports any of the files, let it take over and we're done.
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;

        CLSID clsidBestSoFar;
        DWORD dwCountBestSoFar = 0;

        HUSKEY huskeyExts;
        if (ERROR_SUCCESS == SHRegOpenUSKey(REGSTR_PATH_AUDIOEXTS, KEY_READ, NULL, &huskeyExts, FALSE))
        {
            DWORD dwIndex = 0;
            WCHAR szCLSID[GUIDSTR_MAX];
            DWORD cchKey = ARRAYSIZE(szCLSID);
            while (ERROR_SUCCESS == MySHRegEnumUSKey(huskeyExts, dwIndex, szCLSID, &cchKey))
            {
                CLSID clsidExt;
                if (GUIDFromString(szCLSID, &clsidExt))
                {
                    DWORD dwCountExt = _CountOfAudioFilesForHandler(pdo, clsidExt);
                    if (dwCountExt > dwCountBestSoFar)
                    {
                        hr = S_OK;
                        dwCountBestSoFar = dwCountExt;
                        clsidBestSoFar = clsidExt;
                    }
                }
                cchKey = ARRAYSIZE(szCLSID);
                dwIndex++;
            }
            SHRegCloseUSKey(huskeyExts);
        }

        if (SUCCEEDED(hr))
        {
            *pclsid = clsidBestSoFar;
        }
    }
    return hr;
}

HRESULT CBurnAudioCDExtension::DragEnter(IDataObject *pdo, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    *pdwEffect = DROPEFFECT_NONE;

    // on DTC even the default handler may or may not be installed, so do an early check if we can create the object.
    // cache it since this DragEnter is hit determining if the "burn audio cd" task show up.
    static int s_fBurnHandlerAvailable = -1;
    if (s_fBurnHandlerAvailable == -1)
    {
        CLSID clsid;
        if (SUCCEEDED(_PickHandler(NULL, &clsid)))
        {
            s_fBurnHandlerAvailable = 1;
        }
        else
        {
            s_fBurnHandlerAvailable = 0;
        }
    }

    ICDBurnPriv *pcdbp;
    if (s_fBurnHandlerAvailable && SUCCEEDED(SHCoCreateInstance(NULL, &CLSID_CDBurn, NULL, IID_PPV_ARG(ICDBurnPriv, &pcdbp))))
    {
        // mini-hack: we want the web view task "copy to audio cd" to always show up no matter what
        // the current state of the media is, however we only want to show the wizard page if it's blank.
        // so we check against if the wizard is active or not now.
        // this has the added effect of disabling the "copy to audio cd" task if we're burning in
        // the wizard -- which is probably what we want so its okay.
        if (_DataObjectHasAllAudioFiles(pdo))
        {
            BOOL fOnMedia;
            // if we're not running the wizard, go for it.
            // if we are running the wizard, make sure there are no files on the media.
            if ((S_OK != pcdbp->IsWizardUp()) || (SUCCEEDED(pcdbp->GetContentState(NULL, &fOnMedia)) && !fOnMedia))
            {
                *pdwEffect = DROPEFFECT_COPY;
            }
        }
        pcdbp->Release();
    }    
    return S_OK;
}

CLSID CBurnAudioCDExtension::_GetDefaultCLSID()
{
    WCHAR szCLSID[GUIDSTR_MAX];
    DWORD cb = sizeof(szCLSID);
    CLSID clsid;
    if ((ERROR_SUCCESS != SHRegGetUSValue(REGSTR_PATH_AUDIOEXTS, L"", NULL, szCLSID, &cb, FALSE, NULL, 0)) ||
        (!GUIDFromString(szCLSID, &clsid)))
    {
        clsid = CLSID_NULL; // default to this, if registry entry is not there or erroneous
    }
    return clsid;
}

HRESULT CBurnAudioCDExtension::_GetVerbForCLSID(REFCLSID clsid, PWSTR psz, UINT cch)
{
    WCHAR szCLSID[GUIDSTR_MAX];
    SHStringFromGUID(clsid, szCLSID, ARRAYSIZE(szCLSID));

    WCHAR szExtensionRegPath[MAX_PATH];
    lstrcpyn(szExtensionRegPath, REGSTR_PATH_AUDIOEXTS, ARRAYSIZE(szExtensionRegPath));
    PathAppend(szExtensionRegPath, szCLSID);

    DWORD cbVerb = cch * sizeof(*psz);
    return (ERROR_SUCCESS == SHRegGetUSValue(szExtensionRegPath, REGVALUE_VERB, NULL, psz, &cbVerb, FALSE, NULL, 0)) ? S_OK : E_FAIL;
}

HRESULT CBurnAudioCDExtension::_DropOnHandler(REFCLSID clsid, IDataObject *pdo)
{
    WCHAR wzVerb[20];
    HRESULT hr = _GetVerbForCLSID(clsid, wzVerb, ARRAYSIZE(wzVerb));
    if (SUCCEEDED(hr))
    {
        IShellExtInit *psei;
        hr = SHExtCoCreateInstance2(NULL, &clsid, NULL, CLSCTX_ALL, IID_PPV_ARG(IShellExtInit, &psei));
        if (SUCCEEDED(hr))
        {
            hr = psei->Initialize(NULL, pdo, NULL);
            if (SUCCEEDED(hr))
            {
                IContextMenu *pcm;
                hr = psei->QueryInterface(IID_PPV_ARG(IContextMenu, &pcm));
                if (SUCCEEDED(hr))
                {
                    HMENU hmenu = CreatePopupMenu();
                    if (hmenu)
                    {
                        hr = pcm->QueryContextMenu(hmenu, 0, 0x1, 0x7fff, 0);
                        if (SUCCEEDED(hr))
                        {
                            CMINVOKECOMMANDINFOEX ici = { 0 };
                            ici.cbSize = sizeof(CMINVOKECOMMANDINFOEX);

                            ici.fMask = CMIC_MASK_UNICODE;
                            ici.lpVerbW = wzVerb;

                            CHAR szVerbAnsi[20];
                            SHTCharToAnsi(wzVerb, szVerbAnsi, ARRAYSIZE(szVerbAnsi));
                            ici.lpVerb = szVerbAnsi;
                            ici.nShow = SW_NORMAL;

                            hr = pcm->InvokeCommand((LPCMINVOKECOMMANDINFO)(&ici));
                        }
                        DestroyMenu(hmenu);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    pcm->Release();
                }
            }
            psei->Release();
        }
    }
    return hr;
}

HRESULT CBurnAudioCDExtension::Drop(IDataObject *pdo, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    CLSID clsid;
    HRESULT hr = _PickHandler(pdo, &clsid);
    if (SUCCEEDED(hr))
    {
        _DropOnHandler(clsid, pdo);
    }
    return hr;
}

HRESULT CBurnAudioCDExtension::GetLastPage(HPROPSHEETPAGE *phPage)
{
    *phPage = _hpage;
    return S_OK;
}

HRESULT CBurnAudioCDExtension::GetFirstPage(HPROPSHEETPAGE *phPage)
{
    *phPage = _hpage;
    return S_OK;
}

HRESULT CBurnAudioCDExtension::AddPages(HPROPSHEETPAGE *aPages, UINT cPages, UINT *pnPages)
{
    *pnPages = 0;

    WIZPAGE c_wp =
        {DLG_BURNWIZ_MUSIC, IDS_BURNWIZ_MUSIC_HEAD, IDS_BURNWIZ_MUSIC_SUB, 0, CBurnAudioCDExtension::s_MusicDlgProc};

    _hpage = _CreatePropPageFromInfo(&c_wp, (LPARAM)this);
    if (cPages > 0)
    {
        aPages[0] = _hpage;
        *pnPages = 1;
    }
    return S_OK;
}

// pushes the return state back to the main wizard
void CBurnAudioCDExtension::_SetCompletionState()
{
    IPropertyBag *ppb;
    if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_CDWizardHost, IID_PPV_ARG(IPropertyBag, &ppb))))
    {
        SHPropertyBag_WriteDWORD(ppb, PROPSTR_EXTENSIONCOMPLETIONSTATE, CDBE_RET_STOPWIZARD);
        ppb->Release();
    }
}

INT_PTR CBurnAudioCDExtension::_MusicDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet = FALSE;
    switch (uMsg)
    {
        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_BACK | PSWIZB_NEXT);
                    Button_SetCheck(GetDlgItem(hwnd, IDC_BURNWIZ_BURNAUDIO), _fSelectMusic ? BST_CHECKED : BST_UNCHECKED);
                    Button_SetCheck(GetDlgItem(hwnd, IDC_BURNWIZ_BURNDATA), _fSelectMusic ? BST_UNCHECKED : BST_CHECKED);
                    fRet = TRUE;
                    break;

                case PSN_WIZBACK:
                    if (_punkSite) 
                    {
                        IWizardSite *pws;
                        if (SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IWizardSite, &pws))))
                        {
                            HPROPSHEETPAGE hpage;
                            if (SUCCEEDED(pws->GetPreviousPage(&hpage)))
                            {
                                PropSheet_SetCurSel(GetParent(hwnd), hpage, -1);
                                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)-1);
                            }
                            pws->Release();
                        }
                    }
                    fRet = TRUE;
                    break;

                case PSN_WIZNEXT:
                    if (IsDlgButtonChecked(hwnd, IDC_BURNWIZ_BURNAUDIO) == BST_CHECKED)
                    {
                        IDataObject *pdo;
                        if (SUCCEEDED(_CreateDataObject(&pdo)))
                        {
                            POINTL pt = {0};
                            if (SUCCEEDED(Drop(pdo, 0, pt, NULL)))
                            {
                                _SetCompletionState();
                            }
                            pdo->Release();
                        }
                    }
                    if (_punkSite) 
                    {
                        IWizardSite *pws;
                        if (SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IWizardSite, &pws))))
                        {
                            HPROPSHEETPAGE hpage;
                            if (SUCCEEDED(pws->GetNextPage(&hpage)))
                            {
                                PropSheet_SetCurSel(GetParent(hwnd), hpage, -1);
                                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)-1);
                            }
                            pws->Release();
                        }
                    }
                    fRet = TRUE;
                    break;

                case PSN_KILLACTIVE:
                    _fSelectMusic = (IsDlgButtonChecked(hwnd, IDC_BURNWIZ_BURNAUDIO) == BST_CHECKED);
                    break;
            }
            break;
        }
    }
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\browse.cpp ===
#include "shellprv.h"

#include "ids.h"
#include "findhlp.h"
#include "shitemid.h"
#include "findfilter.h"
#include <inetreg.h>
#include <help.h>

class CBrowseForFolder;


// Structure to pass information to browse for folder dialog

typedef struct
{
    HWND          hwndOwner;
    LPCITEMIDLIST pidlRoot;      // Root of search.  Typically desktop or my net
    LPTSTR        pszDisplayName;// Return display name of item selected.
    int           *piImage;      // where to return the Image index.
    LPCTSTR       lpszTitle;      // resource (or text to go in the banner over the tree.
    UINT          ulFlags;       // Flags that control the return stuff
    BFFCALLBACK   lpfn;
    LPARAM        lParam;
    HWND          hwndDlg;       // The window handle to the dialog
    HWND          hwndTree;      // The tree control.
    HWND          hwndEdit;
    HTREEITEM     htiCurParent;  // tree item associated with Current shell folder
    IShellFolder  *psfParent;    // Cache of the last IShell folder I needed...
    LPITEMIDLIST  pidlCurrent;   // IDlist of current folder to select
    BOOL          fShowAllObjects; // Should we Show all ?
    BOOL          fUnicode;     // 1:unicode entry pt  0:ansi
} BFSF;


LPITEMIDLIST SHBrowseForFolder2(BFSF * pbfsf);
BOOL_PTR CALLBACK _BrowseDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
LPITEMIDLIST _BFSFUpdateISHCache(BFSF *pbfsf, HTREEITEM hti, LPITEMIDLIST pidlItem);

// We want to use SHBrowseForFolder2 if either:
// 1. pbfsf->lpfn == NULL since the caller wont' customize the dialog, or
// 2. pbfsf->ulFlags
BOOL ShouldUseBrowseForFolder2(BFSF *pbfsf)
{
//    FEATURE:  Enable the following code after we have it working with all the backward compat cases.
//    return (!pbfsf->lpfn || (BIF_NEWDIALOGSTYLE == pbfsf->ulFlags));
    return (BIF_NEWDIALOGSTYLE & pbfsf->ulFlags);
}

STDAPI_(LPITEMIDLIST) SHBrowseForFolder(BROWSEINFO *pbi)
{
    HRESULT hrOle = SHCoInitialize();   // Init OLE for AutoComplete

    // NB: The ANSI Thunk (see below) does not call through this routine,
    // but rather called DialogBoxParam on its own.  If you change this
    // routine, change the A version as well!!
    BFSF bfsf = {
      pbi->hwndOwner,
      pbi->pidlRoot,
      pbi->pszDisplayName,
      &pbi->iImage,
      pbi->lpszTitle,
      pbi->ulFlags,
      pbi->lpfn,
      pbi->lParam,
    };
    HCURSOR hcOld = SetCursor(LoadCursor(NULL,IDC_WAIT));
    SHELLSTATE ss;

    SHGetSetSettings(&ss, SSF_SHOWALLOBJECTS, FALSE);
    bfsf.fShowAllObjects = BOOLIFY(ss.fShowAllObjects);
    bfsf.fUnicode = 1;

    LPITEMIDLIST pidlRet = NULL;

    if (ShouldUseBrowseForFolder2(&bfsf))
    {
        pidlRet = SHBrowseForFolder2(&bfsf);  // Continue even if OLE wasn't initialized.
    }
    else if (DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_BROWSEFORFOLDER),
                            pbi->hwndOwner, _BrowseDlgProc, (LPARAM)&bfsf))
    {
        pidlRet = bfsf.pidlCurrent;
    }

    if (pidlRet && !(pbi->ulFlags & BIF_NOTRANSLATETARGETS))
    {
        LPITEMIDLIST pidlTarget;
        if (SUCCEEDED(SHGetTargetFolderIDList(pidlRet, &pidlTarget)))
        {
            ILFree(pidlRet);
            pidlRet = pidlTarget;
        }
    }

    if (hcOld)
        SetCursor(hcOld);

    SHCoUninitialize(hrOle);
    return pidlRet;
}

STDAPI_(LPITEMIDLIST) SHBrowseForFolderA(BROWSEINFOA *pbi)
{
    LPITEMIDLIST pidlRet = NULL;
    HRESULT hrOle = SHCoInitialize();   // Init OLE for AutoComplete
    ThunkText *pThunkText = ConvertStrings(1, pbi->lpszTitle);
    if (pThunkText)
    {
        WCHAR wszReturn[MAX_PATH];
        BFSF bfsf =
        {
            pbi->hwndOwner,
            pbi->pidlRoot,
            wszReturn,
            &pbi->iImage,
            pThunkText->m_pStr[0],   // UNICODE copy of pbi->lpszTitle
            pbi->ulFlags,
            pbi->lpfn,
            pbi->lParam,
        };
        HCURSOR hcOld = SetCursor(LoadCursor(NULL,IDC_WAIT));
        SHELLSTATE ss;

        SHGetSetSettings(&ss, SSF_SHOWALLOBJECTS, FALSE);
        bfsf.fShowAllObjects = BOOLIFY(ss.fShowAllObjects);
        bfsf.fUnicode = 0;

        // Now Create the dialog that will be doing the browsing.
        if (ShouldUseBrowseForFolder2(&bfsf))
        {
            pidlRet = SHBrowseForFolder2(&bfsf);
        }
        else if (DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_BROWSEFORFOLDER),
                                pbi->hwndOwner, _BrowseDlgProc, (LPARAM)&bfsf))
        {
            pidlRet = bfsf.pidlCurrent;
        }

        LocalFree(pThunkText);

        if (hcOld)
            SetCursor(hcOld);

        if (pidlRet)
        {
            if (pbi->pszDisplayName)
            {
                SHUnicodeToAnsi(wszReturn, pbi->pszDisplayName, MAX_PATH);
            }

            if (!(pbi->ulFlags & BIF_NOTRANSLATETARGETS))
            {
                LPITEMIDLIST pidlTarget;
                if (SUCCEEDED(SHGetTargetFolderIDList(pidlRet, &pidlTarget)))
                {
                    ILFree(pidlRet);
                    pidlRet = pidlTarget;
                }
            }
        }
    }

    SHCoUninitialize(hrOle);
    return pidlRet;
}

int BFSFCallback(BFSF *pbfsf, UINT uMsg, LPARAM lParam)
{
    return pbfsf->lpfn ? pbfsf->lpfn(pbfsf->hwndDlg, uMsg, lParam, pbfsf->lParam) : 0;
}

HTREEITEM _BFSFAddItemToTree(HWND hwndTree, HTREEITEM htiParent, LPITEMIDLIST pidl, int cChildren)
{
    TV_INSERTSTRUCT tii;

    // Initialize item to add with callback for everything
    tii.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE |
            TVIF_PARAM | TVIF_CHILDREN;
    tii.hParent = htiParent;
    tii.hInsertAfter = TVI_FIRST;
    tii.item.iImage = I_IMAGECALLBACK;
    tii.item.iSelectedImage = I_IMAGECALLBACK;
    tii.item.pszText = LPSTR_TEXTCALLBACK;   //
    tii.item.cChildren = cChildren; //  Assume it has children
    tii.item.lParam = (LPARAM)pidl;
    return TreeView_InsertItem(hwndTree, &tii);
}

LPITEMIDLIST _BFSFGetIDListFromTreeItem(HWND hwndTree, HTREEITEM hti)
{
    LPITEMIDLIST pidl;
    LPITEMIDLIST pidlT;
    TV_ITEM tvi;

    // If no hti passed in, get the selected on.
    if (hti == NULL)
    {
        hti = TreeView_GetSelection(hwndTree);
        if (hti == NULL)
            return(NULL);
    }

    // now lets get the information about the item
    tvi.mask = TVIF_PARAM | TVIF_HANDLE;
    tvi.hItem = hti;
    if (!TreeView_GetItem(hwndTree, &tvi))
        return(NULL);   // Failed again

    pidl = ILClone((LPITEMIDLIST)tvi.lParam);

    // Now walk up parents.
    while ((NULL != (tvi.hItem = TreeView_GetParent(hwndTree, tvi.hItem))) && pidl)
    {
        if (!TreeView_GetItem(hwndTree, &tvi))
            return(pidl);   // will assume I messed up...
        pidlT = ILCombine((LPITEMIDLIST)tvi.lParam, pidl);

        ILFree(pidl);

        pidl = pidlT;

    }
    return pidl;
}


int CALLBACK _BFSFTreeCompare(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    IShellFolder *psfParent = (IShellFolder *)lParamSort;
    HRESULT hr = psfParent->CompareIDs(0, (LPITEMIDLIST)lParam1, (LPITEMIDLIST)lParam2);
    if (FAILED(hr))
        return 0;
    
    return (short)SCODE_CODE(GetScode(hr));
}

void _BFSFSort(BFSF *pbfsf, HTREEITEM hti, IShellFolder *psf)
{
    TV_SORTCB sSortCB;
    sSortCB.hParent = hti;
    sSortCB.lpfnCompare = _BFSFTreeCompare;

    psf->AddRef();
    sSortCB.lParam = (LPARAM)psf;
    TreeView_SortChildrenCB(pbfsf->hwndTree, &sSortCB, FALSE);
    psf->Release();
}

BOOL _BFSFHandleItemExpanding(BFSF *pbfsf, LPNM_TREEVIEW lpnmtv)
{
    LPITEMIDLIST pidlToExpand;
    LPITEMIDLIST pidl;
    IShellFolder *psf;
    BYTE bType;
    DWORD grfFlags;
    BOOL fPrinterTest = FALSE;
    int cAdded = 0;
    TV_ITEM tvi;

    if (lpnmtv->action != TVE_EXPAND)
        return FALSE;

    if ((lpnmtv->itemNew.state & TVIS_EXPANDEDONCE))
        return FALSE;

    // set this bit now because we might be reentered via the wnet apis
    tvi.mask = TVIF_STATE;
    tvi.hItem = lpnmtv->itemNew.hItem;
    tvi.state = TVIS_EXPANDEDONCE;
    tvi.stateMask = TVIS_EXPANDEDONCE;
    TreeView_SetItem(pbfsf->hwndTree, &tvi);


    if (lpnmtv->itemNew.hItem == NULL)
    {
        lpnmtv->itemNew.hItem = TreeView_GetSelection(pbfsf->hwndTree);
        if (lpnmtv->itemNew.hItem == NULL)
            return FALSE;
    }

    pidlToExpand = _BFSFGetIDListFromTreeItem(pbfsf->hwndTree, lpnmtv->itemNew.hItem);

    if (pidlToExpand == NULL)
        return FALSE;

    // Now lets get the IShellFolder and iterator for this object
    // special case to handle if the Pidl is the desktop
    // This is rather gross, but the desktop appears to be simply a pidl
    // of length 0 and ILIsEqual will not work...
    if (FAILED(SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidlToExpand, &psf))))
    {
        ILFree(pidlToExpand);
        return FALSE; // Could not get IShellFolder.
    }


    // Need to do a couple of special cases here to allow us to
    // browse for a network printer.  In this case if we are at server
    // level we then need to change what we search for non folders when
    // we are the level of a server.
    if (pbfsf->ulFlags & BIF_BROWSEFORPRINTER)
    {
        grfFlags = SHCONTF_FOLDERS | SHCONTF_NETPRINTERSRCH | SHCONTF_NONFOLDERS;
        pidl = ILFindLastID(pidlToExpand);
        bType = SIL_GetType(pidl);
        fPrinterTest = ((bType & (SHID_NET | SHID_INGROUPMASK)) == SHID_NET_SERVER);
    }
    else if (pbfsf->ulFlags & BIF_BROWSEINCLUDEFILES)
        grfFlags = SHCONTF_FOLDERS | SHCONTF_NONFOLDERS;
    else
        grfFlags = SHCONTF_FOLDERS;

    if (pbfsf->fShowAllObjects)
        grfFlags |= SHCONTF_INCLUDEHIDDEN;

    IEnumIDList *penum;
    if (S_OK != psf->EnumObjects(pbfsf->hwndDlg, grfFlags, &penum))
    {
        psf->Release();
        ILFree(pidlToExpand);
        return FALSE;
    }
    // psf->AddRef();

    while (S_OK == penum->Next(1, &pidl, NULL))
    {
        int cChildren = I_CHILDRENCALLBACK;  // Do call back for children
        //
        // We need to special case here in the netcase where we onlyu
        // browse down to workgroups...
        //
        //
        // Here is where I also need to special case to not go below
        // workgroups when the appropriate option is set.
        //
        bType = SIL_GetType(pidl);
        if ((pbfsf->ulFlags & BIF_DONTGOBELOWDOMAIN) && (bType & SHID_NET))
        {
            switch (bType & (SHID_NET | SHID_INGROUPMASK))
            {
            case SHID_NET_SERVER:
                ILFree(pidl);       // Dont want to add this one
                continue;           // Try the next one
            case SHID_NET_DOMAIN:
                cChildren = 0;      // Force to not have children;
            }
        }
        else if ((pbfsf->ulFlags & BIF_BROWSEFORCOMPUTER) && (bType & SHID_NET))
        {
            if ((bType & (SHID_NET | SHID_INGROUPMASK)) == SHID_NET_SERVER)
                cChildren = 0;  // Don't expand below it...
        }
        else if (pbfsf->ulFlags & BIF_BROWSEFORPRINTER)
        {
            // Special case when we are only allowing printers.
            // for now I will simply key on the fact that it is non-FS.
            ULONG ulAttr = SFGAO_FILESYSANCESTOR;

            psf->GetAttributesOf(1, (LPCITEMIDLIST *) &pidl, &ulAttr);

            if ((ulAttr & SFGAO_FILESYSANCESTOR) == 0)
            {
                cChildren = 0;      // Force to not have children;
            }
            else if (fPrinterTest)
            {
                ILFree(pidl);       // We are down to server level so don't add other things here
                continue;           // Try the next one
            }
        }
        else if (pbfsf->ulFlags & BIF_BROWSEINCLUDEFILES)
        {
            // Lets not use the callback to see if this item has children or not
            // as some or files (no children) and it is not worth writing our own
            // enumerator as we don't want the + to depend on if there are sub-folders
            // but instead it should be if it has files...
            ULONG ulAttr = SFGAO_FOLDER;

            psf->GetAttributesOf(1, (LPCITEMIDLIST *) &pidl, &ulAttr);
            if ((ulAttr & SFGAO_FOLDER)== 0)
                cChildren = 0;      // Force to not have children;
            else
                cChildren = 1;
        }

        if (pbfsf->ulFlags & (BIF_RETURNONLYFSDIRS | BIF_RETURNFSANCESTORS))
        {
            // If we are only looking for FS level things only add items
            // that are in the name space that are file system objects or
            // ancestors of file system objects
            ULONG ulAttr = SFGAO_FILESYSANCESTOR | SFGAO_FILESYSTEM;

            psf->GetAttributesOf(1, (LPCITEMIDLIST *) &pidl, &ulAttr);

            if ((ulAttr & (SFGAO_FILESYSANCESTOR | SFGAO_FILESYSTEM))== 0)
            {
                ILFree(pidl);       // We are down to server level so don't add other things here
                continue;           // Try the next one
            }
        }

        _BFSFAddItemToTree(pbfsf->hwndTree, lpnmtv->itemNew.hItem,
                pidl, cChildren);
        cAdded++;
    }

    // Now Cleanup after ourself
    penum->Release();

    _BFSFSort(pbfsf, lpnmtv->itemNew.hItem, psf);
    psf->Release();
    ILFree(pidlToExpand);

    // If we did not add anything we should update this item to let
    // the user know something happened.
    //
    if (cAdded == 0)
    {
        TV_ITEM tvi;
        tvi.mask = TVIF_CHILDREN | TVIF_HANDLE;   // only change the number of children
        tvi.hItem = lpnmtv->itemNew.hItem;
        tvi.cChildren = 0;

        TreeView_SetItem(pbfsf->hwndTree, &tvi);

    }

    return TRUE;
}

void _BFSFHandleDeleteItem(BFSF *pbfsf, LPNM_TREEVIEW lpnmtv)
{
    // We need to free the IDLists that we allocated previously
    if (lpnmtv->itemOld.lParam != 0)
        ILFree((LPITEMIDLIST)lpnmtv->itemOld.lParam);
}

LPITEMIDLIST _BFSFUpdateISHCache(BFSF *pbfsf, HTREEITEM hti, LPITEMIDLIST pidlItem)
{
    HTREEITEM htiParent;

    if ((pidlItem == NULL) || (pbfsf == NULL))
        return NULL;

    // Need to handle the root case here!
    htiParent = TreeView_GetParent(pbfsf->hwndTree, hti);
    if ((htiParent != pbfsf->htiCurParent) || (pbfsf->psfParent == NULL))
    {
        LPITEMIDLIST pidl;
        IShellFolder *psfDesktop;

        if (SUCCEEDED(SHGetDesktopFolder(&psfDesktop)))
        {
            if (pbfsf->psfParent)
            {
                if (pbfsf->psfParent != psfDesktop)
                    pbfsf->psfParent->Release();
                pbfsf->psfParent = NULL;
            }

            if (htiParent)
            {
                pidl = _BFSFGetIDListFromTreeItem(pbfsf->hwndTree, htiParent);
            }
            else
            {
                //
                // If No Parent then the item here is one of our roots which
                // should be fully qualified.  So try to get the parent by
                // decomposing the ID.
                //
                LPITEMIDLIST pidlT = (LPITEMIDLIST)ILFindLastID(pidlItem);
                if (pidlT != pidlItem)
                {
                    pidl = ILClone(pidlItem);
                    ILRemoveLastID(pidl);
                    pidlItem = pidlT;
                }
                else
                    pidl = NULL;
            }

            pbfsf->htiCurParent = htiParent;

            // If still NULL then we use root of evil...
            SHBindToObject(psfDesktop, IID_X_PPV_ARG(IShellFolder, pidl, &pbfsf->psfParent));
            ILFree(pidl);
            if (pbfsf->psfParent == NULL)
                return NULL;

            psfDesktop->Release();
        }
    }
    return ILFindLastID(pidlItem);
}

void _BFSFGetDisplayInfo(BFSF *pbfsf, TV_DISPINFO *lpnm)
{
    LPITEMIDLIST pidlItem = (LPITEMIDLIST)lpnm->item.lParam;

    if ((lpnm->item.mask & (TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT | TVIF_CHILDREN)) == 0)
        return; // nothing for us to do here.

    pidlItem = _BFSFUpdateISHCache(pbfsf, lpnm->item.hItem, pidlItem);

    if (pidlItem && pbfsf->psfParent)
    {
        TV_ITEM ti;
        ti.mask = 0;
        ti.hItem = (HTREEITEM)lpnm->item.hItem;

        // They are asking for IconIndex.  See if we can find it now.
        // Once found update their list, such that they wont call us back for
        // it again.
        if (lpnm->item.mask & (TVIF_IMAGE | TVIF_SELECTEDIMAGE))
        {
            // We now need to map the item into the right image index.
            ti.iImage = lpnm->item.iImage = SHMapPIDLToSystemImageListIndex(
                    pbfsf->psfParent, pidlItem, &ti.iSelectedImage);
            // we should save it back away to
            lpnm->item.iSelectedImage = ti.iSelectedImage;
            ti.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
        }
        // Also see if this guy has any child folders
        if (lpnm->item.mask & TVIF_CHILDREN)
        {
            ULONG ulAttrs = SFGAO_HASSUBFOLDER;
            pbfsf->psfParent->GetAttributesOf(1, (LPCITEMIDLIST *) &pidlItem, &ulAttrs);

            ti.cChildren = lpnm->item.cChildren =
                    (ulAttrs & SFGAO_HASSUBFOLDER)? 1 : 0;

            ti.mask |= TVIF_CHILDREN;

        }

        if (lpnm->item.mask & TVIF_TEXT)
        {
            if (SUCCEEDED(DisplayNameOf(pbfsf->psfParent, pidlItem, SHGDN_INFOLDER, lpnm->item.pszText, lpnm->item.cchTextMax)))
            {
                ti.mask |= TVIF_TEXT;
                ti.pszText = lpnm->item.pszText;
            }
            else
            {
                AssertMsg(0, TEXT("The folder %08x that owns pidl %08x rejected it!"),
                          pbfsf, pidlItem);
                // Oh well - display a blank name and hope for the best.
            }
        }

        // Update the item now
        ti.mask |= TVIF_DI_SETITEM;
    }
}

void DlgEnableOk(HWND hwndDlg, LPARAM lParam)
{
    EnableWindow(GetDlgItem(hwndDlg, IDOK), BOOLFROMPTR(lParam));
    return;
}

void _BFSFHandleSelChanged(BFSF *pbfsf, LPNM_TREEVIEW lpnmtv)
{
    LPITEMIDLIST pidl;

    // We only need to do anything if we only want to return File system
    // level objects.
    if ((pbfsf->ulFlags & (BIF_RETURNONLYFSDIRS | BIF_RETURNFSANCESTORS | BIF_BROWSEFORPRINTER | BIF_BROWSEFORCOMPUTER)) == 0)
        goto NotifySelChange;

    // We need to get the attributes of this object...
    pidl = _BFSFUpdateISHCache(pbfsf, lpnmtv->itemNew.hItem,
            (LPITEMIDLIST)lpnmtv->itemNew.lParam);

    if (pidl && pbfsf->psfParent)
    {
        BOOL fEnable = TRUE;

        BYTE bType = SIL_GetType(pidl);
        if ((pbfsf->ulFlags & (BIF_RETURNFSANCESTORS|BIF_RETURNONLYFSDIRS)) != 0)
        {

        int i;
        // if this is the root pidl, then do a get attribs on 0
        // so that we'll get the attributes on the root, rather than
        // random returned values returned by FSFolder
        if (ILIsEmpty(pidl)) 
            i = 0;
        else
            i = 1;

        ULONG ulAttrs = SFGAO_FILESYSTEM | SFGAO_FILESYSANCESTOR;

        pbfsf->psfParent->GetAttributesOf(i, (LPCITEMIDLIST *) &pidl, &ulAttrs);

            fEnable = (((ulAttrs & SFGAO_FILESYSTEM) && (pbfsf->ulFlags & BIF_RETURNONLYFSDIRS)) ||
                ((ulAttrs & SFGAO_FILESYSANCESTOR) && (pbfsf->ulFlags & BIF_RETURNFSANCESTORS))) ||
                    ((bType & (SHID_NET | SHID_INGROUPMASK)) == SHID_NET_SERVER);
        }
        else if ((pbfsf->ulFlags & BIF_BROWSEFORCOMPUTER) != 0)
            fEnable = ((bType & (SHID_NET | SHID_INGROUPMASK)) == SHID_NET_SERVER);
        else if ((pbfsf->ulFlags & BIF_BROWSEFORPRINTER) != 0)
        {
            // Printers are of type Share and usage Print...
            fEnable = ((bType & (SHID_NET | SHID_INGROUPMASK)) == SHID_NET_SHARE);
        }

        DlgEnableOk(pbfsf->hwndDlg, fEnable);

    }

NotifySelChange:

    if (pbfsf->ulFlags & BIF_EDITBOX)
    {
        TCHAR szText[MAX_PATH];        // update the edit box
        TVITEM tvi;

        szText[0] = 0;
        tvi.mask = TVIF_TEXT;
        tvi.hItem = lpnmtv->itemNew.hItem;
        tvi.pszText = szText;
        tvi.cchTextMax = ARRAYSIZE(szText);
        TreeView_GetItem(pbfsf->hwndTree, &tvi);
        SetWindowText(pbfsf->hwndEdit, szText);
    }

    if (pbfsf->lpfn)
    {
        pidl = _BFSFGetIDListFromTreeItem(pbfsf->hwndTree, lpnmtv->itemNew.hItem);
        if (pidl)
        {
            BFSFCallback(pbfsf, BFFM_SELCHANGED, (LPARAM)pidl);
            ILFree(pidl);
        }
    }
}

BOOL BrowseSelectPidl(BFSF *pbfsf, LPCITEMIDLIST pidl)
{
    HTREEITEM htiParent;
    LPITEMIDLIST pidlTemp;
    LPITEMIDLIST pidlNext = NULL;
    LPITEMIDLIST pidlParent = NULL;
    BOOL fRet = FALSE;

    htiParent = TreeView_GetChild(pbfsf->hwndTree, NULL);
    if (htiParent) 
    {
        // step through each item of the pidl
        for (;;) 
        {
            TreeView_Expand(pbfsf->hwndTree, htiParent, TVE_EXPAND);
            pidlParent = _BFSFGetIDListFromTreeItem(pbfsf->hwndTree, htiParent);
            if (!pidlParent)
                break;

            pidlNext = ILClone(pidl);
            if (!pidlNext)
                break;

            pidlTemp = ILFindChild(pidlParent, pidlNext);
            if (!pidlTemp)
                break;

            if (ILIsEmpty(pidlTemp)) 
            {
                // found it!
                TreeView_SelectItem(pbfsf->hwndTree, htiParent);
                fRet = TRUE;
                break;
            } 
            else 
            {
                // loop to find the next item
                HTREEITEM htiChild;

                pidlTemp = ILGetNext(pidlTemp);
                if (!pidlTemp)
                    break;
                else
                    pidlTemp->mkid.cb = 0;


                htiChild = TreeView_GetChild(pbfsf->hwndTree, htiParent);
                while (htiChild) 
                {
                    BOOL fEqual;
                    pidlTemp = _BFSFGetIDListFromTreeItem(pbfsf->hwndTree, htiChild);
                    if (!pidlTemp) 
                    {
                        htiChild = NULL;
                        break;
                    }
                    fEqual = ILIsEqual(pidlTemp, pidlNext);

                    ILFree(pidlTemp);
                    if (fEqual) 
                    {
                        break;
                    }
                    else 
                    {
                        htiChild = TreeView_GetNextSibling(pbfsf->hwndTree, htiChild);
                    }
                }

                if (!htiChild) 
                {
                    // we didn't find the next one... bail
                    break;
                }
                else 
                {
                    // the found child becomes the next parent
                    htiParent = htiChild;
                    ILFree(pidlParent);
                    ILFree(pidlNext);
                }
            }
        }
    }

    if (pidlParent) ILFree(pidlParent);
    if (pidlNext) ILFree(pidlNext);
    return fRet;
}

//===========================================================================
// _BrowseForFolderOnBFSFInitDlg - Process the init dialog
//===========================================================================
BOOL _BrowseForFolderOnBFSFInitDlg(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    HTREEITEM hti;
    BFSF *pbfsf = (BFSF *)lParam;
    HIMAGELIST himl;
    LPTSTR lpsz;
    TCHAR szTitle[80];    // no title should be bigger than this!
    HWND hwndTree;

    lpsz = ResourceCStrToStr(HINST_THISDLL, pbfsf->lpszTitle);
    SetDlgItemText(hwnd, IDD_BROWSETITLE, lpsz);
    if (lpsz != pbfsf->lpszTitle)
    {
        LocalFree(lpsz);
        lpsz = NULL;
    }

    if(!(IS_WINDOW_RTL_MIRRORED(pbfsf->hwndOwner)))
    {
        SHSetWindowBits(hwnd, GWL_EXSTYLE, RTL_MIRRORED_WINDOW, 0);
    }
    SetWindowLongPtr(hwnd, DWLP_USER, lParam);
    pbfsf->hwndDlg = hwnd;
    hwndTree = pbfsf->hwndTree = GetDlgItem(hwnd, IDD_FOLDERLIST);

    if (hwndTree)
    {
        UINT swpFlags = SWP_FRAMECHANGED | SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER
                | SWP_NOACTIVATE;
        RECT rc;
        POINT pt = {0,0};

        GetClientRect(hwndTree, &rc);
        MapWindowPoints(hwndTree, hwnd, (POINT*)&rc, 2);
        pbfsf->hwndEdit = GetDlgItem(hwnd, IDD_BROWSEEDIT);

        if (!(pbfsf->ulFlags & BIF_STATUSTEXT))
        {
            HWND hwndStatus = GetDlgItem(hwnd, IDD_BROWSESTATUS);
            // nuke the status window
            ShowWindow(hwndStatus, SW_HIDE);
            MapWindowPoints(hwndStatus, hwnd, &pt, 1);
            rc.top = pt.y;
            swpFlags =  SWP_FRAMECHANGED | SWP_NOZORDER | SWP_NOACTIVATE;
        }

        if (pbfsf->ulFlags & BIF_EDITBOX)
        {
            RECT rcT;
            GetClientRect(pbfsf->hwndEdit, &rcT);
            SetWindowPos(pbfsf->hwndEdit, NULL, rc.left, rc.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
            rc.top += (rcT.bottom - rcT.top) + GetSystemMetrics(SM_CYEDGE) * 4;
            swpFlags =  SWP_FRAMECHANGED | SWP_NOZORDER | SWP_NOACTIVATE;
            SHAutoComplete(GetDlgItem(hwnd, IDD_BROWSEEDIT), (SHACF_FILESYSTEM | SHACF_URLALL | SHACF_FILESYS_ONLY));
        }
        else
        {
            DestroyWindow(pbfsf->hwndEdit);
            pbfsf->hwndEdit = NULL;
        }

        Shell_GetImageLists(NULL, &himl);
        TreeView_SetImageList(hwndTree, himl, TVSIL_NORMAL);

        SetWindowLongPtr(hwndTree, GWL_EXSTYLE,
                GetWindowLongPtr(hwndTree, GWL_EXSTYLE) | WS_EX_CLIENTEDGE);

        // Now try to get this window to know to recalc
        SetWindowPos(hwndTree, NULL, rc.left, rc.top,
                     rc.right - rc.left, rc.bottom - rc.top, swpFlags);

    }

    // If they passed in a root, add it, else add the contents of the
    // Root of evil... to the list as ROOT objects.
    if (pbfsf->pidlRoot)
    {
        LPITEMIDLIST pidl;
        if (IS_INTRESOURCE(pbfsf->pidlRoot)) 
        {
            pidl = SHCloneSpecialIDList(NULL, PtrToUlong((void *)pbfsf->pidlRoot), TRUE);
        }
        else 
        {
            pidl = ILClone(pbfsf->pidlRoot);
        }
        // Now lets insert the Root object
        hti = _BFSFAddItemToTree(hwndTree, TVI_ROOT, pidl, 1);
        // Still need to expand below this point. to the starting location
        // That was passed in. But for now expand the first level.
        TreeView_Expand(hwndTree, hti, TVE_EXPAND);
    }
    else
    {
        LPITEMIDLIST pidlDesktop = SHCloneSpecialIDList(NULL, CSIDL_DESKTOP, FALSE);
        HTREEITEM htiRoot = _BFSFAddItemToTree(hwndTree, TVI_ROOT, pidlDesktop, 1);
        BOOL bFoundDrives = FALSE;

        // Expand the first level under the desktop
        TreeView_Expand(hwndTree, htiRoot, TVE_EXPAND);

        // Lets Preexpand the Drives portion....
        hti = TreeView_GetChild(hwndTree, htiRoot);
        while (hti && !bFoundDrives)
        {
            LPITEMIDLIST pidl = _BFSFGetIDListFromTreeItem(hwndTree, hti);
            if (pidl)
            {
                LPITEMIDLIST pidlDrives = SHCloneSpecialIDList(NULL, CSIDL_DRIVES, FALSE);
                if (pidlDrives)
                {
                    bFoundDrives = ILIsEqual(pidl, pidlDrives);
                    if (bFoundDrives)
                    {
                        TreeView_Expand(hwndTree, hti, TVE_EXPAND);
                        TreeView_SelectItem(hwndTree, hti);
                    }
                    ILFree(pidlDrives);
                }
                ILFree(pidl);
            }
            hti = TreeView_GetNextSibling(hwndTree, hti);
        }
    }

    // go to our internal selection changed code to do any window enabling needed
    {
        NM_TREEVIEW nmtv;
        hti = TreeView_GetSelection(hwndTree);
        if (hti) 
        {
            TV_ITEM ti;
            ti.mask = TVIF_PARAM;
            ti.hItem = hti;
            TreeView_GetItem(hwndTree, &ti);
            nmtv.itemNew.hItem = hti;
            nmtv.itemNew.lParam = ti.lParam;

            _BFSFHandleSelChanged(pbfsf, &nmtv);
        }
    }

    if ((pbfsf->ulFlags & BIF_BROWSEFORCOMPUTER) != 0)
    {
        LoadString(HINST_THISDLL, IDS_FINDSEARCH_COMPUTER, szTitle, ARRAYSIZE(szTitle));
        SetWindowText(hwnd, szTitle);
    }
    else if ((pbfsf->ulFlags & BIF_BROWSEFORPRINTER) != 0)
    {
        LoadString(HINST_THISDLL, IDS_FINDSEARCH_PRINTER, szTitle, ARRAYSIZE(szTitle));
        SetWindowText(hwnd, szTitle);
    }

    BFSFCallback(pbfsf, BFFM_INITIALIZED, 0);

    return TRUE;
}


//
// Called when a ANSI app sends BFFM_SETSTATUSTEXT message.
//
void _BFSFSetStatusTextA(BFSF *pbfsf, LPCSTR lpszText)
{
    CHAR szText[100];
    if (IS_INTRESOURCE(lpszText)) 
    {
        LoadStringA(HINST_THISDLL, LOWORD((DWORD_PTR)lpszText), szText, ARRAYSIZE(szText));
        lpszText = szText;
    }

    SetDlgItemTextA(pbfsf->hwndDlg, IDD_BROWSESTATUS, lpszText);
}

// UNICODE BFFM_SETSTATUSTEXT message.

void _BFSFSetStatusTextW(BFSF *pbfsf, LPCWSTR lpszText)
{
    WCHAR szText[100];
    if (IS_INTRESOURCE(lpszText)) 
    {
        LoadStringW(HINST_THISDLL, LOWORD((DWORD_PTR)lpszText), szText, ARRAYSIZE(szText));
        lpszText = szText;
    }

    SetDlgItemTextW(pbfsf->hwndDlg, IDD_BROWSESTATUS, lpszText);
}

// ANSI BFFM_SETSELECTION message.

BOOL _BFSFSetSelectionA(BFSF *pbfsf, BOOL blParamIsPath, LPARAM lParam)
{
    if (blParamIsPath)
    {
        TCHAR szPath[MAX_PATH];
        SHAnsiToTChar((LPCSTR)lParam, szPath, ARRAYSIZE(szPath));
        lParam = (LPARAM)SHSimpleIDListFromPath(szPath);
        if (!lParam)
            return FALSE;  // Failed pidl creation.
    }

    BOOL fRet = BrowseSelectPidl(pbfsf, (LPITEMIDLIST)lParam);

    if (blParamIsPath)
        ILFree((LPITEMIDLIST)lParam);

    return fRet;
}

// UNICODE BFFM_SETSELECTION message.

BOOL _BFSFSetSelectionW(BFSF *pbfsf, BOOL blParamIsPath, LPARAM lParam)
{
    if (blParamIsPath)
    {
        lParam = (LPARAM)SHSimpleIDListFromPath((LPCTSTR)lParam);
        if (!lParam)
            return FALSE;   // Failed pidl creation.
    }

    BOOL fRet = BrowseSelectPidl(pbfsf, (LPITEMIDLIST)lParam);

    if (blParamIsPath)
        ILFree((LPITEMIDLIST)lParam);

    return fRet;
}

// Called when an app sends BFFM_SETOKTEXT message.
void _BFSFSetOkText(BFSF *pbfsf, LPCTSTR pszText)
{
    LPTSTR psz = ResourceCStrToStr(HINST_THISDLL, pszText);
    SetDlgItemText(pbfsf->hwndDlg, IDOK, psz);
    if (psz != pszText)
        LocalFree(psz);
}

// Process the WM_COMMAND message
void _BrowseOnCommand(BFSF *pbfsf, int id, HWND hwndCtl, UINT codeNotify)
{
    HTREEITEM hti;

    switch (id)
    {
    case IDD_BROWSEEDIT:
        if (codeNotify == EN_CHANGE)
        {
            TCHAR szBuf[4];     // (arb. size, anything > 2)

            szBuf[0] = 1;       // if Get fails ('impossible'), enable OK
            GetDlgItemText(pbfsf->hwndDlg, IDD_BROWSEEDIT, szBuf,
                    ARRAYSIZE(szBuf));
            DlgEnableOk(pbfsf->hwndDlg, (WPARAM)(BOOL)szBuf[0]);
        }
        break;

    case IDOK:
    {
        TV_ITEM tvi;
        TCHAR szText[MAX_PATH];
        BOOL fDone = TRUE;

        // We can now update the structure with the idlist of the item selected
        hti = TreeView_GetSelection(pbfsf->hwndTree);
        pbfsf->pidlCurrent = _BFSFGetIDListFromTreeItem(pbfsf->hwndTree,
                hti);

        tvi.mask = TVIF_TEXT | TVIF_IMAGE;
        tvi.hItem = hti;
        tvi.pszText = pbfsf->pszDisplayName;
        if (!tvi.pszText)
            tvi.pszText = szText;
        tvi.cchTextMax = MAX_PATH;
        TreeView_GetItem(pbfsf->hwndTree, &tvi);

        if (pbfsf->ulFlags & BIF_EDITBOX)
        {
            TCHAR szEditTextRaw[MAX_PATH];
            TCHAR szEditText[MAX_PATH];

            GetWindowText(pbfsf->hwndEdit, szEditTextRaw, ARRAYSIZE(szEditTextRaw));
            SHExpandEnvironmentStrings(szEditTextRaw, szEditText, ARRAYSIZE(szEditText));

            if (lstrcmpi(szEditText, tvi.pszText))
            {
                // the two are different, we need to get the user typed one
                LPITEMIDLIST pidl;
                if (SUCCEEDED(SHParseDisplayName(szEditText, NULL, &pidl, 0, NULL)))
                {
                    ILFree(pbfsf->pidlCurrent);
                    pbfsf->pidlCurrent = pidl;
                    lstrcpy(tvi.pszText, szEditText);
                    tvi.iImage = -1;
                }
                else if (pbfsf->ulFlags & BIF_VALIDATE)
                {
                    LPARAM lParam;
                    char szAnsi[MAX_PATH];

                    ASSERTMSG(pbfsf->lpfn != NULL, "No BrowseCallbackProc supplied with BIF_VALIDATE flag");
                    // n.b. we free everything up, not callback (fewer bugs...)
                    ILFree(pbfsf->pidlCurrent);
                    pbfsf->pidlCurrent = NULL;
                    tvi.pszText[0] = 0;
                    tvi.iImage = -1;
                    lParam = (LPARAM)szEditText;
                    if (!pbfsf->fUnicode)
                    {
                        SHUnicodeToAnsi(szEditText, szAnsi, ARRAYSIZE(szAnsi));
                        lParam = (LPARAM)szAnsi;
                    }
                    // 0:EndDialog, 1:continue
                    fDone = BFSFCallback(pbfsf, pbfsf->fUnicode ? BFFM_VALIDATEFAILEDW : BFFM_VALIDATEFAILEDA, lParam) == 0;
                }
                // else old behavior: hand back last-clicked pidl (even
                // though it doesn't match editbox text!)
            }
        }

        if (pbfsf->piImage)
            *pbfsf->piImage = tvi.iImage;
        if (fDone)
            EndDialog(pbfsf->hwndDlg, TRUE);        // To return TRUE.
        break;
    }
    case IDCANCEL:
        EndDialog(pbfsf->hwndDlg, 0);     // to return FALSE from this.
        break;
    }
}

const static DWORD aBrowseHelpIDs[] = {  // Context Help IDs
    IDD_BROWSETITLE,        NO_HELP,
    IDD_BROWSESTATUS,       NO_HELP,
    IDD_FOLDERLABLE,        NO_HELP,
    IDD_BROWSEEDIT,         IDH_DISPLAY_FOLDER,
    IDD_BFF_RESIZE_TAB,     NO_HELP,
    IDD_NEWFOLDER_BUTTON,   IDH_CREATE_NEW_FOLDER,
    IDD_FOLDERLIST,         IDH_BROWSELIST,

    0, 0
};

BOOL_PTR CALLBACK _BrowseDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BFSF *pbfsf = (BFSF *)GetWindowLongPtr(hwndDlg, DWLP_USER);

    switch (msg) 
    {
    HANDLE_MSG(pbfsf, WM_COMMAND, _BrowseOnCommand);

    case WM_INITDIALOG:
        return (BOOL)HANDLE_WM_INITDIALOG(hwndDlg, wParam, lParam, _BrowseForFolderOnBFSFInitDlg);

    case WM_DESTROY:
        if (pbfsf && pbfsf->psfParent)
        {
            IShellFolder *psfDesktop;
            SHGetDesktopFolder(&psfDesktop);
            if (pbfsf->psfParent != psfDesktop)
            {
                pbfsf->psfParent->Release();
                pbfsf->psfParent = NULL;
            }
        }
        break;

    case BFFM_SETSTATUSTEXTA:
        _BFSFSetStatusTextA(pbfsf, (LPCSTR)lParam);
        break;

    case BFFM_SETSTATUSTEXTW:
        _BFSFSetStatusTextW(pbfsf, (LPCWSTR)lParam);
        break;

    case BFFM_SETSELECTIONW:
        return _BFSFSetSelectionW(pbfsf, (BOOL)wParam, lParam);

    case BFFM_SETSELECTIONA:
        return _BFSFSetSelectionA(pbfsf, (BOOL)wParam, lParam);

    case BFFM_ENABLEOK:
        DlgEnableOk(hwndDlg, lParam);
        break;

    case BFFM_SETOKTEXT:
        _BFSFSetOkText(pbfsf, (LPCTSTR)lParam);
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code)
        {
        case TVN_GETDISPINFOA:
        case TVN_GETDISPINFOW:
            _BFSFGetDisplayInfo(pbfsf, (TV_DISPINFO *)lParam);
            break;

        case TVN_ITEMEXPANDINGA:
        case TVN_ITEMEXPANDINGW:
            SetCursor(LoadCursor(NULL, IDC_WAIT));
            _BFSFHandleItemExpanding(pbfsf, (LPNM_TREEVIEW)lParam);
            break;
        case TVN_ITEMEXPANDEDA:
        case TVN_ITEMEXPANDEDW:
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            break;
        case TVN_DELETEITEMA:
        case TVN_DELETEITEMW:
            _BFSFHandleDeleteItem(pbfsf, (LPNM_TREEVIEW)lParam);
            break;
        case TVN_SELCHANGEDA:
        case TVN_SELCHANGEDW:
            _BFSFHandleSelChanged(pbfsf, (LPNM_TREEVIEW)lParam);
            break;
        }
        break;

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL,
            HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aBrowseHelpIDs);
        break;

    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU, (ULONG_PTR)(void *) aBrowseHelpIDs);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


// Flags for _OnPidlNavigation()
#define     SHBFFN_NONE                 0x00000000  //
#define     SHBFFN_FIRE_SEL_CHANGE      0x00000001  //
#define     SHBFFN_UPDATE_TREE          0x00000002  //
#define     SHBFFN_STRICT_PARSING       0x00000004  //
#define     SHBFFN_DISPLAY_ERRORS       0x00000008  // If the parse fails, display an error dialog to inform the user.


/***********************************************************************\
    DESCRIPTION:
        The API SHBrowseForFolder will now be able to act differently
    if a callback function isn't provided or the caller specified a flag
    to use the new UI.  We can't rev the old UI because so many 3rd parties
    hack on it that we would break them.  Therefore, we leave the code
    above this point alone and use the code below if and only if we know
    we won't break a 3rd party hacking on our dialog.

  NOTES:
    _pidlSelected/_fEditboxDirty: This is used to keep track of what
        is most up to date, the editbox or the TreeView.
\***********************************************************************/
#define WNDPROP_CBrowseForFolder TEXT("WNDPROP_CBrowseForFolder_THIS")

class CBrowseForFolder : public IFolderFilter
                         , public IFolderFilterSite
{
public:
    LPITEMIDLIST DisplayDialog(BFSF * pbfsf);

    // *** IUnknown ***
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // *** IFolderFilter methods ***
    STDMETHODIMP ShouldShow(IShellFolder* psf, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlItem) {return _ShouldShow(psf, pidlFolder, pidlItem, FALSE);};
    STDMETHODIMP GetEnumFlags(IShellFolder* psf, LPCITEMIDLIST pidlFolder, HWND *phwnd, DWORD *pgrfFlags);

    // *** IFolderFilterSite methods ***
    STDMETHODIMP SetFilter(IUnknown* punk);

    CBrowseForFolder(void);
    ~CBrowseForFolder(void);

private:
    // Private Methods
    BOOL_PTR _DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _NameSpaceWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL _CreateNewFolder(HWND hDlg);
    BOOL _OnCreateNameSpace(HWND hwnd);
    BOOL _OnOK(void);
    void _OnNotify(LPNMHDR pnm);
    BOOL_PTR _OnCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify);
    HRESULT _InitAutoComplete(HWND hwndEdit);
    HRESULT _OnInitDialog(HWND hwnd);
    HRESULT _OnInitSize(HWND hwnd);
    HRESULT _OnLoadSize(HWND hwnd);
    HRESULT _OnSaveSize(HWND hwnd);
    HRESULT _OnSizeDialog(HWND hwnd, DWORD dwWidth, DWORD dwHeight);
    HDWP _SizeControls(HWND hwnd, HDWP hdwp, RECT rcTree, int dx, int dy);
    HRESULT _SetDialogSize(HWND hwnd, DWORD dwWidth, DWORD dwHeight);
    BOOL_PTR _OnGetMinMaxInfo(MINMAXINFO * pMinMaxInfo);

    HRESULT _ProcessEditChangeOnOK(BOOL fUpdateTree);
    HRESULT _OnTreeSelectChange(DWORD dwFlags);
    HRESULT _OnSetSelectPathA(LPCSTR pszPath);
    HRESULT _OnSetSelectPathW(LPCWSTR pwzPath);
    HRESULT _OnSetSelectPidl(LPCITEMIDLIST pidl);
    HRESULT _OnSetExpandedPath(LPCTSTR pszPath);
    HRESULT _OnSetExpandedPidl(LPCITEMIDLIST pidl);
    HRESULT _OnPidlNavigation(LPCITEMIDLIST pidl, DWORD dwFlags);
    HRESULT _OfferToPrepPath(OUT LPTSTR szPath, IN DWORD cchSize);

    HRESULT _InitFilter(void);
    HRESULT _DoesMatchFilter(IShellFolder* psf, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlChild, BOOL fStrict);
    HRESULT _FilterThisFolder(LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlChild);
    BOOL _DoesFilterAllow(LPCITEMIDLIST pidl, BOOL fStrictParsing);
    HRESULT _ShouldShow(IShellFolder* psf, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlItem, BOOL fStrict);

    // Private Member Variables
    LONG                        _cRef;

    INSCTree *                  _pns;
    IWinEventHandler *          _pweh;
    IPersistFolder *            _ppf;      // AutoComplete's interface to set the current working directory for AC.
    LPITEMIDLIST                _pidlSelected;
    BOOL                        _fEditboxDirty; // Is the editbox the last thing the user modified (over the selection tree).
    HWND                        _hwndTv;        // This is the NSC tree.
    HWND                        _hwndBFF;       // This is our NSC host hwnd.
    HWND                        _hDlg;
    BFSF *                      _pbfsf;
    BOOL                        _fPrinterFilter;
    LPITEMIDLIST                _pidlChildFilter; // If non-NULL, we want to filter all children in this filder. (Including grandchildren)
    IFolderFilter *             _pClientFilter; // A client provided filter.

    // Resize Info
    POINT                       _ptLastSize;      // Sizes in Window Coords
    DWORD                       _dwMinWidth;      // Sizes in Client Coords
    DWORD                       _dwMinHeight;     // Sizes in Client Coords
    int                         _cxGrip;
    int                         _cyGrip;

    static BOOL_PTR CALLBACK BrowseForDirDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK NameSpaceWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

LPITEMIDLIST SHBrowseForFolder2(BFSF * pbfsf)
{
    LPITEMIDLIST pidl = NULL;
    HRESULT hrOle = SHOleInitialize(0);     // The caller may not have inited OLE and we need to CoCreate _pns.
    CBrowseForFolder * pcshbff = new CBrowseForFolder();
    if (pcshbff)
    {
        pidl = pcshbff->DisplayDialog(pbfsf);
        delete pcshbff;
    }

    SHOleUninitialize(hrOle);
    return pidl;
}

CBrowseForFolder::CBrowseForFolder() : _cRef(1)
{
    DllAddRef();
    ASSERT(!_pns);
    ASSERT(!_ppf);
    ASSERT(!_pClientFilter);
}

CBrowseForFolder::~CBrowseForFolder()
{
    ATOMICRELEASE(_pns);
    ATOMICRELEASE(_ppf);
    ATOMICRELEASE(_pweh);
    ATOMICRELEASE(_pClientFilter);

    Pidl_Set(&_pidlSelected, NULL);
    AssertMsg((1 == _cRef), TEXT("CBrowseForFolder isn't a real COM object, but let's make sure people RefCount us like one."));
    _FilterThisFolder(NULL, NULL);

    DllRelease();
}


LPITEMIDLIST CBrowseForFolder::DisplayDialog(BFSF * pbfsf)
{
    _pbfsf = pbfsf;
    HRESULT hr = (HRESULT) DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_BROWSEFORFOLDER2), pbfsf->hwndOwner, BrowseForDirDlgProc, (LPARAM)this);

    return (((S_OK == hr) && _pidlSelected) ? ILClone(_pidlSelected) : NULL);
}


//This WndProc will get the this pointer and call _NameSpaceWndProc() to do all the real work.
// This window proc is for the parent window of the tree control, not the dialog.
LRESULT CALLBACK CBrowseForFolder::NameSpaceWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{   // GWL_USERDATA
    LRESULT lResult = 0;
    CBrowseForFolder * pThis = (CBrowseForFolder *)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (uMsg)
    {
    case WM_CREATE:
    {
        CREATESTRUCT * pcs = (CREATESTRUCT *) lParam;
        pThis = (CBrowseForFolder *)pcs->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)(void*)(CBrowseForFolder*)pThis);
    }
    break;
    }

    // we get a few messages before we get the WM_INITDIALOG (such as WM_SETFONT)
    // and until we get the WM_INITDIALOG we dont have our pmbci pointer, we just
    // return false
    if (pThis)
        lResult = (LRESULT) pThis->_NameSpaceWndProc(hwnd, uMsg, wParam, lParam);
    else
        lResult = DefWindowProc(hwnd, uMsg, wParam, lParam);

    return lResult;
}


// Now that NameSpaceWndProc() gave us our this pointer, let's continue.
// This window proc is for the parent window of the tree control, not the dialog.
LRESULT CBrowseForFolder::_NameSpaceWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;    // 0 means we didn't do anything

    switch (uMsg)
    {
    case WM_CREATE:
        _OnCreateNameSpace(hwnd);
        break;

    case WM_DESTROY:
        IUnknown_SetSite(_pns, NULL);
        break;

    case WM_SETFOCUS:
        SetFocus(_hwndTv);
        break;

    case WM_NOTIFY:
        _OnNotify((LPNMHDR)lParam);
        // Fall Thru...
    case WM_SYSCOLORCHANGE:
    case WM_WININICHANGE:
    case WM_PALETTECHANGED:
        if (_pweh)
            _pweh->OnWinEvent(hwnd, uMsg, wParam, lParam, &lResult);
        break;

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return lResult;
}


BOOL_PTR CBrowseForFolder::_OnCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {
    case IDOK:
        if (_OnOK())
        {
            EVAL(SUCCEEDED(_OnSaveSize(hDlg)));
            EndDialog(hDlg, (int) S_OK);
            return TRUE;
        }
        break;

    case IDCANCEL:
        EVAL(SUCCEEDED(_OnSaveSize(hDlg)));
        EndDialog(hDlg, (int) S_FALSE);
        return TRUE;
        break;

    case IDD_BROWSEEDIT:
        if (codeNotify == EN_CHANGE)
            _fEditboxDirty = TRUE;
        break;

    case IDD_NEWFOLDER_BUTTON:
        _CreateNewFolder(hDlg);
        return TRUE;
        break;
    default:
        break;
    }

    return FALSE;
}


// This DlgProc will get the this pointer and call _DlgProc() to do all the real work.
// This window proc is for the dialog.
BOOL_PTR CALLBACK CBrowseForFolder::BrowseForDirDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL_PTR pfResult = FALSE;
    CBrowseForFolder * pThis = (CBrowseForFolder *)GetWindowLongPtr(hDlg, GWLP_USERDATA);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pThis = (CBrowseForFolder *)lParam;
        SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)(void*)(CBrowseForFolder*)pThis);
        pfResult = TRUE;
        break;
    }

    // we get a few messages before we get the WM_INITDIALOG (such as WM_SETFONT)
    // and until we get the WM_INITDIALOG we dont have our pmbci pointer, we just
    // return false
    if (pThis)
        pfResult = pThis->_DlgProc(hDlg, uMsg, wParam, lParam);

    return pfResult;
}


#define WINDOWSTYLES_EX_BFF    (WS_EX_LEFT | WS_EX_LTRREADING)
#define WINDOWSTYLES_BFF    (WS_CHILD | WS_VISIBLE | WS_TABSTOP)

// Now that BrowseForDirDlgProc() gave us our this pointer, let's continue.
// This window proc is for the dialog.
BOOL_PTR CBrowseForFolder::_DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL_PTR pfResult = FALSE;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        EVAL(SUCCEEDED(_OnInitDialog(hDlg)));

        // Give initial focus to the ok button
        pfResult = SetFocus(GetDlgItem(hDlg, IDOK)) == 0;
        // Return FALSE if the ok button got focus.

        break;

    case WM_SIZE:
        EVAL(SUCCEEDED(_OnSizeDialog(hDlg, LOWORD(lParam), HIWORD(lParam))));
        pfResult = FALSE;
        break;

    case WM_GETMINMAXINFO:
        pfResult = _OnGetMinMaxInfo((MINMAXINFO *) lParam);
        break;

    case WM_CLOSE:
        BFSFCallback(_pbfsf, BFFM_IUNKNOWN, (LPARAM)NULL);
        wParam = IDCANCEL;
        // fall through
    case WM_COMMAND:
        pfResult = _OnCommand(hDlg, (int) LOWORD(wParam), (HWND) lParam, (UINT)HIWORD(wParam));
        break;

    // These BFFM_* messages are sent by the callback proc (_pbfsf->lpfn)
    case BFFM_SETSTATUSTEXTA:
        _BFSFSetStatusTextA(_pbfsf, (LPCSTR)lParam);
        break;

    case BFFM_SETSTATUSTEXTW:
        _BFSFSetStatusTextW(_pbfsf, (LPCWSTR)lParam);
        break;

    case BFFM_SETSELECTIONW:
        if ((BOOL)wParam)
        {
            // Is it a path?
            pfResult = SUCCEEDED(_OnSetSelectPathW((LPCWSTR)lParam));
            break;
        }

        // Fall Thru for pidl case
    case BFFM_SETSELECTIONA:
        if ((BOOL)wParam)
        {
            // Is it a path?
            pfResult = SUCCEEDED(_OnSetSelectPathA((LPCSTR)lParam));
            break;
        }

        // We hit the pidl case.
        pfResult = SUCCEEDED(_OnSetSelectPidl((LPCITEMIDLIST)lParam));
        break;

    case BFFM_SETEXPANDED:
        if ((BOOL)wParam)
        {
            // Is it a path?
            pfResult = SUCCEEDED(_OnSetExpandedPath((LPCTSTR)lParam));
            break;
        }

        // We hit the pidl case.
        pfResult = SUCCEEDED(_OnSetExpandedPidl((LPCITEMIDLIST)lParam));
        break;

    case BFFM_ENABLEOK:
        DlgEnableOk(_hDlg, lParam);
        break;

    case BFFM_SETOKTEXT:
        _BFSFSetOkText(_pbfsf, (LPCTSTR)lParam);
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code)
        {
        case TVN_ITEMEXPANDINGA:
        case TVN_ITEMEXPANDINGW:
            SetCursor(LoadCursor(NULL, IDC_WAIT));
            break;

        case TVN_ITEMEXPANDEDA:
        case TVN_ITEMEXPANDEDW:
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            break;

        case TVN_SELCHANGEDA:
        case TVN_SELCHANGEDW:
            _OnTreeSelectChange(SHBFFN_DISPLAY_ERRORS);
            break;
        }
        break;

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL, HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aBrowseHelpIDs);
        break;

    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU, (ULONG_PTR)(LPTSTR) aBrowseHelpIDs);
        break;
    }

    return pfResult;
}


HRESULT CBrowseForFolder::_OnInitDialog(HWND hwnd)
{
    RECT rcDlg;
    RECT rcTree;
    WNDCLASS wc = {0};
    LONG lTreeBottom = 0;

    wc.style         = CS_PARENTDC;
    wc.lpfnWndProc   = NameSpaceWndProc;
    wc.hInstance     = HINST_THISDLL;
    wc.lpszClassName = CLASS_NSC;
    SHRegisterClass(&wc);

    _pbfsf->hwndDlg = hwnd;
    _hDlg = hwnd;

    GetWindowRect(GetDlgItem(hwnd, IDD_FOLDERLIST), &rcTree);

    // cannot have both at the same time...
    if ((_pbfsf->ulFlags & (BIF_UAHINT | BIF_EDITBOX)) == (BIF_UAHINT | BIF_EDITBOX))
        _pbfsf->ulFlags &= ~BIF_UAHINT;
    
    if (_pbfsf->ulFlags & BIF_NONEWFOLDERBUTTON)
    {
        EnableWindow(GetDlgItem(hwnd, IDD_NEWFOLDER_BUTTON), FALSE);
        ShowWindow(GetDlgItem(hwnd, IDD_NEWFOLDER_BUTTON), SW_HIDE);
    }

    // Hide the edit box (or hide the UA hint if the edit box is enabled)
    if (!(_pbfsf->ulFlags & BIF_EDITBOX))
    {
        // Hide the edit box
        HWND hwndBrowseEdit = GetDlgItem(hwnd, IDD_BROWSEEDIT);
        HWND hwndBrowseEditLabel = GetDlgItem(hwnd, IDD_FOLDERLABLE);

        EnableWindow(hwndBrowseEdit, FALSE);
        EnableWindow(hwndBrowseEditLabel, FALSE);
        ShowWindow(hwndBrowseEdit, SW_HIDE);
        ShowWindow(hwndBrowseEditLabel, SW_HIDE);

        // Bottom of tree
        RECT rcEdit;
        GetWindowRect(hwndBrowseEdit, &rcEdit);
        lTreeBottom = rcEdit.bottom;
    }

    if (!(_pbfsf->ulFlags & BIF_UAHINT))
    {
        // Hide the UA hint
        HWND hwndBrowseInstruction = GetDlgItem(hwnd, IDD_BROWSEINSTRUCTION);
        EnableWindow(hwndBrowseInstruction, FALSE);
        ShowWindow(hwndBrowseInstruction, SW_HIDE);
    }

    if (!(_pbfsf->ulFlags & (BIF_EDITBOX | BIF_UAHINT)))
    {
        // Neither a UA hint nor an edit box.
        // Increase the size of the tree
        rcTree.bottom = lTreeBottom;
    }

    EnableWindow(GetDlgItem(hwnd, IDD_FOLDERLIST), FALSE);
    ShowWindow(GetDlgItem(hwnd, IDD_FOLDERLIST), SW_HIDE);
    EVAL(MapWindowPoints(HWND_DESKTOP, hwnd, (LPPOINT)&rcTree, 2));
    _hwndBFF = CreateWindowEx(WINDOWSTYLES_EX_BFF, CLASS_NSC, NULL, WINDOWSTYLES_BFF, rcTree.left, rcTree.top, RECTWIDTH(rcTree), RECTHEIGHT(rcTree), hwnd, NULL, HINST_THISDLL, (void *)this);
    ASSERT(_hwndBFF);

    // Make sure the NSCTree is the first focusable control after the title static control,
    // so that an accelerator in the title will give focus to the NSCTree.
    SetWindowPos(_hwndBFF, GetDlgItem(hwnd, IDD_FOLDERLIST), 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);

    LPTSTR psz = ResourceCStrToStr(HINST_THISDLL, _pbfsf->lpszTitle);
    if (psz)
    {
        SetWindowText(GetDlgItem(hwnd, IDD_BROWSETITLE), psz);
        if (psz != _pbfsf->lpszTitle)
            LocalFree(psz);
    }

    _InitAutoComplete(GetDlgItem(hwnd, IDD_BROWSEEDIT));
    BFSFCallback(_pbfsf, BFFM_INITIALIZED, 0);
    BFSFCallback(_pbfsf, BFFM_IUNKNOWN, (LPARAM)SAFECAST(this, IFolderFilter *));

    GetClientRect(hwnd, &rcDlg);

    // Get the size of the gripper and position it.
    _cxGrip = GetSystemMetrics(SM_CXVSCROLL);
    _cyGrip = GetSystemMetrics(SM_CYHSCROLL);

    _dwMinWidth = RECTWIDTH(rcDlg);      // Sizes in Client Coords
    _dwMinHeight = RECTHEIGHT(rcDlg);

    GetWindowRect(hwnd, &rcDlg);      // _ptLastSize sizes in Window Coords
    _ptLastSize.x = RECTWIDTH(rcDlg);  // This will force a resize for the first time.
    _ptLastSize.y = RECTHEIGHT(rcDlg);  // This will force a resize for the first time.

    if ((_pbfsf->ulFlags & BIF_BROWSEFORPRINTER) != 0)
    {
        TCHAR szTitle[80];
        LoadString(HINST_THISDLL, IDS_FINDSEARCH_PRINTER, szTitle, ARRAYSIZE(szTitle));
        SetWindowText(hwnd, szTitle);
    }

    if (S_OK != _OnLoadSize(hwnd))  // Set the dialog size.
        _OnInitSize(hwnd);

    return S_OK;
}

HRESULT TranslateCloneOrDefault(LPCITEMIDLIST pidl, UINT csidl, LPITEMIDLIST *ppidl)
{
    HRESULT hr;
    if (pidl)
    {
        // map into friendly part of the name space
        hr = SHILAliasTranslate(pidl, ppidl, XLATEALIAS_ALL); 
        if (FAILED(hr))
            hr = SHILClone(pidl, ppidl);
    }
    else
    {
        hr = SHGetFolderLocation(NULL, csidl, NULL, 0, ppidl);
    }
    return hr;
}


BOOL CBrowseForFolder::_OnCreateNameSpace(HWND hwnd)
{
    HRESULT hr = CoCreateInstance(CLSID_NSCTree, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(INSCTree, &_pns));
    if (SUCCEEDED(hr))
    {
        RECT rc;
        DWORD shcontf = SHCONTF_FOLDERS;

        IFolderFilterSite *psffs;
        hr = _pns->QueryInterface(IID_PPV_ARG(IFolderFilterSite, &psffs));
        if (SUCCEEDED(hr))
        {
            hr = psffs->SetFilter(SAFECAST(this, IFolderFilter *));
            psffs->Release();
        }

        _pns->SetNscMode(0);    // 0 == Tree
        _hwndTv = NULL;
        DWORD dwStyle = WS_HSCROLL, dwExStyle = 0;

        // ifdef'd out the following section of code until we can resolve the following problem:
        // A TVS_SINGLEEXPAND tree expands selections even if they are done programatically. This
        // results in My Documents, and any other selections by the client, expanding those nodes.
        if (SHRegGetBoolUSValue(TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"), 
            TEXT("FriendlyTree"), FALSE, TRUE))
        {
            dwStyle |= TVS_HASBUTTONS | TVS_SINGLEEXPAND | TVS_TRACKSELECT;
            dwExStyle |= TVS_EX_NOSINGLECOLLAPSE;
        }
        else
        {
            dwStyle |= TVS_HASBUTTONS | TVS_HASLINES;
        }

        INSCTree2 *pns2;
        if (dwExStyle && SUCCEEDED(_pns->QueryInterface(IID_PPV_ARG(INSCTree2, &pns2))))
        {
            pns2->CreateTree2(hwnd, dwStyle, dwExStyle, &_hwndTv);
            pns2->Release();
        }
        else
        {
            _pns->CreateTree(hwnd, dwStyle, &_hwndTv);
        }
        _pns->QueryInterface(IID_PPV_ARG(IWinEventHandler, &_pweh));

        LPTSTR psz = ResourceCStrToStr(HINST_THISDLL, _pbfsf->lpszTitle);
        if (psz)
        {
            SetWindowText(_hwndTv, psz);
            if (psz != _pbfsf->lpszTitle)
                LocalFree(psz);
        }

        // Turn on the ClientEdge
        SetWindowBits(_hwndTv, GWL_EXSTYLE, WS_EX_CLIENTEDGE, WS_EX_CLIENTEDGE);
#define SIZE_ZOOM       1

        // Show the ClientEdge
        GetWindowRect(_hwndTv, &rc);
        MapWindowRect(NULL, GetParent(_hwndTv), &rc);
        InflateRect(&rc, (- SIZE_ZOOM * GetSystemMetrics(SM_CXEDGE)), (- SIZE_ZOOM * GetSystemMetrics(SM_CYEDGE)));
        SetWindowPos(_hwndTv, NULL, rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc), SWP_NOZORDER);
        _InitFilter();

        if (_pbfsf->ulFlags & BIF_BROWSEFORPRINTER)
        {
            shcontf |= SHCONTF_NONFOLDERS;
        }

        if (_pbfsf->ulFlags & BIF_BROWSEINCLUDEFILES)
        {
            shcontf |= SHCONTF_NONFOLDERS;
        }

        if (_pbfsf->fShowAllObjects)
        {
            shcontf |= SHCONTF_INCLUDEHIDDEN;
        }

        LPITEMIDLIST pidlRoot;
        TranslateCloneOrDefault(_pbfsf->pidlRoot, CSIDL_DESKTOP, &pidlRoot);

        _pns->Initialize(pidlRoot, shcontf, NSS_DROPTARGET);
        if (!_pbfsf->pidlRoot)
        {
            LPITEMIDLIST pidl;
            if (SUCCEEDED(SHGetFolderLocation(NULL, CSIDL_PERSONAL, NULL, 0, &pidl)))
            {
                _pns->SetSelectedItem(pidl, TRUE, FALSE, 0);
                ILFree(pidl);
            }
        }

        ILFree(pidlRoot);

        _pns->ShowWindow(TRUE);
        _OnTreeSelectChange(SHBFFN_UPDATE_TREE | SHBFFN_NONE);
    }

    return TRUE;
}


// returns:
//      TRUE    - close the dialog
//      FALSE   - keep it up

BOOL CBrowseForFolder::_OnOK(void)
{
    HRESULT hr = S_OK;

    if (_pns)
    {
        // We get the <ENTER> event even if it was pressed while in editbox in a rename in
        // the tree.  Is that the case now?
        if (_pns->InLabelEdit())
            return FALSE;   // Yes, so just bail.

        // Was IDD_BROWSEEDIT modified more recently than the selection in the tree?
        if (_fEditboxDirty)
        {
            // No, so _ProcessEditChangeOnOK() will update _pidlSelected with what's in the editbox.
            // SUCCEEDED(hr)->EndDialog, FAILED(hr)->continue

            // NOTE: FALSE means don't update the tree (since the dialog is closing)
            hr = _ProcessEditChangeOnOK(FALSE);
        }
        else
        {
            // The user may have just finished editing the name of a newly created folder
            // and NSC didn't tell use the pidl changes because of the rename. NT #377453.
            // Therefore, we just update the pidl before we leave.
            hr = _OnTreeSelectChange(SHBFFN_NONE);
        }

        if (SUCCEEDED(hr))
        {
            if (_pbfsf->pszDisplayName && _pidlSelecte