ager
    HIMAGELIST              himl;                   // imagelist for Zones combobox
    HWND                    hwndZones;              // zones combo box hwnd
    LPSECURITYZONESETTINGS  pszs;                   // current settings for displayed zone
    INT                     iZoneSel;               // selected zone (as defined by ComboBox)
    DWORD                   dwZoneCount;            // number of zones
    BOOL                    fChanged;
    BOOL                    fPendingChange;         // to prevent the controls sending multiple sets (for cancel, mostly)
    HINSTANCE               hinstUrlmon;
    BOOL                    fNoEdit;                // hklm lockout of level edit
    BOOL                    fNoAddSites;            // hklm lockout of addsites
    BOOL                    fNoZoneMapEdit;         // hklm lockout of zone map edits
    HFONT                   hfontBolded;            // special bolded font created for the zone title
    BOOL                    fForceUI;               // Force every zone to show ui?
    BOOL                    fDisableAddSites;       // Automatically diable add sites button?
} SECURITYPAGE, *LPSECURITYPAGE;

// structure for Intranet Add Sites
typedef struct tagADDSITESINTRANETINFO {
    HWND hDlg;                                      // handle to window
    BOOL fUseIntranet;                              // Use local defined intranet addresses (in reg)
    BOOL fUseProxyExclusion;                        // Use proxy exclusion list
    BOOL fUseUNC;                                   // Include UNC in intranet
    LPSECURITYPAGE pSec;            
} ADDSITESINTRANETINFO, *LPADDSITESINTRANETINFO;

// structure for Add Sites
typedef struct tagADDSITESINFO {
    HWND hDlg;                                      // handle to window
    BOOL fRequireServerVerification;                // Require Server Verification on sites in zone
    HWND hwndWebSites;                              // handle to list
    HWND hwndAdd;                                   // handle to edit
    TCHAR szWebSite[MAX_ZONE_PATH];                 // text in edit control
    BOOL fRSVOld;
    LPSECURITYPAGE pSec;            
} ADDSITESINFO, *LPADDSITESINFO;

// structure for Custom Settings 
typedef struct tagCUSTOMSETTINGSINFO {
    HWND  hDlg;                                     // handle to window
    HWND hwndTree;

    LPSECURITYPAGE pSec;
    HWND hwndCombo;
    INT iLevelSel;
    IRegTreeOptions *pTO;
    BOOL fUseHKLM;          // get/set settings from HKLM
    DWORD dwJavaPolicy;     // Java policy selected
    BOOL fChanged;
} CUSTOMSETTINGSINFO, *LPCUSTOMSETTINGSINFO;


BOOL SecurityEnableControls(LPSECURITYPAGE pSec, BOOL fSetFocus);
BOOL SecurityDlgApplyNow(LPSECURITYPAGE pSec, BOOL bPrompt);


// global variables
extern DWORD g_dwtlsSecInitFlags;

extern BOOL g_fSecurityChanged; // flag indicating that Active Security has changed.

//////////////////////////////////////////////////////////////////////////////
//
// Main Security Page Helper Functions
//
//////////////////////////////////////////////////////////////////////////////

#define NUM_TEMPLATE_LEVELS      4
TCHAR g_szLevel[3][64];
TCHAR LEVEL_DESCRIPTION0[300];
TCHAR LEVEL_DESCRIPTION1[300];
TCHAR LEVEL_DESCRIPTION2[300];
TCHAR LEVEL_DESCRIPTION3[300];
LPTSTR LEVEL_DESCRIPTION[NUM_TEMPLATE_LEVELS] = {
    LEVEL_DESCRIPTION0,
    LEVEL_DESCRIPTION1,
    LEVEL_DESCRIPTION2,
    LEVEL_DESCRIPTION3
};
TCHAR CUSTOM_DESCRIPTION[300];

TCHAR LEVEL_NAME0[30];
TCHAR LEVEL_NAME1[30];
TCHAR LEVEL_NAME2[30];
TCHAR LEVEL_NAME3[30];
LPTSTR LEVEL_NAME[NUM_TEMPLATE_LEVELS] = {
    LEVEL_NAME0,
    LEVEL_NAME1,
    LEVEL_NAME2,
    LEVEL_NAME3
};
TCHAR CUSTOM_NAME[30];

// Some accessibility related prototypes.

// Our override of the slider window proc. 
LRESULT CALLBACK SliderSubWndProc (HWND hwndSlider, UINT uMsg, WPARAM wParam, LPARAM lParam, WPARAM uID, ULONG_PTR dwRefData );

extern BOOL g_fAttemptedOleAccLoad ;
extern HMODULE g_hOleAcc;


// Can't find value for WM_GETOBJECT in the headers. Need to figure out the right header to include
// here. 
#ifndef WM_GETOBJECT
#define WM_GETOBJECT        0x03d
#endif

// Prototype for CreateStdAccessibleProxy.
// A and W versions are available - pClassName can be ANSI or UNICODE
// string. This is a TCHAR-style prototype, but you can do a A or W
// specific one if desired.
typedef HRESULT (WINAPI *PFNCREATESTDACCESSIBLEPROXY) (
    HWND     hWnd,
    LPTSTR   pClassName,
    LONG     idObject,
    REFIID   riid,
    void **  ppvObject 
    );
/*
 * Arguments:
 *
 * HWND hWnd
 *   Handle of window to return IAccessible for.
 *
 * LPTSTR pClassName
 *   Class name indicating underlying class of the window. For
 *   example, if "LISTBOX" is used here, the returned object will
 *   behave appropriately for a listbox, and will expect the given
 *   hWnd to support listbox messages and styles. This argument
 *   nearly always reflects the window class from which the control
 *   is derived.
 *
 * LONG idObject
 *   Always OBJID_CLIENT
 *
 * REFIID riid
 *   Always IID_IAccessible
 *
 * void ** ppvObject
 *   Out pointer used to return an IAccessible to a newly-created
 *   object which represents the control hWnd as though it were of
 *   window class pClassName.
 *
 * If successful,
 * returns S_OK, *ppvObject != NULL;
 * otherwise returns error HRESULT.
 *
 *
 */



// Same for LresultFromObject...
typedef LRESULT (WINAPI *PFNLRESULTFROMOBJECT)(
    REFIID riid,
    WPARAM wParam,
    LPUNKNOWN punk 
    );


PRIVATE PFNCREATESTDACCESSIBLEPROXY s_pfnCreateStdAccessibleProxy = NULL;
PRIVATE PFNLRESULTFROMOBJECT s_pfnLresultFromObject = NULL;

// Simple accessibility wrapper class which returns the right string values

class CSecurityAccessibleWrapper: public CAccessibleWrapper
{
                // Want to remember the hwnd of the trackbar...
                HWND m_hWnd;
public:
                CSecurityAccessibleWrapper( HWND hWnd, IAccessible * pAcc );
               ~CSecurityAccessibleWrapper();

                STDMETHODIMP get_accValue(VARIANT varChild, BSTR* pszValue);
};

// Ctor - pass through the IAccessible we're wrapping to the
// CAccessibleWrapper base class; also remember the trackbar hwnd.
CSecurityAccessibleWrapper::CSecurityAccessibleWrapper( HWND hWnd, IAccessible * pAcc )
    : CAccessibleWrapper( pAcc ),
      m_hWnd( hWnd )

{
    // Do nothing
}

// Nothing to do here - but if we do need to do cleanup, this is the
// place for it.
CSecurityAccessibleWrapper::~CSecurityAccessibleWrapper()
{
    // Do nothing
}


// Overridden get_accValue method...
STDMETHODIMP   CSecurityAccessibleWrapper::get_accValue(VARIANT varChild, BSTR* pszValue)
{
    // varChild.lVal specifies which sub-part of the component
    // is being queried.
    // CHILDID_SELF (0) specifies the overall component - other
    // non-0 values specify a child.

    // In a trackbar, CHILDID_SELF refers to the overall trackbar
    // (which is what we want), whereas other values refer to the
    // sub-components - the actual slider 'thumb', and the 'page
    // up/page down' areas to the left/right of it.
    if( varChild.vt == VT_I4 && varChild.lVal == CHILDID_SELF )
    {
        // Get the scrollbar value...
        int iPos = (int)SendMessage( m_hWnd, TBM_GETPOS , 0, 0 );

        // Check that it's in range...
        // (It's possible that we may get this request after the
        // trackbar has been created, bu before we've set it to
        // a meaningful value.)
        if( iPos < 0 || iPos >= NUM_TEMPLATE_LEVELS )
        {
            TCHAR rgchUndefined[40];
            int cch = MLLoadString(IDS_TEMPLATE_NAME_UNDEFINED, rgchUndefined, ARRAYSIZE(rgchUndefined));
            if (cch != 0)
            {
                *pszValue = SysAllocString(rgchUndefined);
            }
            else
            {
                // Load String failed, for some reason.
                return HRESULT_FROM_WIN32(GetLastError());
            }
    
        }
        else
        {
            *pszValue = SysAllocString( LEVEL_NAME[iPos]);
        }
        
        // All done!
        return S_OK;

    }
    else
    {
        // Pass requests about the sub-components to the
        // base class (which will forward to the 'original'
        // IAccessible for us).
        return CAccessibleWrapper::get_accValue(varChild, pszValue);
    }
}


// Converting the Security Level DWORD identitifiers to slider levels, and vice versa
int SecLevelToSliderPos(DWORD dwLevel)
{
    switch(dwLevel)
    {
        case URLTEMPLATE_LOW:
            return 3;
        case URLTEMPLATE_MEDLOW:
            return 2;
        case URLTEMPLATE_MEDIUM:
            return 1;
        case URLTEMPLATE_HIGH:
            return 0;        
        case URLTEMPLATE_CUSTOM:
            return -1;            
        default:
            return -2;
    }
}

DWORD SliderPosToSecLevel(int iPos)
{
    switch(iPos)
    {
        case 3:
            return URLTEMPLATE_LOW;
        case 2:
            return URLTEMPLATE_MEDLOW;
        case 1:
            return URLTEMPLATE_MEDIUM;
        case 0:
            return URLTEMPLATE_HIGH;
        default:
            return URLTEMPLATE_CUSTOM;
    }
}

int ZoneIndexToGuiIndex(DWORD dwZoneIndex)
// Product testing asked for the zones in a specific order in the list box;
// This function returns the desired gui position for a given zone
// Unrecognized zones are added to the front
{
    int iGuiIndex = -1;
    switch(dwZoneIndex)
    {
        // Intranet: 2nd spot
        case 1:
            iGuiIndex = 1;
            break;

        // Internet: 1st spot
        case 3:
            iGuiIndex = 0;
            break;

        // Trusted Sites: 3rd Spot
        case 2:
            iGuiIndex = 2;
            break;

        // Restricted Sites: 4th Spot
        case 4:
            iGuiIndex = 3;
            break;

        // unknown zone
        default:
            iGuiIndex = -1;   
            break;
    }


    return iGuiIndex;
}



// Initialize the global variables (to be destroyed at WM_DESTROY)
// pSec, Urlmon, pSec->pInternetZoneManager, pSec->hIml
// and set up the proper relationships among them
BOOL SecurityInitGlobals(LPSECURITYPAGE * ppSec, HWND hDlg, SECURITYINITFLAGS * psif)
{
    DWORD cxIcon;
    DWORD cyIcon;

    LPSECURITYPAGE pSec = NULL;

    *ppSec = (LPSECURITYPAGE)LocalAlloc(LPTR, sizeof(SECURITYPAGE));
    pSec = *ppSec;
    if (!pSec)
    {
        return FALSE;   // no memory?
    }

    // make sure Urlmon stays around until we're done with it.
    pSec->hinstUrlmon = LoadLibrary(TEXT("URLMON.DLL"));
    if(pSec->hinstUrlmon == NULL)
    {
        return FALSE;  // no urlmon?
    }

    // Get the zone manager
    if (FAILED(CoInternetCreateZoneManager(NULL, &(pSec->pInternetZoneManager),0)))
    {
        return FALSE;  // no zone manager?
    }

    // get our zones hwnd
    pSec->hwndZones = GetDlgItem(hDlg, IDC_LIST_ZONE);
    if(! pSec->hwndZones)
    {
        ASSERT(FALSE);
        return FALSE;  // no list box?
    }

    // Get the internet secrity manager (for telling if a zone is empty, 
    // and deciphering the current URL
    if(FAILED(CoInternetCreateSecurityManager(NULL, &(pSec->pInternetSecurityManager), 0)))
        pSec->pInternetSecurityManager = NULL;

    // tell dialog where to get info
    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pSec);

    // save the handle to the page
    pSec->hDlg = hDlg;
    pSec->fPendingChange = FALSE;

    // set dialog options: force ui and disable add sites
    if(psif)
    {
        pSec->fForceUI = psif->fForceUI;
        pSec->fDisableAddSites = psif->fDisableAddSites;
    }
    
    // create an imagelist for the ListBox            
    cxIcon = GetSystemMetrics(SM_CXICON);
    cyIcon = GetSystemMetrics(SM_CYICON);
#ifndef UNIX
    UINT flags = ILC_COLOR32|ILC_MASK;
    
    if(IS_WINDOW_RTL_MIRRORED(hDlg))
    {
        flags |= ILC_MIRROR;
    }
    pSec->himl = ImageList_Create(cxIcon, cyIcon, flags, pSec->dwZoneCount, 0);
#else
    pSec->himl = ImageList_Create(cxIcon, cyIcon, ILC_COLOR|ILC_MASK, pSec->dwZoneCount, 0);
#endif
    if(! pSec->himl)
    {
        return FALSE;  // Image list not created
    }
    SendMessage(pSec->hwndZones, LVM_SETIMAGELIST, (WPARAM)LVSIL_NORMAL, (LPARAM)pSec->himl);

    return TRUE;    
}

// Set up the variables in pSec about whether the zone settings can be editted
void SecuritySetEdit(LPSECURITYPAGE pSec)
{
    // if these calls fail then we'll use the default of zero which means no lockout
    DWORD cb;
    

    cb = SIZEOF(pSec->fNoEdit);  
    SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_SECURITY_LOCKOUT, REGSTR_VAL_OPTIONS_EDIT, 
                NULL, &(pSec->fNoEdit), &cb);

    // also allow g_restrict to restrict changing settings
    pSec->fNoEdit += g_restrict.fSecChangeSettings;
    
    SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_SECURITY_LOCKOUT, REGSTR_VAL_OPTIONS_EDIT, 
                NULL, &(pSec->fNoAddSites), &cb);

    cb = SIZEOF(pSec->fNoZoneMapEdit);
    SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_SECURITY_LOCKOUT, REGSTR_VAL_ZONES_MAP_EDIT, 
                NULL, &(pSec->fNoZoneMapEdit), &cb);

    // also allow the g_restrict to restrict edit
    pSec->fNoAddSites += g_restrict.fSecAddSites;
}


// Fill a zone with information from the zone manager and add it to the
// ordered list going to the listbox
// REturn values:
//  S_OK indicates success
//  S_FALSE indicates a good state, but the zone was not added (example: flag ZAFLAGS_NO_UI)
//  E_OUTOFMEMORY
//  E_FAIL - other failure
HRESULT SecurityInitZone(DWORD dwIndex, LPSECURITYPAGE pSec, DWORD dwZoneEnumerator, 
                         LV_ITEM * plviZones, BOOL * pfSpotTaken)
{
        DWORD                   dwZone;
        ZONEATTRIBUTES          za = {0};
        HICON                   hiconSmall = NULL;
        HICON                   hiconLarge = NULL;
        LPSECURITYZONESETTINGS  pszs;
        WORD                    iIcon=0;
        LPWSTR                  psz;
        TCHAR                   szIconPath[MAX_PATH];
        int                     iSpot;
        LV_ITEM *               plvItem;
        HRESULT                 hr = 0;



        // get the zone attributes for this zone
        za.cbSize = sizeof(ZONEATTRIBUTES);
        pSec->pInternetZoneManager->GetZoneAt(dwZoneEnumerator, dwIndex, &dwZone);
        hr = pSec->pInternetZoneManager->GetZoneAttributes(dwZone, &za);
        if(FAILED(hr))
        {
            return S_FALSE;
        }

        // if no ui, then ignore
        if ((za.dwFlags & ZAFLAGS_NO_UI) && !pSec->fForceUI)
        {
            return S_FALSE;
        }



        // create a structure for zone settings
        pszs = (LPSECURITYZONESETTINGS)LocalAlloc(LPTR, sizeof(*pszs));
        if (!pszs)
        {
            return E_OUTOFMEMORY;
        }



        // store settings for later use
        pszs->dwFlags       = za.dwFlags;
        pszs->dwZoneIndex   = dwZone;
        pszs->dwSecLevel    = za.dwTemplateCurrentLevel;    
        pszs->dwMinSecLevel = za.dwTemplateMinLevel;
        pszs->dwRecSecLevel = za.dwTemplateRecommended;                 
        StrCpyN(pszs->szDescription, za.szDescription, ARRAYSIZE(pszs->szDescription));
        StrCpyN(pszs->szDisplayName, za.szDisplayName, ARRAYSIZE(pszs->szDisplayName));
        // load the icon                
        psz = za.szIconPath;
        if (*psz)
        {
            // search for the '#'
            while ((psz[0] != WIDETEXT('#')) && (psz[0] != WIDETEXT('\0')))
                psz++;
            
            // if we found it, then we have the foo.dll#00001200 format
            if (psz[0] == WIDETEXT('#'))
            {
                psz[0] = WIDETEXT('\0');
                StrCpyN(szIconPath, za.szIconPath, ARRAYSIZE(szIconPath));
                iIcon = (WORD)StrToIntW(psz+1);
                CHAR szPath[MAX_PATH];
                SHUnicodeToAnsi(szIconPath, szPath, ARRAYSIZE(szPath));
                ExtractIconExA(szPath,(UINT)(-1*iIcon), &hiconLarge, &hiconSmall, 1);
            }
            else
            {
                hiconLarge = (HICON)ExtractAssociatedIcon(ghInstance, szIconPath, (LPWORD)&iIcon);
            }
        }
        // no icons?!  well, just use the generic icon
        if (!hiconSmall && !hiconLarge)
        {
            hiconLarge = LoadIcon(ghInstance, MAKEINTRESOURCE(IDI_ZONE));
            if(! hiconLarge)
            {
                LocalFree((HLOCAL)pszs);
                return S_FALSE;  // no icon found for this zone, not even the generic one
            }
        }
        // we want to save the Large icon if possible for use in the subdialogs
        pszs->hicon = hiconLarge ? hiconLarge : hiconSmall;

        


        // Find the proper index for the zone in the listbox (there is a user-preferred order)
        iSpot = ZoneIndexToGuiIndex(dwIndex);
        if(iSpot == -1)
        {
            // if not a recognized zone, add it to the end of the list
            iSpot = pSec->dwZoneCount - 1;
        }
        // Make sure there are no collisisons
        while(iSpot >= 0 && pfSpotTaken[iSpot] == TRUE)
        {
            iSpot--;
        }
        // Don't go past beginning of array
        if(iSpot < 0)
        {
            // It can be proven that it is impossible to get here, unless there is
            // something wrong with the function ZoneIndexToGuiIndex
            ASSERT(FALSE);
            LocalFree((HLOCAL)pszs);
            if(hiconSmall)
                DestroyIcon(hiconSmall);
            if(hiconLarge)
                DestroyIcon(hiconLarge);
            return E_FAIL;
        }
        plvItem = &(plviZones[iSpot]);
        pfSpotTaken[iSpot] = TRUE;


        // init the List Box item and save it for later addition
        plvItem->mask           = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
        plvItem->iItem          = iSpot;
        plvItem->iSubItem       = 0;
        // large icons prefered for the icon view (if switch back to report view, prefer small icons)
        plvItem->iImage         = ImageList_AddIcon(pSec->himl, hiconLarge ? hiconLarge : hiconSmall);

        plvItem->pszText        = new TCHAR[MAX_PATH];
        if(! plvItem->pszText)
        {
            LocalFree((HLOCAL)pszs);
            if(hiconSmall)
                DestroyIcon(hiconSmall);   
            if(hiconLarge)
                DestroyIcon(hiconLarge);
            return E_OUTOFMEMORY;
        }

        MLLoadString( IDS_ZONENAME_LOCAL + dwIndex, plvItem->pszText, MAX_PATH);

        plvItem->lParam         = (LPARAM)pszs;       // save the zone settings here

        

        // if we created a small icon, destroy it, since the system does not save the handle
        // when it is added to the imagelist (see ImageList_AddIcon in VC help)
        // Keep it around if we had to use it in place of the large icon
        if (hiconSmall && hiconLarge)
            DestroyIcon(hiconSmall);   

        return S_OK;
}

// Find the current zone from, in order of preference,
// Current URL
// Parameter passed in through dwZone
// Default of internet
void SecurityFindCurrentZone(LPSECURITYPAGE pSec, SECURITYINITFLAGS * psif)
{
    INT_PTR iItem;
    DWORD dwZone=0;
    HRESULT hr = E_FAIL;

    // Check for zone selection in psif
    if(psif)
    {
        dwZone = psif->dwZone;
        hr = S_OK;
    }

    // check for current url, and if found, make it's zone the current (overwriting any request from
    // psif)
    if (g_szCurrentURL[0] && (pSec->pInternetSecurityManager != NULL))
    {
        LPWSTR pwsz;

#ifndef UNICODE
        WCHAR wszCurrentURL[MAX_URL_STRING];
        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, g_szCurrentURL, -1, wszCurrentURL, ARRAYSIZE(wszCurrentURL));
        pwsz = wszCurrentURL;
#else
        pwsz = g_szCurrentURL;
#endif
        hr = pSec->pInternetSecurityManager->MapUrlToZone(pwsz, (LPDWORD)&dwZone, 0);        
    }
    

    // If there is an active zone, then dwZone now holds the zone's identifier
    // if there is no active zone, check to see if there was a zone requested in dwZone
    iItem = -1;
    if (SUCCEEDED(hr)) // then we have a zone to display
    {
        ZONEATTRIBUTES za = {0};
        LPTSTR pszText;
        LV_FINDINFO lvfiName;
       
        za.cbSize = (ULONG) sizeof(ZONEATTRIBUTES);
        if(pSec->pInternetZoneManager->GetZoneAttributes(dwZone, &za) != E_FAIL)
        {
#ifdef UNICODE    
            pszText        = za.szDisplayName;
#else    
            CHAR szDisplayName[MAX_ZONE_PATH];
            WideCharToMultiByte(CP_ACP, 0, za.szDisplayName, -1, szDisplayName, ARRAYSIZE(szDisplayName), NULL, NULL);
            pszText        = szDisplayName;
#endif // UNICODE

            // Create a find info structure to find the index of the Zone
            lvfiName.flags = LVFI_STRING;
            lvfiName.psz = pszText;
            iItem = SendMessage(pSec->hwndZones, LVM_FINDITEM, (WPARAM)-1, (LPARAM)&lvfiName);
        }
    }

    if (iItem < 0)
    {
        iItem = 0;
        // 0 is the the index (in the listbox) of the "Internet" zone, which we want to come up by default
    }
    // Sundown: typecast OK since zone values restricted
    pSec->iZoneSel = (int) iItem;
}

// To make the slider control accessbile we have to subclass it and over-ride 
// the accessiblity object 

void SecurityInitSlider(LPSECURITYPAGE pSec)
{
    HWND hwndSlider = GetDlgItem(pSec->hDlg, IDC_SLIDER);
    ASSERT(hwndSlider != NULL);

    // Sub-class the control
    BOOL fSucceeded = SetWindowSubclass(hwndSlider, SliderSubWndProc, 0, NULL);

    // Shouldn't fail normally. If we fail we will just fall through and use the
    // base slider control.
    ASSERT(fSucceeded);

    // Initialize the slider control (set number of levels, and frequency one tick per level)
    SendDlgItemMessage(pSec->hDlg, IDC_SLIDER, TBM_SETRANGE, (WPARAM) (BOOL) FALSE, (LPARAM) MAKELONG(0, NUM_TEMPLATE_LEVELS - 1));
    SendDlgItemMessage(pSec->hDlg, IDC_SLIDER, TBM_SETTICFREQ, (WPARAM) 1, (LPARAM) 0);
}
                    
void SecurityInitControls(LPSECURITYPAGE pSec)
{
    LV_COLUMN lvCasey;
    LV_ITEM lvItem;

    // select the item in the listbox
    lvItem.mask = LVIF_STATE;
    lvItem.stateMask = LVIS_SELECTED;
    lvItem.state = LVIS_SELECTED;
    SendMessage(pSec->hwndZones, LVM_SETITEMSTATE, (WPARAM)pSec->iZoneSel, (LPARAM)&lvItem);
    


    // get the zone settings for the selected item
    lvItem.mask  = LVIF_PARAM;
    lvItem.iItem = pSec->iZoneSel;
    lvItem.iSubItem = 0;
    SendMessage(pSec->hwndZones, LVM_GETITEM, (WPARAM)0, (LPARAM)&lvItem);
    pSec->pszs = (LPSECURITYZONESETTINGS)lvItem.lParam;


    // Initialize the local strings to carry the Level Descriptions
    MLLoadString(IDS_TEMPLATE_DESC_HI, LEVEL_DESCRIPTION0, ARRAYSIZE(LEVEL_DESCRIPTION0));
    MLLoadString(IDS_TEMPLATE_DESC_MED, LEVEL_DESCRIPTION1, ARRAYSIZE(LEVEL_DESCRIPTION1));
    MLLoadString(IDS_TEMPLATE_DESC_MEDLOW, LEVEL_DESCRIPTION2, ARRAYSIZE(LEVEL_DESCRIPTION2));
    MLLoadString(IDS_TEMPLATE_DESC_LOW, LEVEL_DESCRIPTION3, ARRAYSIZE(LEVEL_DESCRIPTION3));
    MLLoadString(IDS_TEMPLATE_DESC_CUSTOM, CUSTOM_DESCRIPTION, ARRAYSIZE(CUSTOM_DESCRIPTION));

    MLLoadString(IDS_TEMPLATE_NAME_HI, LEVEL_NAME0, ARRAYSIZE(LEVEL_NAME0));
    MLLoadString(IDS_TEMPLATE_NAME_MED, LEVEL_NAME1, ARRAYSIZE(LEVEL_NAME1));
    MLLoadString(IDS_TEMPLATE_NAME_MEDLOW, LEVEL_NAME2, ARRAYSIZE(LEVEL_NAME2));
    MLLoadString(IDS_TEMPLATE_NAME_LOW, LEVEL_NAME3, ARRAYSIZE(LEVEL_NAME3));
    MLLoadString(IDS_TEMPLATE_NAME_CUSTOM, CUSTOM_NAME, ARRAYSIZE(CUSTOM_NAME));

    // Initialize text boxes and icons for the current zone
    WCHAR wszBuffer[ MAX_PATH*2];
    MLLoadString( IDS_ZONEDESC_LOCAL + pSec->pszs->dwZoneIndex, wszBuffer, ARRAYSIZE(wszBuffer));
    SetDlgItemText(pSec->hDlg, IDC_ZONE_DESCRIPTION, wszBuffer);
    MLLoadString( IDS_ZONENAME_LOCAL + pSec->pszs->dwZoneIndex, wszBuffer, ARRAYSIZE(wszBuffer));
    SetDlgItemText(pSec->hDlg, IDC_ZONELABEL, wszBuffer);
    SendDlgItemMessage(pSec->hDlg, IDC_ZONE_ICON, STM_SETIMAGE, (WPARAM)IMAGE_ICON, (LPARAM)pSec->pszs->hicon);

    // Initialize the slider control
    SecurityInitSlider(pSec);

    // Initialize the list view (add column 0 for icon and text, and autosize it)
    lvCasey.mask = 0;
    SendDlgItemMessage(pSec->hDlg, IDC_LIST_ZONE, LVM_INSERTCOLUMN, (WPARAM) 0, (LPARAM) &lvCasey);
    SendDlgItemMessage(pSec->hDlg, IDC_LIST_ZONE, LVM_SETCOLUMNWIDTH, (WPARAM) 0, (LPARAM) MAKELPARAM(LVSCW_AUTOSIZE, 0));

    // Set the font of the name to the bold font
    pSec->hfontBolded = NULL;
    HFONT hfontOrig = (HFONT) SendDlgItemMessage(pSec->hDlg, IDC_STATIC_EMPTY, WM_GETFONT, (WPARAM) 0, (LPARAM) 0);
    if(hfontOrig == NULL)
        hfontOrig = (HFONT) GetStockObject(SYSTEM_FONT);

    // set the zone name and level font to bolded
    if(hfontOrig)
    {
        LOGFONT lfData;
        if(GetObject(hfontOrig, SIZEOF(lfData), &lfData) != 0)
        {
            // The distance from 400 (normal) to 700 (bold)
            lfData.lfWeight += 300;
            if(lfData.lfWeight > 1000)
                lfData.lfWeight = 1000;
            pSec->hfontBolded = CreateFontIndirect(&lfData);
            if(pSec->hfontBolded)
            {
                // the zone level and zone name text boxes should have the same font, so this is okat
                SendDlgItemMessage(pSec->hDlg, IDC_ZONELABEL, WM_SETFONT, (WPARAM) pSec->hfontBolded, (LPARAM) MAKELPARAM(FALSE, 0));
                SendDlgItemMessage(pSec->hDlg, IDC_LEVEL_NAME, WM_SETFONT, (WPARAM) pSec->hfontBolded, (LPARAM) MAKELPARAM(FALSE, 0));

            }
        }
    }

/*
    {
        // calculate the postions of the static text boxes for the "The current level is:" "<bold>(Level)</bold>" message
        TCHAR * pszText = NULL;
        LONG lLength = 30;
        HDC hdc = NULL;
        SIZE size;
        RECT rect;
        LONG lNameLeftPos = 0;

        // Get the text from the "The current level is" box.
        lLength = SendDlgItemMessage(pSec->hDlg, IDC_SEC_STATIC_CURRENT_LEVEL, WM_GETTEXTLENGTH, 
                                     (WPARAM) 0, (LPARAM) 0);
        pszText = new TCHAR[lLength + 1];
        if(!pszText)
            goto Exit; // E_OUTOFMEMORY
        SendDlgItemMessage(pSec->hDlg, IDC_SEC_STATIC_CURRENT_LEVEL, WM_GETTEXT, (WPARAM) lLength, 
                           (LPARAM) pszText);

        // get the device context
        hdc = GetDC(GetDlgItem(pSec->hDlg, IDC_SEC_STATIC_CURRENT_LEVEL));
        if(! hdc)
            goto Exit;
        // get the length of the text from the device context; assumes the proper font is already in
        if(GetTextExtentPoint32(hdc, pszText, lLength, &size) == 0)
            goto Exit;

        // set the width of the "The current level is" box
        GetClientRect(GetDlgItem(pSec->hDlg, IDC_SEC_STATIC_CURRENT_LEVEL), &rect);
        rect.right = rect.left + size.cx;
        lNameLeftPos = rect.right;
        if(MoveWindow(GetDlgItem(pSec->hDlg, IDC_SEC_STATIC_CURRENT_LEVEL), rect.left, rect.top, 
                      rect.right - rect.left, rect.top - rect.bottom, FALSE) == 0)
            goto Exit;

        // set the x position of the level name box
        GetClientRect(GetDlgItem(pSec->hDlg, IDC_LEVEL_NAME), &rect);
        rect.left = lNameLeftPos;
        if(MoveWindow(GetDlgItem(pSec->hDlg, IDC_LEVEL_NAME), rect.left, 
                      rect.top, rect.right - rect.left, rect.top - rect.bottom, FALSE) == 0)
            goto Exit;

Exit:
        if(hdc)
            ReleaseDC(GetDlgItem(pSec->hDlg, IDC_SEC_STATIC_CURRENT_LEVEL), hdc);
        if(pszText)
            delete pszText;
    }
    */
}


//
// SecurityDlgInit()
//
// Does initalization for Security Dlg.
//
// History:
//
// 6/17/96  t-gpease   remove 'gPrefs', cleaned up code
// 6/20/96  t-gpease   UI changes
// 5/14/97  t-ashlm    UI changes 
//
// 7/02/97  t-mattp    UI changes (slider, listbox)
//
// hDlg is the handle to the SecurityDialog window
// psif holds initialization parameters.  In the case of our entry point
//      from shdocvw (ie, double click browser zone icon, view-internetoptions-security, or right click
//      on desktop icon), it can be NULL

BOOL SecurityDlgInit(HWND hDlg, SECURITYINITFLAGS * psif)
{
    LPSECURITYPAGE  pSec = NULL;
    UINT iIndex = 0;
    HRESULT hr = 0;
    DWORD dwZoneEnumerator;
    
    // Initialize globals variables (to be destroyed at WM_DESTROY)
    if(SecurityInitGlobals(&pSec, hDlg, psif) == FALSE)
    {
        EndDialog(hDlg, 0);
        return FALSE;  // Initialization failed
    }

    // Get a (local) enumerator for the zones
    if (FAILED(pSec->pInternetZoneManager->
                     CreateZoneEnumerator(&dwZoneEnumerator, &(pSec->dwZoneCount), 0)))
    {
        EndDialog(hDlg, 0);
        return FALSE;  // no zone enumerator?
    }


    // Set up the variables in pSec about whether the zone settings can be editted
    SecuritySetEdit(pSec);

         
    // Add the Listbox items for the zones


    // The zones have to be added in a particular order
    // Array used to order zones for adding
    LV_ITEM * plviZones = new LV_ITEM[pSec->dwZoneCount];
    BOOL * pfSpotTaken = new BOOL[pSec->dwZoneCount];
    for(iIndex =0; iIndex < pSec->dwZoneCount; iIndex++)
        pfSpotTaken[iIndex] = FALSE;

    // propogate zone dropdown
    for (DWORD dwIndex=0; dwIndex < pSec->dwZoneCount; dwIndex++)
    {
        if(FAILED(SecurityInitZone(dwIndex, pSec, dwZoneEnumerator, plviZones, pfSpotTaken)))
        {
            // Delete all memory allocated for any previous zones (which have not yet been added to
            // the listbox)
            for(iIndex = 0; iIndex < pSec->dwZoneCount; iIndex++)
            {
                if(pfSpotTaken[iIndex] && (LPSECURITYZONESETTINGS) (plviZones[iIndex].lParam) != NULL)
                {
                    LocalFree((LPSECURITYZONESETTINGS) (plviZones[iIndex].lParam));
                    plviZones[iIndex].lParam = NULL;
                    if(plviZones[iIndex].pszText)
                        delete [] plviZones[iIndex].pszText;
                }
            }
            delete [] plviZones;
            delete [] pfSpotTaken;
            pSec->pInternetZoneManager->DestroyZoneEnumerator(dwZoneEnumerator);
            EndDialog(hDlg, 0);
            return FALSE;
        }
    }
    pSec->pInternetZoneManager->DestroyZoneEnumerator(dwZoneEnumerator);


    // Add all of the arrayed listitems to the listbox
    for(iIndex = 0; iIndex < pSec->dwZoneCount; iIndex++)
    {
        if(pfSpotTaken[iIndex])
        {
            SendMessage(pSec->hwndZones, LVM_INSERTITEM, (WPARAM)0, (LPARAM)&(plviZones[iIndex]));
            delete [] plviZones[iIndex].pszText;
        }
    }
    delete [] plviZones;
    delete [] pfSpotTaken;



    SecurityFindCurrentZone(pSec, psif);
    SecurityInitControls(pSec);
    SecurityEnableControls(pSec, FALSE);
    return TRUE;
}

void SecurityChanged()
{
    TCHAR szClassName[32];
    HWND hwnd = GetTopWindow(GetDesktopWindow());

    //
    // FEATURE: These should be gotten from some place that is public
    //         to both MSHTML and INETCPL.
    //
    while (hwnd) {
        GetClassName(hwnd, szClassName, ARRAYSIZE(szClassName));

        // notify all "browser" windows that security has changed            
        if (!StrCmpI(szClassName, TEXT("ExploreWClass"))            ||
            !StrCmpI(szClassName, TEXT("IEFrame"))                  ||
            !StrCmpI(szClassName, TEXT("CabinetWClass")))
        {
            // yes...  post it a message..
            PostMessage(hwnd, CWM_GLOBALSTATECHANGE, CWMF_SECURITY, 0L );
        }

        hwnd = GetNextWindow(hwnd, GW_HWNDNEXT);
    }
}

int SecurityWarning(LPSECURITYPAGE pSec)
{
    TCHAR szWarning[64];

    TCHAR szBuf[512];
    TCHAR szMessage[512];
    TCHAR szLevel[64];

    // Load "Warning!"
    MLLoadShellLangString(IDS_WARNING, szWarning, ARRAYSIZE(szWarning));

    // Load "It is not recommended...."
    MLLoadShellLangString(IDS_SECURITY_WARNING, szBuf, ARRAYSIZE(szBuf));

    // Load level: "High, Medium, Medium Low, Low"
    if (pSec->pszs->dwMinSecLevel == URLTEMPLATE_HIGH)
        MLLoadShellLangString(IDS_TEMPLATE_NAME_HI, szLevel, ARRAYSIZE(szLevel));
    else if (pSec->pszs->dwMinSecLevel == URLTEMPLATE_MEDIUM)
        MLLoadShellLangString(IDS_TEMPLATE_NAME_MED, szLevel, ARRAYSIZE(szLevel));
    else if (pSec->pszs->dwMinSecLevel == URLTEMPLATE_MEDLOW)
        MLLoadShellLangString(IDS_TEMPLATE_NAME_MEDLOW, szLevel, ARRAYSIZE(szLevel));
    else
        MLLoadShellLangString(IDS_TEMPLATE_NAME_LOW, szLevel, ARRAYSIZE(szLevel));

    wnsprintf(szMessage, ARRAYSIZE(szMessage), szBuf, szLevel);

    return MessageBox(pSec->hDlg,szMessage,szWarning, MB_ICONWARNING | MB_YESNO | MB_DEFBUTTON2);
}

int RegWriteWarning(HWND hParent)
{
    TCHAR szWarning[64];
    TCHAR szWriteWarning[128];

    // load "Warning!"
    MLLoadShellLangString(IDS_WARNING, szWarning, ARRAYSIZE(szWarning));
    // Load "You are about to write..."
    MLLoadShellLangString(IDS_WRITE_WARNING, szWriteWarning, ARRAYSIZE(szWriteWarning));

    return MessageBox(hParent,szWriteWarning, szWarning, MB_ICONWARNING | MB_YESNO | MB_DEFBUTTON2);
}


BOOL SecurityEnableControls(LPSECURITYPAGE pSec, BOOL fSetFocus)
// Duties:
// Make the controls (slider, en/disabled buttons) match the data for the current zone
// Make the views (Level description text) match the data for the current zone
// Set focus (to slider, if enabled, else custom settings button, if enabled, else 
//     listbox) if fSetFocus is TRUE
// Note: the zone descriptions are not set here; those are handled by the code responsible
//       for changing zones
{
    int iLevel = -1;


    if (pSec && pSec->pszs)
    {
        HWND hwndSlider = GetDlgItem(pSec->hDlg, IDC_SLIDER);
        
        iLevel = SecLevelToSliderPos(pSec->pszs->dwSecLevel);
        ASSERT(iLevel > -2);

        // Set the level of the slider to the setting for the current zone
        // Show or hide the slider for preset levels/custom
        // Set the level description text
        if(iLevel >= 0)
        {
            SendMessage(hwndSlider, TBM_SETPOS, (WPARAM) (BOOL) TRUE, (LPARAM) (LONG) iLevel);
            // Make sure the slider is visible
            ShowWindow(hwndSlider, SW_SHOW);
            ShowWindow(GetDlgItem(pSec->hDlg, IDC_STATIC_SLIDERMOVETEXT), SW_SHOW);
            SetDlgItemText(pSec->hDlg, IDC_LEVEL_DESCRIPTION, LEVEL_DESCRIPTION[iLevel]);         
            SetDlgItemText(pSec->hDlg, IDC_LEVEL_NAME, LEVEL_NAME[iLevel]);
        }
        else
        {
            // Hide the slider for custom
            ShowWindow(hwndSlider, SW_HIDE);
            ShowWindow(GetDlgItem(pSec->hDlg, IDC_STATIC_SLIDERMOVETEXT), SW_HIDE);
            SetDlgItemText(pSec->hDlg, IDC_LEVEL_DESCRIPTION, CUSTOM_DESCRIPTION);
            SetDlgItemText(pSec->hDlg, IDC_LEVEL_NAME, CUSTOM_NAME);
        }

        // If the zone is empty, show the "zone is empty" string
        // Default is to not show the sting (if something goes wrong)
        // Empty zone not possible for internet, intranet, or local zones
        if((pSec->pszs->dwZoneIndex != URLZONE_INTRANET && 
            pSec->pszs->dwZoneIndex != URLZONE_INTERNET) &&
            pSec->pszs->dwZoneIndex != URLZONE_LOCAL_MACHINE &&
            (pSec->pInternetSecurityManager != NULL))
        {
            IEnumString * piesZones = NULL;
            LPOLESTR ppszDummy[1];
            pSec->pInternetSecurityManager->GetZoneMappings(pSec->pszs->dwZoneIndex, &piesZones, 0);

            // If enumerator can not get 1 item, zone is empty (not valid for internet and intranet)
            if(piesZones && (piesZones->Next(1, ppszDummy, NULL) == S_FALSE))
            {
                ShowWindow(GetDlgItem(pSec->hDlg, IDC_STATIC_EMPTY), SW_SHOW);
            }
            else
            {
                ShowWindow(GetDlgItem(pSec->hDlg, IDC_STATIC_EMPTY), SW_HIDE);
            }
            if(piesZones)
                piesZones->Release();
        }
        else
        {
            ShowWindow(GetDlgItem(pSec->hDlg, IDC_STATIC_EMPTY), SW_HIDE);
        }

        // If we were told to set focus then move focus to the slider.
        if (fSetFocus)
        {
            if(!pSec->fNoEdit)
            {
               if(iLevel >= 0)
                    SetFocus(hwndSlider);
               else if(pSec->pszs->dwFlags & ZAFLAGS_CUSTOM_EDIT)
                    SetFocus(GetDlgItem(pSec->hDlg, IDC_BUTTON_SETTINGS));
               else
                 SetFocus(GetDlgItem(pSec->hDlg, IDC_LIST_ZONE));
            }
            else // No focus is allowed, set focus to the list box
            {
                SetFocus(GetDlgItem(pSec->hDlg, IDC_LIST_ZONE));
            }

        }
        EnableWindow(hwndSlider, (iLevel >= 0) && !pSec->fNoEdit);
        EnableWindow(GetDlgItem(pSec->hDlg, IDC_ZONE_RESET), 
                     !pSec->fNoEdit && (pSec->pszs->dwSecLevel != pSec->pszs->dwRecSecLevel));
        EnableWindow(GetDlgItem(pSec->hDlg, IDC_BUTTON_SETTINGS), 
                     (pSec->pszs->dwFlags & ZAFLAGS_CUSTOM_EDIT) && !pSec->fNoEdit);
        EnableWindow(GetDlgItem(pSec->hDlg, IDC_BUTTON_ADD_SITES), 
                     (pSec->pszs->dwFlags & ZAFLAGS_ADD_SITES) && !pSec->fDisableAddSites);

        return TRUE;
    }

    return FALSE;
}

void SecuritySetLevel(DWORD dwLevel, LPSECURITYPAGE pSec)
{
    // All calls to this function are requests to change the security
    // level for the current zone
    // dwLevel = requested level template (URLTEMPLATE_???)
    int iPos = SecLevelToSliderPos(dwLevel);
    ASSERT(iPos != -2);
    BOOL bCanceled = FALSE;

    // Do nothing if the requested level is equal to the current level 
    if(dwLevel != pSec->pszs->dwSecLevel)
    {
        // Pop up warning box if under recommended min level and lowering security (custom N/A)
        if((pSec->pszs->dwMinSecLevel > dwLevel) && (pSec->pszs->dwSecLevel > dwLevel)
            && (dwLevel != URLTEMPLATE_CUSTOM))
        {
            if(SecurityWarning(pSec) == IDNO)
            {
                bCanceled = TRUE;
            }
        }                
        if(! bCanceled)
        {
            // Set the level
            pSec->pszs->dwPrevSecLevel = pSec->pszs->dwSecLevel;
            pSec->pszs->dwSecLevel = dwLevel;
            ENABLEAPPLY(pSec->hDlg);

            //Tell apply and ok that settings have been changed
            pSec->fChanged = TRUE;
        }
        // Sync the controls to the new level (or back to the old if cancelled)
        SecurityEnableControls(pSec, TRUE);
    }
    // Record that the change request has been handled
    pSec->fPendingChange = FALSE;
}


//
// SecurityDlgApplyNow()
//
// Retrieves the user's choices in dlg ctls,
//    and saves them through SecurityManager interfaces
// If bSaveAll is true, the data for all zones is saved,
// if false, only the current
// Return value is whether the changes were okayed 
//
BOOL SecurityDlgApplyNow(LPSECURITYPAGE pSec, BOOL bSaveAll)
{
    if (pSec->fChanged)
    {
        for (int iIndex = (int)SendMessage(pSec->hwndZones, LVM_GETITEMCOUNT, 0, 0) - 1;
             iIndex >= 0; iIndex--)
        {
            if(!((bSaveAll) || (iIndex == pSec->iZoneSel)))
                continue;
            LV_ITEM lvItem = {0};
            ZONEATTRIBUTES za = {0};
            LPSECURITYZONESETTINGS pszs;
            
            // get the item settings
            lvItem.mask  = LVIF_PARAM;
            lvItem.iItem = iIndex;
            lvItem.iSubItem = 0;
            if(SendMessage(pSec->hwndZones, LVM_GETITEM, (WPARAM)0, (LPARAM)&lvItem))
            {
                pszs = (LPSECURITYZONESETTINGS)lvItem.lParam;

                za.cbSize = sizeof(ZONEATTRIBUTES);
                pSec->pInternetZoneManager->GetZoneAttributes(pszs->dwZoneIndex, &za);
                za.dwTemplateCurrentLevel = pszs->dwSecLevel;
                pSec->pInternetZoneManager->SetZoneAttributes(pszs->dwZoneIndex, &za);
                // Custom settings are saved on exit from the Custom Settings window
            }
        }
        UpdateAllWindows();
        SecurityChanged();
        if (bSaveAll)
        {
            // if bSaveAll is false, that means we're saving the info for one zone, but not
            // the others. This happens when you have custom settings for a particular zone
            // However, other zones may have been changed to only one of the standard settings
            // We need to ensure that those settings also get saved when the user clicks OK/Apply.
            pSec->fChanged = FALSE;
        }
    }
    return TRUE;
}


//
// SecurityOnCommand()
//
// Handles Security Dialog's window messages
//
// History:
//
// 6/17/96  t-gpease   created
// 5/14/97  t-ashlm    ui changes
//
void SecurityOnCommand(LPSECURITYPAGE pSec, UINT id, UINT nCmd)
{

    switch (id)
    {
        case IDC_BUTTON_ADD_SITES:
        {
            if (pSec->pszs->dwZoneIndex == URLZONE_INTRANET)
                DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_SECURITY_INTRANET), pSec->hDlg,
                               SecurityAddSitesIntranetDlgProc, (LPARAM)pSec);
            else
                DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_SECURITY_ADD_SITES), pSec->hDlg,
                               SecurityAddSitesDlgProc, (LPARAM)pSec);
                               
            // Resynch controls (in case the "zone is empty" message needs to be updated)
            SecurityEnableControls(pSec, FALSE);
        }   
        break;

        case IDC_BUTTON_SETTINGS:
        {
            // Note: messages to change the level from preset to custom as a result of this call
            //       are sent by the CustomSettings dialog
            DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_SECURITY_CUSTOM_SETTINGS), pSec->hDlg,
                           SecurityCustomSettingsDlgProc, (LPARAM)pSec);
            break;
        }
        case IDC_ZONE_RESET:
            if(!pSec->fPendingChange && pSec->pszs->dwSecLevel != pSec->pszs->dwRecSecLevel)
            {
                pSec->fPendingChange = TRUE;
                PostMessage(pSec->hDlg, WM_APP, (WPARAM) 0, (LPARAM) pSec->pszs->dwRecSecLevel);
            }
            break;
            
        case IDOK:
            SecurityDlgApplyNow(pSec, TRUE);
            EndDialog(pSec->hDlg, IDOK);
            break;
            
        case IDCANCEL:
            EndDialog(pSec->hDlg, IDCANCEL);
            break;
            
        case IDC_SLIDER:
            {
                // Get the current slider position
                // Sundown: forced typecast to int, slider positions are restricted
                int iPos = (int) SendDlgItemMessage(pSec->hDlg, IDC_SLIDER, TBM_GETPOS, (WPARAM) 0, (LPARAM) 0);
                if(nCmd == TB_THUMBTRACK)
                {
                    // on Mouse Move, change the level description only
                    SetDlgItemText(pSec->hDlg, IDC_LEVEL_DESCRIPTION, LEVEL_DESCRIPTION[iPos]);
                    SetDlgItemText(pSec->hDlg, IDC_LEVEL_NAME, LEVEL_NAME[iPos]);
                }
                else
                {
                    // Request that the current zone's security level be set to the corresponding level
                    DWORD_PTR dwLevel = SliderPosToSecLevel(iPos);
                    if(! pSec->fPendingChange)
                    {
                        pSec->fPendingChange = TRUE;
                        PostMessage(pSec->hDlg, WM_APP, (WPARAM) 0, (LPARAM) dwLevel);
                    }
                }
            }
            break;
            
        case IDC_LIST_ZONE:
        {
            // Sundown: coercion to int-- selection is range-restricted
            int iNewSelection = (int) SendMessage(pSec->hwndZones, LVM_GETNEXTITEM, (WPARAM)-1, 
                                                  MAKELPARAM(LVNI_SELECTED, 0));

            if ((iNewSelection != pSec->iZoneSel) && (iNewSelection != -1))
            {
                LV_ITEM lvItem;

                lvItem.iItem = iNewSelection;
                lvItem.iSubItem = 0;
                lvItem.mask  = LVIF_PARAM;                                            
                SendMessage(pSec->hwndZones, LVM_GETITEM, (WPARAM)0, (LPARAM)&lvItem);
                pSec->pszs = (LPSECURITYZONESETTINGS)lvItem.lParam;
                pSec->iZoneSel = iNewSelection;

                WCHAR wszBuffer[ MAX_PATH*2];
                MLLoadString( IDS_ZONEDESC_LOCAL + pSec->pszs->dwZoneIndex, wszBuffer, ARRAYSIZE(wszBuffer));
                SetDlgItemText(pSec->hDlg, IDC_ZONE_DESCRIPTION, wszBuffer);
                MLLoadString( IDS_ZONENAME_LOCAL + pSec->pszs->dwZoneIndex, wszBuffer, ARRAYSIZE(wszBuffer));
                SetDlgItemText(pSec->hDlg, IDC_ZONELABEL, wszBuffer);
                SendDlgItemMessage(pSec->hDlg, IDC_ZONE_ICON, STM_SETIMAGE, (WPARAM)IMAGE_ICON, (LPARAM)pSec->pszs->hicon);
                SecurityEnableControls(pSec, FALSE);
            }    
            break;
        }
    }   

} // SecurityOnCommand()


//
// SecurityDlgProc()
//
// Handles Security Dialog's window messages
//
// History:
//
// 6/17/96  t-gpease   created
// 5/14/97  t-ashlm    ui changes
//
INT_PTR CALLBACK SecurityDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPSECURITYPAGE pSec;

    if (uMsg == WM_INITDIALOG)
    {
        // A hack forced by PropertyPage:
        // PropertyPage creates this dialog in mainwnd.cpp when the dialog is entered from
        // the desktop e's properties, the browser's menu view-internetoptions-security, or
        // right clicking on the browser's zone icon.
        // In the property page case, lParam (our only route to get initialization information
        // in) is a pointer to a PROPERTYSHEETHEADER, more or less, and of entirely no use to us.
        // However, when called from our exported function LaunchSecurityDialogEx, using
        // CreateDialogParamWrapW, we want to pass useful information in.  The only way to make sure 
        // we our dealing with useful information is to make the passed in pointer be to a 
        // structure we know and love, and hence could not possibly be pointed to by PropertyPage.  
        // We use a ThreadLocalStorage object, as our information reference
        SECURITYINITFLAGS * psif = NULL;
        if(g_dwtlsSecInitFlags != (DWORD) -1)
            psif = (SECURITYINITFLAGS *) TlsGetValue(g_dwtlsSecInitFlags);
        if((SECURITYINITFLAGS *) lParam != psif)
            psif = NULL; 
        return SecurityDlgInit(hDlg, psif);
    }

    pSec = (LPSECURITYPAGE)GetWindowLongPtr(hDlg, DWLP_USER);
    if (!pSec)
        return FALSE;
    
    switch (uMsg)
    {
        case WM_COMMAND:
            SecurityOnCommand(pSec, LOWORD(wParam), HIWORD(wParam));
            return TRUE;

        case WM_NOTIFY:
        {
            NMHDR *lpnm = (NMHDR *) lParam;

            ASSERT(lpnm);

            // List Box Messages
            if(lpnm->idFrom == IDC_LIST_ZONE)
            {
                NM_LISTVIEW * lplvnm = (NM_LISTVIEW *) lParam;
                if(lplvnm->hdr.code == LVN_ITEMCHANGED)
                {
                    // If an item's state has changed, and it is now selected
                    if(((lplvnm->uChanged & LVIF_STATE) != 0) && ((lplvnm->uNewState & LVIS_SELECTED) != 0))
                    {
                        SecurityOnCommand(pSec, IDC_LIST_ZONE, LVN_ITEMCHANGED);
                    }                   
                }
            }
            else
            {
                switch (lpnm->code)
                {
                    case PSN_QUERYCANCEL:
                    case PSN_KILLACTIVE:
                    case PSN_RESET:
                        SetWindowLongPtr(pSec->hDlg, DWLP_MSGRESULT, FALSE);
                        return TRUE;

                    case PSN_APPLY:
                        // Hitting the apply button runs this code
                        SecurityDlgApplyNow(pSec, TRUE);
                        break;
                }
            }
        }
        break;

        case WM_HELP:           // F1
            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                        HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_APP:
            // A message needs to be posted, because the set tools sometimes send two messages
            // hence we need delayed action and a pending change boolean
            // lParam is the level to set for this message
            // wParam is not used
            SecuritySetLevel((DWORD) lParam, pSec);
            break;
        case WM_VSCROLL:
            // Slider Messages
            SecurityOnCommand(pSec, IDC_SLIDER, LOWORD(wParam));
            return TRUE;

        case WM_CONTEXTMENU:        // right mouse click
            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                        HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_DESTROY:
            if(! pSec)
                break;

            if(pSec->hwndZones)
            {
                for (int iIndex = (int)SendMessage(pSec->hwndZones, LVM_GETITEMCOUNT, 0, 0) - 1;
                     iIndex >= 0; iIndex--)
                {
                    LV_ITEM lvItem;

                    // get security zone settings object for this item and release it
                    lvItem.mask = LVIF_PARAM;
                    lvItem.iItem = iIndex;
                    lvItem.iSubItem = 0;
                    if (SendMessage(pSec->hwndZones, LVM_GETITEM, (WPARAM)0, (LPARAM)&lvItem) == TRUE)
                    {
                        LPSECURITYZONESETTINGS pszs = (LPSECURITYZONESETTINGS)lvItem.lParam;
                        if (pszs)
                        {
                            if (pszs->hicon)
                                DestroyIcon(pszs->hicon);
                            LocalFree((HLOCAL)pszs);
                            pszs = NULL;
                        }
                    }                 
                }   
            }

            if(pSec->pInternetZoneManager)
                pSec->pInternetZoneManager->Release();

            if(pSec->pInternetSecurityManager)
                pSec->pInternetSecurityManager->Release();

            if(pSec->himl)
                ImageList_Destroy(pSec->himl);

            if(pSec->hfontBolded)
                DeleteObject(pSec->hfontBolded);

            // ok, we're done with URLMON
            if(pSec->hinstUrlmon)
                FreeLibrary(pSec->hinstUrlmon);
            
            LocalFree(pSec);
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NULL);
            break;
    }
    return FALSE;
}

// Subclassed window proc for the slider. This is used to take over the
// accessibility wrapper for the class so we can return the right zone
// string ( i.e. High, Medium, Low, etc). Just trap WM_GETOBJECT and pass
// in our override of the accessibility wrapper. 

LRESULT CALLBACK SliderSubWndProc (HWND hwndSlider, UINT uMsg, WPARAM wParam, LPARAM lParam, WPARAM uID, ULONG_PTR dwRefData)
{
    ASSERT(uID == 0);
    ASSERT(dwRefData == 0);

    switch (uMsg)
    {
        case WM_GETOBJECT:
            if ( lParam == OBJID_CLIENT )
            {       
                // At this point we will try to load oleacc and get the functions
                // we need. 
                if (!g_fAttemptedOleAccLoad)
                {
                    g_fAttemptedOleAccLoad = TRUE;

                    ASSERT(s_pfnCreateStdAccessibleProxy == NULL);
                    ASSERT(s_pfnLresultFromObject == NULL);

                    g_hOleAcc = LoadLibrary(TEXT("OLEACC"));
                    if (g_hOleAcc != NULL)
                    {
        #ifdef UNICODE
                        s_pfnCreateStdAccessibleProxy = (PFNCREATESTDACCESSIBLEPROXY)
                                                    GetProcAddress(g_hOleAcc, "CreateStdAccessibleProxyW");
        #else
                        s_pfnCreateStdAccessibleProxy = (PFNCREATESTDACCESSIBLEPROXY)
                                                    GetProcAddress(g_hOleAcc, "CreateStdAccessibleProxyA");
        #endif
                        s_pfnLresultFromObject = (PFNLRESULTFROMOBJECT)
                                                    GetProcAddress(g_hOleAcc, "LresultFromObject");
                    }
                    if (s_pfnLresultFromObject == NULL || s_pfnCreateStdAccessibleProxy == NULL)
                    {
                        // No point holding on to Oleacc since we can't use it.
                        FreeLibrary(g_hOleAcc);
                        g_hOleAcc = NULL;
                        s_pfnLresultFromObject = NULL;
                        s_pfnCreateStdAccessibleProxy = NULL;
                    }
                }

                
                if (g_hOleAcc && s_pfnCreateStdAccessibleProxy && s_pfnLresultFromObject)
                {
                    IAccessible *pAcc = NULL;
                    HRESULT hr;
                
                    // Create default slider proxy.
                    hr = s_pfnCreateStdAccessibleProxy(
                            hwndSlider,
                            TEXT("msctls_trackbar32"),
                            OBJID_CLIENT,
                            IID_IAccessible,
                            (void **)&pAcc
                            );


                    if (SUCCEEDED(hr) && pAcc)
                    {
                        // now wrap it up in our customized wrapper...
                        IAccessible * pWrapAcc = new CSecurityAccessibleWrapper( hwndSlider, pAcc );
                        // Release our ref to proxy (wrapper has its own addref'd ptr)...
                        pAcc->Release();
                    
                        if (pWrapAcc != NULL)
                        {

                            // ...and return the wrapper via LresultFromObject...
                            LRESULT lr = s_pfnLresultFromObject( IID_IAccessible, wParam, pWrapAcc );
                            // Release our interface pointer - OLEACC has its own addref to the object
                            pWrapAcc->Release();

                            // Return the lresult, which 'contains' a reference to our wrapper object.
                            return lr;
                            // All done!
                        }
                    // If it didn't work, fall through to default behavior instead. 
                    }
                }
            }
            break;

        case WM_DESTROY:
            RemoveWindowSubclass(hwndSlider, SliderSubWndProc, uID);
            break;    

    } /* end switch */

    return DefSubclassProc(hwndSlider, uMsg, wParam, lParam);
}

                        
                          




HRESULT _AddSite(LPADDSITESINFO pasi)
{
    HRESULT hr = S_OK;
    LPWSTR psz;

    SendMessage(pasi->hwndAdd, WM_GETTEXT, MAX_ZONE_PATH, (LPARAM)pasi->szWebSite);
#ifndef UNICODE
    WCHAR wszMapping[MAX_ZONE_PATH];
    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pasi->szWebSite, sizeof(pasi->szWebSite),  wszMapping, ARRAYSIZE(wszMapping));
    psz = wszMapping;
#else
    psz = pasi->szWebSite;
#endif

    if (*psz)
    {


        pasi->fRSVOld = pasi->fRequireServerVerification;
        pasi->fRequireServerVerification = IsDlgButtonChecked(pasi->hDlg, IDC_CHECK_REQUIRE_SERVER_VERIFICATION);                 

        // if the state of RequireServerVer has changed, then do a SetZoneAttr so we'll get the correct error codes
        if (pasi->fRSVOld != pasi->fRequireServerVerification)
        {
            ZONEATTRIBUTES za;
            za.cbSize = sizeof(ZONEATTRIBUTES);
            pasi->pSec->pInternetZoneManager->GetZoneAttributes(pasi->pSec->pszs->dwZoneIndex, &za);
            if (pasi->fRequireServerVerification)
                za.dwFlags |= ZAFLAGS_REQUIRE_VERIFICATION;
            else
                za.dwFlags &= ~ZAFLAGS_REQUIRE_VERIFICATION;
            
            pasi->pSec->pInternetZoneManager->SetZoneAttributes(pasi->pSec->pszs->dwZoneIndex, &za);

        }
        
        hr = pasi->pSec->pInternetSecurityManager->SetZoneMapping(pasi->pSec->pszs->dwZoneIndex,
            psz, SZM_CREATE);

        if (FAILED(hr))
        {
            UINT id = IDS_MAPPINGFAIL;
        
            if (hr == URL_E_INVALID_SYNTAX)
            {
                id = IDS_INVALIDURL;
            }
            else if (hr == E_INVALIDARG)
            {
                id = IDS_INVALIDWILDCARD;
            }
            else if (hr == E_ACCESSDENIED)
            {
                id = IDS_HTTPSREQ;
            }
            else if (hr == HRESULT_FROM_WIN32(ERROR_FILE_EXISTS))
            {
                id = IDS_SITEEXISTS;
            }

            MLShellMessageBox(pasi->hDlg, MAKEINTRESOURCEW(id), NULL, MB_ICONSTOP|MB_OK);
            Edit_SetSel(pasi->hwndAdd, 0, -1);
        }
        else
        {
            SendMessage(pasi->hwndWebSites, LB_ADDSTRING, (WPARAM)0, (LPARAM)pasi->szWebSite);
            SendMessage(pasi->hwndAdd, WM_SETTEXT, (WPARAM)0, (LPARAM)NULL);
            SetFocus(pasi->hwndAdd);
        }
    }
    return hr;
}

INT_PTR CALLBACK SecurityAddSitesDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
    LPADDSITESINFO pasi;

    if (uMsg == WM_INITDIALOG)
    {
        pasi = (LPADDSITESINFO)LocalAlloc(LPTR, sizeof(*pasi));
        if (!pasi)
        {
            EndDialog(hDlg, IDCANCEL);
            return FALSE;
        }

        // tell dialog where to get info
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pasi);

        // save the handle to the page
        pasi->hDlg         = hDlg;
        pasi->pSec         = (LPSECURITYPAGE)lParam;
        pasi->hwndWebSites = GetDlgItem(hDlg, IDC_LIST_WEBSITES);
        pasi->hwndAdd      = GetDlgItem(hDlg, IDC_EDIT_ADD_SITE);

        // cross-lang platform support
        SHSetDefaultDialogFont(hDlg, IDC_EDIT_ADD_SITE);

        // limit the text so it will fit
        SendMessage(pasi->hwndAdd, EM_SETLIMITTEXT, (WPARAM)sizeof(pasi->szWebSite), (LPARAM)0);

        pasi->fRequireServerVerification = pasi->pSec->pszs->dwFlags & ZAFLAGS_REQUIRE_VERIFICATION;
        CheckDlgButton(hDlg, IDC_CHECK_REQUIRE_SERVER_VERIFICATION, pasi->fRequireServerVerification);
        
        // hide the checkbox if it doesn't support server verification
        if (!(pasi->pSec->pszs->dwFlags & ZAFLAGS_SUPPORTS_VERIFICATION))
            ShowWindow(GetDlgItem(hDlg, IDC_CHECK_REQUIRE_SERVER_VERIFICATION), SW_HIDE);

        SendMessage(hDlg, WM_SETTEXT, (WPARAM)0, (LPARAM)pasi->pSec->pszs->szDisplayName);
        SetDlgItemText(hDlg, IDC_ADDSITES_GROUPBOX,(LPTSTR)pasi->pSec->pszs->szDisplayName);
        SendDlgItemMessage(hDlg, IDC_ZONE_ICON, STM_SETIMAGE, (WPARAM)IMAGE_ICON, (LPARAM)pasi->pSec->pszs->hicon);
        EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_REMOVE), FALSE);
        
        if (pasi->pSec->pInternetSecurityManager || SUCCEEDED(CoInternetCreateSecurityManager(NULL, &(pasi->pSec->pInternetSecurityManager), 0)))
        {
            IEnumString *pEnum;

            if (SUCCEEDED(pasi->pSec->pInternetSecurityManager->GetZoneMappings(pasi->pSec->pszs->dwZoneIndex, &pEnum, 0)))
            {
                LPOLESTR pszMapping;
#ifndef UNICODE
                CHAR szMapping[MAX_URL_STRING];
#endif
                LPTSTR psz;

                while (pEnum->Next(1, &pszMapping, NULL) == S_OK)
                {
#ifndef UNICODE
                    WideCharToMultiByte(CP_ACP, 0, pszMapping, -1, szMapping, ARRAYSIZE(szMapping), NULL, NULL);
                    psz = szMapping;
#else
                    psz = pszMapping;
#endif // UNICODE                       
                    SendMessage(pasi->hwndWebSites, LB_INSERTSTRING, (WPARAM)-1, (LPARAM)psz);
                    CoTaskMemFree(pszMapping);
                }
                pEnum->Release();
            }
        }
        
        if (pasi->pSec->fNoAddSites || pasi->pSec->fNoZoneMapEdit)
        {
            EnableDlgItem(hDlg, IDC_EDIT_ADD_SITE, FALSE);
            EnableDlgItem(hDlg, IDC_BUTTON_REMOVE, FALSE);            
        }

        if (pasi->pSec->fNoZoneMapEdit)
        {
            EnableDlgItem(hDlg, IDC_CHECK_REQUIRE_SERVER_VERIFICATION, FALSE);
            EnableDlgItem(hDlg, IDS_STATIC_ADDSITE, FALSE);            
        }

        SHAutoComplete(GetDlgItem(hDlg, IDC_EDIT_ADD_SITE), SHACF_DEFAULT);
    }
    
    else
        pasi = (LPADDSITESINFO)GetWindowLongPtr(hDlg, DWLP_USER);

    if (!pasi)
        return FALSE;
    
    switch (uMsg)
    {
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                {
                    ZONEATTRIBUTES za;

                    pasi->fRequireServerVerification = IsDlgButtonChecked(hDlg, IDC_CHECK_REQUIRE_SERVER_VERIFICATION);                 

                    if (pasi->fRequireServerVerification)
                        pasi->pSec->pszs->dwFlags |= ZAFLAGS_REQUIRE_VERIFICATION;
                    else
                        pasi->pSec->pszs->dwFlags &= ~ZAFLAGS_REQUIRE_VERIFICATION;

                    za.cbSize = sizeof(ZONEATTRIBUTES);
                    pasi->pSec->pInternetZoneManager->GetZoneAttributes(pasi->pSec->pszs->dwZoneIndex, &za);
                    za.dwFlags = pasi->pSec->pszs->dwFlags;
                    pasi->pSec->pInternetZoneManager->SetZoneAttributes(pasi->pSec->pszs->dwZoneIndex, &za);
                    if (SUCCEEDED(_AddSite(pasi)))
                    {
                        SecurityChanged();
                        EndDialog(hDlg, IDOK);
                    }
                    break;
                }

                case IDCANCEL:
                {
                    ZONEATTRIBUTES za;

                    // reset to original state of RequireServerVerification on cancel
                    za.cbSize = sizeof(ZONEATTRIBUTES);
                    pasi->pSec->pInternetZoneManager->GetZoneAttributes(pasi->pSec->pszs->dwZoneIndex, &za);
                    za.dwFlags = pasi->pSec->pszs->dwFlags;
                    pasi->pSec->pInternetZoneManager->SetZoneAttributes(pasi->pSec->pszs->dwZoneIndex, &za);

                    EndDialog(hDlg, IDCANCEL);
                    break;
                }
                
                case IDC_LIST_WEBSITES:
                    switch (HIWORD(wParam))
                    {
                        case LBN_SELCHANGE:
                        case LBN_SELCANCEL:
                            if (!pasi->pSec->fNoAddSites && !pasi->pSec->fNoZoneMapEdit)
                                EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_REMOVE), SendDlgItemMessage(hDlg, IDC_LIST_WEBSITES, LB_GETCURSEL, 0, 0) != -1);
                            break;
                    }
                    break;
                            
                case IDC_EDIT_ADD_SITE:
                    switch(HIWORD(wParam))
                    {
                        case EN_CHANGE:
                            BOOL fEnable = GetWindowTextLength(GetDlgItem(hDlg, IDC_EDIT_ADD_SITE)) ? TRUE:FALSE;
                            EnableWindow(GetDlgItem(hDlg,IDC_BUTTON_ADD), fEnable);
                            SendMessage(hDlg, DM_SETDEFID, fEnable ? IDC_BUTTON_ADD : IDOK, 0);
                            break;
                    }   
                    break;

                case IDC_BUTTON_ADD:
                    _AddSite(pasi);
                    break;

                case IDC_BUTTON_REMOVE:
                {
                    TCHAR szMapping[MAX_ZONE_PATH];
                    LPWSTR psz;
                    
                            
                    INT_PTR iSel = SendMessage(pasi->hwndWebSites, LB_GETCURSEL, 0, 0);
                    if (iSel != -1)
                    {
                        SendMessage(pasi->hwndWebSites, LB_GETTEXT, (WPARAM)iSel, (LPARAM)szMapping);
#ifndef UNICODE
                        WCHAR wszMapping[MAX_ZONE_PATH];
                        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szMapping, sizeof(szMapping),  wszMapping, ARRAYSIZE(wszMapping));
                        psz = wszMapping;
#else
                        psz = szMapping;
#endif
                        SendMessage(pasi->hwndWebSites, LB_DELETESTRING, iSel , 0);
                        SendMessage(pasi->hwndWebSites, LB_SETCURSEL, iSel-1, 0);
                        if (!pasi->pSec->fNoAddSites && !pasi->pSec->fNoZoneMapEdit)
                            EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_REMOVE), SendDlgItemMessage(hDlg, IDC_LIST_WEBSITES, LB_GETCURSEL, 0, 0) != -1);

                        pasi->pSec->pInternetSecurityManager->SetZoneMapping(pasi->pSec->pszs->dwZoneIndex,
                            psz, SZM_DELETE);
                    }

                    break;
                }
                default:
                    return FALSE;
            }
            return TRUE;                
            break;

        case WM_HELP:           // F1
            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                        HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:        // right mouse click
            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                        HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_DESTROY:
            SHRemoveDefaultDialogFont(hDlg);
            if (pasi)
            {
                LocalFree(pasi);
                SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NULL);
            }
            break;
    }
    return FALSE;
}

INT_PTR CALLBACK SecurityAddSitesIntranetDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
    LPADDSITESINTRANETINFO pasii;

    if (uMsg == WM_INITDIALOG)
    {
        pasii = (LPADDSITESINTRANETINFO)LocalAlloc(LPTR, sizeof(*pasii));
        if (!pasii)
        {
            EndDialog(hDlg, IDCANCEL);
            return FALSE;
        }

        // tell dialog where to get info
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pasii);

        // save the handle to the page
        pasii->hDlg = hDlg;
        pasii->pSec = (LPSECURITYPAGE)lParam;

        SendMessage(hDlg, WM_SETTEXT, (WPARAM)0, (LPARAM)pasii->pSec->pszs->szDisplayName);
        CheckDlgButton(hDlg, IDC_CHECK_USEINTRANET, pasii->pSec->pszs->dwFlags & ZAFLAGS_INCLUDE_INTRANET_SITES);
        CheckDlgButton(hDlg, IDC_CHECK_PROXY, pasii->pSec->pszs->dwFlags & ZAFLAGS_INCLUDE_PROXY_OVERRIDE);
        CheckDlgButton(hDlg, IDC_CHECK_UNC, pasii->pSec->pszs->dwFlags & ZAFLAGS_UNC_AS_INTRANET);
        SendDlgItemMessage(hDlg, IDC_ZONE_ICON, STM_SETIMAGE, (WPARAM)IMAGE_ICON, (LPARAM)pasii->pSec->pszs->hicon);

        if (pasii->pSec->fNoAddSites || pasii->pSec->fNoZoneMapEdit)
        {
            EnableDlgItem(hDlg, IDC_CHECK_USEINTRANET, FALSE);
            EnableDlgItem(hDlg, IDC_CHECK_PROXY, FALSE);
        }

        if (pasii->pSec->fNoZoneMapEdit)
        {
            EnableDlgItem(hDlg, IDC_CHECK_UNC, FALSE);
        }
        return TRUE;
    }

    else
         pasii = (LPADDSITESINTRANETINFO)GetWindowLongPtr(hDlg, DWLP_USER);

    if (!pasii)
        return FALSE;
    
    switch (uMsg) {
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                {
                    ZONEATTRIBUTES za;

                    pasii->fUseIntranet       = IsDlgButtonChecked(hDlg, IDC_CHECK_USEINTRANET);
                    pasii->fUseProxyExclusion = IsDlgButtonChecked(hDlg, IDC_CHECK_PROXY);
                    pasii->fUseUNC            = IsDlgButtonChecked(hDlg, IDC_CHECK_UNC);
                    
                    if (pasii->fUseIntranet)
                        pasii->pSec->pszs->dwFlags |= ZAFLAGS_INCLUDE_INTRANET_SITES;
                    else
                        pasii->pSec->pszs->dwFlags &= ~ZAFLAGS_INCLUDE_INTRANET_SITES;

                    if (pasii->fUseProxyExclusion)
                        pasii->pSec->pszs->dwFlags |= ZAFLAGS_INCLUDE_PROXY_OVERRIDE;
                    else
                        pasii->pSec->pszs->dwFlags &= ~ZAFLAGS_INCLUDE_PROXY_OVERRIDE;

                    if (pasii->fUseUNC)
                        pasii->pSec->pszs->dwFlags |= ZAFLAGS_UNC_AS_INTRANET;
                    else
                        pasii->pSec->pszs->dwFlags &= ~ZAFLAGS_UNC_AS_INTRANET;
                    
                    za.cbSize = sizeof(ZONEATTRIBUTES);
                    pasii->pSec->pInternetZoneManager->GetZoneAttributes(pasii->pSec->pszs->dwZoneIndex, &za);
                    za.dwFlags = pasii->pSec->pszs->dwFlags;
                    pasii->pSec->pInternetZoneManager->SetZoneAttributes(pasii->pSec->pszs->dwZoneIndex, &za);
                    SecurityChanged();
                    EndDialog(hDlg, IDOK);
                    break;
                }
                case IDCANCEL:
                    EndDialog(hDlg, IDCANCEL);
                    break;

                case IDC_INTRANET_ADVANCED:
                    DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_SECURITY_ADD_SITES), hDlg,
                                   SecurityAddSitesDlgProc, (LPARAM)pasii->pSec);
                    break;

                default:
                    return FALSE;
            }
            return TRUE;                
            break;

        case WM_HELP:           // F1
            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                        HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:        // right mouse click
            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                        HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_DESTROY:
            if (pasii)
            {
                LocalFree(pasii);
                SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NULL);
            }
            break;
    }
    return FALSE;
}

VOID ShowJavaZonePermissionsDialog (HWND hdlg, LPCUSTOMSETTINGSINFO pcsi)
{
    HRESULT           hr;
    IJavaZonePermissionEditor *zoneeditor;

    hr = CoCreateInstance(
            CLSID_JavaRuntimeConfiguration,
            NULL,
            CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER | CLSCTX_LOCAL_SERVER,
            IID_IJavaZonePermissionEditor,
            (PVOID*)&zoneeditor
            );

    if (SUCCEEDED(hr))
    {
        hr = zoneeditor->ShowUI(
                hdlg,
                0,
                0,
                pcsi->fUseHKLM ? URLZONEREG_HKLM : URLZONEREG_DEFAULT,
                pcsi->pSec->pszs->dwZoneIndex,
                pcsi->dwJavaPolicy | URLACTION_JAVA_PERMISSIONS,
                pcsi->pSec->pInternetZoneManager
                );

        zoneeditor->Release();
    }
}



void ShowCustom(LPCUSTOMSETTINGSINFO pcsi, HTREEITEM hti)
{
    TV_ITEM        tvi;
    tvi.hItem = hti;
    tvi.mask = TVIF_HANDLE | TVIF_PARAM | TVIF_IMAGE;

    TreeView_GetItem( pcsi->hwndTree, &tvi );

        // If it's not selected don't bother.
    if (tvi.iImage != IDRADIOON)
        return;

    TCHAR szValName[64];
    DWORD cb = SIZEOF(szValName);
    DWORD dwChecked;

    if (SHRegQueryUSValue((HUSKEY)tvi.lParam,
                        TEXT("ValueName"),
                        NULL,
                        (LPBYTE)szValName,
                        &cb,
                        pcsi->fUseHKLM,
                        NULL,
                        0) == ERROR_SUCCESS)
    {
        if (!(StrCmp(szValName, TEXT("1C00"))))
        {
            cb = SIZEOF(dwChecked);
            if (SHRegQueryUSValue((HUSKEY)tvi.lParam,
                                TEXT("CheckedValue"),
                                NULL,
                                (LPBYTE)&dwChecked,
                                &cb,
                                pcsi->fUseHKLM,
                                NULL,
                                0) == ERROR_SUCCESS)
            {
#ifndef UNIX
                HWND hCtl = GetDlgItem(pcsi->hDlg, IDC_JAVACUSTOM);
                ShowWindow(hCtl,
                           (dwChecked == URLPOLICY_JAVA_CUSTOM) && (tvi.iImage == IDRADIOON) ? SW_SHOWNA : SW_HIDE);
                EnableWindow(hCtl, dwChecked==URLPOLICY_JAVA_CUSTOM ? TRUE : FALSE);
                pcsi->dwJavaPolicy = dwChecked;
#endif
            }
        }
    }
}

void _FindCustomRecursive(
    LPCUSTOMSETTINGSINFO pcsi,
    HTREEITEM htvi
)
{
    HTREEITEM hctvi;    // child
    
    // step through the children
    hctvi = TreeView_GetChild( pcsi->hwndTree, htvi );
    while ( hctvi )
    {
        _FindCustomRecursive(pcsi,hctvi);
        hctvi = TreeView_GetNextSibling( pcsi->hwndTree, hctvi );
    }

    ShowCustom(pcsi, htvi);
}

void _FindCustom(
    LPCUSTOMSETTINGSINFO pcsi
    )
{
    HTREEITEM hti = TreeView_GetRoot( pcsi->hwndTree );
    
    // and walk the list of other roots
    while (hti)
    {
        // recurse through its children
        _FindCustomRecursive(pcsi, hti);

        // get the next root
        hti = TreeView_GetNextSibling(pcsi->hwndTree, hti );
    }
}

BOOL SecurityCustomSettingsInitDialog(HWND hDlg, LPARAM lParam)
{
    LPCUSTOMSETTINGSINFO pcsi = (LPCUSTOMSETTINGSINFO)LocalAlloc(LPTR, sizeof(*pcsi));
    HRESULT hr;
    
    if (!pcsi)
    {
        EndDialog(hDlg, IDCANCEL);
        return FALSE;
    }
    
    // tell dialog where to get info
    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pcsi);

    // save the handle to the page
    pcsi->hDlg = hDlg;
    pcsi->pSec = (LPSECURITYPAGE)lParam;

    // save dialog handle
    pcsi->hwndTree = GetDlgItem(pcsi->hDlg, IDC_TREE_SECURITY_SETTINGS);

    CoInitialize(0);
    hr = CoCreateInstance(CLSID_CRegTreeOptions, NULL, CLSCTX_INPROC_SERVER,
                          IID_IRegTreeOptions, (LPVOID *)&(pcsi->pTO));


    DWORD cb = SIZEOF(pcsi->fUseHKLM);
    
    SHGetValue(HKEY_LOCAL_MACHINE,
               REGSTR_PATH_SECURITY_LOCKOUT,
               REGSTR_VAL_HKLM_ONLY,
               NULL,
               &(pcsi->fUseHKLM),
               &cb);

    // if this fails, we'll just use the default of fUseHKLM == 0
               
    if (SUCCEEDED(hr))
    {
        CHAR szZone[32];

        wnsprintfA(szZone, ARRAYSIZE(szZone), "%ld", pcsi->pSec->pszs->dwZoneIndex);

        // use the SOHKLM tree when fUseHKLM==TRUE for IEAK
        hr = pcsi->pTO->InitTree(pcsi->hwndTree, HKEY_LOCAL_MACHINE,
                                 pcsi->fUseHKLM ?
                                 "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\SOIEAK" :
                                 "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\SO",
                                 szZone);
    }
    
    // find the first root and make sure that it is visible
    TreeView_EnsureVisible( pcsi->hwndTree, TreeView_GetRoot( pcsi->hwndTree ) );

    pcsi->hwndCombo = GetDlgItem(hDlg, IDC_COMBO_RESETLEVEL);
    
    SendMessage(pcsi->hwndCombo, CB_INSERTSTRING, (WPARAM)0, (LPARAM)LEVEL_NAME[3]);
    SendMessage(pcsi->hwndCombo, CB_INSERTSTRING, (WPARAM)0, (LPARAM)LEVEL_NAME[2]);
    SendMessage(pcsi->hwndCombo, CB_INSERTSTRING, (WPARAM)0, (LPARAM)LEVEL_NAME[1]);
    SendMessage(pcsi->hwndCombo, CB_INSERTSTRING, (WPARAM)0, (LPARAM)LEVEL_NAME[0]);
    
    switch (pcsi->pSec->pszs->dwRecSecLevel)
    {
        case URLTEMPLATE_LOW:
            pcsi->iLevelSel = 3;
            break;
        case URLTEMPLATE_MEDLOW:
            pcsi->iLevelSel = 2;
            break;
        case URLTEMPLATE_MEDIUM:
            pcsi->iLevelSel = 1;
            break;
        case URLTEMPLATE_HIGH:
            pcsi->iLevelSel = 0;
            break;
        default:
            pcsi->iLevelSel = 0;
            break;
    }

    _FindCustom(pcsi);
    
    SendMessage(pcsi->hwndCombo, CB_SETCURSEL, (WPARAM)pcsi->iLevelSel, (LPARAM)0);

    if (pcsi->pSec->fNoEdit)
    {
        EnableDlgItem(hDlg, IDC_COMBO_RESETLEVEL, FALSE);
        EnableDlgItem(hDlg, IDC_BUTTON_APPLY, FALSE);
    }
    pcsi->fChanged = FALSE;
    return TRUE;
}

INT_PTR CALLBACK SecurityCustomSettingsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
    LPCUSTOMSETTINGSINFO pcsi;

    if (uMsg == WM_INITDIALOG)
        return SecurityCustomSettingsInitDialog(hDlg, lParam);
    else
        pcsi = (LPCUSTOMSETTINGSINFO)GetWindowLongPtr(hDlg, DWLP_USER);
    
    if (!pcsi)
        return FALSE;
                
    switch (uMsg) {

        case WM_NOTIFY:
        {
            LPNMHDR psn = (LPNMHDR)lParam;
            switch( psn->code )
            {
                case TVN_KEYDOWN:
                {
                    TV_KEYDOWN *pnm = (TV_KEYDOWN*)psn;
                    if (pnm->wVKey == VK_SPACE) {
                        if (!pcsi->pSec->fNoEdit)
                        {
                            HTREEITEM hti = (HTREEITEM)SendMessage(pcsi->hwndTree, TVM_GETNEXTITEM, TVGN_CARET, NULL);
                            pcsi->pTO->ToggleItem(hti);
                            ShowCustom(pcsi, hti);
                            pcsi->fChanged = TRUE;
                            EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_APPLY),TRUE);
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE); // eat the key
                            return TRUE;
                         }
                    }
                    break;
                }
            
                case NM_CLICK:
                case NM_DBLCLK:
                {   // is this click in our tree?
                    if ( psn->idFrom == IDC_TREE_SECURITY_SETTINGS )
                    {   // yes...
                        TV_HITTESTINFO ht;
                        HTREEITEM hti;

                        if (!pcsi->pSec->fNoEdit)
                        {
                            GetCursorPos( &ht.pt );                         // get where we were hit
                            ScreenToClient( pcsi->hwndTree, &ht.pt );       // translate it to our window

                            // retrieve the item hit
                            hti = TreeView_HitTest( pcsi->hwndTree, &ht);

                            pcsi->pTO->ToggleItem(hti);
                            pcsi->fChanged = TRUE;
                            ShowCustom(pcsi, hti);
                            EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_APPLY),TRUE);
                         }
                    }   
                }
                break;
            }
        }
        break;
        
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                    if(pcsi->pSec->fPendingChange)
                        break;
                    
                    if(pcsi->fChanged && RegWriteWarning(pcsi->pSec->hDlg) == IDNO)
                        break;
                    // we use send message instead of post because there is no chance of this button
                    // receiving multiple signals at one click, and we need the change level message to be
                    // processed before the apply message below
                    pcsi->pSec->fPendingChange = TRUE;
                    SendMessage(pcsi->pSec->hDlg, WM_APP, (WPARAM) 0, (LPARAM) URLTEMPLATE_CUSTOM);
                    if(pcsi->fChanged)
                    {
                        pcsi->pTO->WalkTree( WALK_TREE_SAVE );
                    }
                    // Saves custom to registry and Handles updateallwindows 
                    // and securitychanged calls

                    // APPCOMPAT: Force a call to SetZoneAttributes when anything in custom changes.
                    // This forces the security manager to flush any caches it has for that zone. 
                    pcsi->pSec->fChanged = TRUE;

                    SecurityDlgApplyNow(pcsi->pSec, FALSE);
                    EndDialog(hDlg, IDOK);
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, IDCANCEL);
                    break;

                case IDC_COMBO_RESETLEVEL:
                    switch (HIWORD(wParam))
                    {
                        case CBN_SELCHANGE:
                        {
                            // Sundown: coercion to integer since cursor selection is 32b
                            int iNewSelection = (int) SendMessage(pcsi->hwndCombo, CB_GETCURSEL, (WPARAM)0, (LPARAM)0);

                            if (iNewSelection != pcsi->iLevelSel)
                            {
                                pcsi->iLevelSel = iNewSelection;
                                EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_APPLY),TRUE);
                            }
                            break;
                        }
                    }
                    break;

                case IDC_JAVACUSTOM:
                    ShowJavaZonePermissionsDialog(hDlg, pcsi);
                    break;
                    
                case IDC_BUTTON_APPLY:
                {
                    TCHAR szLevel[64];
                    ZONEATTRIBUTES za;
                    
                    if(pcsi->pSec->fPendingChange == TRUE)
                        break;
                    if(RegWriteWarning(hDlg) == IDNO)
                    {
                        break;
                    }
                    pcsi->pSec->fPendingChange = TRUE;

                    SendMessage(pcsi->hwndCombo, WM_GETTEXT, (WPARAM)ARRAYSIZE(szLevel), (LPARAM)szLevel);

                    za.cbSize = sizeof(ZONEATTRIBUTES);
                        
                    pcsi->pSec->pInternetZoneManager->GetZoneAttributes(pcsi->pSec->pszs->dwZoneIndex, &za);
                                
                    if (!StrCmp(szLevel, LEVEL_NAME[3])) 
                        za.dwTemplateCurrentLevel = URLTEMPLATE_LOW;
                    else if (!StrCmp(szLevel, LEVEL_NAME[2]))
                        za.dwTemplateCurrentLevel = URLTEMPLATE_MEDLOW;
                    else if (!StrCmp(szLevel, LEVEL_NAME[1]))
                        za.dwTemplateCurrentLevel = URLTEMPLATE_MEDIUM;
                    else if (!StrCmp(szLevel, LEVEL_NAME[0]))
                        za.dwTemplateCurrentLevel = URLTEMPLATE_HIGH;
                    else
                        za.dwTemplateCurrentLevel = URLTEMPLATE_CUSTOM;

                    pcsi->pSec->pInternetZoneManager->SetZoneAttributes(pcsi->pSec->pszs->dwZoneIndex, &za);

                    pcsi->pTO->WalkTree(WALK_TREE_REFRESH);

                    // find the first root and make sure that it is visible
                    TreeView_EnsureVisible( pcsi->hwndTree, TreeView_GetRoot( pcsi->hwndTree ) );
                    EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_APPLY), FALSE);
                    SendMessage(hDlg, DM_SETDEFID, IDOK, 0);
                    SetFocus(GetDlgItem(hDlg, IDOK));   // since we grayout the reset button, might have keyboard
                                                        // focus, so we should set focus somewhere else
                    _FindCustom(pcsi);

                    // BUG #57358. We tell the Zone Manager to change to [High/Med/Low] level because we want
                    //             the policy values for those, but we don't want it to change the level from
                    //             custom.  So, after it changes the setting from Custom, we change it back.
                    // Save the level as custom

                    // we use send message instead of post because there is no chance of this button
                    // receiving multiple signals at one click, and we need the change level message to be
                    // processed before the apply message below
                    SendMessage(pcsi->pSec->hDlg, WM_APP, (WPARAM) 0, (LPARAM) URLTEMPLATE_CUSTOM);

                    // Saves custom to registry and Handles updateallwindows 
                    // and securitychanged calls

                    // APPCOMPAT: Force a call to SetZoneAttributes when anything in custom changes.
                    // This forces the security manager to flush any caches it has for that zone. 
                    pcsi->pSec->fChanged = TRUE;

                    SecurityDlgApplyNow(pcsi->pSec, TRUE);

                    pcsi->fChanged = FALSE;
                    break;
                }
                    

                default:
                    return FALSE;
            }
            return TRUE;                
            break;

        case WM_HELP:           // F1
        {
            LPHELPINFO lphelpinfo;
            lphelpinfo = (LPHELPINFO)lParam;

            TV_HITTESTINFO ht;
            HTREEITEM hItem;

            // If this help is invoked through the F1 key.
            if (GetAsyncKeyState(VK_F1) < 0)
            {
                // Yes we need to give help for the currently selected item.
                hItem = TreeView_GetSelection(pcsi->hwndTree);
            }
            else
            {
                // Else we need to give help for the item at current cursor position
                ht.pt =((LPHELPINFO)lParam)->MousePos;
                ScreenToClient(pcsi->hwndTree, &ht.pt); // Translate it to our window
                hItem = TreeView_HitTest(pcsi->hwndTree, &ht);
            }

                        
            if (FAILED(pcsi->pTO->ShowHelp(hItem , HELP_WM_HELP)))
            {
                ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                            HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            }
            break; 

        }
        case WM_CONTEXTMENU:        // right mouse click
        {
            TV_HITTESTINFO ht;

            GetCursorPos( &ht.pt );                         // get where we were hit
            ScreenToClient( pcsi->hwndTree, &ht.pt );       // translate it to our window

            // retrieve the item hit
            if (FAILED(pcsi->pTO->ShowHelp(TreeView_HitTest( pcsi->hwndTree, &ht),HELP_CONTEXTMENU)))
            {           
                ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                            HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            }
            break; 
        }
        case WM_DESTROY:
            if (pcsi)
            {
                if (pcsi->pTO)
                {
                    pcsi->pTO->WalkTree( WALK_TREE_DELETE );
                    pcsi->pTO->Release();
                    pcsi->pTO=NULL;
                }
                
                LocalFree(pcsi);
                SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NULL);
                CoUninitialize();
            }
            break;
    }
    return FALSE;
}

#ifdef UNIX
extern "C" 
#endif
BOOL LaunchSecurityDialogEx(HWND hDlg, DWORD dwZone, DWORD dwFlags)
{
    INITCOMMONCONTROLSEX icex;
    SECURITYINITFLAGS * psif = NULL;

    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC  = ICC_USEREX_CLASSES|ICC_NATIVEFNTCTL_CLASS;
    InitCommonControlsEx(&icex);

    if(g_dwtlsSecInitFlags != (DWORD) -1)
        psif = (SECURITYINITFLAGS *) TlsGetValue(g_dwtlsSecInitFlags);
    if(psif)
    {
        psif->fForceUI = dwFlags & LSDFLAG_FORCEUI;
        psif->fDisableAddSites = dwFlags & LSDFLAG_NOADDSITES;
        psif->dwZone = dwZone;
    }

    // passing in a NULL psif is okay
    DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_SECSTANDALONE), hDlg,
                           SecurityDlgProc, (LPARAM) psif);
    
    return TRUE;
}

// backwards compatability
#ifdef UNIX
extern "C"
#endif
void LaunchSecurityDialog(HWND hDlg, DWORD dwZone)
{
    LaunchSecurityDialogEx(hDlg, dwZone, LSDFLAG_DEFAULT);
}

#ifdef UNIX
extern "C" 
#endif
void LaunchSiteCertDialog(HWND hDlg)
{
    CRYPTUI_CERT_MGR_STRUCT ccm = {0};
    ccm.dwSize = sizeof(ccm);
    ccm.hwndParent = hDlg;
    CryptUIDlgCertMgr(&ccm);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\shalias.cpp ===
/****************************************************************************
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1994
 *  All rights reserved
 *
 ***************************************************************************/

#ifdef UNIX_FEATURE_ALIAS

#undef UNICODE

#include "inetcplp.h"
#include "shalias.h"

#include "mluisupp.h"

static TCHAR g_szAliasKey[]     = TEXT("Software\\Microsoft\\Internet Explorer\\Unix\\Alias");

// Member function definitions for CAlias
CAlias::CAlias( TCHAR * name )
{
    m_alias = (TCHAR *) LocalAlloc( LPTR, (lstrlen(name) + 1)*sizeof(TCHAR) );
    StrCpy( m_alias, name );
    m_szurl = NULL;
    m_fDirty= TRUE;
}

CAlias::~CAlias()
{
    if( m_alias ) LocalFree( m_alias );
    if( m_szurl ) LocalFree( m_szurl );
}

CAlias::Load()
{
    if(m_alias)
    {
        HKEY hKey;

        TCHAR aliasKey[MAX_PATH], buffer[MAX_PATH];
        StrCpy( aliasKey, g_szAliasKey);
        StrCat( aliasKey, TEXT("\\"));
        StrCat( aliasKey, m_alias );
         
           HRESULT lResult = RegOpenKeyExA(
                  HKEY_CURRENT_USER,
                  aliasKey,
                  0,
                  KEY_QUERY_VALUE | KEY_READ,
                  &hKey);
        if( lResult == ERROR_SUCCESS )
        {
            DWORD dwLen = MAX_PATH;
            if (RegQueryValue( hKey, NULL, buffer,  (long *)&dwLen ) 
                  == ERROR_SUCCESS )
            {
                 m_szurl = (TCHAR *)LocalAlloc( LPTR, (dwLen+1)*sizeof(TCHAR));
                 StrCpy(m_szurl, buffer);
            }
                
            RegCloseKey( hKey );
        }
        else
            return FALSE;
       
    }

    return TRUE;
}

CAlias::Save()
{
    HRESULT lResult;
    HKEY    hKey;
    TCHAR aliasKey[MAX_PATH], buffer[MAX_PATH];
    StrCpy( aliasKey, g_szAliasKey);
    StrCat( aliasKey, TEXT("\\"));
    StrCat( aliasKey, m_alias );
         
    lResult = RegOpenKeyEx(
        HKEY_CURRENT_USER,
        aliasKey,
        0,
        KEY_QUERY_VALUE| KEY_WRITE,
        &hKey);

    if( lResult != ERROR_SUCCESS )
    {
        lResult = RegCreateKey(
                      HKEY_CURRENT_USER,
                      aliasKey,
                      &hKey);      
    }

    if( lResult == ERROR_SUCCESS )
    {
        DWORD dwType = REG_SZ;
        DWORD dwLen  = (lstrlen(m_szurl)+1)*sizeof(TCHAR);

        RegSetValue( hKey, NULL, dwType, m_szurl, dwLen );
        RegCloseKey( hKey);
    }
    else 
        return FALSE;
               
    m_fDirty = FALSE;
    return TRUE;
}


CAlias::Delete()
{
    TCHAR aliasKey[MAX_PATH], buffer[MAX_PATH];
    StrCpy( aliasKey, g_szAliasKey);
    StrCat( aliasKey, TEXT("\\"));
    StrCat( aliasKey, m_alias );
    RegDeleteKey( HKEY_CURRENT_USER, aliasKey ); 
    return TRUE;
}

#ifdef DEBUG
CAlias::Print()
{
    if( m_alias ) printf( m_alias );
    printf(",");
    if( m_szurl ) printf( m_szurl );
    printf("\n");
    return TRUE;
}
#endif

STDAPI_(BOOL) FreeAliases( HDPA aliasListIn )
{
    if(aliasListIn)
    {
        int aliasCount = DPA_GetPtrCount( aliasListIn );

        for(int i=0; i<aliasCount; i++ )
        {
           CAlias * ptr = (CAlias *)DPA_FastGetPtr( aliasListIn, i );
          if(ptr) delete ptr;
        }
        return TRUE;
    }

    return FALSE;
}

STDAPI_(BOOL) AddAliasToList( HDPA aliasListIn, LPTSTR aliasIn, LPTSTR szurl, HWND hwnd )
{
    int index;
    CAlias * ptr;
    TCHAR alias[ MAX_ALIAS_LENGTH + 1 ];
    TCHAR achTemp[MAX_ALIAS_LENGTH], achTemp2[MAX_ALIAS_LENGTH];

    if (aliasListIn && aliasIn && lstrlen(aliasIn)<MAX_ALIAS_LENGTH)
    {
        StrCpy( alias, aliasIn );
        EatSpaces( alias );
        if((index = FindAliasIndex( aliasListIn, alias )) != -1)
        {
            if( !hwnd ) 
                return FALSE;

            MLLoadShellLangString(IDS_ERROR_ALIAS_ALREADY_EXISTS,
                achTemp, sizeof(achTemp));
            MLLoadShellLangString(IDS_TITLE_ALIASADD,
                achTemp2, sizeof(achTemp2));

            if(hwnd && MessageBox(hwnd, achTemp, achTemp2 , MB_YESNO|MB_ICONQUESTION) != IDYES)
                 return FALSE;

            ptr = (CAlias *)DPA_FastGetPtr( aliasListIn, index );
            SetAliasInfo( ptr, NULL, szurl );
            return TRUE;
        }
        else
        {
            ptr = new CAlias( alias );
            SetAliasInfo( ptr, NULL, szurl );
            DPA_InsertPtr(aliasListIn, 0x7FFF, (LPVOID)ptr);
            return TRUE;
        }
    }

    return FALSE;
}

STDAPI_(BOOL) SaveAliases( HDPA aliasListIn )
{
    // Save the currently changed aliases
    if( aliasListIn )
    {
        int count = DPA_GetPtrCount( aliasListIn );

        for(int i=0;i<count;i++)
        {
            CAlias * pAlias = (CAlias *)DPA_FastGetPtr( aliasListIn, i );
            if(pAlias && pAlias->m_fDirty)
            {
                pAlias->Save();
            }
        }

        return TRUE;
    }

    return FALSE;
}

STDAPI_(BOOL) LoadAliases( HDPA aliasListIn )
{
    HKEY hKey, hKeyAlias;
    int index = 0;
    DWORD dwLen  = MAX_PATH;

    if(aliasListIn) 
        FreeAliases( aliasListIn );

    TCHAR * buffer = (TCHAR *)LocalAlloc( LPTR, (MAX_PATH+1)*sizeof(TCHAR) );

    LONG lResult = RegOpenKeyExA(
                HKEY_CURRENT_USER,
                g_szAliasKey,
                0,
                KEY_QUERY_VALUE | KEY_READ,
                &hKeyAlias);
    
    if( lResult == ERROR_SUCCESS )
    {
        while( buffer )
        {
            dwLen  = MAXPATH; 
            if( RegEnumKeyEx( hKeyAlias, index, buffer, &dwLen,
                              NULL, NULL, NULL, NULL )
                == ERROR_NO_MORE_ITEMS ) break;
            {
                CAlias * ptr = new CAlias( buffer );

                if(ptr->Load())
                {
                   DPA_InsertPtr(aliasListIn, 0x7FFF, (LPVOID)ptr);
                   ptr->m_fDirty = FALSE;
                }
                else
                   delete ptr;

                index++;
            }
        }

        if(buffer) LocalFree( buffer );
        RegCloseKey( hKeyAlias );
    }

    return TRUE;
}


#ifdef DEBUG
STDAPI_(BOOL) PrintAliases( HDPA aliasListIn )
{
    printf("Listing Aliases:\n");

    if( !aliasListIn ) return FALSE;

    int aliasCount = DPA_GetPtrCount( aliasListIn );
    for(int i=0; i<aliasCount; i++ )
    {
       CAlias * ptr = (CAlias *)DPA_FastGetPtr( aliasListIn, i );
       ptr->Print();
    }

    return TRUE;
}
#endif

STDAPI_(INT) FindAliasIndex(HDPA aliasListIn , LPTSTR alias)
{
    if( ! aliasListIn ) return -1;

    int aliasCount = DPA_GetPtrCount( aliasListIn );
    for(int i = 0; i< aliasCount;i++ )
    {
        CAlias * ptr = (CAlias *)DPA_FastGetPtr( aliasListIn, i );
        if( !StrCmpI(alias, ptr->m_alias) )
            return i;
    }

    return -1;
}

STDAPI_(BOOL) FindAliasByURL(HDPA aliasListIn , LPTSTR szurl, LPTSTR aliasIn, INT cchAlias)
{
    if( ! aliasListIn ) return FALSE;

    int aliasCount = DPA_GetPtrCount( aliasListIn );
    for(int i = 0; i< aliasCount;i++ )
    {
        CAlias * ptr = (CAlias *)DPA_FastGetPtr( aliasListIn, i );
        if( !StrCmp(szurl, ptr->m_szurl) )
        {
            StrCpy( aliasIn, ptr->m_alias );
            return TRUE;
        }
    }

    return FALSE;
}

STDAPI_(BOOL) GetURLForAlias(HDPA aliasListIn, LPTSTR alias, LPTSTR szUrl, int cchUrl )
{
    int index = -1;

    if(!aliasListIn || !alias || !szUrl || cchUrl <= 0 ) return FALSE;
    
    // ENTERCRITICAL;

    if( (index = FindAliasIndex(aliasListIn, alias) ) != -1 )
    {
         CAlias * ptr = (CAlias *)DPA_FastGetPtr( aliasListIn, index );
         StrCpy( szUrl, ptr->m_szurl );
    }

Done:
    // LEAVECRITICAL;
    return (index != -1);  
}


STDAPI_(LPCTSTR) GetAliasName( CAlias * ptr )
{
    if( ptr )
        return ptr->m_alias;
    return NULL;
}

STDAPI_(LPCTSTR) GetAliasUrl( CAlias * ptr )
{
    if( ptr )
        return ptr->m_szurl;
    return NULL;
}

STDAPI_(LPVOID) CreateAlias( LPTSTR str )
{
    return new CAlias(str);
}

STDAPI_(VOID) DestroyAlias( CAlias * ptr )
{
    if( ptr ) delete ptr;
}

STDAPI_(BOOL) SetAliasInfo( CAlias * ptr, TCHAR * alias, TCHAR * url )
{
    if( ptr )
    {
        if(alias)
        {
           if( ptr->m_alias ) LocalFree( ptr->m_alias );
           ptr->m_alias = DuplicateString( alias );
           ptr->m_fDirty= TRUE;
        }
        if(url)
        {
           if( ptr->m_szurl ) LocalFree( ptr->m_szurl );
           ptr->m_szurl = DuplicateString( url );
           ptr->m_fDirty= TRUE;
        }
    } 
}



#ifdef UNICODE
STDAPI_(BOOL) FindAliasByURLA(HDPA aliasListIn , LPTSTR szurl, LPTSTR aliasIn, INT cchAlias)
{
    WCHAR szwurl[MAX_URL_STRING];
    WCHAR aliasw[MAX_ALIAS_LENGTH];

    if( !szurl || !aliasIn || !aliasListIn ) 
        return FALSE;

    SHAnsiToUnicode( aliasIn, alias
}

STDAPI_(BOOL) AddAliasToListA( HDPA aliasListIn, LPTSTR aliasIn, LPTSTR szurl, HWND hwnd )
{
    return FALSE;
}


#else

TCHAR *DuplicateString( TCHAR *orig )
{
    TCHAR * newStr;
    if( !orig ) return NULL;

    newStr  = (TCHAR *)LocalAlloc( LPTR, (lstrlen(orig) + 1)*sizeof(TCHAR));
    if(newStr) StrCpy( newStr, orig );

    return newStr;
}

TCHAR *EatSpaces( TCHAR * str )
{
    if( !str ) return NULL;

    TCHAR *ptr = str, *tmpStr = DuplicateString( str );
    TCHAR *tmpPtr = tmpStr;

    while( *tmpStr )
    {
        if(*tmpStr == TEXT(' ')  || *tmpStr == TEXT('\t') || 
           *tmpStr == TEXT('\n') || *tmpStr == TEXT('\r') || 
            // Remove special characters.
            (int)(*tmpStr) >= 127)
            tmpStr++; 
        else
            *ptr++ = *tmpStr++;
    }

    *ptr = TEXT('\0');

    LocalFree( tmpPtr );

    return str;
}

#endif /* UNICODE */

#endif /* UNIX_FEATURE_ALIAS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\unixstuff.h ===
#ifndef _UNIXSTUFF_H_
#define _UNIXSTUFF_H_

#include "cachecpl.h"

#define FONT_UPDATE_TICK 150

UINT  RegPopulateEditText(HWND hwndCB, HKEY hkeyProtocol);
BOOL  LocalFileCheck(LPCTSTR aszFileName);
BOOL  FoundProgram(HWND hwndDlg, int nIDDlgItem);
void  FontUpdateFeedBack(int nTick, void *pvParam);
VOID  DrawXFontButton(HWND hDlg, LPDRAWITEMSTRUCT lpdis);

BOOL  IsCacheReadOnly();

BOOL CALLBACK FontUpdDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

#endif // _UNIXSTUFF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\unixstuff.cpp ===
#ifdef unix

#include <tchar.h>
#include "inetcplp.h"
#include <shsemip.h>
#include <mluisupp.h>

#include <mainwin.h>  // _MAX_FNAME
#include <unistd.h>

#define UNIX_EDITOR_ENV TEXT("EDITOR")
#define UNIX_EDITOR_REG TEXT("command")

//
// Private Functions and Structures
//
BOOL ProgramsDlgInit( HWND hDlg);

typedef struct {
    HWND hDlg;          // dialog windows handle
    HWND hwndMail;      // Mail dropdown
    HWND hwndNews;      // News dropdown
    HWND hwndCalendar;  // Calendar dropdown
    HWND hwndContact;   // Contact dropdown
    HWND hwndCall;      // Internet call dropdown

    BOOL bAssociationCheck;     // Is IE the default browser?

    int  iMail;
    int  iNews;
    int  iCalendar;
    int  iContact;
    int  iCall; 
    BOOL fChanged;
} PROGRAMSPAGE, *LPPROGRAMSPAGE;

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

#ifdef WALLET    
typedef int (*PFN_DISPLAYWALLETPAYDIALOG_PROC)(HWND, HINSTANCE, LPTSTR, int);
typedef int (*PFN_DISPLAYWALLETADDRDIALOG_PROC)(HWND, HINSTANCE, LPTSTR, int);
#endif

void FindEditClient(LPTSTR szProtocol, HWND hwndDlg, int nIDDlgItem, LPTSTR szPath)
{
    TCHAR    szCurrent[MAX_PATH];
    TCHAR    szMsg[MAX_PATH];
    HKEY    hkey;
    DWORD   dw;
    HWND    hwnd;

    // get the name of the new client
    if (hwnd = GetDlgItem(hwndDlg, nIDDlgItem))
    {
        Edit_GetText(hwnd, szCurrent, MAX_PATH);
        if (RegCreateKeyEx(HKEY_CURRENT_USER, szPath,
            0, NULL, 0, KEY_READ|KEY_WRITE, NULL, &hkey, &dw) == ERROR_SUCCESS)
        {        
            DWORD   cb;
    
            cb = (lstrlen(szCurrent)+1)*sizeof(TCHAR);
            RegSetValueEx(hkey, REGSTR_PATH_CURRENT, NULL, REG_SZ, (LPBYTE)szCurrent, cb);
            // close the keys
            RegCloseKey(hkey);        
        
        }   // if RegCreateKeyEx()
    }
}   // FindEditClient()

BOOL  FoundProgram(HWND hwndDlg, int nIDDlgItem)
{
    TCHAR   szCurrent[MAX_PATH];
    CHAR    szCurrentA[MAX_PATH]; 
    TCHAR   szMsg[MAX_PATH];
    HWND    hwnd;
    DWORD   dwCurChar;
	BOOL    bPath = FALSE;

    // get the name of the new client
    if (hwnd = GetDlgItem(hwndDlg, nIDDlgItem))
    {
        if (!IsWindowEnabled(hwnd))
            return TRUE;
        Edit_GetText(hwnd, szCurrent, MAX_PATH);
        for (dwCurChar = 0; dwCurChar < lstrlen(szCurrent); dwCurChar++)
        {
            if (szCurrent[dwCurChar] == TEXT('/'))
            {
                bPath = TRUE;
                break;
            }
        }
        if (!bPath)  // if it's file name with no path we assume it's in the user's PATH
            return TRUE;
#ifdef UNICODE
	WideCharToMultiByte(CP_ACP, 0, szCurrent, -1, szCurrentA, MAX_PATH, NULL, NULL);
        if (access(szCurrentA, X_OK) == 0)
#else
        if (access(szCurrent, X_OK) == 0)
#endif
            return TRUE;
    }

    return FALSE;
}   // FoundProgram()


HRESULT ViewScript(TCHAR *lpszPath)
{
    HRESULT         hr = S_OK;

    TCHAR           tszPath[MAX_PATH];
    TCHAR           tszCommand[INTERNET_MAX_URL_LENGTH];
    TCHAR           tszExpandedCommand[INTERNET_MAX_URL_LENGTH];
    UINT            nCommandSize;
    int             i;
    HKEY    hkey;
    DWORD   dw;
    TCHAR *pchPos;
    BOOL bMailed;
    STARTUPINFO stInfo;

    _tcscpy(tszPath, lpszPath);

    hr = RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_VSOURCECLIENTS, 0, NULL, 0, KEY_READ, NULL, &hkey, &dw);
    if (hr != ERROR_SUCCESS)
        goto Cleanup;
    dw = INTERNET_MAX_URL_LENGTH;
    hr = RegQueryValueEx(hkey, REGSTR_PATH_CURRENT, NULL, NULL, (LPBYTE)tszCommand, &dw);
    if (hr != ERROR_SUCCESS)
    {
        RegCloseKey(hkey);
        goto Cleanup;
    }

    dw = ExpandEnvironmentStrings(tszCommand, tszExpandedCommand, INTERNET_MAX_URL_LENGTH);
    if (!dw)
     {
        _tcscpy(tszExpandedCommand, tszCommand);
     }
    _tcscat(tszCommand, tszExpandedCommand);
    for (i = _tcslen(tszCommand); i > 0; i--)
	if (tszCommand[i] == TEXT('/'))
	{
	    tszCommand[i] = TEXT('\0');
	    break;
	}
    _tcscat(tszCommand, TEXT(" "));
    _tcscat(tszCommand, tszPath);

    memset(&stInfo, 0, sizeof(stInfo));
    stInfo.cb = sizeof(stInfo);
    stInfo.wShowWindow= SW_SHOWNORMAL;
    bMailed = CreateProcess(tszExpandedCommand, tszCommand, NULL, NULL, TRUE, CREATE_NEW_CONSOLE, NULL, NULL, &stInfo, NULL);
 
Cleanup:

    return hr;
}

BOOL EditScript(HKEY hkeyProtocol)
{
    HKEY hKey;
    TCHAR tszCurrent[MAX_PATH];
    TCHAR tszScript[MAX_PATH];
    DWORD dw;

    dw = MAX_PATH;
    if (RegQueryValueEx(hkeyProtocol, REGSTR_PATH_CURRENT, NULL, NULL, (LPBYTE)tszCurrent, &dw)
        != ERROR_SUCCESS)
    {
        return FALSE;
    }    
    ExpandEnvironmentStrings(tszCurrent, tszScript, INTERNET_MAX_URL_LENGTH);

    return ViewScript(tszScript);
}

BOOL FindScript(HWND hwndLabel, HKEY hkeyProtocol)
{
    TCHAR tszCurrent[2*MAX_PATH + 1 ];
    TCHAR tszScript[2*MAX_PATH + 1];
    TCHAR tszFilter[5];
    DWORD dw;
    OPENFILENAME ofn;

    dw = MAX_PATH;
    if (RegQueryValueEx(hkeyProtocol, REGSTR_PATH_CURRENT, NULL, NULL, (LPBYTE)tszCurrent, &dw)
        != ERROR_SUCCESS)
    {
        return FALSE;
    }    

    tszCurrent[MAX_PATH] = TEXT('\0');

    ExpandEnvironmentStrings(tszCurrent, tszScript, INTERNET_MAX_URL_LENGTH);
    _tcscpy(tszCurrent, tszScript);

    BOOL bDirFound = FALSE;
    int  i;
    for (i = _tcslen(tszCurrent) - 1; i>=0; i--)
        if (tszCurrent[i] == TEXT('/') )
	{
	    tszCurrent[i] = TEXT('\0');
        bDirFound = TRUE;
	    break;
	}

    if( !bDirFound )
        tszCurrent[0] = TEXT('\0');
    else
        _tcscpy( tszScript, tszCurrent+i+1 );

    tszScript[ _MAX_FNAME - 1 ] = TEXT('\0');

    memset((void*)&tszFilter, 0, 5 * sizeof(TCHAR));
    tszFilter[0] = TEXT('*');
    tszFilter[2] = TEXT('*');

    memset((void*)&ofn, 0, sizeof(ofn));
    ofn.lpstrFilter = tszFilter;
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwndLabel;
    ofn.lpstrFile = tszScript;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrInitialDir = tszCurrent;
    ofn.Flags = OFN_HIDEREADONLY;

    if (GetOpenFileName(&ofn))
    {
        SendMessage(hwndLabel, EM_SETSEL, 0, -1);
        SendMessage(hwndLabel, EM_REPLACESEL, 0, (LPARAM)tszScript);
    }    

    return TRUE;
}
#endif


// Function used to determine if the given file exists in the directory
// that the current process is running from
BOOL LocalFileCheck(LPCTSTR aszFileName)
{
    // Determinate the base path of the current process binary
    TCHAR szPath[MAX_PATH];
    GetModuleFileName(NULL, szPath, sizeof(szPath)/sizeof(szPath[0]));

    // Find the final element separator if there is one
#ifdef UNICODE
    LPTSTR szPathName = _tcsrchr(szPath, FILENAME_SEPARATOR_W);
#else
    LPTSTR szPathName = _tcsrchr(szPath, FILENAME_SEPARATOR);
#endif
    DWORD dwPathLength;
    if (szPathName)
    {
        szPathName[1] = TEXT('\0');

        dwPathLength = szPathName-szPath+1;
    }
    else
    {
	dwPathLength = _tcslen(szPath)+1;

#ifdef UNICODE
        _tcsncat(szPath, FILENAME_SEPARATOR_STR_W, sizeof(szPath)/
#else
        _tcsncat(szPath, FILENAME_SEPARATOR_STR, sizeof(szPath)/
#endif
            sizeof(szPath[0])-dwPathLength);
    }

    // Append the target file name to the base path (make sure
    // the new string can't overflow the buffer)
    _tcsncat(szPath, aszFileName, sizeof(szPath)/sizeof(szPath[0])-
        dwPathLength-1);

    // Look for the given file without trying to open it
    WIN32_FIND_DATA findData;
    HANDLE hFind = FindFirstFile(szPath, &findData);
    if (hFind == INVALID_HANDLE_VALUE)
    {
        return TRUE;
    }
    else
    {
        FindClose(hFind);

        return(FALSE);
    }
}

UINT RegPopulateEditText(HWND hwndCB, HKEY hkeyProtocol)
{
    TCHAR           szCurrent           [MAX_PATH];
    TCHAR           szExpanded          [MAX_PATH];
    FILETIME        ftLastWriteTime;

    DWORD   cb;

    cb = sizeof(szCurrent);
    if (RegQueryValueEx(hkeyProtocol, REGSTR_PATH_CURRENT, NULL, NULL, (LPBYTE)szCurrent, &cb)
        != ERROR_SUCCESS)
    {
        szCurrent[0]=TEXT('\0');
    }

    ExpandEnvironmentStrings(szCurrent, szExpanded, MAX_PATH);
    SendMessage(hwndCB, EM_REPLACESEL, (WPARAM) 0, (LPARAM) szExpanded);

    return 0;
}   // RegPopulateEditText()

static const CHAR szCacheLockStatus[] = "unixGetWininetCacheLockStatus";
static const TCHAR szCacheLockStatusDll[] = TEXT("WININET.DLL");
typedef void (WINAPI *LPCACHELOCKSTATUS)(BOOL *pBoolReadOnly, TCHAR **ppszLockingHost);

BOOL IsCacheReadOnly()
{
     HINSTANCE hCacheLockStatusDll = NULL;
     LPCACHELOCKSTATUS fnCacheLockStatus;
     BOOL bReadOnlyCacheLockStatus;

     hCacheLockStatusDll = LoadLibrary(szCacheLockStatusDll); 
     if (hCacheLockStatusDll)
     {
        fnCacheLockStatus = (LPCACHELOCKSTATUS)GetProcAddress(hCacheLockStatusDll, szCacheLockStatus); 
        FreeLibrary(hCacheLockStatusDll);
     }

     if (fnCacheLockStatus)
        fnCacheLockStatus(&bReadOnlyCacheLockStatus, NULL);

     return bReadOnlyCacheLockStatus;
}

BOOL CALLBACK FontUpdDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HWND hProg = GetDlgItem(hDlg, IDC_FONTUPD_PROG);
    UINT nTimer = 1;

    switch (uMsg)
    {
       case WM_INITDIALOG:
	    HCURSOR hOldCursor = NULL;
	    HCURSOR hNewCursor = NULL;

	    hNewCursor = LoadCursor(NULL, IDC_WAIT);
	    if (hNewCursor) 
	        hOldCursor = SetCursor(hNewCursor);
	    SendMessage(hProg, PBM_SETRANGE, 0, MAKELPARAM(0, FONT_UPDATE_TICK));
	    SendMessage(hProg, PBM_SETSTEP, 1, 0);
	    SetTimer(hDlg, nTimer, 600, NULL);
	    break;
       case WM_TIMER:
	    KillTimer(hDlg, nTimer);
	    MwFontCacheUpdate(TRUE, FontUpdateFeedBack, FONT_UPDATE_TICK, (void*)hDlg);
	    break;
       case WM_CLOSE:
            EndDialog(hDlg, 0);
       case PBM_SETRANGE:
	    SendMessage(hProg, PBM_SETRANGE, wParam, lParam);
            break;
        case PBM_SETSTEP:
	    SendMessage(hProg, PBM_SETSTEP, wParam, lParam);
            break;
        case PBM_STEPIT:
	    SendMessage(hProg, PBM_STEPIT, wParam, lParam);
            break;
        default:
            return FALSE;
    }
    return TRUE;
}


void  FontUpdateFeedBack(int nTick, void *pvParam) 
{
    HWND hDlg = (HWND)pvParam;
    MSG msg;
    int iMsg = 0;

    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) && iMsg++ < 20)
    {
	TranslateMessage(&msg);
	DispatchMessage(&msg);
    } 
    if (hDlg)
        SendMessage(hDlg, PBM_STEPIT, 0, 0);    
    if (nTick == FONT_UPDATE_TICK - 1)
        SendMessage(hDlg, WM_CLOSE, 0, 0);        
}


VOID DrawXFontButton(HWND hDlg, LPDRAWITEMSTRUCT lpdis)
{
    SIZE thin   = { GetSystemMetrics(SM_CXBORDER), GetSystemMetrics(SM_CYBORDER) };
    RECT rc     = lpdis->rcItem;
    HDC hdc     = lpdis->hDC;
    BOOL bFocus = ((lpdis->itemState & ODS_FOCUS) && !(lpdis->itemState & ODS_DISABLED));

    if (!thin.cx) thin.cx = 1;
    if (!thin.cy) thin.cy = 1;

    FillRect(hdc, &rc, GetSysColorBrush(COLOR_3DFACE));

    //Draw Icon
    HICON hXFIcon;
    if (hXFIcon = LoadIcon(ghInstance, MAKEINTRESOURCE(IDI_FONT)))
    {
        DrawIcon(hdc, (rc.right + rc.left) / 2 - 8, (rc.top + rc.bottom / 2) / 2 - 8, hXFIcon);
    }

    // Draw any caption
    TCHAR szCaption[80];
    int cyText = (rc.bottom + rc.top)/2;

    if (GetWindowText(lpdis->hwndItem, szCaption, ARRAYSIZE(szCaption)))
    {
        COLORREF crText;

        RECT rcText = rc;
        rcText.top = cyText;

        int nOldMode = SetBkMode(hdc, TRANSPARENT);

        if (lpdis->itemState & ODS_DISABLED)
        {
            // Draw disabled text using the embossed look
            crText = SetTextColor(hdc, GetSysColor(COLOR_BTNHIGHLIGHT));
            RECT rcOffset = rcText;
            OffsetRect(&rcOffset, 1, 1);
            DrawText(hdc, szCaption, -1, &rcOffset, DT_VCENTER|DT_SINGLELINE);
            SetTextColor(hdc, GetSysColor(COLOR_BTNSHADOW));
        }
        else
        {
            crText = SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
        }
        DrawText(hdc, szCaption, -1, &rcText, DT_VCENTER|DT_CENTER|DT_SINGLELINE);
        SetTextColor(hdc, crText);
        SetBkMode(hdc, nOldMode);
    }

    // Draw the button portion
    if (lpdis->itemState & ODS_SELECTED)
    {
        DrawEdge(hdc, &rc, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
        OffsetRect(&rc, 1, 1);
    }
    else
    {
        DrawEdge(hdc, &rc, EDGE_RAISED, BF_RECT | BF_ADJUST);
    }

    if (bFocus)
    {
        InflateRect(&rc, -thin.cx, -thin.cy);
        DrawFocusRect(hdc, &rc);
        InflateRect(&rc, thin.cx, thin.cy);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\util.cpp ===
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  UTIL.C - common utility functions
//

//  HISTORY:
//  
//  12/21/94    jeremys     Created.
//

#include "inetcplp.h"
#include <advpub.h>         // For REGINSTALL
#include <mluisupp.h>
#include "brutil.h"
#include <mlang.h>

// function prototypes
VOID _cdecl FormatErrorMessage(TCHAR * pszMsg,DWORD cbMsg,TCHAR * pszFmt,va_list ArgList);
extern VOID GetRNAErrorText(UINT uErr,CHAR * pszErrText,DWORD cbErrText);
extern VOID GetMAPIErrorText(UINT uErr,CHAR * pszErrText,DWORD cbErrText);

/*******************************************************************

    NAME:       MsgBox

    SYNOPSIS:   Displays a message box with the specified string ID

********************************************************************/
int MsgBox(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons)
{
    TCHAR szMsgBuf[MAX_RES_LEN+1];
    TCHAR szSmallBuf[SMALL_BUF_LEN+1];

    MLLoadShellLangString(IDS_APPNAME,szSmallBuf,sizeof(szSmallBuf));
    MLLoadShellLangString(nMsgID,szMsgBuf,sizeof(szMsgBuf));

    MessageBeep(uIcon);
    return (MessageBox(hWnd,szMsgBuf,szSmallBuf,uIcon | uButtons));

}

/*******************************************************************

    NAME:       MsgBoxSz

    SYNOPSIS:   Displays a message box with the specified text

********************************************************************/
int MsgBoxSz(HWND hWnd,LPTSTR szText,UINT uIcon,UINT uButtons)
{
    TCHAR szSmallBuf[SMALL_BUF_LEN+1];
    MLLoadShellLangString(IDS_APPNAME,szSmallBuf,sizeof(szSmallBuf));

    MessageBeep(uIcon);
    return (MessageBox(hWnd,szText,szSmallBuf,uIcon | uButtons));
}

/*******************************************************************

    NAME:       MsgBoxParam

    SYNOPSIS:   Displays a message box with the specified string ID

    NOTES:      extra parameters are string pointers inserted into nMsgID.

********************************************************************/
int _cdecl MsgBoxParam(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons,...)
{

        va_list nextArg;

    BUFFER Msg(3*MAX_RES_LEN+1);    // nice n' big for room for inserts
    BUFFER MsgFmt(MAX_RES_LEN+1);

    if (!Msg || !MsgFmt) {
        return MsgBox(hWnd,IDS_ERROutOfMemory,MB_ICONSTOP,MB_OK);
    }

        MLLoadShellLangString(nMsgID,MsgFmt.QueryPtr(),MsgFmt.QuerySize());

        va_start(nextArg, uButtons);

    FormatErrorMessage(Msg.QueryPtr(),Msg.QuerySize(),
        MsgFmt.QueryPtr(),nextArg);
        va_end(nextArg);
    return MsgBoxSz(hWnd,Msg.QueryPtr(),uIcon,uButtons);
}

BOOL EnableDlgItem(HWND hDlg,UINT uID,BOOL fEnable)
{
    return EnableWindow(GetDlgItem(hDlg,uID),fEnable);
}


/*******************************************************************

    NAME:       LoadSz

    SYNOPSIS:   Loads specified string resource into buffer

    EXIT:       returns a pointer to the passed-in buffer

    NOTES:      If this function fails (most likely due to low
                memory), the returned buffer will have a leading NULL
                so it is generally safe to use this without checking for
                failure.

********************************************************************/
LPTSTR LoadSz(UINT idString,LPTSTR lpszBuf,UINT cbBuf)
{
    ASSERT(lpszBuf);

    // Clear the buffer and load the string
    if ( lpszBuf )
    {
        *lpszBuf = '\0';
        MLLoadString( idString, lpszBuf, cbBuf );
    }
    return lpszBuf;
}

/*******************************************************************

    NAME:       FormatErrorMessage

    SYNOPSIS:   Builds an error message by calling FormatMessage

    NOTES:      Worker function for DisplayErrorMessage

********************************************************************/
VOID _cdecl FormatErrorMessage(TCHAR * pszMsg,DWORD cbMsg,TCHAR * pszFmt,va_list ArgList)
{
    ASSERT(pszMsg);
    ASSERT(pszFmt);

    // build the message into the pszMsg buffer
    DWORD dwCount = FormatMessage(FORMAT_MESSAGE_FROM_STRING,
        pszFmt,0,0,pszMsg,cbMsg,&ArgList);
    ASSERT(dwCount > 0);
}


/*----------------------------------------------------------
Purpose: Calls the ADVPACK entry-point which executes an inf
         file section.

*/
HRESULT CallRegInstall(LPSTR szSection)
{
    HRESULT hr = E_FAIL;

    STRENTRY seReg[] = {
#ifdef WINNT
        { "CHANNELBARINIT", "no" }, // channel bar off by default on NT
#else
        { "CHANNELBARINIT", "yes" } // channel bar on by default on Win95/98
#endif
    };
    STRTABLE stReg = { ARRAYSIZE(seReg), seReg };

    RegInstall(ghInstance, szSection, &stReg);

    return hr;
}

//
// Code page to Script mapping table
// Can't load MLang during setup, so, we port this table from MLANG
//
typedef struct tagCPTOSCRIPT{
	UINT        uiCodePage;
	SCRIPT_ID   sid;
} CPTOSCRIPT;

const CPTOSCRIPT CpToScript [] = 
{
    {1252,  sidAsciiLatin},
    {1250,  sidAsciiLatin},
    {1254,  sidAsciiLatin},
    {1257,  sidAsciiLatin},
    {1258,  sidAsciiLatin},
    {1251,  sidCyrillic  },
    {1253,  sidGreek     },
    {1255,  sidHebrew    },
    {1256,  sidArabic    },
    {874,   sidThai      },
    {932,   sidKana      },
    {936,   sidHan       },
    {949,   sidHangul    },
    {950,   sidBopomofo  },
    {50000, sidUserDefined},
};


/*******************************************************************

    NAME:       MigrateIEFontSetting

    SYNOPSIS:   Port IE4 font setting data to IE5 script settings

    NOTES:      

********************************************************************/

VOID MigrateIEFontSetting(void)
{
    HKEY    hKeyInternational;
    HKEY    hKeyScripts;

    // Open IE international setting registry key
    if (ERROR_SUCCESS ==
        RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_INTERNATIONAL, NULL, KEY_READ, &hKeyInternational))
    {
        DWORD dwIndex = 0;
        DWORD dwCreate = 0;
        TCHAR szCodePage[1024] = {0};

        // Open/Create scripts key
        if (ERROR_SUCCESS == RegCreateKeyEx(hKeyInternational, REGSTR_VAL_FONT_SCRIPTS, 0, NULL, 
                                            REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, 
                                            NULL, &hKeyScripts, &dwCreate))
        {
            // If scripts already exists, we're upgrading from IE5, no data porting needed
            if (dwCreate == REG_CREATED_NEW_KEY)
            {
                DWORD dwSize = ARRAYSIZE(szCodePage);
                TCHAR szFont[LF_FACESIZE];

    	        while (ERROR_SUCCESS == RegEnumKeyEx(hKeyInternational, dwIndex, szCodePage, 
                                                     &dwSize, NULL, NULL, NULL, NULL))
    	        {
                    UINT uiCP = StrToInt(szCodePage);

                    for (int i=0; i<ARRAYSIZE(CpToScript); i++)
                    {
                        if (uiCP == CpToScript[i].uiCodePage)
                        {
                            HKEY hKeyCodePage;

                            if ( ERROR_SUCCESS == RegOpenKeyEx(hKeyInternational, szCodePage, 
                                                               NULL, KEY_READ, &hKeyCodePage))
                            {
                                HKEY    hKeyScript;
                                CHAR    szScript[1024];
                                    
                                wsprintfA(szScript, "%d", CpToScript[i].sid);

                                // Port code page font data to script font data
                                // If CP == 1252, we always need to use it to update Latin CP font info
                                if ((ERROR_SUCCESS == RegCreateKeyExA(hKeyScripts, szScript, 0, NULL, 
                                            REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, 
                                            NULL, &hKeyScript, &dwCreate)) &&
                                    ((dwCreate == REG_CREATED_NEW_KEY) || (uiCP == 1252)))
                                {
                                    DWORD cb = sizeof(szFont);

                                    if (ERROR_SUCCESS == RegQueryValueEx(hKeyCodePage, 
                                                            REGSTR_VAL_FIXED_FONT, NULL, NULL,
                                                            (LPBYTE)szFont, &cb))
                                    {
                                        RegSetValueEx(hKeyScript, REGSTR_VAL_FIXED_FONT, 0, 
                                            REG_SZ, (LPBYTE)szFont, cb);
                                    }

                                    cb = sizeof(szFont);
                                    if (ERROR_SUCCESS == RegQueryValueEx(hKeyCodePage, 
                                                            REGSTR_VAL_PROP_FONT, NULL, NULL,
                                                            (LPBYTE)szFont, &cb))
                                    {
                                        RegSetValueEx(hKeyScript, REGSTR_VAL_PROP_FONT, 0, 
                                            REG_SZ, (LPBYTE)szFont, cb);
                                    }
                                    RegCloseKey(hKeyScript);
                                }                                
                                RegCloseKey(hKeyCodePage);
                            }
                        }                    
                    }
                    dwIndex++;
                    dwSize = ARRAYSIZE(szCodePage);
                }
            }
            RegCloseKey(hKeyScripts);
        }
        RegCloseKey(hKeyInternational);
    }        
}

/*----------------------------------------------------------
Purpose: Install/uninstall user settings

*/
STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
#ifdef DEBUG
    if (IsFlagSet(g_dwBreakFlags, BF_ONAPIENTER))
    {
        TraceMsg(TF_ALWAYS, "Stopping in DllInstall");
        DEBUG_BREAK;
    }
#endif

    if (bInstall)
    {
        //
        // We use to delete the whole key here - that doesn't work anymore
        // because other people write to this key and we don't want 
        // to crush them. If you need to explicity delete a value
        // add it to ao_2 value
        // CallRegInstall("UnregDll");
        CallRegInstall("RegDll");
        
        // If we also have the integrated shell installed, throw in the options
        // related to the Integrated Shell.
        if (WhichPlatform() == PLATFORM_INTEGRATED)
            CallRegInstall("RegDll.IntegratedShell");

        // NT5's new shell has special reg key settings
        if (GetUIVersion() >= 5)
            CallRegInstall("RegDll.NT5");

        // Run Whistler-specific settings.
        if (IsOS(OS_WHISTLERORGREATER))
        {
            CallRegInstall("RegDll.Whistler");
        }

        // Port IE4 code page font setting
        MigrateIEFontSetting();
    }
    else
    {
        CallRegInstall("UnregDll");
    }

    return S_OK;
}


#define REGSTR_CCS_CONTROL_WINDOWS  REGSTR_PATH_CURRENT_CONTROL_SET TEXT("\\WINDOWS")
#define CSDVERSION      TEXT("CSDVersion")

BOOL IsNTSPx(BOOL fEqualOrGreater, UINT uMajorVer, UINT uSPVer)
{
    HKEY    hKey;
    DWORD   dwSPVersion;
    DWORD   dwSize;
    BOOL    fResult = FALSE;
    OSVERSIONINFO VerInfo;

    VerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionEx(&VerInfo);

    // make sure we're on NT4 or greater (or specifically NT4, if required)
    if (VER_PLATFORM_WIN32_NT != VerInfo.dwPlatformId ||
        (!fEqualOrGreater && VerInfo.dwMajorVersion != uMajorVer) ||
        (fEqualOrGreater && VerInfo.dwMajorVersion < uMajorVer))
        return FALSE;

    if (fEqualOrGreater && VerInfo.dwMajorVersion > uMajorVer)
        return TRUE;

    // check for installed SP
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_CCS_CONTROL_WINDOWS, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(dwSPVersion);
        if (RegQueryValueEx(hKey, CSDVERSION, NULL, NULL, (unsigned char*)&dwSPVersion, &dwSize) == ERROR_SUCCESS)
        {
            dwSPVersion = dwSPVersion >> 8;
        }
        RegCloseKey(hKey);

        if (fEqualOrGreater)
            fResult = (dwSPVersion >= uSPVer ? TRUE : FALSE);
        else
            fResult = (dwSPVersion == uSPVer ? TRUE : FALSE);
    }

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\dll\makefile.inc ===
..\inetcpl.rc : ..\inetcpld.rc $(SELFREGNAME)

!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\shassoc.cpp ===
/****************************************************************************
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1994
 *  All rights reserved
 *
 * This module handles the File Association UI
 *
 ***************************************************************************/

#include "inetcplp.h"
#include "mluisupp.h"
#include <unistd.h>

// For definition of FTA_OpenIsSafe
// the file class's open verb may be safely invoked for downloaded files
#include "../inc/filetype.h"

// Macros required for default button processing
#define REMOVE_DEF_BORDER(hDlg, cntrl )  \
    SendMessage( hDlg,  DM_SETDEFID, -1, 0 ); \
    SendDlgItemMessage( hDlg, cntrl, BM_SETSTYLE, BS_PUSHBUTTON, TRUE );  \

#define SET_DEF_BORDER(hDlg, cntrl )  \
    SendMessage( hDlg, DM_SETDEFID, cntrl, 0 );   \
    SendDlgItemMessage( hDlg, cntrl, BM_SETSTYLE, BS_DEFPUSHBUTTON, TRUE );  \

// Editing modes
#define NORMAL   0x00
#define ADDING   0x01
#define UPDATING 0x02

// Association status
#define NEW      0x01
#define UPD      0x02
#define UNM      0x03

#define LocalRealloc(a, b) LocalReAlloc(a, b, LMEM_MOVEABLE)

static TCHAR g_szDefaultIcon[]  = TEXT("shell32.dll,3");
static TCHAR g_szIEUnix[]       = TEXT("IEUNIX");
static TCHAR g_szIEUnixEntry[]   = TEXT("IEUNIX Specific entry");
static TCHAR g_szEditFlags[]    = TEXT("EditFlags");
static TCHAR g_szDocClass[]     = TEXT("DocClass");
static TCHAR g_szMimeKey[]      = TEXT("MIME\\Database\\Content Type");
static TCHAR g_szCmndSubKey[]   = TEXT("Shell\\Open\\Command");
static TCHAR g_szPolicySubKey[] = REGSTR_PATH_INETCPL_RESTRICTIONS;
static TCHAR g_szPolicyName[]   = TEXT("Mappings");

int SwitchToAddMode( HWND hDlg );
int SwitchToNrmlMode( HWND hDlg );
BOOL CALLBACK EnterAssocDlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);


BOOL IsAssocEnabled()
{
    HKEY  hKey = NULL;

    LONG lResult = RegOpenKey(HKEY_CURRENT_USER, g_szPolicySubKey, &hKey);

    if( lResult == ERROR_SUCCESS )
    {
	// Get then size first
	DWORD dwPolicy, dwType, dwSize = sizeof(DWORD);
	if (RegQueryValueEx( hKey, g_szPolicyName, NULL, &dwType, (LPBYTE)&dwPolicy, &dwSize ) == ERROR_SUCCESS )
	{
	    if( dwPolicy )
	    {
	        RegCloseKey( hKey );
	        return FALSE;
	    }
	}
	RegCloseKey( hKey );
    }
    return TRUE;
}

/*
** AddStringToComboBox()
**
** Adds a string to a combo box.  Does not check to see if the string has
** already been added.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
BOOL AddStringToComboBox(HWND hwndComboBox, LPCTSTR pcsz)
{
   BOOL bResult;
   LONG lAddStringResult;

   lAddStringResult = SendMessage(hwndComboBox, CB_ADDSTRING, 0, (LPARAM)pcsz);

   bResult = (lAddStringResult != CB_ERR &&
              lAddStringResult != CB_ERRSPACE);

   return(bResult);
}


/*
** SafeAddStringToComboBox()
**
** Adds a string to a combo box.  Checks to see if the string has already been
** added.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
BOOL SafeAddStringToComboBox(HWND hwndComboBox, LPCTSTR pcsz)
{
   BOOL bResult;

   if (SendMessage(hwndComboBox, CB_FINDSTRINGEXACT, 0, (LPARAM)pcsz) == CB_ERR)
      bResult = AddStringToComboBox(hwndComboBox, pcsz);
   else
   {
      bResult = TRUE;
   }

   return(bResult);
}

typedef struct ASSOCIATION
{
    HWND hDlg;
    int  mode;
    BOOL fInternalChange;
    BOOL fChanged;
} ASSOCINFO, * LPASSOCTABINFO;

typedef struct ENTERASSOC
{
    LPASSOCTABINFO pgti;
    TCHAR *pszAssoc;
} ENTERASSOC, * LPENTERASSOC;

#define PGTI_FROM_HDLG( hDlg ) \
    ((LPASSOCTABINFO)GetWindowLong(hDlg, DWL_USER)) \

#define PGTI_FROM_PARENT_HDLG( hDlg ) \
    ((LPASSOCTABINFO)GetWindowLong(GetParent(hDlg), DWL_USER)) \

class CMime
{
public:
    TCHAR * m_mime;
    TCHAR * m_exts;

    CMime( TCHAR * name );
   ~CMime();

    // Operations defined for Asscociation

};

CMime::CMime( TCHAR * name )
{
    m_mime = (TCHAR *) LocalAlloc( LPTR, (lstrlen(name) + 1)*sizeof(TCHAR) );
    StrCpy( m_mime, name );
    m_exts = NULL;
}

CMime::~CMime()
{
    if( m_mime ) LocalFree( m_mime );
    if( m_exts ) LocalFree( m_exts );
}


HDPA mimeList = NULL;

BOOL FreeExtensions( HDPA dpa )
{
    if( dpa == (HDPA)NULL ) return FALSE;

    int count = DPA_GetPtrCount( dpa );

    for(int i=0; i<count; i++ )
    {
        LPTSTR ptr = (LPTSTR)DPA_FastGetPtr( dpa, i );
        if(ptr) LocalFree(ptr);
    }

    DPA_Destroy( dpa );
    return TRUE;
}

class CAssoc
{
public:
    TCHAR * m_type;  // File Type class
    TCHAR * m_desc;  // File TYpe Description
    TCHAR * m_mime;  // File Type Mime
    TCHAR * m_cmnd;  // Shell/open/command
    BOOL    m_safe;  // protected or not
    DWORD   m_edit;  // EditFlags value
    UINT    m_stat;  // Status

    HDPA    m_exts;  // Dynamic array for extensions

    CAssoc( TCHAR * name );
   ~CAssoc();
    
    // Operations defined for Asscociation

    Load();
    Save(); 
    Print();
    Delete();

    // Some helper functions

    HDPA   GetExtsOfAssoc( );
    LPTSTR GetDescOfAssoc( );
    LPTSTR GetMimeOfAssoc( );
    LPTSTR GetCmndOfAssoc( );
    DWORD  GetEditOfAssoc( );

};

// Some Helper Function Prototypes

BOOL     FAR PASCAL InitAssocDialog(HWND hDlg, CAssoc * current = NULL);
void     HandleSelChange( LPASSOCTABINFO pgti , BOOL bChangeAppl = TRUE);
TCHAR *  EatSpaces( TCHAR * str );
TCHAR *  ChopSpaces( TCHAR * str );
TCHAR *  DuplicateString( TCHAR * str );
CAssoc * GetCurrentAssoc( HWND hDlg );

// Member function definitions for CAssoc.

CAssoc::CAssoc( TCHAR * name )
{
    m_type = (TCHAR *) LocalAlloc( LPTR, (lstrlen(name) + 1)*sizeof(TCHAR) );
    StrCpy( m_type, name );
    m_desc = NULL;
    m_mime = NULL;
    m_cmnd = NULL;
    m_stat = NEW ;
    m_safe = TRUE; // Internal Assoc, Dont mess with this
    m_exts = NULL;
    m_edit = 0;
}

CAssoc::~CAssoc()
{
    if( m_type ) LocalFree( m_type );
    if( m_desc ) LocalFree( m_desc );
    if( m_mime ) LocalFree( m_mime );
    if( m_cmnd ) LocalFree( m_cmnd );

    if( m_exts ) FreeExtensions( m_exts );
}

CAssoc::Load()
{
    if(m_type)
    {
       TCHAR * ptr = NULL;

       m_exts = GetExtsOfAssoc();
       m_edit = GetEditOfAssoc();

       if ((ptr = GetDescOfAssoc( )) != NULL)
       { 
          m_desc = (TCHAR *)LocalAlloc( LPTR, (lstrlen(ptr) + 1)*sizeof(TCHAR));
          StrCpy( m_desc, ptr );
          ptr = NULL;
       }
       else 
           // Each type must have a description. (Required)
           return FALSE;

       if ((ptr = GetMimeOfAssoc()) != NULL)
       {
          m_mime = (TCHAR *)LocalAlloc( LPTR, (lstrlen(ptr) + 1)*sizeof(TCHAR));
          StrCpy( m_mime, ptr );
          ptr = NULL;
       }

       if ((ptr = GetCmndOfAssoc()) != NULL)
       {
          m_cmnd = (TCHAR *)LocalAlloc( LPTR, (lstrlen(ptr) + 1)*sizeof(TCHAR));
          StrCpy( m_cmnd, ptr );
          ptr = NULL;
       }

       m_stat = UNM;
       m_safe = FALSE;
    }

    return TRUE;
}

CAssoc::Save()
{

    if( m_safe ) return TRUE;

    if( m_stat != UPD ) return TRUE;

    // Create a Key for DocType in HKEY_CLASSES_ROOT
    // [doctype
    //   (--reg-val-- "Description")
    //   [defaulticon
    //      (reg-val "shell32.dll,3")
    //   ]
    //   [shell
    //     [open
    //       [command
    //         (--reg-val-- "Command" )
    //       ]
    //     ]
    //   ]
    // ]

    HKEY hKey1, hKey2, hKey3, hKey4;

    LONG lResult = RegOpenKeyEx(
            HKEY_CLASSES_ROOT,
            m_type,
            0,
            KEY_QUERY_VALUE|KEY_WRITE,
            &hKey1);

    if (lResult != ERROR_SUCCESS)
    {
        lResult = RegCreateKey(
        HKEY_CLASSES_ROOT,
        m_type,
        &hKey1);
    }

    if (lResult == ERROR_SUCCESS)
    {
        DWORD dwType = REG_SZ;
        DWORD dwLen  = (lstrlen(m_desc)+1)*sizeof(TCHAR);
        RegSetValue( hKey1, NULL, dwType, m_desc, dwLen );

        // Add IEUNIX tag to this entry
        dwLen  = (lstrlen(g_szIEUnixEntry)+1)*sizeof(TCHAR);
        RegSetValueEx( hKey1, g_szIEUnix, 0,
            dwType, (LPBYTE)g_szIEUnixEntry, dwLen );
        
        // Add Edit flags to this entry
        DWORD value = m_edit;
        RegSetValueEx( hKey1, g_szEditFlags, 0,
            REG_DWORD, (LPBYTE)(&value), sizeof(DWORD) ); 

        HKEY hKey2;

        RegDeleteKey( hKey1, TEXT("defaulticon" ) );
       
        lResult = RegCreateKey(
            hKey1,
            TEXT("defaulticon"),
            &hKey2);

        if(lResult == ERROR_SUCCESS)
        {
            DWORD dwType = REG_SZ;
            DWORD dwLen  = (lstrlen(g_szDefaultIcon)+1)*sizeof(TCHAR);
            RegSetValue( hKey2, NULL, dwType, g_szDefaultIcon, dwLen );
            RegCloseKey( hKey2);
        }

        RegDeleteKey( hKey1, g_szCmndSubKey );

        lResult = RegOpenKeyEx(
                hKey1,
                TEXT("shell"),
                0,
                KEY_QUERY_VALUE| KEY_WRITE,
                &hKey2);
       
        if(lResult != ERROR_SUCCESS)
        {
            lResult = RegCreateKey(
                hKey1,
                TEXT("shell"),
                &hKey2);      
        }

        if(lResult == ERROR_SUCCESS)
        {
            lResult = RegOpenKeyEx(
                hKey2,
                TEXT("open"),
                0,
                KEY_QUERY_VALUE| KEY_WRITE,
                &hKey3);

            if( lResult != ERROR_SUCCESS )
            {
                lResult = RegCreateKey(
                    hKey2,
                    TEXT("open"),
                    &hKey3);      
            }

            if( lResult == ERROR_SUCCESS )
            {
                lResult = RegOpenKeyEx(
                    hKey3,
                    TEXT("command"),
                    0,
                    KEY_QUERY_VALUE| KEY_WRITE,
                    &hKey4);

                if( lResult != ERROR_SUCCESS )
                {
                    lResult = RegCreateKey(
                        hKey3,
                        TEXT("command"),
                        &hKey4);      
                }

                if( lResult == ERROR_SUCCESS )
                {
                    DWORD dwType = REG_SZ;
                    DWORD dwLen  = (lstrlen(m_cmnd)+1)*sizeof(TCHAR);

                    RegSetValue( hKey4, NULL, dwType, m_cmnd, dwLen );
                    RegCloseKey( hKey4);
                }
               
                RegCloseKey(hKey3);
            }

            RegCloseKey(hKey2);
        }   

        RegCloseKey(hKey1);
    }    
  
    // Add mime type to the mimetype data base if it doesn't exist
    LPTSTR mimeKey = (LPTSTR)LocalAlloc( LPTR, (lstrlen(m_mime)+lstrlen(g_szMimeKey) + 3)*sizeof(TCHAR));
    
    if(mimeKey && m_mime)
    {
        StrCpy( mimeKey, g_szMimeKey );
        StrCat( mimeKey, TEXT("\\")  );
        StrCat( mimeKey, m_mime      );
        
        lResult = RegOpenKeyEx(
                HKEY_CLASSES_ROOT,
                mimeKey,
                0,
                KEY_QUERY_VALUE| KEY_WRITE,
                &hKey1);
    
        if(lResult != ERROR_SUCCESS)
        {
            lResult = RegCreateKey(
                HKEY_CLASSES_ROOT,
                mimeKey,
                &hKey1);

            if(lResult == ERROR_SUCCESS && m_exts)
            {
                int count    = DPA_GetPtrCount( m_exts );
                if(count > 0 )
                {
                    LPTSTR firstExt = (LPTSTR)DPA_FastGetPtr( m_exts, 0 );
                    RegSetValueEx( hKey1, TEXT("extension"), NULL,
                        REG_SZ, (LPBYTE)firstExt, (lstrlen(firstExt)+1)*sizeof(TCHAR) );
                }

                RegCloseKey( hKey1 );
            }
        }
        else
        {
            RegCloseKey( hKey1 );
        }

    }

    if(mimeKey) 
         LocalFree(mimeKey);

    // Add extention/document type association
    // [.ext
    //   (--reg-val-- "Application")
    //   (content.type "mimetype"  )
    // ]

    // First remove all the extensions for the current assoc from the
    // registry.

    HDPA prevExts = GetExtsOfAssoc();
    if( prevExts )
    {
        int extCount = DPA_GetPtrCount( prevExts );
        for( int i=0; i< extCount; i++ )
           RegDeleteKey( HKEY_CLASSES_ROOT, (LPTSTR)DPA_FastGetPtr( prevExts, i ) ); 

        FreeExtensions( prevExts );
    }


    if( m_exts )
    {
        int count = DPA_GetPtrCount( m_exts );

        for( int i=0; i<count; i++ )
        { 
            LPTSTR ptr = (LPTSTR)DPA_FastGetPtr( m_exts, i );
            if( ptr && *ptr == TEXT('.') )
            {
                lResult = RegOpenKeyEx(
                    HKEY_CLASSES_ROOT,
                    ptr,
                    0,
                    KEY_QUERY_VALUE| KEY_WRITE,
                    &hKey1);

                if( lResult != ERROR_SUCCESS )
                {
                    lResult = RegCreateKey(
                        HKEY_CLASSES_ROOT,
                        ptr, 
                        &hKey1);      
                }

                if( lResult == ERROR_SUCCESS )
                {
                    DWORD dwType = REG_SZ;
                    DWORD dwLen  = (lstrlen(m_type)+1)*sizeof(TCHAR);
                    RegSetValue( hKey1, NULL, dwType, m_type, dwLen );
                       
                    EatSpaces(m_mime ); 
                    dwLen  = lstrlen(m_mime);
                    if(m_mime && (dwLen=lstrlen(m_mime))>0)
                        RegSetValueEx( hKey1, TEXT("Content Type"), 0,
                            dwType, (LPBYTE)m_mime, (dwLen+1)*sizeof(TCHAR) );

                    // Add IEUNIX tag to this entry
                    dwLen  = (lstrlen(g_szIEUnixEntry)+1)*sizeof(TCHAR);
                    RegSetValueEx( hKey1, g_szIEUnix, 0,
                        dwType, (LPBYTE)g_szIEUnixEntry, dwLen );

                    RegCloseKey( hKey1);
                    hKey1 = NULL;
                }
            }
        }
    } 
    else
        return FALSE; 
    
    return TRUE;
}


CAssoc::Delete()
{
    HKEY hKey;
    
    // Don't touch the safe keys
    if( m_safe ) return FALSE;

    // Delete Application from HKEY_CLASSES_ROOT
    EatSpaces(m_type);
    if(m_type && *m_type)
    {
        // NT restrictions
        TCHAR * key = (TCHAR *)LocalAlloc(LPTR, (lstrlen(m_type) + 200)*sizeof(TCHAR) ) ;

        if(!key) return FALSE;
        
        StrCpy( key, m_type );        
        StrCat( key, TEXT("\\defaulticon") );        
        RegDeleteKey(HKEY_CLASSES_ROOT, key);

        StrCpy( key, m_type );        
        StrCat( key, TEXT("\\") );        
        StrCat( key, g_szCmndSubKey );
        RegDeleteKey(HKEY_CLASSES_ROOT, key);

        StrCpy( key, m_type );        
        StrCat( key, TEXT("\\shell\\open") );        
        RegDeleteKey(HKEY_CLASSES_ROOT, key);

        StrCpy( key, m_type );        
        StrCat( key, TEXT("\\shell") );        
        RegDeleteKey(HKEY_CLASSES_ROOT, key);

        RegDeleteKey(HKEY_CLASSES_ROOT, m_type);

        LocalFree( key );
    }
    else
        return FALSE; 

    // Delete Extensions  from HKEY_CLASSES_ROOT
    if( m_exts )
    {
        int count = DPA_GetPtrCount( m_exts );

        for( int i=0; i<count; i++ )
        { 
            LPTSTR ptr = (LPTSTR)DPA_FastGetPtr( m_exts, i );
            if( ptr && *ptr == TEXT('.') )
            {
                RegDeleteKey(HKEY_CLASSES_ROOT, ptr);
            }
        }
    } 
    else
        return FALSE; 

    return TRUE;
}

CAssoc::Print()
{
#ifndef UNICODE
    if( m_type ) printf( m_type );
    printf(",");
    if( m_desc ) printf( m_desc );
    printf(",");
    if( m_mime ) printf( m_mime );
    printf(",");
    if( m_cmnd ) printf( m_cmnd );

    if( m_exts )
    {
        int count = DPA_GetPtrCount( m_exts );
        for( int i=0; i<count; i++ )
        { 
            LPTSTR ptr = (LPTSTR)DPA_FastGetPtr( m_exts, i );
            if( ptr && *ptr == TEXT('.') )
            {
                printf("%s;", ptr );
            }
        }
    }

    printf("\n");
#endif
    return TRUE;
}

HDPA CAssoc::GetExtsOfAssoc()
{
    TCHAR buffer[MAX_PATH];

    DWORD index  = 0;
    DWORD type   = REG_SZ;
    long  dwLen  = MAX_PATH;
    DWORD dwLen2 = MAX_PATH;

    HDPA  exts = DPA_Create(4);
    
    *buffer = TEXT('\0');

    if( !m_type ) return NULL;

    TCHAR * key   = (TCHAR *)LocalAlloc( LPTR, (MAX_PATH+1)*sizeof(TCHAR) );
    TCHAR * value = (TCHAR *)LocalAlloc( LPTR, (MAX_PATH+1)*sizeof(TCHAR) );

    if( !key || !value  ) goto EXIT;

    while( RegEnumKey( HKEY_CLASSES_ROOT, index, key, MAX_PATH ) != ERROR_NO_MORE_ITEMS ) 
    {    
        if( *key == TEXT('.') )
        {
            HKEY  hKey = NULL;

            LONG lResult = RegOpenKeyEx(
                HKEY_CLASSES_ROOT,
                key,
                0,
                KEY_QUERY_VALUE,
                &hKey);

            if( lResult == ERROR_SUCCESS )
            {
                // Get then size first
	        dwLen = (MAX_PATH+1)*sizeof(TCHAR);
		if (RegQueryValue( hKey, NULL, value,  &dwLen )
		    == ERROR_SUCCESS )
		{
		    if( !StrCmpIC( value, m_type ) )
		    {
			DPA_InsertPtr( exts, 0x7FFF, (LPVOID)DuplicateString(key) );
		    }
		}

                RegCloseKey( hKey );
            }
        }
        index++;
    }

EXIT:
    if( key )
        LocalFree( key );
    if( value)
        LocalFree( value );

    return exts;
}


LPTSTR CAssoc::GetDescOfAssoc()
{
    HKEY hKey;

    static TCHAR buffer[MAX_PATH];
    DWORD type  = REG_SZ;
    DWORD dwLen = sizeof(buffer);

    *buffer = TEXT('\0');

    if( !m_type ) return NULL;

    LONG lResult = RegOpenKeyEx(
        HKEY_CLASSES_ROOT,
        m_type,
        0,
        KEY_QUERY_VALUE | KEY_READ,
        &hKey);

    if (lResult == ERROR_SUCCESS)
    {
        lResult = RegQueryValueEx(
           hKey,
           NULL,
           NULL,
           (LPDWORD) &type,
           (LPBYTE)  buffer,
           (LPDWORD) &dwLen);

        RegCloseKey( hKey );

        if( lResult == ERROR_SUCCESS ) 
        {
            return buffer;
        }
        
    }
    return NULL;
}

DWORD CAssoc::GetEditOfAssoc()
{
    HKEY hKey;

    DWORD buffer = 0;
    DWORD type  = REG_DWORD;
    DWORD dwLen = sizeof(buffer);

    if( !m_type ) return NULL;

    LONG lResult = RegOpenKeyEx(
        HKEY_CLASSES_ROOT,
        m_type,
        0,
        KEY_QUERY_VALUE | KEY_READ,
        &hKey);

    if (lResult == ERROR_SUCCESS)
    {
        lResult = RegQueryValueEx(
           hKey,
           g_szEditFlags, 
           NULL,
           (LPDWORD) &type,
           (LPBYTE)  &buffer,
           (LPDWORD) &dwLen);

        RegCloseKey( hKey );

        if( lResult == ERROR_SUCCESS )
        {
            return buffer;
        }

    }

    return 0;
}

LPTSTR CAssoc::GetMimeOfAssoc()
{
    HKEY hKey;

    static TCHAR buffer[MAX_PATH];
    DWORD type  = REG_SZ;
    DWORD dwLen = sizeof(buffer);

    *buffer = TEXT('\0');

    if( !m_type || !m_exts ) return NULL;

    int count = DPA_GetPtrCount( m_exts );

    for( int i=0; i< count; i++ )
    {
        LPTSTR str = (LPTSTR)DPA_FastGetPtr( m_exts, i );

        if( !str ) continue;

        LONG lResult = RegOpenKeyEx(
            HKEY_CLASSES_ROOT,
            str,
            0,
            KEY_QUERY_VALUE | KEY_READ,
            &hKey);

        if (lResult == ERROR_SUCCESS)
        {
            lResult = RegQueryValueEx(
               hKey,
               TEXT("Content Type"),
               NULL,
               (LPDWORD) &type,
               (LPBYTE)  buffer,
               (LPDWORD) &dwLen);

            RegCloseKey( hKey );

            if( lResult == ERROR_SUCCESS ) 
            {
                return buffer;
            }
        }
    }

    return NULL;
}

LPTSTR CAssoc::GetCmndOfAssoc()
{
    HKEY hKey;

    static TCHAR buffer [MAX_PATH];
    TCHAR keyName[MAX_PATH+40];
    DWORD type  = REG_SZ;
    DWORD dwLen = sizeof(buffer);

    *buffer = TEXT('\0');

    if( !m_type ) return NULL;

    StrCpy( keyName, m_type );
    StrCat( keyName, TEXT("\\") );
    StrCat( keyName, g_szCmndSubKey );

    LONG lResult = RegOpenKeyEx(
        HKEY_CLASSES_ROOT,
        keyName,
        0,
        KEY_QUERY_VALUE | KEY_READ,
        &hKey);

    if (lResult == ERROR_SUCCESS)
    {
        lResult = RegQueryValueEx(
           hKey,
           NULL,
           NULL,
           (LPDWORD) &type,
           (LPBYTE)  buffer,
           (LPDWORD) &dwLen);

        RegCloseKey( hKey );

        if( lResult == ERROR_SUCCESS ) 
        {
            return buffer;
        }
    }
    return NULL;
}

HDPA assocList    = (HDPA)NULL;
HDPA assocDelList = (HDPA)NULL;

SetEditLimits(HWND hDlg )
{
    SendMessage(GetDlgItem( hDlg, IDC_DOC_TYPE ), EM_LIMITTEXT, (WPARAM) MAX_PATH-1, 0);
    SendMessage(GetDlgItem( hDlg, IDC_DOC_MIME ), EM_LIMITTEXT, (WPARAM) MAX_PATH-1, 0);
    SendMessage(GetDlgItem( hDlg, IDC_DOC_EXTS ), EM_LIMITTEXT, (WPARAM) MAX_PATH-1, 0);
    SendMessage(GetDlgItem( hDlg, IDC_DOC_DESC ), EM_LIMITTEXT, (WPARAM) MAX_PATH-1, 0);
    SendMessage(GetDlgItem( hDlg, IDC_DOC_CMND ), EM_LIMITTEXT, (WPARAM) MAX_PATH-1, 0);

    return TRUE;
}

TCHAR *DuplicateString( TCHAR *orig )
{
    TCHAR * newStr;
    if( !orig ) return NULL;

    newStr  = (TCHAR *)LocalAlloc( LPTR, (lstrlen(orig) + 1)*sizeof(TCHAR));
    if(newStr) StrCpy( newStr, orig );

    return newStr;
}

TCHAR * EatSpaces( TCHAR * str )
{
    if( !str ) return NULL;

    TCHAR *ptr = str, *tmpStr = DuplicateString( str );
    TCHAR *tmpPtr = tmpStr;

    while( *tmpStr )
    {
        if(*tmpStr == TEXT(' ')  || *tmpStr == TEXT('\t') || 
           *tmpStr == TEXT('\n') || *tmpStr == TEXT('\r') || 
            // Remove special characters.
            (int)(*tmpStr) >= 127)
            tmpStr++; 
        else
            *ptr++ = *tmpStr++;
    }

    *ptr = TEXT('\0');

    LocalFree( tmpPtr );

    return str;
}

TCHAR * ChopSpaces( TCHAR * str )
{
    if( !str ) return NULL;

    TCHAR *ptr = str;

    while( *ptr && 
         (*ptr == TEXT(' ')  || *ptr == TEXT('\t')) ||
         (*ptr == TEXT('\n') || *ptr == TEXT('\r')) 
         ) ptr++;

    TCHAR *tmpStr = DuplicateString( ptr );
    TCHAR *tmpPtr = tmpStr + lstrlen(tmpStr);

    tmpPtr--;

    while( tmpPtr>= tmpStr && 
         (*tmpPtr == TEXT(' ')  || *tmpPtr == TEXT('\t')) ||
         (*tmpPtr == TEXT('\n') || *tmpPtr == TEXT('\r'))
         ) tmpPtr--;

    tmpPtr++;

    *tmpPtr = TEXT('\0');

    StrCpy( str, tmpStr );
    
    LocalFree( tmpStr );

    return str;
}


BOOL FreeAssociations( )
{
    if( assocList == (HDPA)NULL ) return FALSE;

    int assocCount = DPA_GetPtrCount( assocList );

    for(int i=0; i<assocCount; i++ )
    {
        CAssoc * ptr = (CAssoc *)DPA_FastGetPtr( assocList, i );
        if(ptr) delete ptr;
    }

    DPA_Destroy( assocList );
    assocList = (HDPA)NULL;
    return TRUE;
}

BOOL LoadAssociations( )
{
    HKEY hKey;
    int index = 0;
    DWORD dwLen  = MAX_PATH;

    if(assocList) 
        FreeAssociations();

    if((assocList = DPA_Create(4)) == (HDPA)NULL ) 
        return FALSE;

    TCHAR * buffer = (TCHAR *)LocalAlloc( LPTR, (MAX_PATH+1)*sizeof(TCHAR) );
    TCHAR * tmpKey = (TCHAR *)LocalAlloc( LPTR, (MAX_PATH+MAX_PATH+2)*sizeof(TCHAR) );

    while( buffer && tmpKey )
    {
        dwLen  = (MAX_PATH+sizeof(g_szCmndSubKey)+2)*sizeof(TCHAR); 
        if( RegEnumKeyEx( HKEY_CLASSES_ROOT, index, buffer, &dwLen,
                              NULL, NULL, NULL, NULL )
                == ERROR_NO_MORE_ITEMS ) break;
        {
            // Skip Extensions and *.
            if( *buffer == TEXT('.') || *buffer == TEXT('*')) 
            {
                index++;
                continue;
            }

            CAssoc * ptr = NULL;

            StrCpy( tmpKey, buffer );
            StrCat( tmpKey, TEXT("\\"));
            StrCat( tmpKey, g_szCmndSubKey);

            LONG lResult = RegOpenKeyEx(
                    HKEY_CLASSES_ROOT,
                    tmpKey,
                    0,       
                    KEY_QUERY_VALUE | KEY_READ,
                    &hKey);
            if( lResult == ERROR_SUCCESS )
            {
                ptr=new CAssoc(buffer);
                if( ptr->Load() == TRUE ) 
                    DPA_InsertPtr( assocList, 0x7FFF, (LPVOID)ptr);
                else 
                {
                    delete ptr;
                    ptr = NULL;
                }
                RegCloseKey( hKey ); 
            }
   
            // Check if this association needs to be protected.
            //  - uses DDE
            //  - has clsid
            //  - has protected key.
            if(ptr)
            {
                StrCpy(tmpKey, buffer);
                StrCat(tmpKey, TEXT("\\shell\\open\\ddeexec") );
                // wnsprintf(tmpKey, ARRAYSIZE(tmpKey), TEXT("%s\\shell\\open\\ddeexec"), buffer);

                lResult = RegOpenKeyEx(
                        HKEY_CLASSES_ROOT,
                        tmpKey,
                        0,
                        KEY_QUERY_VALUE | KEY_READ,
                        &hKey);
                if( lResult == ERROR_SUCCESS )
                {
                    ptr->m_safe = TRUE;
                    RegCloseKey( hKey );
                    goto Cont;
                }

                StrCpy(tmpKey, buffer);
                StrCat(tmpKey, TEXT("\\clsid") );
                //wnsprintf(tmpKey, ARRAYSIZE(tmpKey), TEXT("%s\\clsid"), buffer);

                lResult = RegOpenKeyEx(
                        HKEY_CLASSES_ROOT,
                        tmpKey,
                        0,
                        KEY_QUERY_VALUE | KEY_READ,
                        &hKey);
                if( lResult == ERROR_SUCCESS )
                {
                    ptr->m_safe = TRUE;
                    RegCloseKey( hKey );
                    goto Cont;
                }

                StrCpy(tmpKey, buffer);
                StrCat(tmpKey, TEXT("\\protected") );
                // wnsprintf(tmpKey, ARRAYSIZE(tmpKey), TEXT("%s\\protected"), buffer);

                lResult = RegOpenKeyEx(
                        HKEY_CLASSES_ROOT,
                        tmpKey,
                        0,
                        KEY_QUERY_VALUE | KEY_READ,
                        &hKey);
                if( lResult == ERROR_SUCCESS )
                {
                    ptr->m_safe = TRUE;
                    RegCloseKey( hKey );
                }
            }

Cont:

            index++;
        }
    }

    if( tmpKey ) LocalFree( tmpKey );
    if( buffer ) LocalFree( buffer );

    return TRUE;
}


BOOL FreeMimeTypes( )
{
    if( mimeList == NULL ) return FALSE;

    int mimeCount = DPA_GetPtrCount( mimeList );

    for(int i=0; i<mimeCount; i++ )
    {
        CMime * ptr = (CMime *)DPA_FastGetPtr( mimeList, i );
        if(ptr) delete ptr;
    }
    
    DPA_Destroy( mimeList );
    mimeList = (HDPA)NULL;
    return TRUE;
}


BOOL LoadMimeTypes( )
{
    HKEY hKeyMime, hKey;
    int index = 0;
    DWORD dwLen  = MAX_PATH;

    if(mimeList) FreeMimeTypes();

    if((mimeList = DPA_Create(4)) == (HDPA)NULL) return FALSE;

    // TODO : Get Max length of the key from registry and use it
    // instead of MAX_PATH.
    TCHAR * buffer = (TCHAR *)LocalAlloc( LPTR, (MAX_PATH+1)*sizeof(TCHAR) );

    LONG lResult = RegOpenKeyEx(
                HKEY_CLASSES_ROOT,
                g_szMimeKey,
                0,
                KEY_QUERY_VALUE | KEY_READ,
                &hKeyMime);
    
    if( lResult == ERROR_SUCCESS )
    {

    while( buffer )
    {
        dwLen  = MAXPATH;
        if( RegEnumKeyEx( hKeyMime, index, buffer, &dwLen,
                              NULL, NULL, NULL, NULL )
                == ERROR_NO_MORE_ITEMS ) break;
        {
            CMime * ptr = new CMime( buffer );

            lResult = RegOpenKeyEx(
                    hKeyMime,
                    buffer,
                    0,
                    KEY_QUERY_VALUE | KEY_READ,
                    &hKey);
            if( lResult == ERROR_SUCCESS )
            {
                dwLen = MAX_PATH;
                if (RegQueryValue( hKey, TEXT("extension"), buffer,  (long *)&dwLen ) 
                    == ERROR_SUCCESS )
                {
                    ptr->m_exts = (TCHAR *)LocalAlloc( LPTR, (dwLen+1)*sizeof(TCHAR));
                    StrCpy(ptr->m_exts, buffer);
                }
                
                RegCloseKey( hKey );
            }

            DPA_InsertPtr(mimeList, 0x7FFF, (LPVOID)ptr);

            index++;
        }
    }

    RegCloseKey( hKeyMime );

    }

    if( buffer ) LocalFree( buffer );

    return TRUE;
}


BOOL PrintAssociations()
{
    printf("Listing Associations:\n");

    if( !assocList ) return FALSE;

    int assocCount = DPA_GetPtrCount( assocList );
    for(int i=0; i<assocCount; i++ )
    {
       CAssoc * ptr = (CAssoc *)DPA_FastGetPtr( assocList, i );
       ptr->Print();
    }

    return TRUE;
}

BOOL FindCommand(HWND hDlg)
{
    TCHAR szFile[MAX_PATH] = TEXT("");
    TCHAR szFilter[5];
    OPENFILENAME ofn;

    HWND hCmnd = GetDlgItem(hDlg, IDC_DOC_CMND );

    memset((void*)&szFilter, 0, 5*sizeof(TCHAR));
    szFilter[0] = TCHAR('*');
    szFilter[2] = TCHAR('*');

    memset((void*)&ofn, 0, sizeof(ofn));
    ofn.lpstrFilter = szFilter;
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hDlg;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrInitialDir = NULL;
    ofn.Flags = OFN_HIDEREADONLY|OFN_CREATEPROMPT;

    if (GetOpenFileName(&ofn))
    {
        SendMessage(hCmnd, EM_SETSEL, 0, -1);
        SendMessage(hCmnd, EM_REPLACESEL, 0, (LPARAM)szFile);
    }

    return TRUE;
}

int FindIndex(LPTSTR doc)
{
    if( ! assocList ) return -1;

    int assocCount = DPA_GetPtrCount( assocList );
    for(int i = 0; i< assocCount;i++ )
    {
        CAssoc * ptr = (CAssoc *)DPA_FastGetPtr( assocList, i );
        if( !StrCmp(doc, ptr->m_type ) )
            return i;
    }

    return -1;
}

HDPA CreateDPAForExts( TCHAR * strPassed, int * error, CAssoc * existing)
{
    HKEY hKey;
    int  bFound = 0;
    HDPA hdpaExts = NULL;

    // Check for existing associations not created by IEUNIX
    // [.ext
    //   (--reg-val--  "Application")
    //   (content.type "mimetype"   )
    //   (g_szIEUnix   "g_szIEUnixTag" )
    // ]

    EatSpaces(strPassed);
    if(strPassed && *strPassed)
    {
        TCHAR *strExt = DuplicateString( strPassed );
        TCHAR *pos, *ptr = strExt;
        BOOL  bCont = TRUE;
         
        while(bCont && *ptr)
        {   
            pos = StrChr(ptr, TEXT(';'));

            if(pos)
            {
                bCont = ( *pos == TEXT(';') )? TRUE : FALSE;
                *pos = TEXT('\0');
            }
            else
            {
               bCont = FALSE;
            }
             
            if( !hdpaExts ) hdpaExts = DPA_Create(4);
            DPA_InsertPtr( hdpaExts, 0x7FFF, (LPVOID)DuplicateString( ptr ) );

            if(*ptr == TEXT('.') && *(ptr+1) )
            {
                int  assocCount, extCount;
                assocCount = DPA_GetPtrCount( assocList );
                for( int i = 0; i< assocCount; i++ )
                {
                    CAssoc * pAssoc = (CAssoc*)DPA_FastGetPtr( assocList, i );
                    
                    if( pAssoc->m_exts == NULL || pAssoc == existing ) continue;

                    extCount = DPA_GetPtrCount(pAssoc->m_exts) ;
                    for(int j=0;j<extCount;j++ )
                    {
                       if( !StrCmpI(ptr, (LPTSTR)DPA_FastGetPtr( pAssoc->m_exts, j ) ) )
                       {
                          bFound = IDS_ERROR_EXTS_ALREADY_EXISTS;
                          break;
                       }
                    }
                   
                    if( bFound ) break;
                }
            }
            else
            {
                // Extension must start with a '.'
                bFound = IDS_ERROR_NOT_AN_EXT;
                break;
            }
            ptr = pos+1;
        }

        if(strExt) LocalFree(strExt);
    } 
    else
        bFound = IDS_ERROR_MISSING_EXTS;

    *error = bFound;

    // Error occured while checking extensions
    if( bFound )
    {
        if(hdpaExts) FreeExtensions( hdpaExts );
        return NULL;
    }

    return hdpaExts;
}

// Following functions are called in response to the 
// actions performed on the associations.

AssocDel( HWND hDlg )
{
    int index    = 0;
    int lbindex  = 0;
    HWND lb      = GetDlgItem( hDlg, IDC_DOC_LIST );

    if( (lbindex = SendMessage( lb, LB_GETCURSEL, 0, 0 ) )!= LB_ERR )
    {
        LPTSTR str = (LPTSTR)SendMessage(lb, LB_GETITEMDATA, lbindex, 0 );
        if(str)
        {
            if( (index = FindIndex( str ) ) != -1 )
            {
                 CAssoc * ptr = (CAssoc *)DPA_FastGetPtr( assocList, index );
                 TCHAR question[MAX_PATH];
                 wnsprintf( question, ARRAYSIZE(question), TEXT("Are you Sure you want to delete '%s'?"), ptr->m_desc );
                 if( MessageBox( GetParent(hDlg), question, TEXT("Delete Association"), MB_YESNO ) == IDYES )
                 {
                     CAssoc *pAssoc = (CAssoc *)DPA_DeletePtr( assocList, index );

                    // Add to List of deleted entries
                    if( assocDelList == NULL ) assocDelList = DPA_Create(4);
                    if( assocDelList != NULL ) DPA_InsertPtr( assocDelList, 0x7FFF, pAssoc );

                    SendMessage( lb, LB_DELETESTRING, lbindex, 0 );
                    InitAssocDialog( hDlg ); 
                    SwitchToNrmlMode( hDlg );
                    PropSheet_Changed(GetParent(hDlg),hDlg);
                    LocalFree( str );
                } 
            }
        }
    }

    return TRUE;
}

#ifdef 0
AssocUpd( HWND hDlg )
{
    BOOL bFound = FALSE;
    TCHAR szTemp [1024];
    TCHAR szTitle [80];
    CAssoc *ptr = NULL;
    TCHAR *str;
    int    index, len;
    HDPA   hdpaExts = NULL;

    HWND lb   = GetDlgItem( hDlg, IDC_DOC_LIST );
    HWND exts = GetDlgItem( hDlg, IDC_DOC_EXTS );
    HWND desc = GetDlgItem( hDlg, IDC_DOC_DESC );
    HWND mime = GetDlgItem( hDlg, IDC_DOC_MIME );
    HWND cmnd = GetDlgItem( hDlg, IDC_DOC_CMND );

    MLLoadString(IDS_ERROR_REGISTRY_TITLE, szTitle, sizeof(szTitle));

    // Get the pointer to existing associations.
    if(PGTI_FROM_HDLG(hDlg)->mode == UPDATING)
    {
         ptr = GetCurrentAssoc( hDlg );
    }

    //Check for Description
    len = SendMessage( GetDlgItem(hDlg, IDC_DOC_DESC), WM_GETTEXTLENGTH, 0, 0 );
    if( len > 0 )
    {
        str = (TCHAR *)LocalAlloc( LPTR, (len+1)*sizeof(TCHAR) );
        SendMessage(GetDlgItem(hDlg, IDC_DOC_DESC), WM_GETTEXT, len+1, (LPARAM)str );
        ChopSpaces( str );
        if( *str == TEXT('\0') )
        {    
            LocalFree(str);
            MLLoadString(IDS_ERROR_MISSING_DESC, szTemp, sizeof(szTemp));
            MessageBox(GetParent(hDlg), szTemp, szTitle, MB_OK);
            SetFocus( GetDlgItem(hDlg, IDC_DOC_DESC) );
            return FALSE;
        }

        int assocCount = DPA_GetPtrCount( assocList );
        for( int i= 0; i<assocCount; i++ )
        {
            CAssoc * pAssoc ;
            if((pAssoc= (CAssoc *)DPA_FastGetPtr( assocList, i )) == ptr ) continue;
            
            if( StrCmpI( str, pAssoc->m_cmnd ) == NULL )
            {
                LocalFree(str);
                MLLoadString(IDS_ERROR_DESC_ALREADY_EXISTS, szTemp, sizeof(szTemp));
                MessageBox(GetParent(hDlg), szTemp, szTitle, MB_OK);
                SetFocus( GetDlgItem(hDlg, IDC_DOC_DESC) );
                return FALSE;
            }
        }

        LocalFree(str);
    }
    else
    {
        MLLoadString(IDS_ERROR_MISSING_DESC, szTemp, sizeof(szTemp));
        MessageBox(GetParent(hDlg), szTemp, szTitle, MB_OK);
        SetFocus( GetDlgItem(hDlg, IDC_DOC_DESC) );
        return FALSE;
    }

    //Check for MIME
    len = SendMessage( GetDlgItem(hDlg, IDC_DOC_MIME), WM_GETTEXTLENGTH, 0, 0 );
    if( len > 0 )
    {
        str = (TCHAR *)LocalAlloc( LPTR, (len+1)*sizeof(TCHAR) );
        SendMessage(GetDlgItem(hDlg, IDC_DOC_MIME), WM_GETTEXT, len+1, (LPARAM)str );
        ChopSpaces( str );
        if( *str != TEXT('\0') )
        {
            if( !StrChr( str, TEXT('/') ) )
            {
                LocalFree(str);
                MLLoadString(IDS_ERROR_INVALID_MIME, szTemp, sizeof(szTemp));
                MessageBox(GetParent(hDlg), szTemp, szTitle, MB_OK);
                SetFocus( GetDlgItem(hDlg, IDC_DOC_MIME) );
                return FALSE;
            }
        }
        LocalFree(str);
    }
    

    //Check for command line
    len = SendMessage( GetDlgItem(hDlg, IDC_DOC_CMND), WM_GETTEXTLENGTH, 0, 0 );
    if( len > 0 )
    {
        str = (TCHAR *)LocalAlloc( LPTR, (len+1)*sizeof(TCHAR) );
        SendMessage(GetDlgItem(hDlg, IDC_DOC_CMND), WM_GETTEXT, len+1, (LPARAM)str );
        ChopSpaces( str );
        if( *str == TEXT('\0') )
        {
            LocalFree(str);
            MLLoadString(IDS_ERROR_MISSING_CMND, szTemp, sizeof(szTemp));
            MessageBox(GetParent(hDlg), szTemp, szTitle, MB_OK);
            SetFocus( GetDlgItem(hDlg, IDC_DOC_CMND) );
            return FALSE;
        }    

        LocalFree(str);
    }
    else
    {
        MLLoadString(IDS_ERROR_MISSING_CMND, szTemp, sizeof(szTemp));
        MessageBox(GetParent(hDlg), szTemp, szTitle, MB_OK);
        SetFocus( GetDlgItem(hDlg, IDC_DOC_CMND) );
        return FALSE;
    }

    // Check for extensions.
    // User entered may already have associations in the
    // registry.
    len = SendMessage( GetDlgItem(hDlg, IDC_DOC_EXTS), WM_GETTEXTLENGTH, 0, 0 );
    str = (TCHAR *)LocalAlloc( LPTR, (len+1)*sizeof(TCHAR) );
    SendMessage(GetDlgItem(hDlg, IDC_DOC_EXTS), WM_GETTEXT, len+1, (LPARAM)str );

    int error;
    if(!(hdpaExts = CreateDPAForExts(EatSpaces(str), &error, ptr)))
    {
        LocalFree( str );
        MLLoadString(error, szTemp, sizeof(szTemp));
        MessageBox(GetParent(hDlg), szTemp, szTitle, MB_OK);
        SetFocus( GetDlgItem(hDlg, IDC_DOC_EXTS) );
        return FALSE;
    }
    LocalFree( str );

  
    // Check and Add CAssoc if we are inserting a new entry.

    if(PGTI_FROM_HDLG(hDlg)->mode == ADDING)
    {
         LPTSTR firstExt = (LPTSTR)DPA_FastGetPtr( hdpaExts, 0 );
         int len = lstrlen( firstExt ) + lstrlen(g_szDocClass) + 1;
         str = (TCHAR *)LocalAlloc( LPTR, len*sizeof(TCHAR) );

         StrCpy( str, firstExt+1   );
         StrCat( str, g_szDocClass );

         ptr = new CAssoc( str );
         ptr->m_safe = FALSE; // Since we are adding this entry.
         DPA_InsertPtr( assocList, 0x7FFF, ptr );
         LocalFree( str );
    }

    // We are not able to add or retrieve Assoc from the List
    if( ptr == NULL || ptr->m_safe == TRUE )
    {
        FreeExtensions( hdpaExts );
        return FALSE;
    }

    // Start replacing components of the Associations.

    // Replace Extensions
    if(ptr->m_exts) FreeExtensions( ptr->m_exts );
    ptr->m_exts = hdpaExts;
 
    // Replace mime type
    len = SendMessage( GetDlgItem(hDlg, IDC_DOC_MIME), WM_GETTEXTLENGTH, 0, 0 );
    str = (TCHAR *)LocalAlloc( LPTR, (len+1)*sizeof(TCHAR) );
    SendMessage(GetDlgItem(hDlg, IDC_DOC_MIME), WM_GETTEXT, len+1, (LPARAM)str );
    if( ptr->m_mime ) LocalFree( ptr->m_mime );
    ptr->m_mime = EatSpaces(str);

    // Replace Description
    len = SendMessage( GetDlgItem(hDlg, IDC_DOC_DESC), WM_GETTEXTLENGTH, 0, 0 );
    str = (TCHAR *)LocalAlloc( LPTR, (len+1)*sizeof(TCHAR) );
    SendMessage(GetDlgItem(hDlg, IDC_DOC_DESC), WM_GETTEXT, len+1, (LPARAM)str );
    if( ptr->m_desc ) LocalFree( ptr->m_desc);
    ptr->m_desc = ChopSpaces(str);

    // Replace Command Line
    len = SendMessage( GetDlgItem(hDlg, IDC_DOC_CMND), WM_GETTEXTLENGTH, 0, 0 );
    str = (TCHAR *)LocalAlloc( LPTR, (len+4)*sizeof(TCHAR) );
    SendMessage(GetDlgItem(hDlg, IDC_DOC_CMND), WM_GETTEXT, len+1, (LPARAM)str );
    if( ptr->m_cmnd ) LocalFree( ptr->m_cmnd );
    ptr->m_cmnd = ChopSpaces(str);
    if (ptr->m_stat == NEW)
	if (!StrStr(ptr->m_cmnd, TEXT("%1")))
	    lstrcat(ptr->m_cmnd, TEXT(" %1"));
    {
        DWORD dwCurChar;
        BOOL  bPath = FALSE;
	    
        for (dwCurChar = 0; dwCurChar < lstrlen(ptr->m_cmnd); dwCurChar++)
        {
	    if (ptr->m_cmnd[dwCurChar] == TEXT('/'))
            {
		bPath = TRUE;
	    }
	    if (ptr->m_cmnd[dwCurChar] == TEXT(' '))
            {
		break;
	    }
	}
	if (bPath)  // if it's file name with no path we assume it's in the user's PATH
    {    
        CHAR szExeFile[MAX_PATH];
        TCHAR szWarning[MAX_PATH + 128];

#ifndef UNICODE
        lstrcpyn(szExeFile, ptr->m_cmnd, dwCurChar + 1);
#else
        WCHAR wszExeFile[MAX_PATH];
        lstrcpyn(wszExeFile, ptr->m_cmnd, dwCurChar + 1);
        SHUnicodeToAnsi(wszExeFile, szExeFile, ARRAYSIZE(szExeFile));
#endif
        if (access(szExeFile, X_OK) != 0)
	    {
#ifndef UNICODE
            wsprintf(szWarning, TEXT("File %s is not an executable file."), szExeFile);
#else
            wsprintf(szWarning, TEXT("File %s is not an executable file."), wszExeFile);
#endif
		    MessageBox( GetParent(hDlg), szWarning, TEXT("Warning"), MB_OK);
	    }
	}
    }

    if (Button_GetCheck(GetDlgItem(hDlg, IDC_ASSOC_EDIT)) != BST_UNCHECKED)
       ptr->m_edit &= (~FTA_OpenIsSafe );
    else
       ptr->m_edit |= FTA_OpenIsSafe;

    ptr->m_stat = UPD;

    InitAssocDialog( hDlg, ptr );
    SwitchToNrmlMode( hDlg);
    
    // SetFocus to Ok button again
    SetFocus( GetDlgItem(GetParent( hDlg ), IDOK ) );

    PropSheet_Changed(GetParent(hDlg),hDlg);
    return TRUE;
}


AssocAdd( HWND hDlg)
{
    SwitchToAddMode( hDlg );
    PropSheet_Changed(GetParent(hDlg),hDlg);
    return TRUE;
}
#endif // 0

CAssoc * GetCurrentAssoc( HWND hDlg )
{
    int index = 0;
    HWND lb   = GetDlgItem( hDlg, IDC_DOC_LIST );

    if( (index = SendMessage( lb, LB_GETCURSEL, 0, 0 ) )!= LB_ERR )
    {
        TCHAR * str = (LPTSTR)SendMessage( lb, LB_GETITEMDATA, index, 0 );
        if(!str) return NULL;

        if(str && *str)
        {

            if( (index = FindIndex( str ) ) != -1 )
            {
                CAssoc * ptr = (CAssoc *)DPA_FastGetPtr( assocList, index );
                return ptr;
            }
        }
    }
    return NULL;
}

SwitchToNrmlMode( HWND hDlg )
{
    PGTI_FROM_HDLG(hDlg)->mode = NORMAL;

    EnableWindow(GetDlgItem(hDlg,IDC_DOC_DESC), FALSE );
    EnableWindow(GetDlgItem(hDlg,IDC_DOC_EXTS), FALSE );
    EnableWindow(GetDlgItem(hDlg,IDC_DOC_MIME), FALSE );
    EnableWindow(GetDlgItem(hDlg,IDC_DOC_CMND), FALSE );
    EnableWindow(GetDlgItem(hDlg,IDC_ASSOC_EDIT), FALSE );

    if (IsAssocEnabled())
    {
	CAssoc *pAssoc = GetCurrentAssoc( hDlg );
        EnableWindow(GetDlgItem(hDlg,IDC_ASSOC_ADD), TRUE );
	if( pAssoc ) 
        {
	    if( pAssoc->m_safe )
	    {
		EnableWindow(GetDlgItem(hDlg,IDC_ASSOC_DEL), FALSE);
		EnableWindow(GetDlgItem(hDlg,IDC_ASSOC_UPD), FALSE );
	    }
	    else
	    {
		EnableWindow(GetDlgItem(hDlg,IDC_ASSOC_DEL), TRUE );
		EnableWindow(GetDlgItem(hDlg,IDC_ASSOC_UPD), TRUE );
	    }
	}
    }
    else
    {
        EnableWindow(GetDlgItem(hDlg,IDC_ASSOC_DEL), FALSE);
        EnableWindow(GetDlgItem(hDlg,IDC_ASSOC_UPD), FALSE );
        EnableWindow(GetDlgItem(hDlg,IDC_ASSOC_ADD), FALSE );
    }


    REMOVE_DEF_BORDER(hDlg, IDC_ASSOC_ADD );
    REMOVE_DEF_BORDER(hDlg, IDC_ASSOC_UPD );
    REMOVE_DEF_BORDER(hDlg, IDC_ASSOC_DEL );
    SET_DEF_BORDER( GetParent(hDlg), IDOK );

    return TRUE;
}


SwitchToAddMode( HWND hDlg )
{
    PGTI_FROM_HDLG(hDlg)->mode = ADDING;

    LPASSOCTABINFO pgti = (LPASSOCTABINFO)GetWindowLong(hDlg, DWL_USER);

    // Remove Selection from Listbox.
    SendMessage( GetDlgItem(hDlg, IDC_DOC_LIST), LB_SETCURSEL,
           (WPARAM)-1, 0);

    pgti->fInternalChange = TRUE;
    
    // Clear all the fields
    SendMessage( GetDlgItem(hDlg, IDC_DOC_DESC), WM_SETTEXT,
           0, LPARAM( TEXT("")) );
    SendMessage( GetDlgItem(hDlg, IDC_DOC_MIME), WM_SETTEXT,
           0, LPARAM( TEXT("")) );
    SendMessage( GetDlgItem(hDlg, IDC_DOC_EXTS), WM_SETTEXT,
           0, LPARAM( TEXT("")) );
    SendMessage( GetDlgItem(hDlg, IDC_DOC_CMND), WM_SETTEXT,
           0, LPARAM( TEXT("")) );
    
    // Default value
    Button_SetCheck( GetDlgItem( hDlg, IDC_ASSOC_EDIT),  TRUE ); 

    pgti->fInternalChange = FALSE;

    // Enable all edit windows
    EnableWindow(GetDlgItem(hDlg,IDC_DOC_DESC), TRUE);
    EnableWindow(GetDlgItem(hDlg,IDC_DOC_MIME), TRUE);
    EnableWindow(GetDlgItem(hDlg,IDC_DOC_EXTS), TRUE);
    EnableWindow(GetDlgItem(hDlg,IDC_DOC_CMND), TRUE);
    EnableWindow(GetDlgItem(hDlg,IDC_BROWSE  ), TRUE);
    EnableWindow(GetDlgItem(hDlg,IDC_ASSOC_EDIT  ), TRUE);

    // Enable Add option
    EnableWindow(GetDlgItem(hDlg,IDC_ASSOC_ADD), FALSE);
    EnableWindow(GetDlgItem(hDlg,IDC_ASSOC_UPD), TRUE );
    EnableWindow(GetDlgItem(hDlg,IDC_ASSOC_DEL), FALSE);

    // Remove Default Border
    REMOVE_DEF_BORDER( GetParent(hDlg), IDOK );
    REMOVE_DEF_BORDER( hDlg, IDC_ASSOC_ADD);
    REMOVE_DEF_BORDER( hDlg, IDC_ASSOC_DEL);
    SET_DEF_BORDER( hDlg, IDC_ASSOC_UPD );
    SetFocus( GetDlgItem( hDlg, IDC_ASSOC_UPD ) );

    return TRUE;
}

SwitchToUpdMode( HWND hDlg )
{
    if(PGTI_FROM_HDLG(hDlg)->mode != NORMAL )
       return FALSE;

    PGTI_FROM_HDLG(hDlg)->mode = UPDATING;

    // Enable Upd option
    EnableWindow(GetDlgItem(hDlg,IDC_ASSOC_ADD), TRUE );
    EnableWindow(GetDlgItem(hDlg,IDC_ASSOC_UPD), TRUE );
    EnableWindow(GetDlgItem(hDlg,IDC_ASSOC_DEL), TRUE );

    // Remove Default Border
    REMOVE_DEF_BORDER( GetParent(hDlg), IDOK );
    REMOVE_DEF_BORDER( hDlg, IDC_ASSOC_ADD);
    REMOVE_DEF_BORDER( hDlg, IDC_ASSOC_DEL);
    SET_DEF_BORDER( hDlg, IDC_ASSOC_UPD);

    return TRUE;
}

void ListBoxResetContents(HWND listBox)
{
    int count = SendMessage( listBox, LB_GETCOUNT, 0, 0 );

    for( int i= 0; i< count; i++ )
    {
        LPSTR data = (LPSTR)SendMessage( listBox, LB_GETITEMDATA, i, 0 );
        if( data ) LocalFree( data );
    }
    SendMessage( listBox, LB_RESETCONTENT, 0, 0 );
}

BOOL FAR PASCAL InitAssocDialog(HWND hDlg, CAssoc * current)
{
    HRESULT  hr = E_FAIL;
    HKEY     hKey;
    HWND     listBox = GetDlgItem( hDlg, IDC_DOC_LIST );
    TCHAR *  displayString;

    // Allocate memory for a structure which will hold all the info
    // gathered from this page
    //
    LPASSOCTABINFO pgti = (LPASSOCTABINFO)GetWindowLong(hDlg, DWL_USER);
    pgti->fInternalChange = FALSE;

    ListBoxResetContents( listBox );

    if( assocList == NULL ) return FALSE;

    int assocCount = DPA_GetPtrCount( assocList );

    for(int i = 0; i< assocCount; i++ )
    {
        CAssoc * ptr = (CAssoc *)DPA_FastGetPtr( assocList, i );
        int index = SendMessage( listBox, LB_ADDSTRING, 0, (LPARAM)ptr->m_desc );
        SendMessage( listBox, LB_SETITEMDATA, index, (LPARAM)DuplicateString( ptr->m_type ) );
    }

    if( i>0 )
        SendMessage( listBox, LB_SETCURSEL, 0, 0 );
    else
    {
        SendMessage( GetDlgItem(hDlg, IDC_DOC_DESC), WM_SETTEXT,
           0, LPARAM( TEXT("")) );
        SendMessage( GetDlgItem(hDlg, IDC_DOC_MIME), WM_SETTEXT,
           0, LPARAM( TEXT("")) );
        SendMessage( GetDlgItem(hDlg, IDC_DOC_EXTS), WM_SETTEXT,
           0, LPARAM( TEXT("")) );
        SendMessage( GetDlgItem(hDlg, IDC_DOC_CMND), WM_SETTEXT,
           0, LPARAM( TEXT("")) );

        // Default value
        Button_SetCheck( GetDlgItem( hDlg, IDC_ASSOC_EDIT),  TRUE ); 
    }

    // Add Strings to Mimetype dialog
    int mimeCount = 0;

    if( mimeList && (mimeCount = DPA_GetPtrCount(mimeList)))
    {
        for(i=0; i< mimeCount; i++)
        {
            CMime * ptr = (CMime *)DPA_FastGetPtr( mimeList , i );
		    SafeAddStringToComboBox( GetDlgItem(hDlg, IDC_DOC_MIME) , ptr->m_mime) ;
        }   
    }

    if( current )
        SendMessage( listBox, LB_SELECTSTRING, -1, (LPARAM)current->m_desc );

    HandleSelChange( pgti );

    SwitchToNrmlMode( hDlg );

    if( IsAssocEnabled() && i > 0 )
        EnableWindow(GetDlgItem(hDlg,IDC_ASSOC_DEL), TRUE);
    else
        EnableWindow(GetDlgItem(hDlg,IDC_ASSOC_DEL), FALSE);

    return TRUE;
}

void HandleSelChange( LPASSOCTABINFO pgti, BOOL bApplChange )
{
    int index = 0;
    HWND hDlg = pgti->hDlg;
    TCHAR str[MAX_PATH] = TEXT("");

    if( hDlg == NULL ) return;

    HWND exts = GetDlgItem( hDlg, IDC_DOC_EXTS );
    HWND desc = GetDlgItem( hDlg, IDC_DOC_DESC );
    HWND mime = GetDlgItem( hDlg, IDC_DOC_MIME );
    HWND cmnd = GetDlgItem( hDlg, IDC_DOC_CMND );
    HWND brws = GetDlgItem( hDlg, IDC_BROWSE   );
    HWND edit = GetDlgItem( hDlg, IDC_ASSOC_EDIT );

    CAssoc * ptr = GetCurrentAssoc( hDlg );
 
    if(ptr)
    {
        SendMessage( desc, WM_SETTEXT, 0, (LPARAM)ptr->m_desc );
        SendMessage( mime, WM_SETTEXT, 0, (LPARAM)ptr->m_mime );
        SendMessage( cmnd, WM_SETTEXT, 0, (LPARAM)ptr->m_cmnd );

        // Create Extension List
        if( ptr->m_exts )
        {
            int i, count = DPA_GetPtrCount( ptr->m_exts );
            for(i=0;i<count;i++)
            {
                StrCat( str, (LPTSTR)DPA_FastGetPtr( ptr->m_exts, i ) );
                StrCat( str, TEXT(";") );
            }
            SendMessage( exts, WM_SETTEXT, 0, (LPARAM)str );
        }
                
        Button_SetCheck( GetDlgItem( hDlg, IDC_ASSOC_EDIT), !(ptr->m_edit & FTA_OpenIsSafe) ); 

        EnableWindow( desc, !(ptr->m_safe) );
        EnableWindow( exts, !(ptr->m_safe) );
        EnableWindow( mime, !(ptr->m_safe) );
        EnableWindow( cmnd, !(ptr->m_safe) );
        EnableWindow( brws, !(ptr->m_safe) );
        EnableWindow( edit, !(ptr->m_safe) );

        pgti->fInternalChange = FALSE;

        // Change back to the NORMAL mode if not coming from 
        // edit.
        SwitchToNrmlMode( hDlg );
    }
}

BOOL AssocOnCommand(LPASSOCTABINFO pgti, UINT id, UINT nCmd)
{
    switch (id)
    { 
        case IDC_BROWSE:
            switch (nCmd )
            {
               case BN_CLICKED:
               {
                    FindCommand( pgti->hDlg );
                    break;
               }
            }
            break;

        case IDC_ASSOC_ADD:
            switch (nCmd )
            {
                case BN_CLICKED:
                {
		    ENTERASSOC enter;
		    enter.pgti = pgti;
		    enter.pszAssoc = NULL;
		    DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_ENTER_ASSOC), 
					 pgti->hDlg, EnterAssocDlgProc, (LPARAM) &enter);
		    InitAssocDialog( pgti->hDlg, GetCurrentAssoc( pgti->hDlg ) );
		    SwitchToNrmlMode( pgti->hDlg);
		    // SetFocus to Ok button again
		    SetFocus( GetDlgItem(GetParent( pgti->hDlg ), IDOK ) );
		    if (pgti->fChanged)
		    {
		        pgti->fChanged = FALSE;
			PropSheet_Changed(GetParent(pgti->hDlg),pgti->hDlg);
		    }
                    //AssocAdd( pgti->hDlg );
                    break;
               }
            }
            break;

        case IDC_ASSOC_UPD:
            switch (nCmd )
            {
               case BN_CLICKED:
               {
		    HWND lb   = GetDlgItem( pgti->hDlg, IDC_DOC_LIST );
		    int  index;

		    if( (index = SendMessage( lb, LB_GETCURSEL, 0, 0 ) )!= LB_ERR )
		    {
		        TCHAR * str = (LPTSTR)SendMessage( lb, LB_GETITEMDATA, index, 0 );
			ENTERASSOC enter;
			if(!str) return FALSE;
			enter.pgti = pgti;
			enter.pszAssoc = str;
			DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_ENTER_ASSOC), 
					     pgti->hDlg, EnterAssocDlgProc, (LPARAM) &enter);
			InitAssocDialog( pgti->hDlg, GetCurrentAssoc( pgti->hDlg ) );
			SwitchToNrmlMode( pgti->hDlg);
			// SetFocus to Ok button again
			SetFocus( GetDlgItem(GetParent( pgti->hDlg ), IDOK ) );
			if (pgti->fChanged)
			{
			    pgti->fChanged = FALSE;
			    PropSheet_Changed(GetParent(pgti->hDlg),pgti->hDlg);
			}
		    }
                    //AssocUpd( pgti->hDlg );
                    break;
               }
            }
            break;

        case IDC_ASSOC_DEL:
            switch (nCmd )
            {
               case BN_CLICKED:
               {
                    AssocDel( pgti->hDlg ); 
                    break;
               }
            }
            break;

        case IDC_DOC_LIST:
            switch (nCmd )
            {
                case LBN_SELCHANGE:
                     HandleSelChange( pgti );
                     break;
	        case LBN_DBLCLK:
               {
		    HWND lb   = GetDlgItem( pgti->hDlg, IDC_DOC_LIST );
		    int  index;

		    if( (index = SendMessage( lb, LB_GETCURSEL, 0, 0 ) )!= LB_ERR )
		    {
		        TCHAR * str = (LPTSTR)SendMessage( lb, LB_GETITEMDATA, index, 0 );
			ENTERASSOC enter;
			CAssoc *pAssoc = GetCurrentAssoc( pgti->hDlg );
			if(!IsAssocEnabled() || pAssoc->m_safe || !str) return FALSE;
			enter.pgti = pgti;
			enter.pszAssoc = str;
			DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_ENTER_ASSOC), 
					     pgti->hDlg, EnterAssocDlgProc, (LPARAM) &enter);
			InitAssocDialog( pgti->hDlg, GetCurrentAssoc( pgti->hDlg ) );
			SwitchToNrmlMode( pgti->hDlg);
			// SetFocus to Ok button again
			SetFocus( GetDlgItem(GetParent( pgti->hDlg ), IDOK ) );
			if (pgti->fChanged)
			{
			    pgti->fChanged = FALSE;
			    PropSheet_Changed(GetParent(pgti->hDlg),pgti->hDlg);
			}
		    }
                    //AssocUpd( pgti->hDlg );
                    break;
               }
            }
            break;
#ifdef 0
        case IDC_DOC_MIME:
            switch (nCmd)
            {
                case CBN_SELCHANGE:
                case CBN_EDITCHANGE:
                    if (!pgti->fInternalChange)
                    {
                        pgti->fChanged = TRUE;
                        SwitchToUpdMode( pgti->hDlg );
                    }
                    break;
            }
            break;

        case IDC_ASSOC_EDIT:
            switch (nCmd )
            {
               case BN_CLICKED:
               {
                    if (!pgti->fInternalChange)
                    {
                        pgti->fChanged = TRUE;
                        SwitchToUpdMode( pgti->hDlg );
                    }
                    break;
               }
            }
            break;

        case IDC_DOC_TYPE:
        case IDC_DOC_EXTS:
        case IDC_DOC_DESC:
        case IDC_DOC_CMND:
            switch (nCmd)
            {
                case EN_CHANGE:
                    if (!pgti->fInternalChange)
                    {
                        pgti->fChanged = TRUE;
                        SwitchToUpdMode( pgti->hDlg );
                    }
                    break;
                case EN_SETFOCUS:
                    if ( pgti->mode == ADDING)
                    {
                        SET_DEF_BORDER( pgti->hDlg, IDC_ASSOC_UPD );
                        break; 
                    }
            }
            break;
#endif //0
    }

    return FALSE;
}

void AssocApply(HWND hDlg)
{
    // Delete the associations removed by the user.
    if( assocDelList )
    {
        int count = DPA_GetPtrCount( assocDelList );
        
        for(int i=0;i<count;i++)
        {
            CAssoc * pAssoc = (CAssoc *)DPA_FastGetPtr( assocDelList, i );
            if(pAssoc) 
            {
                pAssoc->Delete();
                delete pAssoc;
            }
        }

        DPA_Destroy( assocDelList );
        assocDelList = NULL;
    }

    // Save the currently changed associations.
    if( assocList )
    {
        int count = DPA_GetPtrCount( assocList );
        
        for(int i=0;i<count;i++)
        {
            CAssoc * pAssoc = (CAssoc *)DPA_FastGetPtr( assocList, i );
            if(pAssoc) 
            {  
                pAssoc->Save();
            }
        }
    }
}

/****************************************************************************
 *
 * AssocDlgProc
 *
 *
 ***************************************************************************/
 
BOOL CALLBACK AssocDlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // get our tab info structure
    LPASSOCTABINFO pgti;

    if (uMsg == WM_INITDIALOG)
    {
        // Set Limits for edit fields
        SetEditLimits( hDlg );
  
        // Allocate memory for a structure which will hold all the info
        // gathered from this page
        //
        LPASSOCTABINFO pgti = (LPASSOCTABINFO)LocalAlloc(LPTR, sizeof(ASSOCINFO));
        if (!pgti)
        {
            EndDialog(hDlg, 0);
            return FALSE;
        }

        pgti->hDlg = hDlg;
        pgti->mode = NORMAL;

        pgti->fInternalChange = FALSE;
        SetWindowLong(hDlg, DWL_USER, (LPARAM)pgti);
        
        // Create an association array from registry
        LoadAssociations();
        LoadMimeTypes();

        // Initailize dialog 
        if( InitAssocDialog(hDlg) ) 
        {
            HandleSelChange(pgti);
            return TRUE;
        }
        else
        {
            TCHAR szTitle[MAX_PATH];
            MLLoadString(IDS_ERROR_REGISTRY_TITLE, szTitle, sizeof(szTitle));
            MessageBox( GetParent(hDlg), TEXT("Cannot read associations from registry."), szTitle, MB_OK ); 
            return FALSE;
        }
    }
    else
        pgti = (LPASSOCTABINFO)GetWindowLong(hDlg, DWL_USER);

    if (!pgti)
        return FALSE;

    switch (uMsg)
    {
        case WM_NOTIFY:
        {
            NMHDR *lpnm = (NMHDR *) lParam;

            switch (lpnm->code)
            {
                case PSN_QUERYCANCEL:
                case PSN_KILLACTIVE:
                case PSN_RESET:
                    SetWindowLong( hDlg, DWL_MSGRESULT, FALSE );
                    return TRUE;

                case PSN_APPLY:
                    AssocApply(hDlg);
                    break;
            }
            break;
        }

        case WM_COMMAND:
            AssocOnCommand(pgti, LOWORD(wParam), HIWORD(wParam));
            break;

        case WM_HELP:           // F1
            //ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
            //            HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:    // right mouse click
            //ResWinHelp( (HWND) wParam, IDS_HELPFILE,
            //            HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_DESTROY:
#if 0
            RemoveDefaultDialogFont(hDlg);
#endif

            if (pgti)
                LocalFree(pgti);

            // Remove Associated data items for the listbos items.
            ListBoxResetContents( GetDlgItem( hDlg, IDC_DOC_LIST ) );
  
            // Delete registry information
            FreeAssociations();
            FreeMimeTypes();

            SetWindowLong(hDlg, DWL_USER, (LONG)NULL);  // make sure we don't re-enter
            break;
    }
    return FALSE;
}

BOOL AssocEnter( HWND hDlg )
{
    LPASSOCTABINFO pgti = ((LPENTERASSOC)GetWindowLong(hDlg, DWL_USER))->pgti;
    BOOL bFound = FALSE;
    TCHAR szTemp [1024];
    TCHAR szTitle [80];
    CAssoc *ptr = NULL;
    TCHAR *str;
    int    index, len;
    HDPA   hdpaExts = NULL;

    HWND exts = GetDlgItem( hDlg, IDC_DOC_EXTS );
    HWND desc = GetDlgItem( hDlg, IDC_DOC_DESC );
    HWND mime = GetDlgItem( hDlg, IDC_DOC_MIME );
    HWND cmnd = GetDlgItem( hDlg, IDC_DOC_CMND );

    MLLoadString(IDS_ERROR_REGISTRY_TITLE, szTitle, sizeof(szTitle));

    // Get the pointer to existing associations.
    if(GetWindowLong(hDlg, DWL_USER))
    {
        TCHAR *pszAssoc = ((LPENTERASSOC)GetWindowLong(hDlg, DWL_USER))->pszAssoc;
	if(pszAssoc && *pszAssoc)
	    if( (index = FindIndex( pszAssoc ) ) != -1 )
	        ptr = (CAssoc *)DPA_FastGetPtr( assocList, index );
    }

    //Check for Description
    len = SendMessage( GetDlgItem(hDlg, IDC_DOC_DESC), WM_GETTEXTLENGTH, 0, 0 );
    if( len > 0 )
    {
        str = (TCHAR *)LocalAlloc( LPTR, (len+1)*sizeof(TCHAR) );
        SendMessage(GetDlgItem(hDlg, IDC_DOC_DESC), WM_GETTEXT, len+1, (LPARAM)str );
        ChopSpaces( str );
        if( *str == TEXT('\0') )
        {    
            LocalFree(str);
            MLLoadString(IDS_ERROR_MISSING_DESC, szTemp, sizeof(szTemp));
            MessageBox(GetParent(hDlg), szTemp, szTitle, MB_OK);
            SetFocus( GetDlgItem(hDlg, IDC_DOC_DESC) );
            return FALSE;
        }

        int assocCount = DPA_GetPtrCount( assocList );
        for( int i= 0; i<assocCount; i++ )
        {
            CAssoc * pAssoc ;
            if((pAssoc= (CAssoc *)DPA_FastGetPtr( assocList, i )) == ptr ) continue;
            
            if( StrCmpI( str, pAssoc->m_cmnd ) == NULL )
            {
                LocalFree(str);
                MLLoadString(IDS_ERROR_DESC_ALREADY_EXISTS, szTemp, sizeof(szTemp));
                MessageBox(GetParent(hDlg), szTemp, szTitle, MB_OK);
                SetFocus( GetDlgItem(hDlg, IDC_DOC_DESC) );
                return FALSE;
            }
        }

        LocalFree(str);
    }
    else
    {
        MLLoadString(IDS_ERROR_MISSING_DESC, szTemp, sizeof(szTemp));
        MessageBox(GetParent(hDlg), szTemp, szTitle, MB_OK);
        SetFocus( GetDlgItem(hDlg, IDC_DOC_DESC) );
        return FALSE;
    }

    //Check for MIME
    len = SendMessage( GetDlgItem(hDlg, IDC_DOC_MIME), WM_GETTEXTLENGTH, 0, 0 );
    if( len > 0 )
    {
        str = (TCHAR *)LocalAlloc( LPTR, (len+1)*sizeof(TCHAR) );
        SendMessage(GetDlgItem(hDlg, IDC_DOC_MIME), WM_GETTEXT, len+1, (LPARAM)str );
        ChopSpaces( str );
        if( *str != TEXT('\0') )
        {
            if( !StrChr( str, TEXT('/') ) )
            {
                LocalFree(str);
                MLLoadString(IDS_ERROR_INVALID_MIME, szTemp, sizeof(szTemp));
                MessageBox(GetParent(hDlg), szTemp, szTitle, MB_OK);
                SetFocus( GetDlgItem(hDlg, IDC_DOC_MIME) );
                return FALSE;
            }
        }
        LocalFree(str);
    }
    

    //Check for command line
    len = SendMessage( GetDlgItem(hDlg, IDC_DOC_CMND), WM_GETTEXTLENGTH, 0, 0 );
    if( len > 0 )
    {
        str = (TCHAR *)LocalAlloc( LPTR, (len+1)*sizeof(TCHAR) );
        SendMessage(GetDlgItem(hDlg, IDC_DOC_CMND), WM_GETTEXT, len+1, (LPARAM)str );
        ChopSpaces( str );
        if( *str == TEXT('\0') )
        {
            LocalFree(str);
            MLLoadString(IDS_ERROR_MISSING_CMND, szTemp, sizeof(szTemp));
            MessageBox(GetParent(hDlg), szTemp, szTitle, MB_OK);
            SetFocus( GetDlgItem(hDlg, IDC_DOC_CMND) );
            return FALSE;
        }    

        LocalFree(str);
    }
    else
    {
        MLLoadString(IDS_ERROR_MISSING_CMND, szTemp, sizeof(szTemp));
        MessageBox(GetParent(hDlg), szTemp, szTitle, MB_OK);
        SetFocus( GetDlgItem(hDlg, IDC_DOC_CMND) );
        return FALSE;
    }

    // Check for extensions.
    // User entered may already have associations in the
    // registry.
    len = SendMessage( GetDlgItem(hDlg, IDC_DOC_EXTS), WM_GETTEXTLENGTH, 0, 0 );
    str = (TCHAR *)LocalAlloc( LPTR, (len+1)*sizeof(TCHAR) );
    SendMessage(GetDlgItem(hDlg, IDC_DOC_EXTS), WM_GETTEXT, len+1, (LPARAM)str );

    int error;
    if(!(hdpaExts = CreateDPAForExts(EatSpaces(str), &error, ptr)))
    {
        LocalFree( str );
        MLLoadString(error, szTemp, sizeof(szTemp));
        MessageBox(GetParent(hDlg), szTemp, szTitle, MB_OK);
        SetFocus( GetDlgItem(hDlg, IDC_DOC_EXTS) );
        return FALSE;
    }
    LocalFree( str );

  
    // Check and Add CAssoc if we are inserting a new entry.

    if(!((LPENTERASSOC)GetWindowLong(hDlg, DWL_USER))->pszAssoc)
    {
         LPTSTR firstExt = (LPTSTR)DPA_FastGetPtr( hdpaExts, 0 );
         int len = lstrlen( firstExt ) + lstrlen(g_szDocClass) + 1;
         str = (TCHAR *)LocalAlloc( LPTR, len*sizeof(TCHAR) );

         StrCpy( str, firstExt+1   );
         StrCat( str, g_szDocClass );

         ptr = new CAssoc( str );
         ptr->m_safe = FALSE; // Since we are adding this entry.
         DPA_InsertPtr( assocList, 0x7FFF, ptr );
         LocalFree( str );
    }

    // We are not able to add or retrieve Assoc from the List
    if( ptr == NULL || ptr->m_safe == TRUE )
    {
        FreeExtensions( hdpaExts );
        return FALSE;
    }

    // Start replacing components of the Associations.

    // Replace Extensions
    if(ptr->m_exts) FreeExtensions( ptr->m_exts );
    ptr->m_exts = hdpaExts;
 
    // Replace mime type
    len = SendMessage( GetDlgItem(hDlg, IDC_DOC_MIME), WM_GETTEXTLENGTH, 0, 0 );
    str = (TCHAR *)LocalAlloc( LPTR, (len+1)*sizeof(TCHAR) );
    SendMessage(GetDlgItem(hDlg, IDC_DOC_MIME), WM_GETTEXT, len+1, (LPARAM)str );
    if( ptr->m_mime ) LocalFree( ptr->m_mime );
    ptr->m_mime = EatSpaces(str);

    // Replace Description
    len = SendMessage( GetDlgItem(hDlg, IDC_DOC_DESC), WM_GETTEXTLENGTH, 0, 0 );
    str = (TCHAR *)LocalAlloc( LPTR, (len+1)*sizeof(TCHAR) );
    SendMessage(GetDlgItem(hDlg, IDC_DOC_DESC), WM_GETTEXT, len+1, (LPARAM)str );
    if( ptr->m_desc ) LocalFree( ptr->m_desc);
    ptr->m_desc = ChopSpaces(str);

    // Replace Command Line
    len = SendMessage( GetDlgItem(hDlg, IDC_DOC_CMND), WM_GETTEXTLENGTH, 0, 0 );
    str = (TCHAR *)LocalAlloc( LPTR, (len+4)*sizeof(TCHAR) );
    SendMessage(GetDlgItem(hDlg, IDC_DOC_CMND), WM_GETTEXT, len+1, (LPARAM)str );
    if( ptr->m_cmnd ) LocalFree( ptr->m_cmnd );
    ptr->m_cmnd = ChopSpaces(str);
    if (ptr->m_stat == NEW)
	if (!StrStr(ptr->m_cmnd, TEXT("%1")))
	    lstrcat(ptr->m_cmnd, TEXT(" %1"));
    {
        DWORD dwCurChar;
        BOOL  bPath = FALSE;
	    
        for (dwCurChar = 0; dwCurChar < lstrlen(ptr->m_cmnd); dwCurChar++)
        {
	    if (ptr->m_cmnd[dwCurChar] == TEXT('/'))
            {
		bPath = TRUE;
	    }
	    if (ptr->m_cmnd[dwCurChar] == TEXT(' '))
            {
		break;
	    }
	}
	if (bPath)  // if it's file name with no path we assume it's in the user's PATH
    {    
        CHAR szExeFile[MAX_PATH];
        TCHAR szWarning[MAX_PATH + 128];

#ifndef UNICODE
        lstrcpyn(szExeFile, ptr->m_cmnd, dwCurChar + 1);
#else
        WCHAR wszExeFile[MAX_PATH];
        lstrcpyn(wszExeFile, ptr->m_cmnd, dwCurChar + 1);
        SHUnicodeToAnsi(wszExeFile, szExeFile, ARRAYSIZE(szExeFile));
#endif
        if (access(szExeFile, X_OK) != 0)
	    {
#ifndef UNICODE
            wsprintf(szWarning, TEXT("File %s is not an executable file."), szExeFile);
#else
            wsprintf(szWarning, TEXT("File %s is not an executable file."), wszExeFile);
#endif
		    MessageBox( GetParent(hDlg), szWarning, TEXT("Warning"), MB_OK);
	    }
	}
    }

    if (Button_GetCheck(GetDlgItem(hDlg, IDC_ASSOC_EDIT)) != BST_UNCHECKED)
       ptr->m_edit &= (~FTA_OpenIsSafe );
    else
       ptr->m_edit |= FTA_OpenIsSafe;

    ptr->m_stat = UPD;

    pgti->fChanged = TRUE;

    return TRUE;
}

BOOL FAR PASCAL InitEnterAssocDialog(HWND hDlg, LPENTERASSOC penter)
{
    LPASSOCTABINFO pgti = penter->pgti;
    int index = 0;
    HWND hDlgParent = pgti->hDlg;
    TCHAR str[MAX_PATH] = TEXT("");

    if( hDlg == NULL ) return;

    HWND exts = GetDlgItem( hDlg, IDC_DOC_EXTS );
    HWND desc = GetDlgItem( hDlg, IDC_DOC_DESC );
    HWND mime = GetDlgItem( hDlg, IDC_DOC_MIME );
    HWND cmnd = GetDlgItem( hDlg, IDC_DOC_CMND );
    HWND brws = GetDlgItem( hDlg, IDC_BROWSE   );
    HWND edit = GetDlgItem( hDlg, IDC_ASSOC_EDIT );

    CAssoc * ptr = NULL;

    if(penter->pszAssoc && *(penter->pszAssoc))
	if( (index = FindIndex( penter->pszAssoc ) ) != -1 )
	    ptr = (CAssoc *)DPA_FastGetPtr( assocList, index );
 
    if(ptr)
    {
        SendMessage( desc, WM_SETTEXT, 0, (LPARAM)ptr->m_desc );
        SendMessage( mime, WM_SETTEXT, 0, (LPARAM)ptr->m_mime );
        SendMessage( cmnd, WM_SETTEXT, 0, (LPARAM)ptr->m_cmnd );

        // Create Extension List
        if( ptr->m_exts )
        {
            int i, count = DPA_GetPtrCount( ptr->m_exts );
            for(i=0;i<count;i++)
            {
                StrCat( str, (LPTSTR)DPA_FastGetPtr( ptr->m_exts, i ) );
                StrCat( str, TEXT(";") );
            }
            SendMessage( exts, WM_SETTEXT, 0, (LPARAM)str );
        }
                
        Button_SetCheck( GetDlgItem( hDlg, IDC_ASSOC_EDIT), !(ptr->m_edit & FTA_OpenIsSafe) ); 

        EnableWindow( desc, !(ptr->m_safe) );
        EnableWindow( exts, !(ptr->m_safe) );
        EnableWindow( mime, !(ptr->m_safe) );
        EnableWindow( cmnd, !(ptr->m_safe) );
        EnableWindow( brws, !(ptr->m_safe) );
        EnableWindow( edit, !(ptr->m_safe) );

        pgti->fInternalChange = FALSE;
    }

    SetWindowLong(hDlg, DWL_USER, (LPARAM)penter);

    int mimeCount = 0;

    if( mimeList && (mimeCount = DPA_GetPtrCount(mimeList)))
    {
        for(int i=0; i< mimeCount; i++)
        {
            CMime * ptr = (CMime *)DPA_FastGetPtr( mimeList , i );
	    SafeAddStringToComboBox( GetDlgItem(hDlg, IDC_DOC_MIME) , ptr->m_mime) ;
        }   
    }


}

BOOL EnterAssocOnCommand(HWND hDlg, UINT id, UINT nCmd, BOOL *pbChanged)
{
    switch (id)
    { 
        case IDC_BROWSE:
            switch (nCmd )
            {
               case BN_CLICKED:
               {
                    FindCommand( hDlg );
                    break;
               }
            }
            break;
        case IDOK:
            switch (nCmd )
            {
                case BN_CLICKED:
                {
		    SwitchToUpdMode(GetParent(hDlg));
		    if (!*pbChanged || AssocEnter(hDlg))
		        return EndDialog(hDlg, 0);
		    else
		        break;
                }
            }
            break;
        case IDCANCEL:
            switch (nCmd )
            {
                case BN_CLICKED:
                {
		    return EndDialog(hDlg, 0);
                }
            }
            break;
        case IDC_DOC_MIME:
            switch (nCmd)
            {
                case CBN_SELCHANGE:
                case CBN_EDITCHANGE:
		    if (!*pbChanged)
		    {
		        *pbChanged = TRUE;
		    }
                    break;
            }
            break;

        case IDC_ASSOC_EDIT:
            switch (nCmd )
            {
               case BN_CLICKED:
               {
		    if (!*pbChanged)
		    {
		        *pbChanged = TRUE;
		    }
                    break;
               }
            }
            break;

        case IDC_DOC_TYPE:
        case IDC_DOC_EXTS:
        case IDC_DOC_DESC:
        case IDC_DOC_CMND:
            switch (nCmd)
            {
                case EN_CHANGE:
		    if (!*pbChanged)
		    {
		        *pbChanged = TRUE;
		    }
                    break;
            }
            break;
    }

    return FALSE;
}

BOOL CALLBACK EnterAssocDlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static BOOL bChanged;
    if (uMsg == WM_INITDIALOG)
    {
        SendMessage(GetDlgItem( hDlg, IDC_DOC_MIME ), EM_LIMITTEXT, (WPARAM) MAX_PATH-1, 0);
	SendMessage(GetDlgItem( hDlg, IDC_DOC_EXTS ), EM_LIMITTEXT, (WPARAM) MAX_PATH-1, 0);
	SendMessage(GetDlgItem( hDlg, IDC_DOC_DESC ), EM_LIMITTEXT, (WPARAM) MAX_PATH-1, 0);
	SendMessage(GetDlgItem( hDlg, IDC_DOC_CMND ), EM_LIMITTEXT, (WPARAM) MAX_PATH-1, 0);
	InitEnterAssocDialog(hDlg, (LPENTERASSOC)lParam);
	bChanged = FALSE;
    }

    switch (uMsg)
    {
        case WM_COMMAND:
            return EnterAssocOnCommand(hDlg, LOWORD(wParam), HIWORD(wParam), &bChanged);
            break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\inetcpl\webjitres.h ===
/*
 *
 *  IMPORTANT IMPORTANT IMPORTANT
 *
 */
//inetcore\urlmon\download\webjitres.h and shell\cpls\inetcpl\webjitres.h need to be IDENTICAL.

#ifndef IDC_STATIC
#define IDC_STATIC                      -1
#endif
#define IDC_PROGRESS1                   20000
#define IDC_CHECK1                      20001
#define IDC_TEXT                        20002
#define IDB_BITMAP1                     20003
#define IDC_ICON1                       20004
#define IDC_REMAINING_SIZE              20005
#define IDC_REMAINING_TIME              20006

#define IDS_DOWNLOAD_MSG                20201
#define IDS_ERROROCCURED                20202
#define IDS_JAVAVMJIT                   20203
#define IDS_MEDIAPLAYER                 20204

#define IDS_MISSINGCOMPONENTNAME        20301
#define IDS_REINSTALL                   20302
#define IDS_DIALOGERROR                 20303
#define IDS_DIALOGERROR2                20304
#define IDS_WARNINGINSTALLING           20305
#define IDS_ALTWARNINGDOWNLOAD          20306
#define IDS_ALTLANGUAGEDOWNLOAD         20307
#define IDS_DLFAIL                      20308
#define IDS_INSTALLFAIL                 20309
#define IDS_SERVERERROR                 20310
#define IDS_UNKNOWNERROR                20311
#define IDS_PRODUCTUPDATES              20312
#define IDS_NOTCONNECTED                20313
#define IDS_CERTREFUSE                  20314
#define IDS_IBUSY                       20315
#define IDS_SECURITYHIGH                20316
#define IDS_SECURITYHIGH1               20317
#define IDS_SECURITYHIGH2               20318
#define IDS_SECURITYHIGH3               20319
#define IDS_OFFLINEALERT                20320
#define IDS_OFFLINEALERT2               20321
#define IDS_ADMINRIGHTS                 20322
#define IDS_PLATFORMNOT                 20323
#define IDS_INTERNAL                    20324
#define IDS_SETUP                       20325
#define IDS_PROCESS                     20326
#define IDS_KILOBYTES_TEXT              20327
#define IDS_MEGABYTE_TEXT               20328
#define IDS_MINUTES_TEXT                20329
#define IDS_LessThanAMinute_TEXT        20330
#define IDS_hr1_TEXT                    20331
#define IDS_hrs_TEXT                    20332
#define IDS_SIZE                        20333
#define IDS_TIME                        20334
#define IDS_DOWNLOADING                 20335
#define IDS_INSTALLING                  20336
#define IDS_CHECKTRUST                  20337
#define IDS_ERRORTITLE                  20338
#define IDS_WEBJITHELPFILE              20339

#define IDD_WEBJIT                      20440

#define IDDOWNLOAD                      20441
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\main\applet.h ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    applet.h

Abstract:

    This module contains the main header information for this project.

Revision History:

--*/



#ifndef _APPLETS_H
#define _APPLETS_H



//
//  The prototype for an applet function is:
//    int Applet(HINSTANCE instance, HWND parent, LPCTSTR cmdline);
//
//  instance - The instance handle of the control panel containing the applet.
//
//  parent   - Contains the handle of a parent window for the applet (if any).
//
//  cmdline  - Points to the command line for the applet (if available).
//             If the applet was launched without a command line,
//             'cmdline' contains NULL.
//

typedef int (*PFNAPPLET)(HINSTANCE, HWND, LPCTSTR);


//
//  The return value specifies any further action that must be taken:
//      APPLET_RESTART -- Windows must be restarted
//      APPLET_REBOOT  -- the machine must be rebooted
//      all other values are ignored
//

#define APPLET_RESTART            0x8
#define APPLET_REBOOT             (APPLET_RESTART | 0x4)


//
//  The prototype for an applet query functions is:
//      LRESULT AppletQuery(UINT Message);
//

typedef LRESULT (*PFNAPPLETQUERY)(HWND, UINT);

#define APPLET_QUERY_EXISTS       0   //  BOOL result
#define APPLET_QUERY_GETICON      1   //  HICON result



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\main\drvaplet.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    drvaplet.c

Abstract:

    This module contains the driver routines for the project.

Revision History:

--*/



//
//  Include Files.
//

#include "main.h"
#include "drvaplet.h"




//
//  Defines for Win16 builds.
//

#ifndef WIN32
#define LoadLibrary16       LoadLibrary
#define FreeLibrary16       FreeLibrary
#define GetProcAddress16    GetProcAddress
#endif




//
//  Global Variables.
//

//
//  CplApplet.
//
const TCHAR *c_szCplApplet  = TEXT("CPlApplet");
const char  *c_szCplAppletA = "CPlApplet";




//
//  Typedef Declarations.
//

//
//  DRIVER_APPLET_INFO: the info we keep around about a driver applet.
//
typedef struct
{
    HMODULE     module;
    APPLET_PROC applet;
    HICON       icon;

} DRIVER_APPLET_INFO, *PDAI;




//
//  GetDriverModule: gets the module.
//
////////////////////////////////////////////////////////////////////////////
//
//  GetDriverModule
//
//  Gets the module.
//
////////////////////////////////////////////////////////////////////////////

HMODULE GetDriverModule(
    LPCTSTR name)
{
#ifdef WIN32

#ifdef WINNT
    return (LoadLibrary(name));
#else
    return (LoadLibrary16(name));
#endif

#else
    return (GetModuleHandle(name));
#endif
}


////////////////////////////////////////////////////////////////////////////
//
//  ReleaseDriverModule
//
////////////////////////////////////////////////////////////////////////////

void ReleaseDriverModule(
    HMODULE module)
{
#ifdef WIN32

#ifdef WINNT
    FreeLibrary(module);
#else
    FreeLibrary16(module);
#endif

#else
    //
    // do nothing (got it with GetModuleHandle)
    //
#endif
}


////////////////////////////////////////////////////////////////////////////
//
//  OpenDriverApplet
//
//  Opens a handle to the named driver applet.
//
////////////////////////////////////////////////////////////////////////////

HDAP OpenDriverApplet(
    LPCTSTR name)
{
    PDAI driver = (PDAI)LocalAlloc(LPTR, sizeof(DRIVER_APPLET_INFO));

    if (driver)
    {
        if ((driver->module = GetDriverModule(name)) != NULL)
        {
            if ((driver->applet = (APPLET_PROC)
#ifdef WINNT
                GetProcAddress(driver->module, c_szCplAppletA)) != NULL)
#else
                GetProcAddress16(driver->module, c_szCplApplet)) != NULL)
#endif
            {
                union
                {
                    NEWCPLINFO newform;
                    CPLINFO oldform;
                } info = { 0 };

                CallDriverApplet( (HDAP) driver,
                                  NULL,
                                  CPL_NEWINQUIRE,
                                  0,
                                  (LPARAM)&info.newform );

                if (info.newform.dwSize == sizeof(info.newform))
                {
                    driver->icon = info.newform.hIcon;
                    return ((HDAP)driver);
                }

//
//  NOTE: If the driver doesn't handle CPL_NEWIQUIRE, we must use CPL_INQUIRE
//  and LoadIcon the icon ourselves.  Win32 doesn't provide a LoadIcon16, so
//  in Win32 the 16 bit side of the thunk for CPL_NEWINQUIRE does this.  In
//  Win16, we do it right here.
//

#ifndef WIN32
                info.oldform.idIcon = 0;

                CallDriverApplet( (HDAP)driver,
                                  NULL,
                                  CPL_INQUIRE,
                                  0,
                                  (LPARAM)&info.oldform );

                if (info.oldform.idIcon)
                {
                    driver->icon =
                        LoadIcon( driver->module,
                                  MAKEINTRESOURCE(info.oldform.idIcon) );

                    return ((HDAP)driver);
                }
#endif
            }

            ReleaseDriverModule(driver->module);
        }

        LocalFree(driver);
    }

    return ((HDAP)0);
}


////////////////////////////////////////////////////////////////////////////
//
//  CloseDriverApplet
//
//  Closes a handle to a driver applet.
//
////////////////////////////////////////////////////////////////////////////

void CloseDriverApplet(
    HDAP HDAP)
{
#define driver ((PDAI)HDAP)

    if (driver)
    {
        if (driver->icon)
        {
            DestroyIcon(driver->icon);
        }
        ReleaseDriverModule(driver->module);
        LocalFree(driver);
    }

#undef driver
}


////////////////////////////////////////////////////////////////////////////
//
//  GetDriverAppletIcon
//
//  Gets a driver applet's icon (if any).
//
////////////////////////////////////////////////////////////////////////////

HICON GetDriverAppletIcon(
    HDAP HDAP)
{
#define driver ((PDAI)HDAP)

    //
    //  Must return a copy for the current process/task to own.
    //
    return ((driver && driver->icon) ? CopyIcon(driver->icon) : NULL);

#undef driver
}


////////////////////////////////////////////////////////////////////////////
//
//  CallDriverApplet
//
//  Calls the driver applet (same syntax as CplApplet).
//
////////////////////////////////////////////////////////////////////////////

LRESULT CallDriverApplet(
    HDAP HDAP,
    HWND wnd,
    UINT msg,
    LPARAM p1,
    LPARAM p2)
{
#define driver ((PDAI)HDAP)

    if (driver)
    {
#ifdef WIN32
        return ( CallCPLEntry16( driver->module,
                                 (FARPROC16)driver->applet,
                                 wnd,
                                 msg,
                                 p1,
                                 p2 ) );
#else
        return (driver->applet(wnd, msg, p1, p2));
#endif
    }

    return (0L);

#undef driver
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\main\drvaplet.h ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    drvaplet.h

Abstract:

    This module contains the header information for the driver routines
    for the project.

Revision History:

--*/



#ifndef _DRVAPLET_H
#define _DRVAPLET_H


//
//  HDAP: handle to a driver applet.
//

DECLARE_HANDLE(HDAP);


//
//  GetDriverModule: gets the module.
//
HMODULE GetDriverModule(LPCTSTR name);

//
// ReleaseDriverModule:  releases the module.
//
void ReleaseDriverModule(HMODULE module);

//
//  OpenDriverApplet: opens a handle to the named driver applet.
//
HDAP OpenDriverApplet(LPCTSTR);


//
//  CloseDriverApplet: closes a handle to a driver applet.
//
void CloseDriverApplet(HDAP);


//
//  GetDriverAppletIcon: get's a driver applet's icon (if any).
//
HICON GetDriverAppletIcon(HDAP);


//
//  CallDriverApplet: sends a message to the driver applet (CplApplet syntax).
//
LRESULT CallDriverApplet(HDAP, HWND, UINT, LPARAM, LPARAM);


//
//  RunDriverApplet: runs the driver applet.
//
#define RunDriverApplet(h, w)  CallDriverApplet(h, w, CPL_DBLCLK, 0L, 0L)


//
//  "CplApplet"
//
extern const TCHAR *c_szCplApplet;



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\main\fake.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    mouse.c

Abstract:

    This module contains the routines for the "fake" applets.

Revision History:

--*/



//
//  Include Files.
//

#include "main.h"
#include "rc.h"
#include "applet.h"

//
// From shell\inc\shsemip.h
//
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

//
//  From shelldll\help.c.
//
VOID WINAPI SHHelpShortcuts_RunDLL( HWND, HINSTANCE, LPCSTR, int );
VOID WINAPI SHHelpShortcuts_RunDLLW( HWND, HINSTANCE, LPCWSTR, int );

static const TCHAR c_szPrintersFolder[]           = TEXT("PrintersFolder");
static const TCHAR c_szFontsFolder[]              = TEXT("FontsFolder");




////////////////////////////////////////////////////////////////////////////
//
//  PrintApplet
//
////////////////////////////////////////////////////////////////////////////

int PrintApplet(
    HINSTANCE instance,
    HWND parent,
    LPCTSTR cmdline)
{
#ifdef UNICODE
    SHHelpShortcuts_RunDLLW( NULL,
                             GetModuleHandle(NULL),
                             c_szPrintersFolder,
                             SW_SHOWNORMAL );
#else
    SHHelpShortcuts_RunDLL( NULL,
                            GetModuleHandle(NULL),
                            c_szPrintersFolder,
                            SW_SHOWNORMAL );
#endif

    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  FontsApplet
//
////////////////////////////////////////////////////////////////////////////

int FontsApplet(
    HINSTANCE instance,
    HWND parent,
    LPCTSTR cmdline)
{
#ifdef UNICODE
    SHHelpShortcuts_RunDLLW( NULL,
                             GetModuleHandle(NULL),
                             c_szFontsFolder,
                             SW_SHOWNORMAL );
#else
    SHHelpShortcuts_RunDLL( NULL,
                            GetModuleHandle(NULL),
                            c_szFontsFolder,
                            SW_SHOWNORMAL );
#endif

    return (0);
}

////////////////////////////////////////////////////////////////////////////
//
//  AdmApplet
//
////////////////////////////////////////////////////////////////////////////

int AdmApplet(
    HINSTANCE instance,
    HWND parent,
    LPCTSTR cmdline)
{
    TCHAR szPath[MAX_PATH];
    TCHAR szAdminTools[MAX_PATH];

    if ( !SHGetSpecialFolderPath(parent, szPath, CSIDL_COMMON_PROGRAMS, 0) )
        return 1;

    // load the string for the tools folder, then path combine the two so that
    // we can open that directory.

    if ( !LoadString(instance, IDS_ADM_TITLE, szAdminTools, ARRAYSIZE(szAdminTools)) )
        return 1;
    
    //+1 for backslash and +1 for '\0'

    if ( (lstrlen(szPath)+lstrlen(szAdminTools)+1+1) > ARRAYSIZE(szPath) )
        return 1;

    PathCombine(szPath, szPath, szAdminTools);
    ShellExecute(parent, NULL, szPath, NULL, NULL, SW_SHOWDEFAULT);

    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\main\keybdspd.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    keybdspd.c

Abstract:

    This module contains the main routines for the Keyboard applet's
    Speed property page.

Revision History:

--*/



//
//  Include Files.
//

#include "main.h"
#include "rc.h"
#include "util.h"
#include <regstr.h>
#include <help.h>




//
//  Constant Declarations.
//

#define KSPEED_MIN      0
#define KSPEED_MAX      31
#define KSPEED_RANGE    (KSPEED_MAX - KSPEED_MIN + 1)

//
//  For keyboard delay control.
//
#define KDELAY_MIN      0
#define KDELAY_MAX      3
#define KDELAY_RANGE    (KDELAY_MAX - KDELAY_MIN + 1)

//
//  For control of the cursor blink rate.
//
//  timer ID
#define BLINK           1000
//  Note that 1300 is converted to -1, which means "off". The max value
//  that we set is actually 1200.
#define CURSORMIN       200
#define CURSORMAX       1300
#define CURSORRANGE     (CURSORMAX - CURSORMIN)

static ARROWVSCROLL avsDelay =  { -1,
                                  1,
                                  -KDELAY_RANGE / 4,
                                  KDELAY_RANGE / 4,
                                  KDELAY_MAX,
                                  KDELAY_MIN
                                };
static ARROWVSCROLL avsSpeed  = { -1,
                                  1,
                                  -KSPEED_RANGE / 4,
                                  KSPEED_RANGE / 4,
                                  KSPEED_MAX,
                                  KSPEED_MIN
                                };
static ARROWVSCROLL avsCursor = { -1,                   // lineup
                                  1,                    // linedown
                                  -CURSORRANGE / 400,   // pageup
                                  CURSORRANGE / 400,    // pagedown
                                  CURSORRANGE / 100,    // top
                                  0,                    // bottom
                                  0,                    // thumbpos
                                  0                     // thumbtrack
                                };




//
//  Context Help Ids.
//

static DWORD aKbdHelpIds[] =
{
    KDELAY_GROUP,        IDH_COMM_GROUPBOX,
    KBLINK_GROUP,        IDH_COMM_GROUPBOX,
    KDELAY_SCROLL,       IDH_DLGKEY_REPDEL,
    KSPEED_SCROLL,       IDH_DLGKEY_REPSPEED,
    KREPEAT_EDIT,        IDH_DLGKEY_REPTEST,
    KBLINK_EDIT,         IDH_DLGKEY_CURSOR_GRAPHIC,
    KCURSOR_BLINK,       IDH_DLGKEY_CURSOR_GRAPHIC,
    KCURSOR_SCROLL,      IDH_DLGKEY_CURSBLNK,

    0, 0
};



//
//  Global Variables.
//

//
//  FEATURE - these should be moved into the KeyboardSpdStr structure
//
static UINT uOriginalDelay, uOriginalSpeed;
static UINT uBlinkTime;
static UINT uNewBlinkTime;
static BOOL bKbNeedsReset = FALSE;
static HWND hwndCursorScroll;
static HWND hwndCursorBlink;
static BOOL fBlink = TRUE;



//
//  Typedef Declarations.
//

typedef struct tag_KeyboardSpdStr
{
    HWND hDlg;        // HWND hKeyboardSpdDlg;

} KEYBOARDSPDSTR, *PKEYBOARDSPDSTR;


//
// Helper functions to handle the caret "off" setting
//
void _SetCaretBlinkTime(UINT uInterval)
{
    if (uInterval != uNewBlinkTime)
    {
        uNewBlinkTime = uInterval;

        if (CURSORMAX == uInterval)
            uInterval = (UINT)-1;   // blink is "off"

        SetCaretBlinkTime(uInterval);
    }
}

void _SetTimer(HWND hDlg, UINT uInterval)
{
    if (uInterval < CURSORMAX)
    {
        SetTimer(hDlg, BLINK, uInterval, NULL);
    }
    else
    {
        // Caret blink is "off".
        // Kill the timer and show our pseudo-caret.
        KillTimer(hDlg, BLINK);
        fBlink = TRUE;
        ShowWindow(hwndCursorBlink, SW_SHOW);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  KeyboardSpeedSupported
//
////////////////////////////////////////////////////////////////////////////

BOOL KeyboardSpeedSupported()
{
#ifdef WINNT
    //
    // FEATURE  For Windows NT we assume that all keyboards can
    //         handle the SetSpeed - we might be able to do a
    //         better check in the future if KEYBOARD.DLL is available.
    //
    return (TRUE);
#else
    HANDLE hKeyboardModule = LoadLibrary16(TEXT("KEYBOARD"));
    BOOL bCanDorkWithTheSpeed = FALSE;

    if (hKeyboardModule)
    {
        if (GetProcAddress16(hKeyboardModule, TEXT("SetSpeed")))
        {
            bCanDorkWithTheSpeed = TRUE;
        }

        FreeLibrary16(hKeyboardModule);
    }

    return (bCanDorkWithTheSpeed);
#endif
}


////////////////////////////////////////////////////////////////////////////
//
//  SetDelayAndSpeed
//
////////////////////////////////////////////////////////////////////////////

void SetDelayAndSpeed(
    HWND hDlg,
    int nDelay,
    int nSpeed,
    UINT uFlags)
{
    if (nDelay < 0)
    {
        nDelay = (int)SendDlgItemMessage( hDlg,
                                          KDELAY_SCROLL,
                                          TBM_GETPOS,
                                          0,
                                          0L );
    }

    if (nSpeed < 0)
    {
        nSpeed = (int)SendDlgItemMessage( hDlg,
                                          KSPEED_SCROLL,
                                          TBM_GETPOS,
                                          0,
                                          0L );
    }

    //
    //  Only send the WININICHANGE once.
    //
    SystemParametersInfo( SPI_SETKEYBOARDSPEED,
                          nSpeed,
                          0,
                          uFlags & ~SPIF_SENDWININICHANGE );
    SystemParametersInfo( SPI_SETKEYBOARDDELAY,
                          KDELAY_MAX - nDelay + KDELAY_MIN,
                          0L,
                          uFlags );
}


////////////////////////////////////////////////////////////////////////////
//
//  DestroyKeyboardSpdDlg
//
////////////////////////////////////////////////////////////////////////////

void DestroyKeyboardSpdDlg(
    PKEYBOARDSPDSTR pKstr)
{
    HWND hDlg;

    if (pKstr)
    {
        hDlg = pKstr->hDlg;

        LocalFree((HGLOBAL)pKstr);

        SetWindowLongPtr(hDlg, DWLP_USER, 0);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  GetSpeedGlobals
//
//  Get Repeat Speed, Delay, and Blink Time.
//
////////////////////////////////////////////////////////////////////////////

VOID GetSpeedGlobals()
{
    SystemParametersInfo(SPI_GETKEYBOARDSPEED, 0, &uOriginalSpeed, FALSE);
    SystemParametersInfo(SPI_GETKEYBOARDDELAY, 0, &uOriginalDelay, FALSE);

    uOriginalDelay = KDELAY_MAX - uOriginalDelay + KDELAY_MIN;

    // -1 means "off"
    uBlinkTime = GetCaretBlinkTime();
    if ((UINT)-1 == uBlinkTime || uBlinkTime > CURSORMAX)
        uBlinkTime = CURSORMAX;
    uNewBlinkTime = uBlinkTime;
}


////////////////////////////////////////////////////////////////////////////
//
//  InitKeyboardSpdDlg
//
////////////////////////////////////////////////////////////////////////////

BOOL InitKeyboardSpdDlg(
    HWND hDlg)
{
    HourGlass(TRUE);

    if (!KeyboardSpeedSupported())
    {
        MyMessageBox( hDlg,
                      IDS_KEYBD_NOSETSPEED,
                      IDS_KEYBD_TITLE,
                      MB_OK | MB_ICONINFORMATION );

        HourGlass(FALSE);
        return (FALSE);
    }

    //
    //  Get Repeat Speed, Delay, and Blink Time.
    //
    GetSpeedGlobals();

    TrackInit(GetDlgItem(hDlg, KSPEED_SCROLL), uOriginalSpeed, &avsSpeed);
    TrackInit(GetDlgItem(hDlg, KDELAY_SCROLL), uOriginalDelay, &avsDelay);
    TrackInit(GetDlgItem(hDlg, KCURSOR_SCROLL), (CURSORMAX - uBlinkTime) / 100, &avsCursor );

    hwndCursorScroll = GetDlgItem(hDlg, KCURSOR_SCROLL);
    hwndCursorBlink = GetDlgItem(hDlg, KCURSOR_BLINK);

    _SetTimer(hDlg, uBlinkTime);

    HourGlass(FALSE);
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  KeyboardSpdDlg
//
////////////////////////////////////////////////////////////////////////////

static const TCHAR c_szUserDesktopKey[] = REGSTR_PATH_DESKTOP;
static const TCHAR c_szCursorBlink[] = TEXT("CursorBlinkRate");

INT_PTR CALLBACK KeyboardSpdDlg(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PKEYBOARDSPDSTR pKstr = (PKEYBOARDSPDSTR)GetWindowLongPtr(hDlg, DWLP_USER);
    
    switch (message)
    {
        case ( WM_INITDIALOG ) :
        {
            bKbNeedsReset = FALSE;
            return (InitKeyboardSpdDlg(hDlg));
            break;
        }
        case ( WM_DESTROY ) :
        {
            DestroyKeyboardSpdDlg(pKstr);
            break;
        }
        case ( WM_HSCROLL ) :
        {
            if ((HWND)lParam == hwndCursorScroll)
            {
                int nCurrent = (int)SendMessage( (HWND)lParam,
                                                 TBM_GETPOS,
                                                 0,
                                                 0L );

                _SetCaretBlinkTime(CURSORMAX - (nCurrent * 100));
                _SetTimer(hDlg, uNewBlinkTime);
            }
            else
            {
                SetDelayAndSpeed(hDlg, -1, -1, 0);
                bKbNeedsReset = TRUE;
            }

            SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
            break;
        }
        case ( WM_TIMER ) :
        {
            if (wParam == BLINK)
            {
                fBlink = !fBlink;
                ShowWindow(hwndCursorBlink, fBlink ? SW_SHOW : SW_HIDE);
            }
            break;
        }
        case ( WM_WININICHANGE ) :
        case ( WM_SYSCOLORCHANGE ) :
        case ( WM_DISPLAYCHANGE ) :
        {
            SHPropagateMessage(hDlg, message, wParam, lParam, TRUE);
            break;
        }

        case ( WM_HELP ) :             // F1
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     NULL,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aKbdHelpIds );
            break;
        }
        case ( WM_CONTEXTMENU ) :      // right mouse click
        {
            WinHelp( (HWND)wParam,
                     NULL,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aKbdHelpIds );
            break;
        }
        case ( WM_NOTIFY ) :
        {
            switch (((NMHDR *)lParam)->code)
            {
                case ( PSN_APPLY ) :
                {
                    HKEY hk;

                    HourGlass(TRUE);

                    if (RegCreateKey( HKEY_CURRENT_USER,
                                      c_szUserDesktopKey,
                                      &hk ) == ERROR_SUCCESS)
                    {
                        TCHAR buf[16];

                        if (CURSORMAX == uNewBlinkTime)
                            lstrcpy(buf, TEXT("-1"));
                        else
                            wsprintf(buf, TEXT("%d"), uNewBlinkTime);
                        RegSetValueEx( hk,
                                       c_szCursorBlink,
                                       0,
                                       REG_SZ,
                                       (LPBYTE)buf,
                                       (DWORD)(lstrlen(buf) + 1) * sizeof(TCHAR) );

                        RegCloseKey(hk);
                    }

                    SetDelayAndSpeed( hDlg,
                                      -1,
                                      -1,
                                      SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE );
                    GetSpeedGlobals();
                    HourGlass(FALSE);

                    break;
                }
                case ( PSN_RESET ) :
                {
                    _SetCaretBlinkTime(uBlinkTime);

                    if (bKbNeedsReset)
                    {
                        //
                        //  Restore the original keyboard speed.
                        //
                        SetDelayAndSpeed( hDlg,
                                          uOriginalDelay,
                                          uOriginalSpeed,
                                          0 );
                    }
                    break;
                }
            }
            break;
        }
        default :
        {
            return FALSE;
        }
    }

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\main\main.h ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    main.h

Abstract:

    This module contains the header information for the main routines of the
    Control Panel interface of the 32bit MAIN.CPL.

Revision History:

--*/



#ifndef _MAIN_H
#define _MAIN_H

#define USECOMM
#define OEMRESOURCE
#define STRICT

#ifdef WIN32
#define INC_OLE2
#define CONST_VTABLE
#endif



//
//  Include Files.
//

#include <windows.h>
#include <windowsx.h>
#include <dlgs.h>
#include <cpl.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <shellapi.h>
#include <shlobjp.h>
#include <commctrl.h>
#include <shfusion.h>

#ifndef RC_INVOKED
#include <prsht.h>
#include <debug.h>  // for ASSERT
#endif




//
//  Constant Declarations.
//

#define PATHMAX MAX_PATH
#define HELP_FILE TEXT("mouse.hlp")  // Help file for the mouse control panel




//
//  Typedef Declarations.
//

#ifndef NOARROWS
typedef struct
{
    short lineup;             // lineup/down, pageup/down are relative
    short linedown;           // changes.  top/bottom and the thumb
    short pageup;             // elements are absolute locations, with
    short pagedown;           // top & bottom used as limits.
    short top;
    short bottom;
    short thumbpos;
    short thumbtrack;
    BYTE  flags;              // flags set on return
} ARROWVSCROLL, NEAR *PARROWVSCROLL, FAR *LPARROWVSCROLL;

#define UNKNOWNCOMMAND 1
#define OVERFLOW       2
#define UNDERFLOW      4

#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\main\keybd.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    keybd.c

Abstract:

    This module contains the main routines for the Keyboard applet.

Revision History:

--*/



//
//  Include Files.
//

#include "main.h"
#include "rc.h"
#include "applet.h"
#include <regstr.h>
#include <cplext.h>
#include "util.h"
#include <intlid.h>




//
//  Constant Declarations.
//

#define MAX_PAGES 32              // limit on number of pages

const HWPAGEINFO c_hpiKeybd = {
    // Keyboard device class
    { 0x4d36e96bL, 0xe325, 0x11ce, { 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 } },

    // Keyboard troubleshooter command line
    IDS_KEYBD_TSHOOT,
};





//
//  Global Variables.
//

//
//  Location of prop sheet hooks in the registry.
//
static const TCHAR sc_szRegKeybd[] = REGSTR_PATH_CONTROLSFOLDER TEXT("\\Keyboard");




//
//  Function Prototypes.
//

INT_PTR CALLBACK
KeyboardSpdDlg(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);





////////////////////////////////////////////////////////////////////////////
//
//  _AddKeybdPropSheetPage
//
//  Adds a property sheet page.
//
////////////////////////////////////////////////////////////////////////////

BOOL CALLBACK _AddKeybdPropSheetPage(
    HPROPSHEETPAGE hpage,
    LPARAM lParam)
{
    PROPSHEETHEADER *ppsh = (PROPSHEETHEADER *)lParam;

    if (hpage && ppsh->nPages < MAX_PAGES)
    {
        ppsh->phpage[ppsh->nPages++] = hpage;
        return (TRUE);
    }
    return (FALSE);
}



////////////////////////////////////////////////////////////////////////////
//
//  KeybdApplet
//
////////////////////////////////////////////////////////////////////////////

int KeybdApplet(
    HINSTANCE instance,
    HWND parent,
    LPCTSTR cmdline)
{
    HPROPSHEETPAGE rPages[MAX_PAGES];
    PROPSHEETPAGE psp;
    PROPSHEETHEADER psh;
    HPSXA hpsxa;
    int Result;

    //
    //  Make the initial page.
    //
    psh.dwSize     = sizeof(psh);
    psh.dwFlags    = PSH_PROPTITLE;
    psh.hwndParent = parent;
    psh.hInstance  = instance;
    psh.pszCaption = MAKEINTRESOURCE(IDS_KEYBD_TITLE);
    psh.nPages     = 0;

    if (cmdline)
    {
        psh.nStartPage = lstrlen(cmdline) ? StrToLong(cmdline) : 0;
    }
    else
    {
        psh.nStartPage = 0;
    }
    psh.phpage = rPages;

    //
    //  Load any installed extensions.
    //
    hpsxa = SHCreatePropSheetExtArray(HKEY_LOCAL_MACHINE, sc_szRegKeybd, 8);

    //
    //  Add the Speed page.
    //
    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_DEFAULT;
    psp.hInstance   = instance;
    psp.pszTemplate = MAKEINTRESOURCE(DLG_KEYBD_SPEED);
    psp.pfnDlgProc  = KeyboardSpdDlg;
    psp.lParam      = 0;

    _AddKeybdPropSheetPage(CreatePropertySheetPage(&psp), (LPARAM)&psh);

    //
    //  Add the Hardware page (not replaceable).
    //
    _AddKeybdPropSheetPage(CreateHardwarePage(&c_hpiKeybd), (LPARAM)&psh);

    //
    //  Add any extra pages that the extensions want in there.
    //
    if (hpsxa)
    {
        UINT cutoff = psh.nPages;
        UINT added = SHAddFromPropSheetExtArray( hpsxa,
                                                 _AddKeybdPropSheetPage,
                                                 (LPARAM)&psh );

        if (psh.nStartPage >= cutoff)
        {
            psh.nStartPage += added;
        }
    }

    //
    //  Invoke the Property Sheets.
    //
    switch (PropertySheet(&psh))
    {
        case ( ID_PSRESTARTWINDOWS ) :
        {
            Result = APPLET_RESTART;
            break;
        }
        case ( ID_PSREBOOTSYSTEM ) :
        {
            Result = APPLET_REBOOT;
            break;
        }
        default :
        {
            Result = 0;
            break;
        }
    }

    //
    //  Free any loaded extensions.
    //
    if (hpsxa)
    {
        SHDestroyPropSheetExtArray(hpsxa);
    }

    return (Result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\main\main.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    main.c

Abstract:

    This module contains the main routines for the Control Panel
    interface of the 32bit MAIN.CPL.

Revision History:

--*/



//
//  Include Files.
//

#include "main.h"
#include "rc.h"
#include "applet.h"
#include "mousectl.h"
#include "drvaplet.h"


#define SZ_DEBUGINI     "maincpl.ini"
#define SZ_MODULE       "main"
#define SZ_DEBUGSECTION "debug"

#define DECLARE_DEBUG
#include <ccstock.h>
#include <debug.h>


//
//  Global Variables.
//

#ifdef WINNT

HINSTANCE g_hInst = NULL;

#else

#pragma data_seg(".idata")
HINSTANCE g_hInst = NULL;
#pragma data_seg()

#endif




//
//  Externally Defined Applets.
//

int MouseApplet(HINSTANCE, HWND, LPCTSTR);  // mouse.c
int KeybdApplet(HINSTANCE, HWND, LPCTSTR);  // keybd.c

BOOL RegisterPointerStuff(HINSTANCE);       // from mouseptr.c




//
//  Typedef Declarations.
//
typedef struct
{
    int            idIcon;
    int            idTitle;
    int            idExplanation;
    PFNAPPLETQUERY pfnAppletQuery;
    PFNAPPLET      pfnApplet;
    LPCTSTR        szDriver;
} APPLET;

APPLET Applets[] =
{
    { IDI_MOUSE,       IDS_MOUSE_TITLE,  IDS_MOUSE_EXPLAIN,  NULL,  MouseApplet,  TEXT("MOUSE") },
    { IDI_KEYBD,       IDS_KEYBD_TITLE,  IDS_KEYBD_EXPLAIN,  NULL,  KeybdApplet,  NULL    },
};

#define NUM_APPLETS (sizeof(Applets) / sizeof(Applets[0]))

int cApplets = NUM_APPLETS;





////////////////////////////////////////////////////////////////////////////
//
//  LibMain
//
////////////////////////////////////////////////////////////////////////////

BOOL APIENTRY LibMain(
    HINSTANCE hDll,
    DWORD dwReason,
    LPVOID lpReserved)
{
    switch (dwReason)
    {
        case ( DLL_PROCESS_ATTACH ) :
        {
            g_hInst = hDll;
            DisableThreadLibraryCalls(hDll);
            SHFusionInitializeFromModuleID(hDll, 124);
            break;
        }
        case ( DLL_PROCESS_DETACH ) :
        {
            SHFusionUninitialize();
            break;
        }
        case ( DLL_THREAD_ATTACH ) :
        case ( DLL_THREAD_DETACH ) :
        {
            break;
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CplInit
//
//  Called when a CPL consumer initializes a CPL.
//
////////////////////////////////////////////////////////////////////////////

LRESULT CplInit(
    HWND hParent)
{
    int i;

    InitCommonControls();

    RegisterPointerStuff(g_hInst);

    RegisterMouseControlStuff(g_hInst);

    for (i = 0; i < cApplets; i++)
    {
        if ((Applets[i].pfnAppletQuery != NULL) &&
            ((*Applets[i].pfnAppletQuery)(hParent, APPLET_QUERY_EXISTS) == FALSE))
        {
            cApplets--;

            if (i != cApplets)
            {
                Applets[i] = Applets[cApplets];
            }

            i--;
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CplExit
//
//  Called when a CPL consumer is done with a CPL.
//
////////////////////////////////////////////////////////////////////////////

void CplExit(void)
{
}


////////////////////////////////////////////////////////////////////////////
//
//  CplInquire
//
//  Called when a CPL consumer wants info about an applet.
//
////////////////////////////////////////////////////////////////////////////

LRESULT CplInquire(
    LPCPLINFO info,
    int iApplet)
{
    APPLET *applet = Applets + iApplet;
    HMODULE hDriverApplet = NULL;

    info->idIcon = applet->idIcon;

    if (applet->szDriver) {

        if (hDriverApplet = GetDriverModule(applet->szDriver)) {

            info->idIcon = CPL_DYNAMIC_RES;
            ReleaseDriverModule(hDriverApplet);

        } // if (hDriverApplet = ...

    } // if (applet->szDriver)

    info->idName = applet->idTitle;
    info->idInfo = applet->idExplanation;
    info->lData  = 0L;

    return (1L);
}


////////////////////////////////////////////////////////////////////////////
//
//  CplNewInquire
//
//  Called when a CPL consumer wants info about an applet.
//
////////////////////////////////////////////////////////////////////////////

LRESULT CplNewInquire(
    HWND parent,
    LPNEWCPLINFO info,
    int iApplet)
{
    APPLET *applet = Applets + iApplet;
    HDAP hdap;

    info->dwSize = sizeof(NEWCPLINFO);
    info->hIcon = NULL;

    //
    //  See if the applet is associated with a driver which can provide us
    //  an icon.
    //
    if ((applet->szDriver) &&
        ((hdap = OpenDriverApplet(applet->szDriver)) != NULL))
    {
        info->hIcon = GetDriverAppletIcon(hdap);
        CloseDriverApplet(hdap);
    }

    if ((!info->hIcon) && (applet->pfnAppletQuery != NULL))
    {
        info->hIcon = (HICON)(*(applet->pfnAppletQuery))( parent,
                                                          APPLET_QUERY_GETICON );
    }

    if (!info->hIcon)
    {
        info->hIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(applet->idIcon));
    }

    LoadString(g_hInst, applet->idTitle, info->szName, sizeof(info->szName));
    LoadString(g_hInst, applet->idExplanation, info->szInfo, sizeof(info->szInfo));

    info->lData = 0L;
    *info->szHelpFile = 0;
    info->dwHelpContext = 0UL;

    return (1L);
}


////////////////////////////////////////////////////////////////////////////
//
//  CplInvoke
//
//  Called to invoke an applet.  It checks the applet's return value to see
//  if we need to restart.
//
////////////////////////////////////////////////////////////////////////////

LRESULT CplInvoke(
    HWND parent,
    int iApplet,
    LPCTSTR cmdline)
{
    DWORD exitparam = 0UL;
    DWORD dwExitReason = SHTDN_REASON_FLAG_PLANNED |
                         SHTDN_REASON_MAJOR_OPERATINGSYSTEM |
                         SHTDN_REASON_MINOR_RECONFIG;

    switch (Applets[iApplet].pfnApplet(g_hInst, parent, cmdline))
    {
        case ( APPLET_RESTART ) :
        {
            exitparam = EW_RESTARTWINDOWS;
            break;
        }
        case ( APPLET_REBOOT ) :
        {
            exitparam = EW_REBOOTSYSTEM;
            break;
        }
        default :
        {
            return (1L);
        }
    }

    RestartDialogEx(parent, NULL, exitparam, dwExitReason);
    return (1L);
}


////////////////////////////////////////////////////////////////////////////
//
//  CplApplet
//
//  A CPL consumer calls this to request stuff from us.
//
////////////////////////////////////////////////////////////////////////////

LRESULT APIENTRY CPlApplet(
    HWND parent,
    UINT msg,
    LPARAM lparam1,
    LPARAM lparam2)
{
    switch (msg)
    {
        case ( CPL_INIT ) :
        {
            return (CplInit(parent));
        }
        case ( CPL_EXIT ) :
        {
            CplExit();
            break;
        }
        case ( CPL_GETCOUNT ) :
        {
            return (cApplets);
        }
        case ( CPL_INQUIRE ) :
        {
            return (CplInquire((LPCPLINFO)lparam2, (int)lparam1));
        }
        case ( CPL_NEWINQUIRE ) :
        {
            return (CplNewInquire(parent, (LPNEWCPLINFO)lparam2, (int)lparam1));
        }
        case ( CPL_DBLCLK ) :
        {
            lparam2 = 0L;

            // fall through...
        }
        case ( CPL_STARTWPARMS ) :
        {
            return (CplInvoke(parent, (int)lparam1, (LPTSTR)lparam2));
        }
    }

    return (0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\main\mousectl.h ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    mousectl.h

Abstract:

    This module contains the header information for the Mouse control.

Revision History:

--*/



#ifndef _MOUSECTL_H
#define _MOUSECTL_H



#define MOUSECTL_CLASSNAME  TEXT("PropertyMouseButtonControl")


BOOL
RegisterMouseControlStuff(
    HINSTANCE instance);

void
MouseControlSetSwap(
    HWND window,
    BOOL swap);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\main\mouse.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    mouse.c

Abstract:

    This module contains the main routines for the Mouse applet.

Revision History:

--*/



//
//  Include Files.
//

#include "main.h"
#include "rc.h"
#include "applet.h"
#include <regstr.h>
#include <cplext.h>
#include "util.h"



//
//  Constant Declarations.
//

#define MAX_PAGES 32


const HWPAGEINFO c_hpiMouse = {
    // Mouse device class
    { 0x4d36e96fL, 0xe325, 0x11ce, { 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 } },

    // Mouse troubleshooter command line
    IDS_MOUSE_TSHOOT,
};


//
//  Global Variables.
//

//
//  Location of prop sheet hooks in the registry.
//
static const TCHAR sc_szRegMouse[] = REGSTR_PATH_CONTROLSFOLDER TEXT("\\Mouse");




//
//  Function Prototypes.
//

INT_PTR CALLBACK
MouseButDlg(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);

INT_PTR CALLBACK
MousePtrDlg(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam);

INT_PTR CALLBACK
MouseMovDlg(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);

/*
INT_PTR CALLBACK
MouseActivitiesDlg(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);
*/

INT_PTR CALLBACK
MouseWheelDlg(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);


static int
GetClInt( const TCHAR *p );


////////////////////////////////////////////////////////////////////////////
//
//  _AddMousePropSheetPage
//
//  Adds a property sheet page.
//
////////////////////////////////////////////////////////////////////////////

BOOL CALLBACK _AddMousePropSheetPage(
    HPROPSHEETPAGE hpage,
    LPARAM lParam)
{
    PROPSHEETHEADER *ppsh = (PROPSHEETHEADER *)lParam;

    if (hpage && (ppsh->nPages < MAX_PAGES))
    {
        ppsh->phpage[ppsh->nPages++] = hpage;
        return (TRUE);
    }
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  MouseApplet
//
////////////////////////////////////////////////////////////////////////////

int MouseApplet(
    HINSTANCE instance,
    HWND parent,
    LPCTSTR cmdline)
{
    HPROPSHEETPAGE rPages[MAX_PAGES];
    PROPSHEETPAGE psp;
    PROPSHEETHEADER psh;
    HPSXA hpsxa;
    int Result;

    //
    //  Make the initial page.
    //
    psh.dwSize     = sizeof(psh);
    psh.dwFlags    = PSH_PROPTITLE;
    psh.hwndParent = parent;
    psh.hInstance  = instance;
    psh.pszCaption = MAKEINTRESOURCE(IDS_MOUSE_TITLE);
    psh.nPages     = 0;
    psh.nStartPage = ( ( cmdline && *cmdline )? GetClInt( cmdline ) : 0 );
    psh.phpage     = rPages;

    //
    //  Load any installed extensions.
    //
    hpsxa = SHCreatePropSheetExtArray(HKEY_LOCAL_MACHINE, sc_szRegMouse, 8);

    //
    //  Add the Buttons page, giving the extensions a chance to replace it.
    //
    if (!hpsxa ||
        !SHReplaceFromPropSheetExtArray( hpsxa,
                                         CPLPAGE_MOUSE_BUTTONS,
                                         _AddMousePropSheetPage,
                                         (LPARAM)&psh ))
    {
        psp.dwSize      = sizeof(psp);
        psp.dwFlags     = PSP_DEFAULT;
        psp.hInstance   = instance;
        psp.pszTemplate = MAKEINTRESOURCE(DLG_MOUSE_BUTTONS);
        psp.pfnDlgProc  = MouseButDlg;
        psp.lParam      = 0;

        _AddMousePropSheetPage(CreatePropertySheetPage(&psp), (LPARAM)&psh);
    }


    //
    //  Add the Pointers page (not replaceable).
    //
    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_DEFAULT;
    psp.hInstance   = instance;
    psp.pszTemplate = MAKEINTRESOURCE(DLG_MOUSE_POINTER);
    psp.pfnDlgProc  = MousePtrDlg;
    psp.lParam      = 0;

    _AddMousePropSheetPage(CreatePropertySheetPage(&psp), (LPARAM)&psh);

    //
    //  Add the Motion page, giving the extensions a chance to replace it.
    //
    if (!hpsxa ||
        !SHReplaceFromPropSheetExtArray( hpsxa,
                                         CPLPAGE_MOUSE_PTRMOTION,
                                         _AddMousePropSheetPage,
                                         (LPARAM)&psh ))
    {
        psp.dwSize      = sizeof(psp);
        psp.dwFlags     = PSP_DEFAULT;
        psp.hInstance   = instance;
        psp.pszTemplate = MAKEINTRESOURCE(DLG_MOUSE_MOTION);
        psp.pfnDlgProc  = MouseMovDlg;
        psp.lParam      = 0;

        _AddMousePropSheetPage(CreatePropertySheetPage(&psp), (LPARAM)&psh);
    }

/*
/*  Not added due to lack of time.  ewatson (05/05/2000)
    //
    //  Add the Activities page, giving the extensions a chance to replace it.
    //
    if (!hpsxa ||
        !SHReplaceFromPropSheetExtArray( hpsxa,
                                         CPLPAGE_MOUSE_ACTIVITIES,
                                         _AddMousePropSheetPage,
                                         (LPARAM)&psh ))
    {
        psp.dwSize      = sizeof(psp);
        psp.dwFlags     = PSP_DEFAULT;
        psp.hInstance   = instance;
        psp.pszTemplate = MAKEINTRESOURCE(DLG_MOUSE_ACTIVITIES);
        psp.pfnDlgProc  = MouseActivitiesDlg;
        psp.lParam      = 0;

        _AddMousePropSheetPage(CreatePropertySheetPage(&psp), (LPARAM)&psh);
    }
*/

    //
    //  Add the Wheel page (if mouse with wheel is present)
    //  This page is replace-able.
    //
    if (!hpsxa ||
        !SHReplaceFromPropSheetExtArray( hpsxa,
                                         CPLPAGE_MOUSE_WHEEL,
                                         _AddMousePropSheetPage,
                                         (LPARAM)&psh ))
    {
      //
      //If a Wheel mouse is present on the system, then display the Wheel property sheet page
      //
      if  (GetSystemMetrics(SM_MOUSEWHEELPRESENT))
        {
        psp.dwSize      = sizeof(psp);
        psp.dwFlags     = PSP_DEFAULT;
        psp.hInstance   = instance;
        psp.pszTemplate = MAKEINTRESOURCE(DLG_MOUSE_WHEEL);
        psp.pfnDlgProc  = MouseWheelDlg;
        psp.lParam      = 0;

        _AddMousePropSheetPage(CreatePropertySheetPage(&psp), (LPARAM)&psh);
        }
    }


    _AddMousePropSheetPage(CreateHardwarePage(&c_hpiMouse), (LPARAM)&psh);
     



    //
    //  Add any extra pages that the extensions want in there.
    //
    if (hpsxa)
    {
        UINT cutoff = psh.nPages;
        UINT added = SHAddFromPropSheetExtArray( hpsxa,
                                                 _AddMousePropSheetPage,
                                                 (LPARAM)&psh );

        if (psh.nStartPage >= cutoff)
        {
            psh.nStartPage += added;
        }
    }

    //
    //  Invoke the Property Sheets.
    //
    switch (PropertySheet(&psh))
    {
        case ( ID_PSRESTARTWINDOWS ) :
        {
            Result = APPLET_RESTART;
            break;
        }
        case ( ID_PSREBOOTSYSTEM ) :
        {
            Result = APPLET_REBOOT;
            break;
        }
        default :
        {
            Result = 0;
            break;
        }
    }

    //
    //  Free any loaded extensions.
    //
    if (hpsxa)
    {
        SHDestroyPropSheetExtArray(hpsxa);
    }

    return (Result);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetClInt  to determine command line argument.
//
////////////////////////////////////////////////////////////////////////////
static int
GetClInt( const TCHAR *p )
{
    BOOL neg = FALSE;
    int v = 0;

    while( *p == TEXT(' ') )
        p++;                        // skip spaces

    if( *p == TEXT('-') )                 // is it negative?
    {
        neg = TRUE;                     // yes, remember that
        p++;                            // skip '-' char
    }

    // parse the absolute portion
    while( ( *p >= TEXT('0') ) && ( *p <= TEXT('9') ) )     // digits only
        v = v * 10 + *p++ - TEXT('0');    // accumulate the value

    return ( neg? -v : v );         // return the result
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\main\mousebut.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    mousebut.c

Abstract:

    This module contains the routines for the Mouse Buttons Property Sheet
    page.

Revision History:

--*/



//
//  Include Files.
//

#include "main.h"
#include "util.h"
#include "rc.h"
#include "mousectl.h"
#include <regstr.h>
#include <winerror.h>        // needed for ERROR_SUCCESS value
#include "mousehlp.h"



//
//  Constant Declarations.
//
const TCHAR szYes[]          = TEXT("yes");
const TCHAR szNo[]           = TEXT("no");
const TCHAR szDblClkSpeed[]  = TEXT("DoubleClickSpeed");
const TCHAR szRegStr_Mouse[] = REGSTR_PATH_MOUSE;

#define SAFE_DESTROYICON(hicon)   if (hicon) { DestroyIcon(hicon); hicon=NULL; }


//
//  SwapMouseButtons takes:
//      TRUE to make it a right mouse
//      FALSE to make it a left mouse
//
#define RIGHT       TRUE
#define LEFT        FALSE


//Identifiers used for setting DoubleClick speed
#define DBLCLICK_MIN    200      // milliseconds
#define DBLCLICK_MAX    900
#define DBLCLICK_DEFAULT_TIME 500 

#define DBLCLICK_TIME_SLIDER_MIN  0   
#define DBLCLICK_TIME_SLIDER_MAX  10   


#define DBLCLICK_RANGE  (DBLCLICK_MAX - DBLCLICK_MIN)
#define DBLCLICK_SLIDER_RANGE ( CLICKLOCK_TIME_SLIDER_MAX - CLICKLOCK_TIME_SLIDER_MIN)


#define DBLCLICK_TICKMULT  (DBLCLICK_RANGE / DBLCLICK_SLIDER_RANGE)

#define DBLCLICK_TICKS_TO_TIME(ticks)  (SHORT) (((DBLCLICK_TIME_SLIDER_MAX - ticks) * DBLCLICK_TICKMULT) + DBLCLICK_MIN)
#define DBLCLICK_TIME_TO_TICKS(time)   (SHORT) (DBLCLICK_TIME_SLIDER_MAX - ((time - DBLCLICK_MIN) / DBLCLICK_TICKMULT))




#define CLICKLOCK_TIME_SLIDER_MIN  1    //Minimum ClickLock Time setting for slider control
#define CLICKLOCK_TIME_SLIDER_MAX  11   //Maximum ClickLock Time setting for slider control
#define CLICKLOCK_TIME_FACTOR      200  //Multiplier for translating clicklock time slider units to milliseconds
#define TICKS_PER_CLICK       1

//Size assumed as the default size for icons, used for scaling the icons
#define		ICON_SIZEX								32									
#define		ICON_SIZEY								32
//The font size used for scaling
#define		SMALLFONTSIZE					96										
#define CLAPPER_CLASS   TEXT("Clapper")

//
// From shell\inc\shsemip.h
//
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))



//
//  Typedef Declarations.
//

typedef struct tag_MouseGenStr
{
    BOOL bSwap;
    BOOL bOrigSwap;

    short ClickSpeed;
    short OrigDblClkSpeed;

    HWND hWndDblClkScroll;
    HWND hDlg;                    

    HWND hWndDblClk_TestArea;

    RECT DblClkRect;
    
    HICON hIconDblClick[2];

#ifdef SHELL_SINGLE_CLICK
    BOOL bShellSingleClick,
         bOrigShellSingleClick ;

    HICON hIconSglClick,
          hIconDblClick ;
#endif //SHELL_SINGLE_CLICK

    BOOL bClickLock;
    BOOL bOrigClickLock;

    DWORD dwClickLockTime;
    DWORD dwOrigClickLockTime;

} MOUSEBUTSTR, *PMOUSEBUTSTR, *LPMOUSEBUTSTR;

//
//  Context Help Ids.
//

const DWORD aMouseButHelpIds[] =
{
    IDC_GROUPBOX_1,             IDH_COMM_GROUPBOX,
    IDBTN_BUTTONSWAP,           IDH_MOUSE_SWITCH,
    MOUSE_MOUSEBMP,             IDH_MOUSE_SWITCH_PIC,
    IDC_GROUPBOX_2,             IDH_COMM_GROUPBOX,
    
    IDC_GROUPBOX_4,             IDH_COMM_GROUPBOX,
    MOUSE_CLICKSCROLL,          IDH_MOUSE_DOUBLECLICK,
    IDC_DBLCLICK_TEXT,          IDH_COMM_GROUPBOX,
    IDC_TEST_DOUBLE_CLICK,      IDH_MOUSE_DCLICK_TEST_BOX,
    MOUSE_DBLCLK_TEST_AREA,     IDH_MOUSE_DCLICK_TEST_BOX,
    
    IDC_GROUPBOX_6,             IDH_COMM_GROUPBOX,
    IDCK_CLICKLOCK,             IDH_MOUSE_CLKLCK_CHKBOX,
    IDBTN_CLICKLOCK_SETTINGS,   IDH_MOUSE_CLKLCK_SETTINGS_BTN,
    IDC_CLICKLOCK_TEXT,         IDH_COMM_GROUPBOX,
    
    IDC_CLICKLOCK_SETTINGS_TXT,         IDH_COMM_GROUPBOX,
    IDT_CLICKLOCK_TIME_SETTINGS,        IDH_MOUSE_CLKLCK_DIALOG,
    IDC_CLICKLOCK_SETTINGS_LEFT_TXT,    IDH_MOUSE_CLKLCK_DIALOG,
    IDC_CLICKLOCK_SETTINGS_RIGHT_TXT,   IDH_MOUSE_CLKLCK_DIALOG,

#ifdef SHELL_SINGLE_CLICK    
    MOUSE_SGLCLICK,             IDH_MOUSE_SGLCLICK,
    MOUSE_DBLCLICK,             IDH_MOUSE_DBLCLICK,
#endif // SHELL_SINGLE_CLICK

    0,0 
};


//
//  helper function prototypes
//
void ShellClick_UpdateUI( HWND hDlg, PMOUSEBUTSTR pMstr) ;
void ShellClick_Refresh( PMOUSEBUTSTR pMstr ) ;


//
//  Debug Info.
//

#ifdef DEBUG

#define REG_INTEGER  1000

int fTraceRegAccess = 0;

void RegDetails(
    int     iWrite,
    HKEY    hk,
    LPCTSTR lpszSubKey,
    LPCTSTR lpszValueName,
    DWORD   dwType,
    LPTSTR  lpszString,
    int     iValue)
{
    TCHAR Buff[256];
    TCHAR *lpszReadWrite[] = { TEXT("DESK.CPL:Read"), TEXT("DESK.CPL:Write") };

    if (!fTraceRegAccess)
    {
        return;
    }

    switch (dwType)
    {
        case ( REG_SZ ) :
        {
            wsprintf( Buff,
                      TEXT("%s String:hk=%#08lx, %s:%s=%s\n\r"),
                      lpszReadWrite[iWrite],
                      hk,
                      lpszSubKey,
                      lpszValueName,
                      lpszString );
            break;
        }
        case ( REG_INTEGER ) :
        {
            wsprintf( Buff,
                      TEXT("%s int:hk=%#08lx, %s:%s=%d\n\r"),
                      lpszReadWrite[iWrite],
                      hk,
                      lpszSubKey,
                      lpszValueName,
                      iValue );
            break;
        }
        case ( REG_BINARY ) :
        {
            wsprintf( Buff,
                      TEXT("%s Binary:hk=%#08lx, %s:%s=%#0lx;DataSize:%d\r\n"),
                      lpszReadWrite[iWrite],
                      hk,
                      lpszSubKey,
                      lpszValueName,
                      lpszString,
                      iValue );
            break;
        }
    }
    OutputDebugString(Buff);
}

#endif  // DEBUG





////////////////////////////////////////////////////////////////////////////
//
//  GetIntFromSubKey
//
//  hKey is the handle to the subkey (already pointing to the proper
//  location.
//
////////////////////////////////////////////////////////////////////////////

int GetIntFromSubkey(
    HKEY hKey,
    LPCTSTR lpszValueName,
    int iDefault)
{
    TCHAR szValue[20];
    DWORD dwSizeofValueBuff = sizeof(szValue);
    DWORD dwType;
    int iRetValue = iDefault;

    if ((RegQueryValueEx( hKey,
                          (LPTSTR)lpszValueName,
                          NULL,
                          &dwType,
                          (LPBYTE)szValue,
                          &dwSizeofValueBuff ) == ERROR_SUCCESS) &&
        (dwSizeofValueBuff))
    {
        //
        //  BOGUS: This handles only the string type entries now!
        //
        if (dwType == REG_SZ)
        {
            iRetValue = (int)StrToLong(szValue);
        }
#ifdef DEBUG
        else
        {
            OutputDebugString(TEXT("String type expected from Registry\n\r"));
        }
#endif
    }

#ifdef DEBUG
    RegDetails(0, hKey, TEXT(""), lpszValueName, REG_INTEGER, NULL, iRetValue);
#endif

    return (iRetValue);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetIntFromReg
//
//  Opens the given subkey and gets the int value.
//
////////////////////////////////////////////////////////////////////////////

int GetIntFromReg(
    HKEY hKey,
    LPCTSTR lpszSubkey,
    LPCTSTR lpszNameValue,
    int iDefault)
{
    HKEY hk;
    int iRetValue = iDefault;

    //
    //  See if the key is present.
    //
    if (RegOpenKey(hKey, lpszSubkey, &hk) == ERROR_SUCCESS)
    {
        iRetValue = GetIntFromSubkey(hk, lpszNameValue, iDefault);
        RegCloseKey(hk);
    }

    return (iRetValue);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetStringFromReg
//
//  Opens the given subkey and gets the string value.
//
////////////////////////////////////////////////////////////////////////////

BOOL GetStringFromReg(
    HKEY hKey,
    LPCTSTR lpszSubkey,
    LPCTSTR lpszValueName,
    LPCTSTR lpszDefault,
    LPTSTR lpszValue,
    DWORD dwSizeofValueBuff)
{
    HKEY hk;
    DWORD dwType;
    BOOL fSuccess = FALSE;

    //
    //  See if the key is present.
    //
    if (RegOpenKey(hKey, lpszSubkey, &hk) == ERROR_SUCCESS)
    {
        if ((RegQueryValueEx( hk,
                              (LPTSTR)lpszValueName,
                              NULL,
                              &dwType,
                              (LPBYTE)lpszValue,
                              &dwSizeofValueBuff ) == ERROR_SUCCESS) &&
            (dwSizeofValueBuff))
        {
            //
            //  BOGUS: This handles only the string type entries now!
            //
#ifdef DEBUG
            if (dwType != REG_SZ)
            {
                OutputDebugString(TEXT("String type expected from Registry\n\r"));
            }
            else
#endif
            fSuccess = TRUE;
        }
        RegCloseKey(hk);
    }

    //
    //  If failure, use the default string.
    //
    if (!fSuccess)
    {
        lstrcpy(lpszValue, lpszDefault);
    }

#ifdef DEBUG
    RegDetails(0, hKey, lpszSubkey, lpszValueName, REG_SZ, lpszValue, 0);
#endif

    return (fSuccess);
}


////////////////////////////////////////////////////////////////////////////
//
//  UpdateRegistry
//
//  This updates a given value of any data type at a given location in
//  the registry.
//
//  The value name is passed in as an Id to a string in USER's String
//  table.
//
////////////////////////////////////////////////////////////////////////////

BOOL UpdateRegistry(
    HKEY hKey,
    LPCTSTR lpszSubkey,
    LPCTSTR lpszValueName,
    DWORD dwDataType,
    LPVOID lpvData,
    DWORD dwDataSize)
{
    HKEY hk;

    if (RegCreateKey(hKey, lpszSubkey, &hk) == ERROR_SUCCESS)
    {
        RegSetValueEx( hk,
                       (LPTSTR)lpszValueName,
                       0,
                       dwDataType,
                       (LPBYTE)lpvData,
                       dwDataSize );
#ifdef DEBUG
        RegDetails(1, hKey, lpszSubkey, lpszValueName, dwDataType, lpvData, (int)dwDataSize);
#endif

        RegCloseKey(hk);
        return (TRUE);
    }

    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CenterDlgOverParent
//
////////////////////////////////////////////////////////////////////////////
void WINAPI CenterDlgOverParent (HWND hWnd)
{
    HWND hwndOwner; 
    RECT rc, rcDlg, rcOwner; 
  
    if ((hwndOwner = GetParent(hWnd)) == NULL) 
    {      
         return;
    }

    GetWindowRect(hwndOwner, &rcOwner); 
    GetWindowRect(hWnd, &rcDlg); 
    CopyRect(&rc, &rcOwner); 
 
    // Offset the owner and dialog box rectangles so that 
    // right and bottom values represent the width and 
    // height, and then offset the owner again to discard 
    // space taken up by the dialog box. 
 
    OffsetRect(&rcDlg, -rcDlg.left, -rcDlg.top); 
    OffsetRect(&rc, -rc.left, -rc.top); 
    OffsetRect(&rc, -rcDlg.right, -rcDlg.bottom); 
 
    //The new position is the sum of half the remaining 
    //space and the owner's original position. 
    SetWindowPos(hWnd, 
                 HWND_TOP, 
                 rcOwner.left + (rc.right / 2), 
                 rcOwner.top + (rc.bottom / 2), 
                 0, 0,          // ignores size arguments 
                 SWP_NOSIZE);

	  // now let's verify left side is not off screen
		GetWindowRect( hWnd, &rc);

		if ((rc.left < 0) || (rc.top < 0))
		{
			if (rc.left < 0)
				rc.left = 0;
			if (rc.top < 0)
				rc.top = 0;

		    SetWindowPos(hWnd, 
		           HWND_TOP, 
		           rc.left, 
		           rc.top,
		           0, 0,          // ignores size arguments 
		           SWP_NOSIZE);

						
		}	
}



////////////////////////////////////////////////////////////////////////////
//
//  ShowButtonState
//
//  Swaps the menu and selection bitmaps.
//
////////////////////////////////////////////////////////////////////////////

void ShowButtonState(
    PMOUSEBUTSTR pMstr)
{
    HWND hDlg;

    Assert(pMstr);

    hDlg = pMstr->hDlg;

    MouseControlSetSwap(GetDlgItem(hDlg, MOUSE_MOUSEBMP), pMstr->bSwap);

    CheckDlgButton(hDlg,IDBTN_BUTTONSWAP, pMstr->bSwap);

#ifdef SHELL_SINGLE_CLICK
//This was removed
    CheckDlgButton(hDlg, MOUSE_SGLCLICK, pMstr->bShellSingleClick);
    CheckDlgButton(hDlg, MOUSE_DBLCLICK, !pMstr->bShellSingleClick);
#endif  //SHELL_SINGLE_CLICK
}


////////////////////////////////////////////////////////////////////////////
//
//  DestroyMouseButDlg
//
////////////////////////////////////////////////////////////////////////////

void DestroyMouseButDlg(
    PMOUSEBUTSTR pMstr)
{
    if (pMstr)
    {
#ifdef SHELL_SINGLE_CLICK
        SAFE_DESTROYICON( pMstr->hIconSglClick ) ;
        SAFE_DESTROYICON( pMstr->hIconDblClick ) ;
#endif 

        SAFE_DESTROYICON( pMstr->hIconDblClick[0]); 
        SAFE_DESTROYICON( pMstr->hIconDblClick[1]);


        SetWindowLongPtr(pMstr->hDlg, DWLP_USER, 0);
        LocalFree((HGLOBAL)pMstr);
    }
}




////////////////////////////////////////////////////////////////////////////
//
//  ClickLockSettingsDlg
//
////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK ClickLockSettingsDlg (
   HWND   hDlg,                        // dialog window handle
   UINT   msg,                         // message identifier
   WPARAM wParam,                      // primary parameter
   LPARAM lParam)                      // secondary parameter
{
static DWORD* pdwClickLockTime;
static HICON hIcon = 0;

   switch (msg)
   {
   case WM_INITDIALOG:
     {
      
      WPARAM wSliderSetting;      //ClickLock time in terms of slider units

       HourGlass (TRUE);

       Assert(lParam);
      pdwClickLockTime = (DWORD*) lParam;   //Save Original value for return


      //Convert into slider units from milliseconds. Note that the slider
      //values get larger as the ClickLock time gets larger.
      wSliderSetting = (*pdwClickLockTime) / CLICKLOCK_TIME_FACTOR;

      //Make sure setting is within valid range for ClickLock slider
      wSliderSetting = max(wSliderSetting, CLICKLOCK_TIME_SLIDER_MIN);
      wSliderSetting = min(wSliderSetting, CLICKLOCK_TIME_SLIDER_MAX);

      SendDlgItemMessage (hDlg, IDT_CLICKLOCK_TIME_SETTINGS, TBM_SETRANGE,
        TRUE, MAKELONG(CLICKLOCK_TIME_SLIDER_MIN, CLICKLOCK_TIME_SLIDER_MAX));
      SendDlgItemMessage (hDlg, IDT_CLICKLOCK_TIME_SETTINGS, TBM_SETPAGESIZE,
                         0, TICKS_PER_CLICK); // click movement
      SendDlgItemMessage (hDlg, IDT_CLICKLOCK_TIME_SETTINGS, TBM_SETPOS,
                         TRUE, (LPARAM)(LONG)wSliderSetting);

      //icon for the dialog
      //  (saved in a static variable, and released on WM_DESTROY)
      hIcon = LoadIcon((HINSTANCE)GetWindowLongPtr( hDlg, GWLP_HINSTANCE ),
                                  MAKEINTRESOURCE(ICON_CLICKLOCK));
      SendMessage( GetDlgItem (hDlg, MOUSE_CLICKICON), 
                   STM_SETICON, (WPARAM)hIcon, 0L );

         
      CenterDlgOverParent(hDlg);    //Center dialog here so it doesn't jump around on screen
      HourGlass(FALSE);
      return(TRUE);
     }

   case WM_HSCROLL:
     {
      if (LOWORD(wParam) == TB_ENDTRACK)
        { 
        DWORD dwClTime;
        int  wSliderSetting = (int) SendMessage (GetDlgItem (hDlg, IDT_CLICKLOCK_TIME_SETTINGS),
                                                      TBM_GETPOS, 0, 0L);

        dwClTime = wSliderSetting * CLICKLOCK_TIME_FACTOR;

        SystemParametersInfo(SPI_SETMOUSECLICKLOCKTIME, 
                              0,
                              (PVOID) (LOWORD(dwClTime)), 
                              0);
        }
     }
     break;


   case WM_HELP:    //F1
      {
            WinHelp( ((LPHELPINFO)lParam)->hItemHandle,
                     HELP_FILE,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aMouseButHelpIds );
      }
      break;

   case WM_CONTEXTMENU:                // Display simple "What's This?" menu
      {  
            WinHelp( (HWND) wParam,
                     HELP_FILE,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aMouseButHelpIds );
      }
      break;

   case WM_DESTROY:
      SAFE_DESTROYICON(hIcon);
      break;


   case WM_COMMAND:
      switch(LOWORD(wParam))
      {
 
      case IDOK:                       // Flag to save setting
        {
          DWORD dwClickLockTime;
          int  wSliderSetting = (int) SendMessage (GetDlgItem (hDlg, IDT_CLICKLOCK_TIME_SETTINGS),
                                                      TBM_GETPOS, 0, 0L);

          //verify range
          wSliderSetting = max(wSliderSetting, CLICKLOCK_TIME_SLIDER_MIN);
          wSliderSetting = min(wSliderSetting, CLICKLOCK_TIME_SLIDER_MAX);
        
          // Convert to milliseconds from slider units.
          dwClickLockTime = wSliderSetting * CLICKLOCK_TIME_FACTOR;

          *pdwClickLockTime = dwClickLockTime;

          EndDialog(hDlg, IDOK); 
          break;  
        }
        
      case IDCANCEL:                   // revert to previous setting         
         EndDialog(hDlg, IDCANCEL);
         break;

      default:
         return(FALSE);
      }
      return (TRUE);
      
   default:
     return(FALSE);    
   }
   return (TRUE);                   
}


////////////////////////////////////////////////////////////////////////////
//
//  InitMouseButDlg
//
////////////////////////////////////////////////////////////////////////////

BOOL InitMouseButDlg(
    HWND hDlg)
{
    SHELLSTATE   shellstate = {0} ;
    PMOUSEBUTSTR pMstr = NULL;
    HINSTANCE    hInstDlg = (HINSTANCE)GetWindowLongPtr( hDlg, GWLP_HINSTANCE ) ;
    HWND hwndClickLockSettingsButton = GetDlgItem(hDlg, IDBTN_CLICKLOCK_SETTINGS);
    DWORD dwClickLockSetting = 0;

    HWND hwndDoubleClickTestArea = NULL;

    pMstr = (PMOUSEBUTSTR)LocalAlloc(LPTR , sizeof(MOUSEBUTSTR));

    if (pMstr == NULL)
    {
        return (TRUE);
    }

    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pMstr);

    pMstr->hDlg = hDlg;
   
    //
    //Set up the double click test area 
    //
    pMstr->hWndDblClk_TestArea = GetDlgItem(hDlg, MOUSE_DBLCLK_TEST_AREA);
    GetWindowRect(pMstr->hWndDblClk_TestArea, &pMstr->DblClkRect);  
    MapWindowPoints(NULL, hDlg, (LPPOINT) &pMstr->DblClkRect, 2);                 

    pMstr->hIconDblClick[0] = LoadIcon(hInstDlg, MAKEINTRESOURCE(ICON_FOLDER_CLOSED));
    pMstr->hIconDblClick[1] = LoadIcon(hInstDlg, MAKEINTRESOURCE(ICON_FOLDER_OPEN));
 
    SendMessage(pMstr->hWndDblClk_TestArea, STM_SETICON, (WPARAM)pMstr->hIconDblClick[0], 0L);

    //
    //  Set (and get), then restore the state of the mouse buttons.
    //
    (pMstr->bOrigSwap) = (pMstr->bSwap) = SwapMouseButton(TRUE);

    SwapMouseButton(pMstr->bOrigSwap);
    
#ifdef SHELL_SINGLE_CLICK
    //
    //  Get shell single-click behavior:
    //
    SHGetSetSettings( &shellstate, SSF_DOUBLECLICKINWEBVIEW | SSF_WIN95CLASSIC, FALSE /*get*/ ) ;
    pMstr->bShellSingleClick =
    pMstr->bOrigShellSingleClick =  shellstate.fWin95Classic ? FALSE :
                                    shellstate.fDoubleClickInWebView ? FALSE :
                                    TRUE ;
    pMstr->hIconSglClick = LoadIcon( hInstDlg, MAKEINTRESOURCE( IDI_SGLCLICK ) ) ;
    pMstr->hIconDblClick = LoadIcon( hInstDlg, MAKEINTRESOURCE( IDI_DBLCLICK ) ) ;
    ShellClick_UpdateUI( hDlg, pMstr ) ;
#endif //SHELL_SINGLE_CLICK

    //
    //  Initialize check/radio button state
    //
    ShowButtonState(pMstr);

    pMstr->OrigDblClkSpeed =
    pMstr->ClickSpeed = (SHORT) GetIntFromReg( HKEY_CURRENT_USER,
                                       szRegStr_Mouse,
                                       szDblClkSpeed,
                                       DBLCLICK_DEFAULT_TIME );

    pMstr->hWndDblClkScroll = GetDlgItem(hDlg, MOUSE_CLICKSCROLL);

    SendMessage( pMstr->hWndDblClkScroll,
                 TBM_SETRANGE,
                 0,
                 MAKELONG(DBLCLICK_TIME_SLIDER_MIN, DBLCLICK_TIME_SLIDER_MAX) );
   
    SendMessage( pMstr->hWndDblClkScroll,
                 TBM_SETPOS,
                 TRUE,
                 (LONG) (DBLCLICK_TIME_TO_TICKS(pMstr->ClickSpeed)) );
   


    SetDoubleClickTime(pMstr->ClickSpeed);


    //
    //Get clicklock settings and set the checkbox
    //
    SystemParametersInfo(SPI_GETMOUSECLICKLOCK, 0, (PVOID)&dwClickLockSetting, 0);
    pMstr->bOrigClickLock = pMstr->bClickLock  = (dwClickLockSetting) ? TRUE : FALSE;
    
    if ( pMstr->bClickLock )
      {
       CheckDlgButton (hDlg, IDCK_CLICKLOCK, BST_CHECKED);  
       EnableWindow(hwndClickLockSettingsButton, TRUE);       
      }
    else
      {
       CheckDlgButton (hDlg, IDCK_CLICKLOCK, BST_UNCHECKED);  
       EnableWindow(hwndClickLockSettingsButton, FALSE);             
      }

    // click lock speed    
    {
    DWORD dwClTime = 0;
    SystemParametersInfo(SPI_GETMOUSECLICKLOCKTIME, 0, (PVOID)&dwClTime, 0);

    dwClTime = max(dwClTime, CLICKLOCK_TIME_SLIDER_MIN * CLICKLOCK_TIME_FACTOR);
    dwClTime = min(dwClTime, CLICKLOCK_TIME_SLIDER_MAX * CLICKLOCK_TIME_FACTOR);

    pMstr->dwOrigClickLockTime = pMstr->dwClickLockTime  = dwClTime;
    }
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  MouseButDlg
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK MouseButDlg(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{

    static int iTestIcon = 0;   //index into hIconDblClick array

    PMOUSEBUTSTR pMstr = (PMOUSEBUTSTR)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (message)
    {
        case ( WM_INITDIALOG ) :
        {
            iTestIcon = 0;
            return (InitMouseButDlg(hDlg));
        }
        case ( WM_DESTROY ) :
        {
            DestroyMouseButDlg(pMstr);
            break;
        }
        case ( WM_HSCROLL ) :
        {
            if ((HWND)lParam == pMstr->hWndDblClkScroll)
            {
                short temp = DBLCLICK_TICKS_TO_TIME((short)SendMessage( (HWND)lParam,
                                                 TBM_GETPOS,
                                                 0,
                                                 0L ));

                if (temp != pMstr->ClickSpeed)
                {
                    pMstr->ClickSpeed = temp;

                    SetDoubleClickTime(pMstr->ClickSpeed);

                    SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                }
            }
            break;
        }
        case ( WM_RBUTTONDBLCLK ) :
        case ( WM_LBUTTONDBLCLK ) :
        {
            POINT point = { (int)MAKEPOINTS(lParam).x,
                            (int)MAKEPOINTS(lParam).y };

            if (PtInRect(&pMstr->DblClkRect, point))
            {
            iTestIcon ^= 1;
            SendMessage(pMstr->hWndDblClk_TestArea, STM_SETICON, 
                         (WPARAM)pMstr->hIconDblClick[iTestIcon], 0L);
            }
            break;
        }

        case ( WM_COMMAND ) :
        {
            switch (LOWORD(wParam))
            {
                case ( IDCK_CLICKLOCK ) :
                {
                 HWND hwndClickLockSettingsButton = GetDlgItem(hDlg, IDBTN_CLICKLOCK_SETTINGS);

                 SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                  
                 pMstr->bClickLock = !(pMstr->bClickLock);
                  
                 // update control(s) appearance
                 CheckDlgButton (hDlg, IDCK_CLICKLOCK,      ( pMstr->bClickLock ) ? BST_CHECKED : BST_UNCHECKED);
                 EnableWindow(hwndClickLockSettingsButton,  ( pMstr->bClickLock ) ? TRUE        : FALSE);       

                 SystemParametersInfo(SPI_SETMOUSECLICKLOCK,     
                                      0,
                                      IntToPtr(pMstr->bClickLock),     
                                      0);

                 break;
                }

                case ( IDBTN_CLICKLOCK_SETTINGS ) :
                {
                  LPARAM lRet;
                  UINT code = HIWORD(wParam);
                  
                  DWORD dwTempClickLockTime =  pMstr->dwClickLockTime;
                  
                  if (code == BN_CLICKED)
                    {                 
                    lRet = DialogBoxParam ((HINSTANCE)GetWindowLongPtr( hDlg, GWLP_HINSTANCE ),
                                            MAKEINTRESOURCE(IDD_CLICKLOCK_SETTINGS_DLG ),
                                            GetParent (hDlg),
                                            ClickLockSettingsDlg, 
                                            (LPARAM) &dwTempClickLockTime);
                    if (lRet == IDOK &&
                        pMstr->dwClickLockTime != dwTempClickLockTime)
                      {
                      pMstr->dwClickLockTime = dwTempClickLockTime;
                      SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                      }
                    else if (lRet == IDCANCEL)
                      {
                      //set back
                      DWORD dwClTime = pMstr->dwClickLockTime;
                      SystemParametersInfo(SPI_SETMOUSECLICKLOCKTIME, 
                                            0,
                                            IntToPtr(LOWORD(dwClTime)), 
                                            0);
                      }
                                      
                    }

                  break;
                }


                case ( IDBTN_BUTTONSWAP) :
                {                   
                    pMstr->bSwap = !pMstr->bSwap;                     
                    SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                    SystemParametersInfo( SPI_SETMOUSEBUTTONSWAP,
                          pMstr->bSwap,
                          NULL,
                          0);
                    ShowButtonState(pMstr);                   
                }



#ifdef SHELL_SINGLE_CLICK
                case ( MOUSE_SGLCLICK ) :
                case ( MOUSE_DBLCLICK ) :
                {
                    if( pMstr->bShellSingleClick != (MOUSE_SGLCLICK == LOWORD(wParam)) )
                    {
                        pMstr->bShellSingleClick = (MOUSE_SGLCLICK == LOWORD(wParam)) ;
                        ShellClick_UpdateUI( hDlg, pMstr ) ;
                        SendMessage( GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L ) ;
                    }
                    break ;
                }
#endif // SHELL_SINGLE_CLICK


            }
            break;
        }
        case ( WM_NOTIFY ) :
        {
            switch (((NMHDR *)lParam)->code)
            {
                case ( PSN_APPLY ) :
                {
                    HourGlass(TRUE);


                    //
                    // Apply Button Swap setting.
                    //
                    if (pMstr->bSwap != pMstr->bOrigSwap)
                    {
                        SystemParametersInfo( SPI_SETMOUSEBUTTONSWAP,
                                              pMstr->bSwap,
                                              NULL,
                                              SPIF_UPDATEINIFILE |
                                                SPIF_SENDWININICHANGE );
                        pMstr->bOrigSwap = pMstr->bSwap;
                    }
          
                    // 
                    // Apply DoubleClickTime setting.
                    //
                    if (pMstr->ClickSpeed != pMstr->OrigDblClkSpeed)
                    {
                        SystemParametersInfo( SPI_SETDOUBLECLICKTIME,
                                              pMstr->ClickSpeed,
                                              NULL,
                                              SPIF_UPDATEINIFILE |
                                                SPIF_SENDWININICHANGE );
                        pMstr->OrigDblClkSpeed = pMstr->ClickSpeed;
                    }


                    // 
                    // Apply ClickLock setting.
                    //
                    if (pMstr->bClickLock != pMstr->bOrigClickLock)
                    {
                        SystemParametersInfo(SPI_SETMOUSECLICKLOCK,     
                                              0,
                                              IntToPtr(pMstr->bClickLock),     
                                              SPIF_UPDATEINIFILE | 
                                                SPIF_SENDWININICHANGE);   
                        pMstr->bOrigClickLock = pMstr->bClickLock;
                    }

                    // 
                    // Apply ClickLockTime setting.
                    //                    
                    if (pMstr->dwClickLockTime != pMstr->dwOrigClickLockTime)
                    {    
                        SystemParametersInfo(SPI_SETMOUSECLICKLOCKTIME, 
                                              0,
                                              (PVOID) (LOWORD(pMstr->dwClickLockTime)), 
                                              SPIF_UPDATEINIFILE |
                                                SPIF_SENDWININICHANGE );

                        pMstr->dwOrigClickLockTime = pMstr->dwClickLockTime;
                    }



#ifdef SHELL_SINGLE_CLICK
                    if( pMstr->bOrigShellSingleClick != pMstr->bShellSingleClick )
                    {
                        SHELLSTATE shellstate = {0} ;
                        ULONG      dwFlags = SSF_DOUBLECLICKINWEBVIEW ;

                        shellstate.fWin95Classic =
                        shellstate.fDoubleClickInWebView = !pMstr->bShellSingleClick ;

                        // update the WIN95CLASSIC member only if we've chosen single-click.
                        if( pMstr->bShellSingleClick )
                            dwFlags |= SSF_WIN95CLASSIC ;

                        SHGetSetSettings( &shellstate, dwFlags, TRUE ) ;
                        ShellClick_Refresh( pMstr ) ;

                        pMstr->bOrigShellSingleClick = pMstr->bShellSingleClick ;
                    }
#endif //SHELL_SINGLE_CLICK

                    HourGlass(FALSE);
                    break;
                }
                case ( PSN_RESET ) :
                {
                  //
                  // Reset Button Swap setting.
                  //
                  if (pMstr->bSwap != pMstr->bOrigSwap)
                  {
                      SystemParametersInfo( SPI_SETMOUSEBUTTONSWAP,
                                            pMstr->bOrigSwap,
                                            NULL,
                                            0);
                  }
        
                  // 
                  // Reset DoubleClickTime setting.
                  //
                  if (pMstr->ClickSpeed != pMstr->OrigDblClkSpeed)
                  {
                      SystemParametersInfo( SPI_SETDOUBLECLICKTIME,
                                            pMstr->OrigDblClkSpeed,
                                            NULL,
                                            0);
                  }


                  // 
                  // Reset ClickLock setting.
                  //
                  if (pMstr->bClickLock != pMstr->bOrigClickLock)
                  {
                      SystemParametersInfo(SPI_SETMOUSECLICKLOCK,     
                                            0,
                                            IntToPtr(pMstr->bOrigClickLock),     
                                            0);
                  }

                  // 
                  // Reset ClickLockTime setting.
                  //                    
                  if (pMstr->dwClickLockTime != pMstr->dwOrigClickLockTime)
                  {    
                      SystemParametersInfo(SPI_SETMOUSECLICKLOCKTIME, 
                                            0,
                                            (PVOID) (LOWORD(pMstr->dwOrigClickLockTime)), 
                                            0);
                  }



#ifdef SHELL_SINGLE_CLICK
                  if( pMstr->bOrigShellSingleClick != pMstr->bShellSingleClick )
                  {
                      SHELLSTATE shellstate = {0} ;
                      ULONG      dwFlags = SSF_DOUBLECLICKINWEBVIEW ;

                      shellstate.fWin95Classic =
                      shellstate.fDoubleClickInWebView = !pMstr->bOrigShellSingleClick ;

                      // update the WIN95CLASSIC member only if we've chosen single-click.
                      if( pMstr->bShellSingleClick )
                          dwFlags |= SSF_WIN95CLASSIC ;

                      SHGetSetSettings( &shellstate, dwFlags, TRUE ) ;
                      ShellClick_Refresh( pMstr ) ;

                      pMstr->bShellSingleClick  = pMstr->bOrigShellSingleClick ;
                  }
#endif //SHELL_SINGLE_CLICK

                    break;
                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }
        case ( WM_HELP ) :             // F1
        {
            WinHelp( ((LPHELPINFO)lParam)->hItemHandle,
                     HELP_FILE,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aMouseButHelpIds );
            break;
        }
        case ( WM_CONTEXTMENU ) :      // right mouse click
        {
            WinHelp( (HWND) wParam,
                     HELP_FILE,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aMouseButHelpIds );
            break;
        }

        case ( WM_DISPLAYCHANGE ) :
        case ( WM_WININICHANGE ) :
        case ( WM_SYSCOLORCHANGE ) :
        {
            SHPropagateMessage(hDlg, message, wParam, lParam, TRUE);
            return TRUE;
        }

        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}


#ifdef SHELL_SINGLE_CLICK
////////////////////////////////////////////////////////////////////////////
//
//  ShellClick_UpdateUI
//
//  Assigns the appropriate icon for shell single/double click
//
////////////////////////////////////////////////////////////////////////////
void ShellClick_UpdateUI(
    HWND hDlg,
    PMOUSEBUTSTR pMstr)
{
    HICON hicon = pMstr->bShellSingleClick ? pMstr->hIconSglClick :
                                             pMstr->hIconDblClick ;

    SendMessage( GetDlgItem( hDlg, MOUSE_CLICKICON ), STM_SETICON,
                 (WPARAM)hicon, 0L ) ;
}
#endif //SHELL_SINGLE_CLICK

////////////////////////////////////////////////////////////////////////////
//
//  IsShellWindow
//
//  Determines whether the specified window is a shell folder window.
//
////////////////////////////////////////////////////////////////////////////
#define c_szExploreClass TEXT("ExploreWClass")
#define c_szIExploreClass TEXT("IEFrame")
#ifdef IE3CLASSNAME
#define c_szCabinetClass TEXT("IEFrame")
#else
#define c_szCabinetClass TEXT("CabinetWClass")
#endif

BOOL IsShellWindow( HWND hwnd )
{
    TCHAR szClass[32];

    GetClassName(hwnd, szClass, ARRAYSIZE(szClass));
    return (lstrcmp(szClass, c_szCabinetClass) == 0) ||
           (lstrcmp(szClass, c_szExploreClass) == 0) ||
           (lstrcmp(szClass, c_szIExploreClass) == 0) ;
}

//The following value is taken from shdocvw\rcids.h
#ifndef FCIDM_REFRESH
#define FCIDM_REFRESH  0xA220
#endif // FCIDM_REFRESH

////////////////////////////////////////////////////////////////////////////
//
//  ShellClick_RefreshEnumProc
//
//  EnumWindow callback for shell refresh.
//
////////////////////////////////////////////////////////////////////////////
BOOL CALLBACK ShellClick_RefreshEnumProc( HWND hwnd, LPARAM lParam )
{
    if( IsShellWindow(hwnd) )
        PostMessage(hwnd, WM_COMMAND, FCIDM_REFRESH, 0L);

    return(TRUE);
}

////////////////////////////////////////////////////////////////////////////
//
//  ShellClick_Refresh
//
//  Re-renders the contents of all shell folder windows.
//
////////////////////////////////////////////////////////////////////////////
void ShellClick_Refresh( PMOUSEBUTSTR pMstr )
{
    HWND hwndDesktop = FindWindowEx(NULL, NULL, TEXT(STR_DESKTOPCLASS), NULL);

    if( NULL != hwndDesktop )
       PostMessage( hwndDesktop, WM_COMMAND, FCIDM_REFRESH, 0L );

    EnumWindows( ShellClick_RefreshEnumProc, 0L ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\main\mousemov.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    mousemov.c

Abstract:

    This module contains the routines for the Mouse Pointer Property Sheet
    page.

Revision History:

--*/



//
//  Include Files.
//

#include "main.h"
#include "util.h"
#include "rc.h"
#include "mousehlp.h"


extern void WINAPI CenterDlgOverParent (HWND hWnd);

#define SAFE_DESTROYICON(hicon)   if (hicon) { DestroyIcon(hicon); hicon=NULL; }

//
//  Constant Declarations.
//


#define TRAILMIN   2
#define TRAILMAX   (TRAILMIN + 5)      // range of 8 settings
//
// Motion trackbar parameters.
//
const int MOTION_TB_MIN  =  0;
const int MOTION_TB_MAX  = 10;
const int MOTION_TB_STEP =  1;


//
//  Typedef Declarations.
//
typedef struct
{
    int Thresh1;
    int Thresh2;
    int Accel;
} GETMOUSE;

//
//  Dialog Data.
//
typedef struct tag_MouseGenStr
{
    int       nMotion;
    int       nOrigMotion;
    BOOL      fOrigEnhancedMotion;

    short     nTrailSize;
    short     nOrigTrailSize;

    HWND      hWndTrailScroll;

    BOOL      fOrigSnapTo;

    HWND      hWndSpeedScroll;
    HWND      hDlg;

    BOOL      fOrigVanish;

    BOOL      fOrigSonar;
} MOUSEPTRSTR, *PMOUSEPTRSTR, *LPMOUSEPTRSTR;




//
//  Context Help Ids.
//

const DWORD aMouseMoveHelpIds[] =
{
    IDC_GROUPBOX_1,                 IDH_COMM_GROUPBOX,
    MOUSE_SPEEDSCROLL,              IDH_MOUSE_POINTERSPEED,

    IDC_GROUPBOX_4,                 IDH_COMM_GROUPBOX,
    MOUSE_SNAPDEF,                  IDH_MOUSE_SNAPTO,
    MOUSE_PTRSNAPDEF,               IDH_MOUSE_SNAPTO,

    IDC_GROUPBOX_5,                 IDH_COMM_GROUPBOX,
    MOUSE_TRAILS,                   IDH_MOUSE_POINTER_TRAILS,
    MOUSE_TRAILSCROLLTXT1,          IDH_MOUSE_POINTER_TRAILS,
    MOUSE_TRAILSCROLLTXT2,          IDH_MOUSE_POINTER_TRAILS,
    MOUSE_TRAILSCROLL,              IDH_MOUSE_POINTER_TRAILS,
    MOUSE_VANISH,                   IDH_MOUSE_VANISH,
    MOUSE_SONAR,                    IDH_MOUSE_SONAR,
    MOUSE_ENHANCED_MOTION,          IDH_MOUSE_ENHANCED_MOTION,

    0,0
};


BOOL
_IsValidTrackbarMotionValue(
    int nMotionTrackbar
    )
{
    return (MOTION_TB_MIN <= nMotionTrackbar && MOTION_TB_MAX >= nMotionTrackbar);
}

//
// Sets the mouse acceleration settings.
// If the "Enhanced Motion" checkbox is checked we disable acceleration and
// let USER handle it based on the "motion" setting.
// If the checkbox is unchecked, we default to what was "low" acceleration
// in Windows 2000.  Therefore, it is critical that the MOUSE_ENHANCED_MOTION
// checkbox be in the proper configuration before calling this function.
//
DWORD
_SetPointerAcceleration(
    HWND hwndDlg,
    UINT fWinIni
    )
{
    DWORD dwResult = ERROR_SUCCESS;
    GETMOUSE gm = { 0, 0, 0 };

    if (IsDlgButtonChecked(hwndDlg, MOUSE_ENHANCED_MOTION))
    {
        gm.Thresh1 =  6;
        gm.Thresh2 = 10;
        gm.Accel   =  1;
    }

    if (!SystemParametersInfo(SPI_SETMOUSE, 0, (PVOID)&gm, fWinIni))
    {
        dwResult = GetLastError();
        ASSERTMSG(0,
                  "SystemParametersInfo(SPI_SETMOUSE) failed with error %d",
                  dwResult);
    }
    return dwResult;
}



//
// Sets the mouse motion settings based on the current position of
// the motion trackbar and the configuration of the "enhanced motion"
// checkbox.
//
DWORD
_SetPointerMotion(
    HWND hwndDlg,
    int nMotionTrackbar, // Trackbar position [0 - 10]
    UINT fWinIni
    )
{
    DWORD dwResult = ERROR_SUCCESS;
    int nSpiSpeedValue;

    //
    // Calculations below depend on a trackbar max value of 10.
    // If the trackbar scaling changes, the expressions calculating
    // the system parameter below must also change.
    //
    ASSERT(0 == MOTION_TB_MIN);
    ASSERT(10 == MOTION_TB_MAX);
    ASSERT(_IsValidTrackbarMotionValue(nMotionTrackbar));

    if (0 == nMotionTrackbar)
    {
        //
        // SPI_SETMOUSESPEED doesn't accept 0 so we set a lower-bound
        // of 1.
        //
        nSpiSpeedValue = 1;
    } else {
        nSpiSpeedValue = nMotionTrackbar * 2;
    }

    //
    // Ensure pointer acceleration is correctly set before setting
    // the speed value.
    //
    dwResult = _SetPointerAcceleration(hwndDlg, fWinIni);
    if (ERROR_SUCCESS == dwResult)
    {
        if (!SystemParametersInfo(SPI_SETMOUSESPEED,
                                  0,
                                  IntToPtr(nSpiSpeedValue),
                                  fWinIni))
        {
            dwResult = GetLastError();
            ASSERTMSG(0,
                      "SystemParametersInfo(SPI_SETMOUSESPEED) failed with error %d",
                      dwResult);
        }
    }
    return dwResult;
}



//
// Retrieves the motion trackbar setting based on the values returned
// by SystemParametersInfo.
//
DWORD
_GetPointerMotion(
    HWND hwndDlg,
    int *pnMotionTrackbar,
    BOOL *pfEnhancedMotion
    )
{
    BOOL fEnhancedMotion = FALSE;
    int nSpiSpeedValue   = 0;
    int nMotionTrackbar  = 0;
    GETMOUSE gm;
    DWORD dwResult       = ERROR_SUCCESS;

    ASSERT(0 == MOTION_TB_MIN);
    ASSERT(10 == MOTION_TB_MAX);

    //
    // Read the speed setting from USER.
    //
    if (!SystemParametersInfo(SPI_GETMOUSESPEED,
                              0,
                              &nSpiSpeedValue,
                              FALSE) ||
        !SystemParametersInfo(SPI_GETMOUSE,
                              0,
                              &gm,
                              FALSE))
    {
        dwResult = GetLastError();
        ASSERTMSG(0,
                  "SystemParametersInfo failed with error %d",
                  dwResult);
    }
    else
    {
        //
        // USER is no longer exposing the old acceleration algorithm. Thus,
        // if acceleration is on, then "Enhanced Motion" is (since it's the
        // only acceleration algorithm supported).
        //
        if (gm.Accel)
        {
            //
            // Enhanced.
            //
            fEnhancedMotion = TRUE;
        }

        if (1 <= nSpiSpeedValue && 20 >= nSpiSpeedValue)
        {
            //
            // Classic.
            //
            nMotionTrackbar = nSpiSpeedValue / 2;
        }
        else
        {
            //
            // Invalid value.  Default to classic mid-point.
            //
            nMotionTrackbar = 5;
        }
    }

    ASSERT(_IsValidTrackbarMotionValue(nMotionTrackbar));
    if (NULL != pfEnhancedMotion)
    {
        *pfEnhancedMotion = fEnhancedMotion;
    }
    if (NULL != pnMotionTrackbar)
    {
        *pnMotionTrackbar = nMotionTrackbar;
    }

    return dwResult;
}



////////////////////////////////////////////////////////////////////////////
//
//  DestroyMousePtrDlg
//
////////////////////////////////////////////////////////////////////////////

void DestroyMousePtrDlg(
    PMOUSEPTRSTR pMstr)
{
    HWND hDlg;

    ASSERT( pMstr )

    if( pMstr )
    {
        hDlg = pMstr->hDlg;

        LocalFree( (HGLOBAL)pMstr );

        SetWindowLongPtr( hDlg, DWLP_USER, 0 );
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  EnableTrailScroll
//
////////////////////////////////////////////////////////////////////////////

void EnableTrailScroll(
    HWND hDlg,
    BOOL val)
{
    EnableWindow(GetDlgItem(hDlg, MOUSE_TRAILSCROLL), val);
    EnableWindow(GetDlgItem(hDlg, MOUSE_TRAILSCROLLTXT1), val);
    EnableWindow(GetDlgItem(hDlg, MOUSE_TRAILSCROLLTXT2), val);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitMousePtrDlg
//
////////////////////////////////////////////////////////////////////////////

BOOL InitMousePtrDlg(
    HWND hDlg)
{
    PMOUSEPTRSTR pMstr = NULL;

    BOOL fSnapTo         = FALSE;  //default
    BOOL fVanish         = FALSE;  //default
    BOOL fSonar          = FALSE;  //default
    BOOL fEnhancedMotion = FALSE;
    short nTrails        = 0;      //default

    pMstr = (PMOUSEPTRSTR)LocalAlloc(LPTR, sizeof(MOUSEPTRSTR));

    if (pMstr == NULL)
    {
        return (TRUE);
    }

    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pMstr);

    pMstr->hDlg = hDlg;

    //
    //  Mouse Trails
    //
    SystemParametersInfo(SPI_GETMOUSETRAILS, 0, &nTrails, 0);
    pMstr->nOrigTrailSize = pMstr->nTrailSize = nTrails;


    SendDlgItemMessage( hDlg,
                        MOUSE_TRAILSCROLL,
                        TBM_SETRANGE,
                        0,
                        MAKELONG(TRAILMIN, TRAILMAX) );

    CheckDlgButton(hDlg, MOUSE_TRAILS, (pMstr->nTrailSize > 1));

    if (pMstr->nTrailSize > 1)
      {
        SendDlgItemMessage( hDlg,
                            MOUSE_TRAILSCROLL,
                            TBM_SETPOS,
                            TRUE,
                            (LONG)pMstr->nTrailSize );
      }
    else
      {
        pMstr->nTrailSize = TRAILMAX;

        EnableTrailScroll(hDlg, FALSE);

        SendDlgItemMessage( hDlg,
                            MOUSE_TRAILSCROLL,
                            TBM_SETPOS,
                            TRUE,
                            (LONG)pMstr->nTrailSize );
      }

    //
    // Enable or disable the Snap To Default Checkbutton
    //
    SystemParametersInfo(SPI_GETSNAPTODEFBUTTON, 0, (PVOID)&fSnapTo, FALSE);
    pMstr->fOrigSnapTo = fSnapTo;
    CheckDlgButton(hDlg, MOUSE_SNAPDEF, fSnapTo);

    //
    //Enable or disable the Sonar Checkbutton
    //
    SystemParametersInfo(SPI_GETMOUSESONAR, 0, (PVOID)&fSonar, FALSE);
    pMstr->fOrigSonar = fSonar;
	CheckDlgButton(hDlg, MOUSE_SONAR, fSonar);

    //
    //Enable or disable the Vanish Checkbutton
    //
    SystemParametersInfo(SPI_GETMOUSEVANISH, 0, (PVOID)&fVanish, FALSE);
    pMstr->fOrigVanish = fVanish;
	CheckDlgButton(hDlg, MOUSE_VANISH, fVanish);

    //
    //  Mouse Speed
    //
    _GetPointerMotion(hDlg, &pMstr->nOrigMotion, &fEnhancedMotion);

    CheckDlgButton(hDlg, MOUSE_ENHANCED_MOTION, fEnhancedMotion);
    pMstr->nMotion = pMstr->nOrigMotion;
    pMstr->fOrigEnhancedMotion = fEnhancedMotion;

    pMstr->hWndTrailScroll = GetDlgItem(hDlg, MOUSE_TRAILSCROLL);

    pMstr->hWndSpeedScroll = GetDlgItem(hDlg, MOUSE_SPEEDSCROLL);

    SendDlgItemMessage( hDlg,
                        MOUSE_SPEEDSCROLL,
                        TBM_SETRANGE,
                        0,
                        MAKELONG(MOTION_TB_MIN, MOTION_TB_MAX) );

    SendDlgItemMessage( hDlg,
                        MOUSE_SPEEDSCROLL,
                        TBM_SETTICFREQ,
                        MOTION_TB_STEP,
                        0);

    SendDlgItemMessage( hDlg,
                        MOUSE_SPEEDSCROLL,
                        TBM_SETLINESIZE,
                        0,
                        MOTION_TB_STEP);

    SendDlgItemMessage( hDlg,
                        MOUSE_SPEEDSCROLL,
                        TBM_SETPOS,
                        TRUE,
                        (LONG)pMstr->nOrigMotion);
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  TrailScroll
//
////////////////////////////////////////////////////////////////////////////

void TrailScroll(
    WPARAM wParam,
    LPARAM lParam,
    PMOUSEPTRSTR pMstr)
{
    pMstr->nTrailSize = (short)SendMessage((HWND)lParam, TBM_GETPOS, 0, 0L);
    SystemParametersInfo(SPI_SETMOUSETRAILS, pMstr->nTrailSize, 0,0);
}


////////////////////////////////////////////////////////////////////////////
//
//  SpeedScroll
//
////////////////////////////////////////////////////////////////////////////

void SpeedScroll(
    WPARAM wParam,
    LPARAM lParam,
    PMOUSEPTRSTR pMstr)
{
    const HWND hwndTrackbar = (HWND)lParam;
    pMstr->nMotion = (int)SendMessage(hwndTrackbar, TBM_GETPOS, 0, 0L);
    //
    //  Update speed when they let go of the thumb.
    //
    if (LOWORD(wParam) == SB_ENDSCROLL)
    {
        const HWND hwndDlg = GetParent(hwndTrackbar);
        _SetPointerMotion(hwndDlg, pMstr->nMotion, SPIF_SENDCHANGE);
    }
}


//
// User checked or unchecked the "Enhanced pointer motion" checkbox.
//
void
_OnEnhancedMotionChecked(
    PMOUSEPTRSTR pMstr
    )
{
    const HWND hwndTrackbar = (HWND)pMstr->hWndSpeedScroll;
    const HWND hwndDlg      = GetParent(hwndTrackbar);

    pMstr->nMotion = (int)SendMessage(hwndTrackbar, TBM_GETPOS, 0, 0L);
    _SetPointerMotion(hwndDlg, pMstr->nMotion, SPIF_SENDCHANGE);
}




////////////////////////////////////////////////////////////////////////////
//
//  MouseMovDlg
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK MouseMovDlg(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PMOUSEPTRSTR pMstr = NULL;
    BOOL bRet = FALSE;

    pMstr = (PMOUSEPTRSTR)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (message)
    {
        case ( WM_INITDIALOG ) :
        {
            bRet = InitMousePtrDlg(hDlg);
            break;
        }
        case ( WM_DESTROY ) :
        {
            DestroyMousePtrDlg(pMstr);
            break;
        }
        case ( WM_HSCROLL ) :
        {
            SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);

            if ((HWND)lParam == pMstr->hWndSpeedScroll)
            {
                SpeedScroll(wParam, lParam, pMstr);
            }
            else if ((HWND)lParam == pMstr->hWndTrailScroll)
            {
                TrailScroll(wParam, lParam, pMstr);
            }

            break;
        }
        case ( WM_COMMAND ) :
        {
            switch (LOWORD(wParam))
            {
                case ( MOUSE_TRAILS ) :
                {
                    if (IsDlgButtonChecked(hDlg, MOUSE_TRAILS))
                    {
                        EnableTrailScroll(hDlg, TRUE);

                        pMstr->nTrailSize =
                            (int)SendMessage( pMstr->hWndTrailScroll,
                                              TBM_GETPOS,
                                              0,
                                              0 );
                        SystemParametersInfo( SPI_SETMOUSETRAILS,
                                              pMstr->nTrailSize,
                                              0,
                                              0 );

                    }
                    else
                    {
                        EnableTrailScroll(hDlg, FALSE);
                        SystemParametersInfo(SPI_SETMOUSETRAILS, 0, 0, 0);
                    }
                    SendMessage( GetParent(hDlg),
                                 PSM_CHANGED,
                                 (WPARAM)hDlg,
                                 0L );
                    break;
                }

                case ( MOUSE_SNAPDEF ) :
                {
                    SystemParametersInfo( SPI_SETSNAPTODEFBUTTON,
                                          IsDlgButtonChecked(hDlg, MOUSE_SNAPDEF),
                                          0,
                                          FALSE );
                    SendMessage( GetParent(hDlg),
                                 PSM_CHANGED,
                                 (WPARAM)hDlg,
                                 0L );
                    break;
                }

                case ( MOUSE_SONAR ) :
                {
                    SystemParametersInfo( SPI_SETMOUSESONAR,
                                          0,
                                          IntToPtr( IsDlgButtonChecked(hDlg, MOUSE_SONAR) ),
                                          FALSE );
                    SendMessage( GetParent(hDlg),
                                 PSM_CHANGED,
                                 (WPARAM)hDlg,
                                 0L );
                    break;
                }

                case ( MOUSE_VANISH ) :
                {
                    SystemParametersInfo( SPI_SETMOUSEVANISH,
                                          0,
                                          IntToPtr( IsDlgButtonChecked(hDlg, MOUSE_VANISH) ),
                                          FALSE );
                    SendMessage( GetParent(hDlg),
                                 PSM_CHANGED,
                                 (WPARAM)hDlg,
                                 0L );
                    break;
                }

                case ( MOUSE_ENHANCED_MOTION ) :
                    _OnEnhancedMotionChecked(pMstr);
                    SendMessage( GetParent(hDlg),
                                 PSM_CHANGED,
                                 (WPARAM)hDlg,
                                 0L );
                    break;

            }
            break;
        }
        case ( WM_NOTIFY ) :
        {
            switch (((NMHDR *)lParam)->code)
            {
              case ( PSN_APPLY ) :
                {
                short nTrails = 0;
                BOOL fSnapTo = FALSE;
                BOOL fSonar = FALSE;
                BOOL fVanish = FALSE;

                //
                //  Change cursor to hour glass.
                //
                HourGlass(TRUE);

                //
                //  Apply Mouse trails setting.
                //
                nTrails = (IsDlgButtonChecked(hDlg, MOUSE_TRAILS)) ? pMstr->nTrailSize : 0;
                SystemParametersInfo( SPI_SETMOUSETRAILS,
                                      nTrails,
                                      0,
                                      SPIF_UPDATEINIFILE |
                                        SPIF_SENDCHANGE );
                pMstr->nOrigTrailSize = pMstr->nTrailSize = nTrails;


                //
                //  Apply Snap-To-Default setting.
                //
                fSnapTo = IsDlgButtonChecked(hDlg, MOUSE_SNAPDEF);

                if (fSnapTo != pMstr->fOrigSnapTo)
                  {
                  SystemParametersInfo( SPI_SETSNAPTODEFBUTTON,
                                        fSnapTo,
                                        0,
                                        SPIF_UPDATEINIFILE |
                                          SPIF_SENDCHANGE );
                  pMstr->fOrigSnapTo = fSnapTo;
                  }


                //
                //  Apply Sonar setting.
                //
                fSonar = IsDlgButtonChecked(hDlg, MOUSE_SONAR);
                if (fSonar != pMstr->fOrigSonar)
                  {
                  SystemParametersInfo( SPI_SETMOUSESONAR,
                                        0,
                                        IntToPtr(fSonar),
                                        SPIF_UPDATEINIFILE |
                                          SPIF_SENDCHANGE );
                  pMstr->fOrigSonar = fSonar;
                  }


                //
                //  Apply Vanish setting.
                //
                fVanish = IsDlgButtonChecked(hDlg, MOUSE_VANISH);

                if (fVanish != pMstr->fOrigVanish)
                  {
                  SystemParametersInfo( SPI_SETMOUSEVANISH,
                                        0,
                                        IntToPtr(fVanish),
                                        SPIF_UPDATEINIFILE |
                                          SPIF_SENDCHANGE );
                  pMstr->fOrigVanish = fVanish;
                  }

                //
                //  Apply Mouse Speed setting.
                //
                _SetPointerMotion(hDlg, pMstr->nMotion, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);
                pMstr->fOrigEnhancedMotion = IsDlgButtonChecked(hDlg, MOUSE_ENHANCED_MOTION);
                pMstr->nOrigMotion = pMstr->nMotion;

                HourGlass(FALSE);
                break;
                }
              case ( PSN_RESET ) :
                {
                //
                //  Restore the original Mouse Trails setting.
                //
                SystemParametersInfo( SPI_SETMOUSETRAILS,
                                      pMstr->nOrigTrailSize,
                                      0,
                                      0 );

                //
                //  Restore the original Snap-To-Default setting .
                //
                SystemParametersInfo( SPI_SETSNAPTODEFBUTTON,
                                      pMstr->fOrigSnapTo,
                                      0,
                                      0 );

                //
                //  Restore the original Sonar setting.
                //
                SystemParametersInfo( SPI_SETMOUSESONAR,
                                      0,
                                      IntToPtr(pMstr->fOrigSonar),
                                      0);

                //
                //  Restore the original Vanish setting.
                //
                SystemParametersInfo( SPI_SETMOUSEVANISH,
                                      0,
                                      IntToPtr(pMstr->fOrigVanish),
                                      0);

                //
                //  Restore the original Mouse Motion value.
                //
                CheckDlgButton(hDlg, MOUSE_ENHANCED_MOTION, pMstr->fOrigEnhancedMotion);
                _SetPointerMotion(hDlg, pMstr->nOrigMotion, FALSE);
                break;
                }
              default :
                {
                    return (FALSE);
                }
            }
            break;
        }
        case ( WM_HELP ) :             // F1
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     HELP_FILE,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aMouseMoveHelpIds );
            break;
        }
        case ( WM_CONTEXTMENU ) :      // right mouse click
        {
            WinHelp( (HWND)wParam,
                     HELP_FILE,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aMouseMoveHelpIds );
            break;
        }

        case ( WM_DISPLAYCHANGE ) :
        case ( WM_WININICHANGE ) :
        case ( WM_SYSCOLORCHANGE ) :
        {
            SHPropagateMessage(hDlg, message, wParam, lParam, TRUE);
            return TRUE;
        }

        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\main\mousehlp.h ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:
    mousehlp.h
Abstract:
    This module contains the header information for the Mouse help.

Revision History:
--*/

//  ID values for Mouse property sheet.

#define IDH_COMM_GROUPBOX               28548

// Buttons tab
#define IDH_MOUSE_SWITCH	 	        3000	// Switch primary and secondary buttons check box
#define IDH_MOUSE_SWITCH_PIC  		    3001	// Button configuration picture
#define IDH_MOUSE_DOUBLECLICK	 	    3002	// Double-click text and slider
#define IDH_MOUSE_DCLICK_TEST_BOX  	    3003	// Double-click speed test area
#define IDH_MOUSE_CLKLCK_CHKBOX		    3004	// ClickLock check box and text
#define IDH_MOUSE_CLKLCK_SETTINGS_BTN	3005	// ClickLock Settings button
#define IDH_MOUSE_CLKLCK_DIALOG		    3006	// Settings dialog (entire dialog)

// Pointers tab
#define IDH_MOUSE_POINT_SCHEME      	3010	// Scheme list box
#define IDH_MOUSE_POINT_DEL     	    3011	// Scheme Delete button
#define IDH_MOUSE_POINT_SAVEAS     	    3012	// Scheme Save As button
#define IDH_MOUSE_POINT_PREVIEW      	3013	// Scheme Preview box
#define IDH_MOUSE_POINT_BROWSE      	3014	// Browse button
#define IDH_MOUSE_POINT_LIST      	    3015	// Customize list box
#define IDH_MOUSE_POINT_DEFAULT      	3016	// Use Default button
#define IDH_MOUSE_NEW_SCHEME_NAME      	3017	// Save As dialog box
#define IDH_MOUSE_CURSORSHADOW      	3030	// Mouse Shadow check box
#define IDH_MOUSE_ENHANCED_MOTION       3031    // Enhanced motion checkbox

// Pointer Options tab
#define IDH_MOUSE_POINTERSPEED	 	    3020	// Text and slider
#define IDH_MOUSE_ADVANCED_BTN	 	    3021	// Advanced button
#define IDH_MOUSE_ACCELERATION_DLG	    3022	// Entire Advanced Settings dialog box
#define IDH_MOUSE_SNAPTO		        3023	// Text and check box
#define IDH_MOUSE_POINTER_TRAILS	    3024	// Includes slider
#define IDH_MOUSE_VANISH		        3025	// Hide pointer check box and text
#define IDH_MOUSE_SONAR			        3026	// Show location check box and text

// Wheel tab
#define IDH_MOUSE_WHEEL_SCROLLING	    3028	// Includes entire control
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\main\mousectl.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    mousectl.c

Abstract:

    This module contains the routines for the Mouse control.

Revision History:

--*/



//
//  Include Files.
//

#include "main.h"
#include "mousectl.h"
#include "rc.h"



//
//  Constant Declarations.
//

#define MOUSECTL_BITMAP_NAME          MAKEINTRESOURCE(IDB_MOUSE)

#define MOUSECTL_DATA                 0

//
//  These are indices into the VGA palette!
//
#define MOUSECTL_BKGND_INDEX          14    // light cyan
#define MOUSECTL_LBUTTON_INDEX        13    // light magenta
#define MOUSECTL_RBUTTON_INDEX        11    // light yellow
#define MOUSECTL_LBUTTON_ALTERNATE    5     // magenta
#define MOUSECTL_RBUTTON_ALTERNATE    3     // yellow

#define MOUSECTL_NORMAL_COLOR         RGB(255, 255, 255)

#define HALFRGB(c)  RGB(GetRValue(c) / 2, GetGValue(c) / 2, GetBValue(c) / 2)




//
//  Typedef Declarations.
//

typedef struct tagMOUSECTLDATA
{
    HWND     window;         // window handle for this control
    BOOL     swapped;        // are the buttons swapped?

    HBITMAP  image;          // DIB section image of mouse
    HDC      imagedc;        // DC where image lives
    HBITMAP  olddcimage;     // previous inhabitant of imagedc

    POINT    offset;         // offset of bitmap in control
    SIZE     size;           // size of bitmap

} MOUSECTLDATA, *PMOUSECTLDATA;




//
//  Forward Declarations.
//

LRESULT CALLBACK
MouseControlWndProc(
    HWND window,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);

void
MouseControlShowSwap(
    PMOUSECTLDATA ctldata);





////////////////////////////////////////////////////////////////////////////
//
//  SetMouseControlData
//
////////////////////////////////////////////////////////////////////////////

__inline void SetMouseControlData(
    HWND window,
    PMOUSECTLDATA ctldata)
{
    SetWindowLongPtr(window, MOUSECTL_DATA, (LONG_PTR)ctldata);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetMouseControlData
//
////////////////////////////////////////////////////////////////////////////

__inline PMOUSECTLDATA GetMouseControlData(
    HWND window)
{
    return ((PMOUSECTLDATA)GetWindowLongPtr(window, MOUSECTL_DATA));
}


////////////////////////////////////////////////////////////////////////////
//
//  RegisterMouseControlStuff
//
////////////////////////////////////////////////////////////////////////////

BOOL RegisterMouseControlStuff(
    HINSTANCE instance)
{
    WNDCLASS wc;

    wc.style         = 0;
    wc.lpfnWndProc   = MouseControlWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = sizeof(PMOUSECTLDATA);
    wc.hInstance     = instance;
    wc.hIcon         = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);
    wc.lpszMenuName  = NULL;
    wc.lpszClassName = MOUSECTL_CLASSNAME;

    return (RegisterClass(&wc));
}


////////////////////////////////////////////////////////////////////////////
//
//  CreateMouseControlData
//
////////////////////////////////////////////////////////////////////////////

PMOUSECTLDATA CreateMouseControlData(
    HWND window)
{
    PMOUSECTLDATA ctldata = (PMOUSECTLDATA)LocalAlloc(LPTR, sizeof(MOUSECTLDATA));

    if (ctldata)
    {
        ctldata->window = window;
        SetMouseControlData(window, ctldata);
    }

    return (ctldata);
}


////////////////////////////////////////////////////////////////////////////
//
//  DestroyMouseControlData
//
////////////////////////////////////////////////////////////////////////////

void DestroyMouseControlData(
    PMOUSECTLDATA ctldata)
{
    if (ctldata)
    {
        SetMouseControlData(ctldata->window, 0);

        LocalFree(ctldata);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  MouseControlNCCreate
//
////////////////////////////////////////////////////////////////////////////

BOOL MouseControlNCCreate(
    PMOUSECTLDATA ctldata,
    LPCREATESTRUCT cs)
{
    if (!ctldata)
    {
        return (FALSE);
    }

    ctldata->image = LoadImage( cs->hInstance,
                                MOUSECTL_BITMAP_NAME,
                                IMAGE_BITMAP,
                                0,
                                0,
                                LR_CREATEDIBSECTION );

    if (ctldata->image)
    {
        ctldata->imagedc = CreateCompatibleDC(NULL);

        if (ctldata->imagedc)
        {
            BITMAP bm;

            ctldata->olddcimage =
                SelectBitmap(ctldata->imagedc, ctldata->image);

            ctldata->offset.x = ctldata->offset.y = 0;

            if (GetObject(ctldata->image, sizeof(BITMAP), &bm))
            {
                ctldata->size.cx  = bm.bmWidth;
                ctldata->size.cy  = bm.bmHeight;
                ctldata->offset.x = (cs->cx - ctldata->size.cx) / 2;
                ctldata->offset.y = (cs->cy - ctldata->size.cy) / 2;

                ctldata->swapped = FALSE;
                MouseControlShowSwap(ctldata);
                return (TRUE);
            }

            SelectBitmap(ctldata->imagedc, ctldata->olddcimage);
            ctldata->olddcimage = NULL;
        }

        DeleteBitmap(ctldata->image);
        ctldata->image = NULL;
    }

    ctldata->olddcimage = NULL;
    ctldata->imagedc    = NULL;

    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  MouseControlNCDestroy
//
////////////////////////////////////////////////////////////////////////////

void MouseControlNCDestroy(
    PMOUSECTLDATA ctldata)
{
    if (ctldata)
    {
        if (ctldata->olddcimage)
        {
            SelectBitmap(ctldata->imagedc, ctldata->olddcimage);
            ctldata->olddcimage = NULL;
        }

        if (ctldata->imagedc)
        {
            DeleteDC(ctldata->imagedc);
            ctldata->imagedc = NULL;
        }

        if (ctldata->image)
        {
            DeleteBitmap(ctldata->image);
            ctldata->image = NULL;
        }

        DestroyMouseControlData(ctldata);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  MouseControlPaint
//
////////////////////////////////////////////////////////////////////////////

void MouseControlPaint(
    PMOUSECTLDATA ctldata)
{
    PAINTSTRUCT ps;
    HDC dc = BeginPaint(ctldata->window, &ps);

    BitBlt( dc,
            ctldata->offset.x,
            ctldata->offset.y,
            ctldata->size.cx,
            ctldata->size.cy,
            ctldata->imagedc,
            0,
            0,
            SRCCOPY|NOMIRRORBITMAP);

    EndPaint(ctldata->window, &ps);
}


////////////////////////////////////////////////////////////////////////////
//
//  MouseControlSetColor
//
////////////////////////////////////////////////////////////////////////////

__inline void MouseControlSetColor(
    PMOUSECTLDATA ctldata,
    UINT index,
    COLORREF color)
{
    RGBQUAD rgbq = { GetBValue(color), GetGValue(color), GetRValue(color), 0 };

    SetDIBColorTable(ctldata->imagedc, index, 1, &rgbq);
}


////////////////////////////////////////////////////////////////////////////
//
//  MouseControlShowSwap
//
////////////////////////////////////////////////////////////////////////////

void MouseControlShowSwap(
    PMOUSECTLDATA ctldata)
{
    MouseControlSetColor( ctldata,
                          MOUSECTL_BKGND_INDEX,
                          GetSysColor(COLOR_BTNFACE) );

    MouseControlSetColor( ctldata,
                          ctldata->swapped
                            ? MOUSECTL_RBUTTON_INDEX
                            : MOUSECTL_LBUTTON_INDEX,
                          GetSysColor(COLOR_HIGHLIGHT) );

    MouseControlSetColor( ctldata,
                          ctldata->swapped
                            ? MOUSECTL_RBUTTON_ALTERNATE
                            : MOUSECTL_LBUTTON_ALTERNATE,
                          HALFRGB(GetSysColor(COLOR_HIGHLIGHT)) );

    MouseControlSetColor( ctldata,
                          ctldata->swapped
                            ? MOUSECTL_LBUTTON_INDEX
                            : MOUSECTL_RBUTTON_INDEX,
                          MOUSECTL_NORMAL_COLOR );

    MouseControlSetColor( ctldata,
                          ctldata->swapped
                            ? MOUSECTL_LBUTTON_ALTERNATE
                            : MOUSECTL_RBUTTON_ALTERNATE,
                          HALFRGB(MOUSECTL_NORMAL_COLOR) );

    InvalidateRect(ctldata->window, NULL, FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  MouseControlSetSwap
//
////////////////////////////////////////////////////////////////////////////

void MouseControlSetSwap(
    HWND window,
    BOOL swap)
{
    PMOUSECTLDATA ctldata = GetMouseControlData(window);

    if (ctldata->swapped != swap)
    {
        ctldata->swapped = swap;
        MouseControlShowSwap(ctldata);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  MouseControlWndProc
//
////////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK MouseControlWndProc(
    HWND window,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PMOUSECTLDATA ctldata = (message == WM_NCCREATE)
                              ? CreateMouseControlData(window)
                              : GetMouseControlData(window);

    switch (message)
    {
        HANDLE_MSG(ctldata, WM_NCCREATE,  MouseControlNCCreate );
        HANDLE_MSG(ctldata, WM_NCDESTROY, MouseControlNCDestroy);
        HANDLE_MSG(ctldata, WM_PAINT,     MouseControlPaint    );
    }

    return (DefWindowProc(window, message, wParam, lParam));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\main\rc.h ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    rc.h

Abstract:

    This module contains the header information for the resources of
    this project.

Revision History:

--*/



#ifndef _RC_H
#define _RC_H

#define IDC_STATIC -1


//
//  Icons.
//

//
// These IDs determine the index of the icons in the cpl. They
// should not be changed as they are externally referenced,
// In particular IDI_ADM and IDI_FONT must maintain their indices (9 and 10)
// If you add/remove icons from main.cpl, make sure you don't break
// the icons for the fonts and admin folder.
//

#define IDI_MOUSE                      100
#define IDI_KEYBD                      200
#define IDI_PRINT                      300
#define IDI_FONTS                      400
#define IDI_ADM                        500

#define IDI_PTSPEED                    104

#define IDI_DELAY                      105
#define IDI_REPEAT                     106

#define IDI_SNAPDEF                    108

#define IDI_SGLCLICK                   109
#define IDI_DBLCLICK                   110

//
// IDI_PTTRAILS has been renumbered to have a higher index
// than IDI_ADM as earlier it was not getting installed on Winnt
// We used to install only IDI_SNAPDEF on Winnt and IDI_PTTRAILS
// on Millennium, hence the index of the Fonts and Admin icon used
// to be the same in both cases, now we are installing both IDI_SNAPDEF
// and IDI_PTTRAILS in Whistler we must bump one of these IDs 
// above ID_ADM so that we maintain their indices.
//

#define IDI_PTTRAILS                   600

#define IDI_PTVANISH                   601  
#define IDI_PTSONAR                    602  
#define IDI_WHEEL                      603  

#define ICON_FOLDER_CLOSED             605
#define ICON_FOLDER_OPEN               606

//
// Add any new Icon IDs here, ie, value greater than 606.
//
#define ICON_CLICKLOCK                 607

//
//  Bitmaps.
//

#define IDB_MOUSE                     100






//
//  Strings.
//

#define IDS_MOUSE_TITLE                100
#define IDS_MOUSE_EXPLAIN              101
#define IDS_KEYBD_TITLE                102
#define IDS_KEYBD_EXPLAIN              103
#define IDS_PRINT_TITLE                104
#define IDS_PRINT_EXPLAIN              105
#define IDS_FONTS_TITLE                106
#define IDS_FONTS_EXPLAIN              107
#define IDS_ADM_TITLE                  108
#define IDS_ADM_EXPLAIN                109

#define IDS_MOUSE_TSHOOT               110
#define IDS_KEYBD_TSHOOT               111

#define IDS_UNKNOWN                    198
#define IDS_KEYBD_NOSETSPEED           199

#define IDS_ANICUR_FILTER              200
#define IDS_NAME                       201
#define IDS_INFO                       202
#define IDS_CUR_NOMEM                  203
#define IDS_CUR_BADFILE                204
#define IDS_CUR_BROWSE                 205
#define IDS_CUR_FILTER                 206
#define IDS_ARROW                      207
#define IDS_WAIT                       208
#define IDS_APPSTARTING                209
#define IDS_NO                         210
#define IDS_IBEAM                      211
#define IDS_CROSS                      212
#define IDS_SIZENS                     213
#define IDS_SIZEWE                     214
#define IDS_SIZENWSE                   215
#define IDS_SIZENESW                   216
#define IDS_SIZEALL                    217
#define IDS_HELPCUR                    218
#define IDS_NWPEN                      219
#define IDS_UPARROW                    220
#define IDS_NONE                       221
#define IDS_SUFFIX                     222
#define IDS_OVERWRITE_TITLE            223
#define IDS_OVERWRITE_MSG              224
#define IDS_HANDCUR                    225

#define IDS_REMOVESCHEME               230
#define IDS_DEFAULTSCHEME              231

#define IDS_FIRSTSCHEME                1000
#define IDS_LASTSCHEME                 1017




//
//  Dialog Boxes.
//

#define DLG_MOUSE_POINTER_SCHEMESAVE   99
#define DLG_MOUSE_BUTTONS              100
#define DLG_MOUSE_POINTER              101
#define DLG_MOUSE_POINTER_BROWSE       102
#define DLG_MOUSE_MOTION               103
#define DLG_KEYBD_SPEED                104
#define DLG_KEYBD_POINTER              105
#define DLG_HARDWARE                   106
#define DLG_MOUSE_ACTIVITIES           107
#define DLG_MOUSE_WHEEL                108
#define DLG_POINTER_OPTIONS_ADVANCED   109
#define DLG_MOUSE_SET_ORIENTATION      110


//
//  Dialog Controls.
//

#define IDC_GROUPBOX_1                 94   // Use in place of IDC_STATIC for
#define IDC_GROUPBOX_2                 95   // controls with no context Help
#define IDC_GROUPBOX_3                 96
#define IDC_GROUPBOX_4                 97
#define IDC_GROUPBOX_5                 98
#define IDC_GROUPBOX_6                 99




//
//  Mouse Button Page.
//

#define MOUSE_SELECTBMP                102
#define IDBTN_BUTTONSWAP               101

#define MOUSE_MOUSEBMP                 103
#define MOUSE_MENUBMP                  104
#define MOUSE_CLICKSCROLL              105
#define MOUSE_DBLCLK_TEST_AREA         106
#define MOUSE_PTRCOLOR                 107
#define MOUSE_SIZESCROLL               108
#define MOUSE_CLICKICON                111
#define MOUSE_DBLCLICK                 112
#define MOUSE_SGLCLICK                 113
#define IDCK_CLICKLOCK                 114
#define IDBTN_CLICKLOCK_SETTINGS       115
#define IDD_CLICKLOCK_SETTINGS_DLG          116
#define IDC_CLICKLOCK_SETTINGS_TXT          117
#define IDC_CLICKLOCK_SETTINGS_LEFT_TXT     118
#define IDC_CLICKLOCK_SETTINGS_RIGHT_TXT    119
#define IDT_CLICKLOCK_TIME_SETTINGS         120
#define IDC_TEST_DOUBLE_CLICK          123
#define IDC_DBLCLICK_TEXT              124 
#define IDC_CLICKLOCK_TEXT             125

//
//  Mouse Pointer Page.
//

#define DLG_CURSORS                    100
#define ID_CURSORLIST                  101
#define ID_BROWSE                      102
#define ID_DEFAULT                     103
#define ID_TITLEH                      104
#define ID_CREATORH                    105
#define ID_FILEH                       106
#define ID_TITLE                       107
#define ID_CREATOR                     108
#define ID_FILE                        109
#define ID_PREVIEW                     110
#define ID_SAVESCHEME                  111
#define ID_REMOVESCHEME                112
#define ID_SCHEMECOMBO                 113
#define ID_CURSORSHADOW                114


#define ID_SCHEMEFILENAME              300

#define ID_CURSORPREVIEW               400




//
//  Mouse Motion Page.  (Now called Pointer Options)
//

#define MOUSE_SPEEDSCROLL              101
#define MOUSE_TRAILBMP                 102
#define MOUSE_TRAILS                   103
#define MOUSE_TRAILSCROLL              104
#define MOUSE_PTRTRAIL                 105
#define MOUSE_SPEEDBMP                 106
#define MOUSE_TRAILSCROLLTXT1          107
#define MOUSE_TRAILSCROLLTXT2          108
#define MOUSE_SNAPDEF                  109
#define MOUSE_PTRSNAPDEF               110
#define MOUSE_PTRVANISH                112
#define MOUSE_PTRSONAR                 113
#define MOUSE_VANISH                   114
#define MOUSE_SONAR                    115
#define MOUSE_ENHANCED_MOTION          116

/*
//
// Mouse Activities Page.
//
#define IDB_SET_ORIENTATION             101
#define IDB_DEFAULT_ORIENTATION         102
#define IDBMP_WHEEL                     103

//Orientation wizard Dialog 
#define IDBTN_BACK                      110
#define IDBTN_NEXT                      111
#define IDBTN_FINISH                    112
#define IDGB_BITMAP_AREA                113
#define IDC_ORIENT_AREA                 114
#define IDGB_3D_LINE                    115
#define IDC_ORIENT_WIZ_TXT              116
#define IDC_ORIENT_WIZ_TXT_2            117
*/

//
// Mouse Wheel Page
//
#define IDBMP_SCROLL                    101
#define IDT_SCROLL_FEATURE_TXT          102
#define IDRAD_SCROLL_LINES              103
#define IDRAD_SCROLL_PAGE               104
#define IDE_BUDDY_SCROLL_LINES          105
#define IDC_SPIN_SCROLL_LINES           106
#define IDT_SCROLL_LINES_PER_TICK_TXT   107


//
//  Keyboard Speed Page.
//

#define KDELAY_SCROLL                  100
#define KSPEED_SCROLL                  101
#define KREPEAT_EDIT                   102
#define KBLINK_EDIT                    103
#define KCURSOR_BLINK                  104
#define KCURSOR_SCROLL                 105
#define KDELAY_GROUP                   106
#define KBLINK_GROUP                   107




//
//  Keyboard Pointer Page.
//

#define KCHK_ON                        100
#define KNUM_BMP                       101
#define KBTN_NUMBER                    102
#define KBTN_ARROW                     103
#define KARROW_BMP                     104
#define KPSPEED_SCROLL                 105
#define KPACC_SCROLL                   106


//
//	Friend User Type
//
//	This is refered to in the registry for "anifile" types.

#define IDS_FRIENDUSERTYPE			   2000



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\main\mousewhl.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    mousewhl.c

Abstract:

    This module contains the routines for the Mouse Wheel Property Sheet
    page.

Revision History:

--*/


//
//  Include Files.
//

#include "main.h"
#include "util.h"
#include "rc.h"
#include "mousehlp.h"


#ifndef ARRAYSIZE
#define ARRAYSIZE(x)   (sizeof(x)/sizeof((x)[0]))
#endif
//
//  Constant Declarations.
//
#define SCROLL_DEFAULT              3

#define MIN_SCROLL_LINES            1 
#define MAX_SCROLL_LINES            100

#define MAX_CHARS_FOR_SCROLL_LINES  3

#ifndef UINT_MAX
#define UINT_MAX                ((UINT)-1)
#endif




//
//  Typedef Declarations.
//


//
//  Dialog Data.
//
typedef struct tag_MouseGenStr
{

    UINT       nOrigScrollLines;    //If this is WHEEL_PAGESCROLL, then we scroll one Page at a time.
    HWND      hDlg;

} MOUSEWHLSTR, *PMOUSEWHLSTR, *LPMOUSEWHLSTR;




//
//  Context Help Ids.
//

const DWORD aMouseWheelHelpIds[] =
{
    IDC_GROUPBOX_1,                 IDH_COMM_GROUPBOX,
    IDRAD_SCROLL_LINES,             IDH_MOUSE_WHEEL_SCROLLING,
    IDRAD_SCROLL_PAGE,              IDH_MOUSE_WHEEL_SCROLLING,
    IDC_SPIN_SCROLL_LINES,          IDH_MOUSE_WHEEL_SCROLLING,
    IDT_SCROLL_FEATURE_TXT,         IDH_MOUSE_WHEEL_SCROLLING,
    IDE_BUDDY_SCROLL_LINES,         IDH_MOUSE_WHEEL_SCROLLING,
    0,0
};


////////////////////////////////////////////////////////////////////////////
//
//  EnableMouseWheelDlgControls
//
////////////////////////////////////////////////////////////////////////////
void EnableMouseWheelDlgControls(HWND hDlg, BOOL bEnable)
{
      static const UINT rgidCtl[] = {
          IDE_BUDDY_SCROLL_LINES,
          IDC_SPIN_SCROLL_LINES,
          };
 
      int i;
      for (i = 0; i < ARRAYSIZE(rgidCtl); i++)
      {
          HWND hwnd = GetDlgItem(hDlg, rgidCtl[i]);
          if (NULL != hwnd)
          {
              EnableWindow(hwnd, bEnable);
          }
      }
}
 

////////////////////////////////////////////////////////////////////////////
//
//  SetScrollWheelLines
//
////////////////////////////////////////////////////////////////////////////
void SetScrollWheelLines(HWND hDlg, BOOL bSaveSettings)
{
  UINT uNumLines = SCROLL_DEFAULT;  
  UINT uiSaveFlag = (bSaveSettings) ? SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE : FALSE;

  if (IsDlgButtonChecked(hDlg, IDRAD_SCROLL_LINES))
   {
    //Scrolling n Lines at a time

    BOOL fTranslated = FALSE;       // numeric conversion successful
    // Retrieve number of scroll-lines from edit control.
    uNumLines = GetDlgItemInt(hDlg, IDE_BUDDY_SCROLL_LINES,
                             &fTranslated, FALSE);
    if (!fTranslated)
      {
      uNumLines = SCROLL_DEFAULT;
      }
    }   
  else    
  {
  //Scrolling a page at a time
  uNumLines = WHEEL_PAGESCROLL;
  }

  SystemParametersInfo( SPI_SETWHEELSCROLLLINES,
                        uNumLines,
                        NULL,
                        uiSaveFlag);
}


////////////////////////////////////////////////////////////////////////////
//
//  DestroyMouseWheelDlg
//
////////////////////////////////////////////////////////////////////////////

void DestroyMouseWheelDlg(
    PMOUSEWHLSTR pMstr)
{
  HWND hDlg = NULL;
    
  if( pMstr )
    {
    hDlg = pMstr->hDlg;

    LocalFree( (HGLOBAL)pMstr );

    SetWindowLongPtr( hDlg, DWLP_USER, 0 );
    }
}



////////////////////////////////////////////////////////////////////////////
//
//  InitMouseWheelDlg
//
////////////////////////////////////////////////////////////////////////////

void InitMouseWheelDlg(
    HWND hDlg)
{
    PMOUSEWHLSTR pMstr = NULL;
    HWND hWndBuddy = NULL;
    UINT nScrollLines = SCROLL_DEFAULT;

    pMstr = (PMOUSEWHLSTR)LocalAlloc(LPTR, sizeof(MOUSEWHLSTR));

    if (pMstr == NULL)
    {
        return;
    }

    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pMstr);

    pMstr->hDlg = hDlg;

//////////////////////
    SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &nScrollLines, 0);
    
    if (nScrollLines < MIN_SCROLL_LINES) 
      {
      nScrollLines = SCROLL_DEFAULT;
      }
    
    pMstr->nOrigScrollLines = nScrollLines; 

    //Set the buddy window
    hWndBuddy = GetDlgItem (hDlg, IDE_BUDDY_SCROLL_LINES);
    
    SendDlgItemMessage (hDlg, IDC_SPIN_SCROLL_LINES, UDM_SETBUDDY,
                        (WPARAM)hWndBuddy, 0L);


    //Set the range.  The maximum range is UINT_MAX for the scroll-lines feature
    //but the up-down control can only accept a max value of UD_MAXVAL. Therefore,
    //the scroll-lines feature will only have a setting of UINT_MAX when user
    //explicitly specifies to scroll one page at a time.
    SendDlgItemMessage (hDlg, IDC_SPIN_SCROLL_LINES, UDM_SETRANGE, 0L,
                        MAKELONG(MAX_SCROLL_LINES, MIN_SCROLL_LINES));

    //Initialize appropriate scroll-line controls depending on value of
    //scroll-lines setting.
    if (nScrollLines > MAX_SCROLL_LINES)
      {
      EnableMouseWheelDlgControls(hDlg, FALSE);
      SetDlgItemInt (hDlg, IDE_BUDDY_SCROLL_LINES, SCROLL_DEFAULT, FALSE);
      CheckRadioButton (hDlg, IDRAD_SCROLL_LINES, IDRAD_SCROLL_PAGE, IDRAD_SCROLL_PAGE);
      }
    else
      {
      //Display current value in edit control
      SetDlgItemInt (hDlg, IDE_BUDDY_SCROLL_LINES, nScrollLines, FALSE);
     
      //Check scroll-lines or scroll-page button
      CheckRadioButton (hDlg, IDRAD_SCROLL_LINES, IDRAD_SCROLL_PAGE, IDRAD_SCROLL_LINES);                                                            
      }

    Edit_LimitText (GetDlgItem (hDlg, IDE_BUDDY_SCROLL_LINES),
                    MAX_CHARS_FOR_SCROLL_LINES);

}



////////////////////////////////////////////////////////////////////////////
//
//  MouseWheelDlg
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK MouseWheelDlg(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PMOUSEWHLSTR pMstr = NULL;
    BOOL bRet = FALSE;

    pMstr = (PMOUSEWHLSTR)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (message)
    {
        case ( WM_INITDIALOG ) :
        {
            InitMouseWheelDlg(hDlg);
            break;
        }
        case ( WM_DESTROY ) :
        {
            DestroyMouseWheelDlg(pMstr);
            break;
        }

        case WM_VSCROLL:    
          {
            SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
            break;
          }


          case ( WM_COMMAND ) :
            {
              switch (LOWORD(wParam))
              {
              case IDRAD_SCROLL_LINES:
              case IDRAD_SCROLL_PAGE :
                {
                UINT code = HIWORD(wParam);

                if (code == BN_CLICKED)
                  {
                  EnableMouseWheelDlgControls(hDlg, IsDlgButtonChecked(hDlg, IDRAD_SCROLL_LINES) );
                  // Set the property
                  SetScrollWheelLines(hDlg, FALSE);
              
                  SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                  }              
                break;
                }

              case IDE_BUDDY_SCROLL_LINES:
                {
                UINT code = HIWORD(wParam);
                if (code == EN_UPDATE)
                  {
                   BOOL fTranslated = FALSE;       // numeric conversion successful

                   // Retrieve number of scroll-lines from edit control.
                   UINT uNumLines = GetDlgItemInt(hDlg, IDE_BUDDY_SCROLL_LINES,
                                             &fTranslated, FALSE);
                   if (fTranslated)        // valid number converted from text
                   {
                      if (uNumLines >= MIN_SCROLL_LINES &&
                          uNumLines <= MAX_SCROLL_LINES)
                      {                                             // spin-control range
                         if (uNumLines != pMstr->nOrigScrollLines)  // different value
                         {
                         // Set the property
                         SetScrollWheelLines(hDlg, FALSE);
              
                         SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                        }
                      }
                      else                 // value out of range
                      {
                         fTranslated = FALSE; // discard value
                      }
                   }
                   if (!fTranslated &&  // invalid (non-numeric) data
                                        // or out of range numeric value
                        pMstr)          //and the Window has been initialized.
                   {                       
                      SetDlgItemInt (hDlg, IDE_BUDDY_SCROLL_LINES,
                                     pMstr->nOrigScrollLines, FALSE);  // unsigned
                    //MessageBeep (0xFFFFFFFF);  // chastise user
                   }
                  }
                
                }
                

              }//switch
             break;
            } //WM_COMMAND


          case ( WM_NOTIFY ) :
            {
            ASSERT (lParam);

            switch (((NMHDR *)lParam)->code)
              {
                case ( PSN_APPLY ) :
                {
                    SetScrollWheelLines(hDlg, TRUE);
                    break;
                }
                case ( PSN_RESET ) :
                {
                    //
                    //  Restore the original 
                    //
                    SystemParametersInfo( SPI_SETWHEELSCROLLLINES,
                                            pMstr->nOrigScrollLines,
                                            NULL,
                                            FALSE);                    
                    break;
                }
                default :
                {
                    return (FALSE);
                }
            
              }
            break;
            }

          case ( WM_HELP ) :             // F1
            {
              WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                       HELP_FILE,
                       HELP_WM_HELP,
                       (DWORD_PTR)(LPTSTR)aMouseWheelHelpIds );
              break;
            }

          case ( WM_CONTEXTMENU ) :      // right mouse click
            {
              WinHelp( (HWND)wParam,
                       HELP_FILE,
                       HELP_CONTEXTMENU,
                       (DWORD_PTR)(LPTSTR)aMouseWheelHelpIds );
              break;
            }

          case ( WM_DISPLAYCHANGE ) :
          case ( WM_WININICHANGE ) :
          case ( WM_SYSCOLORCHANGE ) :
            {
              SHPropagateMessage(hDlg, message, wParam, lParam, TRUE);
              return TRUE;
            }
            
        default :
          {
              return (FALSE);
          }
    }

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\main\util.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    util.c

Abstract:

    This module contains the utility routines for this project.

Revision History:

--*/



//
//  Include Files.
//

#include "main.h"
#include "util.h"
#include "rc.h"

//
// From shell\inc\shsemip.h
//
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))


//
//  Global Variables.
//

extern HINSTANCE g_hInst;





////////////////////////////////////////////////////////////////////////////
//
//  HourGlass
//
////////////////////////////////////////////////////////////////////////////

void HourGlass(
    BOOL fOn)
{
   if (!GetSystemMetrics(SM_MOUSEPRESENT))
   {
      ShowCursor(fOn);
   }
   SetCursor(LoadCursor(NULL, (fOn ? IDC_WAIT : IDC_ARROW)));
}


////////////////////////////////////////////////////////////////////////////
//
//  MyMessageBox
//
////////////////////////////////////////////////////////////////////////////

#ifdef WINNT

int MyMessageBox(
    HWND hWnd,
    UINT uText,
    UINT uCaption,
    UINT uType,
    ...)
{
    TCHAR szText[4 * PATHMAX], szCaption[2 * PATHMAX];
    int result;
    va_list parg;

    va_start(parg, uType);

    LoadString(g_hInst, uText, szCaption, ARRAYSIZE(szCaption));

    wvsprintf(szText, szCaption, parg);

    LoadString(g_hInst, uCaption, szCaption, ARRAYSIZE(szCaption));

    result = MessageBox(hWnd, szText, szCaption, uType);

    va_end(parg);

    return (result);
}

#else

int MyMessageBox(
    HWND hWnd,
    UINT uText,
    UINT uCaption,
    UINT uType,
    ...)
{
    TCHAR szText[256 + PATHMAX], szCaption[256];
    int result;


    LoadString(g_hInst, uText, szCaption, ARRAYSIZE(szCaption));

    wvsprintf(szText, szCaption, (LPTSTR)(&uType + 1));

    LoadString(g_hInst, uCaption, szCaption, ARRAYSIZE(szCaption));

    result = MessageBox(hWnd, szText, szCaption, uType);

    return (result);
}

#endif


////////////////////////////////////////////////////////////////////////////
//
//  TrackInit
//
////////////////////////////////////////////////////////////////////////////

void TrackInit(
    HWND hwndScroll,
    int nCurrent,
    PARROWVSCROLL pAVS)
{
    SendMessage(hwndScroll, TBM_SETRANGE, 0, MAKELONG(pAVS->bottom, pAVS->top));
    SendMessage(hwndScroll, TBM_SETPOS, TRUE, (LONG)nCurrent);
}


////////////////////////////////////////////////////////////////////////////
//
//  TrackMessage
//
////////////////////////////////////////////////////////////////////////////

int TrackMessage(
    WPARAM wParam,
    LPARAM lParam,
    PARROWVSCROLL pAVS)
{
    return ((int)SendMessage((HWND)lParam, TBM_GETPOS, 0, 0L));
}

////////////////////////////////////////////////////////////////////////////
//
//  HardwareDlg_OnInitDialog
//
//  Load the real hardware tab out of devmgr.dll.
//
//  DWLP_USER     - HWND of inner page
//
////////////////////////////////////////////////////////////////////////////

// There is no devmgr.h (go figure) so we must declare it ourselves.

EXTERN_C DECLSPEC_IMPORT HWND STDAPICALLTYPE
DeviceCreateHardwarePage(HWND hwndParent, const GUID *pguid);

void
HardwareDlg_OnInitDialog(HWND hdlg, LPARAM lp)
{
    PCHWPAGEINFO phpi = (PCHWPAGEINFO)((LPPROPSHEETPAGE)lp)->lParam;
    HWND hwndHW = DeviceCreateHardwarePage(hdlg, &phpi->guidClass);

    if (hwndHW) {
        TCHAR tszTshoot[MAX_PATH];
        SetWindowLongPtr(hdlg, DWLP_USER, (LONG_PTR)hwndHW);
        if (LoadString(g_hInst, phpi->idsTshoot, tszTshoot, ARRAYSIZE(tszTshoot))) {
            SetWindowText(hwndHW, tszTshoot);
        }
    } else {
        DestroyWindow(hdlg); // catastrophic failure
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  HardwareDlg
//
//  The dialog procedure for generic hardware tabs.
//
//  GWLP_USERDATA - HINSTANCE of devmgr.dll
//  DWLP_USER     - HWND of inner page
//
//
////////////////////////////////////////////////////////////////////////////

typedef HWND (WINAPI *DEVICECREATEHARDWAREPAGE)
        (HWND hwndParent, const GUID *pguid);

INT_PTR CALLBACK HardwareDlg(HWND hdlg, UINT uMsg, WPARAM wp, LPARAM lp)
{
    switch (uMsg) {

    case WM_INITDIALOG:
        HardwareDlg_OnInitDialog(hdlg, lp);
        return TRUE;
    }
    return FALSE;
}

////////////////////////////////////////////////////////////////////////////
//
//  CreateHardwarePage
//
////////////////////////////////////////////////////////////////////////////

HPROPSHEETPAGE
CreateHardwarePage(PCHWPAGEINFO phpi)
{
    PROPSHEETPAGE psp;

    // No hardware tab if we are a remote TS session, since we would end
    // up showing the properties of the server, not the client, and that
    // would be too confusing.
    if (GetSystemMetrics(SM_REMOTESESSION))
        return NULL;

    // No hardware tab if it's been disabled via policy.
    if (SHRestricted(REST_NOHARDWARETAB))
        return NULL;

    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_DEFAULT;
    psp.hInstance   = g_hInst;
    psp.pszTemplate = MAKEINTRESOURCE(DLG_HARDWARE);
    psp.pfnDlgProc  = HardwareDlg;
    psp.lParam      = (LPARAM)phpi;

    return CreatePropertySheetPage(&psp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\main\util.h ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    util.h

Abstract:

    This module contains the header information for the utility routines
    for this project.

Revision History:

--*/



#ifndef _UTIL_H
#define _UTIL_H



void
HourGlass(
    BOOL fOn);

int
MyMessageBox(
    HWND hWnd,
    UINT uText,
    UINT uCaption,
    UINT uType,
    ...);

void
TrackInit(
    HWND hwndScroll,
    int nCurrent,
    PARROWVSCROLL pAVS);

int
TrackMessage(
    WPARAM wParam,
    LPARAM lParam,
    PARROWVSCROLL pAVS);

typedef struct HWPAGEINFO {
    GUID    guidClass;                  // Setup device class
    UINT    idsTshoot;                  // Troubleshooter string
} HWPAGEINFO, *PHWPAGEINFO;
typedef const HWPAGEINFO *PCHWPAGEINFO;

HPROPSHEETPAGE
CreateHardwarePage(PCHWPAGEINFO phpi);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\main\mouseptr.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    mouseptr.c

Abstract:

    This module contains the routines for the Mouse Pointer Property Sheet
    page.

Revision History:

--*/



//
//  Include Files.
//

#include "main.h"
#include "rc.h"
#include "mousehlp.h"
#include <regstr.h>

//
// From shell\inc\shsemip.h
//
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))



//
//  Constant Declarations.
//

#define gcxAvgChar              8

#define MAX_SCHEME_NAME_LEN     64
#define MAX_SCHEME_SUFFIX       32      // length of " (system scheme)" - update if more space is needed
#define OVERWRITE_TITLE         32      // length of title for the confirm overwrite dialog
#define OVERWRITE_MSG           200     // length of the message for the overwrite dialog

#define PM_NEWCURSOR            (WM_USER + 1)
#define PM_PAUSEANIMATION       (WM_USER + 2)
#define PM_UNPAUSEANIMATION     (WM_USER + 3)

#define ID_PREVIEWTIMER         1

#define CCH_ANISTRING           80

#define CIF_FILE        0x0001
#define CIF_MODIFIED    0x0002
#define CIF_SHARED      0x0004

#define IDT_BROWSE 1




//
//  Typedef Declarations.
//

typedef struct _CURSOR_INFO
{
    DWORD    fl;
    HCURSOR  hcur;
    int      ccur;
    int      icur;
    TCHAR    szFile[MAX_PATH];
} CURSOR_INFO, *PCURSOR_INFO;

#pragma pack(2)
typedef struct tagNEWHEADER
{
    WORD reserved;
    WORD rt;
    WORD cResources;
} NEWHEADER, *LPNEWHEADER;
#pragma pack()

typedef struct
{
    UINT   idVisName;
    int    idResource;
    int    idDefResource;
    LPTSTR pszIniName;
    TCHAR  szVisName[MAX_PATH];
} CURSORDESC, *PCURSORDESC;

//
// Structure that contains data used within a preview window.  This
// data is unique for each preview window, and is used to optimize
// the painting.
//
typedef struct
{
    HDC          hdcMem;
    HBITMAP      hbmMem;
    HBITMAP      hbmOld;
    PCURSOR_INFO pcuri;
} PREVIEWDATA, *PPREVIEWDATA;


typedef struct _MOUSEPTRBR
{
    HWND        hDlg;
    CURSOR_INFO curi;
} MOUSEPTRBR, *PMOUSEPTRBR;




//
//  Global Variables.
//

extern HINSTANCE g_hInst;    // from main.c
int gcxCursor, gcyCursor;
HWND ghwndDlg, ghwndFile, ghwndFileH, ghwndTitle, ghwndTitleH;
HWND ghwndCreator, ghwndCreatorH, ghwndCursors, ghwndPreview, ghwndSchemeCB;
HBRUSH ghbrHighlight, ghbrHighlightText, ghbrWindow, ghbrButton;

UINT guTextHeight = 0;
UINT guTextGap = 0;

COLORREF gcrHighlightText;

TCHAR gszFileName2[MAX_PATH];

UINT wBrowseHelpMessage;

LPTSTR gszFileNotFound = NULL;
LPTSTR gszBrowse = NULL;
LPTSTR gszFilter = NULL;

TCHAR gszNoMem[256] = TEXT("No Memory");

HHOOK ghhkMsgFilter;         // hook handle for message filter function

static const TCHAR szRegStr_Setup[] = REGSTR_PATH_SETUP TEXT("\\Setup");
static const TCHAR szSharedDir[]    = TEXT("SharedDir");

BOOL gfCursorShadow = FALSE;

//
//  Make sure you add new cursors to the end of this array.
//  Otherwise the cursor schemes will not work
//
CURSORDESC gacd[] =
{
    { IDS_ARROW,       OCR_NORMAL,      OCR_ARROW_DEFAULT,       TEXT("Arrow"),       TEXT("") },
    { IDS_HELPCUR,     OCR_HELP,        OCR_HELP_DEFAULT,        TEXT("Help"),        TEXT("") },
    { IDS_APPSTARTING, OCR_APPSTARTING, OCR_APPSTARTING_DEFAULT, TEXT("AppStarting"), TEXT("") },
    { IDS_WAIT,        OCR_WAIT,        OCR_WAIT_DEFAULT,        TEXT("Wait"),        TEXT("") },
    { IDS_CROSS,       OCR_CROSS,       OCR_CROSS_DEFAULT,       TEXT("Crosshair"),   TEXT("") },
    { IDS_IBEAM,       OCR_IBEAM,       OCR_IBEAM_DEFAULT,       TEXT("IBeam"),       TEXT("") },
    { IDS_NWPEN,       OCR_NWPEN,       OCR_NWPEN_DEFAULT,       TEXT("NWPen"),       TEXT("") },
    { IDS_NO,          OCR_NO,          OCR_NO_DEFAULT,          TEXT("No"),          TEXT("") },
    { IDS_SIZENS,      OCR_SIZENS,      OCR_SIZENS_DEFAULT,      TEXT("SizeNS"),      TEXT("") },
    { IDS_SIZEWE,      OCR_SIZEWE,      OCR_SIZEWE_DEFAULT,      TEXT("SizeWE"),      TEXT("") },
    { IDS_SIZENWSE,    OCR_SIZENWSE,    OCR_SIZENWSE_DEFAULT,    TEXT("SizeNWSE"),    TEXT("") },
    { IDS_SIZENESW,    OCR_SIZENESW,    OCR_SIZENESW_DEFAULT,    TEXT("SizeNESW"),    TEXT("") },
    { IDS_SIZEALL,     OCR_SIZEALL,     OCR_SIZEALL_DEFAULT,     TEXT("SizeAll"),     TEXT("") },
    { IDS_UPARROW,     OCR_UP,          OCR_UPARROW_DEFAULT,     TEXT("UpArrow"),     TEXT("") },
    { IDS_HANDCUR,     OCR_HAND,        OCR_HAND_DEFAULT,        TEXT("Hand"),        TEXT("") },
};

#define CCURSORS   (sizeof(gacd) / sizeof(gacd[0]))

CURSOR_INFO acuri[CCURSORS];

//
//  Registry Keys.
//
const TCHAR szCursorSubdir[]  = TEXT("Cursors");
const TCHAR szCursorRegPath[] = REGSTR_PATH_CURSORS;

static const TCHAR c_szRegPathCursors[] = REGSTR_PATH_CURSORS;
static const TCHAR c_szSchemes[]        = TEXT("Schemes");

static const TCHAR c_szRegPathCursorSchemes[] = REGSTR_PATH_CURSORS TEXT( "\\Schemes" );

//
//  Strings used to read from the combo box must be larger than max length.
//
TCHAR gszSchemeName[MAX_SCHEME_SUFFIX + MAX_SCHEME_NAME_LEN + 1];    // used to store selected scheme name for saving
int iSchemeLocation;        // used to store scheme location (HKCU vs HKLM)

static const TCHAR c_szRegPathSystemSchemes[] = REGSTR_PATH_SETUP TEXT("\\Control Panel\\Cursors\\Schemes");
TCHAR szSystemScheme[MAX_SCHEME_SUFFIX];
TCHAR szNone[MAX_SCHEME_NAME_LEN + 1];
const TCHAR szSchemeSource[] = TEXT("Scheme Source");

TCHAR gszPreviousScheme[MAX_SCHEME_SUFFIX + MAX_SCHEME_NAME_LEN + 1];   // used to tell if a different scheme is selected

#define ID_NONE_SCHEME    0
#define ID_USER_SCHEME    1
#define ID_OS_SCHEME      2




//
//  Context Help Ids.
//

const static DWORD aMousePtrHelpIDs[] =
{
    IDC_GROUPBOX_1,    IDH_COMM_GROUPBOX,
    ID_SCHEMECOMBO,    IDH_MOUSE_POINT_SCHEME,
    ID_SAVESCHEME,     IDH_MOUSE_POINT_SAVEAS,
    ID_REMOVESCHEME,   IDH_MOUSE_POINT_DEL,
    ID_PREVIEW,        IDH_MOUSE_POINT_PREVIEW,
    ID_CURSORLIST,     IDH_MOUSE_POINT_LIST,
    ID_DEFAULT,        IDH_MOUSE_POINT_DEFAULT,
    ID_BROWSE,         IDH_MOUSE_POINT_BROWSE,
    ID_CURSORSHADOW,   IDH_MOUSE_CURSORSHADOW,

    0, 0
};

const static DWORD aMousePtrBrowseHelpIDs[] =
{
    IDC_GROUPBOX_1,    IDH_MOUSE_POINT_PREVIEW,
    ID_CURSORPREVIEW,  IDH_MOUSE_POINT_PREVIEW,

    0, 0
};

const static DWORD aHelpIDs[] =
{
    ID_SCHEMEFILENAME, IDH_MOUSE_NEW_SCHEME_NAME,

    0, 0
};




//
//  Forward Declarations.
//

void LoadCursorSet(HWND hwnd);

void CreateBrushes(void);

LPTSTR GetResourceString(HINSTANCE hmod,int id);

void DrawCursorListItem(DRAWITEMSTRUCT *pdis);

BOOL GetCursorFromFile(CURSOR_INFO *pcuri);

BOOL Browse(HWND hwndOwner);

void CleanUpEverything(void);

VOID UpdateCursorList(void);

VOID NextFrame(HWND hwnd);

void HourGlass(BOOL fOn);

BOOL TryToLoadCursor(
    HWND hwnd,
    int i,
    CURSOR_INFO *pcuri);

BOOL LoadScheme(void);

BOOL SaveScheme(void);

BOOL SaveSchemeAs(void);

void SaveCurSchemeName(void);

BOOL RemoveScheme(void);

BOOL InitSchemeComboBox(void);

BOOL SchemeUpdate(int i);

LPTSTR MakeFilename(LPTSTR sz);

INT_PTR CALLBACK SaveSchemeDlgProc(
    HWND  hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);

void CurStripBlanks(LPTSTR pszString);

int SystemOrUser(TCHAR *pszSchemeName);

BOOL UnExpandPath( LPTSTR pszPath );




////////////////////////////////////////////////////////////////////////////
//
//  RegisterPointerStuff
//
////////////////////////////////////////////////////////////////////////////

BOOL RegisterPointerStuff(
    HINSTANCE hi)
{
    gcxCursor = GetSystemMetrics(SM_CXCURSOR);
    gcyCursor = GetSystemMetrics(SM_CYCURSOR);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitCursorsShadow
//
////////////////////////////////////////////////////////////////////////////

void InitCursorShadow(HWND hwnd)
{
    BOOL fPalette;
    HDC hdc;
    int nCommand;

    hdc = GetDC(NULL);
    fPalette = (GetDeviceCaps(hdc, NUMCOLORS) != -1);
    ReleaseDC(NULL, hdc);

    if (!fPalette) {
        nCommand = SW_SHOW;
    } else {
        nCommand = SW_HIDE;
    }
    ShowWindow(GetDlgItem(hwnd, ID_CURSORSHADOW), nCommand);

    if (nCommand == SW_SHOW) {
        SystemParametersInfo(SPI_GETCURSORSHADOW, 0, (PVOID)&gfCursorShadow, 0);
        CheckDlgButton(hwnd, ID_CURSORSHADOW, gfCursorShadow);
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  InitCursorsDlg
//
////////////////////////////////////////////////////////////////////////////

BOOL InitCursorsDlg(
    HWND hwnd)
{
    int i;

    ghwndDlg = hwnd;
    gszPreviousScheme[0] = TEXT('\0');

    //
    //  Register the help message from the File Open (Browse) dialog.
    //
    wBrowseHelpMessage = RegisterWindowMessage(HELPMSGSTRING);

    //
    //  Load Strings.
    //
    if (gszFileNotFound == NULL)
    {
        gszFileNotFound = GetResourceString(g_hInst, IDS_CUR_BADFILE);

        if (gszFileNotFound == NULL)
        {
            return (FALSE);
        }
    }

    if (gszBrowse == NULL)
    {
        gszBrowse = GetResourceString(g_hInst, IDS_CUR_BROWSE);

        if (gszBrowse == NULL)
        {
            return (FALSE);
        }
    }

#ifdef WINNT
    if (gszFilter == NULL)
    {
        gszFilter = GetResourceString(g_hInst, IDS_ANICUR_FILTER);

        if (!gszFilter)
        {
            return (FALSE);
        }
    }
#else
    if (gszFilter == NULL)
    {
        HDC  dc = GetDC(NULL);
        BOOL fAni = (GetDeviceCaps(dc, CAPS1) & C1_COLORCURSOR) != 0;

        ReleaseDC(NULL, dc);

        gszFilter = GetResourceString( g_hInst,
                                       fAni
                                         ? IDS_ANICUR_FILTER
                                         : IDS_CUR_FILTER );

        if (!gszFilter)
        {
            return (FALSE);
        }
    }
#endif

    //
    //  Load description strings from the resource file.
    //
    for (i = 0; i < CCURSORS; i++)
    {
        if ((!gacd[i].idVisName) ||
            (LoadString( g_hInst,
                         gacd[i].idVisName,
                         gacd[i].szVisName,
                         ARRAYSIZE(gacd[i].szVisName) ) <= 0))
        {
            //
            //  Show something.
            //
            lstrcpy(gacd[i].szVisName, gacd[i].pszIniName);
        }
    }

    //
    //  As an optimization, remember the window handles of the cursor
    //  information fields.
    //
    ghwndPreview  = GetDlgItem(hwnd, ID_PREVIEW);
    ghwndFile     = GetDlgItem(hwnd, ID_FILE);
    ghwndFileH    = GetDlgItem(hwnd, ID_FILEH);
    ghwndTitle    = GetDlgItem(hwnd, ID_TITLE);
    ghwndTitleH   = GetDlgItem(hwnd, ID_TITLEH);
    ghwndCreator  = GetDlgItem(hwnd, ID_CREATOR);
    ghwndCreatorH = GetDlgItem(hwnd, ID_CREATORH);
    ghwndCursors  = GetDlgItem(hwnd, ID_CURSORLIST);
    ghwndSchemeCB = GetDlgItem(hwnd, ID_SCHEMECOMBO);

    //
    //  Create some brushes we'll be using.
    //
    CreateBrushes();

    //
    //  Initialize the scheme combo box.
    //
    InitSchemeComboBox();

    //
    //  Pre-clear the cursor info array.
    //
    ZeroMemory(&acuri, sizeof(acuri));

    //
    //  Load the cursors.
    //
    LoadCursorSet(hwnd);

    //
    //  Force an update of the preview window and the cursor details.
    //
    UpdateCursorList();

    InitCursorShadow(hwnd);

    return (TRUE);
}



////////////////////////////////////////////////////////////////////////////
//
//  LoadCursorSet
//
////////////////////////////////////////////////////////////////////////////

void LoadCursorSet(
    HWND hwnd)
{
    CURSOR_INFO *pcuri;
    HKEY hkCursors;
    int i;

    if (RegOpenKey( HKEY_CURRENT_USER,
                    szCursorRegPath,
                    &hkCursors ) != ERROR_SUCCESS)
    {
        hkCursors = NULL;
    }

    for (pcuri = &acuri[0], i = 0; i < CCURSORS; i++, pcuri++)
    {
        if ( hkCursors )
        {
            DWORD dwType;
            DWORD dwCount = sizeof(pcuri->szFile);

            DWORD dwErr = RegQueryValueEx( hkCursors,
                              gacd[i].pszIniName,
                              NULL,
                              &dwType,
                              (LPBYTE)pcuri->szFile,
                              &dwCount );

            if (dwErr == ERROR_SUCCESS)
            {
                if (TryToLoadCursor(hwnd, i, pcuri))
                {
                    goto EverythingWorked;
                }
            }
        }

        // This is actually the failure case.  We load the default cursor.
        pcuri->hcur =
            (HCURSOR)LoadImage( NULL,
                                MAKEINTRESOURCE(gacd[i].idResource),
                                IMAGE_CURSOR,
                                0,
                                0,
                                LR_SHARED | LR_DEFAULTSIZE | LR_ENVSUBST );

        pcuri->fl |= CIF_SHARED;

EverythingWorked:

        SendMessage(ghwndCursors, LB_ADDSTRING, 0, (LPARAM)gacd[i].szVisName);
        SendMessage(ghwndCursors, LB_SETITEMDATA, i, i);
    }

    if (hkCursors)
    {
        RegCloseKey(hkCursors);
    }

    SendMessage(ghwndCursors, LB_SETCURSEL, 0, 0);
}


////////////////////////////////////////////////////////////////////////////
//
//  CreateBrushes
//
//  Creates the brushes that are used to paint within the Cursors applet.
//
////////////////////////////////////////////////////////////////////////////

VOID CreateBrushes()
{
    ghbrHighlight     = GetSysColorBrush(COLOR_HIGHLIGHT);
    gcrHighlightText  = GetSysColor(COLOR_HIGHLIGHTTEXT);
    ghbrHighlightText = GetSysColorBrush(COLOR_HIGHLIGHTTEXT);
    ghbrWindow        = GetSysColorBrush(COLOR_WINDOW);
    ghbrButton        = GetSysColorBrush(COLOR_BTNFACE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetResourceString
//
//  Gets a string out of the resource file.
//
////////////////////////////////////////////////////////////////////////////

LPTSTR GetResourceString(
    HINSTANCE hmod,
    int id)
{
    TCHAR szBuffer[256];
    LPTSTR psz;
    int cch;

    if ((cch = LoadString(hmod, id, szBuffer, ARRAYSIZE(szBuffer))) == 0)
    {
        return (NULL);
    }

    psz = LocalAlloc(LPTR, (cch + 1) * sizeof(TCHAR));

    if (psz != NULL)
    {
        int i;

        for (i = 0; i <= cch; i++)
        {
            psz[i] = (szBuffer[i] == TEXT('\1')) ? TEXT('\0') : szBuffer[i];
        }
    }

    return (psz);
}


////////////////////////////////////////////////////////////////////////////
//
//  FreeItemCursor
//
////////////////////////////////////////////////////////////////////////////

void FreeItemCursor(
    CURSOR_INFO *pcuri)
{
    if (pcuri->hcur)
    {
        if (!(pcuri->fl & CIF_SHARED))
        {
            DestroyCursor(pcuri->hcur);
        }
        pcuri->hcur = NULL;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  MousePtrDlg
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK MousePtrDlg(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    CURSOR_INFO *pcuri;
    HKEY hkCursors;
    int i;

    switch (msg)
    {
        case ( WM_INITDIALOG ) :
        {
            return InitCursorsDlg(hwnd);
        }
        case ( WM_DISPLAYCHANGE ) :
        {
            InitCursorShadow(hwnd);
            SHPropagateMessage(hwnd, msg, wParam, lParam, TRUE);
            break;
        }
        case ( WM_MEASUREITEM ) :
        {
            ((MEASUREITEMSTRUCT *)lParam)->itemHeight = gcyCursor + 2;
            break;
        }
        case ( WM_DRAWITEM ) :
        {
            DrawCursorListItem((DRAWITEMSTRUCT *)lParam);
            break;
        }
        case ( WM_COMMAND ) :
        {
            switch (LOWORD(wParam))
            {
                case ( ID_SCHEMECOMBO ) :
                {
                    switch (HIWORD(wParam))
                    {
                        case ( CBN_SELCHANGE ) :
                        {
                            LoadScheme();
                            break;
                        }
                    }
                    break;
                }
                case ( ID_DEFAULT ) :
                {
                    //
                    //  Throw away any fancy new cursor and replace it with
                    //  the system's original.
                    //
                    i = (int)SendMessage(ghwndCursors, LB_GETCURSEL, 0, 0);

                    pcuri = &acuri[i];

                    if (!(pcuri->fl & CIF_FILE))
                    {
                        break;
                    }
                    pcuri->fl = CIF_MODIFIED;

                    SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM)hwnd, 0L);

                    FreeItemCursor(pcuri);

                    pcuri->hcur =
                        (HCURSOR)LoadImage( NULL,
                                            MAKEINTRESOURCE(gacd[i].idDefResource),
                                            IMAGE_CURSOR,
                                            0,
                                            0,
                                            LR_DEFAULTSIZE | LR_ENVSUBST );

                    *pcuri->szFile = TEXT('\0');

                    EnableWindow(GetDlgItem(hwnd, ID_SAVESCHEME), TRUE);

                    UpdateCursorList();

                    break;
                }
                case ( ID_CURSORLIST ) :
                {
                    switch (HIWORD(wParam))
                    {
                        case ( LBN_SELCHANGE ) :
                        {
                            i = (int)SendMessage((HWND)lParam, LB_GETCURSEL, 0, 0);
                            pcuri = &acuri[i];

                            //
                            //  Show a preview (including animation) in the
                            //  preview window.
                            //
                            SendMessage( ghwndPreview,
                                         STM_SETICON,
                                         (WPARAM)pcuri->hcur,
                                         0L );

                            //
                            //  Enable the "Set Default" button if the cursor
                            //  is from a file.
                            //
                            EnableWindow( GetDlgItem(hwnd, ID_DEFAULT),
                                          (pcuri->fl & CIF_FILE ) ? TRUE : FALSE );
                            break;
                        }
                        case ( LBN_DBLCLK ) :
                        {
                            Browse(hwnd);
                            break;
                        }
                    }
                    break;
                }
                case ( ID_BROWSE ) :
                {
                    Browse(hwnd);
                    break;
                }
                case ( ID_SAVESCHEME ) :
                {
                    SaveSchemeAs();
                    break;
                }
                case ( ID_REMOVESCHEME ) :
                {
                    RemoveScheme();
                    break;
                }
                case ( ID_CURSORSHADOW ) :
                {
                    gfCursorShadow = IsDlgButtonChecked(hwnd, ID_CURSORSHADOW);
                    SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM)hwnd, 0L);
                    break;
                }
            }
            break;
        }
        case ( WM_NOTIFY ) :
        {
            switch(((NMHDR *)lParam)->code)
            {
                case ( PSN_APPLY ) :
                {
                    //
                    //  Change cursor to hour glass.
                    //
                    HourGlass(TRUE);

                    // Set cursor shadow
                    SystemParametersInfo( SPI_SETCURSORSHADOW,
                                          0,
                                          IntToPtr(gfCursorShadow),
                                          SPIF_UPDATEINIFILE);

                    //
                    //  Save the modified scheme, order of calls important.
                    //
                    SaveCurSchemeName();

                    //
                    //  Set the system cursors.
                    //
                    if (RegCreateKey( HKEY_CURRENT_USER,
                                      szCursorRegPath,
                                      &hkCursors ) == ERROR_SUCCESS)
                    {
                        for (pcuri = &acuri[0], i = 0; i < CCURSORS; i++, pcuri++)
                        {
                            if (pcuri->fl & CIF_MODIFIED)
                            {
                                LPCTSTR data;
                                UINT count;

                                // Always unexpand before we save a filename
                                UnExpandPath(pcuri->szFile);

                                data = (pcuri->fl & CIF_FILE) ? pcuri->szFile : TEXT("");
                                count = (pcuri->fl & CIF_FILE) ? (lstrlen(pcuri->szFile) + 1) * sizeof(TCHAR) : sizeof(TCHAR);

                                RegSetValueEx( hkCursors,
                                               gacd[i].pszIniName,
                                               0L,
                                               REG_EXPAND_SZ,
                                               (CONST LPBYTE)data,
                                               count );
                            }
                        }

                        RegCloseKey(hkCursors);

                        SystemParametersInfo( SPI_SETCURSORS,
                                              0,
                                              0,
                                              SPIF_SENDCHANGE );
                    }

                    HourGlass(FALSE);
                    break;
                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }
        case ( WM_SYSCOLORCHANGE ) :
        {
            gcrHighlightText = GetSysColor(COLOR_HIGHLIGHTTEXT);
            SHPropagateMessage(hwnd, msg, wParam, lParam, TRUE);
            break;
        }

        case ( WM_WININICHANGE ) :
        {
            SHPropagateMessage(hwnd, msg, wParam, lParam, TRUE);
            break;
        }

        case ( WM_DESTROY ) :
        {
            //
            //  Clean up global allocs.
            //
            CleanUpEverything();

            if (gszFileNotFound != NULL)
            {
                LocalFree(gszFileNotFound);
                gszFileNotFound = NULL;
            }

            if (gszBrowse != NULL)
            {
                LocalFree(gszBrowse);
                gszBrowse = NULL;
            }

            if (gszFilter != NULL)
            {
                LocalFree(gszFilter);
                gszFilter = NULL;
            }
            break;
        }
        case ( WM_HELP ) :
        {
            WinHelp( ((LPHELPINFO)lParam)->hItemHandle,
                     HELP_FILE,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aMousePtrHelpIDs );
            break;
        }
        case ( WM_CONTEXTMENU ) :
        {
            WinHelp( (HWND)wParam,
                     HELP_FILE,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPVOID)aMousePtrHelpIDs );
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawCursorListItem
//
////////////////////////////////////////////////////////////////////////////

void DrawCursorListItem(
    DRAWITEMSTRUCT *pdis)
{
    CURSOR_INFO *pcuri;
    COLORREF clrOldText, clrOldBk;
    RECT rc;
    DWORD dwLayout;

    if (!guTextHeight || !guTextGap)
    {
        TEXTMETRIC tm;

        tm.tmHeight = 0;
        GetTextMetrics(pdis->hDC, &tm);

        if (tm.tmHeight < 0)
        {
            tm.tmHeight *= -1;
        }
        guTextHeight = (UINT)tm.tmHeight;
        guTextGap = (UINT)tm.tmAveCharWidth;
    }

    pcuri = &acuri[pdis->itemData];

    if (pdis->itemState & ODS_SELECTED)
    {
        clrOldText = SetTextColor(pdis->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
        clrOldBk = SetBkColor(pdis->hDC, GetSysColor(COLOR_HIGHLIGHT));
    }
    else
    {
        clrOldText = SetTextColor(pdis->hDC, GetSysColor(COLOR_WINDOWTEXT));
        clrOldBk = SetBkColor(pdis->hDC, GetSysColor(COLOR_WINDOW));
    }

    ExtTextOut( pdis->hDC,
                pdis->rcItem.left + guTextGap,   // fudge factor
                (pdis->rcItem.top + pdis->rcItem.bottom - guTextHeight) / 2,
                ETO_OPAQUE,
                &pdis->rcItem,
                gacd[pdis->itemData].szVisName,
                lstrlen(gacd[pdis->itemData].szVisName),
                NULL );

    if (pcuri->hcur != NULL)
    {
        dwLayout = GetLayout(pdis->hDC);
        SetLayout(pdis->hDC, dwLayout | LAYOUT_BITMAPORIENTATIONPRESERVED);
        DrawIcon( pdis->hDC,
                  pdis->rcItem.right - (gcxCursor + guTextGap),
                  pdis->rcItem.top + 1, pcuri->hcur );
        SetLayout(pdis->hDC, dwLayout);
    }

    if (pdis->itemState & ODS_FOCUS)
    {
        CopyRect(&rc, &pdis->rcItem);
        InflateRect(&rc, -1, -1);
        DrawFocusRect(pdis->hDC, &rc);
    }

    SetTextColor(pdis->hDC, clrOldText);
    SetBkColor(pdis->hDC, clrOldBk);
}


////////////////////////////////////////////////////////////////////////////
//
//  TryToLoadCursor
//
////////////////////////////////////////////////////////////////////////////

BOOL TryToLoadCursor(
    HWND hwnd,
    int i,
    CURSOR_INFO *pcuri)
{
    BOOL fRet    = TRUE;
    BOOL bCustom = (*pcuri->szFile != 0);


    if (bCustom && !GetCursorFromFile(pcuri))
    {
        HWND hwndControl = GetParent(hwnd);
        LPTSTR pszText;
        LPTSTR pszFilename;

        //
        //  MakeFilename returns the address of a global, so we don't
        //  need to free pszFilename.
        //
        pszFilename = MakeFilename(pcuri->szFile);

        pszText = LocalAlloc( LPTR,
                              (lstrlen(gszFileNotFound) +
                               lstrlen(gacd[i].szVisName) +
                               lstrlen(pszFilename) +
                               1) * sizeof(TCHAR) );

        if (pszText == NULL)
        {
            return (FALSE);
        }

        wsprintf(pszText, gszFileNotFound, pszFilename, gacd[i].szVisName);

        MessageBeep(MB_ICONEXCLAMATION);

        MessageBox(hwndControl, pszText, NULL, MB_ICONEXCLAMATION | MB_OK);

        pcuri->fl = CIF_MODIFIED;

        SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM)hwnd, 0L);

        bCustom = FALSE;

        LocalFree(pszText);
    }

    if (!bCustom)
    {
        FreeItemCursor(pcuri);

        pcuri->hcur =
            (HCURSOR)LoadImage( NULL,
                                MAKEINTRESOURCE(gacd[i].idDefResource),
                                IMAGE_CURSOR,
                                0,
                                0,
                                LR_DEFAULTSIZE | LR_ENVSUBST );

        *pcuri->szFile = TEXT('\0');

        EnableWindow(GetDlgItem(hwnd, ID_SAVESCHEME), TRUE);
        UpdateCursorList();
    }

    return (pcuri->hcur != NULL);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetCursorFromFile
//
////////////////////////////////////////////////////////////////////////////

BOOL GetCursorFromFile(
    CURSOR_INFO *pcuri)
{
    pcuri->fl = 0;
    pcuri->hcur =
        (HCURSOR)LoadImage( NULL,
                            MakeFilename(pcuri->szFile),
                            IMAGE_CURSOR,
                            0,
                            0,
                            LR_LOADFROMFILE | LR_DEFAULTSIZE | LR_ENVSUBST );

    if (pcuri->hcur)
    {
        pcuri->fl |= CIF_FILE;
    }

    return (pcuri->hcur != NULL);
}


////////////////////////////////////////////////////////////////////////////
//
//  MousePtrBrowsePreview
//
////////////////////////////////////////////////////////////////////////////

void MousePtrBrowsePreview(
    HWND hDlg)
{
    PMOUSEPTRBR pPtrBr;
    HCURSOR hcurOld;

    pPtrBr = (PMOUSEPTRBR)GetWindowLongPtr(hDlg, DWLP_USER);

    hcurOld = pPtrBr->curi.hcur;

    CommDlg_OpenSave_GetFilePath( GetParent(hDlg),
                                  pPtrBr->curi.szFile,
                                  ARRAYSIZE(pPtrBr->curi.szFile) );

    if (!GetCursorFromFile(&pPtrBr->curi))
    {
        pPtrBr->curi.hcur = NULL;
    }

    SendDlgItemMessage( hDlg,
                        ID_CURSORPREVIEW,
                        STM_SETICON,
                        (WPARAM)pPtrBr->curi.hcur, 0L );

    if (hcurOld)
    {
        DestroyCursor(hcurOld);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  MousePtrBrowseNotify
//
////////////////////////////////////////////////////////////////////////////

BOOL MousePtrBrowseNotify(
    HWND hDlg,
    LPOFNOTIFY pofn)
{
    switch (pofn->hdr.code)
    {
        case ( CDN_SELCHANGE ) :
        {
            //
            //  Don't show the cursor until the user stops moving around.
            //
            if (SetTimer(hDlg, IDT_BROWSE, 250, NULL))
            {
                //
                //  Don't destroy the old cursor.
                //
                SendDlgItemMessage( hDlg,
                                    ID_CURSORPREVIEW,
                                    STM_SETICON,
                                    0,
                                    0L );
            }
            else
            {
                MousePtrBrowsePreview(hDlg);
            }
            break;
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  MousePtrBrowseDlgProc
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK MousePtrBrowseDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            PMOUSEPTRBR pPtrBr = (PMOUSEPTRBR)((LPOPENFILENAME)lParam)->lCustData;

            if (pPtrBr)
            {
                pPtrBr->hDlg = hDlg;
            }

            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) pPtrBr);
            break;
        }
        case ( WM_DESTROY ) :
        {
            KillTimer(hDlg, IDT_BROWSE);

            //
            //  Don't destroy the old cursor.
            //
            SendDlgItemMessage(hDlg, ID_CURSORPREVIEW, STM_SETICON, 0, 0L);
            break;
        }
        case ( WM_TIMER ) :
        {
            KillTimer(hDlg, IDT_BROWSE);

            MousePtrBrowsePreview(hDlg);
            break;
        }
        case ( WM_NOTIFY ) :
        {
            return (MousePtrBrowseNotify(hDlg, (LPOFNOTIFY) lParam));
        }
        case ( WM_HELP ) :
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     HELP_FILE,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aMousePtrBrowseHelpIDs );
            break;
        }
        case ( WM_CONTEXTMENU ) :
        {
            WinHelp( (HWND)wParam,
                     HELP_FILE,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPVOID)aMousePtrBrowseHelpIDs );
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Browse
//
//  Browse the file system for a new cursor for the selected item.
//
////////////////////////////////////////////////////////////////////////////

BOOL Browse(HWND hwndOwner)
{
    static TCHAR szCustomFilter[80] = TEXT("");
    static TCHAR szStartDir[MAX_PATH] = TEXT("");

    OPENFILENAME ofn;
    CURSOR_INFO curi;
    int i;
    BOOL fRet = FALSE;
    MOUSEPTRBR sPtrBr;

    if (!*szStartDir)
    {
        HKEY key = NULL;

        if (RegOpenKey(HKEY_LOCAL_MACHINE, szRegStr_Setup, &key) == ERROR_SUCCESS)
        {
            LONG len = sizeof(szStartDir) / sizeof(szStartDir[0]);

            if (RegQueryValueEx( key,
                                 szSharedDir,
                                 NULL,
                                 NULL,
                                 (LPBYTE)szStartDir,
                                 &len ) != ERROR_SUCCESS)
            {
                *szStartDir = TEXT('\0');
            }

            RegCloseKey(key);
        }

        if (!*szStartDir)
        {
            if (0 == GetWindowsDirectory(szStartDir, MAX_PATH))
            {
                goto Error;
            }
        }

        PathAppend(szStartDir, szCursorSubdir);
    }

    curi.szFile[0] = TEXT('\0');

    sPtrBr.curi.szFile[0] = TEXT('\0');
    sPtrBr.curi.hcur      = NULL;

    ofn.lStructSize       = sizeof(ofn);
    ofn.hwndOwner         = hwndOwner;
    ofn.hInstance         = g_hInst;
    ofn.lpstrFilter       = gszFilter;
    ofn.lpstrCustomFilter = szCustomFilter;
    ofn.nMaxCustFilter    = ARRAYSIZE(szCustomFilter);
    ofn.nFilterIndex      = 1;
    ofn.lpstrFile         = curi.szFile;
    ofn.nMaxFile          = ARRAYSIZE(curi.szFile);
    ofn.lpstrFileTitle    = NULL;
    ofn.nMaxFileTitle     = 0;
    ofn.lpstrInitialDir   = szStartDir;
    ofn.lpstrTitle        = gszBrowse;
    ofn.Flags             = OFN_EXPLORER | OFN_ENABLETEMPLATE | OFN_ENABLEHOOK |
                            OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;
    ofn.lpstrDefExt       = NULL;
    ofn.lpfnHook          = MousePtrBrowseDlgProc;
    ofn.lpTemplateName    = MAKEINTRESOURCE(DLG_MOUSE_POINTER_BROWSE);
    ofn.lCustData         = (LPARAM)(PMOUSEPTRBR)&sPtrBr;

    fRet = GetOpenFileName(&ofn);

    if (!fRet)
    {
        goto brErrExit;
    }
    // we got a valid value, save the current location
    GetCurrentDirectory(ARRAYSIZE(szStartDir), szStartDir);

    fRet = FALSE;

    //
    //  We have probably already gotten this cursor.
    //
    if (lstrcmpi(curi.szFile, sPtrBr.curi.szFile) == 0)
    {
        if (!sPtrBr.curi.hcur)
        {
            goto brErrExit;
        }

        curi = sPtrBr.curi;

        //
        //  Clear this so it will not get destroyed in the cleanup code.
        //
        sPtrBr.curi.hcur = NULL;
    }
    else
    {
        //
        //  The user must have typed in a name.
        //
        if (!GetCursorFromFile(&curi))
        {
            goto brErrExit;
        }
    }

    //
    //  Convert mapped drive letters to UNC.
    //
#ifdef UNICODE
    if (curi.szFile[1] == TEXT(':'))
#else
    if (!IsDBCSLeadByte(curi.szFile[0]) && (curi.szFile[1] == TEXT(':')))
#endif
    {
        TCHAR szDrive[3];
        TCHAR szNet[MAX_PATH];
        int lenNet = ARRAYSIZE(szNet);

        lstrcpyn(szDrive, curi.szFile, ARRAYSIZE(szDrive));

        if ((WNetGetConnection(szDrive, szNet, &lenNet) == NO_ERROR) &&
            (szNet[0] == TEXT('\\')) &&
            (szNet[1] == TEXT('\\')))
        {
            lstrcat(szNet, curi.szFile + 2);
            lstrcpy(curi.szFile, szNet);
        }
    }

    i = (int)SendMessage(ghwndCursors, LB_GETCURSEL, 0, 0);

    curi.fl |= CIF_MODIFIED;

    SendMessage(GetParent(ghwndDlg), PSM_CHANGED, (WPARAM)ghwndDlg, 0L);

    EnableWindow(GetDlgItem(ghwndDlg, ID_SAVESCHEME), TRUE);

    //
    //  Destroy the old cursor before we retain the new one.
    //
    FreeItemCursor(acuri + i);

    acuri[i] = curi;

    UpdateCursorList();

    fRet = TRUE;

brErrExit:
    if (sPtrBr.curi.hcur)
    {
        DestroyCursor(sPtrBr.curi.hcur);
    }

Error:
    return (fRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  CleanUpEverything
//
//  Destroy all the outstanding cursors.
//
////////////////////////////////////////////////////////////////////////////

void CleanUpEverything()
{
    CURSOR_INFO *pcuri;
    int i;

    for (pcuri = &acuri[0], i = 0; i < CCURSORS; i++, pcuri++)
    {
        FreeItemCursor(pcuri);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  UpdateCursorList
//
//  Force the Cursor ListBox to repaint and the cursor information below the
//  listbox to be refreshed as well.
//
////////////////////////////////////////////////////////////////////////////

VOID UpdateCursorList()
{
    int i = (int)SendMessage(ghwndCursors, LB_GETCURSEL, 0, 0);
    PCURSOR_INFO pcuri = ((i >= 0) ? &acuri[i] : NULL);
    HCURSOR hcur = pcuri ? pcuri->hcur : NULL;
    HWND hDefaultButton = GetDlgItem(ghwndDlg, ID_DEFAULT);
    BOOL fEnableDefaultButton = (pcuri && (pcuri->fl & CIF_FILE));

    InvalidateRect(ghwndCursors, NULL, FALSE);

    SendMessage(ghwndPreview, STM_SETICON, (WPARAM)hcur, 0L);

    if (!fEnableDefaultButton && (GetFocus() == hDefaultButton))
    {
        SendMessage(ghwndDlg, WM_NEXTDLGCTL, (WPARAM)ghwndCursors, TRUE);
    }

    EnableWindow(hDefaultButton, fEnableDefaultButton);
}


////////////////////////////////////////////////////////////////////////////
//
//  SaveSchemeAs
//
////////////////////////////////////////////////////////////////////////////

BOOL SaveSchemeAs()
{
    BOOL fSuccess = TRUE;

    //
    //  Dialog proc returns TRUE & sets gszSchemeName to filename entered
    //  on OK.
    //
    if (DialogBox( g_hInst,
                   MAKEINTRESOURCE(DLG_MOUSE_POINTER_SCHEMESAVE),
                   ghwndDlg,
                   SaveSchemeDlgProc ))
    {
        fSuccess = SaveScheme();

        if (fSuccess)
        {
            int index = (int)SendMessage( ghwndSchemeCB,
                                          CB_FINDSTRINGEXACT,
                                          (WPARAM)-1,
                                          (LPARAM)gszSchemeName );
            //
            //  If not found, add it.
            //
            if (index < 0)
            {
                index = (int)SendMessage( ghwndSchemeCB,
                                          CB_ADDSTRING,
                                          0,
                                          (LPARAM)gszSchemeName );
            }

            //
            //  Select the name.
            //
            SendMessage(ghwndSchemeCB, CB_SETCURSEL, (WPARAM) index, 0);

            //
            //  Since this is now a user saved scheme, activate the delete
            //  button.
            //
            EnableWindow(GetDlgItem(ghwndDlg, ID_REMOVESCHEME), TRUE);
        }
    }

    return (fSuccess);
}


////////////////////////////////////////////////////////////////////////////
//
//  SubstituteString
//
//  Replaces the string pszRemove with the string pszReplace in the
//  string pszInput and places the output in pszResult.  Only looks
//  at the begining of the input string.
//
////////////////////////////////////////////////////////////////////////////

BOOL SubstituteString(LPCTSTR pszInput, LPCTSTR pszRemove, LPCTSTR pszReplace, LPTSTR pszResult, UINT cchResult)
{
    DWORD cchRemove = lstrlen(pszRemove);

    if (CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE,
                       pszRemove, cchRemove, pszInput, cchRemove) == 2)
    {
        if (lstrlen(pszInput) + cchRemove < cchResult)
        {
            lstrcpy(pszResult, pszReplace);
            lstrcat(pszResult, pszInput + cchRemove);
            return TRUE;
        }
    }
    return FALSE;
}


BOOL UnExpandPath( LPTSTR pszPath )
{
    static TCHAR szUserProfile[MAX_PATH];
    static TCHAR szSystemRoot[MAX_PATH];
    static TCHAR szProgramFiles[MAX_PATH];
    static BOOL bInit = FALSE;
    TCHAR szUnexpandedFilename[MAX_PATH];

    if ( !bInit )
    {
        ExpandEnvironmentStrings( TEXT("%USERPROFILE%"),  szUserProfile,  ARRAYSIZE(szUserProfile)  );
        ExpandEnvironmentStrings( TEXT("%SYSTEMROOT%"),   szSystemRoot,   ARRAYSIZE(szSystemRoot)   );
        ExpandEnvironmentStrings( TEXT("%ProgramFiles%"), szProgramFiles, ARRAYSIZE(szProgramFiles) );
        bInit = TRUE;
    }

    if (!SubstituteString(pszPath, szUserProfile, TEXT("%USERPROFILE%"), szUnexpandedFilename, ARRAYSIZE(szUnexpandedFilename)))
    {
        if (!SubstituteString(pszPath, szSystemRoot, TEXT("%SYSTEMROOT%"), szUnexpandedFilename, ARRAYSIZE(szUnexpandedFilename)))
        {
            if (!SubstituteString(pszPath, szProgramFiles, TEXT("%ProgramFiles%"), szUnexpandedFilename, ARRAYSIZE(szUnexpandedFilename)))
            {
                return FALSE;
            }
        }
    }
    lstrcpy(pszPath, szUnexpandedFilename);
    return TRUE;
}


////////////////////////////////////////////////////////////////////////////
//
//  SaveScheme
//
////////////////////////////////////////////////////////////////////////////

BOOL SaveScheme()
{
    BOOL fSuccess = FALSE;

    if (*gszSchemeName)
    {
        const BUFFER_SIZE = CCURSORS * (MAX_PATH + 1) + 1;
        LPTSTR pszBuffer = (LPTSTR)LocalAlloc( LMEM_FIXED,
                                               BUFFER_SIZE * sizeof(TCHAR) );

        HKEY hk;
        int i;

        if (!pszBuffer)
        {
            return (FALSE);
        }

        pszBuffer[0] = TEXT('\0');

        for (i = 0; i < CCURSORS; i++)
        {
            if (i)
            {
                lstrcat(pszBuffer, TEXT(","));
            }

            // Replace path with evnironment variables.
            UnExpandPath(acuri[i].szFile);

            lstrcat(pszBuffer, acuri[i].szFile);
        }

        if (RegCreateKey( HKEY_CURRENT_USER,
                          c_szRegPathCursors,
                          &hk ) == ERROR_SUCCESS)
        {
            HKEY hks;

            if (RegCreateKey(hk, c_szSchemes, &hks) == ERROR_SUCCESS)
            {
                LPTSTR pszOldValue = (LPTSTR)LocalAlloc( LMEM_FIXED,
                                               BUFFER_SIZE * sizeof(TCHAR) );
                if (NULL != pszOldValue)
                {
                    DWORD dwType;
                    DWORD dwSize = BUFFER_SIZE*sizeof(TCHAR);
                    BOOL bSave = FALSE;

                    int ret = RegQueryValueEx(hks, gszSchemeName, NULL, &dwType, (LPBYTE)pszOldValue, &dwSize);

                    //
                    //  If the key already exists, ask to confirm the overwrite.
                    //
                    if (ret == ERROR_SUCCESS && (dwType==REG_SZ || dwType==REG_EXPAND_SZ))
                    {
                        // only need to save if value is different from old value
                        if (lstrcmp(pszOldValue,pszBuffer)!=0)
                        {
                            TCHAR szTitle[OVERWRITE_TITLE];
                            TCHAR szMsg[OVERWRITE_MSG];
                            LoadString(g_hInst, IDS_OVERWRITE_TITLE, szTitle, OVERWRITE_TITLE);
                            LoadString(g_hInst, IDS_OVERWRITE_MSG, szMsg, OVERWRITE_MSG);

                            if (MessageBox( ghwndDlg,
                                            szMsg,
                                            szTitle,
                                            MB_ICONQUESTION | MB_YESNO ) == IDYES)
                            {
                                //
                                //  Overwrite confirmed.  Safe to save.
                                //
                                bSave = TRUE;
                            }
                        }
                        else
                        {
                            // no need to save since the new value is the same as the old value.
                            fSuccess = TRUE;
                        }
                    }
                    else
                    {
                        //
                        //  The key doesn't exist, so it's safe to create it.
                        //
                        bSave = TRUE;
                    }

                    if (bSave)
                    {
                        if (RegSetValueEx( hks,
                                           gszSchemeName,
                                           0,
                                           REG_EXPAND_SZ,
                                           (LPBYTE)pszBuffer,
                                           (lstrlen(pszBuffer) + 1) * sizeof(TCHAR) )
                              == ERROR_SUCCESS)
                        {
                            fSuccess = TRUE;
                        }
                    }

                    LocalFree( pszOldValue );
                }

                RegCloseKey(hks);
            }

            RegCloseKey(hk);
        }

        LocalFree(pszBuffer);
    }

    return (fSuccess);
}


////////////////////////////////////////////////////////////////////////////
//
//  SaveCurSchemeName
//
////////////////////////////////////////////////////////////////////////////

void SaveCurSchemeName()
{
    HKEY hk;

    if (RegCreateKey( HKEY_CURRENT_USER,
                      c_szRegPathCursors,
                      &hk ) == ERROR_SUCCESS)
    {
        int index = (int)SendMessage(ghwndSchemeCB, CB_GETCURSEL, 0, 0L);

        SendMessage( ghwndSchemeCB,
                     CB_GETLBTEXT,
                     (WPARAM)index,
                     (LPARAM)gszSchemeName );
        //
        //  Exclude the "none" pattern.
        //
        if (lstrcmpi(gszSchemeName, szNone) == 0)
        {
            *gszSchemeName = 0;
            iSchemeLocation = ID_NONE_SCHEME;
        }
        else
        {
            iSchemeLocation = SystemOrUser(gszSchemeName);
        }

        RegSetValue( hk,
                     NULL,
                     REG_SZ,
                     gszSchemeName,
                     (lstrlen(gszSchemeName) + 1) * sizeof(TCHAR) );

        RegSetValueEx( hk,
                       szSchemeSource,
                       0,
                       REG_DWORD,
                       (unsigned char *)&iSchemeLocation,
                       sizeof(iSchemeLocation) );

        RegCloseKey(hk);

        if (iSchemeLocation == ID_USER_SCHEME)
        {
            SaveScheme();
        }
    }
}



////////////////////////////////////////////////////////////////////////////
//
//  LoadScheme
//
//  This is called whenever a selection is made from the schemes combo box.
//
////////////////////////////////////////////////////////////////////////////

BOOL LoadScheme()
{
    const BUFFER_SIZE = CCURSORS * (MAX_PATH + 1) + 1;
    TCHAR pszSchemeName[MAX_SCHEME_SUFFIX + MAX_SCHEME_NAME_LEN + 1];
    LPTSTR pszBuffer;
    BOOL fSuccess = FALSE;
    int index, ret;
    HKEY hk;

    //
    //  Allocate buffer for cursor paths.
    //
    pszBuffer = (LPTSTR)LocalAlloc(LMEM_FIXED, BUFFER_SIZE * sizeof(TCHAR));
    if (pszBuffer == NULL)
    {
        return (FALSE);
    }

    HourGlass(TRUE);

    *pszBuffer = *pszSchemeName = 0;

    index = (int)SendMessage(ghwndSchemeCB, CB_GETCURSEL, 0, 0L);

    //
    //  Get current scheme name.
    //
    SendMessage( ghwndSchemeCB,
                 CB_GETLBTEXT,
                 (WPARAM)index,
                 (LPARAM)pszSchemeName );

    // Get the text for the item at index, compare to the previous value to see
    // if it changed.  We can't simply compare the previous index because new items
    // get inserted into the list so the index can change and still be the same or
    // can be different when nothing has changed.
    if ( 0 == lstrcmp(gszPreviousScheme, pszSchemeName) )
    {
        LocalFree(pszBuffer);
        // nothing to do, we're loading the already selected scheme
        return FALSE;
    }

    // We're loading a different scheme, enable the apply button.
    SendMessage(GetParent(ghwndDlg), PSM_CHANGED, (WPARAM)ghwndDlg, 0L);
    lstrcpy(gszPreviousScheme, pszSchemeName);

    //
    //  Exclude the "none" pattern.
    //
    if (lstrcmpi(pszSchemeName, szNone) != 0)
    {
        //
        //  If we have an os scheme, then search for the scheme in HKLM,
        //  otherwise look in HKCU.
        //
        if ((((ret = SystemOrUser(pszSchemeName)) == ID_OS_SCHEME)
               ? (RegOpenKey(HKEY_LOCAL_MACHINE, c_szRegPathSystemSchemes, &hk))
               : (RegOpenKey(HKEY_CURRENT_USER, c_szRegPathCursorSchemes, &hk)))
             == ERROR_SUCCESS)
        {
            DWORD len = BUFFER_SIZE * sizeof(TCHAR);

            if (RegQueryValueEx( hk,
                                 pszSchemeName, 0, NULL,
                                 (LPBYTE)pszBuffer,
                                 &len ) == ERROR_SUCCESS)
            {
                fSuccess = TRUE;       // can be reset to FALSE below
            }

            RegCloseKey(hk);
        }
    }
    else
    {
        //
        //  "none" pattern is a valid choice.
        //
        ret = ID_NONE_SCHEME;
        fSuccess = TRUE;
    }

    if (fSuccess)
    {
        LPTSTR pszNextFile, pszFile = pszBuffer;
        BOOL fEOL = FALSE;
        int i = 0;

        //
        // Remove an enclosing pair of double quotes from the list
        // of cusor file names associated with the scheme.
        //
        // Why?  On 3/29/00 someone changed the setup file accessor.inx 
        // placing double quotes around some of the cursor scheme reg values
        // in HKLM.  We'll fix the setup file but we should handle this
        // case for all those who have already installed using that
        // setup file.
        //
        if (TEXT('"') == *pszFile)
        {
            const LPTSTR pszLastChar = pszFile + lstrlen(pszFile) - 1;
            if (TEXT('"') == *pszLastChar && pszLastChar > pszFile)
            {
                //
                // Increment passed first dbl quote and truncate 
                // string before the last.
                //
                pszFile++;
                *pszLastChar = TEXT('\0');
            }
        }

        //
        //  Parse string of format TEXT("filename1, filename2, filename3...")
        //  into cursor info array.
        //
        do
        {
            while (*pszFile &&
                   (*pszFile == TEXT(' ')  ||
                    *pszFile == TEXT('\t') ||
                    *pszFile == TEXT('\n')))
            {
                pszFile++;
            }

            pszNextFile = pszFile;

            while (*pszNextFile != TEXT('\0'))
            {
                if (*pszNextFile == TEXT(','))
                {
                    break;
                }

                pszNextFile = CharNext(pszNextFile);
            }

            if (*pszNextFile == TEXT('\0'))
            {
                fEOL = TRUE;
            }
            else
            {
                *pszNextFile = TEXT('\0');
            }

            if (lstrcmp(pszFile, acuri[i].szFile))
            {
                //
                //  It's different than current, update.
                //
                lstrcpy(acuri[i].szFile, pszFile);

                fSuccess &= SchemeUpdate(i);
            }

            pszFile = pszNextFile;

            if (!fEOL)
            {
                pszFile++;        // skip TEXT('\0') and move to next path
            }

            i++;

        } while (i < CCURSORS);
    }

    LocalFree(pszBuffer);

    UpdateCursorList();

    EnableWindow(GetDlgItem(ghwndDlg, ID_REMOVESCHEME), (ret == ID_USER_SCHEME));

    HourGlass(FALSE);

    return (fSuccess);
}


////////////////////////////////////////////////////////////////////////////
//
//  SchemeUpdate
//
//  Updates the cursor at index i in acuri.
//
////////////////////////////////////////////////////////////////////////////

BOOL SchemeUpdate(int i)
{
    BOOL fSuccess = TRUE;

    if (acuri[i].hcur)
    {
        FreeItemCursor(acuri + i);
    }

    //
    //  If TEXT("Set Default").
    //
    if (*(acuri[i].szFile) == TEXT('\0'))
    {
        acuri[i].hcur =
            (HCURSOR)LoadImage( NULL,
                                MAKEINTRESOURCE(gacd[i].idDefResource),
                                IMAGE_CURSOR,
                                0,
                                0,
                                LR_DEFAULTSIZE | LR_ENVSUBST );
        acuri[i].fl = 0;
    }
    else
    {
        fSuccess = TryToLoadCursor(ghwndDlg, i, &acuri[i]);
    }

    acuri[i].fl |= CIF_MODIFIED;

    return (fSuccess);
}


////////////////////////////////////////////////////////////////////////////
//
//  RemoveScheme
//
////////////////////////////////////////////////////////////////////////////

BOOL RemoveScheme()
{
    //
    //  Only user schemes can be removed, so this only needs to
    //  be MAX_SCHEME_NAME_LEN + 1 long.
    //
    TCHAR szSchemeName[MAX_SCHEME_NAME_LEN + 1];
    int index;
    HKEY hk;

    index = (int)SendMessage(ghwndSchemeCB, CB_GETCURSEL, 0, 0L);

    //
    //  Get current scheme name.
    //
    SendMessage( ghwndSchemeCB,
                 CB_GETLBTEXT,
                 (WPARAM)index,
                 (LPARAM)szSchemeName );

    //
    //  Exclude the "none" pattern from removal.
    //
    if (lstrcmpi(szSchemeName, szNone) == 0)
    {
        return (FALSE);
    }

    //
    //  HACK: assume deleting noname needs no confirmation -
    //  this is because the scheme won't save properly anyway.
    //
    if (*szSchemeName)
    {
        TCHAR RemoveMsg[MAX_PATH];
        TCHAR DialogMsg[MAX_PATH];

        LoadString(g_hInst, IDS_REMOVESCHEME, RemoveMsg, MAX_PATH);

        wsprintf(DialogMsg, RemoveMsg, (LPTSTR)szSchemeName);

        LoadString(g_hInst, IDS_NAME, RemoveMsg, MAX_PATH);

        if (MessageBox( ghwndDlg,
                        DialogMsg,
                        RemoveMsg,
                        MB_ICONQUESTION | MB_YESNO ) != IDYES)
        {
            return (TRUE);
        }
    }

    if (RegOpenKey( HKEY_CURRENT_USER,
                    c_szRegPathCursors,
                    &hk ) == ERROR_SUCCESS)
    {
        HKEY hks;

        if (RegOpenKey(hk, c_szSchemes, &hks) == ERROR_SUCCESS)
        {
            RegDeleteValue(hks, szSchemeName);
            RegCloseKey(hks);
        }

        RegCloseKey(hk);
    }

    //
    //  Delete from list box.
    //
    index = (int)SendMessage( ghwndSchemeCB,
                              CB_FINDSTRINGEXACT,
                              (WPARAM)-1,
                              (LPARAM)szSchemeName );

    SendMessage(ghwndSchemeCB, CB_DELETESTRING, (WPARAM)index, 0);

    SendMessage(ghwndSchemeCB, CB_SETCURSEL, 0, 0);
    SendMessage(ghwndDlg, WM_NEXTDLGCTL, 1, 0L);

    EnableWindow(GetDlgItem(ghwndDlg, ID_REMOVESCHEME), FALSE);
    return TRUE;
}


////////////////////////////////////////////////////////////////////////////
//
//  InitSchemeComboBox
//
////////////////////////////////////////////////////////////////////////////

BOOL InitSchemeComboBox()
{
    TCHAR pszSchemeName[MAX_SCHEME_NAME_LEN + 1];
    TCHAR pszDefaultSchemeName[MAX_SCHEME_NAME_LEN + 1];
    TCHAR pszLongName[MAX_SCHEME_SUFFIX + MAX_SCHEME_NAME_LEN + 1];
    int index;
    HKEY hk;
    DWORD len;

    LoadString(g_hInst, IDS_NONE, szNone, ARRAYSIZE(szNone));
    LoadString(g_hInst, IDS_SUFFIX, szSystemScheme, ARRAYSIZE(szSystemScheme));

    if (RegOpenKey(HKEY_CURRENT_USER, c_szRegPathCursors, &hk) == ERROR_SUCCESS)
    {
        HKEY hks;

        //
        //  Enumerate the schemes.
        //
        if (RegOpenKey(hk, c_szSchemes, &hks) == ERROR_SUCCESS)
        {
            DWORD i;

            for (i = 0; ;i++)
            {
                LONG ret;

                //
                //  Reset each pass.
                //
                len = ARRAYSIZE(pszSchemeName);

                ret = RegEnumValue( hks,
                                    i,
                                    pszSchemeName,
                                    &len,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL );

                if (ret == ERROR_MORE_DATA)
                {
                    continue;
                }

                if (ret != ERROR_SUCCESS)
                {
                    break;
                }

                //
                //  HACK to keep "NONE" pure.
                //
                if (lstrcmpi(pszSchemeName, szNone) != 0)
                {
                    SendMessage( ghwndSchemeCB,
                                 CB_ADDSTRING,
                                 0,
                                 (LPARAM)pszSchemeName );
                }
            }

            //
            //  At this point, all of the user defined scheme names have been
            //  added to the combo box.
            //
            RegCloseKey(hks);
        }

        //
        //  Get name of current one.
        //
        //  Reset again.
        //
        len = sizeof(pszDefaultSchemeName);

        RegQueryValue(hk, NULL, pszDefaultSchemeName, &len);

        //
        //  Try to read the value of Scheme Source.  If this value doesn't
        //  exist, then we have a pre NT 5.0 implementation, so all schemes
        //  will be user schemes.
        //
        len = sizeof(iSchemeLocation);
        if (RegQueryValueEx( hk,
                             szSchemeSource,
                             NULL,
                             NULL,
                             (unsigned char *)&iSchemeLocation,
                             &len ) != ERROR_SUCCESS)
        {
            iSchemeLocation = ID_USER_SCHEME;
        }

        RegCloseKey(hk);
    }

    //
    //  Now add the system defined pointer schemes.
    //
    if (RegOpenKey(HKEY_LOCAL_MACHINE, c_szRegPathSystemSchemes, &hk) == ERROR_SUCCESS)
    {
        DWORD i;

        for (i = 0; ;i++)
        {
            LONG ret;

            //
            //  Reset each pass.
            //
            len = ARRAYSIZE(pszSchemeName);

            ret = RegEnumValue( hk,
                                i,
                                pszSchemeName,
                                &len,
                                NULL,
                                NULL,
                                NULL,
                                NULL );

            //
            //  If the Scheme name is longer than the allowed length, skip it.
            //
            if (ret == ERROR_MORE_DATA)
            {
                continue;
            }

            //
            //  If there's an error, then we're done.
            //
            if (ret != ERROR_SUCCESS)
            {
                break;
            }

            //
            //  When we add the system identifier to the string, it could be
            //  longer than MAX_SCHEME_NAME, however we only want to read
            //  max length from the registry.
            //
            lstrcpy(pszLongName, pszSchemeName);
            lstrcat(pszLongName, szSystemScheme);
            SendMessage(ghwndSchemeCB, CB_ADDSTRING, 0, (LPARAM)pszLongName);
        }

        RegCloseKey(hk);
    }

    //
    //  Add the "none" scheme.
    //
    SendMessage(ghwndSchemeCB, CB_INSERTSTRING, 0, (LPARAM)szNone);

    //
    //  Try to find current one in the combobox.
    //
    lstrcpy(pszLongName, pszDefaultSchemeName);
    if (iSchemeLocation == ID_OS_SCHEME)
    {
        lstrcat(pszLongName, szSystemScheme);
    }
    index = (int)SendMessage( ghwndSchemeCB,
                              CB_FINDSTRINGEXACT,
                              0xFFFF,
                              (LPARAM)pszLongName );

    //
    //  If found, select it.
    //
    if (index < 0)           // if we are on the None scheme
    {
        iSchemeLocation = ID_NONE_SCHEME;
        index = 0;
    }

    // We keep around a selection indicator so we know when selection has changed.
    // Initialize that value here.
    lstrcpy(gszPreviousScheme, pszLongName);

    SendMessage(ghwndSchemeCB, CB_SETCURSEL, (WPARAM)index, 0);

    EnableWindow( GetDlgItem(ghwndDlg, ID_REMOVESCHEME),
                  (iSchemeLocation == ID_USER_SCHEME) );

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  SaveSchemeDlgProc
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK SaveSchemeDlgProc(
    HWND  hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TCHAR szSchemeName[MAX_SCHEME_SUFFIX + MAX_SCHEME_NAME_LEN + 1];

    switch (message)
    {
        case ( WM_INITDIALOG ) :
        {
            HourGlass(TRUE);

            GetWindowText(ghwndSchemeCB, szSchemeName, ARRAYSIZE(szSchemeName));

            //
            //  CANNOT SAVE "NONE" SCHEME.
            //
            if (lstrcmpi(szSchemeName, szNone) == 0)
            {
                *szSchemeName = 0;
            }

            iSchemeLocation = SystemOrUser(szSchemeName);

            SetDlgItemText(hWnd, ID_SCHEMEFILENAME,  szSchemeName);

            SendDlgItemMessage(hWnd, ID_SCHEMEFILENAME, EM_SETSEL, 0, 32767);

            SendDlgItemMessage( hWnd,
                                ID_SCHEMEFILENAME,
                                EM_LIMITTEXT,
                                MAX_SCHEME_NAME_LEN,
                                0L );

            EnableWindow(GetDlgItem(hWnd, IDOK), szSchemeName[0] != TEXT('\0'));

            HourGlass(FALSE);
            return (TRUE);
        }
        case ( WM_HELP ) :
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     HELP_FILE,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aHelpIDs );
            return (TRUE);
        }
        case ( WM_CONTEXTMENU ) :
        {
            WinHelp( (HWND)wParam,
                     HELP_FILE,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPVOID)aHelpIDs );
            return (TRUE);
        }
        case ( WM_COMMAND ) :
        {
            switch (LOWORD(wParam))
            {
                case ( ID_SCHEMEFILENAME ) :
                {
                    if (HIWORD(wParam) == EN_CHANGE)
                    {
                        //
                        //  CANNOT SAVE "NONE" SCHEME
                        //  cannot save a scheme ending with szSystemScheme
                        //
                        EnableWindow(
                            GetDlgItem(hWnd, IDOK),
                            ((GetDlgItemText( hWnd,
                                              ID_SCHEMEFILENAME,
                                              szSchemeName,
                                              ARRAYSIZE(szSchemeName) ) > 0) &&
                             (lstrcmpi(szSchemeName, szNone) != 0) &&
                             (SystemOrUser(szSchemeName) != ID_OS_SCHEME)) );
                    }
                    break;
                }
                case ( IDOK ) :
                {
                    GetDlgItemText( hWnd,
                                    ID_SCHEMEFILENAME,
                                    szSchemeName,
                                    MAX_SCHEME_NAME_LEN + 1 );

                    CurStripBlanks(szSchemeName);

                    if (*szSchemeName == TEXT('\0'))
                    {
                        MessageBeep(0);
                        break;
                    }

                    lstrcpy(gszSchemeName, szSchemeName);

                    // fall through...
                }
                case ( IDCANCEL ) :
                {
                    EndDialog(hWnd, LOWORD(wParam) == IDOK);
                    return (TRUE);
                }
            }
        }
    }

    //
    //  Didn't process a message.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  MakeFilename
//
//  Returns Filename with a default path in system directory if no path
//  is already specified.
//
////////////////////////////////////////////////////////////////////////////

LPTSTR MakeFilename(
    LPTSTR sz)
{
    TCHAR szTemp[MAX_PATH];

    ExpandEnvironmentStrings(sz, szTemp, MAX_PATH);

    if (szTemp[0] == TEXT('\\') || szTemp[1] == TEXT(':'))
    {
        lstrcpy(gszFileName2, szTemp);

        return (gszFileName2);
    }
    else
    {
        GetSystemDirectory(gszFileName2, ARRAYSIZE(gszFileName2));

        lstrcat(gszFileName2, TEXT("\\"));
        lstrcat(gszFileName2, szTemp);

        return (gszFileName2);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CurStripBlanks
//
//  Strips leading and trailing blanks from a string.
//  Alters the memory where the string sits.
//
////////////////////////////////////////////////////////////////////////////

void CurStripBlanks(LPTSTR pszString)
{
    LPTSTR pszPosn;

    //
    //  Strip leading blanks.
    //
    pszPosn = pszString;

    while (*pszPosn == TEXT(' '))
    {
        pszPosn++;
    }

    if (pszPosn != pszString)
    {
        lstrcpy(pszString, pszPosn);
    }

    //
    //  Strip trailing blanks.
    //
    if ((pszPosn = pszString + lstrlen(pszString)) != pszString)
    {
       pszPosn = CharPrev(pszString, pszPosn);

       while (*pszPosn == TEXT(' '))
       {
           pszPosn = CharPrev(pszString, pszPosn);
       }

       pszPosn = CharNext(pszPosn);

       *pszPosn = TEXT('\0');
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  SystemOrUser
//
//  Attempts to determine if the scheme name selected from the combo
//  box ends with the string szSystemScheme and retuns ID_OS_SCHEME
//  if it does, ID_USER_SCHEME if it doesn't.
//
////////////////////////////////////////////////////////////////////////////

int SystemOrUser(TCHAR *pszSchemeName)
{
    TCHAR *pszSN;
    int lenSS, lenSN;
    int i;

    lenSS = lstrlen(szSystemScheme);
    lenSN = lstrlen(pszSchemeName);

    if (lenSN <= lenSS)
    {
        return (ID_USER_SCHEME);
    }

    pszSN = pszSchemeName + (lenSN - lenSS);

    //
    //  If these strings are different, it's a user scheme.
    //
    if (lstrcmpi(pszSN, szSystemScheme))
    {
        return (ID_USER_SCHEME);
    }

    //
    //  For system schemes, this function also removes the
    //  szSystemScheme string from the end.
    //
    *pszSN = TEXT('\0');

    return (ID_OS_SCHEME);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\nusrmgr\commondialog.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1999.
//
//  File:       CommonDialog.h
//
//  Contents:   interface definition for ICommonDialog
//
//----------------------------------------------------------------------------
#ifndef _NUSRMGR_COMMONDIALOG_H_
#define _NUSRMGR_COMMONDIALOG_H_


class ATL_NO_VTABLE CCommonDialog :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatchImpl<ICommonDialog, &IID_ICommonDialog, &LIBID_NUSRMGRLib>,
    public CComCoClass<CCommonDialog, &CLSID_CommonDialog>
{
public:
    CCommonDialog(void)
    : _hwndOwner(NULL), _dwFlags(0), _dwFilterIndex(0),
      _strFilter(NULL), _strFileName(NULL), _strInitialDir(NULL)
    {}
    ~CCommonDialog() {}

DECLARE_REGISTRY_RESOURCEID((UINT)0)

BEGIN_COM_MAP(CCommonDialog)
    COM_INTERFACE_ENTRY(ICommonDialog)
    COM_INTERFACE_ENTRY2(IDispatch, ICommonDialog)
END_COM_MAP()

    // *** ICommonDialog ***
    STDMETHODIMP get_Filter(BSTR* pbstrFilter);
    STDMETHODIMP put_Filter(BSTR bstrFilter);
    STDMETHODIMP get_FilterIndex(UINT* puiFilterIndex);
    STDMETHODIMP put_FilterIndex(UINT uiFilterIndex);
    STDMETHODIMP get_FileName(BSTR* pbstrFilter);
    STDMETHODIMP put_FileName(BSTR bstrFilter);
    STDMETHODIMP get_Flags(UINT* puiFlags);
    STDMETHODIMP put_Flags(UINT uiFlags);
    STDMETHODIMP put_Owner(VARIANT varOwner);
    STDMETHODIMP get_InitialDir(BSTR* pbstrInitialDir);
    STDMETHODIMP put_InitialDir(BSTR bstrInitialDir);

    STDMETHODIMP ShowOpen(VARIANT_BOOL *pbSuccess);

private:
    // private member variables
    HWND  _hwndOwner;
    DWORD _dwFlags;
    DWORD _dwFilterIndex;
    CComBSTR _strFilter;
    CComBSTR _strFileName;
    CComBSTR _strInitialDir;
};


#endif // _NUSRMGR_COMMONDIALOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\nusrmgr\commondialog.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 2000.
//
//  File:       CommonDialog.cpp
//
//  Contents:   implementation of CCommonDialog
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "commondialog.h"

HWND _VariantToHWND(const VARIANT& varOwner);   // passportmanager.cpp


//
// ICommonDialog Interface
//
STDMETHODIMP CCommonDialog::get_Filter(BSTR* pbstrFilter)
{
    if (!pbstrFilter)
        return E_POINTER;

    *pbstrFilter = _strFilter.Copy();
    return S_OK;
}


STDMETHODIMP CCommonDialog::put_Filter(BSTR bstrFilter)
{
    _strFilter = bstrFilter;
    return S_OK;
}


STDMETHODIMP CCommonDialog::get_FilterIndex(UINT *puiFilterIndex)
{
    if (!puiFilterIndex)
        return E_POINTER;

    *puiFilterIndex = _dwFilterIndex;
    return S_OK;
}


STDMETHODIMP CCommonDialog::put_FilterIndex(UINT uiFilterIndex)
{
    _dwFilterIndex = uiFilterIndex;
    return S_OK;
}


STDMETHODIMP CCommonDialog::get_FileName(BSTR* pbstrFileName)
{
    if (!pbstrFileName)
        return E_POINTER;

    *pbstrFileName = _strFileName.Copy();
    return S_OK;
}


STDMETHODIMP CCommonDialog::put_FileName(BSTR bstrFileName)
{
    _strFileName = bstrFileName;
    return S_OK;
}


STDMETHODIMP CCommonDialog::get_Flags(UINT *puiFlags)
{
    if (!puiFlags)
        return E_POINTER;

    *puiFlags = _dwFlags;
    return S_OK;
}


STDMETHODIMP CCommonDialog::put_Flags(UINT uiFlags)
{
    _dwFlags = uiFlags;
    return S_OK;
}


STDMETHODIMP CCommonDialog::put_Owner(VARIANT varOwner)
{
    HRESULT hr = E_INVALIDARG;

    _hwndOwner = _VariantToHWND(varOwner);
    if (_hwndOwner)
        hr = S_OK;

    return hr;
}

STDMETHODIMP CCommonDialog::get_InitialDir(BSTR* pbstrInitialDir)
{
    if (!pbstrInitialDir)
        return E_POINTER;

    *pbstrInitialDir = _strInitialDir.Copy();
    return S_OK;
}


STDMETHODIMP CCommonDialog::put_InitialDir(BSTR bstrInitialDir)
{
    _strInitialDir = bstrInitialDir;
    return S_OK;
}


STDMETHODIMP CCommonDialog::ShowOpen(VARIANT_BOOL *pbSuccess)
{
    OPENFILENAMEW ofn = { 0 };
    WCHAR szFileName[MAX_PATH];

    // Null characters can't be passed through script, so we separated
    // name filter string combinations with the '|' character.
    // The CommDlg32 api expects name/filter pairs to be separated by
    // a null character, and the entire string to be double
    // null terminated.

    // copy the filter string (plus one for double null at the end)
    CComBSTR strFilter(_strFilter.Length()+1, _strFilter);
    if (strFilter)
    {
        LPWSTR pch;
        int cch = lstrlenW(strFilter);
        for (pch = strFilter; cch > 0; ++pch, --cch)
        {
            if ( *pch == L'|' )
            {
                *pch = L'\0';
            }
        }
        // Double null terminate the string
        ++pch;
        *pch = L'\0';
    }

    // copy the initial file name, if any
    if (_strFileName)
    {
        lstrcpynW(szFileName, _strFileName, ARRAYSIZE(szFileName));
    }
    else
    {
        szFileName[0] = L'\0';
    }

    // set the struct members
    ofn.lStructSize       = SIZEOF(ofn);
    ofn.hwndOwner         = _hwndOwner;
    ofn.lpstrFilter       = strFilter;
    ofn.nFilterIndex      = _dwFilterIndex;
    ofn.lpstrFile         = szFileName;
    ofn.nMaxFile          = ARRAYSIZE(szFileName);
    ofn.lpstrInitialDir   = _strInitialDir;
    ofn.Flags             = _dwFlags;

    // make the call
    if (GetOpenFileNameW(&ofn))
    {
        _strFileName = szFileName;
        *pbSuccess = VARIANT_TRUE;
    }
    else
    {
        *pbSuccess = VARIANT_FALSE;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\nusrmgr\makefile.inc ===
# This is the list of html and related files packaged in the resource
HTM_FILES = \
            $(O)\nusrmgr.hta        \
            $(O)\nusrmgr.css        \
            $(O)\classic.css        \
            $(O)\body.htc           \
            $(O)\popup.htc          \
            $(O)\selectable.htc     \
            $(O)\accountpage.htm    \
            $(O)\advpage.htm        \
            $(O)\changepage.htm     \
            $(O)\createpage.htm     \
            $(O)\createpage2.htm    \
            $(O)\deletepage.htm     \
            $(O)\deletepage2.htm    \
            $(O)\enableguest.htm    \
            $(O)\mainpage.htm       \
            $(O)\mainpage2.htm      \
            $(O)\namepage.htm       \
            $(O)\passport.htm       \
            $(O)\passwordpage.htm   \
            $(O)\passwordpage2.htm  \
            $(O)\picturepage.htm    \
            $(O)\pwchange_o.htm     \
            $(O)\pwcreate.htm       \
            $(O)\pwcreate_o.htm     \
            $(O)\removepassword.htm \
            $(O)\accountpage.js     \
            $(O)\acct_common.js     \
            $(O)\advpage.js         \
            $(O)\chg_common.js      \
            $(O)\createpage.js      \
            $(O)\createpage2.js     \
            $(O)\deletepage.js      \
            $(O)\deletepage2.js     \
            $(O)\localtext.js       \
            $(O)\mainpage.js        \
            $(O)\namepage.js        \
            $(O)\name_common.js     \
            $(O)\nusrmgr.js         \
            $(O)\passport.js        \
            $(O)\picturepage.js     \
            $(O)\popup.js           \
            $(O)\pw_common.js       \
            $(O)\removepassword.js  \

IMG_FILES = \
            res\camera.ico              \
            res\helpdoc.ico             \
            res\stfind_3.ico            \
            res\users.ico               \
            res\users32.ico             \
            res\guest_disabled.bmp      \
            res\users32.gif             \
            res\tbdef.bmp               \
            res\tbhot.bmp               \
            res\tbdefhi.bmp             \
            res\tbhothi.bmp


$(O)\selfreg_nusrmgr.inf : selfreg.inx
        $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS:-DNT =) $** > $*.cln
        $(CLEANINF) -inf $*.cln $@
        del $*.cln

nusrmgr.rc : $(HTM_FILES) $(IMG_FILES) $(MIDL_TLBDIR)\$(TARGETNAME).tlb $(O)\selfreg_nusrmgr.inf $(SXS_MANIFEST)

nusrmgr.cpp : commondialog.h passportmanager.h toolbar.h
commondialog.cpp : commondialog.h
passportmanager.cpp : passportmanager.h
toolbar.cpp : toolbar.h

# 
# Inference rules
#

.SUFFIXES:.js .htc .htm .hta .css

{html}.hta{$(O)}.hta:
    $(CLEANINF) $** $@

{html}.htm{$(O)}.htm:
    $(CLEANINF) $** $@

{html}.htc{$(O)}.htc:
    $(CLEANINF) $** $@

{html}.css{$(O)}.css:
    $(CLEANINF) $** $@

{html}.js{$(O)}.js:
    $(CLEANINF) $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\nusrmgr\debug.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       debug.cpp
//
//--------------------------------------------------------------------------
#include "stdafx.h"

#define DECLARE_DEBUG
#define SZ_DEBUGINI     "nusrmgr.ini"
#define SZ_MODULE       "nusrmgr.cpl"
#define SZ_DEBUGSECTION ""
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\nusrmgr\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\nusrmgr\nusrmgr.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 2000.
//
//  File:       nusrmgr.cpp
//
//  Contents:   DllMain routines
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include <advpub.h> // for REGINSTALL
#define DECL_CRTFREE
#include <crtfree.h>
#include "resource.h"
#include "nusrmgr_i.c"
#include "commondialog.h"
#include "passportmanager.h"
#include "toolbar.h"


DWORD g_tlsAppCommandHook = -1;

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_CommonDialog, CCommonDialog)
OBJECT_ENTRY(CLSID_PassportManager, CPassportManager)
OBJECT_ENTRY(CLSID_Toolbar, CToolbar)
END_OBJECT_MAP()


//
// DllMain (attach/deatch) routine
//
STDAPI_(BOOL) DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        // Don't put it under #ifdef DEBUG
        CcshellGetDebugFlags();
        DisableThreadLibraryCalls(hInstance);
        g_tlsAppCommandHook = TlsAlloc();
        SHFusionInitializeFromModuleID(hInstance, 123);
        _Module.Init(ObjectMap, hInstance, &LIBID_NUSRMGRLib);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
        SHFusionUninitialize();
        if (-1 != g_tlsAppCommandHook)
        {
            TlsFree(g_tlsAppCommandHook);
        }
    }
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow()
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}


//
// Calls the ADVPACK entry-point which executes an inf
// file section.
//
HRESULT CallRegInstall(HINSTANCE hinstFTP, LPSTR szSection)
{
    UNREFERENCED_PARAMETER(hinstFTP);

    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");

        if (pfnri)
        {
            char szThisDLL[MAX_PATH];

            // Get the location of this DLL from the HINSTANCE
            if (GetModuleFileNameA(_Module.GetModuleInstance(), szThisDLL, ARRAYSIZE(szThisDLL)))
            {
                STRENTRY seReg[] = {
                    {"THISDLL", szThisDLL },
                    { "25", "%SystemRoot%" },           // These two NT-specific entries
                    { "11", "%SystemRoot%\\system32" }, // must be at the end of the table
                };
                STRTABLE stReg = {ARRAYSIZE(seReg) - 2, seReg};

                hr = pfnri(_Module.GetResourceInstance(), szSection, &stReg);
            }
        }

        FreeLibrary(hinstAdvPack);
    }

    return hr;
}


HRESULT UnregisterTypeLibrary(const CLSID* piidLibrary)
{
    HRESULT hr = E_FAIL;
    TCHAR szGuid[GUIDSTR_MAX];
    HKEY hk;

    // convert the libid into a string.
    //
    SHStringFromGUID(*piidLibrary, szGuid, ARRAYSIZE(szGuid));

    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("TypeLib"), 0, MAXIMUM_ALLOWED, &hk) == ERROR_SUCCESS)
    {
        if (SHDeleteKey(hk, szGuid))
        {
            // success
            hr = S_OK;
        }
        RegCloseKey(hk);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    
    return hr;
}


HRESULT RegisterTypeLibrary(const CLSID* piidLibrary)
{
    HRESULT hr = E_FAIL;
    ITypeLib* pTypeLib;
    WCHAR wszModuleName[MAX_PATH];

    // Load and register our type library.
    
    if (GetModuleFileNameW(_Module.GetModuleInstance(), wszModuleName, ARRAYSIZE(wszModuleName)))
    {
        hr = LoadTypeLib(wszModuleName, &pTypeLib);

        if (SUCCEEDED(hr))
        {
            // call the unregister type library in case we had some old junk in the registry
            UnregisterTypeLibrary(piidLibrary);

            hr = RegisterTypeLib(pTypeLib, wszModuleName, NULL);
            if (FAILED(hr))
            {
                TraceMsg(TF_WARNING, "RegisterTypeLibrary: RegisterTypeLib failed (%x)", hr);
            }
            pTypeLib->Release();
        }
        else
        {
            TraceMsg(TF_WARNING, "RegisterTypeLibrary: LoadTypeLib failed (%x) on", hr);
        }
    } 

    return hr;
}


STDAPI DllRegisterServer(void)
{
    HRESULT hr;

    hr = CallRegInstall(_Module.GetResourceInstance(), "UserAccountsInstall");
    ASSERT(SUCCEEDED(hr));

    hr = RegisterTypeLibrary(&LIBID_NUSRMGRLib);
    ASSERT(SUCCEEDED(hr));

    return hr;
}


STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

    hr = CallRegInstall(_Module.GetResourceInstance(), "UserAccountsUninstall");
    ASSERT(SUCCEEDED(hr));

    hr = UnregisterTypeLibrary(&LIBID_NUSRMGRLib);
    ASSERT(SUCCEEDED(hr));

    return hr;
}


STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\nusrmgr\passportmanager.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1999.
//
//  File:       PassportManager.h
//
//  Contents:   interface definition for IPassportManager
//
//----------------------------------------------------------------------------
#ifndef _NUSRMGR_PASSPORTMANAGER_H_
#define _NUSRMGR_PASSPORTMANAGER_H_


class ATL_NO_VTABLE CPassportManager :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatchImpl<IPassportManager, &IID_IPassportManager, &LIBID_NUSRMGRLib>,
    public CComCoClass<CPassportManager, &CLSID_PassportManager>
{
public:
    CPassportManager(void) {};
    ~CPassportManager() {};

DECLARE_REGISTRY_RESOURCEID((UINT)0)

BEGIN_COM_MAP(CPassportManager)
    COM_INTERFACE_ENTRY(IPassportManager)
    COM_INTERFACE_ENTRY2(IDispatch, IPassportManager)
END_COM_MAP()

    // *** IPassportManager ***
    STDMETHODIMP get_currentPassport(BSTR* pbstrPassport);
    STDMETHODIMP get_memberServicesURL(BSTR* pbstrURL);
    STDMETHODIMP showWizard(VARIANT varOwner, VARIANT_BOOL *pbRet);
    STDMETHODIMP showKeyManager(VARIANT varOwner, VARIANT_BOOL *pbRet);
};


#endif // _NUSRMGR_PASSPORTMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\nusrmgr\passportmanager.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 2000.
//
//  File:       PassportManager.cpp
//
//  Contents:   implementation of CPassportManager
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "passportmanager.h"
#include <wincrui.h>        // credui
#include <wininet.h>        // INTERNET_MAX_URL_LENGTH
#include <keymgr.h>         // KRShowKeyMgr


const TCHAR c_szWininetKey[]        = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Passport");
const TCHAR c_szMemberServicesVal[] = TEXT("Properties");


void PassportForceNexusRepopulate()
{
    HMODULE hm = LoadLibrary(TEXT("wininet.dll"));
    if (hm)
    {
        FARPROC fp = GetProcAddress(hm, "ForceNexusLookup");
        if (fp)
        {
            (*fp)();
        }
        FreeLibrary(hm);
    }
}

HWND _VariantToHWND(const VARIANT& varOwner)
{
    HWND hwndResult = NULL;

    if (VT_BSTR == varOwner.vt && varOwner.bstrVal && *varOwner.bstrVal != TEXT('\0'))
    {
        hwndResult = FindWindow(NULL, varOwner.bstrVal);
    }

    return hwndResult;
}


//
// IPassportManager Interface
//
STDMETHODIMP CPassportManager::get_currentPassport(BSTR* pbstrPassport)
{
    if (!pbstrPassport)
        return E_POINTER;

    *pbstrPassport = NULL;

    LPWSTR pszCred = NULL;
    if (ERROR_SUCCESS == CredUIReadSSOCredW(NULL, &pszCred))
    {
        *pbstrPassport = SysAllocString(pszCred);
        LocalFree(pszCred);
    }

    return S_OK;
}


STDMETHODIMP CPassportManager::get_memberServicesURL(BSTR* pbstrURL)
{
    if (!pbstrURL)
        return E_POINTER;

    *pbstrURL = NULL;

    BSTR bstrURL = SysAllocStringLen(NULL, INTERNET_MAX_URL_LENGTH);

    if (!bstrURL)
        return E_OUTOFMEMORY;

    // This ensures that the correct reg values are populated.
    PassportForceNexusRepopulate();

    // Try HKEY_CURRENT_USER first
    DWORD cbData = SysStringByteLen(bstrURL);
    DWORD dwErr = SHGetValue(HKEY_CURRENT_USER, c_szWininetKey, c_szMemberServicesVal, NULL, bstrURL, &cbData);

    if (ERROR_SUCCESS != dwErr)
    {
        // Not under HKEY_CURRENT_USER, try HKEY_LOCAL_MACHINE instead
        cbData = SysStringByteLen(bstrURL);
        dwErr = SHGetValue(HKEY_LOCAL_MACHINE, c_szWininetKey, c_szMemberServicesVal, NULL, bstrURL, &cbData);
    }

    if (ERROR_SUCCESS != dwErr)
    {
        SysFreeString(bstrURL);
        bstrURL = NULL;
    }

    *pbstrURL = bstrURL;

    return S_OK;
}
    

STDMETHODIMP CPassportManager::showWizard(VARIANT varOwner, VARIANT_BOOL *pbRet)
{
    if (!pbRet)
        return E_POINTER;

    *pbRet = VARIANT_FALSE;

    IPassportWizard *pPW;
    if (SUCCEEDED(CoCreateInstance(CLSID_PassportWizard, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IPassportWizard, &pPW))))
    {
        pPW->SetOptions(PPW_LAUNCHEDBYUSER);
        if (S_OK == pPW->Show(_VariantToHWND(varOwner)))
        {
            *pbRet = VARIANT_TRUE;
        }
        pPW->Release();
    }

    return S_OK;
}
    

STDMETHODIMP CPassportManager::showKeyManager(VARIANT varOwner, VARIANT_BOOL *pbRet)
{
    if (!pbRet)
        return E_POINTER;

    // This returns void, so we claim to always succeed
    KRShowKeyMgr(_VariantToHWND(varOwner), NULL, NULL, 0);
    *pbRet = VARIANT_TRUE;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\nusrmgr\cpl.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 2000.
//
//  File:       cpl.cpp
//
//  Contents:   Control Panel entry point (CPlApplet)
//
//----------------------------------------------------------------------------

#include "stdafx.h"

#include <regstr.h>     // REGSTR_PATH_POLICIES
#include <lm.h>         // NetGetJoinInformation
#include <cpl.h>
#include "resource.h"


const struct
{
    LPCTSTR pszApp;
    LPCTSTR pszCommand;
}
s_rgCommands[] =
{
    { TEXT("%SystemRoot%\\system32\\rundll32.exe"), TEXT("rundll32.exe \"%SystemRoot%\\system32\\netplwiz.dll\",UsersRunDll")   },
    { TEXT("%SystemRoot%\\system32\\mshta.exe"),    TEXT("mshta.exe \"res://%SystemRoot%\\system32\\nusrmgr.cpl/nusrmgr.hta\"") },
};

TCHAR const c_szPolicyKey[]         = REGSTR_PATH_POLICIES TEXT("\\Explorer");
TCHAR const c_szPolicyVal[]         = TEXT("UserPasswordsVer");


HRESULT StartUserManager(LPCTSTR pszParams)
{
    TCHAR szApp[MAX_PATH];
    TCHAR szCommand[MAX_PATH];
    int iCommandIndex;
    STARTUPINFO rgStartup = {0};
    PROCESS_INFORMATION rgProcess = {0};

    // Default is to use the old UI
    iCommandIndex = 0;

#ifndef _WIN64
    if (IsOS(OS_PERSONAL) || (IsOS(OS_PROFESSIONAL) && !IsOS(OS_DOMAINMEMBER)))
    {
        // Switch to the friendly UI.
        iCommandIndex = 1;
    }
#endif

    ExpandEnvironmentStrings(s_rgCommands[iCommandIndex].pszApp, szApp, MAX_PATH);
    ExpandEnvironmentStrings(s_rgCommands[iCommandIndex].pszCommand, szCommand, MAX_PATH);

    if (pszParams && *pszParams != TEXT('\0'))
    {
        StrCatBuff(szCommand, TEXT(" "), MAX_PATH);
        StrCatBuff(szCommand, pszParams, MAX_PATH);
    }

    rgStartup.cb = sizeof(rgStartup);
    rgStartup.wShowWindow = SW_SHOWNORMAL;

    if (CreateProcess(szApp,
                      szCommand,
                      NULL,
                      NULL,
                      FALSE,
                      0,
                      NULL,
                      NULL,
                      &rgStartup,
                      &rgProcess))
    {
        WaitForInputIdle( rgProcess.hProcess, 10000 );
        CloseHandle( rgProcess.hProcess );
        CloseHandle( rgProcess.hThread );
        return S_OK;
    }

    return E_FAIL;
}


LONG APIENTRY CPlApplet(HWND hwnd, UINT Msg, LPARAM lParam1, LPARAM lParam2)
{
    LPCPLINFO lpCplInfo;

    switch (Msg)
    {
    case CPL_INIT:
        return TRUE;

    case CPL_GETCOUNT:
        return 1;

    case CPL_INQUIRE:
        lpCplInfo = (LPCPLINFO)lParam2;
        lpCplInfo->idIcon = IDI_CPLICON;
        lpCplInfo->idName = IDS_NAME;
        lpCplInfo->idInfo = IDS_INFO;
        lpCplInfo->lData  = 0;
        break;

    case CPL_DBLCLK:
        StartUserManager(NULL);
        return TRUE;

    case CPL_STARTWPARMS:
        StartUserManager((LPCTSTR)lParam2);
        return TRUE;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\nusrmgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by TaskUI.rc
//
#define IDS_NAME                        101
#define IDS_INFO                        102
#define ID_BACK                         103
#define ID_FORWARD                      104
#define ID_HOME                         105
#define IDS_TOOLTIP_BACK                106
#define IDS_TOOLTIP_FORWARD             107
#define IDS_TOOLTIP_HOME                108
#define IDR_ACCEL                       109
#define IDI_CPLICON                     200
#define IDB_NAVBAR                      201
#define IDB_NAVBARHOT                   202
#define IDB_NAVBARHICOLOR               203
#define IDB_NAVBARHOTHICOLOR            204
#define IDI_CPUSRPICT                   205

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        206
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         205
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\plus\debug.cpp ===
#include "precomp.hxx"
// Define some things for debug.h
//

#ifdef DBG
#define DEBUG
#endif

#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "plustab"
#define SZ_MODULE           "PLUSTAB"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\nusrmgr\toolbar.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 2001.
//
//  File:       Toolbar.cpp
//
//  Contents:   implementation of CToolbar
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "Toolbar.h"


class CAppCommandHook
{
public:
    static void SetHook(HWND hWnd)
    {
        CAppCommandHook *pach = _GetInfo(TRUE);
        if (pach)
        {
            if (NULL != pach->_hHook)
            {
                UnhookWindowsHookEx(pach->_hHook);
                pach->_hHook = NULL;
                pach->_hWnd = NULL;
            }
            if (NULL != hWnd)
            {
                pach->_hWnd = hWnd;
                pach->_hHook = SetWindowsHookEx(WH_SHELL, _HookProc, NULL, GetCurrentThreadId());
            }
        }
    }

    static void Unhook(void)
    {
        CAppCommandHook *pach = _GetInfo(FALSE);
        if (-1 != g_tlsAppCommandHook)
        {
            TlsSetValue(g_tlsAppCommandHook, NULL);
        }
        delete pach;
    }

private:
    CAppCommandHook() : _hHook(NULL), _hWnd(NULL) {}
    ~CAppCommandHook()
    {
        if (NULL != _hHook)
            UnhookWindowsHookEx(_hHook);
    }

    static CAppCommandHook* _GetInfo(BOOL bAlloc)
    {
        CAppCommandHook *pach = NULL;
        if (-1 != g_tlsAppCommandHook)
        {
            pach = (CAppCommandHook*)TlsGetValue(g_tlsAppCommandHook);

            if (NULL == pach && bAlloc)
            {
                pach = new CAppCommandHook;
                if (NULL != pach)
                {
                    TlsSetValue(g_tlsAppCommandHook, pach);
                }
            }
        }
        return pach;
    }

    static LRESULT CALLBACK _HookProc(int nCode, WPARAM wParam, LPARAM lParam)
    {
        CAppCommandHook *pach = _GetInfo(FALSE);
        if (pach)
        {
            if (nCode == HSHELL_APPCOMMAND && NULL != pach->_hWnd)
            {
                if (::SendMessage(pach->_hWnd, WM_APPCOMMAND, wParam, lParam))
                    return 0;
            }
            if (NULL != pach->_hHook)
                return CallNextHookEx(pach->_hHook, nCode, wParam, lParam);
        }
        return 0;
    }

private:
    HHOOK _hHook;
    HWND  _hWnd;
};


/////////////////////////////////////////////////////////////////////////////
// CToolbar

LRESULT CToolbar::_OnCreate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
{
    m_hAccel = LoadAccelerators(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDR_ACCEL));

    DWORD dwExStyle = TBSTYLE_EX_MIXEDBUTTONS;

    //
    // NTRAID#NTBUG9-300152-2001/02/02-jeffreys  Toolbar isn't mirrored
    //
    // The HTA frame window isn't getting the right layout style on mirrored
    // builds.  This style is normally inherited from parent to child, so
    // we shouldn't have to do anything here.
    //
    // However, I'm putting this in temporarily so the toolbar will be
    // mirrored for beta 2.  After beta 2, or whenever trident fixes the
    // HTA problem, this can be removed.
    //
    CComVariant varRTL;
    if (SUCCEEDED(GetAmbientProperty(DISPID_AMBIENT_RIGHTTOLEFT, varRTL))
        && varRTL.boolVal == VARIANT_TRUE)
    {
        dwExStyle |= WS_EX_NOINHERITLAYOUT | WS_EX_LAYOUTRTL;
    }

    RECT rc = {0,0,0,0};
    m_ctlToolbar.Create(m_hWnd,
                        &rc,
                        NULL,
                        WS_CHILD | WS_VISIBLE | CCS_NODIVIDER | CCS_TOP | CCS_NOPARENTALIGN | TBSTYLE_FLAT | TBSTYLE_LIST | TBSTYLE_TOOLTIPS,
                        dwExStyle);
    if (!m_ctlToolbar)
        return -1;

    m_ctlToolbar.SendMessage(TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);

    int idBmp = IDB_NAVBAR;
    if (SHGetCurColorRes() > 8)
        idBmp += (IDB_NAVBARHICOLOR - IDB_NAVBAR);

    m_himlNBDef = ImageList_LoadImageW(_Module.GetResourceInstance(),
                                       MAKEINTRESOURCE(idBmp),
                                       NAVBAR_CX,
                                       0,
                                       CLR_DEFAULT,
                                       IMAGE_BITMAP,
                                       LR_CREATEDIBSECTION);
    if (m_himlNBDef)
    {
        m_ctlToolbar.SendMessage(TB_SETIMAGELIST, 0, (LPARAM)m_himlNBDef);
    }

    m_himlNBHot = ImageList_LoadImageW(_Module.GetResourceInstance(),
                                       MAKEINTRESOURCE(idBmp+1),
                                       NAVBAR_CX,
                                       0,
                                       CLR_DEFAULT,
                                       IMAGE_BITMAP,
                                       LR_CREATEDIBSECTION);
    if (m_himlNBHot)
    {
        m_ctlToolbar.SendMessage(TB_SETHOTIMAGELIST, 0, (LPARAM)m_himlNBHot);
    }

    if (!m_himlNBDef && !m_himlNBHot)
    {
        // Must be serious low memory or other resource problems.
        // There's no point having a toolbar without any images.
        m_ctlToolbar.DestroyWindow();
        return -1;
    }

    TCHAR szBack[64];
    TCHAR szHome[64];
    TBBUTTON rgButtons[] =
    {
        {0, ID_BACK,    TBSTATE_ENABLED, BTNS_BUTTON | BTNS_AUTOSIZE | BTNS_SHOWTEXT, {0}, 0, (INT_PTR)szBack},
        {1, ID_FORWARD, TBSTATE_ENABLED, BTNS_BUTTON | BTNS_AUTOSIZE, {0}, 0, 0},
        {2, ID_HOME,    TBSTATE_ENABLED, BTNS_BUTTON | BTNS_AUTOSIZE | BTNS_SHOWTEXT, {0}, 0, (INT_PTR)szHome},
    };

    ::LoadStringW(_Module.GetResourceInstance(), ID_BACK, szBack, ARRAYSIZE(szBack));
    ::LoadStringW(_Module.GetResourceInstance(), ID_HOME, szHome, ARRAYSIZE(szHome));
    m_ctlToolbar.SendMessage(TB_ADDBUTTONSW, ARRAYSIZE(rgButtons), (LPARAM)rgButtons);

    // Update the position and extent stuff. Do this asynchronously since ATL
    // will call SetObjectRects shortly after we return from this method (with
    // the original rect).
    PostMessage(PWM_UPDATESIZE);

    // Set a hook to redirect WM_APPCOMMAND messages to our control window
    CAppCommandHook::SetHook(m_hWnd);

    return 0;
}

LRESULT CToolbar::_OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    CAppCommandHook::Unhook();
    return 0;
}

LRESULT CToolbar::_OnAppCommand(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
{
    switch (GET_APPCOMMAND_LPARAM(lParam))
    {
    case APPCOMMAND_BROWSER_BACKWARD:
        Fire_OnButtonClick(0);
        break;

    case APPCOMMAND_BROWSER_FORWARD:
        Fire_OnButtonClick(1);
        break;

    case APPCOMMAND_BROWSER_HOME:
        Fire_OnButtonClick(2);
        break;

    default:
        bHandled = FALSE;
        break;
    }
    return 0;
}

LRESULT CToolbar::_UpdateSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (m_ctlToolbar)
    {
        //
        // TB_AUTOSIZE causes m_ctlToolbar to set its preferred height, but it
        // doesn't adjust it's width or position because of the styles we use
        // (CCS_TOP | CCS_NOPARENTALIGN).
        //
        // The width will always be the same as m_rcPos because we keep them
        // in sync via SetObjectRects below.
        //
        // If the height is different after TB_AUTOSIZE, ask the container to
        // adjust our rect.
        //

        m_ctlToolbar.SendMessage(TB_AUTOSIZE, 0, 0);

        RECT rc;
        m_ctlToolbar.GetWindowRect(&rc);
        ::MapWindowPoints(NULL, GetParent(), (LPPOINT)&rc, 2);

        if ((rc.bottom - rc.top) != (m_rcPos.bottom - m_rcPos.top))
        {
            //
            // We only want to set the height (leave the width alone), but
            // OnPosRectChange sets both the height and the width. Moreover,
            // it sets the width to a fixed (pixel) width, nuking styles such
            // as "100%". We get around this by getting the current width
            // now and restoring it after calling OnPosRectChange.
            //
            CComPtr<IHTMLStyle> spStyle;
            CComVariant varWidth;
            CComQIPtr<IOleControlSite> spCtrlSite(m_spClientSite);
            if (spCtrlSite)
            {
                CComPtr<IDispatch> spDispatch;
                spCtrlSite->GetExtendedControl(&spDispatch);
                if (spDispatch)
                {
                    CComQIPtr<IHTMLElement> spElement(spDispatch);
                    if (spElement)
                    {
                        spElement->get_style(&spStyle);
                        if (spStyle)
                        {
                            spStyle->get_width(&varWidth);
                        }
                    }
                }
            }

            // Ask the container to give us a new rect
            m_spInPlaceSite->OnPosRectChange(&rc);

            // Restore the previous width style
            if (spStyle)
            {
                spStyle->setAttribute(L"width", varWidth, 0);
            }
        }
    }

    return 0;
}

HRESULT CToolbar::OnAmbientPropertyChange(DISPID dispid)
{
    switch (dispid)
    {
    case DISPID_UNKNOWN:
    case DISPID_AMBIENT_FONT:
        _ClearAmbientFont();
        _GetAmbientFont();
        m_ctlToolbar.SendMessage(WM_SETFONT, (WPARAM)m_hFont, FALSE);
        m_ctlToolbar.InvalidateRect(NULL);   // redraw
        break;
    }

    return S_OK;
}

void CToolbar::_ClearAmbientFont(void)
{
    if (m_pFont)
    {
        if (m_hFont)
            m_pFont->ReleaseHfont(m_hFont);
        m_pFont->Release();
        m_pFont = NULL;

    }
    m_hFont = NULL;
}

void CToolbar::_GetAmbientFont(void)
{
    if (!m_hFont)
    {
        // Try to get the ambient font from our container
        if (SUCCEEDED(GetAmbientFont(&m_pFont)))
        {
            if (SUCCEEDED(m_pFont->get_hFont(&m_hFont)))
            {
                // Yea, everybody is happy
                m_pFont->AddRefHfont(m_hFont);
            }
            else
            {
                // Darn, couldn't get the font from container
                _ClearAmbientFont();
            }
        }
    }
}

STDMETHODIMP CToolbar::get_enabled(VARIANT vIndex, VARIANT_BOOL *pVal)
{
    if (!pVal)
        return E_POINTER;

    *pVal = VARIANT_FALSE;

    if (FAILED(VariantChangeType(&vIndex, &vIndex, 0, VT_I4)))
        return E_INVALIDARG;

    LRESULT state = m_ctlToolbar.SendMessage(TB_GETSTATE, ID_BACK + vIndex.lVal, 0);
    if (-1 == state)
        return E_INVALIDARG;

    if (state & TBSTATE_ENABLED)
        *pVal = VARIANT_TRUE;

    return S_OK;
}

STDMETHODIMP CToolbar::put_enabled(VARIANT vIndex, VARIANT_BOOL newVal)
{
    if (FAILED(VariantChangeType(&vIndex, &vIndex, 0, VT_I4)))
        return E_INVALIDARG;

    m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_BACK + vIndex.lVal, MAKELONG((VARIANT_TRUE == newVal), 0));

    return S_OK;
}

void CToolbar::Fire_OnButtonClick(int buttonIndex)
{
    int nConnectionIndex;
    CComVariant* pvars = new CComVariant[1];
    int nConnections = m_vec.GetSize();

    for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
    {
        Lock();
        CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
        Unlock();
        IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
        if (pDispatch != NULL)
        {
            pvars[0] = buttonIndex;
            DISPPARAMS disp = { pvars, NULL, 1, 0 };
            pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
        }
    }
    delete[] pvars;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\nusrmgr\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__7705A854_5A8D_48E4_8E5D_E7209E726836__INCLUDED)
#define AFX_STDAFX_H__7705A854_5A8D_48E4_8E5D_E7209E726836__INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0501
#endif
#define _ATL_APARTMENT_THREADED

#include <windows.h>
#include <ctype.h>

#define DISALLOW_Assert             // Force to use ASSERT instead of Assert
#define DISALLOW_DebugMsg           // Force to use TraceMsg instead of DebugMsg
#include <debug.h>

#include <ccstock.h>
#include <shlguid.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <commctrl.h>
#include <comctrlp.h>   // HDPA
#include <shlwapi.h>
#include <shlwapip.h>
#include <shfusion.h>

#include <nusrmgr.h>    // our IDL generated header file

extern DWORD g_tlsAppCommandHook;

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlhost.h>
#include <atlwin.h>
#include <exdisp.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7705A854_5A8D_48E4_8E5D_E7209E726836__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\plus\effectsadvpg.cpp ===
/*****************************************************************************\
    FILE: EffectsAdvPg.cpp

    DESCRIPTION:
        This code will display the Effect tab in the Advanced Display Control
    panel.

    BryanSt 4/13/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "precomp.hxx"
#pragma hdrstop


#include "EffectsAdvPg.h"



typedef struct
{
    DWORD dwControlID;
    DWORD dwHelpContextID;
}POPUP_HELP_ARRAY;

POPUP_HELP_ARRAY phaMainDisplay[] = {
   { (DWORD)IDC_ICONS,              (DWORD)IDH_DISPLAY_EFFECTS_DESKTOP_ICONS },
   { (DWORD)IDC_CHANGEICON,         (DWORD)IDH_DISPLAY_EFFECTS_CHANGE_ICON_BUTTON },
   { (DWORD)IDC_LARGEICONS,         (DWORD)IDH_DISPLAY_EFFECTS_LARGE_ICONS_CHECKBOX },
   { (DWORD)IDC_ICONHIGHCOLOR,      (DWORD)IDH_DISPLAY_EFFECTS_ALL_COLORS_CHECKBOX  },
   { (DWORD)IDC_ICONDEFAULT,        (DWORD)IDH_DISPLAY_EFFECTS_DEFAULT_ICON_BUTTON },
   { (DWORD)IDC_MENUANIMATION,      (DWORD)IDH_DISPLAY_EFFECTS_ANIMATE_WINDOWS },
   { (DWORD)IDC_FONTSMOOTH,         (DWORD)IDH_DISPLAY_EFFECTS_SMOOTH_FONTS_CHECKBOX },
   { (DWORD)IDC_SHOWDRAG,           (DWORD)IDH_DISPLAY_EFFECTS_DRAG_WINDOW_CHECKBOX },
   { (DWORD)IDC_KEYBOARDINDICATORS, (DWORD)IDH_DISPLAY_EFFECTS_HIDE_KEYBOARD_INDICATORS },
   { (DWORD)IDC_GRPBOX_1,           (DWORD)IDH_COMM_GROUPBOX                 },
   { (DWORD)IDC_GRPBOX_2,           (DWORD)IDH_COMM_GROUPBOX                 },
   { (DWORD)IDC_COMBOEFFECT,        (DWORD)IDH_DISPLAY_EFFECTS_ANIMATE_LISTBOX },
   { (DWORD)IDC_COMBOFSMOOTH,       (DWORD)IDH_DISPLAY_EFFECTS_SMOOTH_FONTS_LISTBOX },
   { (DWORD)0, (DWORD)0 },
   { (DWORD)0, (DWORD)0 },          // double-null terminator NECESSARY!
};

/* Not using this table for win9x after win2k backport -- jonburs
POPUP_HELP_ARRAY phaMainWinPlus[] = {
   { (DWORD)IDC_ICONS,                          (DWORD)IDH_PLUS_PLUSPACK_LIST         },
   { (DWORD)IDC_CHANGEICON,                     (DWORD)IDH_PLUS_PLUSPACK_CHANGEICON   },
   { (DWORD)IDC_LARGEICONS,                     (DWORD)IDH_PLUS_PLUSPACK_LARGEICONS   },
   { (DWORD)IDC_ICONHIGHCOLOR,                  (DWORD)IDH_PLUS_PLUSPACK_ALLCOLORS    },
   { (DWORD)IDC_GRPBOX_1,                       (DWORD)IDH_COMM_GROUPBOX              },
   { (DWORD)IDC_GRPBOX_2,                       (DWORD)IDH_COMM_GROUPBOX              },
   { (DWORD)0, (DWORD)0 },
   { (DWORD)0, (DWORD)0 },          // double-null terminator NECESSARY!
};
*/

POPUP_HELP_ARRAY * g_phaHelp = NULL;
TCHAR g_szHelpFile[32];
BOOL  g_fCoInitDone = FALSE;         // track state of OLE CoInitialize()
HWND g_hWndList;          // handle to the list view window
HIMAGELIST g_hIconList;   // handles to image lists for large icons
ULONG   g_ulFontInformation, g_ulNewFontInformation;

typedef struct tagDefIcons
{
    int     iIndex;
    UINT    uPath;
    TCHAR   szFile[16];
}DEFICONS;

DEFICONS sDefaultIcons[NUM_ICONS] =
{
    { 0,PATH_WIN ,TEXT("\\EXPLORER.EXE")},  // "My Computer" default icon
    { 0,PATH_SYS ,TEXT("\\mydocs.dll")},    // "My Documents" default icon
#ifdef INET_EXP_ICON
    { 0,PATH_IEXP,TEXT("\\iexplore.exe")},  // "Internet Explorer" default icon
#endif
    {17,PATH_SYS, TEXT("\\shell32.dll")},   // "Net Neighbourhood" default icon
    {32,PATH_SYS, TEXT("\\shell32.dll")},   // "Trash full" default icon
    {31,PATH_SYS, TEXT("\\shell32.dll")},   // "Trash empty" default icon
#ifdef DIRECTORY_ICON
    { 0,PATH_SYS, TEXT("\\dsfolder.dll")},  // "Directory" default icon
#endif
};



//need to be L"..." since SHGetRestriction takes only LPCWSTR and this file is compiled as ANSI
#define POLICY_KEY_EXPLORER       L"Explorer"
#define POLICY_VALUE_ANIMATION    L"NoChangeAnimation"
#define POLICY_VALUE_KEYBOARDNAV  L"NoChangeKeyboardNavigationIndicators"

#ifdef CLEARTYPECOMBO
BOOL RegisterTextEdgeClass(void);
INT_PTR CALLBACK TextEdgeDlgProc( HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam );
BOOL DisplayFontSmoothingDetails(HWND hWnd, BOOL* pfFontSmoothing, DWORD *pdwSmoothingType);
static void EnableDlgItem(HWND dlg, int idkid, BOOL val);
void ShowTextRedraw(HWND hDlg);
#endif // CLEARTYPECOMBO



//===========================
// *** Class Internals & Helpers ***
//===========================
STDAPI SHPropertyBag_WriteByRef(IN IPropertyBag * pPropertyPage, IN LPCWSTR pwzPropName, IN void * p)
{
    HRESULT hr = E_INVALIDARG;

    if (pPropertyPage && pwzPropName && p)
    {
        VARIANT va;

        va.vt = VT_BYREF;
        va.byref = p;
        hr = pPropertyPage->Write(pwzPropName, &va);
    }

    return hr;
}


STDAPI SHPropertyBag_ReadByRef(IN IPropertyBag * pPropertyPage, IN LPCWSTR pwzPropName, IN void * p, IN SIZE_T cbSize)
{
    HRESULT hr = E_INVALIDARG;

    if (pPropertyPage && pwzPropName && p)
    {
        VARIANT va;

        hr = pPropertyPage->Read(pwzPropName, &va, NULL);
        if (SUCCEEDED(hr))
        {
            if ((VT_BYREF == va.vt) && va.byref)
            {
                CopyMemory(p, va.byref, cbSize);
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }

    return hr;
}


//  ExtractPlusColorIcon
//
//  Extract Icon from a file in proper Hi or Lo color for current system display
//
// from FrancisH on 6/22/95 with mods by TimBragg
HRESULT ExtractPlusColorIcon( LPCTSTR szPath, int nIndex, HICON *phIcon,
                              UINT uSizeLarge, UINT uSizeSmall)
{
    IShellLink *psl;
    HRESULT hres;
    HICON hIcons[2];    // MUST! - provide for TWO return icons

    if (!g_fCoInitDone)
    {
        if (SUCCEEDED(CoInitialize(NULL)))
            g_fCoInitDone = TRUE;
    }

    *phIcon = NULL;
    if (SUCCEEDED(hres = CoCreateInstance(CLSID_ShellLink, NULL,
        CLSCTX_INPROC_SERVER, IID_IShellLink, (void**)&psl)))
    {
        if (SUCCEEDED(hres = psl->SetIconLocation(szPath, nIndex)))
        {
            IExtractIcon *pei;
            if (SUCCEEDED(hres = psl->QueryInterface(IID_IExtractIcon, (void**)&pei)))
            {
                if (SUCCEEDED(hres = pei->Extract(szPath, nIndex,
                    &hIcons[0], &hIcons[1], (UINT)MAKEWPARAM((WORD)uSizeLarge,
                    (WORD)uSizeSmall))))
                {
                    *phIcon = hIcons[0];    // Return first icon to caller
                }

                pei->Release();
            }
        }

        psl->Release();
    }

    return hres;
}   // end ExtractPlusColorIcon()


BOOL FadeEffectAvailable()
{
    BOOL fFade = FALSE, fTestFade = FALSE;
    
    SystemParametersInfo( SPI_GETMENUFADE, 0, (PVOID)&fFade, 0 );
    if (fFade) 
        return TRUE;
    
    SystemParametersInfo( SPI_SETMENUFADE, 0, (PVOID)1, 0);
    SystemParametersInfo( SPI_GETMENUFADE, 0, (PVOID)&fTestFade, 0 );
    SystemParametersInfo( SPI_SETMENUFADE, 0, IntToPtr(fFade), 0);

    return (fTestFade);
}


HRESULT CEffectsPage::_OnApply(HWND hDlg)
{
    HRESULT hr = S_OK;

    // Full Color Icons
    if (m_pEffectsState && (m_pEffectsState->_nOldHighIconColor != m_pEffectsState->_nHighIconColor))
    {
        if ((GetBitsPerPixel() < 16) && (m_pEffectsState->_nHighIconColor == 16)) // Display mode won't support icon high colors
        {
            TCHAR szTemp1[512];
            TCHAR szTemp2[256];

            LoadString(g_hInst, IDS_256COLORPROBLEM, szTemp1, ARRAYSIZE(szTemp1));
            LoadString(g_hInst, IDS_ICONCOLORWONTWORK, szTemp2, ARRAYSIZE(szTemp2));
            StrCatBuff(szTemp1, szTemp2, ARRAYSIZE(szTemp1));
            LoadString(g_hInst, IDS_EFFECTS, szTemp2, ARRAYSIZE(szTemp2));

            MessageBox(hDlg, szTemp1, szTemp2, MB_OK|MB_ICONINFORMATION);
        }
    }

    return hr;
}


HRESULT CEffectsPage::_OnInit(HWND hDlg)
{
    HRESULT hr = S_OK;
    TCHAR szRes[100];

    if (!m_pEffectsState)
    {
        return E_INVALIDARG;
    }

    //////////////////////////////////////////////////////////////////////////
    // Load the state from persisted form (registry) to the state struct
    //////////////////////////////////////////////////////////////////////////
    m_nIndex = 0;

    g_bMirroredOS = IS_MIRRORING_ENABLED();

    // Create our list view and fill it with the system icons
    _CreateListView(hDlg);

    // Get the name of our help file.  For Memphis, it's
    // IDS_HELPFILE_PLUS for NT it's IDS_HELPFILE.
    // g_phaHelp = phaMainWinPlus;

    // Running Win2k shellport, want Win2k helpfile and resources
    g_phaHelp = phaMainDisplay;

    LoadString(g_hInst, IDS_HELPFILE, g_szHelpFile, 32);


    //////////////////////////////////////////////////////////////////////////
    // Update UI based on the state struct
    //////////////////////////////////////////////////////////////////////////
    if (m_pEffectsState->_nLargeIcon == ICON_INDETERMINATE)
    {
        HWND hItem = GetDlgItem(hDlg, IDC_LARGEICONS);
        SendMessage(hItem, BM_SETSTYLE, (WPARAM)LOWORD(BS_AUTO3STATE), MAKELPARAM(FALSE,0));
    }

    // Set CheckBoxes
    SendMessage((HWND)GetDlgItem(hDlg, IDC_LARGEICONS), BM_SETCHECK, (WPARAM)m_pEffectsState->_nLargeIcon, 0);
    SendMessage((HWND)GetDlgItem(hDlg, IDC_MENUSHADOWS), BM_SETCHECK, (WPARAM)m_pEffectsState->_fMenuShadows, 0);
    SendMessage((HWND)GetDlgItem(hDlg, IDC_ICONHIGHCOLOR ), BM_SETCHECK, (WPARAM)(BOOL)(m_pEffectsState->_nHighIconColor == 16), 0);
    SendMessage((HWND)GetDlgItem(hDlg, IDC_MENUANIMATION), BM_SETCHECK, (WPARAM)m_pEffectsState->_wpMenuAnimation, 0);
    SendMessage((HWND)GetDlgItem(hDlg, IDC_FONTSMOOTH), BM_SETCHECK, (WPARAM)m_pEffectsState->_fFontSmoothing, 0);
    SendMessage((HWND)GetDlgItem(hDlg, IDC_SHOWDRAG), BM_SETCHECK, (WPARAM)m_pEffectsState->_fDragWindow, 0);
    SendMessage((HWND)GetDlgItem(hDlg, IDC_KEYBOARDINDICATORS), BM_SETCHECK, (WPARAM)(m_pEffectsState->_fKeyboardIndicators ? BST_UNCHECKED : BST_CHECKED), 0);


    // Set Effects Drop Down
    HWND hwndCombo = GetDlgItem(hDlg,IDC_COMBOEFFECT);
    ComboBox_ResetContent(hwndCombo);
    LoadString(g_hInst, IDS_FADEEFFECT, szRes, ARRAYSIZE(szRes) );
    ComboBox_AddString(hwndCombo, szRes);
    LoadString(g_hInst, IDS_SCROLLEFFECT, szRes, ARRAYSIZE(szRes) );
    ComboBox_AddString(hwndCombo, szRes);
    ComboBox_SetCurSel(hwndCombo, (MENU_EFFECT_FADE == m_pEffectsState->_dwAnimationEffect) ? 0 : 1);
    EnableWindow(hwndCombo, (UINT)m_pEffectsState->_wpMenuAnimation);

    if (!FadeEffectAvailable()) 
    {
        ShowWindow(GetDlgItem(hDlg, IDC_COMBOEFFECT), SW_HIDE);
    }

    if (0 != SHGetRestriction(NULL,POLICY_KEY_EXPLORER,POLICY_VALUE_ANIMATION))
    {
        //disable
        //0=     enable
        //non-0= disable
        //relies on the fact that if the key does not exist it returns 0 as well
        EnableWindow((HWND)GetDlgItem(hDlg, IDC_MENUANIMATION), FALSE);
        EnableWindow((HWND)GetDlgItem(hDlg, IDC_COMBOEFFECT), FALSE);
    }

    hwndCombo = GetDlgItem(hDlg,IDC_COMBOFSMOOTH); 
#ifdef CLEARTYPECOMBO
    ComboBox_ResetContent(hwndCombo);
    LoadString(g_hInst, IDS_STANDARDSMOOTHING, szRes, ARRAYSIZE(szRes));
    ComboBox_AddString(hwndCombo, szRes);
    LoadString(g_hInst, IDS_CLEARTYPE, szRes, ARRAYSIZE(szRes));
    ComboBox_AddString(hwndCombo, szRes);

    BOOL fTemp;
    ComboBox_SetCurSel(hwndCombo, m_pEffectsState->_dwFontSmoothingType-1);
    if (SystemParametersInfo(SPI_GETFONTSMOOTHINGTYPE, 0, (PVOID)&fTemp, 0)) 
    {
        EnableWindow((HWND)hwndCombo, m_pEffectsState->_fFontSmoothing);
    }
    else
    {
        ShowWindow(hwndCombo, SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDC_SHOWME), SW_HIDE);
    }
#else
    ShowWindow(hwndCombo, SW_HIDE);
    ShowWindow(GetDlgItem(hDlg, IDC_SHOWME), SW_HIDE);
#endif //CLEARTYPECOMBO


    if (0 != SHGetRestriction(NULL,POLICY_KEY_EXPLORER,POLICY_VALUE_KEYBOARDNAV))
    {
        //disable, see comment for animation
        EnableWindow((HWND)GetDlgItem(hDlg, IDC_KEYBOARDINDICATORS), FALSE);
    }

    //disable and uncheck things if we are on terminal server
    BOOL bEffectsEnabled;
    if (!SystemParametersInfo(SPI_GETUIEFFECTS, 0, (PVOID) &bEffectsEnabled, 0))
    {
        // This flag is only available on Win2k and later. We're depending
        // on the call returning false if the flag doesn't exist...
        bEffectsEnabled = TRUE;
    }
    
    if (!bEffectsEnabled || SHGetMachineInfo(GMI_TSCLIENT))
    {
        EnableWindow((HWND)GetDlgItem( hDlg, IDC_MENUANIMATION), FALSE);
        EnableWindow((HWND)GetDlgItem(hDlg, IDC_ICONHIGHCOLOR), FALSE);
        EnableWindow((HWND)GetDlgItem(hDlg, IDC_KEYBOARDINDICATORS), FALSE);
        EnableWindow((HWND)GetDlgItem(hDlg, IDC_FONTSMOOTH), FALSE);
        ShowWindow(GetDlgItem( hDlg, IDC_COMBOEFFECT ), SW_HIDE);
        SendDlgItemMessage(hDlg, IDC_MENUANIMATION, BM_SETCHECK, 0, 0);
        SendDlgItemMessage(hDlg, IDC_ICONHIGHCOLOR, BM_SETCHECK, 0, 0);
        SendDlgItemMessage(hDlg, IDC_KEYBOARDINDICATORS, BM_SETCHECK, 0, 0);
        SendDlgItemMessage(hDlg, IDC_FONTSMOOTH, BM_SETCHECK, 0, 0);
    }

    // We remove the Keyboard indicators check box on non-NT platform since User32
    // does not provide the functionality to implement the feature.
    if (!g_RunningOnNT)
    {
        HWND hwndSWC = GetDlgItem(hDlg, IDC_SHOWDRAG);
        HWND hwndKI = GetDlgItem(hDlg, IDC_KEYBOARDINDICATORS);
        HWND hwndGroup = GetDlgItem(hDlg, IDC_GRPBOX_2);

        // Hide the Hide keyboard cues check box on non-NT platform
        ShowWindow(hwndKI, SW_HIDE);

        // Calculate the bottom margin
        RECT rect;
        RECT rectGroup;
        GetWindowRect(hwndKI, &rect);
        GetWindowRect(hwndGroup, &rectGroup);
        int margin = rectGroup.bottom - rect.bottom;

        GetWindowRect(hwndSWC, &rect);
        SetWindowPos(hwndGroup, HWND_TOP, 0, 0, rectGroup.right - rectGroup.left,
            rect.bottom - rectGroup.top + margin, SWP_NOMOVE | SWP_NOZORDER);
    }

    return hr;
}


HRESULT CEffectsPage::_OnCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL fHandled = 1;   // Not handled (WM_COMMAND seems to be different)
    WORD idCtrl = GET_WM_COMMAND_ID(wParam, lParam);
    WORD wEvent = GET_WM_COMMAND_CMD(wParam, lParam);
    BOOL bDorked = FALSE;

    switch (idCtrl)
    {
    case IDOK:
        EndDialog(hDlg, IDOK);
        break;

    case IDCANCEL:
        EndDialog(hDlg, IDCANCEL);
        break;

    case IDC_LARGEICONS:
        if (m_pEffectsState)
        {
            m_pEffectsState->_nLargeIcon  = (int)SendMessage ( (HWND)lParam, BM_GETCHECK, 0, 0 );
            bDorked = TRUE;
        }
        break;

    case IDC_MENUSHADOWS:
        if (m_pEffectsState)
        {
            m_pEffectsState->_fMenuShadows  = (int)SendMessage ( (HWND)lParam, BM_GETCHECK, 0, 0 );
            bDorked = TRUE;
        }
        break;

    case IDC_ICONHIGHCOLOR:
        if (m_pEffectsState)
        {
            m_pEffectsState->_nHighIconColor = 4;
            if (SendMessage((HWND)lParam, BM_GETCHECK, 0, 0) == TRUE)
            {
                m_pEffectsState->_nHighIconColor = 16;
            }
            bDorked = TRUE;
        }
        break;

    case IDC_SHOWDRAG:
        if (m_pEffectsState)
        {
            m_pEffectsState->_fDragWindow = (SendMessage( (HWND)lParam, BM_GETCHECK, 0, 0 ) == BST_CHECKED);
            bDorked = TRUE;
        }
        break;

    case IDC_MENUANIMATION:
        if (m_pEffectsState)
        {
            switch (m_pEffectsState->_wpMenuAnimation)
            {
            case BST_UNCHECKED:
                m_pEffectsState->_wpMenuAnimation = BST_CHECKED;
                break;

            case BST_CHECKED:
                m_pEffectsState->_wpMenuAnimation = BST_UNCHECKED;
                break;

            case BST_INDETERMINATE:
                m_pEffectsState->_wpMenuAnimation = BST_UNCHECKED;
                break;
            }
            SendMessage( (HWND)lParam, BM_SETCHECK, (WPARAM)m_pEffectsState->_wpMenuAnimation, 0 );
            EnableWindow((HWND)GetDlgItem( hDlg, IDC_COMBOEFFECT), (BST_CHECKED == m_pEffectsState->_wpMenuAnimation));
            bDorked = TRUE;
        }
        break;

    case IDC_COMBOEFFECT:
        if ((wEvent == CBN_SELCHANGE) && m_pEffectsState)
        {
            m_pEffectsState->_dwAnimationEffect = (DWORD)ComboBox_GetCurSel(GetDlgItem(hDlg, IDC_COMBOEFFECT)) + 1;
            bDorked = TRUE;
        }
        break;
        
#ifdef CLEARTYPECOMBO
    case IDC_COMBOFSMOOTH:
        if ((wEvent == CBN_SELCHANGE) && m_pEffectsState)
        {
            m_pEffectsState->_dwFontSmoothingType = (DWORD)ComboBox_GetCurSel(GetDlgItem(hDlg, IDC_COMBOFSMOOTH)) + 1;
            bDorked = TRUE;
        }
        break;
#endif                    
    case IDC_FONTSMOOTH:
        if (m_pEffectsState)
        {
            m_pEffectsState->_fFontSmoothing = (SendMessage( (HWND)lParam, BM_GETCHECK, 0, 0 ) == BST_CHECKED);
#ifdef CLEARTYPECOMBO
            EnableWindow((HWND)GetDlgItem( hDlg, IDC_COMBOFSMOOTH), m_pEffectsState->_fFontSmoothing);
            if (m_pEffectsState->_fFontSmoothing)
                m_pEffectsState->_dwFontSmoothingType = ((DWORD)ComboBox_GetCurSel(GetDlgItem(hDlg, IDC_COMBOFSMOOTH)) + 1);
#endif
            bDorked = TRUE;
        }
        break;

    case IDC_CHANGEICON:
        if (m_pEffectsState)
        {
            INT i = m_pEffectsState->_IconData[m_nIndex].iOldIndex;
            WCHAR szTemp[ MAX_PATH ];
            TCHAR szExp[ MAX_PATH ];

            ExpandEnvironmentStrings(m_pEffectsState->_IconData[m_nIndex].szOldFile, szExp, ARRAYSIZE(szExp));

            if (g_RunningOnNT)
            {
                SHTCharToUnicode(szExp, szTemp, ARRAYSIZE(szTemp));
            }
            else
            {
                SHTCharToAnsi(szExp, (LPSTR)szTemp, ARRAYSIZE(szTemp));
            }

            if (PickIconDlg(hDlg, (LPTSTR)szTemp, ARRAYSIZE(szTemp), &i) == TRUE)
            {
                HICON hIcon;

                if (g_RunningOnNT)
                {
                    SHUnicodeToTChar(szTemp, m_pEffectsState->_IconData[m_nIndex].szNewFile, ARRAYSIZE(m_pEffectsState->_IconData[m_nIndex].szNewFile));
                }
                else
                {
                    SHAnsiToTChar((LPSTR)szTemp, m_pEffectsState->_IconData[m_nIndex].szNewFile, ARRAYSIZE(m_pEffectsState->_IconData[m_nIndex].szNewFile));
                }
                m_pEffectsState->_IconData[m_nIndex].iNewIndex = i;
                ExtractPlusColorIcon(m_pEffectsState->_IconData[m_nIndex].szNewFile, m_pEffectsState->_IconData[m_nIndex].iNewIndex, &hIcon, 0, 0);

                ImageList_ReplaceIcon(g_hIconList, m_nIndex, hIcon);
                ListView_RedrawItems(g_hWndList, m_nIndex, m_nIndex);
                bDorked = TRUE;
            }
            SetFocus(g_hWndList);
        }
        break;

    case IDC_ICONDEFAULT:
    {
        TCHAR szTemp[_MAX_PATH];
        HICON hIcon;

        switch( sDefaultIcons[m_nIndex].uPath )
        {
        case PATH_WIN:
            GetWindowsDirectory( szTemp, ARRAYSIZE(szTemp) );
            break;

#ifdef INET_EXP_ICON
        case PATH_IEXP:
            if (g_RunningOnNT)
            {
                StrCpyN(szTemp, TEXT("%SystemDrive%"), ARRAYSIZE(szTemp));
            }
            else
            {
                GetWindowsDirectory( szTemp, ARRAYSIZE(szTemp) );

                // Clear out path after drive, ie: C:
                szTemp[ 2 ] = 0;
            }
            StrCatBuff(szTemp, c_szIEXP, ARRAYSIZE(szTemp));
            break;
#endif

        case PATH_SYS:
        default:
            GetSystemDirectory( szTemp, ARRAYSIZE(szTemp) );
            break;
        }

        if (m_pEffectsState)
        {
            StrCatBuff(szTemp, sDefaultIcons[m_nIndex].szFile, ARRAYSIZE(szTemp));
            StrCpyN(m_pEffectsState->_IconData[m_nIndex].szNewFile, szTemp, ARRAYSIZE(m_pEffectsState->_IconData[m_nIndex].szNewFile));
            m_pEffectsState->_IconData[m_nIndex].iNewIndex = sDefaultIcons[m_nIndex].iIndex;

            ExtractPlusColorIcon(m_pEffectsState->_IconData[m_nIndex].szNewFile, m_pEffectsState->_IconData[m_nIndex].iNewIndex, &hIcon, 0, 0);

            ImageList_ReplaceIcon(g_hIconList, m_nIndex, hIcon);
            ListView_RedrawItems(g_hWndList, m_nIndex, m_nIndex);
            bDorked = TRUE;
            SetFocus(g_hWndList);
        }
    }
    break;

    case IDC_KEYBOARDINDICATORS:
        if (m_pEffectsState)
        {
            m_pEffectsState->_fKeyboardIndicators = ((SendMessage((HWND)lParam, BM_GETCHECK, 0, 0) == BST_CHECKED) ? FALSE : TRUE);
            bDorked = TRUE;
        }
        break;

    default:
        break;
    }

    // If the user dorked with a setting, tell the property manager we
    // have outstanding changes. This will enable the "Apply Now" button...
    if (bDorked)
    {
        SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
    }

    return fHandled;
}


INT_PTR CALLBACK PropertySheetDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CEffectsPage * pThis = (CEffectsPage *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (WM_INITDIALOG == wMsg)
    {
        pThis = (CEffectsPage *) lParam;

        if (pThis)
        {
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        }
    }

    if (pThis)
        return pThis->_PropertySheetDlgProc(hDlg, wMsg, wParam, lParam);

    return DefWindowProc(hDlg, wMsg, wParam, lParam);
}



//---------------------------------------------------------------------------
//
// PropertySheetDlgProc()
//
//  The dialog procedure for the "PlusPack" property sheet page.
//
//---------------------------------------------------------------------------
INT_PTR CEffectsPage::_PropertySheetDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    BOOL bDorked = FALSE;

    switch( uMessage )
    {
    case WM_INITDIALOG:
        _OnInit(hDlg);
    break;

    case WM_DESTROY:
        if (g_fCoInitDone)
        {
            CoUninitialize();
            g_fCoInitDone = FALSE;
        }
        if (g_hmodShell32)
        {
            FreeLibrary(g_hmodShell32);
            g_hmodShell32 = NULL;
        }
        break;


    case WM_COMMAND:
        _OnCommand(hDlg, uMessage, wParam, lParam);
        break;

    case WM_NOTIFY:
        switch( ((NMHDR *)lParam)->code )
        {   
#ifdef CLEARTYPECOMBO
        case NM_CLICK:
            switch (wParam)
            {
                case IDC_SHOWME:
                    if (m_pEffectsState)
                    {
                        DWORD dwSmoothingType = m_pEffectsState->_dwFontSmoothingType;
                        BOOL fFontSmoothing = m_pEffectsState->_fFontSmoothing;
                        if (DisplayFontSmoothingDetails(hDlg, &fFontSmoothing, &dwSmoothingType) &&
                            ((m_pEffectsState->_dwFontSmoothingType != dwSmoothingType)
                            || (m_pEffectsState->_fFontSmoothing != fFontSmoothing)))
                        {
                            m_pEffectsState->_dwFontSmoothingType = dwSmoothingType;
                            m_pEffectsState->_fFontSmoothing = fFontSmoothing;
                            bDorked = TRUE;
                            SendMessage( GetParent( hDlg ), PSM_CHANGED, (WPARAM)hDlg, 0L );

                            ComboBox_SetCurSel(GetDlgItem(hDlg, IDC_COMBOFSMOOTH), dwSmoothingType - 1);

                            if (fFontSmoothing)
                            {
                                EnableWindow(GetDlgItem(hDlg,IDC_COMBOFSMOOTH), TRUE);
                            }
                            else
                            {
                                EnableWindow(GetDlgItem(hDlg,IDC_COMBOFSMOOTH), FALSE);
                            }

                            SendMessage( (HWND)GetDlgItem( hDlg, IDC_FONTSMOOTH ),
                                                           BM_SETCHECK,
                                                           (WPARAM) fFontSmoothing,
                                                           0
                                                         );
                        }
                    }
                    break;
            }
            break;
#endif                    
        case LVN_ITEMCHANGED:   // The selection changed in our listview
            if( wParam == IDC_ICONS )
            {
                // Find out who's selected now
                for( m_nIndex = 0; m_nIndex < NUM_ICONS;m_nIndex++ )
                {
                    if( ListView_GetItemState(g_hWndList, m_nIndex, LVIS_SELECTED))
                    {
                        break;
                    }
                }

            }
            break;

        default:
            break;
        }
        break;

    case WM_HELP:
    {
        LPHELPINFO lphi = (LPHELPINFO)lParam;

        if( lphi->iContextType == HELPINFO_WINDOW )
        {
            WinHelp( (HWND)lphi->hItemHandle, (LPTSTR)g_szHelpFile,
                     HELP_WM_HELP, (DWORD_PTR)((POPUP_HELP_ARRAY FAR *)g_phaHelp));
        }
    }
        break;

    case WM_CONTEXTMENU:
        // first check for dlg window
        if( (HWND)wParam == hDlg )
        {
            // let the def dlg proc decide whether to respond or ignore;
            // necessary for title bar sys menu on right click
            return FALSE;       // didn't process message EXIT
        }
        else
        {
            // else go for the controls
            WinHelp( (HWND)wParam, (LPTSTR)g_szHelpFile,
                     HELP_CONTEXTMENU, (DWORD_PTR)((POPUP_HELP_ARRAY FAR *)g_phaHelp));
        }
        break;

    default:
        return FALSE;
    }
    return(TRUE);
}


/****************************************************************************
*
*    FUNCTION: CreateListView(HWND)
*
*    PURPOSE:  Creates the list view window and initializes it
*
****************************************************************************/
HWND CEffectsPage::_CreateListView(HWND hWndParent)
{
    LV_ITEM lvI;            // List view item structure
    TCHAR   szTemp[MAX_PATH];
    BOOL bEnable = FALSE;
#ifdef JIGGLE_FIX
    RECT rc;
#endif
    UINT flags = ILC_MASK | ILC_COLOR24;
    // Create a device independant size and location
    LONG lWndunits = GetDialogBaseUnits();
    int iWndx = LOWORD(lWndunits);
    int iWndy = HIWORD(lWndunits);
    int iX = ((11 * iWndx) / 4);
    int iY = ((15 * iWndy) / 8);
    int iWidth = ((163 * iWndx) / 4);
    int iHeight = ((40 * iWndy) / 8);

    // Ensure that the common control DLL is loaded.
    InitCommonControls();

    // Get the list view window
    g_hWndList = GetDlgItem(hWndParent, IDC_ICONS);
    if(g_hWndList == NULL)
        return NULL;
    if(IS_WINDOW_RTL_MIRRORED(hWndParent))
    {
        flags |= ILC_MIRROR;
    }
    // initialize the list view window
    // First, initialize the image lists we will need
    g_hIconList = ImageList_Create( 32, 32, flags, NUM_ICONS, 0 );   // create an image list for the icons

    // load the icons and add them to the image lists
    // get the icon files and indexes from the registry, including for the Default recycle bin
    for (iX = 0; iX < ARRAYSIZE(m_pEffectsState->_IconData); iX++)
    {
        HICON hIcon;

        ExtractPlusColorIcon(m_pEffectsState->_IconData[iX].szNewFile, m_pEffectsState->_IconData[iX].iNewIndex, &hIcon, 0, 0);

        // Added this "if" to fix bug 2831.  We want to use SHELL32.DLL
        // icon 0 if there is no icon in the file specified in the
        // registry (or if the registry didn't specify a file).
        if(hIcon == NULL)
        {
            GetSystemDirectory(szTemp, ARRAYSIZE(szTemp));
            PathAppend(szTemp, TEXT("shell32.dll"));
            StrCpyN(m_pEffectsState->_IconData[iX].szOldFile, szTemp, ARRAYSIZE(m_pEffectsState->_IconData[iX].szNewFile));
            StrCpyN(m_pEffectsState->_IconData[iX].szNewFile, szTemp, ARRAYSIZE(m_pEffectsState->_IconData[iX].szNewFile));
            m_pEffectsState->_IconData[iX].iOldIndex = m_pEffectsState->_IconData[iX].iNewIndex = 0;

            ExtractPlusColorIcon(szTemp, 0, &hIcon, 0, 0);
        }

        if (ImageList_AddIcon(g_hIconList, hIcon) == -1)
        {
            return NULL;
        }
    }

    // Make sure that all of the icons were added
    if( ImageList_GetImageCount(g_hIconList) < NUM_ICONS )
        return FALSE;

    ListView_SetImageList(g_hWndList, g_hIconList, LVSIL_NORMAL);

    // Make sure the listview has WS_HSCROLL set on it.
    DWORD dwStyle = GetWindowLong(g_hWndList, GWL_STYLE);
    SetWindowLong(g_hWndList, GWL_STYLE, (dwStyle & (~WS_VSCROLL)) | WS_HSCROLL);

    // Finally, let's add the actual items to the control.  Fill in the LV_ITEM
    // structure for each of the items to add to the list.  The mask specifies
    // the the .pszText, .iImage, and .state members of the LV_ITEM structure are valid.
    lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE;
    lvI.state = 0;
    lvI.stateMask = 0;

    for( iX = 0; iX < NUM_ICONS; iX++ )
    {
        TCHAR szAppend[64];
        BOOL bRet;

        bRet = IconGetRegValueString(c_aIconRegKeys[iX].pclsid, NULL, NULL, szTemp, ARRAYSIZE(szTemp));

        // if the title string was in the registry, else we have to use the default in our resources
        if( (bRet) && (lstrlen(szTemp) > 0))
        {
            if( LoadString(g_hInst, c_aIconRegKeys[iX].iTitleResource, szAppend, 64) != 0)
            {
                StrCatBuff(szTemp, szAppend, ARRAYSIZE(szTemp));
            }
        }
        else
        {
            LoadString(g_hInst, c_aIconRegKeys[iX].iDefaultTitleResource, szTemp, ARRAYSIZE(szTemp));
        }

        lvI.iItem = iX;
        lvI.iSubItem = 0;
        lvI.pszText = szTemp;
        lvI.iImage = iX;

        if(ListView_InsertItem(g_hWndList, &lvI) == -1)
            return NULL;

    }
#ifdef JIGGLE_FIX
    // To fix long standing listview bug, we need to "jiggle" the listview
    // window size so that it will do a recompute and realize that we need a
    // scroll bar...
    GetWindowRect(g_hWndList, &rc);
    MapWindowPoints( NULL, hWndParent, (LPPOINT)&rc, 2 );
    MoveWindow(g_hWndList, rc.left, rc.top, rc.right - rc.left+1, rc.bottom - rc.top, FALSE );
    MoveWindow(g_hWndList, rc.left, rc.top, rc.right - rc.left,   rc.bottom - rc.top, FALSE );
#endif
    // Set First item to selected
    ListView_SetItemState (g_hWndList, 0, LVIS_SELECTED, LVIS_SELECTED);

    // Get Selected item
    for (m_nIndex = 0; m_nIndex < NUM_ICONS; m_nIndex++)
    {
        if (ListView_GetItemState(g_hWndList, m_nIndex, LVIS_SELECTED))
        {
            bEnable = TRUE;
            break;
        }
    }

    EnableWindow( GetDlgItem( hWndParent, IDC_CHANGEICON ), bEnable );
    EnableWindow( GetDlgItem( hWndParent, IDC_ICONDEFAULT ), bEnable );

    return g_hWndList;
}


HRESULT CEffectsPage::_IsDirty(IN BOOL * pIsDirty)
{
    HRESULT hr = E_INVALIDARG;

    if (pIsDirty && m_pEffectsState)
    {
        // Ask state if it's dirty
        *pIsDirty = m_pEffectsState->IsDirty();
        hr = S_OK;
    }

    return hr;
}







//===========================
// *** IAdvancedDialog Interface ***
//===========================
HRESULT CEffectsPage::DisplayAdvancedDialog(IN HWND hwndParent, IN IPropertyBag * pBasePage, IN BOOL * pfEnableApply)
{
    HRESULT hr = E_INVALIDARG;

    if (hwndParent && pBasePage && pfEnableApply)
    {
        // Load State Into Advanced Dialog 
        if (m_pEffectsState)
        {
            delete m_pEffectsState;
            m_pEffectsState = NULL;
        }

        *pfEnableApply = FALSE;
        CEffectState * pEffectClone;

        hr = SHPropertyBag_ReadByRef(pBasePage, SZ_PBPROP_EFFECTSSTATE, (void *)&pEffectClone, sizeof(pEffectClone));
        if (SUCCEEDED(hr))
        {
            // We want a copy of their state
            hr = pEffectClone->Clone(&m_pEffectsState);
            if (SUCCEEDED(hr))
            {
                LinkWindow_RegisterClass();

                // Display Advanced Dialog
                if (IDOK == DialogBoxParam(g_hInst, MAKEINTRESOURCE(PROP_SHEET_DLG), hwndParent, PropertySheetDlgProc, (LPARAM)this))
                {
                    // The user clicked OK, so merge modified state back into base dialog
                    _IsDirty(pfEnableApply);

                    // The user clicked Okay in the dialog so merge the dirty state from the
                    // advanced dialog into the base dialog.
                    hr = SHPropertyBag_WriteByRef(pBasePage, SZ_PBPROP_EFFECTSSTATE, (void *)m_pEffectsState);
                    m_pEffectsState = NULL;
                }
            }

            LinkWindow_UnregisterClass(g_hInst);
        }
    }

    return hr;
}





//===========================
// *** IUnknown Interface ***
//===========================
ULONG CEffectsPage::AddRef()
{
    m_cRef++;
    return m_cRef;
}


ULONG CEffectsPage::Release()
{
    Assert(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}


HRESULT CEffectsPage::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hr = E_NOINTERFACE;

    static const QITAB qit[] =
    {
        QITABENT(CEffectsPage, IObjectWithSite),
        QITABENT(CEffectsPage, IAdvancedDialog),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}




//===========================
// *** Class Methods ***
//===========================
CEffectsPage::CEffectsPage() : m_cRef(1)
{
    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    m_fDirty = FALSE;
}


CEffectsPage::~CEffectsPage()
{
    if (m_pEffectsState)
    {
        delete m_pEffectsState;
    }
}


HRESULT CEffectsPage_CreateInstance(OUT IAdvancedDialog ** ppAdvDialog)
{
    HRESULT hr = E_INVALIDARG;

    if (ppAdvDialog)
    {
        CEffectsPage * pThis = new CEffectsPage();

        if (pThis)
        {
            hr = pThis->QueryInterface(IID_PPV_ARG(IAdvancedDialog, ppAdvDialog));
            pThis->Release();
        }
        else
        {
            *ppAdvDialog = NULL;
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

#ifdef CLEARTYPECOMBO
static void EnableDlgChild( HWND dlg, HWND kid, BOOL val )
{
    if( !val && ( kid == GetFocus() ) )
    {
        // give prev tabstop focus
        SendMessage( dlg, WM_NEXTDLGCTL, 1, 0L );
    }

    EnableWindow( kid, val );
}

static void EnableDlgItem( HWND dlg, int idkid, BOOL val )
{
    EnableDlgChild( dlg, GetDlgItem( dlg, idkid ), val );
}

#define TEXTEDGE_CLASS TEXT("TextEdge")

#define SZ_SAMPLETEXT TEXT("The quick brown fox jumps over the lazy dog")

void ShowTextRedraw(HWND hDlg)
{
    HWND hWnd;

    hWnd = GetDlgItem(hDlg, IDC_TEXTSAMPLE);

    InvalidateRgn (hWnd, NULL, TRUE);
   
}

// Handle to the DLL
extern HINSTANCE g_hInst;

void GetFontInfo(HWND hDlg)
{
    BOOL bOldSF = FALSE;
    BOOL bOldCT = FALSE;
    
    CheckDlgButton(hDlg, IDC_MONOTEXT, FALSE);
    CheckDlgButton(hDlg, IDC_AATEXT, FALSE);
    CheckDlgButton(hDlg, IDC_CTTEXT, FALSE);

    if (g_ulFontInformation)
    {
        if (g_ulFontInformation == FONT_SMOOTHING_AA)
        {
            CheckDlgButton(hDlg, IDC_AATEXT, TRUE);
        }
        else if (g_ulFontInformation == FONT_SMOOTHING_CT)
        {
            CheckDlgButton(hDlg, IDC_CTTEXT, TRUE);
        }

        CheckDlgButton(hDlg, IDC_MONOTEXT, TRUE);
    }
    else
    {
        CheckDlgButton(hDlg, IDC_MONOTEXT, FALSE);
        EnableDlgItem(hDlg,IDC_AATEXT,FALSE);
        EnableDlgItem(hDlg,IDC_CTTEXT,FALSE);
        EnableDlgItem(hDlg,IDC_AASHOW,FALSE);
        EnableDlgItem(hDlg,IDC_CTSHOW,FALSE);
    }

    g_ulNewFontInformation = g_ulFontInformation;
}


HRESULT Text_OnCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL fHandled = 1;   // Not handled (WM_COMMAND seems to be different)
    WORD idCtrl = GET_WM_COMMAND_ID(wParam, lParam);
    WORD wEvent = GET_WM_COMMAND_CMD(wParam, lParam);
    BOOL bDorked = FALSE;

    switch (idCtrl)
    {
    case IDC_MONOTEXT:
        if (wEvent == BN_CLICKED)
        {
            if (IsDlgButtonChecked(hDlg, IDC_MONOTEXT))
            {
                EnableDlgItem(hDlg, IDC_AATEXT,TRUE);
                EnableDlgItem(hDlg, IDC_CTTEXT,TRUE);
                EnableDlgItem(hDlg, IDC_AASHOW,TRUE);
                EnableDlgItem(hDlg, IDC_CTSHOW,TRUE);

                CheckDlgButton(hDlg, IDC_AATEXT, FALSE);
                CheckDlgButton(hDlg, IDC_CTTEXT, FALSE);

                if (g_ulFontInformation == FONT_SMOOTHING_AA)
                {
                    CheckDlgButton(hDlg, IDC_AATEXT, TRUE);
                    g_ulNewFontInformation = FONT_SMOOTHING_AA;
                }
                else if (g_ulFontInformation == FONT_SMOOTHING_CT)
                {
                    CheckDlgButton(hDlg, IDC_CTTEXT, TRUE);
                    g_ulNewFontInformation = FONT_SMOOTHING_CT;
                } 
                else
                {
                    CheckDlgButton(hDlg, IDC_AATEXT, TRUE);
                    g_ulNewFontInformation = FONT_SMOOTHING_AA;
                }
            }
            else
            {
                EnableDlgItem(hDlg,IDC_AATEXT,FALSE);
                EnableDlgItem(hDlg,IDC_CTTEXT,FALSE);
                EnableDlgItem(hDlg,IDC_AASHOW,FALSE);
                EnableDlgItem(hDlg,IDC_CTSHOW,FALSE);
                
                g_ulNewFontInformation = 0;
            }

            bDorked = TRUE;
        }
        break;
    case IDC_AATEXT:
    case IDC_CTTEXT:
        if (wEvent == BN_CLICKED)
        {
            ULONG ulFontInformation;

            ulFontInformation = 0;
            
            if ( LOWORD(wParam) == IDC_AATEXT)
                ulFontInformation = FONT_SMOOTHING_AA;
            else if ( LOWORD(wParam) == IDC_CTTEXT)
                ulFontInformation = FONT_SMOOTHING_CT;
            
            if (ulFontInformation != g_ulNewFontInformation)
            {
                g_ulNewFontInformation = ulFontInformation;
                bDorked = TRUE;
            }
        }
        break;
    default:
        break;
    }

    // If the user dorked with a setting, tell the property manager we
    // have outstanding changes. This will enable the "Apply Now" button...
    if (bDorked)
    {
        ShowTextRedraw(hDlg);
        SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
        bDorked = FALSE;
    }

    return fHandled;
}


//---------------------------------------------------------------------------
//
// TextEdgeDlgProc()
//
//  The dialog procedure for the "TextEdge" property sheet page.
//
//---------------------------------------------------------------------------
INT_PTR CALLBACK TextEdgeDlgProc( HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam )
{
    LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE)GetWindowLongPtr( hDlg, DWLP_USER );
    static int      iIndex, iX;
    static TCHAR    szHelpFile[32];

    switch( uMessage )
    {
        case WM_INITDIALOG:
            // Need to add some code for help, but it is later.
            GetFontInfo(hDlg);
            break;

        case WM_DESTROY:
            break;

        case WM_COMMAND:
            Text_OnCommand(hDlg, uMessage, wParam, lParam);
            break;

        case WM_NOTIFY:
            switch( ((NMHDR *)lParam)->code )
            {
                case PSN_APPLY: // OK or Apply clicked
                {
                    HDC hDC = GetDC( NULL );


                    break;
                }
                
                case PSN_RESET:
                    g_ulNewFontInformation = g_ulFontInformation;
                    break;
                        
                default:
                    break;
            }
            break;

        default:
            return FALSE;
    }
    return(TRUE);
}

void ShowTextSample(HWND hWnd)
{
    HFONT    hfont;
    HFONT    hfontT;
    RECT     rc;
    LOGFONT  lf;
    HDC      hdc;
    SIZE     TextExtent;
    INT      yPos;
    INT      i, j, k, tmp;
    INT      LogPixelY;
    INT      yHeight;

    hdc = GetDC(hWnd);

    GetWindowRect(hWnd, &rc);

    yHeight = (rc.bottom - rc.top) / 2;

    ZeroMemory (&lf, sizeof(LOGFONT));

    LogPixelY = GetDeviceCaps(hdc, LOGPIXELSY);

    // This code can put on WM_CREATE
    SetTextAlign(hdc, TA_LEFT| TA_TOP);

    lf.lfPitchAndFamily = FF_ROMAN | VARIABLE_PITCH;
    lstrcpy(lf.lfFaceName, TEXT("Times New Roman"));

    i = (8 * LogPixelY + 36) / 72; // initial ppem size
    j = (4 * LogPixelY + 36) / 72; // pixel size increment

    if (g_ulNewFontInformation == FONT_SMOOTHING_AA)
    {
        lf.lfQuality = ANTIALIASED_QUALITY;
    }
    else if (g_ulNewFontInformation == FONT_SMOOTHING_CT)
    {
        lf.lfQuality = CLEARTYPE_QUALITY;
    }
    else
    {
        lf.lfQuality = NONANTIALIASED_QUALITY ;
    }

    yPos = 2;
    tmp = i;

    for (k = 0; k < 4; k++, i=i+j)
    {
        INT yNext;

        lf.lfHeight = -i;
        hfont = CreateFontIndirect(&lf);
        hfontT = (HFONT)SelectObject(hdc, hfont);
        GetTextExtentPoint(hdc, SZ_SAMPLETEXT, lstrlen(SZ_SAMPLETEXT), &TextExtent);
        yNext = yPos + TextExtent.cy;

        if (yNext > yHeight)
        {
            break;
        }
        ExtTextOut(hdc, 2, yPos, 0, &rc, SZ_SAMPLETEXT, lstrlen(SZ_SAMPLETEXT), NULL);
        yPos = yNext;
        SelectObject(hdc, hfontT);
        DeleteObject(hfont);
    }

    yPos = yHeight + 2;

    yHeight = (rc.bottom - rc.top);

    i = tmp;

    lf.lfItalic = TRUE;

    for (k = 0; k < 4; k++, i=i+j)
    {
        INT yNext;

        lf.lfHeight = -i;
        hfont = CreateFontIndirect(&lf);
        hfontT = (HFONT)SelectObject(hdc, hfont);
        GetTextExtentPoint(hdc, SZ_SAMPLETEXT, lstrlen(SZ_SAMPLETEXT), &TextExtent);
        yNext = yPos + TextExtent.cy;

        if (yNext > yHeight)
        {
            break;
        }

        ExtTextOut(hdc, 2, yPos, 0, &rc, SZ_SAMPLETEXT, lstrlen(SZ_SAMPLETEXT), NULL);
        yPos = yNext;
        SelectObject(hdc, hfontT);
        DeleteObject(hfont);
    }

    ReleaseDC(hWnd, hdc);
}

LRESULT CALLBACK  TextEdgeWndProc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    PAINTSTRUCT     ps;

    switch(message)
    {
        case WM_CREATE:
            break;

        case WM_DESTROY:
            break;

        case WM_PALETTECHANGED:
                break;
            //fallthru
        case WM_QUERYNEWPALETTE:
            break;

        case WM_PAINT:
            BeginPaint(hWnd,&ps);
            ShowTextSample(hWnd);
            EndPaint(hWnd,&ps);
            return 0;
    }
    return DefWindowProc(hWnd,message,wParam,lParam);
}

BOOL RegisterTextEdgeClass(void)
{
    WNDCLASS wc;

    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = TextEdgeWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = g_hInst;
    wc.hIcon = NULL;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName = NULL;
    wc.lpszClassName = TEXTEDGE_CLASS;

    if (!RegisterClass(&wc))
        return FALSE;

    return TRUE;
}

BOOL DisplayFontSmoothingDetails(HWND hWnd, BOOL* pfFontSmoothing, DWORD *pdwSmoothingType)
{
    BOOL    bRet = TRUE;

    PROPSHEETPAGE apsp[1];
    PROPSHEETHEADER psh;

    RegisterTextEdgeClass();

    psh.nStartPage = 0;

    psh.dwSize = sizeof(psh);

    //
    //  Disable Apply button
    //
    psh.dwFlags = PSH_PROPTITLE | PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;

    psh.hwndParent = hWnd;
    psh.hInstance = g_hInst;
    psh.pszIcon = NULL;

    //
    //  psh.nStartPage is set above.
    //
    psh.pszCaption = MAKEINTRESOURCE(IDS_TEXTPROP);
    psh.nPages = 1;
    psh.ppsp = apsp;

    apsp[0].dwSize = sizeof(PROPSHEETPAGE);
    apsp[0].dwFlags = PSP_DEFAULT;
    apsp[0].hInstance = g_hInst;
    apsp[0].pszTemplate = MAKEINTRESOURCE(DLG_TEXTEDGE);
    apsp[0].pfnDlgProc = TextEdgeDlgProc;
    apsp[0].lParam = 0;

    if (*pfFontSmoothing)
    {
        g_ulFontInformation = *pdwSmoothingType;
    }
    else
    {
        g_ulFontInformation = 0;
    }

    if (psh.nStartPage >= psh.nPages)
    {
        psh.nStartPage = 0;
    }

    if (PropertySheet(&psh) != -1)
        bRet = FALSE;

    if (g_ulNewFontInformation == 0)
    {
        *pfFontSmoothing = FALSE;
    }
    else
    {
        *pfFontSmoothing = TRUE;
        *pdwSmoothingType = (DWORD) g_ulNewFontInformation;
    }

    return TRUE;
}
#endif // CLEARTYPECOMBO




#include "..\common\propsext.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\nusrmgr\toolbar.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 2001.
//
//  File:       Toolbar.h
//
//  Contents:   declaration of CToolbar
//
//----------------------------------------------------------------------------

#ifndef _NUSRMGR_TOOLBAR_H_
#define _NUSRMGR_TOOLBAR_H_

#include "resource.h"       // main symbols
#include <atlctl.h>

#define NAVBAR_CX               24
#define PWM_UPDATESIZE          (WM_APP + 143)


/////////////////////////////////////////////////////////////////////////////
// CToolbar

class ATL_NO_VTABLE CToolbar : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatchImpl<IToolbar, &IID_IToolbar, &LIBID_NUSRMGRLib>,
    public CComControl<CToolbar>,
    public IOleControlImpl<CToolbar>,
    public IOleObjectImpl<CToolbar>,
    public IOleInPlaceActiveObjectImpl<CToolbar>,
    public IViewObjectExImpl<CToolbar>,
    public IOleInPlaceObjectWindowlessImpl<CToolbar>,
    public IConnectionPointImpl<CToolbar, &DIID_DToolbarEvents>,
    //public IPropertyNotifySinkCP<CToolbar>,
    public IConnectionPointContainerImpl<CToolbar>,
    public IProvideClassInfo2Impl<&CLSID_Toolbar, &DIID_DToolbarEvents, &LIBID_NUSRMGRLib>,
    public CComCoClass<CToolbar, &CLSID_Toolbar>
{
public:
    CToolbar() :
        m_ctlToolbar(_T("ToolbarWindow32"), this, 1),
        m_hAccel(NULL), m_pFont(NULL), m_hFont(NULL),
        m_himlNBDef(NULL), m_himlNBHot(NULL)
    {
        m_bWindowOnly = TRUE;
        m_bRecomposeOnResize = TRUE;

        // This is an educated guess based on the usual height (the width
        // doesn't matter).
        m_sizeExtent.cx = 5000;
        m_sizeExtent.cy =  688; //  26px @ 96dpi
        m_sizeNatural.cx = -1;
        m_sizeNatural.cy = -1;
    }

    ~CToolbar()
    {
        _ClearAmbientFont();

        if (m_himlNBDef)
            ImageList_Destroy(m_himlNBDef);
        if (m_himlNBHot)
            ImageList_Destroy(m_himlNBHot);
    }

DECLARE_WND_CLASS_EX(_T("UserAccounts.Toolbar"), CS_DBLCLKS, -1)
DECLARE_REGISTRY_RESOURCEID((UINT)0)
DECLARE_NOT_AGGREGATABLE(CToolbar)
//DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CToolbar)
    COM_INTERFACE_ENTRY(IToolbar)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IViewObjectEx)
    COM_INTERFACE_ENTRY(IViewObject2)
    COM_INTERFACE_ENTRY(IViewObject)
    COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceObject)
    COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleControl)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CToolbar)
    CONNECTION_POINT_ENTRY(DIID_DToolbarEvents)
    //CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP()

BEGIN_MSG_MAP(CToolbar)
    NOTIFY_CODE_HANDLER(TBN_GETINFOTIP, _OnGetInfoTip)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    COMMAND_RANGE_HANDLER(ID_BACK, ID_HOME, _OnButtonClick)
    MESSAGE_HANDLER(WM_APPCOMMAND, _OnAppCommand)
    MESSAGE_HANDLER(WM_CREATE, _OnCreate)
    MESSAGE_HANDLER(WM_DESTROY, _OnDestroy)
    MESSAGE_HANDLER(PWM_UPDATESIZE, _UpdateSize)
    CHAIN_MSG_MAP(CComControl<CToolbar>)
ALT_MSG_MAP(1)
    // Replace this with message map entries for superclassed ToolbarWindow32
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT _OnGetInfoTip(int /*idCtrl*/, LPNMHDR pnmh, BOOL& /*bHandled*/)
    {
        LPNMTBGETINFOTIP pgit = (LPNMTBGETINFOTIP)pnmh;
        ::LoadString(_Module.GetResourceInstance(),
                     pgit->iItem + (IDS_TOOLTIP_BACK - ID_BACK),
                     pgit->pszText,
                     pgit->cchTextMax);
        return 0;
    }

    LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        LRESULT lRes = CComControl<CToolbar>::OnSetFocus(uMsg, wParam, lParam, bHandled);
        if (m_bInPlaceActive)
        {
            DoVerbUIActivate(&m_rcPos,  NULL);
            if(!IsChild(::GetFocus()))
                m_ctlToolbar.SetFocus();
        }
        return lRes;
    }

    LRESULT _OnButtonClick(WORD, WORD wID, HWND, BOOL&)
    {
        Fire_OnButtonClick(wID - ID_BACK);
        return 0;
    }

    LRESULT _OnAppCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT _OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT _OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT _UpdateSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

// IOleInPlaceObject
    STDMETHOD(SetObjectRects)(LPCRECT prcPos, LPCRECT prcClip)
    {
        IOleInPlaceObjectWindowlessImpl<CToolbar>::SetObjectRects(prcPos, prcClip);
        m_ctlToolbar.SetWindowPos(NULL, 0, 0,
                                  prcPos->right - prcPos->left,
                                  prcPos->bottom - prcPos->top,
                                  SWP_NOZORDER | SWP_NOACTIVATE);
        return S_OK;
    }

// IViewObjectEx
    DECLARE_VIEW_STATUS(0)

// IOleControl
    STDMETHOD(GetControlInfo)(CONTROLINFO *pci)
    {
        if (!pci)
            return E_POINTER;
        pci->hAccel = m_hAccel;
        pci->cAccel = m_hAccel ? 3 : 0;
        pci->dwFlags = 0;
        return S_OK;
    }

    STDMETHOD(OnAmbientPropertyChange)(DISPID dispid);

    STDMETHOD(OnMnemonic)(MSG *pMsg)
    {
        WORD wID;
        if (m_hAccel && ::IsAccelerator(m_hAccel, 3, pMsg, &wID))
        {
            Fire_OnButtonClick(wID - ID_BACK);
            return S_OK;
        }
        return S_FALSE;
    }

// IOleInPlaceActiveObject
    STDMETHOD(TranslateAccelerator)(MSG *pMsg)
    {
        HRESULT hr = IOleInPlaceActiveObjectImpl<CToolbar>::TranslateAccelerator(pMsg);
        if (S_FALSE == hr)
        {
            hr = OnMnemonic(pMsg);
        }
        return hr;
    }

// IOleObject
    STDMETHOD(GetMiscStatus)(DWORD /*dwAspect*/, DWORD *pdwStatus)
    {
        if (!pdwStatus)
            return E_POINTER;
        *pdwStatus = OLEMISC_RECOMPOSEONRESIZE | OLEMISC_CANTLINKINSIDE | OLEMISC_INSIDEOUT | OLEMISC_ACTIVATEWHENVISIBLE | OLEMISC_SETCLIENTSITEFIRST;
        return S_OK;
    }

// IToolbar
    STDMETHOD(get_enabled)(/*[in]*/ VARIANT vIndex, /*[out, retval]*/ VARIANT_BOOL *pVal);
    STDMETHOD(put_enabled)(/*[in]*/ VARIANT vIndex, /*[in]*/ VARIANT_BOOL newVal);

// DToolbarEvents
    void Fire_OnButtonClick(int buttonIndex);

private:
    void _ClearAmbientFont(void);
    void _GetAmbientFont(void);

private:
    CContainedWindow m_ctlToolbar;
    HACCEL m_hAccel;
    IFont *m_pFont;
    HFONT m_hFont;
    HIMAGELIST m_himlNBDef;
    HIMAGELIST m_himlNBHot;
};

#endif //_NUSRMGR_TOOLBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\plus\addon.h ===
// Common strings

#define NO_HELP                         ((DWORD) -1)
#define IDH_COMM_GROUPBOX               28548

// Welcome Help after Setup: Jessev

#define GET_WELCOME                     0002

// Enhanced Property Sheet ID's: Shawnb


#define IDH_COMPDRV_TABLE_ULTRA         1002
#define IDH_COMPDRV_TABLE_HIPACK        1003
#define IDH_COMPDRV_TABLE_STD           1004
#define IDH_COMPDRV_TABLE_UNCOMP        1005
#define IDH_COMPDRV_TABLE_FREESP        1006
#define IDH_COMPDRV_TABLE_REDUCED       1007
#define IDH_COMPDRV_PIE                 1008
#define IDH_COMPDRV_TABLE               1009
#define IDH_COMPDRV_RECOMPNOW           1010
#define IDH_COMPDRV_UPGRADENOW          1011
#define IDH_COMPDRV_ADV                 1012
#define IDH_COMPDRV_ADV_HIDEHOST        1013
#define IDH_UNCOMPDRV_COMPDRIVE         1014
#define IDH_UNCOMPDRV_COMPPIE           1015
#define IDH_UNCOMPDRV_CREATENEW         1016
#define IDH_UNCOMPDRV_CREATEPIE         1017
#define IDH_HOSTDRV_PIE                 1018
#define IDH_HOSTDRV_TABLE               1019
#define IDH_RUN_DRVSPACE                1020
#define IDH_COMPDRV_GAUGE               1021
#define IDH_COMPDRV_TABLE_TOTAL         1022


//ID's for the Theme Picker applet

#define IDH_THEME_LIST                  2001
#define IDH_THEME_SAVEAS                2002
#define IDH_THEME_DELETE                2003
#define IDH_THEME_PREVSCRN              2004
#define IDH_THEME_PREVETC               2005
#define IDH_THEME_PREVIEW               2006
#define IDH_THEME_SCRNSAVER             2007
#define IDH_THEMES_SOUNDS               2008
#define IDH_THEME_POINTERS              2009
#define IDH_THEME_WALLPAPER             2010
#define IDH_THEME_ICONS                 2011
#define IDH_THEME_COLORS                2012
#define IDH_THEME_FONTS                 2013
#define IDH_THEME_BORDER                2014
#define IDH_THEME_POINTERS_LIST         2015
#define IDH_THEME_POINTERS_PREV         2016
#define IDH_THEME_POINTERS_FILE         2018
#define IDH_THEME_SOUNDS_LIST           2019
#define IDH_THEME_SOUNDS_ICON_PREV      2020
#define IDH_THEME_SOUNDS_PLAYS          2021
#define IDH_THEME_SOUNDS_FILE           2022
#define IDH_THEME_PICS_LIST             2023
#define IDH_THEME_PICS_PREV             2024
#define IDH_THEME_PICS_FILE             2025
// #define IDH_THEME_SAVE_NAME          2026
#define IDH_THEME_ICON_SIZESPACE        2027

// Lens settings ID's

#define IDH_LENS_FLIP                   3000            // Temporary
#define IDH_LENS_GLASS_SPHERE           3001
#define IDH_LENS_INSIDE_OUT             3002
#define IDH_LENS_BLACK_HOLE             3003
#define IDH_LENS_DENT                   3004
#define IDH_LENS_SPIRAL                 3005
#define IDH_LENS_SIZE                   3006
#define IDH_LENS_SPEED                  3007
#define IDH_LENS_INDEX                  3008
#define IDH_LENS_ALTITUDE               3009
#define IDH_LENS_MASS                   3010
#define IDH_LENS_HEIGHT                 3011
#define IDH_LENS_TWIST                  3012
#define IDH_LENS_WALLPAPER              3013

//Blocks settings ID's

#define IDH_BLOCKS_SIZE                 3050
#define IDH_BLOCKS_SPEED                3051

//Socha Settings ID's

#define IDH_SCRNSAVER_GEN_MONITOR       3100
#define IDH_SCRNSAVER_GEN_MOUSESEN      3101
#define IDH_SCRNSAVER_GEN_PASSREQUIRED  3102
#define IDH_SCRNSAVER_GEN_ABOUT         3103
#define IDH_SCRNSAVER_PREVIEW           3104
#define IDH_SCRNSAVER_GEN_NOSOUND       3105

// Plus Display Properties ID's

// windows.hlp IDH_'s
#define IDH_DISPLAY_PLUSPACK_LIST       4300
#define IDH_DISPLAY_PLUSPACK_CHANGEICON 4301
#define IDH_DISPLAY_PLUSPACK_ALLCOLORS  4302
#define IDH_DISPLAY_PLUSPACK_FULLWINDOW 4303
#define IDH_DISPLAY_PLUSPACK_FONTSMOOTH 4304
#define IDH_DISPLAY_PLUSPACK_STRETCH    4305
#define IDH_DISPLAY_PLUSPACK_LARGEICONS 4306
#define IDH_DISPLAY_PLUSPACK_DEFAULT_ICON 4307

// plus!.hlp IDH_'s
#define IDH_PLUS_PLUSPACK_LIST       4100
#define IDH_PLUS_PLUSPACK_CHANGEICON 4101
#define IDH_PLUS_PLUSPACK_ALLCOLORS  4102
#define IDH_PLUS_PLUSPACK_FULLWINDOW 4103
#define IDH_PLUS_PLUSPACK_FONTSMOOTH 4104
#define IDH_PLUS_PLUSPACK_STRETCH    4105
#define IDH_PLUS_PLUSPACK_LARGEICONS 4106

// display.hlp IDH_'s
#define IDH_DISPLAY_EFFECTS_DESKTOP_ICONS               4300
#define IDH_DISPLAY_EFFECTS_CHANGE_ICON_BUTTON          4301
#define IDH_DISPLAY_EFFECTS_ALL_COLORS_CHECKBOX         4302
#define IDH_DISPLAY_EFFECTS_DRAG_WINDOW_CHECKBOX        4303
#define IDH_DISPLAY_EFFECTS_SMOOTH_FONTS_CHECKBOX       4304
//#define IDH_DISPLAY_EFFECTS_STRETCH                   4305    //Obsolete in NT5
#define IDH_DISPLAY_EFFECTS_ANIMATE_WINDOWS             4305
#define IDH_DISPLAY_EFFECTS_LARGE_ICONS_CHECKBOX        4306
#define IDH_DISPLAY_EFFECTS_DEFAULT_ICON_BUTTON         4307
#define IDH_DISPLAY_EFFECTS_HIDE_KEYBOARD_INDICATORS    4308
#define IDH_DISPLAY_EFFECTS_SMOOTH_FONTS_LISTBOX        4309
#define IDH_DISPLAY_EFFECTS_ANIMATE_LISTBOX             4310



// RNA dial-in ID's

#define IDH_RNA_IN_NOACC                4259
#define IDH_RNA_IN_ENABLEACC            4260
#define IDH_RNA_IN_PASSWORD             4263
#define IDH_RNA_IN_COMMENT              4264
#define IDH_RNA_IN_STATUS               4265
#define IDH_RNA_IN_DISCONNECT           4266
#define IDH_RNA_MODEM_SERVER            4275

// Internet Shortcut Target URL

#define IDH_INTERNET_SHORTCUT_TARGET    6001

// Disk Troubleshooter ID's

#define IDH_DSKTRB_FREESPACE            5001
#define IDH_COMPSET_TRB_MAIN            5002    // Must match DOS\DOS86\DBLSPACE\UTILITY\FROSTHLP.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\plus\effectsadvpg.h ===
/*****************************************************************************\
    FILE: EffectsAdvPg.h

    DESCRIPTION:
        This code will display the Effect tab in the Advanced Display Control
    panel.

    BryanSt 4/13/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _EFFECTSADVPG_H
#define _EFFECTSADVPG_H

#include "store.h"
#include <cowsite.h>            // for CObjectWithSite
#include <shpriv.h>
#include "..\common\propsext.h"

class CEffectsPage;

#include "EffectsBasePg.h"

static const GUID IID_CEffectsPage_THIS = { 0xef2b6246, 0x6c1b, 0x44fd, { 0x87, 0xea, 0xb3, 0xc5, 0xd, 0x47, 0x8b, 0x8e } };// {EF2B6246-6C1B-44fd-87EA-B3C50D478B8E}



#define PROPSHEET_CLASS             CEffectsBasePage
class CPropSheetExt;

HRESULT CEffectsPage_CreateInstance(OUT IAdvancedDialog ** ppAdvDialog);


class CEffectsPage              : public CObjectWithSite
                                , public IAdvancedDialog
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IAdvancedDialog ***
    virtual STDMETHODIMP DisplayAdvancedDialog(IN HWND hwndParent, IN IPropertyBag * pBasePage, IN BOOL * pfEnableApply);


private:
    CEffectsPage(void);
    virtual ~CEffectsPage(void);

    // Private Member Variables
    int                     m_cRef;
    BOOL                    m_fDirty;
    CEffectState *          m_pEffectsState;
    int                     m_nIndex;

    // Private Member Functions
    HRESULT _OnInit(HWND hDlg);
    HRESULT _OnApply(HWND hDlg);            // The user clicked apply
    HWND _CreateListView(HWND hWndParent);
    HRESULT _IsDirty(IN BOOL * pIsDirty);
    HRESULT _OnCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

    INT_PTR _PropertySheetDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
    friend INT_PTR CALLBACK PropertySheetDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);

    friend HRESULT CEffectsPage_CreateInstance(OUT IAdvancedDialog ** ppAdvDialog);
};




#endif // _EFFECTSADVPG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\plus\effectsbasepg.h ===
/*****************************************************************************\
    FILE: EffectsBasePg.h

    DESCRIPTION:
        This code will be the base object that won't add any pages to the base
    "Display Properties" dialog.  However, it will request a "Effects" page be
    added to the Advanced.

    BryanSt 4/13/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _EFFECTSBASEPG_H
#define _EFFECTSBASEPG_H

#include "store.h"
#include <cowsite.h>
#include <objclsid.h>
#include <shpriv.h>


#define SZ_PBPROP_EFFECTSSTATE               TEXT("EffectsState") // VT_BYREF (void *) to CEffectState class



HRESULT CEffectsPage_CreateInstance(OUT IAdvancedDialog ** ppAdvDialog);


class CEffectsBasePage          : public CPropSheetExt
                                , public CObjectCLSID
                                , public CObjectWithSite
                                , public IPropertyBag
                                , public IBasePropPage
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) {return CPropSheetExt::AddRef();}
    virtual STDMETHODIMP_(ULONG) Release(void) {return CPropSheetExt::Release();}

    // *** IShellPropSheetExt ***
    virtual STDMETHODIMP AddPages(IN LPFNSVADDPROPSHEETPAGE pfnAddPage, IN LPARAM lParam);
    virtual STDMETHODIMP ReplacePage(IN EXPPS uPageID, IN LPFNSVADDPROPSHEETPAGE pfnReplaceWith, IN LPARAM lParam) {return E_NOTIMPL;}

    // *** IPropertyBag ***
    virtual STDMETHODIMP Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog);
    virtual STDMETHODIMP Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar);

    // *** IBasePropPage ***
    virtual STDMETHODIMP GetAdvancedDialog(OUT IAdvancedDialog ** ppAdvDialog);
    virtual STDMETHODIMP OnApply(IN PROPPAGEONAPPLY oaAction);



    CEffectsBasePage(IUnknown * punkOuter, LPFNDESTROYED pfnDestroy);
    virtual ~CEffectsBasePage(void);
protected:

private:

    // Private Member Variables
    int                     m_cRef;

    BOOL                    m_fDirty;
    CEffectState *          m_pEffectsState;

    // Private Member Functions
    HRESULT _InitState(void);
    HRESULT _SaveState(CEffectState * pEffectsState);
};


#endif // _EFFECTSBASEPG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\plus\effectsbasepg.cpp ===
/*****************************************************************************\
    FILE: EffectsBasePg.cpp

    DESCRIPTION:
        This code will be the base object that won't add any pages to the base
    "Display Properties" dialog.  However, it will request a "Effects" page be
    added to the Advanced.

    BryanSt 4/13/2000    Updated and Converted to C++

    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.

\*****************************************************************************/
#include "precomp.hxx"
#include "shlwapip.h"
#include "shlguidp.h"
#pragma hdrstop

#include "EffectsBasePg.h"
#include "EffectsAdvPg.h"
#include <cfgmgr32.h>           // For MAX_GUID_STRING_LEN

//============================================================================================================
// *** Globals ***
//============================================================================================================

//===========================
// *** Class Internals & Helpers ***
//===========================
HRESULT HrSysAllocString(IN const OLECHAR * pwzSource, OUT BSTR * pbstrDest)
{
    HRESULT hr = S_OK;

    if (pbstrDest)
    {
        *pbstrDest = SysAllocString(pwzSource);
        if (pwzSource)
        {
            if (*pbstrDest)
                hr = S_OK;
            else
                hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


HRESULT CEffectsBasePage::_InitState(void)
{
    HRESULT hr = S_OK;

    if (!m_pEffectsState)
    {
        m_pEffectsState = new CEffectState();
        if (m_pEffectsState)
        {
            m_pEffectsState->Load();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


HRESULT CEffectsBasePage::_SaveState(CEffectState * pEffectsState)
{
    HRESULT hr = E_INVALIDARG;

    if (pEffectsState)
    {
        BOOL fHasIconsChanged = FALSE;

        if (m_pEffectsState)
        {
            fHasIconsChanged = pEffectsState->HasIconsChanged(m_pEffectsState);
            delete m_pEffectsState;
        }
        
        m_pEffectsState = pEffectsState;
        hr = S_OK;

        // Only switch to "Custom" if the icons changed.
        if (_punkSite && fHasIconsChanged)
        {
            // We need to tell the Theme tab to customize the theme.
            IPropertyBag * pPropertyBag;
            hr = _punkSite->QueryInterface(IID_PPV_ARG(IPropertyBag, &pPropertyBag));
            if (SUCCEEDED(hr))
            {
                // Tell the theme that we have customized the values.
                hr = SHPropertyBag_WriteInt(pPropertyBag, SZ_PBPROP_CUSTOMIZE_THEME, 0);
                pPropertyBag->Release();
            }
        }
    }

    return hr;
}




//===========================
// *** IBasePropPage Interface ***
//===========================
#define SZ_ICONHEADER           L"CLSID\\{"
HRESULT CEffectsBasePage::Read(IN LPCOLESTR pszPropName, IN VARIANT * pVar, IN IErrorLog *pErrorLog)
{
    HRESULT hr = E_INVALIDARG;

    if (pszPropName && pVar)
    {
        // The caller can pass us the string in the following format:
        // pszPropName="CLSID\{<CLSID>}\DefaultIcon:<Item>" = "<FilePath>,<ResourceIndex>"
        // For example:
        // pszPropName="CLSID\{20D04FE0-3AEA-1069-A2D8-08002B30309D}\DefaultIcon:DefaultValue" = "%WinDir%SYSTEM\COOL.DLL,16"
        if (!StrCmpNIW(SZ_ICONHEADER, pszPropName, ARRAYSIZE(SZ_ICONHEADER) - 1) &&
            ((ARRAYSIZE(SZ_ICONHEADER) + 38) < lstrlenW(pszPropName)))
        {
            hr = _InitState();
            if (SUCCEEDED(hr))
            {
                CLSID clsid;
                WCHAR szTemp[MAX_PATH];

                // Get the CLSID
                StrCpyNW(szTemp, &(pszPropName[ARRAYSIZE(SZ_ICONHEADER) - 2]), MAX_GUID_STRING_LEN);
                hr = SHCLSIDFromString(szTemp, &clsid);
                if (SUCCEEDED(hr))
                {
                    // Get the name of the icon type.  Normally this is "DefaultIcon", but it can be several states, like
                    // "full" and "empty" for the recycle bin.
                    LPCWSTR pszToken = StrChrW((pszPropName + ARRAYSIZE(SZ_ICONHEADER)), L':');

                    hr = E_FAIL;
                    if (pszToken)
                    {
                        TCHAR szIconPath[MAX_PATH];

                        pszToken++;
                        hr = m_pEffectsState->GetIconPath(clsid, pszToken, szIconPath, ARRAYSIZE(szIconPath));
                        if (SUCCEEDED(hr))
                        {
                            pVar->vt = VT_BSTR;
                            hr = HrSysAllocString(szIconPath, &pVar->bstrVal);
                        }
                    }
                }
            }
        }
        else if (!StrCmpW(SZ_PBPROP_EFFECTSSTATE, pszPropName) && m_pEffectsState)
        {
            pVar->vt = VT_BYREF;
            pVar->byref = (void *)&m_pEffectsState;
            hr = S_OK;
        }
    }

    return hr;
}


HRESULT CEffectsBasePage::Write(IN LPCOLESTR pszPropName, IN VARIANT *pVar)
{
    HRESULT hr = E_INVALIDARG;

    if (pszPropName && pVar)
    {
        if (VT_BSTR == pVar->vt)
        {
            // The caller can pass us the string in the following format:
            // pszPropName="CLSID\{<CLSID>}\DefaultIcon:<Item>" = "<FilePath>,<ResourceIndex>"
            // For example:
            // pszPropName="CLSID\{20D04FE0-3AEA-1069-A2D8-08002B30309D}\DefaultIcon:DefaultValue" = "%WinDir%SYSTEM\COOL.DLL,16"
            if (!StrCmpNIW(SZ_ICONHEADER, pszPropName, ARRAYSIZE(SZ_ICONHEADER) - 1) &&
                ((ARRAYSIZE(SZ_ICONHEADER) + 38) < lstrlenW(pszPropName)))
            {
                hr = _InitState();
                if (SUCCEEDED(hr))
                {
                    CLSID clsid;
                    WCHAR szTemp[MAX_PATH];

                    // Get the CLSID
                    StrCpyNW(szTemp, &(pszPropName[ARRAYSIZE(SZ_ICONHEADER) - 2]), MAX_GUID_STRING_LEN);
                    hr = SHCLSIDFromString(szTemp, &clsid);
                    if (SUCCEEDED(hr))
                    {
                        // Get the name of the icon type.  Normally this is "DefaultIcon", but it can be several states, like
                        // "full" and "empty" for the recycle bin.
                        LPCWSTR pszToken = StrChrW((pszPropName + ARRAYSIZE(SZ_ICONHEADER)), L':');

                        hr = E_FAIL;
                        if (pszToken)
                        {
                            pszToken++;

                            StrCpyNW(szTemp, pszToken, ARRAYSIZE(szTemp));

                            // Now the pVar->bstrVal is the icon path + "," + resourceID.  Separate those two.
                            WCHAR szPath[MAX_PATH];

                            StrCpyNW(szPath, pVar->bstrVal, ARRAYSIZE(szPath));

                            int nResourceID = PathParseIconLocationW(szPath);
                            hr = m_pEffectsState->SetIconPath(clsid, szTemp, szPath, nResourceID);
                        }
                    }
                }
            }
        }
        else if (VT_BYREF == pVar->vt)
        {
            // The caller is passing us a (CEffectState *) object to save.
            if (!StrCmpW(SZ_PBPROP_EFFECTSSTATE, pszPropName))
            {
                hr = _SaveState((CEffectState *) pVar->byref);
            }
        }
    }

    return hr;
}





//===========================
// *** IBasePropPage Interface ***
//===========================
HRESULT CEffectsBasePage::GetAdvancedDialog(OUT IAdvancedDialog ** ppAdvDialog)
{
    HRESULT hr = E_INVALIDARG;

    if (ppAdvDialog)
    {
        *ppAdvDialog = NULL;
        hr = _InitState();

        if (SUCCEEDED(hr))
        {
            hr = CEffectsPage_CreateInstance(ppAdvDialog);
        }
    }

    return hr;
}


HRESULT CEffectsBasePage::OnApply(IN PROPPAGEONAPPLY oaAction)
{
    HRESULT hr = S_OK;

    if ((PPOAACTION_CANCEL != oaAction) && m_pEffectsState)
    {
        hr = m_pEffectsState->Save();

        // Make sure we reload the state next time we open the dialog.
        delete m_pEffectsState;
        m_pEffectsState = NULL;
    }

    return hr;
}



//===========================
// *** IShellPropSheetExt Interface ***
//===========================
HRESULT CEffectsBasePage::AddPages(IN LPFNSVADDPROPSHEETPAGE pfnAddPage, IN LPARAM lParam)
{
    // We don't want to add any pages to the base dialog since we moved the
    // "Effects" tab to the Advanced dlg.
    return S_OK;
}



//===========================
// *** IUnknown Interface ***
//===========================
HRESULT CEffectsBasePage::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hr = E_NOINTERFACE;

    static const QITAB qit[] =
    {
        QITABENT(CEffectsBasePage, IBasePropPage),
        QITABENT(CEffectsBasePage, IPropertyBag),
        QITABENT(CEffectsBasePage, IPersist),
        QITABENT(CEffectsBasePage, IObjectWithSite),
        QITABENTMULTI(CEffectsBasePage, IShellPropSheetExt, IBasePropPage),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


//===========================
// *** Class Methods ***
//===========================
CEffectsBasePage::CEffectsBasePage(IUnknown * punkOuter, LPFNDESTROYED pfnDestroy) : CPropSheetExt(punkOuter, pfnDestroy), CObjectCLSID(&PPID_Effects)
{
    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    m_fDirty = FALSE;
}


CEffectsBasePage::~CEffectsBasePage()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\plus\regutils.h ===
//-----------------------------------------------------------------------
//
//      File: REGUTILS.H
//
//-----------------------------------------------------------------------

#ifndef _REGUTILS_H_
#define _REGUTILS_H_

BOOL GetRegValueString( HKEY hMainKey, LPCTSTR lpszSubKey, LPCTSTR lpszValName, LPTSTR lpszValue, int iMaxSize );
BOOL GetRegValueInt( HKEY hMainKey, LPCTSTR lpszSubKey, LPCTSTR lpszValName, int* piValue );
BOOL SetRegValueString( HKEY hMainKey, LPCTSTR lpszSubKey, LPCTSTR lpszValName, LPCTSTR lpszValue );
BOOL SetRegValueInt( HKEY hMainKey, LPCTSTR lpszSubKey, LPCTSTR lpszValName, int iValue );
BOOL SetRegValueDword( HKEY hk, LPCTSTR pSubKey, LPCTSTR pValue, DWORD dwVal );
DWORD GetRegValueDword( HKEY hk, LPCTSTR pSubKey, LPCTSTR pValue );
#define REG_BAD_DWORD 0xF0F0F0F0

BOOL IconSetRegValueString(const CLSID* pclsid, LPCTSTR lpszSubKey, LPCTSTR lpszValName, LPCTSTR lpszValue);
BOOL IconGetRegValueString(const CLSID* pclsid, LPCTSTR lpszSubKey, LPCTSTR lpszValName, LPTSTR lpszValue, int cchValue);

#endif //_REGUTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\plus\propsext.cpp ===
//---------------------------------------------------------------------------
//
//  File: PROPSEXT.CPP
//
//  Implementation of the CPropSheetExt object.
//
//---------------------------------------------------------------------------

#include "precomp.hxx"
#pragma hdrstop

#include "..\common\propsext.h"
#include "EffectsBasePg.h"
#include <cowsite.h>            // for CObjectWithSite


#define PROPSHEET_CLASS             CEffectsBasePage
class CPropSheetExt;


HRESULT CEffectsPage_CreateInstance(OUT IAdvancedDialog ** ppAdvDialog);

class CEffectsPage              : public CObjectWithSite
                                , public IAdvancedPropPage
                                , public IShellExtInit
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IShellExtInit ***
    virtual STDMETHODIMP Initialize(IN LPCITEMIDLIST pidlFolder, IDataObject * pDataObj, IN HKEY hkeyProgID) {return E_NOTIMPL;}

    // *** IShellPropSheetExt ***
    virtual STDMETHODIMP AddPages(IN LPFNSVADDPROPSHEETPAGE pfnAddPage, IN LPARAM lParam);
    virtual STDMETHODIMP ReplacePage(IN EXPPS uPageID, IN LPFNSVADDPROPSHEETPAGE pfnReplaceWith, IN LPARAM lParam) {return E_NOTIMPL;}

    // *** IAdvancedPropPage ***
    virtual STDMETHODIMP IsDirty(IN BOOL * pIsDirty);
    virtual STDMETHODIMP OnClose(IN BOOL fCancelled, IN IBasePropPage * pAdvPage);


private:
    CEffectsPage(void);
    virtual ~CEffectsPage(void);

    // Private Member Variables
    int                     m_cRef;
    BOOL                    m_fDirty;
    EFFECTS_STATE           m_effectsState;

    // Private Member Functions
    HRESULT _OnInit(HWND hDlg);
    HRESULT _OnLoad(HWND hDlg);             // Load the state from the base page.
    HRESULT _OnApply(HWND hDlg);            // The user clicked apply
    HRESULT _OnSave(HWND hDlg);             // Save the state to the base page.

    INT_PTR _PropertySheetDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
    friend INT_PTR CALLBACK PropertySheetDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);

    friend HRESULT CEffectsPage_CreateInstance(OUT IAdvancedDialog ** ppAdvDialog);
};






//===========================
// *** Class Internals & Helpers ***
//===========================





//===========================
// *** IAdvancedPropPage Interface ***
//===========================
HRESULT CEffectsPage::IsDirty(IN BOOL * pIsDirty)
{
    HRESULT hr = E_INVALIDARG;

    if (pIsDirty)
    {
        *pIsDirty = m_fDirty;
        hr = S_OK;
    }

    return hr;
}


HRESULT CEffectsPage::OnClose(IN BOOL fCancelled, IN IBasePropPage * pAdvPage)
{
    HRESULT hr = S_OK;

    // TODO: Merger State as appropriate
    return hr;
}




#define MAX_PROPSHEET_TITLE     50

//===========================
// *** IShellPropSheetExt Interface ***
//===========================
HRESULT CEffectsPage::AddPages(IN LPFNSVADDPROPSHEETPAGE pfnAddPage, IN LPARAM lParam)
{
    HRESULT hr = E_INVALIDARG;
    PROPSHEETPAGE psp = {0};
    TCHAR szTitle[MAX_PROPSHEET_TITLE];

    LoadString(g_hInst, IDS_PAGE_TITLE, szTitle, ARRAYSIZE(szTitle));
    psp.dwSize = sizeof(psp);
    psp.hInstance = g_hInst;
    psp.dwFlags = (PSP_USETITLE | PSP_USECALLBACK);
    psp.lParam = (LPARAM) this;

    psp.pszTemplate = MAKEINTRESOURCE(PROP_SHEET_DLG);
    psp.pfnDlgProc = PropertySheetDlgProc;
    psp.pfnCallback = PropertySheetCallback;
    psp.pszTitle = szTitle;

    HPROPSHEETPAGE hpsp = CreatePropertySheetPage(&psp);
    if (hpsp)
    {
        if (pfnAddPage(hpsp, lParam))
        {
            hr = S_OK;
        }
        else
        {
            DestroyPropertySheetPage(hpsp);
            hr = E_FAIL;
        }
    }

    return hr;
}



//===========================
// *** IUnknown Interface ***
//===========================
ULONG CEffectsPage::AddRef()
{
    m_cRef++;
    return m_cRef;
}


ULONG CEffectsPage::Release()
{
    Assert(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}


HRESULT CEffectsPage::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hr = E_NOINTERFACE;

    static const QITAB qit[] = {
        QITABENT(CEffectsPage, IObjectWithSite),
        QITABENT(CEffectsPage, IAdvancedPropPage),
        QITABENTMULTI(CEffectsPage, IShellPropSheetExt, IAdvancedPropPage),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}




//===========================
// *** Class Methods ***
//===========================
CEffectsPage::CEffectsPage() : m_cRef(1)
{
    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    m_fDirty = FALSE;
}


CEffectsPage::~CEffectsPage()
{
}


HRESULT CEffectsPage_CreateInstance(OUT IAdvancedDialog ** ppAdvDialog)
{
    HRESULT hr = E_INVALIDARG;

    if (ppAdvDialog)
    {
        CEffectsPage * pThis = new CEffectsPage();

        if (pThis)
        {
            hr = pThis->QueryInterface(IID_PPV_ARG(IAdvancedDialog, ppAdvDialog));
            pThis->Release();
        }
        else
        {
            *ppAdvDialog = NULL;
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}





#include "..\common\propsext.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\plus\rc.h ===
/******************************************************************************

  Source File:  rc.H

  Resource Identifier Definitions for Effects property page

  Copyright (c) 1998 by Microsoft Corporation


******************************************************************************/


#define IDS_PAGE_TITLE                  1
#define PROP_SHEET_DLG                  2

#define IDS_HELPFILE                    3
#define IDS_NOICONSMSG1                 4
#define IDS_NOICONSMSG                  5
#define IDS_BADPATHMSG                  6
// #define IDS_REBOOTFORCHANGE             7 // NO LONGER NEEDED, DO NOT REUSE....
#define IDS_FONTSMOOTHWONTWORK          8
#define IDS_ICONCOLORWONTWORK           9
#define IDS_FULL                        10
#define IDS_EMPTY                       11
#define IDS_MYCOMPUTER                  12
#define IDS_NETNEIGHBOUR                13
#define IDS_TRASHFULL                   14
#define IDS_TRASHEMPTY                  16
#define IDS_TRASHDEFAULT                18
#define IDS_USE_LARGE                   19
#define IDS_256COLORPROBLEM             20
#define IDS_ICONFILTER                  21
#define IDS_INVALIDPATH                 22
#define IDS_HELPFILE_PLUS               23
#define IDS_MYDOCUMENTS                 24
#define IDS_INTERNET                    25
#define IDS_DIRECTORY                   26
#define IDS_EFFECTS                     27
#define IDS_FADEEFFECT                  28
#define IDS_SCROLLEFFECT                29
#define IDS_CLEARTYPE                   30
#define IDS_STANDARDSMOOTHING           31
#define IDI_WINDRAGICON                 101
#define IDI_FONTSMOOTHICON              102
#define IDI_HIGHCOLORICON               103
#define IDI_WALLPAPERFITICON            104
#define IDI_USELARGEICONS               107
#define IDC_FULLWINDOWDRAGGING          1000
#define IDC_FONTSMOOTHING               1001
#define IDC_ICONHIGHCOLOR               1002
#define IDC_STRETCHWALLPAPERFITSCREEN   1003
//#define IDC_HIDEICONS                   1003
#define IDC_CHANGEICON                  1004
#define IDC_ICONS                       1005
#define IDD_PATH                        1006
#define IDC_MENUANIMATION               1006
#define IDD_ICON                        1007
#define IDC_FONTSMOOTH                  1007
#define IDD_BROWSE                      1008
#define IDC_SHOWDRAG                    1008
#define IDC_ICONDEFAULT                 1009
#define IDC_LARGEICONS                  1010
#define IDC_KEYBOARDINDICATORS          1011
#define IDC_COMBOEFFECT                 1012
#define IDC_SHOWME                      1013
#define IDC_COMBOFSMOOTH                1014
#define IDC_MENUSHADOWS                 1015
#define IDC_GRPBOX_1                    2000
#define IDC_GRPBOX_2                    2001

#ifdef CLEARTYPECOMBO
// For TEXT EDGE
#define IDS_TEXTPROP                    3000
#define DLG_TEXTEDGE                    3001
#define IDC_TEXTEDGEMODE                3002
#define IDC_MONOTEXT                    3003
#define IDC_AATEXT                      3004
#define IDC_CTTEXT                      3005                  
#define IDC_TEXTSAMPLE                  3006
#define IDC_AASHOW                      3007
#define IDC_CTSHOW                      3008
#endif // CLEARTYPECOMBO

#define IDC_STATIC                      -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\plus\store.h ===
/*****************************************************************************\
    FILE: store.h

    DESCRIPTION:
        This file will get and set effect settings into the persisted store.
    That persisted store is the registery and in SystemParametersInfo.

    BryanSt 4/17/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _STORE_H
#define _STORE_H


// Name of the file that holds each icon, and an index for which icon to use in the file
typedef struct tagIconKeys
{
    TCHAR szOldFile[MAX_PATH];
    int   iOldIndex;
    TCHAR szNewFile[MAX_PATH];
    int   iNewIndex;
}ICONDATA;



// Registry Info for the icons
typedef struct tagIconRegKeys
{
    const CLSID* pclsid;
    TCHAR szIconValue[16];
    int  iTitleResource;
    int  iDefaultTitleResource;
    LPCWSTR szDefault;
    int  nDefaultIndex;
}ICONREGKEYS;

static const ICONREGKEYS c_aIconRegKeys[] =
{
    { &CLSID_MyComputer,    TEXT("\0"),     0,          IDS_MYCOMPUTER,     L"%WinDir%\\explorer.exe",            0},
    { &CLSID_MyDocuments,   TEXT("\0"),     0,          IDS_MYDOCUMENTS,    L"%WinDir%\\SYSTEM32\\mydocs.dll",    0},
#ifdef INET_EXP_ICON
    { &CLSID_Internet,      TEXT("\0"),     0,          IDS_INTERNET,       L"",                                0},
#endif
    { &CLSID_NetworkPlaces, TEXT("\0"),     0,          IDS_NETNEIGHBOUR,   L"%WinDir%\\SYSTEM32\\shell32.dll",   17},
    { &CLSID_RecycleBin,    TEXT("full"),   IDS_FULL,   IDS_TRASHFULL,      L"%WinDir%\\SYSTEM32\\shell32.dll",   32},
    { &CLSID_RecycleBin,    TEXT("empty"),  IDS_EMPTY,  IDS_TRASHEMPTY,     L"%WinDir%\\SYSTEM32\\shell32.dll",   31},
#ifdef DIRECTORY_ICON
    { &CLSID_ShellFSFolder, TEXT("\0"),     0,          IDS_DIRECTORY,      L"",                                0},
#endif
};

#define NUM_ICONS (ARRAYSIZE(c_aIconRegKeys))

enum ICON_SIZE_TYPES {
   ICON_DEFAULT         = 0,
   ICON_LARGE           = 1,
   ICON_INDETERMINATE   = 2
};

#define ICON_DEFAULT_SMALL    16
#define ICON_DEFAULT_NORMAL   32
#define ICON_DEFAULT_LARGE    48

#define MENU_EFFECT_FADE        1
#define MENU_EFFECT_SCROLL      2

#define FONT_SMOOTHING_MONO        0
#define FONT_SMOOTHING_AA          1
#define FONT_SMOOTHING_CT          2

#define PATH_WIN  0
#define PATH_SYS  1
#define PATH_IEXP 2





class CEffectState
{
public:
    // Private Member Variables
    ICONDATA _IconData[NUM_ICONS];

    int      _nLargeIcon;             // Large Icon State            (iOldLI, iNewLI)
    int      _nHighIconColor;         // High Icon Colour            (iOldHIC, iNewHIC)
    WPARAM   _wpMenuAnimation;        // Menu Animation State        (wOldMA, wNewMA)
    BOOL     _fFontSmoothing;         // Font Smoothing State        (bOldSF, bNewSF)
    DWORD    _dwFontSmoothingType;    // Font Smoothing Type         (dwOldSFT, dwNewSFT)
    BOOL     _fDragWindow;            // Drag Window State           (bOldDW, bNewDW)
    BOOL     _fKeyboardIndicators;    // Keyboard Indicators         (uOldKI, uNewKI)
    DWORD    _dwAnimationEffect;      // Animation Effect            (dwOldEffect, dwNewEffect)
    BOOL     _fMenuShadows;           // Show Menu Shadows

    // Old values (before they were dirtied)
    int      _nOldLargeIcon;             // Large Icon State            (iOldLI)
    int      _nOldHighIconColor;         // High Icon Colour            (iOldHIC)
    WPARAM   _wpOldMenuAnimation;        // Menu Animation State        (wOldMA)
    BOOL     _fOldFontSmoothing;         // Font Smoothing State        (bOldSF)
    DWORD    _dwOldFontSmoothingType;    // Font Smoothing Type         (dwOldSFT)
    BOOL     _fOldDragWindow;            // Drag Window State           (bOldDW)
    BOOL     _fOldKeyboardIndicators;    // Keyboard Indicators         (uOldKI)
    DWORD    _dwOldAnimationEffect;      // Animation Effect            (dwOldEffect)
    BOOL     _fOldMenuShadows;           // Show Menu Shadows

    // Private Member Functions
    HRESULT Load(void);
    HRESULT Save(void);
    HRESULT Clone(OUT CEffectState ** ppEffectClone);
    BOOL IsDirty(void);
    BOOL HasIconsChanged(IN CEffectState * pCurrent);
    HRESULT GetIconPath(IN CLSID clsid, IN LPCWSTR pszName, IN LPWSTR pszPath, IN DWORD cchSize);
    HRESULT SetIconPath(IN CLSID clsid, IN LPCWSTR pszName, IN LPCWSTR pszPath, IN int nResourceID);

    CEffectState(void);
    virtual ~CEffectState(void);

private:
};




int GetBitsPerPixel(void);

extern HINSTANCE g_hmodShell32;



#endif // _STORE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\plus\store.cpp ===
//---------------------------------------------------------------------------
//
//  File: plustab.cpp
//
//  Main Implementation of the Effects page
//
//---------------------------------------------------------------------------


#include "precomp.hxx"
#include "shlwapip.h"
#include "shlguidp.h"
#include "EffectsAdvPg.h"
#include "store.h"
#pragma hdrstop

// OLE-Registry magic number
GUID g_CLSID_CplExt = { 0x41e300e0, 0x78b6, 0x11ce,
                        { 0x84, 0x9b, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00}
                      };

#define SPI_GETKEYBOARDINDICATORS SPI_GETMENUUNDERLINES//0x100A
#define SPI_SETKEYBOARDINDICATORS SPI_SETMENUUNDERLINES//0x100B

#define SPI_GETFONTCLEARTYPE      116
#define SPI_SETFONTCLEARTYPE      117

//Defines for getting registry settings
const TCHAR c_szHICKey[] = TEXT("Control Panel\\Desktop\\WindowMetrics"); // show icons using highest possible colors
const TCHAR c_szHICVal[] = TEXT("Shell Icon BPP"); // (4 if the checkbox is false, otherwise 16, don't set it to anything else)
const TCHAR c_szSSKey[]  = TEXT("Control Panel\\Desktop");
const TCHAR c_szSSVal[]  = TEXT("SmoothScroll");
const TCHAR c_szWMSISVal[] = TEXT("Shell Icon Size"); // Normal Icon Size (default 32 x 32)
#ifdef INET_EXP_ICON
const TCHAR c_szIEXP[]   = TEXT("\\Program Files\\Microsoft Internet Explorer 4");
#endif

// Handle to the DLL
extern HINSTANCE g_hInst;

BOOL g_bMirroredOS = FALSE;
// vars needed for new shell api
#define SZ_SHELL32                  TEXT("shell32.dll")
#define SZ_SHUPDATERECYCLEBINICON   "SHUpdateRecycleBinIcon"    // Parameter for GetProcAddr()... DO NOT TEXT("") IT!

HINSTANCE g_hmodShell32 = NULL;
typedef void (* PFNSHUPDATERECYCLEBINICON)( void );

// Function prototype
BOOL CALLBACK PlusPackDlgProc( HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam );

// Icon Stuff
int   GetIconState (void);
BOOL  ChangeIconSizes(int iOldState, int iNewState);


// animation stuff
WPARAM GetAnimations(DWORD *pdwEffect);
void SetAnimations(WPARAM wVal, DWORD dwEffect);

BOOL DisplayFontSmoothingDetails(DWORD *pdwSetting)
{
    return FALSE;
}

int GetBitsPerPixel(void)
{
    int iBitsPerPixel = 8;
    HDC hDC = GetDC(NULL);

    if (hDC)
    {
        iBitsPerPixel = GetDeviceCaps(hDC, BITSPIXEL);
        ReleaseDC(NULL, hDC);
    }

    return iBitsPerPixel;
}

int GetIconState(void)
{
    BOOL bRet;
    int iSize;

    bRet = GetRegValueInt(HKEY_CURRENT_USER, c_szHICKey, c_szWMSISVal, &iSize);
    if (bRet == FALSE)
        return ICON_DEFAULT;

    if (iSize == ICON_DEFAULT_NORMAL)
        return ICON_DEFAULT;
    else if (iSize == ICON_DEFAULT_LARGE)
        return ICON_LARGE;
    return ICON_INDETERMINATE;
}


BOOL ChangeIconSizes(int iOldState, int iNewState)
{
    BOOL bRet;
    int  iOldSize, iNewSize;
    int  iHorz;
    int  iVert;

    // Don't bother if nothing changed
    if (iOldState == iNewState)
        return FALSE;

    // Get New Size
    switch (iNewState)
        {
        case ICON_DEFAULT:
            iNewSize = ICON_DEFAULT_NORMAL;
            break;

        case ICON_LARGE:
            iNewSize = ICON_DEFAULT_LARGE;
            break;

        case ICON_INDETERMINATE:
            // Don't bother to change anything
            return FALSE;

        default:
            return FALSE;
        }

    // Get Original Size
    bRet = GetRegValueInt (HKEY_CURRENT_USER, c_szHICKey, c_szWMSISVal, &iOldSize);
    if (!bRet)
    {
        // Try geting system default instead
        iOldSize = GetSystemMetrics (SM_CXICON);
    }


    // Don't need to change size if nothing has really changed
    if (iNewSize == iOldSize)
        return FALSE;

    // Get new horizontal spacing
    iHorz = GetSystemMetrics (SM_CXICONSPACING);
    iHorz -= iOldSize;
    if (iHorz < 0)
    {
        iHorz = 0;
    }
    iHorz += iNewSize;

    // Get new vertical spacing
    iVert = GetSystemMetrics (SM_CYICONSPACING);
    iVert -= iOldSize;
    if (iVert < 0)
    {
        iVert = 0;
    }
    iVert += iNewSize;

        // Set New sizes and spacing
    bRet = SetRegValueInt( HKEY_CURRENT_USER, c_szHICKey, c_szWMSISVal, iNewSize );
    if (!bRet)
        return FALSE;

    SystemParametersInfo( SPI_ICONHORIZONTALSPACING, iHorz, NULL, SPIF_UPDATEINIFILE );
    SystemParametersInfo( SPI_ICONVERTICALSPACING, iVert, NULL, SPIF_UPDATEINIFILE );

    // We did change the sizes
    return TRUE;
}


//
//  GetAnimations
//
//  Get current state of animations (windows / menus / etc.).
//
WPARAM GetAnimations(DWORD *pdwEffect)
{
    BOOL fMenu = FALSE, fWindow = FALSE, fCombo = FALSE, fSmooth = FALSE, fList = FALSE, fFade = FALSE;
    ANIMATIONINFO ai;

    ai.cbSize = sizeof(ai);
    if (SystemParametersInfo( SPI_GETANIMATION, sizeof(ai), (PVOID)&ai, 0 ))
    {
        fWindow = (ai.iMinAnimate) ? TRUE : FALSE;
    }

    SystemParametersInfo( SPI_GETCOMBOBOXANIMATION, 0, (PVOID)&fCombo, 0 );
    SystemParametersInfo( SPI_GETLISTBOXSMOOTHSCROLLING, 0, (PVOID)&fList, 0 );
    SystemParametersInfo( SPI_GETMENUANIMATION, 0, (PVOID)&fMenu, 0 );
    fSmooth = (BOOL)GetRegValueDword( HKEY_CURRENT_USER,
                                      (LPTSTR)c_szSSKey,
                                      (LPTSTR)c_szSSVal
                                     );

    if (fSmooth == REG_BAD_DWORD)
    {
        fSmooth = 1;
    }
    
    SystemParametersInfo( SPI_GETMENUFADE, 0, (PVOID)&fFade, 0 );
    *pdwEffect = (fFade ? MENU_EFFECT_FADE : MENU_EFFECT_SCROLL);
    
    if (fMenu && fWindow && fCombo && fSmooth && fList)
        return BST_CHECKED;

    if ((!fMenu) && (!fWindow) && (!fCombo) && (!fSmooth) && (!fList))
        return BST_UNCHECKED;

    return BST_INDETERMINATE;
}

//
//  SetAnimations
//
//  Set animations according (windows / menus / etc.) according to flag.
//
void SetAnimations(WPARAM wVal, DWORD dwEffect)
{
    ANIMATIONINFO ai;

    // Note, if the checkbox is indeterminate, we treat it like it was checked.
    // We should never get this far if the user didn't change something so this should be okay.
    BOOL bVal = (wVal == BST_UNCHECKED) ? 0 : 1;
    BOOL bEfx = (dwEffect == MENU_EFFECT_FADE) ? 1 : 0;
        
    ai.cbSize = sizeof(ai);
    ai.iMinAnimate = bVal;
    SystemParametersInfo( SPI_SETANIMATION, sizeof(ai), (PVOID)&ai, SPIF_UPDATEINIFILE );
    SystemParametersInfo( SPI_SETCOMBOBOXANIMATION, 0, IntToPtr(bVal), SPIF_UPDATEINIFILE );
    SystemParametersInfo( SPI_SETLISTBOXSMOOTHSCROLLING, 0, IntToPtr(bVal), SPIF_UPDATEINIFILE );
    SystemParametersInfo( SPI_SETMENUANIMATION, 0, IntToPtr(bVal), SPIF_UPDATEINIFILE );
    SystemParametersInfo( SPI_SETTOOLTIPANIMATION, 0, IntToPtr(bVal), SPIF_UPDATEINIFILE );
    SetRegValueDword(HKEY_CURRENT_USER, (LPTSTR)c_szSSKey, (LPTSTR)c_szSSVal, bVal);

    SystemParametersInfo( SPI_SETMENUFADE, 0, IntToPtr(bEfx), SPIF_UPDATEINIFILE);
    SystemParametersInfo( SPI_SETTOOLTIPFADE, 0, IntToPtr(bEfx), SPIF_UPDATEINIFILE);
    SystemParametersInfo( SPI_SETSELECTIONFADE, 0, bVal ? IntToPtr(bEfx) : 0, SPIF_UPDATEINIFILE);
}




CEffectState::CEffectState()
{
}


CEffectState::~CEffectState()
{
}


HRESULT CEffectState::Load(void)
{
    HRESULT hr = S_OK;

    // Get the values for the settings from the registry and set the checkboxes
    // Large Icons
    _nLargeIcon = GetIconState();

    // Full Color Icons
    if(FALSE == GetRegValueInt(HKEY_CURRENT_USER, c_szHICKey, c_szHICVal, &_nHighIconColor)) // Key not in registry yet
    {
        _nHighIconColor = 4;
    }

    // Use animations
    _wpMenuAnimation = GetAnimations(&_dwAnimationEffect);
    
    // Smooth edges of screen fonts
    _fFontSmoothing = FALSE;
    SystemParametersInfo(SPI_GETFONTSMOOTHING, 0, (PVOID)&_fFontSmoothing, 0);

    _dwFontSmoothingType = FONT_SMOOTHING_AA;
#ifdef CLEARTYPECOMBO
    if (SystemParametersInfo(SPI_GETFONTSMOOTHINGTYPE, 0, (PVOID)&_dwFontSmoothingType, 0)) 
    {
    }
#endif //CLEARTYPECOMBO
    
    // Show contents while dragging
    _fDragWindow = FALSE;
    SystemParametersInfo(SPI_GETDRAGFULLWINDOWS, 0, (PVOID)&_fDragWindow, 0);

    _fKeyboardIndicators = FALSE;
    SystemParametersInfo(SPI_GETKEYBOARDINDICATORS, 0, (PVOID)&_fKeyboardIndicators, 0);

    _fMenuShadows = TRUE;
    SystemParametersInfo(SPI_GETDROPSHADOW, 0, (PVOID)&_fMenuShadows, 0);

    // Set the old values so we know when they changed.
    _nOldLargeIcon = _nLargeIcon;
    _nOldHighIconColor = _nHighIconColor;
    _wpOldMenuAnimation = _wpMenuAnimation;
    _fOldFontSmoothing = _fFontSmoothing;
    _dwOldFontSmoothingType = _dwFontSmoothingType;
    _fOldDragWindow = _fDragWindow;
    _fOldKeyboardIndicators = _fKeyboardIndicators;
    _dwOldAnimationEffect = _dwAnimationEffect;
    _fOldMenuShadows = _fMenuShadows;

    // load the icons and add them to the image lists
    // get the icon files and indexes from the registry, including for the Default recycle bin
    for (int nIndex = 0; nIndex < ARRAYSIZE(_IconData); nIndex++)
    {
        TCHAR szTemp[MAX_PATH];

        szTemp[0] = 0;
        IconGetRegValueString(c_aIconRegKeys[nIndex].pclsid, TEXT("DefaultIcon"), c_aIconRegKeys[nIndex].szIconValue, szTemp, ARRAYSIZE(szTemp));
        int iIndex = PathParseIconLocation(szTemp);

        // store the icon information
        lstrcpy(_IconData[nIndex].szOldFile, szTemp);
        lstrcpy(_IconData[nIndex].szNewFile, szTemp);
        _IconData[nIndex].iOldIndex = iIndex;
        _IconData[nIndex].iNewIndex = iIndex;
    }


    return hr;
}


BOOL CEffectState::HasIconsChanged(IN CEffectState * pCurrent)
{
    BOOL fHasIconsChanged = FALSE;
    int nIndex;

    for (nIndex = 0; nIndex < ARRAYSIZE(_IconData); nIndex++)
    {
        if (StrCmpI(_IconData[nIndex].szNewFile, pCurrent->_IconData[nIndex].szNewFile) ||
            (_IconData[nIndex].iNewIndex != pCurrent->_IconData[nIndex].iNewIndex))
        {
            fHasIconsChanged = TRUE;
            break;
        }
    }

    return fHasIconsChanged;
}


HRESULT CEffectState::Save(void)
{
    HRESULT hr = S_OK;
    BOOL bDorked = FALSE;
    int iX;

    // Large Icons
    BOOL bSendSettingsChange = ChangeIconSizes(_nOldLargeIcon, _nLargeIcon);
    if (bSendSettingsChange)
    {
        _nOldLargeIcon = _nLargeIcon;
        bDorked = TRUE;
    }

    // Full Color Icons
    if(_nOldHighIconColor != _nHighIconColor)
    {
        SetRegValueInt(HKEY_CURRENT_USER, c_szHICKey, c_szHICVal, _nHighIconColor);
        if ((GetBitsPerPixel() < 16) && (_nHighIconColor == 16)) // Display mode won't support icon high colors
        {
        }
        else
        {
           _nOldHighIconColor = _nHighIconColor;
           bSendSettingsChange = TRUE;
        }
    }

    // Full window drag
    if (_fOldDragWindow != _fDragWindow)
    {
        _fOldDragWindow = _fDragWindow;
        SystemParametersInfo(SPI_SETDRAGFULLWINDOWS, _fDragWindow, 0, SPIF_UPDATEINIFILE);
        // we need to send this because the tray's autohide switches off this
        bSendSettingsChange = TRUE;
    }

    // Show Menu Shadows
    if (_fOldMenuShadows != _fMenuShadows)
    {
        _fOldMenuShadows = _fMenuShadows;
        SystemParametersInfo(SPI_SETDROPSHADOW, _fMenuShadows, 0, SPIF_UPDATEINIFILE);
        // we need to send this because the tray's autohide switches off this
        bSendSettingsChange = TRUE;
    }

    // Font smoothing
    if ((_fOldFontSmoothing != _fFontSmoothing) || (_dwOldFontSmoothingType != _dwFontSmoothingType))
    {
#ifdef CLEARTYPECOMBO
        SystemParametersInfo(SPI_SETFONTSMOOTHINGTYPE, 0, (PVOID)UlongToPtr(_dwFontSmoothingType), SPIF_UPDATEINIFILE);
#endif
        _dwOldFontSmoothingType = _dwFontSmoothingType;
        _fOldFontSmoothing = _fFontSmoothing;
        SystemParametersInfo(SPI_SETFONTSMOOTHING, _fFontSmoothing, 0, SPIF_UPDATEINIFILE);
    }

    // Menu animations
    if ((_wpOldMenuAnimation != _wpMenuAnimation) || (_dwOldAnimationEffect != _dwAnimationEffect))
    {
        _wpOldMenuAnimation = _wpMenuAnimation;
        SetAnimations(_wpMenuAnimation, _dwAnimationEffect);
        _dwOldAnimationEffect = _dwAnimationEffect;
    }

    // Change the system icons
    for( iX = 0; iX < NUM_ICONS; iX++)
    {
        if ((lstrcmpi(_IconData[iX].szNewFile, _IconData[iX].szOldFile) != 0) ||
            (_IconData[iX].iNewIndex != _IconData[iX].iOldIndex))
        {
            TCHAR   szTemp[MAX_PATH];

            wnsprintf(szTemp, ARRAYSIZE(szTemp), TEXT("%s,%d"), _IconData[iX].szNewFile, _IconData[iX].iNewIndex);
            
            IconSetRegValueString(c_aIconRegKeys[iX].pclsid, TEXT("DefaultIcon"), c_aIconRegKeys[iX].szIconValue, szTemp);

            // Next two lines necessary if the user does an Apply as opposed to OK
            lstrcpy(_IconData[iX].szOldFile, _IconData[iX].szNewFile);
            _IconData[iX].iOldIndex = _IconData[iX].iNewIndex;
            bDorked = TRUE;
        }
    }

    // Keyboard indicators
    if (_fOldKeyboardIndicators != _fKeyboardIndicators)
    {
        _fOldKeyboardIndicators = _fKeyboardIndicators;

        DWORD_PTR dwResult;

        // Are we turning this on? (!_fKeyboardIndicators means "don't show" -> hide)
        if (!_fKeyboardIndicators)
        {
            // Yes, on: hide the key cues, turn on the mechanism
            SystemParametersInfo(SPI_SETKEYBOARDINDICATORS, 0, IntToPtr(_fKeyboardIndicators), SPIF_UPDATEINIFILE);

            SendMessageTimeout(HWND_BROADCAST, WM_CHANGEUISTATE, MAKEWPARAM(UIS_SET, UISF_HIDEFOCUS | UISF_HIDEACCEL), 0, SMTO_ABORTIFHUNG, 10*1000, &dwResult);
        }
        else
        {
            // No, off: means show the keycues, turn off the mechanism
            SendMessageTimeout(HWND_BROADCAST, WM_CHANGEUISTATE, 
                MAKEWPARAM(UIS_CLEAR, UISF_HIDEFOCUS | UISF_HIDEACCEL),
                0, SMTO_ABORTIFHUNG, 10*1000, &dwResult);

            SystemParametersInfo(SPI_SETKEYBOARDINDICATORS, 0, IntToPtr(_fKeyboardIndicators), SPIF_UPDATEINIFILE);
        }
    }

    // Make the system notice we changed the system icons
    if (bDorked)
    {
        PFNSHUPDATERECYCLEBINICON pfnSHUpdateRecycleBinIcon = NULL;
        SHChangeNotify(SHCNE_ASSOCCHANGED, 0, NULL, NULL); // should do the trick!

        if (!pfnSHUpdateRecycleBinIcon)
        {
            // Load SHUpdateRecycleBinIcon() if it exists
            g_hmodShell32 = LoadLibrary(SZ_SHELL32);
            pfnSHUpdateRecycleBinIcon = (PFNSHUPDATERECYCLEBINICON)GetProcAddress(g_hmodShell32, SZ_SHUPDATERECYCLEBINICON);
        }

        if (pfnSHUpdateRecycleBinIcon != NULL)
        {
            pfnSHUpdateRecycleBinIcon();
        }
    }

    if (bSendSettingsChange)
    {
        DWORD_PTR dwResult = 0;

        SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, 0, 0, SMTO_ABORTIFHUNG, 10*1000, &dwResult);
    }

    return hr;
}


#define SZ_ICON_DEFAULTICON               L"DefaultValue"
HRESULT CEffectState::GetIconPath(IN CLSID clsid, IN LPCWSTR pszName, IN LPWSTR pszPath, IN DWORD cchSize)
{
    HRESULT hr = E_FAIL;
    int nIndex;

    if (!StrCmpIW(SZ_ICON_DEFAULTICON, pszName))
    {
        pszName = L"";
    }

    for (nIndex = 0; nIndex < ARRAYSIZE(_IconData); nIndex++)
    {
        if (IsEqualCLSID(*(c_aIconRegKeys[nIndex].pclsid), clsid) &&
            !StrCmpIW(pszName, c_aIconRegKeys[nIndex].szIconValue))
        {
            // We found it.
            wnsprintfW(pszPath, cchSize, L"%s,%d", _IconData[nIndex].szNewFile, _IconData[nIndex].iNewIndex);

            hr = S_OK;
            break;
        }
    }

    return hr;
}


HRESULT CEffectState::SetIconPath(IN CLSID clsid, IN LPCWSTR pszName, IN LPCWSTR pszPath, IN int nResourceID)
{
    HRESULT hr = E_FAIL;
    int nIndex;

    if (!StrCmpIW(SZ_ICON_DEFAULTICON, pszName))
    {
        pszName = L"";
    }

    for (nIndex = 0; nIndex < ARRAYSIZE(_IconData); nIndex++)
    {
        if (IsEqualCLSID(*(c_aIconRegKeys[nIndex].pclsid), clsid) &&
            !StrCmpIW(pszName, c_aIconRegKeys[nIndex].szIconValue))
        {
            TCHAR szTemp[MAX_PATH];

            if (!pszPath || !pszPath[0])
            {
                // The caller didn't specify an icon so use the default values.
                if (!SHExpandEnvironmentStrings(c_aIconRegKeys[nIndex].szDefault, szTemp, ARRAYSIZE(szTemp)))
                {
                    StrCpyN(szTemp, c_aIconRegKeys[nIndex].szDefault, ARRAYSIZE(szTemp));
                }

                pszPath = szTemp;
                nResourceID = c_aIconRegKeys[nIndex].nDefaultIndex;
            }

            // We found it.
            StrCpyNW(_IconData[nIndex].szNewFile, pszPath, ARRAYSIZE(_IconData[nIndex].szNewFile));
            _IconData[nIndex].iNewIndex = nResourceID;

            hr = S_OK;
            break;
        }
    }

    return hr;
}


HRESULT CEffectState::Clone(OUT CEffectState ** ppEffectClone)
{
    HRESULT hr = E_OUTOFMEMORY;

    *ppEffectClone = new CEffectState();
    if (*ppEffectClone)
    {
        hr = S_OK;

        (*ppEffectClone)->_nLargeIcon = _nLargeIcon;
        (*ppEffectClone)->_nHighIconColor = _nHighIconColor;
        (*ppEffectClone)->_wpMenuAnimation = _wpMenuAnimation;
        (*ppEffectClone)->_fFontSmoothing = _fFontSmoothing;
        (*ppEffectClone)->_dwFontSmoothingType = _dwFontSmoothingType;
        (*ppEffectClone)->_fDragWindow = _fDragWindow;
        (*ppEffectClone)->_fKeyboardIndicators = _fKeyboardIndicators;
        (*ppEffectClone)->_dwAnimationEffect = _dwAnimationEffect;

        (*ppEffectClone)->_nOldLargeIcon = _nOldLargeIcon;
        (*ppEffectClone)->_nOldHighIconColor = _nOldHighIconColor;
        (*ppEffectClone)->_wpOldMenuAnimation = _wpOldMenuAnimation;
        (*ppEffectClone)->_fOldFontSmoothing = _fOldFontSmoothing;
        (*ppEffectClone)->_dwOldFontSmoothingType = _dwOldFontSmoothingType;
        (*ppEffectClone)->_fOldDragWindow = _fOldDragWindow;
        (*ppEffectClone)->_fOldKeyboardIndicators = _fOldKeyboardIndicators;
        (*ppEffectClone)->_dwOldAnimationEffect = _dwOldAnimationEffect;
        (*ppEffectClone)->_fOldMenuShadows = _fOldMenuShadows;

        for (int nIndex = 0; nIndex < ARRAYSIZE(_IconData); nIndex++)
        {
            (*ppEffectClone)->_IconData[nIndex].iOldIndex = _IconData[nIndex].iOldIndex;
            (*ppEffectClone)->_IconData[nIndex].iNewIndex = _IconData[nIndex].iNewIndex;

            StrCpyN((*ppEffectClone)->_IconData[nIndex].szOldFile, _IconData[nIndex].szOldFile, ARRAYSIZE((*ppEffectClone)->_IconData[nIndex].szOldFile));
            StrCpyN((*ppEffectClone)->_IconData[nIndex].szNewFile, _IconData[nIndex].szNewFile, ARRAYSIZE((*ppEffectClone)->_IconData[nIndex].szNewFile));
        }
    }

    return hr;
}



BOOL CEffectState::IsDirty(void)
{
    BOOL fDirty = FALSE;

    if ((_nLargeIcon != _nOldLargeIcon) ||
        (_nHighIconColor != _nOldHighIconColor) ||
        (_wpMenuAnimation != _wpOldMenuAnimation) ||
        (_fFontSmoothing != _fOldFontSmoothing) ||
        (_dwFontSmoothingType != _dwOldFontSmoothingType) ||
        (_fDragWindow != _fOldDragWindow) ||
        (_fMenuShadows != _fOldMenuShadows) ||
        (_fKeyboardIndicators != _fOldKeyboardIndicators) ||
        (_dwAnimationEffect != _dwOldAnimationEffect))
    {
        fDirty = TRUE;
    }
    else
    {
        for (int nIndex = 0; nIndex < ARRAYSIZE(_IconData); nIndex++)
        {
            if ((_IconData[nIndex].iNewIndex != _IconData[nIndex].iOldIndex) ||
                (StrCmpI(_IconData[nIndex].szNewFile, _IconData[nIndex].szOldFile)))
            {
                fDirty = TRUE;
                break;
            }
        }
    }

    return fDirty;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\plus\old_src\addon.h ===
// Common strings

#define NO_HELP                         ((DWORD) -1)
#define IDH_COMM_GROUPBOX               28548

// Welcome Help after Setup: Jessev

#define GET_WELCOME                     0002

// Enhanced Property Sheet ID's: Shawnb


#define IDH_COMPDRV_TABLE_ULTRA         1002
#define IDH_COMPDRV_TABLE_HIPACK        1003
#define IDH_COMPDRV_TABLE_STD           1004
#define IDH_COMPDRV_TABLE_UNCOMP        1005
#define IDH_COMPDRV_TABLE_FREESP        1006
#define IDH_COMPDRV_TABLE_REDUCED       1007
#define IDH_COMPDRV_PIE                 1008
#define IDH_COMPDRV_TABLE               1009
#define IDH_COMPDRV_RECOMPNOW           1010
#define IDH_COMPDRV_UPGRADENOW          1011
#define IDH_COMPDRV_ADV                 1012
#define IDH_COMPDRV_ADV_HIDEHOST        1013
#define IDH_UNCOMPDRV_COMPDRIVE         1014
#define IDH_UNCOMPDRV_COMPPIE           1015
#define IDH_UNCOMPDRV_CREATENEW         1016
#define IDH_UNCOMPDRV_CREATEPIE         1017
#define IDH_HOSTDRV_PIE                 1018
#define IDH_HOSTDRV_TABLE               1019
#define IDH_RUN_DRVSPACE                1020
#define IDH_COMPDRV_GAUGE               1021
#define IDH_COMPDRV_TABLE_TOTAL         1022


//ID's for the Theme Picker applet

#define IDH_THEME_LIST                  2001
#define IDH_THEME_SAVEAS                2002
#define IDH_THEME_DELETE                2003
#define IDH_THEME_PREVSCRN              2004
#define IDH_THEME_PREVETC               2005
#define IDH_THEME_PREVIEW               2006
#define IDH_THEME_SCRNSAVER             2007
#define IDH_THEMES_SOUNDS               2008
#define IDH_THEME_POINTERS              2009
#define IDH_THEME_WALLPAPER             2010
#define IDH_THEME_ICONS                 2011
#define IDH_THEME_COLORS                2012
#define IDH_THEME_FONTS                 2013
#define IDH_THEME_BORDER                2014
#define IDH_THEME_POINTERS_LIST         2015
#define IDH_THEME_POINTERS_PREV         2016
#define IDH_THEME_POINTERS_FILE         2018
#define IDH_THEME_SOUNDS_LIST           2019
#define IDH_THEME_SOUNDS_ICON_PREV      2020
#define IDH_THEME_SOUNDS_PLAYS          2021
#define IDH_THEME_SOUNDS_FILE           2022
#define IDH_THEME_PICS_LIST             2023
#define IDH_THEME_PICS_PREV             2024
#define IDH_THEME_PICS_FILE             2025
// #define IDH_THEME_SAVE_NAME          2026
#define IDH_THEME_ICON_SIZESPACE        2027

// Lens settings ID's

#define IDH_LENS_FLIP                   3000            // Temporary
#define IDH_LENS_GLASS_SPHERE           3001
#define IDH_LENS_INSIDE_OUT             3002
#define IDH_LENS_BLACK_HOLE             3003
#define IDH_LENS_DENT                   3004
#define IDH_LENS_SPIRAL                 3005
#define IDH_LENS_SIZE                   3006
#define IDH_LENS_SPEED                  3007
#define IDH_LENS_INDEX                  3008
#define IDH_LENS_ALTITUDE               3009
#define IDH_LENS_MASS                   3010
#define IDH_LENS_HEIGHT                 3011
#define IDH_LENS_TWIST                  3012
#define IDH_LENS_WALLPAPER              3013

//Blocks settings ID's

#define IDH_BLOCKS_SIZE                 3050
#define IDH_BLOCKS_SPEED                3051

//Socha Settings ID's

#define IDH_SCRNSAVER_GEN_MONITOR       3100
#define IDH_SCRNSAVER_GEN_MOUSESEN      3101
#define IDH_SCRNSAVER_GEN_PASSREQUIRED  3102
#define IDH_SCRNSAVER_GEN_ABOUT         3103
#define IDH_SCRNSAVER_PREVIEW           3104
#define IDH_SCRNSAVER_GEN_NOSOUND       3105

// Plus Display Properties ID's

// windows.hlp IDH_'s
#define IDH_DISPLAY_PLUSPACK_LIST       4300
#define IDH_DISPLAY_PLUSPACK_CHANGEICON 4301
#define IDH_DISPLAY_PLUSPACK_ALLCOLORS  4302
#define IDH_DISPLAY_PLUSPACK_FULLWINDOW 4303
#define IDH_DISPLAY_PLUSPACK_FONTSMOOTH 4304
#define IDH_DISPLAY_PLUSPACK_STRETCH    4305
#define IDH_DISPLAY_PLUSPACK_LARGEICONS 4306
#define IDH_DISPLAY_PLUSPACK_DEFAULT_ICON 4307

// plus!.hlp IDH_'s
#define IDH_PLUS_PLUSPACK_LIST       4100
#define IDH_PLUS_PLUSPACK_CHANGEICON 4101
#define IDH_PLUS_PLUSPACK_ALLCOLORS  4102
#define IDH_PLUS_PLUSPACK_FULLWINDOW 4103
#define IDH_PLUS_PLUSPACK_FONTSMOOTH 4104
#define IDH_PLUS_PLUSPACK_STRETCH    4105
#define IDH_PLUS_PLUSPACK_LARGEICONS 4106


// RNA dial-in ID's

#define IDH_RNA_IN_NOACC                4259
#define IDH_RNA_IN_ENABLEACC            4260
#define IDH_RNA_IN_PASSWORD             4263
#define IDH_RNA_IN_COMMENT              4264
#define IDH_RNA_IN_STATUS               4265
#define IDH_RNA_IN_DISCONNECT           4266
#define IDH_RNA_MODEM_SERVER            4275

// Internet Shortcut Target URL

#define IDH_INTERNET_SHORTCUT_TARGET    6001

// Disk Troubleshooter ID's

#define IDH_DSKTRB_FREESPACE            5001
#define IDH_COMPSET_TRB_MAIN            5002    // Must match DOS\DOS86\DBLSPACE\UTILITY\FROSTHLP.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\plus\regutils.cpp ===
//------------------------------------------------------------------------------------
//
//      File: REGUTILS.CPP
//
//      Helper functions that handle reading and writing strings to the system registry.
//
//------------------------------------------------------------------------------------

#include "precomp.hxx"
#pragma hdrstop

BOOL _GetRegValueString( HKEY hkey, LPCTSTR lpszValName, LPTSTR lpszValue, int cchSize );

// our own atoi function so we don't have to link to the C runtimes...
INT AtoI( LPCTSTR pValue )
{
    INT i = 0;
    INT iSign = 1;

    while( pValue && *pValue )
    {
        if (*pValue == TEXT('-'))
        {
            iSign = -1;
        }
        else
        {
            i = (i*10) + (*pValue - TEXT('0'));
        }
        pValue++;
    }

    return (i * iSign);
}

void ItoA ( INT val, LPTSTR buf, UINT radix )
{
    LPTSTR p;               /* pointer to traverse string */
    LPTSTR firstdig;        /* pointer to first digit */
    TCHAR temp;             /* temp char */
    INT digval;             /* value of digit */
    
    p = buf;
    
    if (val < 0) {
        /* negative, so output '-' and negate */
        *p++ = TEXT('-');
        val = -val;
    }
    
    firstdig = p;           /* save pointer to first digit */
    
    do {
        digval = (val % radix);
        val /= radix;       /* get next digit */
        
        /* convert to ascii and store */
        if (digval > 9)
            *p++ = (TCHAR) (digval - 10 + TEXT('a'));  /* a letter */
        else
            *p++ = (TCHAR) (digval + TEXT('0'));       /* a digit */
    } while (val > 0);
    
    /* We now have the digit of the number in the buffer, but in reverse
    order.  Thus we reverse them now. */
    
    *p-- = TEXT('\0');            /* terminate string; p points to last digit */
    
    do {
        temp = *p;
        *p = *firstdig;
        *firstdig = temp;   /* swap *p and *firstdig */
        --p;
        ++firstdig;         /* advance to next two digits */
    } while (firstdig < p); /* repeat until halfway */
}


//------------------------------------------------------------------------------------
//
//      IconSet/GetRegValueString()
//
//      Versions of Get/SetRegValueString that go to the user classes section.
//
//      Returns: success of string setting / retrieval
//
//------------------------------------------------------------------------------------
BOOL IconSetRegValueString(const CLSID* pclsid, LPCTSTR lpszSubKey, LPCTSTR lpszValName, LPCTSTR lpszValue)
{
    HKEY hkey;
    if (SUCCEEDED(SHRegGetCLSIDKey(*pclsid, lpszSubKey, TRUE, TRUE, &hkey)))
    {
        DWORD dwRet = SHRegSetPath(hkey, NULL, lpszValName, lpszValue, 0);
        RegCloseKey(hkey);
        return (dwRet == ERROR_SUCCESS);
    }

    return FALSE;
}

BOOL IconGetRegValueString(const CLSID* pclsid, LPCTSTR lpszSubKey, LPCTSTR lpszValName, LPTSTR lpszValue, int cchValue)
{
    HKEY hkey;
    if (SUCCEEDED(SHRegGetCLSIDKey(*pclsid, lpszSubKey, TRUE, FALSE, &hkey)) ||
        SUCCEEDED(SHRegGetCLSIDKey(*pclsid, lpszSubKey, FALSE, FALSE, &hkey)))
    {
        BOOL fRet = _GetRegValueString(hkey, lpszValName, lpszValue, cchValue);
        RegCloseKey(hkey);
        return fRet;
    }
    return FALSE;
}


//------------------------------------------------------------------------------------
//
//      GetRegValueString()
//
//      Just a little helper routine, gets an individual string value from the
//      registry and returns it to the caller. Takes care of registry headaches,
//      including a paranoid length check before getting the string.
//
//      Returns: success of string retrieval
//
//------------------------------------------------------------------------------------

BOOL GetRegValueString( HKEY hMainKey, LPCTSTR lpszSubKey, LPCTSTR lpszValName, LPTSTR lpszValue, int cchValue )
{
    HKEY hKey;                   // cur open key
    LONG lRet = RegOpenKeyEx( hMainKey, lpszSubKey, (DWORD)0, KEY_QUERY_VALUE, (PHKEY)&hKey );
    if( lRet == ERROR_SUCCESS )
    {
        BOOL fRet = _GetRegValueString(hKey, lpszValName, lpszValue, cchValue);

        // close subkey
        RegCloseKey( hKey );
        return fRet;
    }

    return FALSE;
}

BOOL _GetRegValueString( HKEY hKey, LPCTSTR lpszValName, LPTSTR lpszValue, int cchValue )
{
    // now do our paranoid check of data size
    DWORD dwType;
    DWORD dwSize = cchValue * sizeof(*lpszValue);
    LONG lRet = RegQueryValueEx( hKey, lpszValName, NULL, &dwType, (LPBYTE)lpszValue, &dwSize );

    return ( ERROR_SUCCESS == lRet );
}

//------------------------------------------------------------------------------------
//
//      GetRegValueInt()
//
//      Just a little helper routine, gets an individual string value from the
//      registry and returns it to the caller as an int. Takes care of registry headaches,
//      including a paranoid length check before getting the string.
//
//      Returns: success of string retrieval
//
//------------------------------------------------------------------------------------
BOOL GetRegValueInt( HKEY hMainKey, LPCTSTR lpszSubKey, LPCTSTR lpszValName, int* piValue )
{
    TCHAR szValue[16];
    *szValue = NULL;
    BOOL bOK = GetRegValueString( hMainKey, lpszSubKey, lpszValName, szValue, 16 );
    *piValue = AtoI( szValue );

    return bOK;
}

//------------------------------------------------------------------------------------
//
//      SetRegValueString()
//
//      Just a little helper routine that takes string and writes it to the     registry.
//
//      Returns: success writing to Registry, should be always TRUE.
//
//------------------------------------------------------------------------------------
BOOL SetRegValueString( HKEY hMainKey, LPCTSTR lpszSubKey, LPCTSTR lpszValName, LPCTSTR lpszValue )
{
    HKEY hKey;                       // cur open key
    BOOL bOK = TRUE;
    
    // open this subkey
    LONG lRet = RegOpenKeyEx( hMainKey, lpszSubKey, 0, KEY_SET_VALUE, &hKey );
    
    // check that you got a good key here
    if( lRet != ERROR_SUCCESS )
    {
        DWORD dwDisposition;
        
        // **********************************************************************************
        // based on the sketchy documentation we have for this Reg* and Error stuff, we're
        // guessing that you've ended up here because this totally standard, Windows-defined
        // subkey name just doesn't happen to be defined for the current user.
        // **********************************************************************************
        
        // SO: Just create this subkey for this user, and maybe it will get used after you create and set it.
        // still successful so long as can create new subkey to write to
        
        lRet = RegCreateKeyEx( hMainKey, lpszSubKey, 0, NULL, REG_OPTION_NON_VOLATILE,
            KEY_SET_VALUE, NULL, &hKey, &dwDisposition );
        if( lRet != ERROR_SUCCESS )
        {
            bOK = FALSE;
        }
    }
    lRet = SHRegSetPath( hKey, NULL, lpszValName, lpszValue, 0);
    bOK = bOK && (lRet == ERROR_SUCCESS);
    RegCloseKey( hKey );
    return (bOK);
}

//------------------------------------------------------------------------------------
//
//      SetRegValueInt()
//
//      Just a little helper routine that takes an int and writes it as a string to the
//      registry.
//
//      Returns: success writing to Registry, should be always TRUE.
//
//------------------------------------------------------------------------------------
BOOL SetRegValueInt( HKEY hMainKey, LPCTSTR lpszSubKey, LPCTSTR lpszValName, int iValue )
{
    TCHAR lpszValue[16];

    ItoA( iValue, lpszValue, 10 );
    return SetRegValueString( hMainKey, lpszSubKey, lpszValName, lpszValue );
}


//------------------------------------------------------------------------------------
//
//      SetRegValueDword()
//
//      Just a little helper routine that takes an dword and writes it to the
//      supplied location.
//
//      Returns: success writing to Registry, should be always TRUE.
//
//------------------------------------------------------------------------------------
BOOL SetRegValueDword( HKEY hk, LPCTSTR pSubKey, LPCTSTR pValue, DWORD dwVal )
{
    HKEY hkey = NULL;
    BOOL bRet = FALSE;

    if (ERROR_SUCCESS == RegOpenKey( hk, pSubKey, &hkey ))
    {
        if (ERROR_SUCCESS == RegSetValueEx(hkey, pValue, 0, REG_DWORD, (LPBYTE)&dwVal, sizeof(DWORD)))
        {
            bRet = TRUE;
        }
    }


    if (hkey)
    {
        RegCloseKey( hkey );
    }

    return bRet;
}


//------------------------------------------------------------------------------------
//
//      GetRegValueDword()
//
//      Just a little helper routine that takes an dword and writes it to the
//      supplied location.
//
//      Returns: success writing to Registry, should be always TRUE.
//
//------------------------------------------------------------------------------------
DWORD GetRegValueDword( HKEY hk, LPCTSTR pSubKey, LPCTSTR pValue )
{
    HKEY hkey = NULL;
    DWORD dwVal = REG_BAD_DWORD;

    if (ERROR_SUCCESS == RegOpenKey( hk, pSubKey, &hkey ))
    {
        DWORD dwType, dwSize = sizeof(DWORD);

        RegQueryValueEx( hkey, pValue, NULL, &dwType, (LPBYTE)&dwVal, &dwSize );
    }


    if (hkey)
    {
        RegCloseKey( hkey );
    }

    return dwVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\plus\old_src\plustab.h ===
//--------------------------------------------------------------------------------
//
//	File:	PLUSTAB.H
//
//	Definitions, classes, and prototypes for a DLL that
//	provides CPropSheetExt objects to any other object user.
//
//--------------------------------------------------------------------------------

#ifndef _PLUSTAB_H_
#define _PLUSTAb_H_

//Get the object definitions
#include <WINDOWS.H>
#include <WINDOWSX.H>


#endif //_PLUSTAB_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\plus\old_src\clssfact.h ===
//--------------------------------------------------------------------------------
//
//      File:   CLSSFACT.H
//
//      Defines the CClassFactory object.
//
//--------------------------------------------------------------------------------

#ifndef _CLSSFACT_H_
#define _CLSSFACT_H_

void FAR PASCAL ObjectDestroyed();

//This class factory object creates CPropSheetExt objects.
class CClassFactory : public IClassFactory
{
protected:
        ULONG   m_cRef;

public:
        CClassFactory();
        ~CClassFactory();

        //IUnknown members
        STDMETHODIMP             QueryInterface( REFIID, LPVOID* );
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();

        //IClassFactory members
        STDMETHODIMP            CreateInstance( LPUNKNOWN, REFIID, LPVOID* );
        STDMETHODIMP            LockServer( BOOL );
};

#endif //_CLSSFACT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\plus\old_src\pickicon.h ===
//---------------------------------------------------------------------------
//
//	File: PICKICON.H
//
//	Support code for the Change Icon dialog.
//
//---------------------------------------------------------------------------

#ifndef _PICKICON_H_
#define _PICKICON_H_

int WINAPI PickIconDlg(HWND hwnd, LPSTR pszIconPath, UINT cbIconPath, int FAR *piIconIndex);


#endif //_PICKICON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\plus\old_src\clssfact.cpp ===
//---------------------------------------------------------------------------
//
//      File: CLSSFACT.CPP
//
//      Implements a class factory object that creates CPropSheetExt objects.
//
//---------------------------------------------------------------------------

#include "precomp.hxx"
#pragma hdrstop


extern ULONG g_cObj;    // See PLUSTAB.CPP
extern ULONG g_cLock;   // See PLUSTAB.CPP


//---------------------------------------------------------------------------
//      ObjectDestroyed()
//
//      Function for the CPropSheetExt object to call when it is destroyed.
//      Because we're in a DLL, we only track the number of objects here,
//      letting DllCanUnloadNow take care of the rest.
//---------------------------------------------------------------------------
void FAR PASCAL ObjectDestroyed( void )
{
    g_cObj--;
    return;
}


//---------------------------------------------------------------------------
//      Class Member functions
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//      Constructor
//---------------------------------------------------------------------------
CClassFactory::CClassFactory()
{
    m_cRef = 0L;
    return;
}

//---------------------------------------------------------------------------
//      Destructor
//---------------------------------------------------------------------------
CClassFactory::~CClassFactory( void )
{
    return;
}

//---------------------------------------------------------------------------
//      QueryInterface()
//---------------------------------------------------------------------------
STDMETHODIMP CClassFactory::QueryInterface( REFIID riid, LPVOID* ppv )
{
    *ppv = NULL;

    //Any interface on this object is the object pointer.
    if( IsEqualIID( riid, IID_IUnknown ) ||
        IsEqualIID( riid, IID_IClassFactory )
       )
    {
        *ppv = (LPVOID)this;
        ++m_cRef;
        return NOERROR;
    }

    return E_NOINTERFACE;
}

//---------------------------------------------------------------------------
//      AddRef()
//---------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return ++m_cRef;
}

//---------------------------------------------------------------------------
//      Release()
//---------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    ULONG cRefT;

    cRefT = --m_cRef;

    if( 0L == m_cRef )
            delete this;

    return cRefT;
}

//---------------------------------------------------------------------------
//      CreateInstance()
//---------------------------------------------------------------------------
STDMETHODIMP
CClassFactory::CreateInstance( LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR *ppvObj
                              )
{
    CPropSheetExt*  pObj;
    HRESULT         hr = E_OUTOFMEMORY;

    *ppvObj = NULL;

    // We don't support aggregation at all.
    if( pUnkOuter )
    {
        return CLASS_E_NOAGGREGATION;
    }

    //Verify that a controlling unknown asks for IShellPropSheetExt
    if( IsEqualIID( riid, IID_IShellPropSheetExt ) )
    {
        //Create the object, passing function to notify on destruction
        pObj = new CPropSheetExt( pUnkOuter, ObjectDestroyed );

        if( NULL == pObj )
        {
            return hr;
        }

        hr = pObj->QueryInterface( riid, ppvObj );

        //Kill the object if initial creation or FInit failed.
        if( FAILED(hr) )
        {
            delete pObj;
        }
        else
        {
            g_cObj++;
        }
        return hr;
    }

    return E_NOINTERFACE;
}

//---------------------------------------------------------------------------
//      LockServer()
//---------------------------------------------------------------------------
STDMETHODIMP CClassFactory::LockServer( BOOL fLock )
{
    if( fLock )
    {
        g_cLock++;
    }
    else
    {
        g_cLock--;
    }
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\plus\old_src\pickicon.cpp ===
//---------------------------------------------------------------------------
//
//      File: PICKICON.CPP
//
//      Support code for the Change Icon dialog.
//
//---------------------------------------------------------------------------

#include <windows.h>
#include <windowsx.h>
#include "rc.h"
#include "pickicon.h"

#define MAX_ICONS   500             // that is a lot 'o icons

#define ARRAYSIZE(s)                (sizeof(s) / sizeof((s)[0]))

typedef struct
{
        LPSTR pszIconPath;              // input/output
        int cbIconPath;                 // input
        int iIconIndex;             // input/output
        // private state variables
        HWND hDlg;
        BOOL fFirstPass;
        char szPathField[MAX_PATH];
        char szBuffer[MAX_PATH];
} PICKICON_DATA, FAR *LPPICKICON_DATA;

extern HINSTANCE g_hInst;

// Checks if the file exists, if it doesn't it tries tagging on .exe and if that
// fails it reports an error. The given path is environment expanded.  If it needs
// to put up an error box, it changes the cursor back.  Path's assumed to be
// MAXITEMPATHLEN long.  The main reason for moving this out of the DlgProc was
// because we're running out of stack space on the call to the comm dlg.
BOOL NEAR PASCAL IconFileExists( LPPICKICON_DATA lppid )
{
TCHAR szTitle[128];
TCHAR szInvPath[ 64 ];
TCHAR szText[MAX_PATH+40];
TCHAR szPath[MAX_PATH];
LPTSTR psz;
DWORD dwRet;

        if( lppid->szBuffer[0] == 0 )
                return FALSE;

        // Use the Win32 version instead of the shell version.  The shell version
        // is/was really only there for 16-bit apps.  (RickTu)
        //
        // DoEnvironmentSubst( lppid->szBuffer, sizeof(lppid->szBuffer) );
        //

        dwRet = ExpandEnvironmentStrings( lppid->szBuffer, szPath, MAX_PATH );
        if (dwRet > 0 && dwRet <= MAX_PATH)
        {
            lstrcpy( lppid->szBuffer, szPath );
        }

//      PathUnquoteSpaces( lppid->szBuffer );   // JER

//      if( PathResolve( lppid->szBuffer, NULL, PRF_VERIFYEXISTS | PRF_TRYPROGRAMEXTENSIONS ) ) // JER
        if (SearchPath(NULL, lppid->szBuffer, NULL, ARRAYSIZE(szPath), szPath, &psz) != 0)
                return TRUE;

        LoadString( g_hInst, IDS_BADPATHMSG, szTitle, ARRAYSIZE(szTitle) );
        LoadString( g_hInst, IDS_INVALIDPATH, szInvPath, ARRAYSIZE(szInvPath) );
        wsprintf( szText, szTitle, lppid->szBuffer );
        GetWindowText( lppid->hDlg, szTitle, sizeof(szTitle) );
        lstrcat( szTitle, szInvPath );
        MessageBox( GetDesktopWindow(), szText, szTitle , MB_OK | MB_ICONEXCLAMATION );
        return FALSE;
}

void NEAR PASCAL PutIconsInList( LPPICKICON_DATA lppid )
{
HICON  *rgIcons;
int      iTempIcon;
int  cIcons;
HWND hDlg = lppid->hDlg;
//HCURSOR hOldCursor;

        SendDlgItemMessage( hDlg, IDD_ICON, LB_RESETCONTENT, 0, 0L );

        GetDlgItemText( hDlg, IDD_PATH, lppid->szPathField, sizeof(lppid->szPathField) );

        lstrcpy( lppid->szBuffer, lppid->szPathField );

        if( !IconFileExists(lppid) )
        {
                if( lppid->fFirstPass )
                {
                        // Icon File doesn't exist, use progman
                        lppid->fFirstPass = FALSE;  // Only do this bit once.
                        GetModuleFileName( g_hInst, lppid->szBuffer, ARRAYSIZE(lppid->szBuffer) );
                }
                else
                {
                        return;
                }
        }
        lstrcpy( lppid->szPathField, lppid->szBuffer );
        SetDlgItemText( hDlg, IDD_PATH, lppid->szPathField );

//      hOldCursor = SetCursor( LoadCursor( NULL, IDC_WAIT ) );

        rgIcons = (HICON *)LocalAlloc(LPTR, MAX_ICONS*sizeof(HICON));

        if( rgIcons != NULL )
                cIcons = (int)ExtractIconEx( lppid->szBuffer, 0, rgIcons, NULL, MAX_ICONS );
        else
                cIcons = 0;

//      SetCursor( hOldCursor );
    if( !cIcons )
    {
        char szText[256];
        char szTitle[40];

                GetWindowText( lppid->hDlg, szTitle, sizeof(szTitle) );
                if( lppid->fFirstPass )
                {
                        lppid->fFirstPass = FALSE;  // Only do this bit once.
                        LoadString( g_hInst, IDS_NOICONSMSG1, szText, 256 );
                        MessageBox( GetDesktopWindow(), szText, szTitle, MB_OK | MB_ICONEXCLAMATION );

                        // No icons here - change the path do somewhere where we
                        // know there are icons. Get the path to progman.
//                      GetModuleFileName( g_hInst, lppid->szPathField, sizeof(lppid->szPathField) );
                        GetSystemDirectory( lppid->szPathField, sizeof(lppid->szPathField) );
                        lstrcat( lppid->szPathField, "\\shell32.dll" );
                        SetDlgItemText( hDlg, IDD_PATH, lppid->szPathField );
                        PutIconsInList( lppid );
                }
                else
                {
                        LoadString( g_hInst, IDS_NOICONSMSG, szText, 256 );
                        MessageBox( GetDesktopWindow(), szText, szTitle, MB_OK | MB_ICONEXCLAMATION );
                        return;
                }
        }
//      hOldCursor = SetCursor( LoadCursor( NULL, IDC_WAIT ) );

        SendDlgItemMessage( hDlg, IDD_ICON, WM_SETREDRAW, FALSE, 0L );

    if( rgIcons )
    {
                for( iTempIcon = 0; iTempIcon < cIcons; iTempIcon++ )
                {
                        SendDlgItemMessage( hDlg, IDD_ICON, LB_ADDSTRING, 0, (LPARAM)(UINT)rgIcons[iTempIcon] );
                }
                LocalFree((HLOCAL)rgIcons);
        }

        if( SendDlgItemMessage( hDlg, IDD_ICON, LB_SETCURSEL, lppid->iIconIndex, 0L ) == LB_ERR )
        {
                // select the first.
                SendDlgItemMessage( hDlg, IDD_ICON, LB_SETCURSEL, 0, 0L );
        }

        SendDlgItemMessage( hDlg, IDD_ICON, WM_SETREDRAW, TRUE, 0L );
        InvalidateRect( GetDlgItem(hDlg, IDD_ICON), NULL, TRUE );

//      SetCursor( hOldCursor );
}

void NEAR PASCAL InitPickIconDlg( HWND hDlg, LPPICKICON_DATA lppid )
{
RECT rc;
UINT cy;
HWND hwndIcons;

        // init state variables
        lppid->hDlg = hDlg;
        lstrcpyn( lppid->szPathField, lppid->pszIconPath, sizeof(lppid->szPathField) );

        // this first pass stuff is so that the first time something bogus happens
        // (file not found, no icons) we give the user a list of icons from progman.
        lppid->fFirstPass = TRUE;

        // init the dialog controls
        SetDlgItemText( hDlg, IDD_PATH, lppid->pszIconPath );
        SendDlgItemMessage( hDlg, IDD_PATH, EM_LIMITTEXT, lppid->cbIconPath, 0L );

        SendDlgItemMessage( hDlg, IDD_ICON, LB_SETCOLUMNWIDTH, GetSystemMetrics(SM_CXICON) + 12, 0L );

        hwndIcons = GetDlgItem( hDlg, IDD_ICON );

        // compute the height of the listbox based on icon dimensions
        GetClientRect( hwndIcons, &rc );

        cy = GetSystemMetrics( SM_CYICON ) + GetSystemMetrics( SM_CYHSCROLL ) + GetSystemMetrics( SM_CYEDGE ) * 3;

        SetWindowPos( hwndIcons, NULL, 0, 0, rc.right, cy, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE );

        // REVIEW, explicitly position this dialog?

        cy = rc.bottom - cy;

        GetWindowRect( hDlg, &rc );
        rc.bottom -= rc.top;
        rc.right -= rc.left;
        rc.bottom = rc.bottom - cy;

        SetWindowPos( hDlg, NULL, 0, 0, rc.right, rc.bottom, SWP_NOMOVE | SWP_NOACTIVATE );

        PutIconsInList( lppid );
}

// call the common browse code for this
BOOL NEAR PASCAL BrowseForIconFile( LPPICKICON_DATA lppid )
{
OPENFILENAME  ofn;
CHAR szFilter[256] = TEXT("Icon Files\0*.ico;*.exe;*.dll\0Programs (*.exe)\0*.exe\0Libraries (*.dll)\0*.dll\0Icons (*.ico)\0*.ico\0All Files (*.*)\0*.*\0\0");
char szTitle[40];

        ZeroMemory(&ofn, sizeof(ofn));

        if (LoadString( g_hInst, IDS_ICONFILTER, szFilter, ARRAYSIZE(szFilter) ) != 0) {
            LPTSTR psz;

            for( psz = szFilter; *psz != TEXT('\0'); psz++ ) {
#ifdef DBCS
                if ( IsDBCSLeadByte(*psz) ) {
                    psz = CharNext(psz) - 1;
                    continue;
                }
#endif

                if (*psz == TEXT('\1')) {
                    *psz = TEXT('\0');
                }
            }
        }



        GetWindowText( lppid->hDlg, szTitle, sizeof(szTitle) );
        GetDlgItemText( lppid->hDlg, IDD_PATH, lppid->szBuffer, sizeof(lppid->szBuffer) );

        ofn.lStructSize                 = sizeof(OPENFILENAME);
        ofn.hwndOwner                   = lppid->hDlg;
        ofn.lpstrFilter                 = szFilter;
//      ofn.lpstrCustomFilter   = (LPSTR)NULL;
//      ofn.nMaxCustFilter              = 0L;
        ofn.nFilterIndex                = 1L;
        ofn.lpstrFile                   = lppid->szBuffer;
        ofn.nMaxFile                    = sizeof(lppid->szBuffer);
//      ofn.lpstrFileTitle              = (LPSTR)NULL;
//      ofn.lpstrInitialDir             = NULL;
        ofn.lpstrTitle                  = szTitle;
        ofn.Flags                               = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_NOCHANGEDIR | OFN_PATHMUSTEXIST;
//      ofn.nFileOffset                 = 0;
//      ofn.nFileExtension              = 0;
//      ofn.lCustData                   = 0;

        if( GetOpenFileName( &ofn ) )
        {
//              PathQuoteSpaces( lppid->szBuffer );     // JER
                SetDlgItemText( lppid->hDlg, IDD_PATH, lppid->szBuffer );
                // Set default button to OK.
                SendMessage( lppid->hDlg, DM_SETDEFID, IDOK, 0 );
                return TRUE;
        }
        else
                return FALSE;
}

// test if the name field is different from the last file we looked at
BOOL NEAR PASCAL NameChange( LPPICKICON_DATA lppid )
{
        GetDlgItemText( lppid->hDlg, IDD_PATH, lppid->szBuffer, sizeof(lppid->szBuffer) );
        return lstrcmpi(lppid->szBuffer, lppid->szPathField);
}


//
// dialog procedure for picking an icon (ala progman change icon)
// uses DLG_PICKICON template
//
// in:
//      pszIconFile
//      cbIconFile
//      iIndex
//
// out:
//      pszIconFile
//      iIndex
//
INT_PTR CALLBACK PickIconDlgProc( HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam )
{
LPPICKICON_DATA lppid = (LPPICKICON_DATA)GetWindowLong(hDlg, DWL_USER);

// Array for context help:
/*static DWORD aPickIconHelpIDs[] = {           // JER
        IDD_PATH,   IDH_FCAB_LINK_ICONNAME,
        IDD_ICON,   IDH_FCAB_LINK_CURRENT_ICON,
        IDD_BROWSE, IDH_BROWSE,
        0, 0
        };
*/
        switch( wMsg )
        {
                case WM_INITDIALOG:
                        SetWindowLong( hDlg, DWL_USER, lParam );
                        InitPickIconDlg( hDlg, (LPPICKICON_DATA)lParam );
                        break;

                case WM_COMMAND:
                        switch( GET_WM_COMMAND_ID(wParam, lParam) )
                        {
                                case IDHELP:        // not wired
                                        break;

                                case IDD_BROWSE:
                                        if( BrowseForIconFile( lppid ) )
                                                PutIconsInList( lppid );
                                        break;

                                case IDD_PATH:
                                        if( NameChange( lppid ) )
                                                SendDlgItemMessage( hDlg, IDD_ICON, LB_SETCURSEL, (WPARAM)-1, 0 );
                                        break;

                                case IDD_ICON:
                                        if( NameChange( lppid ) )
                                        {
                                                PutIconsInList( lppid );
                                                break;
                                        }
                                        if( GET_WM_COMMAND_CMD(wParam, lParam) != LBN_DBLCLK )
                                                break;

                                        /*** FALL THRU on double click ***/

                                case IDOK:
                                        if( NameChange( lppid ) )
                                        {
                                                PutIconsInList( lppid );
                                        }
                                        else
                                        {
                                        int iIconIndex = (int)SendDlgItemMessage( hDlg, IDD_ICON, LB_GETCURSEL, 0, 0L );
                                                if( iIconIndex < 0 )
                                                        iIconIndex = 0;
                                                lppid->iIconIndex = iIconIndex;
                                                lstrcpy( lppid->pszIconPath, lppid->szPathField );

                                                EndDialog( hDlg, TRUE );
                                        }
                                        break;

                                case IDCANCEL:
                                        EndDialog( hDlg, FALSE );
                                        break;

                                default:
                                        return( FALSE );
                        }
                        break;

                // owner draw messages for icon listbox
                case WM_DRAWITEM:
                        #define lpdi ((DRAWITEMSTRUCT FAR *)lParam)

                        if( lpdi->itemState & ODS_SELECTED )
                                SetBkColor( lpdi->hDC, GetSysColor( COLOR_HIGHLIGHT ) );
                        else
                                SetBkColor( lpdi->hDC, GetSysColor( COLOR_WINDOW ) );

                        /* repaint the selection state */
                        ExtTextOut( lpdi->hDC, 0, 0, ETO_OPAQUE, &lpdi->rcItem, NULL, 0, NULL );

                        /* draw the icon */
                        if( (int)lpdi->itemID >= 0 )
                                DrawIcon(lpdi->hDC, (lpdi->rcItem.left + lpdi->rcItem.right - GetSystemMetrics(SM_CXICON)) / 2,
                                        (lpdi->rcItem.bottom + lpdi->rcItem.top - GetSystemMetrics(SM_CYICON)) / 2, (HICON)lpdi->itemData);

                        // InflateRect(&lpdi->rcItem, -1, -1);

                        /* if it has the focus, draw the focus */
                        if( lpdi->itemState & ODS_FOCUS )
                                DrawFocusRect( lpdi->hDC, &lpdi->rcItem );

                        #undef lpdi
                        break;

                case WM_MEASUREITEM:
                        #define lpmi ((MEASUREITEMSTRUCT FAR *)lParam)

                        lpmi->itemWidth = GetSystemMetrics( SM_CXICON ) + 12;
                        lpmi->itemHeight = GetSystemMetrics( SM_CYICON ) + 4;

                        #undef lpmi
                        break;

                case WM_DELETEITEM:
                        #define lpdi ((DELETEITEMSTRUCT FAR *)lParam)

                        DestroyIcon( (HICON)lpdi->itemData );

                        #undef lpdi
                        break;

                case WM_HELP:
//                      WinHelp( ((LPHELPINFO) lParam)->hItemHandle, NULL, HELP_WM_HELP, (DWORD)(LPSTR) aPickIconHelpIDs ); // JER
                        break;

                case WM_CONTEXTMENU:
//                      WinHelp( (HWND) wParam, NULL, HELP_CONTEXTMENU, (DWORD)(LPVOID)aPickIconHelpIDs ); // JER
                        break;

                default:
                        return FALSE;
        }
        return TRUE;
}


// puts up the pick icon dialog
int WINAPI PickIconDlg( HWND hwnd, LPSTR pszIconPath, UINT cbIconPath, int FAR *piIconIndex )
{
PICKICON_DATA *pid;
int iResult;

        // if we are coming up from a 16->32 thunk.  it is possible that SHELL32 will
        // not be loaded in this context, so we will load ourself if we are not loaded.
//      IsDllLoaded( g_hInst, "SHELL32" );      // JER

        pid = (PICKICON_DATA *)LocalAlloc( LPTR, sizeof(PICKICON_DATA) );

        if( pid == NULL )
                return 0;

        pid->pszIconPath = pszIconPath;
        pid->cbIconPath = cbIconPath;
        pid->iIconIndex = *piIconIndex;

        iResult = DialogBoxParam( g_hInst, MAKEINTRESOURCE(DLG_PICKICON), hwnd, PickIconDlgProc, (LPARAM)(LPPICKICON_DATA)pid );

        *piIconIndex = pid->iIconIndex;

        LocalFree( pid );

        return iResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\plus\old_src\plustab.cpp ===
//--------------------------------------------------------------------------------
//
//      File:   EFFECTS.CPP
//
//      Implements the interfaces to the DLL.
//
//--------------------------------------------------------------------------------

#include "precomp.hxx"
#pragma hdrstop

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

//
// Count number of objects and number of locks.
//
ULONG       g_cObj = 0;
ULONG       g_cLock = 0;
HINSTANCE   g_hInst = NULL;
BOOL        g_RunningOnNT = FALSE;

// OLE-Registry magic number
static const GUID CLSID_PlusPackCplExt = { 0x41e300e0, 0x78b6, 0x11ce,
                                           { 0x84, 0x9b, 0x44, 0x45,
                                             0x53, 0x54, 0x00, 0x00
                                           }
                                         };

super_invalid;

//---------------------------------------------------------------------------
// DllMain()
//---------------------------------------------------------------------------
int APIENTRY DllMain( HINSTANCE hInstance, DWORD dwReason, LPVOID )
{
    if( dwReason == DLL_PROCESS_ATTACH )        // Initializing
    {
        OSVERSIONINFO os;

        os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if (GetVersionEx( &os ))
        {
            if (os.dwPlatformId == VER_PLATFORM_WIN32_NT)
            {
                g_RunningOnNT = TRUE;
            }
        }

        g_hInst = hInstance;



        DisableThreadLibraryCalls(hInstance);
    }

    return 1;
}
//---------------------------------------------------------------------------
//      DllGetClassObject()
//
//      If someone calls with our CLSID, create an IClassFactory and pass it to
//      them, so they can create and use one of our CPropSheetExt objects.
//
//---------------------------------------------------------------------------
STDAPI DllGetClassObject( REFCLSID rclsid, REFIID riid, LPVOID* ppvOut )
{
    *ppvOut = NULL; // Assume Failure
    if( IsEqualCLSID( rclsid, CLSID_PlusPackCplExt ) )
    {
        //
        //Check that we can provide the interface
        //
        if( IsEqualIID( riid, IID_IUnknown) ||
            IsEqualIID( riid, IID_IClassFactory )
           )
        {
            //Return our IClassFactory for CPropSheetExt objects
            *ppvOut = (LPVOID* )new CClassFactory();
            if( NULL != *ppvOut )
            {
                //AddRef the object through any interface we return
                ((CClassFactory*)*ppvOut)->AddRef();
                return NOERROR;
            }
            return E_OUTOFMEMORY;
        }
        return E_NOINTERFACE;
    }
    else
    {
        return CLASS_E_CLASSNOTAVAILABLE;
    }
}

//---------------------------------------------------------------------------
//      DllCanUnloadNow()
//
//      If we are not locked, and no objects are active, then we can exit.
//
//---------------------------------------------------------------------------
STDAPI DllCanUnloadNow()
{
    SCODE   sc;

    //
    //Our answer is whether there are any object or locks
    //
    sc = (0L == g_cObj && 0 == g_cLock) ? S_OK : S_FALSE;

    return ResultFromScode(sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\plus\old_src\propsext.h ===
//---------------------------------------------------------------------------
//
//      File: PROPSEXT.CPP
//
//      Defines the CPropSheetExt object.
//
//---------------------------------------------------------------------------

#ifndef _PROPSEXT_H_
#define _PROPSEXT_H_

#include <windows.h>

#include <prsht.h>
#include <shlobj.h>


extern BOOL g_RunningOnNT;

//Type for an object-destroyed callback
typedef void (FAR PASCAL *LPFNDESTROYED)(void);


class CPropSheetExt : public IShellPropSheetExt
{
private:
        ULONG           m_cRef;
        LPUNKNOWN       m_pUnkOuter;    //Controlling unknown
        LPFNDESTROYED   m_pfnDestroy;   //Function closure call

public:
        CPropSheetExt( LPUNKNOWN pUnkOuter, LPFNDESTROYED pfnDestroy );
        ~CPropSheetExt(void);

        // IUnknown members
        STDMETHODIMP             QueryInterface(REFIID, LPVOID*);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

    // *** IShellPropSheetExt methods ***
    STDMETHODIMP                AddPages( LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam );
    STDMETHODIMP                ReplacePage( UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam );
};

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))
#endif

#endif //_PROPSEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\plus\old_src\regutils.h ===
//-----------------------------------------------------------------------
//
//      File: REGUTILS.H
//
//-----------------------------------------------------------------------

#ifndef _REGUTILS_H_
#define _REGUTILS_H_

BOOL GetRegValueString( HKEY hMainKey, LPSTR lpszSubKey, LPSTR lpszValName, LPSTR lpszValue, int iMaxSize );
BOOL GetRegValueInt( HKEY hMainKey, LPSTR lpszSubKey, LPSTR lpszValName, int* piValue );
BOOL SetRegValueString( HKEY hMainKey, LPSTR lpszSubKey, LPSTR lpszValName, LPSTR lpszValue );
BOOL SetRegValueInt( HKEY hMainKey, LPSTR lpszSubKey, LPSTR lpszValName, int iValue );
BOOL SetRegValueDword( HKEY hk, LPTSTR pSubKey, LPTSTR pValue, DWORD dwVal );
DWORD GetRegValueDword( HKEY hk, LPTSTR pSubKey, LPTSTR pValue );
#define REG_BAD_DWORD 0xF0F0F0F0

BOOL IconSetRegValueString(LPSTR lpszSubKey, LPSTR lpszValName, LPSTR lpszValue );
BOOL IconGetRegValueString(LPSTR lpszSubKey, LPSTR lpszValName, LPSTR lpszValue, int iMaxSize );

#endif //_REGUTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\plus\old_src\rc.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by effects.rc
//
#define IDS_HELPFILE                    1
#define IDS_NOICONSMSG1                 2
#define IDS_NOICONSMSG                  3
#define IDS_BADPATHMSG                  4
#define IDS_REBOOTFORCHANGE             5
#define IDS_FONTSMOOTHWONTWORK          6
#define IDS_ICONCOLORWONTWORK           7
#define IDS_FULL                        8
#define IDS_EMPTY                       9
#define IDS_MYCOMPUTER                  10
#define IDS_NETNEIGHBOUR                11
#define IDS_TRASHFULL                   12
#define IDS_TRASHEMPTY                  13
#define IDS_TRASHDEFAULT                14
#define IDS_USE_LARGE                   16
#define IDS_256COLORPROBLEM             18
#define IDS_ICONFILTER                  19
#define IDS_INVALIDPATH                 20
#define IDS_ICONS                       21
#define IDS_HELPFILE_PLUS               22
#define IDS_MYDOCUMENTS                 23
#define IDS_INTERNET                    24
#define IDS_DIRECTORY                   25
#define PLUSPACK_DLG                    101
#define IDI_WINDRAGICON                 101
#define IDI_FONTSMOOTHICON              102
#define IDI_HIGHCOLORICON               103
#define IDI_WALLPAPERFITICON            104
#define IDI_USELARGEICONS               107
#define IDC_FULLWINDOWDRAGGING          1000
#define IDC_FONTSMOOTHING               1001
#define IDC_ICONHIGHCOLOR               1002
#define IDC_STRETCHWALLPAPERFITSCREEN   1003
#define IDC_HIDEICONS                   1003
#define IDC_CHANGEICON                  1004
#define IDC_ICONS                       1005
#define IDD_PATH                        1006
#define IDC_MENUANIMATION               1006
#define IDD_ICON                        1007
#define IDC_FONTSMOOTH                  1007
#define IDD_BROWSE                      1008
#define IDC_SHOWDRAG                    1008
#define IDC_ICONDEFAULT                 1009
#define IDC_LARGEICONS                  1010
#define IDC_GRPBOX_1                    2000
#define IDC_GRPBOX_2                    2001
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        108
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1012
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\plus\old_src\propsext.cpp ===
//---------------------------------------------------------------------------
//
//  File: PROPSEXT.CPP
//
//  Implementation of the CPropSheetExt object.
//
//---------------------------------------------------------------------------

#include "precomp.hxx"
#pragma hdrstop


//Defines for getting registry settings
const TCHAR c_szHICKey[] = TEXT("Control Panel\\Desktop\\WindowMetrics"); // show icons using highest possible colors
const TCHAR c_szHICVal[] = TEXT("Shell Icon BPP"); // (4 if the checkbox is false, otherwise 16, don't set it to anything else)
const TCHAR c_szHIKey[]  = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced");
const TCHAR c_szHIVal[]  = TEXT("HideIcons");
const TCHAR c_szWMSISVal[] = TEXT("Shell Icon Size"); // Normal Icon Size (default 32 x 32)
const TCHAR c_szTitle[]  = TEXT("Effects");
#ifdef INET_EXP_ICON
const TCHAR c_szIEXP[]   = TEXT("\\Program Files\\Microsoft Internet Explorer 4");
#endif

#define HSUBKEY_HIC     (LPTSTR)c_szHICKey
#define HVALUE_HIC      (LPTSTR)c_szHICVal

#define HSUBKEY_WM      (LPTSTR)c_szHICKey
#define HVALUE_WMSIS    (LPTSTR)c_szWMSISVal

#define ICON_DEFAULT_SMALL    16
#define ICON_DEFAULT_NORMAL   32
#define ICON_DEFAULT_LARGE    48

enum ICON_SIZE_TYPES {
   ICON_DEFAULT         = 0,
   ICON_LARGE           = 1,
   ICON_INDETERMINATE   = 2
};

// Registry Info for the icons
typedef struct tagIconRegKeys
{
    TCHAR szIconSubKey[128];
    TCHAR szIconValue[16];
    TCHAR szTitleSubKey[128];
    int  iTitleResource;
    int  iDefaultTitleResource;
    BOOL bNTOnly;
}ICONREGKEYS;

ICONREGKEYS sIconRegKeys[] =
{
     // "My Computer" icon
    { TEXT("CLSID\\{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\DefaultIcon"),
      TEXT("\0"),
      TEXT("CLSID\\{20D04FE0-3AEA-1069-A2D8-08002B30309D}"),
      NULL,
      IDS_MYCOMPUTER,
      FALSE
    },

    // "My Documents" icon
    { TEXT("CLSID\\{450D8FBA-AD25-11D0-98A8-0800361B1103}\\DefaultIcon"),
      TEXT("\0"),
      TEXT("CLSID\\{450D8FBA-AD25-11D0-98A8-0800361B1103}"),
      NULL,
      IDS_MYDOCUMENTS,
      FALSE
     },

// This one doesn't seem to pick up updates, so disable for now...
#ifdef INET_EXP_ICON
    // "Internet Explorer" icon
    { TEXT("CLSID\\{FBF23B42-E3F0-101B-8488-00AA003E56F8}\\DefaultIcon"),
      TEXT("\0"),
      TEXT("CLSID\\{FBF23B42-E3F0-101B-8488-00AA003E56F8}"),
      NULL,
      IDS_INTERNET
     },
#endif

    // "Net Neighbourhood" icon
    { TEXT("CLSID\\{208D2C60-3AEA-1069-A2D7-08002B30309D}\\DefaultIcon"),
      TEXT("\0"),
      TEXT("CLSID\\{208D2C60-3AEA-1069-A2D7-08002B30309D}"),
      NULL,
      IDS_NETNEIGHBOUR
    },

    // "Trash full" icon
    { TEXT("CLSID\\{645FF040-5081-101B-9F08-00AA002F954E}\\DefaultIcon"),
      TEXT("full"),
      TEXT("CLSID\\{645FF040-5081-101B-9F08-00AA002F954E}"),
      IDS_FULL,
      IDS_TRASHFULL
     },

     // "Trash empty" icon
    { TEXT("CLSID\\{645FF040-5081-101B-9F08-00AA002F954E}\\DefaultIcon"),
      TEXT("empty"),
      TEXT("CLSID\\{645FF040-5081-101B-9F08-00AA002F954E}"),
      IDS_EMPTY,
      IDS_TRASHEMPTY
     },

    //
    // This is not a desktop icon, so for now it's not included.
    //

/*
    // "Directory" icon
    { TEXT("CLSID\\{FE1290F0-CFBD-11CF-A330-00AA00C16E65}\\DefaultIcon"),
      TEXT("\0"),
      TEXT("CLSID\\{FE1290F0-CFBD-11CF-A330-00AA00C16E65}"),
      NULL,
      IDS_DIRECTORY
    },
*/


};

#define NUM_ICONS (ARRAYSIZE(sIconRegKeys))

#define PATH_WIN  0
#define PATH_SYS  1
#define PATH_IEXP 2

typedef struct tagDefIcons
{
    int     iIndex;
    UINT    uPath;
    TCHAR   szFile[16];
}DEFICONS;

DEFICONS sDefaultIcons[NUM_ICONS] =
{
    { 0,PATH_WIN ,TEXT("\\EXPLORER.EXE")},  // "My Computer" default icon
    { 0,PATH_SYS ,TEXT("\\mydocs.dll")},    // "My Documents" default icon
#ifdef INET_EXP_ICON
    { 0,PATH_IEXP,TEXT("\\iexplore.exe")},  // "Internet Explorer" default icon
#endif
    {17,PATH_SYS, TEXT("\\shell32.dll")},   // "Net Neighbourhood" default icon
    {32,PATH_SYS, TEXT("\\shell32.dll")},   // "Trash full" default icon
    {31,PATH_SYS, TEXT("\\shell32.dll")},   // "Trash empty" default icon
//    { 0,TEXT("\\dsfolder.dll")},  // "Directory" default icon
};

// Name of the file that holds each icon, and an index for which icon to use in the file
typedef struct tagIconKeys
{
    TCHAR szOldFile[MAX_PATH];
    int   iOldIndex;
    TCHAR szNewFile[MAX_PATH];
    int   iNewIndex;
}ICONDATA;

ICONDATA sIconData[NUM_ICONS];

typedef struct
{
    DWORD dwControlID;
    DWORD dwHelpContextID;
}POPUP_HELP_ARRAY;

POPUP_HELP_ARRAY phaMainWin[] = {
   { (DWORD)IDC_ICONS,                          (DWORD)IDH_DISPLAY_PLUSPACK_LIST         },
   { (DWORD)IDC_CHANGEICON,                     (DWORD)IDH_DISPLAY_PLUSPACK_CHANGEICON   },
   { (DWORD)IDC_LARGEICONS,                     (DWORD)IDH_DISPLAY_PLUSPACK_LARGEICONS   },
   { (DWORD)IDC_ICONHIGHCOLOR,                  (DWORD)IDH_DISPLAY_PLUSPACK_ALLCOLORS    },
   { (DWORD)IDC_ICONDEFAULT,                    (DWORD)IDH_DISPLAY_PLUSPACK_DEFAULT_ICON },
   { (DWORD)IDC_GRPBOX_1,                       (DWORD)IDH_COMM_GROUPBOX                 },
   { (DWORD)IDC_GRPBOX_2,                       (DWORD)IDH_COMM_GROUPBOX                 },
   { (DWORD)0, (DWORD)0 },
   { (DWORD)0, (DWORD)0 },          // double-null terminator NECESSARY!
};

POPUP_HELP_ARRAY phaMainWinPlus[] = {
   { (DWORD)IDC_ICONS,                          (DWORD)IDH_PLUS_PLUSPACK_LIST         },
   { (DWORD)IDC_CHANGEICON,                     (DWORD)IDH_PLUS_PLUSPACK_CHANGEICON   },
   { (DWORD)IDC_LARGEICONS,                     (DWORD)IDH_PLUS_PLUSPACK_LARGEICONS   },
   { (DWORD)IDC_ICONHIGHCOLOR,                  (DWORD)IDH_PLUS_PLUSPACK_ALLCOLORS    },
   { (DWORD)IDC_GRPBOX_1,                       (DWORD)IDH_COMM_GROUPBOX              },
   { (DWORD)IDC_GRPBOX_2,                       (DWORD)IDH_COMM_GROUPBOX              },
   { (DWORD)0, (DWORD)0 },
   { (DWORD)0, (DWORD)0 },          // double-null terminator NECESSARY!
};

POPUP_HELP_ARRAY * g_phaHelp = NULL;


HWND hWndList;          // handle to the list view window
HIMAGELIST hIconList;   // handles to image lists for large icons

// Handle to the DLL
extern HINSTANCE g_hInst;

// vars needed for new shell api
#define SZ_SHELL32                  TEXT("shell32.dll")
#define SZ_SHUPDATERECYCLEBINICON   "SHUpdateRecycleBinIcon"    // Parameter for GetProcAddr()... DO NOT TEXT("") IT!

HINSTANCE hmodShell32 = NULL;
typedef void (* PFNSHUPDATERECYCLEBINICON)( void );
PFNSHUPDATERECYCLEBINICON pfnSHUpdateRecycleBinIcon = NULL;

// Function prototype
INT_PTR CALLBACK PlusPackDlgProc( HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam );
HWND CreateListView( HWND hWndParent );

// Icon Stuff
int   GetIconState (void);
BOOL  ChangeIconSizes (HWND hDlg, int iOldState, int iNewState);

HRESULT ExtractPlusColorIcon(LPCTSTR szPath, int nIndex, HICON *phIcon, UINT uSizeLarge, UINT uSizeSmall);
BOOL  gfCoInitDone = FALSE;         // track state of OLE CoInitialize()


//---------------------------------------------------------------------------
//  Class Member functions
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//  Constructor
//---------------------------------------------------------------------------
CPropSheetExt::CPropSheetExt( LPUNKNOWN pUnkOuter, LPFNDESTROYED pfnDestroy )
{
    m_cRef = 0;
    m_pUnkOuter = pUnkOuter;
    m_pfnDestroy = pfnDestroy;
    return;
}

//---------------------------------------------------------------------------
//  Destructor
//---------------------------------------------------------------------------
CPropSheetExt::~CPropSheetExt( void )
{
    return;
}

//---------------------------------------------------------------------------
//  QueryInterface()
//---------------------------------------------------------------------------
STDMETHODIMP CPropSheetExt::QueryInterface( REFIID riid, LPVOID* ppv )
{
    *ppv = NULL;

    if( IsEqualIID( riid, IID_IShellPropSheetExt ) )
    {
        *ppv = (LPVOID)this;
        ++m_cRef;
        return NOERROR;
    }
    return ResultFromScode(E_NOINTERFACE);
}

//---------------------------------------------------------------------------
//  AddRef()
//---------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPropSheetExt::AddRef( void )
{
    return ++m_cRef;
}

//---------------------------------------------------------------------------
//  Release()
//---------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPropSheetExt::Release( void )
{
ULONG cRefT;

    cRefT = --m_cRef;

    if( m_cRef == 0 )
    {
        // Tell the housing that an object is going away so that it
        // can shut down if appropriate.
        if( NULL != m_pfnDestroy )
        {
            (*m_pfnDestroy)();
        }
        delete this;
    }
    return cRefT;
}

//---------------------------------------------------------------------------
//  AddPages()
//---------------------------------------------------------------------------
STDMETHODIMP CPropSheetExt::AddPages( LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam )
{
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hpage;
    TCHAR szTitle[ 30 ];

    LoadString( g_hInst, IDS_ICONS, szTitle, ARRAYSIZE(szTitle) );
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_USETITLE;
    psp.hIcon = NULL;
    psp.hInstance = g_hInst;
    psp.pszTemplate =MAKEINTRESOURCE( PLUSPACK_DLG );
    psp.pfnDlgProc = PlusPackDlgProc;
    psp.pszTitle = szTitle;
    psp.lParam = 0;

    if( ( hpage = CreatePropertySheetPage( &psp ) ) == NULL )
    {
        return ( E_OUTOFMEMORY );
    }

    if( !lpfnAddPage( hpage, lParam ) )
    {
        DestroyPropertySheetPage( hpage );
        return ( E_FAIL );
    }
    return NOERROR;
}

//---------------------------------------------------------------------------
//  ReplacePage()
//---------------------------------------------------------------------------
STDMETHODIMP CPropSheetExt::ReplacePage( UINT uPageID, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam )
{
    return NOERROR;
}


//---------------------------------------------------------------------------
//
// PlusPackDlgProc()
//
//  The dialog procedure for the "PlusPack" property sheet page.
//
//---------------------------------------------------------------------------
INT_PTR CALLBACK PlusPackDlgProc( HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam )
{
    LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE)GetWindowLong( hDlg, DWL_USER );
    static int      iOldLI, iNewLI;         // Large Icon State
    static int      iOldHIC, iNewHIC;       // High Icon Colour
    static BOOL     bOldMA, bNewMA;         // Menu Animation State
    static BOOL     bOldSF, bNewSF;         // Font Smoothing State
    static BOOL     bOldDW, bNewDW;         // Drag Window State
    static BOOL     bOldHI, bNewHI;         // Hide Icons State
    BOOL            bDorked = FALSE, bRet, bDorkedIcons;
    static int      iIndex, iX;
    static char     szHelpFile[32];


    switch( uMessage )
    {
        case WM_INITDIALOG:
        {
            OSVERSIONINFO osvi;
            UINT id = IDS_HELPFILE_PLUS;


            // Create our list view and fill it with the system icons
            CreateListView( hDlg );
            iIndex = 0;

            SetWindowLong( hDlg, DWL_USER, lParam );
            psp = (LPPROPSHEETPAGE)lParam;

            // Get the name of our help file.  For Memphis, it's
            // IDS_HELPFILE_PLUS for NT it's IDS_HELPFILE.
            g_phaHelp = phaMainWinPlus;
            osvi.dwOSVersionInfoSize = sizeof(osvi);
            if (GetVersionEx( &osvi ))
            {
                if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT)
                {
                    id = IDS_HELPFILE;
                    g_phaHelp = phaMainWin;
                }
            }

            LoadString( g_hInst, id, szHelpFile, 32 );


            // Get the values for the settings from the registry and set the checkboxes

            // Large Icons
            iOldLI = GetIconState ();
            if (iOldLI == ICON_INDETERMINATE)
            {
                HWND hItem = GetDlgItem (hDlg, IDC_LARGEICONS);
                SendMessage( hItem,
                             BM_SETSTYLE,
                             (WPARAM)LOWORD(BS_AUTO3STATE),
                             MAKELPARAM( FALSE,0)
                            );
            }
            iNewLI = iOldLI;
            SendMessage( (HWND)GetDlgItem( hDlg, IDC_LARGEICONS ),
                         BM_SETCHECK,
                         (WPARAM)iOldLI,
                         0
                        );

            // Full Color Icons
            bRet = GetRegValueInt( HKEY_CURRENT_USER,
                                   HSUBKEY_HIC,
                                   HVALUE_HIC,
                                   &iOldHIC
                                  );

            if( bRet == FALSE ) // Key not in registry yet
            {
                iOldHIC = iNewHIC = 4;
            }

            iNewHIC = iOldHIC;
            SendMessage( (HWND)GetDlgItem( hDlg, IDC_ICONHIGHCOLOR ),
                         BM_SETCHECK,
                         (WPARAM)(BOOL)(iOldHIC == 16),
                         0
                        );

            // Hide Icons
            bOldHI = (BOOL)GetRegValueDword( HKEY_CURRENT_USER,
                                             (LPTSTR)c_szHIKey,
                                             (LPTSTR)c_szHIVal
                                            );
            if (bOldHI == REG_BAD_DWORD)
            {
                bOldHI = FALSE;
            }
            SendMessage( (HWND)GetDlgItem( hDlg, IDC_HIDEICONS ),
                         BM_SETCHECK,
                         (WPARAM)bOldHI,
                         0
                        );
            bNewHI = bOldHI;


            // Use menu animations
            bOldMA = FALSE;
            SystemParametersInfo( SPI_GETMENUANIMATION, 0, (PVOID)&bOldMA, 0 );
            SendMessage( (HWND)GetDlgItem( hDlg, IDC_MENUANIMATION ),
                         BM_SETCHECK,
                         (WPARAM)bOldMA,
                         0
                        );
            bNewMA = bOldMA;

            // Smooth edges of screen fonts
            bOldSF = FALSE;
            SystemParametersInfo( SPI_GETFONTSMOOTHING, 0, (PVOID)&bOldSF, 0 );
            SendMessage( (HWND)GetDlgItem( hDlg, IDC_FONTSMOOTH ),
                         BM_SETCHECK,
                         (WPARAM)bOldSF,
                         0
                        );
            bNewSF = bOldSF;

            // Show contents while dragging
            bOldDW = FALSE;
            SystemParametersInfo( SPI_GETDRAGFULLWINDOWS, 0, (PVOID)&bOldDW, 0 );
            SendMessage( (HWND)GetDlgItem( hDlg, IDC_SHOWDRAG ),
                         BM_SETCHECK,
                         (WPARAM)bOldDW,
                         0
                        );
            bNewDW = bOldDW;

            // Load SHUpdateRecycleBinIcon() if it exists
            hmodShell32 = LoadLibrary(SZ_SHELL32);
            pfnSHUpdateRecycleBinIcon = (PFNSHUPDATERECYCLEBINICON)GetProcAddress( hmodShell32, SZ_SHUPDATERECYCLEBINICON );
        }
        break;

        case WM_DESTROY:
            if ( gfCoInitDone )
                CoUninitialize();
            if (hmodShell32)
                FreeLibrary(hmodShell32);
            break;

        case WM_COMMAND:
            switch( LOWORD(wParam) )
            {
                case IDC_LARGEICONS:
                    iNewLI = SendMessage ( (HWND)lParam, BM_GETCHECK, 0, 0 );
                    bDorked = TRUE;
                    break;

                case IDC_ICONHIGHCOLOR:
                    iNewHIC = 4;
                    if( SendMessage( (HWND)lParam, BM_GETCHECK, 0, 0 ) == TRUE )
                    {
                        iNewHIC = 16;
                    }
                    bDorked = TRUE;
                    break;

                case IDC_SHOWDRAG:
                    bNewDW = (SendMessage( (HWND)lParam, BM_GETCHECK, 0, 0 ) == BST_CHECKED);
                    bDorked = TRUE;
                    break;

                case IDC_HIDEICONS:
                    bNewHI = (SendMessage( (HWND)lParam, BM_GETCHECK, 0, 0 ) == BST_CHECKED);
                    bDorked = TRUE;
                    break;

                case IDC_MENUANIMATION:
                    bNewMA = (SendMessage( (HWND)lParam, BM_GETCHECK, 0, 0 ) == BST_CHECKED);
                    bDorked = TRUE;
                    break;

                case IDC_FONTSMOOTH:
                    bNewSF = (SendMessage( (HWND)lParam, BM_GETCHECK, 0, 0 ) == BST_CHECKED);
                    bDorked = TRUE;
                    break;

                case IDC_CHANGEICON:
                {
                    INT i = sIconData[iIndex].iOldIndex;
                    WCHAR szTemp[ MAX_PATH ];
                    TCHAR szExp[ MAX_PATH ];

                    ExpandEnvironmentStrings( sIconData[iIndex].szOldFile,
                                              szExp,
                                              ARRAYSIZE(szExp)
                                             );

                    if (g_RunningOnNT)
                    {
                        MultiByteToWideChar( CP_ACP, 0, szExp, -1, szTemp, ARRAYSIZE(szTemp) );
                    }
                    else
                    {
                        lstrcpy( (LPTSTR)szTemp, szExp );
                    }

                    if ( PickIconDlg( hDlg,
                                      (LPTSTR)szTemp,
                                      ARRAYSIZE(szTemp),
                                      &i
                                     ) == TRUE
                        )
                    {
                        HICON hIcon;

                        if (g_RunningOnNT)
                        {
                            WideCharToMultiByte( CP_ACP, 0,
                                                 szTemp, -1,
                                                 sIconData[iIndex].szNewFile,
                                                 ARRAYSIZE(sIconData[iIndex].szNewFile),
                                                 NULL, NULL
                                                );
                        }
                        else
                        {
                            lstrcpy( sIconData[iIndex].szNewFile, (LPTSTR)szTemp );
                        }
                        sIconData[iIndex].iNewIndex = i;
                        ExtractPlusColorIcon( sIconData[iIndex].szNewFile,
                                              sIconData[iIndex].iNewIndex,
                                              &hIcon,
                                              0,
                                              0
                                             );

                        ImageList_ReplaceIcon( hIconList, iIndex, hIcon );
                        ListView_RedrawItems( hWndList, iIndex, iIndex );
                        bDorked = TRUE;
                    }
                }
                    break;

                case IDC_ICONDEFAULT:
                    {
                        TCHAR szTemp[_MAX_PATH];
                        HICON hIcon;

                        switch( sDefaultIcons[iIndex].uPath )
                        {
                            case PATH_WIN:
                                GetWindowsDirectory( szTemp, ARRAYSIZE(szTemp) );
                                break;

#ifdef INET_EXP_ICON
                            case PATH_IEXP:
                                if (g_RunningOnNT)
                                {
                                    lstrcpy( szTemp, TEXT("%SystemDrive%") );
                                }
                                else
                                {
                                    GetWindowsDirectory( szTemp, ARRAYSIZE(szTemp) );

                                    //
                                    // Clear out path after drive, ie: C:
                                    //
                                    szTemp[ 2 ] = 0;
                                }
                                lstrcat( szTemp, c_szIEXP );
                                break;
#endif

                            case PATH_SYS:
                            default:
                                GetSystemDirectory( szTemp, ARRAYSIZE(szTemp) );
                                break;

                        }

                        lstrcat( szTemp,  sDefaultIcons[iIndex].szFile );
                        lstrcpy( sIconData[iIndex].szNewFile, szTemp );
                        sIconData[iIndex].iNewIndex = sDefaultIcons[iIndex].iIndex;

                        ExtractPlusColorIcon( sIconData[iIndex].szNewFile,
                                              sIconData[iIndex].iNewIndex,
                                              &hIcon,
                                              0,
                                              0
                                             );

                        ImageList_ReplaceIcon( hIconList, iIndex, hIcon );
                        ListView_RedrawItems( hWndList, iIndex, iIndex );
                        bDorked = TRUE;
                    }
                    break;
                default:
                    break;
            }

            // If the user dorked with a setting, tell the property manager we
            // have outstanding changes. This will enable the "Apply Now" button...
            if( bDorked )
            {
                SendMessage( GetParent( hDlg ), PSM_CHANGED, (WPARAM)hDlg, 0L );
            }
            break;

        case WM_NOTIFY:
            switch( ((NMHDR *)lParam)->code )
            {
                case LVN_ITEMCHANGED:   // The selection changed in our listview
                    if( wParam == IDC_ICONS )
                    {
                        BOOL bEnable = FALSE;
                        // Find out who's selected now
                        for( iIndex = 0; iIndex < NUM_ICONS;iIndex++ )
                        {
                            if( ListView_GetItemState( hWndList, iIndex, LVIS_SELECTED ) )
                            {
                                bEnable = TRUE;
                                break;
                            }
                        }
                        EnableWindow( GetDlgItem( hDlg, IDC_CHANGEICON ), bEnable );
                        EnableWindow( GetDlgItem( hDlg, IDC_ICONDEFAULT ), bEnable );
                    }
                    break;

                case PSN_APPLY: // OK or Apply clicked
                {
                    HDC hDC = GetDC( NULL );
                    int iBitsPerPixel;

                    iBitsPerPixel = GetDeviceCaps( hDC, BITSPIXEL );
                    ReleaseDC( NULL, hDC );

                    // Large Icons
                    bDorkedIcons = ChangeIconSizes (hDlg, iOldLI, iNewLI);
                    if (bDorkedIcons)
                    {
                        iOldLI = iNewLI;
                        bDorked = TRUE;
                    }

                    // Full Color Icons
                    if( iOldHIC != iNewHIC )
                    {
                        TCHAR szTemp1[512];
                        TCHAR szTemp2[256];

                        bRet = SetRegValueInt( HKEY_CURRENT_USER,
                                               HSUBKEY_HIC,
                                               HVALUE_HIC,
                                               iNewHIC
                                              );
                        iOldHIC = iNewHIC;
                        if ((iBitsPerPixel < 16) && (iNewHIC == 16)) // Display mode won't support icon high colors
                        {
                            LoadString (g_hInst, IDS_256COLORPROBLEM, szTemp1, ARRAYSIZE(szTemp1) );
                            LoadString( g_hInst, IDS_ICONCOLORWONTWORK, szTemp2, ARRAYSIZE(szTemp2) );
                            lstrcat (szTemp1, szTemp2);
                            MessageBox( hDlg, szTemp1, c_szTitle, MB_OK );
                        }
                        else
                        {
                           LoadString( g_hInst, IDS_REBOOTFORCHANGE, szTemp1, ARRAYSIZE(szTemp1) );
                           MessageBox( hDlg, szTemp1, c_szTitle, MB_OK );
                        }
                    }

                    // Full window drag
                    if ( bOldDW != bNewDW )
                    {
                        bOldDW = bNewDW;
                        SystemParametersInfo( SPI_SETDRAGFULLWINDOWS,
                                              bNewDW,
                                              NULL,
                                              SPIF_SENDCHANGE
                                             );
                    }

                    // Font smoothing
                    if ( bOldSF != bNewSF )
                    {
                        bOldSF = bNewSF;
                        SystemParametersInfo( SPI_SETFONTSMOOTHING,
                                              bNewSF,
                                              NULL,
                                              SPIF_SENDCHANGE
                                             );
                    }

                    // Menu animations
                    if ( bOldMA != bNewMA )
                    {
                        bOldMA = bNewMA;
                        SystemParametersInfo( SPI_SETMENUANIMATION,
                                              bNewMA,
                                              NULL,
                                              SPIF_SENDCHANGE
                                             );
                    }

                    // Hide Icons
                    if ( bOldHI != bNewHI )
                    {
                        bOldHI = bNewHI;
                        SetRegValueDword( HKEY_CURRENT_USER,
                                          (LPTSTR)c_szHIKey,
                                          (LPTSTR)c_szHIVal,
                                          (DWORD)bNewHI
                                         );
                    }

                    // Change the system icons
                    for( iX = 0;iX < NUM_ICONS;iX++ )
                    {

                        if( (lstrcmpi( sIconData[iX].szNewFile, sIconData[iX].szOldFile ) != 0) ||
                            (sIconData[iX].iNewIndex != sIconData[iX].iOldIndex)
                           )
                        {
                            TCHAR szTemp[MAX_PATH];

                            wsprintf( szTemp,
                                      TEXT("%s,%d"),
                                      sIconData[iX].szNewFile,
                                      sIconData[iX].iNewIndex
                                     );
                            bRet = IconSetRegValueString( sIconRegKeys[iX].szIconSubKey,
                                                          sIconRegKeys[iX].szIconValue,
                                                          (LPTSTR)szTemp
                                                         );

                            // Next two lines necessary if the user does an Apply as opposed to OK
                            lstrcpy( sIconData[iX].szOldFile, sIconData[iX].szNewFile );
                            sIconData[iX].iOldIndex = sIconData[iX].iNewIndex;
                            bDorked = TRUE;
                        }
                    }

                    // Make the system notice we changed the system icons
                    if( bDorked )
                    {
                        SHChangeNotify( SHCNE_ASSOCCHANGED, 0, NULL, NULL ); // should do the trick!

                        if (pfnSHUpdateRecycleBinIcon != NULL)
                        {
                            pfnSHUpdateRecycleBinIcon();
                        }
                    }

                    if (bDorkedIcons)
                    {
                        SendMessage (HWND_BROADCAST, WM_SETTINGCHANGE, 0, 0);
                    }

                    break;
                }
                default:
                    break;
            }
            break;

        case WM_HELP:
        {
            LPHELPINFO lphi = (LPHELPINFO)lParam;

            if( lphi->iContextType == HELPINFO_WINDOW )
            {
                WinHelp( (HWND)lphi->hItemHandle,
                         (LPTSTR)szHelpFile,
                         HELP_WM_HELP,
                         (DWORD)((POPUP_HELP_ARRAY FAR *)g_phaHelp)
                        );
            }
        }
            break;

        case WM_CONTEXTMENU:
            // first check for dlg window
            if( (HWND)wParam == hDlg )
            {
                // let the def dlg proc decide whether to respond or ignore;
                // necessary for title bar sys menu on right click
                return FALSE;       // didn't process message EXIT
            }
            else
            {
                // else go for the controls
                WinHelp( (HWND)wParam,
                         (LPTSTR)szHelpFile,
                         HELP_CONTEXTMENU,
                         (DWORD)((POPUP_HELP_ARRAY FAR *)g_phaHelp)
                        );
            }
            break;

        default:
            return FALSE;
    }
    return(TRUE);
}


/****************************************************************************
*
*    FUNCTION: CreateListView(HWND)
*
*    PURPOSE:  Creates the list view window and initializes it
*
****************************************************************************/
HWND CreateListView( HWND hWndParent )
{
    LV_ITEM lvI;            // List view item structure
    TCHAR   szTemp[MAX_PATH];
    BOOL bEnable = FALSE;
    RECT rc;

    // Create a device independant size and location
    LONG lWndunits = GetDialogBaseUnits();
    int iWndx = LOWORD(lWndunits);
    int iWndy = HIWORD(lWndunits);
    int iX = ((11 * iWndx) / 4);
    int iY = ((15 * iWndy) / 8);
    int iWidth = ((163 * iWndx) / 4);
    int iHeight = ((40 * iWndy) / 8);

    // Ensure that the common control DLL is loaded.
    InitCommonControls();

    // Get the list view window
    hWndList = GetDlgItem (hWndParent, IDC_ICONS);
    if( hWndList == NULL  )
        return NULL;

    // initialize the list view window
    // First, initialize the image lists we will need
    hIconList = ImageList_Create( 32, 32, ILC_MASK | ILC_COLOR24, NUM_ICONS, 0 );   // create an image list for the icons

    // load the icons and add them to the image lists
    // get the icon files and indexes from the registry, including for the Default recycle bin
    for( iX = 0; iX < NUM_ICONS; iX++ )
    {
        TCHAR* pPos;
        HICON hIcon;
        BOOL bRet;

        bRet = IconGetRegValueString( sIconRegKeys[iX].szIconSubKey,
                                      sIconRegKeys[iX].szIconValue,
                                      (LPSTR)szTemp,
                                      MAX_PATH
                                     );

        int iIndex = PathParseIconLocation( szTemp );

        // store the icon information
        lstrcpy( sIconData[iX].szOldFile, szTemp );
        lstrcpy( sIconData[iX].szNewFile, szTemp );
        sIconData[iX].iOldIndex = iIndex;
        sIconData[iX].iNewIndex = iIndex;

        ExtractPlusColorIcon( szTemp, iIndex, &hIcon, 0, 0);

        // Added this "if" to fix bug 2831.  We want to use SHELL32.DLL
        // icon 0 if there is no icon in the file specified in the
        // registry (or if the registry didn't specify a file).
        if( hIcon == NULL )
        {
            GetSystemDirectory( szTemp, sizeof(szTemp) );
            lstrcat( szTemp,  TEXT("\\shell32.dll") );
            lstrcpy( sIconData[iX].szOldFile, szTemp );
            lstrcpy( sIconData[iX].szNewFile, szTemp );
            sIconData[iX].iOldIndex = sIconData[iX].iNewIndex = 0;

            hIcon = ExtractIcon( g_hInst, szTemp, iIndex );
        }

        if (ImageList_AddIcon( hIconList, hIcon ) == -1)
        {
            return NULL;
        }
    }

    // Make sure that all of the icons were added
    if( ImageList_GetImageCount( hIconList ) < NUM_ICONS )
        return FALSE;

    ListView_SetImageList( hWndList, hIconList, LVSIL_NORMAL );

    // Make sure the listview has WS_HSCROLL set on it.
    DWORD dwStyle = GetWindowLong( hWndList, GWL_STYLE );
    SetWindowLong( hWndList, GWL_STYLE, (dwStyle & (~WS_VSCROLL)) | WS_HSCROLL );

    // Finally, let's add the actual items to the control.  Fill in the LV_ITEM
    // structure for each of the items to add to the list.  The mask specifies
    // the the .pszText, .iImage, and .state members of the LV_ITEM structure are valid.
    lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE;
    lvI.state = 0;
    lvI.stateMask = 0;

    for( iX = 0; iX < NUM_ICONS; iX++ )
    {
        TCHAR szAppend[64];
        BOOL bRet;

        bRet = IconGetRegValueString( sIconRegKeys[iX].szTitleSubKey,
                                      NULL,
                                      (LPTSTR)szTemp,
                                      MAX_PATH
                                     );

        // if the title string was in the registry, else we have to use the default in our resources
        if( (bRet) && (lstrlen(szTemp) > 0) )
        {
            if( LoadString( g_hInst, sIconRegKeys[iX].iTitleResource, szAppend, 64 ) != 0 )
            {
                lstrcat( szTemp, szAppend );
            }
        }
        else
        {
            LoadString( g_hInst,
                        sIconRegKeys[iX].iDefaultTitleResource,
                        szTemp,
                        MAX_PATH
                       );
        }

        lvI.iItem = iX;
        lvI.iSubItem = 0;
        lvI.pszText = (LPSTR)&(szTemp);
        lvI.cchTextMax = lstrlen(szTemp);
        lvI.iImage = iX;

        if( ListView_InsertItem( hWndList, &lvI ) == -1 )
            return NULL;

    }
/*
    // To fix long standing listview bug, we need to "jiggle" the listview
    // window size so that it will do a recompute and realize that we need a
    // scroll bar...
    GetWindowRect( hWndList, &rc );
    MapWindowPoints( NULL, hWndParent, (LPPOINT)&rc, 2 );
    MoveWindow( hWndList, rc.left, rc.top, rc.right - rc.left+1, rc.bottom - rc.top, FALSE );
    MoveWindow( hWndList, rc.left, rc.top, rc.right - rc.left,   rc.bottom - rc.top, FALSE );
*/
    // Set First item to selected
    ListView_SetItemState (hWndList, 0, LVIS_SELECTED, LVIS_SELECTED);

    // Get Selected item
    for(int iIndex = 0;iIndex < NUM_ICONS;iIndex++ )
    {
        if( ListView_GetItemState( hWndList, iIndex, LVIS_SELECTED ) )
        {
            bEnable = TRUE;
            break;
        }
    }

    EnableWindow( GetDlgItem( hWndParent, IDC_CHANGEICON ), bEnable );
    EnableWindow( GetDlgItem( hWndParent, IDC_ICONDEFAULT ), bEnable );

    return (hWndList);
}


int GetIconState (void)
{
    BOOL bRet;
    int iSize;

    bRet = GetRegValueInt (HKEY_CURRENT_USER, HSUBKEY_WM, HVALUE_WMSIS, &iSize);
    if (bRet == FALSE)
        return ICON_DEFAULT;

    if (iSize == ICON_DEFAULT_NORMAL)
        return ICON_DEFAULT;
    else if (iSize == ICON_DEFAULT_LARGE)
        return ICON_LARGE;
    return ICON_INDETERMINATE;
}


BOOL ChangeIconSizes (HWND hDlg, int iOldState, int iNewState)
{
    BOOL bRet;
    int  iOldSize, iNewSize;
    int  iHorz;
    int  iVert;

    // Don't bother if nothing changed
    if (iOldState == iNewState)
        return FALSE;

    // Get New Size
    switch (iNewState)
        {
        case ICON_DEFAULT:
            iNewSize = ICON_DEFAULT_NORMAL;
            break;

        case ICON_LARGE:
            iNewSize = ICON_DEFAULT_LARGE;
            break;

        case ICON_INDETERMINATE:
            // Don't bother to change anything
            return FALSE;

        default:
            return FALSE;
        }

    // Get Original Size
    bRet = GetRegValueInt (HKEY_CURRENT_USER, HSUBKEY_WM, HVALUE_WMSIS, &iOldSize);
    if (!bRet)
    {
        // Try geting system default instead
        iOldSize = GetSystemMetrics (SM_CXICON);
    }


    // Don't need to change size if nothing has really changed
    if (iNewSize == iOldSize)
        return FALSE;

    // Get new horizontal spacing
    iHorz = GetSystemMetrics (SM_CXICONSPACING);
    iHorz -= iOldSize;
    if (iHorz < 0)
    {
        iHorz = 0;
    }
    iHorz += iNewSize;

    // Get new vertical spacing
    iVert = GetSystemMetrics (SM_CYICONSPACING);
    iVert -= iOldSize;
    if (iVert < 0)
    {
        iVert = 0;
    }
    iVert += iNewSize;

        // Set New sizes and spacing
    bRet = SetRegValueInt( HKEY_CURRENT_USER, HSUBKEY_WM, HVALUE_WMSIS, iNewSize );
    if (!bRet)
        return FALSE;

    SystemParametersInfo( SPI_ICONHORIZONTALSPACING, (WPARAM)iHorz, NULL, SPIF_UPDATEINIFILE );
    SystemParametersInfo( SPI_ICONVERTICALSPACING, (WPARAM)iVert, NULL, SPIF_UPDATEINIFILE );

        // Turn from Tri-State back to normal check box
    if (iOldState == ICON_INDETERMINATE)
    {
        HWND hItem = GetDlgItem (hDlg, IDC_LARGEICONS);
        SendMessage( hItem,
                     BM_SETSTYLE,
                     (WPARAM)LOWORD(BS_AUTOCHECKBOX),
                     MAKELPARAM( FALSE,0)
                    );
    }

    // We did change the sizes
    return TRUE;
}


//
//  ExtractPlusColorIcon
//
//  Extract Icon from a file in proper Hi or Lo color for current system display
//
// from FrancisH on 6/22/95 with mods by TimBragg
HRESULT ExtractPlusColorIcon( LPCTSTR szPath, int nIndex, HICON *phIcon,
                              UINT uSizeLarge, UINT uSizeSmall)
{
    IShellLink *psl;
    HRESULT hres;
    HICON hIcons[2];    // MUST! - provide for TWO return icons

    if ( !gfCoInitDone )
    {
        if (SUCCEEDED(CoInitialize(NULL)))
            gfCoInitDone = TRUE;
    }

    *phIcon = NULL;
    if (SUCCEEDED(hres = CoCreateInstance(CLSID_ShellLink, NULL,
        CLSCTX_INPROC_SERVER, IID_IShellLink, (void**)&psl)))
    {
        if (SUCCEEDED(hres = psl->SetIconLocation(szPath, nIndex)))
        {
            IExtractIcon *pei;
            if (SUCCEEDED(hres = psl->QueryInterface(IID_IExtractIcon, (void**)&pei)))
            {
                if (SUCCEEDED(hres = pei->Extract(szPath, nIndex,
                    &hIcons[0], &hIcons[1], (UINT)MAKEWPARAM((WORD)uSizeLarge,
                    (WORD)uSizeSmall))))
                {
                    *phIcon = hIcons[0];    // Return first icon to caller
                }

                pei->Release();
            }
        }

        psl->Release();
    }

    return hres;
}   // end ExtractPlusColorIcon()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\poscpl\debug.h ===
/*
 *  DEBUG.H
 *
 *		Point-of-Sale Control Panel Applet
 *
 *      Author:  Ervin Peretz
 *
 *      (c) 2001 Microsoft Corporation 
 */



#if DBG
    PWCHAR DbgHidStatusStr(DWORD hidStatus);

    #define ASSERT(fact) { if (!(fact)) MessageBox(NULL, L#fact, L"POSCPL assertion failed", MB_OK); }
    #define DBGERR(msg, arg)  { \
                                WCHAR __s[200]={0}; \
                                WCHAR __narg[11]; \
                                WStrNCpy(__s, msg, 100); \
                                WStrNCpy(__s+wcslen(__s), L", ", 3); \
                                IntToWChar(__narg, arg); \
                                WStrNCpy(__s+wcslen(__s), __narg, 100); \
                                WStrNCpy(__s+wcslen(__s), L"=", 2); \
                                HexToWChar(__narg, arg); \
                                WStrNCpy(__s+wcslen(__s), __narg, 100); \
                                WStrNCpy(__s+wcslen(__s), L"h.", 3); \
                                MessageBox(NULL, __s, L"POSCPL error message", MB_OK); \
    }

    #define DBGHIDSTATUSSTR(hidStatus) DbgHidStatusStr(hidStatus)

#else
    #define ASSERT(fact)
    #define DBGERR(msg, arg)
    #define DBGHIDSTATUSSTR(hidStatus)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\plus\old_src\regutils.cpp ===
//------------------------------------------------------------------------------------
//
//      File: REGUTILS.CPP
//
//      Helper functions that handle reading and writing strings to the system registry.
//
//------------------------------------------------------------------------------------

#include "precomp.hxx"
#pragma hdrstop


#define MAX_VALUELEN    16

const TCHAR c_szSoftwareClassesFmt[] = TEXT("Software\\Classes\\%s");

// our own atoi function so we don't have to link to the C runtimes...
INT AtoI( LPTSTR pValue )
{
    INT i = 0;
    INT iSign = 1;

    while( pValue && *pValue )
    {
        if (*pValue == TEXT('-'))
        {
            iSign = -1;
        }
        else
        {
            i = (i*10) + (*pValue - TEXT('0'));
        }
        pValue++;
    }

    return (i * iSign);
}

void ItoA ( INT val, LPTSTR buf, UINT radix )
{
        LPTSTR p;               /* pointer to traverse string */
        LPTSTR firstdig;        /* pointer to first digit */
        TCHAR temp;             /* temp char */
        INT digval;             /* value of digit */

        p = buf;

        if (val < 0) {
            /* negative, so output '-' and negate */
            *p++ = TEXT('-');
            val = -val;
        }

        firstdig = p;           /* save pointer to first digit */

        do {
            digval = (val % radix);
            val /= radix;       /* get next digit */

            /* convert to ascii and store */
            if (digval > 9)
                *p++ = (TCHAR) (digval - 10 + TEXT('a'));  /* a letter */
            else
                *p++ = (TCHAR) (digval + TEXT('0'));       /* a digit */
        } while (val > 0);

        /* We now have the digit of the number in the buffer, but in reverse
           order.  Thus we reverse them now. */

        *p-- = TEXT('\0');            /* terminate string; p points to last digit */

        do {
            temp = *p;
            *p = *firstdig;
            *firstdig = temp;   /* swap *p and *firstdig */
            --p;
            ++firstdig;         /* advance to next two digits */
        } while (firstdig < p); /* repeat until halfway */
}


//------------------------------------------------------------------------------------
//
//      IconSet/GetRegValueString()
//
//      Versions of Get/SetRegValueString that go to the user classes section.
//      This can be overridden by the bClasses flag, which will only write the
//      value to the HKEY_CLASSES_ROOT section.
//
//      Returns: success of string setting / retrieval
//
//------------------------------------------------------------------------------------
BOOL IconSetRegValueString(LPSTR lpszSubKey, LPSTR lpszValName, LPSTR lpszValue ) {
    TCHAR szRegPath[MAX_PATH];

    wsprintf( szRegPath, c_szSoftwareClassesFmt, lpszSubKey );
    return SetRegValueString(HKEY_CURRENT_USER, szRegPath, lpszValName, lpszValue );

}

BOOL IconGetRegValueString(LPSTR lpszSubKey, LPSTR lpszValName, LPSTR lpszValue, int iMaxSize ) {
    TCHAR szRegPath[MAX_PATH];

    wsprintf( szRegPath, c_szSoftwareClassesFmt, lpszSubKey );

    if (!GetRegValueString(HKEY_CURRENT_USER, szRegPath, lpszValName, lpszValue, iMaxSize ))
        return GetRegValueString(HKEY_CLASSES_ROOT, lpszSubKey, lpszValName, lpszValue, iMaxSize );

    return TRUE;
}


//------------------------------------------------------------------------------------
//
//      GetRegValueString()
//
//      Just a little helper routine, gets an individual string value from the
//      registry and returns it to the caller. Takes care of registry headaches,
//      including a paranoid length check before getting the string.
//
//      Returns: success of string retrieval
//
//------------------------------------------------------------------------------------
BOOL GetRegValueString( HKEY hMainKey, LPSTR lpszSubKey, LPSTR lpszValName, LPSTR lpszValue, int iMaxSize )
{
LONG lRet;
HKEY hKey;                   // cur open key
BOOL bOK = TRUE;
DWORD dwSize, dwType;

        // get subkey
        lRet = RegOpenKeyEx( hMainKey, lpszSubKey, (DWORD)0, KEY_QUERY_VALUE, (PHKEY)&hKey );
        if( lRet != ERROR_SUCCESS )
        {
//              Assert(FALSE, "problem on RegOpenKeyEx in GetRegValue\n");
                return FALSE;
        }

        // now do our paranoid check of data size
        lRet = RegQueryValueEx( hKey, lpszValName,(LPDWORD)NULL,(LPDWORD)&dwType, (LPBYTE)NULL,/* null for size info only */ (LPDWORD)&dwSize );

        if( ERROR_SUCCESS == lRet )
        {     // saw something there
                // here's the size check before getting the data
                if( dwSize > (DWORD)iMaxSize )
                { // if string too big
//                      Assert(FALSE, "Humongous registry string; can't GetRegValue...\n");
                        bOK = FALSE;               // can't read, so very bad news
                }
                else
                {                        // size is OK to continue
                        // now really get the value
                        lRet = RegQueryValueEx( hKey, lpszValName, (LPDWORD)NULL,(LPDWORD)&dwType, (LPBYTE)lpszValue, /* getting actual value */ (LPDWORD)&dwSize );
//                      Assert(lret == ERROR_SUCCESS, "bad return GetRegValue query\n");
//                      Assert(dwType == (DWORD)REG_SZ, "non-string type in GetValue!\n");

                        if( ERROR_SUCCESS != lRet )
                                bOK = FALSE;
                }
        }
        else
        {
                bOK = FALSE;
        }

        // close subkey
        RegCloseKey( hKey );

        return (bOK);
}

//------------------------------------------------------------------------------------
//
//      GetRegValueInt()
//
//      Just a little helper routine, gets an individual string value from the
//      registry and returns it to the caller as an int. Takes care of registry headaches,
//      including a paranoid length check before getting the string.
//
//      Returns: success of string retrieval
//
//------------------------------------------------------------------------------------
BOOL GetRegValueInt( HKEY hMainKey, LPSTR lpszSubKey, LPSTR lpszValName, int* piValue )
{
char lpszValue[16];
BOOL bOK = TRUE;

        bOK = GetRegValueString( hMainKey, lpszSubKey, lpszValName, lpszValue, MAX_VALUELEN );
        *piValue = AtoI( lpszValue );

        return bOK;
}

//------------------------------------------------------------------------------------
//
//      SetRegValueString()
//
//      Just a little helper routine that takes string and writes it to the     registry.
//
//      Returns: success writing to Registry, should be always TRUE.
//
//------------------------------------------------------------------------------------
BOOL SetRegValueString( HKEY hMainKey, LPSTR lpszSubKey, LPSTR lpszValName, LPSTR lpszValue )
{
HKEY hKey;                       // cur open key
LONG lRet;
BOOL bOK = TRUE;

        // open this subkey
        lRet = RegOpenKeyEx( hMainKey, (LPSTR)lpszSubKey, (DWORD)0, KEY_SET_VALUE, (PHKEY)&hKey );

        // check that you got a good key here
        if( lRet != ERROR_SUCCESS )
        {
        DWORD dwDisposition;

//              Assert(FALSE, "problem on RegOpenKeyEx (write) of subkey ");
//              Assert(FALSE, szSubKey);
//              Assert(FALSE, "\n");

                // OK, you couldn't even open the key !!!

                // **********************************************************************************
                // based on the sketchy documentation we have for this Reg* and Error stuff, we're
                // guessing that you've ended up here because this totally standard, Windows-defined
                // subkey name just doesn't happen to be defined for the current user.
                // **********************************************************************************

                // SO: Just create this subkey for this user, and maybe it will get used after you create and set it.
                // still successful so long as can create new subkey to write to

                lRet = RegCreateKeyEx( hMainKey, (LPSTR)lpszSubKey, (DWORD)0, (LPSTR)NULL, REG_OPTION_NON_VOLATILE,
                        KEY_SET_VALUE, (LPSECURITY_ATTRIBUTES)NULL, (PHKEY)&hKey, (LPDWORD)&dwDisposition );
                if( lRet != ERROR_SUCCESS )
                {
//                      Assert(FALSE, "problem even with RegCreateKeyEx (write) of subkey ");
//                      Assert(FALSE, szSubKey);
//                      Assert(FALSE, "\n");

                        // oh, oh, couldn't create the key
                        bOK = FALSE;
                }
        }
        lRet = RegSetValueEx( hKey, lpszValName, (DWORD)NULL,(DWORD)REG_SZ,(LPBYTE)lpszValue, (DWORD)( lstrlen( lpszValue) + 1 ) );
        bOK = bOK && (lRet == ERROR_SUCCESS);
//      Assert(bOK, "couldn't write a string value to registry!\n");

        // close this key
        RegCloseKey( hKey );

//      Assert(bOK, "didn't SetRegValue well\n");
        return (bOK);
}

//------------------------------------------------------------------------------------
//
//      SetRegValueInt()
//
//      Just a little helper routine that takes an int and writes it as a string to the
//      registry.
//
//      Returns: success writing to Registry, should be always TRUE.
//
//------------------------------------------------------------------------------------
BOOL SetRegValueInt( HKEY hMainKey, LPSTR lpszSubKey, LPSTR lpszValName, int iValue )
{
    char lpszValue[16];

    ItoA( iValue, lpszValue, 10 );
    return SetRegValueString( hMainKey, lpszSubKey, lpszValName, lpszValue );
}


//------------------------------------------------------------------------------------
//
//      SetRegValueDword()
//
//      Just a little helper routine that takes an dword and writes it to the
//      supplied location.
//
//      Returns: success writing to Registry, should be always TRUE.
//
//------------------------------------------------------------------------------------
BOOL SetRegValueDword( HKEY hk, LPTSTR pSubKey, LPTSTR pValue, DWORD dwVal )
{
    HKEY hkey = NULL;
    BOOL bRet = FALSE;

    if (ERROR_SUCCESS == RegOpenKey( hk, pSubKey, &hkey ))
    {
        if (ERROR_SUCCESS == RegSetValueEx( hkey, pValue, 0,
                                            REG_DWORD, (LPBYTE)&dwVal,
                                            sizeof(DWORD)
                                           )
            )
        {
            bRet = TRUE;
        }
    }


    if (hkey)
    {
        RegCloseKey( hkey );
    }

    return bRet;
}


//------------------------------------------------------------------------------------
//
//      GetRegValueDword()
//
//      Just a little helper routine that takes an dword and writes it to the
//      supplied location.
//
//      Returns: success writing to Registry, should be always TRUE.
//
//------------------------------------------------------------------------------------
DWORD GetRegValueDword( HKEY hk, LPTSTR pSubKey, LPTSTR pValue )
{
    HKEY hkey = NULL;
    DWORD dwVal = REG_BAD_DWORD;

    if (ERROR_SUCCESS == RegOpenKey( hk, pSubKey, &hkey ))
    {
        DWORD dwType, dwSize = sizeof(DWORD);

        RegQueryValueEx( hkey, pValue, NULL, &dwType, (LPBYTE)&dwVal, &dwSize );
    }


    if (hkey)
    {
        RegCloseKey( hkey );
    }

    return dwVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\poscpl\cashdrwr.c ===
/*
 *  CASHDRWR.C
 *
 *		Point-of-Sale Control Panel Applet
 *
 *      Author:  Ervin Peretz
 *
 *      (c) 2001 Microsoft Corporation 
 */

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <cpl.h>

#include <setupapi.h>
#include <hidsdi.h>

#include "internal.h"
#include "res.h"
#include "debug.h"



#if USE_OVERLAPPED_IO
    VOID CALLBACK OverlappedWriteCompletionRoutine( DWORD dwErrorCode,                
                                                    DWORD dwNumberOfBytesTransfered,  
                                                    LPOVERLAPPED lpOverlapped)
    {
        posDevice *posDev;
        
        /*
         *  We stashed our context in the hEvent field of the
         *  overlapped structure (this is allowed).
         */
        ASSERT(lpOverlapped);
        posDev = lpOverlapped->hEvent;
        ASSERT(posDev->sig == POSCPL_SIG);

        posDev->overlappedWriteStatus = dwErrorCode;
        posDev->overlappedWriteLen = dwNumberOfBytesTransfered;
        SetEvent(posDev->overlappedWriteEvent);
    }
#endif


BOOL SetCashDrawerState(posDevice *posDev, enum cashDrawerStates newState)
{
    NTSTATUS ntStat;
    BOOL result = FALSE;

    ASSERT(posDev->hidCapabilities.OutputReportByteLength <= 20);
    ntStat = HidP_SetUsageValue(HidP_Output,
                                USAGE_PAGE_CASH_DEVICE,
                                0, // all collections
                                USAGE_CASH_DRAWER_SET,
                                newState,
                                posDev->hidPreparsedData,
                                posDev->writeBuffer,
                                posDev->hidCapabilities.OutputReportByteLength);
    if (ntStat == HIDP_STATUS_SUCCESS){
        DWORD bytesWritten = 0;
        BOOL ok;

        ASSERT(posDev->hidCapabilities.OutputReportByteLength > 0);
        ASSERT(posDev->writeBuffer);

        #if USE_OVERLAPPED_IO
            /*
             *  It's ok to stash our context in the hEvent field
             *  of the overlapped structure.
             */
            posDev->overlappedWriteInfo.hEvent = (HANDLE)posDev;
            posDev->overlappedWriteInfo.Offset = 0;
            posDev->overlappedWriteInfo.OffsetHigh = 0;
            posDev->overlappedWriteLen = 0;
            ResetEvent(posDev->overlappedWriteEvent);
            ok = WriteFileEx(   posDev->devHandle,
                                posDev->writeBuffer,
                                posDev->hidCapabilities.OutputReportByteLength,
                                &posDev->overlappedWriteInfo,
                                OverlappedWriteCompletionRoutine);
            if (ok){
                WaitForSingleObject(posDev->overlappedWriteEvent, INFINITE);
                ok = (posDev->overlappedWriteStatus == NO_ERROR);
                bytesWritten = posDev->overlappedWriteLen;
            }
            else {
                bytesWritten = 0;
            }
        #else
            ok = WriteFile( posDev->devHandle,
                            posDev->writeBuffer,
                            posDev->hidCapabilities.OutputReportByteLength,
                            &bytesWritten,
                            NULL);
        #endif

        if (ok){
            ASSERT(bytesWritten <= posDev->hidCapabilities.OutputReportByteLength);
            result = TRUE;
        }
        else {
            DWORD err = GetLastError();
            DBGERR(L"WriteFile failed", err);
        }
    }
    else {
        DBGERR(L"HidP_SetUsageValue failed", ntStat);
        DBGERR(DBGHIDSTATUSSTR(ntStat), 0);
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\poscpl\msr.c ===
/*
 *  MSR.C
 *
 *		Point-of-Sale Control Panel Applet
 *
 *      Author:  Ervin Peretz
 *
 *      (c) 2001 Microsoft Corporation 
 */

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <cpl.h>

#include <setupapi.h>
#include <hidsdi.h>

#include "internal.h"
#include "res.h"
#include "debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\poscpl\debug.c ===
/*
 *  DEBUG.C
 *
 *		Point-of-Sale Control Panel Applet
 *
 *      Author:  Ervin Peretz
 *
 *      (c) 2001 Microsoft Corporation 
 */

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <cpl.h>

#include <setupapi.h>
#include <hidsdi.h>

#include "internal.h"
#include "res.h"
#include "debug.h"




#if DBG

    PWCHAR DbgHidStatusStr(DWORD hidStatus)
    {
        PWCHAR statusName = L"<Unknown>";

        switch (hidStatus){

            #define MAKE_CASE(stat) case stat: statusName = L#stat; break;

            MAKE_CASE(HIDP_STATUS_SUCCESS)
            MAKE_CASE(HIDP_STATUS_NULL)
            MAKE_CASE(HIDP_STATUS_INVALID_PREPARSED_DATA)
            MAKE_CASE(HIDP_STATUS_INVALID_REPORT_TYPE)
            MAKE_CASE(HIDP_STATUS_INVALID_REPORT_LENGTH)
            MAKE_CASE(HIDP_STATUS_USAGE_NOT_FOUND)
            MAKE_CASE(HIDP_STATUS_VALUE_OUT_OF_RANGE)
            MAKE_CASE(HIDP_STATUS_BAD_LOG_PHY_VALUES)
            MAKE_CASE(HIDP_STATUS_BUFFER_TOO_SMALL)
            MAKE_CASE(HIDP_STATUS_INTERNAL_ERROR)
            MAKE_CASE(HIDP_STATUS_I8042_TRANS_UNKNOWN)
            MAKE_CASE(HIDP_STATUS_INCOMPATIBLE_REPORT_ID)
            MAKE_CASE(HIDP_STATUS_NOT_VALUE_ARRAY)
            MAKE_CASE(HIDP_STATUS_IS_VALUE_ARRAY)
            MAKE_CASE(HIDP_STATUS_DATA_INDEX_NOT_FOUND)
            MAKE_CASE(HIDP_STATUS_DATA_INDEX_OUT_OF_RANGE)
            MAKE_CASE(HIDP_STATUS_BUTTON_NOT_PRESSED)
            MAKE_CASE(HIDP_STATUS_REPORT_DOES_NOT_EXIST)
            MAKE_CASE(HIDP_STATUS_NOT_IMPLEMENTED)
        }

        return statusName;
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\poscpl\internal.h ===
/*
 *  INTERNAL.H
 *
 *		Point-of-Sale Control Panel Applet
 *
 *      Author:  Ervin Peretz
 *
 *      (c) 2001 Microsoft Corporation 
 */



#define USE_OVERLAPPED_IO   FALSE



typedef struct posDevice {
                            #define POSCPL_SIG 'CsoP'
                            DWORD sig;

                            LIST_ENTRY listEntry;

                            /*
                             *  Device type, identified by dialog
                             *  id for the device type
                             *  (e.g. IDD_POS_CASHDRAWER_DLG).
                             */
                            DWORD dialogId;

                            PHIDP_PREPARSED_DATA hidPreparsedData;
                            HIDD_ATTRIBUTES hidAttrib;
                            HIDP_CAPS hidCapabilities;

                            HWND hDlg;

                            HANDLE hThread;

                            PUCHAR readBuffer;
                            PUCHAR writeBuffer;

                            HANDLE devHandle;
                            WCHAR pathName[MAX_PATH];

                            #if USE_OVERLAPPED_IO
                                OVERLAPPED overlappedReadInfo;
                                NTSTATUS overlappedReadStatus;
                                DWORD overlappedReadLen;
                                HANDLE overlappedReadEvent;

                                OVERLAPPED overlappedWriteInfo;
                                NTSTATUS overlappedWriteStatus;
                                DWORD overlappedWriteLen;
                                HANDLE overlappedWriteEvent;
                            #endif
} posDevice;



/*
 *  These are non-standard vendor usage values and codes
 *  used by APG Cash Drawer.
 */
#define USAGE_PAGE_CASH_DEVICE          0x0F0
#define USAGE_CASH_DRAWER               0x0F1
#define USAGE_CASH_DRAWER_NUMBER        0x0F2
#define USAGE_CASH_DRAWER_SET           0x0F3
#define USAGE_CASH_DRAWER_STATUS        0x0F4
enum cashDrawerStates {
                        DRAWER_STATE_OPEN =             1,
                        DRAWER_STATE_CLOSED_READY =     2,
                        DRAWER_STATE_CLOSED_CHARGING =  3,
                        DRAWER_STATE_LOCKED =           4,
                      };





/*
 *  List macros -- not defined in winnt.h for some reason.
 */
#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))
#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))
#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}
#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}
#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }
#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }
#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }



/*
 *  Function prototypes
 */
VOID LaunchPOSDialog(HWND hwndCPl);
INT_PTR APIENTRY POSDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY NullPOSDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
posDevice *NewPOSDevice(DWORD dialogId, HANDLE devHandle, PWCHAR devPath, PHIDP_PREPARSED_DATA pHidPreparsedData, PHIDD_ATTRIBUTES pHidAttrib, HIDP_CAPS *pHidCapabilities);
VOID DestroyPOSDevice(posDevice *posDev);
VOID EnqueuePOSDevice(posDevice *posDev);
VOID DequeuePOSDevice(posDevice *posDev);
VOID OpenAllHIDPOSDevices();
VOID IntToWChar(WCHAR *buf, DWORD x);
VOID HexToWChar(WCHAR *buf, DWORD x);
ULONG WStrNCpy(WCHAR *dest, const WCHAR *src, ULONG maxWChars);
ULONG AsciiToWChar(WCHAR *dest, const char *src, ULONG maxChars);
posDevice *GetDeviceByHDlg(HWND hDlg);
VOID LaunchDeviceInstanceThread(posDevice *posDev);
DWORD __stdcall DeviceInstanceThread(void *context);
BOOL SetCashDrawerState(posDevice *posDev, enum cashDrawerStates newState);
#if USE_OVERLAPPED_IO
    VOID CALLBACK OverlappedReadCompletionRoutine(DWORD dwErrorCode, DWORD dwNumberOfBytesTransfered, LPOVERLAPPED lpOverlapped);
    VOID CALLBACK OverlappedWriteCompletionRoutine(DWORD dwErrorCode, DWORD dwNumberOfBytesTransfered, LPOVERLAPPED lpOverlapped);
#endif



/*
 *  Externs
 */
extern HANDLE g_hInst;
extern ULONG numDeviceInstances;
extern LIST_ENTRY allPOSDevicesList;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\poscpl\poscpl.c ===
/*
 *  POSCPL.C
 *
 *		Point-of-Sale Control Panel Applet
 *
 *      Author:  Ervin Peretz
 *
 *      (c) 2001 Microsoft Corporation 
 */

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <cpl.h>

#include <setupapi.h>
#include <hidsdi.h>

#include "internal.h"
#include "res.h"
#include "debug.h"




HANDLE g_hInst = NULL;


BOOL WINAPI LibMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason){

        case DLL_PROCESS_ATTACH:
            g_hInst = hDll;
            DisableThreadLibraryCalls(hDll);
            InitializeListHead(&allPOSDevicesList);
            break;

        case DLL_PROCESS_DETACH:
        case DLL_THREAD_DETACH:
        case DLL_THREAD_ATTACH:
        default:
            break;
    }

    return TRUE;
}


LONG CPlApplet(HWND hwndCPl, UINT uMsg, LPARAM lParam1, LPARAM lParam2)
{
    LONG result = 0L;

	switch (uMsg){

		case CPL_INIT:
            result = 1;
			break;

        case CPL_GETCOUNT:
            result = 1;
			break;

		case CPL_INQUIRE:
            {
                LPCPLINFO pcplinfo = (LPCPLINFO)lParam2;
                switch (lParam1){
                    case 0:
                        pcplinfo->idIcon = IDI_POSCPL_ICON;
                        pcplinfo->idName = IDS_CAPTION;
                        pcplinfo->idInfo = IDS_DESCRIPTION;
                        break;
                    case 1:     // BUGBUG
                        pcplinfo->idIcon = IDI_POSCPL_ICON;
                        pcplinfo->idName = IDS_CAPTION;
                        pcplinfo->idInfo = IDS_DESCRIPTION;
                        break;
                    }
                pcplinfo->lData = 0L;
            }
            result = 1;
			break;

		case CPL_SELECT:
            result = 0;  // BUGBUG ?
			break;

		case CPL_DBLCLK:
            /*
             *  The CPL was selected by the user.
             *  Show our main dialog.
             */
            switch (lParam1){

                case 0:

                    OpenAllHIDPOSDevices();
                    
                    LaunchPOSDialog(hwndCPl);

                    break;
            }
			break;

		case CPL_STOP:
            result = 1;     // BUGBUG ?
			break;

		case CPL_EXIT:
            result = 1;
			break;

		case CPL_NEWINQUIRE:
            {
                LPNEWCPLINFO pnewcplinfo = (LPNEWCPLINFO)lParam2;
                switch (lParam1){
                    case 0:
                        pnewcplinfo->hIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_POSCPL_ICON));
                        // BUGBUG LoadString(g_hInst, IDS_xxx, pnewcplinfo->szName, sizeof(pnewcplinfo->szName));
                        // BUGBUG LoadString(g_hInst, IDS_xxx, pnewcplinfo->szInfo, sizeof(pnewcplinfo->szInfo));
                        break;
                }
                pnewcplinfo->dwHelpContext = 0;
                pnewcplinfo->dwSize = sizeof(NEWCPLINFO);
                pnewcplinfo->lData = 0L;
                pnewcplinfo->szHelpFile[0] = 0;
            }
            result = 1;
			break;

        default:
            result = 0;
            break;
    }

    return result;
}


VOID LaunchPOSDialog(HWND hwndCPl)
{
    PROPSHEETPAGE *propSheetPages;
    ULONG numPropSheetPages;
    
    /*
     *  Make sure we allocate at least one propsheetpage,
     *  even if there are no devices.
     */
    numPropSheetPages = (numDeviceInstances == 0) ? 1 : numDeviceInstances;
    propSheetPages = GlobalAlloc(   GMEM_FIXED|GMEM_ZEROINIT,
                                    numPropSheetPages*sizeof(PROPSHEETPAGE));

    if (propSheetPages){
        PROPSHEETHEADER propSheetHeader = {0};

        if (numDeviceInstances == 0){
            /*
             *  If there are no POS devices, 
             *  then put up a single tab saying so.
             */
            propSheetPages[0].dwSize = sizeof(PROPSHEETPAGE);
            propSheetPages[0].dwFlags = PSP_DEFAULT;
            propSheetPages[0].hInstance = g_hInst;
            propSheetPages[0].pszTemplate = MAKEINTRESOURCE(IDD_NO_DEVICES_DLG);
            propSheetPages[0].pszIcon = NULL;   // PSP_USEICONID not set in dwFlags
            propSheetPages[0].pszTitle = MAKEINTRESOURCE("BUGBUG");  // PSP_USETITLE not set in dwFlags
            propSheetPages[0].pfnDlgProc = NullPOSDlgProc;
            propSheetPages[0].lParam = (LPARAM)NULL;
            propSheetPages[0].pfnCallback = NULL;
            propSheetPages[0].pcRefParent = NULL;
        }
        else {
            LIST_ENTRY *listEntry;
            ULONG i;

            /*
             *  Create the array of property sheet handles
             */
            i = 0;
            listEntry = &allPOSDevicesList;
            while ((listEntry = listEntry->Flink) != &allPOSDevicesList){        
                posDevice *posDev;
            
                posDev = CONTAINING_RECORD(listEntry, posDevice, listEntry);

                ASSERT(i < numDeviceInstances);
                propSheetPages[i].dwSize = sizeof(PROPSHEETPAGE);
                propSheetPages[i].dwFlags = PSP_DEFAULT;
                propSheetPages[i].hInstance = g_hInst;
                propSheetPages[i].pszTemplate = MAKEINTRESOURCE(posDev->dialogId);
                propSheetPages[i].pszIcon = NULL;   // PSP_USEICONID not set in dwFlags
                propSheetPages[i].pszTitle = MAKEINTRESOURCE("BUGBUG");  // PSP_USETITLE not set in dwFlags
                propSheetPages[i].pfnDlgProc = POSDlgProc;
                propSheetPages[i].lParam = (LPARAM)posDev;  // BUGBUG ? - context ?
                propSheetPages[i].pfnCallback = NULL;
                propSheetPages[i].pcRefParent = NULL;

                i++;
            }
        }

        /*
         *  Initialize the property sheet header
         */
        propSheetHeader.dwSize = sizeof(PROPSHEETHEADER);
        propSheetHeader.dwFlags = PSH_PROPTITLE | PSH_PROPSHEETPAGE;
        propSheetHeader.hwndParent = hwndCPl;
        propSheetHeader.hInstance = g_hInst;
        propSheetHeader.pszIcon = NULL;
        propSheetHeader.pszCaption = MAKEINTRESOURCE(IDS_DIALOG_TITLE);
        propSheetHeader.ppsp = propSheetPages;
        propSheetHeader.nPages = numPropSheetPages; 


        /*
         *  Launch the property sheet tabbed dialog
         */
        PropertySheet(&propSheetHeader);

        GlobalFree(propSheetPages);
    }
    else {
        ASSERT(propSheetPages);
    }
}


INT_PTR APIENTRY POSDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL result = TRUE;

    switch (uMsg){

        case WM_INITDIALOG:
            {
                /*
                 *  On the WM_INITDIALOG only, lParam points to
                 *  our propSheetPage, which contains our posDevice
                 *  context (in the 'lParam' field).  This is our
                 *  only chance to associate the posDevice context
                 *  with the actual dialog for future calls.
                 */
                PROPSHEETPAGE *propSheetPage = (PROPSHEETPAGE *)lParam;
                posDevice *posDev = (posDevice *)propSheetPage->lParam;

                ASSERT(posDev->sig == POSCPL_SIG);

                posDev->hDlg = hDlg;
                
                LaunchDeviceInstanceThread(posDev);
            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR*)lParam)->code){
                case PSN_APPLY:
                    SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                    break;
                default:
                    result = FALSE;
                    break;
            }
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)){

                case IDC_SELECT_DEVICETYPE:
                    break;

                case IDC_CASHDRAWER_STATE:
                    break;

                case IDC_CASHDRAWER_STATETEXT:
                    break;

                case IDC_CASHDRAWER_OPEN:
                    {
                        posDevice *posDev;

                        posDev = GetDeviceByHDlg(hDlg);
                        if (posDev){
                            SetCashDrawerState(posDev, DRAWER_STATE_OPEN);
                        }
                        else {
                            DBGERR(L"GetDeviceByHDlg failed", 0);
                        }
                    }
                    break;

                case IDC_MSR_TEXT:
                    break;

                case IDC_STATIC1:
                case IDC_STATIC2:
                    break;

            }
            break;

        case WM_DESTROY:
            {
                LIST_ENTRY *listEntry = &allPOSDevicesList;
                while ((listEntry = listEntry->Flink) != &allPOSDevicesList){        
                    posDevice *posDev = CONTAINING_RECORD(listEntry, posDevice, listEntry);
                    if (posDev->hThread){

                        #if 0
                            // BUGBUG FINISH - kill the thread

                            WaitForSingleObject(posDev->hThread, INFINITE);
                            CloseHandle(posDev->hThread);
                        #endif
                    }
                }
            }
            break;

        case WM_HELP: 
            break;

        case WM_CONTEXTMENU:
            break;

        default:
            result = FALSE;
            break;
    }

    return (INT_PTR)result;
}


/*
 *  NullPOSDlgProc
 *
 *      This is the dialog proc when we have no POS devices to display.
 */
INT_PTR APIENTRY NullPOSDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL result = TRUE;

    switch (uMsg){

        case WM_NOTIFY:
            switch (((NMHDR FAR*)lParam)->code){
                case PSN_APPLY:
                    SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                    break;
                default:
                    result = FALSE;
                    break;
            }
            break;

        default:
            result = FALSE;
            break;
    }

    return (INT_PTR)result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\poscpl\res.h ===
/*
 *  RESOURCE.H
 *
 *		Point-of-Sale Control Panel Applet
 *
 *      Author:  Ervin Peretz
 *
 *      (c) 2001 Microsoft Corporation 
 */


/*
 *  Icon identifiers
 */
#define	IDI_POSCPL_ICON			        1


/*
 *  String identifiers
 */
#define IDS_DIALOG_TITLE                101
#define IDS_CAPTION                     102
#define IDS_DESCRIPTION                 103
#define IDS_DRAWERSTATE_UNKNOWN         104
#define IDS_DRAWERSTATE_OPEN            105
#define IDS_DRAWERSTATE_READY           106
#define IDS_DRAWERSTATE_CHARGING        107
#define IDS_DRAWERSTATE_LOCKED          108


/*
 *  Prop sheet page identifiers (one for each POS device type)
 */
#define IDD_NO_DEVICES_DLG              1
#define IDD_POS_CASHDRAWER_DLG          2
#define IDD_POS_MSR_DLG                 3

#define IDD_DEVICETYPE_NONE             11
#define IDD_DEVICETYPE_CASHDRAWER       12   
#define IDD_DEVICETYPE_MSR              13

/*
 *  Dialog control identifiers
 */
#define IDC_SELECT_DEVICETYPE           51
#define IDC_CASHDRAWER_STATE            52
#define IDC_CASHDRAWER_STATETEXT        53
#define IDC_CASHDRAWER_OPEN             54
#define IDC_MSR_TEXT                    55
#define IDC_STATIC1                     56
#define IDC_STATIC2                     57
#define IDC_NO_DEVICES_TEXT             58
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\poscpl\devices.c ===
/*
 *  DEVICES.C
 *
 *		Point-of-Sale Control Panel Applet
 *
 *      Author:  Ervin Peretz
 *
 *      (c) 2001 Microsoft Corporation 
 */

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <cpl.h>

#include <setupapi.h>
#include <hidsdi.h>

#include "internal.h"
#include "res.h"
#include "debug.h"


ULONG numDeviceInstances = 0;
LIST_ENTRY allPOSDevicesList;



posDevice *NewPOSDevice(    DWORD dialogId,
                            HANDLE devHandle,
                            PWCHAR devPath,
                            PHIDP_PREPARSED_DATA pHidPreparsedData,
                            PHIDD_ATTRIBUTES pHidAttrib,
                            HIDP_CAPS *pHidCapabilities)
{
    posDevice *newPosDev;

    newPosDev = (posDevice *)GlobalAlloc(   GMEM_FIXED|GMEM_ZEROINIT, 
                                            sizeof(posDevice));
    if (newPosDev){

        newPosDev->sig = POSCPL_SIG;
        InitializeListHead(&newPosDev->listEntry);

        newPosDev->dialogId = dialogId;
        newPosDev->devHandle = devHandle;
        WStrNCpy(newPosDev->pathName, devPath, MAX_PATH);
        newPosDev->hidPreparsedData = pHidPreparsedData;
        newPosDev->hidAttrib = *pHidAttrib;
        newPosDev->hidCapabilities = *pHidCapabilities;

        /*
         *  Allocate components of the context
         */
        if (newPosDev->hidCapabilities.InputReportByteLength){
            newPosDev->readBuffer = GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, 
                                                newPosDev->hidCapabilities.InputReportByteLength);
        }
        if (newPosDev->hidCapabilities.OutputReportByteLength){
            newPosDev->writeBuffer = GlobalAlloc(   GMEM_FIXED|GMEM_ZEROINIT, 
                                                    newPosDev->hidCapabilities.OutputReportByteLength);
        }
        #if USE_OVERLAPPED_IO
            newPosDev->overlappedReadEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
            newPosDev->overlappedWriteEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        #endif

        /*
         *  Check if we allocated everything successfully.
         */
        if (    
                (newPosDev->readBuffer || !newPosDev->hidCapabilities.InputReportByteLength) &&
                (newPosDev->writeBuffer || !newPosDev->hidCapabilities.OutputReportByteLength) &&
                #if USE_OVERLAPPED_IO
                    newPosDev->overlappedReadEvent  && 
                    newPosDev->overlappedWriteEvent &&
                #endif
                TRUE
            ){

            /*
             *  Created device context successfully.
             */


        }
        else {
            DBGERR(L"allocation error in NewPOSDevice()", 0);
            DestroyPOSDevice(newPosDev);
            newPosDev = NULL;
        }
    }

    ASSERT(newPosDev);
    return newPosDev;
}


VOID DestroyPOSDevice(posDevice *posDev)
{
    ASSERT(IsListEmpty(&posDev->listEntry));

    /*
     *  Note: this destroy function is called from a failed NewPOSDevice()
     *        call as well; so check every pointer before freeing.
     */
    if (posDev->readBuffer) GlobalFree(posDev->readBuffer);
    if (posDev->writeBuffer) GlobalFree(posDev->writeBuffer);
    if (posDev->hidPreparsedData) GlobalFree(posDev->hidPreparsedData);

    #if USE_OVERLAPPED_IO
        if (posDev->overlappedReadEvent) CloseHandle(posDev->overlappedReadEvent);
        if (posDev->overlappedWriteEvent) CloseHandle(posDev->overlappedWriteEvent);
    #endif

    GlobalFree(posDev);
}


VOID EnqueuePOSDevice(posDevice *posDev)
{
    ASSERT(IsListEmpty(&posDev->listEntry));
    InsertTailList(&allPOSDevicesList, &posDev->listEntry);
    numDeviceInstances++;
}


VOID DequeuePOSDevice(posDevice *posDev)
{
    ASSERT(!IsListEmpty(&allPOSDevicesList));
    ASSERT(!IsListEmpty(&posDev->listEntry));
    RemoveEntryList(&posDev->listEntry);
    InitializeListHead(&posDev->listEntry);
    numDeviceInstances--;
}


posDevice *GetDeviceByHDlg(HWND hDlg)
{
    posDevice *foundPosDev = NULL;
    LIST_ENTRY *listEntry;

    listEntry = &allPOSDevicesList;
    while ((listEntry = listEntry->Flink) != &allPOSDevicesList){        
        posDevice *thisPosDev;
    
        thisPosDev = CONTAINING_RECORD(listEntry, posDevice, listEntry);
        if (thisPosDev->hDlg == hDlg){
            foundPosDev = thisPosDev;
            break;
        }
    }

    return foundPosDev;
}


VOID OpenAllHIDPOSDevices()
{
    HDEVINFO hDevInfo;
    GUID hidGuid = {0};
    WCHAR devicePath[MAX_PATH];
    
    /*
     *  Call hid.dll to get the GUID for Human Input Devices.
     */
    HidD_GetHidGuid(&hidGuid);

    hDevInfo = SetupDiGetClassDevs( &hidGuid,
                                    NULL, 
                                    NULL,
                                    DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);
    if (hDevInfo == INVALID_HANDLE_VALUE){
        DWORD err = GetLastError();
        DBGERR(L"SetupDiGetClassDevs failed", err);
    }
    else {
        int i;

        for (i = 0; TRUE; i++){
            SP_DEVICE_INTERFACE_DATA devInfoData = {0};
            BOOL ok;

            devInfoData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
            ok = SetupDiEnumDeviceInterfaces(   hDevInfo, 
                                                0, 
                                                &hidGuid,
                                                i,
                                                &devInfoData);
            if (ok){
                DWORD hwDetailLen = 0;

                /*
                 *  Call SetupDiGetDeviceInterfaceDetail with
                 *  a NULL PSP_DEVICE_INTERFACE_DETAIL_DATA pointer
                 *  just to get the length of the hardware details.
                 */
                ASSERT(devInfoData.cbSize == sizeof(SP_DEVICE_INTERFACE_DATA));
                ok = SetupDiGetDeviceInterfaceDetail(
                                        hDevInfo,
                                        &devInfoData,
                                        NULL,
                                        0,  
                                        &hwDetailLen,
                                        NULL);
                if (ok || (GetLastError() == ERROR_INSUFFICIENT_BUFFER)){
                    PSP_DEVICE_INTERFACE_DETAIL_DATA devDetails;

                    /*
                     *  Now make the real call to SetupDiGetDeviceInterfaceDetail.
                     */
                    ASSERT(hwDetailLen > sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA));
                    devDetails = GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, hwDetailLen);
                    if (devDetails){
                        devDetails->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
                        ok = SetupDiGetDeviceInterfaceDetail(
                                                hDevInfo,
                                                &devInfoData,
                                                devDetails,
                                                hwDetailLen,  
                                                &hwDetailLen,
                                                NULL);
                        if (ok){

                            /*
                             *  BUGBUG - FINISH
                             *  Right now, we only handle cash drawers.
                             *  And we only work with the APG cash drawers 
                             *  (with vendor-specific usages) for now.
                             */
                            WCHAR apgKbPathPrefix[] = L"\\\\?\\hid#vid_0f25&pid_0500";

                            /*
                             *  If this is an APG keyboard, then the device path
                             *  (very long) will begin with apgKbPathPrefix.
                             */
                            if (RtlEqualMemory( devDetails->DevicePath,
                                                apgKbPathPrefix,
                                                sizeof(apgKbPathPrefix)-sizeof(WCHAR))){
                                HANDLE hDev;

                                // MessageBox(NULL, devDetails->DevicePath, L"DEBUG message - found APG kb", MB_OK);

                                hDev = CreateFile(  
                                            devDetails->DevicePath,
                                            GENERIC_READ | GENERIC_WRITE,
                                            FILE_SHARE_READ | FILE_SHARE_WRITE,  
                                            NULL,
                                            OPEN_EXISTING,                
                                            0,                 
                                            NULL);
                                if (hDev == INVALID_HANDLE_VALUE){
                                    DWORD err = GetLastError();
                                    DBGERR(L"CreateFile failed", err);
                                }
                                else {
                                    PHIDP_PREPARSED_DATA hidPreparsedData;

                                    // MessageBox(NULL, devDetails->DevicePath, L"DEBUG message - CreateFile succeeded", MB_OK);

                                    ok = HidD_GetPreparsedData(hDev, &hidPreparsedData);
                                    if (ok){
                                        HIDD_ATTRIBUTES hidAttrib;

                                        ok = HidD_GetAttributes(hDev, &hidAttrib);
                                        if (ok){
                                            HIDP_CAPS hidCapabilities;

                                            ok = HidP_GetCaps(hidPreparsedData, &hidCapabilities);
                                            if (ok){
                                                posDevice *posDev;
                                            
                                                posDev = NewPOSDevice(  IDD_POS_CASHDRAWER_DLG,
                                                                        hDev,
                                                                        devDetails->DevicePath,
                                                                        hidPreparsedData,
                                                                        &hidAttrib,
                                                                        &hidCapabilities);
                                                if (posDev){
                                                    EnqueuePOSDevice(posDev);
                                                }
                                                else {
                                                    ASSERT(posDev);
                                                }
                                            }
                                            else {
                                                DBGERR(L"HidP_GetCaps failed", 0);

                                            }
                                        }
                                        else {
                                            DWORD err = GetLastError();
                                            DBGERR(L"HidD_GetAttributes failed", err);
                                        }
                                    }
                                    else {
                                        DWORD err = GetLastError();
                                        DBGERR(L"HidD_GetPreparsedData failed", err);
                                    }
                                }
                            }
                        }
                        else {
                            DWORD err = GetLastError();
                            DBGERR(L"SetupDiGetDeviceInterfaceDetail(2) failed", err);
                        }

                        GlobalFree(devDetails);
                    }
                }
                else {
                    DWORD err = GetLastError();
                    DBGERR(L"SetupDiGetDeviceInterfaceDetail(1) failed", err);
                }
            }
            else {
                DWORD err = GetLastError();
                if (err != ERROR_NO_MORE_ITEMS){
                    DBGERR(L"SetupDiEnumDeviceInterfaces failed", err); 
                }
                break;
            }
        }

        SetupDiDestroyDeviceInfoList(hDevInfo);
    }

}


/*
 *  LaunchDeviceInstanceThread
 *
 *      Launch a thread for a device instance to read
 *      asynchronous events from the device.
 */
VOID LaunchDeviceInstanceThread(posDevice *posDev)
{
    DWORD threadId;

    posDev->hThread = CreateThread(NULL, 0, DeviceInstanceThread, posDev, 0, &threadId);
    if (posDev->hThread){

    }
    else {
        DWORD err = GetLastError();
        DBGERR(L"CreateThread failed", err);
    }

}


#if USE_OVERLAPPED_IO
    VOID CALLBACK OverlappedReadCompletionRoutine(  DWORD dwErrorCode,                
                                                    DWORD dwNumberOfBytesTransfered,  
                                                    LPOVERLAPPED lpOverlapped)
    {
        posDevice *posDev;
        
        /*
         *  We stashed our context in the hEvent field of the
         *  overlapped structure (this is allowed).
         */
        ASSERT(lpOverlapped);
        posDev = lpOverlapped->hEvent;
        ASSERT(posDev->sig == POSCPL_SIG);

        posDev->overlappedReadStatus = dwErrorCode;
        posDev->overlappedReadLen = dwNumberOfBytesTransfered;
        SetEvent(posDev->overlappedReadEvent);
    }
#endif


DWORD __stdcall DeviceInstanceThread(void *context)
{
    posDevice *posDev = (posDevice *)context;
    HANDLE hDevNew;

    ASSERT(posDev->sig == POSCPL_SIG);


    // BUGBUG - for some reason, reads and writes on the same handle
    //          interfere with one another
    hDevNew = CreateFile(  
                posDev->pathName,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,  
                NULL,
                OPEN_EXISTING,                
                0,                 
                NULL);
    if (hDevNew == INVALID_HANDLE_VALUE){
        DWORD err = GetLastError();
        DBGERR(L"CreateFile failed", err);
    }
    else {

        /*
         *  Loop forever until main thread kills this thread.
         */
        while (TRUE){
            WCHAR drawerStateString[100];
            DWORD bytesRead = 0;
            BOOL ok;

            /*
             *  Load the default string for the drawer state
             */
            LoadString(g_hInst, IDS_DRAWERSTATE_UNKNOWN, drawerStateString, 100);

            ASSERT(posDev->hidCapabilities.InputReportByteLength > 0);
            ASSERT(posDev->readBuffer);

            #if USE_OVERLAPPED_IO
                /*
                 *  It's ok to stash our context in the hEvent field
                 *  of the overlapped structure.
                 */
                posDev->overlappedReadInfo.hEvent = (HANDLE)posDev;
                posDev->overlappedReadInfo.Offset = 0;
                posDev->overlappedReadInfo.OffsetHigh = 0;
                posDev->overlappedReadLen = 0;
                ResetEvent(posDev->overlappedReadEvent);
                ok = ReadFileEx(hDevNew,
                                posDev->readBuffer,
                                posDev->hidCapabilities.InputReportByteLength,
                                &posDev->overlappedReadInfo,
                                OverlappedReadCompletionRoutine);
                if (ok){
                    WaitForSingleObject(posDev->overlappedReadEvent, INFINITE);
                    ok = (posDev->overlappedReadStatus == NO_ERROR);
                    bytesRead = posDev->overlappedWriteLen;
                }
                else {
                    bytesRead = 0;
                }
            #else
                ok = ReadFile(  hDevNew,
                                posDev->readBuffer,
                                posDev->hidCapabilities.InputReportByteLength,
                                &bytesRead,
                                NULL);
            #endif


            if (ok){
                NTSTATUS ntStat;
                ULONG usageVal;

                ASSERT(bytesRead <= posDev->hidCapabilities.InputReportByteLength);

                ntStat = HidP_GetUsageValue(HidP_Input,
                                            USAGE_PAGE_CASH_DEVICE,
                                            0, // all collections
                                            USAGE_CASH_DRAWER_STATUS,
                                            &usageVal,
                                            posDev->hidPreparsedData,
                                            posDev->readBuffer,
                                            posDev->hidCapabilities.InputReportByteLength);
                if (ntStat == HIDP_STATUS_SUCCESS){
                    HWND hOpenButton;

                    /*
                     *  Get display string for new drawer state.
                     */
                    switch (usageVal){
                        case DRAWER_STATE_OPEN:
                            LoadString(g_hInst, IDS_DRAWERSTATE_OPEN, drawerStateString, 100);
                            break;
                        case DRAWER_STATE_CLOSED_READY:
                            LoadString(g_hInst, IDS_DRAWERSTATE_READY, drawerStateString, 100);
                            break;
                        case DRAWER_STATE_CLOSED_CHARGING:
                            LoadString(g_hInst, IDS_DRAWERSTATE_CHARGING, drawerStateString, 100);
                            break;
                        case DRAWER_STATE_LOCKED:
                            LoadString(g_hInst, IDS_DRAWERSTATE_LOCKED, drawerStateString, 100);
                            break;
                        default:
                            DBGERR(L"illegal usage", usageVal); 
                            break;
                    }

                    /*
                     *  Set 'Open' button based on the drawer state.
                     */
                    hOpenButton = GetDlgItem(posDev->hDlg, IDC_CASHDRAWER_OPEN);
                    if (hOpenButton){

                        LONG btnState = GetWindowLong(hOpenButton, GWL_STYLE);
                        switch (usageVal){
                            case DRAWER_STATE_OPEN:
                                btnState |= WS_DISABLED;
                                break;
                            default:
                                btnState &= ~WS_DISABLED;
                                break;
                        }
                        SetWindowLong(hOpenButton, GWL_STYLE, btnState);

                        /*
                         *  To make SetWindowLong take effect, you
                         *  sometimes have to call SetWindowPos.
                         */
                        SetWindowPos(hOpenButton, 0,
                                     0, 0, 0, 0,
                                     SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_HIDEWINDOW);
                        SetWindowPos(hOpenButton, 0,
                                     0, 0, 0, 0,
                                     SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_SHOWWINDOW);
                    }
                    else {
                        DBGERR(L"GetDlgItem failed", 0);
                    }
                }
                else {
                    DBGERR(L"HidP_GetUsageValue failed", ntStat);
                    DBGERR(DBGHIDSTATUSSTR(ntStat), 0);
                }
            }
            else {
                DWORD err = GetLastError();
                DBGERR(L"ReadFile failed", err);
            }


            ASSERT(posDev->hDlg);
            ok = SetDlgItemText(posDev->hDlg, IDC_CASHDRAWER_STATETEXT, drawerStateString);
            if (ok){

            }
            else {
                DWORD err = GetLastError();
                DBGERR(L"SetDlgItemText failed", err);
            }
        }

        CloseHandle(hDevNew);
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\poscpl\util.c ===
/*
 *  UTIL.C
 *
 *		Point-of-Sale Control Panel Applet
 *
 *      Author:  Ervin Peretz
 *
 *      (c) 2001 Microsoft Corporation 
 */

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <cpl.h>

#include <setupapi.h>
#include <hidsdi.h>

#include "internal.h"
#include "res.h"
#include "debug.h"



/*
 *  WStrNCpy
 *
 *      Like wcsncpy, but terminates the string if truncated.
 *      Also, tolerates NULL src string.
 */
ULONG WStrNCpy(WCHAR *dest, const WCHAR *src, ULONG maxWChars)
{
    ULONG wCharsWritten = 0;

    ASSERT(dest);

    if (src){
        while ((maxWChars-- > 1) && (*dest++ = *src++)){
            wCharsWritten++;
        }
        if (maxWChars == 1){
            *dest = L'\0';
            wCharsWritten++;
        }
    }
    else {
        *dest = L'\0';
        wCharsWritten++;
    }

    return wCharsWritten;
}


/*
 *  AsciiToWChar
 *
 *      Like mbstowcs, but terminates the string if truncated.
 *      Also, tolerates NULL ascii string.
 */
ULONG AsciiToWChar(WCHAR *dest, const char *src, ULONG maxChars)
{
    ULONG charsWritten = 0;

    if (src){
        while ((maxChars-- > 1) && (*dest++ = (WCHAR)*src++)){
            charsWritten++;
        }
        if (maxChars == 1){
            *dest = (WCHAR)NULL;
            charsWritten++;
        }
    }
    else {
        *dest = (WCHAR)NULL;
        charsWritten++;
    }

    return charsWritten;
}


VOID IntToWChar(WCHAR *buf, DWORD x)
{
	int i;
	WCHAR tmpbuf[11] = {0};

    if (x){
	    for (i = 10; x && (i >= 0); i--){
		    tmpbuf[i] = (WCHAR)(L'0' + (x % 10));
		    x /= 10;
	    }

	    WStrNCpy(buf, &tmpbuf[i+1], 11);
    }
    else {
        WStrNCpy(buf, L"0", 2);
    }
}


VOID HexToWChar(WCHAR *buf, DWORD x)
{
	int i;
	WCHAR tmpbuf[9] = {0};

    if (x){
	    for (i = 7; x && (i >= 0); i--){
            ULONG nibble = (x % 16);
            if (nibble < 10){
		        tmpbuf[i] = (WCHAR)(L'0' + nibble);
            }
            else {
                tmpbuf[i] = (WCHAR)(L'A' + nibble - 10);
            }
		    x /= 16;
	    }

	    WStrNCpy(buf, &tmpbuf[i+1], 9);
    }
    else {
        WStrNCpy(buf, L"0", 2);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\poscpl\resource.h ===
/*
 *  RESOURCE.H
 *
 *		Point-of-Sale Control Panel Applet
 *
 *      Author:  Ervin Peretz
 *
 *      (c) 2001 Microsoft Corporation 
 */


/*
 *  Icon identifiers
 */
#define	IDI_POSCPL_ICON			        1


/*
 *  String identifiers
 */
#define IDS_DIALOG_TITLE                101
#define IDS_CAPTION                     102
#define IDS_DESCRIPTION                 103
#define IDS_DRAWERSTATE_UNKNOWN         104
#define IDS_DRAWERSTATE_OPEN            105
#define IDS_DRAWERSTATE_READY           106
#define IDS_DRAWERSTATE_CHARGING        107
#define IDS_DRAWERSTATE_LOCKED          108


/*
 *  Prop sheet page identifiers (one for each POS device type)
 */
#define IDD_POS_CASHDRAWER_DLG          1   
#define IDD_POS_MSR_DLG                 2

#define IDD_DEVICETYPE_NONE             11
#define IDD_DEVICETYPE_CASHDRAWER       12   
#define IDD_DEVICETYPE_MSR              13

/*
 *  Dialog control identifiers
 */
#define IDC_SELECT_DEVICETYPE           51
#define IDC_CASHDRAWER_STATE            52
#define IDC_CASHDRAWER_STATETEXT        53
#define IDC_CASHDRAWER_OPEN             54
#define IDC_MSR_TEXT                    55
#define IDC_STATIC1                     56
#define IDC_STATIC2                     57
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\advanced.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    advanced.h

Abstract:

    Public declarations for the Advanced tab of the System Control Panel 
    Applet.

Author:

    Scott Hallock (scotthal) 15-Oct-1997

--*/
#ifndef _SYSDM_ADVANCED_H_
#define _SYSDM_ADVANCED_H_

INT_PTR
APIENTRY
AdvancedDlgProc(
    IN HWND hDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
);

void DoPerformancePS(HWND hDlg);

#endif // _SYSDM_ADVANCED_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\debug.c ===
//*************************************************************
//  File name:    DEBUG.C
//
//  Description:  Debug helper code for System control panel
//                applet
//
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1992-2000
//  All rights reserved
//
//*************************************************************
#include "sysdm.h"

// Define some things for debug.h
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "SYSDM"
#define SZ_MODULE           "SYSDM"
#define DECLARE_DEBUG

#include <ccstock.h>
#include <debug.h>


///////////////////////////////////////////////////////////////
//      Constants
///////////////////////////////////////////////////////////////

#ifdef DBG_CODE

#define CCH_LABEL (sizeof(DWORD) * 2)   // 64 BITS == 8 ANSI chars

#define CB_TAG     sizeof(DWORD)
#define DW_TAG      ((DWORD)(0x44535953))   // 'SYSD'

#define DW_TAG2     ((DWORD)(0x444F4F47))   // 'GOOD'

#define CH_FILL     '*'

///////////////////////////////////////////////////////////////
//      Structures and Types
///////////////////////////////////////////////////////////////

/*
 * NOTE!!!!
 *
 * The HOBJHDR structure MUST be a multiple of 8 bytes (64bits) in len!
 * otherwise this code will *FAULT* on ALPHA machines!
 *
 */
typedef struct HHO *PHHO;

struct HHO {
    PHHO    phhoNext;
    PHHO    phhoPrev;
    CHAR    szFile[CCH_LABEL];
    DWORD   iLine;
    DWORD   cBytesData;
    DWORD   dwTmp;
    DWORD   dwTag2;
};

typedef struct HHO HOBJHDR;

typedef struct {
    LPVOID  pvPtr;
    CHAR    szFile[CCH_LABEL];
    DWORD   iLine;
    CHAR    szFreedBy[CCH_LABEL];
    DWORD   iLineFreed;
} FREELOGREC, *PFREELOGREC;

///////////////////////////////////////////////////////////////
//      Global variables
///////////////////////////////////////////////////////////////

/*
 * Root of memory chain
 */
HOBJHDR hhoRoot = { &hhoRoot, &hhoRoot, { 'R', 'O', 'O', 'T' }, 0, sizeof(hhoRoot) };


/*
 * Buffer used for OutputDebugString formatting (See DbgPrintf and DbgStopX)
 */
TCHAR szDbgOutBuffer[1024];

/*
 * Buffer used for logging
 */
#define CFLR_MAX    1024
FREELOGREC aflrFreeLog[CFLR_MAX];
PFREELOGREC g_pflrUnused = NULL;

#define NextFreeLogRec( pflr )    ((pflr >= &aflrFreeLog[CFLR_MAX-1]) ? aflrFreeLog : pflr+1)
#define PrevFreeLogRec( pflr )    ((pflr <= aflrFreeLog) ? &aflrFreeLog[CFLR_MAX-1] : pflr-1)

//***************************************************************
//
// void DbgPrintf( LPTSTR szFmt, ... )
//
//  Formatted version of OutputDebugString
//
//  Parameters: Same as printf()
//
//  History:
//      18-Jan-1996 JonPa       Wrote it
//***************************************************************
void DbgPrintf( LPTSTR szFmt, ... ) {
    va_list marker;

    va_start( marker, szFmt );

    wvsprintf( szDbgOutBuffer, szFmt, marker );
    OutputDebugString( szDbgOutBuffer );

    va_end( marker );
}


//***************************************************************
//
// void DbgStopX(LPSTR mszFile, int iLine, LPTSTR szText )
//
//  Print a string (with location id) and then break
//
//  Parameters:
//      mszFile     ANSI filename (__FILE__)
//      iLine       line number   (__LINE__)
//      szText      Text string to send to debug port
//
//  History:
//      18-Jan-1996 JonPa       Wrote it
//***************************************************************
void DbgStopX(LPSTR mszFile, int iLine, LPTSTR szText )
{
    wsprintf( szDbgOutBuffer, TEXT("SYSDM.CPL (%hs %d) : %s\n"), mszFile, iLine, szText );

    OutputDebugString(szDbgOutBuffer);

    DebugBreak();
}

//***************************************************************
//
// void MemAllocWorker(LPSTR szFile, int iLine, UINT uFlags, UINT cBytes)
//
//  Debug replacement for LocalAlloc
//
//  Parameters:
//      mszFile     ANSI filename (__FILE__)
//      iLine       line number   (__LINE__)
//      uFlags      same as LocalAlloc
//      cBytes      same as LocalAlloc
//
//  History:
//      18-Jan-1996 JonPa       Wrote it
//***************************************************************
HLOCAL MemAllocWorker(LPSTR szFile, int iLine, UINT uFlags, UINT cBytes) {
    PHHO phhoNew;
    HLOCAL hMem;
    LPSTR psz;
    UINT i, cBytesAlloc;

    cBytesAlloc = cBytes;

    //
    // If fixed alloc...
    //
    if ((uFlags & (LMEM_MOVEABLE | LMEM_DISCARDABLE)) != 0) {
        DBGSTOPX( szFile, iLine, "Attempting to allocate movable memory... Returning NULL");
        return NULL;
    }

    cBytesAlloc = cBytes + sizeof(HOBJHDR);

    // DWORD align Tag
    cBytesAlloc = ((cBytesAlloc + 3) & ~3);
    cBytesAlloc += CB_TAG;


    hMem = LocalAlloc( uFlags, cBytesAlloc );

    //
    // If a valid pointer, and it is a fixed pointer...
    //
    phhoNew = (PHHO)hMem;

    if (hMem != NULL) {


        phhoNew->phhoNext = hhoRoot.phhoNext;
        hhoRoot.phhoNext = phhoNew;
        phhoNew->phhoNext->phhoPrev = phhoNew;
        phhoNew->phhoPrev = &hhoRoot;

        phhoNew->dwTag2 = DW_TAG2;

        for( psz = szFile; *psz != '\0'; psz++ );

        for( ; psz != szFile && *psz != ':' && *psz != '/' && *psz != '\\'; psz--);
        if (*psz == ':' || *psz == '/' || *psz == '\\')
            psz++;

        for( i = 0; i < CCH_LABEL; i++ ) {
            phhoNew->szFile[i] = *psz;
            if (*psz) {
                psz++;
            }
        }

        phhoNew->iLine = iLine;

        phhoNew->cBytesData = cBytes;

        phhoNew += 1;   // point phhoNew to 1st byte after structure

        // round up to nearest DWORD
        { LPBYTE pb = (LPBYTE)phhoNew + cBytes;

            cBytesAlloc -= CB_TAG;
            cBytes += sizeof(HOBJHDR);

            while( cBytes < cBytesAlloc ) {
                *pb++ = CH_FILL;
                cBytes++;
            }

            *((LPDWORD)pb) = DW_TAG;
        }
    }

    return (HLOCAL)phhoNew;
}

//***************************************************************
//
// void MemFreeWorker( LPSTR szFile, int iLine, HLOCAL hMem )
//
//  Debug replacement for LocalFree
//
//  Parameters:
//      mszFile     ANSI filename (__FILE__)
//      iLine       line number   (__LINE__)
//      hMem        same as LocalAlloc
//
//  History:
//      18-Jan-1996 JonPa       Wrote it
//***************************************************************
HLOCAL MemFreeWorker( LPSTR szFile, int iLine, HLOCAL hMem )
{
    PHHO phhoMem;
    UINT cBytes, cBytesAlloc;
    LPSTR psz;
    INT  i;


    if (g_pflrUnused == NULL) {
        ZeroMemory( aflrFreeLog, sizeof(aflrFreeLog) );
        g_pflrUnused = aflrFreeLog;
    }

    if (hMem == NULL) {
        DBGSTOPX( szFile, iLine, "Freeing NULL handle!");
        return LocalFree(hMem);
    }

    phhoMem = (PHHO)hMem - 1;

    if (phhoMem->dwTag2 != DW_TAG2) {
        PFREELOGREC pflr;
        //
        // Our tag has been stompped on, see if we have already freed this object
        //
        for( pflr = PrevFreeLogRec(g_pflrUnused); pflr != g_pflrUnused; pflr = PrevFreeLogRec(pflr) ) {
            if (pflr->pvPtr == phhoMem) {
                DBGPRINTF((TEXT("SYSDM.CPL: Object may have already been freed by %.8hs line %d\n(that obj was allocated by %.8hs line %d)\n"),
                    pflr->szFreedBy, pflr->iLineFreed, pflr->szFile, pflr->iLine));
                break;
            }
        }

        DBGPRINTF((TEXT("SYSDM.CPL: Trashed memory object was allocated in %.8hs line %d (%d bytes)\n"), phhoMem->szFile, phhoMem->iLine, phhoMem->cBytesData));
        DBGSTOPX( szFile, iLine, "Either heap object trashed or not allocated object");
    }

    cBytes = phhoMem->cBytesData;

#if 0
    if (cBytes < 0) {
        // Not our object?
        DBGSTOPX( szFile, iLine, "Either heap object trashed or not allocated object");
        return LocalFree(hMem);
    }
#endif

    cBytes += sizeof(HOBJHDR);

    // DWORD align
    cBytesAlloc = (cBytes + 3) & ~3;

    { LPBYTE pb = (LPBYTE)(phhoMem);
        pb += cBytes;
        while( cBytes < cBytesAlloc ) {
            if (*pb++ != CH_FILL) {
                DBGPRINTF((TEXT("SYSDM.CPL: Trashed memory object was allocated in %.8hs line %d (%d bytes)\n"),
                        phhoMem->szFile, phhoMem->iLine, phhoMem->cBytesData));
                DBGSTOPX( szFile, iLine, "End of structure overwritten");
            }
            cBytes++;
        }

        if (*((LPDWORD)pb) != DW_TAG) {
            DBGSTOPX( szFile, iLine, "Freeing structure that was not allocated!");

            // Not our structure
            return LocalFree(hMem);
        }
    }

    // Our structure, check header
    if (phhoMem->phhoNext->phhoPrev != phhoMem || phhoMem->phhoPrev->phhoNext != phhoMem ) {
        DBGPRINTF((TEXT("SYSDM.CPL: Orphaned memory object was allocated in %.8hs line %d (%d bytes)\n"),
                phhoMem->szFile, phhoMem->iLine, phhoMem->cBytesData));
        DBGSTOPX( szFile, iLine, "Attempting to free orphaned memory object");
    }

    phhoMem->phhoPrev->phhoNext = phhoMem->phhoNext;
    phhoMem->phhoNext->phhoPrev = phhoMem->phhoPrev;

    //
    // Log this free, incase we try and free it twice
    //

    // Mark as freed
    phhoMem->dwTag2 = 0;

    // Remember who alloc'ed obj
    g_pflrUnused->pvPtr = phhoMem;
    CopyMemory( g_pflrUnused->szFile, phhoMem->szFile, sizeof(g_pflrUnused->szFile) );
    g_pflrUnused->iLine = phhoMem->iLine;

    // Remember who freed the obj
    for( psz = szFile; *psz != '\0'; psz++ );

    for( ; psz != szFile && *psz != ':' && *psz != '/' && *psz != '\\'; psz--);
    if (*psz == ':' || *psz == '/' || *psz == '\\')
        psz++;

    for( i = 0; i < CCH_LABEL; i++ ) {
        g_pflrUnused->szFreedBy[i] = *psz;
        if (*psz) {
            psz++;
        }
    }
    g_pflrUnused->iLineFreed = iLine;

    // Point roaming ptr to next record and mark as unused
    g_pflrUnused = NextFreeLogRec(g_pflrUnused);
    ZeroMemory( g_pflrUnused, sizeof(*g_pflrUnused) );

    return LocalFree(phhoMem);
}

//***************************************************************
//
//  void MemExitCheckWorker() {
//
//  Debug replacement for LocalFree
//
//  Parameters:
//      mszFile     ANSI filename (__FILE__)
//      iLine       line number   (__LINE__)
//      hMem        same as LocalAlloc
//
//  History:
//      18-Jan-1996 JonPa       Wrote it
//***************************************************************
void MemExitCheckWorker( void ) {
    PHHO phho;

    for( phho = hhoRoot.phhoNext; phho != &hhoRoot; phho = phho->phhoNext ) {
        DBGPRINTF((TEXT("SYSDM.CPL: Exiting with out freeing object allocated in %.8hs line %d (%d bytes)\n"),
                phho->szFile, phho->iLine, phho->cBytesData));
    }
}

#endif // DBG_CODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\edtenvar.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    edtenvar.h

Abstract:

    Public declarations for the Edit Environment Variables dialog of the
    System Control Panel Applet
    
Author:

    Scott Hallock (scotthal) 11-Nov-1997

Revision History:


--*/

//
// Preprocessor definitions
//
#define SYSTEM_VAR        1
#define USER_VAR          2
#define INVALID_VAR_TYPE  0xeeee

#define EDIT_VAR          1
#define NEW_VAR           2
#define INVALID_EDIT_TYPE 0xeeee

#define EDIT_NO_CHANGE    0
#define EDIT_CHANGE       1
#define EDIT_ERROR       (-1)

#define EDIT_ENVVAR_CAPTION_LENGTH 128

//
// Global variables
//
extern UINT g_VarType;
extern UINT g_EditType;
extern TCHAR g_szVarName[BUFZ];
extern TCHAR g_szVarValue[BUFZ];

//
// Function prototypes
//
INT_PTR
APIENTRY
EnvVarsEditDlg(
    IN HWND hDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\advanced.c ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    advanced.c

Abstract:

    Implements the Advanced tab of the System Control Panel Applet.

Author:

    Scott Hallock (scotthal) 15-Oct-1997

--*/
#include "sysdm.h"

//
// Help IDs
//
DWORD aAdvancedHelpIds[] = {
    IDC_ADV_PERF_TEXT,             (IDH_ADVANCED + 0),
    IDC_ADV_PERF_BTN,              (IDH_ADVANCED + 1),
    IDC_ADV_ENV_TEXT,              (IDH_ADVANCED + 2),
    IDC_ADV_ENV_BTN,               (IDH_ADVANCED + 3),
    IDC_ADV_RECOVERY_TEXT,         (IDH_ADVANCED + 4),
    IDC_ADV_RECOVERY_BTN,          (IDH_ADVANCED + 5),
    IDC_ADV_PROF_TEXT,             (IDH_ADVANCED + 6),
    IDC_ADV_PROF_BTN,              (IDH_ADVANCED + 7),
    IDC_ADV_PFR_BTN,               (IDH_PFR + 99),
    0, 0
};
//
// Private function prototypes
//
BOOL
AdvancedHandleCommand(
    IN HWND hDlg,
    IN WPARAM wParam,
    IN LPARAM lParam
);

BOOL
AdvancedHandleNotify(
    IN HWND hDlg,
    IN WPARAM wParam,
    IN LPARAM lParam
);


INT_PTR
APIENTRY
AdvancedDlgProc(
    IN HWND hDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
)
/*++

Routine Description:

    Handles messages sent to the Advanced page

Arguments:

    hDlg -
        Window handle

    uMsg -
        Message being sent

    wParam -
        Message parameter

    lParam -
        Message parameter

Return Value:

    TRUE if message was handled
    FALSE if message was unhandled

--*/
{

    switch (uMsg) {
        case WM_COMMAND:
            return(AdvancedHandleCommand(hDlg, wParam, lParam));
            break;

        case WM_NOTIFY:
            return(AdvancedHandleNotify(hDlg, wParam, lParam));
            break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP, (DWORD_PTR) (LPSTR) aAdvancedHelpIds);
            break;
    
        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) aAdvancedHelpIds);
            break;

        default:
            return(FALSE);
    } // switch

    return(TRUE);

}

static const PSPINFO c_pspPerf[] =
{
    { CreatePage,   IDD_VISUALEFFECTS,  VisualEffectsDlgProc    },
    { CreatePage,   IDD_ADVANCEDPERF,   PerformanceDlgProc      },
};

void DoPerformancePS(HWND hDlg)
{
    PROPSHEETHEADER psh;
    HPROPSHEETPAGE rPages[ARRAYSIZE(c_pspPerf)];
    int i;

    //
    // Property sheet stuff.
    //
    psh.dwSize = SIZEOF(psh);
    psh.dwFlags = PSH_DEFAULT;
    psh.hInstance = hInstance;
    psh.hwndParent = hDlg;
    psh.pszCaption = MAKEINTRESOURCE(IDS_PERFOPTIONS);
    psh.nPages = 0;
    psh.nStartPage = 0;
    psh.phpage = rPages;

    for (i = 0; i < ARRAYSIZE(c_pspPerf); i++)
    {
        rPages[psh.nPages] = c_pspPerf[i].pfnCreatePage(c_pspPerf[i].idd, c_pspPerf[i].pfnDlgProc);
        if (rPages[psh.nPages] != NULL)
        {
            psh.nPages++;
        }
    }

    //
    // Display the property sheet.
    //
    PropertySheet(&psh);
}

BOOL
AdvancedHandleCommand(
    IN HWND hDlg,
    IN WPARAM wParam,
    IN LPARAM lParam
)
/*++

Routine Description:

    Handles WM_COMMAND messages sent to Advanced tab

Arguments:

    hDlg -
        Supplies window handle

    wParam -
        Supplies message parameter

    lParam -
        Supplies message parameter

Return Value:

    TRUE if message was handled
    FALSE if message was unhandled

--*/
{
    DWORD_PTR dwResult = 0;

    switch (LOWORD(wParam))
    {
        case IDC_ADV_PERF_BTN:
            DoPerformancePS(hDlg);        
            break;
    
        case IDC_ADV_PROF_BTN:
        {
            dwResult = DialogBox(
                hInstance,
                (LPTSTR) MAKEINTRESOURCE(IDD_USERPROFILE),
                hDlg,
                UserProfileDlgProc);
            break;
        }

        case IDC_ADV_ENV_BTN:
            dwResult = DialogBox(
                hInstance,
                (LPTSTR) MAKEINTRESOURCE(IDD_ENVVARS),
                hDlg,
                EnvVarsDlgProc
            );

            break;

        case IDC_ADV_RECOVERY_BTN:
            dwResult = DialogBox(
                hInstance,
                (LPTSTR) MAKEINTRESOURCE(IDD_STARTUP),
                hDlg,
                StartupDlgProc
            );

            break;

        case IDC_ADV_PFR_BTN:
        {
            INITCOMMONCONTROLSEX    icex;
            OSVERSIONINFOEXW        osvi;
            UINT                    uiDlg;

            icex.dwSize = sizeof(icex);
            icex.dwICC  = ICC_LISTVIEW_CLASSES;

            if (InitCommonControlsEx(&icex) == FALSE)
                MessageBoxW(NULL, L"ICEX failed.", NULL, MB_OK);

            ZeroMemory(&osvi, sizeof(osvi));
            osvi.dwOSVersionInfoSize = sizeof(osvi);
            GetVersionEx((LPOSVERSIONINFOW)&osvi);

            if (osvi.wProductType == VER_NT_WORKSTATION)
                uiDlg = IDD_PFR_REPORT;
            else
                uiDlg = IDD_PFR_REPORTSRV;

            dwResult = DialogBox(hInstance, MAKEINTRESOURCE(uiDlg),
                                 hDlg, PFRDlgProc);
            break;
        }

        default:
            return(FALSE);
    } // switch

    return(TRUE);

}


BOOL
AdvancedHandleNotify(
    IN HWND hDlg,
    IN WPARAM wParam,
    IN LPARAM lParam
)
/*++

Routine Description:

    Handles WM_NOTIFY messages sent to Advanced tab

Arguments:

    hDlg -
        Supplies window handle

    wParam -
        Supplies message parameter

    lParam -
        Supplies message parameter

Return Value:

    TRUE if message was handled
    FALSE if message was unhandled

--*/
{
    LPNMHDR pnmh = (LPNMHDR) lParam;
    LPPSHNOTIFY psh = (LPPSHNOTIFY) lParam;

    switch (pnmh->code) {
        case PSN_APPLY:
            //
            // If the user is pressing "OK" and a reboot is required,
            // send the PSM_REBOOTSYSTEM message.
            //
            if ((psh->lParam) && g_fRebootRequired) {
                PropSheet_RebootSystem(GetParent(hDlg));
            } // if

            break;

        default:
            return(FALSE);

    } // switch

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\crashdmp.c ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    crashdmp.c

Abstract:

    Implements the "Recovery" group on the Startup/Recovery
    dialog of the System Control Panel Applet

Notes:

    The virtual memory settings and the crash dump (core dump) settings
    are tightly-coupled.  Therefore, crashdmp.c and startup.h have some
    heavy dependencies on virtual.c and virtual.h (and vice versa).

Author:

    Byron Dazey 06-Jun-1992

Revision History:

    15-Oct-1997 scotthal
        Complete overhaul

--*/

#include "sysdm.h"
#include <windowsx.h>

#define KBYTE (1024UI64)
#define MBYTE (1024UI64 * KBYTE)
#define GBYTE (1024UI64 * MBYTE)

//
// CrashDumpEnabled is not a boolean value anymore. It can take on one of the
// following types.
//

#define DUMP_TYPE_NONE              (0)
#define DUMP_TYPE_MINI              (1)
#define DUMP_TYPE_SUMMARY           (2)
#define DUMP_TYPE_FULL              (3)
#define DUMP_TYPE_MAX               (4)

#define REG_LOG_EVENT_VALUE_NAME    TEXT ("LogEvent")
#define REG_SEND_ALERT_VALUE_NAME   TEXT ("SendAlert")
#define REG_OVERWRITE_VALUE_NAME    TEXT ("Overwrite")
#define REG_AUTOREBOOT_VALUE_NAME   TEXT ("AutoReboot")
#define REG_DUMPFILE_VALUE_NAME     TEXT ("DumpFile")
#define REG_MINIDUMP_DIR_VALUE_NAME TEXT ("MinidumpDir")
#define REG_DUMP_TYPE_VALUE_NAME    TEXT ("CrashDumpEnabled")

#define BIG_MEMORY_MAX_BOOT_PF_MB   (2048)
#define CRASH_CONTROL_KEY           TEXT("System\\CurrentControlSet\\Control\\CrashControl")

//
// The crashdump code is hard-coded to generate only summary dumps for
// machines with more than 2 GB of physical memory. Do not change this
// constant unless unless you change the same code in ntos\io\dumpctl.c
//

#define LARGE_MEMORY_THRESHOLD      (2 * GBYTE)

typedef struct _SYSTEM_MEMORY_CONFIGURATION {
    BOOL    BigMemory;
    ULONG   PageSize;
    ULONG64 PhysicalMemorySize;
    ULONG64 BootPartitionPageFileSize;
    TCHAR   BootDrive;
} SYSTEM_MEMORY_CONFIGURATION;

VCREG_RET gvcCrashCtrl =  VCREG_ERROR;
HKEY ghkeyCrashCtrl = NULL;
int  gcrefCrashCtrl = 0;
BOOL gfCoreDumpChanged = FALSE;

TCHAR CrashDumpFile [MAX_PATH] = TEXT("%SystemRoot%\\MEMORY.DMP");
TCHAR MiniDumpDirectory [MAX_PATH] = TEXT("%SystemRoot%\\Minidump");
TCHAR DumpFileText [100];
TCHAR MiniDumpDirText [100];

SYSTEM_MEMORY_CONFIGURATION SystemMemoryConfiguration;

//
// Private function prototypes
//

DWORD
GetDumpSelection(
    HWND hDlg
    );

NTSTATUS
GetMemoryConfiguration(
    OUT SYSTEM_MEMORY_CONFIGURATION * MemoryConfig
    );

VOID
DisableCoreDumpControls(
    HWND hDlg
    );

static
BOOL
CoreDumpInit(
    IN HWND hDlg
    );

static
BOOL
CoreDumpUpdateRegistry(
    IN HWND hDlg,
    IN HKEY hKey
    );

int
CoreDumpHandleOk(
    IN BOOL fInitialized,
    IN HWND hDlg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );


VOID
SwapDumpSelection(
    HWND hDlg
    );
//
// Implementation
//

VCREG_RET
CoreDumpOpenKey(
    )
{
    if (gvcCrashCtrl == VCREG_ERROR) {
        gvcCrashCtrl = OpenRegKey( CRASH_CONTROL_KEY, &ghkeyCrashCtrl );
    }

    if (gvcCrashCtrl != VCREG_ERROR) {
        gcrefCrashCtrl++;
    }

    return gvcCrashCtrl;
}

void
CoreDumpCloseKey(
    )
{
    if (gcrefCrashCtrl > 0) {
        gcrefCrashCtrl--;
        if (gcrefCrashCtrl == 0) {
            CloseRegKey( ghkeyCrashCtrl );
            gvcCrashCtrl = VCREG_ERROR;
        }
    }
}




BOOL
StartAlerterService(
    IN SC_HANDLE hAlerter
    )
{
    BOOL fResult = FALSE;

    fResult = ChangeServiceConfig(
        hAlerter,
        SERVICE_NO_CHANGE,
        SERVICE_AUTO_START,
        SERVICE_NO_CHANGE,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
    );

    fResult = StartService(hAlerter, 0, NULL);

    return(fResult);

}

BOOL
IsAlerterSvcStarted(
    HWND hDlg
    )
{
    SC_HANDLE schSCManager, schService = NULL;
    LPQUERY_SERVICE_CONFIG lpqscBuf;
    DWORD dwBytesNeeded;
    BOOL fRunning = FALSE;
    SERVICE_STATUS ssSrvcStat;


    /*
     * Open the Service Controller
     */
    schSCManager = OpenSCManager(
         NULL,                   /* local machine           */
         NULL,                   /* ServicesActive database */
         SC_MANAGER_ALL_ACCESS); /* full access rights      */

    if (schSCManager == NULL) {
        goto iassExit;
    }


    /*
     * Try to open the Alerter Service
     */


    /* Open a handle to the service. */

    schService = OpenService(
         schSCManager,           /* SCManager database  */
         TEXT("Alerter"),        /* name of service     */
         SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG | SERVICE_CHANGE_CONFIG | SERVICE_START
    );

    if (schService == NULL) {
        goto iassExit;
    }

    /*
     * Query the Alerter service to see if it has been started
     */

    if (!QueryServiceStatus(schService, &ssSrvcStat )) {
        goto iassExit;
    }


    if (ssSrvcStat.dwCurrentState != SERVICE_RUNNING) {
        fRunning = StartAlerterService(schService);
    } else {

        fRunning = TRUE;
    }


iassExit:
    if (!fRunning) {
        MsgBoxParam(hDlg, IDS_SYSDM_NOALERTER, IDS_SYSDM_TITLE, MB_ICONEXCLAMATION );
    }

    if (schService != NULL) {
        CloseServiceHandle(schService);
    }

    if (schSCManager != NULL) {
        CloseServiceHandle(schSCManager);
    }

    return fRunning;
}


BOOL
VerifyDumpPath(
    IN HWND hDlg
    )
{
    
    TCHAR szPath[MAX_PATH];
    TCHAR szExpPath[MAX_PATH];
    LPTSTR psz;
    TCHAR ch;
    UINT uType;

    if( GetDlgItemText(hDlg, IDC_STARTUP_CDMP_FILENAME, szPath,
            ARRAYSIZE(szPath)) == 0) {

        MsgBoxParam(hDlg, IDS_SYSDM_DEBUGGING_FILENAME, IDS_SYSDM_TITLE, MB_ICONSTOP | MB_OK);
        return FALSE;
    }

    /*
     * Expand any environment vars, and then check to make sure it
     * is a fully quallified path
     */
     
    // if it has a '%' in it, then try to expand it
    
    if (ExpandEnvironmentStrings(szPath, szExpPath, ARRAYSIZE(szExpPath)) >= ARRAYSIZE(szExpPath)) {
        MsgBoxParam(hDlg, IDS_SYSDM_DEBUGGING_PATHLONG, IDS_SYSDM_TITLE, MB_ICONSTOP | MB_OK,
                (DWORD)MAX_PATH);
        return FALSE;
    }

    // now cannonicalize it

    GetFullPathName( szExpPath, ARRAYSIZE(szPath), szPath, &psz );

    // check to see that it already was cannonicalized

    if (lstrcmp( szPath, szExpPath ) != 0) {
        MsgBoxParam(hDlg, IDS_SYSDM_DEBUGGING_UNQUALIFIED, IDS_SYSDM_TITLE, MB_ICONSTOP | MB_OK );
        return FALSE;
    }

    /*
     * check the drive (don't allow remote)
     */

    ch = szPath[3];
    szPath[3] = TEXT('\0');
    if (IsPathSep(szPath[0]) || ((uType = GetDriveType(szPath)) !=
            DRIVE_FIXED && uType != DRIVE_REMOVABLE)) {
        MsgBoxParam(hDlg, IDS_SYSDM_DEBUGGING_DRIVE, IDS_SYSDM_TITLE, MB_ICONSTOP | MB_OK );
        return FALSE;
    }
    szPath[3] = ch;

    /*
     * if path is non-exstant, tell user and let him decide what to do
     */

    if (GetFileAttributes(szPath) == 0xFFFFFFFFL && GetLastError() !=
        ERROR_FILE_NOT_FOUND && MsgBoxParam(hDlg, IDS_SYSDM_DEBUGGING_PATH, IDS_SYSDM_TITLE,
            MB_ICONQUESTION | MB_YESNO ) == IDYES) {
        return FALSE;
    }

    return TRUE;
}

    
    

BOOL
CoreDumpValidFile(
    HWND hDlg
    )
{
    switch (GetDumpSelection (hDlg)) {

        case DUMP_TYPE_NONE:
            return TRUE;

        case DUMP_TYPE_MINI:
            return VerifyDumpPath (hDlg);
            

        case DUMP_TYPE_SUMMARY:
        case DUMP_TYPE_FULL:
            return VerifyDumpPath (hDlg);
            
        default:
            ASSERT (FALSE);
            return TRUE;
    }

    return FALSE;
}


int
APIENTRY
CoreDumpDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static BOOL fInitialized = FALSE;

    switch (message)
    {
    case WM_INITDIALOG:
        g_fStartupInitializing = TRUE;
        fInitialized = CoreDumpInit(hDlg);
        g_fStartupInitializing = FALSE;
        return RET_CONTINUE;
        break;

    case WM_COMMAND:

        switch (LOWORD(wParam)) {
            case IDOK:
                return(CoreDumpHandleOk(fInitialized, hDlg, wParam, lParam));
                break;

            case IDCANCEL:
                if (fInitialized) {
                    VirtualCloseKey();
                    CoreDumpCloseKey();
                }
                // Let the Startup/Recovery dlg proc also handle IDOK
                return(RET_NO_CHANGE);
                break;

            case IDC_STARTUP_CDMP_TYPE: {
                SwapDumpSelection (hDlg);
            }
            // Fall through

            case IDC_STARTUP_CDMP_FILENAME:
            case IDC_STARTUP_CDMP_LOG:
            case IDC_STARTUP_CDMP_SEND:
            case IDC_STARTUP_CDMP_OVERWRITE:
            case IDC_STARTUP_CDMP_AUTOREBOOT:
                if (!g_fStartupInitializing) {
                    gfCoreDumpChanged = TRUE;
                }
                break;
            default: {
                // indicat not handled
                return RET_CONTINUE;
            }
        }
        break; // WM_COMMAND

    case WM_DESTROY:
        return RET_CONTINUE;
        break;

    default:
        return RET_CONTINUE;
    }

    return RET_BREAK;
}

int
CoreDumpHandleOk(
    IN BOOL fInitialized,
    IN HWND hDlg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL fRegChg;
    NTSTATUS Status;
    DWORD Ret;
    int iRet = RET_NO_CHANGE;
    SYSTEM_MEMORY_CONFIGURATION MemoryConfig = {0};

    if (fInitialized && gfCoreDumpChanged)
    {
        // Validate crashdump file name.
        if (!CoreDumpValidFile(hDlg))
        {
            SetFocus(GetDlgItem(hDlg, IDC_STARTUP_CDMP_FILENAME));
            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
            iRet = RET_ERROR;
            return iRet;
        }


        Status = GetMemoryConfiguration(&MemoryConfig);

        if (NT_SUCCESS (Status) &&
            MemoryConfig.BootPartitionPageFileSize <
            CoreDumpGetRequiredFileSize (hDlg))
        {
            // Warn that the dump file may be truncated.
            Ret = MsgBoxParam (hDlg,
                               IDS_SYSDM_DEBUGGING_MINIMUM,
                               IDS_SYSDM_TITLE,
                               MB_ICONEXCLAMATION | MB_YESNO,
                               (MemoryConfig.BootDrive ? MemoryConfig.BootDrive : TEXT('?')),
                               (DWORD) (CoreDumpGetRequiredFileSize (hDlg) / MBYTE)
                               );

            if (Ret == IDNO)
            {
                return RET_ERROR;
            }
        }

        // If the Alert button is checked, make sure the alerter service
        // is started.
        if (IsDlgButtonChecked(hDlg, IDC_STARTUP_CDMP_SEND))
        {
            IsAlerterSvcStarted(hDlg);
        }

        fRegChg = CoreDumpUpdateRegistry (hDlg, ghkeyCrashCtrl);

        // Clean up registry stuff
        CoreDumpCloseKey();
        VirtualCloseKey();

        if (fRegChg)
        {
            // Notify the kernel to reread the crashdump parameters from the registry.
            Status = NtSetSystemInformation(SystemCrashDumpStateInformation, NULL, 0);
            if (NT_SUCCESS(Status))
            {
                iRet = RET_CHANGE_NO_REBOOT;
            }
            else
            {
                iRet = RET_RECOVER_CHANGE;
            }
        }
    } else {
        iRet = RET_NO_CHANGE;
    }

    return(iRet);
}

void
CoreDumpInitErrorExit(
    HWND hDlg,
    HKEY hk
    )
{
    MsgBoxParam(hDlg, IDS_SYSDM_NOOPEN_RECOVER_GROUP, IDS_SYSDM_TITLE, MB_ICONEXCLAMATION);
    if( hk == ghkeyMemMgt )
        VirtualCloseKey();

    DisableCoreDumpControls(hDlg);

    HourGlass(FALSE);
    return;
}


DWORD
GetDumpSelection(
    HWND hDlg
    )
{
    HWND hControl;

    hControl = GetDlgItem (hDlg, IDC_STARTUP_CDMP_TYPE);
    return ComboBox_GetCurSel ( hControl );
}

VOID
DisableCoreDumpControls(
    HWND hDlg
    )
{
    EnableWindow( GetDlgItem (hDlg, IDC_STARTUP_CDMP_GRP), FALSE);
    EnableWindow( GetDlgItem (hDlg, IDC_STARTUP_CDMP_TXT1), FALSE);
    EnableWindow( GetDlgItem (hDlg, IDC_STARTUP_CDMP_LOG ), FALSE);
    EnableWindow( GetDlgItem (hDlg, IDC_STARTUP_CDMP_SEND), FALSE);
    EnableWindow( GetDlgItem (hDlg, IDC_STARTUP_CDMP_TYPE), FALSE);
    EnableWindow( GetDlgItem (hDlg, IDC_STARTUP_CDMP_FILENAME), FALSE);
    EnableWindow( GetDlgItem (hDlg, IDC_STARTUP_CDMP_OVERWRITE), FALSE);
    EnableWindow( GetDlgItem (hDlg, IDC_STARTUP_CDMP_AUTOREBOOT), FALSE);
}

VOID
SwapDumpSelection(
    HWND hDlg
    )
{
    //
    // If there is no dump type, disable some controls. If this is a minidump
    // disable overwrite and change "File Name:" to "Mini Dump Directory:"
    //

    switch (GetDumpSelection (hDlg)) {

        case DUMP_TYPE_NONE:
            EnableWindow (GetDlgItem (hDlg, IDC_STARTUP_CDMP_OVERWRITE), FALSE);
            EnableWindow (GetDlgItem (hDlg, IDC_STARTUP_CDMP_FILENAME), FALSE);
            EnableWindow (GetDlgItem (hDlg, IDC_STARTUP_CDMP_FILE_LABEL), FALSE);
            SetWindowText (GetDlgItem (hDlg, IDC_STARTUP_CDMP_FILENAME),
                           CrashDumpFile
                           );
            Static_SetText (GetDlgItem (hDlg, IDC_STARTUP_CDMP_FILE_LABEL),
                            DumpFileText
                            );
            break;

        case DUMP_TYPE_MINI:
            EnableWindow (GetDlgItem (hDlg, IDC_STARTUP_CDMP_OVERWRITE), FALSE);
            EnableWindow (GetDlgItem (hDlg, IDC_STARTUP_CDMP_FILENAME), TRUE);
            EnableWindow (GetDlgItem (hDlg, IDC_STARTUP_CDMP_FILE_LABEL), TRUE);
            SetWindowText (GetDlgItem (hDlg, IDC_STARTUP_CDMP_FILENAME),
                           MiniDumpDirectory
                           );
            Static_SetText (GetDlgItem (hDlg, IDC_STARTUP_CDMP_FILE_LABEL),
                            MiniDumpDirText
                            );
            break;

        default:
            EnableWindow (GetDlgItem (hDlg, IDC_STARTUP_CDMP_OVERWRITE), TRUE);
            EnableWindow (GetDlgItem (hDlg, IDC_STARTUP_CDMP_FILENAME), TRUE);
            EnableWindow (GetDlgItem (hDlg, IDC_STARTUP_CDMP_FILE_LABEL), TRUE);
            SetWindowText (GetDlgItem (hDlg, IDC_STARTUP_CDMP_FILENAME),
                           CrashDumpFile
                           );
            Static_SetText (GetDlgItem (hDlg, IDC_STARTUP_CDMP_FILE_LABEL),
                             DumpFileText
                             );
    }
}

BOOL
GetSystemDrive(
    OUT TCHAR * Drive
    )
{
    TCHAR WindowsDir [ MAX_PATH ];

    if (!GetWindowsDirectory (WindowsDir, ARRAYSIZE (WindowsDir))) {
        return FALSE;
    }

    if (!isalpha (*WindowsDir)) {
        return FALSE;
    }

    *Drive = *WindowsDir;

    return TRUE;
}

NTSTATUS
GetMemoryConfiguration(
    OUT SYSTEM_MEMORY_CONFIGURATION * MemoryConfig
    )
{
    BOOL Succ;
    TCHAR SystemDrive;
    NTSTATUS Status;
    SYSTEM_BASIC_INFORMATION BasicInfo;
    ULONGLONG iMaxPageFileSize;

    Status = NtQuerySystemInformation(
                        SystemBasicInformation,
                        &BasicInfo,
                        sizeof (BasicInfo),
                        NULL
                        );

    if (NT_SUCCESS (Status)) {
        Status;
    }

    MemoryConfig->PhysicalMemorySize =
            (ULONG64) BasicInfo.NumberOfPhysicalPages *
            (ULONG64) BasicInfo.PageSize;

    MemoryConfig->PageSize = BasicInfo.PageSize;

    //
    // Get the Boot-partition pagefile size.
    //

    Succ = GetSystemDrive (&SystemDrive);

    if (!Succ) {
        return FALSE;
    }

    MemoryConfig->BootDrive = (WCHAR) toupper (SystemDrive);

    SystemDrive = tolower (SystemDrive) - 'a';

    //
    // A big memory machine is one that has more memory than we can write to
    // at crashdump time.
    //

    iMaxPageFileSize = GetMaxPagefileSizeInMB(SystemDrive);
    iMaxPageFileSize *= (1024 * 1024); // MaxPageFileSize stored in megabytes
    if ((ULONGLONG)MemoryConfig->PhysicalMemorySize >= iMaxPageFileSize) { 
        MemoryConfig->BigMemory = TRUE;
    } else {
        MemoryConfig->BigMemory = FALSE;
    }

    //
    // NOTE: apf is a global exposed by virtual.c
    //

    Succ = VirtualGetPageFiles ( apf );

    if (!Succ) {
        return FALSE;
    }

    //
    // This is the file size in terms of megabytes.
    //

    MemoryConfig->BootPartitionPageFileSize = apf [ SystemDrive ].nMinFileSize;

    //
    // Convert to bytes.
    //

    MemoryConfig->BootPartitionPageFileSize *= MBYTE;

    VirtualFreePageFiles ( apf );

    return STATUS_SUCCESS;

}

BOOL
CheckInitFromRegistry(
    IN HWND hDlg,
    IN DWORD ControlId,
    IN HKEY RegKey,
    IN LPTSTR ValueName,
    IN BOOL Default
    )
{
    BOOL Succ;
    DWORD Type;
    DWORD Data;
    BOOL DataSize;
    BOOL Value;

    DataSize = sizeof (Data);

    Succ = RegQueryValueEx (
                     RegKey,
                     ValueName,
                     NULL,
                     &Type,
                     (LPBYTE) &Data,
                     &DataSize
                     );

    if (Succ != ERROR_SUCCESS || Type != REG_DWORD) {
        Value = Default;
    } else {
        Value = Data ? TRUE : FALSE;
    }

    return CheckDlgButton (hDlg, ControlId, Value);
}


BOOL
ComboAddStringFromResource(
    IN HWND hDlg,
    IN DWORD ControlId,
    IN HINSTANCE ModuleHandle,
    IN DWORD ResourceId,
    IN DWORD ItemData
    )
{
    DWORD Res;
    DWORD Item;
    HWND hControl;
    DWORD Result;
    WCHAR Buffer[512];

    Res = LoadString(ModuleHandle, ResourceId, Buffer, ARRAYSIZE(Buffer));
    if (Res == 0)
    {
        return FALSE;
    }

    hControl = GetDlgItem(hDlg, ControlId);
    Item = ComboBox_InsertString(hControl, -1, Buffer);
    ComboBox_SetItemData(hControl, Item, ItemData);

    return TRUE;
}


BOOL
StoreCheckboxToReg(
    IN HWND hDlg,
    IN DWORD ControlId,
    IN HKEY hKey,
    IN LPCTSTR RegValueName
    )
{
    DWORD Checked;

    Checked = IsDlgButtonChecked (hDlg, ControlId);

    RegSetValueEx(
            hKey,
            RegValueName,
            0,
            REG_DWORD,
            (LPBYTE) &Checked,
            sizeof (Checked)
            );

    return TRUE;
}


BOOL
StoreStringToReg(
    IN HWND hDlg,
    IN DWORD ControlId,
    IN HKEY hKey,
    IN LPCTSTR RegValueName
    )
{
    TCHAR Buffer [ MAX_PATH ];

    GetDlgItemText (hDlg, ControlId, Buffer, ARRAYSIZE(Buffer));

    //
    // Check the buffer for valid file-name??
    //

    RegSetValueEx (
            hKey,
            RegValueName,
            0,
            REG_EXPAND_SZ,
            (LPBYTE) Buffer,
            (wcslen (Buffer) + 1) * sizeof (TCHAR)
            );

    return TRUE;
}

static DWORD SelectionToType [] = { 0, 3, 2, 1 };

DWORD
GetDumpTypeFromRegistry(
    HKEY Key
    )
{
    DWORD DataSize;
    DWORD Type;
    DWORD DumpType;

    DataSize = sizeof (DWORD);
    RegQueryValueEx (
                    Key,
                    REG_DUMP_TYPE_VALUE_NAME,
                    NULL,
                    &Type,
                    (LPBYTE) &DumpType,
                    &DataSize
                    );

    if (DumpType > 3) {
        DumpType = DUMP_TYPE_MINI;
    } else {
        DumpType = SelectionToType [ DumpType ];
    }

    return DumpType;
}


BOOL CoreDumpInit(HWND hDlg)
{
    BOOL Succ;
    NTSTATUS Status;
    DWORD DataSize;
    DWORD DumpType;
    DWORD Type;
    VCREG_RET vcVirt;
    VCREG_RET vcCore;
    SYSTEM_MEMORY_CONFIGURATION MemoryConfig;

    HourGlass (TRUE);

    // Do no put anything before the initialization of the globals, here.
    vcVirt = VirtualOpenKey();

    if( vcVirt == VCREG_ERROR )
    {
        CoreDumpInitErrorExit(hDlg, NULL);
        return FALSE;
    }

    vcCore = CoreDumpOpenKey();
    if (vcCore == VCREG_ERROR)
    {
        CoreDumpInitErrorExit(hDlg, ghkeyMemMgt);
        return FALSE;
    }
    else if (vcCore == VCREG_READONLY || vcVirt == VCREG_READONLY)
    {
        DisableCoreDumpControls (hDlg);
    }
    else
    {
        Status = GetMemoryConfiguration (&SystemMemoryConfiguration);
        if (!NT_SUCCESS (Status))
        {
            return FALSE;
        }
    }

    Status = GetMemoryConfiguration (&MemoryConfig);
    if (!NT_SUCCESS (Status))
    {
        return FALSE;
    }

    Succ = LoadString (hInstance, IDS_CRASHDUMP_DUMP_FILE, DumpFileText, ARRAYSIZE(DumpFileText));
    Succ = LoadString (hInstance, IDS_CRASHDUMP_MINI_DIR, MiniDumpDirText, ARRAYSIZE(MiniDumpDirText));

    // Special Case: Server Product does not want ability to disable logging
    // of crashdumps.
    if (IsWorkstationProduct ())
    {
        CheckInitFromRegistry(
                    hDlg,
                    IDC_STARTUP_CDMP_LOG,
                    ghkeyCrashCtrl,
                    REG_LOG_EVENT_VALUE_NAME,
                    TRUE
                    );
    }
    else
    {
        CheckDlgButton (hDlg, IDC_STARTUP_CDMP_LOG, TRUE);
        EnableWindow ( GetDlgItem (hDlg, IDC_STARTUP_CDMP_LOG), FALSE);
    }

    CheckInitFromRegistry(hDlg, IDC_STARTUP_CDMP_SEND, ghkeyCrashCtrl,REG_SEND_ALERT_VALUE_NAME, TRUE);
    CheckInitFromRegistry(hDlg, IDC_STARTUP_CDMP_OVERWRITE, ghkeyCrashCtrl, REG_OVERWRITE_VALUE_NAME, TRUE);
    CheckInitFromRegistry(hDlg, IDC_STARTUP_CDMP_AUTOREBOOT, ghkeyCrashCtrl, REG_AUTOREBOOT_VALUE_NAME, TRUE);
    ComboAddStringFromResource(hDlg, IDC_STARTUP_CDMP_TYPE, hInstance,                  // Global hInstance
                    IDS_CRASHDUMP_NONE, 0);

#ifdef _WIN64
    ComboAddStringFromResource(hDlg, IDC_STARTUP_CDMP_TYPE, hInstance, IDS_CRASHDUMP_MINI_WIN64, 0);
#else
    ComboAddStringFromResource(hDlg, IDC_STARTUP_CDMP_TYPE, hInstance, IDS_CRASHDUMP_MINI, 0);
#endif
    ComboAddStringFromResource(hDlg, IDC_STARTUP_CDMP_TYPE, hInstance, IDS_CRASHDUMP_SUMMARY, 0 );

    // Special case: Server Products do not allow full memory dumps.
    DumpType = GetDumpTypeFromRegistry(ghkeyCrashCtrl);
    if (MemoryConfig.PhysicalMemorySize < LARGE_MEMORY_THRESHOLD)
    {        
        ComboAddStringFromResource(hDlg, IDC_STARTUP_CDMP_TYPE, hInstance, IDS_CRASHDUMP_FULL, 0);
    }
    else
    {
        if (DumpType == DUMP_TYPE_FULL)
        {
            DumpType = DUMP_TYPE_SUMMARY;
        }
    }

    ComboBox_SetCurSel(GetDlgItem (hDlg, IDC_STARTUP_CDMP_TYPE), DumpType);

    DataSize = sizeof (CrashDumpFile);
    RegQueryValueEx (
                    ghkeyCrashCtrl,
                    REG_DUMPFILE_VALUE_NAME,
                    NULL,
                    &Type,
                    (LPBYTE) CrashDumpFile,
                    &DataSize
                    );

    DataSize = sizeof (MiniDumpDirectory);
    RegQueryValueEx (
                    ghkeyCrashCtrl,
                    REG_MINIDUMP_DIR_VALUE_NAME,
                    NULL,
                    &Type,
                    (LPBYTE) MiniDumpDirectory,
                    &DataSize
                    );

    // Update the selection fields of the dialog.
    SwapDumpSelection (hDlg);
    HourGlass(FALSE);

    return TRUE;
}



BOOL
CoreDumpUpdateRegistry(
    HWND hDlg,
    HKEY hKey
    )
{
    DWORD Selection;

    StoreCheckboxToReg(
                hDlg,
                IDC_STARTUP_CDMP_LOG,
                hKey,
                REG_LOG_EVENT_VALUE_NAME
                );

    StoreCheckboxToReg(
                hDlg,
                IDC_STARTUP_CDMP_SEND,
                hKey,
                REG_SEND_ALERT_VALUE_NAME
                );

    StoreCheckboxToReg(
                hDlg,
                IDC_STARTUP_CDMP_OVERWRITE,
                hKey,
                REG_OVERWRITE_VALUE_NAME
                );

    StoreCheckboxToReg(
                hDlg,
                IDC_STARTUP_CDMP_AUTOREBOOT,
                hKey,
                REG_AUTOREBOOT_VALUE_NAME
                );

    Selection = GetDumpSelection (hDlg);

    if (Selection == DUMP_TYPE_MINI) {

        StoreStringToReg (
                    hDlg,
                    IDC_STARTUP_CDMP_FILENAME,
                    hKey,
                    REG_MINIDUMP_DIR_VALUE_NAME
                    );

    } else {

        StoreStringToReg(
                    hDlg,
                    IDC_STARTUP_CDMP_FILENAME,
                    hKey,
                    REG_DUMPFILE_VALUE_NAME
                    );
    }


    if (Selection > 3) {
        Selection = 3;
    }

    Selection = SelectionToType [ Selection ];
    RegSetValueEx (
            hKey,
            REG_DUMP_TYPE_VALUE_NAME,
            0,
            REG_DWORD,
            (LPBYTE) &Selection,
            sizeof (Selection)
            );

    return TRUE;
}


ULONG64
EstimateSummaryDumpSize(
    ULONG64 PhysicalMemorySize
    )
{
    ULONG64 Size;

    //
    // Very rough guesses at the size of the summary dump.
    //

    if (PhysicalMemorySize < 128 * MBYTE) {

        Size = 50 * MBYTE;

    } else if (PhysicalMemorySize < 4 * GBYTE) {

        Size = 200 * MBYTE;

    } else if (PhysicalMemorySize < 8 * GBYTE) {

        Size = 400 * MBYTE;

    } else {

        Size = 800 * MBYTE;
    }

    return Size;
}


ULONG64
CoreDumpGetRequiredFileSize(
    IN HWND hDlg OPTIONAL
    )
{
    ULONG64 Size;
    DWORD DumpType;
    NTSTATUS Status;
    SYSTEM_MEMORY_CONFIGURATION MemoryConfig;


    //
    // If we were passed a hDlg, get the selection from the dlg. Otherwise,
    // get the selection from the registry.
    //

    if (hDlg != NULL) {

        //
        // Get selection from dlg.
        //

        DumpType = GetDumpSelection ( hDlg );

    } else {

        HKEY hKey;
        DWORD Err;

        //
        // Get selection from registry.
        //

        Err = OpenRegKey (CRASH_CONTROL_KEY,
                          &hKey
                          );

        if (Err == VCREG_ERROR) {
            return DUMP_TYPE_MINI;
        }

        ASSERT ( hKey );
        DumpType = GetDumpTypeFromRegistry ( hKey );
        CloseRegKey ( hKey );
    }

    switch (DumpType) {

        case DUMP_TYPE_NONE:
            Size = 0;
            break;

        case DUMP_TYPE_MINI:
            Size = 64 * KBYTE;
            break;

        case DUMP_TYPE_SUMMARY:

            Status = GetMemoryConfiguration (&MemoryConfig);

            if (NT_SUCCESS (Status)) {
                Size = EstimateSummaryDumpSize (MemoryConfig.PhysicalMemorySize);
            } else {
                //
                // A (large) shot in the dark.
                //
                Size = 800 * MBYTE;
            }
            break;

        case DUMP_TYPE_FULL:

            Status = GetMemoryConfiguration (&MemoryConfig);

            if (NT_SUCCESS (Status)) {
                Size = MemoryConfig.PhysicalMemorySize;
            } else {
                Size = 0;
            }

        break;

        default:
            ASSERT (FALSE);
    }

    return Size;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\envvar.c ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    envvar.c

Abstract:

    Implements the Environment Variables dialog of the System 
    Control Panel Applet

Author:

    Eric Flo (ericflo) 19-Jun-1995

Revision History:

    15-Oct-1997 scotthal
        Complete overhaul

--*/
#include "sysdm.h"

#include <help.h>
// C Runtime
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>

// for Hydra
#include <winsta.h>


//==========================================================================
//                             Local Definitions
//==========================================================================
#define LB_SYSVAR   1
#define LB_USERVAR  2

#define SYSTEMROOT TEXT("SystemRoot")
#define SYSTEMDRIVE TEXT("SystemDrive")

//==========================================================================
//                            Typedefs and Structs
//==========================================================================

//  Registry valuename linked-list structure
typedef struct _regval
{
    struct _regval *prvNext;
    LPTSTR szValueName;
} REGVAL;


//==========================================================================
//                             Local Functions
//==========================================================================
void EVDoCommand(HWND hDlg, HWND hwndCtl, int idCtl, int iNotify );
void EVSave(HWND hDlg);
void EVCleanUp (HWND hDlg);
PENVAR GetVar(HWND hDlg, UINT VarType, int iSelection);
int  FindVar (HWND hwndLB, LPTSTR szVar);

void
SetVar(
    IN HWND hDlg,
    IN UINT VarType,
    IN LPCTSTR szVarName,
    IN LPCTSTR szVarValue
);

void
DeleteVar(
    IN HWND hDlg,
    IN UINT VarType,
    IN LPCTSTR szVarName
);

//
// New.../Edit... subdialog functions
//
INT_PTR
APIENTRY
EnvVarsEditDlg(
    IN HWND hDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
);

void
EVDoEdit(
    IN HWND hWnd,
    IN UINT VarType,
    IN UINT EditType,
    IN int  iSelection
);
 
BOOL 
ExpandSystemVar( 
    IN LPCTSTR pszSrc, 
    OUT LPTSTR pszDst, 
    IN DWORD cchDst 
);

//==========================================================================
//                      "Global" Variables for this page
//==========================================================================
BOOL bEditSystemVars = FALSE;
DWORD cxLBSysVars = 0;
BOOL bUserVars = TRUE;

//
// Help ID's
//

DWORD aEnvVarsHelpIds[] = {
    IDC_STATIC,                   NO_HELP,
    IDC_ENVVAR_SYS_USERGROUP,     (IDH_ENV + 2),
    IDC_ENVVAR_SYS_LB_USERVARS,   (IDH_ENV + 2),
    IDC_ENVVAR_SYS_SYSGROUP,      (IDH_ENV + 0),
    IDC_ENVVAR_SYS_LB_SYSVARS,    (IDH_ENV + 0),
    IDC_ENVVAR_SYS_NEWUV,         (IDH_ENV + 7),
    IDC_ENVVAR_SYS_EDITUV,        (IDH_ENV + 8),
    IDC_ENVVAR_SYS_NDELUV,        (IDH_ENV + 9),
    IDC_ENVVAR_SYS_NEWSV,         (IDH_ENV + 10),
    IDC_ENVVAR_SYS_EDITSV,        (IDH_ENV + 11),
    IDC_ENVVAR_SYS_DELSV,         (IDH_ENV + 12),
    0, 0
};

TCHAR szUserEnv[] = TEXT( "Environment" );
TCHAR szSysEnv[]  = TEXT( "System\\CurrentControlSet\\Control\\Session Manager\\Environment" );


BOOL 
InitEnvVarsDlg(
    IN HWND hDlg
)
/*++

Routine Description:

    Initializes the environment variables page

Arguments:

    hDlg -
        Supplies window handle

Return Value:

    TRUE if successful
    FALSE if an error occurs

--*/
{
    TCHAR szBuffer1[200];
    TCHAR szBuffer2[300];
    TCHAR szUserName[MAX_USER_NAME];
    DWORD dwSize = MAX_USER_NAME;
    HWND hwndTemp;
    HKEY hkeyEnv;
    TCHAR  *pszValue;
    HANDLE hKey;
    DWORD dwBufz, dwValz, dwIndex, dwType;
    LONG Error;
    TCHAR   szTemp[BUFZ];
    LPTSTR  pszString;
    ENVARS *penvar;
    int     n;
    LV_COLUMN col;
    LV_ITEM item;
    RECT rect;
    int cxFirstCol;
    DWORD dwSysRegMode;


    HourGlass (TRUE);


    //
    // Create the first column
    //

    LoadString (hInstance, IDS_ENVVAR_VARIABLE_HEADING, szBuffer1, 200);

    if (!GetClientRect (GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_SYSVARS), &rect)) {
        rect.right = 300;
    }

    cxFirstCol = (int)(rect.right * .3);

    col.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    col.fmt = LVCFMT_LEFT;
    col.cx = cxFirstCol;
    col.pszText = szBuffer1;
    col.iSubItem = 0;

    SendDlgItemMessage (hDlg, IDC_ENVVAR_SYS_LB_SYSVARS, LVM_INSERTCOLUMN,
                        0, (LPARAM) &col);

    SendDlgItemMessage (hDlg, IDC_ENVVAR_SYS_LB_USERVARS, LVM_INSERTCOLUMN,
                        0, (LPARAM) &col);


    //
    // Create the second column
    //

    LoadString (hInstance, IDS_ENVVAR_VALUE_HEADING, szBuffer1, 200);

    col.cx = rect.right - cxFirstCol - GetSystemMetrics(SM_CYHSCROLL);
    col.iSubItem = 1;

    SendDlgItemMessage (hDlg, IDC_ENVVAR_SYS_LB_SYSVARS, LVM_INSERTCOLUMN,
                        1, (LPARAM) &col);

    SendDlgItemMessage (hDlg, IDC_ENVVAR_SYS_LB_USERVARS, LVM_INSERTCOLUMN,
                        1, (LPARAM) &col);


    ////////////////////////////////////////////////////////////////////
    // Display System Variables from registry in listbox
    ////////////////////////////////////////////////////////////////////

    hwndTemp = GetDlgItem (hDlg, IDC_ENVVAR_SYS_LB_SYSVARS);

    hKey = MemAlloc (LPTR, BUFZ*SIZEOF(TCHAR));
    pszString = (LPTSTR) MemAlloc (LPTR, BUFZ*sizeof(TCHAR));

    cxLBSysVars = 0;
    hkeyEnv = NULL;

    // If user is an admin, then try to open the System Environment variables area with R/W, allow to edit
    if (IsUserAdmin())
    {
        dwSysRegMode = KEY_READ | KEY_WRITE;
        bEditSystemVars = TRUE;
    }
    else // If not ad admin, open with Read-Only, disallow edit of System Env variables area
    {
        dwSysRegMode = KEY_READ;
        bEditSystemVars = FALSE;
    }

    //  On failure, just try to open it for reading
    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, szSysEnv, 0, dwSysRegMode, &hkeyEnv) != ERROR_SUCCESS) {
        hkeyEnv = NULL;
    }

    if (hkeyEnv)
    {
        pszValue = (TCHAR *) hKey;
        dwBufz = ARRAYSIZE(szTemp);
        dwValz = BUFZ * SIZEOF(TCHAR);
        dwIndex = 0;

        //  Read all values until an error is encountered

        while (!RegEnumValue(hkeyEnv,
                             dwIndex++, // Index'th value name/data
                             szTemp,    // Ptr to ValueName buffer
                             &dwBufz,   // Size of ValueName buffer
                             NULL,      // Title index return
                             &dwType,   // Type code of entry
                    (LPBYTE) pszValue,  // Ptr to ValueData buffer
                             &dwValz))  // Size of ValueData buffer
        {
            if ((dwType != REG_SZ) && (dwType != REG_EXPAND_SZ))
                goto SysLoop;

            //
            //  Clip length of returned Environment variable string
            //  to MAX_VALUE_LEN-1, as necessary.
            //

            pszValue[MAX_VALUE_LEN-1] = TEXT('\0');

            ExpandSystemVar (pszValue, pszString, BUFZ);

            penvar = (ENVARS *) MemAlloc (LPTR, SIZEOF(ENVARS));

            penvar->dwType      = dwType;
            penvar->szValueName = CloneString( szTemp );
            penvar->szValue     = CloneString( pszValue );
            penvar->szExpValue  = CloneString( pszString );


            item.mask = LVIF_TEXT | LVIF_PARAM;
            item.iItem = (dwIndex - 1);
            item.iSubItem = 0;
            item.pszText = penvar->szValueName;
            item.lParam = (LPARAM) penvar;

            n = (int)SendMessage (hwndTemp, LVM_INSERTITEM, 0, (LPARAM) &item);

            if (n != -1) {
                item.mask = LVIF_TEXT;
                item.iItem = n;
                item.iSubItem = 1;
                item.pszText = penvar->szExpValue;

                SendMessage (hwndTemp, LVM_SETITEMTEXT, n, (LPARAM) &item);
            }

SysLoop:
            //  Reset vars for next iteration

            dwBufz = ARRAYSIZE(szTemp);
            dwValz = BUFZ * SIZEOF(TCHAR);
        }
        RegCloseKey (hkeyEnv);

    }


    ////////////////////////////////////////////////////////////////////
    //  Display USER variables from registry in listbox
    ////////////////////////////////////////////////////////////////////


    //
    // Set the "User Environments for <username>" string
    //

    if (GetUserName(szUserName, &dwSize) &&
        LoadString (hInstance, IDS_USERENVVARS, szBuffer1, 200)) {

        wsprintf (szBuffer2, szBuffer1, szUserName);
        SetDlgItemText (hDlg, IDC_ENVVAR_SYS_USERGROUP, szBuffer2);
    }


    Error = RegCreateKey (HKEY_CURRENT_USER, szUserEnv, &hkeyEnv);

    if (Error == ERROR_SUCCESS && hKey)
    {
        hwndTemp = GetDlgItem (hDlg, IDC_ENVVAR_SYS_LB_USERVARS);

        pszValue = (TCHAR *) hKey;
        dwBufz = ARRAYSIZE(szTemp);
        dwValz = BUFZ * SIZEOF(TCHAR);
        dwIndex = 0;


        //  Read all values until an error is encountered

        while (!RegEnumValue(hkeyEnv,
                             dwIndex++, // Index'th value name/data
                             szTemp,    // Ptr to ValueName buffer
                             &dwBufz,   // Size of ValueName buffer
                             NULL,      // Title index return
                             &dwType,   // Type code of entry
                    (LPBYTE) pszValue,  // Ptr to ValueData buffer
                             &dwValz))  // Size of ValueData buffer
        {
            if ((dwType != REG_SZ) && (dwType != REG_EXPAND_SZ))
                goto UserLoop;

            //
            //  Clip length of returned Environment variable string
            //  to MAX_VALUE_LEN-1, as necessary.
            //

            pszValue[MAX_VALUE_LEN-1] = TEXT('\0');

            ExpandEnvironmentStrings (pszValue, pszString, BUFZ);

            penvar = (ENVARS *) MemAlloc (LPTR, sizeof(ENVARS));

            penvar->dwType      = dwType;
            penvar->szValueName = CloneString (szTemp);
            penvar->szValue     = CloneString (pszValue);
            penvar->szExpValue  = CloneString (pszString);

            item.mask = LVIF_TEXT | LVIF_PARAM;
            item.iItem = (dwIndex - 1);
            item.iSubItem = 0;
            item.pszText = penvar->szValueName;
            item.lParam = (LPARAM) penvar;

            n = (int)SendMessage (hwndTemp, LVM_INSERTITEM, 0, (LPARAM) &item);

            if (n != -1) {
                item.mask = LVIF_TEXT;
                item.iItem = n;
                item.iSubItem = 1;
                item.pszText = penvar->szExpValue;

                SendMessage (hwndTemp, LVM_SETITEMTEXT, n, (LPARAM) &item);
            }

UserLoop:
            //  Reset vars for next iteration

            dwBufz = ARRAYSIZE(szTemp);
            dwValz = BUFZ * SIZEOF(TCHAR);

        }
        RegCloseKey (hkeyEnv);
    }
    else
    {
        //  Report opening USER Environment key
        if (MsgBoxParam (hDlg, IsUserAnAdmin() ? IDS_SYSDM_NOOPEN_USER_UNK : IDS_SYSDM_NOOPEN_USER_NOTADMIN, 
                          IDS_SYSDM_TITLE, MB_OKCANCEL | MB_ICONEXCLAMATION) == IDCANCEL)
        {
            //  Free allocated memory since we are returning from here
            MemFree ((LPVOID)hKey);
            MemFree (pszString);

            HourGlass (FALSE);
            return FALSE;
        }
    }

    //
    // Select the first items in the listviews
    // It is important to set the User listview first, and
    // then the system.  When the system listview is set,
    // we will receive a LVN_ITEMCHANGED notification and
    // clear the focus in the User listview.  But when someone
    // tabs to the control the arrow keys will work correctly.
    //

    item.mask = LVIF_STATE;
    item.iItem = 0;
    item.iSubItem = 0;
    item.state = LVIS_SELECTED | LVIS_FOCUSED;
    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

    SendDlgItemMessage (hDlg, IDC_ENVVAR_SYS_LB_USERVARS,
                        LVM_SETITEMSTATE, 0, (LPARAM) &item);

    SendDlgItemMessage (hDlg, IDC_ENVVAR_SYS_LB_SYSVARS,
                        LVM_SETITEMSTATE, 0, (LPARAM) &item);



    MemFree ((LPVOID)hKey);
    MemFree (pszString);

    // Set extended LV style for whole line selection
    SendDlgItemMessage(hDlg, IDC_ENVVAR_SYS_LB_SYSVARS, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);
    SendDlgItemMessage(hDlg, IDC_ENVVAR_SYS_LB_USERVARS, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);

    HourGlass (FALSE);

    //
    // Disable System Var Editing buttons if
    // user is not an administrator
    //
    EnableWindow(
        GetDlgItem(hDlg, IDC_ENVVAR_SYS_NEWSV),
        bEditSystemVars
    );
    EnableWindow(
        GetDlgItem(hDlg, IDC_ENVVAR_SYS_EDITSV),
        bEditSystemVars
    );
    EnableWindow(
        GetDlgItem(hDlg, IDC_ENVVAR_SYS_DELSV),
        bEditSystemVars
    );

    ///////////////////
    // Return succes //
    ///////////////////
    return TRUE;
}


INT_PTR
APIENTRY 
EnvVarsDlgProc(
    IN HWND hDlg, 
    IN UINT uMsg, 
    IN WPARAM wParam, 
    IN LPARAM lParam
)
/*++

Routine Description:

    Handles messages sent to the Environment Variables dialog box

Arguments:

    hDlg -
        Supplies window handle

    uMsg -
        Supplies message being sent

    wParam -
        Supplies message parameter

    lParam -
        Supplies message parameter

Return Value:

    TRUE if message was handled
    FALSE if message was unhandled

--*/
{
    INT i = 0;
    HWND hWndTemp = NULL;

    switch (uMsg)
    {
    case WM_INITDIALOG:

        if (!InitEnvVarsDlg(hDlg)) {
            EndDialog (hDlg, 0);
        }
        break;


    case WM_NOTIFY:

        switch (((NMHDR FAR*)lParam)->code)
        {
        case LVN_KEYDOWN:
            switch (((NMHDR FAR*)lParam)->idFrom) {
                case IDC_ENVVAR_SYS_LB_USERVARS:
                    i = IDC_ENVVAR_SYS_NDELUV;
                    break;
                case IDC_ENVVAR_SYS_LB_SYSVARS:
                    i = IDC_ENVVAR_SYS_DELSV;
                    break;
                default:
                    return(FALSE);
                    break;
            } // switch

            hWndTemp = GetDlgItem(hDlg, i);

            if ((VK_DELETE == ((LV_KEYDOWN FAR *) lParam)->wVKey)) {
                if (IsWindowEnabled(hWndTemp)) {
                    SendMessage(
                        hDlg,
                        WM_COMMAND,
                        MAKEWPARAM(i, BN_CLICKED),
                        (LPARAM) hWndTemp
                    );
                } // if (IsWindowEnabled...
                else {
                    MessageBeep(MB_ICONASTERISK);
                } // else
            } // if (VK_DELETE...
            break;

            
        case NM_DBLCLK:
            switch (((NMHDR FAR*)lParam)->idFrom) {
                case IDC_ENVVAR_SYS_LB_USERVARS:
                    i = IDC_ENVVAR_SYS_EDITUV;
                    break;
                case IDC_ENVVAR_SYS_LB_SYSVARS:
                    i = IDC_ENVVAR_SYS_EDITSV;
                    break;
                default:
                    return(FALSE);
                    break;
            } // switch

            hWndTemp = GetDlgItem(hDlg, i);

            if (IsWindowEnabled(hWndTemp)) {
                SendMessage(
                    hDlg,
                    WM_COMMAND,
                    MAKEWPARAM(i, BN_CLICKED),
                    (LPARAM) hWndTemp
                );
            } // if (IsWindowEnabled...
            else {
                MessageBeep(MB_ICONASTERISK);
            } // else
            break;

        default:
            return FALSE;
        }
        break;


    case WM_COMMAND:
        EVDoCommand(hDlg, (HWND)lParam, LOWORD(wParam), HIWORD(wParam));
        break;

    case WM_DESTROY:
        EVCleanUp (hDlg);
        break;

    case WM_HELP:      // F1
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP, (DWORD_PTR) (LPSTR) aEnvVarsHelpIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) aEnvVarsHelpIds);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

void 
EVDoCommand(
    IN HWND hDlg, 
    IN HWND hwndCtl, 
    IN int idCtl, 
    IN int iNotify 
)
/*++

Routine Description:

    Handles WM_COMMAND messages sent to Environment Variables dialog box

Arguments:

    hDlg -
        Supplies window handle

    hwndCtl -
        Supplies window handle of control which sent the WM_COMMAND

    idCtl -
        Supplies ID of control which sent the WM_COMMAND

    iNotify -
        Supplies notification code

Return Value:

    None

--*/
{
    TCHAR   szTemp[MAX_PATH];
    int     i;
    HWND    hwndTemp;
    PENVAR  penvar;

    switch (idCtl) {
        case IDOK:
            EVSave(hDlg);
            EndDialog(hDlg, 0);
            break;

        case IDCANCEL:
            EndDialog(hDlg, 0);
            break;

        case IDC_ENVVAR_SYS_EDITSV:
            EVDoEdit(
                hDlg, 
                SYSTEM_VAR,
                EDIT_VAR,
                GetSelectedItem(GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_SYSVARS))
            );
            break;

        case IDC_ENVVAR_SYS_EDITUV:
            EVDoEdit(
                hDlg, 
                USER_VAR,
                EDIT_VAR,
                GetSelectedItem(GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_USERVARS))
            );
            break;

        case IDC_ENVVAR_SYS_NEWSV:
            EVDoEdit(hDlg, SYSTEM_VAR, NEW_VAR, -1);
            break;

        case IDC_ENVVAR_SYS_NEWUV:
            EVDoEdit(hDlg, USER_VAR, NEW_VAR, -1); 
            break;

        case IDC_ENVVAR_SYS_DELSV:
            i = GetSelectedItem(GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_SYSVARS));
            if (-1 != i)
            {
                penvar = GetVar(hDlg, SYSTEM_VAR, i);
                if (penvar)
                {
                    DeleteVar(hDlg, SYSTEM_VAR, penvar->szValueName);
                }
            } // if
            break;

        case IDC_ENVVAR_SYS_NDELUV:
            i = GetSelectedItem(GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_USERVARS));
            if (-1 != i)
            {
                penvar = GetVar(hDlg, USER_VAR, i);
                if (penvar)
                {
                    DeleteVar(hDlg, USER_VAR, penvar->szValueName);
                }
            } // if
            break;

        default:
            break;
    } // switch

    return;

}

void
DeleteVar(
    IN HWND hDlg,
    IN UINT VarType,
    IN LPCTSTR szVarName
)
/*++

Routine Description:

    Deletes an environment variable of a given name and type

Arguments:

    hDlg -
        Supplies window handle

    VarType -
        Supplies variable type (user or system)

    szVarName -
        Supplies variable name

Return Value:

    None, although it really should have one someday.

--*/
{
    TCHAR   szTemp2[MAX_PATH];
    int     i, n;
    TCHAR  *bBuffer;
    TCHAR  *pszTemp;
    LPTSTR  pszString;
    HWND    hwndTemp;
    ENVARS *penvar;
    LV_ITEM item;

    // Delete listbox entry that matches value in szVarName
    //  If found, delete entry else ignore
    wsprintf(
        szTemp2,
        TEXT("%s"),
        szVarName
    );

    if (szTemp2[0] == TEXT('\0'))
        return;

    //  Determine which Listbox to use (SYSTEM or USER vars)
    switch (VarType) {
        case SYSTEM_VAR:
            i = IDC_ENVVAR_SYS_LB_SYSVARS;
            break;

        case USER_VAR:
        default:
            i = IDC_ENVVAR_SYS_LB_USERVARS;
            break;

    } // switch (VarType)

    hwndTemp = GetDlgItem (hDlg, i);

    n = FindVar (hwndTemp, szTemp2);

    if (n != -1)
    {
        // Free existing strings (listbox and ours)

        item.mask = LVIF_PARAM;
        item.iItem = n;
        item.iSubItem = 0;


        if (SendMessage (hwndTemp, LVM_GETITEM, 0, (LPARAM) &item)) {
            penvar = (ENVARS *) item.lParam;

        } else {
            penvar = NULL;
        }


        if (penvar) {
            MemFree (penvar->szValueName);
            MemFree (penvar->szValue);
            MemFree (penvar->szExpValue);
            MemFree ((LPVOID) penvar);
        }

        SendMessage (hwndTemp, LVM_DELETEITEM, n, 0L);
        PropSheet_Changed(GetParent(hDlg), hDlg);

        //  Fix selection state in listview
        if (n > 0) {
            n--;
        }

        item.mask = LVIF_STATE;
        item.iItem = n;
        item.iSubItem = 0;
        item.state = LVIS_SELECTED | LVIS_FOCUSED;
        item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

        SendDlgItemMessage (hDlg, i,
                            LVM_SETITEMSTATE, n, (LPARAM) &item);

    }

    return;
}

void
SetVar(
    IN HWND hDlg,
    IN UINT VarType,
    IN LPCTSTR szVarName,
    IN LPCTSTR szVarValue
)
/*++

Routine Description:

    Given an environment variable's type (system or user), name, and value,
    creates a ENVVARS structure for that environment variable and inserts
    it into the proper list view control, deleteing any existing variable
    of the same name.

Arguments:

    hDlg -
        Supplies window handle

    VarType -
        Supplies the type of the environment variable (system or user)

    szVarName -
        Supplies the name of the environment variable

    szVarValue -
        Supplies the value of the environment variable

Return Value:

    None, although it really should have one someday.

--*/
{
    TCHAR   szTemp2[BUFZ];
    int     i, n;
    TCHAR  *bBuffer;
    TCHAR  *pszTemp;
    LPTSTR  pszString;
    HWND    hwndTemp;
    int     idTemp;
    ENVARS *penvar;
    LV_ITEM item;

    wnsprintf(szTemp2, ARRAYSIZE(szTemp2), TEXT("%s"), szVarName);

    //  Strip trailing whitespace from end of Env Variable
    i = lstrlen(szTemp2) - 1;
    while (i >= 0)
    {
        if (_istspace(szTemp2[i]))
            szTemp2[i--] = TEXT('\0');
        else
            break;
    }

    // Make sure variable name does not contain the "=" sign.
    pszTemp = _tcspbrk (szTemp2, TEXT("="));
    if (pszTemp)
        *pszTemp = TEXT('\0');

    if (szTemp2[0] == TEXT('\0'))
        return;

    bBuffer = (TCHAR *) MemAlloc (LPTR, BUFZ * sizeof(TCHAR));
    if (bBuffer)
    {
        pszString = (LPTSTR) MemAlloc (LPTR, BUFZ * sizeof(TCHAR));
        if (pszString)
        {
            wnsprintf(bBuffer, (BUFZ), TEXT("%s"), szVarValue);

            //  Determine which Listbox to use (SYSTEM or USER vars)
            switch (VarType)
            {
                case SYSTEM_VAR:
                    idTemp = IDC_ENVVAR_SYS_LB_SYSVARS;
                    break;

                case USER_VAR:
                default:
                    idTemp = IDC_ENVVAR_SYS_LB_USERVARS;
                    break;

            } // switch (VarType)
            hwndTemp = GetDlgItem(hDlg, idTemp);

            n = FindVar(hwndTemp, szTemp2);
            if (n != -1)
            {
                // Free existing strings (listview and ours)

                item.mask = LVIF_PARAM;
                item.iItem = n;
                item.iSubItem = 0;

                if (SendMessage(hwndTemp, LVM_GETITEM, 0, (LPARAM) &item))
                {
                    penvar = (ENVARS *) item.lParam;
                }
                else
                {
                    penvar = NULL;
                }

                if (penvar)
                {
                    MemFree(penvar->szValueName);
                    MemFree(penvar->szValue);
                    MemFree(penvar->szExpValue);
                }

                SendMessage(hwndTemp, LVM_DELETEITEM, n, 0L);
            }
            else
            {
                //  Get some storage for new Env Var
                penvar = (ENVARS *) MemAlloc(LPTR, sizeof(ENVARS));
            }

            //  If there are two '%' chars in string, then this is a
            //  REG_EXPAND_SZ style environment string
            pszTemp = _tcspbrk (bBuffer, TEXT("%"));
            if (penvar)
            {
                if (pszTemp && _tcspbrk (pszTemp, TEXT("%")))
                    penvar->dwType = REG_EXPAND_SZ;
                else
                    penvar->dwType = REG_SZ;
            }

            switch (VarType)
            {
            case SYSTEM_VAR:
                ExpandSystemVar(bBuffer, pszString, BUFZ);
                break;

            case USER_VAR:
                ExpandEnvironmentStrings (bBuffer, pszString, BUFZ);
                break;

            default:
                break;

            } // switch

            if (penvar)
            {
                penvar->szValueName = CloneString (szTemp2);
                penvar->szValue     = CloneString (bBuffer);
                penvar->szExpValue  = CloneString (pszString);

                item.mask = LVIF_TEXT | LVIF_PARAM;
                item.iItem = ListView_GetItemCount(hwndTemp);
                item.iSubItem = 0;
                item.pszText = penvar->szValueName;
                item.lParam = (LPARAM) penvar;

                n = (int)SendMessage (hwndTemp, LVM_INSERTITEM, 0, (LPARAM) &item);
            }
            else
            {
                n = -1;
            }

            if (n != -1)
            {
                item.mask = LVIF_TEXT;
                item.iItem = n;
                item.iSubItem = 1;
                item.pszText = penvar->szExpValue;

                SendMessage (hwndTemp, LVM_SETITEMTEXT, n, (LPARAM) &item);

                item.mask = LVIF_STATE;
                item.iItem = n;
                item.iSubItem = 0;
                item.state = LVIS_SELECTED | LVIS_FOCUSED;
                item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

                SendDlgItemMessage (hDlg, idTemp, LVM_SETITEMSTATE, n, (LPARAM) &item);
            }

            MemFree(pszString);
        }

        MemFree(bBuffer);
    }

    return;

}

void
EVDoEdit(
    IN HWND hWnd,
    IN UINT VarType,
    IN UINT EditType,
    IN int iSelection
)
/*++

Routine Description:

    Sets up for, executes, and cleans up after an Environment Variable
    New... or Edit... dialog.  Called when user presses a New... or Edit...
    button.

Arguments:

    hWnd -
        Supplies window handle

    VarType -
        Supplies the type of the variable:  User (USER_VAR) or 
        System (SYSTEM_VAR)

    EditType -
        Supplies the type of the edit:  create New (NEW_VAR) or 
        Edit existing (EDIT_VAR)

    iSelection -
        Supplies the currently selected variable of type VarType.  This
        value is ignored if EditType is NEW_VAR.

Return Value:

    None.  May alter the contents of a list view control as a side effect.

--*/
{
    LRESULT Result = 0;
    BOOL fVarChanged = FALSE;
    HWND hWndLB = NULL;
    ENVARS *penvar = NULL;
    LV_ITEM item;

    ASSERT((-1 != iSelection) || (NEW_VAR == EditType));

    g_VarType = VarType;
    g_EditType = EditType;

    penvar = GetVar(hWnd, VarType, iSelection);

    switch (EditType) {
        case NEW_VAR:
            ZeroMemory((LPVOID) g_szVarName, (DWORD) BUFZ * sizeof(TCHAR));
            ZeroMemory((LPVOID) g_szVarValue, (DWORD) BUFZ * sizeof(TCHAR));
            break;

        case EDIT_VAR:
            if (penvar) {
                wsprintf(
                    g_szVarName,
                    TEXT("%s"),
                    penvar->szValueName
                );
                wsprintf(
                    g_szVarValue,
                    TEXT("%s"),
                    penvar->szValue
                );

            } // if
            else {
                MessageBeep(MB_ICONASTERISK);
                return;
            } // else
            break;

        case INVALID_EDIT_TYPE:
        default:
            return;
    } // switch
    
    Result = DialogBox(
        hInstance,
        (LPTSTR) MAKEINTRESOURCE(IDD_ENVVAREDIT),
        hWnd,
        EnvVarsEditDlg
    );

    //
    // Only update the list view control if the user
    // actually changed or created a variable
    //
    switch (Result) {
        case EDIT_CHANGE:
            if (EDIT_VAR == EditType) {
                fVarChanged = 
                    lstrcmp(penvar->szValueName, g_szVarName) ||
                    lstrcmp(penvar->szValue, g_szVarValue);
            } // if (EDIT_VAR...
            else if (NEW_VAR == EditType) {
                fVarChanged =
                    lstrlen(g_szVarName) && lstrlen(g_szVarValue);
            } // else if (NEW_VAR...
            else {
                fVarChanged = FALSE;
            } // else

            if (fVarChanged) {
                if (EDIT_VAR == EditType) {
                    DeleteVar(hWnd, VarType, penvar->szValueName);
                } // if (EDIT_VAR...
                SetVar(hWnd, VarType, g_szVarName, g_szVarValue);
            } // if (fVarChanged)
            break;

        default:
        break;
    } // switch (Result)

    g_VarType = INVALID_VAR_TYPE;
    g_EditType = INVALID_EDIT_TYPE;
    return; 
}

PENVAR
GetVar(
    IN HWND hDlg, 
    IN UINT VarType, 
    IN int iSelection
)
/*++

Routine Description:

    Returns a given System or User environment variable, as stored
    in the System or User environment variable listview control.

    Changing the structure returned by this routine is not
    recommended, because it will alter the values actually stored
    in the listview control.

Arguments:

    hDlg -
        Supplies window handle

    VarType -
        Supplies variable type--System or User

    iSelection -
        Supplies the selection index into the listview control of
        the desired environment variable

Return Value:

    Pointer to a valid ENVARS structure if successful.

    NULL if unsuccessful.

--*/
{
    HWND hWndLB = NULL;
    PENVAR penvar = NULL;
    LV_ITEM item;

    switch (VarType)
    {
        case SYSTEM_VAR:
            hWndLB = GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_SYSVARS);
            break;

        case USER_VAR:
            hWndLB = GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_USERVARS);
            break;

        case INVALID_VAR_TYPE:
        default:
            return NULL;
    } // switch (VarType)

    item.mask = LVIF_PARAM;
    item.iItem = iSelection;
    item.iSubItem = 0;
    if (iSelection >= 0 && SendMessage (hWndLB, LVM_GETITEM, 0, (LPARAM) &item))
    {
        penvar = (ENVARS *) item.lParam;
    }
    else
    {
        penvar = NULL;
    }
    
    return penvar;
}

int 
FindVar(
    IN HWND hwndLV, 
    IN LPTSTR szVar
)
/*++

Routine Description:

    Find the USER Environment variable that matches passed string
    and return its listview index or -1

Arguments:

    hwndLV -
        Supplies window handle to the list view control containing the
        environment variables

    szVar -
        Supplies the variable name in string form

Return Value:

    List view item index which matches the passed in string if the string
    is the name of an environment variable

    -1 if the passed in string is not the name of an environment variable

--*/
{
    LV_FINDINFO FindInfo;


    FindInfo.flags = LVFI_STRING;
    FindInfo.psz = szVar;

    return (int)(SendMessage (hwndLV, LVM_FINDITEM, (WPARAM) -1, (LPARAM) &FindInfo));
}

//
// Hydra's
// WinStationBroadcastSystemMessage(
//
typedef
LONG
(*PWINSTABSM_ROUTINE) (
                    HANDLE  hServer,
                    BOOL    sendToAllWinstations,   // you set this to TRUE
                    ULONG   sessionID,          // set to NULL, due to above
                    ULONG   timeOut,
                    DWORD   dwFlags,
                    DWORD   *lpdwRecipients,
                    ULONG   uiMessage,
                    WPARAM  wParam,
                    LPARAM  lParam,
                    LONG    *pResponse);

PWINSTABSM_ROUTINE               fp_WinStaBroadcastSystemMessage;

// load winsta.dll (if any) and initialize the global function pointers to use
HANDLE 
InitializeHydraInterface(
    void
    )
{
    HANDLE  hwinStaLib=NULL;

    //
    // Load the Terminal Server base library that contains the user message dispatch
    // routines if termial server is running.
    //
    if (hwinStaLib = LoadLibrary(TEXT("WINSTA.DLL"))) 
    {
        fp_WinStaBroadcastSystemMessage = (PWINSTABSM_ROUTINE)GetProcAddress(
                             hwinStaLib,"WinStationBroadcastSystemMessage");

        if (fp_WinStaBroadcastSystemMessage )
        {
            return (hwinStaLib);
        }
        else
        {
            // this must not be a NT5 running Terminal Services, which means
            // it could be NT5 WKS, or some flavor of NT4.
            // So, we just bail out, no problem.
            FreeLibrary(hwinStaLib);
            return (NULL);
        }
    }

    return NULL;
}

void 
EVSave(
    IN HWND hDlg
)
/*++

Routine Description:

    Saves the environment variables in the registry

Arguments:

    hDlg -
        Supplies window handle

Return Value:

    None

--*/
{
    TCHAR   szTemp[BUFZ];
    int     selection;
    int     i, n;
    TCHAR  *bBuffer;
    TCHAR  *pszTemp;
    LPTSTR  pszString;
    HWND    hwndTemp;
    ENVARS *penvar;
    REGVAL *prvFirst;
    REGVAL *prvRegVal;
    HKEY    hkeyEnv;
    DWORD   dwBufz, dwIndex, dwType;
    LV_ITEM item;

    HourGlass (TRUE);

    /////////////////////////////////////////////////////////////////
    //  Set all new USER environment variables to current values
    //  but delete all old environment variables first
    /////////////////////////////////////////////////////////////////

    if (RegOpenKeyEx (HKEY_CURRENT_USER, szUserEnv, 0,
                     KEY_READ | KEY_WRITE, &hkeyEnv)
            == ERROR_SUCCESS)
    {
        dwBufz = ARRAYSIZE(szTemp);
        dwIndex = 0;

        //  Delete all values of type REG_SZ & REG_EXPAND_SZ under key

        //  First: Make a linked list of all USER Env string vars

        prvFirst = (REGVAL *) NULL;

        while (!RegEnumValue(hkeyEnv,
                             dwIndex++, // Index'th value name/data
                             szTemp,    // Ptr to ValueName buffer
                             &dwBufz,   // Size of ValueName buffer
                             NULL,      // Title index return
                             &dwType,   // Type code of entry
                             NULL,      // Ptr to ValueData buffer
                             NULL))     // Size of ValueData buffer
        {
            if ((dwType != REG_SZ) && (dwType != REG_EXPAND_SZ))
                goto EVSGetNextUserVar;

            if (prvFirst)
            {
                prvRegVal->prvNext = (REGVAL *) MemAlloc (LPTR, sizeof(REGVAL));
                prvRegVal = prvRegVal->prvNext;
            }
            else        // First time thru
            {
                prvFirst = prvRegVal = (REGVAL *) MemAlloc (LPTR, sizeof(REGVAL));
            }

            prvRegVal->prvNext = NULL;
            prvRegVal->szValueName = CloneString (szTemp);

            // Reset vars for next call
EVSGetNextUserVar:
            dwBufz = ARRAYSIZE(szTemp);
        }

        //  Now traverse the list, deleting them all

        prvRegVal = prvFirst;

        while (prvRegVal)
        {
            RegDeleteValue (hkeyEnv, prvRegVal->szValueName);

            MemFree (prvRegVal->szValueName);

            prvFirst  = prvRegVal;
            prvRegVal = prvRegVal->prvNext;

            MemFree ((LPVOID) prvFirst);
        }

        ///////////////////////////////////////////////////////////////
        //  Set all new USER environment variables to current values
        ///////////////////////////////////////////////////////////////

        hwndTemp = GetDlgItem (hDlg, IDC_ENVVAR_SYS_LB_USERVARS);

        if ((n = (int)SendMessage (hwndTemp, LVM_GETITEMCOUNT, 0, 0L)) != LB_ERR)
        {

            item.mask = LVIF_PARAM;
            item.iSubItem = 0;

            for (i = 0; i < n; i++)
            {

                item.iItem = i;

                if (SendMessage (hwndTemp, LVM_GETITEM, 0, (LPARAM) &item)) {
                    penvar = (ENVARS *) item.lParam;

                } else {
                    penvar = NULL;
                }

                if (penvar) {
                    if (RegSetValueEx (hkeyEnv,
                                       penvar->szValueName,
                                       0L,
                                       penvar->dwType,
                              (LPBYTE) penvar->szValue,
                                       (lstrlen (penvar->szValue)+1) * sizeof(TCHAR)))
                    {
                        //  Report error trying to set registry values

                        if (MsgBoxParam (hDlg, IsUserAnAdmin() ? IDS_SYSDM_NONEW_ENV_UNK : IDS_SYSDM_NONEW_ENV_NOTADMIN, IDS_SYSDM_TITLE,
                            MB_OKCANCEL | MB_ICONEXCLAMATION) == IDCANCEL)
                            break;
                    }
                }
            }
        }

        RegFlushKey (hkeyEnv);
        RegCloseKey (hkeyEnv);
    }
    else
    {
        //  Report opening USER Environment key
        if (MsgBoxParam (hDlg, IsUserAnAdmin() ? IDS_SYSDM_NOOPEN_USER_UNK : IDS_SYSDM_NOOPEN_USER_NOTADMIN, IDS_SYSDM_TITLE,
                       MB_OKCANCEL | MB_ICONEXCLAMATION) == IDCANCEL)
            goto Exit;
    }

    /////////////////////////////////////////////////////////////////
    //  Set all new SYSTEM environment variables to current values
    //  but delete all old environment variables first
    /////////////////////////////////////////////////////////////////

    if (!bEditSystemVars)
        goto SkipSystemVars;

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                       szSysEnv,
                       0,
                       KEY_READ | KEY_WRITE,
                       &hkeyEnv)
            == ERROR_SUCCESS)
    {
        dwBufz = ARRAYSIZE(szTemp);
        dwIndex = 0;

        //  Delete all values of type REG_SZ & REG_EXPAND_SZ under key

        //  First: Make a linked list of all Env string vars

        prvFirst = (REGVAL *) NULL;

        while (!RegEnumValue(hkeyEnv,
                             dwIndex++, // Index'th value name/data
                             szTemp,    // Ptr to ValueName buffer
                             &dwBufz,   // Size of ValueName buffer
                             NULL,      // Title index return
                             &dwType,   // Type code of entry
                             NULL,      // Ptr to ValueData buffer
                             NULL))     // Size of ValueData buffer
        {
            if ((dwType != REG_SZ) && (dwType != REG_EXPAND_SZ))
                goto EVSGetNextSysVar;

            if (prvFirst)
            {
                prvRegVal->prvNext = (REGVAL *) MemAlloc (LPTR, sizeof(REGVAL));
                prvRegVal = prvRegVal->prvNext;
            }
            else        // First time thru
            {
                prvFirst = prvRegVal = (REGVAL *) MemAlloc (LPTR, sizeof(REGVAL));
            }

            prvRegVal->prvNext = NULL;
            prvRegVal->szValueName = CloneString (szTemp);

            // Reset vars for next call
EVSGetNextSysVar:
            dwBufz = ARRAYSIZE(szTemp);
        }

        //  Now traverse the list, deleting them all

        prvRegVal = prvFirst;

        while (prvRegVal)
        {
            RegDeleteValue (hkeyEnv, prvRegVal->szValueName);

            MemFree (prvRegVal->szValueName);

            prvFirst  = prvRegVal;
            prvRegVal = prvRegVal->prvNext;

            MemFree ((LPVOID) prvFirst);
        }

        ///////////////////////////////////////////////////////////////
        //  Set all new SYSTEM environment variables to current values
        ///////////////////////////////////////////////////////////////

        hwndTemp = GetDlgItem (hDlg, IDC_ENVVAR_SYS_LB_SYSVARS);

        if ((n = (int)SendMessage (hwndTemp, LVM_GETITEMCOUNT, 0, 0L)) != LB_ERR)
        {
            item.mask = LVIF_PARAM;
            item.iSubItem = 0;

            for (i = 0; i < n; i++)
            {
                item.iItem = i;

                if (SendMessage (hwndTemp, LVM_GETITEM, 0, (LPARAM) &item)) {
                    penvar = (ENVARS *) item.lParam;

                } else {
                    penvar = NULL;
                }

                if (penvar) {
                    if (RegSetValueEx (hkeyEnv,
                                       penvar->szValueName,
                                       0L,
                                       penvar->dwType,
                              (LPBYTE) penvar->szValue,
                                       (lstrlen (penvar->szValue)+1) * sizeof(TCHAR)))
                    {
                        //  Report error trying to set registry values

                        if (MsgBoxParam (hDlg, IsUserAnAdmin() ? IDS_SYSDM_NONEW_ENV_UNK : IDS_SYSDM_NONEW_ENV_NOTADMIN, IDS_SYSDM_TITLE,
                            MB_OKCANCEL | MB_ICONEXCLAMATION) == IDCANCEL)
                            break;
                    }
                }
            }
        }

        RegFlushKey (hkeyEnv);
        RegCloseKey (hkeyEnv);
    }
    else
    {
        //  Report opening SYSTEM Environment key
        if (MsgBoxParam (hDlg, IsUserAnAdmin() ? IDS_SYSDM_NOOPEN_SYS_UNK : IDS_SYSDM_NOOPEN_SYS_NOTADMIN, IDS_SYSDM_TITLE,
                       MB_OKCANCEL | MB_ICONEXCLAMATION) == IDCANCEL)
            goto Exit;
    }

SkipSystemVars:


    // Send public message announcing change to Environment
    SendMessageTimeout( (HWND)-1, WM_WININICHANGE, 0L, (LPARAM)szUserEnv,
                                            SMTO_ABORTIFHUNG, 1000, NULL );

    // the folllowing block will send a message to all terminal server session
    // if and only if this is a NT5 and terminal services has been enabled.
    if ( IsUserAdmin() )
    {
        HANDLE  hwinStaLib;
        // if this is an NT5, then we get a valid handle to winsta.dll library
        // and the function pointer will be valid/initialized
        hwinStaLib = InitializeHydraInterface();
        if ( hwinStaLib) 
        {
            // these are not used
            DWORD   dwRecipients=0;
            LONG    dwResponse=0;

            // Broadcast the message to all hydra sessions (if any)
            fp_WinStaBroadcastSystemMessage( SERVERNAME_CURRENT, TRUE, 0, 
                                     1 /*timeout in seconds*/ , BSF_NOHANG,
                                     &dwRecipients,
                                     WM_WININICHANGE, 0L, 
                                     (LPARAM)szUserEnv,
                                     &dwResponse );

            //Close the handle to Winsta
            FreeLibrary (hwinStaLib);
        }
    }

Exit:

    HourGlass (FALSE);
}


void 
EVCleanUp(
    IN HWND hDlg
)
/*++

Routine Description:

    Frees memory allocated for environment variables

Arguments:

    hDlg -
        Supplies window handle

Return Value:

    None.

--*/
{
    int     i, n;
    HWND    hwndTemp;
    ENVARS *penvar;
    LV_ITEM item;


    //
    //  Free alloc'd strings and memory for UserEnvVars list box items
    //

    hwndTemp = GetDlgItem (hDlg, IDC_ENVVAR_SYS_LB_USERVARS);
    n = (int)SendMessage (hwndTemp, LVM_GETITEMCOUNT, 0, 0L);

    item.mask = LVIF_PARAM;
    item.iSubItem = 0;

    for (i = 0; i < n; i++) {

        item.iItem = i;

        if (SendMessage (hwndTemp, LVM_GETITEM, 0, (LPARAM) &item)) {
            penvar = (ENVARS *) item.lParam;

        } else {
            penvar = NULL;
        }

        if (penvar) {
            MemFree (penvar->szValueName);
            MemFree (penvar->szValue);
            MemFree (penvar->szExpValue);
            MemFree ((LPVOID) penvar);
        }
    }


    //
    //  Free alloc'd strings and memory for SysEnvVars list box items
    //

    hwndTemp = GetDlgItem (hDlg, IDC_ENVVAR_SYS_LB_SYSVARS);
    n = (int)SendMessage (hwndTemp, LVM_GETITEMCOUNT, 0, 0L);

    for (i = 0; i < n; i++) {

        item.iItem = i;

        if (SendMessage (hwndTemp, LVM_GETITEM, 0, (LPARAM) &item)) {
            penvar = (ENVARS *) item.lParam;

        } else {
            penvar = NULL;
        }

        if (penvar) {
            MemFree (penvar->szValueName);
            MemFree (penvar->szValue);
            MemFree (penvar->szExpValue);
            MemFree ((LPVOID) penvar);
        }
    }
}


BOOL 
ExpandSystemVar( 
    IN LPCTSTR pszSrc, 
    OUT LPTSTR pszDst, 
    IN DWORD cchDst 
) 
/*++

Routine Description:

    Private version of ExpandEnvironmentStrings() which only expands
    references to the variables "SystemRoot" and "SystemDrive".

    This behavior is intended to match the way SMSS expands system
    environment variables.

Arguments:

    pszSrc -
        Supplies the system variable value to be expanded.

    pszDst -
        Returns the expanded system variable value.

    cchDst -
        Supplies the size, in characters, of the buffer pointed to
        by pszDst

Return Value:

    TRUE if there was room in the supplied buffer for the entire
    expanded string.

    FALSE if there was insufficient space in the supplied buffer
    for the entire expanded string.

--*/
{
    TCHAR ch;
    LPTSTR p;
    TCHAR szVar[BUFZ];
    DWORD cch;

    do {

        ch = *pszSrc++;

        if (ch != TEXT('%') ) {

            // no space left, truncate string and return false
            if (--cchDst == 0) {
                *pszDst = TEXT('\0');
                return FALSE;
            }

            *pszDst++ = ch;

        } else {
            /*
             * Expand variable
             */
            // look for the next '%'
            p = szVar;
            while( *pszSrc != TEXT('\0') && *pszSrc != TEXT('%') )
                    *p++ = *pszSrc++;

            *p = TEXT('\0');

            if (*pszSrc == TEXT('\0')) {
                // end of string, first '%' must be literal
                cch = lstrlen(szVar) + 1;

                // no more space, return false
                if (cch + 1 > cchDst) {
                    *pszDst++ = TEXT('\0');
                    return FALSE;
                }

                *pszDst++ = TEXT('%');
                CopyMemory( pszDst, szVar, cch * sizeof(TCHAR));
                return TRUE;

            } else {
                // we found the ending '%' sign, expand that string

                //
                // We're expanding a SYSTEM variable, so only expand
                // references to SystemRoot and SystemDrive.
                //
                if ((!lstrcmpi(szVar, SYSTEMROOT)) || (!lstrcmpi(szVar, SYSTEMDRIVE))) {
                    cch = GetEnvironmentVariable(szVar, pszDst, cchDst);
                } /* if */
                else {
                    cch = 0;
                } /* else */

                if (cch == 0 || cch >= cchDst) {
                    //String didn't expand, copy it as a literal
                    cch = lstrlen(szVar);

                    // no space left, trunc string and return FALSE
                    if (cch + 2 + 1 > cchDst ) {
                        *pszDst = TEXT('\0');
                        return FALSE;
                    }

                    *pszDst++ = TEXT('%');

                    CopyMemory(pszDst, szVar, cch * sizeof(TCHAR));
                    pszDst += cch;

                    *pszDst++ = TEXT('%');

                    // cchDst -= two %'s and the string
                    cchDst -= (2 + cch);

                } else {
                    // string was expanded in place, bump pointer past its end
                    pszDst += cch;
                    cchDst -= cch;
                }

                // continue with next char after ending '%'
                pszSrc++;
            }
        }

    } while( ch != TEXT('\0') );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\envvar.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    envvar.h

Abstract:

    Public declarations for the Environment Variables dialog of the 
    System Control Panel Applet

Author:

    Eric Flo (ericflo) 19-Jun-1995

Revision History:

    15-Oct-1997 scotthal
        Complete overhaul

--*/
#ifndef _SYSDM_ENVVAR_H_
#define _SYSDM_ENVVAR_H_

#define MAX_USER_NAME   100

#define BUFZ              4096
#define MAX_VALUE_LEN     1024

//  Environment variables structure
typedef struct
{
    DWORD  dwType;
    LPTSTR szValueName;
    LPTSTR szValue;
    LPTSTR szExpValue;
} ENVARS, *PENVAR;

HPROPSHEETPAGE 
CreateEnvVarsPage(
    IN HINSTANCE hInst
);

INT_PTR 
APIENTRY 
EnvVarsDlgProc(
    IN HWND hDlg, 
    IN UINT uMsg, 
    IN WPARAM wParam, 
    IN LPARAM lParam
);



#endif // _SYSDM_ENVVAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\edtenvar.c ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    edtenvar.c

Abstract:

    Implements the Edit Environment Variables dialog of the
    System Control Panel Applet

Author:

    Scott Hallock (scotthal) 11-Nov-1997

Revision History:

--*/
#include "sysdm.h"

//
// Global Variables
//
UINT g_VarType = INVALID_VAR_TYPE;
UINT g_EditType = INVALID_EDIT_TYPE;
TCHAR g_szVarName[BUFZ];
TCHAR g_szVarValue[BUFZ];

//
// Help IDs
//
DWORD aEditEnvVarsHelpIds[] = {
    IDC_ENVVAR_EDIT_NAME_LABEL,  (IDH_ENV_EDIT + 0),
    IDC_ENVVAR_EDIT_NAME,        (IDH_ENV_EDIT + 0),
    IDC_ENVVAR_EDIT_VALUE_LABEL, (IDH_ENV_EDIT + 1),
    IDC_ENVVAR_EDIT_VALUE,       (IDH_ENV_EDIT + 1),
    0, 0
};

//
// Function prototypes
//
BOOL
InitEnvVarsEdit(
    IN HWND hDlg
);

BOOL
EnvVarsEditHandleCommand(
    IN HWND hDlg,
    IN WPARAM wParam,
    IN LPARAM lParam
);

//
// Function implementation
//
INT_PTR
APIENTRY
EnvVarsEditDlg(
    IN HWND hDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
)
/*++

Routine Description:

    Handles messages sent to the New.../Edit... dialog.

Arguments:

    hDlg -
        Supplies the window handle

    uMsg -
        Supplies the message being sent

    wParam -
        Supplies message parameter

    lParam -
        Supplies message parameter

Return Value:

    TRUE if message was handled.
    FALSE if message was unhandled.

--*/
{
    BOOL fInitializing = FALSE;

    switch (uMsg) {
        case WM_INITDIALOG: {
            BOOL fSuccess = FALSE;

            fInitializing = TRUE;

            fSuccess = InitEnvVarsEdit(hDlg);
            if (!fSuccess) {
                EndDialog(hDlg, EDIT_ERROR);
            } // if

            fInitializing = FALSE;
            break;
        } // case WM_INITDIALOG

        case WM_COMMAND:
            return EnvVarsEditHandleCommand(hDlg, wParam, lParam);
            break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP, (DWORD_PTR) (LPSTR) aEditEnvVarsHelpIds);
            break;
    
        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) aEditEnvVarsHelpIds);
            break;

        default:
            return(FALSE);
            break;

    } // switch (uMsg)

    return(TRUE);
}

BOOL
InitEnvVarsEdit(
    IN HWND hDlg
)
/*++

Routine Description:

    Initializes the Edit Environment Variables dialog by placing initial
    values into the text editing controls if necessary.

Arguments:

    hDlg -
        Supplies window handle

Return Value:

    TRUE if successful
    FALSE if an error occurs

--*/
{
    TCHAR szCaption[EDIT_ENVVAR_CAPTION_LENGTH];
    LRESULT fRetVal = FALSE;
    INT  nResult = 0;

    ASSERT(INVALID_EDIT_TYPE != g_EditType);
    ASSERT(INVALID_VAR_TYPE != g_VarType);

    __try {

        fRetVal = SendMessage(
            GetDlgItem(hDlg, IDC_ENVVAR_EDIT_NAME),
            EM_LIMITTEXT,
            MAX_PATH - 1,
            0
        );
        fRetVal = SendMessage(
            GetDlgItem(hDlg, IDC_ENVVAR_EDIT_VALUE),
            EM_LIMITTEXT,
            MAX_VALUE_LEN - 1,
            0
        );

        switch (g_EditType) {
            //
            // If this is to be a New.. dialog, we only need to
            // load the proper capiton for the variable type
            //
            case NEW_VAR:

                switch (g_VarType) {
                    case SYSTEM_VAR:
                        nResult = LoadString(
                            hInstance,
                            IDS_NEW_SYSVAR_CAPTION,
                            szCaption,
                            EDIT_ENVVAR_CAPTION_LENGTH
                        );
                        break;

                    case USER_VAR:
                        nResult = LoadString(
                            hInstance,
                            IDS_NEW_USERVAR_CAPTION,
                            szCaption,
                            EDIT_ENVVAR_CAPTION_LENGTH
                        );
                        break;

                    default:
                        __leave;
                        break;
                } // switch (g_VarType)

                //
                // Set the focus to the "Name" field
                // SetFocus() doesn't want to work here
                //
                PostMessage(
                    hDlg, 
                    WM_NEXTDLGCTL,
                    (WPARAM) GetDlgItem(hDlg, IDC_ENVVAR_EDIT_NAME),
                    (LPARAM) TRUE
                );

                break;

            //
            // If this is to be an Edit.. dialog, then we need to load the
            // proper caption and fill in initial values for the edit
            // controls
            //
            case EDIT_VAR:

                switch (g_VarType) {
                    case SYSTEM_VAR:
                        nResult = LoadString(
                            hInstance,
                            IDS_EDIT_SYSVAR_CAPTION,
                            szCaption,
                            EDIT_ENVVAR_CAPTION_LENGTH
                        );
                        break;

                     case USER_VAR:
                        nResult = LoadString(
                            hInstance,
                            IDS_EDIT_USERVAR_CAPTION,
                            szCaption,
                            EDIT_ENVVAR_CAPTION_LENGTH
                        );
                        break;
    
                    default:
                         __leave;
                        break;
                } // switch (g_VarType)
        
                SetDlgItemText(
                    hDlg,
                    IDC_ENVVAR_EDIT_NAME,
                    g_szVarName
                );
                SetDlgItemText(
                    hDlg,
                    IDC_ENVVAR_EDIT_VALUE,
                    g_szVarValue
                );

                //
                // Set the focus to the "Value" field
                // SetFocus() doesn't want to work here
                //
                PostMessage(
                    hDlg, 
                    WM_NEXTDLGCTL,
                    (WPARAM) GetDlgItem(hDlg, IDC_ENVVAR_EDIT_VALUE),
                    (LPARAM) TRUE
                );
        
                break;
        } // switch (g_EditType)
        
        fRetVal = SendMessage(
            GetDlgItem(hDlg, IDC_ENVVAR_EDIT_NAME),
            EM_SETSEL,
            0,
            -1
        );
        fRetVal = SendMessage(
            GetDlgItem(hDlg, IDC_ENVVAR_EDIT_VALUE),
            EM_SETSEL,
            0,
            -1
        );

        fRetVal = SetWindowText(hDlg, szCaption);

    } // __try
    __finally {
        //
        // Nothing to clean up.  __try is only there for __leave on
        // failure capability.
        //
    } // __finally

    return fRetVal ? TRUE : FALSE;
}

BOOL
EnvVarsEditHandleCommand(
    IN HWND hDlg,
    IN WPARAM wParam,
    IN LPARAM lParam
)
/*++

Routine Description:

    Handles WM_COMMAND messages sent to the Edit Environment Variables
    dialog

Arguments:

    hDlg -
        Supplies window handle

    wParam -
        Supplies message parameter

    lParam -
        Supplies message parameter

Return Value:

    TRUE if message was handled
    FALSE if message was unhandled

--*/
{
    switch (LOWORD(wParam)) {

        case IDOK:
            GetDlgItemText(
                hDlg,
                IDC_ENVVAR_EDIT_NAME,
                g_szVarName,
                BUFZ
            );
            GetDlgItemText(
                hDlg,
                IDC_ENVVAR_EDIT_VALUE,
                g_szVarValue,
                BUFZ
            );
            EndDialog(hDlg, EDIT_CHANGE);
            break;

        case IDCANCEL:
            EndDialog(hDlg, EDIT_NO_CHANGE);
            break;

        default:
            return(FALSE);
            break;

    } // switch (LOWORD(wParam))

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\general.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    general.h

Abstract:

    Public declarations for the General tab of the System Control Panel
    Applet

Author:

    Eric Flo (ericflo) 19-Jun-1995

Revision History:

    15-Oct-1997 scotthal
        Complete overhaul

--*/
#ifndef _SYSDM_GENERAL_H_
#define _SYSDM_GENERAL_H_

INT_PTR 
APIENTRY GeneralDlgProc(
    IN HWND hDlg, 
    IN UINT uMsg, 
    IN WPARAM wParam, 
    IN LPARAM lParam
);

#endif // _SYSDM_GENERAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\helpid.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    helpid.h

Abstract:

    Resource IDs for the System Control Panel Applet

Author:

    Scott Hallock (scotthal) 17-Oct-1997

Revision History:

    15-Oct-1997 scotthal
        Split Help IDs into their own header

--*/
#ifndef _SYSDM_HELPID_H_
#define _SYSDM_HELPID_H_

#define HELP_FILE           TEXT("sysdm.hlp")

#define IDH_HELPFIRST       5000

//
// Help IDs for the General tab
//
#define IDH_GENERAL         (IDH_HELPFIRST + 0000)
#define IDH_PERF            (IDH_HELPFIRST + 1000)
#define IDH_ENV             (IDH_HELPFIRST + 2000)
#define IDH_ENV_EDIT        (IDH_HELPFIRST + 2500)
#define IDH_STARTUP         (IDH_HELPFIRST + 3000)
#define IDH_HWPROFILE       (IDH_HELPFIRST + 4000)
#define IDH_USERPROFILE     (IDH_HELPFIRST + 5000)
#define IDH_HARDWARE        (IDH_HELPFIRST + 6000)
#define IDH_ADVANCED        (IDH_HELPFIRST + 7000)
#define IDH_PFR             (IDH_HELPFIRST + 9000)
#define IDH_DLGFIRST        (IDH_HELPFIRST + 3000)
#define IDH_DLG_VIRTUALMEM  (IDH_DLGFIRST + DLG_VIRTUALMEM)

#define IDH_HWP_PROPERTIES_SELECTION_CHECKBOX     9327

#endif // _SYSDM_HELPID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\hardware.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    hardware.h

Abstract:

    Public declarations for the Hardware tab of the System 
    Control Panel Applet

Author:

    William Hsieh (williamh) 03-Jul-1997

Revision History:

    17-Oct-1997 scotthal
        Complete overhaul

--*/
#ifndef _SYSDM_HARDWARE_H_
#define _SYSDM_HARDWARE_H_

//
// Constants and macros
//
#define DEVMGR_FILENAME 	L"devmgr.dll"
#define WIZARD_FILENAME 	L"hdwwiz.cpl"
#define WIZARD_PARAMETERS	L""
#define WIZARD_VERB         L"CPLOpen"
#ifdef UNICODE
#define DEVMGR_EXECUTE_PROC_NAME "DeviceManager_ExecuteW"
#else
#define DEVMGR_EXECUTE_PROC_NAME "DeviceManager_ExecuteA"
#endif

//
// Type definitions
//
typedef BOOL (*PDEVMGR_EXECUTE_PROC)(HWND hwnd, HINSTANCE hInst, LPCTSTR MachineName, int nCmdShow);

INT_PTR 
APIENTRY 
HardwareDlgProc(
    IN HWND hDlg, 
    IN UINT uMsg, 
    IN WPARAM wParam, 
    IN LPARAM lParam
);

#endif // _SYSDM_HARDWARE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\hardware.c ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    hardware.c

Abstract:

    Implements the Hardware tab of the System Control Panel Applet

Author:

    William Hsieh (williamh) 03-Jul-1997

Revision History:

    17-Oct-1997 scotthal
        Complete overhaul

--*/
#include "sysdm.h"

//
// Help IDs
//
DWORD aHardwareHelpIds[] = {
    IDC_WIZARD_ICON,           (IDH_HARDWARE + 0),
    IDC_WIZARD_TEXT,           (IDH_HARDWARE + 0),
    IDC_WIZARD_START,          (IDH_HARDWARE + 1),
    IDC_DEVMGR_ICON,           (IDH_HARDWARE + 2),
    IDC_DEVMGR_TEXT,           (IDH_HARDWARE + 2),
    IDC_DEVMGR_START,          (IDH_HARDWARE + 3),
    IDC_HWPROFILES_ICON,       (IDH_HARDWARE + 4),
    IDC_HWPROFILES_START_TEXT, (IDH_HARDWARE + 4),
    IDC_HWPROFILES_START,      (IDH_HARDWARE + 5),
    IDC_DRIVER_SIGNING,          (IDH_HARDWARE + 6),
    0, 0
};

//
// Function prototypes
//
void 
InitHardwareDlg(
    IN HWND hDlg
);

BOOL
HardwareHandleCommand(
    IN HWND hDlg,
    IN WPARAM wParam,
    IN LPARAM lParam
);

void 
StartHardwareWizard(
    IN HWND hDlg
);

void 
StartDeviceManager(
    IN HWND hDlg
);

typedef HRESULT (WINAPI *PFNDRIVERSIGNING)(HWND hwnd, DWORD dwFlags);

BOOL ShowDriverSigning(HWND hDlg)
{
    BOOL bFound = FALSE;
    HMODULE hmod = LoadLibrary(TEXT("sigtab.dll"));
    if (hmod)
    {
        PFNDRIVERSIGNING pfn = (PFNDRIVERSIGNING)GetProcAddress(hmod, "DriverSigningDialog");
        if (pfn)
        {
            bFound = TRUE;
            if (hDlg)
                pfn(hDlg, 0);
        }
        FreeLibrary(hmod);
    }
    return bFound;
}



VOID 
InitHardwareDlg(
    IN HWND hDlg
)
/*++

Routine Description:

    Initialize the hardware page

Arguments:

    hDlg -
        Supplies the window handle

Return Value:

    None

--*/
{


    HICON hIconNew;
    HICON hIconOld;

    hIconNew = ExtractIcon(hInstance, WIZARD_FILENAME, 0);

    if (hIconNew && (HICON)1 != hIconNew) {
        hIconOld = (HICON)SendDlgItemMessage(hDlg, IDC_WIZARD_ICON, STM_SETICON, (WPARAM)hIconNew, 0);
        if(hIconOld) {
            DestroyIcon(hIconOld);
        }
    }

    hIconNew = ExtractIcon(hInstance, DEVMGR_FILENAME, 0);
    if (hIconNew && (HICON)1 != hIconNew) {
        hIconOld = (HICON)SendDlgItemMessage(hDlg, IDC_DEVMGR_ICON, STM_SETICON, (WPARAM)hIconNew, 0);
        if(hIconOld) {
            DestroyIcon(hIconOld);
        }
    }

    if (!ShowDriverSigning(NULL))
        ShowWindow(GetDlgItem(hDlg, IDC_DRIVER_SIGNING), SW_HIDE);
}


INT_PTR
APIENTRY 
HardwareDlgProc(
    IN HWND hDlg, 
    IN UINT uMsg, 
    IN WPARAM wParam, 
    IN LPARAM lParam
)
/*++

Routine Description:

    Handles messages sent to the hardware tab

Arguments:

    hDlg -
        Supplies window handle

    uMsg -
        Supplies message being sent

    wParam -
        Supplies message parameter

    lParam -
        Supplies message parameter

Return Value:

    TRUE if message was handled
    FALSE if message was unhandled

--*/
{

    switch (uMsg) {
        case WM_INITDIALOG:
            InitHardwareDlg(hDlg);
            break;
    
        case WM_COMMAND:
            return HardwareHandleCommand(hDlg, wParam, lParam);
            break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP, (DWORD_PTR) (LPSTR) aHardwareHelpIds);
            break;
    
        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) aHardwareHelpIds);
            break;

        default:
            return(FALSE);
    } // switch

    return(TRUE);
}


BOOL
HardwareHandleCommand(
    IN HWND hDlg,
    IN WPARAM wParam,
    IN LPARAM lParam
)
/*++

Routine Description:

    Handles WM_COMMAND messages sent to the Hardware tab

Arguments:

    hDlg -
        Supplies the window handle

    wParam -
        Supplies message parameter

    lParam -
        Supplies message parameter

Return Value:

    TRUE if message was handled
    FALSE if message was unhandled

--*/
{
    DWORD_PTR dwResult = 0;

    switch (LOWORD(wParam)) {
        case IDC_WIZARD_START:
            StartHardwareWizard(hDlg);
            break;

        case IDC_DEVMGR_START:
            StartDeviceManager(hDlg);
            break;

        case IDC_DRIVER_SIGNING:
            ShowDriverSigning(hDlg);
            break;

        case IDC_HWPROFILES_START:
            dwResult = DialogBox(
                hInstance,
                MAKEINTRESOURCE(DLG_HWPROFILES),
                hDlg,
                HardwareProfilesDlg
            );
            break;
        
        default:
            return(FALSE);
    } // switch

    return(TRUE);
}


void
StartHardwareWizard(
    IN HWND hDlg
)
/*++

Routine Description:

    Start the Hardware wizard

Arguments:

    hDlg -
        Supplies window handle

Return Value:

    None
--*/
{
    SHELLEXECUTEINFO sei;

    memset(&sei, 0, sizeof(sei));
    sei.cbSize = sizeof(sei);
    sei.hwnd = hDlg;
    sei.lpFile = WIZARD_FILENAME;
    sei.lpParameters = WIZARD_PARAMETERS;
    sei.lpVerb = WIZARD_VERB;
    sei.nShow = SW_NORMAL;
    sei.hInstApp = hInstance;
    if (!ShellExecuteEx(&sei))
    {
	if (ERROR_FILE_NOT_FOUND == GetLastError() ||
	    ERROR_PATH_NOT_FOUND == GetLastError())
	{
	    // reinitialize the contents of the dialog in case
	    // user has fixed the problem
	    InitHardwareDlg(hDlg);
	}
    }
}


void
StartDeviceManager(
    IN HWND hDlg
)
/*++

Routine Description:

    Start Device Manager

Arguments:

    hDlg -
        Supplies window handle

Return Value:

    None

--*/
{
    HINSTANCE hDevMgr;

    PDEVMGR_EXECUTE_PROC    DevMgrProc;
    hDevMgr = LoadLibrary(DEVMGR_FILENAME);

    if (hDevMgr)
    {

    HourGlass(TRUE);

	DevMgrProc = (PDEVMGR_EXECUTE_PROC) GetProcAddress(hDevMgr, DEVMGR_EXECUTE_PROC_NAME);
	if (DevMgrProc)
	    (*DevMgrProc)(hDlg, hInstance, NULL, SW_NORMAL);
	else
	    MsgBoxParam(hDlg, IDS_SYSDM_NOEXPORTS_DEVMANPROG, IDS_SYSDM_TITLE, MB_OK | MB_ICONEXCLAMATION, DEVMGR_FILENAME);

	FreeLibrary(hDevMgr);

    HourGlass(FALSE);

    }
    else
    {
	MsgBoxParam(hDlg, IDS_SYSDM_NOLOAD_DEVMANPROG, IDS_SYSDM_TITLE, MB_OK | MB_ICONEXCLAMATION, DEVMGR_FILENAME);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\hwprof.h ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    hwprof.h

Abstract:

    Public declarations for the Hardware Profiles dialog.

Author:

    Paula Tomlinson (paulat) 8-22-1995

Revision History:

    22-Aug-1995     paulat
        Creation and initial implementation.

    17-Oc-1997 scotthal
        Split public declarations into their own header file

--*/
#ifndef _SYSDM_HWPROF_H_
#define _SYSDM_HWPROF_H_

//
// Public function prototypes
//
INT_PTR 
APIENTRY 
HardwareProfilesDlg(
    IN HWND hDlg, 
    IN UINT uMessage, 
    IN WPARAM wParam, 
    IN LPARAM lParam
);

INT_PTR 
APIENTRY 
CopyProfileDlg(
    IN HWND hDlg, 
    IN UINT uMessage, 
    IN WPARAM wParam, 
    IN LPARAM lParam
);

INT_PTR 
APIENTRY 
RenameProfileDlg(
    IN HWND hDlg, 
    IN UINT uMessage, 
    IN WPARAM wParam, 
    IN LPARAM lParam
);

INT_PTR 
APIENTRY GeneralProfileDlg(
    IN HWND hDlg, 
    IN UINT uMessage, 
    IN WPARAM wParam, 
    IN LPARAM lParam
);

#endif // _SYSDM_HWPROF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\netid.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    netid.h

Abstract:

    Public declarations for the Network ID tab of the System Control 
    Panel Applet


--*/
#ifndef _SYSDM_NETID_H_
#define _SYSDM_NETID_H_

//
// Public function prototypes
//


HPROPSHEETPAGE
CreateNetIDPage(
    int,
    DLGPROC
);



#endif // _SYSDM_NETID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\general.cpp ===
//*************************************************************
//
//  General.cpp  -   General property sheet page
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1996-2000
//  All rights reserved
//
//*************************************************************
// NT base apis
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>

#include <sysdm.h>
#include <regstr.h>
#include <help.h>
#include <shellapi.h>
#include <shlapip.h>
#include <shlobjp.h>
#include <regapix.h>
#include <wininet.h>
#include <wbemcli.h>        // Contains the WMI APIs: IWbemLocator, etc.
#include <ccstock.h>        // Contains IID_PPV_ARG()
#include <debug.h>          // For TraceMsg()
#include <stdio.h>
#include <math.h>
#include <tchar.h>
#include <winbrand.h>       // For added branding resources


#define CP_ENGLISH                          1252        // This is the English code page.

#ifdef DEBUG
#undef TraceMsg 
#define TraceMsg(nTFFlags, str, n1)         DbgPrintf(TEXT(str) TEXT("\n"), n1)
#else // DEBUG
#endif // DEBUG

#define SYSCPL_ASYNC_COMPUTER_INFO (WM_APP + 1)

#define SZ_REGKEY_MYCOMP_OEMLINKS           TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\OEMLinks")
#define SZ_REGKEY_MYCOMP_OEMENGLISH         TEXT("1252")
#define SZ_ATCOMPATIBLE                     TEXT("AT/AT COMPATIBLE")

#define SZ_WMI_WIN32PROCESSOR_ATTRIB_NAME           L"Name"                 // Example, "Intel Pentium III Xeon processor"
#define SZ_WMI_WIN32PROCESSOR_ATTRIB_SPEED          L"CurrentClockSpeed"   // Example, "550".
#define SZ_WMI_WIN32PROCESSOR_ATTRIB_MAXSPEED       L"MaxClockSpeed"   // Example, "550".

#define SZ_WMI_WQL_QUERY_STRING                     L"select Name,CurrentClockSpeed,MaxClockSpeed from Win32_Processor"

#define MHZ_TO_GHZ_THRESHHOLD          1000

// if cpu speed comes back slower than WMI_WIN32PROCESSOR_SPEEDSTEP_CUTOFF,
//   assume we're in power-save mode, display max speed instead.
#define WMI_WIN32PROCESSOR_SPEEDSTEP_CUTOFF         50  

#define FEATURE_IGNORE_ATCOMPAT
#define FEATURE_LINKS

#define MAX_URL_STRING                  (INTERNET_MAX_SCHEME_LENGTH \
                                        + sizeof("://") \
                                        + INTERNET_MAX_PATH_LENGTH)

#define MAX_PROCESSOR_DESCRIPTION               MAX_URL_STRING


// Globals for this page
static BOOL g_fWin9xUpgrade = FALSE;

static const TCHAR c_szEmpty[] = TEXT("");
static const TCHAR c_szCRLF[] = TEXT("\r\n");

static const TCHAR c_szAboutKey[] = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion");
static const TCHAR c_szAboutRegisteredOwner[] = REGSTR_VAL_REGOWNER;
static const TCHAR c_szAboutRegisteredOrganization[] = REGSTR_VAL_REGORGANIZATION;
static const TCHAR c_szAboutProductId[] = REGSTR_VAL_PRODUCTID;
static const TCHAR c_szAboutAnotherSerialNumber[] = TEXT("Plus! VersionNumber");
static const TCHAR c_szAboutAnotherProductId[] = TEXT("Plus! ProductId");

// oeminfo stuff
static const TCHAR c_szSystemDir[] = TEXT("System\\");
static const TCHAR c_szOemFile[] = TEXT("OemInfo.Ini");
static const TCHAR c_szOemImageFile[] = TEXT("OemLogo.Bmp");
static const TCHAR c_szOemGenSection[] = TEXT("General");
static const TCHAR c_szOemSupportSection[] = TEXT("Support Information");
static const TCHAR c_szOemName[] = TEXT("Manufacturer");
static const TCHAR c_szOemModel[] = TEXT("Model");
static const TCHAR c_szOemSupportLinePrefix[] = TEXT("line");
static const TCHAR c_szDefSupportLineText[] = TEXT("@");

static const TCHAR SZ_REGKEY_HARDWARE_CPU[] = TEXT("HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0");
static const TCHAR c_szMemoryManagement[] = TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management");
static const TCHAR c_szPhysicalAddressExtension[] = TEXT("PhysicalAddressExtension");
static const TCHAR c_szIndentifier[] = TEXT("Identifier");
static const TCHAR SZ_REGVALUE_PROCESSORNAMESTRING[] = TEXT("ProcessorNameString");

#define SZ_REGKEY_HARDWARE                  TEXT("HARDWARE\\DESCRIPTION\\System")

#define SZ_REGKEY_USE_WMI                   TEXT("UseWMI")


// Help ID's
int g_nStartOfOEMLinks = 0;

DWORD aGeneralHelpIds[] = {
    IDC_GEN_WINDOWS_IMAGE,         NO_HELP,
    IDC_TEXT_1,                    (IDH_GENERAL + 0),
    IDC_GEN_VERSION_0,             (IDH_GENERAL + 1),
    IDC_GEN_VERSION_1,             (IDH_GENERAL + 1),
    IDC_GEN_VERSION_2,             (IDH_GENERAL + 1),
    IDC_GEN_SERVICE_PACK,          (IDH_GENERAL + 1),
    IDC_TEXT_3,                    (IDH_GENERAL + 3),
    IDC_GEN_REGISTERED_0,          (IDH_GENERAL + 3),
    IDC_GEN_REGISTERED_1,          (IDH_GENERAL + 3),
    IDC_GEN_REGISTERED_2,          (IDH_GENERAL + 3),
    IDC_GEN_REGISTERED_3,          (IDH_GENERAL + 3),
    IDC_GEN_OEM_IMAGE,             NO_HELP,
    IDC_TEXT_4,                    (IDH_GENERAL + 6),
    IDC_GEN_MACHINE_0,             (IDH_GENERAL + 7),
    IDC_GEN_MACHINE_1,             (IDH_GENERAL + 8),
    IDC_GEN_MACHINE_2,             (IDH_GENERAL + 9),
    IDC_GEN_MACHINE_3,             (IDH_GENERAL + 10),
    IDC_GEN_MACHINE_4,             (IDH_GENERAL + 11),
    IDC_GEN_MACHINE_5,             NO_HELP,
    IDC_GEN_MACHINE_6,             NO_HELP,
    IDC_GEN_MACHINE_7,             NO_HELP,
    IDC_GEN_MACHINE_8,             NO_HELP,
    IDC_GEN_OEM_SUPPORT,           (IDH_GENERAL + 12),
    IDC_GEN_REGISTERED_2,          (IDH_GENERAL + 14),
    IDC_GEN_REGISTERED_3,          (IDH_GENERAL + 15),
    IDC_GEN_MACHINE,               (IDH_GENERAL + 7),
    IDC_GEN_OEM_NUDGE,             NO_HELP,
    0, 0
};


//
// Macros
//

#define BytesToK(pDW)   (*(pDW) = (*(pDW) + 512) / 1024)        // round up

//
// Function proto-types
//

INT_PTR APIENTRY PhoneSupportProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
DWORD WINAPI InitGeneralDlgThread(LPVOID lpParam);

typedef struct {
    TCHAR szProcessorDesc[MAX_PROCESSOR_DESCRIPTION];
    TCHAR szProcessorClockSpeed[MAX_PROCESSOR_DESCRIPTION];
} PROCESSOR_INFO;

typedef struct {
    LONGLONG llMem;
    PROCESSOR_INFO pi;
    BOOL fShowProcName;
    BOOL fShowProcSpeed;
} INITDLGSTRUCT;

HRESULT _SetMachineInfoLine(HWND hDlg, int idControl, LPCTSTR pszText, BOOL fSetTabStop)
{
    HRESULT hr = S_OK;

#ifdef FEATURE_LINKS
    HWND hwndItem = GetDlgItem(hDlg, idControl);

    SetDlgItemText(hDlg, idControl, pszText);
    if (fSetTabStop)
    {
        // We also want to add the WS_TABSTOP attribute for accessibility.
        SetWindowLong(hwndItem, GWL_STYLE, (WS_TABSTOP | GetWindowLong(hwndItem, GWL_STYLE)));
    }
    else
    {
        // We want to remove the tab stop behavior and we do that by removing
        // the LWIS_ENABLED attribute
        LWITEM item = {0};

        item.mask       = (LWIF_ITEMINDEX | LWIF_STATE);
        item.stateMask  = LWIS_ENABLED;
        item.state      = 0;     // 0 if we want it disabled.
        item.iLink      = 0;

        hr = (SendMessage(hwndItem, LWM_SETITEM, 0, (LPARAM)&item) ? S_OK : E_FAIL);
    }

#else // FEATURE_LINKS
    SetDlgItemText(hDlg, idControl, pszText);
#endif // FEATURE_LINKS

    return hr;
}


//*************************************************************
//  Purpose:    Sets or clears an image in a static control.
//
//  Parameters: control  -   handle of static control
//              resource -   resource / filename of bitmap
//              fl       -   SCB_ flags:
//                SCB_FROMFILE      'resource' specifies a filename instead of a resource
//                SCB_REPLACEONLY   only put the new image up if there was an old one
//
//  Return:     (BOOL) TRUE if successful
//                     FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/24/95     ericflo    Ported
//*************************************************************
#define SCB_FROMFILE     (0x1)
#define SCB_REPLACEONLY  (0x2)
BOOL SetClearBitmap( HWND control, LPCTSTR resource, UINT fl )
{
    HBITMAP hbm = (HBITMAP)SendMessage(control, STM_GETIMAGE, IMAGE_BITMAP, 0);

    if( hbm )
    {
        DeleteObject( hbm );
    }
    else if( fl & SCB_REPLACEONLY )
    {
        return FALSE;
    }

    if( resource )
    {
        SendMessage(control, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)
            LoadImage( hInstance, resource, IMAGE_BITMAP, 0, 0,
            LR_LOADTRANSPARENT | LR_LOADMAP3DCOLORS |
            ( ( fl & SCB_FROMFILE )? LR_LOADFROMFILE : 0 ) ) );
    }

    return
        ((HBITMAP)SendMessage(control, STM_GETIMAGE, IMAGE_BITMAP, 0) != NULL);
}

BOOL IsLowColor (HWND hDlg)
{
    BOOL fLowColor = FALSE;
    HDC hdc = GetDC(hDlg);
    if (hdc)
    {
        INT iColors = GetDeviceCaps( hdc, NUMCOLORS );
        fLowColor = ((iColors != -1) && (iColors <= 256));
        ReleaseDC(hDlg, hdc);
    }
    return fLowColor;
}

HRESULT _GetLinkInfo(HKEY hkey, LPCTSTR pszLanguageKey, int nIndex, LPTSTR pszLink, SIZE_T cchNameSize)
{
    DWORD cbSize = (DWORD)(cchNameSize * sizeof(pszLink[0]));
    TCHAR szIndex[10];
    DWORD dwError;

    wnsprintf(szIndex, ARRAYSIZE(szIndex), TEXT("%03d"), nIndex);
    dwError = SHGetValue(hkey, pszLanguageKey, szIndex, NULL, (void *) pszLink, &cbSize);
    
    return HRESULT_FROM_WIN32(dwError);
}


// GSierra is worried that if we allow admins to put an arbirary
// number of OEM links that they will abuse the privalage.
// So we use this arbitrary limit.  PMs may want to change it in
// the future.
#define ARTIFICIAL_MAX_SLOTS            3

HRESULT AddOEMHyperLinks(HWND hDlg, int * pControlID)
{
    HKEY hkey;
    DWORD dwError;
    HRESULT hr;
    
    g_nStartOfOEMLinks = *pControlID;
    dwError = RegOpenKey(HKEY_LOCAL_MACHINE, SZ_REGKEY_MYCOMP_OEMLINKS, &hkey);
    hr = HRESULT_FROM_WIN32(dwError);

    if (hkey)
    {
        int nIndex;

        // While we have room and haven't hit the limit.
        for (nIndex = 0; ((nIndex <= ARTIFICIAL_MAX_SLOTS) &&
               (*pControlID <= LAST_GEN_MACHINES_SLOT)); nIndex++)
        {
            TCHAR szLink[2 * MAX_URL_STRING];
            TCHAR szLanguageKey[10];

            wnsprintf(szLanguageKey, ARRAYSIZE(szLanguageKey), TEXT("%u"), GetACP());
            hr = _GetLinkInfo(hkey, szLanguageKey, nIndex, szLink, ARRAYSIZE(szLink));
            if (FAILED(hr) && (CP_ENGLISH != GetACP()))
            {
                // We failed to find it in the natural language, so try English.
                hr = _GetLinkInfo(hkey, SZ_REGKEY_MYCOMP_OEMENGLISH, nIndex, szLink, ARRAYSIZE(szLink));
            }

            if (SUCCEEDED(hr))
            {
                // TODO: Find out how to turn on the link control and set the URL.
                _SetMachineInfoLine(hDlg, *pControlID, szLink, TRUE);
            }

            (*pControlID)++;
        }

        RegCloseKey(hkey);
    }

    return hr;
}


HRESULT HrSysAllocStringW(IN const OLECHAR * pwzSource, OUT BSTR * pbstrDest)
{
    HRESULT hr = S_OK;

    if (pbstrDest)
    {
        *pbstrDest = SysAllocString(pwzSource);
        if (pwzSource)
        {
            if (*pbstrDest)
                hr = S_OK;
            else
                hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


HRESULT SetWMISecurityBlanket(IN IUnknown * punk, IUnknown * punkToPass)
{
    IClientSecurity * pClientSecurity;
    HRESULT hr = punk->QueryInterface(IID_PPV_ARG(IClientSecurity, &pClientSecurity));
    TraceMsg(TF_ALWAYS, "IEnumWbemClassObject::QueryInterface(IClientSecurity) called and hr=%#08lx", hr);

    if (SUCCEEDED(hr))
    {
        // Nuke after we get this working. RPC_C_AUTHN_NONE , RPC_C_AUTHZ_NAME 
        hr = pClientSecurity->SetBlanket(punk, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
                        RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE);
        TraceMsg(TF_ALWAYS, "IClientSecurity::SetBlanket() called and hr=%#08lx", hr);
        pClientSecurity->Release();
    }

    return hr;
}


// DESCRIPTION:
//      WMI's Win32_Processor object will return a lot of rich information.
// We use this because we want rich information even if the processor doesn't
// provide it (like intel pre-Willette).  Millennium uses cpuid.asm as a
// hack and we want to prevent from copying that because there is a political
// pressure from the NT team to intel to have the processors provide this
// information.  That way the OS doesn't need to rev to include new processor
// names when they are released.  WMI does something to generate good results
// (\admin\wmi\WBEM\Providers\Win32Provider\Providers\processor.cpp) which
// includes asm.  I don't know if it's the exact same logic as Millennium and
// I don't care.  The important fact is that they are the only ones to maintain
// any hard coded list.  Therefore we are willing to use their poorly written
// API so we can re-use code and get out of the maintaince problems.
HRESULT GetWMI_Win32_Processor(OUT IEnumWbemClassObject ** ppEnumProcessors)
{
    HRESULT hr = E_NOTIMPL;

    *ppEnumProcessors = NULL;
    // Our second try is to use the WMI automation object.  It has a Win32_Processor object
    // that can give us a good Description, even when SZ_REGVALUE_PROCESSORNAMESTRING
    // isn't set.
    IWbemLocator * pLocator;

    hr = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IWbemLocator, &pLocator));
    if (SUCCEEDED(hr))
    {
        hr = E_OUTOFMEMORY;
        BSTR bstrLocalMachine = SysAllocString(L"root\\cimv2");
        if (bstrLocalMachine)
        {
            IWbemServices * pIWbemServices;

            hr = pLocator->ConnectServer(bstrLocalMachine, NULL, NULL, 0L, 0L, NULL, NULL, &pIWbemServices);
            TraceMsg(TF_ALWAYS, "IWbemLocator::ConnectServer() called and hr=%#08lx", hr);
            if (SUCCEEDED(hr))
            {
                hr = E_OUTOFMEMORY;
                BSTR bstrQueryLang = SysAllocString(L"WQL");
                BSTR bstrQuery = SysAllocString(SZ_WMI_WQL_QUERY_STRING);
                if (bstrQueryLang && bstrQuery)
                {
                    IEnumWbemClassObject * pEnum = NULL;
                    hr = pIWbemServices->ExecQuery(bstrQueryLang, bstrQuery, (WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY), NULL , &pEnum);                        
                    TraceMsg(TF_ALWAYS, "IWbemServices::CreateInstanceEnum() called and hr=%#08lx", hr);
                    if (SUCCEEDED(hr))
                    {
                        hr = SetWMISecurityBlanket(pEnum, pIWbemServices);
                        TraceMsg(TF_ALWAYS, "SetWMISecurityBlanket() called and hr=%#08lx", hr);
                        if (SUCCEEDED(hr))
                        {
                            hr = pEnum->QueryInterface(IID_PPV_ARG(IEnumWbemClassObject, ppEnumProcessors));
                        }
                        pEnum->Release();
                    }
                }
                SysFreeString(bstrQuery); // SysFreeString is happy to take NULL             
                SysFreeString(bstrQueryLang);
                pIWbemServices->Release();
            }
            SysFreeString(bstrLocalMachine);
        }
        pLocator->Release();
    }

    return hr;
}


HRESULT GetProcessorDescFromWMI(PROCESSOR_INFO *ppi)
{
    IEnumWbemClassObject * pEnumProcessors;
    HRESULT hr = GetWMI_Win32_Processor(&pEnumProcessors);

    if (SUCCEEDED(hr))
    {
        IWbemClassObject * pProcessor;
        ULONG ulRet;

        // Currently we only care about the first processor.
        hr = pEnumProcessors->Next(WBEM_INFINITE, 1, &pProcessor, &ulRet);
        TraceMsg(TF_ALWAYS, "IEnumWbemClassObject::Next() called and hr=%#08lx", hr);
        if (SUCCEEDED(hr))
        {
            VARIANT varProcessorName = {0};

            hr = pProcessor->Get(SZ_WMI_WIN32PROCESSOR_ATTRIB_NAME, 0, &varProcessorName, NULL, NULL);
            if (SUCCEEDED(hr))
            {
                VARIANT varProcessorSpeed = {0};

                hr = pProcessor->Get(SZ_WMI_WIN32PROCESSOR_ATTRIB_SPEED, 0, &varProcessorSpeed, NULL, NULL);
                if (SUCCEEDED(hr) && 
                    VT_I4   == varProcessorSpeed.vt && 
                    varProcessorSpeed.lVal < WMI_WIN32PROCESSOR_SPEEDSTEP_CUTOFF) // we're in speed step power-saving mode
                {
                    hr = pProcessor->Get(SZ_WMI_WIN32PROCESSOR_ATTRIB_MAXSPEED, 0, &varProcessorSpeed, NULL, NULL);
                }

                if (SUCCEEDED(hr))
                {
                    if ((VT_BSTR == varProcessorName.vt) && (VT_I4 == varProcessorSpeed.vt))
                    {                        
                        StrCpyN(ppi->szProcessorDesc, varProcessorName.bstrVal, ARRAYSIZE(ppi->szProcessorDesc));                        

                        TCHAR szTemplate[MAX_PATH];
                        UINT idStringTemplate = IDS_PROCESSOR_SPEED;
                        szTemplate[0] = 0;

                        if (MHZ_TO_GHZ_THRESHHOLD <= varProcessorSpeed.lVal)
                        {
                            TCHAR szSpeed[20];
                            double dGHz = (varProcessorSpeed.lVal / (double)1000.0);

                            // Someone released a "1.13 GHz" chip, so let's display that correctly...
                            _snwprintf(szSpeed, ARRAYSIZE(szSpeed), TEXT("%1.2f"), dGHz);
                            LoadString(hInstance, IDS_PROCESSOR_SPEEDGHZ, szTemplate, ARRAYSIZE(szTemplate));
                            wnsprintf(ppi->szProcessorClockSpeed, ARRAYSIZE(ppi->szProcessorClockSpeed), szTemplate, szSpeed);
                        }
                        else
                        {
                            LoadString(hInstance, IDS_PROCESSOR_SPEED, szTemplate, ARRAYSIZE(szTemplate));
                            wnsprintf(ppi->szProcessorClockSpeed, ARRAYSIZE(ppi->szProcessorClockSpeed), szTemplate, varProcessorSpeed.lVal);
                        }
                    }
                    else
                    {
                        hr = E_FAIL;
                    }
                }

                VariantClear(&varProcessorSpeed);
            }

            VariantClear(&varProcessorName);
            pProcessor->Release();
        }

        pEnumProcessors->Release();
    }

    return hr;
}


HRESULT GetProcessorInfoFromRegistry(HKEY hkey, PROCESSOR_INFO *ppi)
{
    HRESULT hr = E_FAIL;
    TCHAR szTemp[MAX_PROCESSOR_DESCRIPTION];
    *szTemp = NULL;
    DWORD cbData = sizeof(szTemp);
    //To avoid copying blank string.
    if ((RegQueryValueEx(hkey, SZ_REGVALUE_PROCESSORNAMESTRING, 0, 0, (LPBYTE)szTemp, &cbData) == ERROR_SUCCESS) &&
        (*szTemp != NULL) && (cbData > 1))
    {
        //ISSUE - How do I get the processor clock speed. 
        StrCpyN(ppi->szProcessorDesc, szTemp, MAX_PROCESSOR_DESCRIPTION);
        hr = S_OK;
    }
    return hr;
}



// This is the number of chars that will fit on one line in our dialog
// with the current layout.
#define SIZE_CHARSINLINE            30

BOOL _GetProcessorDescription(PROCESSOR_INFO* ppi, BOOL* pbShowClockSpeed)
{
    BOOL bShowProcessorInfo = FALSE;
    *pbShowClockSpeed = TRUE;
    HKEY hkey;

    // In general, WMI is a lowse API.  However, they provide the processor description on
    // downlevel so we need them.  They implement this in a hacky way so we want them to
    // maintain the hack and all the problems associated with it.  We need to turn this feature
    // off until they fix their bugs.  Currently, they call JET which recently regressed and
    // causes their API to take 10-20 seconds.  -BryanSt
    if (SHRegGetBoolUSValue(SZ_REGKEY_HARDWARE, SZ_REGKEY_USE_WMI, FALSE, TRUE))
    {
        if (SUCCEEDED(GetProcessorDescFromWMI(ppi)))
        {
            bShowProcessorInfo = TRUE;
        }
    }


    if (RegOpenKey(HKEY_LOCAL_MACHINE, SZ_REGKEY_HARDWARE_CPU, &hkey) == ERROR_SUCCESS)
    {
        // Try for ProcessorNameString if present.
        // This registry entry will contain the most correct description of the processor
        // because it came directly from the CPU.  AMD and Cyrix support this but
        // intel won't until Willette.
        if (FAILED(GetProcessorInfoFromRegistry(hkey, ppi)))
        {
            if (!bShowProcessorInfo)
            {
                // Our last try is to use the generic Identifier.  This is normally formatted like,
                // "x86 Family 6 Model 7 Stepping 3" but it's better than nothing.
                DWORD cbData = sizeof(ppi->szProcessorDesc);
                if (RegQueryValueEx(hkey, c_szIndentifier, 0, 0, (LPBYTE)ppi->szProcessorDesc, &cbData) == ERROR_SUCCESS)
                {
                    bShowProcessorInfo = TRUE;
                    *pbShowClockSpeed = FALSE;
                }
            }
        }
        RegCloseKey(hkey);
    }

    return bShowProcessorInfo;    
}

void _SetProcessorDescription(HWND hDlg, PROCESSOR_INFO* ppi, BOOL bShowClockSpeed, BOOL bShowProcessorInfo, int * pnControlID)
{
    if (bShowProcessorInfo)
    {
        TCHAR szProcessorLine1[MAX_PATH];
        TCHAR szProcessorLine2[MAX_PATH];

        // We need to get the CPU name from the CPU itself so we don't
        // need to rev our OS's INF files every time they ship a new processor.  So we guaranteed
        // them that we would display whatever string they provide in whatever way they provide it
        // up to 49 chars.  The layout on the dlg doesn't allow 49 chars on one line so we need to wrap
        // in that case.  Whistler #159510.
        // Don't change this without talking to me (BryanSt) or JVert.
        //
        // Note: there is often talk of stripping leading spaces.  Intel even asks software to do this.
        //   (http://developer.intel.com/design/processor/future/manuals/CPUID_Supplement.htm)
        // However, we SHOULD NOT do this.  This call was defined and standardized by AMD long ago. 
        //   The rule we make is they must be compatible with AMDs existing implementation.
        //   (http://www.amd.com/products/cpg/athlon/techdocs/pdf/20734.pdf)
        // Contact JVert for questions on stripping leading spaces.
        
        StrCpyN(szProcessorLine1, ppi->szProcessorDesc, ARRAYSIZE(szProcessorLine1));        
        szProcessorLine2[0] = 0;

        if (SIZE_CHARSINLINE < lstrlen(szProcessorLine1))
        {
            // Now word wrap
            TCHAR* pszWrapPoint = StrRChr(szProcessorLine1, szProcessorLine1 + SIZE_CHARSINLINE, TEXT(' '));
            if (pszWrapPoint)
            {
                StrCpyN(szProcessorLine2, pszWrapPoint + 1, ARRAYSIZE(szProcessorLine2));
                *pszWrapPoint = 0;
            }
            else // if no space found, just wrap at SIZE_CHARSINLINE
            {
                StrCpyN(szProcessorLine2, &szProcessorLine1[SIZE_CHARSINLINE], ARRAYSIZE(szProcessorLine2));
                szProcessorLine1[SIZE_CHARSINLINE] = 0;
            }
        }

        _SetMachineInfoLine(hDlg, (*pnControlID)++, szProcessorLine1, FALSE);
        if (szProcessorLine2[0])
        {
            _SetMachineInfoLine(hDlg, (*pnControlID)++, szProcessorLine2, FALSE);
        }

        if (bShowClockSpeed)
        {
           _SetMachineInfoLine(hDlg, (*pnControlID)++, ppi->szProcessorClockSpeed, FALSE);
        }
    }
}


typedef struct _OSNAMEIDPAIR {
    UINT iOSType;
    UINT iOSName;
} OSNAMEIDPAIR;

//*************************************************************
//  Purpose:    Initalize the general page
//
//  Parameters: hDlg -  Handle to the dialog box
//
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              11/20/95    ericflo    Ported
//*************************************************************
VOID InitGeneralDlg(HWND hDlg)
{
    OSVERSIONINFO ver;
    TCHAR szScratch1[64];
    TCHAR szScratch2[64];
    DWORD cbData;
    HKEY hkey;
    int ctlid;
    UINT uXpSpLevel = 0;
    HMODULE hResourceDll = hInstance;

    // Set the default bitmap
    SetClearBitmap(GetDlgItem(hDlg, IDC_GEN_WINDOWS_IMAGE), 
                   IsLowColor(hDlg) ? MAKEINTRESOURCE(IDB_WINDOWS_256) : MAKEINTRESOURCE(IDB_WINDOWS), 0);

    // Query for the build number information
    ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if (!GetVersionEx(&ver)) {
        return;
    }

    // IDC_GEN_VERSION_0: Major Branding ("Windows XP")
    // todo: for now, everything is "Windows XP". must change for blackcomb
    UINT id = IDS_WINVER_WINDOWSXP;
    LoadString(hInstance, id, szScratch1, ARRAYSIZE(szScratch1));
    SetDlgItemText(hDlg, IDC_GEN_VERSION_0, szScratch1);

    // IDC_GEN_VERSION_1: Minor Branding ("Personal", "Professional", etc)
    szScratch1[0] = TEXT('\0');
    id = 0;
    // note: OS_EMBEDDED must be before any options that may co-occur with OS_EMBEDDED
#ifndef _WIN64
    OSNAMEIDPAIR rgID[] = {{OS_EMBEDDED, IDS_WINVER_EMBEDDED},
                           {OS_TABLETPC, IDS_WINVER_TABLETPC_SYSDM_CPL},
                           {OS_MEDIACENTER, IDS_WINVER_MEDIACENTER_SYSDM_CPL},
                           {OS_PERSONAL, IDS_WINVER_PERSONAL}, 
                           {OS_PROFESSIONAL, IDS_WINVER_PROFESSIONAL}, 
                           {OS_SERVER, IDS_WINVER_SERVER}, 
                           {OS_ADVSERVER, IDS_WINVER_ADVANCEDSERVER}, 
                           {OS_DATACENTER, IDS_WINVER_DATACENTER}};
#else
    OSNAMEIDPAIR rgID[] = {{OS_PROFESSIONAL, IDS_WINVER_PROFESSIONAL_WIN64}, 
                           {OS_SERVER, IDS_WINVER_SERVER}, 
                           {OS_ADVSERVER, IDS_WINVER_ADVANCEDSERVER}, 
                           {OS_DATACENTER, IDS_WINVER_DATACENTER}};
#endif

    for (int i = 0; i < ARRAYSIZE(rgID); i++)
    {
        if (IsOS(rgID[i].iOSType))
        {
            // Do a special test now to determine if this resource was added
            // for a Windows XP service pack.

            switch (rgID[i].iOSType)
            {
            case OS_TABLETPC:
            case OS_MEDIACENTER:
                uXpSpLevel = 1;
                break;
            }

            id = (rgID[i].iOSName);
            break;
        }
    };

    // If this string resource was added for a Windows XP service pack, and
    // lives in a special resource DLL, attempt to load it now. If this
    // fails, revert to the Professional string resource.
    
    if (uXpSpLevel > 0)
    {
        hResourceDll = LoadLibraryEx(TEXT("winbrand.dll"),
                                     NULL, 
                                     LOAD_LIBRARY_AS_DATAFILE);

        if (hResourceDll == NULL)
        {
            hResourceDll = hInstance;
            id = IDS_WINVER_PROFESSIONAL;
        }
    }

    LoadString(hResourceDll, id, szScratch1, ARRAYSIZE(szScratch1));

    if (hResourceDll != hInstance)
    {
        FreeLibrary(hResourceDll);
    }

    SetDlgItemText(hDlg, IDC_GEN_VERSION_1, szScratch1);
        
    // IDC_GEN_VERSION_2: Version Year ("Version 2002", etc)

    // set szScratch2 to "Debug" if the debugging version of USER.EXE is installed
    if (GetSystemMetrics(SM_DEBUG)) 
    {
        szScratch2[0] = TEXT(' ');
        LoadString(hInstance, IDS_DEBUG, &szScratch2[1], ARRAYSIZE(szScratch2));
    } 
    else 
    {
        szScratch2[0] = TEXT('\0');
    }
    // todo: for now, everything is 2002.  For Blackcomb we'll need to update this.
    LoadString(hInstance, IDS_WINVER_2002, szScratch1, ARRAYSIZE(szScratch1));
    StrCatBuff(szScratch1, szScratch2, ARRAYSIZE(szScratch1));
    SetDlgItemText(hDlg, IDC_GEN_VERSION_2, szScratch1);

    // IDC_GEN_SERVICE_PACK: Service Pack (if any)
    SetDlgItemText(hDlg, IDC_GEN_SERVICE_PACK, ver.szCSDVersion);

    if (RegOpenKey(HKEY_LOCAL_MACHINE, c_szAboutKey, &hkey) == ERROR_SUCCESS)
    {
        // Do registered user info
        ctlid = IDC_GEN_REGISTERED_0;  // start here and use more as needed

        cbData = ARRAYSIZE( szScratch2 ) * sizeof (TCHAR);
        if( (RegQueryValueEx(hkey, c_szAboutRegisteredOwner,
            NULL, NULL, (LPBYTE)szScratch2, &cbData) == ERROR_SUCCESS) &&
            ( cbData > 1 ) )
        {
            SetDlgItemText(hDlg, ctlid++, szScratch2);
        }

        cbData = ARRAYSIZE( szScratch2 ) * sizeof (TCHAR);
        if( (RegQueryValueEx(hkey, c_szAboutRegisteredOrganization,
            NULL, NULL, (LPBYTE)szScratch2, &cbData) == ERROR_SUCCESS) &&
            ( cbData > 1 ) )
        {
            SetDlgItemText(hDlg, ctlid++, szScratch2);
        }

        cbData = ARRAYSIZE( szScratch2 ) * sizeof (TCHAR);
        if( (RegQueryValueEx(hkey, c_szAboutProductId,
            NULL, NULL, (LPBYTE)szScratch2, &cbData) == ERROR_SUCCESS) &&
            ( cbData > 1 ) )
        {
            SetDlgItemText(hDlg, ctlid++, szScratch2);
        }

        cbData = ARRAYSIZE( szScratch2 ) * sizeof (TCHAR);
        if( (RegQueryValueEx(hkey, c_szAboutAnotherProductId,
            NULL, NULL, (LPBYTE)szScratch2, &cbData) == ERROR_SUCCESS) &&
            ( cbData > 1 ) )
        {
            SetDlgItemText(hDlg, ctlid++, szScratch2);
        }

        RegCloseKey(hkey);
    }    

    SHCreateThread(InitGeneralDlgThread, hDlg, CTF_COINIT | CTF_FREELIBANDEXIT, NULL);
}

DWORD WINAPI InitGeneralDlgThread(LPVOID lpParam)
{
    SYSTEM_BASIC_INFORMATION BasicInfo;
    NTSTATUS Status;
    
    if (!lpParam)
        return -1;
    
    INITDLGSTRUCT* pids = (INITDLGSTRUCT*)LocalAlloc(LPTR, sizeof(INITDLGSTRUCT));
    if (pids)
    {
        // Memory
        Status = NtQuerySystemInformation(
                    SystemBasicInformation,
                    &BasicInfo,
                    sizeof(BasicInfo),
                    NULL
                    );

        if (NT_SUCCESS(Status))
        {
            LONGLONG nTotalBytes = BasicInfo.NumberOfPhysicalPages; 

            nTotalBytes *= BasicInfo.PageSize;

            // WORKAROUND - NtQuerySystemInformation doesn't really return the total available physical
            // memory, it instead just reports the total memory seen by the Operating System. Since
            // some amount of memory is reserved by BIOS, the total available memory is reported 
            // incorrectly. To work around this limitation, we convert the total bytes to 
            // the nearest 4MB value
        
            #define ONEMB 1048576  //1MB = 1048576 bytes.
            double nTotalMB =  (double)(nTotalBytes / ONEMB);
            pids->llMem = (LONGLONG)((ceil(ceil(nTotalMB) / 4.0) * 4.0) * ONEMB);
        }

        pids->fShowProcName = _GetProcessorDescription(&pids->pi, &pids->fShowProcSpeed);

        PostMessage((HWND)lpParam, SYSCPL_ASYNC_COMPUTER_INFO, (WPARAM)pids, 0);
    }

    return 0;
}

VOID CompleteGeneralDlgInitialization(HWND hDlg, INITDLGSTRUCT* pids)
{
    TCHAR oemfile[MAX_PATH];
    int ctlid;
    NTSTATUS Status;
    HKEY hkey;
    TCHAR szScratch1[64];
    TCHAR szScratch2[64];
    TCHAR szScratch3[64];
    DWORD cbData;

    // Do machine info
    ctlid = IDC_GEN_MACHINE_0;  // start here and use controls as needed

    // if OEM name is present, show logo and check for phone support info
    if (!GetSystemDirectory(oemfile, ARRAYSIZE(oemfile)))
    {
        oemfile[0] = 0;
    }

    if( oemfile[ lstrlen( oemfile ) - 1 ] != TEXT('\\') )
        lstrcat( oemfile, TEXT("\\"));
    lstrcat( oemfile, c_szOemFile );

    if (!PathFileExists(oemfile))
    {
        // On Win9x, the oeminfo files went in %windir%\system,
        // so we need to look in there, as well.
        if (GetWindowsDirectory(oemfile, ARRAYSIZE(oemfile)))
        {
            if (oemfile[lstrlen(oemfile)-1] != TEXT('\\'))
                lstrcat(oemfile, TEXT("\\"));
        }
        
        lstrcat(oemfile, c_szSystemDir);
        lstrcat(oemfile, c_szOemFile);

        if (PathFileExists(oemfile)) {
            g_fWin9xUpgrade = TRUE;
        } 

    }

    if( GetPrivateProfileString( c_szOemGenSection, c_szOemName, c_szEmpty,
        szScratch1, ARRAYSIZE( szScratch1 ), oemfile ) )
    {
        _SetMachineInfoLine(hDlg, ctlid++, szScratch1, FALSE);

        if( GetPrivateProfileString( c_szOemGenSection, c_szOemModel,
            c_szEmpty, szScratch1, ARRAYSIZE( szScratch1 ), oemfile ) )
        {
            _SetMachineInfoLine(hDlg, ctlid++, szScratch1, FALSE);
        }

        lstrcpy( szScratch2, c_szOemSupportLinePrefix );
        lstrcat( szScratch2, TEXT("1") );

        if( GetPrivateProfileString( c_szOemSupportSection,
            szScratch2, c_szEmpty, szScratch1, ARRAYSIZE( szScratch1 ), oemfile ) )
        {
            HWND wnd = GetDlgItem( hDlg, IDC_GEN_OEM_SUPPORT );

            EnableWindow( wnd, TRUE );
            ShowWindow( wnd, SW_SHOW );
        }

        if (g_fWin9xUpgrade)
        {
            if (GetWindowsDirectory( oemfile, ARRAYSIZE( oemfile ) ))
            {
                if( oemfile[ lstrlen( oemfile ) - 1 ] != TEXT('\\') )
                    lstrcat( oemfile, TEXT("\\") );
            }
            else
            {
                oemfile[0] = 0;
            }
            lstrcat(oemfile, c_szSystemDir);
            lstrcat( oemfile, c_szOemImageFile );
        }
        else {
            if (!GetSystemDirectory( oemfile, ARRAYSIZE( oemfile ) ))
            {
                oemfile[0] = 0;
            }
            if( oemfile[ lstrlen( oemfile ) - 1 ] != TEXT('\\') )
                lstrcat( oemfile, TEXT("\\") );
            lstrcat( oemfile, c_szOemImageFile );
        }

        if( SetClearBitmap( GetDlgItem( hDlg, IDC_GEN_OEM_IMAGE ), oemfile,
            SCB_FROMFILE ) )
        {
            ShowWindow( GetDlgItem( hDlg, IDC_GEN_OEM_NUDGE ), SW_SHOWNA );
            ShowWindow( GetDlgItem( hDlg, IDC_GEN_MACHINE ), SW_HIDE );
        }
    }

    // Get Processor Description
    _SetProcessorDescription(hDlg, &pids->pi, pids->fShowProcSpeed, pids->fShowProcName, &ctlid);

    // System identifier
    if (RegOpenKey(HKEY_LOCAL_MACHINE, SZ_REGKEY_HARDWARE, &hkey) == ERROR_SUCCESS)
    {
        cbData = ARRAYSIZE( szScratch2 ) * sizeof (TCHAR);
        if (RegQueryValueEx(hkey, c_szIndentifier, 0, 0, (LPBYTE)szScratch2, &cbData) == ERROR_SUCCESS)
        {
            // Some OEMs put "AT/AT Compatible" as the System Identifier.  Since this
            // is completely obsolete, we may want to have a feature that simply ignores
            // it.
#ifdef FEATURE_IGNORE_ATCOMPAT
            if (StrCmpI(szScratch2, SZ_ATCOMPATIBLE))
#endif // FEATURE_IGNORE_ATCOMPAT
            {
                _SetMachineInfoLine(hDlg, ctlid++, szScratch2, FALSE);
            }
        }

        RegCloseKey(hkey);
    }            
        
    StrFormatByteSize(pids->llMem, szScratch1, ARRAYSIZE(szScratch1));
    LoadString(hInstance, IDS_XDOTX_MB, szScratch3, ARRAYSIZE(szScratch3));
    wnsprintf(szScratch2, ARRAYSIZE(szScratch2), szScratch3, szScratch1);
    _SetMachineInfoLine(hDlg, ctlid++, szScratch2, FALSE);
    

    // Physical address extension
    Status = RegOpenKey(
        HKEY_LOCAL_MACHINE,
        c_szMemoryManagement,
        &hkey
    );
    
    if (ERROR_SUCCESS == Status)
    {
        DWORD paeEnabled;

        Status = RegQueryValueEx(
            hkey,
            c_szPhysicalAddressExtension,
            NULL,
            NULL,
            (LPBYTE)&paeEnabled,
            &cbData
        );

        if (ERROR_SUCCESS == Status &&
            sizeof(paeEnabled) == cbData &&
            0 != paeEnabled) {
            LoadString(hInstance, IDS_PAE, szScratch1, ARRAYSIZE(szScratch1));
            _SetMachineInfoLine(hDlg, ctlid++, szScratch1, FALSE);
        }

        RegCloseKey(hkey);
    }

    AddOEMHyperLinks(hDlg, &ctlid);
}

HRESULT _DisplayHelp(LPHELPINFO lpHelpInfo)
{
    // We will call WinHelp() unless it's an OEM link
    // because in that case, we don't know what to show.
    if ((g_nStartOfOEMLinks <= lpHelpInfo->iCtrlId) &&      // Is it outside of the IDC_GEN_MACHINE_* range used by OEM Links?
        (LAST_GEN_MACHINES_SLOT >= lpHelpInfo->iCtrlId) &&   // Is it outside of the IDC_GEN_MACHINE_* range used by OEM Links?
        (IDC_GEN_OEM_SUPPORT != lpHelpInfo->iCtrlId))       // Is it outside of the IDC_GEN_MACHINE_* range used by OEM Links?
    {
        int nIndex;

        // This item is an OEM link, so let's mark it as "No Help".
        for (nIndex = 0; nIndex < ARRAYSIZE(aGeneralHelpIds); nIndex++)
        {
            if ((DWORD)lpHelpInfo->iCtrlId == aGeneralHelpIds[nIndex])
            {
                aGeneralHelpIds[nIndex + 1] = NO_HELP;
                break;
            }

            nIndex++;   // We need to skip every other entry because it's a list.
        }
    }

    WinHelp((HWND)lpHelpInfo->hItemHandle, HELP_FILE, HELP_WM_HELP, (DWORD_PTR) (LPSTR) aGeneralHelpIds);
    return S_OK;
}


//*************************************************************
//  Purpose:    Dialog box procedure for general tab
//
//  Parameters: hDlg    -   handle to the dialog box
//              uMsg    -   window message
//              wParam  -   wParam
//              lParam  -   lParam
//
//  Return:     TRUE if message was processed
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              11/17/95    ericflo    Created
//*************************************************************
INT_PTR APIENTRY GeneralDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        InitGeneralDlg(hDlg);
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR*)lParam)->code)
        {
        case PSN_APPLY:
            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
            return TRUE;

        default:
            return FALSE;
        }
        break;

    case WM_COMMAND:
        if (wParam == IDC_GEN_OEM_SUPPORT) {
            DialogBox(hInstance, MAKEINTRESOURCE(IDD_PHONESUP),
                      GetParent(hDlg), PhoneSupportProc);
        }
        break;

    case WM_SYSCOLORCHANGE:
        {
        TCHAR oemfile[MAX_PATH];

        if (g_fWin9xUpgrade)
        {
            if (GetWindowsDirectory( oemfile, ARRAYSIZE( oemfile ) ))
            {
                if( oemfile[ lstrlen( oemfile ) - 1 ] != TEXT('\\') )
                    lstrcat( oemfile, TEXT("\\") );
            }
            else
            {
                *oemfile = TEXT('\0');
            }
            lstrcat(oemfile, c_szSystemDir);
            lstrcat( oemfile, c_szOemImageFile );
        }
        else {
            if (!GetSystemDirectory( oemfile, ARRAYSIZE( oemfile ) ))
            {
                oemfile[0] = 0;
            }

            if( oemfile[ lstrlen( oemfile ) - 1 ] != TEXT('\\') )
                lstrcat( oemfile, TEXT("\\") );
            lstrcat( oemfile, c_szOemImageFile );
        }

        SetClearBitmap(GetDlgItem(hDlg, IDC_GEN_OEM_IMAGE), oemfile, SCB_FROMFILE | SCB_REPLACEONLY);

        SetClearBitmap(GetDlgItem(hDlg, IDC_GEN_WINDOWS_IMAGE), 
                       IsLowColor(hDlg) ? MAKEINTRESOURCE(IDB_WINDOWS_256) : MAKEINTRESOURCE(IDB_WINDOWS), 0);
        }
        break;

    case SYSCPL_ASYNC_COMPUTER_INFO:
        {
            if (wParam)
            {
                CompleteGeneralDlgInitialization(hDlg, (INITDLGSTRUCT*)wParam);
                LocalFree((HLOCAL)wParam);
            }
        }        
        break;
    case WM_DESTROY:
        SetClearBitmap( GetDlgItem( hDlg, IDC_GEN_OEM_IMAGE ), NULL, 0 );
        SetClearBitmap( GetDlgItem( hDlg, IDC_GEN_WINDOWS_IMAGE ), NULL, 0 );
        break;

    case WM_HELP:      // F1
        _DisplayHelp((LPHELPINFO) lParam);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
        (DWORD_PTR) (LPSTR) aGeneralHelpIds);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


//*************************************************************
//
//  PhoneSupportProc()
//
//  Purpose:    Dialog box procedure for OEM phone support dialog
//
//  Parameters: hDlg    -   handle to the dialog box
//              uMsg    -   window message
//              wParam  -   wParam
//              lParam  -   lParam
//
//  Return:     TRUE if message was processed
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              11/17/95    ericflo    Created
//
//*************************************************************

INT_PTR APIENTRY PhoneSupportProc(HWND hDlg, UINT uMsg,
                               WPARAM wParam, LPARAM lParam )
{
    switch( uMsg ) {

        case WM_INITDIALOG:
        {
            HWND edit = GetDlgItem(hDlg, IDC_SUPPORT_TEXT);
            UINT i = 1;  // 1-based by design
            TCHAR oemfile[MAX_PATH];
            TCHAR text[ 256 ];
            TCHAR line[ 12 ];
            LPTSTR endline = line + lstrlen( c_szOemSupportLinePrefix );

            if (g_fWin9xUpgrade)
            {
                if (GetWindowsDirectory( oemfile, ARRAYSIZE( oemfile ) ))
                {
                    if( oemfile[ lstrlen( oemfile ) - 1 ] != TEXT('\\') )
                        lstrcat( oemfile, TEXT("\\") );
                }
                else
                {
                    *oemfile = TEXT('\0');
                }
                lstrcat(oemfile, c_szSystemDir);
                lstrcat( oemfile, c_szOemFile );
            }
            else
            {
                if (!GetSystemDirectory( oemfile, ARRAYSIZE( oemfile ) ))
                {
                    oemfile[0] = 0;
                }

                if( oemfile[ lstrlen( oemfile ) - 1 ] != TEXT('\\') )
                    lstrcat( oemfile, TEXT("\\") );
                lstrcat( oemfile, c_szOemFile );
            }

            GetPrivateProfileString( c_szOemGenSection, c_szOemName, c_szEmpty,
                text, ARRAYSIZE( text ), oemfile );
            SetWindowText( hDlg, text );

            lstrcpy( line, c_szOemSupportLinePrefix );

            SendMessage (edit, WM_SETREDRAW, FALSE, 0);

            for( ;; i++ )
            {
                wsprintf( endline, TEXT("%u"), i );

                GetPrivateProfileString( c_szOemSupportSection,
                    line, c_szDefSupportLineText, text, ARRAYSIZE( text ) - 2,
                    oemfile );

                if( !lstrcmpi( text, c_szDefSupportLineText ) )
                    break;

                lstrcat( text, c_szCRLF );

                SendMessage( edit, EM_SETSEL, (WPARAM)-1, (LPARAM)-1);

                SendMessage( edit, EM_REPLACESEL, 0, (LPARAM)text );
            }

            SendMessage (edit, WM_SETREDRAW, TRUE, 0);
            break;
        }

        case WM_COMMAND:

            switch (LOWORD(wParam)) {
                 case IDOK:
                 case IDCANCEL:
                     EndDialog( hDlg, 0 );
                     break;

                 default:
                     return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\netid.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Network ID Tab hook
// 
// 3-07-98 sburns



#include "sysdm.h"



HPROPSHEETPAGE
CreateNetIDPage(int, DLGPROC)
{
   TCHAR dll_name[MAX_PATH + 1] = {0};
   if (!::LoadString(hInstance, IDS_NETID_DLL_NAME, dll_name, MAX_PATH))
   {
      return 0;
   }

   HPROPSHEETPAGE result = 0;
   HINSTANCE netid = ::LoadLibrary(dll_name);

   if (netid)
   {
      typedef HPROPSHEETPAGE (*CreateProc)();

      CreateProc proc =
         reinterpret_cast<CreateProc>(
            ::GetProcAddress(netid, "CreateNetIDPropertyPage"));

      if (proc)
      {
         result = proc();
      }
   }

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\hwprof.c ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    hwprof.c

Abstract:

    This module contains the dialog box procedure for the Hardware Profiles
    Dialog Box in the System Applet.

Author:

    Paula Tomlinson (paulat) 8-22-1995

Environment:

    User mode only.

Revision History:

    22-Aug-1995     paulat

        Creation and initial implementation.

    21-Jan-1999     jamesca

        Added handling for hardware profile aliases and hardware-detected
        profile attributes.

--*/


//
// include files
//

#include "sysdm.h"
#include <stdlib.h>
#include <usp10.h>
#include <dbt.h>

//
// private types and definitions
//

#define MAX_PROFILES             9999
#define MAX_ALIASES              9999
#define MAX_FRIENDLYNAME_LEN     80
#define MAX_PROFILEID_LEN        5
#define MAX_DOCKID_LEN           128
#define MAX_SERIALNUM_LEN        128

#define MAX_USER_WAIT            500
#define MIN_USER_WAIT            0
#define DEFAULT_USER_WAIT        30

#define MAX_GUID_STRING_LEN      39   // 38 chars + terminating null

typedef struct HWPROFILE_s {
   HWND     hParent;
   ULONG    ulFromProfileID;
   TCHAR    szFromFriendlyName[MAX_FRIENDLYNAME_LEN];
   ULONG    ulToProfileID;
   TCHAR    szToFriendlyName[MAX_FRIENDLYNAME_LEN];
} HWPROFILE, *PHWPROFILE;


typedef struct HWPROF_VALUES_s {
   ULONG    ulAction;
   ULONG    ulProfile;
   ULONG    ulPreferenceOrder;
   ULONG    ulDockState;
   BOOL     bAliasable;
   BOOL     bCloned;
   BOOL     bPortable;
   ULONG    ulCreatedFrom;
   WCHAR    szDockID[MAX_DOCKID_LEN];
   WCHAR    szSerialNumber[MAX_SERIALNUM_LEN];
   WCHAR    szFriendlyName[MAX_FRIENDLYNAME_LEN];
} HWPROF_VALUES, *PHWPROF_VALUES;


typedef struct HWPROF_INFO_s {
   ULONG             ulNumProfiles;
   ULONG             ulActiveProfiles;
   PHWPROF_VALUES    pHwProfValues;
   ULONG             ulSelectedProfile;
   ULONG             ulSelectedProfileIndex;
   BOOL              bPortable;
   BOOL              bHwDetectedPortable;
   ULONG             ulUndockedProfileNameCount;
   ULONG             ulDockedProfileNameCount;
   ULONG             ulUnknownProfileNameCount;
} HWPROF_INFO, *PHWPROF_INFO;


#define HWP_NO_ACTION   0x00000000
#define HWP_DELETE      0x00000001
#define HWP_CREATE      0x00000002
#define HWP_RENAME      0x00000004
#define HWP_REORDER     0x00000008
#define HWP_PROPERTIES  0x00000010
#define HWP_NEWPROFILE  0x00001000

//
// private prototypes
//

BOOL
GetCurrentProfile(
      PULONG  pulProfile
      );

BOOL
GetRegProfileCount(
      PULONG   pulProfiles
      );

BOOL
FillProfileList(
      HWND  hDlg
      );

BOOL
IsProfileNameInUse(
      HWND     hDlg,
      LPTSTR   pszFriendlyName
      );

BOOL
CopyHardwareProfile(
      HWND   hDlg,
      ULONG_PTR ulIndex,
      ULONG  ulProfile,
      LPTSTR szNewFriendlyName
      );

BOOL
RenameHardwareProfile(
      HWND   hDlg,
      ULONG_PTR ulIndex,
      ULONG  ulProfile,
      LPTSTR szNewFriendlyName
      );

BOOL
DeleteHardwareProfile(
      HWND   hDlg,
      ULONG_PTR ulIndex
      );

BOOL
GetUserWaitInterval(
      PULONG   pulWait
      );

BOOL
SetUserWaitInterval(
      ULONG   ulWait
      );

BOOL
GetFreeProfileID(
      PHWPROF_INFO   pInfo,
      PULONG         pulProfile
      );

ULONG
GetOriginalProfile(
      PHWPROF_INFO  pInfo,
      ULONG         ulProfile,
      ULONG         ulBufferIndex
      );

BOOL
InsertRank(
      PHWPROF_INFO   pInfo,
      ULONG          ulRank
      );

BOOL
DeleteRank(
      PHWPROF_INFO   pInfo,
      ULONG          ulRank
      );

BOOL
FlushProfileChanges(
      HWND hDlg,
      HWND hList
      );

BOOL
WriteProfileInfo(
      PHWPROF_VALUES pProfValues
      );

BOOL
RemoveNewProfiles(
      PHWPROF_INFO   pInfo
      );

BOOL
SwapPreferenceOrder(
      HWND  hDlg,
      HWND  hList,
      ULONG_PTR ulIndex1,
      ULONG_PTR ulIndex2
      );

BOOL
DeleteProfileDependentTree(
      ULONG ulProfile
      );

BOOL
CopyAliasEntries(
      ULONG ulSrcProfile,
      ULONG ulDestProfile
      );

BOOL
DeleteAliasEntries(
      ULONG ulProfile
      );

BOOL
CopyAliasEntryType(
      ULONG  ulSrcProfile,
      ULONG  ulDestProfile,
      LPWSTR szSubKeyName
      );

BOOL
DeleteAliasEntryType(
      ULONG  ulProfile,
      LPWSTR szSubKeyName
      );

BOOL
CopyRegistryNode(
      HKEY     hSrcKey,
      HKEY     hDestKey
      );

BOOL
DeleteRegistryNode(
      HKEY     hNodeKey,
      LPTSTR   szSubKey
      );
VOID
AdjustProfileTypeCounter(
      PHWPROF_INFO   pInfo,
      ULONG          ulDockState,
      BOOL           bIncrement
      );

BOOL
StripCurrentTag(
      LPTSTR   szOriginalName,
      ULONG    ulProfile,
      ULONG    ulCurrentProfile
      );

BOOL
AppendCurrentTag(
      LPTSTR   szTaggedName,
      LPCTSTR  szOriginalName,
      ULONG    ulProfile,
      ULONG    ulCurrentProfile
      );

VOID
CreateHwProfileFriendlyName(
      IN  HWND    hDlg,
      IN  ULONG   ulDockState,
      OUT LPTSTR  szFriendlyName
   );

VOID
DisplayPrivateMessage(
      HWND  hDlg,
      UINT  uiPrivateError
      );

VOID
DisplaySystemMessage(
      HWND  hWnd,
      UINT  uiSystemError
      );

BOOL
UpdateOrderButtonState(
      HWND  hDlg
      );

BOOL
DisplayProperties(
      IN HWND           hOwnerDlg,
      IN PHWPROF_INFO   pProfValues
      );

typedef BOOL (CALLBACK FAR * LPFNADDPROPSHEETPAGE)(HPROPSHEETPAGE, LPARAM);


//
// global strings
//
WCHAR pszErrorCaption[MAX_PATH];
WCHAR pszRegDefaultFriendlyName[MAX_FRIENDLYNAME_LEN];
WCHAR pszCurrentTag[64];
WCHAR pszUnavailable[64];
WCHAR pszDocked[64];
WCHAR pszUndocked[64];
WCHAR pszUnknown[64];

WCHAR pszRegIDConfigDB[] = TEXT("System\\CurrentControlSet\\Control\\IDConfigDB");
WCHAR pszRegHwProfiles[] = TEXT("System\\CurrentControlSet\\Hardware Profiles");
WCHAR pszRegKnownDockingStates[] =  TEXT("Hardware Profiles");
WCHAR pszRegCurrentDockInfo[] =     TEXT("CurrentDockInfo");
WCHAR pszRegDockingState[] =        TEXT("DockingState");
WCHAR pszRegAlias[] =               TEXT("Alias");
WCHAR pszRegAcpiAlias[] =           TEXT("AcpiAlias");
WCHAR pszRegProfileNumber[] =       TEXT("ProfileNumber");
WCHAR pszRegCurrentConfig[] =       TEXT("CurrentConfig");
WCHAR pszRegUserWaitInterval[] =    TEXT("UserWaitInterval");
WCHAR pszRegFriendlyName[] =        TEXT("FriendlyName");
WCHAR pszRegPristine[] =            TEXT("Pristine");
WCHAR pszRegHwProfileGuid[] =       TEXT("HwProfileGuid");
WCHAR pszRegPreferenceOrder[] =     TEXT("PreferenceOrder");
WCHAR pszRegDockState[] =           TEXT("DockState");
WCHAR pszRegAliasable[] =           TEXT("Aliasable");
WCHAR pszRegCloned[] =              TEXT("Cloned");
WCHAR pszRegIsPortable[] =          TEXT("IsPortable");
WCHAR pszRegDockID[] =              TEXT("DockID");
WCHAR pszRegSerialNumber[] =        TEXT("SerialNumber");
WCHAR pszRegAcpiSerialNumber[] =    TEXT("AcpiSerialNumber");
WCHAR pszRegPropertyProviders[] =   TEXT("PropertyProviders");
WCHAR pszRegDocked[] =              TEXT("Docked");
WCHAR pszRegUndocked[] =            TEXT("Undocked");
WCHAR pszRegUnknown[] =             TEXT("Unknown");

//
// global mutex for synchronization
//
WCHAR  pszNamedMutex[] =            TEXT("System-HardwareProfiles-PLT");
HANDLE g_hMutex = NULL;

//
// global info for property sheet extensions
//
#define MAX_EXTENSION_PROVIDERS  32
HMODULE        hLibs[MAX_EXTENSION_PROVIDERS];
HPROPSHEETPAGE hPages[MAX_EXTENSION_PROVIDERS];
ULONG          ulNumPages = 0;
BOOL           bAdmin = FALSE;


static int HwProfileHelpIds[] = {
   IDD_HWP_PROFILES,        (IDH_HWPROFILE + IDD_HWP_PROFILES),
   IDD_HWP_PROPERTIES,      (IDH_HWPROFILE + IDD_HWP_PROPERTIES),
   IDD_HWP_COPY,            (IDH_HWPROFILE + IDD_HWP_COPY),
   IDD_HWP_RENAME,          (IDH_HWPROFILE + IDD_HWP_RENAME),
   IDD_HWP_DELETE,          (IDH_HWPROFILE + IDD_HWP_DELETE),
   IDD_HWP_ST_MULTIPLE,     (IDH_HWPROFILE + IDD_HWP_ST_MULTIPLE),
   IDD_HWP_WAITFOREVER,     (IDH_HWPROFILE + IDD_HWP_WAITFOREVER),
   IDD_HWP_WAITUSER,        (IDH_HWPROFILE + IDD_HWP_WAITUSER),
   IDD_HWP_SECONDS,         (IDH_HWPROFILE + IDD_HWP_SECONDS),
   IDD_HWP_SECSCROLL,       (IDH_HWPROFILE + IDD_HWP_SECSCROLL),
   IDD_HWP_COPYTO,          (IDH_HWPROFILE + IDD_HWP_COPYTO),
   IDD_HWP_COPYTO_CAPTION,  (IDH_HWPROFILE + IDD_HWP_COPYTO),
   IDD_HWP_COPYFROM,        (IDH_HWPROFILE + IDD_HWP_COPYFROM),
   IDD_HWP_ST_DOCKID,       (IDH_HWPROFILE + IDD_HWP_ST_DOCKID),
   IDD_HWP_ST_SERIALNUM,    (IDH_HWPROFILE + IDD_HWP_ST_SERIALNUM),
   IDD_HWP_DOCKID,          (IDH_HWPROFILE + IDD_HWP_DOCKID),
   IDD_HWP_SERIALNUM,       (IDH_HWPROFILE + IDD_HWP_SERIALNUM),
   IDD_HWP_PORTABLE,        (IDH_HWPROFILE + IDD_HWP_PORTABLE),
   IDD_HWP_ALIASABLE,       IDH_HWP_PROPERTIES_SELECTION_CHECKBOX,
   IDD_HWP_UNKNOWN,         (IDH_HWPROFILE + IDD_HWP_UNKNOWN),
   IDD_HWP_DOCKED,          (IDH_HWPROFILE + IDD_HWP_DOCKED),
   IDD_HWP_UNDOCKED,        (IDH_HWPROFILE + IDD_HWP_UNDOCKED),
   IDD_HWP_ST_PROFILE,      (IDH_HWPROFILE + IDD_HWP_ST_PROFILE),
   IDD_HWP_ORDERUP,         (IDH_HWPROFILE + IDD_HWP_ORDERUP),
   IDD_HWP_ORDERDOWN,       (IDH_HWPROFILE + IDD_HWP_ORDERDOWN),
   IDD_HWP_RENAMEFROM,      (IDH_HWPROFILE + IDD_HWP_RENAMEFROM),
   IDD_HWP_RENAMETO,        (IDH_HWPROFILE + IDD_HWP_RENAMETO),
   IDD_HWP_RENAMETO_CAPTION,(IDH_HWPROFILE + IDD_HWP_RENAMETO),
   IDD_HWP_WAITUSER_TEXT_1, (IDH_HWPROFILE + IDD_HWP_SECSCROLL),
   IDD_HWP_UNUSED_1,        -1,
   IDD_HWP_UNUSED_2,        -1,
   IDD_HWP_UNUSED_3,        -1,
   IDD_HWP_UNUSED_4,        -1,
   IDD_HWP_UNUSED_5,        -1,
   IDD_HWP_UNUSED_6,        -1,
   0, 0
};


/**-------------------------------------------------------------------------**/
INT_PTR
APIENTRY
HardwareProfilesDlg(
      HWND    hDlg,
      UINT    uMessage,
      WPARAM  wParam,
      LPARAM  lParam
      )

{
   BOOL           Status;
   ULONG          ulCurrentProfile, ulSelectedProfile,
                  ulWait, ulBufferIndex = 0;
   ULONG_PTR      ulIndex;
   LONG           lValue;
   TCHAR          szProfileName[MAX_PATH], szName[MAX_PATH];
   HWND           hList;
   int            nValue;
   HWPROFILE      HwSelectedProfile;
   LPNM_UPDOWN    pUDData;
   PHWPROF_INFO   pInfo;
   HICON          hIcon;


   switch (uMessage)
   {
      case WM_INITDIALOG:
         bAdmin = IsUserAdmin();

         //
         // attempt to claim the named mutex and lock other instances of
         // this dialog box out
         //
         g_hMutex = CreateMutex(NULL, TRUE, pszNamedMutex);

         if (g_hMutex == NULL) {

            if (GetLastError() == ERROR_ALREADY_EXISTS) {
               DisplayPrivateMessage(hDlg, HWP_ERROR_IN_USE);
            } else {
               DisplaySystemMessage(hDlg, GetLastError());
            }

            EndDialog(hDlg, FALSE);
            return FALSE;
         }

         //
         // load some global strings
         //
         LoadString(hInstance, HWP_CURRENT_TAG, pszCurrentTag, 64);
         LoadString(hInstance, HWP_UNAVAILABLE, pszUnavailable, 64);
         LoadString(hInstance, HWP_UNKNOWN_PROFILE,  pszUnknown, 64);
         LoadString(hInstance, HWP_DOCKED_PROFILE,   pszDocked, 64);
         LoadString(hInstance, HWP_UNDOCKED_PROFILE, pszUndocked, 64);
         LoadString(hInstance, HWP_ERROR_CAPTION, pszErrorCaption, MAX_PATH);
         LoadString(hInstance, HWP_DEF_FRIENDLYNAME, pszRegDefaultFriendlyName,
                  MAX_FRIENDLYNAME_LEN);

         //
         // fill the profiles listbox with all installed profiles,
         // this will also select the current profile
         //
         if (!FillProfileList(hDlg)) {
            EndDialog(hDlg, FALSE);
            return FALSE;
         }

         pInfo = (PHWPROF_INFO)GetWindowLongPtr(hDlg, DWLP_USER);

         //
         // place the icons on the up and down selection buttons
         //
         SendDlgItemMessage(
               hDlg, IDD_HWP_ORDERUP, BM_SETIMAGE, (WPARAM)IMAGE_ICON,
               (LPARAM)LoadIcon(hInstance, MAKEINTRESOURCE(UP_ICON)));

         SendDlgItemMessage(
               hDlg, IDD_HWP_ORDERDOWN, BM_SETIMAGE, (WPARAM)IMAGE_ICON,
               (LPARAM)LoadIcon(hInstance, MAKEINTRESOURCE(DOWN_ICON)));

         //
         // update button enable/disable states
         //
         UpdateOrderButtonState(hDlg);

         //
         // disable Delete for the current profile
         //
         EnableWindow(GetDlgItem(hDlg, IDD_HWP_DELETE), FALSE);

         //
         // disable copy if we're already at the max number of profiles
         // (including the pristine profile)
         //
         if ((pInfo->ulNumProfiles+1) > MAX_PROFILES) {
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_COPY), FALSE);
         }

         //
         // initialize the user wait setting
         //
         SendDlgItemMessage(hDlg, IDD_HWP_SECSCROLL, UDM_SETBASE, 10, 0);
         SendDlgItemMessage(hDlg, IDD_HWP_SECSCROLL, UDM_SETRANGE, 0,
                  MAKELONG((SHORT)MAX_USER_WAIT, (SHORT)MIN_USER_WAIT));
         SendDlgItemMessage(hDlg, IDD_HWP_SECONDS, EM_LIMITTEXT, 3, 0L);

         GetUserWaitInterval(&ulWait);

         if (ulWait == 0xFFFFFFFF) {
             CheckRadioButton(hDlg, IDD_HWP_WAITFOREVER, IDD_HWP_WAITUSER,
                              IDD_HWP_WAITFOREVER);
            SendDlgItemMessage(hDlg, IDD_HWP_SECSCROLL, UDM_SETPOS, 0,
                               DEFAULT_USER_WAIT);
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_SECONDS), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_SECSCROLL), FALSE);
         }
         else {
            CheckRadioButton(hDlg, IDD_HWP_WAITFOREVER, IDD_HWP_WAITUSER,
                             IDD_HWP_WAITUSER);
            SendDlgItemMessage(hDlg, IDD_HWP_SECSCROLL, UDM_SETPOS, 0, ulWait);
         }

         //
         // Disable all actions if user not part of administrators local group
         //
         if (!bAdmin) {
             EnableWindow(GetDlgItem(hDlg, IDD_HWP_ORDERUP),    FALSE);
             EnableWindow(GetDlgItem(hDlg, IDD_HWP_PROPERTIES), FALSE);
             EnableWindow(GetDlgItem(hDlg, IDD_HWP_COPY),       FALSE);
             EnableWindow(GetDlgItem(hDlg, IDD_HWP_RENAME),     FALSE);
             EnableWindow(GetDlgItem(hDlg, IDD_HWP_DELETE),     FALSE);
             EnableWindow(GetDlgItem(hDlg, IDD_HWP_ORDERDOWN),  FALSE);
             EnableWindow(GetDlgItem(hDlg, IDD_HWP_WAITFOREVER),FALSE);
             EnableWindow(GetDlgItem(hDlg, IDD_HWP_WAITUSER),   FALSE);
             EnableWindow(GetDlgItem(hDlg, IDD_HWP_WAITUSER_TEXT_1), FALSE);
             EnableWindow(GetDlgItem(hDlg, IDD_HWP_SECONDS),    FALSE);
             EnableWindow(GetDlgItem(hDlg, IDD_HWP_SECSCROLL),  FALSE);
         }
         return 0;


      case WM_HELP:
         WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, HELP_FILE,
               HELP_WM_HELP, (DWORD_PTR)(LPTSTR)HwProfileHelpIds);
         break;

      case WM_CONTEXTMENU:
         WinHelp((HWND)wParam, HELP_FILE, HELP_CONTEXTMENU,
               (DWORD_PTR)(LPTSTR)HwProfileHelpIds);
         break;

      case WM_DESTROY:
          //
          // only free the buffer if we've already initialized
          //
          pInfo = (PHWPROF_INFO)GetWindowLongPtr(hDlg, DWLP_USER);

          if (pInfo) {
              LocalFree((HLOCAL)pInfo->pHwProfValues);
              LocalFree((HLOCAL)pInfo);

              hIcon = (HICON)SendDlgItemMessage(
                    hDlg, IDD_HWP_ORDERUP, BM_GETIMAGE, 0, 0);
              if (hIcon) {
                 DeleteObject(hIcon);
              }

              hIcon = (HICON)SendDlgItemMessage(
                    hDlg, IDD_HWP_ORDERDOWN, BM_GETIMAGE, 0, 0);
              if (hIcon) {
                 DeleteObject(hIcon);
              }
          }
          break;

      case WM_DEVICECHANGE:
          //
          // If a hardware profile change event takes place while the dialog is
          // up, just dismiss the dialog because things have changed.
          //
          if (wParam == DBT_CONFIGCHANGED) {
              EndDialog(hDlg, FALSE);
              return FALSE;
          }
          break;

      case WM_COMMAND:
      {
         switch (LOWORD(wParam))
         {
            case IDOK:
                if (bAdmin) {
                    //
                    // save the user wait interval in the registry
                    //
                    if (IsDlgButtonChecked(hDlg, IDD_HWP_WAITFOREVER)) {
                        ulWait = 0xFFFFFFFF;
                    }
                    else {
                        ulWait = GetDlgItemInt(hDlg, IDD_HWP_SECONDS,
                            &Status, FALSE);
                        if (!Status  ||  ulWait > MAX_USER_WAIT) {
                            TCHAR szCaption[MAX_PATH];
                            TCHAR szMsg[MAX_PATH];

                            LoadString(hInstance, HWP_ERROR_CAPTION, szCaption, MAX_PATH);
                            LoadString(hInstance, HWP_INVALID_WAIT, szMsg, MAX_PATH);
        
                            MessageBox(hDlg, szMsg, szCaption,
                                       MB_OK | MB_ICONEXCLAMATION);
        
                            SetFocus(GetDlgItem(hDlg, IDD_HWP_SECONDS));
        
                            return(TRUE);
                        }
                    }
                    SetUserWaitInterval(ulWait);
    
                    //
                    // flush the pending changes in profile buffer
                    //
                    hList = GetDlgItem(hDlg, IDD_HWP_PROFILES);
                    FlushProfileChanges(hDlg, hList);
                }
                EndDialog(hDlg, 0);
                break;

            case IDCANCEL:
                pInfo = (PHWPROF_INFO)GetWindowLongPtr(hDlg, DWLP_USER);

                if (pInfo) {
                    //
                    // If profile modifications have already been commited from
                    // within the Property Sheet, that's okay. But if accessing
                    // Properties caused any profiles to be created then they
                    // should be removed now since the user is effectively
                    // cancelling that creation now by cancelling from the main
                    // Hardware Profiles dialog.
                    //
                    if (bAdmin) {
                        RemoveNewProfiles(pInfo);
                    }
                }
                SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                EndDialog(hDlg, 0);
                break;

            case IDD_HWP_ORDERUP:
               //
               // move selected profile "up" in preference order
               //
               hList = GetDlgItem(hDlg, IDD_HWP_PROFILES);

               ulIndex = SendMessage(hList, LB_GETCURSEL, 0, 0);
               if (ulIndex == LB_ERR) {
                  break;
               }

               pInfo = (PHWPROF_INFO)GetWindowLongPtr(hDlg, DWLP_USER);

               //
               // if we're not already at the top, swap preferences
               //
               if (ulIndex > 0) {
                  SwapPreferenceOrder(hDlg, hList, ulIndex, ulIndex-1);
                  UpdateOrderButtonState(hDlg);
                  PropSheet_Changed(GetParent(hDlg), hDlg);
               }
               break;


            case IDD_HWP_ORDERDOWN:
               //
               // move selected profile "down" in preference order
               //
               hList = GetDlgItem(hDlg, IDD_HWP_PROFILES);

               ulIndex = SendMessage(hList, LB_GETCURSEL, 0, 0);
               if (ulIndex == LB_ERR) {
                  break;
               }

               pInfo = (PHWPROF_INFO)GetWindowLongPtr(hDlg, DWLP_USER);

               //
               // if we're not already at the bottom, swap preferences
               //
               if (ulIndex < pInfo->ulNumProfiles-1) {
                  SwapPreferenceOrder(hDlg, hList, ulIndex, ulIndex+1);
                  UpdateOrderButtonState(hDlg);
                  PropSheet_Changed(GetParent(hDlg), hDlg);
               }
               break;


            case IDD_HWP_PROFILES:
               //
               // selection changed, enable/disable Delete button based
               // on whether it's the current config that is selected
               //

               if (bAdmin) {

                   if (HIWORD(wParam) == LBN_DBLCLK) {
                      SendMessage(hDlg, WM_COMMAND, MAKELONG(IDD_HWP_PROPERTIES,0), 0);
                   }
                   else if (HIWORD(wParam) == LBN_SELCHANGE) {

                      if (!GetCurrentProfile(&ulCurrentProfile)) {
                         break;
                      }

                      if ((ulIndex = SendMessage((HWND)lParam,
                            LB_GETCURSEL, 0, 0)) == LB_ERR) {
                         break;
                      }

                      if ((lValue = (LONG)SendMessage((HWND)lParam, LB_GETITEMDATA,
                            ulIndex, 0)) == LB_ERR) {
                         break;
                      }

                      if ((ULONG)lValue == ulCurrentProfile) {
                         EnableWindow(GetDlgItem(hDlg, IDD_HWP_DELETE), FALSE);
                      }
                      else {
                         EnableWindow(GetDlgItem(hDlg, IDD_HWP_DELETE), TRUE);
                      }


                      //
                      // update button enable/disable states
                      //
                      UpdateOrderButtonState(hDlg);
                   }
               }
               break;


            case IDD_HWP_WAITFOREVER:
               //
               // if user chooses wait forever, disable the seconds control
               //
               if (HIWORD(wParam) == BN_CLICKED) {
                  EnableWindow(GetDlgItem(hDlg, IDD_HWP_SECONDS), FALSE);
                  EnableWindow(GetDlgItem(hDlg, IDD_HWP_SECSCROLL), FALSE);
                  PropSheet_Changed(GetParent(hDlg), hDlg);
               }
               break;


            case IDD_HWP_WAITUSER:
               //
               // if user chooses a wait interval, reenable seconds control
               //
               if (HIWORD(wParam) == BN_CLICKED) {
                  EnableWindow(GetDlgItem(hDlg, IDD_HWP_SECONDS), TRUE);
                  EnableWindow(GetDlgItem(hDlg, IDD_HWP_SECSCROLL), TRUE);
                  PropSheet_Changed(GetParent(hDlg), hDlg);
               }
               break;


            case IDD_HWP_PROPERTIES:
               //
               // retrieve the profile buffer
               //
               pInfo = (PHWPROF_INFO)GetWindowLongPtr(hDlg, DWLP_USER);

               //
               // get the selected profile
               //
               hList = GetDlgItem(hDlg, IDD_HWP_PROFILES);

               ulIndex = SendMessage(hList, LB_GETCURSEL, 0, 0);
               if (ulIndex == LB_ERR) {
                  break;
               }

               //
               // find the profile entry in the buffer that matches the selection
               //
               hList = GetDlgItem(hDlg, IDD_HWP_PROFILES);
               ulSelectedProfile = (ULONG)SendMessage(hList, LB_GETITEMDATA, ulIndex, 0);

               while (ulBufferIndex < pInfo->ulNumProfiles) {
                  if (pInfo->pHwProfValues[ulBufferIndex].ulProfile == ulSelectedProfile) {
                     break;
                  }
                  ulBufferIndex++;
               }

               //
               // commit the changes for this profile before calling Properties
               //
               WriteProfileInfo(&pInfo->pHwProfValues[ulBufferIndex]);

               //
               // pass the HWPROF_VALUES struct for the selected profile
               // to the property sheet page when it's created. The
               // property sheet may update some of these fields and
               // may also commit changes for this profile to the registry.
               //
               pInfo->ulSelectedProfileIndex = ulBufferIndex;
               pInfo->ulSelectedProfile = (ULONG)SendMessage(hList, LB_GETITEMDATA,
                                                      ulIndex, 0);

               DisplayProperties(hDlg, pInfo);
               //DisplayProperties(hDlg, &pInfo->pHwProfValues[ulBufferIndex]);
               break;


            case IDD_HWP_COPY:               
               //
               // retrieve the profile buffer
               //
               pInfo = (PHWPROF_INFO)GetWindowLongPtr(hDlg, DWLP_USER);

               //
               // get the selected profile, this is the "From" selection
               //
               hList = GetDlgItem(hDlg, IDD_HWP_PROFILES);

               ulIndex = SendMessage(hList, LB_GETCURSEL, 0, 0);
               if (ulIndex == LB_ERR) {
                  break;
               }

               SendMessage(hList, LB_GETTEXT, ulIndex,
                     (LPARAM)(LPCTSTR)HwSelectedProfile.szFromFriendlyName);
               HwSelectedProfile.ulFromProfileID =
                     (ULONG)SendMessage(hList, LB_GETITEMDATA, ulIndex, 0);

               //
               // find the profile entry in the buffer that matches the selection
               //
               ulBufferIndex = 0;
               while (ulBufferIndex < pInfo->ulNumProfiles) {
                   if (pInfo->pHwProfValues[ulBufferIndex].ulProfile == HwSelectedProfile.ulFromProfileID) {
                       break;
                   }
                   ulBufferIndex++;
               }


               //
               // determine the next suggested name for the given profile
               //
               CreateHwProfileFriendlyName(hDlg,
                                           pInfo->pHwProfValues[ulBufferIndex].ulDockState,
                                           HwSelectedProfile.szToFriendlyName);

               //
               // pass selected profile info to copy profile dialog box
               //

               HwSelectedProfile.hParent = hDlg;

               if (!DialogBoxParam(hInstance,
                        MAKEINTRESOURCE(DLG_HWP_COPY), hDlg,
                        CopyProfileDlg,
                        (LPARAM)&HwSelectedProfile)) {
                  //
                  // if returns FALSE, either user canceled or no work
                  // required
                  //
                  break;
               }

               //
               // clone the profile in the in-memory profile buffer
               // and update the display
               //
               CopyHardwareProfile(
                        hDlg,
                        ulIndex,
                        HwSelectedProfile.ulFromProfileID,
                        HwSelectedProfile.szToFriendlyName);

               UpdateOrderButtonState(hDlg);
               PropSheet_Changed(GetParent(hDlg), hDlg);
               break;


            case IDD_HWP_RENAME:
               //
               // get the selected profile
               //
               hList = GetDlgItem(hDlg, IDD_HWP_PROFILES);

               ulIndex = SendMessage(hList, LB_GETCURSEL, 0, 0);
               if (ulIndex == LB_ERR) {
                  break;
               }

               SendMessage(hList, LB_GETTEXT, ulIndex,
                     (LPARAM)(LPCTSTR)HwSelectedProfile.szFromFriendlyName);
               HwSelectedProfile.ulFromProfileID =
                     (ULONG)SendMessage(hList, LB_GETITEMDATA, ulIndex, 0);

               //
               // strip off the current tag if it exists "(Current)"
               //
               GetCurrentProfile(&ulCurrentProfile);

               StripCurrentTag(
                     HwSelectedProfile.szFromFriendlyName,
                     HwSelectedProfile.ulFromProfileID,
                     ulCurrentProfile);

               // pass selected profile info to rename profile dialog box
               //

               HwSelectedProfile.hParent = hDlg;

               if (!DialogBoxParam(hInstance,
                        MAKEINTRESOURCE(DLG_HWP_RENAME), hDlg,
                        RenameProfileDlg,
                        (LPARAM)&HwSelectedProfile)) {
                  //
                  // if returns FASLE, either user canceled or no work
                  // required (i.e., user chose same name or zero-length
                  // name)
                  //
                  break;
               }

               //
               // rename the profile in the in-memory profile buffer
               // and update the display
               //
               RenameHardwareProfile(
                        hDlg,
                        ulIndex,
                        HwSelectedProfile.ulFromProfileID,
                        HwSelectedProfile.szToFriendlyName);

               PropSheet_Changed(GetParent(hDlg), hDlg);
               break;


            case IDD_HWP_DELETE: {

               TCHAR szCaption[MAX_PATH];
               TCHAR szMsg[MAX_PATH];
               TCHAR szMsg1[MAX_PATH];

               //
               // get the selected profile
               //
               hList = GetDlgItem(hDlg, IDD_HWP_PROFILES);

               ulIndex = SendMessage(hList, LB_GETCURSEL, 0, 0);
               if (ulIndex == LB_ERR) {
                  break;
               }

               //
               // confirm that user really wants to delete the profile
               // (the confirm message has a substitute symbol for
               // profile name)
               //
               SendMessage(hList, LB_GETTEXT, ulIndex,
                     (LPARAM)(LPCTSTR)szProfileName);

               LoadString(hInstance, HWP_CONFIRM_DELETE_CAP, szCaption, MAX_PATH);
               LoadString(hInstance, HWP_CONFIRM_DELETE, szMsg1, MAX_PATH);

               wsprintf(szMsg, szMsg1, szProfileName);

               if (MessageBox(hDlg, szMsg, szCaption,
                              MB_YESNO | MB_ICONQUESTION) == IDNO) {
                   break;
               }

               //
               // mark the profile as deleted in the in-memory buffer
               // and update the display
               //
               DeleteHardwareProfile(
                        hDlg,
                        ulIndex);

               UpdateOrderButtonState(hDlg);
               PropSheet_Changed(GetParent(hDlg), hDlg);
               break;
             }

             case IDD_HWP_SECONDS:

                if (HIWORD(wParam) == EN_UPDATE) {
                    PropSheet_Changed(GetParent(hDlg), hDlg);
                }
                break;

            default:
               return FALSE;
          }
          break;

       } // case WM_COMMAND...

       default:
          return FALSE;
          break;
    }

    return TRUE;

} // HardwareProfilesDlg



/**-------------------------------------------------------------------------**/
INT_PTR
APIENTRY
CopyProfileDlg(
      HWND    hDlg,
      UINT    uMessage,
      WPARAM  wParam,
      LPARAM  lParam
      )

{
   PHWPROFILE  pHwProfile;
   static HIMC himcOrg;


   switch (uMessage)
   {
      case WM_INITDIALOG:
         //
         // the profile info struct is passed in lparam, save in
         // Window word for thread-safe use in later messages
         //
         SetWindowLongPtr(hDlg, DWLP_USER, lParam);
         pHwProfile = (PHWPROFILE)lParam;

         //
         // initialize "To" and "From" fields
         //
         SendDlgItemMessage(hDlg, IDD_HWP_COPYTO, EM_LIMITTEXT,
               MAX_FRIENDLYNAME_LEN-1, 0L);
         SetDlgItemText(hDlg, IDD_HWP_COPYFROM, pHwProfile->szFromFriendlyName);
         SetDlgItemText(hDlg, IDD_HWP_COPYTO, pHwProfile->szToFriendlyName);
         SendDlgItemMessage(hDlg, IDD_HWP_COPYTO, EM_SETSEL, 0, -1);
         SetFocus(GetDlgItem(hDlg, IDD_HWP_COPYTO));
         //
         // Remove any association the window may have with an input context,
         // because we don't allow to use DBCS in H/W profile name.
         //
         himcOrg = ImmAssociateContext(GetDlgItem(hDlg, IDD_HWP_COPYTO), (HIMC)NULL);
         return FALSE;

      case WM_DEVICECHANGE:
         //
         // If a hardware profile change event takes place while the dialog is
         // up, just dismiss the dialog because things have changed.
         //
         if (wParam == DBT_CONFIGCHANGED) {
            EndDialog(hDlg, FALSE);
            return FALSE;
         }
         break;

      case WM_DESTROY:
         if (himcOrg)
           ImmAssociateContext(GetDlgItem(hDlg, IDD_HWP_COPYTO), himcOrg);
         return FALSE;

      case WM_HELP:
         WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, HELP_FILE,
               HELP_WM_HELP, (DWORD_PTR)(LPTSTR)HwProfileHelpIds);
         break;

      case WM_CONTEXTMENU:
         WinHelp((HWND)wParam, HELP_FILE, HELP_CONTEXTMENU,
                  (DWORD_PTR)(LPTSTR)HwProfileHelpIds);
         break;


      case WM_COMMAND:
      {
         switch (LOWORD(wParam))
         {
            case IDOK:
               pHwProfile = (PHWPROFILE)GetWindowLongPtr(hDlg, DWLP_USER);

               GetDlgItemText(hDlg, IDD_HWP_COPYTO,
                     pHwProfile->szToFriendlyName, MAX_FRIENDLYNAME_LEN);


               if (pHwProfile->szToFriendlyName == NULL ||
                        *pHwProfile->szToFriendlyName == '\0') {
                  //
                  // accept request to copy to zero-length string but
                  // do nothing (return FALSE from DialogBox call)
                  //
                  EndDialog(hDlg, FALSE);
                  return TRUE;
               }

               //
               // Check for duplicates
               //

               if (IsProfileNameInUse(pHwProfile->hParent,
                                      pHwProfile->szToFriendlyName)) {
                  //
                  // if name already used by a different profile (including
                  // the name of this profile), deny the request, but don't
                  // end the dialog box
                  //
                  DisplayPrivateMessage(hDlg, HWP_ERROR_PROFILE_IN_USE);
                  break;
               }

               //
               // Check for complex script names
               //
               if (S_OK == ScriptIsComplex(pHwProfile->szToFriendlyName, lstrlen(pHwProfile->szToFriendlyName), SIC_COMPLEX))
               {
                   DisplayPrivateMessage(hDlg, HWP_ERROR_COMPLEX_SCRIPT);
                   break;
               }                  

               //
               // otherwise, we'll accept the name
               //
               EndDialog(hDlg,TRUE);
               break;

            case IDCANCEL:
               EndDialog(hDlg,FALSE);
               break;

            default:
               return FALSE;
          }
          break;

       } // case WM_COMMAND...

       default:
          return FALSE;
          break;
    }

    return TRUE;

} // CopyProfileDlg



/**-------------------------------------------------------------------------**/
INT_PTR
APIENTRY
RenameProfileDlg(
      HWND    hDlg,
      UINT    uMessage,
      WPARAM  wParam,
      LPARAM  lParam
      )

{
   PHWPROFILE  pHwProfile;
   ULONG       ulReturn;
   static HIMC himcOrg;


   switch (uMessage)
   {
      case WM_INITDIALOG:
         //
         // the profile info struct is passed in lparam, save in
         // Window word for thread-safe use in later messages
         //
         SetWindowLongPtr(hDlg, DWLP_USER, lParam);
         pHwProfile = (PHWPROFILE)lParam;

         //
         // initialize "To" and "From" fields
         //
         SendDlgItemMessage(hDlg, IDD_HWP_RENAMETO, EM_LIMITTEXT,
               MAX_FRIENDLYNAME_LEN-1, 0L);
         SetDlgItemText(hDlg, IDD_HWP_RENAMEFROM, pHwProfile->szFromFriendlyName);
         SetDlgItemText(hDlg, IDD_HWP_RENAMETO, pHwProfile->szFromFriendlyName);
         SendDlgItemMessage(hDlg, IDD_HWP_RENAMETO, EM_SETSEL, 0, -1);
         SetFocus(GetDlgItem(hDlg, IDD_HWP_RENAMETO));
         //
         // Remove any association the window may have with an input context,
         // because we don't allow to use DBCS in H/W profile name.
         //
         himcOrg = ImmAssociateContext(GetDlgItem(hDlg, IDD_HWP_RENAMETO), (HIMC)NULL);
         return FALSE;


      case WM_DESTROY:
         if (himcOrg)
           ImmAssociateContext(GetDlgItem(hDlg, IDD_HWP_RENAMETO), himcOrg);
         return FALSE;

      case WM_DEVICECHANGE:
         //
         // If a hardware profile change event takes place while the dialog is
         // up, just dismiss the dialog because things have changed.
         //
         if (wParam == DBT_CONFIGCHANGED) {
            EndDialog(hDlg, FALSE);
            return FALSE;
         }
         break;


      case WM_HELP:
         WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, HELP_FILE,
               HELP_WM_HELP, (DWORD_PTR)(LPTSTR)HwProfileHelpIds);
         break;

      case WM_CONTEXTMENU:
         WinHelp((HWND)wParam, HELP_FILE, HELP_CONTEXTMENU,
                  (DWORD_PTR)(LPTSTR)HwProfileHelpIds);
         break;


      case WM_COMMAND:
      {
         switch (LOWORD(wParam))
         {
            case IDOK:
               pHwProfile = (PHWPROFILE)GetWindowLongPtr(hDlg, DWLP_USER);

               ulReturn = GetDlgItemText(hDlg, IDD_HWP_RENAMETO,
                     pHwProfile->szToFriendlyName, MAX_FRIENDLYNAME_LEN);


               if (pHwProfile->szToFriendlyName == NULL ||
                        *pHwProfile->szToFriendlyName == '\0') {
                  //
                  // accept request to copy to zero-length string but
                  // do nothing (return FALSE from DialogBox call)
                  //
                  EndDialog(hDlg, FALSE);
                  return TRUE;
               }

               if (lstrcmpi(pHwProfile->szToFriendlyName,
                        pHwProfile->szFromFriendlyName) == 0) {
                  //
                  // accept request to rename to same name but do
                  // nothing (return FALSE from DialogBox call)
                  //
                  EndDialog(hDlg, FALSE);
                  return TRUE;
               }

               //
               // Check for duplicates
               //

               if (IsProfileNameInUse(pHwProfile->hParent,
                                      pHwProfile->szToFriendlyName)) {
                  //
                  // if name already used by a different profile, deny
                  // the request, but don't end the dialog box
                  //
                  DisplayPrivateMessage(hDlg, HWP_ERROR_PROFILE_IN_USE);
                  break;
               }

               //
               // Check for complex script names
               //
               if (S_OK == ScriptIsComplex(pHwProfile->szToFriendlyName, lstrlen(pHwProfile->szToFriendlyName), SIC_COMPLEX))
               {
                   DisplayPrivateMessage(hDlg, HWP_ERROR_COMPLEX_SCRIPT);
                   break;
               }                  

               //
               // otherwise, we'll accept the name
               //
               EndDialog(hDlg,TRUE);
               break;

            case IDCANCEL:
               EndDialog(hDlg,FALSE);
               break;

            default:
               return FALSE;
          }
          break;

       } // case WM_COMMAND...

       default:
          return FALSE;
          break;
    }

    return TRUE;

} // RenameProfileDlg




/**-------------------------------------------------------------------------**/
BOOL
GetCurrentProfile(
      PULONG  pulProfile
      )
{
   WCHAR    RegStr[MAX_PATH];
   ULONG    ulSize;
   HKEY     hKey;


   //
   // open the IDConfigDB key
   //
   if (RegOpenKeyEx(
            HKEY_LOCAL_MACHINE, pszRegIDConfigDB, 0,
            KEY_QUERY_VALUE, &hKey) != ERROR_SUCCESS) {

      DisplaySystemMessage(NULL, ERROR_REGISTRY_CORRUPT);
      return FALSE;
   }

   //
   // retrieve the CurrentConfig value
   //
   ulSize = sizeof(ULONG);
   if (RegQueryValueEx(
            hKey, pszRegCurrentConfig, NULL, NULL,
            (LPBYTE)pulProfile, &ulSize) != ERROR_SUCCESS) {

      RegCloseKey(hKey);
      DisplaySystemMessage(NULL, ERROR_REGISTRY_CORRUPT);
      return FALSE;
   }

   RegCloseKey(hKey);
   return TRUE;

} // GetCurrentProfile


/**-------------------------------------------------------------------------**/
BOOL
GetRegProfileCount(
      PULONG   pulProfiles
      )
{
   WCHAR    RegStr[MAX_PATH];
   HKEY     hKey;


   //
   // open the Known Docking States key
   //
   wsprintf(RegStr, TEXT("%s\\%s"),
            pszRegIDConfigDB,
            pszRegKnownDockingStates);

   if (RegOpenKeyEx(
            HKEY_LOCAL_MACHINE, RegStr, 0, KEY_READ,
            &hKey) != ERROR_SUCCESS) {

      *pulProfiles = 0;
      DisplaySystemMessage(NULL, ERROR_REGISTRY_CORRUPT);
      return FALSE;
   }

   //
   // find out the total number of profiles
   //
   if (RegQueryInfoKey(
            hKey, NULL, NULL, NULL, pulProfiles, NULL, NULL, NULL,
            NULL, NULL, NULL, NULL) != ERROR_SUCCESS) {

      *pulProfiles = 0;
      RegCloseKey(hKey);
      DisplaySystemMessage(NULL, ERROR_REGISTRY_CORRUPT);
      return FALSE;
   }

   ASSERT(*pulProfiles > 0);  // The key for the pristine profile should be there, at least.
   *pulProfiles-= 1;          // Don't count the pristine in the number or working profiles.

   RegCloseKey(hKey);
   return TRUE;

} // GetRegProfileCount


/**-------------------------------------------------------------------------**/
BOOL
GetSelectedProfile(
      HWND     hCtl,
      PULONG   pulSelectedProfile
      )
{
    LONG lSelect;

    // THIS ISN"T BEING CALLED RIGHT NOW, IF IT STARTS GETTING CALLED,
    // THERE SHOULD BE LOGIC FOR REENABLING OR DISABLING THE DELETE
    // BUTTON BASED ON WHETHER THE FIRST INDEX IS THE CURRENT PROFILE
    // (ONLY APPLIES TO THE ERROR CASE WHERE THERE ARE NO CURRENT
    // SELECTIONS)

    lSelect = (LONG)SendMessage(hCtl, LB_GETCURSEL, 0, 0);

    if (lSelect != LB_ERR) {

      *pulSelectedProfile =
         (ULONG)SendMessage(hCtl, LB_GETITEMDATA, lSelect, 0);
    }
    else {
       //
       // no selections, assume first one
       //
       SendMessage(hCtl, LB_SETCURSEL, 0, 0);

       *pulSelectedProfile = (ULONG)SendMessage(hCtl, LB_GETITEMDATA, 0, 0);
    }

    return TRUE;

} // GetSelectedProfile



/**-------------------------------------------------------------------------**/
BOOL
FillProfileList(
      HWND  hDlg
      )

{
   HWND           hList;
   ULONG          ulCurrentProfile, ulCurrentIndex;
   ULONG          ulIndex=0, ulSize=0;
   ULONG          enumIndex = 0, ulProfileID=0;
   ULONG          ulCurrentDockingState = 0;
   ULONG          ulDockID = 0, ulSerialNumber=0;
   HKEY           hKey = NULL, hCfgKey = NULL;
   HKEY           hCurrent = NULL;
   WCHAR          RegStr[MAX_PATH], szName[MAX_PATH];
   ULONG          RegStatus = ERROR_SUCCESS;
   WCHAR          szFriendlyName[MAX_FRIENDLYNAME_LEN];
   WCHAR          szProfile[MAX_PROFILEID_LEN];
   PHWPROF_INFO   pInfo;
   LRESULT        lReturn;
   REGSAM         sam;


   //
   // retrieve a handle to the listbox window
   //
   hList = GetDlgItem(hDlg, IDD_HWP_PROFILES);

   //
   // retrieve the id of the current profile
   //
   if (!GetCurrentProfile(&ulCurrentProfile)) {
      DisplaySystemMessage(hDlg, ERROR_NOT_ENOUGH_MEMORY);
      return FALSE;
   }

   //
   // allocate a buffer for the main profile info struct
   //
   pInfo = (PHWPROF_INFO) LocalAlloc(LPTR, sizeof(HWPROF_INFO));

   if (pInfo == NULL) {
      DisplaySystemMessage(hDlg, ERROR_NOT_ENOUGH_MEMORY);
      return FALSE;
   }

   //
   // save the number of profiles currently in the registry
   //
   if (!GetRegProfileCount(&(pInfo->ulNumProfiles))) {
      LocalFree((HLOCAL)pInfo);
      return FALSE;
   }

   pInfo->ulActiveProfiles = pInfo->ulNumProfiles;

   //
   // Initialize the hardware detected portable flag
   //
   pInfo->bHwDetectedPortable = FALSE;

   //
   // allocate a buffer to hold all the profile values
   //
   pInfo->pHwProfValues = (PHWPROF_VALUES) LocalAlloc(LPTR, sizeof(HWPROF_VALUES) * pInfo->ulNumProfiles);

   if (pInfo->pHwProfValues == NULL) {
      LocalFree((HLOCAL)pInfo);
      return FALSE;
   }

   SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pInfo);

   //
   // clear the listbox and turn redraw off
   //
   SendMessage(hList, LB_RESETCONTENT, 0, 0);
   SendMessage(hList, WM_SETREDRAW, (WPARAM)FALSE, 0);

   //
   // open the Hardware Profiles key
   //
   wsprintf(RegStr, TEXT("%s\\%s"),
            pszRegIDConfigDB,
            pszRegKnownDockingStates);

   if (RegOpenKeyEx(
            HKEY_LOCAL_MACHINE, RegStr, 0,
            KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
            &hKey) != ERROR_SUCCESS) {

      DisplaySystemMessage(hDlg, ERROR_REGISTRY_CORRUPT);
      LocalFree((HLOCAL)pInfo->pHwProfValues);
      LocalFree((HLOCAL)pInfo);
      return FALSE;
   }

   //
   // read the values for the name generating counters
   //
   ulSize = sizeof(DWORD);

   wsprintf(szName, pszRegUndocked);
   if (RegQueryValueEx(hKey, szName, NULL, NULL,
                       (LPBYTE)&pInfo->ulUndockedProfileNameCount, &ulSize)) {
       pInfo->ulUnknownProfileNameCount = 0;
   }

   wsprintf(szName, pszRegDocked);
   if (RegQueryValueEx(hKey, szName, NULL, NULL,
                       (LPBYTE)&pInfo->ulDockedProfileNameCount, &ulSize)) {
       pInfo->ulUnknownProfileNameCount = 0;
   }

   wsprintf(szName, pszRegUnknown);
   if (RegQueryValueEx(hKey, szName, NULL, NULL,
                       (LPBYTE)&pInfo->ulUnknownProfileNameCount, &ulSize)) {
       pInfo->ulUnknownProfileNameCount = 0;
   }

   //
   // pad the list box with a blank entry for each profile
   // (this facilitates adding the profiles in rank order
   //
   for (ulIndex = 0; ulIndex < pInfo->ulNumProfiles; ulIndex++) {
      SendMessage(hList, LB_ADDSTRING, 0, (LPARAM)(LPCTSTR)TEXT(" "));
   }

   //
   // enumerate each of the existing hardware profiles
   //
   ulIndex = 0;
   enumIndex = 0;
   while (RegStatus != ERROR_NO_MORE_ITEMS) {

      //
      // enumerate the profile key
      //
      ulSize = MAX_PROFILEID_LEN;
      RegStatus = RegEnumKeyEx(
               hKey, enumIndex, szProfile, &ulSize, NULL, NULL, NULL, NULL);

      if (RegStatus == ERROR_SUCCESS) {
         //
         // open the enumerated profile key
         //
         if (bAdmin) {
             sam = KEY_QUERY_VALUE | KEY_SET_VALUE;
         } else {
             sam = KEY_QUERY_VALUE;
         }

         if (RegOpenKeyEx(
                  hKey, szProfile, 0, sam, &hCfgKey) != ERROR_SUCCESS) {

            RegCloseKey(hKey);
            LocalFree((HLOCAL)pInfo->pHwProfValues);
            LocalFree((HLOCAL)pInfo);
            if (bAdmin) {
                DisplaySystemMessage(hDlg, ERROR_REGISTRY_CORRUPT);
                return FALSE;
            }
            else {
                return TRUE;
            }
         }

         //
         // if this is the Pristine profile, ignore it, and move on to the next.
         //

         ulProfileID = _wtoi(szProfile);

         if (!ulProfileID) {
             enumIndex++;
             RegCloseKey(hCfgKey);
             continue;
         }

         //----------------------------------------------------------
         // retrieve the profile registry info, save in buffer
         //----------------------------------------------------------

         //
         // aliasable
         //
         ulSize = sizeof(DWORD);
         if (RegQueryValueEx(
             hCfgKey, pszRegAliasable, NULL, NULL,
             (LPBYTE)&pInfo->pHwProfValues[ulIndex].bAliasable,
             &ulSize) != ERROR_SUCCESS) {
             pInfo->pHwProfValues[ulIndex].bAliasable = TRUE;
         }

         //
         // cloned
         //
         ulSize = sizeof(DWORD);
         if (RegQueryValueEx(
             hCfgKey, pszRegCloned, NULL, NULL,
             (LPBYTE)&pInfo->pHwProfValues[ulIndex].bCloned,
             &ulSize) != ERROR_SUCCESS) {
             pInfo->pHwProfValues[ulIndex].bCloned = FALSE;
         }

         //
         // friendly name
         //
         ulSize = MAX_FRIENDLYNAME_LEN * sizeof(TCHAR);
         if (RegQueryValueEx(
                  hCfgKey, pszRegFriendlyName, NULL, NULL,
                  (LPBYTE)&pInfo->pHwProfValues[ulIndex].szFriendlyName,
                  &ulSize) != ERROR_SUCCESS) {

            //
            // if no FriendlyName then write out and use a default
            // value name (for compatibility with Win95)
            //
            if (bAdmin) {

                lstrcpy(pInfo->pHwProfValues[ulIndex].szFriendlyName,
                         pszRegDefaultFriendlyName);

                RegSetValueEx(
                         hCfgKey, pszRegFriendlyName, 0, REG_SZ,
                         (LPBYTE)pszRegDefaultFriendlyName,
                         (lstrlen(pszRegDefaultFriendlyName)+1) * sizeof(TCHAR));
            }
         }

         //
         // preference order ranking
         //
         ulSize = sizeof(ULONG);
         if (RegQueryValueEx(
                  hCfgKey, pszRegPreferenceOrder, NULL, NULL,
                  (LPBYTE)&pInfo->pHwProfValues[ulIndex].ulPreferenceOrder,
                  &ulSize) != ERROR_SUCCESS) {

            // FEATURE - rerank all profiles if this happens
         }

         //
         // dock state
         //
         ulSize = sizeof(ULONG);
         if (RegQueryValueEx(
                  hCfgKey, pszRegDockState, NULL, NULL,
                  (LPBYTE)&pInfo->pHwProfValues[ulIndex].ulDockState,
                  &ulSize) != ERROR_SUCCESS) {

            pInfo->pHwProfValues[ulIndex].ulDockState =
                     DOCKINFO_USER_SUPPLIED | DOCKINFO_DOCKED | DOCKINFO_UNDOCKED;
         }

         //
         // portable computer flag  - this is obsolete info, just save the current
         // setting if it exists and then delete it (might need the original
         // setting later)
         //
         ulSize = sizeof(ULONG);
         if (RegQueryValueEx(
                  hCfgKey, pszRegIsPortable, NULL, NULL,
                  (LPBYTE)&pInfo->pHwProfValues[ulIndex].bPortable,
                  &ulSize) != ERROR_SUCCESS) {

            pInfo->pHwProfValues[ulIndex].bPortable = FALSE;
         }

         RegDeleteValue(hCfgKey, pszRegIsPortable);

         pInfo->pHwProfValues[ulIndex].ulProfile = _wtoi(szProfile);
         pInfo->pHwProfValues[ulIndex].ulAction = HWP_NO_ACTION;
         RegCloseKey(hCfgKey);

         //
         // If this is the current profile, open the CurrentDockInfo key
         //
         if (pInfo->pHwProfValues[ulIndex].ulProfile == ulCurrentProfile) {

             wsprintf(RegStr, TEXT("%s\\%s"),
                      pszRegIDConfigDB,
                      pszRegCurrentDockInfo);
             
             if (RegOpenKeyEx(
                 HKEY_LOCAL_MACHINE, RegStr, 0,
                 KEY_QUERY_VALUE, &hCurrent) != ERROR_SUCCESS) {
                 
                 //
                 // Could not open the CurrentDockInfo key;
                 // Dock ID and Serial Number are unavailable
                 //
                 
                 pInfo->pHwProfValues[ulIndex].szDockID[0] = TEXT('\0');
                 pInfo->pHwProfValues[ulIndex].szSerialNumber[0] = TEXT('\0');

             } else {
                 
                 //
                 // Retrieve the hardware-detected dock state for the current profile
                 //
                 ulSize = sizeof(DWORD);
                 if ((RegQueryValueEx(
                     hCurrent, pszRegDockingState, NULL, NULL,
                     (LPBYTE)&ulCurrentDockingState,
                     &ulSize) == ERROR_SUCCESS) && 
                     ulCurrentDockingState &&
                     !((ulCurrentDockingState & DOCKINFO_DOCKED) &&
                       (ulCurrentDockingState & DOCKINFO_UNDOCKED))) {
                     //
                     // if the hardware-detected dockstate is present and known,
                     // override the user-supplied dockstate
                     //
                     pInfo->bHwDetectedPortable = TRUE;
                     pInfo->pHwProfValues[ulIndex].ulDockState = ulCurrentDockingState;
                 } else {
                     //
                     // keep the user-supplied dockstate
                     //
                     pInfo->bHwDetectedPortable = FALSE;
                     ulCurrentDockingState = pInfo->pHwProfValues[ulIndex].ulDockState;
                 }

                 if ((ulCurrentDockingState & DOCKINFO_UNDOCKED) &&
                     !(ulCurrentDockingState & DOCKINFO_DOCKED) &&
                     !(ulCurrentDockingState & DOCKINFO_USER_SUPPLIED)) {
                     //
                     // The hardware has detected an undocked state; set the global IsPortable flag
                     //
                     pInfo->bPortable = TRUE;

                 } else if ((ulCurrentDockingState & DOCKINFO_DOCKED) &&
                     !(ulCurrentDockingState & DOCKINFO_UNDOCKED) &&
                     !(ulCurrentDockingState & DOCKINFO_USER_SUPPLIED)) {                     
                     //
                     // The hardware has detected a docked state; set the global IsPortable flag
                     //
                     pInfo->bPortable = TRUE;
                     
                     //
                     // Serial Number and DockID are only valid for docked Profiles
                     //

                     //
                     // Retrieve the Serial Number for the current Profile.
                     //
                     // ("AcpiSerialNumber" is preferred because it is updated
                     // on Acpi dock events; "SerialNumber" is set only at boot
                     // time, from the BIOS, and may be inaccurate across Acpi
                     // dock transitions)
                     //
                     ulSize = MAX_SERIALNUM_LEN * sizeof(TCHAR);
                     if (RegQueryValueEx(
                         hCurrent, pszRegAcpiSerialNumber, NULL, NULL,
                         (LPBYTE)&pInfo->pHwProfValues[ulIndex].szSerialNumber,
                         &ulSize) != ERROR_SUCCESS) {
                         //
                         // No Acpi Serial Number, but we know the machine is
                         // docked (based on the DockState from the PnP BIOS
                         // info) so check for a PnP BIOS SerialNumber
                         //
                         ulSize = sizeof(DWORD);
                         if (RegQueryValueEx(
                             hCurrent, pszRegSerialNumber, NULL, NULL,
                             (LPBYTE)&ulSerialNumber,
                             &ulSize) != ERROR_SUCCESS) {                             
                             pInfo->pHwProfValues[ulIndex].szSerialNumber[0] = TEXT('\0');
                         } else {
                             wsprintf(pInfo->pHwProfValues[ulIndex].szSerialNumber,
                                      L"%X", 
                                      (ULONG)ulSerialNumber);
                         }
                     }
                     
                     //
                     // Retrieve the DockID for the current Profile, if available.
                     //
                     ulSize = sizeof(DWORD);
                     if (RegQueryValueEx(
                         hCurrent, pszRegDockID, NULL, NULL,
                         (LPBYTE)&ulDockID,
                         &ulSize) != ERROR_SUCCESS) {                 
                         pInfo->pHwProfValues[ulIndex].szDockID[0] = TEXT('\0');
                     } else {
                         wsprintf(pInfo->pHwProfValues[ulIndex].szDockID, 
                                  L"%X", 
                                  (ULONG)ulDockID);
                     }
                     
                 }
                 
             }
             
         } else {
             //
             // Serial Number and DockID are only valid for the current Profile
             //         
             pInfo->pHwProfValues[ulIndex].szSerialNumber[0] = TEXT('\0');
             pInfo->pHwProfValues[ulIndex].szDockID[0] = TEXT('\0');
         }
         
         //
         // delete the blank string in this spot, add the friendly name
         // (append current tag if necessary)
         //
         SendMessage(hList, LB_DELETESTRING,
                  pInfo->pHwProfValues[ulIndex].ulPreferenceOrder, 0);

         AppendCurrentTag(
                  szName,        // new fixed up name
                  pInfo->pHwProfValues[ulIndex].szFriendlyName,
                  pInfo->pHwProfValues[ulIndex].ulProfile,
                  ulCurrentProfile);

         lReturn = SendMessage(hList, LB_INSERTSTRING,
                  pInfo->pHwProfValues[ulIndex].ulPreferenceOrder,
                  (LPARAM)(LPCTSTR)szName);


         //
         // store the profile id along with the entry so we
         // can associate the string and the profile id later
         //
         SendMessage(hList, LB_SETITEMDATA,
            (WPARAM)lReturn, pInfo->pHwProfValues[ulIndex].ulProfile);

         //
         // if this is the current profile, save the index
         //
         if (pInfo->pHwProfValues[ulIndex].ulProfile == ulCurrentProfile) {
            ulCurrentIndex = pInfo->pHwProfValues[ulIndex].ulPreferenceOrder;
         }
      }

      ulIndex++;
      enumIndex++;

   } // while

   RegCloseKey(hKey);

   //---------------------------------------------------------------------
   // migrate portable information
   //---------------------------------------------------------------------
   
   if (bAdmin) {
       sam = KEY_READ | KEY_WRITE;
   } else {
       sam = KEY_READ;
   }

   if (RegOpenKeyEx(
       HKEY_LOCAL_MACHINE, pszRegIDConfigDB, 0,
       sam, &hKey) == ERROR_SUCCESS) {

       if (pInfo->bHwDetectedPortable) {
           if (bAdmin) {
               //
               // Set the global IsPortable setting as identified by the Hardware
               //
               RegSetValueEx(hKey, pszRegIsPortable, 0, REG_DWORD,
                             (LPBYTE)&pInfo->bPortable, sizeof(DWORD));
           }
           
       } else {
           //
           // Is there a global IsPortable setting?
           //
           ulSize = sizeof(DWORD);
           if (RegQueryValueEx(hKey, pszRegIsPortable, NULL, NULL,
                               (LPBYTE)&pInfo->bPortable, &ulSize) != ERROR_SUCCESS) {
               //
               // the global IsPortable flag isn't there, and the hardware did
               // not detect this as being a portable machine, so by default, it
               // is not.
               //
               pInfo->bPortable = FALSE;
           }
       }
       
       RegCloseKey(hKey);
   }

   SendMessage(hList, WM_SETREDRAW, (WPARAM)TRUE, 0);
   SendMessage(hList, LB_SETCURSEL, ulCurrentIndex, 0);

   return TRUE;

} // FillProfileList



/**-------------------------------------------------------------------------**/
BOOL
IsProfileNameInUse(
      HWND     hDlg,
      LPTSTR   pszFriendlyName
      )
{
   ULONG          ulBufferIndex=0;
   PHWPROF_INFO   pInfo=NULL;


   //
   // retrieve the profile buffer
   //
   pInfo = (PHWPROF_INFO)GetWindowLongPtr(hDlg, DWLP_USER);

   //
   // check each friendly name (that hasn't been deleted) for a
   // match (case-insensitive)
   //
   while (ulBufferIndex < pInfo->ulNumProfiles) {

      if (!(pInfo->pHwProfValues[ulBufferIndex].ulAction & HWP_DELETE)) {

         if (lstrcmpi(pInfo->pHwProfValues[ulBufferIndex].szFriendlyName,
                  pszFriendlyName) == 0) {
            return TRUE;      // match, name is in use
         }
      }
      ulBufferIndex++;
   }

   return FALSE;  // no match found, name not in use

} // IsProfileNameInUse



/**-------------------------------------------------------------------------**/
VOID
UnicodeToUL(LPWSTR pString, PULONG pulValue)
{
    ULONG i;

    *pulValue = 0;
    for (i = 0; i < 4; i++) {
        *pulValue *= 10;
        *pulValue += (pString[i] <= '9') ?
                     (pString[i] - '0') :
                     (pString[i]-'A'+10);
    }
} // UnicodeToUL



/**-------------------------------------------------------------------------**/
BOOL
CopyHardwareProfile(
      HWND   hDlg,
      ULONG_PTR ulIndex,
      ULONG  ulProfile,
      LPTSTR szNewFriendlyName
      )
{
   HWND           hList;
   ULONG          ulBufferIndex=0, ulNewBufferIndex=0;
   ULONG          ulNewProfile=0;
   ULONG_PTR      ulNewIndex=0;
   PHWPROF_INFO   pInfo=NULL;
   HLOCAL         hMem=NULL;
   WCHAR          szTemp[MAX_PATH];
   HKEY           hKey;
   LONG           RegStatus;


   //
   // retrieve the profile buffer
   //
   pInfo = (PHWPROF_INFO)GetWindowLongPtr(hDlg, DWLP_USER);

   //
   // retrieve a handle to the listbox window
   //
   hList = GetDlgItem(hDlg, IDD_HWP_PROFILES);

   //
   // find which entry in the buffer list matches this profile
   //
   while (ulBufferIndex < pInfo->ulNumProfiles) {
      if (pInfo->pHwProfValues[ulBufferIndex].ulProfile == ulProfile) {
         break;
      }
      ulBufferIndex++;
   }

   //
   // reallocate the profile buffer to hold another entry
   //
   pInfo->ulActiveProfiles++;
   pInfo->ulNumProfiles++;

   LocalUnlock(LocalHandle(pInfo->pHwProfValues));

   hMem = (PHWPROF_VALUES)LocalReAlloc(
               LocalHandle(pInfo->pHwProfValues),
               pInfo->ulNumProfiles * sizeof(HWPROF_VALUES),
               LMEM_MOVEABLE | LMEM_ZEROINIT);

   if (hMem == NULL) {
      DisplaySystemMessage(hDlg, ERROR_NOT_ENOUGH_MEMORY);
      return FALSE;
   }

   pInfo->pHwProfValues = (PHWPROF_VALUES)LocalLock(hMem);
   ulNewBufferIndex = pInfo->ulNumProfiles-1;

   //
   // find a free profile id to use
   //
   if (!GetFreeProfileID(pInfo, &ulNewProfile)) {
      return FALSE;
   }

   pInfo->pHwProfValues[ulNewBufferIndex].ulProfile = ulNewProfile;

   //
   // save the friendly name retrieved from the copy dialog box
   //
   lstrcpy(pInfo->pHwProfValues[ulNewBufferIndex].szFriendlyName,
            szNewFriendlyName);

   //
   // assume it's the last in the preference order (zero-based)
   //
   pInfo->pHwProfValues[ulNewBufferIndex].ulPreferenceOrder =
               pInfo->ulActiveProfiles - 1;

   //
   // copy the profile info from the selected profile to the new profile
   //
   pInfo->pHwProfValues[ulNewBufferIndex].ulDockState =
               pInfo->pHwProfValues[ulBufferIndex].ulDockState;

   //
   // new hardware profiles are (by default) not aliasable, unless no alias can
   // be copied for this profile.
   //
   pInfo->pHwProfValues[ulNewBufferIndex].bAliasable = FALSE;

   //
   // copied profiles are not clones of the pristine profile.
   //
   pInfo->pHwProfValues[ulNewBufferIndex].bCloned = FALSE;

   //pInfo->pHwProfValues[ulNewBufferIndex].bPortable =
   //            pInfo->pHwProfValues[ulBufferIndex].bPortable;

   lstrcpy(pInfo->pHwProfValues[ulNewBufferIndex].szDockID,
           pInfo->pHwProfValues[ulBufferIndex].szDockID);

   lstrcpy(pInfo->pHwProfValues[ulNewBufferIndex].szSerialNumber,
           pInfo->pHwProfValues[ulBufferIndex].szSerialNumber);

   //
   // save the original profile id this was copied from
   //
   pInfo->pHwProfValues[ulNewBufferIndex].ulCreatedFrom =
               GetOriginalProfile(pInfo, ulProfile, ulBufferIndex);

   //
   // increment the appropriate name-generating counter
   // (note that the counter is NOT symmetrically decreased whenever a profile
   // is deleted -- it increases over the lifetime of the system as new profiles
   // are created; this prevents us from assigning names that incrementally less
   // than names we have already assigned.)
   //
   AdjustProfileTypeCounter(pInfo,
                            pInfo->pHwProfValues[ulNewBufferIndex].ulDockState, 
                            TRUE);

   //
   // set the new profile in the listbox (at the end)
   //
   ulNewIndex = SendMessage(hList, LB_ADDSTRING, 0,
               (LPARAM)(LPTSTR)szNewFriendlyName);

   SendMessage(hList, LB_SETITEMDATA,
               (WPARAM)ulNewIndex,
               pInfo->pHwProfValues[ulNewBufferIndex].ulProfile);

   //
   // select the new profile
   //
   SendMessage(hList, LB_SETCURSEL, ulNewIndex, 0);

   //
   // mark the change
   //
   pInfo->pHwProfValues[ulNewBufferIndex].ulAction |= HWP_CREATE;

   //
   // disable copy if we're now at the max number of profiles
   //
   if ((pInfo->ulNumProfiles+1) >= MAX_PROFILES) {
      EnableWindow(GetDlgItem(hDlg, IDD_HWP_COPY), FALSE);
   }
   
   //
   // reenable delete since by definition the selection is not on the
   // current profile (whether it was before or not)
   //
   EnableWindow(GetDlgItem(hDlg, IDD_HWP_DELETE), TRUE);

   return TRUE;

} // CopyHardwareProfile



/**-------------------------------------------------------------------------**/
BOOL
RenameHardwareProfile(
      HWND   hDlg,
      ULONG_PTR ulIndex,
      ULONG  ulProfile,
      LPTSTR szNewFriendlyName
      )
{
   HWND           hList;
   ULONG          ulBufferIndex=0, ulCurrentProfile=0;
   PHWPROF_INFO   pInfo=NULL;
   WCHAR          szName[MAX_PATH];


   //
   // retrieve the profile buffer
   //
   pInfo = (PHWPROF_INFO)GetWindowLongPtr(hDlg, DWLP_USER);

   //
   // retrieve a handle to the listbox window
   //
   hList = GetDlgItem(hDlg, IDD_HWP_PROFILES);

   //
   // find the profile entry in the buffer that matches the selection
   //
   while (ulBufferIndex < pInfo->ulNumProfiles) {
      if (pInfo->pHwProfValues[ulBufferIndex].ulProfile == ulProfile) {
         break;
      }
      ulBufferIndex++;
   }

   //
   // set the new friendly name in the listbox
   //
   GetCurrentProfile(&ulCurrentProfile);
   AppendCurrentTag(szName, szNewFriendlyName, ulProfile, ulCurrentProfile);

   SendMessage(hList, LB_DELETESTRING, ulIndex, 0);
   SendMessage(hList, LB_INSERTSTRING, ulIndex, (LPARAM)(LPTSTR)szName);
   SendMessage(hList, LB_SETITEMDATA, ulIndex,
               pInfo->pHwProfValues[ulIndex].ulProfile);

   //
   // re-select the index (is this necessary?)
   //
   SendMessage(hList, LB_SETCURSEL, ulIndex, 0);

   //
   // mark the change
   //
   pInfo->pHwProfValues[ulBufferIndex].ulAction |= HWP_RENAME;
   lstrcpy(pInfo->pHwProfValues[ulBufferIndex].szFriendlyName,
            szNewFriendlyName);

   return TRUE;

} // RenameHardwareProfile



/**-------------------------------------------------------------------------**/
BOOL
DeleteHardwareProfile(
      HWND   hDlg,
      ULONG_PTR ulIndex
      )
{
   HWND           hList;
   ULONG          ulBufferIndex=0, ulProfile=0, ulCurrentProfile=0;
   PHWPROF_INFO   pInfo=NULL;


   //
   // retrieve the profile buffer
   //
   pInfo = (PHWPROF_INFO)GetWindowLongPtr(hDlg, DWLP_USER);

   //
   // retrieve a handle to the listbox window
   //
   hList = GetDlgItem(hDlg, IDD_HWP_PROFILES);

   //
   // find the profile entry in the buffer that matches the selection
   //
   ulProfile = (ULONG)SendMessage(hList, LB_GETITEMDATA, ulIndex, 0);

   while (ulBufferIndex < pInfo->ulNumProfiles) {
      if (pInfo->pHwProfValues[ulBufferIndex].ulProfile == ulProfile) {
         break;
      }
      ulBufferIndex++;
   }

   //
   // readjust all the rankings to be consecutive
   //
   DeleteRank(pInfo, pInfo->pHwProfValues[ulBufferIndex].ulPreferenceOrder);

   //
   // decrement the count of active profiles
   //
   pInfo->ulActiveProfiles--;

   //
   // delete the friendly name in the listbox
   //
   SendMessage(hList, LB_DELETESTRING, ulIndex, 0);

   //
   // re-select the following index (same position)
   //
   if (ulIndex >= pInfo->ulActiveProfiles) {
      ulIndex = pInfo->ulActiveProfiles-1;
   }

   SendMessage(hList, LB_SETCURSEL, ulIndex, 0);

   //
   // mark the change
   //
   pInfo->pHwProfValues[ulBufferIndex].ulAction |= HWP_DELETE;

   //
   // enable copy if less than max number of profiles
   //
   if (pInfo->ulNumProfiles < MAX_PROFILES) {
      EnableWindow(GetDlgItem(hDlg, IDD_HWP_COPY), TRUE);
   }

   //
   // find the profile entry in the buffer that matches the new selection
   //
   ulProfile = (ULONG)SendMessage(hList, LB_GETITEMDATA, ulIndex, 0);
   ulBufferIndex = 0;

   while (ulBufferIndex < pInfo->ulNumProfiles) {
      if (pInfo->pHwProfValues[ulBufferIndex].ulProfile == ulProfile) {
         break;
      }
      ulBufferIndex++;
   }

   GetCurrentProfile(&ulCurrentProfile);

   //
   // if the newly selected entry is the current profile, disable delete
   //
   if (pInfo->pHwProfValues[ulBufferIndex].ulProfile == ulCurrentProfile) {
      EnableWindow(GetDlgItem(hDlg, IDD_HWP_DELETE), FALSE);
   }


   return TRUE;

} // DeleteHardwareProfiles



/**-------------------------------------------------------------------------**/
BOOL
GetUserWaitInterval(
      PULONG   pulWait
      )
{
   ULONG    ulSize;
   HKEY     hKey;


   //
   // open the IDConfigDB key
   //
   if(RegOpenKeyEx(
            HKEY_LOCAL_MACHINE, pszRegIDConfigDB, 0,
            KEY_QUERY_VALUE, &hKey) != ERROR_SUCCESS) {

      DisplaySystemMessage(NULL, ERROR_REGISTRY_CORRUPT);
      return FALSE;
   }

   //
   // retrieve the UserWaitInterval value
   //
   ulSize = sizeof(ULONG);
   if (RegQueryValueEx(
            hKey, pszRegUserWaitInterval, NULL, NULL,
            (LPBYTE)pulWait, &ulSize) != ERROR_SUCCESS) {
      *pulWait = DEFAULT_USER_WAIT;
   }

   RegCloseKey(hKey);
   return TRUE;

} // GetUserWaitInterval



/**-------------------------------------------------------------------------**/
BOOL
SetUserWaitInterval(
      ULONG   ulWait
      )
{
   HKEY     hKey;


   if (bAdmin) {
       //
       // open the IDConfigDB key
       //
       if(RegOpenKeyEx(
                HKEY_LOCAL_MACHINE, pszRegIDConfigDB, 0,
                KEY_SET_VALUE, &hKey) != ERROR_SUCCESS) {

          DisplaySystemMessage(NULL, ERROR_REGISTRY_CORRUPT);
          return FALSE;
       }

       //
       // set the UserWaitInterval value
       //
       if (RegSetValueEx(
                hKey, pszRegUserWaitInterval, 0, REG_DWORD,
                (LPBYTE)&ulWait, sizeof(ULONG)) != ERROR_SUCCESS) {
          RegCloseKey(hKey);
          return FALSE;
       }

       RegCloseKey(hKey);
   }

   return TRUE;

} // SetUserWaitInterval


/**-------------------------------------------------------------------------**/
BOOL
GetFreeProfileID(
      PHWPROF_INFO   pInfo,
      PULONG         pulProfile
      )

{
   ULONG    ulProfileID = 0, ulBufferIndex = 0;
   BOOL     bHit;


   //
   // find a profile id that isn't used
   //
   while (ulProfileID < MAX_PROFILES) {

      ulBufferIndex = 0;
      bHit = FALSE;

      while (ulBufferIndex < pInfo->ulNumProfiles) {

         if (ulProfileID == pInfo->pHwProfValues[ulBufferIndex].ulProfile) {
            bHit = TRUE;
            break;
         }

         ulBufferIndex++;
      }

      //
      // if I got all the way through the list without a hit, then this
      // profile id is free
      //
      if (!bHit) {
         *pulProfile = ulProfileID;
         return TRUE;
      }

      ulProfileID++;
   }

   *pulProfile = 0xFFFFFFFF;
   return FALSE;

} // GetFreeProfileID


/**-------------------------------------------------------------------------**/
ULONG
GetOriginalProfile(
      PHWPROF_INFO  pInfo,
      ULONG         ulProfile,
      ULONG         ulBufferIndex
      )
{
    ULONG   ulIndex, ulIndexCreatedFrom;

    //
    // if the specified profile is a newly created profile, then it is
    // by definition the first in the copy chain
    //
    if (!(pInfo->pHwProfValues[ulBufferIndex].ulAction & HWP_CREATE)) {
        return ulProfile;
    }

    ulIndex = ulBufferIndex;

    while (pInfo->pHwProfValues[ulIndex].ulAction & HWP_CREATE) {
        //
        // find which entry in the buffer list matches the "CopiedFrom" profile
        //
        ulIndexCreatedFrom = 0;

        while (ulIndexCreatedFrom < pInfo->ulNumProfiles) {
           if (pInfo->pHwProfValues[ulIndexCreatedFrom].ulProfile ==
               pInfo->pHwProfValues[ulIndex].ulCreatedFrom) {
              break;
           }
           ulIndexCreatedFrom++;
        }
        ulIndex = ulIndexCreatedFrom;
    }

    return pInfo->pHwProfValues[ulIndex].ulProfile;

} // GetOriginalProfile


/**-------------------------------------------------------------------------**/
BOOL
InsertRank(
      PHWPROF_INFO   pInfo,
      ULONG          ulRank
      )

{
   ULONG ulIndex;

   //
   // for inserting a rank and readjusting the other ranks, just
   // scan through the list and for any rank that is greater than
   // or equal to the inserted rank, increment the rank value
   //
   for (ulIndex = 0; ulIndex < pInfo->ulNumProfiles; ulIndex++) {
      //
      // if it's marked for delete, don't bother with it
      //
      if (!(pInfo->pHwProfValues[ulIndex].ulAction & HWP_DELETE)) {

         if (pInfo->pHwProfValues[ulIndex].ulPreferenceOrder >= ulRank) {
            pInfo->pHwProfValues[ulIndex].ulPreferenceOrder++;
            pInfo->pHwProfValues[ulIndex].ulAction |= HWP_REORDER;
         }
      }

   }

   return TRUE;

} // InsertRank



/**-------------------------------------------------------------------------**/
BOOL
DeleteRank(
      PHWPROF_INFO   pInfo,
      ULONG          ulRank
      )

{
   ULONG ulIndex;

   //
   // for deleting a rank and readjusting the other ranks, just
   // scan through the list and for any rank that is greater than
   // the deleted rank, subtract one from the rank value
   //
   for (ulIndex = 0; ulIndex < pInfo->ulNumProfiles; ulIndex++) {
      //
      // if it's marked for delete, don't bother with it
      //
      if (!(pInfo->pHwProfValues[ulIndex].ulAction & HWP_DELETE)) {

         if (pInfo->pHwProfValues[ulIndex].ulPreferenceOrder > ulRank) {
            pInfo->pHwProfValues[ulIndex].ulPreferenceOrder--;
            pInfo->pHwProfValues[ulIndex].ulAction |= HWP_REORDER;
         }
      }

   }

   return TRUE;

} // DeleteRank



/**-------------------------------------------------------------------------**/
BOOL
FlushProfileChanges(
      HWND hDlg,
      HWND hList
      )
{
   ULONG    ulIndex=0;
   HKEY     hKey = NULL, hDestKey = NULL, hSrcKey = NULL, hHwProf = NULL;
   WCHAR    RegStr[MAX_PATH];
   PHWPROF_INFO   pInfo=NULL;


   //
   // retrieve the profile buffer
   //
   pInfo = (PHWPROF_INFO)GetWindowLongPtr(hDlg, DWLP_USER);


   //
   // First pass, process the changes for each profile (except delete)
   //
   while (ulIndex < pInfo->ulNumProfiles) {

      //
      // were any changes made to this profile?
      //
      if (pInfo->pHwProfValues[ulIndex].ulAction == HWP_NO_ACTION) {
         goto NextProfile;
      }

      //
      // save deleting for the second pass
      //
      if (pInfo->pHwProfValues[ulIndex].ulAction & HWP_DELETE) {
         goto NextProfile;
      }

      //
      // commit the changes for this profile
      //
      WriteProfileInfo(&pInfo->pHwProfValues[ulIndex]);

      NextProfile:
         ulIndex++;
   }



   //
   // Second pass, process the delete requests
   //
   ulIndex = 0;
   while (ulIndex < pInfo->ulNumProfiles) {

      if (pInfo->pHwProfValues[ulIndex].ulAction & HWP_DELETE) {
         //
         // we only need to delete the key if it exists (if this
         // isn't a delete of a profile that was also just created)
         //
         if (!(pInfo->pHwProfValues[ulIndex].ulAction & HWP_CREATE)) {

            wsprintf(RegStr, TEXT("%s\\%s"),
                     pszRegIDConfigDB,
                     pszRegKnownDockingStates);

            if (RegOpenKeyEx(
                     HKEY_LOCAL_MACHINE, RegStr, 0, KEY_ALL_ACCESS,
                     &hKey) != ERROR_SUCCESS) {

               DisplaySystemMessage(hDlg, ERROR_REGISTRY_CORRUPT);
               return FALSE;
            }

            wsprintf(RegStr, TEXT("%04u"),
                     pInfo->pHwProfValues[ulIndex].ulProfile);

            RegDeleteKey(hKey, RegStr);
            RegCloseKey(hKey);

            //
            // also delete the profile specific enum tree
            //
            DeleteProfileDependentTree(pInfo->pHwProfValues[ulIndex].ulProfile);

            //
            // also delete the aliases to this profile
            //
            DeleteAliasEntries(pInfo->pHwProfValues[ulIndex].ulProfile);
            
         } else {
             //
             // decrement the name-generating counter for profiles we are
             // deleting that we created this session (only if registry keys
             // were never created for this new profile)
             //
             AdjustProfileTypeCounter(pInfo,
                                      pInfo->pHwProfValues[ulIndex].ulDockState, 
                                      FALSE);
         }
         
      }
      ulIndex++;
   }

   //
   // commit global settings
   //
   if(RegOpenKeyEx(
            HKEY_LOCAL_MACHINE, pszRegIDConfigDB, 0,
            KEY_SET_VALUE, &hKey) == ERROR_SUCCESS) {

       RegSetValueEx(hKey, pszRegIsPortable, 0, REG_DWORD,
                (LPBYTE)&pInfo->bPortable, sizeof(DWORD));

       if (RegOpenKeyEx(
                 hKey, pszRegKnownDockingStates, 0,
                 KEY_SET_VALUE, &hHwProf) == ERROR_SUCCESS) {

           if (pInfo->ulUndockedProfileNameCount > 0) {
               RegSetValueEx(hHwProf, pszRegUndocked, 0, REG_DWORD,
                             (LPBYTE)&pInfo->ulUndockedProfileNameCount, sizeof(ULONG));
           } else {
               RegDeleteValue(hHwProf, pszRegUndocked);
           }
           
           if (pInfo->ulDockedProfileNameCount > 0) {
               RegSetValueEx(hHwProf, pszRegDocked, 0, REG_DWORD,
                             (LPBYTE)&pInfo->ulDockedProfileNameCount, sizeof(ULONG));
           } else {
               RegDeleteValue(hHwProf, pszRegDocked);
           }
           
           if (pInfo->ulUnknownProfileNameCount > 0) {
               RegSetValueEx(hHwProf, pszRegUnknown, 0, REG_DWORD,
                             (LPBYTE)&pInfo->ulUnknownProfileNameCount, sizeof(ULONG));
           } else {
               RegDeleteValue(hHwProf, pszRegUnknown);
           }
           
           RegCloseKey(hHwProf);
       }
       RegCloseKey(hKey);
   }

   return TRUE;

} // FlushProfileChanges



/**-------------------------------------------------------------------------**/
BOOL
WriteProfileInfo(
   PHWPROF_VALUES pProfValues
   )
{
   HKEY     hKey = NULL, hDestKey = NULL, hSrcKey = NULL;
   WCHAR    RegStr[MAX_PATH];
   UUID     NewGuid;
   LPTSTR   UuidString;
   TCHAR    szGuid[MAX_GUID_STRING_LEN];

   if (pProfValues->ulAction & HWP_DELETE) {
      return TRUE;      // skip it
   }

   //
   // form the registry key string
   //
   wsprintf(RegStr, TEXT("%s\\%s\\%04u"),
            pszRegIDConfigDB,
            pszRegKnownDockingStates,
            pProfValues->ulProfile);

   //
   // create the profile key if it's a new profile. Don't
   // worry about security because the profile subkey always
   // inherits the security of the parent Hardware Profiles key.
   //
   if (pProfValues->ulAction & HWP_CREATE) {

      if (RegCreateKeyEx(
               HKEY_LOCAL_MACHINE, RegStr, 0, NULL,
               REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
               NULL, &hKey, NULL) != ERROR_SUCCESS) {
         return FALSE;
      }

      //
      // create a HwProfileGuid if its a new profile
      //
      if ((UuidCreate(&NewGuid) == RPC_S_OK) &&    
          (UuidToString(&NewGuid, &UuidString) == RPC_S_OK)) {                    

          //
          // put curly braces around the guid
          //
          lstrcpy(szGuid, TEXT("{"));
          lstrcat(szGuid, UuidString);
          lstrcat(szGuid, TEXT("}"));
          RpcStringFree(&UuidString);
          
          //
          // save the new HwProfileGuid in the registry
          //
          RegSetValueEx(
              hKey, pszRegHwProfileGuid, 0, REG_SZ,
              (LPBYTE)szGuid,
              (lstrlen(szGuid)+1) * sizeof(TCHAR) );         
      }
      
   } else {
      //
      // if not a create, just open the existing key
      //
      if (RegOpenKeyEx(
               HKEY_LOCAL_MACHINE, RegStr, 0, KEY_SET_VALUE,
               &hKey) != ERROR_SUCCESS) {
         return FALSE;
      }
   }

   //
   // update preference order if modified
   //
   if ((pProfValues->ulAction & HWP_REORDER) ||
            (pProfValues->ulAction & HWP_CREATE)) {

      RegSetValueEx(
            hKey, pszRegPreferenceOrder, 0, REG_DWORD,
            (LPBYTE)&pProfValues->ulPreferenceOrder, sizeof(ULONG));

      pProfValues->ulAction &= ~HWP_REORDER;    // clear action
   }

   //
   // update friendly name if modified
   //
   if ((pProfValues->ulAction & HWP_RENAME) ||
            (pProfValues->ulAction & HWP_CREATE)) {

      RegSetValueEx(
            hKey, pszRegFriendlyName, 0, REG_SZ,
            (LPBYTE)pProfValues->szFriendlyName,
            (lstrlen(pProfValues->szFriendlyName)+1) * sizeof(TCHAR));

      pProfValues->ulAction &= ~HWP_RENAME;     // clear action
   }

   //
   // update property values if modified
   //
   if ((pProfValues->ulAction & HWP_PROPERTIES) ||
            (pProfValues->ulAction & HWP_CREATE)) {

      RegSetValueEx(
            hKey, pszRegDockState, 0, REG_DWORD,
            (LPBYTE)&pProfValues->ulDockState, sizeof(ULONG));

      RegSetValueEx(
            hKey, pszRegAliasable, 0, REG_DWORD,
            (LPBYTE)&pProfValues->bAliasable, sizeof(DWORD));

      pProfValues->ulAction &= ~HWP_PROPERTIES;    // clear action
   }


   if (pProfValues->ulAction & HWP_CREATE) {
      //
      // copy the profile enum info. Don't worry about security on
      // this createkey because the profile key always inherits the
      // security of the parent Hardware Profiles key.
      //
      wsprintf(RegStr, TEXT("%s\\%04u"),
            pszRegHwProfiles,
            pProfValues->ulProfile);

      RegCreateKeyEx(
            HKEY_LOCAL_MACHINE, RegStr, 0, NULL, REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, NULL, &hDestKey, NULL);

      wsprintf(RegStr, TEXT("%s\\%04u"),
            pszRegHwProfiles,
            pProfValues->ulCreatedFrom);

      RegOpenKeyEx(
            HKEY_LOCAL_MACHINE, RegStr, 0, KEY_ALL_ACCESS, &hSrcKey);

      CopyRegistryNode(hSrcKey, hDestKey);

      //
      // copy all aliases for the source profile to the destination as well.
      //
      if (CopyAliasEntries(pProfValues->ulCreatedFrom, 
                           pProfValues->ulProfile) == FALSE) {

          //
          // We didn't actually copy any aliases, so make sure this profile gets
          // marked as "Aliasable" so that it shows up as a profile option at
          // boot time.
          //
          pProfValues->bAliasable = TRUE;
          RegSetValueEx(
              hKey, pszRegAliasable, 0, REG_DWORD,
              (LPBYTE)&pProfValues->bAliasable, sizeof(DWORD));
      }

      if (hDestKey != NULL) RegCloseKey(hDestKey);
      if (hSrcKey != NULL) RegCloseKey(hSrcKey);

      pProfValues->ulAction &= ~HWP_CREATE;     // clear action
      pProfValues->ulAction |= HWP_NEWPROFILE;  // created during this session
   }

   RegCloseKey(hKey);

   return TRUE;

} // WriteProfileInfo


/**-------------------------------------------------------------------------**/
BOOL
RemoveNewProfiles(
      PHWPROF_INFO   pInfo
      )
{
   ULONG    ulIndex=0;
   HKEY     hKey = NULL;
   WCHAR    RegStr[MAX_PATH];


   //
   // check each profile for any HWP_NEWPROFILE flags
   //
   while (ulIndex < pInfo->ulNumProfiles) {

      if (pInfo->pHwProfValues[ulIndex].ulAction & HWP_NEWPROFILE) {

         wsprintf(RegStr, TEXT("%s\\%s"),
                  pszRegIDConfigDB,
                  pszRegKnownDockingStates);

         if (RegOpenKeyEx(
                  HKEY_LOCAL_MACHINE, RegStr, 0, KEY_ALL_ACCESS,
                  &hKey) == ERROR_SUCCESS) {

            wsprintf(RegStr, TEXT("%04u"),
                     pInfo->pHwProfValues[ulIndex].ulProfile);

            RegDeleteKey(hKey, RegStr);
            RegCloseKey(hKey);
         }

         //
         // also delete the profile specific enum tree
         //
         DeleteProfileDependentTree(pInfo->pHwProfValues[ulIndex].ulProfile);

         //
         // also delete aliases to this profile
         //
         DeleteAliasEntries(pInfo->pHwProfValues[ulIndex].ulProfile);

         //
         // decrement the appropriate name-generating counter
         // (note that the counter is only deleted for new profiles that are
         // never fully commited; we don't make an attempt to decerement the
         // counter when any profile is deleted, else we may get into a case
         // where we assign a name to a new profile that in incrementally less
         // than a name we had previously assigned.)
         //
         AdjustProfileTypeCounter(pInfo,
                                  pInfo->pHwProfValues[ulIndex].ulDockState, 
                                  FALSE);
      }
      ulIndex++;
   }

   return TRUE;

} // RemoveNewProfiles



/**-------------------------------------------------------------------------**/
BOOL
SwapPreferenceOrder(
      HWND  hDlg,
      HWND  hList,
      ULONG_PTR ulIndex1,
      ULONG_PTR ulIndex2
      )

{
   ULONG    ulProfile1=0, ulProfile2=0;
   ULONG    ulBufferIndex1=0, ulBufferIndex2=0;
   WCHAR    szFriendlyName1[MAX_FRIENDLYNAME_LEN];
   WCHAR    szFriendlyName2[MAX_FRIENDLYNAME_LEN];
   ULONG    ulTemp=0;
   PHWPROF_INFO   pInfo=NULL;


   //
   // retrieve the profile buffer
   //
   pInfo = (PHWPROF_INFO)GetWindowLongPtr(hDlg, DWLP_USER);

   //
   // retrieve the profile id for the two selected profile entries
   //
   ulProfile1 = (ULONG)SendMessage(hList, LB_GETITEMDATA, ulIndex1, 0);
   ulProfile2 = (ULONG)SendMessage(hList, LB_GETITEMDATA, ulIndex2, 0);

   //
   // find the profile entry in the buffer that matches these selections
   //
   while (ulBufferIndex1 < pInfo->ulNumProfiles) {
      if (pInfo->pHwProfValues[ulBufferIndex1].ulProfile == ulProfile1) {
         break;
      }
      ulBufferIndex1++;
   }

   while (ulBufferIndex2 < pInfo->ulNumProfiles) {
      if (pInfo->pHwProfValues[ulBufferIndex2].ulProfile == ulProfile2) {
         break;
      }
      ulBufferIndex2++;
   }

   //
   // swap the order values of the profiles in the in-memory buffer
   //
   ulTemp = pInfo->pHwProfValues[ulBufferIndex1].ulPreferenceOrder;
   pInfo->pHwProfValues[ulBufferIndex1].ulPreferenceOrder =
            pInfo->pHwProfValues[ulBufferIndex2].ulPreferenceOrder;
   pInfo->pHwProfValues[ulBufferIndex2].ulPreferenceOrder = ulTemp;

   //
   // mark both profiles as having been reordered
   //
   pInfo->pHwProfValues[ulBufferIndex1].ulAction |= HWP_REORDER;
   pInfo->pHwProfValues[ulBufferIndex2].ulAction |= HWP_REORDER;

   //
   // swap the positions in the list box
   //
   SendMessage(hList, LB_GETTEXT, ulIndex1, (LPARAM)(LPTSTR)szFriendlyName1);
   SendMessage(hList, LB_GETTEXT, ulIndex2, (LPARAM)(LPTSTR)szFriendlyName2);

   SendMessage(hList, LB_DELETESTRING, ulIndex1, 0);
   SendMessage(hList, LB_INSERTSTRING, ulIndex1,
         (LPARAM)(LPTSTR)szFriendlyName2);

   SendMessage(hList, LB_DELETESTRING, ulIndex2, 0);
   SendMessage(hList, LB_INSERTSTRING, ulIndex2,
         (LPARAM)(LPTSTR)szFriendlyName1);

   SendMessage(hList, LB_SETITEMDATA, ulIndex1, ulProfile2);
   SendMessage(hList, LB_SETITEMDATA, ulIndex2, ulProfile1);

   //
   // finally, select the second index (the second index is the rank
   // position we're moving to)
   //
   SendMessage(hList, LB_SETCURSEL, ulIndex2, 0);

   return TRUE;

} // SwapPreferenceOrder


/**-------------------------------------------------------------------------**/
BOOL
DeleteProfileDependentTree(
      ULONG ulProfile
      )
{
   TCHAR szProfile[5], szKey[MAX_PATH];
   LONG  RegStatus = ERROR_SUCCESS;
   HKEY  hHwProfKey, hCfgKey;
   ULONG ulIndex = 0, ulSize = 0;


   //
   // form the registry key string
   //
   if (RegOpenKeyEx(
            HKEY_LOCAL_MACHINE, pszRegHwProfiles, 0, KEY_ALL_ACCESS,
            &hHwProfKey) != ERROR_SUCCESS) {

      DisplaySystemMessage(NULL, ERROR_REGISTRY_CORRUPT);
      return FALSE;
   }

   wsprintf(szProfile, TEXT("%04u"),
            ulProfile);

   DeleteRegistryNode(hHwProfKey, szProfile);
   RegCloseKey(hHwProfKey);

   return TRUE;

} // DeleteProfileDependentTree

/**-------------------------------------------------------------------------**/

BOOL
CopyAliasEntries(
    ULONG ulSrcProfile,
    ULONG ulDestProfile
    )
{
   BOOL bNewAliasCreated = FALSE;

   bNewAliasCreated |= CopyAliasEntryType(ulSrcProfile, ulDestProfile, pszRegAlias);
   bNewAliasCreated |= CopyAliasEntryType(ulSrcProfile, ulDestProfile, pszRegAcpiAlias);    

   return bNewAliasCreated;

} // CopyAliasEntries

/**-------------------------------------------------------------------------**/

BOOL
DeleteAliasEntries(
    ULONG ulProfile    
    )
{
   BOOL bResult = TRUE;

   bResult |= DeleteAliasEntryType(ulProfile, pszRegAlias);
   bResult |= DeleteAliasEntryType(ulProfile, pszRegAcpiAlias);    

   return bResult;

} // CopyAliasEntries

/**-------------------------------------------------------------------------**/

BOOL
CopyAliasEntryType(
    ULONG  ulSrcProfile,
    ULONG  ulDestProfile,
    LPWSTR szSubKeyName
    )
{

   LONG   RegStatus = ERROR_SUCCESS;
   HKEY   hAliasRoot, hSrcKey, hDestKey;
   WCHAR  RegStr[MAX_PATH];
   WCHAR  szString[MAX_PATH];
   ULONG  ulAliasProfileNumber, ulNewAlias, ulSize, i;
   BOOL   bNewAliasCreated=FALSE;

   //
   // check all aliases under the "Alias" key
   //
   wsprintf(RegStr, TEXT("%s\\%s"),
            pszRegIDConfigDB,
            szSubKeyName);

   RegStatus = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE, RegStr, 0, KEY_ALL_ACCESS,
            &hAliasRoot);
   if (RegStatus == ERROR_FILE_NOT_FOUND) {
      //
      // No Alias subkey, this could be ok if we have the other type.
      //
      RegStatus = ERROR_SUCCESS;
      return bNewAliasCreated;
   } else if (RegStatus != ERROR_SUCCESS) {
      //
      // Some other registry error occurred.
      //
      DisplaySystemMessage(NULL, ERROR_REGISTRY_CORRUPT);
      return FALSE;
   } else {
       //
       // enumerate all Alias subkeys
       //
       for (i=0; RegStatus == ERROR_SUCCESS; i++) {

           ulSize = MAX_PATH;
           
           RegStatus = RegEnumKey(hAliasRoot, i, szString, ulSize);

           if (RegStatus == ERROR_SUCCESS) {

               if (RegOpenKey(hAliasRoot, szString, &hSrcKey) == ERROR_SUCCESS) {
             
                   ulSize = sizeof(ULONG);
                   
                   if (RegQueryValueEx(
                       hSrcKey, pszRegProfileNumber, NULL, NULL,
                       (LPBYTE)&ulAliasProfileNumber, 
                       &ulSize) == ERROR_SUCCESS) {
                 
                       //
                       // Check if we need to copy this one
                       //
                       if (ulSrcProfile == ulAliasProfileNumber) {

                           //
                           // Find an unused Alias subkey name
                           //          
                           ulNewAlias = 0;
                           while (ulNewAlias < MAX_ALIASES) {
                               ulNewAlias++;
                               wsprintf(RegStr, TEXT("%s\\%s\\%04u"),
                                        pszRegIDConfigDB,
                                        szSubKeyName,
                                        ulNewAlias);              
                               RegStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                                                        RegStr, 0, KEY_ALL_ACCESS, 
                                                        &hDestKey);
                               
                               if (RegStatus == ERROR_SUCCESS) {
                                   RegCloseKey(hDestKey);
                                   continue;
                               } else if (RegStatus == ERROR_FILE_NOT_FOUND) {
                                   RegStatus = ERROR_SUCCESS;
                                   break;
                               } else {
                                   break;
                               }
                           }
                     
                           if ((RegStatus != ERROR_SUCCESS) || (ulNewAlias >= MAX_ALIASES)) {
                               RegCloseKey(hSrcKey);
                               break;
                           }

                           wsprintf(RegStr, TEXT("%s\\%s\\%04u"),
                                    pszRegIDConfigDB,
                                    szSubKeyName,
                                    ulNewAlias);
                           
                           RegCreateKeyEx(
                               HKEY_LOCAL_MACHINE, RegStr, 0, NULL, REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS, NULL, &hDestKey, NULL);
                        
                           //
                           // copy this alias entry 
                           //   
                           CopyRegistryNode(hSrcKey, hDestKey);
                           
                           RegSetValueEx(
                               hDestKey, pszRegProfileNumber, 0, REG_DWORD,
                               (LPBYTE)&ulDestProfile, sizeof(ULONG));
                           
                           bNewAliasCreated = TRUE;
                           if (ulNewAlias < (ULONG)_wtoi(szString)) {
                               // kick the enumeration index up one, else we'll
                               // find the key we just copied again.
                               i++;
                           }
                           
                           if (hDestKey != NULL) {
                               RegCloseKey(hDestKey);
                               hDestKey = NULL;
                           }                           
                       }
                   }
                   if (hSrcKey != NULL) {
                       RegCloseKey(hSrcKey);
                       hSrcKey = NULL;
                   }
               }
           }
       }
       RegCloseKey(hAliasRoot);
       hAliasRoot = NULL;
   }

   return bNewAliasCreated;

} // CopyAliasEntryType

/**-------------------------------------------------------------------------**/

BOOL
DeleteAliasEntryType(
      ULONG  ulProfile,
      LPWSTR szSubKeyName
      )

{

   LONG   RegStatus = ERROR_SUCCESS;
   HKEY   hAliasRoot;
   HKEY   hAliasSubKey;
   WCHAR  RegStr[MAX_PATH];
   WCHAR  szString[MAX_PATH];
   ULONG  ulAliasProfileNumber, ulSize, i;
   BOOL   bDeleted = FALSE;

   //
   // check all aliases under the "Alias" key
   //
   wsprintf(RegStr, TEXT("%s\\%s"),
            pszRegIDConfigDB,
            szSubKeyName);

   RegStatus = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE, RegStr, 0, KEY_ALL_ACCESS,
            &hAliasRoot);
   if (RegStatus == ERROR_FILE_NOT_FOUND) {
       return TRUE;
   } else if (RegStatus != ERROR_SUCCESS) {
      DisplaySystemMessage(NULL, ERROR_REGISTRY_CORRUPT);
      return FALSE;
   }
   
   //
   // enumerate all subkeys
   //
   RegStatus = ERROR_SUCCESS;

   for (i=0; RegStatus == ERROR_SUCCESS; ) {

      ulSize = MAX_PATH;

      RegStatus = RegEnumKey(hAliasRoot, i, szString, ulSize);
      bDeleted = FALSE;

      if (RegStatus == ERROR_SUCCESS) {
         if (RegOpenKey(hAliasRoot, szString, &hAliasSubKey) == ERROR_SUCCESS) {
             
             ulSize = sizeof(ULONG);
             if (RegQueryValueEx(
                 hAliasSubKey, pszRegProfileNumber, NULL, NULL,
                 (LPBYTE)&ulAliasProfileNumber, 
                 &ulSize) == ERROR_SUCCESS) {
                 
                 if (ulProfile == ulAliasProfileNumber) {
                     //
                     // delete this alias entry 
                     //
                     RegCloseKey(hAliasSubKey);
                     hAliasSubKey = NULL;
                     RegDeleteKey(hAliasRoot, szString);
                     bDeleted = TRUE;
                 }
             }
             if (hAliasSubKey) RegCloseKey(hAliasSubKey);
         }
      }
      if (!bDeleted) i++;
   }   
   RegCloseKey(hAliasRoot);
      
   return TRUE;

} // DeleteAliasEntryType

/**-------------------------------------------------------------------------**/

BOOL
CopyRegistryNode(
   HKEY     hSrcKey,
   HKEY     hDestKey
   )
{

   LONG  RegStatus = ERROR_SUCCESS;
   HKEY  hSrcSubKey, hDestSubKey;
   WCHAR szString[MAX_PATH];
   ULONG ulDataSize, ulLength, ulType, i;
   BYTE  Data[MAX_PATH * 2];          // biggest value data??
   PSECURITY_DESCRIPTOR pSecDesc;

   // copy all values for this key
   for (i=0; RegStatus == ERROR_SUCCESS; i++)
   {
      ulLength = MAX_PATH;
      ulDataSize = sizeof(Data);

      RegStatus = RegEnumValue(hSrcKey, i, szString, &ulLength, NULL,
            &ulType, Data, &ulDataSize);

        if (RegStatus == ERROR_SUCCESS)
        {
           RegSetValueEx(hDestKey, szString, 0, ulType, Data, ulDataSize);
        }
    }

    // recursively call CopyRegistryNode to copy all subkeys
    RegStatus = ERROR_SUCCESS;
    for (i=0; RegStatus == ERROR_SUCCESS; i++)
    {

      ulLength = MAX_PATH;

      RegStatus = RegEnumKey(hSrcKey, i, szString, ulLength);

      if (RegStatus == ERROR_SUCCESS)
      {
         if (RegOpenKey(hSrcKey, szString, &hSrcSubKey) == ERROR_SUCCESS)
         {
            if (RegCreateKey(hDestKey, szString, &hDestSubKey) == ERROR_SUCCESS)
            {
               RegGetKeySecurity(hSrcSubKey, DACL_SECURITY_INFORMATION, NULL, &ulDataSize);
               pSecDesc = LocalAlloc(LPTR, ulDataSize);
               RegGetKeySecurity(hSrcSubKey, DACL_SECURITY_INFORMATION, pSecDesc, &ulDataSize);

               CopyRegistryNode(hSrcSubKey, hDestSubKey);

               RegSetKeySecurity(hDestSubKey, DACL_SECURITY_INFORMATION, pSecDesc);
               LocalFree(pSecDesc);
               RegCloseKey(hDestSubKey);
            }
            RegCloseKey(hSrcSubKey);
         }
      }
   }

   return TRUE;

} // CopyRegistryNode


/**-------------------------------------------------------------------------**/
BOOL
DeleteRegistryNode(
   HKEY     hParentKey,
   LPTSTR   szKey
   )
{
   ULONG ulSize = 0;
   LONG  RegStatus = ERROR_SUCCESS;
   HKEY  hKey = NULL;
   WCHAR szSubKey[MAX_PATH];


   //
   // attempt to delete the key
   //
   if (RegDeleteKey(hParentKey, szKey) != ERROR_SUCCESS) {

      if (RegOpenKeyEx(
               hParentKey, szKey, 0, KEY_ENUMERATE_SUB_KEYS | KEY_WRITE,
               &hKey) != ERROR_SUCCESS) {
         return FALSE;
      }

      //
      // enumerate subkeys and delete those nodes
      //
      while (RegStatus == ERROR_SUCCESS) {
         //
         // enumerate the first level children under the profile key
         //
         ulSize = MAX_PATH;
         RegStatus = RegEnumKeyEx(
                  hKey, 0, szSubKey, &ulSize,
                  NULL, NULL, NULL, NULL);

         if (RegStatus == ERROR_SUCCESS) {

            if (!DeleteRegistryNode(hKey, szSubKey)) {
               RegCloseKey(hKey);
               return FALSE;
            }
         }
      }

      //
      // subkeys have been deleted, try deleting this key again
      //
      RegCloseKey(hKey);
      RegDeleteKey(hParentKey, szKey);
   }

   return TRUE;

}  // DeleteRegistryNode


/**-------------------------------------------------------------------------**/
VOID
AdjustProfileTypeCounter(
    PHWPROF_INFO   pInfo,
    ULONG          ulDockState,
    BOOL           bIncrement
    )
{
    PULONG pCounter;

    //
    // use the counter corresponding to the given DockState.
    //
    if ((ulDockState & DOCKINFO_DOCKED) &&
        (ulDockState & DOCKINFO_UNDOCKED)) {       
        pCounter = &pInfo->ulUnknownProfileNameCount;
    } else if (ulDockState & DOCKINFO_DOCKED) {
        pCounter = &pInfo->ulDockedProfileNameCount;
    } else if (ulDockState & DOCKINFO_UNDOCKED) {
        pCounter = &pInfo->ulUndockedProfileNameCount;
    } else {
        pCounter = &pInfo->ulUnknownProfileNameCount;
    }

    //
    // increment or decrement the counter, as requested.
    //
    if (bIncrement) {
        *pCounter += 1;
    } else if (!bIncrement && (*pCounter > 0)) {
        *pCounter -= 1;        
    } else {
        *pCounter = 0;
    }
}

/**-------------------------------------------------------------------------**/
BOOL
StripCurrentTag(
   LPTSTR   szFriendlyName,
   ULONG    ulProfile,
   ULONG    ulCurrentProfile
   )
{
   ULONG ulTagLen, ulNameLen;


   if (ulProfile == ulCurrentProfile) {

      ulTagLen = lstrlen(pszCurrentTag);
      ulNameLen = lstrlen(szFriendlyName);

      if (ulNameLen < ulTagLen) {
         return TRUE;   // nothing to do
      }

      if (lstrcmpi(&szFriendlyName[ulNameLen - ulTagLen], pszCurrentTag) == 0) {
         //
         // truncate the string before the current tag
         //
         szFriendlyName[ulNameLen - ulTagLen - 1] = '\0';
      }
   }

   return TRUE;

} // StripCurrentTag


/**-------------------------------------------------------------------------**/
BOOL
AppendCurrentTag(
   LPTSTR   szTaggedName,
   LPCTSTR  szOriginalName,
   ULONG    ulProfile,
   ULONG    ulCurrentProfile
   )
{

   lstrcpy(szTaggedName, szOriginalName);

   //
   // if the profile is the current profile, then append the tag
   // (let's user easily identify it as current)
   //
   if (ulProfile == ulCurrentProfile) {
      lstrcat(szTaggedName, TEXT(" "));
      lstrcat(szTaggedName, pszCurrentTag);
   }

   return TRUE;

} // AppendCurrentTag


/**-------------------------------------------------------------------------**/
VOID
CreateHwProfileFriendlyName(
   IN  HWND       hDlg,
   IN  ULONG      ulDockState,
   OUT LPTSTR     szFriendlyName
   )
{

   PHWPROF_INFO   pInfo;
   LPTSTR         szPrefix;
   PULONG         pulIndex;
   BOOL           bUnknown=FALSE, bUniqueFriendlyName=FALSE;

   //
   // retrieve the profile buffer
   //
   pInfo = (PHWPROF_INFO)GetWindowLongPtr(hDlg, DWLP_USER);

   //
   // based on the DockState, determine the appropriate label to use and get a
   // pointer to its counter index
   //
   if ((ulDockState & DOCKINFO_DOCKED) &&
       (ulDockState & DOCKINFO_UNDOCKED)) {
       szPrefix = pszUnknown;
       pulIndex = &pInfo->ulUnknownProfileNameCount;
       bUnknown = TRUE;
   }
   else if (ulDockState & DOCKINFO_DOCKED) {
       szPrefix = pszDocked;
       pulIndex = &pInfo->ulDockedProfileNameCount;
   }
   else if (ulDockState & DOCKINFO_UNDOCKED) {
       szPrefix = pszUndocked;
       pulIndex = &pInfo->ulUndockedProfileNameCount;
   }
   else {
       szPrefix = pszUnknown;
       pulIndex = &pInfo->ulUnknownProfileNameCount;
       bUnknown = TRUE;
   }

   while ((!bUniqueFriendlyName) && (*pulIndex < MAX_PROFILES)) {
       //
       // as long as we don't have a unique name, build a FriendlyName based on
       // the DockState and counter index
       //
       if (bUnknown || (*pulIndex > 0)) {
           wsprintf(szFriendlyName, TEXT("%s %u"),
                    szPrefix,
                    *pulIndex + 1);
       } else {
           lstrcpy(szFriendlyName, szPrefix);
       }

       if (IsProfileNameInUse(hDlg,szFriendlyName)) {
           //
           // if this friendly name is in use, increment the counter to reflect this
           //
           *pulIndex += 1;
       } else {
           //
           // a unique friendly name has been generated
           //
           bUniqueFriendlyName = TRUE;
       }
   }

   if (!bUniqueFriendlyName) {
       //
       // if unable to generate a unique friendly name, just use some default.
       // the user may have to deal with any errors arising from duplicate names
       // is this name is already taken
       //
       lstrcpy(szFriendlyName, pszRegDefaultFriendlyName);
   }

   return;

} // CreateHwProfileFriendlyName


/**-------------------------------------------------------------------------**/
VOID
DisplayPrivateMessage(
      HWND  hWnd,
      UINT  uiPrivateError
      )
{
   WCHAR szMessage[MAX_PATH];


   LoadString(hInstance, uiPrivateError, szMessage, MAX_PATH);
   MessageBox(hWnd, szMessage, pszErrorCaption, MB_OK | MB_ICONSTOP);

   return;
}


/**-------------------------------------------------------------------------**/
VOID
DisplaySystemMessage(
      HWND  hWnd,
      UINT  uiSystemError
      )
{
   WCHAR szMessage[MAX_PATH];

   //
   // retrieve the string matching the Win32 system error
   //
   FormatMessage(
            FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            uiSystemError,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
            szMessage,
            MAX_PATH,
            NULL);

   //
   // display a message box with this error
   //
   MessageBox(
            hWnd,
            szMessage,
            pszErrorCaption,
            MB_OK | MB_ICONSTOP);

   return;

} // DisplaySystemMessage


/**--------------------------------------------------------------------------**/
BOOL
UpdateOrderButtonState(
   HWND  hDlg
   )
{
   PHWPROF_INFO   pInfo;
   ULONG_PTR      ulIndex = 0;
   HWND           hList;


   pInfo = (PHWPROF_INFO)GetWindowLongPtr(hDlg, DWLP_USER);

   hList = GetDlgItem(hDlg, IDD_HWP_PROFILES);

   if ((ulIndex = SendMessage(hList,
        LB_GETCURSEL, 0, 0)) == LB_ERR) {
      return FALSE;
   }

   if (ulIndex == 0) {
      //
      // if focus currently on the button we're about to disable,
      // change focus first or focus will be lost.
      //
      if (GetFocus() == GetDlgItem(hDlg, IDD_HWP_ORDERUP)) {
          SendMessage(hDlg, DM_SETDEFID, IDD_HWP_ORDERDOWN, 0L);
          SetFocus(GetDlgItem(hDlg, IDD_HWP_ORDERDOWN));
      }
      EnableWindow(GetDlgItem(hDlg, IDD_HWP_ORDERUP), FALSE);
   } else {
      EnableWindow(GetDlgItem(hDlg, IDD_HWP_ORDERUP), TRUE);
   }

   if (ulIndex < pInfo->ulActiveProfiles-1) {
      EnableWindow(GetDlgItem(hDlg, IDD_HWP_ORDERDOWN), TRUE);
   } else {
      //
      // if focus currently on the button we're about to disable,
      // change focus first or focus will be lost.
      //
      if (GetFocus() == GetDlgItem(hDlg, IDD_HWP_ORDERDOWN)) {
          SendMessage(hDlg, DM_SETDEFID, IDD_HWP_PROPERTIES, 0L);
          SetFocus(GetDlgItem(hDlg, IDD_HWP_PROPERTIES));
      }
      EnableWindow(GetDlgItem(hDlg, IDD_HWP_ORDERDOWN), FALSE);
   }




   return TRUE;
}


/**-------------------------------------------------------------------------**/
BOOL CALLBACK AddPropSheetPageProc(
    HPROPSHEETPAGE  hpage,
    LPARAM  lParam
   )
{
    hPages[ulNumPages] = hpage;

    return TRUE;

} // AddPropSheetPageProc


/**--------------------------------------------------------------------------**/
BOOL
DisplayProperties(
    IN HWND           hOwnerDlg,
    IN PHWPROF_INFO   pInfo
    )
{
    BOOL              bStatus;
    LPTSTR            pszProviderList = NULL, pszProvider = NULL;
    PROPSHEETPAGE     PropPage;
    PROPSHEETHEADER   PropHeader;
    FARPROC           lpProc;
    ULONG             i, ulSize = 0;
    HKEY              hKey = NULL;


    //
    // create the first page (General)
    //
    ulNumPages = 0;

    PropPage.dwSize        = sizeof(PROPSHEETPAGE);
    PropPage.dwFlags       = PSP_DEFAULT;
    PropPage.hInstance     = hInstance;
    PropPage.pszTemplate   = MAKEINTRESOURCE(DLG_HWP_GENERAL);
    PropPage.pszIcon       = NULL;
    PropPage.pszTitle      = NULL;
    PropPage.pfnDlgProc    = GeneralProfileDlg;
    PropPage.lParam        = (LPARAM)pInfo;
    PropPage.pfnCallback   = NULL;

    hPages[0] = CreatePropertySheetPage(&PropPage);
    if (hPages[0] == NULL) {
        return FALSE;
    }

    ulNumPages++;

    //
    // open the IDConfigDB key
    //
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszRegIDConfigDB, 0,
                     KEY_QUERY_VALUE, &hKey) != ERROR_SUCCESS) {
        return FALSE;
    }


    //---------------------------------------------------------------
    // Are there any other property pages?
    //---------------------------------------------------------------

    if (RegQueryValueEx(hKey, pszRegPropertyProviders, NULL, NULL,
                        NULL, &ulSize) == ERROR_SUCCESS) {

        pszProviderList = LocalAlloc(LPTR, ulSize);

        if (pszProviderList != NULL) {
            //
            // read list of providers
            //
            if (RegQueryValueEx(hKey, pszRegPropertyProviders, NULL, NULL,
                    (LPBYTE)pszProviderList, &ulSize) == ERROR_SUCCESS) {
                //
                // Ask each provider to create and register it's property page
                //
                for (pszProvider = pszProviderList;
                     *pszProvider;
                     pszProvider += lstrlen(pszProvider) + 1) {

                    if (ulNumPages >= MAX_EXTENSION_PROVIDERS) {
                        break;      // stop at max number of pages
                    }

                    //
                    // load the provider DLL
                    //
                    hLibs[ulNumPages] = LoadLibrary(pszProvider);
                    if (hLibs[ulNumPages] != NULL) {

                        lpProc = GetProcAddress(hLibs[ulNumPages],
                                                "ExtensionPropSheetPageProc");
                        if (lpProc != NULL) {
                            //
                            // pass the profile ID to the provider as the lParam value
                            //
                            if ((lpProc)(NULL,
                                         &AddPropSheetPageProc,
                                         pInfo->ulSelectedProfile)) {
                                ulNumPages++;
                            }
                        }
                    }
                }
            }
            LocalFree(pszProviderList);
        }
    }

    RegCloseKey(hKey);


    //
    // create the property sheet
    //
    PropHeader.dwSize      = sizeof(PROPSHEETHEADER);
    PropHeader.dwFlags     = PSH_PROPTITLE | PSH_NOAPPLYNOW;
    PropHeader.hwndParent  = hOwnerDlg;
    PropHeader.hInstance   = hInstance;
    PropHeader.pszIcon     = NULL;   //MAKEINTRESOURCE(DOCK_ICON);
    PropHeader.pszCaption  =
            pInfo->pHwProfValues[pInfo->ulSelectedProfileIndex].szFriendlyName;
    PropHeader.nPages      = ulNumPages;
    PropHeader.phpage      = hPages;
    PropHeader.nStartPage  = 0;
    PropHeader.pfnCallback = NULL;

    if (PropertySheet(&PropHeader) == 1) {
        bStatus = FALSE;
    } else {
        bStatus = TRUE;
    }

    //
    // cleanup extension page info
    //
    for (i = 1; i < ulNumPages; i++) {
        FreeLibrary(hLibs[i]);
    }

    return bStatus;

} // DisplayProperties



/**-------------------------------------------------------------------------**/
INT_PTR
APIENTRY
GeneralProfileDlg(
      HWND    hDlg,
      UINT    uMessage,
      WPARAM  wParam,
      LPARAM  lParam
      )

{
   PHWPROF_INFO      pInfo = NULL;
   PHWPROF_VALUES    pProfInfo = NULL;
   ULONG             ulReturn, ulIndex;

   switch (uMessage)
   {
      case WM_INITDIALOG:

         if (!lParam) {
            break;
         }

         //
         // on WM_INITDIALOG call, lParam points to the property sheet page.
         // The lParam field in the property sheet page struct is set by,
         // caller. When I created the property sheet, I passed in a pointer
         // to a HWPROF_INFO struct. Save this in the user window long so I
         // can access it on later messages.
         //
         pInfo = (PHWPROF_INFO)((LPPROPSHEETPAGE)lParam)->lParam;
         SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pInfo);

         pProfInfo = (PHWPROF_VALUES)(&(pInfo->pHwProfValues[pInfo->ulSelectedProfileIndex]));

         SetDlgItemText(hDlg, IDD_HWP_ST_PROFILE, pProfInfo->szFriendlyName);

         //
         // for pre-beta hwprofile code, the dockstate might have originally
         // been set to zero which is invalid, use 0x111 instead
         //
         if (pProfInfo->ulDockState == 0) {
            pProfInfo->ulDockState =
                     DOCKINFO_USER_SUPPLIED | DOCKINFO_DOCKED | DOCKINFO_UNDOCKED;
         }

         //
         // initialize the dock state radio buttons
         //
         if ((pProfInfo->ulDockState & DOCKINFO_DOCKED) &&
             (pProfInfo->ulDockState & DOCKINFO_UNDOCKED)) {

            CheckRadioButton(hDlg, IDD_HWP_UNKNOWN, IDD_HWP_UNDOCKED, IDD_HWP_UNKNOWN);
         }
         else if (pProfInfo->ulDockState & DOCKINFO_DOCKED) {
            CheckRadioButton(hDlg, IDD_HWP_UNKNOWN, IDD_HWP_UNDOCKED, IDD_HWP_DOCKED);
         }
         else if (pProfInfo->ulDockState & DOCKINFO_UNDOCKED) {
            CheckRadioButton(hDlg, IDD_HWP_UNKNOWN, IDD_HWP_UNDOCKED, IDD_HWP_UNDOCKED);
         }
         else {
            CheckRadioButton(hDlg, IDD_HWP_UNKNOWN, IDD_HWP_UNDOCKED, IDD_HWP_UNKNOWN);
         }

         //
         // if the user-specified bit is not set then the dock state
         // was determined from the hardware so don't allow changing it
         //
         if (pProfInfo->ulDockState & DOCKINFO_USER_SUPPLIED) {
         }
         else {
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_PORTABLE), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_DOCKED), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_UNDOCKED), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_UNKNOWN), FALSE);
         }

         //
         // initialize the dock id and serial # static control
         //
         if (pProfInfo->szSerialNumber[0] &&
             (pProfInfo->szSerialNumber[0] != TEXT('0'))) {
            SetDlgItemText(hDlg, IDD_HWP_SERIALNUM, pProfInfo->szSerialNumber);
         }
         else {
            SetDlgItemText(hDlg, IDD_HWP_SERIALNUM, pszUnavailable);
         }

         if (pProfInfo->szDockID[0] &&
             (pProfInfo->szDockID[0] != TEXT('0'))) {
            SetDlgItemText(hDlg, IDD_HWP_DOCKID, pProfInfo->szDockID);
            //
            // if dock id is available then docking state is known
            // and cannot be over-ridden (this is a redundant check,
            // the dock state should be accurate)
            //
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_PORTABLE), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_DOCKED), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_UNDOCKED), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_UNKNOWN), FALSE);
         }
         else {
            SetDlgItemText(hDlg, IDD_HWP_DOCKID, pszUnavailable);
         }

         //
         // initialize the portable checkbox-groupbox
         //
         if (pInfo->bPortable) {
            CheckDlgButton(hDlg, IDD_HWP_PORTABLE, BST_CHECKED);
         }
         else {
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_DOCKED), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_UNDOCKED), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_UNKNOWN), FALSE);
         }

         //
         // Don't allow changing the global IsPortable Flag if it was determined
         // from the hardware
         //
         if (pInfo->bHwDetectedPortable) {
             EnableWindow(GetDlgItem(hDlg, IDD_HWP_PORTABLE), FALSE);
         }

         //
         // initialize the aliasable checkbox
         //
         if (pProfInfo->bAliasable) {
            CheckDlgButton(hDlg, IDD_HWP_ALIASABLE, BST_CHECKED);
         }
         else {
             CheckDlgButton(hDlg, IDD_HWP_ALIASABLE, BST_UNCHECKED);
         }

         SetFocus(GetDlgItem(hDlg, IDD_HWP_PORTABLE));
         return FALSE;

      case WM_DEVICECHANGE:
         //
         // If a hardware profile change event takes place while the dialog is
         // up, just dismiss the dialog because things have changed.
         //
         if (wParam == DBT_CONFIGCHANGED) {
            PropSheet_PressButton(GetParent(hDlg), PSBTN_CANCEL);
            return TRUE;
         }
         break;

      case WM_NOTIFY:

         if (!lParam) {
            break;
         }

         switch (((NMHDR *)lParam)->code) {

             case PSN_APPLY:

               pInfo = (PHWPROF_INFO)GetWindowLongPtr(hDlg, DWLP_USER);
               pProfInfo = (PHWPROF_VALUES)(&(pInfo->pHwProfValues[pInfo->ulSelectedProfileIndex]));

               //
               // unchecked --> checked case
               //
               if (!pInfo->bPortable && IsDlgButtonChecked(hDlg, IDD_HWP_PORTABLE)) {
                  pInfo->bPortable = TRUE;
               }
               //
               // checked --> unchecked case
               //
               else if (pInfo->bPortable && !IsDlgButtonChecked(hDlg, IDD_HWP_PORTABLE)) {

                   TCHAR szCaption[MAX_PATH];
                   TCHAR szMsg[MAX_PATH];

                   LoadString(hInstance, HWP_ERROR_CAPTION, szCaption, MAX_PATH);
                   LoadString(hInstance, HWP_CONFIRM_NOT_PORTABLE, szMsg, MAX_PATH);

                   //
                   // confirm with user that other profiles will be set to unknown
                   //
                   if (MessageBox(hDlg, szMsg, szCaption,
                                  MB_OKCANCEL | MB_ICONQUESTION) == IDCANCEL) {

                       SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);   // don't apply
                       return TRUE;
                   }

                   for (ulIndex = 0; ulIndex < pInfo->ulNumProfiles; ulIndex++) {

                       if (pInfo->pHwProfValues[ulIndex].ulDockState & 
                           DOCKINFO_USER_SUPPLIED) {
                           //
                           // only user-specified dock states will be changed
                           //
                           pInfo->pHwProfValues[ulIndex].ulDockState =
                               DOCKINFO_USER_SUPPLIED | DOCKINFO_DOCKED | DOCKINFO_UNDOCKED;
                           pInfo->pHwProfValues[ulIndex].ulAction = HWP_PROPERTIES;                           
                       }

                   }
                   pInfo->bPortable = FALSE;
               }

               //
               // if user-specified dock state, then update the profile values
               // with current ui settings
               //
               if (pProfInfo->ulDockState & DOCKINFO_USER_SUPPLIED) {

                  if (IsDlgButtonChecked(hDlg, IDD_HWP_DOCKED)) {
                     pProfInfo->ulDockState |= DOCKINFO_DOCKED;
                     pProfInfo->ulDockState &= ~DOCKINFO_UNDOCKED;
                  }
                  else if (IsDlgButtonChecked(hDlg, IDD_HWP_UNDOCKED)) {
                     pProfInfo->ulDockState |= DOCKINFO_UNDOCKED;
                     pProfInfo->ulDockState &= ~DOCKINFO_DOCKED;
                  }
                  else {
                     pProfInfo->ulDockState |= (DOCKINFO_UNDOCKED | DOCKINFO_DOCKED);
                  }
               }

               //
               // aliasable unchecked --> checked case
               //
               if (!pProfInfo->bAliasable && IsDlgButtonChecked(hDlg, IDD_HWP_ALIASABLE)) {
                  pProfInfo->bAliasable = TRUE;
               } 
               //
               // aliasable checked --> unchecked case
               //
               else if (pProfInfo->bAliasable && !IsDlgButtonChecked(hDlg, IDD_HWP_ALIASABLE)) {
                  pProfInfo->bAliasable = FALSE;
               } 

               //
               // commit the changes for this profile
               //
               pProfInfo->ulAction |= HWP_PROPERTIES;
               WriteProfileInfo(pProfInfo);

               SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);   // TRUE if error
               break;

            case PSN_RESET:
               //
               // user canceled the property sheet
               //
               break;
         }
         break;


      case WM_HELP:
         WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, HELP_FILE,
               HELP_WM_HELP, (DWORD_PTR)(LPTSTR)HwProfileHelpIds);
         break;

      case WM_CONTEXTMENU:
         WinHelp((HWND)wParam, HELP_FILE, HELP_CONTEXTMENU,
                  (DWORD_PTR)(LPTSTR)HwProfileHelpIds);
         break;


      case WM_COMMAND:
      {
         switch (LOWORD(wParam))
         {
            case IDD_HWP_PORTABLE:
               //
               // if user chooses portable
               //
               if (!IsDlgButtonChecked(hDlg, IDD_HWP_PORTABLE)) {
                  CheckRadioButton(hDlg, IDD_HWP_UNKNOWN, IDD_HWP_UNDOCKED, IDD_HWP_UNKNOWN);
                  EnableWindow(GetDlgItem(hDlg, IDD_HWP_DOCKED), FALSE);
                  EnableWindow(GetDlgItem(hDlg, IDD_HWP_UNDOCKED), FALSE);
                  EnableWindow(GetDlgItem(hDlg, IDD_HWP_UNKNOWN), FALSE);
               }
               else {
                  EnableWindow(GetDlgItem(hDlg, IDD_HWP_DOCKED), TRUE);
                  EnableWindow(GetDlgItem(hDlg, IDD_HWP_UNDOCKED), TRUE);
                  EnableWindow(GetDlgItem(hDlg, IDD_HWP_UNKNOWN), TRUE);
               }
               break;

            default:
               return FALSE;
          }
          break;

       } // case WM_COMMAND...

       default:
          return FALSE;
          break;
    }

    return TRUE;

} // GeneralProfileDlg
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\perf.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    perf.h

Abstract:

    Public declarations for the Performance dialog of the 
    System Control Panel Applet

Author:

    Eric Flo (ericflo) 19-Jun-1995

Revision History:

    15-Oct-1997 scotthal
        Complete overhaul

--*/
#ifndef _SYSDM_PERF_H_
#define _SYSDM_PERF_H_

//
//  Reboot switch for crashdump dlg
//

#define RET_ERROR               (-1)
#define RET_NO_CHANGE           0x00
#define RET_VIRTUAL_CHANGE      0x01
#define RET_RECOVER_CHANGE      0x02
#define RET_CHANGE_NO_REBOOT    0x04
#define RET_CONTINUE            0x08
#define RET_BREAK               0x10

#define RET_VIRT_AND_RECOVER (RET_VIRTUAL_CHANGE | RET_RECOVER_CHANGE)



//
// Public function declarations
//
HPROPSHEETPAGE 
CreatePerformancePage(
    IN HINSTANCE hInst
);

INT_PTR 
APIENTRY 
PerformanceDlgProc(
    IN HWND hDlg, 
    IN UINT uMsg, 
    IN WPARAM wParam, 
    IN LPARAM lParam
);

#endif // _SYSDM_PERF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\perf.c ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    perf.c

Abstract:

    Implements the Performance dialog of the System Control Panel Applet

Author:

    Eric Flo (ericflo) 19-Jun-1995

Revision History:

    15-Oct-1997 scotthal
        Complete overhaul
        
    10-Jul-2000 SilviuC
        Added the LargeSystemCache setting.    

--*/
#include <sysdm.h>
#include <help.h>

#define PROCESS_PRIORITY_SEPARATION_MASK    0x00000003
#define PROCESS_PRIORITY_SEPARATION_MAX     0x00000002
#define PROCESS_PRIORITY_SEPARATION_MIN     0x00000000

#define PROCESS_QUANTUM_VARIABLE_MASK       0x0000000c
#define PROCESS_QUANTUM_VARIABLE_DEF        0x00000000
#define PROCESS_QUANTUM_VARIABLE_VALUE      0x00000004
#define PROCESS_QUANTUM_FIXED_VALUE         0x00000008
#define PROCESS_QUANTUM_LONG_MASK           0x00000030
#define PROCESS_QUANTUM_LONG_DEF            0x00000000
#define PROCESS_QUANTUM_LONG_VALUE          0x00000010
#define PROCESS_QUANTUM_SHORT_VALUE         0x00000020

//
// Globals
//

HKEY  m_hKeyPerf = NULL;
TCHAR m_szRegPriKey[] = TEXT( "SYSTEM\\CurrentControlSet\\Control\\PriorityControl" );
TCHAR m_szRegPriority[] = TEXT( "Win32PrioritySeparation" );

HKEY  m_hKeyMemoryManagement = NULL;
TCHAR m_szRegMemoryManagementKey[] = TEXT( "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management" );
TCHAR m_szRegLargeSystemCache[] = TEXT( "LargeSystemCache" );


//
// Help ID's
//

// ISSUE: SilviuC: 07/11/2000: IDC_PERF_CACHE_XXX should get help IDs when help is written

DWORD aPerformanceHelpIds[] =
{
    IDC_STATIC,                  NO_HELP,
    IDC_PERF_VM_ALLOCD,          (IDH_PERF + 1),
    IDC_PERF_VM_ALLOCD_LABEL,    (IDH_PERF + 1),
    IDC_PERF_GROUP,              NO_HELP,
    IDC_PERF_TEXT,               (IDH_PERF + 3),
    IDC_PERF_TEXT2,              NO_HELP,
    IDC_PERF_WORKSTATION,        (IDH_PERF + 4),
    IDC_PERF_SERVER,             (IDH_PERF + 5),
    IDC_PERF_VM_GROUP,           NO_HELP,
    IDC_PERF_VM_ALLOCD_TEXT,     NO_HELP,
    IDC_PERF_CHANGE,             (IDH_PERF + 7),
    IDC_PERF_CACHE_GROUP,        NO_HELP,
    IDC_PERF_CACHE_TEXT,         NO_HELP,
    IDC_PERF_CACHE_TEXT2,        NO_HELP,
    IDC_PERF_CACHE_APPLICATION,  (IDH_PERF + 14),
    IDC_PERF_CACHE_SYSTEM,       (IDH_PERF + 15),
    0, 0
};


INT_PTR
APIENTRY 
PerformanceDlgProc(
    IN HWND hDlg, 
    IN UINT uMsg, 
    IN WPARAM wParam, 
    IN LPARAM lParam
)
/*++

Routine Description:

    Handles messages sent to Performance dialog

Arguments:

    hDlg -
        Supplies window handle

    uMsg -
        Supplies message being sent

    wParam -
        Supplies message parameter

    lParam -
        Supplies message parameter

Return Value:

    TRUE if message was handled
    FALSE if message was unhandled

--*/
    {
    static int    iNewChoice = 0;
    LONG   RegRes;
    DWORD  Type, Value, Length;
    DWORD  CacheType, CacheValue, CacheLength;
    static int InitPos;
    static int InitRegVal, InitCacheRegVal;
    static int NewRegVal, NewCacheRegVal;
    static BOOL fVMInited = FALSE;
    static BOOL fTempPfWarningShown = FALSE;
    BOOL fTempPf;
    BOOL fWorkstationProduct = IsWorkstationProduct();
    BOOL fAdministrator = IsUserAdmin();
    BOOL fVariableQuanta = FALSE;
    BOOL fShortQuanta = FALSE;
    BOOL fFailedToOpenMmKey = FALSE;

    switch (uMsg)
    {
    case WM_INITDIALOG:

        InitPos = 0;
        InitRegVal = 0;
        InitCacheRegVal = 0;

        //
        // initialize from the registry
        //

        RegRes = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                               m_szRegPriKey,
                               0,
                               fAdministrator ? KEY_QUERY_VALUE | KEY_SET_VALUE : KEY_QUERY_VALUE,
                               &m_hKeyPerf );

        if (RegRes == ERROR_SUCCESS)
        {
            Length = sizeof( Value );
            RegRes = RegQueryValueEx( m_hKeyPerf,
                                      m_szRegPriority,
                                      NULL,
                                      &Type,
                                      (LPBYTE) &Value,
                                      &Length );

            if (RegRes == ERROR_SUCCESS)
            {
                InitRegVal = Value;
                InitPos = InitRegVal & PROCESS_PRIORITY_SEPARATION_MASK;
                if (InitPos > PROCESS_PRIORITY_SEPARATION_MAX)
                {
                    InitPos = PROCESS_PRIORITY_SEPARATION_MAX;
                }

            }
        }

        if ((RegRes != ERROR_SUCCESS) || (!fAdministrator))
        {
            EnableWindow(GetDlgItem(hDlg, IDC_PERF_WORKSTATION), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_PERF_SERVER), FALSE);
        }

        NewRegVal = InitRegVal;

        //
        // determine if we are using fixed or variable quantums
        //
        switch (InitRegVal & PROCESS_QUANTUM_VARIABLE_MASK)
        {
        case PROCESS_QUANTUM_VARIABLE_VALUE:
            fVariableQuanta = TRUE;
            break;

        case PROCESS_QUANTUM_FIXED_VALUE:
            fVariableQuanta = FALSE;
            break;

        case PROCESS_QUANTUM_VARIABLE_DEF:
        default:
            if (fWorkstationProduct)
            {
                fVariableQuanta = TRUE;
            }
            else
            {
                fVariableQuanta = FALSE;
            }
            break;
        }

        //
        // determine if we are using long or short
        //
        switch (InitRegVal & PROCESS_QUANTUM_LONG_MASK)
        {
        case PROCESS_QUANTUM_LONG_VALUE:
            fShortQuanta = FALSE;
            break;

        case PROCESS_QUANTUM_SHORT_VALUE:
            fShortQuanta = TRUE;
            break;

        case PROCESS_QUANTUM_LONG_DEF:
        default:
            if (fWorkstationProduct)
            {
                fShortQuanta = TRUE;
            }
            else
            {
                fShortQuanta = FALSE;
            }
            break;
        }

        //
        // Short, Variable Quanta == Workstation-like interactive response
        // Long, Fixed Quanta == Server-like interactive response
        //
        if (fVariableQuanta && fShortQuanta)
        {
            iNewChoice = PROCESS_PRIORITY_SEPARATION_MAX;

            CheckRadioButton(
                            hDlg,
                            IDC_PERF_WORKSTATION,
                            IDC_PERF_SERVER,
                            IDC_PERF_WORKSTATION
                            );
        } // if
        else
        {
            iNewChoice = PROCESS_PRIORITY_SEPARATION_MIN;

            CheckRadioButton(
                            hDlg,
                            IDC_PERF_WORKSTATION,
                            IDC_PERF_SERVER,
                            IDC_PERF_SERVER
                            );
        } // else


        //
        // Initialize the `memory usage' part.
        //

        fFailedToOpenMmKey = FALSE;

        RegRes = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                               m_szRegMemoryManagementKey,
                               0,
                               fAdministrator ? KEY_QUERY_VALUE | KEY_SET_VALUE : KEY_QUERY_VALUE,
                               &m_hKeyMemoryManagement );

        if (RegRes == ERROR_SUCCESS)
        {
            CacheValue = 0;
            CacheLength = sizeof( CacheValue );

            RegRes = RegQueryValueEx( m_hKeyMemoryManagement,
                                      m_szRegLargeSystemCache,
                                      NULL,
                                      &CacheType,
                                      (LPBYTE) &CacheValue,
                                      &CacheLength );

            if (RegRes == ERROR_SUCCESS && CacheValue != 0)
            {
                CheckRadioButton(hDlg,
                                 IDC_PERF_CACHE_APPLICATION,
                                 IDC_PERF_CACHE_SYSTEM,
                                 IDC_PERF_CACHE_SYSTEM);
            }
            else
            {
                CheckRadioButton(hDlg,
                                 IDC_PERF_CACHE_APPLICATION,
                                 IDC_PERF_CACHE_SYSTEM,
                                 IDC_PERF_CACHE_APPLICATION);
            }
        }
        else
        {
            fFailedToOpenMmKey = TRUE;
        }

        if (fFailedToOpenMmKey || (!fAdministrator))
        {
            CheckRadioButton(hDlg,
                             IDC_PERF_CACHE_APPLICATION,
                             IDC_PERF_CACHE_SYSTEM,
                             IDC_PERF_CACHE_APPLICATION);

            EnableWindow(GetDlgItem(hDlg, IDC_PERF_CACHE_APPLICATION), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_PERF_CACHE_SYSTEM), FALSE);
        }


        InitCacheRegVal = CacheValue;
        NewCacheRegVal = CacheValue;

        //
        // Init the virtual memory part
        //
        if (VirtualInitStructures())
        {
            fVMInited = TRUE;
            SetDlgItemMB( hDlg, IDC_PERF_VM_ALLOCD, VirtualMemComputeAllocated(hDlg, &fTempPf) );
            //
            // If the system created a temp pagefile, warn the user that
            // the total pagefile size may appear a bit large, but only
            // do so once per System Applet invokation.
            //
            if (fTempPf && !fTempPfWarningShown)
            {
                MsgBoxParam(
                           hDlg,
                           IDS_TEMP_PAGEFILE_WARN,
                           IDS_SYSDM_TITLE,
                           MB_ICONINFORMATION | MB_OK
                           );
                fTempPfWarningShown = TRUE;
            } // if (fTempPf...
        }
        break;

    case WM_DESTROY:
        //
        // If the dialog box is going away, then close the
        // registry key.
        //


        if (m_hKeyPerf)
        {
            RegCloseKey( m_hKeyPerf );
            m_hKeyPerf = NULL;
        }

        if (m_hKeyMemoryManagement)
        {
            RegCloseKey( m_hKeyMemoryManagement );
            m_hKeyMemoryManagement = NULL;
        }

        if (fVMInited)
        {
            VirtualFreeStructures();
        }
        break;


    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code)
        {
        case PSN_APPLY:
            // 
            // Save new time quantum stuff, if it has changed
            //
            NewRegVal &= ~PROCESS_PRIORITY_SEPARATION_MASK;
            NewRegVal |= iNewChoice;

            if (NewRegVal != InitRegVal)
            {
                Value = NewRegVal;

                if (m_hKeyPerf)
                {
                    Type = REG_DWORD;
                    Length = sizeof( Value );
                    RegSetValueEx( m_hKeyPerf,
                                   m_szRegPriority,
                                   0,
                                   REG_DWORD,
                                   (LPBYTE) &Value,
                                   Length );
                    InitRegVal = Value;

                    //
                    // Kernel monitors this part of the 
                    // registry, so don't tell user he has to reboot
                    //
                }
            }

            //
            // Save `LargeSystemCache' if value changed
            //

            if (InitCacheRegVal != NewCacheRegVal) {

                CacheValue = NewCacheRegVal;

                if (m_hKeyMemoryManagement) {
                    CacheType = REG_DWORD;
                    CacheLength = sizeof( CacheValue );
                    RegSetValueEx( m_hKeyMemoryManagement,
                                   m_szRegLargeSystemCache,
                                   0,
                                   REG_DWORD,
                                   (LPBYTE) &CacheValue,
                                   CacheLength );

                    InitCacheRegVal = CacheValue;

                    //
                    // Request a reboot if things changed
                    //

                    MsgBoxParam(
                               hDlg,
                               IDS_SYSDM_RESTART,
                               IDS_SYSDM_TITLE,
                               MB_OK | MB_ICONINFORMATION
                               );

                    g_fRebootRequired = TRUE;
                }
            }
            break;
        }
        break;

    case WM_COMMAND:
        {
            BOOL fEnableApply = (LOWORD(wParam) != IDC_PERF_CHANGE);

            LRESULT lres;

            switch (LOWORD(wParam))
            {
            case IDC_PERF_CHANGE:
                {
                    lres = DialogBox(
                                    hInstance, 
                                    MAKEINTRESOURCE(DLG_VIRTUALMEM),
                                    hDlg, 
                                    VirtualMemDlg
                                    );

                    if (fVMInited)
                    {
                        SetDlgItemMB(
                                    hDlg, 
                                    IDC_PERF_VM_ALLOCD, 
                                    VirtualMemComputeAllocated(hDlg, NULL) 
                                    );
                    }
                    if (lres != RET_NO_CHANGE)
                    {
                        fEnableApply = TRUE;

                        if (lres != RET_CHANGE_NO_REBOOT)
                        {
                            MsgBoxParam(
                                       hDlg,
                                       IDS_SYSDM_RESTART,
                                       IDS_SYSDM_TITLE,
                                       MB_OK | MB_ICONINFORMATION
                                       );

                            g_fRebootRequired = TRUE;
                        }
                    }
                }
                break;

            case IDC_PERF_WORKSTATION:
                if (BN_CLICKED == HIWORD(wParam))
                {
                    //
                    // Workstations have maximum foreground boost
                    //
                    iNewChoice = PROCESS_PRIORITY_SEPARATION_MAX;

                    //
                    // Workstations have variable, short quanta
                    NewRegVal &= ~PROCESS_QUANTUM_VARIABLE_MASK;
                    NewRegVal |= PROCESS_QUANTUM_VARIABLE_VALUE;
                    NewRegVal &= ~PROCESS_QUANTUM_LONG_MASK;
                    NewRegVal |= PROCESS_QUANTUM_SHORT_VALUE;
                } // if    
                break;

            case IDC_PERF_SERVER:
                if (BN_CLICKED == HIWORD(wParam))
                {
                    //
                    // Servers have minimum foreground boost
                    //
                    iNewChoice = PROCESS_PRIORITY_SEPARATION_MIN;

                    //
                    // Servers have fixed, long quanta
                    //
                    NewRegVal &= ~PROCESS_QUANTUM_VARIABLE_MASK;
                    NewRegVal |= PROCESS_QUANTUM_FIXED_VALUE;
                    NewRegVal &= ~PROCESS_QUANTUM_LONG_MASK;
                    NewRegVal |= PROCESS_QUANTUM_LONG_VALUE;
                } // if
                break;

            case IDC_PERF_CACHE_APPLICATION:
                if (BN_CLICKED == HIWORD(wParam))
                {
                    NewCacheRegVal = 0;
                } // if    
                break;

            case IDC_PERF_CACHE_SYSTEM:
                if (BN_CLICKED == HIWORD(wParam))
                {
                    NewCacheRegVal = 1;
                } // if
                break;
            }

            if (fEnableApply)
            {
                // Enable the "Apply" button because changes have happened.
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
            }
        }
        break;

    case WM_HELP:      // F1
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
                (DWORD_PTR) (LPSTR) aPerformanceHelpIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
                (DWORD_PTR) (LPSTR) aPerformanceHelpIds);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\pfrscpl.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    pfrscpl.cpp

Abstract:
    Implements fault reporting for unhandled exceptions

Revision History:
    created     derekm      08/07/00

******************************************************************************/

#include "sysdm.h"
#include <commctrl.h>
#include <commdlg.h>
#include "pfrscpl.h"
#include "pfrcfg.h"
#include "help.h"
#include "resource.h"
#include "tchar.h"
#include "malloc.h"
#include "windowsx.h"

///////////////////////////////////////////////////////////////////////////////
// data structures

#define KERNELLI        1
#define PROGLI          2
#define EXWINCOMP       0x80000000
#define EXALLMS         0x40000000
#define EXNOREM         0xc0000000 // EXWINCOMP | EXALLMS
#define WM_SETEIELVSEL  WM_APP

#define sizeofSTRT(sz)  sizeof(sz)  / sizeof(TCHAR)
#define sizeofSTRW(wsz) sizeof(wsz) / sizeof(WCHAR)

const DWORD c_dxLVChkPixels = 30;

struct SAddDlg
{
    WCHAR   wszApp[MAX_PATH];
};

struct SMainDlg
{
    CPFFaultClientCfg   *pcfg;
    EEnDis              eedReport;
    EEnDis              eedShowUI;
    EIncEx              eieKernel;
    EIncEx              eieApps;
    EIncEx              eieShut;
    DWORD               iLastSel;
    BOOL                fRW;
    BOOL                fForceQueue;
};

struct SProgDlg
{
    CPFFaultClientCfg   *pcfg;
    EIncEx              eieApps;
    EIncEx              eieMS;
    EIncEx              eieWinComp;
    DWORD               iLastSelE;
    DWORD               iLastSelI;
    DWORD               cchMax;
    DWORD               cxMaxE;
    DWORD               cxMaxI;
    BOOL                fRW;
    BOOL                fShowIncRem;
};

///////////////////////////////////////////////////////////////////////////////
// Global stuff

// help IDs
static DWORD g_rgPFER[] = 
{
    IDC_STATIC,         NO_HELP,
    IDC_PFR_EXADD,      (IDH_PFR),
    IDC_PFR_EXREM,      (IDH_PFR + 1),
    IDC_PFR_INCADD,     (IDH_PFR + 2),
    IDC_PFR_INCREM,     (IDH_PFR + 3),
    IDC_PFR_DISABLE,    (IDH_PFR + 4),
    IDC_PFR_ENABLE,     (IDH_PFR + 5),
    IDC_PFR_ENABLEOS,   (IDH_PFR + 6),
    IDC_PFR_ENABLEPROG, (IDH_PFR + 6),
    IDC_PFR_DETAILS,    (IDH_PFR + 7),
    IDC_PFR_INCLIST,    (IDH_PFR + 10),
    IDC_PFR_NEWPROG,    (IDH_PFR + 11),
    IDC_PFR_BROWSE,     (IDH_PFR + 13),
    IDC_PFR_EXLIST,     (IDH_PFR + 14),
    IDC_PFR_SHOWUI,     (IDH_PFR + 15),
    IDC_PFR_DEFALL,     (IDH_PFR + 16),
    IDC_PFR_DEFNONE,    (IDH_PFR + 16),
    IDC_PFR_ENABLESHUT, (IDH_PFR + 6),
    0, 0
};

// resource strings
TCHAR   g_szWinComp[256]    = { _T('\0') };
TCHAR   g_szOk[256]         = { _T('\0') };
WCHAR   g_wszTitle[256]     = { L'\0' };
WCHAR   g_wszFilter[256]    = { L'\0' };
WCHAR   g_wszMSProg[256]    = { L'\0' };



///////////////////////////////////////////////////////////////////////////////
// utility functions

// **************************************************************************
BOOL LoadPFRResourceStrings(void)
{
    LoadString(hInstance, IDS_PFR_WINCOMP, g_szWinComp, sizeofSTRT(g_szWinComp));
    LoadString(hInstance, IDS_PFR_OK, g_szOk, sizeofSTRT(g_szOk));
    LoadStringW(hInstance, IDS_PFR_FILTER, g_wszFilter, sizeofSTRW(g_wszFilter)); 
    LoadStringW(hInstance, IDS_PFR_MSPROG, g_wszMSProg, sizeofSTRW(g_wszMSProg));
    LoadStringW(hInstance, IDS_PFR_TITLE, g_wszTitle, sizeofSTRW(g_wszTitle));
    return TRUE;
}

// **************************************************************************
static BOOL InitializePFLV(EPFListType epflt, HWND hlc, DWORD *pcchMax,
                           DWORD *pcxMax, CPFFaultClientCfg *pcfg)
{
    LVCOLUMN    lvc;
    LVITEMW     lvi;
    HRESULT     hr;
    LPWSTR      wszApp;
    DWORD       dwExStyle, i, cchApps, cApps, dwChecked, cxMax;
    RECT        rect;
    int         iList;

    if (pcchMax == NULL || pcfg == NULL || hlc == NULL || pcxMax == NULL)
        return FALSE;

    // set up the list control
    SendMessage(hlc, LVM_SETUNICODEFORMAT, TRUE, 0);
    dwExStyle = (LVS_EX_CHECKBOXES | LVS_EX_FULLROWSELECT);
    SendMessage(hlc, LVM_SETEXTENDEDLISTVIEWSTYLE, dwExStyle, dwExStyle);

    GetClientRect(hlc, &rect);
    *pcxMax = rect.right - GetSystemMetrics(SM_CYHSCROLL);


    ZeroMemory(&lvc, sizeof(lvc));
    lvc.mask = LVCF_FMT;
    lvc.fmt  = LVCFMT_LEFT;
    ListView_InsertColumn(hlc, 0, &lvc); 

    hr = pcfg->InitList(epflt);
    if (FAILED(hr))
        return FALSE;

    hr = pcfg->get_ListRegInfo(epflt, &cchApps, &cApps);
    if (FAILED(hr))
        return FALSE;

    cchApps++;
    if (cchApps > *pcchMax)
        *pcchMax = cchApps;

    __try
    {
        wszApp = (LPWSTR)_alloca(cchApps * sizeof(WCHAR));
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        wszApp = NULL;
    }
    if (wszApp == NULL)
        return FALSE;

    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask       = LVIF_PARAM | LVIF_TEXT | LVIF_STATE;
    lvi.stateMask  = LVIS_STATEIMAGEMASK;
    lvi.state      = 0;
    lvi.pszText    = wszApp;

    for (i = 0; i < cApps; i++)
    {
        hr = pcfg->get_ListRegApp(epflt, i, wszApp, cchApps + 1, &dwChecked);
        if (FAILED(hr))
            return FALSE;

        cxMax = (DWORD)SendMessageW(hlc, LVM_GETSTRINGWIDTHW, 0, (LPARAM)wszApp);
        cxMax += c_dxLVChkPixels;
        if (cxMax > *pcxMax)
            *pcxMax = cxMax;

        lvi.iItem  = i;
        lvi.lParam = 1 + ((dwChecked == 1) ? 1 : 0);
        iList = (int)SendMessageW(hlc, LVM_INSERTITEMW, 0, (LPARAM)&lvi);
        if (iList >= 0)
            ListView_SetCheckState(hlc, iList, (dwChecked == 1));
    }

    ListView_SetColumnWidth(hlc, 0, *pcxMax);

    if (cApps > 0)
    {
        ListView_SetItemState(hlc, 0, LVIS_FOCUSED | LVIS_SELECTED,
                              LVIS_FOCUSED | LVIS_SELECTED);
    }

    return TRUE;
}



///////////////////////////////////////////////////////////////////////////////
// Add Program dialog proc

// **************************************************************************
static UINT_PTR CALLBACK OFNHookProc(HWND hdlg, UINT uMsg, WPARAM wParam, 
                                     LPARAM lParam)
{
    HWND hwndFile;

    switch(uMsg)
    {
        case WM_INITDIALOG:
            hwndFile = GetParent(hdlg);
            if (hwndFile != NULL)
                SendMessage(hwndFile, CDM_SETCONTROLTEXT, IDOK, (LPARAM)g_szOk);

            return TRUE;

        default:
            return FALSE;
    }

    return FALSE;
}

// **************************************************************************
static BOOL LaunchOFNDialog(HWND hdlg, LPWSTR wszFile, DWORD cchFile)
{
    OPENFILENAMEW   ofn;
    WCHAR           wszFilePath[2 * MAX_PATH];
    WCHAR           wszInitalDir[] = L"\\";
    WCHAR           wszFilter[MAX_PATH], *pwsz;
    DWORD           dw;

    if (wszFile == NULL || cchFile == 0)
        return FALSE;

    // the filter string needs to be of the form <Description>\0<Extension>\0\0
    ZeroMemory(wszFilter, sizeof(wszFilter));
    wcscpy(wszFilter, g_wszFilter);
    dw = wcslen(g_wszFilter);
    if (dw < sizeofSTRW(wszFilter) - 10)
    {
        pwsz = wszFilter + dw + 1;
    }
    else
    {
        pwsz = wszFilter + sizeofSTRW(wszFilter) - 10;
        ZeroMemory(pwsz, 10);
        pwsz++;
    }
    wcscpy(pwsz, _T("*.exe"));

    wszFilePath[0] = L'\0';
    ZeroMemory(&ofn, sizeof(ofn));
    
    ofn.lStructSize     = sizeof(ofn);
    ofn.hwndOwner       = hdlg;
    ofn.lpstrFilter     = wszFilter;
    ofn.lpstrFile       = wszFilePath;
    ofn.nMaxFile        = sizeofSTRW(wszFilePath);
    ofn.lpstrFileTitle  = wszFile;
    ofn.nMaxFileTitle   = cchFile;
    ofn.lpstrInitialDir = wszInitalDir;
    ofn.lpstrTitle      = g_wszTitle;
    ofn.Flags           = OFN_DONTADDTORECENT | OFN_ENABLESIZING | 
                          OFN_EXPLORER | OFN_FILEMUSTEXIST | 
                          OFN_HIDEREADONLY | OFN_NOCHANGEDIR | 
                          OFN_PATHMUSTEXIST | OFN_SHAREAWARE;
    ofn.lpstrDefExt     = NULL;
    ofn.lpfnHook        = OFNHookProc;

    // get the filename & fill in the edit box with it
    return GetOpenFileNameW(&ofn);
}

// **************************************************************************
static INT_PTR APIENTRY PFRAddDlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, 
                                      LPARAM lParam)
{
    BOOL fShowErr = FALSE;
    
    switch (uMsg)
    {
        case WM_INITDIALOG:
            {
                HWND    hbtn;

                SetWindowLongPtr(hdlg, DWLP_USER, lParam);

                // disable the ok button cuz we know that we don't have anything
                //  in the 'filename' edit box
                hbtn = GetDlgItem(hdlg, IDOK);
                if (hbtn != NULL)
                    EnableWindow(hbtn, FALSE);
            }

            break;

        // F1 help
        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, 
                    HELP_FILE, HELP_WM_HELP, (DWORD_PTR)g_rgPFER);
            break;

        // right-click help
        case WM_CONTEXTMENU:
            WinHelp((HWND)wParam, HELP_FILE, HELP_CONTEXTMENU,
                    (DWORD_PTR)g_rgPFER);
            break;
    
        case WM_COMMAND:
            switch (LOWORD(wParam)) 
            {
                // browse button
                case IDC_PFR_BROWSE:
                {
                    WCHAR   wszFile[2 * MAX_PATH];

                    // get the filename & fill in the edit box with it
                    if (LaunchOFNDialog(hdlg, wszFile, sizeofSTRW(wszFile)))
                        SetDlgItemTextW(hdlg, IDC_PFR_NEWPROG, wszFile);

                    break;
                }

                // Ok button
                case IDOK:
                {
                    SAddDlg *psad;

                    psad = (SAddDlg *)GetWindowLongPtr(hdlg, DWLP_USER);
                    if (psad != NULL)
                    {
                        WCHAR *wszText, *pwsz;
                        DWORD cch;
                        HWND  hwndText;
                        BOOL  fReplaceWSpace = TRUE;

                        hwndText = GetDlgItem(hdlg, IDC_PFR_NEWPROG);
                        if (hwndText == NULL)
                        {
                            fShowErr = TRUE;
                            goto done;
                        }

                        cch = GetWindowTextLength(hwndText);
                        if (cch == 0)
                        {
                            fShowErr = TRUE;
                            goto done;
                        }

                        cch++;
                        __try { wszText = (WCHAR *)_alloca(cch * sizeof(WCHAR)); }
                        __except(EXCEPTION_EXECUTE_HANDLER) { wszText = NULL; }
                        if (wszText == NULL)
                        {
                            fShowErr = TRUE;
                            goto done;
                        }

                        *psad->wszApp = L'\0';
                        *wszText      = L'\0';
                        GetDlgItemTextW(hdlg, IDC_PFR_NEWPROG, wszText, cch);
                        
                        // make sure that we only have the exe name-  probably
                        //  should verify that it IS an exe, but it's possible
                        //  we'd want to trap on other file types as well, so
                        //  don't for now.
                        // And while we're at it, rip off any trailing 
                        //  whitespace (preceeding whitespace is apparently ok)
                        cch = wcslen(wszText);
                        if (cch > 0)
                        {
                            for(pwsz = wszText + cch - 1; pwsz > wszText; pwsz--)
                            {
                                if (fReplaceWSpace)
                                {
                                    if (iswspace(*pwsz))
                                        *pwsz = L'\0';
                                    else
                                        fReplaceWSpace = FALSE;
                                }

                                if (*pwsz == L'\\')
                                {
                                    pwsz++;
                                    break;
                                }
                            }

                            if (*pwsz == L'\\')
                                pwsz++;
                        }

                        cch = wcslen(pwsz);
                        if (cch >= MAX_PATH || cch == 0)
                        {
                            fShowErr = TRUE;
                            goto done;
                        }

                        wcsncpy(psad->wszApp, pwsz, MAX_PATH);
                        psad->wszApp[MAX_PATH - 1] = L'\0';
                    }

                    EndDialog(hdlg, IDOK);
                    break;
                }
            
                // cancel button
                case IDCANCEL:
                    EndDialog(hdlg, IDCANCEL);
                    break;

                case IDC_PFR_NEWPROG:
                    if (HIWORD(wParam) == EN_CHANGE)
                    {
                        HWND    hbtn, hedt;
                        
                        hbtn = GetDlgItem(hdlg, IDOK);
                        hedt = (HWND)(DWORD_PTR)lParam;
                        if (hedt != NULL && hbtn != NULL)
                        {
                            if (GetWindowTextLength(hedt) != 0)
                                EnableWindow(hbtn, TRUE);
                            else
                                EnableWindow(hbtn, FALSE);
                        }
                    }
                    break;
                              
                // return FALSE to indicate that we didn't handle the msg
                default:
                    return FALSE;
            }
            break;

        // return FALSE to indicate that we didn't handle the msg
        default:
            return FALSE;
    }


done:
    if (fShowErr)
    {
        TCHAR szMsg[256];

        LoadString(hInstance, IDS_PFR_BADFILE, szMsg, sizeofSTRT(szMsg));
        MessageBox(hdlg, szMsg, NULL, MB_OK | MB_ICONERROR);
    }

    
    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// Programs dialog proc

// **************************************************************************
static BOOL InitProgDlg(HWND hdlg, SProgDlg *pspd)
{
    CPFFaultClientCfg   *pcfg;
    LVITEMW             lvi;
    DWORD               cxMax;
    HWND                hlc, hbtn;
    BOOL                fRet = FALSE;
    int                 iList, cItems;

    if (pspd == NULL)
        goto done;

    pcfg = pspd->pcfg;

    // fill in the exclude list
    hlc = GetDlgItem(hdlg, IDC_PFR_EXLIST);
    if (hlc == NULL)
        goto done;

    if (InitializePFLV(epfltExclude, hlc, &pspd->cchMax, &pspd->cxMaxE,
                       pcfg) == FALSE)
        goto done;

    // fill in the include list
    hlc = GetDlgItem(hdlg, IDC_PFR_INCLIST);
    if (hlc == NULL)
        goto done;

    if (InitializePFLV(epfltInclude, hlc, &pspd->cchMax, &pspd->cxMaxI, 
                       pcfg) == FALSE)
        goto done;


    // add the item to the include list that lets users include all MS apps
    pspd->eieMS = pcfg->get_IncMSApps();

    // Note that we set lParam to 1 or 2.  This is because we need to ignore 
    //  the first notification message for the list item + the 2nd one if the
    //  check state is set.  Processing these two messages leads to corruption
    //  in the configuration settings    
    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask      = LVIF_PARAM | LVIF_TEXT | LVIF_STATE;
    lvi.stateMask = LVIS_STATEIMAGEMASK;
    lvi.state     = 0;
    lvi.pszText   = g_wszMSProg;
    lvi.iItem     = 0;
    lvi.lParam    = (1 + ((pspd->eieMS == eieInclude) ? 1 : 0)) | EXALLMS;
    iList = (int)SendMessageW(hlc, LVM_INSERTITEMW, 0, (LPARAM)&lvi);
    if (iList >= 0)
        ListView_SetCheckState(hlc, iList, (pspd->eieMS == eieInclude));

    cxMax = (DWORD)SendMessageW(hlc, LVM_GETSTRINGWIDTHW, 0, (LPARAM)g_wszMSProg);
    cxMax += c_dxLVChkPixels;
    if (cxMax > pspd->cxMaxI)
    {
        pspd->cxMaxI = cxMax;
        ListView_SetColumnWidth(hlc, 0, cxMax);
    }

    // add the item to the include list that lets users exclude all windows
    //  components
    pspd->eieWinComp = pcfg->get_IncWinComp();

    // Note that we set lParam to 1 or 2.  This is because we need to ignore 
    //  the first notification message for the list item + the 2nd one if the
    //  check state is set.  Processing these two messages leads to corruption
    //  in the configuration settings    
    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask      = LVIF_PARAM | LVIF_TEXT | LVIF_STATE;
    lvi.stateMask = LVIS_STATEIMAGEMASK;
    lvi.state     = 0;
    lvi.pszText   = g_szWinComp;
    lvi.iItem     = 1;
    lvi.lParam    = (1 + ((pspd->eieWinComp == eieInclude) ? 1 : 0)) | EXWINCOMP;
    iList = (int)SendMessageW(hlc, LVM_INSERTITEMW, 0, (LPARAM)&lvi);
    if (iList >= 0)
        ListView_SetCheckState(hlc, iList, (pspd->eieWinComp == eieInclude));

    cxMax = (DWORD)SendMessageW(hlc, LVM_GETSTRINGWIDTHW, 0, (LPARAM)g_szWinComp);
    cxMax += c_dxLVChkPixels;
    if (cxMax > pspd->cxMaxI)
    {
        pspd->cxMaxI = cxMax;
        ListView_SetColumnWidth(hlc, 0, cxMax);
    }

    // do misc setup on the exclusion list (disabling the remove button, 
    //  setting the initial focus)
    hlc = GetDlgItem(hdlg, IDC_PFR_EXLIST);
    cItems = ListView_GetItemCount(hlc);
    if (cItems == 0)
    {
        hbtn = GetDlgItem(hdlg, IDC_PFR_EXREM);
        if (hbtn != NULL)
            EnableWindow(hbtn, FALSE);
    }
    else
    {
        ListView_SetItemState(hlc, 0, LVIS_FOCUSED | LVIS_SELECTED,
                              LVIS_FOCUSED | LVIS_SELECTED);
    }

    // do misc setup on the inclusion list (disabling the remove button, 
    //  setting the initial focus)
    hlc = GetDlgItem(hdlg, IDC_PFR_INCLIST);
    ListView_SetItemState(hlc, 0, LVIS_FOCUSED | LVIS_SELECTED,
                          LVIS_FOCUSED | LVIS_SELECTED);
    
    cItems = ListView_GetItemCount(hlc);
    if (cItems < 3)
    {
        hbtn = GetDlgItem(hdlg, IDC_PFR_INCREM);
        if (hbtn != NULL)
            EnableWindow(hbtn, FALSE);

        pspd->fShowIncRem = FALSE;
    }
    
    // set up the radio buttons- if we are in 'include all' mode, then
    //  we don't need the inclusion list.
    if (((DWORD)pspd->eieApps & eieIncMask) == eieInclude)
    {
        CheckDlgButton(hdlg, IDC_PFR_DEFALL, BST_CHECKED);
        CheckDlgButton(hdlg, IDC_PFR_DEFNONE, BST_UNCHECKED);

        hlc = GetDlgItem(hdlg, IDC_PFR_INCLIST);
        if (hlc != NULL)
            EnableWindow(hlc, FALSE);
        hbtn = GetDlgItem(hdlg, IDC_PFR_INCREM);
        if (hbtn != NULL)
            EnableWindow(hbtn, FALSE);
        hbtn = GetDlgItem(hdlg, IDC_PFR_INCADD);
        if (hbtn != NULL)
            EnableWindow(hbtn, FALSE);
    }
    else
    {
        CheckDlgButton(hdlg, IDC_PFR_DEFALL, BST_UNCHECKED);
        CheckDlgButton(hdlg, IDC_PFR_DEFNONE, BST_CHECKED);
        EnableWindow(hlc, TRUE);
    }

    fRet = TRUE;

done:
    if (fRet == FALSE)
    {
        TCHAR   szMsg[MAX_PATH];
        LoadString(hInstance, IDS_PFR_CFGREADERR, szMsg, sizeofSTRT(szMsg));
        MessageBox(hdlg, szMsg, NULL, MB_OK | MB_ICONERROR);
    }

    return fRet;
}

// **************************************************************************
static BOOL AddProgramToList(HWND hdlg, HWND hlc, SProgDlg *pspd,
                             EPFListType epflt)
{
    CPFFaultClientCfg   *pcfg = NULL;
    HRESULT             hr;
    SAddDlg             sad;
    LVITEMW             lvi;
    DWORD               cch, cxMax, *pcxMax;
    TCHAR               szMsg[256];
    HWND                hbtn;
    int                 nID, cItems;

    if (pspd == NULL)
        return FALSE;

    pcfg = pspd->pcfg;

    ZeroMemory(&sad, sizeof(sad));
    nID = (int)DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_PFR_ADDPROG), 
                              hdlg, PFRAddDlgProc, (LPARAM)&sad);
    if (nID == IDCANCEL || sad.wszApp[0] == L'\0')
        return FALSE;

    if (pcfg->IsOnList(epfltInclude, sad.wszApp))
    {
        LoadString(hInstance, IDS_PFR_ISONLISTI, szMsg, sizeofSTRT(szMsg));
        if (epflt == epfltExclude)
        {
            TCHAR   szTmp[256];
            LoadString(hInstance, IDS_PFR_ADDTOEX, szTmp, sizeofSTRT(szTmp));
            _tcscat(szMsg, szTmp);
        }

        MessageBox(hdlg, szMsg, NULL, MB_OK | MB_ICONERROR);
        return FALSE;
    }

    else if (pcfg->IsOnList(epfltExclude, sad.wszApp))
    {
        LoadString(hInstance, IDS_PFR_ISONLISTE, szMsg, sizeofSTRT(szMsg));
        if (epflt == epfltInclude)
        {
            TCHAR   szTmp[256];
            LoadString(hInstance, IDS_PFR_ADDTOINC, szTmp, sizeofSTRT(szTmp));
            _tcscat(szMsg, szTmp);
        }

        MessageBox(hdlg, szMsg, NULL, MB_OK | MB_ICONERROR);
        return FALSE;
    }

    cItems = ListView_GetItemCount(hlc);

    // update the max string size if necessary
    cch = wcslen(sad.wszApp);
    if (cch >= pspd->cchMax)
        pspd->cchMax = cch + 1;

    // yay!  add it to the config class
    hr = pcfg->add_ListApp(epflt, sad.wszApp);
    if (FAILED(hr))
        return FALSE;

    pcxMax = (epflt == epfltInclude) ? &pspd->cxMaxI : &pspd->cxMaxE;
    cxMax = (DWORD)SendMessageW(hlc, LVM_GETSTRINGWIDTHW, 0, (LPARAM)sad.wszApp);
    cxMax += c_dxLVChkPixels;
    if (cxMax > *pcxMax)
    {
        *pcxMax = cxMax;
        ListView_SetColumnWidth(hlc, 0, cxMax);
    }

    // add it to the UI
    //  Note that we set lParam to 2.  This is because we need to ignore the 
    //   first two notification messages per entry sent to the wndproc because
    //   they are 'list initialization' messages and processing them leads to
    //   corruption in the configuration settings
    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask      = LVIF_PARAM | LVIF_TEXT | LVIF_STATE;
    lvi.stateMask = LVIS_STATEIMAGEMASK;
    lvi.state     = 0;
    lvi.pszText   = sad.wszApp;
    lvi.iItem     = 0;
    lvi.lParam    = 2;
    nID = (int)SendMessageW(hlc, LVM_INSERTITEMW, 0, (LPARAM)&lvi);
    if (nID >= 0)
        ListView_SetCheckState(hlc, nID, TRUE);

    // if there are no items, then there is no currently selected item, so
    //  make sure this item gets selected.  In our handler for this message
    //  we will take care of setting the 'last selected item' field...
    if (cItems == 0)
    {
        ListView_SetItemState(hlc, nID, LVIS_FOCUSED | LVIS_SELECTED, 
                              LVIS_FOCUSED | LVIS_SELECTED);

        // Also, got to make sure we enable the 'Remove' button.  The only
        //  way we can get zero items in a list is in the exclude list cuz
        //  the include list always has the 'include MS apps' item.
        hbtn = GetDlgItem(hdlg, IDC_PFR_EXREM);
        if (hbtn != NULL)
            EnableWindow(hbtn, TRUE);
    }

    return TRUE;
}

// **************************************************************************
static BOOL DelProgramFromList(HWND hdlg, HWND hlc, SProgDlg *pspd, 
                               EPFListType epflt)
{
    LVITEMW lvi;
    HRESULT hr;
    LPWSTR  wszApp;
    DWORD   cItems, iSel;

    __try
    {
        wszApp = (LPWSTR)_alloca(pspd->cchMax * sizeof(WCHAR));
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        wszApp = NULL;
    }
    if (wszApp == NULL)
        return FALSE;

    iSel = ((epflt == epfltInclude) ? pspd->iLastSelI : pspd->iLastSelE);

    // fetch the string for the item
    ZeroMemory(&lvi, sizeof(lvi));
    lvi.iItem      = iSel;
    lvi.mask       = LVIF_TEXT;
    lvi.pszText    = wszApp;
    lvi.cchTextMax = pspd->cchMax;
    if (SendMessageW(hlc, LVM_GETITEMW, 0, (LPARAM)&lvi))
    {
        // delete it from the config class
        hr = pspd->pcfg->del_ListApp(epflt, lvi.pszText);
        if (FAILED(hr))
            return FALSE;
    }

    // delete it from the UI
    if (ListView_DeleteItem(hlc, iSel) == FALSE)
        return FALSE;

    // reset the selection to be either the same index or one higher (if the
    //  user deleted the last item)
    cItems = ListView_GetItemCount(hlc);
    if (cItems == 0)
    {
        HWND hbtn;

        // only time we can ever hit zero items is in the exclude list cuz the
        //  include list always has the 'include MS apps' option.
        hbtn = GetDlgItem(hdlg, IDC_PFR_EXADD);
        if (hbtn != NULL)
        {
            SetFocus(hbtn);
            SendMessage(hdlg, DM_SETDEFID, IDC_PFR_EXADD, 0);
        }
        hbtn = GetDlgItem(hdlg, IDC_PFR_EXREM);
        if (hbtn != NULL)
            EnableWindow(hbtn, FALSE);
        pspd->iLastSelI = 0;
        return TRUE;
    }


    // if cItems <= iSel, then we just deleted the last index, so decrement the
    //  select index down 1.
    else if (cItems <= iSel)
    {
        iSel--;
    }

    // this will convieniently take care of setting the appropriate iLastSel
    //  field
    ListView_SetItemState(hlc, iSel, LVIS_FOCUSED | LVIS_SELECTED, 
                          LVIS_FOCUSED | LVIS_SELECTED);

    return TRUE;

}

// **************************************************************************
static INT_PTR APIENTRY PFRProgDlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, 
                                       LPARAM lParam)
{
    CPFFaultClientCfg   *pcfg = NULL;
    SProgDlg            *pspd = (SProgDlg *)GetWindowLongPtr(hdlg, DWLP_USER);
    HRESULT             hr;
    HWND                hlc, hbtn;

    if (pspd != NULL)
        pcfg = pspd->pcfg;

    switch(uMsg)
    {
        case WM_INITDIALOG:
            SetWindowLongPtr(hdlg, DWLP_USER, lParam);
            if (InitProgDlg(hdlg, (SProgDlg *)lParam) == FALSE)
                EndDialog(hdlg, IDCANCEL);

            break;

        // F1 help
        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, 
                    HELP_FILE, HELP_WM_HELP, (DWORD_PTR)g_rgPFER);
            break;

        // right-click help
        case WM_CONTEXTMENU:
            WinHelp((HWND)wParam, HELP_FILE, HELP_CONTEXTMENU,
                    (DWORD_PTR)g_rgPFER);
            break;
    
        case WM_COMMAND:
        {
            switch (LOWORD(wParam)) 
            {
                case IDOK:
                    if (pspd->fRW)
                    {
                        hr = pcfg->CommitChanges(epfltExclude);
                        if (SUCCEEDED(hr))
                        {
                            hr = pcfg->CommitChanges(epfltInclude);
                            if (SUCCEEDED(hr))
                            {
                                pcfg->set_IncWinComp(pspd->eieWinComp);
                                pcfg->set_IncMSApps(pspd->eieMS);
                                pcfg->set_AllOrNone(pspd->eieApps);
                                hr = pcfg->Write();
                            }
                        }

                        if (FAILED(hr))
                        {
                            TCHAR   szMsg[MAX_PATH];
                            if (hr != HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
                            {
                                LoadString(hInstance, IDS_PFR_CFGWRITEERR, szMsg,
                                           sizeofSTRT(szMsg));
                            }
                            else
                            {
                                LoadString(hInstance, IDS_PFR_NOTADMIN, szMsg,
                                           sizeofSTRT(szMsg));
                            }
                            MessageBox(hdlg, szMsg, NULL, MB_OK | MB_ICONERROR);
                            pcfg->ClearChanges(epfltExclude);
                            pcfg->ClearChanges(epfltInclude);
                        }
                    }
                    else
                    {
                        TCHAR   szMsg[MAX_PATH];
                        LoadString(hInstance, IDS_PFR_NOTADMIN, szMsg,
                                   sizeofSTRT(szMsg));
                        MessageBox(hdlg, szMsg, NULL, MB_OK | MB_ICONERROR);
                    }

                    EndDialog(hdlg, IDOK);
                    break;

                case IDCANCEL:
                    EndDialog(hdlg, IDCANCEL);
                    break;

                case IDC_PFR_DEFNONE:
                    pspd->eieApps = (EIncEx)(((DWORD)pspd->eieApps & eieDisableMask) | 
                                             eieExclude);

                    // enable the include list.
                    hlc = GetDlgItem(hdlg, IDC_PFR_INCLIST);
                    if (hlc != NULL)
                        EnableWindow(hlc, TRUE);
                    hbtn = GetDlgItem(hdlg, IDC_PFR_INCADD);
                    if (hbtn != NULL)
                        EnableWindow(hbtn, TRUE);
                    hbtn = GetDlgItem(hdlg, IDC_PFR_INCREM);
                    if (hbtn != NULL)
                        EnableWindow(hbtn, pspd->fShowIncRem);

                    break;

                case IDC_PFR_DEFALL:
                    pspd->eieApps = (EIncEx)(((DWORD)pspd->eieApps & eieDisableMask) | 
                                             eieInclude);

                    // disable the include list.
                    hlc = GetDlgItem(hdlg, IDC_PFR_INCLIST);
                    if (hlc != NULL)
                        EnableWindow(hlc, FALSE);
                    hbtn = GetDlgItem(hdlg, IDC_PFR_INCADD);
                    if (hbtn != NULL)
                        EnableWindow(hbtn, FALSE);
                    hbtn = GetDlgItem(hdlg, IDC_PFR_INCREM);
                    if (hbtn != NULL)
                        EnableWindow(hbtn, FALSE);

                    break;

                case IDC_PFR_INCADD:
                    hlc = GetDlgItem(hdlg, IDC_PFR_INCLIST);
                    if (hlc != NULL)
                        return AddProgramToList(hdlg, hlc, pspd, epfltInclude);
                    break;

                case IDC_PFR_EXADD:
                    hlc = GetDlgItem(hdlg, IDC_PFR_EXLIST);
                    if (hlc != NULL)
                        return AddProgramToList(hdlg, hlc, pspd, epfltExclude);
                    break;

                case IDC_PFR_INCREM:
                    hlc = GetDlgItem(hdlg, IDC_PFR_INCLIST);
                    if (hlc != NULL)
                        return DelProgramFromList(hdlg, hlc, pspd, epfltInclude);
                    break;

                case IDC_PFR_EXREM:
                    hlc = GetDlgItem(hdlg, IDC_PFR_EXLIST);
                    if (hlc != NULL)
                        return DelProgramFromList(hdlg, hlc, pspd, epfltExclude);
                    break;

                default:
                    return FALSE;
            }
            
            break;
        }

        case WM_SETEIELVSEL:
        {
            hlc = GetDlgItem(hdlg, (int)wParam);
            if (ListView_GetItemCount(hlc) > 0)
            {
                int iSel;

                if (wParam == IDC_PFR_EXLIST)
                    iSel = pspd->iLastSelE;
                else
                    iSel = pspd->iLastSelI;

                ListView_SetItemState(hlc, iSel, 
                                      LVIS_FOCUSED | LVIS_SELECTED, 
                                      LVIS_FOCUSED | LVIS_SELECTED);
            }

            break;
        }

        case WM_NOTIFY:
        {
            EPFListType epflt;
            NMLISTVIEW  *pnmlv = (NMLISTVIEW *)lParam;
            LVITEMW     lvi;
            NMHDR       *pnmh  = (NMHDR *)lParam;
            DWORD       dw;
            BOOL        fCheck;

            if ((pnmh->code != LVN_ITEMCHANGED &&
                 pnmh->code != NM_SETFOCUS) ||
                (pnmh->idFrom != IDC_PFR_EXLIST && 
                 pnmh->idFrom != IDC_PFR_INCLIST))
                return FALSE;

            hlc = pnmh->hwndFrom;
            
            // if we get the focus set to the listview, then 
            //  make sure we show what the selected item is.
            if (pnmh->code == NM_SETFOCUS)
            {
                if (ListView_GetItemCount(hlc) > 0)
                    PostMessage(hdlg, WM_SETEIELVSEL, pnmh->idFrom, 0);

                return TRUE;
            }

            // if it doesn't fit this condition, don't give a rat's
            //  patootie about it
            if ((pnmlv->uChanged & LVIF_STATE) == 0 ||
                (pnmlv->uNewState ^ pnmlv->uOldState) == 0)
                return FALSE;

            // hack cuz we get 1 or 2 messages when inserting items into the 
            //  list & initially setting their check state.  Want to not 
            //  process those messages.  The exception is the 'include
            //  ms apps' item which we can process any number of times
            if ((pnmlv->lParam & ~EXNOREM) > 0)
            {
                ZeroMemory(&lvi, sizeof(lvi));
                lvi.iItem  = pnmlv->iItem;
                lvi.mask   = LVIF_PARAM;
                lvi.lParam = (pnmlv->lParam - 1) | (pnmlv->lParam & EXNOREM);
                SendMessageW(hlc, LVM_SETITEM, 0, (LPARAM)&lvi);
                return TRUE;
            }

            // did the selection change?
            if ((pnmlv->uNewState & LVIS_SELECTED) != 0)
            {
                if (pnmh->idFrom == IDC_PFR_INCLIST)
                {
                    pspd->iLastSelI = pnmlv->iItem;
                    
                    // we need to disable the exclude remove button if we hit
                    //  the 'exclude non ms apps' item
                    hbtn = GetDlgItem(hdlg, IDC_PFR_INCREM);
                    if (hbtn != NULL)
                    {
                        if ((pnmlv->lParam & EXNOREM) != 0)
                        {
                            // disable the remove button- but if the remove 
                            //  button had focus, we need to reset the focus
                            //  or nothing on the dialog will have focus.
                            if (GetFocus() == hbtn)
                            {
                                HWND hbtnAdd;
                                hbtnAdd = GetDlgItem(hdlg, IDC_PFR_INCADD);
                                if (hbtnAdd != NULL)
                                {
                                    SetFocus(hbtnAdd);
                                    SendMessage(hdlg, DM_SETDEFID, IDC_PFR_INCADD, 0);
                                }

                            }

                            pspd->fShowIncRem = FALSE;
                            EnableWindow(hbtn, FALSE);
                        }
                        else
                        {
                            pspd->fShowIncRem = TRUE;
                            EnableWindow(hbtn, TRUE);
                        }
                    }

                }
                else
                {
                    pspd->iLastSelE = pnmlv->iItem;
                }
            }

            // if we don't have a check-state change, can bail now.
            if (((pnmlv->uNewState ^ pnmlv->uOldState) & 0x3000) == 0)
                return TRUE;

            fCheck = ListView_GetCheckState(hlc, pnmlv->iItem);
            if (pnmh->idFrom == IDC_PFR_EXLIST)
                epflt = epfltExclude;
            else
                epflt = epfltInclude;

            // did we modify the 'exclude non ms apps' item? 
            if ((pnmlv->lParam & EXNOREM) != 0)
            {
                if ((pnmlv->lParam & EXALLMS) != 0)
                    pspd->eieMS = ((fCheck) ? eieInclude : eieExclude);
                else
                    pspd->eieWinComp = ((fCheck) ? eieInclude : eieExclude);
            }

            // nope, modified a regular item
            else
            {
                LPWSTR  wszApp;

                __try
                {
                    wszApp = (LPWSTR)_alloca(pspd->cchMax * sizeof(WCHAR));
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    wszApp = NULL;
                }
                if (wszApp == NULL)
                    return FALSE;
            
                // got to fetch it to make sure we have a unicode string
                ZeroMemory(&lvi, sizeof(lvi));
                lvi.iItem      = pnmlv->iItem;
                lvi.mask       = LVIF_TEXT;
                lvi.pszText    = wszApp;
                lvi.cchTextMax = pspd->cchMax;
                if (SendMessageW(hlc, LVM_GETITEMW, 0, (LPARAM)&lvi))
                {
                    hr = pcfg->mod_ListApp(epflt, lvi.pszText, fCheck);
                    if (FAILED(hr))
                        return FALSE;
                }

            }

            break;
        }

        default:
            return FALSE;
    }

    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
// Main PFR dialog proc

// **************************************************************************
static BOOL InitMainDlg(HWND hdlg)
{
    CPFFaultClientCfg   *pcfg = NULL;
    SMainDlg            *psmd = NULL;
    BOOL                fRet = FALSE;
    UINT                ui;
    HWND                hbtn, hchk;

    LoadPFRResourceStrings();

    hbtn = GetDlgItem(hdlg, IDC_PFR_DETAILS);
    if (hbtn == NULL)
        goto done;

    psmd = new SMainDlg;
    if (psmd == NULL)
        goto done;

    pcfg = new CPFFaultClientCfg;
    if (pcfg == NULL)
        goto done;

    // see if this user has write access to the appropriate registry
    //  locations
    psmd->fRW = pcfg->HasWriteAccess();
    if (FAILED(pcfg->Read((psmd->fRW) ? eroCPRW : eroCPRO)))
        goto done;

    psmd->eedReport   = pcfg->get_DoReport();
    psmd->eieKernel   = pcfg->get_IncKernel();
    psmd->eieApps     = pcfg->get_AllOrNone();
    psmd->eedShowUI   = pcfg->get_ShowUI();
    psmd->eieShut     = pcfg->get_IncShutdown();
    psmd->fForceQueue = pcfg->get_ForceQueueMode();
    psmd->iLastSel    = 0;

    // if ShowUI is completely disabled, then so should reporting- the control
    //  panel does not support entering corporate mode.
    if (psmd->eedShowUI == eedDisabled)
        psmd->eedReport = eedDisabled;

    psmd->pcfg = pcfg;
    SetWindowLongPtr(hdlg, DWLP_USER, (LONG_PTR)psmd);

    // set up the kernel checkbox
    ui = (psmd->eieKernel == eieInclude) ? BST_CHECKED : BST_UNCHECKED;
    CheckDlgButton(hdlg, IDC_PFR_ENABLEOS, ui);

    // set up the programs checkbox
    ui = ((psmd->eieApps & eieDisableMask) == 0) ? BST_CHECKED : BST_UNCHECKED;
    CheckDlgButton(hdlg, IDC_PFR_ENABLEPROG, ui);

    // set up the notification checkbox
    ui = (psmd->eedShowUI == eedEnabled) ? BST_CHECKED : BST_UNCHECKED;
    CheckDlgButton(hdlg, IDC_PFR_SHOWUI, ui);

    // set up the shutdown checkbox on server only
    if (pcfg->get_IsServer())
    {
        ui = (psmd->eieShut == eieInclude) ? BST_CHECKED : BST_UNCHECKED;
        CheckDlgButton(hdlg, IDC_PFR_ENABLESHUT, ui);

        ui = (psmd->fForceQueue) ? BST_CHECKED : BST_UNCHECKED;
        CheckDlgButton(hdlg, IDC_PFR_FORCEQ, ui);
    }

    // set up the radio buttons
    if (psmd->eedReport == eedDisabled)
    {
        CheckRadioButton(hdlg, IDC_PFR_DISABLE, IDC_PFR_ENABLE, IDC_PFR_DISABLE);

        hchk = GetDlgItem(hdlg, IDC_PFR_SHOWUI);
        if (hchk != NULL)
            EnableWindow(hchk, TRUE);

        hchk = GetDlgItem(hdlg, IDC_PFR_ENABLEOS);
        if (hchk != NULL)
            EnableWindow(hchk, FALSE);

        hchk = GetDlgItem(hdlg, IDC_PFR_ENABLEPROG);
        if (hchk != NULL)
            EnableWindow(hchk, FALSE);

        hbtn = GetDlgItem(hdlg, IDC_PFR_DETAILS);
        if (hbtn != NULL)
            EnableWindow(hbtn, FALSE);

        if (pcfg->get_IsServer())
        {
            hbtn = GetDlgItem(hdlg, IDC_PFR_ENABLESHUT);
            if (hbtn != NULL)
                EnableWindow(hbtn, FALSE);

            hbtn = GetDlgItem(hdlg, IDC_PFR_FORCEQ);
            if (hbtn != NULL)
                EnableWindow(hbtn, FALSE);
        }
    }
    else
    {
        CheckRadioButton(hdlg, IDC_PFR_DISABLE, IDC_PFR_ENABLE, IDC_PFR_ENABLE);

        hchk = GetDlgItem(hdlg, IDC_PFR_SHOWUI);
        if (hchk != NULL)
            EnableWindow(hchk, FALSE);

        hchk = GetDlgItem(hdlg, IDC_PFR_ENABLEOS);
        if (hchk != NULL)
            EnableWindow(hchk, TRUE);

        hchk = GetDlgItem(hdlg, IDC_PFR_ENABLEPROG);
        if (hchk != NULL)
            EnableWindow(hchk, TRUE);

        if (pcfg->get_IsServer())
        {
            hbtn = GetDlgItem(hdlg, IDC_PFR_ENABLESHUT);
            if (hbtn != NULL)
                EnableWindow(hbtn, TRUE);
        }

        if ((psmd->eieApps & eieDisableMask) != 0)
        {
            hbtn = GetDlgItem(hdlg, IDC_PFR_DETAILS);
            if (hbtn != NULL)
                EnableWindow(hbtn, FALSE);

            if (pcfg->get_IsServer())
            {
                hbtn = GetDlgItem(hdlg, IDC_PFR_FORCEQ);
                if (hbtn != NULL)
                    EnableWindow(hbtn, FALSE);
            }
        }
    }

    fRet = TRUE;
    psmd = NULL;
    pcfg = NULL;

done:
    if (fRet == FALSE)
    {
        TCHAR   szMsg[MAX_PATH];
        LoadString(hInstance, IDS_PFR_CFGREADERR, szMsg, sizeofSTRT(szMsg));
        MessageBox(hdlg, szMsg, NULL, MB_OK | MB_ICONERROR);
    }
    
    if (psmd != NULL)
        delete psmd;
    if (pcfg != NULL)
        delete pcfg;

    return fRet;
}

// **************************************************************************
static inline INT_PTR LaunchSubDialog(HWND hdlgParent, DWORD dwDlgToLaunch, 
                                      SMainDlg *psmd)
{
    if (dwDlgToLaunch == PROGLI)
    {
        SProgDlg spd;

        ZeroMemory(&spd, sizeof(spd));
        spd.pcfg    = psmd->pcfg;
        spd.eieApps = psmd->eieApps;
        spd.eieMS   = psmd->pcfg->get_IncMSApps();
        spd.fRW     = psmd->fRW;
        if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_PFR_PROG), 
                           hdlgParent, PFRProgDlgProc, (LPARAM)&spd) == IDOK)
        {
            psmd->eieApps = psmd->pcfg->get_AllOrNone();
        }
    }

    else
    {
        return IDCANCEL;
    }

    return IDOK;
}


// **************************************************************************
INT_PTR APIENTRY PFRDlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, 
                            LPARAM lParam)
{
    CPFFaultClientCfg   *pcfg = NULL;
    SMainDlg            *psmd = (SMainDlg *)GetWindowLongPtr(hdlg, DWLP_USER);
    HWND                hbtn, hchk;

    if (psmd != NULL)
        pcfg = psmd->pcfg;

    switch(uMsg)
    {
        case WM_INITDIALOG:
            if (InitMainDlg(hdlg) == FALSE)
                EndDialog(hdlg, IDCANCEL);
            break;

        case WM_DESTROY:
            if (psmd != NULL)
            {
                if (psmd->pcfg != NULL)
                    delete psmd->pcfg;
            
                delete psmd;
                SetWindowLongPtr(hdlg, DWLP_USER, NULL);
            }
            break;
            
        // F1 help
        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, 
                    HELP_FILE, HELP_WM_HELP, (DWORD_PTR)g_rgPFER);
            break;

        // right-click help
        case WM_CONTEXTMENU:
            WinHelp((HWND)wParam, HELP_FILE, HELP_CONTEXTMENU,
                    (DWORD_PTR)g_rgPFER);
            break;
    
        case WM_COMMAND:
        {
            switch (LOWORD(wParam)) 
            {
                case IDOK:
                    if (psmd->fRW)
                    {
                        HRESULT hr;

                        pcfg->set_AllOrNone(psmd->eieApps);
                        pcfg->set_DoReport(psmd->eedReport);
                        pcfg->set_IncKernel(psmd->eieKernel);
                        pcfg->set_ShowUI(psmd->eedShowUI);
                        if (pcfg->get_IsServer())
                        {
                            pcfg->set_IncShutdown(psmd->eieShut);
                            pcfg->set_ForceQueueMode(psmd->fForceQueue);
                        }

                        hr = pcfg->Write();
                        if (FAILED(hr))
                        {
                            TCHAR   szMsg[MAX_PATH];

                            if (hr != HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
                            {
                                LoadString(hInstance, IDS_PFR_CFGWRITEERR, szMsg,
                                           sizeofSTRT(szMsg));
                            }
                            else
                            {
                                LoadString(hInstance, IDS_PFR_NOTADMIN, szMsg,
                                           sizeofSTRT(szMsg));
                            }
                            MessageBox(hdlg, szMsg, NULL, MB_OK | MB_ICONERROR);
                        }
                    }
                    else
                    {
                        TCHAR   szMsg[MAX_PATH];

                        LoadString(hInstance, IDS_PFR_NOTADMIN, szMsg,
                                   sizeofSTRT(szMsg));
                        MessageBox(hdlg, szMsg, NULL, MB_OK | MB_ICONERROR);
                    }

                    EndDialog(hdlg, IDOK);
                    break;

                case IDCANCEL:
                    EndDialog(hdlg, IDCANCEL);
                    break;

                case IDC_PFR_ENABLE:
                {
                    LVITEM lvi;

                    psmd->eedReport = eedEnabled;

                    // if UI is disbaled, then implicitly enable it (but don't
                    //  change the check state of the 'show UI' checkbox) cuz
                    //  we only support headless uploading thru policy.
                    if (psmd->eedShowUI == eedDisabled)
                        psmd->eedShowUI = eedEnabledNoCheck;

                    hchk = GetDlgItem(hdlg, IDC_PFR_SHOWUI);
                    if (hchk != NULL)
                        EnableWindow(hchk, FALSE);

                    hchk = GetDlgItem(hdlg, IDC_PFR_ENABLEOS);
                    if (hchk != NULL)
                        EnableWindow(hchk, TRUE);

                    hchk = GetDlgItem(hdlg, IDC_PFR_ENABLEPROG);
                    if (hchk != NULL)
                        EnableWindow(hchk, TRUE);

                    if (pcfg->get_IsServer())
                    {
                        hbtn = GetDlgItem(hdlg, IDC_PFR_ENABLESHUT);
                        if (hbtn != NULL)
                            EnableWindow(hbtn, TRUE);
                    }

                    if ((psmd->eieApps & eieDisableMask) == 0)
                    {
                        hbtn = GetDlgItem(hdlg, IDC_PFR_DETAILS);
                        if (hbtn != NULL)
                            EnableWindow(hbtn, TRUE);

                        if (pcfg->get_IsServer())
                        {
                            hbtn = GetDlgItem(hdlg, IDC_PFR_FORCEQ);
                            if (hbtn != NULL)
                                EnableWindow(hbtn, TRUE);
                        }
                    }

                    break;
                }

                case IDC_PFR_DISABLE:
                {
                    psmd->eedReport = eedDisabled;

                    // if UI isn't explicitly enabled, disable it- it was 
                    //  implicity enabled when the user previously enabled 
                    //  reporting
                    if (psmd->eedShowUI == eedEnabledNoCheck)
                        psmd->eedShowUI = eedDisabled;

                    hchk = GetDlgItem(hdlg, IDC_PFR_SHOWUI);
                    if (hchk != NULL)
                        EnableWindow(hchk, TRUE);

                    hchk = GetDlgItem(hdlg, IDC_PFR_ENABLEOS);
                    if (hchk != NULL)
                        EnableWindow(hchk, FALSE);

                    hchk = GetDlgItem(hdlg, IDC_PFR_ENABLEPROG);
                    if (hchk != NULL)
                        EnableWindow(hchk, FALSE);

                    hbtn = GetDlgItem(hdlg, IDC_PFR_DETAILS);
                    if (hbtn != NULL)
                        EnableWindow(hbtn, FALSE);

                    if (pcfg->get_IsServer())
                    {
                        hbtn = GetDlgItem(hdlg, IDC_PFR_ENABLESHUT);
                        if (hbtn != NULL)
                            EnableWindow(hbtn, FALSE);
                        
                        hbtn = GetDlgItem(hdlg, IDC_PFR_FORCEQ);
                        if (hbtn != NULL)
                            EnableWindow(hbtn, FALSE);
                    }
                    
                    break;
                }

                case IDC_PFR_DETAILS:
                {
                    // don't need to check if this is a valid thing to bring up
                    //  a dialog for cuz the details button should not be 
                    //  available if it isn't
                    return LaunchSubDialog(hdlg, PROGLI, psmd);
                    break;
                }

                case IDC_PFR_SHOWUI:
                {
                    if (IsDlgButtonChecked(hdlg, IDC_PFR_SHOWUI) == BST_UNCHECKED)
                        psmd->eedShowUI = eedDisabled;
                    else if (psmd->eedReport == eedEnabled)
                        psmd->eedShowUI = eedEnabledNoCheck;
                    else
                        psmd->eedShowUI = eedEnabled;
                    break;
                }

                case IDC_PFR_ENABLEOS:
                {
                    if (IsDlgButtonChecked(hdlg, IDC_PFR_ENABLEOS) == BST_UNCHECKED)
                        psmd->eieKernel = eieExclude;
                    else
                        psmd->eieKernel = eieInclude;
                    break;
                }

                case IDC_PFR_ENABLEPROG:
                {
                    DWORD dw;
                    
                    hbtn = GetDlgItem(hdlg, IDC_PFR_DETAILS);
                    if (pcfg->get_IsServer())
                        hchk = GetDlgItem(hdlg, IDC_PFR_FORCEQ);
                    else
                        hchk = NULL;
                    if (IsDlgButtonChecked(hdlg, IDC_PFR_ENABLEPROG) == BST_UNCHECKED)
                    {
                        dw = (DWORD)psmd->eieApps | eieDisableMask;
                        if (hbtn != NULL)
                            EnableWindow(hbtn, FALSE);
                        if (hchk != NULL)
                            EnableWindow(hchk, FALSE);
                    }
                    else
                    {
                        dw = (DWORD)psmd->eieApps & eieIncMask;
                        if (hbtn != NULL)
                            EnableWindow(hbtn, TRUE);
                        if (hchk != NULL)
                            EnableWindow(hchk, TRUE);
                    }

                    psmd->eieApps = (EIncEx)dw;

                    break;
                }

                case IDC_PFR_ENABLESHUT:
                    if (pcfg->get_IsServer())
                    {
                        if (IsDlgButtonChecked(hdlg, IDC_PFR_ENABLESHUT) == BST_UNCHECKED)
                            psmd->eieShut = eieExclude;
                        else
                            psmd->eieShut = eieInclude;
                    }

                case IDC_PFR_FORCEQ:
                    if (pcfg->get_IsServer())
                    {
                        if (IsDlgButtonChecked(hdlg, IDC_PFR_FORCEQ) == BST_UNCHECKED)
                            psmd->fForceQueue = FALSE;
                        else
                            psmd->fForceQueue = TRUE;
                    }
                    

                default:
                    return FALSE;

            }

            break;
        }

        default:
            return FALSE;

    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\pfrscpl.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    pfrscpl.h

Abstract:
    Implements fault reporting for unhandled exceptions

Revision History:
    created     derekm      08/07/00

******************************************************************************/

#ifndef PFRSCPL_H
#define PFRSCPL_H

INT_PTR APIENTRY PFRDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL LoadPFRResourceStrings(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\sid.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    sid.h

Abstract:

    Public declarations for SID management functions

Author:

    (davidc) 26-Aug-1992

Revision History:

    17-Oct-1997 scotthal
        Split public declarations into separate header

--*/
#ifndef _SYSDM_SID_H_
#define _SYSDM_SID_H_

//
// Public function prototypes
//
LPTSTR 
GetSidString(
    void
);

VOID 
DeleteSidString(
    IN LPTSTR SidString
);

PSID 
GetUserSid(
    void
);

VOID 
DeleteUserSid(
    IN PSID Sid
);

#endif // _SYSDM_SID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\profile.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    profile.h

Abstract:

    Public declarations for the User Profiles tab of the
    System Control Panel Applet

Author:

    Eric Flo (ericflo) 19-Jun-1995

Revision History:

    15-Oct-1997 scotthal
        Complete overhaul

--*/
#ifndef _SYSDM_PROFILE_H_
#define _SYSDM_PROFILE_H_

//
// Flags
//

#define USERINFO_FLAG_DIRTY             1
#define USERINFO_FLAG_CENTRAL_AVAILABLE 2
#define USERINFO_FLAG_ACCOUNT_UNKNOWN   4

//
// Profile types : obtained from ds\security\gina\userenv\profile\profile.h
//

#define USERINFO_LOCAL                  0
#define USERINFO_FLOATING               1
#define USERINFO_MANDATORY              2
#define USERINFO_BACKUP                 3
#define USERINFO_TEMP                   4
#define USERINFO_READONLY               5


typedef struct _USERINFO {
    DWORD     dwFlags;
    LPTSTR    lpSid;
    LPTSTR    lpProfile;
    LPTSTR    lpUserName;
    DWORD     dwProfileType;
    DWORD     dwProfileStatus;
} USERINFO, *LPUSERINFO;

typedef struct _UPCOPYINFO {
    DWORD         dwFlags;
    PSID          pSid;
    LPUSERINFO    lpUserInfo;
    BOOL          bDefaultSecurity;   
} UPCOPYINFO, *LPUPCOPYINFO;


INT_PTR 
APIENTRY 
UserProfileDlgProc(
    IN HWND hDlg, 
    IN UINT uMsg, 
    IN WPARAM wParam, 
    IN LPARAM lParam
);

#endif // _SYSDM_PROFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\sid.c ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    sid.c

Abstract:

    SID management functions

Author:

    (davidc) 26-Aug-1992

--*/
// NT base apis
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>

#include "sysdm.h"


LPTSTR 
GetSidString(
    void
)
/*++

Routine Description:

    Allocates and returns a string representing the sid of the current user
    The returned pointer should be freed using DeleteSidString().

Arguments:

    None

Return Value:

    Returns a pointer to the string or NULL on failure.

--*/
{
    NTSTATUS NtStatus;
    PSID UserSid;
    UNICODE_STRING UnicodeString;
    LPTSTR lpEnd;
#ifndef UNICODE
    STRING String;
#endif

    //
    // Get the user sid
    //

    UserSid = GetUserSid();
    if (UserSid == NULL) {
        return NULL;
    }

    //
    // Convert user SID to a string.
    //

    NtStatus = RtlConvertSidToUnicodeString(
                            &UnicodeString,
                            UserSid,
                            (BOOLEAN)TRUE // Allocate
                            );
    //
    // We're finished with the user sid
    //

    DeleteUserSid(UserSid);

    //
    // See if the conversion to a string worked
    //

    if (!NT_SUCCESS(NtStatus)) {
        return NULL;
    }

#ifdef UNICODE


    return(UnicodeString.Buffer);

#else

    //
    // Convert the string to ansi
    //

    NtStatus = RtlUnicodeStringToAnsiString(&String, &UnicodeString, TRUE);
    RtlFreeUnicodeString(&UnicodeString);
    if (!NT_SUCCESS(NtStatus)) {
        return NULL;
    }


    return(String.Buffer);

#endif

}


VOID 
DeleteSidString(
    IN LPTSTR SidString
)
/*++

Routine Description:

    Frees up a sid string previously returned by GetSidString()

Arguments:

    SidString -
        Supplies string to free

Return Value:

    None

--*/
{

#ifdef UNICODE
    UNICODE_STRING String;

    RtlInitUnicodeString(&String, SidString);

    RtlFreeUnicodeString(&String);
#else
    ANSI_STRING String;

    RtlInitAnsiString(&String, SidString);

    RtlFreeAnsiString(&String);
#endif

}


PSID 
GetUserSid(
    void
)
/*++

Routine Description:

    Allocs space for the user sid, fills it in and returns a pointer. Caller
    The sid should be freed by calling DeleteUserSid.

    Note the sid returned is the user's real sid, not the per-logon sid.

Arguments:

    None

Return Value:

    Returns pointer to sid or NULL on failure.

--*/
{
    PTOKEN_USER pUser, pTemp;
    PSID pSid;
    DWORD BytesRequired = 200;
    NTSTATUS status;
    HANDLE UserToken;


    if (!OpenProcessToken (GetCurrentProcess(), TOKEN_READ, &UserToken)) {
        return NULL;
    }

    //
    // Allocate space for the user info
    //

    pUser = (PTOKEN_USER)LocalAlloc(LMEM_FIXED, BytesRequired);


    if (pUser == NULL) {
        CloseHandle (UserToken);
        return NULL;
    }


    //
    // Read in the UserInfo
    //

    status = NtQueryInformationToken(
                 UserToken,                 // Handle
                 TokenUser,                 // TokenInformationClass
                 pUser,                     // TokenInformation
                 BytesRequired,             // TokenInformationLength
                 &BytesRequired             // ReturnLength
                 );

    if (status == STATUS_BUFFER_TOO_SMALL) {

        //
        // Allocate a bigger buffer and try again.
        //

        pTemp = pUser;
        pUser = (PTOKEN_USER)LocalReAlloc(pUser, BytesRequired, LMEM_MOVEABLE);
        if (pUser == NULL) {
            LocalFree((HLOCAL) pTemp);
            CloseHandle (UserToken);
            return NULL;
        }

        status = NtQueryInformationToken(
                     UserToken,             // Handle
                     TokenUser,             // TokenInformationClass
                     pUser,                 // TokenInformation
                     BytesRequired,         // TokenInformationLength
                     &BytesRequired         // ReturnLength
                     );

    }

    if (!NT_SUCCESS(status)) {
        LocalFree(pUser);
        CloseHandle (UserToken);
        return NULL;
    }


    BytesRequired = RtlLengthSid(pUser->User.Sid);
    pSid = LocalAlloc(LMEM_FIXED, BytesRequired);
    if (pSid == NULL) {
        LocalFree(pUser);
        CloseHandle (UserToken);
        return NULL;
    }


    status = RtlCopySid(BytesRequired, pSid, pUser->User.Sid);

    LocalFree(pUser);

    if (!NT_SUCCESS(status)) {
        LocalFree(pSid);
        pSid = NULL;
    }

    CloseHandle (UserToken);

    return pSid;
}


VOID 
DeleteUserSid(
    IN PSID Sid
)
/*++

Routine Description:

    Deletes a user sid previously returned by GetUserSid()

Arguments:

    Sid -
        Supplies sid to delete

Return Value:

    None

--*/
{
    LocalFree(Sid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\resource.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    resource.h

Abstract:

    Resource IDs for the System Control Panel Applet

Author:

    Eric Flo (ericflo) 19-Jun-1995

Revision History:

    15-Oct-1997 scotthal
        Complete overhaul

--*/
#ifndef _SYSDM_RESOURCE_H_
#define _SYSDM_RESOURCE_H_

//
// Icons
//
#define ID_ICON                       1
#define IDI_PROFILE                   2
#define DOCK_ICON                     3
#define UP_ICON                       4
#define DOWN_ICON                     5
#define IDI_COMPUTER                  6
#define PERF_ICON                     7
#define ENVVAR_ICON                   8
#define CRASHDUMP_ICON                9

//
// Bitmaps
//
#define IDB_WINDOWS                   1
#define IDB_WINDOWS_256               2
#define IDB_PFR_CHECK                 5
#define IDB_PFR_CHECKG                6
#define IDB_PFR_UNCHECK               7

//
// String table constants
//
#define IDS_NAME                                        1
#define IDS_INFO                                        2
#define IDS_TITLE                                       3
#define IDS_DEBUG                                       4
#define IDS_XDOTX_MB                                    5
#define IDS_PAGESIZE                                    6
#define IDS_DUMPFILE                                    7
#define IDS_USERENVVARS                                 8
#define IDS_UP_NAME                                     9
#define IDS_UP_SIZE                                     10
#define IDS_UP_TYPE                                     11
#define IDS_UP_STATUS                                   12
#define IDS_UP_MOD                                      13
// UNUSED                                               14
#define IDS_UP_LOCAL                                    15
#define IDS_UP_FLOATING                                 16
#define IDS_UP_MANDATORY                                17
#define IDS_UP_CONFIRM                                  18
#define IDS_UP_CONFIRMTITLE                             19
#define IDS_UP_DIRPICK                                  20
#define IDS_UP_ERRORTITLE                               21

#define IDS_UP_ACCUNKNOWN                               22
#define IDS_UP_ACCDELETED                               23
#define IDS_UP_CHANGETYPEMSG                            24
#define IDS_UP_CONFIRMCOPYMSG                           25
#define IDS_UP_CONFIRMCOPYTITLE                         26
#define IDS_UP_DELETE_ERROR                             27
#define IDS_UP_SETSECURITY_ERROR                        28
#define IDS_UP_COPYHIVE_ERROR                           29
#define IDS_UP_BACKUP                                   30
#define IDS_UP_TEMP                                     31
#define IDS_UP_READONLY                                 32
#define IDS_PROCESSOR_SPEED                             33
#define IDS_PROCESSOR_SPEEDGHZ                          34
#define IDS_PERFOPTIONS                                 35
#define IDS_UP_UPLINK_SERVER                            36

#define IDS_PAE                                         50

#define IDS_NETID_DLL_NAME                              55
#define IDS_TEMP_PAGEFILE_WARN                          56

#define IDS_CRASHDUMP_NONE                              75
#define IDS_CRASHDUMP_MINI                              76
#define IDS_CRASHDUMP_SUMMARY                           77
#define IDS_CRASHDUMP_FULL                              78
#define IDS_CRASHDUMP_DUMP_FILE                         79
#define IDS_CRASHDUMP_MINI_DIR                          80
#define IDS_CRASHDUMP_MINI_WIN64                        81

#define IDS_INSUFFICIENT_MEMORY                         100
#define IDS_SYSDM_TITLE                                 101

#define IDS_SYSDM_ENTERSECONDS                          114

#define IDS_SYSDM_NOOPEN_USER_UNK                       118
#define IDS_SYSDM_NONEW_ENV_UNK                         119

#define IDS_SYSDM_NOOPEN_VM_NOTUSER                     121
//#define IDS_SYSDM_NOOPEN_VM_NOTADMIN                  122
#define IDS_SYSDM_PAGEFILESIZE_START                    123
#define IDS_SYSDM_PAGEFILESIZE_MAX                      124
#define IDS_SYSDM_PAGEFILESIZE_TOOSMALL                 125
#define IDS_SYSDM_PAGEFILESIZE_TOOSMALL_NAMED           126
#define IDS_SYSDM_CANNOTREAD                            127
#define IDS_SYSDM_MB                                    128
#define IDS_SYSDM_NOCHANGE_BOOTINI                      129
#define IDS_SYSDM_PAGEFILESIZE_TOOSMALL_GROW            130
#define IDS_SYSDM_NOOPEN_SYS_UNK                        131
#define IDS_SYSDM_NOOPEN_RECOVER_GROUP                  132
//#define IDS_SYSDM_NOOPEN_RECOVER_UNK                  133
#define IDS_SYSDM_SAVE_ERROR                            134
#define IDS_SYSDM_OVERWRITE                             135
#define IDS_SYSDM_NOTENOUGHSPACE_PAGE                   136
#define IDS_SYSDM_NOTENOUGHSPACE_CRASHRECOVER           137
#define IDS_SYSDM_RECOVERY_MINIMUM                      138
#define IDS_SYSDM_DEBUGGING_MINIMUM                     139
#define IDS_SYSDM_DEBUGGING_FILENAME                    140
#define IDS_SYSDM_DEBUGGING_DRIVE                       141
#define IDS_SYSDM_DEBUGGING_PATH                        142
#define IDS_SYSDM_DEBUGGING_PATHLONG                    143
#define IDS_SYSDM_DEBUGGING_UNQUALIFIED                 144
#define IDS_SYSDM_NOALERTER                             148
#define IDS_SYSDM_CANNOTOPENFILE                        149
#define IDS_SYSDM_ENTERINITIALSIZE                      150
#define IDS_SYSDM_ENTERMAXIMUMSIZE                      151
#define IDS_SYSDM_RESTART                               152
#define IDS_SYSDM_DONTKNOWCURRENT                       153
#define IDS_SYSDM_NOOPEN_SYS_NOTADMIN                   154

#define IDS_ENVVAR_VARIABLE_HEADING                     160
#define IDS_ENVVAR_VALUE_HEADING                        161
#define IDS_SYSDM_NOLOAD_DEVMANPROG                     162
#define IDS_SYSDM_NOEXPORTS_DEVMANPROG                  163

#define IDS_SYSDM_NOOPEN_USER_NOTADMIN                  170
#define IDS_SYSDM_NONEW_ENV_NOTADMIN                    171

#define IDS_WINVER_WINDOWSXP                            180

#define IDS_WINVER_PROFESSIONAL_WIN64                   188
#define IDS_WINVER_EMBEDDED                             189
#define IDS_WINVER_PERSONAL                             190
#define IDS_WINVER_PROFESSIONAL                         191
#define IDS_WINVER_SERVER                               192
#define IDS_WINVER_ADVANCEDSERVER                       193
#define IDS_WINVER_DATACENTER                           194

#define IDS_WINVER_2002                                 195

//
// Edit Environment Variable strings
//
#define IDS_NEW_SYSVAR_CAPTION                          200
#define IDS_EDIT_SYSVAR_CAPTION                         201
#define IDS_NEW_USERVAR_CAPTION                         202
#define IDS_EDIT_USERVAR_CAPTION                        203

//
// Profile using new constants after 3000
//

#define IDS_UP_DELNODE_ERROR                            3000

#define IDS_PFR_OK                                      4000
#define IDS_PFR_FILTER                                  4001
#define IDS_PFR_TITLE                                   4002
#define IDS_PFR_CFGREADERR                              4003
#define IDS_PFR_CFGWRITEERR                             4004
#define IDS_PFR_WINCOMP                                 4005
#define IDS_PFR_KERNEL                                  4006
#define IDS_PFR_PROG                                    4007
#define IDS_PFR_MSPROG                                  4008
#define IDS_PFR_NOTADMIN                                4009
#define IDS_PFR_ISWINCOMP                               4010
#define IDS_PFR_ISONLISTI                               4011
#define IDS_PFR_ADDTOEX                                 4012
#define IDS_PFR_ADDTOINC                                4013
#define IDS_PFR_BADFILE                                 4014
#define IDS_PFR_ISONLISTE                               4015
#define IDS_PFR_DEFINC                                  4016
#define IDS_PFR_DEFEX                                   4017


#define HWP                         60

#define HWP_DEF_FRIENDLYNAME        HWP+0
#define HWP_CURRENT_TAG             HWP+1
#define HWP_UNAVAILABLE             HWP+2
#define HWP_ERROR_CAPTION           HWP+3
#define HWP_ERROR_PROFILE_IN_USE    HWP+4
#define HWP_ERROR_IN_USE            HWP+5
#define HWP_CONFIRM_DELETE_CAP      HWP+6
#define HWP_CONFIRM_DELETE          HWP+7
#define HWP_INVALID_WAIT            HWP+8
#define HWP_CONFIRM_NOT_PORTABLE    HWP+9
#define HWP_UNKNOWN_PROFILE         HWP+10
#define HWP_DOCKED_PROFILE          HWP+11
#define HWP_UNDOCKED_PROFILE        HWP+12
#define HWP_ERROR_COMPLEX_SCRIPT    HWP+13
//
// Dialog box ID's
//
#define DLG_VIRTUALMEM              41
#define IDD_ENVVAREDIT              42
#define IDD_USERPROFILE             100
#define IDD_GENERAL                 101
#define IDD_PHONESUP                102
#define IDD_ADVANCEDPERF            103
#define IDD_STARTUP                 104
#define IDD_ENVVARS                 105
#define DLG_HWPROFILES              106
#define DLG_HWP_RENAME              107
#define DLG_HWP_COPY                108
#define DLG_HWP_GENERAL             109
#define IDD_UP_TYPE                 110
#define IDD_UP_COPY                 111
#define IDD_VISUALEFFECTS           112
#define IDD_ADVANCED                115
#define IDD_HARDWARE                2000
#define IDD_PFR_REPORT              4100
#define IDD_PFR_REPORTSRV           4101
#define IDD_PFR_PROG                4102
#define IDD_PFR_ADDPROG             4103



//
// Shared text id's
//
#define IDC_TEXT_1                 10
#define IDC_TEXT_2                 11
#define IDC_TEXT_3                 12
#define IDC_TEXT_4                 13


//
// General page
//
#define IDC_GEN_WINDOWS_IMAGE            51
#define IDC_GEN_VERSION_0                52
#define IDC_GEN_VERSION_1                53
#define IDC_GEN_VERSION_2                54
#define IDC_GEN_SERVICE_PACK             55
#define IDC_GEN_REGISTERED_0             56
#define IDC_GEN_REGISTERED_1             57
#define IDC_GEN_REGISTERED_2             58
#define IDC_GEN_REGISTERED_3             59
#define IDC_GEN_OEM_NUDGE                60
#define IDC_GEN_MACHINE                  61
#define IDC_GEN_OEM_IMAGE                62
#define IDC_GEN_MACHINE_0                63
#define IDC_GEN_MACHINE_1                64
#define IDC_GEN_MACHINE_2                65
#define IDC_GEN_MACHINE_3                66
#define IDC_GEN_MACHINE_4                67
#define IDC_GEN_MACHINE_5                68
#define IDC_GEN_OEM_SUPPORT              69
#define IDC_GEN_MACHINE_6                70
#define IDC_GEN_MACHINE_7                71
#define IDC_GEN_MACHINE_8                72

#define LAST_GEN_MACHINES_SLOT           IDC_GEN_MACHINE_8
#define MAX_GEN_MACHINES_SLOT            (LAST_GEN_MACHINES_SLOT - IDC_GEN_MACHINE_0)



//
// Phone support dialog
//
#define IDC_SUPPORT_TEXT                 70

//
// Performace dialog
//
#define IDC_PERF_CHANGE                 201
#define IDC_PERF_VM_ALLOCD              202
#define IDC_PERF_GROUP                  203
#define IDC_PERF_WORKSTATION            204
#define IDC_PERF_SERVER                 205
#define IDC_PERF_VM_GROUP               206
#define IDC_PERF_VM_ALLOCD_LABEL        207
#define IDC_PERF_TEXT                   208
#define IDC_PERF_CACHE_GROUP            209
#define IDC_PERF_CACHE_TEXT             210
#define IDC_PERF_CACHE_APPLICATION      211
#define IDC_PERF_CACHE_SYSTEM           212
#define IDC_PERF_VM_ALLOCD_TEXT         213
#define IDC_PERF_TEXT2                  214
#define IDC_PERF_CACHE_TEXT2            215

//
// Startup page
//
#define IDC_STARTUP_SYS_OS              300
#define IDC_STARTUP_SYS_SECONDS         301
#define IDC_STARTUP_SYS_SECSCROLL       302
#define IDC_STARTUP_SYS_ENABLECOUNTDOWN 303
#define IDC_STARTUP_SYSTEM_GRP          304
#define IDC_STARTUP_SYS_SECONDS_LABEL   305
#define IDC_STARTUP_SYS_EDIT_LABEL      306
#define IDC_SYS_EDIT_BUTTION            307
#define IDC_STARTUP_SYS_OS_LABEL        308
#define IDC_STARTUP_AUTOLKG               309
#define IDC_STARTUP_AUTOLKG_SECONDS_LABEL 310
#define IDC_STARTUP_AUTOLKG_SECONDS     311
#define IDC_STARTUP_AUTOLKG_SECSCROLL   312

#define IDC_STARTUP_CDMP_GRP            601
#define IDC_STARTUP_CDMP_TXT1           602
#define IDC_STARTUP_CDMP_LOG            603
#define IDC_STARTUP_CDMP_SEND           604
#define IDC_STARTUP_CDMP_FILENAME       606
#define IDC_STARTUP_CDMP_OVERWRITE      607
#define IDC_STARTUP_CDMP_AUTOREBOOT     608
#define IDC_STARTUP_CDMP_TYPE           610
#define IDC_STARTUP_CDMP_FILE_LABEL     611
#define IDC_STARTUP_CDMP_DEBUGINFO_GROUP 612

//
// Environment Variables dialog
//
#define IDC_ENVVAR_SYS_LB_SYSVARS       400
#define IDC_ENVVAR_SYS_LB_USERVARS      402
#define IDC_ENVVAR_SYS_NEWSV            407
#define IDC_ENVVAR_SYS_EDITSV           408
#define IDC_ENVVAR_SYS_DELSV            409
#define IDC_ENVVAR_SYS_USERGROUP        411
#define IDC_ENVVAR_SYS_NEWUV            412
#define IDC_ENVVAR_SYS_EDITUV           413
#define IDC_ENVVAR_SYS_NDELUV           414
#define IDC_ENVVAR_SYS_SYSGROUP         415

#define IDC_ENVVAR_SYS_SETUV            405
#define IDC_ENVVAR_SYS_DELUV            406

//
// Environment Variables "New..."/"Edit.." dialog
//
#define IDC_ENVVAR_EDIT_NAME_LABEL      100
#define IDC_ENVVAR_EDIT_NAME            101
#define IDC_ENVVAR_EDIT_VALUE_LABEL     102
#define IDC_ENVVAR_EDIT_VALUE           103

//
// Exception Reporting dialog
//
#define IDC_PFR                          4200
#define IDC_PFR_INCADD                   IDC_PFR + 0
#define IDC_PFR_INCREM                   IDC_PFR + 1
#define IDC_PFR_EXADD                    IDC_PFR + 2
#define IDC_PFR_EXREM                    IDC_PFR + 3
#define IDC_PFR_DISABLE                  IDC_PFR + 4
#define IDC_PFR_ENABLE                   IDC_PFR + 5
#define IDC_PFR_DETAILS                  IDC_PFR + 6
#define IDC_PFR_DEFALL                   IDC_PFR + 7
#define IDC_PFR_DEFNONE                  IDC_PFR + 8
#define IDC_PFR_INCLIST                  IDC_PFR + 9
#define IDC_PFR_NEWPROG                  IDC_PFR + 10
#define IDC_PFR_BROWSE                   IDC_PFR + 11
#define IDC_PFR_EXLIST                   IDC_PFR + 12
#define IDC_PFR_REPICON                  IDC_PFR + 13
#define IDC_PFR_SHOWUI                   IDC_PFR + 14
#define IDC_PFR_ENABLEOS                 IDC_PFR + 15
#define IDC_PFR_ENABLEPROG               IDC_PFR + 16
#define IDC_PFR_ENABLESHUT	         IDC_PFR + 17
#define IDC_PFR_FORCEQ		         IDC_PFR + 18
#define IDC_PFR_TEXT                     IDC_PFR + 98
#define IDC_ADV_PFR_BTN                  IDC_PFR + 99


//
// IF IDS ARE ADDED OR REMOVED, THEN ADD/REMOVE THE CORRESPONDING
// HELP IDS IN HWPROF.C ALSO!!
//
#define IDD_HWP_PROFILES                300
#define IDD_HWP_PROPERTIES              301
#define IDD_HWP_COPY                    302
#define IDD_HWP_RENAME                  303
#define IDD_HWP_DELETE                  304
#define IDD_HWP_ST_MULTIPLE             305
#define IDD_HWP_WAITFOREVER             307
#define IDD_HWP_WAITUSER                308
#define IDD_HWP_SECONDS                 309
#define IDD_HWP_SECSCROLL               310
#define IDD_HWP_COPYTO                  311
#define IDD_HWP_COPYFROM                312
#define IDD_HWP_ST_DOCKID               313
#define IDD_HWP_ST_SERIALNUM            314
#define IDD_HWP_DOCKID                  315
#define IDD_HWP_SERIALNUM               316
#define IDD_HWP_PORTABLE                317
#define IDD_HWP_ALIASABLE               318
#define IDD_HWP_UNKNOWN                 319
#define IDD_HWP_DOCKED                  320
#define IDD_HWP_UNDOCKED                321
#define IDD_HWP_ST_PROFILE              322
#define IDD_HWP_ORDERUP                 323
#define IDD_HWP_ORDERDOWN               324
#define IDD_HWP_RENAMEFROM              325
#define IDD_HWP_RENAMETO                326
#define IDD_HWP_WAITUSER_TEXT_1         327
#define IDD_HWP_UNUSED_1                340
#define IDD_HWP_UNUSED_2                341
#define IDD_HWP_UNUSED_3                342
#define IDD_HWP_UNUSED_4                343
#define IDD_HWP_UNUSED_5                344
#define IDD_HWP_UNUSED_6                345
#define IDD_HWP_COPYTO_CAPTION          346
#define IDD_HWP_RENAMETO_CAPTION        347

//
// NOTE: The following ID ranges are reserved for use by property
// page providers for the Hardware Profiles and should not be used
// by the main hardware profiles dialog or the Hardware Profiles
// General property page. All property page providers (dlls that
// add pages to the Hardware Profiles properties) will use help
// IDs within the range allocated for Hardware Profiles (IDH_HWPROFILE)
//
// RESERVE FOR:
//
//      No Net Property Page Extension:
//          Control IDs:    500-549
//          Help IDs:       IDH_HWPROFILE+500 - IDH_HWPROFILE+550
//
//      Other Property Page Extensions...
//
//          Control IDs:    550-599  - reserved for later use
//          Control IDs:    600-649  - reserved for later use
//          Control IDs:    650-699  - reserved for later use
//


//
// Static text id
//
#define IDC_STATIC                -1


//
// User profile page
//
#define IDC_UP_LISTVIEW         1000
#define IDC_UP_DELETE           1001
#define IDC_UP_TYPE             1002
#define IDC_UP_COPY             1003
#define IDC_UP_ICON             1004
#define IDC_UP_TEXT             1005
#define IDC_UP_UPLINK           1006

//
// User profile 'change type' dialog
//
#define IDC_UPTYPE_LOCAL        1020
#define IDC_UPTYPE_FLOAT        1021
// these dwords 1022, 1023 were used as slowlink text, removing..
#define IDC_UPTYPE_GROUP        1024


//
// User profile 'copy to' dialog
//
#define IDC_COPY_PATH           1030
#define IDC_COPY_BROWSE         1031
#define IDC_COPY_USER           1032
#define IDC_COPY_CHANGE         1033
#define IDC_COPY_GROUP          1034
#define IDC_COPY_PROFILE        1035

//
// Virtual Mem dlg
//
#define IDD_VM_DRIVE_HDR        1140
#define IDD_VM_PF_SIZE_LABEL    1142
#define IDD_VM_DRIVE_LABEL      1144
#define IDD_VM_SPACE_LABEL      1146
#define IDD_VM_MIN_LABEL        1148
#define IDD_VM_RECOMMEND_LABEL  1150
#define IDD_VM_ALLOCD_LABEL     1152
#define IDD_VM_VOLUMES          1160
#define IDD_VM_SF_DRIVE         1161
#define IDD_VM_SF_SPACE         1162
#define IDD_VM_SF_SIZE          1163
#define IDD_VM_SF_SIZEMAX       1164
#define IDD_VM_SF_SET           1165
#define IDD_VM_MIN              1166
#define IDD_VM_RECOMMEND        1167
#define IDD_VM_ALLOCD           1168
#define IDD_VM_ST_INITSIZE      1169
#define IDD_VM_ST_MAXSIZE       1170
#define IDD_VMEM_ICON           1171
#define IDD_VMEM_MESSAGE        1172
#define IDD_VM_REG_SIZE_LIM     1173
#define IDD_VM_REG_SIZE_TXT     1174
#define IDD_VM_CUSTOMSIZE_RADIO 1176
#define IDD_VM_RAMBASED_RADIO   1177
#define IDD_VM_NOPAGING_RADIO   1178


//
// Hardware dlg
//
#define IDC_WIZARD_ICON           2001
#define IDC_WIZARD_TEXT           2002
#define IDC_WIZARD_START          2003
#define IDC_DEVMGR_ICON           2004
#define IDC_DEVMGR_TEXT           2005
#define IDC_DEVMGR_START          2006
#define IDC_HWPROFILES_START      2007
#define IDC_HWPROFILES_ICON       2008
#define IDC_HWPROFILES_START_TEXT 2009
#define IDC_DRIVER_SIGNING        2010


//
// Visual Effects dlg
//
// Do not change the order of IDC_VFX_??? entries, we loop over these in visualfx.cpp
#define IDC_VFX_TREE            2020
#define IDC_VFX_AUTO            2021
#define IDC_VFX_BESTLOOKS       2022
#define IDC_VFX_BESTPERF        2023
#define IDC_VFX_CUSTOM          2024
#define IDC_VFX_TITLE           2030

//
// Advanced dlg
//
#define IDC_ADV_PERF_TEXT       101
#define IDC_ADV_PERF_BTN        110
#define IDC_ADV_PROF_TEXT       201
#define IDC_ADV_PROF_BTN        210
#define IDC_ADV_ENV_TEXT        121
#define IDC_ADV_ENV_BTN         130
#define IDC_ADV_RECOVERY_TEXT   141
#define IDC_ADV_RECOVERY_BTN    150

// Property sheet titles
#define IDS_PROPSHEET_TITLE_GENERAL   10000
#define IDS_PROPSHEET_TITLE_HARDWARE  10001
#define IDS_PROPSHEET_TITLE_ADVANCED  10002
#endif // _SYSDM_RESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\profile.cpp ===
//*************************************************************
//
//  Profile.c   - User Profile tab
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1996
//  All rights reserved
//
//*************************************************************

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "sysdm.h"
#include <shellapi.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <userenv.h>
#include <userenvp.h>
#include <getuser.h>
#include <objsel.h>


#define TEMP_PROFILE                 TEXT("Temp profile (sysdm.cpl)")
#define USER_CRED_LOCATION           TEXT("Application Data\\Microsoft\\Credentials")
#define PROFILE_MAPPING              TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList")
#define WINLOGON_KEY                 TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define SYSTEM_POLICIES_KEY          TEXT("Software\\Policies\\Microsoft\\Windows\\System")
#define READONLY_RUP                 TEXT("ReadOnlyProfile")
#define PROFILE_LOCALONLY            TEXT("LocalProfile")
#define PRF_USERSID                  1


//
// Globals
//

const TCHAR c_szNTUserIni[] = TEXT("ntuser.ini");
#define PROFILE_GENERAL_SECTION      TEXT("General")
#define PROFILE_EXCLUSION_LIST       TEXT("ExclusionList")
DWORD g_dwProfileSize;

//
// Help ID's
//
// IDH_USERPROFILE + 20 is used in the OpenUserBrowser routine.
//
DWORD aUserProfileHelpIds[] = {
    IDC_UP_LISTVIEW,              (IDH_USERPROFILE + 0),
    IDC_UP_DELETE,                (IDH_USERPROFILE + 1),
    IDC_UP_TYPE,                  (IDH_USERPROFILE + 2),
    IDC_UP_COPY,                  (IDH_USERPROFILE + 3),
    IDC_UP_ICON,                  (DWORD) -1,
    IDC_UP_TEXT,                  (DWORD) -1,

    // Change Type dialog
    IDC_UPTYPE_LOCAL,             (IDH_USERPROFILE + 4),
    IDC_UPTYPE_FLOAT,             (IDH_USERPROFILE + 5),
    // removed IDC_UPTYPE_SLOW, IDC_UPTYPE_SLOW_TEXT
    IDC_UPTYPE_GROUP,             (IDH_USERPROFILE + 12),

    // Copy To dialog
    IDC_COPY_PROFILE,             (IDH_USERPROFILE + 7),
    IDC_COPY_PATH,                (IDH_USERPROFILE + 7),
    IDC_COPY_BROWSE,              (IDH_USERPROFILE + 8),
    IDC_COPY_USER,                (IDH_USERPROFILE + 9),
    IDC_COPY_CHANGE,              (IDH_USERPROFILE + 10),
    IDC_COPY_GROUP,               (IDH_USERPROFILE + 9),

    0, 0
};


//
// Local function proto-types
//

BOOL InitUserProfileDlg (HWND hDlg, LPARAM lParam);
BOOL FillListView (HWND hDlg, BOOL bAdmin);
LPTSTR CheckSlash (LPTSTR lpDir);
BOOL RecurseDirectory (LPTSTR lpDir, LPTSTR lpExcludeList);
VOID UPSave (HWND hDlg);
VOID UPCleanUp (HWND hDlg);
BOOL IsProfileInUse (LPTSTR lpSid);
void UPDoItemChanged(HWND hDlg, int idCtl);
void UPDeleteProfile(HWND hDlg);
void UPChangeType(HWND hDlg);
void UPOnLink(WPARAM wParam);
INT_PTR APIENTRY ChangeTypeDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
void UPCopyProfile(HWND hDlg);
INT_PTR APIENTRY UPCopyDlgProc (HWND hDlg, UINT uMsg,WPARAM wParam, LPARAM lParam);
BOOL UPCreateProfile (HWND hDlg, LPUPCOPYINFO lpUPCopyInfo, LPTSTR lpDest, PSECURITY_DESCRIPTOR pSecDesc);
VOID UPDisplayErrorMessage(HWND hWnd, UINT uiSystemError, LPTSTR szMsgPrefix);
BOOL ApplyHiveSecurity(LPTSTR lpHiveName, PSID pSid);
LPTSTR CheckSemicolon (LPTSTR lpDir);
LPTSTR ConvertExclusionList (LPCTSTR lpSourceDir, LPCTSTR lpExclusionList);
BOOL ReadExclusionList(LPTSTR szExcludeList, DWORD dwExclSize);
BOOL ReadExclusionListFromIniFile(LPCTSTR lpSourceDir, LPTSTR szExcludeList, DWORD dwExclSize);
HRESULT UPGetUserSelection(HWND hDlg, LPUSERDETAILS lpUserDetails);
BOOL ConfirmDirectory(HWND hDlg, LPTSTR szDir);


//*************************************************************
//
//  UserProfileDlgProc()
//
//  Purpose:    Dialog box procedure for profile tab
//
//  Parameters: hDlg    -   handle to the dialog box
//              uMsg    -   window message
//              wParam  -   wParam
//              lParam  -   lParam
//
//  Return:     TRUE if message was processed
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/11/95    ericflo    Created
//
//*************************************************************

INT_PTR APIENTRY UserProfileDlgProc (HWND hDlg, UINT uMsg,
                                  WPARAM wParam, LPARAM lParam)
{
    switch (uMsg) {
        case WM_INITDIALOG:
           if (!InitUserProfileDlg (hDlg, lParam)) {
               EndDialog(hDlg, FALSE);
           }
           return TRUE;


    case WM_NOTIFY:

        switch (((NMHDR FAR*)lParam)->code)
        {
        case LVN_ITEMCHANGED:
            UPDoItemChanged(hDlg, (int) wParam);
            break;

        case LVN_ITEMACTIVATE:
            PostMessage (hDlg, WM_COMMAND, IDC_UP_TYPE, 0);
            break;

        case LVN_COLUMNCLICK:
            break;

        case NM_CLICK:
        case NM_RETURN:
            UPOnLink(wParam);
            break;

        default:
            return FALSE;
        }
        break;

    case WM_DESTROY:
        UPCleanUp (hDlg);
        break;

    case WM_COMMAND:

        switch (LOWORD(wParam)) {
            case IDC_UP_DELETE:
                UPDeleteProfile(hDlg);
                break;

            case IDC_UP_TYPE:
                UPChangeType(hDlg);
                break;

            case IDC_UP_COPY:
                UPCopyProfile(hDlg);
                break;

            case IDOK:
                UPSave(hDlg);
                EndDialog(hDlg, FALSE);
                break;
                
            case IDCANCEL:
                EndDialog(hDlg, FALSE);
                break;

            default:
                break;

        }
        break;

    case WM_HELP:      // F1
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
        (DWORD_PTR) (LPSTR) aUserProfileHelpIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
        (DWORD_PTR) (LPSTR) aUserProfileHelpIds);
        return (TRUE);

    }

    return (FALSE);
}

//*************************************************************
//
//  InitUserProfileDlg()
//
//  Purpose:    Initializes the User Profiles page
//
//  Parameters: hDlg    -   Dialog box handle
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              1/26/96     ericflo    Created
//
//*************************************************************

BOOL InitUserProfileDlg (HWND hDlg, LPARAM lParam)
{
    TCHAR szHeaderName[30];
    LV_COLUMN col;
    RECT rc;
    HWND hLV;
    INT iTotal = 0, iCurrent;
    HWND hwndTemp;
    BOOL bAdmin;
    HCURSOR hOldCursor;


    hOldCursor = SetCursor (LoadCursor(NULL, IDC_WAIT));

    hLV = GetDlgItem(hDlg, IDC_UP_LISTVIEW);

    // Set extended LV style for whole line selection
    SendMessage(hLV, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);

    //
    // Insert Columns
    //

    GetClientRect (hLV, &rc);
    LoadString(hInstance, IDS_UP_NAME, szHeaderName, 30);
    col.mask = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
    col.fmt = LVCFMT_LEFT;
    iCurrent = (int)(rc.right * .40);
    iTotal += iCurrent;
    col.cx = iCurrent;
    col.pszText = szHeaderName;
    col.iSubItem = 0;

    ListView_InsertColumn (hLV, 0, &col);


    LoadString(hInstance, IDS_UP_SIZE, szHeaderName, 30);
    iCurrent = (int)(rc.right * .15);
    iTotal += iCurrent;
    col.cx = iCurrent;
    col.fmt = LVCFMT_RIGHT;
    col.iSubItem = 1;
    ListView_InsertColumn (hLV, 1, &col);


    LoadString(hInstance, IDS_UP_TYPE, szHeaderName, 30);
    col.iSubItem = 2;
    iCurrent = (int)(rc.right * .15);
    iTotal += iCurrent;
    col.cx = iCurrent;
    col.fmt = LVCFMT_LEFT;
    ListView_InsertColumn (hLV, 2, &col);

    LoadString(hInstance, IDS_UP_STATUS, szHeaderName, 30);
    col.iSubItem = 3;
    iCurrent = (int)(rc.right * .15);
    iTotal += iCurrent;
    col.cx = iCurrent;
    col.fmt = LVCFMT_LEFT;
    ListView_InsertColumn (hLV, 3, &col);

    LoadString(hInstance, IDS_UP_MOD, szHeaderName, 30);
    col.iSubItem = 4;
    col.cx = rc.right - iTotal - GetSystemMetrics(SM_CYHSCROLL);
    col.fmt = LVCFMT_LEFT;
    ListView_InsertColumn (hLV, 4, &col);

    bAdmin = IsUserAdmin();


    if (!bAdmin) {
        RECT rc;
        POINT pt;

        //
        // If the user is not an admin, then we hide the
        // delete and copy to buttons
        //

        hwndTemp = GetDlgItem (hDlg, IDC_UP_DELETE);
        GetWindowRect (hwndTemp, &rc);
        EnableWindow (hwndTemp, FALSE);
        ShowWindow (hwndTemp, SW_HIDE);

        hwndTemp = GetDlgItem (hDlg, IDC_UP_COPY);
        EnableWindow (hwndTemp, FALSE);
        ShowWindow (hwndTemp, SW_HIDE);

        //
        // Move the Change Type button over
        //

        pt.x = rc.left;
        pt.y = rc.top;
        ScreenToClient (hDlg, &pt);

        SetWindowPos (GetDlgItem (hDlg, IDC_UP_TYPE),
                      HWND_TOP, pt.x, pt.y, 0, 0,
                      SWP_NOSIZE | SWP_NOZORDER);

    }

    if (IsOS(OS_ANYSERVER))
    {
        //
        // Adjust the text displayed for the Users & Passwords link.
        // There is no Control Panel applet per se on Server.  The functionality
        // is accessed through MMC.
        //
        TCHAR szTitle[80];
        if (0 < LoadString(hInstance, IDS_UP_UPLINK_SERVER, szTitle, ARRAYSIZE(szTitle)))
        {
            SetWindowText(GetDlgItem(hDlg, IDC_UP_UPLINK), szTitle);
        }
    }
        
    //
    // Fill the user accounts
    //

    if (!FillListView (hDlg, bAdmin)) {
        SetCursor(hOldCursor);
        return FALSE;
    }
    
    SetCursor(hOldCursor);

    return TRUE;
}

//*************************************************************
//
//  AddUser()
//
//  Purpose:    Adds a new user to the listview
//
//
//  Parameters: hDlg            -   handle to the dialog box
//              lpSid           -   Sid (text form)
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              1/26/96     ericflo    Created
//
//*************************************************************

BOOL AddUser (HWND hDlg, LPTSTR lpSid, DWORD dwFlags)
{
    LONG Error;
    HKEY hKeyPolicy, hKeyProfile;
    TCHAR szBuffer[2*MAX_PATH];
    TCHAR szBuffer2[MAX_PATH];
    TCHAR szTemp[100];
    TCHAR szTemp2[100];
    DWORD dwTempSize = 100, dwTemp2Size = 100;
    PSID pSid;
    DWORD dwSize, dwType, dwProfileFlags;
    SID_NAME_USE SidName;
    LV_ITEM item;
    INT iItem;
    HWND hwndTemp;
    HKEY hkeyUser;
    HANDLE hFile;
    WIN32_FIND_DATA fd;
    LPTSTR lpEnd;
    SYSTEMTIME systime;
    FILETIME   ftLocal;
    TCHAR szProfileSize[20];
    INT iTypeID, iStatusID;
    DWORD dwProfileType, dwProfileStatus, dwSysProfileType=0;
    LPUSERINFO lpUserInfo;
    BOOL bCentralAvailable = FALSE, bAccountUnknown;
    TCHAR szExcludeList[2*MAX_PATH+1];
    LPTSTR lpExcludeList = NULL;    

    //
    // Open the user's info
    //

    wsprintf (szBuffer, TEXT("%s\\%s"), PROFILE_MAPPING, lpSid);

    Error = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         szBuffer,
                         0,
                         KEY_READ,
                         &hkeyUser);

    if (Error != ERROR_SUCCESS) {
        return FALSE;
    }

    //
    // If PI_HIDEPROFILE flag is set then do not display
    // the user in system applet
    //

    dwSize = sizeof(DWORD);
    Error = RegQueryValueEx (hkeyUser,
                             TEXT("Flags"),
                             NULL,
                             &dwType,
                             (LPBYTE) &dwProfileFlags,
                             &dwSize);

    if (Error == ERROR_SUCCESS && (dwProfileFlags & PI_HIDEPROFILE)) {
        RegCloseKey (hkeyUser);
        return FALSE;
    }
   

    //
    // Query for the user's central profile location
    //

    dwSize = MAX_PATH * sizeof(TCHAR);
    Error = RegQueryValueEx (hkeyUser,
                             TEXT("CentralProfile"),
                             NULL,
                             &dwType,
                             (LPBYTE) szBuffer2,
                             &dwSize);

    if ((Error == ERROR_SUCCESS) && (szBuffer2[0] != TEXT('\0'))) {
        bCentralAvailable = TRUE;
    }


    //
    // Query for the user's local profile
    //

    dwSize = MAX_PATH * sizeof(TCHAR);
    Error = RegQueryValueEx (hkeyUser,
                             TEXT("ProfileImagePath"),
                             NULL,
                             &dwType,
                             (LPBYTE) szBuffer2,
                             &dwSize);

    if (Error != ERROR_SUCCESS) {
        RegCloseKey (hkeyUser);
        return FALSE;
    }


    //
    // Profile paths need to be expanded
    //

    ExpandEnvironmentStrings (szBuffer2, szBuffer, MAX_PATH);
    lstrcpy (szBuffer2, szBuffer);


    //
    // Test if the directory exists.
    //

    hFile = FindFirstFile (szBuffer, &fd);

    if (hFile == INVALID_HANDLE_VALUE) {
        RegCloseKey (hkeyUser);
        return FALSE;
    }

    FindClose (hFile);


    //
    // Get the time stamp of the profile
    //

    lpEnd = CheckSlash (szBuffer);
    lstrcpy (lpEnd, TEXT("ntuser.dat"));


    //
    // Look for a normal user profile
    //

    hFile = FindFirstFile (szBuffer, &fd);

    if (hFile == INVALID_HANDLE_VALUE) {

        //
        // Try a mandatory user profile
        //

        lstrcpy (lpEnd, TEXT("ntuser.man"));

        hFile = FindFirstFile (szBuffer, &fd);

        if (hFile == INVALID_HANDLE_VALUE) {
            RegCloseKey (hkeyUser);
            return FALSE;
        }
    }

    FindClose (hFile);
    *lpEnd = TEXT('\0');

    //
    // Get the exclusionlist from the registry or ini files
    //

    if (dwFlags & PRF_USERSID)
        ReadExclusionList(szExcludeList, 2*MAX_PATH);
    else
        ReadExclusionListFromIniFile(szBuffer, szExcludeList, 2*MAX_PATH);


    //
    // Convert the exclusionlist read from the registry to a Null terminated list
    // readable by recursedirectory.
    //

    if (szExcludeList[0] != TEXT('\0'))
        lpExcludeList = ConvertExclusionList (szBuffer, szExcludeList);
    else
        lpExcludeList = NULL;

    //
    // Get the profile size
    //

    g_dwProfileSize = 0;

    *lpEnd = TEXT('\0');

    if (!RecurseDirectory (szBuffer, lpExcludeList)) {
        RegCloseKey (hkeyUser);
        if (lpExcludeList) {
            LocalFree (lpExcludeList);
        }

        return FALSE;
    }

    StrFormatByteSize((LONGLONG)g_dwProfileSize, szProfileSize, ARRAYSIZE(szProfileSize));


    //
    // check out the state information to determine profile status.
    // If the user is not logged on currently then report the status
    // of last session.
    //

    Error = RegQueryValueEx (hkeyUser,
                             TEXT("State"),
                             NULL,
                             &dwType,
                             (LPBYTE) &dwSysProfileType,
                             &dwSize);


    //
    // The constants being used come from
    // windows\gina\userenv\profile\profile.h
    //

    if (dwSysProfileType & 0x00008000) {
        dwProfileStatus = USERINFO_BACKUP;
    }
    else if (dwSysProfileType & 0x00000001) {
        dwProfileStatus = USERINFO_MANDATORY;
    } 
    else if ((dwSysProfileType & 0x00000800) ||
             (dwSysProfileType & 0x00000080)) {
        dwProfileStatus = USERINFO_TEMP;
    }
    else if (dwSysProfileType & 0x00000010) {
        dwProfileStatus = USERINFO_FLOATING;
    } 
    else {
        dwProfileStatus = USERINFO_LOCAL;
    }

    if (dwSysProfileType & 0x00000001) {
        dwProfileType = USERINFO_MANDATORY;
    } 
    else {
    
        if (bCentralAvailable) {
            dwProfileType = USERINFO_FLOATING;
        } 
        else {
            dwProfileType = USERINFO_LOCAL;
        }

        // Check User Preference
        dwSize = sizeof(dwProfileType);
        Error = RegQueryValueEx (hkeyUser,
                                 TEXT("UserPreference"),
                                 NULL,
                                 &dwType,
                                 (LPBYTE) &dwProfileType,
                                 &dwSize);

        // Check User Preference in .bak if exist
        wsprintf (szBuffer, TEXT("%s\\%s.bak"), PROFILE_MAPPING, lpSid);
        Error = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                             szBuffer,
                             0,
                             KEY_READ,
                             &hKeyProfile);


        if (Error == ERROR_SUCCESS) {

            dwSize = sizeof(dwProfileType);
            RegQueryValueEx(hKeyProfile,
                            TEXT("UserPreference"),
                            NULL,
                            &dwType,
                            (LPBYTE) &dwProfileType,
                            &dwSize);

            RegCloseKey (hKeyProfile);
        }

        // Check machine policy for disabling roaming profile
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         SYSTEM_POLICIES_KEY,
                         0, KEY_READ,
                         &hKeyPolicy) == ERROR_SUCCESS) {
            DWORD dwTmpVal, dwSize, dwType;

            dwSize = sizeof(dwTmpVal);
            Error = RegQueryValueEx(hKeyPolicy,
                            PROFILE_LOCALONLY,
                            NULL, &dwType,
                            (LPBYTE) &dwTmpVal,
                            &dwSize);

            RegCloseKey (hKeyPolicy);
            if (Error == ERROR_SUCCESS && dwTmpVal == 1) {
                dwProfileType = USERINFO_LOCAL;
            }
        }

        if (dwProfileType == USERINFO_FLOATING) {

            BOOL bReadOnly = FALSE;
            HKEY hSubKey;

            //
            // Check for a roaming profile security/read only preference
            //

            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, WINLOGON_KEY, 0, KEY_READ,
                             &hSubKey) == ERROR_SUCCESS) {

                dwSize = sizeof(bReadOnly);
                RegQueryValueEx(hSubKey, READONLY_RUP, NULL, &dwType,
                                (LPBYTE) &bReadOnly, &dwSize);

                RegCloseKey(hSubKey);
            }


            //
            // Check for a roaming profile security/read only policy
            //

            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, SYSTEM_POLICIES_KEY, 0, KEY_READ,
                             &hSubKey) == ERROR_SUCCESS) {

                dwSize = sizeof(bReadOnly);
                RegQueryValueEx(hSubKey, READONLY_RUP, NULL, &dwType,
                                (LPBYTE) &bReadOnly, &dwSize);
                RegCloseKey(hSubKey);
            }


            if (bReadOnly) {
                dwProfileType = USERINFO_READONLY;
            }
        }           
    }        

    switch (dwProfileStatus) {
        case USERINFO_MANDATORY:
            iStatusID = IDS_UP_MANDATORY;
            break;

        case USERINFO_BACKUP:
            iStatusID = IDS_UP_BACKUP;
            break;

        case USERINFO_TEMP:
            iStatusID = IDS_UP_TEMP;
            break;

        case USERINFO_FLOATING:
            iStatusID = IDS_UP_FLOATING;
            break;

        default:
            iStatusID = IDS_UP_LOCAL;
            break;
    }

    switch (dwProfileType) {
        case USERINFO_MANDATORY:
            iTypeID = IDS_UP_MANDATORY;
            break;

        case USERINFO_READONLY:
            iTypeID = IDS_UP_READONLY;
            break;

        case USERINFO_FLOATING:
            iTypeID = IDS_UP_FLOATING;
            break;

        default:
            iTypeID = IDS_UP_LOCAL;
            break;
    }

    //
    // Get the friendly display name
    //

    Error = RegQueryValueEx (hkeyUser, TEXT("Sid"), NULL, &dwType, NULL, &dwSize);

    if (Error != ERROR_SUCCESS) {
        RegCloseKey (hkeyUser);
        return FALSE;
    }


    pSid = MemAlloc (LPTR, dwSize);

    if (!pSid) {
        RegCloseKey (hkeyUser);
        return FALSE;
    }


    Error = RegQueryValueEx (hkeyUser,
                             TEXT("Sid"),
                             NULL,
                             &dwType,
                             (LPBYTE)pSid,
                             &dwSize);

    if (Error != ERROR_SUCCESS) {
        RegCloseKey (hkeyUser);
        return FALSE;
    }


    //
    // Get the friendly names
    //

    szTemp[0] = TEXT('\0');

    if (!LookupAccountSid (NULL, pSid, szTemp, &dwTempSize,
                           szTemp2, &dwTemp2Size, &SidName)) {

        //
        // Unknown account
        //

        LoadString (hInstance, IDS_UP_ACCUNKNOWN, szBuffer, MAX_PATH);
        bAccountUnknown = TRUE;

    } else {

        if (szTemp[0] != TEXT('\0')) {
            //
            // Build the display name
            //

            wsprintf (szBuffer, TEXT("%s\\%s"), szTemp2, szTemp);
            bAccountUnknown = FALSE;
        } else {

            //
            // Account deleted.
            //

            LoadString (hInstance, IDS_UP_ACCDELETED, szBuffer, MAX_PATH);
            bAccountUnknown = TRUE;
        }
    }


    //
    // Allocate a UserInfo structure
    //

    lpUserInfo = (LPUSERINFO) MemAlloc(LPTR, (sizeof(USERINFO) +
                                       (lstrlen (lpSid) + 1) * sizeof(TCHAR) +
                                       (lstrlen (szBuffer2) + 1) * sizeof(TCHAR) + 
                                       (lstrlen (szBuffer) + 1) * sizeof(TCHAR)));

    if (!lpUserInfo) {
        MemFree (pSid);
        RegCloseKey (hkeyUser);
        return FALSE;
    }

    lpUserInfo->dwFlags = (bCentralAvailable ? USERINFO_FLAG_CENTRAL_AVAILABLE : 0);
    lpUserInfo->dwFlags |= (bAccountUnknown ? USERINFO_FLAG_ACCOUNT_UNKNOWN : 0);    
    lpUserInfo->lpSid = (LPTSTR)((LPBYTE)lpUserInfo + sizeof(USERINFO));
    lpUserInfo->lpProfile = (LPTSTR) (lpUserInfo->lpSid + lstrlen(lpSid) + 1);
    lpUserInfo->lpUserName = (LPTSTR) (lpUserInfo->lpProfile + lstrlen(szBuffer2) + 1);

    lstrcpy (lpUserInfo->lpSid, lpSid);
    lstrcpy (lpUserInfo->lpProfile, szBuffer2);
    lpUserInfo->dwProfileType = dwProfileType;
    lpUserInfo->dwProfileStatus = dwProfileStatus;
    lstrcpy (lpUserInfo->lpUserName, szBuffer);


    //
    // Add the item to the listview
    //

    hwndTemp = GetDlgItem (hDlg, IDC_UP_LISTVIEW);


    item.mask = LVIF_TEXT | LVIF_PARAM;
    item.iItem = 0;
    item.iSubItem = 0;
    item.pszText = szBuffer;
    item.lParam = (LPARAM) lpUserInfo;

    iItem = ListView_InsertItem (hwndTemp, &item);


    //
    // Add the profile size
    //

    item.mask = LVIF_TEXT;
    item.iItem = iItem;
    item.iSubItem = 1;
    item.pszText = szProfileSize;

    SendMessage (hwndTemp, LVM_SETITEMTEXT, iItem, (LPARAM) &item);


    //
    // Add the profile type
    //

    LoadString (hInstance, iTypeID, szTemp, 100);

    item.mask = LVIF_TEXT;
    item.iItem = iItem;
    item.iSubItem = 2;
    item.pszText = szTemp;

    SendMessage (hwndTemp, LVM_SETITEMTEXT, iItem, (LPARAM) &item);

    //
    // Add the profile status
    //

    LoadString (hInstance, iStatusID, szTemp, 100);

    item.mask = LVIF_TEXT;
    item.iItem = iItem;
    item.iSubItem = 3;
    item.pszText = szTemp;

    SendMessage (hwndTemp, LVM_SETITEMTEXT, iItem, (LPARAM) &item);


    //
    // Convert it to local time
    //

    if (!FileTimeToLocalFileTime(&fd.ftLastAccessTime, &ftLocal)) {
        ftLocal = fd.ftLastAccessTime;
    }


    //
    // Add the time/date stamp
    //

    FileTimeToSystemTime (&ftLocal, &systime);

    GetDateFormat (LOCALE_USER_DEFAULT, DATE_SHORTDATE, &systime,
                    NULL, szBuffer, MAX_PATH);


    item.mask = LVIF_TEXT;
    item.iItem = iItem;
    item.iSubItem = 4;
    item.pszText = szBuffer;

    SendMessage (hwndTemp, LVM_SETITEMTEXT, iItem, (LPARAM) &item);


    //
    // Free the sid
    //

    MemFree (pSid);


    if (lpExcludeList) {
        LocalFree (lpExcludeList);
    }

    RegCloseKey (hkeyUser);


    return TRUE;
}

//*************************************************************
//
//  FillListView()
//
//  Purpose:    Fills the listview with either all the profiles
//              or just the current user profile depending if
//              the user has Admin privilages
//
//  Parameters: hDlg            -   Dialog box handle
//              bAdmin          -   User an admin
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              1/26/96     ericflo    Created
//
//*************************************************************

BOOL FillListView (HWND hDlg, BOOL bAdmin)
{
    LV_ITEM item;
    BOOL bRetVal = FALSE;
    LPTSTR lpUserSid;

    lpUserSid = GetSidString();

    //
    // If the current user has admin privilages, then
    // he/she can see all the profiles on this machine,
    // otherwise the user only gets their profile.
    //

    if (bAdmin) {

        DWORD SubKeyIndex = 0;
        TCHAR SubKeyName[100];
        DWORD cchSubKeySize;
        HKEY hkeyProfiles;
        LONG Error;


        //
        // Open the profile list
        //

        Error = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                             PROFILE_MAPPING,
                             0,
                             KEY_READ,
                             &hkeyProfiles);

        if (Error != ERROR_SUCCESS) {
            if (lpUserSid)
                DeleteSidString (lpUserSid);
            return FALSE;
        }


        cchSubKeySize = 100;

        while (TRUE) {

            //
            // Get the next sub-key name
            //

            Error = RegEnumKey(hkeyProfiles, SubKeyIndex, SubKeyName, cchSubKeySize);


            if (Error != ERROR_SUCCESS) {

                if (Error == ERROR_NO_MORE_ITEMS) {

                    //
                    // Successful end of enumeration
                    //

                    Error = ERROR_SUCCESS;

                }

                break;
            }


            if ((lpUserSid) && (lstrcmp(SubKeyName, lpUserSid) == 0))
                AddUser (hDlg, SubKeyName, PRF_USERSID);
            else
                AddUser (hDlg, SubKeyName, 0);


            //
            // Go enumerate the next sub-key
            //

            SubKeyIndex ++;
        }

        //
        // Close the registry
        //

        RegCloseKey (hkeyProfiles);

        bRetVal = ((Error == ERROR_SUCCESS) ? TRUE : FALSE);

    } else {

        //
        // The current user doesn't have admin privilages
        //

        if (lpUserSid) {
            AddUser (hDlg, lpUserSid, PRF_USERSID);
            bRetVal = TRUE;
        }
    }

    if (bRetVal) {
        //
        // Select the first item
        //

        item.mask = LVIF_STATE;
        item.iItem = 0;
        item.iSubItem = 0;
        item.state = LVIS_SELECTED | LVIS_FOCUSED;
        item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

        SendDlgItemMessage (hDlg, IDC_UP_LISTVIEW,
                            LVM_SETITEMSTATE, 0, (LPARAM) &item);
    }

    if (lpUserSid)
        DeleteSidString (lpUserSid);

    return (bRetVal);
}

//*************************************************************
//
//  CheckSemicolon()
//
//  Purpose:    Checks for an ending slash and adds one if
//              it is missing.
//
//  Parameters: lpDir   -   directory
//
//  Return:     Pointer to the end of the string
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericlfo    Created
//
//*************************************************************
LPTSTR CheckSemicolon (LPTSTR lpDir)
{
    LPTSTR lpEnd;

    lpEnd = lpDir + lstrlen(lpDir);

    if (*(lpEnd - 1) != TEXT(';')) {
        *lpEnd =  TEXT(';');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }

    return lpEnd;
}

//*************************************************************
//
//  ReadExclusionList()
//
//  Purpose:    Reads the exclusionlist for the user from the 
//              hkcu part of the registry
//
//  Parameters: szExclusionList - Buffer for exclusionList to be read into
//              dwSize          - Size of the buffer
//
//  Return:     FALSE on error
//
//*************************************************************

BOOL ReadExclusionList(LPTSTR szExcludeList, DWORD dwExclSize)
{
    TCHAR szExcludeList2[MAX_PATH];
    TCHAR szExcludeList1[MAX_PATH];
    HKEY  hKey;
    DWORD dwSize, dwType;

    //
    // Check for a list of directories to exclude both user preferences
    // and user policy
    //

    szExcludeList1[0] = TEXT('\0');
    if (RegOpenKeyEx (HKEY_CURRENT_USER,
                      TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
                      0, KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = sizeof(szExcludeList1);
        RegQueryValueEx (hKey,
                         TEXT("ExcludeProfileDirs"),
                         NULL,
                         &dwType,
                         (LPBYTE) szExcludeList1,
                         &dwSize);

        RegCloseKey (hKey);
    }

    szExcludeList2[0] = TEXT('\0');
    if (RegOpenKeyEx (HKEY_CURRENT_USER,
                      SYSTEM_POLICIES_KEY,
                      0, KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = sizeof(szExcludeList2);
        RegQueryValueEx (hKey,
                         TEXT("ExcludeProfileDirs"),
                         NULL,
                         &dwType,
                         (LPBYTE) szExcludeList2,
                         &dwSize);

        RegCloseKey (hKey);
    }


    //
    // Merge the user preferences and policy together
    //

    szExcludeList[0] = TEXT('\0');

    if (szExcludeList1[0] != TEXT('\0')) {
        CheckSemicolon(szExcludeList1);
        lstrcpy (szExcludeList, szExcludeList1);
    }

    if (szExcludeList2[0] != TEXT('\0')) {
        lstrcat (szExcludeList, szExcludeList2);
    }

    return TRUE;
}

//*************************************************************
//
//  ReadExclusionListFromIniFile()
//
//  Purpose:    Reads the exclusionlist for the user from the 
//              ntuser.ini from the local profile
//
//  Parameters: 
//              (in) lpSourceDir     - Profile Directory
//                   szExclusionList - Buffer for exclusionList to be read into
//                   dwSize          - Size of the buffer
//
//  Return:     FALSE on error
//
//
//*************************************************************

BOOL ReadExclusionListFromIniFile(LPCTSTR lpSourceDir, LPTSTR szExcludeList, DWORD dwExclSize)
{
    TCHAR szNTUserIni[MAX_PATH];
    LPTSTR lpEnd;

    //
    // Get the exclusion list from the cache
    //

    szExcludeList[0] = TEXT('\0');

    lstrcpy (szNTUserIni, lpSourceDir);
    lpEnd = CheckSlash (szNTUserIni);
    lstrcpy(lpEnd, c_szNTUserIni);

    GetPrivateProfileString (PROFILE_GENERAL_SECTION,
                             PROFILE_EXCLUSION_LIST,
                             TEXT(""), szExcludeList,
                             dwExclSize,
                             szNTUserIni);

    return TRUE;
}

//*************************************************************
//
//  ConvertExclusionList()
//
//  Purpose:    Converts the semi-colon profile relative exclusion
//              list to fully qualified null terminated exclusion
//              list
//
//  Parameters: lpSourceDir     -  Profile root directory
//              lpExclusionList -  List of directories to exclude
//
//  Return:     List if successful
//              NULL if an error occurs
//
//*************************************************************

LPTSTR ConvertExclusionList (LPCTSTR lpSourceDir, LPCTSTR lpExclusionList)
{
    LPTSTR lpExcludeList = NULL, lpInsert, lpEnd, lpTempList;
    LPCTSTR lpTemp, lpDir;
    TCHAR szTemp[MAX_PATH];
    DWORD dwSize = 2;  // double null terminator
    DWORD dwStrLen;


    //
    // Setup a temp buffer to work with
    //

    lstrcpy (szTemp, lpSourceDir);
    lpEnd = CheckSlash (szTemp);


    //
    // Loop through the list
    //

    lpTemp = lpDir = lpExclusionList;

    while (*lpTemp) {

        //
        // Look for the semicolon separator
        //

        while (*lpTemp && ((*lpTemp) != TEXT(';'))) {
            lpTemp++;
        }


        //
        // Remove any leading spaces
        //

        while (*lpDir == TEXT(' ')) {
            lpDir++;
        }


        //
        // Put the directory name on the temp buffer
        //

        lstrcpyn (lpEnd, lpDir, (int)(lpTemp - lpDir + 1));


        //
        // Add the string to the exclusion list
        //

        if (lpExcludeList) {

            dwStrLen = lstrlen (szTemp) + 1;
            dwSize += dwStrLen;

            lpTempList = (LPTSTR) LocalReAlloc (lpExcludeList, dwSize * sizeof(TCHAR),
                                       LMEM_MOVEABLE | LMEM_ZEROINIT);

            if (!lpTempList) {
                LocalFree (lpExcludeList);
                lpExcludeList = NULL;
                goto Exit;
            }

            lpExcludeList = lpTempList;

            lpInsert = lpExcludeList + dwSize - dwStrLen - 1;
            lstrcpy (lpInsert, szTemp);

        } else {

            dwSize += lstrlen (szTemp);
            lpExcludeList = (LPTSTR) LocalAlloc (LPTR, dwSize * sizeof(TCHAR));

            if (!lpExcludeList) {
                goto Exit;
            }

            lstrcpy (lpExcludeList, szTemp);
        }


        //
        // If we are at the end of the exclusion list, we're done
        //

        if (!(*lpTemp)) {
            goto Exit;
        }


        //
        // Prep for the next entry
        //

        lpTemp++;
        lpDir = lpTemp;
    }

Exit:

    return lpExcludeList;
}

//*************************************************************
//
//  RecurseDirectory()
//
//  Purpose:    Recurses through the subdirectories counting the size.
//
//  Parameters: lpDir     -   Directory
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              1/30/96     ericflo    Created
//
// Notes:
//      The buffer size expected is MAX_PATH+4 for some internal processing
// We should fix this to be better post Win 2K.
//*************************************************************

BOOL RecurseDirectory (LPTSTR lpDir, LPTSTR lpExcludeList)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA fd;
    LPTSTR lpEnd, lpTemp;
    BOOL bResult = TRUE;
    BOOL bSkip;


    //
    // Setup the ending pointer
    //

    lpEnd = CheckSlash (lpDir);


    //
    // Append *.* to the source directory
    //

    lstrcpy(lpEnd, TEXT("*.*"));



    //
    // Search through the source directory
    //

    hFile = FindFirstFile(lpDir, &fd);

    if (hFile == INVALID_HANDLE_VALUE) {

        if ( (GetLastError() == ERROR_FILE_NOT_FOUND) ||
             (GetLastError() == ERROR_PATH_NOT_FOUND) ) {

            //
            // bResult is already initialized to TRUE, so
            // just fall through.
            //

        } else {

            bResult = FALSE;
        }

        goto RecurseDir_Exit;
    }


    do {

        //
        // Append the file / directory name to the working buffer
        //

        // skip the file if the path > MAX_PATH
        
        if ((1+lstrlen(fd.cFileName)+lstrlen(lpDir)+lstrlen(TEXT("\\*.*"))) >= 2*MAX_PATH) {
            continue;
        }

        lstrcpy (lpEnd, fd.cFileName);


        if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

            //
            // Check for "." and ".."
            //

            if (!lstrcmpi(fd.cFileName, TEXT("."))) {
                continue;
            }

            if (!lstrcmpi(fd.cFileName, TEXT(".."))) {
                continue;
            }


            //
            // Check if this directory should be excluded
            //

            if (lpExcludeList) {

                bSkip = FALSE;
                lpTemp = lpExcludeList;

                while (*lpTemp) {

                    if (lstrcmpi (lpTemp, lpDir) == 0) {
                        bSkip = TRUE;
                        break;
                    }

                    lpTemp += lstrlen (lpTemp) + 1;
                }

                if (bSkip) 
                    continue;
            }

            //
            // Found a directory.
            //
            // 1)  Change into that subdirectory on the source drive.
            // 2)  Recurse down that tree.
            // 3)  Back up one level.
            //

            //
            // Recurse the subdirectory
            //

            if (!RecurseDirectory(lpDir, lpExcludeList)) {
                bResult = FALSE;
                goto RecurseDir_Exit;
            }

        } else {

            //
            // Found a file, add the filesize
            //

            g_dwProfileSize += fd.nFileSizeLow;
        }


        //
        // Find the next entry
        //

    } while (FindNextFile(hFile, &fd));


RecurseDir_Exit:

    //
    // Remove the file / directory name appended above
    //

    *lpEnd = TEXT('\0');


    //
    // Close the search handle
    //

    if (hFile != INVALID_HANDLE_VALUE) {
        FindClose(hFile);
    }

    return bResult;
}

//*************************************************************
//
//  UPCleanUp()
//
//  Purpose:    Free's resources for this dialog box
//
//  Parameters: hDlg    -   Dialog box handle
//
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              1/31/96     ericflo    Created
//
//*************************************************************

VOID UPCleanUp (HWND hDlg)
{
    int           i, n;
    HWND          hwndTemp;
    LPUSERINFO    lpUserInfo;
    LV_ITEM       item;


    //
    //  Free memory used for the listview items
    //

    hwndTemp = GetDlgItem (hDlg, IDC_UP_LISTVIEW);
    n = (int)SendMessage (hwndTemp, LVM_GETITEMCOUNT, 0, 0L);

    item.mask = LVIF_PARAM;
    item.iSubItem = 0;

    for (i = 0; i < n; i++) {

        item.iItem = i;

        if (SendMessage (hwndTemp, LVM_GETITEM, 0, (LPARAM) &item)) {
            lpUserInfo = (LPUSERINFO) item.lParam;

        } else {
            lpUserInfo = NULL;
        }

        if (lpUserInfo) {
            MemFree (lpUserInfo);
        }
    }
}

//*************************************************************
//
//  UPSave()
//
//  Purpose:    Saves the settings
//
//  Parameters: hDlg    -   Dialog box handle
//
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              1/31/96     ericflo    Created
//
//*************************************************************

VOID UPSave (HWND hDlg)
{
    int           i, n;
    HWND          hwndTemp;
    LPUSERINFO    lpUserInfo;
    LV_ITEM       item;
    TCHAR         szBuffer[MAX_PATH];
    HKEY          hkeyUser;
    LONG          Error;


    //
    //  Save type info
    //

    hwndTemp = GetDlgItem (hDlg, IDC_UP_LISTVIEW);
    n = (int)SendMessage (hwndTemp, LVM_GETITEMCOUNT, 0, 0L);

    item.mask = LVIF_PARAM;
    item.iSubItem = 0;

    for (i = 0; i < n; i++) {

        item.iItem = i;

        if (SendMessage (hwndTemp, LVM_GETITEM, 0, (LPARAM) &item)) {
            lpUserInfo = (LPUSERINFO) item.lParam;

        } else {
            lpUserInfo = NULL;
        }

        if (lpUserInfo) {

            if (lpUserInfo->dwFlags & USERINFO_FLAG_DIRTY) {

                lpUserInfo->dwFlags &= ~USERINFO_FLAG_DIRTY;

                wsprintf (szBuffer, TEXT("%s\\%s"), PROFILE_MAPPING,
                          lpUserInfo->lpSid);

                Error = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                     szBuffer,
                                     0,
                                     KEY_WRITE,
                                     &hkeyUser);

                if (Error != ERROR_SUCCESS) {
                    continue;
                }

                RegSetValueEx (hkeyUser,
                               TEXT("UserPreference"),
                               0,
                               REG_DWORD,
                               (LPBYTE) &lpUserInfo->dwProfileType,
                               sizeof(DWORD));

                RegCloseKey(hkeyUser);
            }
        }
    }
}

//*************************************************************
//
//  IsProfileInUse()
//
//  Purpose:    Determines if the given profile is currently in use
//
//  Parameters: lpSid   -   Sid (text) to test
//
//  Return:     TRUE if in use
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/7/96      ericflo    Created
//
//*************************************************************

BOOL IsProfileInUse (LPTSTR lpSid)
{
    LONG lResult;
    HKEY hkeyProfile;


    lResult = RegOpenKeyEx (HKEY_USERS, lpSid, 0, KEY_READ, &hkeyProfile);

    if (lResult == ERROR_SUCCESS) {
        RegCloseKey (hkeyProfile);
        return TRUE;
    }

    return FALSE;
}

void UPDoItemChanged(HWND hDlg, int idCtl)
{
    int     selection;
    HWND    hwndTemp;
    LPUSERINFO lpUserInfo;
    LV_ITEM item;


    hwndTemp = GetDlgItem (hDlg, idCtl);

    selection = GetSelectedItem (hwndTemp);

    if (selection != -1)
    {
        item.mask = LVIF_PARAM;
        item.iItem = selection;
        item.iSubItem = 0;

        if (SendMessage (hwndTemp, LVM_GETITEM, 0, (LPARAM) &item)) {
            lpUserInfo = (LPUSERINFO) item.lParam;

        } else {
            lpUserInfo = NULL;
        }

        if (lpUserInfo) {

            //
            //  Set the "Delete" button state
            //

            if (IsProfileInUse(lpUserInfo->lpSid)) {
                EnableWindow (GetDlgItem (hDlg, IDC_UP_DELETE), FALSE);

            } else {
                EnableWindow (GetDlgItem (hDlg, IDC_UP_DELETE), TRUE);
            }


            //
            // Set the "Change Type" button state
            //

            OSVERSIONINFOEXW version;
            version.dwOSVersionInfoSize = sizeof(version);

            if (GetVersionEx((LPOSVERSIONINFO)&version) && 
                (version.wSuiteMask & VER_SUITE_PERSONAL)) {
                ShowWindow(GetDlgItem (hDlg, IDC_UP_TYPE), SW_HIDE);
            }
            else if((lpUserInfo->dwProfileType == USERINFO_MANDATORY) || 
                    (lpUserInfo->dwProfileType == USERINFO_BACKUP)) {
                EnableWindow (GetDlgItem (hDlg, IDC_UP_TYPE), FALSE);
            } else {
                EnableWindow (GetDlgItem (hDlg, IDC_UP_TYPE), TRUE);
            }

            //
            // Set the "Copy To" button state
            //

            if ((lpUserInfo->dwFlags & USERINFO_FLAG_ACCOUNT_UNKNOWN) ||
                IsProfileInUse(lpUserInfo->lpSid)) {
                EnableWindow (GetDlgItem (hDlg, IDC_UP_COPY), FALSE);
            } else {
                EnableWindow (GetDlgItem (hDlg, IDC_UP_COPY), TRUE);
            }
        }
    }
    else {

        //
        // If nothing is selected set all buttons to inactive
        //
        
        EnableWindow (GetDlgItem (hDlg, IDC_UP_DELETE), FALSE);
        EnableWindow (GetDlgItem (hDlg, IDC_UP_TYPE), FALSE);
        EnableWindow (GetDlgItem (hDlg, IDC_UP_COPY), FALSE);
    }
}

//*************************************************************

void 
UPOnLink(WPARAM wParam)
{
    switch(wParam)
    {
    case IDC_UP_UPLINK:
        {
            SHELLEXECUTEINFO execinfo = {0};

            execinfo.cbSize = sizeof(execinfo);
            execinfo.nShow = SW_SHOW;
            execinfo.lpVerb = TEXT("open");
            execinfo.lpFile = TEXT("control");
            execinfo.lpParameters = TEXT("userpasswords");

            ShellExecuteEx(&execinfo);
        }
        break;
    default:
        break;
    }
    
}

//*************************************************************
//
//  UPDeleteProfile()
//
//  Purpose:    Deletes a user's profile
//
//  Parameters: hDlg    -   Dialog box handle
//
//  Return:
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/8/96      ericflo    Created
//
//*************************************************************

void UPDeleteProfile(HWND hDlg)
{
    int     selection;
    HWND    hwndTemp;
    LPUSERINFO lpUserInfo;
    LV_ITEM item;
    TCHAR   szName[100];
    TCHAR   szBuffer1[100];
    TCHAR   szBuffer2[200];
    HCURSOR hOldCursor;


    //
    // Get the selected profile
    //

    hwndTemp = GetDlgItem (hDlg, IDC_UP_LISTVIEW);

    selection = GetSelectedItem (hwndTemp);

    if (selection == -1) {
        return;
    }

    item.mask = LVIF_PARAM;
    item.iItem = selection;
    item.iSubItem = 0;

    if (SendMessage (hwndTemp, LVM_GETITEM, 0, (LPARAM) &item)) {
        lpUserInfo = (LPUSERINFO) item.lParam;

    } else {
        lpUserInfo = NULL;
    }

    if (!lpUserInfo) {
        return;
    }


    //
    // Confirm that the user really wants to delete the profile
    //

    szBuffer1[0] = TEXT('\0');
    ListView_GetItemText (hwndTemp, selection, 0, szName, 100);

    LoadString (hInstance, IDS_UP_CONFIRM, szBuffer1, 100);
    wsprintf (szBuffer2, szBuffer1, szName);

    LoadString (hInstance, IDS_UP_CONFIRMTITLE, szBuffer1, 100);
    if (MessageBox (hDlg, szBuffer2, szBuffer1,
                    MB_ICONQUESTION | MB_DEFBUTTON2| MB_YESNO) == IDNO) {
        return;
    }



    //
    // Delete the profile and remove the entry from the listview
    //

    hOldCursor = SetCursor (LoadCursor(NULL, IDC_WAIT));


    if (!DeleteProfile (lpUserInfo->lpSid, NULL, NULL)) {
        TCHAR szMsg[MAX_PATH];

        szMsg[0] = TEXT('\0');

        LoadString (hInstance, IDS_UP_DELETE_ERROR, szMsg, MAX_PATH-1);

        UPDisplayErrorMessage(hDlg, GetLastError(), szMsg);    
    }    


    if (ListView_DeleteItem(hwndTemp, selection)) {
        MemFree (lpUserInfo);
    }


    //
    // Select another item
    //

    if (selection > 0) {
        selection--;
    }

    item.mask = LVIF_STATE;
    item.iItem = selection;
    item.iSubItem = 0;
    item.state = LVIS_SELECTED | LVIS_FOCUSED;
    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

    SendDlgItemMessage (hDlg, IDC_UP_LISTVIEW,
                        LVM_SETITEMSTATE, selection, (LPARAM) &item);


    SetCursor(hOldCursor);
}


//*************************************************************
//
//  UPChangeType()
//
//  Purpose:    Display the "Change Type" dialog box
//
//  Parameters: hDlg    -   Dialog box handle
//
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/09/96     ericflo    Created
//
//*************************************************************

void UPChangeType(HWND hDlg)
{
    int     selection, iTypeID;
    HWND    hwndTemp;
    LPUSERINFO lpUserInfo;
    LV_ITEM item;
    TCHAR   szType[100];


    //
    // Get the selected profile
    //

    hwndTemp = GetDlgItem (hDlg, IDC_UP_LISTVIEW);

    selection = GetSelectedItem (hwndTemp);

    if (selection == -1) {
        return;
    }

    item.mask = LVIF_PARAM;
    item.iItem = selection;
    item.iSubItem = 0;

    if (SendMessage (hwndTemp, LVM_GETITEM, 0, (LPARAM) &item)) {
        lpUserInfo = (LPUSERINFO) item.lParam;

    } else {
        lpUserInfo = NULL;
    }

    if (!lpUserInfo) {
        return;
    }

    // if profile type is mandatory then don't display change type dialog box.
    // Although change type button is disabled for mandatory profile this function 
    // can be still executed with double clicking on profile item.

    if (lpUserInfo->dwProfileType == USERINFO_MANDATORY || 
        lpUserInfo->dwProfileType == USERINFO_BACKUP) {
        return;
    }

    //
    // Display the Change Type dialog
    //

    if (!DialogBoxParam (hInstance, MAKEINTRESOURCE(IDD_UP_TYPE), hDlg,
                         ChangeTypeDlgProc, (LPARAM)lpUserInfo)) {
        return;
    }


    //
    // Activate the Apply button
    //

    PropSheet_Changed(GetParent(hDlg), hDlg);


    //
    // Mark this item as 'dirty' so it will be saved
    //

    lpUserInfo->dwFlags |= USERINFO_FLAG_DIRTY;


    //
    // Fix the 'Type' field in the display
    //

    switch (lpUserInfo->dwProfileType) {
        case USERINFO_MANDATORY:
            iTypeID = IDS_UP_MANDATORY;
            break;

        case USERINFO_READONLY:
            iTypeID = IDS_UP_READONLY;
            break;

        case USERINFO_FLOATING:
            iTypeID = IDS_UP_FLOATING;
            break;

        default:
            iTypeID = IDS_UP_LOCAL;
            break;
    }


    LoadString (hInstance, iTypeID, szType, 100);

    item.mask = LVIF_TEXT;
    item.iItem = selection;
    item.iSubItem = 2;
    item.pszText = szType;

    SendMessage (hwndTemp, LVM_SETITEMTEXT, selection, (LPARAM) &item);

}

//*************************************************************
//
//  ChangeTypeDlgProc()
//
//  Purpose:    Dialog box procedure for changing the profile type
//
//  Parameters: hDlg    -   handle to the dialog box
//              uMsg    -   window message
//              wParam  -   wParam
//              lParam  -   lParam
//
//  Return:     TRUE if message was processed
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/9/96      ericflo    Created
//
//*************************************************************

INT_PTR APIENTRY ChangeTypeDlgProc (HWND hDlg, UINT uMsg,
                                 WPARAM wParam, LPARAM lParam)
{
    LPUSERINFO lpUserInfo;
    HKEY hKeyPolicy;

    switch (uMsg) {
        case WM_INITDIALOG:
           lpUserInfo = (LPUSERINFO) lParam;

           if (!lpUserInfo) {
               EndDialog(hDlg, FALSE);
           }
           else {
               TCHAR      szMsg[MAX_PATH], szMsg1[MAX_PATH];
               
               szMsg[0] = TEXT('\0');

               LoadString (hInstance, IDS_UP_CHANGETYPEMSG, szMsg, MAX_PATH);
               
               wsprintf (szMsg1, szMsg, lpUserInfo->lpUserName);

               SetDlgItemText (hDlg, IDC_UPTYPE_GROUP, szMsg1);
               
           }

           SetWindowLongPtr (hDlg, GWLP_USERDATA, (LPARAM) lpUserInfo);



           if (lpUserInfo->dwFlags & USERINFO_FLAG_CENTRAL_AVAILABLE) {

               if (lpUserInfo->dwProfileType == USERINFO_LOCAL) {
                   CheckRadioButton (hDlg, IDC_UPTYPE_LOCAL, IDC_UPTYPE_FLOAT,
                                     IDC_UPTYPE_LOCAL);

                   if (lpUserInfo->dwProfileStatus == USERINFO_TEMP) {
                       EnableWindow (GetDlgItem(hDlg, IDC_UPTYPE_FLOAT), FALSE);
                       EnableWindow (GetDlgItem(hDlg, IDOK), FALSE);
                       SetDefButton(hDlg, IDCANCEL);
                   }
                   else if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                    SYSTEM_POLICIES_KEY,
                                    0, KEY_READ,
                                    &hKeyPolicy) == ERROR_SUCCESS) {
                       DWORD dwTmpVal, dwSize, dwType;

                       dwSize = sizeof(dwTmpVal);
                       RegQueryValueEx(hKeyPolicy,
                                       PROFILE_LOCALONLY,
                                       NULL, &dwType,
                                       (LPBYTE) &dwTmpVal,
                                       &dwSize);

                       RegCloseKey (hKeyPolicy);
                       if (dwTmpVal == 1) {   
                           EnableWindow (GetDlgItem(hDlg, IDC_UPTYPE_FLOAT), FALSE);
                           EnableWindow (GetDlgItem(hDlg, IDOK), FALSE);
                           SetDefButton(hDlg, IDCANCEL);
                       }
                   }    

               }
               else if (lpUserInfo->dwProfileStatus == USERINFO_TEMP) {
                   CheckRadioButton (hDlg, IDC_UPTYPE_LOCAL, IDC_UPTYPE_FLOAT,
                                     IDC_UPTYPE_FLOAT);
                   EnableWindow (GetDlgItem(hDlg, IDC_UPTYPE_LOCAL), FALSE);
                   EnableWindow (GetDlgItem(hDlg, IDOK), FALSE);
                   SetDefButton(hDlg, IDCANCEL);
               }
               else {  // ProfileType is USERINFO_FLOATING
                   CheckRadioButton (hDlg, IDC_UPTYPE_LOCAL, IDC_UPTYPE_FLOAT,
                                     IDC_UPTYPE_FLOAT);
               }              
 
           } else {

               CheckRadioButton (hDlg, IDC_UPTYPE_LOCAL, IDC_UPTYPE_FLOAT,
                                 IDC_UPTYPE_LOCAL);
               EnableWindow (GetDlgItem(hDlg, IDC_UPTYPE_FLOAT), FALSE);
               EnableWindow (GetDlgItem(hDlg, IDOK), FALSE);
               SetDefButton(hDlg, IDCANCEL);
           }

           return TRUE;

        case WM_COMMAND:

          switch (LOWORD(wParam)) {
              case IDOK:

                  lpUserInfo = (LPUSERINFO) GetWindowLongPtr(hDlg, GWLP_USERDATA);

                  if (!lpUserInfo) {
                      EndDialog (hDlg, FALSE);
                      break;
                  }

                  //
                  // Determine what the user wants
                  //

                  if (IsDlgButtonChecked(hDlg, IDC_UPTYPE_LOCAL)) {
                      lpUserInfo->dwProfileType = USERINFO_LOCAL;
                  } else {
                      BOOL bReadOnly = FALSE;
                      HKEY hSubKey;
                      DWORD dwSize, dwType;

                      //
                      // Check for a roaming profile security/read only preference
                      //

                      if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, WINLOGON_KEY, 0, KEY_READ,
                                       &hSubKey) == ERROR_SUCCESS) {

                          dwSize = sizeof(bReadOnly);
                          RegQueryValueEx(hSubKey, READONLY_RUP, NULL, &dwType,
                                          (LPBYTE) &bReadOnly, &dwSize);

                          RegCloseKey(hSubKey);
                      }


                      //
                      // Check for a roaming profile security/read only policy
                      //

                      if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, SYSTEM_POLICIES_KEY, 0, KEY_READ,
                                       &hSubKey) == ERROR_SUCCESS) {

                          dwSize = sizeof(bReadOnly);
                          RegQueryValueEx(hSubKey, READONLY_RUP, NULL, &dwType,
                                          (LPBYTE) &bReadOnly, &dwSize);
                          RegCloseKey(hSubKey);
                      }


                      if (bReadOnly) {
                          lpUserInfo->dwProfileType = USERINFO_READONLY;
                      }
                      else {
                          lpUserInfo->dwProfileType = USERINFO_FLOATING;
                      }

                  }

                  EndDialog(hDlg, TRUE);
                  break;

              case IDCANCEL:
                  EndDialog(hDlg, FALSE);
                  break;

              default:
                  break;

          }
          break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
            (DWORD_PTR) (LPSTR) aUserProfileHelpIds);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (DWORD_PTR) (LPSTR) aUserProfileHelpIds);
            return (TRUE);

    }

    return (FALSE);
}

//*************************************************************
//
//  UPInitCopyDlg()
//
//  Purpose:    Initializes the copy profile dialog
//
//  Parameters: hDlg    -   Dialog box handle
//              lParam  -   lParam (lpUserInfo)
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/26/96     ericflo    Created
//
//*************************************************************

BOOL UPInitCopyDlg (HWND hDlg, LPARAM lParam)
{
    LPUSERINFO lpUserInfo;
    LPUPCOPYINFO lpUPCopyInfo;
    HKEY hKey;
    LONG lResult;
    TCHAR szBuffer[MAX_PATH];
    TCHAR szTemp[100];
    TCHAR szTemp2[100];
    DWORD dwTempSize = 100, dwTemp2Size = 100;
    PSID pSid;
    DWORD dwSize, dwType;
    SID_NAME_USE SidName;

    lpUserInfo = (LPUSERINFO) lParam;

    if (!lpUserInfo) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    //
    // Create a CopyInfo structure
    //

    lpUPCopyInfo = (LPUPCOPYINFO) MemAlloc(LPTR, sizeof(UPCOPYINFO));

    if (!lpUPCopyInfo) {
        return FALSE;
    }

    lpUPCopyInfo->dwFlags = 0;
    lpUPCopyInfo->lpUserInfo = lpUserInfo;
    lpUPCopyInfo->bDefaultSecurity = TRUE;


    //
    // Get the user's sid
    //

    wsprintf (szBuffer, TEXT("%s\\%s"), PROFILE_MAPPING, lpUserInfo->lpSid);
    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                            szBuffer,
                            0,
                            KEY_READ,
                            &hKey);

    if (lResult != ERROR_SUCCESS) {
        MemFree (lpUPCopyInfo);
        SetLastError(lResult);
        return FALSE;
    }

    //
    // Query for the sid size
    //

    dwSize = 0;
    lResult = RegQueryValueEx (hKey,
                               TEXT("Sid"),
                               NULL,
                               &dwType,
                               NULL,
                               &dwSize);

    if (lResult != ERROR_SUCCESS) {
        RegCloseKey (hKey);
        MemFree (lpUPCopyInfo);
        SetLastError(lResult);
        return FALSE;
    }


    //
    // Actually get the sid
    //

    pSid = MemAlloc (LPTR, dwSize);

    if (!pSid) {
        RegCloseKey (hKey);
        MemFree (lpUPCopyInfo);
        SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }

    lResult = RegQueryValueEx (hKey,
                               TEXT("Sid"),
                               NULL,
                               &dwType,
                               (LPBYTE) pSid,
                               &dwSize);

    if (lResult != ERROR_SUCCESS) {
        RegCloseKey (hKey);
        MemFree (pSid);
        MemFree (lpUPCopyInfo);
        SetLastError(lResult);
        return FALSE;
    }

    lpUPCopyInfo->pSid = pSid;

    RegCloseKey (hKey);


    //
    // Get the friendly name
    //

    if (!LookupAccountSid (NULL, pSid, szTemp, &dwTempSize,
                           szTemp2, &dwTemp2Size, &SidName)) {
        MemFree (pSid);
        MemFree (lpUPCopyInfo);
        return FALSE;
    }


    //
    // Display nothing in the edit control till user sets it
    // explicitly
    //

    szBuffer[0] = TEXT('\0');

    SetDlgItemText (hDlg, IDC_COPY_USER, szBuffer);



    //
    // Save the copyinfo structure in the extra words
    //

    SetWindowLongPtr (hDlg, GWLP_USERDATA, (LPARAM) lpUPCopyInfo);
    EnableWindow (GetDlgItem(hDlg, IDOK), FALSE);
    SetDefButton(hDlg, IDCANCEL);

    return TRUE;
}

//*************************************************************
//
//  UPCopyProfile()
//
//  Purpose:    Displays the copy profile dialog box
//
//  Parameters: hDlg    -   Dialog box handle
//
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/13/96     ericflo    Created
//
//*************************************************************

void UPCopyProfile(HWND hDlg)
{
    int     selection, iTypeID;
    HWND    hwndTemp;
    LPUSERINFO lpUserInfo;
    LV_ITEM item;


    //
    // Get the selected profile
    //

    hwndTemp = GetDlgItem (hDlg, IDC_UP_LISTVIEW);

    selection = GetSelectedItem (hwndTemp);

    if (selection == -1) {
        return;
    }

    item.mask = LVIF_PARAM;
    item.iItem = selection;
    item.iSubItem = 0;

    if (SendMessage (hwndTemp, LVM_GETITEM, 0, (LPARAM) &item)) {
        lpUserInfo = (LPUSERINFO) item.lParam;

    } else {
        lpUserInfo = NULL;
    }

    if (!lpUserInfo) {
        return;
    }

    //
    // Display the Copy Profile dialog
    //

    if (!DialogBoxParam (hInstance, MAKEINTRESOURCE(IDD_UP_COPY), hDlg,
                         UPCopyDlgProc, (LPARAM)lpUserInfo)) {
        return;
    }
}


//*************************************************************
//
//  UPCopyDlgProc()
//
//  Purpose:    Dialog box procedure for copying a profile
//
//  Parameters: hDlg    -   handle to the dialog box
//              uMsg    -   window message
//              wParam  -   wParam
//              lParam  -   lParam
//
//  Return:     TRUE if message was processed
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/13/96     ericflo    Created
//
//*************************************************************

INT_PTR APIENTRY UPCopyDlgProc (HWND hDlg, UINT uMsg,
                             WPARAM wParam, LPARAM lParam)
{
    LPUPCOPYINFO lpUPCopyInfo;
    WIN32_FILE_ATTRIBUTE_DATA fad;


    switch (uMsg) {
        case WM_INITDIALOG:

           if (!UPInitCopyDlg(hDlg, lParam)) {
               UPDisplayErrorMessage(hDlg, GetLastError(), NULL);
               EndDialog(hDlg, FALSE);
           }
           return TRUE;

        case WM_COMMAND:

          switch (LOWORD(wParam)) {
              case IDOK:
                  {
                  TCHAR szDir[MAX_PATH];
                  TCHAR szTemp[MAX_PATH];
                  HCURSOR hOldCursor;

                  lpUPCopyInfo = (LPUPCOPYINFO) GetWindowLongPtr(hDlg, GWLP_USERDATA);

                  if (!lpUPCopyInfo) {
                      EndDialog (hDlg, FALSE);
                      break;
                  }

                  GetDlgItemText (hDlg, IDC_COPY_PATH, szTemp, MAX_PATH);
                  if (ExpandEnvironmentStrings (szTemp, szDir, MAX_PATH) > MAX_PATH) {
                     lstrcpy (szDir, szTemp);
                  }

                  //
                  // If the directory already exists "Warn the user"
                  //

                  if (GetFileAttributesEx (szDir, GetFileExInfoStandard, &fad)) {

                      if (!ConfirmDirectory(hDlg, szDir))
                          break;
                      
                      //
                      // If it is just a file, delete it
                      //
                      // If it is a directory and if the user has decided the
                      // user that needs to have permissions, then delete the directory.
                      // and set ACLs using this Sid.
                      //
                      // Otherwise if the directory doesn't exist use the default ACLs.
                      // if it does exist, use the current ACLs
                      //
                      
                      if (!(fad.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                          SetFileAttributes(szDir, FILE_ATTRIBUTE_NORMAL);
                          DeleteFile(szDir);
                      }
                      else if (!(lpUPCopyInfo->bDefaultSecurity)) {

                          if (!Delnode(szDir)) {
                              WCHAR szTitle[100], szMsgFmt[100], szMessage[600];

                              if (!LoadString (hInstance, IDS_UP_ERRORTITLE, szTitle, 100))
                                  break;

                              if (!LoadString (hInstance, IDS_UP_DELNODE_ERROR, szMsgFmt, 100))
                                  break;

                              wsprintf(szMessage, szMsgFmt, szDir);
                              MessageBox(hDlg, szMessage, szTitle, MB_OK | MB_ICONSTOP);
                              break;
                          }

                      }
                  }
    
                  hOldCursor = SetCursor (LoadCursor(NULL, IDC_WAIT));

                  if (!UPCreateProfile (hDlg, lpUPCopyInfo, szDir, NULL)) {
                      SetCursor(hOldCursor);
                      break;
                  }

                  MemFree (lpUPCopyInfo->pSid);
                  MemFree (lpUPCopyInfo);
                  SetCursor(hOldCursor);
                  EndDialog(hDlg, TRUE);
                  }
                  break;

              case IDCANCEL:
                  lpUPCopyInfo = (LPUPCOPYINFO) GetWindowLongPtr(hDlg, GWLP_USERDATA);

                  if (lpUPCopyInfo) {
                      MemFree (lpUPCopyInfo->pSid);
                      MemFree(lpUPCopyInfo);
                  }

                  EndDialog(hDlg, FALSE);
                  break;

              case IDC_COPY_BROWSE:
                  {
                  BROWSEINFO BrowseInfo;
                  TCHAR      szBuffer[MAX_PATH];
                  LPITEMIDLIST pidl;


                  LoadString(hInstance, IDS_UP_DIRPICK, szBuffer, MAX_PATH);

                  BrowseInfo.hwndOwner = hDlg;
                  BrowseInfo.pidlRoot = NULL;
                  BrowseInfo.pszDisplayName = szBuffer;
                  BrowseInfo.lpszTitle = szBuffer;
                  BrowseInfo.ulFlags = BIF_RETURNONLYFSDIRS;
                  BrowseInfo.lpfn = NULL;
                  BrowseInfo.lParam = 0;

                  pidl = SHBrowseForFolder (&BrowseInfo);

                  if (pidl) {
                     SHGetPathFromIDList(pidl, szBuffer);
                     SHFree (pidl);
                     SetDlgItemText (hDlg, IDC_COPY_PATH, szBuffer);
                     SetFocus (GetDlgItem(hDlg, IDOK));
                  }

                  }
                  break;

              case IDC_COPY_PATH:
                  if (HIWORD(wParam) == EN_UPDATE) {
                      if (SendDlgItemMessage(hDlg, IDC_COPY_PATH,
                                             EM_LINELENGTH, 0, 0)) {
                          EnableWindow (GetDlgItem(hDlg, IDOK), TRUE);
                          SetDefButton(hDlg, IDOK);
                      } else {
                          EnableWindow (GetDlgItem(hDlg, IDOK), FALSE);
                          SetDefButton(hDlg, IDCANCEL);
                      }
                  }
                  break;

              case IDC_COPY_PROFILE:
                     SetFocus (GetDlgItem(hDlg, IDC_COPY_PATH));
                     break;

              case IDC_COPY_CHANGE:
                  {

                  LPUSERDETAILS lpUserDetails;
                  DWORD dwSize = 1024;
                  TCHAR szUserName[200];
                  PSID pNewSid;


                  lpUPCopyInfo = (LPUPCOPYINFO) GetWindowLongPtr(hDlg, GWLP_USERDATA);

                  if (!lpUPCopyInfo) {
                      EndDialog (hDlg, FALSE);
                      break;
                  }

                  lpUserDetails = (LPUSERDETAILS) MemAlloc (LPTR, dwSize);

                  if (!lpUserDetails) {
                      break;
                  }
                  
                  if (UPGetUserSelection(hDlg, lpUserDetails) != S_OK) {
                      MemFree(lpUserDetails);
                      break;
                  }

                  // Save our new sid
                  //

                  lpUPCopyInfo->bDefaultSecurity = FALSE;   // at this point user has selected a Sid

                  MemFree (lpUPCopyInfo->pSid);
                  lpUPCopyInfo->pSid = lpUserDetails->psidUser;

                  // Update the edit control
                  lstrcpy(szUserName, lpUserDetails->pszDomainName);
                  lstrcat(szUserName, TEXT("\\"));
                  lstrcat(szUserName, lpUserDetails->pszAccountName);
                  SetDlgItemText (hDlg, IDC_COPY_USER, szUserName);

                  MemFree(lpUserDetails->pszDomainName);
                  MemFree(lpUserDetails->pszAccountName);

                  // Cleanup
                  MemFree (lpUserDetails);
                  }
                  break;

              default:
                  break;

          }
          break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
            (DWORD_PTR) (LPSTR) aUserProfileHelpIds);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (DWORD_PTR) (LPSTR) aUserProfileHelpIds);
            return (TRUE);

    }

    return (FALSE);
}


//*************************************************************
//
//  ConfirmDirectory()
//
//  Purpose:    Confirms the directory selected
//
//  Parameters: 
//              hDlg    -   handle to the parent Dialogbox
//              szDir   - Direcory selected by user that exists
//
//  Return:     TRUE if it is confirmed
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/24/99     ushaji     Created
//
//*************************************************************

BOOL ConfirmDirectory(HWND hDlg, LPTSTR szDir)
{
    LPTSTR szMsgTemplate=NULL, szMsg1=NULL, szMsg=NULL;
    BOOL bRetVal = FALSE;

    szMsgTemplate = (LPTSTR) MemAlloc(LPTR, sizeof(TCHAR)*MAX_PATH);

    if (!szMsgTemplate)
        goto Exit;

    szMsg1 = (LPTSTR) MemAlloc(LPTR, sizeof(TCHAR)*MAX_PATH);

    if (!szMsg1)
        goto Exit;

        
    szMsg = (LPTSTR) MemAlloc(LPTR, sizeof(TCHAR)*(500+MAX_PATH));

    if (!szMsg)
        goto Exit;
                          
    if (!LoadString (hInstance, IDS_UP_CONFIRMCOPYMSG, szMsgTemplate, MAX_PATH)) {
        goto Exit;
    }

    wsprintf (szMsg, szMsgTemplate, szDir);
                      
    if (!LoadString (hInstance, IDS_UP_CONFIRMCOPYTITLE, szMsg1, MAX_PATH)) {
        goto Exit;
    }

    if (MessageBox(hDlg, szMsg, szMsg1, 
                   MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2) == IDYES)
        bRetVal = TRUE;

Exit:
    if (szMsgTemplate) 
        MemFree(szMsgTemplate);

    if (szMsg)
        MemFree(szMsg);

    if (szMsg1)
        MemFree(szMsg1);
        
    return bRetVal;
}


//*************************************************************
//
//  UPGetUserSelection()
//
//  Purpose:    Shows a UI and gets the user to select a
//              username
//
//  Parameters: hDlg          - Parent window handle
//              lpUserDetails - Pointer to an allocated user details
//                              structure which gets filled up if required
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs or user chooses cancel
//
//  Comments:
//
//  History:    Date        Author     Comment
//              4/14/99     ushaji     adapted from Rahulth
//
//*************************************************************

HRESULT UPGetUserSelection(HWND hDlg, LPUSERDETAILS lpUserDetails)
{
    PCWSTR                  apwszAttribs[] = {L"ObjectSid"};
    DWORD                   dwError = ERROR_SUCCESS;
    HRESULT                 hr = S_FALSE;
    IDsObjectPicker       * pDsObjectPicker = NULL;
    DSOP_INIT_INFO          InitInfo;
    const ULONG             cbNumScopes = 3;
    DSOP_SCOPE_INIT_INFO    ascopes[cbNumScopes];
    IDataObject           * pdo = NULL;
    STGMEDIUM               stgmedium = {TYMED_HGLOBAL, NULL};
    UINT                    cf = 0;
    PDS_SELECTION_LIST      pDsSelList = NULL;
    FORMATETC               formatetc = {
                                        (CLIPFORMAT)cf,
                                        NULL,
                                        DVASPECT_CONTENT,
                                        -1,
                                        TYMED_HGLOBAL
                                        };
    
    PDS_SELECTION           pDsSelection = NULL;
    BOOL                    bAllocatedStgMedium = FALSE;
    SAFEARRAY             * pVariantArr = NULL;
    PSID                    pSid = NULL;
    SID_NAME_USE            eUse;    
    DWORD                   dwNameLen, dwDomLen, dwSize;
   
    ZeroMemory(lpUserDetails, sizeof(USERDETAILS));
    
    // This code is not uninitializing COM.
    hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        goto Exit;
    }
    
    hr = CoCreateInstance(CLSID_DsObjectPicker, NULL, CLSCTX_INPROC_SERVER, IID_IDsObjectPicker, (void **) &pDsObjectPicker);
    if (FAILED(hr))
    {
        goto Exit;
    }

    //Initialize the scopes
    ZeroMemory (ascopes, cbNumScopes * sizeof (DSOP_SCOPE_INIT_INFO));
    
    ascopes[0].cbSize = sizeof (DSOP_SCOPE_INIT_INFO);
    ascopes[0].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
    ascopes[0].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;

    ascopes[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS                  |
                                                 DSOP_FILTER_BUILTIN_GROUPS         |
                                                 DSOP_FILTER_WELL_KNOWN_PRINCIPALS  |
                                                 DSOP_FILTER_UNIVERSAL_GROUPS_DL    |
                                                 DSOP_FILTER_UNIVERSAL_GROUPS_SE    |
                                                 DSOP_FILTER_GLOBAL_GROUPS_DL       |
                                                 DSOP_FILTER_GLOBAL_GROUPS_SE       |
                                                 DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL |
                                                 DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE;

    
    ascopes[1].cbSize = sizeof (DSOP_SCOPE_INIT_INFO);
    ascopes[1].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;
    ascopes[1].FilterFlags.Uplevel.flBothModes =
                                        ascopes[0].FilterFlags.Uplevel.flBothModes;

    
    ascopes[2].cbSize = sizeof (DSOP_SCOPE_INIT_INFO);
    ascopes[2].flType = DSOP_SCOPE_TYPE_TARGET_COMPUTER           |
                        DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN   |
                        DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN;

    ascopes[2].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS                |
                                         DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS         |
                                         DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS        |
                                         DSOP_DOWNLEVEL_FILTER_WORLD                |
                                         DSOP_DOWNLEVEL_FILTER_AUTHENTICATED_USER   |
                                         DSOP_DOWNLEVEL_FILTER_DIALUP               |
                                         DSOP_DOWNLEVEL_FILTER_INTERACTIVE          |
                                         DSOP_DOWNLEVEL_FILTER_NETWORK;
    
    //Populate the InitInfo structure that is used to initialize the object
    //picker.
    ZeroMemory (&InitInfo, sizeof (InitInfo));
    
    InitInfo.cbSize = sizeof (InitInfo);
    InitInfo.cDsScopeInfos = cbNumScopes;
    InitInfo.aDsScopeInfos = ascopes;
    InitInfo.cAttributesToFetch = 1;
    InitInfo.apwzAttributeNames = apwszAttribs;
    
    hr = pDsObjectPicker->Initialize (&InitInfo);
    if (FAILED(hr))
    {
        goto Exit;
    }
    
    hr = pDsObjectPicker->InvokeDialog (hDlg, &pdo);
    if (FAILED(hr))
    {
        goto Exit;
    }
    
    if (S_FALSE == hr)
    {   //the user hit cancel
        goto Exit;
    }
    
    //if we are here, the user chose, OK, so find out what group was chosen
    cf = RegisterClipboardFormat (CFSTR_DSOP_DS_SELECTION_LIST);
    if (0 == cf)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    
    //set the clipformat for the formatetc structure
    formatetc.cfFormat = (CLIPFORMAT)cf;
    hr = pdo->GetData (&formatetc, &stgmedium);
    if (FAILED(hr))
    {
        goto Exit;
    }
    
    bAllocatedStgMedium = TRUE;
    
    pDsSelList = (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);
    if (NULL == pDsSelList)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    if (!pDsSelList->cItems)    //some item must have been selected
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    pDsSelection = &(pDsSelList->aDsSelection[0]);

    //we must get the ObjectSid attribute, otherwise we fail
    if (! (VT_ARRAY & pDsSelection->pvarFetchedAttributes->vt))
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }
    
    pVariantArr = pDsSelection->pvarFetchedAttributes->parray;
    pSid = (PSID) pVariantArr->pvData;
    
    //store away the string representation of this sid
    dwSize = GetLengthSid (pSid);
    
    lpUserDetails->psidUser = MemAlloc (LPTR, dwSize);
    
    if (!lpUserDetails->psidUser) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    
    if (!CopySid (dwSize, lpUserDetails->psidUser, pSid)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    lpUserDetails->pszDomainName =  (LPTSTR) MemAlloc (LPTR, MAX_PATH);
    lpUserDetails->pszAccountName = (LPTSTR) MemAlloc (LPTR, MAX_PATH);

    if ((!lpUserDetails->pszDomainName) || (!lpUserDetails->pszAccountName)) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    dwNameLen = dwDomLen = MAX_PATH;

    if (!LookupAccountSid (NULL, pSid, lpUserDetails->pszAccountName, &dwNameLen, 
                           lpUserDetails->pszDomainName, &dwDomLen,
                           &eUse))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    hr = S_OK;

    
Exit:
    if (pDsSelList)
        GlobalUnlock (stgmedium.hGlobal);

    if (bAllocatedStgMedium)
        ReleaseStgMedium (&stgmedium);

    if (pdo)
        pdo->Release();

    if (pDsObjectPicker)
        pDsObjectPicker->Release ();
    
    if (hr != S_OK) {
        if (lpUserDetails->psidUser) 
            MemFree(lpUserDetails->psidUser);
        if (lpUserDetails->pszDomainName)
            MemFree(lpUserDetails->pszDomainName);
        if (lpUserDetails->pszAccountName) 
            MemFree(lpUserDetails->pszAccountName);
    }

    return hr;
}


//*************************************************************
//
//  UPCreateProfile()
//
//  Purpose:    Creates a copy of the specified profile with
//              the correct security.
//
//  Parameters: lpUPCopyInfo  -   Copy Dialog information
//              lpDest      -   Destination directory
//              pNewSecDesc -   New security descriptor
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/13/96     ericflo    Created
//
//*************************************************************

BOOL UPCreateProfile (HWND hDlg, LPUPCOPYINFO lpUPCopyInfo, LPTSTR lpDest,
                      PSECURITY_DESCRIPTOR pNewSecDesc)
{
    HKEY RootKey, hKey;
    SECURITY_DESCRIPTOR sd;
    SECURITY_ATTRIBUTES sa;
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    PACL pAcl = NULL;
    PSID  psidUser = NULL, psidSystem = NULL, psidAdmin = NULL;
    DWORD cbAcl, AceIndex, dwSize, dwType;
    ACE_HEADER * lpAceHeader;
    HANDLE hFile;
    BOOL bMandatory = FALSE;
    TCHAR szTempPath[MAX_PATH];
    TCHAR szBuffer[MAX_PATH];
    TCHAR szHive[MAX_PATH];
    BOOL bRetVal = FALSE;
    HKEY hKeyProfile;
    LONG Error;
    LPTSTR lpEnd;
    TCHAR szExcludeList1[MAX_PATH];
    TCHAR szExcludeList2[MAX_PATH];
    TCHAR szExcludeList[2 * MAX_PATH];
    DWORD dwErr = 0;
    BOOL bSecurityFailed = TRUE;

    
    // Getting the previous last error so that we can set the last error to this in the end.
    dwErr = GetLastError();


    if (!lpDest || !(*lpDest)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    //
    // Create the security descriptor
    //

    //
    // User Sid
    //

    psidUser = lpUPCopyInfo->pSid;


    //
    // Get the system sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem)) {
         dwErr = GetLastError();
         goto Exit;
    }


    //
    // Get the admin sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &psidAdmin)) {
         dwErr = GetLastError();
         goto Exit;
    }


    //
    // Allocate space for the ACL
    //

    cbAcl = (2 * GetLengthSid (psidUser)) + (2 * GetLengthSid (psidSystem)) +
            (2 * GetLengthSid (psidAdmin)) + sizeof(ACL) +
            (6 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


    pAcl = (PACL) MemAlloc(LPTR, cbAcl);
    if (!pAcl) {
        dwErr = GetLastError();
        goto Exit;
    }


    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
        dwErr = GetLastError();
        goto Exit;
    }



    //
    // Add Aces for User, System, and Admin.  Non-inheritable ACEs first
    //

    AceIndex = 0;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidUser)) {
        dwErr = GetLastError();
        goto Exit;
    }


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidSystem)) {
        dwErr = GetLastError();
        goto Exit;
    }

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidAdmin)) {
        dwErr = GetLastError();
        goto Exit;
    }


    //
    // Now the inheritable ACEs
    //

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidUser)) {
        dwErr = GetLastError();
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, (void **)&lpAceHeader)) {
        dwErr = GetLastError();
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidSystem)) {
        dwErr = GetLastError();
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, (void **)&lpAceHeader)) {
        dwErr = GetLastError();
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidAdmin)) {
        dwErr = GetLastError();
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, (void **)&lpAceHeader)) {
        dwErr = GetLastError();
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    //
    // Put together the security descriptor
    //

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
        dwErr = GetLastError();
        goto Exit;
    }


    if (!SetSecurityDescriptorDacl(&sd, TRUE, pAcl, FALSE)) {
        dwErr = GetLastError();
        goto Exit;
    }

    //
    // Add the security descriptor to the sa structure
    //

    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = &sd;
    sa.bInheritHandle = FALSE;


    //
    // Create the destination directory
    //

    if (!CreateNestedDirectory (lpDest, &sa)) {
        dwErr = GetLastError();
        goto Exit;
    }


    //
    // Save/copy the user's profile to a temp file
    //

    if (!GetTempPath(MAX_PATH, szTempPath)) {
        dwErr = GetLastError();
        goto Exit;
    }


    if (!GetTempFileName (szTempPath, TEXT("TMP"), 0, szBuffer)) {
        dwErr = GetLastError();
        goto Exit;
    }

    DeleteFile (szBuffer);


    //
    // Determine if we are working with a mandatory profile
    //

    lstrcpy (szHive, lpUPCopyInfo->lpUserInfo->lpProfile);
    lpEnd = CheckSlash(szHive);
    lstrcpy (lpEnd, TEXT("ntuser.man"));

    hFile = CreateFile(szHive, GENERIC_READ, FILE_SHARE_READ, NULL,
                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);


    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle (hFile);
        bMandatory = TRUE;
    }


    //
    // Test if the requested profile is in use.
    //

    if (IsProfileInUse (lpUPCopyInfo->lpUserInfo->lpSid)) {


        Error = RegOpenKeyEx (HKEY_USERS, lpUPCopyInfo->lpUserInfo->lpSid, 0,
                              KEY_READ, &hKeyProfile);

        if (Error != ERROR_SUCCESS) {
            dwErr = Error;
            goto Exit;
        }

        Error = MyRegSaveKey (hKeyProfile, szBuffer);

        RegCloseKey (hKeyProfile);

        if (Error != ERROR_SUCCESS) {
            DeleteFile (szBuffer);
            dwErr = Error;
            goto Exit;
        }

    } else {

       if (!bMandatory) {
           lstrcpy (lpEnd, TEXT("ntuser.dat"));
       }

       if (!CopyFile(szHive, szBuffer, FALSE)) {
           dwErr = GetLastError();
           goto Exit;
       }
    }

    //
    // Apply security to the hive
    //

    Error = MyRegLoadKey (HKEY_USERS, TEMP_PROFILE, szBuffer);

    if (Error != ERROR_SUCCESS) {
        DeleteFile (szBuffer);
        dwErr = Error;
        goto Exit;
    }

    bRetVal = ApplyHiveSecurity(TEMP_PROFILE, psidUser);


    //
    // Query for the user's exclusion list
    //

    if (bRetVal) {

        //
        // Open the root of the user's profile
        //

        if (RegOpenKeyEx(HKEY_USERS, TEMP_PROFILE, 0, KEY_READ, &RootKey) == ERROR_SUCCESS) {


             //
             // Check for a list of directories to exclude both user preferences
             // and user policy
             //

             szExcludeList1[0] = TEXT('\0');
             if (RegOpenKeyEx (RootKey,
                               TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
                               0, KEY_READ, &hKey) == ERROR_SUCCESS) {

                 dwSize = sizeof(szExcludeList1);
                 RegQueryValueEx (hKey,
                                  TEXT("ExcludeProfileDirs"),
                                  NULL,
                                  &dwType,
                                  (LPBYTE) szExcludeList1,
                                  &dwSize);

                 RegCloseKey (hKey);
             }

             szExcludeList2[0] = TEXT('\0');
             if (RegOpenKeyEx (RootKey,
                               TEXT("Software\\Policies\\Microsoft\\Windows\\System"),
                               0, KEY_READ, &hKey) == ERROR_SUCCESS) {

                 dwSize = sizeof(szExcludeList2);
                 RegQueryValueEx (hKey,
                                  TEXT("ExcludeProfileDirs"),
                                  NULL,
                                  &dwType,
                                  (LPBYTE) szExcludeList2,
                                  &dwSize);

                 RegCloseKey (hKey);
             }


             //
             // Merge the user preferences and policy together
             //

             szExcludeList[0] = TEXT('\0');

             if (szExcludeList1[0] != TEXT('\0')) {
                 lstrcpy (szExcludeList, szExcludeList1);
             }

             if (szExcludeList2[0] != TEXT('\0')) {

                 if (szExcludeList[0] != TEXT('\0')) {
                     lstrcat (szExcludeList, TEXT(";"));
                 }

                 lstrcat (szExcludeList, szExcludeList2);
             }

             // Always exclude USER_CRED_LOCATION

             if (szExcludeList[0] != TEXT('\0')) {
                 lstrcat (szExcludeList, TEXT(";"));
             }
             lstrcat(szExcludeList, USER_CRED_LOCATION);

             RegCloseKey (RootKey);
        }
    }


    if (!bRetVal) {
        DeleteFile (szBuffer);
        lstrcat (szBuffer, TEXT(".log"));
        DeleteFile (szBuffer);
        dwErr = GetLastError();
        goto Exit;
    }


    //
    // Unload the hive
    //

    Error = MyRegUnLoadKey(HKEY_USERS, TEMP_PROFILE);

    if (Error != ERROR_SUCCESS) {
        DeleteFile (szBuffer);
        lstrcat (szBuffer, TEXT(".log"));
        DeleteFile (szBuffer);
        dwErr = Error;
        goto Exit;
    }


    //
    // if it has come till here, we have managed to set the ACLs correctly
    //

    bSecurityFailed = FALSE;


    //
    // Copy the profile without the hive
    //

    bRetVal = CopyProfileDirectoryEx (lpUPCopyInfo->lpUserInfo->lpProfile,
                                      lpDest,
                                      CPD_IGNOREHIVE |
                                      CPD_COPYIFDIFFERENT |
                                      CPD_SYNCHRONIZE |
                                      CPD_USEEXCLUSIONLIST |
                                      CPD_IGNORESECURITY |
                                      CPD_DELDESTEXCLUSIONS,
                                      NULL,
                                      (szExcludeList[0] != TEXT('\0')) ?
                                      szExcludeList : NULL);

    if (!bRetVal) {
        dwErr = GetLastError();
        DeleteFile(szBuffer);
        lstrcat (szBuffer, TEXT(".log"));
        DeleteFile (szBuffer);
        goto Exit;
    }


    //
    // Now copy the hive
    //

    lstrcpy (szHive, lpDest);
    lpEnd = CheckSlash (szHive);
    if (bMandatory) {
        lstrcpy (lpEnd, TEXT("ntuser.man"));
    } else {
        lstrcpy (lpEnd, TEXT("ntuser.dat"));
    }


    //
    // Setting the file attributes first
    //
    
    SetFileAttributes (szHive, FILE_ATTRIBUTE_NORMAL);

    
    bRetVal = CopyFile (szBuffer, szHive, FALSE);

    if (!bRetVal) {

        TCHAR szMsg[MAX_PATH], szMsgTemplate[MAX_PATH];

        dwErr = GetLastError();    

        szMsg[0] = szMsgTemplate[0] = TEXT('\0');


        LoadString (hInstance, IDS_UP_COPYHIVE_ERROR, szMsgTemplate, MAX_PATH-1);
        
        wsprintf(szMsg, szMsgTemplate, szHive);


        UPDisplayErrorMessage(hDlg, dwErr, szMsg);    
    }
        

    //
    // Delete the temp file (and log file)
    //

    DeleteFile (szBuffer);
    lstrcat (szBuffer, TEXT(".log"));
    DeleteFile (szBuffer);


Exit:

    //
    // Free the sids and acl
    //

    if (psidSystem) {
        FreeSid(psidSystem);
    }

    if (psidAdmin) {
        FreeSid(psidAdmin);
    }

    if (pAcl) {
        MemFree (pAcl);
    }

    if ((!bRetVal) && (bSecurityFailed)) {
        TCHAR szMsg[MAX_PATH];

        szMsg[0] = TEXT('\0');

        LoadString (hInstance, IDS_UP_SETSECURITY_ERROR, szMsg, MAX_PATH-1);

        UPDisplayErrorMessage(hDlg, dwErr, szMsg);    
    }
    
    SetLastError(dwErr);

    return (bRetVal);
}





//*************************************************************
//
//  UPDisplayErrorMessage()
//
//  Purpose:    Display an error message
//
//  Parameters: hWnd            -   parent window handle
//              uiSystemError   -   Error code
//
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/14/96     ericflo    Created
//
//*************************************************************

VOID UPDisplayErrorMessage(HWND hWnd, UINT uiSystemError, LPTSTR szMsgPrefix)
{
   TCHAR szMessage[MAX_PATH];
   TCHAR szTitle[100];
   LPTSTR lpEnd;

   if (szMsgPrefix) {
      lstrcpy(szMessage, szMsgPrefix);
   }
   else {
      szMessage[0] = TEXT('\0');
   }

   lpEnd = szMessage+lstrlen(szMessage);
    
   //
   // retrieve the string matching the Win32 system error
   //

   FormatMessage(
            FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            uiSystemError,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
            lpEnd,
            MAX_PATH-lstrlen(szMessage),
            NULL);

   //
   // display a message box with this error
   //

   LoadString (hInstance, IDS_UP_ERRORTITLE, szTitle, 100);
   MessageBox(hWnd, szMessage, szTitle, MB_OK | MB_ICONSTOP);

   return;

}

//*************************************************************
//
//  ApplySecurityToRegistryTree()
//
//  Purpose:    Applies the passed security descriptor to the passed
//              key and all its descendants.  Only the parts of
//              the descriptor inddicated in the security
//              info value are actually applied to each registry key.
//
//  Parameters: RootKey   -     Registry key
//              pSD       -     Security Descriptor
//
//  Return:     ERROR_SUCCESS if successful
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/19/95     ericflo    Created
//
//*************************************************************

DWORD ApplySecurityToRegistryTree(HKEY RootKey, PSECURITY_DESCRIPTOR pSD)

{
    DWORD Error;
    DWORD SubKeyIndex;
    LPTSTR SubKeyName;
    HKEY SubKey;
    DWORD cchSubKeySize = MAX_PATH + 1;



    //
    // First apply security
    //

    RegSetKeySecurity(RootKey, DACL_SECURITY_INFORMATION, pSD);


    //
    // Open each sub-key and apply security to its sub-tree
    //

    SubKeyIndex = 0;

    SubKeyName = (LPTSTR) MemAlloc (LPTR, cchSubKeySize * sizeof(TCHAR));

    if (!SubKeyName) {
        return GetLastError();
    }

    while (TRUE) {

        //
        // Get the next sub-key name
        //

        Error = RegEnumKey(RootKey, SubKeyIndex, SubKeyName, cchSubKeySize);


        if (Error != ERROR_SUCCESS) {

            if (Error == ERROR_NO_MORE_ITEMS) {

                //
                // Successful end of enumeration
                //

                Error = ERROR_SUCCESS;

            }

            break;
        }


        //
        // Open the sub-key
        //

        Error = RegOpenKeyEx(RootKey,
                             SubKeyName,
                             0,
                             WRITE_DAC | KEY_ENUMERATE_SUB_KEYS | READ_CONTROL,
                             &SubKey);

        if (Error == ERROR_SUCCESS) {

            //
            // Apply security to the sub-tree
            //

            ApplySecurityToRegistryTree(SubKey, pSD);


            //
            // We're finished with the sub-key
            //

            RegCloseKey(SubKey);
        }


        //
        // Go enumerate the next sub-key
        //

        SubKeyIndex ++;
    }


    MemFree (SubKeyName);

    return Error;

}

//*************************************************************
//
//  ApplyHiveSecurity()
//
//  Purpose:    Initializes the new user hive created by copying
//              the default hive.
//
//  Parameters: lpHiveName      -   Name of hive in HKEY_USERS
//              pSid            -   Sid (used by CreateNewUser)
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/18/95     ericflo    Created
//
//*************************************************************

BOOL ApplyHiveSecurity(LPTSTR lpHiveName, PSID pSid)
{
    DWORD Error;
    HKEY RootKey;
    SECURITY_DESCRIPTOR sd;
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    PACL pAcl = NULL;
    PSID  psidUser = pSid, psidSystem = NULL, psidAdmin = NULL;
    DWORD cbAcl, AceIndex;
    ACE_HEADER * lpAceHeader;
    BOOL bRetVal = FALSE;



    //
    // Get the system sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem)) {
         goto Exit;
    }


    //
    // Get the admin sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &psidAdmin)) {
         goto Exit;
    }


    //
    // Allocate space for the ACL
    //

    cbAcl = (2 * GetLengthSid (psidUser)) + (2 * GetLengthSid (psidSystem)) +
            (2 * GetLengthSid (psidAdmin)) + sizeof(ACL) +
            (6 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


    pAcl = (PACL) MemAlloc(LPTR, cbAcl);
    if (!pAcl) {
        goto Exit;
    }


    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
        goto Exit;
    }



    //
    // Add Aces for User, System, and Admin.  Non-inheritable ACEs first
    //

    AceIndex = 0;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidUser)) {
        goto Exit;
    }


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidSystem)) {
        goto Exit;
    }

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidAdmin)) {
        goto Exit;
    }


    //
    // Now the inheritable ACEs
    //

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidUser)) {
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, (void **)&lpAceHeader)) {
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidSystem)) {
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, (void **)&lpAceHeader)) {
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidAdmin)) {
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, (void **)&lpAceHeader)) {
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    //
    // Put together the security descriptor
    //

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
        goto Exit;
    }


    if (!SetSecurityDescriptorDacl(&sd, TRUE, pAcl, FALSE)) {
        goto Exit;
    }


    //
    // Open the root of the user's profile
    //

    Error = RegOpenKeyEx(HKEY_USERS,
                         lpHiveName,
                         0,
                         WRITE_DAC | KEY_ENUMERATE_SUB_KEYS | READ_CONTROL,
                         &RootKey);

    if (Error == ERROR_SUCCESS) {

        //
        // Set the security descriptor on the entire tree
        //

        Error = ApplySecurityToRegistryTree(RootKey, &sd);


        if (Error == ERROR_SUCCESS) {
            bRetVal = TRUE;
        }

        RegFlushKey (RootKey);

        RegCloseKey(RootKey);
    }


Exit:

    //
    // Free the sids and acl
    //

    if (psidSystem) {
        FreeSid(psidSystem);
    }

    if (psidAdmin) {
        FreeSid(psidAdmin);
    }

    if (pAcl) {
        MemFree (pAcl);
    }


    return(bRetVal);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\srcfg.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-2000  Microsoft Corporation
All rights reserved

Module Name:

    srcfg.h

Abstract:

    Public declarations for the System Restore tab of the System Control
    Panel Applet.

Author:

    skkhang 15-Jun-2000

--*/
#ifndef _SYSDM_SRCFG_H_
#define _SYSDM_SRCFG_H_

//
// Public function prototypes
//
HPROPSHEETPAGE
CreateSystemRestorePage(
    int,
    DLGPROC
);


#endif // _SYSDM_SRCFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\srcfg.cpp ===
/*++

Microsoft Confidential
Copyright (c) 1992-2000  Microsoft Corporation
All rights reserved

Module Name:
    srcfg.cpp

Abstract:
    Adds System Restore tab to the System Control Panel Applet if necessary.

Author:
    skkhang 15-Jun-2000

NOTE (7/26/00 skkhang):
    Now there is no code to unload srrstr.dll, because property page proc
    cannot unload the DLL. It is acceptable for the current CPL mechanism --
    using a separate process rundll32.exe which would clean up any loaded
    DLLs during termination. However, if system CPL is loaded in the context
    of, e.g., Shell itself, srrstr.dll will be leaked.

    One possible solution is to place a proxy property page proc in this file
    and calls the real proc in srrstr.dll only when srrstr.dll is loaded
    in the memory. Of course, even in that case, determination of whether to
    show SR Tab or not must be made first of all.

--*/

#include "sysdm.h"


typedef HPROPSHEETPAGE (WINAPI *SRGETPAGEPROC)();

static LPCWSTR  s_cszSrSysCfgDllName = L"srrstr.dll";
static LPCSTR   s_cszSrGetPageProc   = "SRGetCplPropPage";


HPROPSHEETPAGE
CreateSystemRestorePage(int, DLGPROC)
{
    HPROPSHEETPAGE  hRet = NULL;
    HMODULE         hModSR = NULL;
    SRGETPAGEPROC   pfnGetPage;

    hModSR = ::LoadLibrary( s_cszSrSysCfgDllName );
    if ( hModSR == NULL )
        goto Exit;

    pfnGetPage = (SRGETPAGEPROC)::GetProcAddress( hModSR, s_cszSrGetPageProc );
    if ( pfnGetPage == NULL )
        goto Exit;

    hRet = pfnGetPage();

Exit:
    if ( hRet == NULL )
        ::FreeLibrary( hModSR );

    return( hRet );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\startup.c ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    startup.c

Abstract:

    Implements the Startup/Recovery dialog of the System
    Control Panel Applet

Author:

    Eric Flo (ericflo) 19-Jun-1995

Revision History:

    15-Oct-1997 scotthal
        Complete overhaul

--*/
#include <sysdm.h>

#ifdef _X86_
extern TCHAR szBootIni[];
#endif 

//
// Globals for this dialog
//

#define CSEC_START_MAX    9999        // Maximum number of seconds allowed

BOOL g_fStartupInitializing;
BOOL g_fRebootRequired = FALSE;

#if defined(_X86_) || defined(EFI_NVRAM_ENABLED)
BOOL g_fSystemStartupEnabled = TRUE;
#else
BOOL g_fSystemStartupEnabled = FALSE;
#endif

//
// Help ID's
//

DWORD aStartupHelpIds[] = {
    IDC_STARTUP_SYS_OS_LABEL,              (IDH_STARTUP + 0),
    IDC_STARTUP_SYS_OS,                    (IDH_STARTUP + 0),
    IDC_STARTUP_SYS_ENABLECOUNTDOWN,       (IDH_STARTUP + 1),
    IDC_STARTUP_SYS_SECONDS,               (IDH_STARTUP + 2),
    IDC_STARTUP_SYS_SECONDS_LABEL,         (IDH_STARTUP + 2),
    IDC_STARTUP_CDMP_TXT1,                 (IDH_STARTUP + 3),
    IDC_STARTUP_CDMP_LOG,                  (IDH_STARTUP + 4),
    IDC_STARTUP_CDMP_SEND,                 (IDH_STARTUP + 5),
    IDC_STARTUP_CDMP_FILENAME,             (IDH_STARTUP + 7),
    IDC_STARTUP_CDMP_OVERWRITE,            (IDH_STARTUP + 13),
    IDC_STARTUP_CDMP_AUTOREBOOT,           (IDH_STARTUP + 9),
    IDC_STARTUP_SYSTEM_GRP,                (IDH_STARTUP + 10),
    IDC_STARTUP_SYS_SECSCROLL,             (IDH_STARTUP + 11),
    IDC_STARTUP_CDMP_GRP,                  (IDH_STARTUP + 12),
    IDC_STARTUP_CDMP_DEBUGINFO_GROUP,      (IDH_STARTUP + 14),
    IDC_STARTUP_CDMP_TYPE,                 (IDH_STARTUP + 8),
    IDC_STARTUP_CDMP_FILE_LABEL,           (IDH_STARTUP + 7),
    IDC_STARTUP_SYS_EDIT_LABEL,            (IDH_STARTUP + 15),
    IDC_SYS_EDIT_BUTTION,                  (IDH_STARTUP + 16),
    0, 0
};


INT_PTR
APIENTRY 
StartupDlgProc(
    IN HWND hDlg, 
    IN UINT uMsg, 
    IN WPARAM wParam, 
    IN LPARAM lParam
)
/*++

Routine Description:

    Handles messages sent to the Startup/Recovery dialog box

Arguments:

    hDlg -
        Supplies window handle

    uMsg -
        Supplies message being sent

    wParam -
        Supplies message parameter

    lParam -
        Supplies message parameter

Return Value:

    TRUE if message was handled
    FALSE if message was unhandled

--*/
{
    int iRet;

    // If any controls on this page are touched by the user,
    // enable the "Apply" button.
    if ((WM_COMMAND == uMsg) && (!g_fStartupInitializing)) {
        switch (HIWORD(wParam)) {
            case EN_CHANGE:
            case BN_CLICKED:
            case CBN_SELCHANGE:
                PropSheet_Changed(GetParent(hDlg), hDlg);
                break;

            default:
                break;
        } // switch (HIWORD(wParam))
    } // if ((WM_COMMAND...

    // Call the Core Dump stuff first.  Only handle
    // messages not handled by the Core Dump stuff.
    iRet = CoreDumpDlgProc(hDlg, uMsg, wParam, lParam);

    switch( iRet ) {
        case RET_CONTINUE: {
            break;
        }

        case RET_BREAK: {
            return TRUE;
        }

        case RET_ERROR: {
            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
            return TRUE;
        }

        case RET_CHANGE_NO_REBOOT:
        case RET_NO_CHANGE: {
            break;
        }

        case RET_VIRTUAL_CHANGE:
        case RET_RECOVER_CHANGE:
        case RET_VIRT_AND_RECOVER: {
            g_fRebootRequired = TRUE;

            MsgBoxParam(
                hDlg, 
                IDS_SYSDM_RESTART, 
                IDS_SYSDM_TITLE,
                MB_OK | MB_ICONINFORMATION
            );

            break;
        }
    }

    switch (uMsg)
    {
    case WM_INITDIALOG:
        g_fStartupInitializing = TRUE;

        StartListInit(hDlg, wParam, lParam);
        AutoAdvancedBootInit(hDlg, wParam, lParam);

        g_fStartupInitializing = FALSE;
        if (!IsUserAdmin())
        {
            EnableWindow(GetDlgItem(hDlg, IDC_SYS_EDIT_BUTTION), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_SYS_EDIT_LABEL), FALSE);

            EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_AUTOLKG), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_AUTOLKG_SECONDS_LABEL), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_AUTOLKG_SECONDS), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_AUTOLKG_SECSCROLL), FALSE);
        }
        if (!g_fSystemStartupEnabled)
        {
            EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_SYSTEM_GRP), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_SYS_OS), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_SYS_OS_LABEL), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_SYS_ENABLECOUNTDOWN), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_SYS_SECONDS_LABEL), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_SYS_SECONDS), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_SYS_EDIT_LABEL), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_SYS_EDIT_BUTTION), FALSE);
        }
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {

        case IDC_STARTUP_AUTOLKG: 
            if (HIWORD(wParam) == BN_CLICKED) {
                BOOL fEnabled;

                fEnabled = !IsDlgButtonChecked(hDlg, IDC_STARTUP_AUTOLKG);

                CheckDlgButton(hDlg, IDC_STARTUP_AUTOLKG, fEnabled);
                EnableWindow(GetDlgItem (hDlg, IDC_STARTUP_AUTOLKG_SECONDS), fEnabled);
                EnableWindow(GetDlgItem (hDlg, IDC_STARTUP_AUTOLKG_SECSCROLL), fEnabled);
            }
            break;

        case IDC_STARTUP_SYS_ENABLECOUNTDOWN:
            if (HIWORD(wParam) == BN_CLICKED) {
                int timeout;

                timeout = IsDlgButtonChecked(hDlg, IDC_STARTUP_SYS_ENABLECOUNTDOWN) ? 0 : 30;
                CheckDlgButton(hDlg, IDC_STARTUP_SYS_ENABLECOUNTDOWN,
                                 (BOOL) timeout);
                SetDlgItemInt(hDlg, IDC_STARTUP_SYS_SECONDS, timeout, FALSE);
                EnableWindow(GetDlgItem (hDlg, IDC_STARTUP_SYS_SECONDS), (BOOL) timeout);
                EnableWindow(GetDlgItem (hDlg, IDC_STARTUP_SYS_SECSCROLL), (BOOL) timeout);

            }
            break;

        case IDOK: {
            int r1, r2;

            if((RET_BREAK != StartListExit(hDlg, wParam, lParam)) && 
               (RET_BREAK != AutoAdvancedBootExit(hDlg, wParam, lParam))) 
            {
                EndDialog(hDlg, 0);
            } // if

            break;
        }

        case IDCANCEL:

            AutoAdvancedBootExit(hDlg, wParam, lParam);
            EndDialog(hDlg, 0);
            break;

        case IDC_STARTUP_SYS_SECONDS:
            if (HIWORD(wParam) == EN_UPDATE) {
                if (!CheckVal(hDlg, IDC_STARTUP_SYS_SECONDS, FORMIN, FORMAX, IDS_SYSDM_ENTERSECONDS)) {
                    SetDlgItemInt(hDlg, IDC_STARTUP_SYS_SECONDS, FORDEF, FALSE); 
                    SendMessage((HWND) lParam, EM_SETSEL, 0, -1);
                    
                } // if (!CheckVal(...

            } // if (HIWORD(wParam == EN_UPDATE)

            break;

        case IDC_STARTUP_AUTOLKG_SECONDS:
            if (HIWORD(wParam) == EN_UPDATE) 
            {
                if (!CheckVal(hDlg, IDC_STARTUP_AUTOLKG_SECONDS, 0, 200, IDS_SYSDM_ENTERSECONDS)) 
                {
                    SetDlgItemInt(hDlg, IDC_STARTUP_AUTOLKG_SECONDS, 30, FALSE); 
                    SendMessage((HWND) lParam, EM_SETSEL, 0, -1);
                } // if (!CheckVal(...

            } // if (HIWORD(wParam == EN_UPDATE)

            break;

        case IDC_SYS_EDIT_BUTTION:
            {
                // invoke notepad.exe to edit boot.ini file
                DWORD dwFileAttr;
                SHELLEXECUTEINFO ExecInfo = {0};
#ifdef _X86_
                ExecInfo.lpParameters    = szBootIni;
#else
                ExecInfo.lpParameters    = TEXT("c:\\boot.ini");
#endif // _X86_
                ExecInfo.lpFile          = TEXT("NOTEPAD.EXE");
                ExecInfo.nShow           = SW_SHOWNORMAL;
                ExecInfo.cbSize          = sizeof(SHELLEXECUTEINFO);
               
                //  Change Read-only file attrs on Boot.ini file if necessary
                if ((dwFileAttr = GetFileAttributes (ExecInfo.lpParameters)) != 0xFFFFFFFF) 
                {
                    if (dwFileAttr & FILE_ATTRIBUTE_READONLY) 
                    {
                        SetFileAttributes (ExecInfo.lpParameters, dwFileAttr & ~FILE_ATTRIBUTE_READONLY);
                    }
                }

                ShellExecuteEx(&ExecInfo);
            }
            break;


        } // switch (LOWORD(wParam))
        break;

    case WM_DESTROY:
        StartListDestroy(hDlg, wParam, lParam);
        break;

    case WM_HELP:      // F1
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
        (DWORD_PTR) (LPSTR) aStartupHelpIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
        (DWORD_PTR) (LPSTR) aStartupHelpIds);
        break;

    default:
        return FALSE;
    }
        
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\syspart.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1998  Microsoft Corporation
All rights reserved

Module Name:

    syspart.h

Abstract:

    Declares the one lousy function that code outside of
    syspart.c needs to be able to see.

Author:

    Scott Hallock (scotthal) 28-Apr-1998

Revision History:

--*/

BOOL InitializeArcStuff();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\syspart.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    syspart.c

Abstract:

    Routines to determine the system partition on x86 machines.

Author:

    Ted Miller (tedm) 30-June-1994

Revision History:

    24-Apr-1997 scotthal
        re-horked for system applet

--*/

#include "sysdm.h"
#include <ntdddisk.h>
#include <tchar.h>

#define ISNT() TRUE
#define MALLOC(s) LocalAlloc(LPTR, (s))
#define REALLOC(p, s) LocalReAlloc((HLOCAL) (p), (s), 0L)
#define FREE(p) LocalFree((HLOCAL) (p))

BOOL g_fInitialized = FALSE;

//
// NT-specific routines we use from ntdll.dll
//
//NTSYSAPI
NTSTATUS
(NTAPI *NtOpenSymLinkRoutine)(
    OUT PHANDLE LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

//NTSYSAPI
NTSTATUS
(NTAPI *NtQuerSymLinkRoutine)(
    IN HANDLE LinkHandle,
    IN OUT PUNICODE_STRING LinkTarget,
    OUT PULONG ReturnedLength OPTIONAL
    );

//NTSYSAPI
NTSTATUS
(NTAPI *NtQuerDirRoutine) (
    IN HANDLE DirectoryHandle,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN BOOLEAN RestartScan,
    IN OUT PULONG Context,
    OUT PULONG ReturnLength OPTIONAL
    );

//NTSYSAPI
NTSTATUS
(NTAPI *NtOpenDirRoutine) (
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

BOOL
MatchNTSymbolicPaths(
    PCTSTR lpDeviceName,
    PCTSTR lpSysPart,
    PCTSTR lpMatchName
    );


IsNEC98(
    VOID
    )
{
    static BOOL Checked = FALSE;
    static BOOL Is98;

    if(!Checked) {

        Is98 = ((GetKeyboardType(0) == 7) && ((GetKeyboardType(1) & 0xff00) == 0x0d00));

        Checked = TRUE;
    }

    return(Is98);
}

BOOL
GetPartitionInfo(
    IN  TCHAR                  Drive,
    OUT PPARTITION_INFORMATION PartitionInfo
    )

/*++

Routine Description:

    Fill in a PARTITION_INFORMATION structure with information about
    a particular drive.

    This routine is meaningful only when run on NT -- it always fails
    on Win95.

Arguments:

    Drive - supplies drive letter whose partition info is desired.

    PartitionInfo - upon success, receives partition info for Drive.

Return Value:

    Boolean value indicating whether PartitionInfo has been filled in.

--*/
{
    TCHAR DriveName[] = TEXT("\\\\.\\?:");
    HANDLE hDisk;
    BOOL b;
    DWORD DataSize;

    if(!ISNT()) {
        return(FALSE);
    }

    DriveName[4] = Drive;

    hDisk = CreateFile(
                DriveName,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

    if(hDisk == INVALID_HANDLE_VALUE) {
        return(FALSE);
    }

    b = DeviceIoControl(
            hDisk,
            IOCTL_DISK_GET_PARTITION_INFO,
            NULL,
            0,
            PartitionInfo,
            sizeof(PARTITION_INFORMATION),
            &DataSize,
            NULL
            );

    CloseHandle(hDisk);

    return(b);
}

UINT
MyGetDriveType(
    IN TCHAR Drive
    )

/*++

Routine Description:

    Same as GetDriveType() Win32 API except on NT returns
    DRIVE_FIXED for removeable hard drives.

Arguments:

    Drive - supplies drive letter whose type is desired.

Return Value:

    Same as GetDriveType().

--*/
{
    TCHAR DriveNameNt[] = TEXT("\\\\.\\?:");
    TCHAR DriveName[] = TEXT("?:\\");
    HANDLE hDisk;
    BOOL b;
    UINT rc;
    DWORD DataSize;
    DISK_GEOMETRY MediaInfo;

    //
    // First, get the win32 drive type. If it tells us DRIVE_REMOVABLE,
    // then we need to see whether it's a floppy or hard disk. Otherwise
    // just believe the api.
    //
    //
    DriveName[0] = Drive;
    rc = GetDriveType(DriveName);

#ifdef _X86_ //NEC98
    if((rc != DRIVE_REMOVABLE) || !ISNT() || (!IsNEC98() && (Drive < L'C'))) {
        return(rc);
    }
#else //NEC98
    if((rc != DRIVE_REMOVABLE) || !ISNT() || (Drive < L'C')) {
        return(rc);
    }
#endif

    //
    // DRIVE_REMOVABLE on NT.
    //

    //
    // Disallow use of removable media (e.g. Jazz, Zip, ...).
    //
#if 0

    DriveNameNt[4] = Drive;

    hDisk = CreateFile(
                DriveNameNt,
                FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

    if(hDisk != INVALID_HANDLE_VALUE) {

        b = DeviceIoControl(
                hDisk,
                IOCTL_DISK_GET_DRIVE_GEOMETRY,
                NULL,
                0,
                &MediaInfo,
                sizeof(MediaInfo),
                &DataSize,
                NULL
                );

        //
        // It's really a hard disk if the media type is removable.
        //
        if(b && (MediaInfo.MediaType == RemovableMedia)) {
            rc = DRIVE_FIXED;
        }

        CloseHandle(hDisk);
    }
#endif

    return(rc);
}

BOOL
ArcPathToNtPath(
    IN  LPCTSTR ArcPath,
    OUT LPTSTR  NtPath,
    IN  UINT    NtPathBufferLen
    )
{
    WCHAR arcPath[256];
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    HANDLE ObjectHandle;
    NTSTATUS Status;
    WCHAR Buffer[512];

    PWSTR ntPath;

    lstrcpyW(arcPath,L"\\ArcName\\");
#ifdef UNICODE
    lstrcpynW(arcPath+9,ArcPath,ARRAYSIZE(arcPath) - 9);
#else
    MultiByteToWideChar(
        CP_ACP,
        0,
        ArcPath,
        -1,
        arcPath+9,
        (sizeof(arcPath)/sizeof(WCHAR))-9
        );
#endif

    UnicodeString.Buffer = arcPath;
    UnicodeString.Length = (USHORT)lstrlenW(arcPath)*sizeof(WCHAR);
    UnicodeString.MaximumLength = UnicodeString.Length + sizeof(WCHAR);

    InitializeObjectAttributes(
        &Obja,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = (*NtOpenSymLinkRoutine)(
                &ObjectHandle,
                READ_CONTROL | SYMBOLIC_LINK_QUERY,
                &Obja
                );

    if(NT_SUCCESS(Status)) {
        //
        // Query the object to get the link target.
        //
        UnicodeString.Buffer = Buffer;
        UnicodeString.Length = 0;
        UnicodeString.MaximumLength = sizeof(Buffer)-sizeof(WCHAR);

        Status = (*NtQuerSymLinkRoutine)(ObjectHandle,&UnicodeString,NULL);

        CloseHandle(ObjectHandle);

        if(NT_SUCCESS(Status)) {

            Buffer[UnicodeString.Length/sizeof(WCHAR)] = 0;

#ifdef UNICODE
            lstrcpyn(NtPath,Buffer,NtPathBufferLen);
#else
            WideCharToMultiByte(CP_ACP,0,Buffer,-1,NtPath,NtPathBufferLen,NULL,NULL);
#endif

            return(TRUE);
        }
    }

    return(FALSE);
}


BOOL
AppearsToBeSysPart(
    IN PDRIVE_LAYOUT_INFORMATION DriveLayout,
    IN TCHAR                     Drive
    )
{
    PARTITION_INFORMATION PartitionInfo,*p;
    BOOL IsPrimary;
    UINT i;
    DWORD d;

    LPTSTR BootFiles[] = { TEXT("BOOT.INI"),
                           TEXT("NTLDR"),
                           TEXT("NTDETECT.COM"),
                           NULL
                         };

    TCHAR FileName[64];

    //
    // Get partition information for this partition.
    //
    if(!GetPartitionInfo(Drive,&PartitionInfo)) {
        return(FALSE);
    }

    //
    // See if the drive is a primary partition.
    //
    IsPrimary = FALSE;
    for(i=0; i<min(DriveLayout->PartitionCount,4); i++) {

        p = &DriveLayout->PartitionEntry[i];

        if((p->PartitionType != PARTITION_ENTRY_UNUSED)
        && (p->StartingOffset.QuadPart == PartitionInfo.StartingOffset.QuadPart)
        && (p->PartitionLength.QuadPart == PartitionInfo.PartitionLength.QuadPart)) {

            IsPrimary = TRUE;
            break;
        }
    }

    if(!IsPrimary) {
        return(FALSE);
    }

    //
    // Don't rely on the active partition flag.  This could easily not be accurate
    // (like user is using os/2 boot manager, for example).
    //

    //
    // See whether all NT boot files are present on this drive.
    //
    for(i=0; BootFiles[i]; i++) {

        wsprintf(FileName,TEXT("%c:\\%s"),Drive,BootFiles[i]);

        d = GetFileAttributes(FileName);
        if(d == (DWORD)(-1)) {
            return(FALSE);
        }
    }

    return(TRUE);
}


DWORD
QueryHardDiskNumber(
    IN  TCHAR   DriveLetter
    )

{
    TCHAR                   driveName[10];
    HANDLE                  h;
    BOOL                    b;
    STORAGE_DEVICE_NUMBER   number;
    DWORD                   bytes;

    driveName[0] = '\\';
    driveName[1] = '\\';
    driveName[2] = '.';
    driveName[3] = '\\';
    driveName[4] = DriveLetter;
    driveName[5] = ':';
    driveName[6] = 0;

    h = CreateFile(driveName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                   INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return (DWORD) -1;
    }

    b = DeviceIoControl(h, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0,
                        &number, sizeof(number), &bytes, NULL);
    CloseHandle(h);

    if (!b) {
        return (DWORD) -1;
    }

    return number.DeviceNumber;
}

TCHAR
x86DetermineSystemPartition(
    IN  HWND   ParentWindow
    )

/*++

Routine Description:

    Determine the system partition on x86 machines.

    On Win95, we always return C:. For NT, read on.

    The system partition is the primary partition on the boot disk.
    Usually this is the active partition on disk 0 and usually it's C:.
    However the user could have remapped drive letters and generally
    determining the system partition with 100% accuracy is not possible.

    The one thing we can be sure of is that the system partition is on
    the physical hard disk with the arc path multi(0)disk(0)rdisk(0).
    We can be sure of this because by definition this is the arc path
    for bios drive 0x80.

    This routine determines which drive letters represent drives on
    that physical hard drive, and checks each for the nt boot files.
    The first drive found with those files is assumed to be the system
    partition.

    If for some reason we cannot determine the system partition by the above
    method, we simply assume it's C:.

Arguments:

    ParentWindow - supplies window handle for window to be the parent for
        any dialogs, etc.

    SysPartDrive - if successful, receives drive letter of system partition.

Return Value:

    Boolean value indicating whether SysPartDrive has been filled in.
    If FALSE, the user will have been infomred about why.

--*/

{
    TCHAR DriveName[3];
    BOOL  GotIt;
    TCHAR NtDevicePath[256];
    DWORD NtDevicePathLen;
    LPTSTR p;
    DWORD PhysicalDriveNumber;
    TCHAR Buffer[512];
    TCHAR FoundSystemPartition[20], temp[5];
    HANDLE hDisk;
    PDRIVE_LAYOUT_INFORMATION DriveLayout;
    DWORD DriveLayoutSize;
    TCHAR Drive;
    BOOL b;
    DWORD DataSize;
    DWORD BootPartitionNumber, cnt;
    PPARTITION_INFORMATION Start, i;

    if (!g_fInitialized) {
        GotIt = FALSE;
        goto c0;
    }

    if(IsNEC98())
    {
        *Buffer = TEXT('c');  // initialize to C in case GetWindowDirectory fails.
        if (!GetWindowsDirectory(Buffer, ARRAYSIZE(Buffer)))
        {
            *Buffer = TEXT('c');  // initialize to C in case GetWindowDirectory fails.
        }

        return Buffer[0];
    }

    if(!ISNT()) {
       return(TEXT('C'));
    }

    DriveName[1] = TEXT(':');
    DriveName[2] = 0;

    //
    // The system partition must be on multi(0)disk(0)rdisk(0)
    // If we can't translate that ARC path then something is really wrong.
    // We assume C: because we don't know what else to do.
    //
    b = ArcPathToNtPath(
            TEXT("multi(0)disk(0)rdisk(0)"),
            NtDevicePath,
            sizeof(NtDevicePath)/sizeof(TCHAR)
            );

    if(!b) {

        //
        // Missed.  Try scsi(0) in case the user is using ntbootdd.sys
        //
        b = ArcPathToNtPath(
                TEXT("scsi(0)disk(0)rdisk(0)"),
                NtDevicePath,
                sizeof(NtDevicePath)/sizeof(TCHAR)
                );
        if(!b) {
            GotIt = FALSE;
            goto c0;
        }
    }

    //
    // The arc path for a disk device is usually linked
    // to partition0. Get rid of the partition part of the name.
    //
    CharLower(NtDevicePath);
    if(p = _tcsstr(NtDevicePath,TEXT("\\partition"))) {
        *p = 0;
    }

    NtDevicePathLen = lstrlen(NtDevicePath);

    //
    // Determine the physical drive number of this drive.
    // If the name is not of the form \device\harddiskx then
    // something is very wrong. Just assume we don't understand
    // this device type, and return C:.
    //
    if(memcmp(NtDevicePath,TEXT("\\device\\harddisk"),16*sizeof(TCHAR))) {
        Drive = TEXT('C');
        GotIt = TRUE;
        goto c0;
    }

    PhysicalDriveNumber = _tcstoul(NtDevicePath+16,NULL,10);
    wsprintf(Buffer,TEXT("\\\\.\\PhysicalDrive%u"),PhysicalDriveNumber);

    //
    // Get drive layout info for this physical disk.
    // If we can't do this something is very wrong.
    //
    hDisk = CreateFile(
                Buffer,
                FILE_READ_ATTRIBUTES | FILE_READ_DATA,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

    if(hDisk == INVALID_HANDLE_VALUE) {
        GotIt = FALSE;
        goto c0;
    }

    //
    // Get partition information.
    //
    DriveLayout = MALLOC(1024);
    DriveLayoutSize = 1024;
    if(!DriveLayout) {
        GotIt = FALSE;
        goto c1;
    }

    _tcscpy( FoundSystemPartition, TEXT("Partition") );

    retry:

    b = DeviceIoControl(
            hDisk,
            IOCTL_DISK_GET_DRIVE_LAYOUT,
            NULL,
            0,
            (PVOID)DriveLayout,
            DriveLayoutSize,
            &DataSize,
            NULL
            );

    if(!b) {

        if(GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

            DriveLayoutSize += 1024;
            if(p = REALLOC((PVOID)DriveLayout,DriveLayoutSize)) {
                (PVOID)DriveLayout = p;
            } else {
                GotIt = FALSE;
                goto c2;
            }
            goto retry;
        } else {
            GotIt = FALSE;
            goto c2;
        }
    }else{
        // Now walk the Drive_Layout to find the boot partition
        
        Start = DriveLayout->PartitionEntry;
        cnt = 0;

        for( i = Start; cnt < DriveLayout->PartitionCount; i++ ){
            cnt++;
            if( i->BootIndicator == TRUE ){
                BootPartitionNumber = i->PartitionNumber;
                _ultot( BootPartitionNumber, temp, 10 );
                _tcscat( FoundSystemPartition, temp );
                break;
            }
        }

    }

    //
    // The system partition can only be a drive that is on
    // this disk.  We make this determination by looking at NT drive names
    // for each drive letter and seeing if the NT equivalent of
    // multi(0)disk(0)rdisk(0) is a prefix.
    //
    GotIt = FALSE;
    for(Drive=TEXT('A'); Drive<=TEXT('Z'); Drive++) {

        if(MyGetDriveType(Drive) == DRIVE_FIXED) {

            DriveName[0] = Drive;

            if(QueryDosDevice(DriveName,Buffer,sizeof(Buffer)/sizeof(TCHAR))) {

                if( MatchNTSymbolicPaths(NtDevicePath,FoundSystemPartition,Buffer)) {
                    //
                    // Now look to see whether there's an nt boot sector and
                    // boot files on this drive.
                    //
                    if(AppearsToBeSysPart(DriveLayout,Drive)) {
                        GotIt = TRUE;
                        break;
                    }
                }
            }
        }
    }

    if(!GotIt) {
        //
        // Strange case, just assume C:
        //
        GotIt = TRUE;
        Drive = TEXT('C');
    }

c2:
    if (DriveLayout) {
        FREE(DriveLayout);
    }
c1:
    CloseHandle(hDisk);
c0:
    if(GotIt) {
        return(Drive);
    }
    else {
        return(TEXT('C'));
    }
}

BOOL
InitializeArcStuff(
    )
{
    HMODULE NtdllLib;

    if(ISNT()) {
        //
        // On NT ntdll.dll had better be already loaded.
        //
        NtdllLib = LoadLibrary(TEXT("NTDLL"));
        if(!NtdllLib) {

            return(FALSE);

        }

        (FARPROC)NtOpenSymLinkRoutine = GetProcAddress(NtdllLib,"NtOpenSymbolicLinkObject");
        (FARPROC)NtQuerSymLinkRoutine = GetProcAddress(NtdllLib,"NtQuerySymbolicLinkObject");
        (FARPROC)NtOpenDirRoutine = GetProcAddress(NtdllLib,"NtOpenDirectoryObject");
        (FARPROC)NtQuerDirRoutine = GetProcAddress(NtdllLib,"NtQueryDirectoryObject");


        if(!NtOpenSymLinkRoutine || !NtQuerSymLinkRoutine || !NtOpenDirRoutine || !NtQuerDirRoutine) {

            FreeLibrary(NtdllLib);

            return(FALSE);
        }

        //
        // We don't need the extraneous handle any more.
        //
        FreeLibrary(NtdllLib);
    }

    return(g_fInitialized = TRUE);
}


BOOL
MatchNTSymbolicPaths(
    PCTSTR lpDeviceName,
    PCTSTR lpSysPart,
    PCTSTR lpMatchName
    )
/*
    
    Introduced this routine to mend the old way of finding if we determined the right system partition.
   
   Arguments:
    lpDeviceName    -  This should be the symbolic link (\Device\HarddiskX) name for the arcpath 
                       multi/scsi(0)disk(0)rdisk(0) which is the arcpath for bios drive 0x80.  
                       Remember that we strip the PartitionX part to get just \Device\HarddiskX.
                       
    lpSysPart       -  When we traverse the lpDeviceName directory we compare the symbolic link corresponding to
                       lpSysPart and see if it matches lpMatchName
                       
    lpMatchName     -  This is the symbolic name that a drive letter translates to (got by calling 
                       QueryDosDevice() ). 
                       
   So it boils down to us trying to match a drive letter to the system partition on bios drive 0x80.


*/
{
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Attributes;
    HANDLE DirectoryHandle, SymLinkHandle;
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    BOOLEAN RestartScan, ret;
    UCHAR DirInfoBuffer[ 512 ];
    WCHAR Buffer[1024];
    WCHAR pDevice[512], pMatch[512], pSysPart[20];
    ULONG Context = 0;
    ULONG ReturnedLength;
    


#ifdef UNICODE
    lstrcpyW( pDevice,lpDeviceName);
    lstrcpyW( pMatch,lpMatchName);
    lstrcpyW( pSysPart,lpSysPart);
#else
    MultiByteToWideChar(
        CP_ACP,
        0,
        lpDeviceName,
        -1,
        pDevice,
        (sizeof(pDevice)/sizeof(WCHAR))
        );
    MultiByteToWideChar(
        CP_ACP,
        0,
        lpMatchName,
        -1,
        pMatch,
        (sizeof(pMatch)/sizeof(WCHAR))
        );
    MultiByteToWideChar(
        CP_ACP,
        0,
        lpSysPart,
        -1,
        pSysPart,
        (sizeof(pSysPart)/sizeof(WCHAR))
        );
#endif


    UnicodeString.Buffer = pDevice;
    UnicodeString.Length = (USHORT)lstrlenW(pDevice)*sizeof(WCHAR);
    UnicodeString.MaximumLength = UnicodeString.Length + sizeof(WCHAR);

    InitializeObjectAttributes( &Attributes,
                                &UnicodeString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );
    Status = (*NtOpenDirRoutine)( &DirectoryHandle,
                                    DIRECTORY_QUERY,
                                    &Attributes
                                  );
    if (!NT_SUCCESS( Status ))
        return(FALSE);
        

    RestartScan = TRUE;
    DirInfo = (POBJECT_DIRECTORY_INFORMATION)&DirInfoBuffer;
    ret = FALSE;
    while (TRUE) {
        Status = (*NtQuerDirRoutine)( DirectoryHandle,
                                         (PVOID)DirInfo,
                                         sizeof( DirInfoBuffer ),
                                         TRUE,
                                         RestartScan,
                                         &Context,
                                         &ReturnedLength
                                       );

        //
        //  Check the status of the operation.
        //

        if (!NT_SUCCESS( Status )) {
            if (Status == STATUS_NO_MORE_ENTRIES) {
                Status = STATUS_SUCCESS;
                }

            break;
            }

        if (!wcsncmp( DirInfo->TypeName.Buffer, L"SymbolicLink", DirInfo->TypeName.Length ) && 
            !_wcsnicmp( DirInfo->Name.Buffer, pSysPart, DirInfo->Name.Length ) ) {


            UnicodeString.Buffer = DirInfo->Name.Buffer;
            UnicodeString.Length = (USHORT)lstrlenW(DirInfo->Name.Buffer)*sizeof(WCHAR);
            UnicodeString.MaximumLength = UnicodeString.Length + sizeof(WCHAR);
            InitializeObjectAttributes( &Attributes,
                                &UnicodeString,
                                OBJ_CASE_INSENSITIVE,
                                DirectoryHandle,
                                NULL
                              );


            Status = (*NtOpenSymLinkRoutine)(
                &SymLinkHandle,
                READ_CONTROL | SYMBOLIC_LINK_QUERY,
                &Attributes
                );

            if(NT_SUCCESS(Status)) {
                //
                // Query the object to get the link target.
                //
                UnicodeString.Buffer = Buffer;
                UnicodeString.Length = 0;
                UnicodeString.MaximumLength = sizeof(Buffer)-sizeof(WCHAR);
        
                Status = (*NtQuerSymLinkRoutine)(SymLinkHandle,&UnicodeString,NULL);
        
                CloseHandle(SymLinkHandle);
                
                if( NT_SUCCESS(Status)){
            
                    if (!_wcsnicmp(UnicodeString.Buffer, pMatch, (UnicodeString.Length/sizeof(WCHAR)))) {
                        ret = TRUE;
                        break;
                    }
                }
            
            }

        }

        RestartScan = FALSE;
    }
    CloseHandle( DirectoryHandle );

    return( ret );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\startup.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    startup.h

Abstract:

    Public declarations for the Startup/Recovery dialog of the System
    Control Panel Applet

Notes:

    The virtual memory settings and the crash dump (core dump) settings
    are tightly-coupled.  Therefore, crashdmp.c and startup.h have some
    heavy dependencies on virtual.c and virtual.h (and vice versa).

    On the other hand, the startup OS settings and the crash dump settings
    have almost nothing in common, so you won't see a lot of dependencies
    between these files (strlst.c/startup.c and crashdmp.c), even
    though they're on the same dialog.

Author:

    Eric Flo (ericflo) 19-Jun-1995

Revision History:

    15-Oct-1997 scotthal
        Complete overhaul

--*/
#ifndef _SYSDM_STARTUP_H_
#define _SYSDM_STARTUP_H_

//
// Constants
//

// Range of valid "Display startup list for..." values
#define FORMIN       0
#define FORMAX     999
// Length of WCHAR buffer needed to hold "Display startup list for..." value
#define FOR_MAX_LENGTH 20

// Default "Display startup list for..." value
#define FORDEF      30

// Crash dump constants
#define IDRV_DEF_BOOT       2       // Asssume booting from C:
#define MIN_SWAPSIZE        2       // Min swap file size.
#define ONE_MEG             1048576

// Set during initialization so we don't think changes made to controls
// during initialization are the same as changes made to controls by
// the user.

extern BOOL g_fStartupInitializing;

//
// Function Declarations
//
HPROPSHEETPAGE 
CreateStartupPage(
    IN HINSTANCE hInst
);

INT_PTR 
APIENTRY 
StartupDlgProc(
    IN HWND hDlg, 
    IN UINT uMsg, 
    IN WPARAM wParam, 
    IN LPARAM lParam
);


//
// Functions implemented in strtlst.c
//
void 
StartListInit( 
    IN HWND hDlg, 
    IN WPARAM wParam, 
    IN LPARAM lParam 
);

int 
StartListExit(
    IN HWND hDlg, 
    IN WPARAM wParam, 
    IN LPARAM lParam 
);

void 
StartListDestroy(
    IN HWND hDlg, 
    IN WPARAM wParam, 
    IN LPARAM lParam
);

BOOL 
CheckVal( 
    IN HWND hDlg, 
    IN WORD wID, 
    IN WORD wMin, 
    IN WORD wMax, 
    IN WORD wMsgID 
);

void
AutoAdvancedBootInit(
    IN HWND hDlg,
    IN WPARAM wParam,
    IN LPARAM lParam
);

int
AutoAdvancedBootExit(
    IN HWND hDlg,
    IN WPARAM wParam,
    IN LPARAM lParam
);

//
// Get the system drive. Exported by crashdmp.c.
//

BOOL
GetSystemDrive(
    OUT TCHAR * Drive
    );

ULONG64
CoreDumpGetRequiredFileSize(
    IN HWND hDlg OPTIONAL
    );

//
// This isn't a real dlg proc -- the return value is a bool.
//

int
APIENTRY
CoreDumpDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );


#endif // _SYSDM_STATUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\sysdm.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    sysdm.h

Abstract:

    Applet-wide declaraions and definitions for the 
    System Control Panel Applet.

Author:

    Eric Flo (ericflo) 19-Jun-1995

Revision History:

    15-Oct-1997 scotthal
        Complete overhaul

--*/
#ifndef _SYSDM_H_
#define _SYSDM_H_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <windows.h>
#include <commctrl.h>
#include <comctrlp.h>
#include <shellapi.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <cpl.h>

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus
#include "resource.h"
#include "helpid.h"
#include "util.h"
#include "sid.h"
#include "general.h"
#include "netid.h"
#include "hardware.h"
#include "hwprof.h"
#include "profile.h"
#include "advanced.h"
#include "perf.h"
#include "virtual.h"
#include "startup.h"
#include "envvar.h"
#include "edtenvar.h"
#include "syspart.h"
#include "pfrscpl.h"
#include "srcfg.h"
#include "visualfx.h"

//
// Global variables
//
extern TCHAR g_szErrMem[ 200 ];         //  Low memory message
extern TCHAR g_szSystemApplet[ 100 ];   //  "System Control Panel Applet" title
extern HINSTANCE hInstance;
extern TCHAR g_szNull[];
extern BOOL g_fRebootRequired;


//
// Macros
//

#define ZeroInit(pv, cb)            (memset((pv), 0, (cb)))

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))
#define SIZEOF(x)    sizeof(x)

#define SetLBWidth( hwndLB, szStr, cxCurWidth )     SetLBWidthEx( hwndLB, szStr, cxCurWidth, 0)

#define IsPathSep(ch)       ((ch) == TEXT('\\') || (ch) == TEXT('/'))
#define IsWhiteSpace(ch)    ((ch) == TEXT(' ') || (ch) == TEXT('\t') || (ch) == TEXT('\n') || (ch) == TEXT('\r'))
#define IsDigit(ch)         ((ch) >= TEXT('0') && (ch) <= TEXT('9'))

#define DigitVal(ch)        ((ch) - TEXT('0'))
#define FmtFree(s)          LocalFree(s)            /* Macro to free FormatMessage allocated strings */

#define MAX_PAGES           16  // Arbitrary Maximum number of pages in the System Control Panel.


typedef HPROPSHEETPAGE (*PSPCALLBACK)(int idd, DLGPROC pfnDlgProc);

typedef struct
{
    PSPCALLBACK pfnCreatePage;
    int idd;
    DLGPROC pfnDlgProc;
}
PSPINFO;

HPROPSHEETPAGE CreatePage(int idd, DLGPROC pfnDlgProc);


//
// Debugging macros
//
#if DBG
#   define  DBG_CODE    1

void DbgPrintf( LPTSTR szFmt, ... );
void DbgStopX(LPSTR mszFile, int iLine, LPTSTR szText );
HLOCAL MemAllocWorker(LPSTR szFile, int iLine, UINT uFlags, UINT cBytes);
HLOCAL MemFreeWorker(LPSTR szFile, int iLine, HLOCAL hMem);
void MemExitCheckWorker(void);


#   define  MemAlloc( f, s )    MemAllocWorker( __FILE__, __LINE__, f, s )
#   define  MemFree( h )        MemFreeWorker( __FILE__, __LINE__, h )
#   define  MEM_EXIT_CHECK()    MemExitCheckWorker()
#   define  DBGSTOP( t )        DbgStopX( __FILE__, __LINE__, TEXT(t) )
#   define  DBGSTOPX( f, l, t ) DbgStopX( f, l, TEXT(t) )
#   define  DBGPRINTF(p)        DbgPrintf p
#   define  DBGOUT(t)           DbgPrintf( TEXT("SYSDM.CPL: %s\n"), TEXT(t) )
#else
#   define  MemAlloc( f, s )    LocalAlloc( f, s )
#   define  MemFree( h )        LocalFree( h )
#   define  MEM_EXIT_CHECK()
#   define  DBGSTOP( t )
#   define  DBGSTOPX( f, l, t )
#   define  DBGPRINTF(p)
#   define  DBGOUT(t)
#endif

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#endif // _SYSDM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\strtlst.c ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    strtlst.c

Abstract:

    Implements the controls in the "Startup" group on the
    Startup/Recovery dialog of the System Control Panel Applet

Revision History:

    23-Jan-1996 JonPa
        ported from NT3.51's system.cpl

--*/
#include "sysdm.h"

///////////////////////////////////////////////////////////////
//          Persistant  vars
///////////////////////////////////////////////////////////////
static TCHAR *pszBoot = NULL;
static int nOriginalSelection;
static int nOriginalTimeout;

HANDLE hBootStatusData = NULL;

/*
 * These functions in SETUPDLL.DLL are ANSI only!!!!
 *
 * Therefore any functions working with this DLL MUST remain ANSI only.
 * The functions are GetRGSZEnvVar and UpdateNVRAM.
 * The structure CPEnvBuf MUST also remain ANSI only.
 */
typedef int (WINAPI *GETNVRAMPROC)(CHAR **, USHORT, CHAR *, USHORT);
typedef int (WINAPI *WRITENVRAMPROC)(DWORD, PSZ *, PSZ *);

#ifdef _X86_

char szBootIniA[]     = "c:\\boot.ini";
TCHAR szBootIni[]     = TEXT( "c:\\boot.ini" );
TCHAR szBootLdr[]     = TEXT( "boot loader" );
TCHAR szFlexBoot[]    = TEXT( "flexboot" );
TCHAR szMultiBoot[]   = TEXT( "multiboot" );
TCHAR szTimeout[]     = TEXT( "timeout" );
TCHAR szDefault[]     = TEXT( "default" );
char szOSA[]          = "operating systems";

#define BUFZ        4096

//
// For NEC PC98. Following definition comes from user\inc\kbd.h.
// The value must be the same as value in kbd.h.
//
#define NLSKBD_OEM_NEC   0x0D

TCHAR x86DetermineSystemPartition( IN HWND hdlg );

#endif

#if defined(EFI_NVRAM_ENABLED)

//
// IsEfi() is always true on IA64 machines. Therefore this determination can
// be made at compile time. When x86 EFI machines are supported, the check
// will need to be made at run time on x86.
//

#if defined(_IA64_)
#define IsEfi() TRUE
#else
BOOLEAN
IsEfi(
    VOID
    );
#endif

typedef struct _MY_BOOT_ENTRY {
    LIST_ENTRY ListEntry;
    PWSTR FriendlyName;
    int Index;
    LOGICAL Show;
    LOGICAL Ordered;
    PBOOT_ENTRY NtBootEntry;
} MY_BOOT_ENTRY, *PMY_BOOT_ENTRY;

LIST_ENTRY BootEntries;
PBOOT_ENTRY_LIST BootEntryList = NULL;
PBOOT_OPTIONS BootOptions;

#define ADD_OFFSET(_p,_o) (PVOID)((PUCHAR)(_p) + (_p)->_o)

#endif // defined(EFI_NVRAM_ENABLED)

     // v-pshuan: since the Silicon Graphics visual workstations boot
     // ARC style, this code needs to be compiled for _X86_ as well.

static HMODULE hmodSetupDll;   // hmod for setup - has api we need
static GETNVRAMPROC fpGetNVRAMvar;  // address of function for getting nvram vars
BOOL fCanUpdateNVRAM;

#define MAX_BOOT_ENTRIES 10

typedef struct tagEnvBuf
{
  int     cEntries;
  CHAR *  pszVars[MAX_BOOT_ENTRIES];
  // v-pshuan: this implies a maximum of 10 boot entries are supported
  // although no error checking is performed in the existing parsing code
  // to make sure there aren't more than 10 boot entries.
} CPEnvBuf;

//*************************************************************
//
//  StringToIntA
//
//  Purpose:    atoi
//
//  Parameters: LPSTR sz - pointer of string to convert
//
//  Return:     void
//
//  WARNING:  Unlike StringToInt, this one does not skip leading
//  white space
//
//*************************************************************
int StringToIntA( LPSTR sz ) {
    int i = 0;

    while( IsDigit( *sz ) ) {
        i = i * 10 + (*sz - '0');
        sz++;
    }

    return i;
}

//*************************************************************
//
//  IntToStringA
//
//  Purpose:    itoa
//
//  Parameters: INT    i    - integer to convert
//              LPSTR sz   - pointer where to put the result
//
//  Return:     void
//
//*************************************************************
#define CCH_MAX_DEC 12         // Number of chars needed to hold 2^32

void IntToStringA( INT i, LPSTR sz) {
    CHAR szTemp[CCH_MAX_DEC];
    int iChr;


    iChr = 0;

    do {
        szTemp[iChr++] = '0' + (i % 10);
        i = i / 10;
    } while (i != 0);

    do {
        iChr--;
        *sz++ = szTemp[iChr];
    } while (iChr != 0);

    *sz++ = '\0';
}

////////////////////////////////////////////////////////////////////////////
//  CP_MAX_ENV assumes entire env. var. value < maxpath +
//  add 20 for various quotes
//  and 10 more for commas (see list description below)
////////////////////////////////////////////////////////////////////////////
#define CP_MAX_ENV   (MAX_PATH + 30)

CPEnvBuf CPEBOSLoadIdentifier;
BOOL fAutoLoad;

//////////////////////////////////////////////////////////////////////
//
// Identify whether we are running on an x86 system which nevertheless
// boots using the ARC path (no c:\boot.ini)
//
//////////////////////////////////////////////////////////////////////

BOOL Is_ARCx86(void)
{
    TCHAR identifier[256];
    ULONG identifierSize = sizeof(identifier);
    HKEY hSystemKey = NULL;
    BOOL rval = FALSE;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     TEXT("HARDWARE\\DESCRIPTION\\System"),
                     0,
                     KEY_QUERY_VALUE,
                     &hSystemKey) == ERROR_SUCCESS) {
        if ((RegQueryValueEx(hSystemKey,
                             TEXT("Identifier"),
                             NULL,
                             NULL,
                             (LPBYTE) identifier,
                             &identifierSize) == ERROR_SUCCESS) &&
            (wcsstr(identifier, TEXT("ARCx86")) != NULL)) {
            rval = TRUE;
        }
        RegCloseKey(hSystemKey);
    }
    return rval;
}

////////////////////////////////////////////////////////////////////////////
//
//  This routine will query the ARC NVRAM for an option passed
//  in szName and fill in the argv style pointer passed in.
//
////////////////////////////////////////////////////////////////////////////

BOOL GetRGSZEnvVar(CPEnvBuf * pEnvBuf, PCHAR pszName)
{
    CHAR   *pszCur, *p;
    int     cb, i;
    CHAR   *rgtmp[1];
    CHAR    rgchOut[CP_MAX_ENV*MAX_BOOT_ENTRIES];

    // GetNVRAMVar takes an argv[] style paramater as input, so crock
    // one up.
    rgtmp[0] = pszName;

    // GetNVRAMVar returns a 'list' of the form
    //   open-curly"string1","string2","string3"close-curly
    //
    // an empty environment string will be 5 bytes:
    // open-curly""close-curly[null-terminator]

    cb = fpGetNVRAMvar (rgtmp, (USHORT)1,
                rgchOut, (USHORT) CP_MAX_ENV*MAX_BOOT_ENTRIES);

    pEnvBuf->cEntries = 0;

    // if cb was equal to 5, the string was empty (see above comment)
    if (cb > 5)
    {
        // break the string up into array of separate strings that
        // can be put into a listbox.
        pszCur = rgchOut;

        // skip first open-curly brace
        pszCur++;

        // counter for array of strings
        i = 0;
        while (*pszCur != '}')
        {
            p = pEnvBuf->pszVars[i] = MemAlloc (LPTR, MAX_PATH);
            
            // PREFIX change to prevent a potential NULL dereference
            if (!p)
            {
                pEnvBuf->cEntries = i;
                return FALSE;
            }

            // skip first quote
            pszCur++;
            while (*pszCur != '"')
               *p++ = *pszCur++;

            // skip the close quote
            pszCur++;

            // null terminate destination
            *p = '\0';

            // skip the comma if not at end of string
            if (*pszCur == ',')
            {
               pszCur++;
               // and go to next string
            }
            i++;
        }
        pEnvBuf->cEntries = i;
    }

    return pEnvBuf->cEntries;
}

////////////////////////////////////////////////////////////////////////////
//
//  This routine will free the memory allocated by GetRGSZEnvVar
//
//  History:
//      22-Apr-1996 JonPa   Created it.
//
////////////////////////////////////////////////////////////////////////////
void FreeRGSZEnvVar(CPEnvBuf * pEnvBuf) {
    int i;

    for( i = 0; i < pEnvBuf->cEntries; i++ ) {
        MemFree( pEnvBuf->pszVars[i] );
    }
}

////////////////////////////////////////////////////////////////////////////
// The user has made a choice among the entries.
// Now we have to arrange all the strings stored in NVRAM so
// that they  have the same ordering.  The selection is passed in,
// so what this  function does is if selection is M, it makes the Mth item
// appear first in each of the 5 environment strings and the other items
// follow it in the list.
//
// Then if the timeout button is checked, it updates the AUTOLOAD variable
// to "yes" and set the COUNTDOWN variable to the number of seconds in the
// edit control.
//
////////////////////////////////////////////////////////////////////////////

BOOL UpdateNVRAM(HWND hdlg, int selection, int timeout)
{
    CHAR *rgszVRAM[5] = { "SYSTEMPARTITION",
                          "OSLOADER",
                          "OSLOADPARTITION",
                          "OSLOADFILENAME",
                          "OSLOADOPTIONS"
                        };
    CPEnvBuf rgcpeb[5];


    WRITENVRAMPROC fpWriteNVRAMVar;
    int iTemp, jTemp;
    CHAR *pszSwap;
    CHAR szTemp[10];
    HMODULE hmodSetupDLL;
    BOOL bChecked;

    // args and charray are needed for call to SetNVRamVar() in SETUP
    PSZ args[2];
    CHAR chArray[CP_MAX_ENV*MAX_BOOT_ENTRIES];
    PSZ pszReturn;

    if ((hmodSetupDll = LoadLibrary (TEXT("setupdll"))) == NULL)
        return(FALSE);

    fpWriteNVRAMVar = (WRITENVRAMPROC) GetProcAddress(hmodSetupDll, "SetNVRAMVar");
    if (fpWriteNVRAMVar == NULL)
        return(FALSE);

    // 0 is always the selection when the dialog is brought up,
    // so as an optimization don't update the nvram if it's
    // not necessary.
    if (selection != 0)
    {
       // read in the strings from NVRAM.  the number of strings (other than
       // LOADIDENTIFIER is 5)
       for (iTemp = 0; iTemp < 5; iTemp++)
       {
           GetRGSZEnvVar (&rgcpeb[iTemp], rgszVRAM[iTemp]);
           // now re-order the strings to swap the 'selection-th' item
           // string with the first string.
           pszSwap = rgcpeb[iTemp].pszVars[0];
           rgcpeb[iTemp].pszVars[0] = rgcpeb[iTemp].pszVars[selection];
           rgcpeb[iTemp].pszVars[selection] = pszSwap;
       }
       // now do the same for the LOADIDENTIFIER, (this was set up earlier
       // in the processing the INITDIALOG message).
       pszSwap = CPEBOSLoadIdentifier.pszVars[0];
       CPEBOSLoadIdentifier.pszVars[0] = CPEBOSLoadIdentifier.pszVars[selection];
       CPEBOSLoadIdentifier.pszVars[selection] = pszSwap;

       // now write to NVRAM:  first write LOADIDENTIFIER, then the other 5
       // variables.
       args[0] = (PSZ)"LOADIDENTIFIER";
       args[1] = chArray;

       chArray[0] = '\0';
       for (iTemp = 0; iTemp < CPEBOSLoadIdentifier.cEntries; iTemp++)
       {
           lstrcatA (chArray, CPEBOSLoadIdentifier.pszVars[iTemp]);
           lstrcatA (chArray, ";");
       }
       // remove the last semi-colon:
       chArray[lstrlenA(chArray)-1] = '\0';

       fpWriteNVRAMVar ((DWORD)2, args, &pszReturn);

       for (iTemp = 0; iTemp < 5; iTemp++)
       {
           args[0] = rgszVRAM[iTemp];
           args[1] = chArray;
           chArray[0] = '\0';
           for (jTemp = 0; jTemp < rgcpeb[iTemp].cEntries; jTemp++)
           {
               lstrcatA (chArray, rgcpeb[iTemp].pszVars[jTemp]);
               lstrcatA (chArray, ";");
           }
           chArray[lstrlenA(chArray)-1] = '\0';

           fpWriteNVRAMVar ((DWORD)2, args, &pszReturn);

           // We are done with this variable... Free the resources it consumes
           FreeRGSZEnvVar( &rgcpeb[iTemp] );
       }

    }
    args[0] = "AUTOLOAD";
    if (bChecked = IsDlgButtonChecked (hdlg, IDC_STARTUP_SYS_ENABLECOUNTDOWN))
       args[1] = "YES";
    else
       args[1] = "";

    fpWriteNVRAMVar ((DWORD)2, args, &pszReturn);
    // This is a temporary hack workaround for the fact that the
    // AUTOLOAD variable seems to be broken on Alpha
//    if (bChecked)
//    {
       args[0] = "COUNTDOWN";
       IntToStringA(timeout, szTemp);
       args[1] = szTemp;
       fpWriteNVRAMVar ((DWORD)2, args, &pszReturn);
//    }
    FreeLibrary (hmodSetupDll);

    return TRUE;
}

#if defined(EFI_NVRAM_ENABLED)

////////////////////////////////////////////////////////////////////////////
//
//  This routine frees allocations related to EFI Boot Manager information
//  from NVRAM.
//
////////////////////////////////////////////////////////////////////////////

VOID
FreeEfiBootEntries (
    VOID
    )
{
    PLIST_ENTRY listEntry;
    PMY_BOOT_ENTRY myBootEntry;

    while (!IsListEmpty(&BootEntries)) {
        listEntry = RemoveHeadList(&BootEntries);
        myBootEntry = CONTAINING_RECORD(listEntry, MY_BOOT_ENTRY, ListEntry);
        MemFree(myBootEntry);
    }
    if (BootEntryList != NULL) {
        MemFree(BootEntryList);
        BootEntryList = NULL;
    }
    if (BootOptions != NULL) {
        MemFree(BootOptions);
        BootOptions = NULL;
    }

    return;

} // FreeEfiBootEntries

////////////////////////////////////////////////////////////////////////////
//
//  This routine reads EFI Boot Manager information from NVRAM.
//
////////////////////////////////////////////////////////////////////////////

BOOL
ReadEfiBootEntries (
    VOID
    )
{
    NTSTATUS status;
    ULONG length;
    ULONG count;
    PULONG order = NULL;
    PBOOT_ENTRY_LIST bootEntryList;
    PBOOT_ENTRY bootEntry;
    PMY_BOOT_ENTRY myBootEntry;
    PLIST_ENTRY listEntry;
    LONG i;
    BOOLEAN wasEnabled;
    BOOL retval = FALSE;

    InitializeListHead(&BootEntries);

    //
    // Enable the privilege that is necessary to query NVRAM.
    //

    status = RtlAdjustPrivilege(
                SE_SYSTEM_ENVIRONMENT_PRIVILEGE,
                TRUE,
                FALSE,
                &wasEnabled
                );
    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    //
    // Get the global system boot options.
    //
    length = 0;
    status = NtQueryBootOptions(NULL, &length);

    if (status != STATUS_BUFFER_TOO_SMALL) {

        ASSERT(FALSE);
        goto error;

    } else {

        BootOptions = MemAlloc(LPTR, length);
        if (BootOptions == NULL) {
            goto error;
        }

        status = NtQueryBootOptions(BootOptions, &length);

        if (status != STATUS_SUCCESS) {
            ASSERT(FALSE);
            goto error;
        }
    }

    //
    // Get the system boot order list.
    //
    count = 0;
    status = NtQueryBootEntryOrder(NULL, &count);

    if (status != STATUS_BUFFER_TOO_SMALL) {

        if (status == STATUS_SUCCESS) {

            //
            // There are no entries in the boot order list. Strange but
            // possible.
            //
            count = 0;

        } else {

            //
            // An unexpected error occurred.
            //
            ASSERT(FALSE);
            goto error;
        }
    }

    if (count != 0) {

        order = MemAlloc(LPTR, count * sizeof(ULONG));
        if (order == NULL) {
            goto error;
        }

        status = NtQueryBootEntryOrder(order, &count);

        if (status != STATUS_SUCCESS) {

            //
            // An unexpected error occurred.
            //
            ASSERT(FALSE);
            goto error;
        }
    }

    //
    // Get all existing boot entries.
    //
    length = 0;
    status = NtEnumerateBootEntries(NULL, &length);

    if (status != STATUS_BUFFER_TOO_SMALL) {

        if (status == STATUS_SUCCESS) {

            //
            // Somehow there are no boot entries in NVRAM.
            //
            goto error;

        } else {

            //
            // An unexpected error occurred.
            //
            ASSERT(FALSE);
            goto error;
        }
    }

    ASSERT(length != 0);
    
    BootEntryList = MemAlloc(LPTR, length);
    if (BootEntryList == NULL) {
        goto error;
    }

    status = NtEnumerateBootEntries(BootEntryList, &length);

    if (status != STATUS_SUCCESS) {
        ASSERT(FALSE);
        goto error;
    }

    //
    // Convert the boot entries into our internal representation.
    //
    bootEntryList = BootEntryList;

    while (TRUE) {

        bootEntry = &bootEntryList->BootEntry;

        //
        // Allocate an internal structure for the boot entry.
        //
        myBootEntry = MemAlloc(LPTR, sizeof(MY_BOOT_ENTRY));
        if (myBootEntry == NULL) {
            goto error;
        }

        RtlZeroMemory(myBootEntry, sizeof(MY_BOOT_ENTRY));

        //
        // Save the address of the NT boot entry.
        //
        myBootEntry->NtBootEntry = bootEntry;

        //
        // Save the address of the entry's friendly name.
        //
        myBootEntry->FriendlyName = ADD_OFFSET(bootEntry, FriendlyNameOffset);

        //
        // Link the new entry into the list.
        //
        InsertTailList(&BootEntries, &myBootEntry->ListEntry);

        //
        // Move to the next entry in the enumeration list, if any.
        //
        if (bootEntryList->NextEntryOffset == 0) {
            break;
        }
        bootEntryList = ADD_OFFSET(bootEntryList, NextEntryOffset);
    }

    //
    // Boot entries are returned in an unspecified order. They are currently
    // in the SpBootEntries list in the order in which they were returned.
    // Sort the boot entry list based on the boot order. Do this by walking
    // the boot order array backwards, reinserting the entry corresponding to
    // each element of the array at the head of the list.
    //

    for (i = (LONG)count - 1; i >= 0; i--) {

        for (listEntry = BootEntries.Flink;
             listEntry != &BootEntries;
             listEntry = listEntry->Flink) {

            myBootEntry = CONTAINING_RECORD(listEntry, MY_BOOT_ENTRY, ListEntry);

            if (myBootEntry->NtBootEntry->Id == order[i] ) {

                //
                // We found the boot entry with this ID. Move it to the
                // front of the list.
                //

                myBootEntry->Ordered = TRUE;

                RemoveEntryList(&myBootEntry->ListEntry);
                InsertHeadList(&BootEntries, &myBootEntry->ListEntry);

                break;
            }
        }
    }

    //
    // Free the boot order list.
    //
    if (count != 0) {
        MemFree(order);
        order = NULL;
    }

    //
    // We don't want to show entries that are not in the boot order list.
    // We don't want to show removable media entries (for floppy or CD).
    // We do show non-NT entries.
    //
    count = 0;
    for (listEntry = BootEntries.Flink;
         listEntry != &BootEntries;
         listEntry = listEntry->Flink) {

        myBootEntry = CONTAINING_RECORD(listEntry, MY_BOOT_ENTRY, ListEntry);

        if (myBootEntry->Ordered &&
            ((myBootEntry->NtBootEntry->Attributes & BOOT_ENTRY_ATTRIBUTE_REMOVABLE_MEDIA) == 0)) {
            myBootEntry->Show = TRUE;
            count++;
        }
    }

    //
    // If we don't have any entries to show, disable the dialog box entirely.
    //
    if (count == 0) {
        goto error;
    }

    retval = TRUE;

done:

    if (!wasEnabled) {
        status = RtlAdjustPrivilege(
                    SE_SYSTEM_ENVIRONMENT_PRIVILEGE,
                    FALSE,
                    FALSE,
                    &wasEnabled
                    );
    }

    return retval;

error:

    //
    // An error occurred. Clean up all allocations.
    //
    if (order != NULL) {
        MemFree(order);
    }
    FreeEfiBootEntries();

    goto done;

} // ReadEfiBootEntries

////////////////////////////////////////////////////////////////////////////
//
// EFI version of UpdateNVRAM.
//
// The user has made a choice among the entries. Rewrite the boot order
// list to put the user's selection at the front. Also update the Timeout
// variable.
//
////////////////////////////////////////////////////////////////////////////

BOOL
WriteEfiBootEntries (
    HWND hdlg,
    int selection,
    int timeout
    )
{
    NTSTATUS status;
    BOOLEAN wasEnabled;
    BOOL retval = FALSE;

    //
    // Enable the privilege that is necessary to query NVRAM.
    //

    status = RtlAdjustPrivilege(
                SE_SYSTEM_ENVIRONMENT_PRIVILEGE,
                TRUE,
                FALSE,
                &wasEnabled
                );
    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    //
    // 0 is always the selection when the dialog is brought up,
    // so as an optimization don't update the nvram if it's
    // not necessary.
    //
    if (selection != 0) {

        //
        // Walk the boot entry list, looking for (a) the entry with combo box
        // index 0, and (b) the selected entry. We want to swap these two
        // entries.
        //

        PLIST_ENTRY listEntry;
        PMY_BOOT_ENTRY myBootEntry;
        PMY_BOOT_ENTRY firstEntry = NULL;
        PMY_BOOT_ENTRY selectedEntry = NULL;
        PLIST_ENTRY previousEntry;
        ULONG count;
        PULONG order;

        for (listEntry = BootEntries.Flink;
             listEntry != &BootEntries;
             listEntry = listEntry->Flink) {

            myBootEntry = CONTAINING_RECORD(listEntry, MY_BOOT_ENTRY, ListEntry);

            if (myBootEntry->Show) {
                if (myBootEntry->Index == 0) {
                    firstEntry = myBootEntry;
                } else if (myBootEntry->Index == selection) {
                    selectedEntry = myBootEntry;
                }
            }
        }

        ASSERT(firstEntry != NULL);
        ASSERT(selectedEntry != NULL);
        ASSERT(selectedEntry != firstEntry);

        //
        // Swap the entries. Capture the address of the entry before the first
        // entry (which might be the list head). Remove the first entry from
        // the list and insert it after the selected entry. Remove the selected
        // entry from the list and insert it after the captured entry.
        //

        previousEntry = firstEntry->ListEntry.Blink;
        RemoveEntryList(&firstEntry->ListEntry);
        InsertHeadList(&selectedEntry->ListEntry, &firstEntry->ListEntry);
        RemoveEntryList(&selectedEntry->ListEntry);
        InsertHeadList(previousEntry, &selectedEntry->ListEntry);

        //
        // Build the new boot order list. Insert all ordered boot entries
        // into the list.
        //
        count = 0;
        for (listEntry = BootEntries.Flink;
             listEntry != &BootEntries;
             listEntry = listEntry->Flink) {

            myBootEntry = CONTAINING_RECORD(listEntry, MY_BOOT_ENTRY, ListEntry);
            if (myBootEntry->Ordered) {
                count++;
            }
        }
        order = MemAlloc(LPTR, count * sizeof(ULONG));
        if (order == NULL) {
            goto done;
        }

        count = 0;
        for (listEntry = BootEntries.Flink;
             listEntry != &BootEntries;
             listEntry = listEntry->Flink) {

            myBootEntry = CONTAINING_RECORD(listEntry, MY_BOOT_ENTRY, ListEntry);
            if (myBootEntry->Ordered) {
                order[count++] = myBootEntry->NtBootEntry->Id;
            }
        }
    
        //
        // Write the new boot entry order list to NVRAM.
        //
        status = NtSetBootEntryOrder(order, count);
        MemFree(order);
        if (!NT_SUCCESS(status)) {
            goto done;
        }
    }

    //
    // Write the new timeout value to NVRAM.
    //
    if (!IsDlgButtonChecked(hdlg, IDC_STARTUP_SYS_ENABLECOUNTDOWN)) {
        timeout = 0xffffffff;
    }

    if (timeout != BootOptions->Timeout) {

        BootOptions->Timeout = timeout;

        status = NtSetBootOptions(BootOptions, BOOT_OPTIONS_FIELD_TIMEOUT);
        if (!NT_SUCCESS(status)) {
            goto done;
        }
    }

    retval = TRUE;

done:

    if (!wasEnabled) {
        status = RtlAdjustPrivilege(
                    SE_SYSTEM_ENVIRONMENT_PRIVILEGE,
                    FALSE,
                    FALSE,
                    &wasEnabled
                    );
    }
    
    return retval;

} // WriteEfiBootEntries

#endif // defined(EFI_NVRAM_ENABLED)

#ifdef _X86_
BOOL WriteableBootIni( LPTSTR szBootIni, HWND hDlg ) {
    BOOL bOK;
    DWORD dwFileAttr;
    HANDLE hFile;

    bOK = TRUE;

    //  Change Read-only file attrs on Boot.ini file if necessary
    if ((dwFileAttr = GetFileAttributes (szBootIni)) != 0xFFFFFFFF) {
        if (dwFileAttr & FILE_ATTRIBUTE_READONLY) {
            if (!SetFileAttributes (szBootIni, dwFileAttr & ~FILE_ATTRIBUTE_READONLY))
            {
                bOK = FALSE;
            }
        }
    }

    if (bOK)
    {

        hFile = CreateFile( szBootIni, GENERIC_WRITE | GENERIC_READ, FILE_SHARE_WRITE | FILE_SHARE_READ, NULL,
                OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );

        if (hFile != INVALID_HANDLE_VALUE) {
            CloseHandle(hFile);
        } else {
            if (GetLastError() == ERROR_FILE_NOT_FOUND || GetLastError() == ERROR_PATH_NOT_FOUND) {
                MsgBoxParam (hDlg, IDS_SYSDM_CANNOTOPENFILE, IDS_SYSDM_TITLE, MB_OK | MB_ICONEXCLAMATION, szBootIni);
            }
            bOK = FALSE;
        }

        //  Restore read-only attr, if necessary, after writes
        if (dwFileAttr != 0xFFFFFFFF && (dwFileAttr & FILE_ATTRIBUTE_READONLY)) {
            SetFileAttributes (szBootIni, dwFileAttr);
        }
    }

    return bOK;
}
#endif

void StartListInit( HWND hDlg, WPARAM wParam, LPARAM lParam ) {
    HWND    hwndTemp;
    HMODULE hmodSetupDll;
    int     iTemp;
    int     n;
#ifdef _X86_
    int     i, timeout;
    TCHAR   szTemp2[MAX_PATH];
    int     selection;
    TCHAR  *pszKeyName;
    LPTSTR  pszLine;
    TCHAR  *pszValue;
    TCHAR  *pszTemp;
    LPTSTR  lpKey = NULL;

    //  ANSI string pointers

    LPSTR   pszSectionA;
#endif

#if defined(EFI_NVRAM_ENABLED)

    if (IsEfi()) {

        ShowWindow(GetDlgItem(hDlg, IDC_SYS_EDIT_BUTTION), FALSE);
        ShowWindow(GetDlgItem(hDlg, IDC_STARTUP_SYS_EDIT_LABEL), FALSE);

        hwndTemp = GetDlgItem (hDlg, IDC_STARTUP_SYS_OS);

        fCanUpdateNVRAM = ReadEfiBootEntries();

        if (fCanUpdateNVRAM) {

            PLIST_ENTRY listEntry;
            PMY_BOOT_ENTRY bootEntry;

            for (listEntry = BootEntries.Flink;
                 listEntry != &BootEntries;
                 listEntry = listEntry->Flink) {
                bootEntry = CONTAINING_RECORD(listEntry, MY_BOOT_ENTRY, ListEntry);
                if (bootEntry->Show) {
                    bootEntry->Index = (int)SendMessage (hwndTemp, CB_ADDSTRING, 0,
                                                         (LPARAM)bootEntry->FriendlyName);
                }
            }

            // the first one is the selection we want (offset 0)
            SendMessage (hwndTemp, CB_SETCURSEL, 0, 0L);
            nOriginalSelection = 0;

            SendDlgItemMessage (hDlg, IDC_STARTUP_SYS_SECONDS,
                                EM_LIMITTEXT, 3, 0L);
            SendDlgItemMessage (hDlg, IDC_STARTUP_SYS_SECSCROLL,
                      UDM_SETRANGE, 0, (LPARAM)MAKELONG(999,0));

            if (BootOptions->Timeout != 0xffffffff) {

                if (BootOptions->Timeout > 999) {
                    BootOptions->Timeout = 999;
                }

                SetDlgItemInt(
                   hDlg,
                   IDC_STARTUP_SYS_SECONDS,
                   BootOptions->Timeout,
                   FALSE
                );
                CheckDlgButton (hDlg, IDC_STARTUP_SYS_ENABLECOUNTDOWN, TRUE);

            } else {

                SetDlgItemInt(
                   hDlg,
                   IDC_STARTUP_SYS_SECONDS,
                   0,
                   FALSE
                );
                CheckDlgButton (hDlg, IDC_STARTUP_SYS_ENABLECOUNTDOWN, FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_STARTUP_SYS_SECONDS), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_STARTUP_SYS_SECSCROLL), FALSE);
            }

        } else {

            // if can't set variables (no privilege), disable controls
            EnableWindow (GetDlgItem(hDlg, IDC_STARTUP_SYS_SECONDS), FALSE);
            EnableWindow (GetDlgItem(hDlg, IDC_STARTUP_SYS_SECONDS_LABEL), FALSE);
            EnableWindow (GetDlgItem(hDlg, IDC_STARTUP_SYS_ENABLECOUNTDOWN), FALSE);
            EnableWindow (GetDlgItem(hDlg, IDC_STARTUP_SYS_SECSCROLL), FALSE);
            EnableWindow (hwndTemp, FALSE);
        }

    } else

#endif // defined(EFI_NVRAM_ENABLED)

#ifdef _X86_
    if (Is_ARCx86())
#endif
    {
        ////////////////////////////////////////////////////////////////////
        //  Read info from NVRAM environment variables
        ////////////////////////////////////////////////////////////////////

        // Init to 0 so we won't try to free garbage if we cant load setup.dll
        CPEBOSLoadIdentifier.cEntries = 0;

        fCanUpdateNVRAM = FALSE;
        fAutoLoad = FALSE;
        hwndTemp = GetDlgItem (hDlg, IDC_STARTUP_SYS_OS);
        if (hmodSetupDll = LoadLibrary(TEXT("setupdll")))
        {
            if (fpGetNVRAMvar = (GETNVRAMPROC)GetProcAddress(hmodSetupDll, "GetNVRAMVar"))
            {
                if (fCanUpdateNVRAM = GetRGSZEnvVar (&CPEBOSLoadIdentifier, "LOADIDENTIFIER"))
                {
                    for (iTemp = 0; iTemp < CPEBOSLoadIdentifier.cEntries; iTemp++)
                        n = (int)SendMessageA (hwndTemp, CB_ADDSTRING, 0,
                                          (LPARAM)CPEBOSLoadIdentifier.pszVars[iTemp]);
                    // the first one is the selection we want (offset 0)
                    SendMessage (hwndTemp, CB_SETCURSEL, 0, 0L);
                    SendDlgItemMessage (hDlg, IDC_STARTUP_SYS_SECONDS,
                              EM_LIMITTEXT, 3, 0L);
                    SendDlgItemMessage (hDlg, IDC_STARTUP_SYS_SECSCROLL,
                              UDM_SETRANGE, 0, (LPARAM)MAKELONG(999,0));

                }
                // fCanUpdateNVRAM is a global that gets set up above
                if (fCanUpdateNVRAM)
                {
                   // This is a temporary hack workaround for the
                   // fact that the AUTOLOAD variable seems to
                   // be broken on Alpha
                   CPEnvBuf cpebTimeout;
                   int timeout;
                   
                   if (GetRGSZEnvVar(&cpebTimeout, "COUNTDOWN")) {
                      timeout = StringToIntA(cpebTimeout.pszVars[0]);
                      fAutoLoad = (BOOL) timeout;
                      SetDlgItemInt(
                         hDlg,
                         IDC_STARTUP_SYS_SECONDS,
                         timeout,
                         FALSE
                      );
                      FreeRGSZEnvVar(&cpebTimeout);
                   } // if
#if 0
                   CPEnvBuf cpebAutoLoad, cpebTimeout;
                   // is Autoload == YES?  if so, check the checkbox
                   //    and read setting for timeouts
                   // autoload == NO? disable edit control.
                   if (GetRGSZEnvVar (&cpebAutoLoad, "AUTOLOAD"))
                   {
                      if (!lstrcmpiA (cpebAutoLoad.pszVars[0], "yes"))
                      {
                         fAutoLoad = TRUE;
                         if (GetRGSZEnvVar (&cpebTimeout, "COUNTDOWN")) {
                            SetDlgItemInt (hDlg, IDC_STARTUP_SYS_SECONDS,
                                           StringToIntA (cpebTimeout.pszVars[0]), FALSE);

                            // We are done with cpebTimeout... Free the resources it consumes
                            FreeRGSZEnvVar(&cpebTimeout);
                         }

                      }

                      // We are done with cpebTimeout... Free the resources it consumes
                      FreeRGSZEnvVar(&cpebAutoLoad);
                   }
#endif //0
                   CheckDlgButton (hDlg, IDC_STARTUP_SYS_ENABLECOUNTDOWN, fAutoLoad);
                   if (!fAutoLoad)
                   {
                       EnableWindow (GetDlgItem (hDlg, IDC_STARTUP_SYS_SECONDS), FALSE);
                       EnableWindow (GetDlgItem (hDlg, IDC_STARTUP_SYS_SECSCROLL), FALSE);
                   }
                }
            }
            FreeLibrary (hmodSetupDll);
        }
        if (!fCanUpdateNVRAM) {
            // if can't set variables (no privilege), disable controls
            EnableWindow (GetDlgItem(hDlg, IDC_STARTUP_SYS_SECONDS), FALSE);
            EnableWindow (GetDlgItem(hDlg, IDC_STARTUP_SYS_SECONDS_LABEL), FALSE);
            EnableWindow (GetDlgItem(hDlg, IDC_STARTUP_SYS_ENABLECOUNTDOWN), FALSE);
            EnableWindow (GetDlgItem(hDlg, IDC_STARTUP_SYS_SECSCROLL), FALSE);
            EnableWindow (GetDlgItem(hDlg, IDC_STARTUP_SYS_OS), FALSE);
        }

        // default to 5 seconds for now.
    }
#ifdef _X86_
    else
    {
        ////////////////////////////////////////////////////////////////////
        //  Read info from boot.ini file and initialize OS Group box items
        ////////////////////////////////////////////////////////////////////

        InitializeArcStuff();

        //
        //  Get correct Boot Drive - this was added because after someone
        //  boots the system, they can ghost or change the drive letter
        //  of their boot drive from "c:" to something else.
        //

        if (IsNEC_98)
        {
            //
            // For NEC PC98.
            // For Install NT to non C: drive.
            // Get drive letter of system directory.
            //
            if ((HIBYTE(LOWORD(GetKeyboardType(1))) & 0xff) == NLSKBD_OEM_NEC) {
                TCHAR   szSystemDirectory[MAX_PATH];
                GetSystemDirectory (szSystemDirectory, ARRAYSIZE(szSystemDirectory));
                szBootIni[0] = szSystemDirectory[0];
            } else {
                //
                // PC/AT
                //
//                szBootIni[0] = GetBootDrive();
                  szBootIni[0] = x86DetermineSystemPartition (hDlg);
            }
        }
        else
        {
//            szBootIni[0] = GetBootDrive();
            szBootIni[0] = x86DetermineSystemPartition (hDlg);
        }

        szBootIniA[0] = (char) szBootIni[0];

        //
        //  Make sure we have access to BOOT.INI
        //
        if (!WriteableBootIni(szBootIni, hDlg)) {
            // if can't set variables (no privilege), disable controls
            EnableWindow (GetDlgItem(hDlg, IDC_STARTUP_SYS_SECONDS), FALSE);
            EnableWindow (GetDlgItem(hDlg, IDC_STARTUP_SYS_SECONDS_LABEL), FALSE);
            EnableWindow (GetDlgItem(hDlg, IDC_STARTUP_SYS_ENABLECOUNTDOWN), FALSE);
            EnableWindow (GetDlgItem(hDlg, IDC_STARTUP_SYS_SECSCROLL), FALSE);
            EnableWindow (GetDlgItem(hDlg, IDC_STARTUP_SYS_OS), FALSE);
        }

        //
        //  Determine which section [boot loader]
        //                          [flexboot]
        //                       or [multiboot] is in file
        //
        n = GetPrivateProfileString (szBootLdr, NULL, NULL, szTemp2,
                                     ARRAYSIZE(szTemp2), szBootIni);
        if (n != 0)
            pszBoot = szBootLdr;
        else
        {
            n = GetPrivateProfileString (szFlexBoot, NULL, NULL, szTemp2,
                                         ARRAYSIZE(szTemp2), szBootIni);
            if (n != 0)
                pszBoot = szFlexBoot;
            else
            {
                n = GetPrivateProfileString (szMultiBoot, NULL, NULL, szTemp2,
                                             ARRAYSIZE(szTemp2), szBootIni);
                if (n != 0)
                {
                    pszBoot = szMultiBoot;
                }
                else
                {
                    //
                    //  This final case is here because I want to DEFAULT
                    //  to "[boot loader]" as the section name to use in
                    //  the event that we do not find any section in the
                    //  boot.ini file.
                    //

                    pszBoot = szBootLdr;
                }
            }

        }

        //  Get info under [*pszBoot] section - timeout & default OS path

        timeout = GetPrivateProfileInt (pszBoot, szTimeout, 0, szBootIni);

        SetDlgItemInt (hDlg, IDC_STARTUP_SYS_SECONDS, timeout, FALSE);

        nOriginalTimeout = timeout;

        //
        //  Get the "Default" os selection
        //

        szTemp2[0] = TEXT('\0');

        GetPrivateProfileString (pszBoot, szDefault, NULL, szTemp2,
                                 ARRAYSIZE(szTemp2), szBootIni);

        //
        //  Display all choices under [operating system] in boot.ini file
        //  in combobox for selection
        //

        hwndTemp = GetDlgItem (hDlg, IDC_STARTUP_SYS_OS);

        selection = -1;

        //
        //  ANSI Buffer!
        //

        pszSectionA = (LPSTR) MemAlloc (LPTR, BUFZ);


        //
        //  Get entire section under OS to properly show user choices
        //

        n = GetPrivateProfileSectionA (szOSA, pszSectionA, BUFZ, szBootIniA);

        if ((n >= BUFZ-2) || (n == 0))
        {
ErrorReadingSection:
            //  Error reading data
            MemFree ((LPVOID)pszSectionA);
            goto ContinueSystemInit;
        }

        //
        //  Check for api errors and NoOptions
        //

        if ((pszSectionA == NULL) || ((*pszSectionA == '\0') && (*(pszSectionA+1) == '\0')))
            goto ErrorReadingSection;


        lpKey = MemAlloc (LPTR, BUFZ*sizeof(TCHAR));
        pszKeyName = lpKey;

        //
        //  Convert entire buffer from OEM to UNICODE
        //

        MultiByteToWideChar (CP_OEMCP, MB_PRECOMPOSED, pszSectionA, n+2, pszKeyName, BUFZ);

        MemFree ((LPVOID)pszSectionA);

        //
        //  Continue until we reach end of buffer, marked by Double '\0'
        //

        while (*(pszKeyName+1) != TEXT('\0'))
        {
            pszLine = pszKeyName;

            //
            //  Get pointer to next line in buffer.
            //

            pszKeyName += lstrlen (pszKeyName) + 1;

            //
            //  Find LHS/RHS delimiter to separate strings
            //

            pszValue = StrStr(pszLine, TEXT("="));

            if (pszValue && (pszValue != pszLine))
            {
                *pszValue = '\0';
                pszValue++;
            }
            else
            {
                pszValue = pszLine;
            }

            //
            //  Put it into combobox (if no descriptive name, use path)
            //

            n = (int)SendMessage (hwndTemp, CB_ADDSTRING, 0, (LPARAM) (LPTSTR) pszValue);

            //
            //  Find the first selection that matches the "default" selection
            //

            if ((selection == -1)  && !lstrcmp (pszLine, szTemp2))
                selection = n;

            //
            //  Also attach pointer to KeyName (i.e. boot path) to each item
            //

            pszTemp = CloneString (pszLine);

            SendMessage (hwndTemp, CB_SETITEMDATA, n, (LPARAM)pszTemp);
        }

        // If no selection was found up to this point, choose 0, because
        // that is the default value that loader would choose.

        if (selection == -1)
            selection = 0;

        SendDlgItemMessage (hDlg, IDC_STARTUP_SYS_SECONDS, EM_LIMITTEXT, 3, 0L);
        SendDlgItemMessage (hDlg, IDC_STARTUP_SYS_SECSCROLL,
                              UDM_SETRANGE, 0, (LPARAM)MAKELONG(999,0));


        //  Check or uncheck the checkbox based on the timeout value
        SendDlgItemMessage(
            hDlg,
            IDC_STARTUP_SYS_ENABLECOUNTDOWN,
            BM_SETCHECK,
            (WPARAM) (BOOL) timeout,
            (LPARAM) 0L
        );
        EnableWindow(
            GetDlgItem(hDlg, IDC_STARTUP_SYS_SECONDS), 
            (BOOL) timeout
        );
        EnableWindow(
            GetDlgItem(hDlg, IDC_STARTUP_SYS_SECSCROLL), 
            (BOOL) timeout
        );

        //  This call should force correct settings for the checkbox
        //  and "Showlist for xx seconds" controls
        nOriginalSelection = selection;

        SendMessage (hwndTemp, CB_SETCURSEL, selection, 0L);

ContinueSystemInit:

        if (lpKey) {
            MemFree (lpKey);
        }
    }
#endif  // _X86_
}


//
//  IE. We need to handle CANCEL case.
//
int StartListExit(HWND hDlg, WPARAM wParam, LPARAM lParam ) {
    HWND hwndTemp;
    int  selection, timeout;
#ifdef _X86_
    DWORD dwFileAttr;
    BOOL bOK;
    HANDLE  hKey;
    TCHAR  *pszKeyName;
    int     i, n;
    DWORD   dwBufz;
    LPSTR   pszSectionA;
    TCHAR  *pszTemp;
    TCHAR   szTemp[MAX_PATH];
    TCHAR   szTemp2[MAX_PATH];
    int     iTemp;
#endif

    /////////////////////////////////////////////////////////////////
    //  Write new info to boot.ini file
    /////////////////////////////////////////////////////////////////

    hwndTemp = GetDlgItem (hDlg, IDC_STARTUP_SYS_OS);

    selection = (int)SendMessage (hwndTemp, CB_GETCURSEL, 0, 0L);

    if ((selection == CB_ERR) || (selection == CB_ERRSPACE))
        selection = nOriginalSelection;

    timeout   = GetDlgItemInt (hDlg, IDC_STARTUP_SYS_SECONDS, NULL, FALSE);

#if defined(EFI_NVRAM_ENABLED)
    if (IsEfi()) {
        if (fCanUpdateNVRAM) {

            TCHAR szTextNew[MAX_PATH];
            TCHAR szTextTop[MAX_PATH];

            WriteEfiBootEntries(hDlg, selection, timeout);

            /*
             * Now reorder list to match NVRAM
             */
            // Get the current text
            SendMessage( hwndTemp, CB_GETLBTEXT, selection, (LPARAM)szTextNew );
            SendMessage( hwndTemp, CB_GETLBTEXT,         0, (LPARAM)szTextTop );
    
            // Set the new text to the 0th entry in the list
            SendMessage( hwndTemp, CB_DELETESTRING, 0, 0 );
            SendMessage( hwndTemp, CB_INSERTSTRING, 0, (LPARAM)szTextNew);
    
            // Set old top text selected item
            SendMessage( hwndTemp, CB_DELETESTRING, selection, 0 );
            SendMessage( hwndTemp, CB_INSERTSTRING, selection, (LPARAM)szTextTop);
    
            // Now point the current selection back to the top of the list, so it matches
            // what the user just chose
            SendMessage( hwndTemp, CB_SETCURSEL, 0, 0);
        }

    } else
#endif // defined(EFI_NVRAM_ENABLED)

#ifdef _X86_
    if (Is_ARCx86())
#endif
    {
    if (fCanUpdateNVRAM) {
        TCHAR szTextNew[MAX_PATH];
        TCHAR szTextTop[MAX_PATH];

        UpdateNVRAM (hDlg, selection, timeout);

        /*
         * Now reorder list to match NVRAM
         */
        // Get the current text
        SendMessage( hwndTemp, CB_GETLBTEXT, selection, (LPARAM)szTextNew );
        SendMessage( hwndTemp, CB_GETLBTEXT,         0, (LPARAM)szTextTop );

        // Set the new text to the 0th entry in the list
        SendMessage( hwndTemp, CB_DELETESTRING, 0, 0 );
        SendMessage( hwndTemp, CB_INSERTSTRING, 0, (LPARAM)szTextNew);

        // Set old top text selected item
        SendMessage( hwndTemp, CB_DELETESTRING, selection, 0 );
        SendMessage( hwndTemp, CB_INSERTSTRING, selection, (LPARAM)szTextTop);

        // Now point the current selection back to the top of the list, so it matches
        // what the user just chose
        SendMessage( hwndTemp, CB_SETCURSEL, 0, 0);
    }
    }
#ifdef _X86_
    else
    {
    if ((selection != nOriginalSelection) || (timeout != nOriginalTimeout))
    {
        bOK = TRUE;

        //  Change Read-only file attrs on Boot.ini file if necessary
        if ((dwFileAttr = GetFileAttributes (szBootIni)) != 0xFFFFFFFF)
            if (dwFileAttr & FILE_ATTRIBUTE_READONLY)
                if (!SetFileAttributes (szBootIni,
                           dwFileAttr & ~FILE_ATTRIBUTE_READONLY))
                {
BootIniWriteError:
                    bOK = FALSE;
                    MsgBoxParam (hDlg, IDS_SYSDM_NOCHANGE_BOOTINI, IDS_SYSDM_TITLE, MB_OK | MB_ICONINFORMATION);
                }

        if (bOK)
        {
            //
            //  Write new [operating systems] section and
            //  set "default" selection in boot.ini file.
            //

            if (selection != nOriginalSelection)
            {
                //
                //  Allocate buffers for new section
                //

                hKey = MemAlloc (LPTR, BUFZ*sizeof(TCHAR));
                pszKeyName = (TCHAR *) hKey;
                if (pszKeyName)
                {
                    //  Total profile section buffer size
                    i = dwBufz = 0;
                    pszSectionA = (LPSTR) MemAlloc (LPTR, BUFZ);
                    if (pszSectionA)
                    {
                        //  Get the User's selection and write it in the
                        //  section buffer first.  Then get all other items.
                        pszTemp = (LPTSTR) SendMessage(hwndTemp, CB_GETITEMDATA, selection, 0L);

                        SendMessage (hwndTemp, CB_GETLBTEXT, selection, (LPARAM) (LPTSTR) szTemp);

                        if (pszTemp != (LPTSTR) CB_ERR)
                        {
                            lstrcpy (pszKeyName, pszTemp);
                            lstrcat (pszKeyName, TEXT("="));
                            lstrcat (pszKeyName, szTemp);

                            i = lstrlen (pszKeyName) + 1;
                            pszKeyName += i;

                            //  Set "default" selection in boot.ini file
                            if (!WritePrivateProfileString (pszBoot, szDefault, pszTemp, szBootIni))
                            {
                               goto BootIniWriteError;
                            }
                        }

                        dwBufz = (DWORD) i;

                        //  Get the rest of the selections
                        n = (int)SendMessage (hwndTemp, CB_GETCOUNT, 0, 0L);
                        if (n != LB_ERR)
                        {
                            for (iTemp = 0; iTemp < n; iTemp++)
                            {
                                //  Skip the User's selection since we got it
                                //  above.
                                if (iTemp == selection)
                                    continue;

                                pszTemp = (LPTSTR) SendMessage (hwndTemp, CB_GETITEMDATA, iTemp, 0L);

                                SendMessage (hwndTemp, CB_GETLBTEXT, iTemp, (LPARAM) (LPTSTR) szTemp);

                                if (pszTemp != (LPTSTR) CB_ERR)
                                {
                                    lstrcpy (pszKeyName, pszTemp);
                                    lstrcat (pszKeyName, TEXT("="));
                                    lstrcat (pszKeyName, szTemp);

                                    i = lstrlen (pszKeyName) + 1;
                                    pszKeyName += i;

                                    dwBufz += (DWORD) i;
                                }
                            }
                        }

                        //  Double-Null terminate the buffer
                        *pszKeyName = TEXT('\0');
                        dwBufz++;

                        pszKeyName = (TCHAR *) hKey;

                        //  Convert entire buffer from UNICODE to OEM
                        WideCharToMultiByte(CP_OEMCP, WC_COMPOSITECHECK, pszKeyName, dwBufz, pszSectionA, BUFZ, NULL, NULL);

                        //  Write new section under OS
                        if (!WritePrivateProfileSectionA(szOSA, pszSectionA, szBootIniA))
                        {
                            MemFree((LPVOID)pszSectionA);
                            MemFree((LPVOID)hKey);
                            goto BootIniWriteError;
                        }

                        MemFree ((LPVOID)pszSectionA);
                    }

                    MemFree ((LPVOID)hKey);
                }
            }

            if (timeout != nOriginalTimeout)
            {
                GetDlgItemText (hDlg, IDC_STARTUP_SYS_SECONDS, szTemp2, ARRAYSIZE(szTemp2));

                if (!CheckVal (hDlg, IDC_STARTUP_SYS_SECONDS, FORMIN, FORMAX, IDS_SYSDM_ENTERSECONDS))
                    return RET_BREAK;

                //  Write timeout value to file

                if (!WritePrivateProfileString (pszBoot, szTimeout,
                                               szTemp2, szBootIni))
                    goto BootIniWriteError;
            }

            //  Restore read-only attr, if necessary, after writes
            if (dwFileAttr != 0xFFFFFFFF && (dwFileAttr & FILE_ATTRIBUTE_READONLY)) {
                    SetFileAttributes (szBootIni, dwFileAttr);
            }
        }
    }
    }
#endif // _X86_

    return RET_CONTINUE;

}


BOOL CheckVal( HWND hDlg, WORD wID, WORD wMin, WORD wMax, WORD wMsgID )
{
    WORD nVal;
    BOOL bOK;
    HWND hVal;
    WCHAR szTemp[FOR_MAX_LENGTH];

    if( wMin > wMax )
    {
        nVal = wMin;
        wMin = wMax;
        wMax = nVal;
    }

    nVal = (WORD) GetDlgItemInt( hDlg, wID, &bOK, FALSE );

    //
    // This is a hack to make the null string act equivalent to zero
    //
    if (!bOK) {
       bOK = !GetDlgItemTextW( hDlg, wID, szTemp, FOR_MAX_LENGTH );
    }

    if( !bOK || ( nVal < wMin ) || ( nVal > wMax ) )
    {
        MsgBoxParam( hDlg, wMsgID, IDS_SYSDM_TITLE,
                      MB_OK | MB_ICONERROR, wMin, wMax );

        SendMessage( hDlg, WM_NEXTDLGCTL,
                     (WPARAM) ( hVal = GetDlgItem( hDlg, wID ) ), 1L );

//        SendMessage(hVal, EM_SETSEL, NULL, MAKELONG(0, 32767));

        SendMessage( hVal, EM_SETSEL, 0, 32767 );

        return( FALSE );
    }

    return( TRUE );
}



//////////////////////////////////////////////////////
//
// Frees the data (if any) associated with the strings in the combo box
//
//////////////////////////////////////////////////////
void StartListDestroy(HWND hDlg, WPARAM wParam, LPARAM lParam) {

#if defined(EFI_NVRAM_ENABLED)
    if (IsEfi()) {
        FreeEfiBootEntries();
    } else
#endif // defined(EFI_NVRAM_ENABLED)

#ifdef _X86_
    if (Is_ARCx86())
#endif
    {
    // Reference vars to make compiler happy
    FreeRGSZEnvVar(&CPEBOSLoadIdentifier);
    return;

    (void)hDlg;
    (void)wParam;
    (void)lParam;
    }
#ifdef _X86_
    else
    {

    // Only X86 has data in the combo
    int     n;
    HWND    hwndTemp;
    int     iTemp;
    TCHAR   *pszTemp;


    //
    //  Free strings stored in the listbox
    //
    hwndTemp = GetDlgItem (hDlg, IDC_STARTUP_SYS_OS);

    n = (int)SendMessage (hwndTemp, CB_GETCOUNT, 0, 0L);

    if (n != LB_ERR)
    {
        for (iTemp = 0; iTemp < n; iTemp++)
        {
            pszTemp = (LPTSTR) SendMessage (hwndTemp,
                                            CB_GETITEMDATA,
                                            iTemp, 0L);

            if (pszTemp != (LPTSTR) CB_ERR)
            {
                MemFree (pszTemp);
            }
        }
    }
    }
#endif // _X86_
}

void AutoAdvancedBootInit( HWND hDlg, WPARAM wParam, LPARAM lParam ) {
    BOOL fEnabled = FALSE;
    UCHAR cTimeout = 0;

    NTSTATUS status;

#ifdef _X86_

    //
    // Initialize the boot status data.
    //

    status = RtlLockBootStatusData(&hBootStatusData);

    if(NT_SUCCESS(status)) {

        RtlGetSetBootStatusData(hBootStatusData,
                                TRUE,
                                RtlBsdItemAabEnabled,
                                &fEnabled,
                                sizeof(BOOL),
                                NULL);

        RtlGetSetBootStatusData(hBootStatusData,
                                TRUE,
                                RtlBsdItemAabTimeout,
                                &cTimeout,
                                sizeof(UCHAR),
                                NULL);

        SetDlgItemInt(hDlg, IDC_STARTUP_AUTOLKG_SECONDS, cTimeout, FALSE);
        CheckDlgButton(hDlg, IDC_STARTUP_AUTOLKG, fEnabled);
    
        SendDlgItemMessage(hDlg, IDC_STARTUP_AUTOLKG_SECONDS, EM_LIMITTEXT, 3, 0L);
        SendDlgItemMessage(hDlg, 
                           IDC_STARTUP_AUTOLKG_SECSCROLL,
                           UDM_SETRANGE, 
                           0, 
                           (LPARAM)MAKELONG(999,0));


        if(!fEnabled) {
            EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_AUTOLKG_SECONDS_LABEL), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_AUTOLKG_SECONDS), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_AUTOLKG_SECSCROLL), FALSE);
        }
    } else {
        EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_AUTOLKG), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_AUTOLKG_SECONDS_LABEL), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_AUTOLKG_SECONDS), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_AUTOLKG_SECSCROLL), FALSE);
    }
#else 

    ShowWindow(GetDlgItem(hDlg, IDC_STARTUP_AUTOLKG), FALSE);
    ShowWindow(GetDlgItem(hDlg, IDC_STARTUP_AUTOLKG_SECONDS_LABEL), FALSE);
    ShowWindow(GetDlgItem(hDlg, IDC_STARTUP_AUTOLKG_SECONDS), FALSE);
    ShowWindow(GetDlgItem(hDlg, IDC_STARTUP_AUTOLKG_SECSCROLL), FALSE);

#endif

    return;
}

//
//  IE. We need to handle CANCEL case.
//
int AutoAdvancedBootExit(HWND hDlg, WPARAM wParam, LPARAM lParam ) {

    BOOL fEnabled;

    UINT iTime;
    UCHAR cTimeout;

    NTSTATUS status;

#if _X86_
    if(LOWORD(wParam) != IDCANCEL) {
    
        //
        // Read the setting of the enabled checkbox.
        //
    
        fEnabled = IsDlgButtonChecked(hDlg, IDC_STARTUP_AUTOLKG);
    
        if(fEnabled) {
            iTime = GetDlgItemInt(hDlg, IDC_STARTUP_AUTOLKG_SECONDS, NULL, FALSE);
            cTimeout = (UCHAR) min(iTime, 0xff);
        }
    
        //
        // If we got access in AutoAdvancedBootInit, write the boot status data and exit.
        //
    
        if (hBootStatusData)
        {
            RtlGetSetBootStatusData(hBootStatusData,
                                    FALSE,
                                    RtlBsdItemAabEnabled,
                                    &fEnabled,
                                    sizeof(BOOL),
                                    NULL);
    
            if(fEnabled) {
                RtlGetSetBootStatusData(hBootStatusData,
                                        FALSE,
                                        RtlBsdItemAabTimeout,
                                        &cTimeout,
                                        sizeof(UCHAR),
                                        NULL);
            }
        }
    }
    
    if (hBootStatusData)            
    {
        RtlUnlockBootStatusData(hBootStatusData);
        hBootStatusData = NULL;    
    }
#endif

    return RET_CONTINUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\sysdm.c ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    sysdm.c 

Abstract:

    Initialization code for System Control Panel Applet

Author:

    Eric Flo (ericflo) 19-Jun-1995

Revision History:

    15-Oct-1997 scotthal
        Complete overhaul

--*/
#include "sysdm.h"
#include <shsemip.h>
#include <regstr.h>

//
// Global Variables
//
HINSTANCE hInstance;
TCHAR szShellHelp[]       = TEXT("ShellHelp");
TCHAR g_szNull[] = TEXT("");
UINT  uiShellHelp;

TCHAR g_szErrMem[ 200 ];           //  Low memory message
TCHAR g_szSystemApplet[ 100 ];     //  "System Control Panel Applet" title

//
// Function prototypes
//

void 
RunApplet(
    IN HWND hwnd, 
    IN LPTSTR lpCmdLine
);
void _GetStartingPage(IN LPTSTR lpCmdLine, IN PROPSHEETHEADER* ppsh, INT* piStartPage, LPTSTR pszStartPage, INT cchStartPage);
BOOL CALLBACK _AddPropSheetPage(HPROPSHEETPAGE hpage, LPARAM lParam);


BOOL 
WINAPI
DllInitialize(
    IN HINSTANCE hInstDLL, 
    IN DWORD dwReason, 
    IN LPVOID lpvReserved
)
/*++

Routine Description:

    Main entry point.

Arguments:

    hInstDLL -
        Supplies DLL instance handle.

    dwReason -
        Supplies the reason DllInitialize() is being called.

    lpvReserved -
        Reserved, NULL.

Return Value:

    BOOL

--*/
{

    if (dwReason == DLL_PROCESS_DETACH)
        MEM_EXIT_CHECK();

    if (dwReason != DLL_PROCESS_ATTACH) {
        return TRUE;
    }

    hInstance = hInstDLL;

    return TRUE;
}


LONG 
APIENTRY
CPlApplet( 
    IN HWND hwnd, 
    IN WORD wMsg, 
    IN LPARAM lParam1, 
    IN LPARAM lParam2
)
/*++

Routine Description:

    Control Panel Applet entry point.

Arguments:

    hwnd -
        Supplies window handle.

    wMsg -
        Supplies message being sent.

    lParam1 -
        Supplies parameter to message.

    lParam2 -
        Supplies parameter to message.

Return Value:

    Nonzero if message was handled.
    Zero if message was unhandled. 

--*/
{

    LPCPLINFO lpCPlInfo;

    switch (wMsg) {

        case CPL_INIT:
            uiShellHelp = RegisterWindowMessage (szShellHelp);

            LoadString( hInstance, IDS_INSUFFICIENT_MEMORY,   g_szErrMem,       ARRAYSIZE( g_szErrMem ) );
            LoadString( hInstance, IDS_SYSDM_TITLE, g_szSystemApplet, ARRAYSIZE( g_szSystemApplet ) );

            return (LONG) TRUE;

        case CPL_GETCOUNT:
            return 1;

        case CPL_INQUIRE:

            lpCPlInfo = (LPCPLINFO)lParam2;

            lpCPlInfo->idIcon = ID_ICON;
            lpCPlInfo->idName = IDS_NAME;
            lpCPlInfo->idInfo = IDS_INFO;

            return (LONG) TRUE;

        case CPL_DBLCLK:

            lParam2 = 0L;
            // fall through...

        case CPL_STARTWPARMS:
            RunApplet(hwnd, (LPTSTR)lParam2);
            return (LONG) TRUE;
    }
    return (LONG)0;

}

HPROPSHEETPAGE CreatePage(int idd, DLGPROC pfnDlgProc)
{
    PROPSHEETPAGE psp;
    psp.dwSize = SIZEOF(psp);
    psp.dwFlags = PSP_DEFAULT;
    psp.hInstance = hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(idd);
    psp.pfnDlgProc = pfnDlgProc;
    return CreatePropertySheetPage(&psp);
}

static const PSPINFO c_pspCB[] =
{
    { CreatePage,               IDD_GENERAL,    GeneralDlgProc  },
    { CreateNetIDPage,          0,              NULL            },
    { CreatePage,               IDD_HARDWARE,   HardwareDlgProc },
    { CreatePage,               IDD_ADVANCED,   AdvancedDlgProc },
    { CreateSystemRestorePage,  0,              NULL            },
};

void 
RunApplet(
    IN HWND hwnd, 
    IN LPTSTR lpCmdLine
)
/*++

Routine Description:

    CPL_STARTWPARMS message handler.  Called when the user
    runs the Applet.

    PropSheet initialization occurs here.

Arguments:

    hwnd -
        Supplies window handle.

    lpCmdLine -
        Supplies the command line used to invoke the applet.

Return Value:

    none

--*/
{
    HRESULT hrOle = CoInitialize(0);

    if (!SHRestricted(REST_MYCOMPNOPROP))
    {
        if (lpCmdLine && *lpCmdLine && !lstrcmp(lpCmdLine, TEXT("-1")))
        {
            // -1 means Performance Options cpl
            DoPerformancePS(NULL);
        }
        else
        {
            HPROPSHEETPAGE hPages[MAX_PAGES];
            PROPSHEETHEADER psh;
            UINT iPage = 0;
            HPSXA hpsxa = NULL;
            INT i;
            INT iStartPage;
            TCHAR szStartPage[MAX_PATH];

            ZeroInit(&psh, sizeof(psh));

            if (SUCCEEDED(hrOle))
            {
                HRESULT hr = CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, 0);
            }

            LinkWindow_RegisterClass();

            psh.dwSize = sizeof(PROPSHEETHEADER);
            psh.dwFlags = 0;
            psh.hwndParent = hwnd;
            psh.hInstance = hInstance;
            psh.pszCaption = MAKEINTRESOURCE(IDS_TITLE);
            psh.phpage = hPages;

            for (i = 0; i < ARRAYSIZE(c_pspCB); i++)
            {
                hPages[iPage] = c_pspCB[i].pfnCreatePage(c_pspCB[i].idd, c_pspCB[i].pfnDlgProc);
                if (hPages[iPage] != NULL)
                {
                    iPage++;
                }
            }

            psh.nPages = iPage; 

            // add any extra property pages from the shell ext hooks in the registry
            // 8 extensions should be enough. Desk.cpl also does the same.
            hpsxa = SHCreatePropSheetExtArray( HKEY_LOCAL_MACHINE, REGSTR_PATH_CONTROLSFOLDER TEXT("\\System"), 8 );
            if (hpsxa != NULL )
                SHAddFromPropSheetExtArray( hpsxa, _AddPropSheetPage, (LPARAM)&psh ); 

            szStartPage[0] = 0;
            _GetStartingPage(lpCmdLine, &psh, &iStartPage, szStartPage, ARRAYSIZE(szStartPage));
            if (szStartPage[0])
            {
                psh.dwFlags |= PSH_USEPSTARTPAGE;
                psh.pStartPage = szStartPage;
            }
            else
            {
                psh.nStartPage = iStartPage;
            }

            if (PropertySheet (&psh) == ID_PSREBOOTSYSTEM)
            {
                RestartDialogEx(hwnd, NULL, EWX_REBOOT, SHTDN_REASON_MAJOR_SYSTEM | SHTDN_REASON_MINOR_RECONFIG | SHTDN_REASON_FLAG_PLANNED);
            }

            if (hpsxa != NULL)
                SHDestroyPropSheetExtArray(hpsxa);
        
            LinkWindow_UnregisterClass(hInstance);
        }
    }

    if (SUCCEEDED(hrOle))
    {
        CoUninitialize();
    }
}


BOOL CALLBACK _AddPropSheetPage(HPROPSHEETPAGE hpage, LPARAM lParam)
{
    PROPSHEETHEADER FAR * ppsh = (PROPSHEETHEADER FAR *)lParam;

    if( hpage && ( ppsh->nPages < MAX_PAGES ) )
    {
        ppsh->phpage[ppsh->nPages++] = hpage;
        return TRUE;
    }
    return FALSE;
}

void _GetStartingPage(IN LPTSTR lpCmdLine, IN PROPSHEETHEADER* ppsh, INT* piStartPage, LPTSTR pszStartPage, INT cchStartPage)
{
    *piStartPage = 0;
    if (lpCmdLine && *lpCmdLine)
    {
        if (!StrToIntEx(lpCmdLine, STIF_DEFAULT, piStartPage) &&
            (*lpCmdLine == TEXT('@')))
        {
            LPTSTR pszComma = StrChr(lpCmdLine, TEXT(','));
            if (pszComma)
            {
                HINSTANCE hInstance;
                *pszComma = 0;
                hInstance = LoadLibrary(lpCmdLine + 1);
                if (hInstance)
                {
                    UINT idResource = StrToInt(++pszComma);
                    LoadString(hInstance, idResource, pszStartPage, cchStartPage);
                    FreeLibrary(hInstance);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\util.c ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    util.c

Abstract:

    Utility functions for System Control Panel Applet

Author:

    Eric Flo (ericflo) 19-Jun-1995

Revision History:

    15-Oct-1997 scotthal
        Complete overhaul

--*/
#include "sysdm.h"

//
// Constants
//
#define CCH_MAX_DEC 12             // Number of chars needed to hold 2^32

#define MAX_SWAPSIZE_X86        (4 * 1024)            // 4 Gb (number stored in megabytes)
#define MAX_SWAPSIZE_X86_PAE    (16 * 1024 * 1024)    // 16 Tb
#define MAX_SWAPSIZE_IA64       (32 * 1024 * 1024)    // 32 Tb
#define MAX_SWAPSIZE_AMD64      (16 * 1024 * 1024)    // 16 Tb

void
ErrMemDlg(
    IN HWND hParent
)
/*++

Routine Description:

    Displays "out of memory" message.

Arguments:

    hParent -
        Supplies parent window handle.

Return Value:

    None.

--*/
{
    MessageBox(
        hParent,
        g_szErrMem,
        g_szSystemApplet,
        MB_OK | MB_ICONHAND | MB_SYSTEMMODAL
    );
    return;
}

LPTSTR
SkipWhiteSpace(
    IN LPTSTR sz
)
/*++

Routine Description:

    SkipWhiteSpace
    For the purposes of this fuction, whitespace is space, tab,
    cr, or lf.

Arguments:

    sz -
        Supplies a string (which presumably has leading whitespace)

Return Value:

    Pointer to string without leading whitespace if successful.

--*/
{
    while( IsWhiteSpace(*sz) )
        sz++;

    return sz;
}

int 
StringToInt( 
    IN LPTSTR sz 
) 
/*++

Routine Description:

    TCHAR version of atoi

Arguments:

    sz -
        Supplies the string to convert

Return Value:

    Integer representation of the string

--*/
{
    int i = 0;

    sz = SkipWhiteSpace(sz);

    while( IsDigit( *sz ) ) {
        i = i * 10 + DigitVal( *sz );
        sz++;
    }

    return i;
}

void 
IntToString( 
    IN INT i, 
    OUT LPTSTR sz
) 
/*++

Routine Description:

    TCHAR version of itoa

Arguments:

    i -
        Supplies the integer to convert

    sz -
        Returns the string form of the supplied int

Return Value:

    None.

--*/
{
    TCHAR szTemp[CCH_MAX_DEC];
    int iChr;


    iChr = 0;

    do {
        szTemp[iChr++] = TEXT('0') + (i % 10);
        i = i / 10;
    } while (i != 0);

    do {
        iChr--;
        *sz++ = szTemp[iChr];
    } while (iChr != 0);

    *sz++ = TEXT('\0');
}


LPTSTR 
CheckSlash(
    IN LPTSTR lpDir
)
/*++

Routine Description:

    Checks for an ending backslash and adds one if
    it is missing.

Arguments:

    lpDir -
        Supplies the name of a directory.

Return Value:

    A string that ends with a backslash.

--*/
{
    DWORD dwStrLen;
    LPTSTR lpEnd;

    lpEnd = lpDir + lstrlen(lpDir);

    if (*(lpEnd - 1) != TEXT('\\')) {
        *lpEnd =  TEXT('\\');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }

    return lpEnd;
}


BOOL 
Delnode_Recurse(
    IN LPTSTR lpDir
)
/*++

Routine Description:

    Recursive delete function for Delnode

Arguments:

    lpDir -
        Supplies directory to delete

Return Value:

    TRUE if successful.
    FALSE if an error occurs.

--*/
{
    WIN32_FIND_DATA fd;
    HANDLE hFile;

    //
    // Setup the current working dir
    //

    if (!SetCurrentDirectory (lpDir)) {
        return FALSE;
    }


    //
    // Find the first file
    //

    hFile = FindFirstFile(TEXT("*.*"), &fd);

    if (hFile == INVALID_HANDLE_VALUE) {

        if (GetLastError() == ERROR_FILE_NOT_FOUND) {
            return TRUE;
        } else {
            return FALSE;
        }
    }


    do {
        //
        // Check for "." and ".."
        //

        if (!lstrcmpi(fd.cFileName, TEXT("."))) {
            continue;
        }

        if (!lstrcmpi(fd.cFileName, TEXT(".."))) {
            continue;
        }


        if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

            //
            // Found a directory.
            //

            if (!Delnode_Recurse(fd.cFileName)) {
                FindClose(hFile);
                return FALSE;
            }

            if (fd.dwFileAttributes & FILE_ATTRIBUTE_READONLY) {
                fd.dwFileAttributes &= ~FILE_ATTRIBUTE_READONLY;
                SetFileAttributes (fd.cFileName, fd.dwFileAttributes);
            }


            RemoveDirectory (fd.cFileName);


        } else {

            //
            // We found a file.  Set the file attributes,
            // and try to delete it.
            //

            if ((fd.dwFileAttributes & FILE_ATTRIBUTE_READONLY) ||
                (fd.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)) {
                SetFileAttributes (fd.cFileName, FILE_ATTRIBUTE_NORMAL);
            }

            DeleteFile (fd.cFileName);

        }


        //
        // Find the next entry
        //

    } while (FindNextFile(hFile, &fd));


    //
    // Close the search handle
    //

    FindClose(hFile);


    //
    // Reset the working directory
    //

    if (!SetCurrentDirectory (TEXT(".."))) {
        return FALSE;
    }


    //
    // Success.
    //

    return TRUE;
}


BOOL 
Delnode(
    IN LPTSTR lpDir
)
/*++

Routine Description:

    Recursive function that deletes files and
    directories.

Arguments:

    lpDir -
        Supplies directory to delete.

Return Value:

    TRUE if successful
    FALSE if an error occurs

--*/
{
    TCHAR szCurWorkingDir[MAX_PATH];

    if (GetCurrentDirectory(MAX_PATH, szCurWorkingDir)) {

        Delnode_Recurse (lpDir);

        SetCurrentDirectory (szCurWorkingDir);

        if (!RemoveDirectory (lpDir)) {
            return FALSE;
        }

    } else {
        return FALSE;
    }

    return TRUE;

}

LONG 
MyRegSaveKey(
    IN HKEY hKey, 
    IN LPCTSTR lpSubKey
)
/*++

Routine Description:

    Saves a registry key.

Arguments:

    hKey -
        Supplies handle to a registry key.

    lpSubKey -
        Supplies the name of the subkey to save.

Return Value:

    ERROR_SUCCESS if successful.
    Error code from RegSaveKey() if an error occurs.

--*/
{

    HANDLE hToken;
    LUID luid;
    DWORD dwSize = 1024;
    PTOKEN_PRIVILEGES lpPrevPrivilages;
    TOKEN_PRIVILEGES tp;
    LONG error;


    //
    // Allocate space for the old privileges
    //

    lpPrevPrivilages = GlobalAlloc(GPTR, dwSize);

    if (!lpPrevPrivilages) {
        return GetLastError();
    }


    if (!OpenProcessToken( GetCurrentProcess(),
                      TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) {
         return GetLastError();
    }

    LookupPrivilegeValue( NULL, SE_BACKUP_NAME, &luid );

    tp.PrivilegeCount           = 1;
    tp.Privileges[0].Luid       = luid;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    if (!AdjustTokenPrivileges( hToken, FALSE, &tp,
         dwSize, lpPrevPrivilages, &dwSize )) {

        if (GetLastError() == ERROR_MORE_DATA) {
            PTOKEN_PRIVILEGES lpTemp;

            lpTemp = GlobalReAlloc(lpPrevPrivilages, dwSize, GMEM_MOVEABLE);

            if (!lpTemp) {
                GlobalFree (lpPrevPrivilages);
                return GetLastError();
            }

            lpPrevPrivilages = lpTemp;

            if (!AdjustTokenPrivileges( hToken, FALSE, &tp,
                 dwSize, lpPrevPrivilages, &dwSize )) {
                return GetLastError();
            }

        } else {
            return GetLastError();
        }

    }

    //
    // Save the hive
    //

    error = RegSaveKey(hKey, lpSubKey, NULL);


    AdjustTokenPrivileges( hToken, FALSE, lpPrevPrivilages,
                           0, NULL, NULL );

    CloseHandle (hToken);

    return error;
}

UINT 
CreateNestedDirectory(
    IN LPCTSTR lpDirectory, 
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes
)
/*++

Routine Description:

    Creates a subdirectory and all its parents
    if necessary.

Arguments:

    lpDirectory -
        Name of directory to create.

    lpSecurityAttributes -
        Desired security attributes.

Return Value:

    Nonzero on success.
    Zero on failure.

--*/
{
    TCHAR szDirectory[MAX_PATH];
    LPTSTR lpEnd;


    //
    // Check for NULL pointer
    //

    if (!lpDirectory || !(*lpDirectory)) {
        return 0;
    }


    //
    // First, see if we can create the directory without having
    // to build parent directories.
    //

    if (CreateDirectory (lpDirectory, lpSecurityAttributes)) {
        return 1;
    }

    //
    // If this directory exists already, this is OK too.
    //

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        return ERROR_ALREADY_EXISTS;
    }


    //
    // No luck, copy the string to a buffer we can munge
    //

    lstrcpy (szDirectory, lpDirectory);


    //
    // Find the first subdirectory name
    //

    lpEnd = szDirectory;

    if (szDirectory[1] == TEXT(':')) {
        lpEnd += 3;
    } else if (szDirectory[1] == TEXT('\\')) {

        //
        // Skip the first two slashes
        //

        lpEnd += 2;

        //
        // Find the slash between the server name and
        // the share name.
        //

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (!(*lpEnd)) {
            return 0;
        }

        //
        // Skip the slash, and find the slash between
        // the share name and the directory name.
        //

        lpEnd++;

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (!(*lpEnd)) {
            return 0;
        }

        //
        // Leave pointer at the beginning of the directory.
        //

        lpEnd++;


    } else if (szDirectory[0] == TEXT('\\')) {
        lpEnd++;
    }

    while (*lpEnd) {

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (*lpEnd == TEXT('\\')) {
            *lpEnd = TEXT('\0');

            if (!CreateDirectory (szDirectory, NULL)) {

                if (GetLastError() != ERROR_ALREADY_EXISTS) {
                    return 0;
                }
            }

            *lpEnd = TEXT('\\');
            lpEnd++;
        }
    }


    //
    // Create the final directory
    //

    if (CreateDirectory (szDirectory, lpSecurityAttributes)) {
        return 1;
    }

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        return ERROR_ALREADY_EXISTS;
    }


    //
    // Failed
    //

    return 0;

}

LONG 
MyRegLoadKey(
    IN HKEY hKey, 
    IN LPTSTR lpSubKey, 
    IN LPTSTR lpFile
)
/*++

Routine Description:

    Loads a hive into the registry

Arguments:

    hKey -
        Supplies a handle to a registry key which will be the parent
        of the created key.

    lpSubKey -
        Supplies the name of the subkey to create.

    lpFile -
        Supplies the name of the file containing the hive.

Return Value:

    ERROR_SUCCESS if successful.
    Error code from RegLoadKey if unsuccessful.

--*/
{
    NTSTATUS Status;
    BOOLEAN WasEnabled;
    int error;

    //
    // Enable the restore privilege
    //

    Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &WasEnabled);

    if (NT_SUCCESS(Status)) {

        error = RegLoadKey(hKey, lpSubKey, lpFile);

        //
        // Restore the privilege to its previous state
        //

        RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, WasEnabled, FALSE, &WasEnabled);


    } else {

        error = GetLastError();
    }

    return error;
}


LONG 
MyRegUnLoadKey(
    IN HKEY hKey, 
    IN LPTSTR lpSubKey
)
/*++

Routine Description:

    Unloads a registry key.

Arguments:

    hKey -
        Supplies handle to parent key

    lpSubKey -
        Supplies name of subkey to delete

Return Value:

    ERROR_SUCCESS if successful
    Error code if unsuccessful

--*/
{
    LONG error;
    NTSTATUS Status;
    BOOLEAN WasEnabled;


    //
    // Enable the restore privilege
    //

    Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &WasEnabled);

    if (NT_SUCCESS(Status)) {

        error = RegUnLoadKey(hKey, lpSubKey);

        //
        // Restore the privilege to its previous state
        //

        RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, WasEnabled, FALSE, &WasEnabled);

    } else {

        error = GetLastError();
    }

    return error;
}

int 
GetSelectedItem(
    IN HWND hCtrl
)
/*++

Routine Description:
    
    Determines which item in a list view control is selected

Arguments:

    hCtrl -
        Supplies handle to the desired list view control.

Return Value:

    The index of the selected item, if an item is selected.
    -1 if no item is selected.

--*/
{
    int i, n;

    n = (int)SendMessage (hCtrl, LVM_GETITEMCOUNT, 0, 0L);

    if (n != LB_ERR)
    {
        for (i = 0; i < n; i++)
        {
            if (SendMessage (hCtrl, LVM_GETITEMSTATE,
                             i, (LPARAM) LVIS_SELECTED) == LVIS_SELECTED) {
                return i;
            }
        }
    }

    return -1;
}

BOOL
IsUserAdmin(
    VOID
)
/*++

Routine Description:

    This routine returns TRUE if the caller's process is a
    member of the Administrators local group.

    Caller is NOT expected to be impersonating anyone and IS
    expected to be able to open their own process and process
    token.

Arguments:

    None.

Return Value:

    TRUE - Caller has Administrators local group.

    FALSE - Caller does not have Administrators local group.

--*/
{
    BOOL b = FALSE;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsGroup;

    if(AllocateAndInitializeSid(
        &NtAuthority,
        2,
        SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_ADMINS,
        0, 0, 0, 0, 0, 0,
        &AdministratorsGroup
        ))
    {
        CheckTokenMembership(NULL, AdministratorsGroup, &b);

        FreeSid(AdministratorsGroup);
    }

    return(b);

} // IsUserAdmin

BOOL
_DriveIsNTFS(
    INT iDrive // drive to check on
)
{
    TCHAR szDrive[4] = TEXT("A:\\");
    TCHAR szDriveNameBuffer[MAX_PATH];
    DWORD dwMaxFnameLen;
    DWORD dwFSFlags;
    TCHAR szDriveFormatName[MAX_PATH];
    BOOL fRetVal = FALSE;
    
    szDrive[0] += (TCHAR)iDrive;
    if (GetVolumeInformation(szDrive, szDriveNameBuffer, ARRAYSIZE(szDriveNameBuffer), NULL, 
                             &dwMaxFnameLen, &dwFSFlags, szDriveFormatName, ARRAYSIZE(szDriveFormatName)))
    {
        if (StrStr(szDriveFormatName, TEXT("NTFS")))
        {
            fRetVal = TRUE;
        }
    }

    return fRetVal;
}

DWORD
GetMaxPagefileSizeInMB(
    INT iDrive // drive to check on
)
{
#if defined(_AMD64_)
    return MAX_SWAPSIZE_AMD64;
#elif defined(_X86_)
    if (USER_SHARED_DATA && (USER_SHARED_DATA->ProcessorFeatures[PF_PAE_ENABLED]) && _DriveIsNTFS(iDrive)) 
    {
        return MAX_SWAPSIZE_X86_PAE;
    }
    else
    {
        return MAX_SWAPSIZE_X86;
    }
#elif defined(_IA64_)
    return MAX_SWAPSIZE_IA64;
#else
    return 0;
#endif
}

int 
MsgBoxParam( 
    IN HWND hWnd, 
    IN DWORD wText, 
    IN DWORD wCaption, 
    IN DWORD wType, 
    ... 
)
/*++

Routine Description:

    Combination of MessageBox and printf

Arguments:

    hWnd -
        Supplies parent window handle

    wText -
        Supplies ID of a printf-like format string to display as the
        message box text

    wCaption -
        Supplies ID of a string to display as the message box caption

    wType -
        Supplies flags to MessageBox()

Return Value:

    Whatever MessageBox() returns.

--*/

{
    TCHAR   szText[ 4 * MAX_PATH ], szCaption[ 2 * MAX_PATH ];
    int     ival;
    va_list parg;

    va_start( parg, wType );

    if( wText == IDS_INSUFFICIENT_MEMORY )
        goto NoMem;

    if( !LoadString( hInstance, wText, szCaption, ARRAYSIZE( szCaption ) ) )
        goto NoMem;

    wvsprintf( szText, szCaption, parg );

    if( !LoadString( hInstance, wCaption, szCaption, ARRAYSIZE( szCaption ) ) )
        goto NoMem;

    if( (ival = MessageBox( hWnd, szText, szCaption, wType ) ) == 0 )
        goto NoMem;

    va_end( parg );

    return( ival );

NoMem:
    va_end( parg );

    ErrMemDlg( hWnd );
    return 0;
}

LPTSTR 
CloneString( 
    IN LPTSTR pszSrc 
) 
/*++

Routine Description:

    Allocates a buffer and copies a string into it

Arguments:

    pszSrc -
        Supplies string to copy

Return Value:

    Valid LPTSTR if successful
    NULL if out of memory

--*/
{
    LPTSTR pszDst = NULL;

    if (pszSrc != NULL) {
        pszDst = MemAlloc(LMEM_FIXED, (lstrlen(pszSrc)+1) * SIZEOF(TCHAR));
        if (pszDst) {
            lstrcpy( pszDst, pszSrc );
        }
    }

    return pszDst;
}

DWORD 
SetLBWidthEx(
    IN HWND hwndLB, 
    IN LPTSTR szBuffer, 
    IN DWORD cxCurWidth, 
    IN DWORD cxExtra
)
/*++

Routine Description:

    Set the width of a listbox, in pixels, acording to the size of the
    string passed in

Arguments:

    hwndLB -
        Supples listbox to resize

    szBuffer -
        Supplies string to resize listbox to

    cxCurWidth -
        Supplies current width of the listbox

    cxExtra -
        Supplies some kind of slop factor

Return Value:

    The new width of the listbox

--*/
{
    HDC     hDC;
    SIZE    Size;
    LONG    cx;
    HFONT   hfont, hfontOld;

    // Get the new Win4.0 thin dialog font
    hfont = (HFONT)SendMessage(hwndLB, WM_GETFONT, 0, 0);

    hDC = GetDC(hwndLB);

    // if we got a font back, select it in this clean hDC
    if (hfont != NULL)
        hfontOld = SelectObject(hDC, hfont);


    // If cxExtra is 0, then give our selves a little breathing space.
    if (cxExtra == 0) {
        GetTextExtentPoint(hDC, TEXT("1234"), 4 /* lstrlen("1234") */, &Size);
        cxExtra = Size.cx;
    }

    // Set scroll width of listbox

    GetTextExtentPoint(hDC, szBuffer, lstrlen(szBuffer), &Size);

    Size.cx += cxExtra;

    // Get the name length and adjust the longest name

    if ((DWORD) Size.cx > cxCurWidth)
    {
        cxCurWidth = Size.cx;
        SendMessage (hwndLB, LB_SETHORIZONTALEXTENT, (DWORD)Size.cx, 0L);
    }

    // retstore the original font if we changed it
    if (hfont != NULL)
        SelectObject(hDC, hfontOld);

    ReleaseDC(NULL, hDC);

    return cxCurWidth;
}

VOID 
SetDefButton(
    IN HWND hwndDlg,
    IN int idButton
)
/*++

Routine Description:

    Sets the default button for a dialog box or proppage
    The old default button, if any,  has its default status removed

Arguments:

    hwndDlg -
        Supplies window handle

    idButton -
        Supplies ID of button to make default

Return Value:

    None

--*/
{
    LRESULT lr;

    if (HIWORD(lr = SendMessage(hwndDlg, DM_GETDEFID, 0, 0)) == DC_HASDEFID)
    {
        HWND hwndOldDefButton = GetDlgItem(hwndDlg, LOWORD(lr));

        SendMessage (hwndOldDefButton,
                     BM_SETSTYLE,
                     MAKEWPARAM(BS_PUSHBUTTON, 0),
                     MAKELPARAM(TRUE, 0));
    }

    SendMessage( hwndDlg, DM_SETDEFID, idButton, 0L );
    SendMessage( GetDlgItem(hwndDlg, idButton),
                 BM_SETSTYLE,
                 MAKEWPARAM( BS_DEFPUSHBUTTON, 0 ),
                 MAKELPARAM( TRUE, 0 ));
}


void 
HourGlass( 
    IN BOOL bOn 
)
/*++

Routine Description:

    Turns hourglass mouse cursor on or off

Arguments:

    bOn -
        Supplies desired status of hourglass mouse cursor

Return Value:

    None

--*/
{
    if( !GetSystemMetrics( SM_MOUSEPRESENT ) )
        ShowCursor( bOn );

    SetCursor( LoadCursor( NULL, bOn ? IDC_WAIT : IDC_ARROW ) );
}

VCREG_RET 
OpenRegKey( 
    IN LPTSTR pszKeyName, 
    OUT PHKEY phk 
) 
/*++

Routine Description:

    Opens a subkey of HKEY_LOCAL_MACHINE

Arguments:

    pszKeyName -
        Supplies the name of the subkey to open

    phk -
        Returns a handle to the key if successfully opened
        Returns NULL if an error occurs

Return Value:

    VCREG_OK if successful
    VCREG_READONLY if the key was opened with read-only access
    VCREG_OK if an error occurred

*/
{
    LONG Error;

    Error = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszKeyName, 0,
            KEY_READ | KEY_WRITE, phk);

    if (Error != ERROR_SUCCESS)
    {
        Error = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszKeyName, 0, KEY_READ, phk);
        if (Error != ERROR_SUCCESS)
        {
            *phk = NULL;
            return VCREG_ERROR;
        }

        /*
         * We only have Read access.
         */
        return VCREG_READONLY;
    }

    return VCREG_OK;
}

LONG    
CloseRegKey( 
    IN HKEY hkey 
) 
/*++

Routine Description:

    Closes a registry key opened by OpenRegKey()

Arguments:

    hkey -
        Supplies handle to key to close

Return Value:

    Whatever RegCloseKey() returns

--*/
{
    return RegCloseKey(hkey);
}

BOOL
IsWorkstationProduct(
)
/*++

Routine Description:

    Determines whether the currently running system is a Workstation
    product or a Server product.

Arguments:

    None.

Return Value:

    TRUE if the currently running system is a Workstation product.
    FALSE if the currently running system is some other kind of product.

--*/
{
    NT_PRODUCT_TYPE ProdType;

    RtlGetNtProductType(&ProdType);

    return(NtProductWinNt == ProdType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\util.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    util.h

Abstract:

    Utility functions for System Control Panel Applet

Author:

    Eric Flo (ericflo) 19-Jun-1995

Revision History:

    15-Oct-1997 scotthal
        Complete overhaul

--*/
#ifndef _SYSDM_UTIL_H_
#define _SYSDM_UTIL_H_

//
// Type definitions
//
typedef enum {
    VCREG_OK,
    VCREG_READONLY,
    VCREG_ERROR,
} VCREG_RET;  // Error return codes from opening registry

//
// Public function prototypes
//
void 
ErrMemDlg( 
    IN HWND hParent 
);

LPTSTR 
SkipWhiteSpace( 
    IN LPTSTR sz 
);

int
StringToInt( 
    IN LPTSTR sz 
);

void 
IntToString( 
    IN INT i, 
    OUT LPTSTR sz
);

LPTSTR 
CheckSlash(
    IN LPTSTR lpDir
);

BOOL 
Delnode(
    IN LPTSTR lpDir
);

LONG 
MyRegSaveKey(
    IN HKEY hKey, 
    LPCTSTR lpSubKey
);

UINT 
CreateNestedDirectory(
    IN LPCTSTR lpDirectory, 
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes
);

LONG 
MyRegLoadKey(
    IN HKEY hKey, 
    IN LPTSTR lpSubKey, 
    IN LPTSTR lpFile
);

LONG 
MyRegUnLoadKey(
    IN HKEY hKey, 
    IN LPTSTR lpSubKey
);

int 
GetSelectedItem(
    IN HWND hCtrl
);

BOOL
IsUserAdmin(
    VOID
);

DWORD
GetMaxPagefileSizeInMB(
    INT iDrive
);
                   
int 
MsgBoxParam( 
    IN HWND hWnd, 
    IN DWORD wText, 
    IN DWORD wCaption, 
    IN DWORD wType, 
    ... 
);

LPTSTR 
CloneString( 
    IN LPTSTR pszSrc 
);

DWORD 
SetLBWidthEx(
    IN HWND hwndLB, 
    IN LPTSTR szBuffer, 
    IN DWORD cxCurWidth, 
    IN DWORD cxExtra
);

void
HourGlass(
    IN BOOL bOn
);

VOID
SetDefButton(
    IN HWND hwndDlg,
    IN int idButton
);

VCREG_RET 
OpenRegKey( 
    IN LPTSTR szKeyName, 
    OUT PHKEY phkMM 
);

LONG CloseRegKey( 
    IN HKEY hkey 
);

BOOL
IsWorkstationProduct(
);

#endif _SYSDM_UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\visualfx.h ===
INT_PTR WINAPI VisualEffectsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\virtual.c ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    virtual.c

Abstract:

    Implements the Change Virtual Memory dialog of the System
    Control Panel Applet

Notes:

    The virtual memory settings and the crash dump (core dump) settings
    are tightly-coupled.  Therefore, virtual.c and virtual.h have some
    heavy dependencies on crashdmp.c and startup.h (and vice versa).

Author:

    Byron Dazey 06-Jun-1992

Revision History:

    14-Apr-93 JonPa 
        maintain paging path if != \pagefile.sys

    15-Dec-93 JonPa 
        added Crash Recovery dialog

    02-Feb-1994 JonPa 
        integrated crash recover and virtual memory settings

    18-Sep-1995 Steve Cathcart 
        split system.cpl out from NT3.51 main.cpl

    12-Jan-1996 JonPa 
        made part of the new SUR pagified system.cpl

    15-Oct-1997 scotthal
        Split out CoreDump*() stuff into separate file
        
    09-Jul-2000 SilviuC
        Allow very big page files if architecture supports it.
        Allow booting without a page file.
        Allow the system to scale the page file size based on RAM changes.   

--*/
//==========================================================================
//                              Include files
//==========================================================================
// NT base apis
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <help.h>

// Application specific
#include "sysdm.h"


//==========================================================================
//                     External Data Declarations
//==========================================================================
extern HFONT   hfontBold;

//==========================================================================
//                            Local Definitions
//==========================================================================

#define MAX_SIZE_LEN        8       // Max chars in the Swap File Size edit.
#define MIN_FREESPACE       5       // Must have 5 meg free after swap file
#define MIN_SUGGEST         22      // Always suggest at least 22 meg
#define CCHMBSTRING         12      // Space for localizing the "MB" string.

/*
 * Space for 26 pagefile info structures and 26 paths to pagefiles.
 */
#define PAGEFILE_INFO_BUFFER_SIZE MAX_DRIVES * sizeof(SYSTEM_PAGEFILE_INFORMATION) + \
                                  MAX_DRIVES * MAX_PATH * sizeof(TCHAR)

/*
 * Maximum length of volume info line in the listbox.
 *                           A:  [   Vol_label  ]   %d   -   %d
 */
#define MAX_VOL_LINE        (3 + 1 + MAX_PATH + 2 + 10 + 3 + 10)


/*
 * This amount will be added to the minimum page file size to determine
 * the maximum page file size if it is not explicitly specified.
 */
#define MAXOVERMINFACTOR    50


#define TABSTOP_VOL         22
#define TABSTOP_SIZE        122


/*
 * My privilege 'handle' structure
 */
typedef struct {
    HANDLE hTok;
    TOKEN_PRIVILEGES tp;
} PRIVDAT, *PPRIVDAT;

//==========================================================================
//                            Typedefs and Structs
//==========================================================================
// registry info for a page file (but not yet formatted).
//Note: since this structure gets passed to FormatMessage, all fields must
//be 4 bytes wide (or 8 bytes on Win64)
typedef struct
{
    LPTSTR pszName;
    DWORD_PTR nMin;
    DWORD_PTR nMax;
    DWORD_PTR chNull;
} PAGEFILDESC;



//==========================================================================
//                     Global Data Declarations
//==========================================================================
HKEY ghkeyMemMgt = NULL;
int  gcrefMemMgt = 0;
VCREG_RET gvcMemMgt =  VCREG_ERROR;
int     gcrefPagingFiles = 0;
TCHAR g_szSysDir[ MAX_PATH ];

//==========================================================================
//                     Local Data Declarations
//==========================================================================
/*
 * Virtual Memory Vars
 */

// Registry Key and Value Names
TCHAR szMemMan[] =
     TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management");

TCHAR szSessionManager[] = TEXT("System\\CurrentControlSet\\Control\\Session Manager");

TCHAR szPendingRename[] = TEXT("PendingFileRenameOperations");
TCHAR szRenameFunkyPrefix[] = TEXT("\\??\\");

#ifndef VM_DBG
TCHAR szPagingFiles[] = TEXT("PagingFiles");
TCHAR szPagedPoolSize[] = TEXT("PagedPoolSize");
#else
// temp values for testing only!
TCHAR szPagingFiles[] = TEXT("TestPagingFiles");
TCHAR szPagedPoolSize[] = TEXT("TestPagedPoolSize");
#endif

/* Array of paging files.  This is indexed by the drive letter (A: is 0). */
PAGING_FILE apf[MAX_DRIVES];
PAGING_FILE apfOriginal[MAX_DRIVES];

// Other VM Vars
TCHAR szPagefile[] = TEXT("x:\\pagefile.sys");
TCHAR szNoPageFile[] = TEXT("TempPageFile");
TCHAR szMB[CCHMBSTRING];

DWORD dwFreeMB;
DWORD cmTotalVM;
DWORD cmRegSizeLim;
DWORD cmPagedPoolLim;
DWORD cmRegUsed;
static DWORD cxLBExtent;
static int cxExtra;

//
// Help IDs
//
DWORD aVirtualMemHelpIds[] = {
    IDC_STATIC,             NO_HELP,
    IDD_VM_VOLUMES,         NO_HELP,
    IDD_VM_DRIVE_HDR,       (IDH_DLG_VIRTUALMEM + 0),
    IDD_VM_PF_SIZE_LABEL,   (IDH_DLG_VIRTUALMEM + 1), 
    IDD_VM_DRIVE_LABEL,     (IDH_DLG_VIRTUALMEM + 2),
    IDD_VM_SF_DRIVE,        (IDH_DLG_VIRTUALMEM + 2),
    IDD_VM_SPACE_LABEL,     (IDH_DLG_VIRTUALMEM + 3),
    IDD_VM_SF_SPACE,        (IDH_DLG_VIRTUALMEM + 3),
    IDD_VM_ST_INITSIZE,     (IDH_DLG_VIRTUALMEM + 4),
    IDD_VM_SF_SIZE,         (IDH_DLG_VIRTUALMEM + 4),
    IDD_VM_ST_MAXSIZE,      (IDH_DLG_VIRTUALMEM + 5),
    IDD_VM_SF_SIZEMAX,      (IDH_DLG_VIRTUALMEM + 5),
    IDD_VM_SF_SET,          (IDH_DLG_VIRTUALMEM + 6),
    IDD_VM_MIN_LABEL,       (IDH_DLG_VIRTUALMEM + 7),
    IDD_VM_MIN,             (IDH_DLG_VIRTUALMEM + 7),
    IDD_VM_RECOMMEND_LABEL, (IDH_DLG_VIRTUALMEM + 8),
    IDD_VM_RECOMMEND,       (IDH_DLG_VIRTUALMEM + 8),
    IDD_VM_ALLOCD_LABEL,    (IDH_DLG_VIRTUALMEM + 9),
    IDD_VM_ALLOCD,          (IDH_DLG_VIRTUALMEM + 9),
    IDD_VM_CUSTOMSIZE_RADIO,(IDH_DLG_VIRTUALMEM + 12),
    IDD_VM_RAMBASED_RADIO,  (IDH_DLG_VIRTUALMEM + 13),
    IDD_VM_NOPAGING_RADIO,  (IDH_DLG_VIRTUALMEM + 14),
    0,0
};

#if 0

    Plan for splitting this into propert sheets:

        1.  Make the VM and CC registry keys globals that are inited
            to NULL (or INVALID_HANDLE_VALUE).  Also make gvcVirt and
            vcCore to be globals (so we can tell how the reg was opened
            inside virtinit().)

        1.  Change all RegCloseKey's to VirtualCloseKey and CoreDumpCloseKey

        2.  Change VirtualOpenKey and CoreDumpOpenKey from macros to
            functions that return the global handles if they are already
            opened, or else opens them.

        3.  In the Perf and Startup pages, call VirtualOpenKey,
            CoreDumpOpenKey, and VirtualGetPageFiles.

        -- now we can call VirtualMemComputeAlloced() from the perf page
        -- we can also just execute the CrashDump code in the startup page

        4.  rewrite VirtInit to not try and open the keys again, but instesd
            use gvcVirt, vcCore, hkeyVM and kheyCC.

        4.  Write VirtualCloseKey and CoreDumpCloseKey as follows...
            4.a     If hkey == NULL return
            4.b     RegCloseKey(hkey)
            4.c     hkey = NULL

        5.  In the PSN_RESET and PSN_APPLY cases for Perf and Startup pages
            call VirtualCloseKey and CoreDumpCloseKey

#endif



//==========================================================================
//                      Local Function Prototypes
//==========================================================================
static BOOL VirtualMemInit(HWND hDlg);
static BOOL ParsePageFileDesc(LPTSTR *ppszDesc, INT *pnDrive,
                  INT *pnMinFileSize, INT *pnMaxFileSize, LPTSTR *ppszName);
static VOID VirtualMemBuildLBLine(LPTSTR pszBuf, INT iDrive);
static INT GetMaxSpaceMB(INT iDrive);
static VOID VirtualMemSelChange(HWND hDlg);
static VOID VirtualMemUpdateAllocated(HWND hDlg);
int VirtualMemComputeTotalMax( void );
static BOOL VirtualMemSetNewSize(HWND hDlg);
static UINT VMGetDriveType(LPCTSTR lpszDrive);
void VirtualMemReconcileState();

void GetAPrivilege( LPTSTR pszPrivilegeName, PPRIVDAT ppd );
void ResetOldPrivilege( PPRIVDAT ppdOld );

DWORD VirtualMemDeletePagefile( LPTSTR szPagefile );

#define GetPageFilePrivilege( ppd )         \
        GetAPrivilege(SE_CREATE_PAGEFILE_NAME, ppd)

#define GetRegistryQuotaPrivilege( ppd )    \
        GetAPrivilege(SE_INCREASE_QUOTA_NAME, ppd)


//==========================================================================
VCREG_RET VirtualOpenKey( void ) {

    DOUT("In VirtOpenKey" );

    if (gvcMemMgt == VCREG_ERROR) {
        gvcMemMgt = OpenRegKey( szMemMan, &ghkeyMemMgt );
    }

    if (gvcMemMgt != VCREG_ERROR)
        gcrefMemMgt++;

    DPRINTF((TEXT("SYSCPL.CPL: VirtOpenKey, cref=%d\n"), gcrefMemMgt ));
    return gvcMemMgt;
}

void VirtualCloseKey(void) {

    DOUT( "In VirtCloseKey" );

    if (gcrefMemMgt > 0) {
        gcrefMemMgt--;
        if (gcrefMemMgt == 0) {
            CloseRegKey( ghkeyMemMgt );
            gvcMemMgt = VCREG_ERROR;
        }
    }


    DPRINTF((TEXT("SYSCPL.CPL: VirtCloseKey, cref=%d\n"), gcrefMemMgt ));
}

LPTSTR SkipNonWhiteSpace( LPTSTR sz ) {
    while( *sz != TEXT('\0') && !IsWhiteSpace(*sz))
        sz++;

    return sz;
}

INT TranslateDlgItemInt( HWND hDlg, int id ) {
    /*
     * We can't just call GetDlgItemInt because the
     * string we are trying to translate looks like:
     *  nnn (MB), and the '(MB)' would break GetDlgInt.
     */
    TCHAR szBuffer[256];
    int i = 0;

    if (GetDlgItemText(hDlg, id, szBuffer,
            sizeof(szBuffer) / sizeof(*szBuffer))) {
        i = StringToInt( szBuffer );
    }

    return i;
}


LPTSTR SZPageFileName (int i)
{
    if (apf[i].pszPageFile != NULL) {
        return  apf[i].pszPageFile;
    }

    szPagefile[0] = (TCHAR)(i + (int)TEXT('A'));
    return szPagefile;
}

LONG GetRegistryInt( HKEY hkey, LPTSTR pszValue, LONG lDefault ) {
    DWORD dwType;
    DWORD cbTemp;
    DWORD dwVal;

    cbTemp = sizeof(DWORD);

    if (RegQueryValueEx (hkey, pszValue, NULL,
            &dwType, (LPBYTE)&dwVal, &cbTemp) != ERROR_SUCCESS ||
            dwType != REG_DWORD || cbTemp != sizeof(DWORD)) {
        dwVal = (DWORD)lDefault;
    }

    return (LONG)dwVal;
}

BOOL SetRegistryInt( HKEY hkey, LPTSTR pszValue, LONG iValue ) {
    return RegSetValueEx(hkey, pszValue, 0L, REG_DWORD, (LPBYTE)&iValue,
            sizeof(iValue)) == ERROR_SUCCESS;
}

void VirtualCopyPageFiles( PAGING_FILE *apfDest, BOOL fFreeOld, PAGING_FILE *apfSrc, BOOL fCloneStrings ) {
    int i;

    for (i = 0; i < MAX_DRIVES; i++) {
        if (fFreeOld && apfDest[i].pszPageFile != NULL) {
            MemFree(apfDest[i].pszPageFile);
        }

        if (apfSrc != NULL) {
            apfDest[i] = apfSrc[i];

            if (fCloneStrings && apfDest[i].pszPageFile != NULL) {
                apfDest[i].pszPageFile = CloneString(apfDest[i].pszPageFile);
            }
        }
    }
}



/*
 * VirtualMemDlg
 *
 *
 *
 */

INT_PTR
APIENTRY
VirtualMemDlg(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static int fEdtCtlHasFocus = 0;

    switch (message)
    {
    case WM_INITDIALOG:
        VirtualMemInit(hDlg);
        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDD_VM_VOLUMES:
            /*
             * Make edit control reflect the listbox selection.
             */
            if (HIWORD(wParam) == LBN_SELCHANGE)
                VirtualMemSelChange(hDlg);

            break;

        case IDD_VM_SF_SET:
            if (VirtualMemSetNewSize(hDlg))
                SetDefButton(hDlg, IDOK);
            break;

        case IDOK:
        {
            int iRet = VirtualMemPromptForReboot(hDlg);
            // RET_ERROR means the user told us not to overwrite an
            // existing file called pagefile.sys, so we shouldn't
            // end the dialog just yet.
            if (RET_ERROR == iRet) {
                break;
            }

            VirtualMemUpdateRegistry();
            VirtualMemReconcileState();

            VirtualCloseKey();
#if 0
            CoreDumpCloseKey();
#endif

#if 0
            if (gfCoreDumpChanged)
                iRet |= RET_RECOVER_CHANGE;
#endif

            //
            // get rid of backup copy of pagefile structs
            //
            VirtualCopyPageFiles( apfOriginal, TRUE, NULL, FALSE );
            EndDialog(hDlg, iRet);
            HourGlass(FALSE);
            break;
        }

        case IDCANCEL:
            //
            // get rid of changes and restore original values
            //
            VirtualCopyPageFiles( apf, TRUE, apfOriginal, FALSE );

            VirtualCloseKey();
#if 0
            CoreDumpCloseKey();
#endif
            EndDialog(hDlg, RET_NO_CHANGE);
            HourGlass(FALSE);
            break;

        case IDD_VM_SF_SIZE:
        case IDD_VM_SF_SIZEMAX:
            switch(HIWORD(wParam))
            {
            case EN_CHANGE:
                if (fEdtCtlHasFocus != 0)
                    SetDefButton( hDlg, IDD_VM_SF_SET);
                break;

            case EN_SETFOCUS:
                fEdtCtlHasFocus++;
                break;

            case EN_KILLFOCUS:
                fEdtCtlHasFocus--;
                break;
            }
            break;

        case IDD_VM_NOPAGING_RADIO:
        case IDD_VM_RAMBASED_RADIO:
            if( HIWORD(wParam) == BN_CLICKED )
            {
                EnableWindow( GetDlgItem( hDlg, IDD_VM_SF_SIZE ), FALSE );
                EnableWindow( GetDlgItem( hDlg, IDD_VM_SF_SIZEMAX ), FALSE );
            }
            break;

        case IDD_VM_CUSTOMSIZE_RADIO:
            if( HIWORD(wParam) == BN_CLICKED )
            {
                EnableWindow( GetDlgItem( hDlg, IDD_VM_SF_SIZE ), TRUE );
                EnableWindow( GetDlgItem( hDlg, IDD_VM_SF_SIZEMAX ), TRUE );
            }
            break;

        default:
            break;
        }
        break;

    case WM_HELP:      // F1
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
        (DWORD_PTR) (LPSTR) aVirtualMemHelpIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
        (DWORD_PTR) (LPSTR) aVirtualMemHelpIds);
        break;


    case WM_DESTROY:
    {

        VirtualFreePageFiles(apf);
        /*
         * The docs were not clear as to what a dialog box should return
         * for this message, so I am going to punt and let the defdlgproc
         * doit.
         */

        /* FALL THROUGH TO DEFAULT CASE! */
    }

    default:
        return FALSE;
        break;
    }

    return TRUE;
}

/*
 * UINT VMGetDriveType( LPCTSTR lpszDrive )
 *
 * Gets the drive type.  This function differs from Win32's GetDriveType
 * in that it returns DRIVE_FIXED for lockable removable drives (like
 * bernolli boxes, etc).
 *
 * On IA64 we don't do this, however, requiring all pagefiles be on actual
 * fixed drives.
 */
TCHAR szDevice[] = TEXT("\\Device");

UINT VMGetDriveType( LPCTSTR lpszDrive ) {
    UINT i;
    TCHAR szDevName[MAX_PATH];

    // Check for subst drive
    if (QueryDosDevice( lpszDrive, szDevName, ARRAYSIZE( szDevName ) ) != 0) {

        // If drive does not start with '\Device', then it is not FIXED
        szDevName[ARRAYSIZE(szDevice) - 1] = '\0';
        if ( lstrcmpi(szDevName, szDevice) != 0 ) {
            return DRIVE_REMOTE;
        }
    }

    i = GetDriveType( lpszDrive );
#ifndef _WIN64
    if ( i == DRIVE_REMOVABLE ) {
        TCHAR szNtDrive[20];
        DWORD cb;
        DISK_GEOMETRY dgMediaInfo;
        HANDLE hDisk;

        /*
         * 'Removable' drive.  Check to see if it is a Floppy or lockable
         * drive.
         */

        cb = wsprintf( szNtDrive, TEXT("\\\\.\\%s"), lpszDrive );

        if ( cb != 0 && IsPathSep(szNtDrive[--cb]) ) {
            szNtDrive[cb] = TEXT('\0');
        }

        hDisk = CreateFile(
                    szNtDrive,
                    /* GENERIC_READ */ 0,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );

        if (hDisk != INVALID_HANDLE_VALUE ) {

            if (DeviceIoControl( hDisk, IOCTL_DISK_GET_MEDIA_TYPES, NULL,
                    0, &dgMediaInfo, sizeof(dgMediaInfo), &cb, NULL) == FALSE &&
                    GetLastError() != ERROR_MORE_DATA) {
                /*
                 * Drive is not a floppy
                 */
                i = DRIVE_FIXED;
            }

            CloseHandle(hDisk);
        } else if (GetLastError() == ERROR_ACCESS_DENIED) {
            /*
             * Could not open the drive, either it is bad, or else we
             * don't have permission.  Since everyone has permission
             * to open floppies, then this must be a bernoulli type device.
             */
            i = DRIVE_FIXED;
        }
    }
#endif
    return i;
}

/*
 * BOOL VirtualGetPageFiles(PAGING_FILE *apf)
 *
 *  Fills in the PAGING_FILE array from the values stored in the registry
 */
BOOL VirtualGetPageFiles(PAGING_FILE *apf) {
    DWORD cbTemp;
    LPTSTR szTemp;
    DWORD dwType;
    INT nDrive;
    INT nMinFileSize;
    INT nMaxFileSize;
    LPTSTR psz;
    DWORD dwDriveMask;
    int i;
    static TCHAR szDir[] = TEXT("?:");

    DPRINTF((TEXT("SYSCPL: In VirtualGetPageFile, cref=%d\n"), gcrefPagingFiles));

    if (gcrefPagingFiles++ > 0) {
        // Paging files already loaded
        return TRUE;
    }

    dwDriveMask = GetLogicalDrives();

    for (i = 0; i < MAX_DRIVES; dwDriveMask >>= 1, i++)
    {
        apf[i].fCanHavePagefile = FALSE;
        apf[i].nMinFileSize = 0;
        apf[i].nMaxFileSize = 0;
        apf[i].nMinFileSizePrev = 0;
        apf[i].nMaxFileSizePrev = 0;
        apf[i].pszPageFile = NULL;

        if (dwDriveMask & 0x01)
        {
            szDir[0] = TEXT('A') + i;
            switch (VMGetDriveType(szDir))
            {
                case DRIVE_FIXED:
                    apf[i].fCanHavePagefile = TRUE;
                    break;

                default:
                    break;
            }
        }
    }

    if (RegQueryValueEx (ghkeyMemMgt, szPagingFiles, NULL, &dwType,
                         (LPBYTE) NULL, &cbTemp) != ERROR_SUCCESS)
    {
        // Could not get the current virtual memory settings size.
        return FALSE;
    }

    if ((szTemp = MemAlloc(LPTR, cbTemp)) == NULL)
    {
        // Could not alloc a buffer for the vmem settings
        return FALSE;
    }


    szTemp[0] = 0;
    if (RegQueryValueEx (ghkeyMemMgt, szPagingFiles, NULL, &dwType,
                         (LPBYTE) szTemp, &cbTemp) != ERROR_SUCCESS)
    {
        // Could not read the current virtual memory settings.
        MemFree(szTemp);
        return FALSE;
    }

    psz = szTemp;
    while (*psz)
    {
        LPTSTR pszPageName;

        /*
         * If the parse works, and this drive can have a pagefile on it,
         * update the apf table.  Note that this means that currently
         * specified pagefiles for invalid drives will be stripped out
         * of the registry if the user presses OK for this dialog.
         */
        if (ParsePageFileDesc(&psz, &nDrive, &nMinFileSize, &nMaxFileSize, &pszPageName))
        {
            if (apf[nDrive].fCanHavePagefile)
            {
                apf[nDrive].nMinFileSize =
                apf[nDrive].nMinFileSizePrev = nMinFileSize;

                apf[nDrive].nMaxFileSize =
                apf[nDrive].nMaxFileSizePrev = nMaxFileSize;

                apf[nDrive].pszPageFile = pszPageName;
            }
        }
    }

    MemFree(szTemp);
    return TRUE;
}

/*
 * VirtualFreePageFiles
 *
 * Frees data alloced by VirtualGetPageFiles
 *
 */
void VirtualFreePageFiles(PAGING_FILE *apf) {
    int i;

    DPRINTF((TEXT("SYSCPL: In VirtualFreePageFile, cref=%d\n"), gcrefPagingFiles));

    if (gcrefPagingFiles > 0) {
        gcrefPagingFiles--;

        if (gcrefPagingFiles == 0) {
            for (i = 0; i < MAX_DRIVES; i++) {
                if (apf[i].pszPageFile != NULL)
                    MemFree(apf[i].pszPageFile);
            }
        }
    }
}



/*
 * VirtualInitStructures()
 *
 * Calls VirtualGetPageFiles so other helpers can be called from the Perf Page.
 *
 * Returns:
 *  TRUE if success, FALSE if failure
 */
BOOL VirtualInitStructures( void ) {
    VCREG_RET vcVirt;
    BOOL fRet = FALSE;

    vcVirt = VirtualOpenKey();

    if (vcVirt != VCREG_ERROR)
        fRet = VirtualGetPageFiles( apf );

    LoadString(hInstance, IDS_SYSDM_MB, szMB, CCHMBSTRING);

    return fRet;
}

void VirtualFreeStructures( void ) {
    VirtualFreePageFiles(apf);
    VirtualCloseKey();
}

/*
 * LPTSTR BackslashTerm( LPTSTR pszPath )
 */
LPTSTR BackslashTerm( LPTSTR pszPath )
{
    LPTSTR pszEnd;

    pszEnd = pszPath + lstrlen( pszPath );

    //
    //  Get the end of the source directory
    //

    switch( *CharPrev( pszPath, pszEnd ) )
    {
    case TEXT('\\'):
    case TEXT(':'):
        break;

    default:
        *pszEnd++ = TEXT( '\\' );
        *pszEnd = TEXT( '\0' );
    }
    return( pszEnd );
}

/*
 * VirtualMemInit
 *
 * Initializes the Virtual Memory dialog.
 *
 * Arguments:
 *  HWND hDlg - Handle to the dialog window.
 *
 * Returns:
 *  TRUE
 */

static
BOOL
VirtualMemInit(
    HWND hDlg
    )
{
    TCHAR szTemp[MAX_VOL_LINE];
    DWORD i;
    INT iItem;
    HWND hwndLB;
    INT aTabs[2];
    RECT rc;
    VCREG_RET vcVirt;
    SYSTEM_BASIC_INFORMATION BasicInfo;
    NTSTATUS status;
    unsigned __int64 TotalPhys;

    HourGlass(TRUE);


    //
    // Load the "MB" string.
    //
    LoadString(hInstance, IDS_SYSDM_MB, szMB, CCHMBSTRING);

    ////////////////////////////////////////////////////////////////////
    //  List all drives
    ////////////////////////////////////////////////////////////////////

    vcVirt = VirtualOpenKey();

    if (vcVirt == VCREG_ERROR ) {
        //  Error - cannot even get list of paging files from  registry
        MsgBoxParam(hDlg, IDS_SYSDM_NOOPEN_VM_NOTUSER, IDS_SYSDM_TITLE, MB_ICONEXCLAMATION);
        EndDialog(hDlg, RET_NO_CHANGE);
        HourGlass(FALSE);

        if (ghkeyMemMgt != NULL)
            VirtualCloseKey();
        return FALSE;
    }

    /*
     * To change Virtual Memory size or Crash control, we need access
     * to both the CrashCtl key and the PagingFiles value in the MemMgr key
     */
    if (vcVirt == VCREG_READONLY ) {
        /*
         * Disable some fields, because they only have Read access.
         */
        EnableWindow(GetDlgItem(hDlg, IDD_VM_SF_SIZE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDD_VM_SF_SIZEMAX), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDD_VM_ST_INITSIZE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDD_VM_ST_MAXSIZE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDD_VM_SF_SET), FALSE);
    }

    if (!VirtualGetPageFiles(apf)) {
        // Could not read the current virtual memory settings.
        MsgBoxParam(hDlg, IDS_SYSDM_CANNOTREAD, IDS_SYSDM_TITLE, MB_ICONEXCLAMATION);
    }

    //
    // Save a backup copy of the current pagefile structs
    //
    VirtualCopyPageFiles( apfOriginal, FALSE, apf, TRUE );

    hwndLB = GetDlgItem(hDlg, IDD_VM_VOLUMES);
    aTabs[0] = TABSTOP_VOL;
    aTabs[1] = TABSTOP_SIZE;
    SendMessage(hwndLB, LB_SETTABSTOPS, 2, (LPARAM)&aTabs);

    /*
     * Since SetGenLBWidth only counts tabs as one character, we must compute
     * the maximum extra space that the tab characters will expand to and
     * arbitrarily tack it onto the end of the string width.
     *
     * cxExtra = 1st Tab width + 1 default tab width (8 chrs) - strlen("d:\t\t");
     *
     * (I know the docs for LB_SETTABSTOPS says that a default tab == 2 dlg
     * units, but I have read the code, and it is really 8 chars)
     */
    rc.top = rc.left = 0;
    rc.bottom = 8;
    rc.right = TABSTOP_VOL + (4 * 8) - (4 * 4);
    MapDialogRect( hDlg, &rc );

    cxExtra = rc.right - rc.left;
    cxLBExtent = 0;

    for (i = 0; i < MAX_DRIVES; i++)
    {
        // Assume we don't have to create anything
        apf[i].fCreateFile = FALSE;

        if (apf[i].fCanHavePagefile)
        {
            VirtualMemBuildLBLine(szTemp, i);
            iItem = (INT)SendMessage(hwndLB, LB_ADDSTRING, 0, (LPARAM)szTemp);
            SendMessage(hwndLB, LB_SETITEMDATA, iItem, i);
            // SetGenLBWidth(hwndLB, szTemp, &cxLBExtent, hfontBold, cxExtra);
            cxLBExtent = SetLBWidthEx( hwndLB, szTemp, cxLBExtent, cxExtra);
        }
    }

    SendDlgItemMessage(hDlg, IDD_VM_SF_SIZE, EM_LIMITTEXT, MAX_SIZE_LEN, 0L);
    SendDlgItemMessage(hDlg, IDD_VM_SF_SIZEMAX, EM_LIMITTEXT, MAX_SIZE_LEN, 0L);

    /*
     * Get the total physical memory in the machine.
     */
    status = NtQuerySystemInformation(
        SystemBasicInformation,
        &BasicInfo,
        sizeof(BasicInfo),
        NULL
    );
    if (NT_SUCCESS(status)) {
        TotalPhys = (unsigned __int64) BasicInfo.NumberOfPhysicalPages * BasicInfo.PageSize;
    }
    else {
        TotalPhys = 0;
    }

    SetDlgItemMB(hDlg, IDD_VM_MIN, MIN_SWAPSIZE);

    // Recommended pagefile size is 1.5 * RAM size these days.
    // Nonintegral multiplication with unsigned __int64s is fun!
    // This will obviously fail if the machine has total RAM
    // greater than 13194139533312 MB (75% of a full 64-bit address
    // space).  Hopefully by the time someone has such a beast we'll
    // have __int128s to hold the results of this calculation.

    TotalPhys >>= 20; // Bytes to MB
    TotalPhys *= 3; // This will always fit because of the operation above
    TotalPhys >>= 1; // x*3/2 == 1.5*x, more or less
    i = (DWORD) TotalPhys; // This cast actually causes the
                           // algorithm to fail if the machine has
                           // more than ~ 3.2 billion MB of RAM.
                           // At that point, either the Win32 API has
                           // to change to allow me to pass __int64s
                           // as message params, or we have to start
                           // reporting these stats in GB.
    SetDlgItemMB(hDlg, IDD_VM_RECOMMEND, max(i, MIN_SUGGEST));

    /*
     * Select the first drive in the listbox.
     */
    SendDlgItemMessage(hDlg, IDD_VM_VOLUMES, LB_SETCURSEL, 0, 0L);
    VirtualMemSelChange(hDlg);

    VirtualMemUpdateAllocated(hDlg);

    /*
     * Show RegQuota
     */
    cmTotalVM = VirtualMemComputeTotalMax();

    HourGlass(FALSE);

    return TRUE;
}


/*
 * ParseSDD
 */

int ParseSDD( LPTSTR psz, LPTSTR szPath, INT *pnMinFileSize, INT *pnMaxFileSize) {
    int cMatched = 0;
    LPTSTR pszNext;

    psz = SkipWhiteSpace(psz);

    if (*psz) {
        int cch;

        cMatched++;
        pszNext = SkipNonWhiteSpace(psz);
        cch = (int)(pszNext - psz);
        CopyMemory( szPath, psz, sizeof(TCHAR) * cch );
        szPath[cch] = TEXT('\0');

        psz = SkipWhiteSpace(pszNext);

        if (*psz) {
            cMatched++;
            pszNext = SkipNonWhiteSpace(psz);
            *pnMinFileSize = StringToInt( psz );

            psz = SkipWhiteSpace(pszNext);

            if (*psz) {
                cMatched++;
                *pnMaxFileSize = StringToInt( psz );
            }
        }
    }

    return cMatched;
}

/*
 * ParsePageFileDesc
 *
 *
 *
 * Arguments:
 *
 * Returns:
 *
 */

static
BOOL
ParsePageFileDesc(
    LPTSTR *ppszDesc,
    INT *pnDrive,
    INT *pnMinFileSize,
    INT *pnMaxFileSize,
    LPTSTR *ppstr
    )
{
    LPTSTR psz;
    LPTSTR pszName = NULL;
    int cFields;
    TCHAR chDrive;
    TCHAR szPath[MAX_PATH];

    /*
     * Find the end of this REG_MULTI_SZ string and point to the next one
     */
    psz = *ppszDesc;
    *ppszDesc = psz + lstrlen(psz) + 1;

    /*
     * Parse the string from "filename minsize maxsize"
     */
    szPath[0] = TEXT('\0');
    *pnMinFileSize = 0;
    *pnMaxFileSize = 0;

    /* Try it without worrying about quotes */
    cFields = ParseSDD( psz, szPath, pnMinFileSize, pnMaxFileSize);

    if (cFields < 2)
        return FALSE;

    /*
     * Find the drive index
     */
    chDrive = (TCHAR)CharUpper((LPTSTR)*szPath);

    if (chDrive < TEXT('A') || chDrive > TEXT('Z'))
        return FALSE;

    *pnDrive = (INT)(chDrive - TEXT('A'));

    /* if the path != x:\pagefile.sys then save it */
    if (lstrcmpi(szPagefile + 1, szPath + 1) != 0)
    {
        pszName = CloneString(szPath);
    }

    *ppstr = pszName;

    if (cFields < 3)
    {
        INT nSpace;

        // don't call GetDriveSpace if the drive is invalid
        if (apf[*pnDrive].fCanHavePagefile)
            nSpace = GetMaxSpaceMB(*pnDrive);
        else
            nSpace = 0;
        *pnMaxFileSize = min(*pnMinFileSize + MAXOVERMINFACTOR, nSpace);
    }

    /*
     * If the page file size in the registry is zero it means this is
     * a RAM based page file.
     */
    if (*pnMinFileSize == 0) {
        apf[*pnDrive].fRamBasedPagefile = TRUE;    
    }
    else {
        apf[*pnDrive].fRamBasedPagefile = FALSE;    
    }

    return TRUE;
}



/*
 * VirtualMemBuildLBLine
 *
 *
 *
 */

static
VOID
VirtualMemBuildLBLine(
    LPTSTR pszBuf,
    INT iDrive
    )
{
    TCHAR szVolume[MAX_PATH];
    TCHAR szTemp[MAX_PATH];

    szTemp[0] = TEXT('A') + iDrive;
    szTemp[1] = TEXT(':');
    szTemp[2] = TEXT('\\');
    szTemp[3] = 0;

    *szVolume = 0;
    GetVolumeInformation(szTemp, szVolume, MAX_PATH,
            NULL, NULL, NULL, NULL, 0);

    szTemp[2] = TEXT('\t');
    lstrcpy(pszBuf, szTemp);

    if (*szVolume)
    {
        lstrcat(pszBuf, TEXT("["));
        lstrcat(pszBuf, szVolume);
        lstrcat(pszBuf, TEXT("]"));
    }

    if (apf[iDrive].fRamBasedPagefile) 
    {
        if( LoadString( hInstance, 164, szTemp, ARRAYSIZE( szTemp ) ) > 0 ) 
        {
            lstrcat(pszBuf, szTemp);
        }
    }
    else if (apf[iDrive].nMinFileSize)
    {
        wsprintf(szTemp, TEXT("\t%d - %d"),
                apf[iDrive].nMinFileSize, apf[iDrive].nMaxFileSize);
        lstrcat(pszBuf, szTemp);
    }
}



/*
 * SetDlgItemMB
 *
 *
 */

VOID SetDlgItemMB( HWND hDlg, INT idControl, DWORD dwMBValue ) {
    TCHAR szBuf[32];

    wsprintf(szBuf, TEXT("%d %s"), dwMBValue, szMB),
    SetDlgItemText(hDlg, idControl, szBuf);
}



/*
 * GetFreeSpaceMB
 *
 *
 *
 */

DWORD
GetFreeSpaceMB(
    INT iDrive
)
{
    TCHAR szDriveRoot[4];
    DWORD dwSectorsPerCluster;
    DWORD dwBytesPerSector;
    DWORD dwFreeClusters;
    DWORD dwClusters;
    DWORD iSpace;
    DWORD iSpaceExistingPagefile;
    HANDLE hff;
    WIN32_FIND_DATA ffd;


    szDriveRoot[0] = TEXT('A') + iDrive;
    szDriveRoot[1] = TEXT(':');
    szDriveRoot[2] = TEXT('\\');
    szDriveRoot[3] = (TCHAR) 0;

    if (!GetDiskFreeSpace(szDriveRoot, &dwSectorsPerCluster, &dwBytesPerSector,
            &dwFreeClusters, &dwClusters))
        return 0;

    iSpace = (INT)((dwSectorsPerCluster * dwFreeClusters) /
            (ONE_MEG / dwBytesPerSector));

    //
    // Be sure to include the size of any existing pagefile.
    // Because this space can be reused for a new paging file,
    // it is effectively "disk free space" as well.  The
    // FindFirstFile api is safe to use, even if the pagefile
    // is in use, because it does not need to open the file
    // to get its size.
    //
    iSpaceExistingPagefile = 0;
    if ((hff = FindFirstFile(SZPageFileName(szDriveRoot[0] - TEXT('A')), &ffd)) !=
        INVALID_HANDLE_VALUE)
    {
        iSpaceExistingPagefile = (INT)(ffd.nFileSizeLow / ONE_MEG);
        FindClose(hff);
    }

    return iSpace + iSpaceExistingPagefile;
}


/*
 * GetMaxSpaceMB
 *
 *
 *
 */

static
INT
GetMaxSpaceMB(
    INT iDrive
    )
{
    TCHAR szDriveRoot[4];
    DWORD dwSectorsPerCluster;
    DWORD dwBytesPerSector;
    DWORD dwFreeClusters;
    DWORD dwClusters;
    INT iSpace;


    szDriveRoot[0] = (TCHAR)(TEXT('A') + iDrive);
    szDriveRoot[1] = TEXT(':');
    szDriveRoot[2] = TEXT('\\');
    szDriveRoot[3] = (TCHAR) 0;

    if (!GetDiskFreeSpace(szDriveRoot, &dwSectorsPerCluster, &dwBytesPerSector,
                          &dwFreeClusters, &dwClusters))
        return 0;

    iSpace = (INT)((dwSectorsPerCluster * dwClusters) /
                   (ONE_MEG / dwBytesPerSector));

    return iSpace;
}


/*
 * VirtualMemSelChange
 *
 *
 *
 */

static
VOID
VirtualMemSelChange(
    HWND hDlg
    )
{
    TCHAR szDriveRoot[4];
    TCHAR szTemp[MAX_PATH];
    TCHAR szVolume[MAX_PATH];
    INT iSel;
    INT iDrive;
    INT nCrtRadioButtonId;
    BOOL fEditsEnabled;
    HWND hWndEdit;

    if ((iSel = (INT)SendDlgItemMessage(
            hDlg, IDD_VM_VOLUMES, LB_GETCURSEL, 0, 0)) == LB_ERR)
        return;

    iDrive = (INT)SendDlgItemMessage(hDlg, IDD_VM_VOLUMES,
            LB_GETITEMDATA, iSel, 0);

    szDriveRoot[0] = TEXT('A') + iDrive;
    szDriveRoot[1] = TEXT(':');
    szDriveRoot[2] = TEXT('\\');
    szDriveRoot[3] = (TCHAR) 0;

    *szVolume = (TCHAR) 0;
    GetVolumeInformation(szDriveRoot, szVolume, MAX_PATH,
            NULL, NULL, NULL, NULL, 0);
    szTemp[0] = TEXT('A') + iDrive;
    szTemp[1] = TEXT(':');
    szTemp[2] = (TCHAR) 0;

    if (*szVolume)
    {
        lstrcat(szTemp, TEXT("  ["));
        lstrcat(szTemp, szVolume);
        lstrcat(szTemp, TEXT("]"));
    }


    //LATER: should we also put up total drive size as well as free space?

    SetDlgItemText(hDlg, IDD_VM_SF_DRIVE, szTemp);
    SetDlgItemMB(hDlg, IDD_VM_SF_SPACE, GetFreeSpaceMB(iDrive));

    if ( apf[iDrive].fRamBasedPagefile ) 
    {
        HWND hWndEdit;

        //
        // Paging file size based on RAM size
        //

        nCrtRadioButtonId = IDD_VM_RAMBASED_RADIO;

        fEditsEnabled = FALSE;
    }
    else
    {
        if ( apf[iDrive].nMinFileSize != 0 ) 
        {
            //
            // Custom size paging file
            //

            nCrtRadioButtonId = IDD_VM_CUSTOMSIZE_RADIO;

            SetDlgItemInt(hDlg, IDD_VM_SF_SIZE, apf[iDrive].nMinFileSize, FALSE);
            SetDlgItemInt(hDlg, IDD_VM_SF_SIZEMAX, apf[iDrive].nMaxFileSize, FALSE);

            fEditsEnabled = TRUE;
        }
        else 
        {
            //
            // No paging file
            //
            
            nCrtRadioButtonId = IDD_VM_NOPAGING_RADIO;

            SetDlgItemText(hDlg, IDD_VM_SF_SIZE, TEXT(""));
            SetDlgItemText(hDlg, IDD_VM_SF_SIZEMAX, TEXT(""));

            fEditsEnabled = FALSE;
        }
    }

    //
    // Select the appropriate radio button
    //

    CheckRadioButton( 
        hDlg,
        IDD_VM_CUSTOMSIZE_RADIO,
        IDD_VM_NOPAGING_RADIO,
        nCrtRadioButtonId );

    //
    // Enable/disable the min & max size edit boxes
    //

    EnableWindow( GetDlgItem( hDlg, IDD_VM_SF_SIZE ), fEditsEnabled );
    EnableWindow( GetDlgItem( hDlg, IDD_VM_SF_SIZEMAX ), fEditsEnabled );
}



/*
 * VirtualMemUpdateAllocated
 *
 *
 *
 */

INT VirtualMemComputeAllocated( HWND hWnd , BOOL *pfTempPf) 
{
    BOOL fSuccess = FALSE;
    static BOOL fWarned = FALSE;
    ULONG ulPagefileSize = 0;
    unsigned __int64 PagefileSize;
    NTSTATUS result = ERROR_ACCESS_DENIED;
    SYSTEM_INFO SysInfo;
    PSYSTEM_PAGEFILE_INFORMATION pPagefileInfo = NULL;
    PSYSTEM_PAGEFILE_INFORMATION pCurrentPagefile = NULL;
    LONG lResult = ERROR_ACCESS_DENIED;
    DWORD dwValueType = 0;
    DWORD fTempPagefile = 0;
    DWORD cbSize = sizeof(DWORD);

    __try {
        pCurrentPagefile = pPagefileInfo = (PSYSTEM_PAGEFILE_INFORMATION) MemAlloc(
            LPTR,
            PAGEFILE_INFO_BUFFER_SIZE
        );
        if (!pPagefileInfo) {
            __leave;
        } // if        
    
        // Get the page size in bytes
        GetSystemInfo(&SysInfo);

        // Get the sizes (in pages) of all of the pagefiles on the system
        result = NtQuerySystemInformation(
            SystemPageFileInformation,
            pPagefileInfo,
            PAGEFILE_INFO_BUFFER_SIZE,
            NULL
        );
        if (ERROR_SUCCESS != result) {
            __leave;
        } // if

        if (pfTempPf) {
            // Check to see if the system created a temporary pagefile
            lResult = RegQueryValueEx(
                ghkeyMemMgt,
                szNoPageFile,
                NULL,
                &dwValueType,
                (LPBYTE) &fTempPagefile,
                &cbSize
            );

            if ((ERROR_SUCCESS == lResult) && fTempPagefile) {
                *pfTempPf = TRUE;
            } // if (ERROR_SUCCESS...
            else {
                *pfTempPf = FALSE;
            } // else
        } // if (pfTempPf)
        
        // Add up pagefile sizes
        while (pCurrentPagefile->NextEntryOffset) {
            ulPagefileSize += pCurrentPagefile->TotalSize;
            ((LPBYTE) pCurrentPagefile) += pCurrentPagefile->NextEntryOffset;
        } // while
        ulPagefileSize += pCurrentPagefile->TotalSize;

        // Convert pages to bytes
        PagefileSize = (unsigned __int64) ulPagefileSize * SysInfo.dwPageSize;

        // Convert bytes to MB
        ulPagefileSize = (ULONG) (PagefileSize / ONE_MEG);

        fSuccess = TRUE;
        
    } // __try
    __finally {

        // If we failed to determine the pagefile size, then
        // warn the user that the reported size is incorrect,
        // once per applet invokation.
        if (!fSuccess && !fWarned) {
            MsgBoxParam(
                hWnd,
                IDS_SYSDM_DONTKNOWCURRENT,
                IDS_SYSDM_TITLE,
                MB_ICONERROR | MB_OK
            );
            fWarned = TRUE;
        } // if

        if (pPagefileInfo) {
            MemFree((HLOCAL) pPagefileInfo);
        } // if

    } // __finally

    return(ulPagefileSize);
}

static VOID VirtualMemUpdateAllocated(
    HWND hDlg
    )
{

    SetDlgItemMB(hDlg, IDD_VM_ALLOCD, VirtualMemComputeAllocated(hDlg, NULL));
}


int VirtualMemComputeTotalMax( void ) {
    INT nTotalAllocated;
    INT i;

    for (nTotalAllocated = 0, i = 0; i < MAX_DRIVES; i++)
    {
        nTotalAllocated += apf[i].nMaxFileSize;
    }

    return nTotalAllocated;
}


/*
 * VirtualMemSetNewSize
 *
 *
 *
 */

static
BOOL
VirtualMemSetNewSize(
    HWND hDlg
    )
{
    DWORD nSwapSize;
    DWORD nSwapSizeMax;
    BOOL fTranslated;
    INT iSel;
    INT iDrive = 2; // default to C
    TCHAR szTemp[MAX_PATH];
    DWORD nFreeSpace;
    DWORD CrashDumpSizeInMbytes;
    TCHAR Drive;
    INT iBootDrive;
    BOOL fRamBasedPagefile = FALSE;

    //
    // Initialize variables for crashdump.
    //

    if (GetSystemDrive (&Drive)) {
        iBootDrive = tolower (Drive) - 'a';
    } else {
        iBootDrive = 0;
    }

    if ((iSel = (INT)SendDlgItemMessage(
            hDlg, IDD_VM_VOLUMES, LB_GETCURSEL, 0, 0)) != LB_ERR)
    {
        if (LB_ERR == 
              (iDrive = (INT)SendDlgItemMessage(hDlg, IDD_VM_VOLUMES,
                                                LB_GETITEMDATA, iSel, 0)))
        {
            return FALSE; // failure!
        }
    }


    CrashDumpSizeInMbytes =
            (DWORD) ( CoreDumpGetRequiredFileSize (NULL) / ONE_MEG );
    
#if 0
    CoreDumpGetValue(CD_LOG);
    CoreDumpGetValue(CD_SEND);
    CoreDumpGetValue(CD_WRITE);

    if (acdfControls[CD_WRITE].u.fValue) {
        nBootPF = -1;
    } else if (acdfControls[CD_LOG].u.fValue ||
            acdfControls[CD_SEND].u.fValue) {
        nBootPF = MIN_SWAPSIZE;
    }

    if (nBootPF != 0) {
        SYSTEM_BASIC_INFORMATION BasicInfo;
        NTSTATUS status;
        unsigned __int64 TotalPhys;
        TCHAR szBootPath[MAX_PATH];

        if (GetWindowsDirectory(szBootPath, MAX_PATH) == 0) {
            iBootDrive = IDRV_DEF_BOOT;
        } else {
            iBootDrive = szBootPath[0];

            if (iBootDrive > TEXT('Z'))
                iBootDrive -= TEXT('a');
            else {
                iBootDrive -= TEXT('A');
            }
        }

        if (nBootPF == -1) {
            // Get the number of Meg in the system, rounding up
            // (note that we round up a zero remainder)
            status = NtQuerySystemInformation(
                SystemBasicInformation,
                &BasicInfo,
                sizeof(BasicInfo),
                NULL
            );
            if (NT_SUCCESS(status)) {
                TotalPhys = (unsigned __int64) BasicInfo.NumberOfPhysicalPages * BasicInfo.PageSize;
            }
            else {
                TotalPhys = 0;
            }

            nBootPF = (DWORD) ((TotalPhys / ONE_MEG) + 1);
        }
    }
#endif

    if( IsDlgButtonChecked( hDlg, IDD_VM_NOPAGING_RADIO ) == BST_CHECKED )
    {
        //
        // No paging file on this drive.
        //

        nSwapSize = 0;
        nSwapSizeMax = 0;
        fTranslated = TRUE;
    }
    else
    {
        if( IsDlgButtonChecked( hDlg, IDD_VM_RAMBASED_RADIO ) == BST_CHECKED )
        {
            MEMORYSTATUSEX MemoryInfo;

            //
            // User requested a RAM based page file. We will compute a page file
            // size based on the RAM currently available so that we can benefit of
            // all the verifications done below related to disk space available etc.
            // The final page file specification written to the registry will contain
            // zero sizes though because this is the way we signal that we
            // want a RAM based page file.
            //

            ZeroMemory (&MemoryInfo, sizeof MemoryInfo);
            MemoryInfo.dwLength =  sizeof MemoryInfo;

            if (GlobalMemoryStatusEx (&MemoryInfo)) 
            {
                fRamBasedPagefile = TRUE;

                //
                // We do not lose info because we first divide the RAM size to
                // 1Mb and only after that we convert to a DWORD.
                //

                nSwapSize = (DWORD)(MemoryInfo.ullTotalPhys / 0x100000) + 12;
                nSwapSizeMax = nSwapSize;
                fTranslated = TRUE;
            }
            else 
            {
                nSwapSize = 0;
                nSwapSizeMax = 0;
                fTranslated = TRUE;
            }
        }
        else
        {
            //
            // User requested a custom size paging file
            //

            nSwapSize = (INT)GetDlgItemInt(hDlg, IDD_VM_SF_SIZE,
                    &fTranslated, FALSE);
            if (!fTranslated)
            {
                MsgBoxParam(hDlg, IDS_SYSDM_ENTERINITIALSIZE, IDS_SYSDM_TITLE, MB_ICONEXCLAMATION);
                SetFocus(GetDlgItem(hDlg, IDD_VM_SF_SIZE));
                return FALSE;
            }

            if ((nSwapSize < MIN_SWAPSIZE && nSwapSize != 0))
            {
                MsgBoxParam(hDlg, IDS_SYSDM_PAGEFILESIZE_START, IDS_SYSDM_TITLE, MB_ICONEXCLAMATION,
					GetMaxPagefileSizeInMB(iDrive));
                SetFocus(GetDlgItem(hDlg, IDD_VM_SF_SIZE));
                return FALSE;
            }

            if (nSwapSize == 0)
            {
                nSwapSizeMax = 0;
            }
            else
            {
                nSwapSizeMax = (INT)GetDlgItemInt(hDlg, IDD_VM_SF_SIZEMAX,
                        &fTranslated, FALSE);
                if (!fTranslated)
                {
                    MsgBoxParam(hDlg, IDS_SYSDM_ENTERMAXIMUMSIZE, IDS_SYSDM_TITLE, MB_ICONEXCLAMATION,
                            GetMaxPagefileSizeInMB(iDrive));
                    SetFocus(GetDlgItem(hDlg, IDD_VM_SF_SIZEMAX));
                    return FALSE;
                }

                if (nSwapSizeMax < nSwapSize || nSwapSizeMax > GetMaxPagefileSizeInMB(iDrive))
                {
                    MsgBoxParam(hDlg, IDS_SYSDM_PAGEFILESIZE_MAX, IDS_SYSDM_TITLE, MB_ICONEXCLAMATION,
                            GetMaxPagefileSizeInMB(iDrive));
                    SetFocus(GetDlgItem(hDlg, IDD_VM_SF_SIZEMAX));
                    return FALSE;
                }
            }
        }
    }

    if (fTranslated && iSel != LB_ERR)
    {
        nFreeSpace = GetMaxSpaceMB(iDrive);

        if (nSwapSizeMax > nFreeSpace)
        {
            MsgBoxParam(hDlg, IDS_SYSDM_PAGEFILESIZE_TOOSMALL_NAMED, IDS_SYSDM_TITLE, MB_ICONEXCLAMATION,
                         (TCHAR)(iDrive + TEXT('A')));
            SetFocus(GetDlgItem(hDlg, IDD_VM_SF_SIZEMAX));
            return FALSE;
        }

        nFreeSpace = GetFreeSpaceMB(iDrive);

        if (nSwapSize > nFreeSpace)
        {
            MsgBoxParam(hDlg, IDS_SYSDM_PAGEFILESIZE_TOOSMALL, IDS_SYSDM_TITLE, MB_ICONEXCLAMATION);
            SetFocus(GetDlgItem(hDlg, IDD_VM_SF_SIZE));
            return FALSE;
        }

        if (nSwapSize != 0 && nFreeSpace - nSwapSize < MIN_FREESPACE)
        {
            MsgBoxParam(hDlg, IDS_SYSDM_NOTENOUGHSPACE_PAGE, IDS_SYSDM_TITLE, MB_ICONEXCLAMATION,
                    (int)MIN_FREESPACE);
            SetFocus(GetDlgItem(hDlg, IDD_VM_SF_SIZE));
            return FALSE;
        }

        if (nSwapSizeMax > nFreeSpace)
        {
            if (MsgBoxParam(hDlg, IDS_SYSDM_PAGEFILESIZE_TOOSMALL_GROW, IDS_SYSDM_TITLE, MB_ICONINFORMATION |
                       MB_OKCANCEL, (TCHAR)(iDrive + TEXT('A'))) == IDCANCEL)
            {
                SetFocus(GetDlgItem(hDlg, IDD_VM_SF_SIZEMAX));
                return FALSE;
            }
        }

        if (iDrive == iBootDrive &&
            (ULONG64) nSwapSize < CrashDumpSizeInMbytes) {

            DWORD Ret;
            
            //
            // The new boot drive page file size is less than we need for
            // crashdump. The message notifies the user that the resultant
            // dump file may be truncated.
            //
            // NOTE: DO NOT, turn off dumping at this point, because a valid
            // dump could still be generated.
            //
             
            Ret = MsgBoxParam (hDlg,
                               IDS_SYSDM_DEBUGGING_MINIMUM,
                               IDS_SYSDM_TITLE,
                               MB_ICONEXCLAMATION | MB_YESNO,
                               (TCHAR) ( iBootDrive + TEXT ('A') ),
                               (DWORD) CrashDumpSizeInMbytes
                               );

            if (Ret != IDYES) {
                SetFocus(GetDlgItem(hDlg, IDD_VM_SF_SIZE));
                return FALSE;
            }
        }

        apf[iDrive].nMinFileSize = nSwapSize;
        apf[iDrive].nMaxFileSize = nSwapSizeMax;
        apf[iDrive].fRamBasedPagefile = fRamBasedPagefile;

        // Remember if the page file does not exist so we can create it later
        if (GetFileAttributes(SZPageFileName(iDrive)) == 0xFFFFFFFF &&
                GetLastError() == ERROR_FILE_NOT_FOUND) {
            apf[iDrive].fCreateFile = TRUE;
        }

        VirtualMemBuildLBLine(szTemp, iDrive);
        SendDlgItemMessage(hDlg, IDD_VM_VOLUMES, LB_DELETESTRING, iSel, 0);
        SendDlgItemMessage(hDlg, IDD_VM_VOLUMES, LB_INSERTSTRING, iSel,
                (LPARAM)szTemp);
        SendDlgItemMessage(hDlg, IDD_VM_VOLUMES, LB_SETITEMDATA, iSel,
                (LPARAM)iDrive);
        SendDlgItemMessage(hDlg, IDD_VM_VOLUMES, LB_SETCURSEL, iSel, 0L);

        cxLBExtent = SetLBWidthEx(GetDlgItem(hDlg, IDD_VM_VOLUMES), szTemp, cxLBExtent, cxExtra);

        if ( ( ! apf[iDrive].fRamBasedPagefile ) && ( apf[iDrive].nMinFileSize != 0 ) ) {
            SetDlgItemInt(hDlg, IDD_VM_SF_SIZE, apf[iDrive].nMinFileSize, FALSE);
            SetDlgItemInt(hDlg, IDD_VM_SF_SIZEMAX, apf[iDrive].nMaxFileSize, FALSE);
        }
        else {
            SetDlgItemText(hDlg, IDD_VM_SF_SIZE, TEXT(""));
            SetDlgItemText(hDlg, IDD_VM_SF_SIZEMAX, TEXT(""));
        }

        VirtualMemUpdateAllocated(hDlg);
        SetFocus(GetDlgItem(hDlg, IDD_VM_VOLUMES));
    }

    return TRUE;
}



/*
 * VirtualMemUpdateRegistry
 *
 *
 *
 */

BOOL
VirtualMemUpdateRegistry(
    VOID
    )
{
    LPTSTR szBuf;
    TCHAR szTmp[MAX_DRIVES * 22];  //max_drives * sizeof(fmt_string)
    LONG i;
    INT c;
    int j;
    PAGEFILDESC aparm[MAX_DRIVES];
    static TCHAR szNULLs[] = TEXT("\0\0");

    c = 0;
    szTmp[0] = TEXT('\0');
    szBuf = szTmp;

    for (i = 0; i < MAX_DRIVES; i++)
    {
        /*
         * Is this a RAM based page file or
         * does this drive have a pagefile specified for it?
         */
        if (apf[i].fRamBasedPagefile) {

            j = (c * 4);
            aparm[c].pszName = CloneString(SZPageFileName(i));
            aparm[c].nMin = 0;
            aparm[c].nMax = 0;
            aparm[c].chNull = (DWORD)TEXT('\0');
            szBuf += wsprintf( szBuf, TEXT("%%%d!s! %%%d!d! %%%d!d!%%%d!c!"),
                 j+1, j+2, j+3, j+4);
            c++;
        }
        else if (apf[i].nMinFileSize)
        {
            j = (c * 4);
            aparm[c].pszName = CloneString(SZPageFileName(i));
            aparm[c].nMin = apf[i].nMinFileSize;
            aparm[c].nMax = apf[i].nMaxFileSize;
            aparm[c].chNull = (DWORD)TEXT('\0');
            szBuf += wsprintf( szBuf, TEXT("%%%d!s! %%%d!d! %%%d!d!%%%d!c!"),
                 j+1, j+2, j+3, j+4);
            c++;
        }
    }

    /*
     * Alloc and fill in the page file registry string
     */
    //since FmtMsg returns 0 for error, it can not return a zero length string
    //therefore, force string to be at least one space long.

    if (szTmp[0] == TEXT('\0')) {
        szBuf = szNULLs;
        j = 1; //Length of string == 1 char (ZTerm null will be added later).
    } else {

        j = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_MAX_WIDTH_MASK |
            FORMAT_MESSAGE_ARGUMENT_ARRAY,
            szTmp, 0, 0, (LPTSTR)&szBuf, 1, (va_list *)&aparm);
    }


    for( i = 0; i < c; i++ )
        MemFree(aparm[i].pszName);

    if (j == 0)
        return FALSE;

    i = RegSetValueEx (ghkeyMemMgt, szPagingFiles, 0, REG_MULTI_SZ,
                       (LPBYTE)szBuf, SIZEOF(TCHAR) * (j+1));

    // free the string now that it is safely stored in the registry
    if (szBuf != szNULLs)
        FmtFree(szBuf);

    // if the string didn't get there, then return error
    if (i != ERROR_SUCCESS)
        return FALSE;


    /*
     * Now be sure that any previous pagefiles will be deleted on
     * the next boot.
     */
    for (i = 0; i < MAX_DRIVES; i++)
    {
        /*
         * Did this drive have a pagefile before, but does not have
         * one now?
         */
        if (apf[i].nMinFileSizePrev != 0 && apf[i].nMinFileSize == 0)
        {
            //
            // Hack workaround -- MoveFileEx() is broken
            //
            TCHAR szPagefilePath[MAX_PATH];

            lstrcpy(szPagefilePath, szRenameFunkyPrefix);
            lstrcat(szPagefilePath, SZPageFileName(i));
            VirtualMemDeletePagefile(szPagefilePath);
//            MoveFileEx(SZPageFileName(i), NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
        }
    }

    return TRUE;
}

void GetAPrivilege( LPTSTR szPrivilegeName, PPRIVDAT ppd ) {
    HANDLE hTok;
    LUID luid;
    TOKEN_PRIVILEGES tpNew;
    DWORD cb;

    if (LookupPrivilegeValue( NULL, szPrivilegeName, &luid ) &&
                OpenProcessToken(GetCurrentProcess(),
                TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hTok)) {

        tpNew.PrivilegeCount = 1;
        tpNew.Privileges[0].Luid = luid;
        tpNew.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

        if (!AdjustTokenPrivileges(hTok, FALSE, &tpNew, sizeof(ppd->tp),
                &(ppd->tp), &cb)) {
            GetLastError();
        }

        ppd->hTok = hTok;
    } else {
        ppd->hTok = NULL;
    }
}



void ResetOldPrivilege( PPRIVDAT ppdOld ) {
    if (ppdOld->hTok != NULL ) {

        AdjustTokenPrivileges(ppdOld->hTok, FALSE, &(ppdOld->tp), 0, NULL,
                NULL);

        CloseHandle( ppdOld->hTok );
        ppdOld->hTok = NULL;
    }
}

/*
 * VirtualMemReconcileState
 *
 * Reconciles the n*FileSizePrev fields of apf with the n*FileSize fields.
 *
 */
void
VirtualMemReconcileState(
)
{
    INT i;

    for (i = 0; i < MAX_DRIVES; i++) {
        apf[i].nMinFileSizePrev = apf[i].nMinFileSize;
        apf[i].nMaxFileSizePrev = apf[i].nMaxFileSize;
    } // for

}

/*
 * VirtualMemDeletePagefile
 *
 * Hack workaround -- MoveFileEx() is broken.
 *
 */
DWORD
VirtualMemDeletePagefile(
    IN LPTSTR szPagefile
)
{
    HKEY hKey;
    BOOL fhKeyOpened = FALSE;
    DWORD dwResult;
    LONG lResult;
    LPTSTR szBuffer = NULL;
    LPTSTR szBufferEnd = NULL;
    DWORD dwValueType;
    DWORD cbRegistry;
    DWORD cbBuffer;
    DWORD cchPagefile;
    DWORD dwRetVal = ERROR_SUCCESS;

    __try {
        cchPagefile = lstrlen(szPagefile) + 1;

        lResult = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            szSessionManager,
            0L,
            KEY_READ | KEY_WRITE,
            &hKey
        );
        if (ERROR_SUCCESS != lResult) {
            dwRetVal = lResult;
            __leave;
        } // if
        
        //
        // Find out of PendingFileRenameOperations exists, and,
        // if it does, how big it is
        //
        lResult = RegQueryValueEx(
            hKey,
            szPendingRename,
            0L,
            &dwValueType,
            (LPBYTE) NULL,
            &cbRegistry
        );
        if (ERROR_SUCCESS != lResult) {
            //
            // If the value doesn't exist, we still need to set
            // it's size to one character so the formulas below (which are
            // written for the "we're appending to an existing string"
            // case) still work.
            //
            cbRegistry = sizeof(TCHAR);
        } // if

        //
        // Buffer needs to hold the existing registry value
        // plus the supplied pagefile path, plus two extra
        // terminating NULL characters.  However, we only have to add
        // room for one extra character, because we'll be overwriting
        // the terminating NULL character in the existing buffer.
        //
        cbBuffer = cbRegistry + ((cchPagefile + 1) * sizeof(TCHAR));

        szBufferEnd = szBuffer = (LPTSTR) MemAlloc(LPTR, cbBuffer);
        if (!szBuffer) {
            dwRetVal = ERROR_NOT_ENOUGH_MEMORY;
            __leave;
        } // if

        // 
        // Grab the existing value, if there is one
        //
        if (ERROR_SUCCESS == lResult) {
            lResult = RegQueryValueEx(
                hKey,
                szPendingRename,
                0L,
                &dwValueType,
                (LPBYTE) szBuffer,
                &cbRegistry
            );
            if (ERROR_SUCCESS != lResult) {
                dwRetVal = ERROR_FILE_NOT_FOUND;
                __leave;
            } // if

            //
            // We'll start our scribbling right on the final
            // terminating NULL character of the existing 
            // value.
            //
            szBufferEnd += (cbRegistry / sizeof(TCHAR)) - 1;
        } // if

        //
        // Copy in the supplied pagefile path.
        //
        lstrcpy(szBufferEnd, szPagefile);

        //
        // Add the final two terminating NULL characters
        // required for REG_MULTI_SZ-ness.  Yes, those indeces
        // are correct--when cchPagfile was calculated above,
        // we added one for its own terminating NULL character.
        //
        szBufferEnd[cchPagefile] = TEXT('\0');
        szBufferEnd[cchPagefile + 1] = TEXT('\0');

        dwValueType = REG_MULTI_SZ;

        lResult = RegSetValueEx(
            hKey,
            szPendingRename,
            0L,
            dwValueType,
            (CONST BYTE *) szBuffer,
            cbBuffer
        );

        if (ERROR_SUCCESS != lResult) {
            dwRetVal = lResult;
        } // if

    } // __try
    __finally {
        if (fhKeyOpened) {
            RegCloseKey(hKey);
        } // if
        if (szBuffer) {
            MemFree((HLOCAL) szBuffer);
        } // if
    } // __finally

    return dwRetVal;
}

/*
 * VirtualMemCreatePagefileFromIndex
 *
 *
 */
NTSTATUS
VirtualMemCreatePagefileFromIndex(
    IN INT i
)
{
    UNICODE_STRING us;
    LARGE_INTEGER liMin, liMax;
    NTSTATUS status;
    WCHAR wszPath[MAX_PATH*2];
    TCHAR szDrive[3];
    DWORD cch;

    HourGlass(TRUE);

    // convert path drive letter to an NT device path
    wsprintf(szDrive, TEXT("%c:"), (TCHAR)(i + (int)TEXT('A')));
    cch = QueryDosDevice( szDrive, wszPath, sizeof(wszPath) /
            sizeof(TCHAR));

    if (cch != 0) {

        // Concat the filename only (skip 'd:') to the nt device
        // path, and convert it to a UNICODE_STRING
        lstrcat( wszPath, SZPageFileName(i) + 2 );
        RtlInitUnicodeString( &us, wszPath );

        liMin.QuadPart = (LONGLONG)(apf[i].nMinFileSize * ONE_MEG);
        liMax.QuadPart = (LONGLONG)(apf[i].nMaxFileSize * ONE_MEG);

        status = NtCreatePagingFile ( &us, &liMin, &liMax, 0L );

    }
    else
    {
        status = STATUS_NO_SUCH_DEVICE;
    }

    HourGlass(FALSE);

    return status;
}

/*
 * VirtualMemUpdateListboxFromIndex
 *
 */
void
VirtualMemUpdateListboxFromIndex(
    HWND hDlg,
    INT  i
)
{
    int j, cLBEntries, iTemp;
    int iLBEntry = -1;
    TCHAR szTemp[MAX_PATH];

    cLBEntries = (int)SendDlgItemMessage(
        (HWND) hDlg,
        (int) IDD_VM_VOLUMES,
        (UINT) LB_GETCOUNT,
        (WPARAM) 0,
        (LPARAM) 0
    );

    if (LB_ERR != cLBEntries) {
        // Loop through all the listbox entries, looking for the one
        // that corresponds to the drive index we were supplied.
        for (j = 0; j < cLBEntries; j++) {
            iTemp = (int)SendDlgItemMessage(
                (HWND) hDlg,
                (int) IDD_VM_VOLUMES,
                (UINT) LB_GETITEMDATA,
                (WPARAM) j,
                (LPARAM) 0
            );
            if (iTemp == i) {
                iLBEntry = j;
                break;
            } // if
        } // for

        if (-1 != iLBEntry) {
            // Found the desired entry, so update it.
            VirtualMemBuildLBLine(szTemp, i);

            SendDlgItemMessage(
                hDlg,
                IDD_VM_VOLUMES,
                LB_DELETESTRING,
                (WPARAM) iLBEntry,
                0
            );

            SendDlgItemMessage(
                hDlg,
                IDD_VM_VOLUMES,
                LB_INSERTSTRING,
                (WPARAM) iLBEntry,
                (LPARAM) szTemp
            );

            SendDlgItemMessage(
                hDlg,
                IDD_VM_VOLUMES,
                LB_SETITEMDATA,
                (WPARAM) iLBEntry,
                (LPARAM) i
            );

            SendDlgItemMessage(
                hDlg,
                IDD_VM_VOLUMES,
                LB_SETCURSEL,
                (WPARAM) iLBEntry,
                0
            );

            if (apf[i].nMinFileSize) {
                SetDlgItemInt(hDlg, IDD_VM_SF_SIZE, apf[i].nMinFileSize, FALSE);
                SetDlgItemInt(hDlg, IDD_VM_SF_SIZEMAX, apf[i].nMaxFileSize, FALSE);
            }
            else {
                SetDlgItemText(hDlg, IDD_VM_SF_SIZE, TEXT(""));
                SetDlgItemText(hDlg, IDD_VM_SF_SIZEMAX, TEXT(""));
            }

            VirtualMemUpdateAllocated(hDlg);

        } // if (-1 != iLBEntry)


    } // if (LB_ERR...

    return;

}

/*
 * VirtualMemPromptForReboot
 *
 *
 *
 */

int
VirtualMemPromptForReboot(
    HWND hDlg
    )
{
    INT i, result;
    int iReboot = RET_NO_CHANGE;
    int iThisDrv;
    UNICODE_STRING us;
    LARGE_INTEGER liMin, liMax;
    NTSTATUS status;
    TCHAR szDrive[3];
    PRIVDAT pdOld;

    GetPageFilePrivilege( &pdOld );

    // Have to make two passes through the list of pagefiles.
    // The first checks to see if files called "pagefile.sys" exist
    // on any of the drives that will be getting new pagefiles.
    // If there are existing files called "pagefile.sys" and the user
    // doesn't want any one of them to be overwritten, we bail out.
    // The second pass through the list does the actual work of
    // creating the pagefiles.

    for (i = 0; i < MAX_DRIVES; i++) {
        //
        // Did something change?
        //
        if (apf[i].nMinFileSize != apf[i].nMinFileSizePrev ||
                apf[i].nMaxFileSize != apf[i].nMaxFileSizePrev ||
                apf[i].fCreateFile ) {
            // Assume we have permission to nuke existing files called pagefile.sys
            // (we'll confirm the assumption later)
            result = IDYES;
            if (0 != apf[i].nMinFileSize) { // Pagefile wanted for this drive
                if (0 == apf[i].nMinFileSizePrev) { // There wasn't one there before
                    if (!(((GetFileAttributes(SZPageFileName(i)) == 0xFFFFFFFF)) || (GetLastError() == ERROR_FILE_NOT_FOUND))) {
                        // A file named pagefile.sys exists on the drive
                        // We need to confirm that we can overwrite it
                        result = MsgBoxParam(
                            hDlg,
                            IDS_SYSDM_OVERWRITE,
                            IDS_SYSDM_TITLE,
                            MB_ICONQUESTION | MB_YESNO,
                            SZPageFileName(i)
                        );
                    } // if (!((GetFileAttributes...
                } // if (0 == apf[i].nMinFileSizePrev)

                if (IDYES != result) {
                    // User doesn't want us overwriting an existing
                    // file called pagefile.sys, so back out the changes
                    apf[i].nMinFileSize = apf[i].nMinFileSizePrev;
                    apf[i].nMaxFileSize = apf[i].nMaxFileSizePrev;
                    apf[i].fCreateFile = FALSE;

                    // Update the listbox
                    VirtualMemUpdateListboxFromIndex(hDlg, i);
                    SetFocus(GetDlgItem(hDlg, IDD_VM_VOLUMES));

                    // Bail, telling the DlgProc not to end the dialog
                    iReboot = RET_ERROR;
                    goto bailout;
                } // if (IDYES != result)
            } // if (0 != apf[i].nMinFileSize)
            
        } // if
    } // for

    for (i = 0; i < MAX_DRIVES; i++)
    {
        //
        // Did something change?
        //
        if (apf[i].nMinFileSize != apf[i].nMinFileSizePrev ||
                apf[i].nMaxFileSize != apf[i].nMaxFileSizePrev ||
                apf[i].fCreateFile ) {
            /*
             * If we are strictly creating a *new* page file, or *enlarging*
             * the minimum or maximum size of an existing page file, then
             * we can try do it on the fly.  If no errors are returned by
             * the system then no reboot will be required.
             */

            // assume we will have to reboot
            iThisDrv = RET_VIRTUAL_CHANGE;

            /*
             * IF we are creating a new page file
             */
            if ((0 != apf[i].nMinFileSize) && (0 == apf[i].nMinFileSizePrev)) {

                status = VirtualMemCreatePagefileFromIndex(i);

                if (NT_SUCCESS(status)) {
                    // made it on the fly, no need to reboot for this drive!
                    iThisDrv = RET_CHANGE_NO_REBOOT;
                }
            }
            /*
             * If we're enlarging the minimum or maximum size of an existing
             * page file, we can try to do it on the fly
             */
            else if ((apf[i].nMinFileSize != 0) &&
                ((apf[i].nMinFileSize > apf[i].nMinFileSizePrev) ||
                (apf[i].nMaxFileSize > apf[i].nMaxFileSizePrev))) {

                status = VirtualMemCreatePagefileFromIndex(i);
                if (NT_SUCCESS(status)) {
                    iThisDrv = RET_CHANGE_NO_REBOOT;
                }

            } /* else if */

            // if this drive has changed, we must reboot
            if (RET_VIRTUAL_CHANGE == iThisDrv)
            {
                iReboot |= RET_VIRTUAL_CHANGE;
            }

        }
    }

bailout:
    ResetOldPrivilege( &pdOld );

    //
    // If Nothing changed, then change our IDOK to IDCANCEL so System.cpl will
    // know not to reboot.
    //
    return iReboot;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\visualfx.cpp ===
#include "sysdm.h"
#include <windowsx.h>
#include "shlapip.h"
#include "regstr.h"
#include "ccstock.h"
#include "shguidp.h"
#include "ieguidp.h"
#include "help.h"

#define REGSTRA_EXPLORER_VISUALFX  "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\VisualEffects"
#define REGSTRA_VISUALFX_SETTING   "VisualFXSetting"

#define VISUALFX_SETTING_AUTO    0x0
#define VISUALFX_SETTING_LOOKS   0x1
#define VISUALFX_SETTING_PERF    0x2
#define VISUALFX_SETTING_CUSTOM  0x3

DWORD aVisualFXHelpIds[] =
{
    IDC_VFX_TITLE,               NO_HELP,
    IDC_VFX_TREE,                NO_HELP,
    IDC_VFX_BESTLOOKS,           (IDH_PERF + 10),
    IDC_VFX_BESTPERF,            (IDH_PERF + 11),
    IDC_VFX_AUTO,                (IDH_PERF + 12),
    IDC_VFX_CUSTOM,              (IDH_PERF + 19),
    0, 0
};

class CVisualEffectsDlg
{
public:
    INT_PTR DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    HRESULT Init();

    CVisualEffectsDlg();
    virtual ~CVisualEffectsDlg();

private:
    void _EnableApply();
    void _SetItemCheckState(HTREEITEM hti, BOOL fCheck);
    void _OnCommand(WORD wID);
    void _OnInitDialog(HWND hDlg);
    void _OnNotify(LPNMHDR pnm);

    WORD  _wMode;
    HWND  _hwndTree;
    HWND  _hDlg;
    IRegTreeOptions *_prto;
    BOOL  _fDirtyTree;
    BOOL  _fTreeInit;
};

CVisualEffectsDlg::CVisualEffectsDlg() : _hwndTree(NULL), _hDlg(NULL), _prto(NULL), _fDirtyTree(FALSE), _fTreeInit(FALSE), _wMode(VISUALFX_SETTING_AUTO)
{
}

CVisualEffectsDlg::~CVisualEffectsDlg()
{
    ATOMICRELEASE(_prto);
}

HRESULT CVisualEffectsDlg::Init()
{
    return CoCreateInstance(CLSID_CRegTreeOptions, NULL, CLSCTX_INPROC_SERVER, 
                                IID_PPV_ARG(IRegTreeOptions, &_prto));
}

void CVisualEffectsDlg::_EnableApply()
{
    if( !_fTreeInit )
    {
        // Enable the "Apply" button because changes have happened.
        _fDirtyTree = TRUE;
        SendMessage(GetParent(_hDlg), PSM_CHANGED, (WPARAM)_hDlg, 0L);
    }
}

void CVisualEffectsDlg::_SetItemCheckState(HTREEITEM hti, BOOL fCheck)
{
    TVITEM tvi;
    tvi.hItem = hti;
    tvi.mask = TVIF_HANDLE | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    
    if (TreeView_GetItem(_hwndTree, &tvi))
    {
        tvi.iImage = fCheck ? IDCHECKED : IDUNCHECKED;
        tvi.iSelectedImage = tvi.iImage;

        TreeView_SetItem(_hwndTree, &tvi);
    }
}

void CVisualEffectsDlg::_OnCommand(WORD wID)
{
    if (wID != _wMode)
    {
        _wMode = wID;
        switch (wID)
        {
        case IDC_VFX_BESTLOOKS:
        case IDC_VFX_BESTPERF:
            {
                BOOL fCheck = (wID == IDC_VFX_BESTLOOKS);
                for (HTREEITEM hti = TreeView_GetRoot(_hwndTree); hti != NULL; 
                        hti = TreeView_GetNextItem(_hwndTree, hti, TVGN_NEXT))
                {
                    _SetItemCheckState(hti, fCheck);
                }
            }
            _EnableApply();
            break;

        case IDC_VFX_AUTO:
            _prto->WalkTree(WALK_TREE_RESTORE);
            _EnableApply();
            break;
        case IDC_VFX_CUSTOM:
            break;
        }
    }
}

void CVisualEffectsDlg::_OnInitDialog(HWND hDlg)
{
    _hDlg = hDlg;
    _hwndTree = GetDlgItem(hDlg, IDC_VFX_TREE);

    DWORD cbData, dwData;
    cbData = sizeof(dwData);
    if (ERROR_SUCCESS != SHRegGetUSValue(TEXT(REGSTRA_EXPLORER_VISUALFX), TEXT(REGSTRA_VISUALFX_SETTING), NULL, &dwData, &cbData, FALSE, NULL, 0))
    {
        dwData = VISUALFX_SETTING_AUTO;
    }

    _fTreeInit = TRUE;
    _prto->InitTree(_hwndTree, HKEY_LOCAL_MACHINE, REGSTRA_EXPLORER_VISUALFX, NULL);
    SendMessage(GetDlgItem(_hDlg, IDC_VFX_AUTO + dwData), BM_CLICK, 0, 0);
    _fTreeInit = FALSE;
}

void CVisualEffectsDlg::_OnNotify(LPNMHDR pnm)
{
    switch (pnm->code)
    {
    case NM_CLICK:
    case NM_DBLCLK:
        if (pnm->idFrom == IDC_VFX_TREE)
        {
            TV_HITTESTINFO ht;

            DWORD dwPos = GetMessagePos();                  // get where we were hit
            ht.pt.x = GET_X_LPARAM(dwPos);
            ht.pt.y = GET_Y_LPARAM(dwPos);
            ScreenToClient(_hwndTree, &ht.pt);       // translate it to our window

            // retrieve the item hit
            HTREEITEM hti = TreeView_HitTest(_hwndTree, &ht);
            if (hti)
            {
                if (VISUALFX_SETTING_CUSTOM != _wMode)
                {
                    CheckRadioButton(_hDlg, IDC_VFX_AUTO, IDC_VFX_CUSTOM, IDC_VFX_CUSTOM);
                }
                _prto->ToggleItem(hti);
                _EnableApply();
            }
        }
        break;

    case TVN_KEYDOWN:
        if (((LPNMTVKEYDOWN)pnm)->wVKey == VK_SPACE)
        {
            if (VISUALFX_SETTING_CUSTOM != _wMode)
            {
                CheckRadioButton(_hDlg, IDC_VFX_AUTO, IDC_VFX_CUSTOM, IDC_VFX_CUSTOM);
            }
            _prto->ToggleItem((HTREEITEM)SendMessage(_hwndTree, TVM_GETNEXTITEM, (WPARAM)TVGN_CARET, 0L));
            _EnableApply();
        }
        break;

    case PSN_APPLY:
        if (_fDirtyTree)
        {
            _prto->WalkTree(WALK_TREE_SAVE);
            for (int i = IDC_VFX_AUTO; i <= IDC_VFX_CUSTOM; i++)
            {
                if (BST_CHECKED == SendMessage(GetDlgItem(_hDlg, i), BM_GETCHECK, 0, 0))
                {
                    DWORD dwData = VISUALFX_SETTING_AUTO + (i - IDC_VFX_AUTO);
                    SHRegSetUSValue(TEXT(REGSTRA_EXPLORER_VISUALFX), TEXT(REGSTRA_VISUALFX_SETTING), REG_DWORD, &dwData, sizeof(dwData), SHREGSET_FORCE_HKCU);
                    break;
                }
            }
            DWORD_PTR dwResult = 0;
            SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, NULL, (LPARAM)TEXT("VisualEffects"),
                               SMTO_NOTIMEOUTIFNOTHUNG, 1000, &dwResult);
            _fDirtyTree = FALSE;
        }
        break;
    }
}

INT_PTR CVisualEffectsDlg::DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        _OnInitDialog(hDlg);
        break;

    case WM_NOTIFY:
        _OnNotify(((LPNMHDR)lParam));
        break;

    case WM_COMMAND:
        _OnCommand(GET_WM_COMMAND_ID(wParam, lParam));
        break;

    case WM_DESTROY:
        _prto->WalkTree(WALK_TREE_DELETE);
        break;

    case WM_HELP:      // F1
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
                (DWORD_PTR) (LPSTR) aVisualFXHelpIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
                (DWORD_PTR) (LPSTR) aVisualFXHelpIds);
        break;
    default:
        return FALSE;
    }

    return TRUE;
}

INT_PTR WINAPI VisualEffectsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR fRet = FALSE;
    CVisualEffectsDlg* pve;

    if (uMsg == WM_INITDIALOG)
    {
        pve = new CVisualEffectsDlg();
        if (pve && FAILED(pve->Init()))
        {
            delete pve;
            pve = NULL;
        }
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pve);
    }
    else
    {
        pve = (CVisualEffectsDlg*)GetWindowLongPtr(hDlg, DWLP_USER);
    }

    if (pve)
    {
        fRet = pve->DlgProc(hDlg, uMsg, wParam, lParam);
        if (uMsg == WM_DESTROY)
        {
            delete pve;
            SetWindowLongPtr(hDlg, DWLP_USER, NULL);
        }
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\system\virtual.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    virtual.h

Abstract:

    Public declarations for the Change Virtual Memory dialog of the System
    Control Panel Applet

Notes:

    The virtual memory settings and the crash dump (core dump) settings
    are tightly-coupled.  Therefore, virtual.c and virtual.h have some
    heavy dependencies on crashdmp.c and startup.h (and vice versa).

Author:

    Byron Dazey 06-Jun-1992

Revision History:

    15-Oct-1997 scotthal
        Split public declarations into separate header

--*/
#ifndef _SYSDM_VIRTUAL_H_
#define _SYSDM_VIRTUAL_H_

//
// Some debugging macros shared by the virtual mem and crash dump stuff
//
#ifdef VM_DBG
#   pragma message(__FILE__"(19): warning !!!! : compiled for DEBUG ONLY!" )
#   define  DPRINTF(p)  DBGPRINTF(p)
#   define  DOUT(S)     DBGOUT(S)
#else
#   define  DPRINTF(p)
#   define  DOUT(S)
#endif

//
// Constants
//
#define MAX_DRIVES          26      // Max number of drives.

//
// Type Definitions
//
typedef struct
{
    BOOL fCanHavePagefile;      // TRUE if the drive can have a pagefile.
    BOOL fCreateFile;           // TRUE if user hits [SET] and no pagefile
    DWORD nMinFileSize;         // Minimum size of pagefile in MB.
    DWORD nMaxFileSize;         // Max size of pagefile in MB.
    DWORD nMinFileSizePrev;     // Previous minimum size of pagefile in MB.
    DWORD nMaxFileSizePrev;     // Previous max size of pagefile in MB.
    LPTSTR  pszPageFile;        // Path to page file if it exists on that drv
    BOOL fRamBasedPagefile;     // TRUE if the pagefile size should always match RAM
} PAGING_FILE; //  Swap file structure

//
// Global Variables
//
extern HKEY ghkeyMemMgt;
extern PAGING_FILE apf[MAX_DRIVES];
extern PAGING_FILE apfOriginal[MAX_DRIVES];

//
// Public function prototypes
//
INT_PTR
APIENTRY
VirtualMemDlg(
    IN HWND hDlg,
    IN UINT message,
    IN WPARAM wParam,
    IN LPARAM lParam
);

BOOL
VirtualInitStructures(
    void
);

void
VirtualFreeStructures(
    void
);

INT
VirtualMemComputeAllocated(
    IN HWND hWnd,
    OUT BOOL *pfTempPf
);

VCREG_RET 
VirtualOpenKey( 
    void 
);

void 
VirtualCloseKey(
    void
);

BOOL 
VirtualGetPageFiles(
    OUT PAGING_FILE *apf
);

void 
VirtualFreePageFiles(
    IN PAGING_FILE *apf
);

BOOL 
VirtualMemUpdateRegistry(
    VOID
);

int 
VirtualMemPromptForReboot(
    IN HWND hDlg
);

DWORD
GetFreeSpaceMB(
    IN INT iDrive
);

VOID 
SetDlgItemMB(
    IN HWND hDlg, 
    IN INT idControl, 
    IN DWORD dwMBValue
);

#endif // _SYSDM_VIRTUAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\utc\calendar.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    calendar.c

Abstract:

    This module implements the calendar control for the Date/Time applet.

Revision History:

--*/



//
//  Include Files.
//

#include "timedate.h"
#include "rc.h"




//
//  Constant Declarations.
//

#define DEF_FIRST_WEEKDAY   (6)

#define cBorderX             5
#define cBorderY             3
#define cBorderSelect        1

#define IS_FE_LANGUAGE(p)    (((p) == LANG_CHINESE)  ||         \
                              ((p) == LANG_JAPANESE) ||         \
                              ((p) == LANG_KOREAN))




//
//  Typedef Declarations.
//

//
//  Struture for global data.
//
typedef struct _CALINFO
{
    HWND    hwnd;       // the hwnd
    HFONT   hfontCal;   // the font to use
    BOOL    fFocus;     // do we have the focus
    int     cxBlank;    // size of a blank
    int     cxChar;     // the width of digits
    int     cyChar;     // the height of digits
} CALINFO, *PCALINFO;




////////////////////////////////////////////////////////////////////////////
//
//  GetFirstDayOfAnyWeek
//
//  For this function ONLY:
//    0 = Monday
//    6 = Sunday
//
////////////////////////////////////////////////////////////////////////////

int GetFirstDayOfAnyWeek()
{
    static int iDay = -1;

    if (iDay < 0)
    {
        TCHAR ch[2] = { 0 };

        *ch = TEXT('0') + DEF_FIRST_WEEKDAY;

        GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_IFIRSTDAYOFWEEK, ch, 2);

        iDay = ( ((*ch >= TEXT('0')) && (*ch <= TEXT('6')))
                     ? ((int)*ch - TEXT('0'))
                     : DEF_FIRST_WEEKDAY );
    }

    return (iDay);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetLocalWeekday
//
////////////////////////////////////////////////////////////////////////////

int GetLocalWeekday()
{
    //
    //  Convert local first day to 0==sunday and subtract from today.
    //
    return ((wDateTime[WEEKDAY] + 7 - ((GetFirstDayOfAnyWeek() + 1) % 7)) % 7);
}

void DetermineDayOfWeek()
{
    FILETIME   FileTime;
    SYSTEMTIME SystemTime;

    SystemTime.wHour   = wDateTime[HOUR];
    SystemTime.wMinute = wDateTime[MINUTE];
    SystemTime.wSecond = wDateTime[SECOND];

    SystemTime.wMilliseconds = 0;

    SystemTime.wMonth  = wDateTime[MONTH];
    SystemTime.wDay    = wDateTime[DAY];
    SystemTime.wYear   = wDateTime[YEAR];
    SystemTimeToFileTime(&SystemTime, &FileTime);
    FileTimeToSystemTime(&FileTime, &SystemTime);
    wDateTime[WEEKDAY] = SystemTime.wDayOfWeek;
}

////////////////////////////////////////////////////////////////////////////
//
//  GetFirstDayOfTheMonth
//
////////////////////////////////////////////////////////////////////////////

int GetFirstDayOfTheMonth()
{
    DetermineDayOfWeek();
    return ((GetLocalWeekday() + 8 - (wDateTime[DAY] % 7)) % 7);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetDaysOfTheMonth
//
////////////////////////////////////////////////////////////////////////////

int GetDaysOfTheMonth(
    int iMonth)
{
    int cDays;
    int nYear;

    //
    //  Calculate the number of days in the current month -
    //  add one if this is a leap year and the month is February.
    //
    if (iMonth <= 7)
    {
        cDays = 30 + (iMonth % 2);
    }
    else
    {
        cDays = 31 - (iMonth % 2);
    }

    if (iMonth == 2)
    {
        cDays = 28;
        nYear = wDateTime[YEAR];
        if ((nYear % 4 == 0) && ((nYear % 100 != 0) || (nYear % 400 == 0)))
        {
            cDays++;
        }
    }

    return (cDays);
}


////////////////////////////////////////////////////////////////////////////
//
//  AdjustDeltaDay
//
//  Adjust the day part of the current date
//
////////////////////////////////////////////////////////////////////////////

void AdjustDeltaDay(
    HWND hwnd,
    int iDay)
{
    GetTime();

    if (wDateTime[DAY] != iDay)
    {
        wPrevDateTime[DAY] = wDateTime[DAY] = (WORD)iDay;
        fDateDirty = TRUE;

        //
        //  Let our parent know that we changed.
        //
        FORWARD_WM_COMMAND( GetParent(hwnd),
                            GetWindowLong(hwnd, GWL_ID),
                            hwnd,
                            CBN_SELCHANGE,
                            SendMessage );
    }
}

int GetCalendarName(LPTSTR pszName, int cch)
{
    TCHAR    szDateString[100];
    SYSTEMTIME SystemTime;
    int cchResult = 0;

    SystemTime.wHour   = wDateTime[HOUR];
    SystemTime.wMinute = wDateTime[MINUTE];
    SystemTime.wSecond = wDateTime[SECOND];

    SystemTime.wMilliseconds = 0;

    SystemTime.wMonth  = wDateTime[MONTH];
    SystemTime.wDay    = wDateTime[DAY];
    SystemTime.wYear   = wDateTime[YEAR];

    if (0 != GetDateFormat(LOCALE_USER_DEFAULT, DATE_LONGDATE,
        &SystemTime, NULL, szDateString, ARRAYSIZE(szDateString)))
    {
        if (pszName)
            lstrcpyn( pszName, szDateString, cch);

        cchResult = lstrlen(szDateString);
    }
    
    return cchResult;
}


////////////////////////////////////////////////////////////////////////////
//
//  ChangeCurrentDate
//
//  If we pass in iNewCol < 0, we simply want to invalidate todays date.
//  This is used when we gain and lose focus.
//
////////////////////////////////////////////////////////////////////////////

void ChangeCurrentDate(
    PCALINFO pci,
    int iNewCol,
    int iNewRow)
{
    int iFirstDay, iRow, iColumn;
    RECT rc, rcT;

    GetClientRect(pci->hwnd, &rc);
    iFirstDay = GetFirstDayOfTheMonth();
    iColumn = (wDateTime[DAY] - 1 + iFirstDay) % 7;
    iRow = 1 + ((wDateTime[DAY] - 1 + iFirstDay) / 7);

    rcT.left = (((rc.right - rc.left) * iColumn) / 7) + cBorderX - cBorderSelect;
    rcT.right = rcT.left + (pci->cxChar * 2) + (2 * cBorderSelect);
    rcT.top = ((rc.bottom - rc.top) * iRow ) / 7 + cBorderY - cBorderSelect;
    rcT.bottom = rcT.top + pci->cyChar + (2 * cBorderSelect);

    InvalidateRect(pci->hwnd, &rcT, FALSE);

    if (iNewCol >= 0)
    {
        AdjustDeltaDay(pci->hwnd, ((iNewRow - 1) * 7) + iNewCol + 1 - iFirstDay);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CalendarPaint
//
////////////////////////////////////////////////////////////////////////////

#ifdef UNICODE
  #define NUM_DBCS_CHARS     1         // 1 Unicode char
#else
  #define NUM_DBCS_CHARS     2         // 1 lead byte, 1 trail byte
#endif

BOOL CalendarPaint(
    PCALINFO pci,
    HWND hwnd)
{
    RECT rc, rcT;
    PAINTSTRUCT ps;
    HDC hdc;
    int iWeek, iWeekDay, iDay, iMaxDays;
    int iFirstDayOfWeek, iFirstDayOfMonth;
    TCHAR pszDate[3];
    TCHAR szShortDay[25];
    DWORD dwbkColor;
    COLORREF o_TextColor;
    LCID Locale;
    LANGID LangID = GetUserDefaultLangID();
    BOOL IsFELang = IS_FE_LANGUAGE(PRIMARYLANGID(LangID));

    iFirstDayOfMonth = GetFirstDayOfTheMonth();
    iMaxDays = GetDaysOfTheMonth(wDateTime[MONTH]);
    iDay = 1;
    pszDate[0] = TEXT(' ');
    pszDate[1] = TEXT('0');

    //
    //  Paint the background of the dates page.
    //
    hdc = BeginPaint(hwnd, &ps);
    GetClientRect(hwnd, &rc);
    FillRect(hdc, &rc, GetSysColorBrush(COLOR_WINDOW));

    //
    //  The day specifier.
    //
    rcT.left = rc.left;
    rcT.right = rc.right;
    rcT.top = rc.top;
    rcT.bottom = rc.top + ((rc.bottom - rc.top) / 7);
    FillRect(hdc, &rcT, GetSysColorBrush(COLOR_INACTIVECAPTION));

    //
    //  Fill the page.
    //
    SetBkColor(hdc, GetSysColor(COLOR_WINDOW));
    SelectFont(hdc, pci->hfontCal);
    SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));

    //
    //  See if we need to calculate the size of characters.
    //
    if (pci->cxChar == 0)
    {
        DrawText(hdc, TEXT("0"), 1, &rcT, DT_CALCRECT);
        pci->cxChar = rcT.right - rcT.left;
        pci->cyChar = rcT.bottom - rcT.top;

        DrawText(hdc, TEXT(" "), 1, &rcT, DT_CALCRECT);
        pci->cxBlank = rcT.right - rcT.left;
    }

    for (iWeek = 1; (iWeek < 7); iWeek++)
    {
        for (iWeekDay = iFirstDayOfMonth;
             (iWeekDay < 7) && (iDay <= iMaxDays);
             iWeekDay++)
        {
            rcT.left = ((((rc.right - rc.left) * iWeekDay) / 7)) + cBorderX;
            rcT.top = (((rc.bottom - rc.top) * iWeek) / 7) + cBorderY;
            rcT.right = rcT.left + 20;
            rcT.bottom = rcT.top + 20;

            if (pszDate[1] == TEXT('9'))
            {
                pszDate[1] = TEXT('0');

                if (pszDate[0] == TEXT(' '))
                {
                    pszDate[0] = TEXT('1');
                }
                else
                {
                    pszDate[0] = pszDate[0] + 1;
                }
            }
            else
            {
                pszDate[1] = pszDate[1] + 1;
            }

            if (wDateTime[DAY] == iDay)
            {
                dwbkColor = GetBkColor(hdc);
                SetBkColor(hdc, GetSysColor(COLOR_ACTIVECAPTION));
                o_TextColor = GetTextColor(hdc);
                SetTextColor(hdc, GetSysColor(COLOR_CAPTIONTEXT));
            }

            ExtTextOut( hdc,
                        rcT.left,
                        rcT.top,
                        0,
                        &rcT,
                        (LPTSTR)pszDate,
                        2,
                        NULL );

            //
            //  If we drew it inverted - put it back.
            //
            if (wDateTime[DAY] == iDay)
            {
                //
                //  If we have the focus we also need to draw the focus
                //  rectangle for this item.
                //
                if (pci->fFocus)
                {
                    rcT.bottom = rcT.top + pci->cyChar;

                    if (iDay <= 9)
                    {
                        rcT.right = rcT.left + pci->cxChar + pci->cxBlank;
                    }
                    else
                    {
                        rcT.right = rcT.left + 2 * pci->cxChar;
                    }

                    DrawFocusRect(hdc, &rcT);
                }

                SetBkColor(hdc, dwbkColor);
                SetTextColor(hdc, o_TextColor);
            }

            iFirstDayOfMonth = 0;
            iDay++;
        }
    }

    //
    //  Set the FONT color for the SMTWTFS line.
    //
    dwbkColor = SetBkColor(hdc, GetSysColor(COLOR_INACTIVECAPTION));
    SetTextColor(hdc, GetSysColor(COLOR_INACTIVECAPTIONTEXT));

    iFirstDayOfWeek = GetFirstDayOfAnyWeek();

    if (!IsFELang)
    {
        //
        //  Not a FE locale.
        //
        //  If it's Arabic or Syriac, then we want to use the US locale to get the
        //  first letter of the abbreviated day name to display in the calendar.
        //
        Locale = ((PRIMARYLANGID(LangID) == LANG_ARABIC) || (PRIMARYLANGID(LangID) == LANG_SYRIAC))
                   ? MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT), SORT_DEFAULT)
                   : LOCALE_USER_DEFAULT;

        for (iWeekDay = 0; (iWeekDay < 7); iWeekDay++)
        {
            GetLocaleInfo( Locale,
                           LOCALE_SABBREVDAYNAME1 + (iWeekDay + iFirstDayOfWeek) % 7,
                           szShortDay,
                           sizeof(szShortDay) / sizeof(TCHAR) );

            if (*szShortDay)
            {
                *szShortDay = (TCHAR)CharUpper((LPTSTR)(DWORD_PTR)*szShortDay);
            }

            TextOut( hdc,
                     (((rc.right - rc.left) * iWeekDay) / 7) + cBorderX,
                     cBorderY,
                     szShortDay,
                     1 );
        }
    }
    else
    {
        //
        //  FE Locale.
        //
        for (iWeekDay = 0; (iWeekDay < 7); iWeekDay++)
        {
            GetLocaleInfo( LOCALE_USER_DEFAULT,
                           LOCALE_SABBREVDAYNAME1 + (iWeekDay + iFirstDayOfWeek) % 7,
                           szShortDay,
                           sizeof(szShortDay) / sizeof(TCHAR) );

#ifndef UNICODE
            if (*szShortDay && !IsDBCSLeadByte(*szShortDay))
#else
            if (*szShortDay)
#endif
            {
                *szShortDay = (TCHAR)CharUpper((LPTSTR)(DWORD_PTR)*szShortDay);
            }

            if ((PRIMARYLANGID(LangID) == LANG_CHINESE) &&
                (lstrlen(szShortDay) == 3 * NUM_DBCS_CHARS))
            {
                TextOut( hdc,
                         (((rc.right - rc.left) * iWeekDay) / 7) + cBorderX,
                         cBorderY,
                         (LangID == MAKELANGID( LANG_CHINESE,
                                                SUBLANG_CHINESE_HONGKONG ))
                           ? szShortDay
                           : szShortDay + (2 * NUM_DBCS_CHARS),
                         1 * NUM_DBCS_CHARS );
            }
            else
            {
                TextOut( hdc,
                         (((rc.right - rc.left) * iWeekDay) / 7) + cBorderX,
                         cBorderY,
                         szShortDay,
                         lstrlen(szShortDay) );
            }
        }
    }

    SetBkColor(hdc, dwbkColor);
    EndPaint(hwnd, &ps);
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  IsValidClick
//
////////////////////////////////////////////////////////////////////////////

BOOL IsValidClick(
    HWND hwnd,
    int x,
    int y)
{
    int iT;

    if (y == 0)
    {
        return (FALSE);
    }

    iT = GetFirstDayOfTheMonth();

    if ((y == 1) && (x < iT))
    {
        return (FALSE);
    }

    iT += GetDaysOfTheMonth(wDateTime[MONTH]) - 1;

    if (y > ((iT / 7) + 1))
    {
        return (FALSE);
    }

    if ((y == ((iT / 7) + 1)) && (x > (iT % 7)))
    {
        return (FALSE);
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  HandleDateChange
//
////////////////////////////////////////////////////////////////////////////

BOOL HandleDateChange(
    PCALINFO pci,
    int x,
    int y)
{
    RECT rc, rcT;
    int ix, iy;

    GetClientRect(pci->hwnd, &rc);

    ix = (x * 7) / (rc.right - rc.left);
    iy = (y * 7) / (rc.bottom - rc.top);

    if (IsValidClick(pci->hwnd, ix, iy))
    {
        rcT.left = (((rc.right - rc.left) * ix)/ 7) + cBorderX - cBorderSelect;
        rcT.right = rcT.left + (2 * pci->cxChar) + (2 * cBorderSelect);
        rcT.top = ((rc.bottom - rc.top) * iy) / 7 + cBorderY - cBorderSelect;
        rcT.bottom = rcT.top + pci->cyChar + (2 * cBorderSelect);

        InvalidateRect(pci->hwnd, &rcT, FALSE);
        ChangeCurrentDate( pci,
                           (x * 7) / (rc.right - rc.left),
                           (y * 7) / (rc.bottom - rc.top) );

        NotifyWinEvent(EVENT_OBJECT_NAMECHANGE , pci->hwnd, OBJID_WINDOW, CHILDID_SELF);
        return (TRUE);
    }
    else
    {
        return (FALSE);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  HandleKeyDown
//
////////////////////////////////////////////////////////////////////////////

void HandleKeyDown(
    PCALINFO pci,
    int vk,
    LPARAM lParam)
{
    RECT rcT;

    //
    //  First thing, lets try to figure out what the current x and y is.
    //
    int ix = GetLocalWeekday();
    int iy = (wDateTime[DAY] + GetFirstDayOfTheMonth() - 1) / 7;

    switch (vk)
    {
        case ( VK_LEFT ) :
        {
            ix--;
            if (ix < 0)
            {
                ix = 6;
                iy--;
            }
            break;
        }
        case ( VK_RIGHT ) :
        {
            ix++;
            if (ix == 7)
            {
                ix = 0;
                iy++;
            }
            break;
        }
        case ( VK_UP ) :
        {
            iy--;
            break;
        }
        case ( VK_DOWN ) :
        {
            iy++;
            break;
        }
        default :
        {
            //
            //  Ignore the character.
            //
            return;
        }
    }

    //
    //  The y's are offset for the days of the week.
    //
    iy++;
    if (!IsValidClick(pci->hwnd, ix, iy))
    {
        return;
    }

    GetClientRect(pci->hwnd, &rcT);
    rcT.left = ((rcT.right * ix) / 7) + cBorderX - cBorderSelect;
    rcT.right = rcT.left + (2 * pci->cxChar) + (2 * cBorderSelect);
    rcT.top = (rcT.bottom * iy) / 7 + cBorderY - cBorderSelect;
    rcT.bottom = rcT.top + pci->cyChar + (2 * cBorderSelect);

    InvalidateRect(pci->hwnd, &rcT, FALSE);

    //
    //  First try, simply call to change the date.
    //
    ChangeCurrentDate(pci, ix, iy);
    NotifyWinEvent(EVENT_OBJECT_NAMECHANGE , pci->hwnd, OBJID_WINDOW, CHILDID_SELF);
}


////////////////////////////////////////////////////////////////////////////
//
//  CalWndProc
//
////////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK CalWndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PCALINFO pci;

    pci = (PCALINFO)GetWindowLongPtr(hwnd, 0);

    switch (message)
    {
        case ( WM_CREATE ) :
        {
            pci = (PCALINFO)LocalAlloc(LPTR, sizeof(CALINFO));
            if (pci == 0)
            {
                return (-1);
            }

            pci->hwnd = hwnd;
            SetWindowLongPtr(hwnd, 0, (LONG_PTR)pci);

            GetDate();
            break;
        }
        case ( WM_NCDESTROY ) :
        {
            if (pci)
            {
                LocalFree((HLOCAL)pci);
            }
            break;
        }
        case ( WM_SETFONT ) :
        {
            if (wParam)
            {
                pci->hfontCal = (HFONT)wParam;
                pci->cxChar = 0;
            }
            break;
        }
        case ( WM_GETTEXT ) :
        {
            return GetCalendarName((LPTSTR)lParam, (int)wParam);   
        }
        case ( WM_GETTEXTLENGTH ) :
        {
            return GetCalendarName(NULL, 0);   
        }
        case ( WM_PAINT ) :
        {
            CalendarPaint(pci, hwnd);
            break;
        }
        case ( WM_LBUTTONDOWN ) :
        {
            SetFocus(hwnd);
            HandleDateChange(pci, LOWORD(lParam), HIWORD(lParam));
            break;
        }
        case ( WM_SETFOCUS ) :
        {
            pci->fFocus = TRUE;
            ChangeCurrentDate(pci, -1, -1);
            break;
        }
        case ( WM_KILLFOCUS ) :
        {
            pci->fFocus = FALSE;
            ChangeCurrentDate(pci, -1, -1);
            break;
        }
        case ( WM_KEYDOWN ) :
        {
            HandleKeyDown(pci, (int)wParam, lParam);
            break;
        }
        case ( WM_GETDLGCODE ) :
        {
            return (DLGC_WANTARROWS);
            break;
        }
        default :
        {
            return ( DefWindowProc(hwnd, message, wParam, lParam) );
        }
    }
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  CalendarInit
//
////////////////////////////////////////////////////////////////////////////

TCHAR const c_szCalClass[] = CALENDAR_CLASS;

BOOL CalendarInit(
    HANDLE hInstance)
{
    WNDCLASS wc;

    if (!GetClassInfo(hInstance, c_szCalClass, &wc))
    {
        wc.style         = CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS;
        wc.cbClsExtra    = 0;
        wc.cbWndExtra    = sizeof(PCALINFO);
        wc.hCursor       = NULL;
        wc.hbrBackground = NULL;
        wc.hIcon         = NULL;
        wc.lpszMenuName  = NULL;
        wc.lpszClassName = c_szCalClass;
        wc.hInstance     = hInstance;
        wc.lpfnWndProc   = CalWndProc;

        return (RegisterClass(&wc));
    }
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\utc\clock.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    clock.c

Abstract:

    This module implements the clock control for the Date/Time applet.

Revision History:

--*/



//
//  Include Files.
//

#include "timedate.h"
#include "rc.h"
#include "clock.h"




//
//  Constant Declarations.
//

#define TIMER_ID             1

#define SECONDSCALE          80
#define HHAND                TRUE
#define MHAND                FALSE
#define MAXBLOBWIDTH         25

#define REPAINT              0
#define HANDPAINT            1

#define OPEN_TLEN            450    /* < half second */

#define MINDESIREDHEIGHT     3




//
//  Macro Definitions.
//

#ifdef WIN32
  #define MoveTo(hdc, x, y)       MoveToEx(hdc, x, y, NULL)
  #define GetWindowPtr(w, o)      GetWindowLongPtr(w, o)
  #define SetWindowPtr(w, o, p)   SetWindowLongPtr(w, o, (LPARAM)(p))
#else
  #define GetWindowPtr(w, o)      GetWindowWord(w, o)
  #define SetWindowPtr(w, o, p)   SetWindowWord(w, o, p)
#endif




//
//  Typedef Declarations.
//

typedef struct
{
    int     hour;                   // 0 - 11 hours for analog clock
    int     minute;
    int     second;

} TIME;

typedef struct
{
    HWND    hWnd;               // Us.

    HWND    hwndGetTime;        // window to provide get/set time

    // Brushes
    HBRUSH  hbrColorWindow;
    HBRUSH  hbrBtnHighlight;
    HBRUSH  hbrForeground;
    HBRUSH  hbrBlobColor;

    // Pens
    HPEN    hpenForeground;
    HPEN    hpenBackground;
    HPEN    hpenBlobHlt;

    // Dimensions of clock
    RECT    clockRect;
    int     clockRadius;
    int     HorzRes;
    int     VertRes;
    int     aspectD;
    int     aspectN;

    // Position of clock
    POINT   clockCenter;

    TIME    oTime;
    TIME    nTime;

} CLOCKSTR, *PCLOCKSTR;

typedef struct
{
    SHORT x;
    SHORT y;

} TRIG;


//
//  Array containing the sine and cosine values for hand positions.
//
POINT rCircleTable[] =
{
    { 0,     -7999},
    { 836,   -7956},
    { 1663,  -7825},
    { 2472,  -7608},
    { 3253,  -7308},
    { 3999,  -6928},
    { 4702,  -6472},
    { 5353,  -5945},
    { 5945,  -5353},
    { 6472,  -4702},
    { 6928,  -4000},
    { 7308,  -3253},
    { 7608,  -2472},
    { 7825,  -1663},
    { 7956,  -836 },

    { 8000,  0    },
    { 7956,  836  },
    { 7825,  1663 },
    { 7608,  2472 },
    { 7308,  3253 },
    { 6928,  4000 },
    { 6472,  4702 },
    { 5945,  5353 },
    { 5353,  5945 },
    { 4702,  6472 },
    { 3999,  6928 },
    { 3253,  7308 },
    { 2472,  7608 },
    { 1663,  7825 },
    { 836,   7956 },

    {  0,    7999 },
    { -836,  7956 },
    { -1663, 7825 },
    { -2472, 7608 },
    { -3253, 7308 },
    { -4000, 6928 },
    { -4702, 6472 },
    { -5353, 5945 },
    { -5945, 5353 },
    { -6472, 4702 },
    { -6928, 3999 },
    { -7308, 3253 },
    { -7608, 2472 },
    { -7825, 1663 },
    { -7956, 836  },

    { -7999, -0   },
    { -7956, -836 },
    { -7825, -1663},
    { -7608, -2472},
    { -7308, -3253},
    { -6928, -4000},
    { -6472, -4702},
    { -5945, -5353},
    { -5353, -5945},
    { -4702, -6472},
    { -3999, -6928},
    { -3253, -7308},
    { -2472, -7608},
    { -1663, -7825},
    { -836 , -7956},
};




//
//  Function prototypes.
//

LRESULT CALLBACK ClockWndProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

void ClockCreate(HWND hWnd, PCLOCKSTR np);
void ClockTimer(HWND hWnd, WPARAM idTimer, PCLOCKSTR np);
void ClockPaint(PCLOCKSTR np, HDC hDC, int hint);
void ClockTimerInterval( HWND hWnd, PCLOCKSTR np );
void CompClockDim(HWND hWnd, PCLOCKSTR np);
void CreateTools(PCLOCKSTR np);
void DeleteTools(PCLOCKSTR np);
void DrawFace(HDC hDC, PCLOCKSTR np);
void DrawFatHand( HDC hDC, int pos, HPEN hPen, BOOL hHand, PCLOCKSTR np);
void DrawHand( HDC hDC, int pos, HPEN hPen, int scale, int patMode, PCLOCKSTR np);





////////////////////////////////////////////////////////////////////////////
//
//  ClockInit
//
//  Registers the clock class.
//
////////////////////////////////////////////////////////////////////////////

TCHAR const c_szClockClass[] = CLOCK_CLASS;

BOOL ClockInit(
    HINSTANCE hInstance)
{
    WNDCLASS wc;

    if (!GetClassInfo(hInstance, c_szClockClass, &wc))
    {
        wc.cbClsExtra    = 0;
        wc.cbWndExtra    = sizeof(PCLOCKSTR);
        wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = NULL;
        wc.hIcon         = NULL;
        wc.lpszMenuName  = NULL;
        wc.lpszClassName = c_szClockClass;
        wc.hInstance     = hInstance;
        wc.style         = CS_VREDRAW | CS_HREDRAW ;
        wc.lpfnWndProc   = ClockWndProc;

        return (RegisterClass(&wc));
    }
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetTimeClock
//
//  Gets the time that we should display on the clock.
//  The client could have specified a function to call to get this
//  or an HWND to pass a message to to get it from.
//
////////////////////////////////////////////////////////////////////////////

void GetTimeClock(
    TIME *pt,
    PCLOCKSTR np)
{
    SYSTEMTIME st;

    //
    //  Call our time provider or default to GetTime.
    //
    if (np->hwndGetTime)
    {
        SendMessage( np->hwndGetTime,
                     CLM_UPDATETIME,
                     CLF_GETTIME,
                     (LPARAM)(LPSYSTEMTIME)&st );
        pt->hour = st.wHour % 12;
        pt->minute = st.wMinute;
        pt->second = st.wSecond;
    }
    else
    {
#ifdef WIN32
        GetLocalTime(&st);

        pt->hour = st.wHour;
        pt->minute = st.wMinute;
        pt->second = st.wSecond;
#else
        //
        // No function call back and no HWND callback.
        //
        GetTime();
        pt->hour = wDateTime[HOUR] % 12;
        pt->minute = wDateTime[MINUTE];
        pt->second = wDateTime[SECOND];
#endif
     }
}


////////////////////////////////////////////////////////////////////////////
//
//  CreateTools
//
////////////////////////////////////////////////////////////////////////////

void CreateTools(
    PCLOCKSTR np)
{
    #define BLOB_COLOR  RGB(0, 128, 128)

    np->hbrForeground   = GetSysColorBrush(COLOR_BTNSHADOW);
    np->hbrColorWindow  = GetSysColorBrush(COLOR_BTNFACE);
    np->hbrBlobColor    = CreateSolidBrush( BLOB_COLOR );
    np->hbrBtnHighlight = GetSysColorBrush(COLOR_BTNHIGHLIGHT);
    np->hpenForeground  = CreatePen(0, 1, GetSysColor(COLOR_WINDOWTEXT));
    np->hpenBackground  = CreatePen(0, 1, GetSysColor(COLOR_BTNFACE));
    np->hpenBlobHlt     = CreatePen(0, 1, RGB(0, 255, 255));
}


////////////////////////////////////////////////////////////////////////////
//
//  DeleteTools
//
////////////////////////////////////////////////////////////////////////////

void DeleteTools(
    PCLOCKSTR np)
{
//  DeleteObject(np->hbrForeground);
//  DeleteObject(np->hbrColorWindow);
    DeleteObject(np->hbrBlobColor);
//  DeleteObject(np->hbrBtnHighlight);
    DeleteObject(np->hpenForeground);
    DeleteObject(np->hpenBackground);
    DeleteObject(np->hpenBlobHlt);
}


////////////////////////////////////////////////////////////////////////////
//
//  CompClockDim
//
//  Calculates the clock dimensions.
//
////////////////////////////////////////////////////////////////////////////

void CompClockDim(
    HWND hWnd,
    PCLOCKSTR np)
{
    int i;
    int tWidth;
    int tHeight;

    tWidth = np->clockRect.right - np->clockRect.left;
    tHeight = np->clockRect.bottom - np->clockRect.top;

    if (tWidth > MulDiv(tHeight,np->aspectD,np->aspectN))
    {
        i = MulDiv(tHeight, np->aspectD, np->aspectN);
        np->clockRect.left += (tWidth - i) / 2;
        np->clockRect.right = np->clockRect.left + i;
    }
    else
    {
        i = MulDiv(tWidth, np->aspectN, np->aspectD);
        np->clockRect.top += (tHeight - i) / 2;
        np->clockRect.bottom = np->clockRect.top + i;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  ClockTimerInterval
//
//  Sets the timer interval. Two things affect this interval:
//    1) if the window is iconic, or
//    2) if seconds option has been disabled
//  In both cases, timer ticks occur every half-minute. Otherwise, timer
//  every half-second.
//
////////////////////////////////////////////////////////////////////////////

void ClockTimerInterval(
    HWND hWnd,
    PCLOCKSTR np)
{
    //
    //  Update every 1/2 second in the opened state.
    //
    KillTimer(hWnd, TIMER_ID);
    SetTimer(hWnd, TIMER_ID, OPEN_TLEN, 0L);
}


////////////////////////////////////////////////////////////////////////////
//
//  ClockSize
//
//  Sizes the clock to the specified size.
//
////////////////////////////////////////////////////////////////////////////

void ClockSize(
    PCLOCKSTR np,
    int newWidth,
    int newHeight)
{
    SetRect(&np->clockRect, 0, 0, newWidth, newHeight);
    CompClockDim(np->hWnd, np);
    ClockTimerInterval(np->hWnd, np);
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawFace
//
//  Draws the clock face.
//
////////////////////////////////////////////////////////////////////////////

void DrawFace(
    HDC hDC,
    PCLOCKSTR np)
{
    int i;
    RECT tRect;
    LPPOINT ppt;
    int blobHeight, blobWidth;

    blobWidth = MulDiv( MAXBLOBWIDTH,
                        (np->clockRect.right - np->clockRect.left),
                        np->HorzRes );
    blobHeight = MulDiv(blobWidth, np->aspectN, np->aspectD);

    if (blobHeight < 2)
    {
        blobHeight = 1;
    }

    if (blobWidth < 2)
    {
        blobWidth = 2;
    }

    InflateRect(&np->clockRect, -(blobHeight / 2), -(blobWidth / 2));

    np->clockRadius = (np->clockRect.right - np->clockRect.left - 8) / 2;
    np->clockCenter.y = np->clockRect.top +
                        ((np->clockRect.bottom - np->clockRect.top) / 2) - 1;
    np->clockCenter.x = np->clockRect.left + np->clockRadius + 3;

    for (i = 0; i < 60; i++)
    {
        ppt = rCircleTable + i;

        tRect.top  = MulDiv(ppt->y, np->clockRadius, 8000) + np->clockCenter.y;
        tRect.left = MulDiv(ppt->x, np->clockRadius, 8000) + np->clockCenter.x;

        if (i % 5)
        {
            //
            //  Draw a dot.
            //
            if (blobWidth > 2 && blobHeight >= 2)
            {
                tRect.right = tRect.left + 2;
                tRect.bottom = tRect.top + 2;
                FillRect(hDC, &tRect, GetStockObject(WHITE_BRUSH));
                OffsetRect(&tRect, -1, -1);
                FillRect(hDC, &tRect, np->hbrForeground);
                tRect.left++;
                tRect.top++;
                FillRect(hDC, &tRect, np->hbrColorWindow);
            }
        }
        else
        {
            tRect.right = tRect.left + blobWidth;
            tRect.bottom = tRect.top + blobHeight;
            OffsetRect(&tRect, -(blobWidth / 2) , -(blobHeight / 2));

            SelectObject(hDC, GetStockObject(BLACK_PEN));
            SelectObject(hDC, np->hbrBlobColor);

            Rectangle(hDC, tRect.left, tRect.top, tRect.right, tRect.bottom);
            SelectObject(hDC, np->hpenBlobHlt);
            MoveTo(hDC, tRect.left, tRect.bottom - 1);
            LineTo(hDC, tRect.left, tRect.top);
            LineTo(hDC, tRect.right - 1, tRect.top);
        }
    }

    InflateRect(&np->clockRect, blobHeight / 2, blobWidth / 2);
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawHand
//
//  Draws the hands of the clock.
//
////////////////////////////////////////////////////////////////////////////

void DrawHand(
    HDC hDC,
    int pos,
    HPEN hPen,
    int scale,
    int patMode,
    PCLOCKSTR np)
{
    LPPOINT lppt;
    int radius;

    MoveTo(hDC, np->clockCenter.x, np->clockCenter.y);
    radius = MulDiv(np->clockRadius, scale, 100);
    lppt = rCircleTable + pos;
    SetROP2(hDC, patMode);
    SelectObject(hDC, hPen);

    LineTo( hDC,
            np->clockCenter.x + MulDiv(lppt->x, radius, 8000),
            np->clockCenter.y + MulDiv(lppt->y, radius, 8000) );
}


////////////////////////////////////////////////////////////////////////////
//
//  Adjust
//
////////////////////////////////////////////////////////////////////////////

void Adjust(
    POINT *rgpt,
    int cPoint,
    int iDelta)
{
    int i;

    for (i = 0; i < cPoint; i++)
    {
        rgpt[i].x += iDelta;
        rgpt[i].y += iDelta;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawFatHand
//
//  Draws either hour or minute hand.
//
////////////////////////////////////////////////////////////////////////////

void DrawFatHand(
    HDC hDC,
    int pos,
    HPEN hPen,
    BOOL hHand,
    PCLOCKSTR np)
{
    int m;
    int n;
    int scale;

    TRIG tip;
    TRIG stip;
    BOOL fErase;
    POINT rgpt[4];
    HBRUSH hbrInit, hbrControl = NULL;

    SetROP2(hDC, 13);
    fErase = (hPen == np->hpenBackground);

    SelectObject(hDC, hPen);

    scale = hHand ? 7 : 5;

    n = (pos + 15) % 60;
    m = MulDiv(np->clockRadius, scale, 100);

    stip.y = (SHORT)MulDiv(rCircleTable[n].y, m, 8000);
    stip.x = (SHORT)MulDiv(rCircleTable[n].x, m, 8000);

    scale = hHand ? 65 : 80;
    tip.y = (SHORT)MulDiv(rCircleTable[pos % 60].y, MulDiv(np->clockRadius, scale, 100), 8000);
    tip.x = (SHORT)MulDiv(rCircleTable[pos % 60].x, MulDiv(np->clockRadius, scale, 100), 8000);

    rgpt[0].x = np->clockCenter.x + stip.x;
    rgpt[0].y = np->clockCenter.y + stip.y;
    rgpt[1].x = np->clockCenter.x + tip.x;
    rgpt[1].y = np->clockCenter.y + tip.y;
    rgpt[2].x = np->clockCenter.x - stip.x;
    rgpt[2].y = np->clockCenter.y - stip.y;

    scale = hHand ? 15 : 20;

    n = (pos + 30) % 60;
    m = MulDiv(np->clockRadius, scale, 100);
    tip.y = (SHORT)MulDiv(rCircleTable[n].y, m, 8000);
    tip.x = (SHORT)MulDiv(rCircleTable[n].x, m, 8000);

    rgpt[3].x = np->clockCenter.x + tip.x;
    rgpt[3].y = np->clockCenter.y + tip.y;

    SelectObject(hDC, GetStockObject(NULL_PEN));

    if (fErase)
    {
        hbrControl = (HBRUSH)SendMessage(GetParent(np->hWnd), WM_CTLCOLORSTATIC, (WPARAM)hDC, (LPARAM)np->hWnd);
        hbrInit = SelectObject(hDC, hbrControl ? hbrControl : np->hbrColorWindow);
    }
    else
    {
        hbrInit = SelectObject(hDC, np->hbrBtnHighlight);
    }

    Adjust(rgpt, 4, -2);
    Polygon(hDC, rgpt, 4);

    if (!fErase)
    {
        SelectObject(hDC, np->hbrForeground);
    }

    Adjust(rgpt, 4, 4);
    Polygon(hDC, rgpt, 4);
  
    if (!fErase)
    {
        SelectObject(hDC, np->hbrBlobColor);
    }

    Adjust(rgpt, 4, -2);
    Polygon(hDC, rgpt, 4);

    //
    //  If we selected a brush in, reset it now.
    //
    if (fErase)
    {
        SelectObject(hDC, hbrInit);        
    }    
}


////////////////////////////////////////////////////////////////////////////
//
//  ClockPaint
//
//  Only paints the clock.
//
//  It assumes you have set nTime already.  This allows it to be called by
//  the timer or by the client.
//
////////////////////////////////////////////////////////////////////////////

void ClockPaint(
    PCLOCKSTR np,
    HDC hDC,
    int hint)
{
    SetBkMode(hDC, TRANSPARENT);

    if (hint == REPAINT)
    {
        //
        //  If doing a full repaint, we do not advance the time.
        //  Otherwise we will create artifacts when there is a clipping
        //  region.
        //
        DrawFace(hDC, np);

        DrawFatHand(hDC, np->oTime.hour * 5 + (np->oTime.minute / 12), np->hpenForeground, HHAND,np);
        DrawFatHand(hDC, np->oTime.minute, np->hpenForeground, MHAND,np);

        //
        //  Draw the second hand.
        //
        DrawHand(hDC, np->oTime.second, np->hpenBackground, SECONDSCALE, R2_NOT,np);
    }
    else if (hint == HANDPAINT)
    {
        DrawHand(hDC, np->oTime.second, np->hpenBackground, SECONDSCALE, R2_NOT, np);

        if (np->nTime.minute != np->oTime.minute || np->nTime.hour != np->oTime.hour)
        {
            DrawFatHand(hDC, np->oTime.minute, np->hpenBackground, MHAND, np);
            DrawFatHand(hDC, np->oTime.hour * 5 + (np->oTime.minute / 12), np->hpenBackground, HHAND,np);
            DrawFatHand(hDC, np->nTime.minute, np->hpenForeground, MHAND, np);
            DrawFatHand(hDC, (np->nTime.hour) * 5 + (np->nTime.minute / 12), np->hpenForeground, HHAND, np);
        }

        DrawHand(hDC, np->nTime.second, np->hpenBackground, SECONDSCALE, R2_NOT, np);
        np->oTime = np->nTime;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  ClockTimer
//
//  Update the clock.  Called on a timer tick.
//
////////////////////////////////////////////////////////////////////////////

void ClockTimer(
    HWND hWnd,
    UINT_PTR idTimer,
    PCLOCKSTR np)
{
    HDC hDC;

    GetTimeClock(&np->nTime, np);

    if ((np->nTime.second == np->oTime.second) &&
        (np->nTime.minute == np->oTime.minute) &&
        (np->nTime.hour == np->oTime.hour))
    {
        return;
    }

    hDC = GetDC(hWnd);
    ClockPaint(np, hDC, HANDPAINT);
    ReleaseDC(hWnd, hDC);
}


////////////////////////////////////////////////////////////////////////////
//
//  ClockCreate
//
////////////////////////////////////////////////////////////////////////////

void ClockCreate(
    HWND hWnd,
    PCLOCKSTR np)
{
    int i;
    HDC hDC;
    int HorzSize;
    int VertSize;
    LPPOINT lppt;

    hDC = GetDC(hWnd);
    np->VertRes = GetDeviceCaps(hDC, VERTRES);
    np->HorzRes = GetDeviceCaps(hDC, HORZRES);
    VertSize= GetDeviceCaps(hDC, VERTSIZE);
    HorzSize= GetDeviceCaps(hDC, HORZSIZE);
    ReleaseDC(hWnd, hDC);
    np->aspectN = MulDiv(np->VertRes, 100, VertSize);
    np->aspectD = MulDiv(np->HorzRes, 100, HorzSize);

    //
    //  Instance stuff.
    //
    np->hWnd = hWnd;

    CreateTools(np);

    //
    //  Scale cosines for aspect ratio if this is the first instance.
    //
    for (i = 0; i < 60; i++)
    {
        lppt = rCircleTable + i;
        lppt->y = MulDiv(lppt->y, np->aspectN, np->aspectD);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  ClockWndProc
//
//  Deals with the clock messages.
//
////////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK ClockWndProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PCLOCKSTR np = (PCLOCKSTR)GetWindowPtr(hWnd, 0);

    switch (message)
    {
        case ( WM_DESTROY ) :
        {
            if (np)
            {
                KillTimer(hWnd, TIMER_ID);
                DeleteTools(np);
                LocalFree((HLOCAL)np);
                SetWindowPtr(hWnd, 0, 0);
            }
            break;
        }
        case ( WM_CREATE ) :
        {
            //
            //  Allocate the instance data space.
            //
            np = (PCLOCKSTR)LocalAlloc(LPTR, sizeof(CLOCKSTR));
            if (!np)
            {
                return (-1);
            }

            SetWindowPtr(hWnd, 0, np);

            ClockCreate(hWnd, np);

            SetLayout(GetDC(hWnd), LAYOUT_BITMAPORIENTATIONPRESERVED);

            //
            //  Loop if control panel time being changed.
            //
            GetTimeClock(&(np->nTime), np);
            do
            {
                GetTimeClock(&(np->oTime), np);
            } while (np->nTime.second == np->oTime.second &&
                     np->nTime.minute == np->oTime.minute &&
                     np->nTime.hour == np->oTime.hour);

            SetTimer(hWnd, TIMER_ID, OPEN_TLEN, 0L);

            ClockSize( np,
                       ((LPCREATESTRUCT)lParam)->cx,
                       ((LPCREATESTRUCT)lParam)->cy );
            break;
        }
        case ( WM_SIZE ) :
        {
            if (np)
            {
                ClockSize(np, LOWORD(lParam), HIWORD(lParam));
            }
            break;
        }
        case ( WM_PAINT ) :
        {
            PAINTSTRUCT ps;

            BeginPaint(hWnd, &ps);
            GetTimeClock(&(np->nTime), np);
            ClockPaint(np, ps.hdc, REPAINT);
            EndPaint(hWnd, &ps);

            break;
        }
        case ( WM_TIMECHANGE ) :
        {
            //
            //  I'm not top level - so I wont get this message.
            //
            InvalidateRect(hWnd, NULL, TRUE);
            if (np->hwndGetTime)
            {
                SYSTEMTIME System;

                GetTime();
                System.wHour = wDateTime[HOUR];
                System.wMinute = wDateTime[MINUTE];
                System.wSecond = wDateTime[SECOND];
                SendMessage( np->hwndGetTime,
                             CLM_UPDATETIME,
                             CLF_SETTIME,
                             (LPARAM)(LPSYSTEMTIME)&System );
            }

            // fall thru...
        }
        case ( WM_TIMER ) :
        {
            ClockTimer(hWnd, wParam, np);
            break;
        }
        case ( WM_SYSCOLORCHANGE ) :
        {
            DeleteTools(np);
            CreateTools(np);
            break;
        }
        case ( CLM_UPDATETIME ) :
        {
            //
            //  Force the clock to repaint. lParam will point to a
            //  SYSTEMTIME struct.
            //
            switch (wParam)
            {
                case ( CLF_SETTIME ) :
                {
                    //
                    //  Caller wants us to reflect a new time.
                    //
                    HDC hDC;
                    LPSYSTEMTIME lpSysTime = (LPSYSTEMTIME)lParam;

                    np->nTime.hour   = lpSysTime->wHour;
                    np->nTime.minute = lpSysTime->wMinute;
                    np->nTime.second = lpSysTime->wSecond;

                    hDC = GetDC(hWnd);
                    ClockPaint(np, hDC, HANDPAINT);
                    ReleaseDC(hWnd, hDC);
                    break;
                }
                case ( CLF_GETTIME ) :
                {
                    //
                    //  Caller wants to know what we think the time is.
                    //
                    LPSYSTEMTIME lpSysTime = (LPSYSTEMTIME)lParam;

                    lpSysTime->wHour = (WORD)np->nTime.hour;
                    lpSysTime->wMinute = (WORD)np->nTime.minute;
                    lpSysTime->wSecond = (WORD)np->nTime.second;
                    break;
                }
            }
            break;
        }
        case ( CLM_TIMEHWND ) :
        {
            //
            //  Get/Set the HWND that we ask to provide the time.
            //
            switch (wParam)
            {
                case ( CLF_SETHWND ) :
                {
                    //
                    //  Caller wants us to reflect a new time.
                    //
                    np->hwndGetTime = (HWND)lParam;
                    break;
                }
                case ( CLF_GETTIME ) :
                {
                    //
                    //  Caller wants to know what we think the time is.
                    //
                    *((HWND *)lParam) = np->hwndGetTime;
                    break;
                }
            }
            break;
        }
        default :
        {
            return ( DefWindowProc(hWnd, message, wParam, lParam) );
        }
    }

    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\utc\clock.h ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    clock.h

Abstract:

    This module contains the information for the clock in the Date/Time
    applet.

Revision History:

--*/



//
//  Messages.
//

//
//  CLM_UPDATETIME
//
//  wParam: CLF_GETTIME or CLF_SETTIME (senders perspective)
//  lParam: pointer to LPSYSTEMTIME called to force reflection of new time
//  return: not used
//
#define CLF_GETTIME          0
#define CLF_SETTIME          1
#define CLM_UPDATETIME       (WM_USER + 102)


//
//  CLM_TIMEHWND
//
//  wParam: CLF_GETPROVIDERHWND or CLF_SETPROVIDERHWND
//  lParam: HWND of timer window
//  return: not used
//
#define CLF_GETHWND          0
#define CLF_SETHWND          1
#define CLM_TIMEHWND         (WM_USER + 103)




//
//  Function Prototypes.
//

BOOL
ClockInit(
    HINSTANCE hInstance);

BOOL
CalendarInit(
    HINSTANCE hInstance);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\utc\date.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    date.c

Abstract:

    This module implements the textual representations of
    Day Month Year : Hours Min Seconds for the Date/Time applet.

Revision History:

--*/



//
//  Include Files.
//

#include "timedate.h"
#include <commctrl.h>
#include <prsht.h>
#include <regstr.h>
#include <imm.h>
#include "clock.h"
#include "mapctl.h"
#include "inettime.h"
#include "rc.h"
#include <help.h>
#include <shlwapi.h>
#include <windows.h>
#include <windowsx.h>




//
//  Constant Declarations.
//

#define TZNAME_SIZE          128
#define TZDISPLAYZ           128

#define BIAS_ONE_HOUR        (-60L)

#define ZONE_IMAGE_SCALE     (356)
#define ZONE_BIAS_SCALE      (-1440)
#define ZONE_IMAGE_LEFT      (120)
#define ZONE_IMAGE_WIDTH     (80)

#define BIAS_PLUS_12         (12L * BIAS_ONE_HOUR)
#define BIAS_MINUS_12        (- BIAS_PLUS_12)

#define TZ_HIT_NONE          (0)
#define TZ_HIT_BASE          (1)
#define TZ_HIT_PARTIAL       (2)
#define TZ_HIT_EXACT         (3)




//
//  Global Variables.
//

TCHAR const szIntl[] = TEXT("intl");

//
//  Default used if none could be found.
//
INTLSTRUCT IntlDef =
{
    TEXT("Other Country"),
    1, 0, 0, 0, 0, 2, 0, 1, 2, 1,
    TEXT("AM"),
    TEXT("PM"),
    TEXT("$"),
    TEXT(","),
    TEXT("."),
    TEXT("/"),
    TEXT(":"),
    TEXT(","),
    TEXT("dddd, MMMM dd, yyyy"),
    TEXT("M/d/yyyy"),
    TEXT("USA"),
    1, 0, 1, 0, 0x0409,
    TEXT("hh:mm:ss tt"),
    0, 1,
    TEXT(","),
    TEXT(".")
};

BOOL g_bFirstBoot = FALSE;   // for first boot during setup

int g_Time[3];               // time the user currently has set
int g_LastTime[3];           // last displayed time - to stop flicker

short wDateTime[7];                 // values for first 7 date/time items
short wPrevDateTime[7];             // only repaint fields if necessary
BOOL  fDateDirty;

//
//  Formatting strings for AM and PM
//
TCHAR sz1159[12];
TCHAR sz2359[12];

//
//  Are we in 24 hour time.  If not, is it AM or PM.
//
BOOL g_b24HR;
BOOL g_bPM;

//
//  This flag indicates if the user has tried to change the time.
//  If so, then we stop providing the system time and use the
//  time that we store internally. We send the clock control our
//  TimeProvider function.
//
WORD g_Modified = 0;
WORD g_WasModified = 0;

//
//  Which of the HMS MDY have leading zeros.
//
BOOL g_bLZero[6] = {FALSE, TRUE, TRUE, FALSE, FALSE, FALSE};

//
//  Ranges of HMS MDY
//
struct
{
    int nMax;
    int nMin;
} g_sDateInfo[] =
{
    23, 0,
    59, 0,
    59, 0,
    12, 1,
    31, 1,
    2099, 1980,
};

//
//  Time Zone info globals.
//
int g_nTimeZones = 0;
TIME_ZONE_INFORMATION g_tziCurrent, *g_ptziCurrent = NULL;

//
//  Registry location for Time Zone information.
//
#ifdef WINNT
  TCHAR c_szTimeZones[] = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones");
#else
  TCHAR c_szTimeZones[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Time Zones");
#endif

//
//  Time Zone data value keys.
//
TCHAR c_szTZDisplayName[]  = TEXT("Display");
TCHAR c_szTZStandardName[] = TEXT("Std");
TCHAR c_szTZDaylightName[] = TEXT("Dlt");
TCHAR c_szTZI[]            = TEXT("TZI");
TCHAR c_szTZMapInfo[]      = TEXT("MapID");

//
//  IME globals.
//
HIMC g_PrevIMCForDateField;




//
//  Context Help Ids.
//

const DWORD aDateTimeHelpIds[] =
{
    IDD_GROUPBOX1,      IDH_DATETIME_DATE_GROUP,
    IDD_GROUPBOX2,      IDH_DATETIME_TIME,
    DATETIME_CURTZ,     IDH_DATETIME_CURRENT_TIME_ZONE,
    DATETIME_CALENDAR,  IDH_DATETIME_DATE,
    DATETIME_CLOCK,     IDH_DATETIME_TIME,
    DATETIME_TBORDER,   IDH_DATETIME_TIME,
    DATETIME_HOUR,      IDH_DATETIME_TIME,
    DATETIME_TSEP1,     IDH_DATETIME_TIME,
    DATETIME_MINUTE,    IDH_DATETIME_TIME,
    DATETIME_TSEP2,     IDH_DATETIME_TIME,
    DATETIME_SECOND,    IDH_DATETIME_TIME,
    DATETIME_AMPM,      IDH_DATETIME_TIME,
    DATETIME_TARROW,    IDH_DATETIME_TIME,
    DATETIME_MONTHNAME, IDH_DATETIME_MONTH,
    DATETIME_YEAR,      IDH_DATETIME_YEAR,
    DATETIME_YARROW,    IDH_DATETIME_YEAR,
    IDD_TIMEZONES,      IDH_DATETIME_TIMEZONE,
//  IDD_TIMEMAP,        IDH_DATETIME_BITMAP,
    IDD_TIMEMAP,        NO_HELP,
    IDD_AUTOMAGIC,      IDH_DATETIME_DAYLIGHT_SAVE,

    0, 0
};




//
//  Typedef Declarations.
//

//
//  Registry info goes in this structure.
//
typedef struct tagTZINFO
{
    struct tagTZINFO *next;
    TCHAR            szDisplayName[TZDISPLAYZ];
    TCHAR            szStandardName[TZNAME_SIZE];
    TCHAR            szDaylightName[TZNAME_SIZE];
    int              ComboIndex;
    int              SeaIndex;
    int              LandIndex;
    int              MapLeft;
    int              MapWidth;
    LONG             Bias;
    LONG             StandardBias;
    LONG             DaylightBias;
    SYSTEMTIME       StandardDate;
    SYSTEMTIME       DaylightDate;

} TZINFO, *PTZINFO;

//
//  State info for the time zone page.
//
typedef struct
{
    PTZINFO zone;
    BOOL initializing;
    PTZINFO lookup[MAPCTL_MAX_INDICES];

} TZPAGE_STATE;



DWORD GetTextExtent(
    HDC hdc,
    LPCTSTR lpsz,
    int cb);


#ifndef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  WideStrToStr
//
////////////////////////////////////////////////////////////////////////////

int WINAPI WideStrToStr(
    LPSTR psz,
    LPWSTR pwsz)
{
    return WideCharToMultiByte(CP_ACP, 0, pwsz, -1, psz, MAX_PATH, NULL, NULL);
}


////////////////////////////////////////////////////////////////////////////
//
//  StrToWideStr
//
////////////////////////////////////////////////////////////////////////////

int WINAPI StrToWideStr(
    LPWSTR pwsz,
    LPCSTR psz)
{
    return MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, MAX_PATH);
}


////////////////////////////////////////////////////////////////////////////
//
//  AnsiWideStrCmpI
//
////////////////////////////////////////////////////////////////////////////

int AnsiWideStrCmpI(
    LPCSTR pszAnsi,
    WCHAR *pwszWide)
{
    char szAnsi[64];

    WideStrToStr(szAnsi, pwszWide);
    return (lstrcmpi(pszAnsi, szAnsi));
}

#endif



////////////////////////////////////////////////////////////////////////////
//
//  ParseDateElement
//
//  Assumes that the character pointed to by pszElement is a
//  'M', 'd', or 'y', and checks if the string indicates a leading zero
//  or century.  The return value is a pointer to the next character,
//  which should be a separator or NULL.  A return value of NULL indicates
//  an error.
//
////////////////////////////////////////////////////////////////////////////

LPTSTR ParseDateElement(
    LPTSTR pszElement,
    BOOL *pbLZero)
{
    //
    //  Check for valid character.
    //
    switch (*pszElement)
    {
        case ( TEXT('y') ) :
        case ( TEXT('M') ) :
        case ( TEXT('d') ) :
        {
            break;
        }
        default:
        {
            return (NULL);
        }
    }

    ++pszElement;

    if (*pszElement != *(pszElement - 1))
    {
        *pbLZero = 0;
    }
    else
    {
        *pbLZero = 1;

        if (*pszElement++ == TEXT('y'))
        {
            if (!(*pszElement == TEXT('y')))
            {
                *pbLZero = 0;
            }
            else
            {
                if (!(*++pszElement == TEXT('y')))
                {
                    //
                    //  Found 3 y's, invalid format.
                    //
                    return (NULL);
                }
                else
                {
                    ++pszElement;
                }
            }
        }
    }

    return (pszElement);
}


int rgMoveTimeControls [] = 
{
    DATETIME_HOUR,
    DATETIME_MINUTE,
    DATETIME_SECOND,
    DATETIME_TSEP1,
    DATETIME_TSEP2
};


////////////////////////////////////////////////////////////////////////////
//
//  AdjustAMPMPosition
//
////////////////////////////////////////////////////////////////////////////
void AdjustAMPMPosition(HWND hwnd)
{
   TCHAR    szTimePrefix[5];
   static BOOL fMoved = FALSE;

   GetLocaleInfo(LOCALE_USER_DEFAULT, 
                 LOCALE_ITIMEMARKPOSN,
                 szTimePrefix,
                 ARRAYSIZE(szTimePrefix));

   if (!fMoved && szTimePrefix[0] == TEXT('1'))
   {
        RECT rLeftCtl, rAMPMCtl, rCurrCtl;
        HWND hwndAMPM, hwndCurr;
        int i, width;
        POINT pt;

        fMoved = TRUE;
        
        //Get rect of left most control (hours)
        GetWindowRect(GetDlgItem(hwnd, DATETIME_HOUR), &rLeftCtl);
        
        //Get rect of AM PM control
        hwndAMPM = GetDlgItem(hwnd, DATETIME_AMPM);
        GetWindowRect(hwndAMPM, &rAMPMCtl);
        width = rAMPMCtl.right - rAMPMCtl.left;
        
        //Shift all controls right by the AM PM control width
        for (i = 0; i < ARRAYSIZE(rgMoveTimeControls); i++)
        {
            hwndCurr = GetDlgItem(hwnd, rgMoveTimeControls[i]);
            GetWindowRect(hwndCurr, &rCurrCtl);
            pt.x = rCurrCtl.left;
            pt.y = rCurrCtl.top;
            ScreenToClient(hwnd, &pt);

            MoveWindow(hwndCurr, pt.x + width, 
                        pt.y,
                        rCurrCtl.right - rCurrCtl.left,
                        rCurrCtl.bottom - rCurrCtl.top,
                        TRUE);
        }
        
        //Move AM PM control left to where the hours were.
        pt.x = rLeftCtl.left;
        pt.y = rAMPMCtl.top;
        ScreenToClient(hwnd, &pt);
        MoveWindow(hwndAMPM, pt.x, 
                    pt.y,
                    rAMPMCtl.right - rAMPMCtl.left,
                    rAMPMCtl.bottom - rAMPMCtl.top,
                    TRUE);
        
   }
}


////////////////////////////////////////////////////////////////////////////
//
//  MonthUpperBound
//
////////////////////////////////////////////////////////////////////////////

int _fastcall MonthUpperBound(
    int nMonth,
    int nYear)
{
    switch (nMonth)
    {
        case ( 2 ) :
        {
            //
            //  A year is a leap year if it is divisible by 4 and is not
            //  a century year (multiple of 100) or if it is divisible by
            //  400.
            //
            return ( ((nYear % 4 == 0) &&
                      ((nYear % 100 != 0) || (nYear % 400 == 0))) ? 29 : 28 );
        }
        case ( 4 ) :
        case ( 6 ) :
        case ( 9 ) :
        case ( 11 ) :
        {
            return (30);
        }
    }

    return (31);
}


////////////////////////////////////////////////////////////////////////////
//
//  IsAMPM
//
//  True if PM.
//
////////////////////////////////////////////////////////////////////////////

BOOL IsAMPM(
    int iHour)
{
    return ((iHour >= 12) ? 1 : 0);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetDateTime
//
////////////////////////////////////////////////////////////////////////////

void GetDateTime()
{
    SYSTEMTIME SystemTime;

    GetLocalTime(&SystemTime);

    wDateTime[HOUR]    = SystemTime.wHour;
    wDateTime[MINUTE]  = SystemTime.wMinute;
    wDateTime[SECOND]  = SystemTime.wSecond;
    wDateTime[MONTH]   = SystemTime.wMonth;
    wDateTime[DAY]     = SystemTime.wDay;
    wDateTime[YEAR]    = SystemTime.wYear;
    wDateTime[WEEKDAY] = SystemTime.wDayOfWeek;
}


////////////////////////////////////////////////////////////////////////////
//
//  GetTime
//
////////////////////////////////////////////////////////////////////////////

void GetTime()
{
    SYSTEMTIME SystemTime;

    GetLocalTime(&SystemTime);

    wDateTime[HOUR]   = SystemTime.wHour;
    wDateTime[MINUTE] = SystemTime.wMinute;
    wDateTime[SECOND] = SystemTime.wSecond;
}


////////////////////////////////////////////////////////////////////////////
//
//  GetDate
//
////////////////////////////////////////////////////////////////////////////

void GetDate()
{
    SYSTEMTIME SystemTime;

    GetLocalTime(&SystemTime);

    wDateTime[MONTH]   = SystemTime.wMonth;
    wDateTime[DAY]     = SystemTime.wDay;
    wDateTime[YEAR]    = SystemTime.wYear;
    wDateTime[WEEKDAY] = SystemTime.wDayOfWeek;
    fDateDirty = FALSE;
}


////////////////////////////////////////////////////////////////////////////
//
//  SetTime
//
////////////////////////////////////////////////////////////////////////////

void SetTime()
{
    SYSTEMTIME SystemTime;

    SystemTime.wHour   = wDateTime[HOUR];
    SystemTime.wMinute = wDateTime[MINUTE];
    SystemTime.wSecond = wDateTime[SECOND];

    SystemTime.wMilliseconds = 0;

    SystemTime.wMonth  = wDateTime[MONTH];
    SystemTime.wDay    = wDateTime[DAY];
    SystemTime.wYear   = wDateTime[YEAR];

    SetLocalTime(&SystemTime);
    SetLocalTime(&SystemTime);
    fDateDirty = FALSE;
}


////////////////////////////////////////////////////////////////////////////
//
//  SetDate
//
////////////////////////////////////////////////////////////////////////////

void SetDate()
{
    SYSTEMTIME SystemTime;

    SystemTime.wHour   = wDateTime[HOUR];
    SystemTime.wMinute = wDateTime[MINUTE];
    SystemTime.wSecond = wDateTime[SECOND];

    SystemTime.wMilliseconds = 0;

    SystemTime.wMonth  = wDateTime[MONTH];
    SystemTime.wDay    = wDateTime[DAY];
    SystemTime.wYear   = wDateTime[YEAR];

    SetLocalTime(&SystemTime);
    SetLocalTime(&SystemTime);
    fDateDirty = FALSE;
}


////////////////////////////////////////////////////////////////////////////
//
//  AdjustDelta
//
//  Alters the variables in wDeltaDateTime, allowing a CANCEL button
//  to perform its job by resetting the time as if it had never been
//  touched.  GetTime() & GetDate() should already have been called.
//
////////////////////////////////////////////////////////////////////////////

void AdjustDelta(
    HWND hDlg,
    int nIndex)
{
    int nDelta;

    //
    //  We dont do time this way any more.
    //
    if (nIndex <= SECOND && nIndex >= HOUR)
    {
        return;
    }

    //
    //  Get position of the buddy from either the date or the time.
    //
    nDelta = (int)SendDlgItemMessage( hDlg,
                                      nIndex <= SECOND
                                        ? DATETIME_TARROW
                                        : DATETIME_YARROW,
                                      UDM_GETPOS,
                                      0,
                                      0L );

    if ((nIndex == YEAR) && !g_bLZero[YEAR])
    {
        //
        //  Years before 80 are 2080.
        //  Range is 1980...2079.
        //
        if (nDelta < 80)
        {
            nDelta += 2000;
        }
        else
        {
            nDelta += 1900;
        }
    }

    //
    //  If our current recording of the time/date is not what we have
    //  now, do deltas.
    //
    if (wDateTime[nIndex] != nDelta)
    {
        //
        //  Previous value is current user's settings.
        //
        wPrevDateTime[nIndex] = wDateTime[nIndex] = (WORD)nDelta;
        fDateDirty = TRUE;
        
        //
        // If we are changing HMS, update the time.
        //
        if (nIndex <= SECOND)
        {
            nIndex = 0;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  AdjustDeltaMonth
//
//  Change the month part of wDateTime
//
////////////////////////////////////////////////////////////////////////////

extern int GetDaysOfTheMonth(int iMonth);

void AdjustDeltaMonth(
    int iMonth)
{
    GetTime();

    if (wDateTime[MONTH] != iMonth)
    {
        //
        //  Make sure the current day is valid in the new month.
        //
        if (wDateTime[DAY] > (WORD)GetDaysOfTheMonth(iMonth))
        {
            wDateTime[DAY] = (WORD)GetDaysOfTheMonth(iMonth);
        }

        wPrevDateTime[MONTH] = wDateTime[MONTH] = (WORD)iMonth;
        fDateDirty = TRUE;

        g_sDateInfo[DAY].nMax = MonthUpperBound( wDateTime[MONTH],
                                                 wDateTime[YEAR] );
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  ReadShortDate
//
//  Verify that pszDate is one of MDY, DMY, or YMD.
//
////////////////////////////////////////////////////////////////////////////

int ReadShortDate(
    LPTSTR pszDate,
    BOOL *pbMonth,
    BOOL *pbDay,
    BOOL *pbYear)
{
    int i, nOrder;
    BOOL *pbOrder[3];
    TCHAR cHope[3];

    //
    //  nOrder :  0 = MDY
    //            1 = DMY
    //            2 = YMD
    //
    switch (cHope[0] = *pszDate)
    {
        case ( TEXT('M') ) :
        {
            nOrder = 0;
            pbOrder[0] = pbMonth;
            break;
        }
        case ( TEXT('d') ) :
        {
            nOrder = 1;
            pbOrder[0] = pbDay;
            break;
        }
        case ( TEXT('y') ) :
        {
            nOrder = 2;
            pbOrder[0] = pbYear;
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    //
    //  Sets element 1.
    //
    if (nOrder)         // 1 2
    {
        cHope[1] = TEXT('M');
        pbOrder[1] = pbMonth;
    }
    else                // 0
    {
        cHope[1] = TEXT('d');
        pbOrder[1] = pbDay;
    }

    //
    //  Sets element 2.
    //
    if (nOrder == 2)    // 2
    {
        cHope[2] = TEXT('d');
        pbOrder[2] = pbDay;
    }
    else                // 0 1
    {
        cHope[2] = TEXT('y');
        pbOrder[2] = pbYear;
    }

    //
    //  Verifies that pszDate is of the form MDY DMY YMD.
    //
    for (i = 0; i < 3; i++, pszDate++)
    {
        if (*pszDate != cHope[i])
        {
            return (-1 - nOrder);
        }

        if (!(pszDate = ParseDateElement(pszDate, pbOrder[i])))
        {
            return (-1 - nOrder);
        }
    }

    //
    //  Success.  Return MDY, DMY or YMD index.
    //
    return (nOrder);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetMaxCharWidth
//
//  Determine the widest digit (safety against variable pitch fonts).
//
////////////////////////////////////////////////////////////////////////////

int GetMaxCharWidth(
    HDC hDC)
{
    UINT nNumWidth[10];
    UINT i, nMaxNumWidth;

    GetCharWidth32(hDC, TEXT('0'), TEXT('9'), nNumWidth);

    for (nMaxNumWidth = 0, i = 0; i < 10; i++)
    {
        if (nNumWidth[i] > nMaxNumWidth)
        {
            nMaxNumWidth = nNumWidth[i];
        }
    }

    return (nMaxNumWidth);
}
////////////////////////////////////////////////////////////////////////////
//
//  GetMaxSubstitutedCharWidth
//
//  Determine the widest digit (safety against variable pitch fonts), but
//  do it using strings so that if number substitution is on, we will get
//  the width of the number based on what will actually be displayed
//
////////////////////////////////////////////////////////////////////////////

int GetMaxSubstitutedCharWidth(
    HDC hDC)
{
    char sz[2] = "0";
    TCHAR szAMPM[12];
    LONG i, nMaxNumWidth;
    DWORD dwWidth;
    SIZE size;
    
    for (nMaxNumWidth = 0, i = 0; i < 10; (*sz)++, i++)
    {
        if (GetTextExtentPoint32A(hDC, sz, 1, &size) && size.cx > nMaxNumWidth)
            nMaxNumWidth = size.cx;
        
    }

    if (nMaxNumWidth <= 8)
    {
        GetProfileString(szIntl, TEXT("s1159"), IntlDef.s1159, szAMPM, ARRAYSIZE(szAMPM));
        dwWidth = LOWORD(GetTextExtent(hDC, szAMPM, lstrlen(szAMPM)));
        if (dwWidth > 22)
            nMaxNumWidth = 10;
        GetProfileString(szIntl, TEXT("s2359"), IntlDef.s2359, szAMPM, ARRAYSIZE(szAMPM));
        dwWidth = LOWORD(GetTextExtent(hDC, szAMPM, lstrlen(szAMPM)));
        if (dwWidth > 22)
            nMaxNumWidth = 10;
    }
    return (nMaxNumWidth);
}


////////////////////////////////////////////////////////////////////////////
//
//  ReflectAMPM
//
//  Sets the global g_bPM and updates the control to display AM or PM.
//
////////////////////////////////////////////////////////////////////////////

void ReflectAMPM(
    HWND hDlg,
    int nNum)
{
    HWND hCtl = GetDlgItem(hDlg, DATETIME_AMPM);

    ListBox_SetTopIndex(hCtl, g_bPM);
    ListBox_SetCurSel(hCtl, (GetFocus() == hCtl) ? g_bPM : -1);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetTextExtent
//
////////////////////////////////////////////////////////////////////////////

#ifdef WIN32
DWORD GetTextExtent(
    HDC hdc,
    LPCTSTR lpsz,
    int cb)
{
    SIZE sz;
    BOOL bSuccess = GetTextExtentPoint(hdc, lpsz, cb, &sz);
    
    if ( !bSuccess )
    {
        ZeroMemory( &sz, sizeof(sz) );
    }

    return ( MAKELONG((WORD)sz.cx, (WORD)sz.cy) );
}
#endif


////////////////////////////////////////////////////////////////////////////
//
//  DateTimeInit
//
//  Determine the widest digit (safety against variable pitch fonts).
//
////////////////////////////////////////////////////////////////////////////

void DateTimeInit(
    HWND hDlg,
    WORD nBaseID,
    WORD nSepID,
    LPTSTR pszSep,
    int nMaxDigitWidth,
    BOOL bDate)
{
    HWND hAMPMList;
    HWND hDay, hMonth, hYear;     // also used as hHour, hMinute, & hSecond
    HWND hOrder[5];
    HDC hDC;
    int nWidth, nHeight, X;
    DWORD dwSepExt;
    RECT Rect;
    int i;
    int nAMPMlength;

    hMonth    = GetDlgItem(hDlg, nBaseID);
    hDay      = GetDlgItem(hDlg, nBaseID + 1);
    hYear     = GetDlgItem(hDlg, nBaseID + 2);
    hOrder[1] = GetDlgItem(hDlg, nSepID);
    hOrder[3] = GetDlgItem(hDlg, nSepID + 1);

    if (bDate)
    {
        i = GetProfileInt(szIntl, TEXT("iDate"), 0);
    }
    else
    {
        if (g_b24HR = (BOOL)GetProfileInt(szIntl, TEXT("iTime"), 0))
        {
            g_sDateInfo[HOUR].nMin = 0;
            g_sDateInfo[HOUR].nMax = 23;
        }
        else
        {
            g_sDateInfo[HOUR].nMin = 1;
            g_sDateInfo[HOUR].nMax = 12;

            GetProfileString(szIntl, TEXT("s1159"), IntlDef.s1159, sz1159, ARRAYSIZE(sz1159));
            GetProfileString(szIntl, TEXT("s2359"), IntlDef.s2359, sz2359, ARRAYSIZE(sz2359));
        }
        i = 0;
    }

    switch (i)
    {
        case ( 1 ) :
        {
            hOrder[0] = hDay;
            hOrder[2] = hMonth;
            hOrder[4] = hYear;
            break;
        }
        case ( 2 ) :
        {
            hOrder[0] = hYear;
            hOrder[2] = hMonth;
            hOrder[4] = hDay;
            break;
        }
        case ( 0 ) :
        default :
        {
            hOrder[0] = hMonth;
            hOrder[2] = hDay;
            hOrder[4] = hYear;
            break;
        }
    }

    hDC = GetDC(hDlg);

    if (!bDate)
    {
        dwSepExt = GetTextExtent(hDC, sz1159, lstrlen(sz1159));
        nAMPMlength = LOWORD(GetTextExtent(hDC, sz2359, lstrlen(sz2359)));
        if (nAMPMlength < (int)LOWORD(dwSepExt))
        {
            nAMPMlength = (int)LOWORD(dwSepExt);
        }
    }

    dwSepExt = GetTextExtent(hDC, pszSep, lstrlen(pszSep));
    ReleaseDC(hDlg, hDC);

    GetWindowRect(hYear, (LPRECT)&Rect);
    ScreenToClient(hDlg, (LPPOINT)&Rect.left);
    ScreenToClient(hDlg, (LPPOINT)&Rect.right);

    nHeight = Rect.bottom - Rect.top;
    nWidth = Rect.top;

    GetWindowRect( GetDlgItem( hDlg,
                               bDate ? DATETIME_CALENDAR : DATETIME_CLOCK ),
                   (LPRECT)&Rect );
    ScreenToClient(hDlg, (LPPOINT)&Rect.left);
    ScreenToClient(hDlg, (LPPOINT)&Rect.right);

    Rect.top = nWidth;
    X = (Rect.left + Rect.right - (6 * nMaxDigitWidth) - (2 * LOWORD(dwSepExt))) / 2;

    if (bDate)
    {
        if (g_bLZero[YEAR])
        {
            X -= nMaxDigitWidth;
        }
    }
    else if (!g_b24HR)
    {
        X -= nAMPMlength / 2;
    }

    for (i = 0; i < 5; i++)
    {
        nWidth = (i % 2) ? LOWORD(dwSepExt) : 2 * nMaxDigitWidth;

        if ((hOrder[i] == hYear) && bDate && g_bLZero[YEAR])
        {
            nWidth *= 2;
        }

        //
        //  Allow for centering in edit control.
        //
        nWidth += 2;

    //  MoveWindow(hOrder[i], X, Rect.top, nWidth, nHeight, FALSE);
        X += nWidth;
    }

    hAMPMList = GetDlgItem(hDlg, DATETIME_AMPM);
    ListBox_ResetContent(hAMPMList);

    if (!bDate && !g_b24HR)
    {
        ListBox_InsertString(hAMPMList, 0, sz1159);
        ListBox_InsertString(hAMPMList, 1, sz2359);
    }

    EnableWindow(hAMPMList, !g_b24HR);

    Edit_LimitText(hYear, (bDate && g_bLZero[YEAR]) ? 4 : 2);
    Edit_LimitText(hMonth, 2);
    Edit_LimitText(hDay, 2);

    SetDlgItemText(hDlg, nSepID, pszSep);
    SetDlgItemText(hDlg, nSepID + 1, pszSep);
}


////////////////////////////////////////////////////////////////////////////
//
//  myitoa
//
////////////////////////////////////////////////////////////////////////////

void myitoa(
    int intValue,
    LPTSTR lpStr)
{
    LPTSTR lpString;
    TCHAR c;

    //
    //  lpString points to 1st char.
    //
    lpString = lpStr;

    do
    {
        *lpStr++ = (TCHAR)(intValue % 10 + TEXT('0'));
    } while ((intValue /= 10) > 0);

    //
    //  lpStr points to last char.
    //
    *lpStr-- = TEXT('\0');

    //
    //  Now reverse the string.
    //
    while (lpString < lpStr)
    {
      c = *lpString;
      *(lpString++) = *lpStr;
      *(lpStr--) = c;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  UpdateItem
//
//  This displays the information in the control from the array
//  of global values. Also selects the control. Also adds leading 0's
//  as well as rounding years to 2 digits and 24 or AM/PM hours.
//
////////////////////////////////////////////////////////////////////////////

void UpdateItem(
    HWND hDlg,
    int i)
{
    TCHAR szNum[5];
    int nNum = g_Modified ? wPrevDateTime[i] : wDateTime[i];

    //
    //  Use internal time.
    //
    if (i <= SECOND && i >= HOUR)
    {
        nNum = g_Time[i];

        //
        //  Do not paint un-necessarily.
        //
        if ((nNum == g_LastTime[i]) && (nNum >= 10))
        {
            return;
        }

        g_LastTime[i] = nNum;

        if (i == HOUR)
        {
            if (IsAMPM(nNum))
            {
                g_bPM = TRUE;
            }
            ReflectAMPM(hDlg, nNum);
        }
    }

    if (i == YEAR)
    {
        //
        //  Round the years to last 2 digits.
        //
        if (!g_bLZero[i])
        {
            nNum %= 100;
        }
    }
    else if ((i == HOUR) && !g_b24HR)
    {
        //
        //  nNum came from our internal date time.
        //  Remove 12 hours if not 24hour.
        //
        if (g_bPM)
        {
            nNum %= 12;
        }

        //
        //  00 hours is actually 12AM.
        //
        if (!nNum)
        {
            nNum = 12;
        }
    }

    //
    //  See if we need leading zeros.
    //  We only deal with 2 character numbers MAX.
    //
    if ((nNum < 10) && (g_bLZero[i] || (i == YEAR)))
    {
        szNum[0] = TEXT('0');
        szNum[1] = (TCHAR)(TEXT('0') + nNum);
        szNum[2] = TEXT('\0');
    }
    else
    {
        myitoa(nNum, szNum);
    }

    //
    //  Reflect the value in the appropriate control.
    //
    SetDlgItemText(hDlg, DATETIME_HOUR + i, szNum);

    //
    //  Select the field too.
    //
    SendDlgItemMessage(hDlg, DATETIME_HOUR + i, EM_SETSEL, 0, MAKELONG(0, 32767));

    //
    //  If we changed year or month, then we may have altered the leap year
    //  state.
    //
    if (i == MONTH || i == YEAR)
    {
        g_sDateInfo[DAY].nMax = MonthUpperBound( wDateTime[MONTH],
                                                 wDateTime[YEAR] );
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  _ShowTZ
//
////////////////////////////////////////////////////////////////////////////

TCHAR c_szFirstBootTZ[] = TEXT("!!!First Boot!!!");

void _ShowTZ(
    HWND hDlg)
{
    HWND ctl = GetDlgItem(hDlg, DATETIME_CURTZ);
    TIME_ZONE_INFORMATION info;
    TCHAR final[64 + TZNAME_SIZE];
    TCHAR name[TZNAME_SIZE];
    DWORD TimeZoneId;

    if (g_bFirstBoot)
    {
        ShowWindow(ctl, SW_HIDE);
    }
    else
    {
        TimeZoneId = GetTimeZoneInformation(&info);
#ifdef UNICODE
        lstrcpy( name,
                 (TimeZoneId == TIME_ZONE_ID_STANDARD)
                   ? info.StandardName
                   : info.DaylightName );
#else
        WideStrToStr(name,  (TimeZoneId == TIME_ZONE_ID_STANDARD)
                   ? info.StandardName
                   : info.DaylightName );
#endif //UNICODE

        //
        //  Display nothing if it is our special 1st boot marker.
        //
        if (*name && (lstrcmpi(name, c_szFirstBootTZ) != 0))
        {
            static TCHAR format[128] = TEXT("");

            if (!*format)
            {
                GetWindowText( ctl,
                               format,
                               ARRAYSIZE(format) );
            }
            wsprintf(final, format, name);
        }
        else
        {
            *final = 0;
        }

        SetWindowText(ctl, final);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  UnhookTime
//
//  To stop the clock calling us back all the time (around exit).
//
////////////////////////////////////////////////////////////////////////////

void UnhookTimer(
    HWND hDlg)
{
    SendDlgItemMessage(hDlg, DATETIME_CLOCK, CLM_TIMEHWND, CLF_SETHWND, 0);
}


////////////////////////////////////////////////////////////////////////////
//
//  TimeProvider
//
//  Called by the clock to find out what time it is.
//
////////////////////////////////////////////////////////////////////////////

void TimeProvider(
    LPSYSTEMTIME lpSystemTime,
    HWND hDlg)
{
    short wTemp[7];

    //
    //  If the user has modified the time, the clock should
    //  display the edit controls, otherwise its just the SystemTime.
    //
    if (g_Modified)
    {
        lpSystemTime->wHour   = (WORD)g_Time[HOUR];
        lpSystemTime->wMinute = (WORD)g_Time[MINUTE];
        lpSystemTime->wSecond = (WORD)g_Time[SECOND];
    }
    else
    {
#ifdef WIN32
        GetLocalTime(lpSystemTime);
#else
        GetTime();
        if (wDateTime[HOUR] >= 0 && wDateTime[HOUR] <= 24)
        {
            lpSystemTime->wHour = wDateTime[HOUR];
        }
        lpSystemTime->wMinute = wDateTime[MINUTE];
        lpSystemTime->wSecond = wDateTime[SECOND];

#endif
        //
        //  Copy the time and display it for us too.
        //
        g_bPM = IsAMPM(lpSystemTime->wHour);
        g_Time[HOUR]   = lpSystemTime->wHour;
        g_Time[MINUTE] = lpSystemTime->wMinute;
        g_Time[SECOND] = lpSystemTime->wSecond;

        //
        //  Check for date rollover.
        //
        if (!fDateDirty)
        {
            wTemp[DAY]   = wDateTime[DAY];
            wTemp[MONTH] = wDateTime[MONTH];
            wTemp[YEAR]  = wDateTime[YEAR];

            GetDate();

            if ((wDateTime[DAY]   != wTemp[DAY])   ||
                (wDateTime[MONTH] != wTemp[MONTH]) ||
                (wDateTime[YEAR]  != wTemp[YEAR]))
            {
                InvalidateRect(GetDlgItem(hDlg, DATETIME_CALENDAR), NULL, TRUE);

                if (wDateTime[MONTH] != wTemp[MONTH])
                {
                    ComboBox_SetCurSel( GetDlgItem(hDlg, DATETIME_MONTHNAME),
                                        wDateTime[MONTH] - 1 );
                }

                if (wDateTime[YEAR] != wTemp[YEAR])
                {
                    UpdateItem(hDlg, YEAR);
                }

                _ShowTZ(hDlg);
            }
        }
        
        UpdateItem(hDlg, HOUR);
        UpdateItem(hDlg, MINUTE);
        UpdateItem(hDlg, SECOND);
        ReflectAMPM(hDlg, g_Time[HOUR]);
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  bSupportedCalendar
//
//  Returns True if the current calendar is not Hijri nor Hebrew
//
//  Otherwise it returns FALSE.
//
////////////////////////////////////////////////////////////////////////////

BOOL bSupportedCalendar()
{
    TCHAR tchCalendar[32];
    CALTYPE defCalendar = CAL_GREGORIAN;

    if (GetLocaleInfo(LOCALE_USER_DEFAULT,
                      LOCALE_ICALENDARTYPE,
                      tchCalendar,
                      ARRAYSIZE(tchCalendar)))
    {
        defCalendar = StrToInt(tchCalendar);
    }

    return (!(defCalendar == CAL_HIJRI || defCalendar == CAL_HEBREW));
}

////////////////////////////////////////////////////////////////////////////
//
//  InitDateTimeDlg
//
//  Called to init the dialog.
//
////////////////////////////////////////////////////////////////////////////

void InitDateTimeDlg(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    int nMaxDigitWidth;
    int i;
    TCHAR szNum[5];
    TCHAR szMonth[64];
    TCHAR szShortDate[12];
    HDC hDC;
    HFONT hFont;
    HWND hwndCB;
    CALID calId;
    static int nInc[] = { 1, 5, 5, 1, 1, 5 };

    HWND hwndScroll;
    UDACCEL udAccel[2];
    HWND hwndTBorder;

    HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

    LCID lcid = LOCALE_USER_DEFAULT;

    InitCommonControls();

    //
    //  Sets the Leading zero status of the 6 controls.
    //
    g_bLZero[HOUR]   = g_bLZero[MONTH]  = g_bLZero[DAY]  = FALSE;
    g_bLZero[MINUTE] = g_bLZero[SECOND] = g_bLZero[YEAR] = TRUE;

    hDC = GetDC(hDlg);

    if (hFont = (HFONT)SendMessage(hDlg, WM_GETFONT, 0, 0L))
    {
        hFont = SelectObject( hDC, hFont );
    }

    if (hFont)
    {
        SelectObject(hDC, hFont);
    }

    AdjustAMPMPosition(hDlg);

    nMaxDigitWidth = GetMaxCharWidth(hDC);
    ReleaseDC(hDlg, hDC);

    g_bLZero[HOUR] = GetProfileInt(szIntl, TEXT("iTLZero"), 0);
    //
    // Initialize szShortDate in case GetProfileString fails.
    //
    lstrcpyn(szShortDate, IntlDef.sShortDate, ARRAYSIZE(szShortDate));
    GetProfileString(szIntl, TEXT("sShortDate"), IntlDef.sShortDate, szShortDate, ARRAYSIZE(szShortDate));
    ReadShortDate(szShortDate, g_bLZero + MONTH, g_bLZero + DAY, g_bLZero + YEAR);

    g_bLZero[YEAR] = TRUE;      //we always want the year to be 4 digits (this will be bad in late 9999)
    
    //
    //  Setup the TIME stuff.
    //
    GetTime();

    g_Time[HOUR]   = wDateTime[HOUR];
    g_Time[MINUTE] = wDateTime[MINUTE];
    g_Time[SECOND] = wDateTime[SECOND];

    GetProfileString(szIntl, TEXT("sTime"), IntlDef.sTime, szNum, 3);
    DateTimeInit(hDlg, DATETIME_HOUR, DATETIME_TSEP1, szNum, nMaxDigitWidth, FALSE);

    //
    //  Force all entries to be re-drawn,
    //
    g_LastTime[HOUR] = g_LastTime[MINUTE] = g_LastTime[SECOND] = -1;
    UpdateItem(hDlg, HOUR);
    UpdateItem(hDlg, MINUTE);
    UpdateItem(hDlg, SECOND);
    ReflectAMPM(hDlg, wDateTime[HOUR]);

    //
    //  Setup the Date stuff.
    //
    GetDate();

    g_sDateInfo[DAY].nMax = MonthUpperBound(wDateTime[MONTH], wDateTime[YEAR]);

    if (!g_bLZero[YEAR])
    {
        wDateTime[YEAR] %= 100;
        g_sDateInfo[YEAR].nMax = 99;
        g_sDateInfo[YEAR].nMin = 0;
    }
    else
    {
        g_sDateInfo[YEAR].nMax = 2099;
        g_sDateInfo[YEAR].nMin = 1980;
    }

    for (i = MONTH; i <= YEAR; i++)
    {
        wPrevDateTime[i] = -1;
    }

    //
    //  Get the month names. And select this month.
    //
    hwndCB = GetDlgItem(hDlg, DATETIME_MONTHNAME);
    ComboBox_ResetContent(hwndCB);
    //
    // If the current calendar is Hijri or Hebrew then use the Gregorian one.
    //
    if (!bSupportedCalendar())
        lcid = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);

    GetLocaleInfo(lcid, LOCALE_ICALENDARTYPE, szMonth, ARRAYSIZE(szMonth));
    calId = (CALID)StrToInt(szMonth);

    for (i = 0; i < 12; i++)
    {
#ifdef WINNT
        GetCalendarInfo(lcid, calId, CAL_SMONTHNAME1 + i, szMonth, ARRAYSIZE(szMonth), NULL);
#else
        GetLocaleInfo( LOCALE_USER_DEFAULT,
                       LOCALE_SMONTHNAME1 + i,
                       szMonth,
                       sizeof(szMonth) );

        if (*szMonth && !IsDBCSLeadByte(*szMonth))
        {
            *szMonth = (TCHAR)CharUpper((LPTSTR)(DWORD)(TBYTE)*szMonth);
        }

#endif
        ComboBox_AddString(hwndCB, szMonth);
    }

    ComboBox_SetCurSel(hwndCB, wDateTime[MONTH] - 1);

    //
    //  Set the default modifier for the Year Updown arrows.
    //
    wParam -= DATETIME_HOUR;
    hwndScroll = GetDlgItem(hDlg, DATETIME_YARROW);
    SendMessage( hwndScroll,
                 UDM_SETRANGE,
                 0,
                 MAKELPARAM(g_sDateInfo[YEAR].nMax, g_sDateInfo[YEAR].nMin) );

    udAccel[0].nSec = 0;
    udAccel[0].nInc = 1;
    udAccel[1].nSec = 2;
    udAccel[1].nInc = nInc[YEAR];

    SendMessage(hwndScroll, UDM_SETACCEL, 2, (LPARAM)(LPUDACCEL)udAccel);
    SendMessage(hwndScroll, UDM_SETBUDDY, (WPARAM)GetDlgItem(hDlg, DATETIME_YEAR), 0L);

    //
    //  Set the default modifier for the time arrows.
    //  It should control the HOURS by default as per joelgros
    //
    hwndScroll = GetDlgItem(hDlg, DATETIME_TARROW);
    SendMessage( hwndScroll,
                 UDM_SETRANGE,
                 0,
                 MAKELPARAM( g_sDateInfo[HOUR].nMax,
                             g_sDateInfo[HOUR].nMin) );
    udAccel[0].nSec = 0;
    udAccel[0].nInc = 1;
    udAccel[1].nSec = 2;
    udAccel[1].nInc = nInc[HOUR];
    
    SendMessage( hwndScroll, UDM_SETACCEL, 2, (LPARAM)(LPUDACCEL)udAccel );
    SendMessage( hwndScroll, UDM_SETBUDDY, (WPARAM)GetDlgItem(hDlg, DATETIME_HOUR), 0L );

    //
    //  Make the 'well' for the digits appear.
    //
    hwndTBorder = GetDlgItem(hDlg, DATETIME_TBORDER);
    SetWindowLong( hwndTBorder,
                   GWL_EXSTYLE,
                   GetWindowLong(hwndTBorder, GWL_EXSTYLE) | WS_EX_CLIENTEDGE );

    //
    //  Display the border right now.
    //
    SetWindowPos( hwndTBorder,
                  NULL,
                  0, 0, 0, 0,
                  SWP_NOMOVE | SWP_NOSIZE | SWP_DRAWFRAME | SWP_SHOWWINDOW );

    //
    //  Display month->year.
    //
    for (i = MONTH; i <= YEAR; i++)
    {
        if ((wDateTime[i] != wPrevDateTime[i]) &&
            (GetFocus() != GetDlgItem(hDlg, DATETIME_HOUR + i)))
        {
            //
            //  Update previous date-time.
            //
            wPrevDateTime[i] = wDateTime[i];

            if (i == YEAR)
            {
                UpdateItem(hDlg, i);
            }
        }
    }

    g_Modified = FALSE;

    //
    //  Tell the clock that we have a time provider - must be done last.
    //
    SendDlgItemMessage( hDlg,
                        DATETIME_CLOCK,
                        CLM_TIMEHWND,
                        CLF_SETHWND,
                        (LPARAM)(LPINT)hDlg );

    SetCursor(oldcursor);
}


////////////////////////////////////////////////////////////////////////////
//
//  CheckNum
//
////////////////////////////////////////////////////////////////////////////

LRESULT CheckNum(
    HWND hDlg,
    UINT nScrollID,
    HWND hCtl)
{
    static int cReenter = 0;

    LRESULT lRet;

    //
    //  If this is an illegal value, (but not blank), then kill the last char
    //  that was entered.
    //
    lRet = SendDlgItemMessage(hDlg, nScrollID, UDM_GETPOS, 0, 0L);

    //
    //  Guard against re-entrance.
    //
    ++cReenter;

    if (cReenter <= 4)
    {
        SendMessage( hCtl,
                     HIWORD(lRet) && GetWindowTextLength(hCtl)
                         ? EM_UNDO
                         : EM_EMPTYUNDOBUFFER,
                     0,
                     0L );
    }

    --cReenter;

    return (lRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  DateTimeDlgProc
//
//  Main dialog proc.
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK DateTimeDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    int i;

    switch (uMsg)
    {
        case (WM_INITDIALOG):
        {
            AddInternetPageAsync(GetParent(hDlg), hDlg);

            InitDateTimeDlg(hDlg, uMsg, wParam, lParam);
            g_PrevIMCForDateField = ImmAssociateContext(GetDlgItem(hDlg, DATETIME_YEAR), 0);
            break;
        }
        case ( WM_DESTROY ) :
        {
            if (g_PrevIMCForDateField)
            {
                ImmAssociateContext( GetDlgItem(hDlg, DATETIME_YEAR),
                                     g_PrevIMCForDateField );
            }
            UnhookTimer(hDlg);
            break;
        }
#ifdef WIN32
        case ( WM_CTLCOLORSTATIC ) :
#endif
        case ( WM_CTLCOLOR ) :
        {
            //
            //  Set the background color of the time controls to the the
            //  color of the edit controls.
            //
            if ((GET_WM_CTLCOLOR_HWND(wParam, lParam, uMsg) ==
                 GetDlgItem(hDlg, DATETIME_TSEP1)) ||
                (GET_WM_CTLCOLOR_HWND(wParam, lParam, uMsg) ==
                 GetDlgItem(hDlg, DATETIME_TSEP2)) ||
                (GET_WM_CTLCOLOR_HWND(wParam, lParam, uMsg) ==
                 GetDlgItem(hDlg, DATETIME_TBORDER)))
            {
#ifndef WIN32
                //
                //  Make the statics the color of the edits.
                //
                lParam = GET_WM_CTLCOLOR_MPS(
                            GET_WM_CTLCOLOR_HDC(wParam, lParam, uMsg),
                            GET_WM_CTLCOLOR_HWND(wParam, lParam, uMsg),
                            CTLCOLOR_EDIT );

                return ((INT_PTR)DefWindowProc(hDlg, uMsg, wParam, lParam));
#else
                return ((INT_PTR)DefWindowProc(hDlg, WM_CTLCOLOREDIT, wParam, lParam));
#endif
            }
            return (0);
            break;
        }
        case ( WM_NOTIFY ) :
        {
            //
            //  Property sheet handler stuff.
            //
            switch (((NMHDR *)lParam)->code)
            {
                case ( PSN_SETACTIVE ) :
                {
                    _ShowTZ(hDlg);
                    break;
                }
                case ( PSN_RESET ) :
                {
                    UnhookTimer(hDlg);

                    SetFocus(GetDlgItem(hDlg, (int)wParam));

                    GetDate();
                    GetTime();
                    break;
                }
                case ( PSN_APPLY ) :
                {
                    wDateTime[MINUTE] = (WORD)g_Time[MINUTE];
                    wDateTime[SECOND] = (WORD)g_Time[SECOND];

                    if (g_b24HR)
                    {
                        wDateTime[HOUR] = (WORD)g_Time[HOUR];
                    }
                    else
                    {
                        wDateTime[HOUR] = g_Time[HOUR] % 12;

                        if (g_bPM)
                        {
                            wDateTime[HOUR] += 12;
                        }
                    }
                    
                    g_WasModified = g_Modified;
                    SetTime();

                    g_LastTime[HOUR] = g_LastTime[MINUTE] = g_LastTime[SECOND] = -1;

                    for (i = MONTH; i <= YEAR; i++)
                    {
                        wPrevDateTime[i] = -1;
                    }

                    g_Modified = FALSE;

                    wPrevDateTime[HOUR]    = wDateTime[HOUR];
                    wPrevDateTime[MINUTE]  = wDateTime[MINUTE];
                    wPrevDateTime[SECOND]  = wDateTime[SECOND];
                    wPrevDateTime[MONTH]   = wDateTime[MONTH];
                    wPrevDateTime[DAY]     = wDateTime[DAY];
                    wPrevDateTime[YEAR]    = wDateTime[YEAR];
                    wPrevDateTime[WEEKDAY] = wDateTime[WEEKDAY];

                    //
                    //  We handled it - no repaint.
                    //
                    return (TRUE);
                }
            }
            break;
        }
        case ( WM_VSCROLL ) :
        {
            switch (GET_WM_VSCROLL_CODE(wParam, lParam))
            {
                case ( SB_THUMBPOSITION ) :
                {
                    SYSTEMTIME SystemTime;
                    HWND hBuddy = (HWND)SendMessage(
                                           GET_WM_VSCROLL_HWND(wParam, lParam),
                                           UDM_GETBUDDY,
                                           0,
                                           0L );

                    if (hBuddy == GetDlgItem(hDlg, DATETIME_HOUR))
                    {
                        g_Time[HOUR] = GET_WM_VSCROLL_POS(wParam, lParam);
                    }
                    else if (hBuddy == GetDlgItem(hDlg, DATETIME_MINUTE))
                    {
                        g_Time[MINUTE] = GET_WM_VSCROLL_POS(wParam, lParam);
                    }
                    else if (hBuddy == GetDlgItem(hDlg, DATETIME_SECOND))
                    {
                        g_Time[SECOND] = GET_WM_VSCROLL_POS(wParam, lParam);
                    }
                //  else if (hBuddy == GetDlgItem(hDlg, DATETIME_AMPM))

                    if (hBuddy != GetDlgItem(hDlg, DATETIME_YEAR))  
                        g_Modified = TRUE;

                    //
                    //  Light the apply now button.
                    //
                    PropSheet_Changed(GetParent(hDlg), hDlg);

                    //
                    //  Force the clock to reflect this setting.
                    //
                    TimeProvider(&SystemTime, hDlg);

                    SendDlgItemMessage( hDlg,
                                        DATETIME_CLOCK,
                                        CLM_UPDATETIME,
                                        CLF_SETTIME,
                                        (LPARAM)(LPSYSTEMTIME)&SystemTime );

                    //
                    //  Fall thru to update the year...
                    //
                }
                case ( SB_ENDSCROLL ) :
                {
                    //
                    //  If this is the year, have the calendar repaint.
                    //
                    if ((HWND)SendMessage( GET_WM_VSCROLL_HWND(wParam, lParam),
                                           UDM_GETBUDDY,
                                           0,
                                           0L ) == GetDlgItem(hDlg, DATETIME_YEAR))
                    {
                        //
                        //  Have it update the information.
                        //
                        GetTime();
                        AdjustDelta(hDlg, YEAR);
                        UpdateItem(hDlg, YEAR);

                        InvalidateRect( GetDlgItem(hDlg, DATETIME_CALENDAR),
                                        NULL,
                                        TRUE );
                    }

                    break;
                }
            }
            break;
        }
        case ( CLM_UPDATETIME ) :
        {
            //
            //  The clock updating/reflecting the time.
            //
            switch (wParam)
            {
                case ( CLF_SETTIME ) :
                {
                    //
                    //  Clock telling us what the time is.
                    //
                    g_Modified = TRUE;
                    g_Time[HOUR] = ((LPSYSTEMTIME)lParam)->wHour;
                    g_Time[MINUTE] = ((LPSYSTEMTIME)lParam)->wMinute;
                    g_Time[SECOND] = ((LPSYSTEMTIME)lParam)->wSecond;
                    g_bPM = IsAMPM(g_Time[HOUR]);
                    break;
                }
                case ( CLF_GETTIME ) :
                {
                    //
                    //  We tell the clock what time it is.
                    //
                    TimeProvider((LPSYSTEMTIME)lParam, hDlg);
                    break;
                }
            }
            break;
        }
        case ( WM_COMMAND ) :
        {
            //
            //  Command processing.
            //
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case ( DATETIME_AMPM ) :
                {
                    //
                    //  Deals with the AMPM control.
                    //
                    UDACCEL udAccel;
                    HWND hwndScroll = GetDlgItem(hDlg, DATETIME_TARROW);
                    HWND hwndThisCtl = GET_WM_COMMAND_HWND(wParam, lParam);

                    //
                    //  We only care if we get/loose the focus.
                    //
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case ( LBN_SETFOCUS ) :
                        {
                            //
                            //  If we get the focus, then the UD control
                            //  should deal with the AMPM.
                            //
                            //  Select the visible entry.
                            //
                            ReflectAMPM(hDlg, wDateTime[HOUR]);

                            // if it has a buddy, remove it...
                            if ((HWND)SendMessage( hwndScroll,
                                               UDM_GETBUDDY,
                                               0,
                                               0 ) != NULL)
                            {
                                SendMessage(hwndScroll, UDM_SETBUDDY, 0, 0);
                            } 
                            
                            //
                            //  Tell the UD control how to manipulate AM/PM.
                            //
                            SendMessage( hwndScroll,
                                         UDM_SETRANGE,
                                         0,
                                         MAKELPARAM(1, 0) );
                            udAccel.nSec = 0;
                            udAccel.nInc = 1;
                            SendMessage( hwndScroll,
                                         UDM_SETACCEL,
                                         1,
                                         (LPARAM)(LPUDACCEL)&udAccel );
                            SendMessage( hwndScroll,
                                         UDM_SETBUDDY,
                                         (WPARAM)hwndThisCtl,
                                         0 );
                            break;
                        }
                        case ( LBN_KILLFOCUS ) :
                        {
                            //
                            //  When we loose focus, the g_bPM flag is updated.
                            //
                            //  Remove selection from the AM/PM.
                            //
                            ListBox_SetCurSel(hwndThisCtl, -1);

                            if ((HWND)SendMessage( hwndScroll,
                                                   UDM_GETBUDDY,
                                                   0,
                                                   0 ) == hwndThisCtl)
                            {
                                SendMessage(hwndScroll, UDM_SETBUDDY, 0, 0);
                            }

                            break;
                        }
                        case ( LBN_SELCHANGE ) :
                        {
                            if ((g_Modified == FALSE) &&
                                (g_bPM == (BOOL)ListBox_GetTopIndex(hwndThisCtl)))
                            {
                                break;
                            }

                            //
                            //  Find the visible entry.
                            //
                            g_Modified = TRUE;

                            //
                            //  Light the apply now button.
                            //
                            PropSheet_Changed(GetParent(hDlg), hDlg);
                            g_bPM = (BOOL)ListBox_GetTopIndex(hwndThisCtl);
                            break;
                        }
                    }
                    break;
                }
                case ( DATETIME_HOUR ) :
                case ( DATETIME_MINUTE ) :
                case ( DATETIME_SECOND ) :
                {
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case ( EN_CHANGE ) :
                        {
                            SYSTEMTIME SystemTime;

                            g_Modified = TRUE;

                            //
                            //  Light the apply now button.
                            //
                            PropSheet_Changed(GetParent(hDlg), hDlg);

                            //
                            //  Work out what the change was too.
                            //
                            g_Time[GET_WM_COMMAND_ID(wParam, lParam) -
                                   DATETIME_HOUR] =
                              (int)SendDlgItemMessage( hDlg,
                                                       DATETIME_TARROW,
                                                       UDM_GETPOS,
                                                       0,
                                                       0 );

                            //
                            //  Force the clock to reflect this setting.
                            //
                            TimeProvider(&SystemTime, hDlg);
                            SendDlgItemMessage( hDlg,
                                                DATETIME_CLOCK,
                                                CLM_UPDATETIME,
                                                0,
                                                (LPARAM)(LPSYSTEMTIME)&SystemTime );
                            break;
                        }
                    }

                    //  fall thru...
                }
                case ( DATETIME_MONTH ) :
                case ( DATETIME_YEAR ) :
                case ( DATETIME_DAY ) :
                {
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case ( EN_CHANGE ) :
                        {
                            CheckNum( hDlg,
                                      GET_WM_COMMAND_ID(wParam, lParam) <= DATETIME_SECOND
                                          ? DATETIME_TARROW
                                          : DATETIME_YARROW,
                                      GET_WM_COMMAND_HWND(wParam, lParam) );

                            // Changing the year may alter the number of days in February.
                            // Yes this is a hack, but this entire applet is a giant
                            // broken hack and I want to change it as little as possible.
                            if (GET_WM_COMMAND_ID(wParam, lParam) == DATETIME_YEAR && wDateTime[MONTH] == 2)
                            {
                                g_sDateInfo[DAY].nMax = MonthUpperBound( wDateTime[MONTH],
                                                                         wDateTime[YEAR] );
                                if (wDateTime[DAY] > g_sDateInfo[DAY].nMax)
                                {
                                    wDateTime[DAY] = (WORD)g_sDateInfo[DAY].nMax;
                                    fDateDirty = TRUE;
                                }
                                InvalidateRect( GetDlgItem(hDlg, DATETIME_CALENDAR),
                                                NULL,
                                                TRUE );
                            }
                            break;
                        }
                        case ( EN_SETFOCUS ) :
                        {
                            UINT id = GET_WM_COMMAND_ID(wParam, lParam) - DATETIME_HOUR;

                            if (id <= SECOND)
                            {
                                UDACCEL udAccel[2];
                                static int nInc[] = { 1, 5, 5, 1, 1, 5 };
                                HWND hwndScroll = GetDlgItem(hDlg, DATETIME_TARROW);

                                // if it has a buddy, remove it...
                                if ((HWND)SendMessage( hwndScroll,
                                                   UDM_GETBUDDY,
                                                   0,
                                                   0 ) != NULL)
                                {
                                    SendMessage(hwndScroll, UDM_SETBUDDY, 0, 0);
                                }    

                                //
                                // now set the new one
                                //
                                SendMessage( hwndScroll,
                                             UDM_SETRANGE,
                                             0,
                                             MAKELPARAM( g_sDateInfo[id].nMax,
                                                         g_sDateInfo[id].nMin) );
                                udAccel[0].nSec = 0;
                                udAccel[0].nInc = 1;
                                udAccel[1].nSec = 2;
                                udAccel[1].nInc = nInc[id];
                                SendMessage( hwndScroll,
                                             UDM_SETACCEL,
                                             2,
                                             (LPARAM)(LPUDACCEL)udAccel );

                                //
                                //  Set the UD to update this control.
                                //
                                SendMessage( hwndScroll,
                                             UDM_SETBUDDY,
                                             (WPARAM)GET_WM_COMMAND_HWND(wParam,
                                                                         lParam),
                                             0 );
                            }
                            break;
                        }
                        case ( EN_KILLFOCUS ) :
                        {
                            //
                            //  Gets in range HMS MDY.
                            //
                            UINT id = GET_WM_COMMAND_ID(wParam, lParam) - DATETIME_HOUR;

                            AdjustDelta(hDlg, id);
                            UpdateItem(hDlg, id);                           

                            //
                            //  If control is YEAR.
                            //
                            if (id == (DATETIME_YEAR - DATETIME_HOUR))
                            {
                                InvalidateRect( GetDlgItem(hDlg, DATETIME_CALENDAR),
                                                NULL,
                                                TRUE );
                            }

                            break;
                        }
                        default :
                        {
                            break;
                        }
                    }
                    break;
                }
                case ( DATETIME_MONTHNAME ) :
                {
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_SELCHANGE)
                    {
                        int nIndex = 1 + (int)ComboBox_GetCurSel(
                                              GetDlgItem( hDlg,
                                                          DATETIME_MONTHNAME ));

                        if (wDateTime[MONTH] != nIndex)
                        {
                            AdjustDeltaMonth(nIndex);
                            InvalidateRect( GetDlgItem(hDlg, DATETIME_CALENDAR),
                                            NULL,
                                            TRUE );
                            PropSheet_Changed(GetParent(hDlg), hDlg);
                        }
                    }
                    break;
                }
                case ( DATETIME_CALENDAR ) :
                {
                    //
                    //  If the calendar sent us a change, we will assume
                    //  that it is to allow the apply now to work.
                    //
                    PropSheet_Changed(GetParent(hDlg), hDlg);
                    break;
                }
            }
            break;
        }
        case ( WM_WININICHANGE ) :
        {
            //
            //  Reinitialize if there is a time format change.
            //
            InitDateTimeDlg(hDlg, uMsg, wParam, lParam);
            InvalidateRect(GetDlgItem(hDlg, DATETIME_CALENDAR), NULL, TRUE);
            break;
        }
        case ( WM_TIMECHANGE ) :
        {
            //
            //  Forward time change messages to the clock control.
            //
            SendDlgItemMessage( hDlg,
                                DATETIME_CLOCK,
                                WM_TIMECHANGE,
                                wParam,
                                lParam );

            break;
        }

        case ( WMUSER_ADDINTERNETTAB ) :
        {
            AddInternetTab(hDlg);
            break;
        }

        case ( WM_HELP ) :             // F1
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     NULL,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aDateTimeHelpIds );
            break;
        }
        case ( WM_CONTEXTMENU ) :      // right mouse click
        {
            WinHelp( (HWND)wParam,
                     NULL,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aDateTimeHelpIds );
            break;
        }
        default :
        {
            return (FALSE);
        }
    }
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetZoneState
//
//  Sets the display state of a time zone in the map control.
//
////////////////////////////////////////////////////////////////////////////

void SetZoneState(
    HWND map,
    PTZINFO zone,
    BOOL highlight)
{
    if (zone)
    {
        if (zone->SeaIndex >= 0)
        {
            MapControlSetSeaRegionHighlight( map,
                                             zone->SeaIndex,
                                             highlight,
                                             zone->MapLeft,
                                             zone->MapWidth );
        }

        if (zone->LandIndex >= 0)
        {
            MapControlSetLandRegionHighlight( map,
                                              zone->LandIndex,
                                              highlight,
                                              zone->MapLeft,
                                              zone->MapWidth );
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  SetZoneFamilyState
//
//  Sets the display state of a time zone family in the map control.
//
////////////////////////////////////////////////////////////////////////////

void SetZoneFamilyState(
    HWND map,
    PTZINFO family,
    BOOL highlight)
{
    if (family)
    {
        PTZINFO zone = family;

        do
        {
            SetZoneState(map, zone, highlight);
            zone = zone->next;
        }
        while(zone && (zone != family));
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  ParseMapInfo
//
//  Parses the color table information about the world bitmap we display.
//
//  Expected format: "sea,land"
//    where sea and land are color table indices or -1.
//
////////////////////////////////////////////////////////////////////////////

void ParseMapInfo(
    PTZINFO zone,
    const TCHAR *text)
{
    const TCHAR *p = text;

    zone->SeaIndex = zone->LandIndex = -1;

    if (*p)
    {
        if (*p != TEXT('-'))
        {
            zone->SeaIndex = 0;

            while (*p && (*p != TEXT(',')))
            {
                zone->SeaIndex = (10 * zone->SeaIndex) + (*p - TEXT('0'));
                p++;
            }
        }
        else
        {
            do
            {
                p++;
            } while (*p && (*p != TEXT(',')));
        }

        if (*p == TEXT(','))
        {
            p++;
        }

        if (*p)
        {
            if (*p != TEXT('-'))
            {
                zone->LandIndex = 0;

                while (*p)
                {
                    zone->LandIndex = (10 * zone->LandIndex) + (*p - TEXT('0'));
                    p++;
                }
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  ReadZoneData
//
//  Reads the data for a time zone from the registry.
//
////////////////////////////////////////////////////////////////////////////

BOOL ReadZoneData(
    PTZINFO zone,
    HKEY key,
    LPCTSTR keyname)
{
    TCHAR mapinfo[16];
    DWORD len;

    len = sizeof(zone->szDisplayName);

    if (RegQueryValueEx( key,
                         c_szTZDisplayName,
                         0,
                         NULL,
                         (LPBYTE)zone->szDisplayName,
                         &len ) != ERROR_SUCCESS)
    {
        return (FALSE);
    }

    //
    //  Under NT, the keyname is the "Standard" name.  Values stored
    //  under the keyname contain the other strings and binary info
    //  related to the time zone.  Every time zone must have a standard
    //  name, therefore, we save registry space by using the Standard
    //  name as the subkey name under the "Time Zones" key.
    //
    len = sizeof(zone->szStandardName);

    if (RegQueryValueEx( key,
                         c_szTZStandardName,
                         0,
                         NULL,
                         (LPBYTE)zone->szStandardName,
                         &len ) != ERROR_SUCCESS)
    {
        //
        //  Use keyname if can't get StandardName value.
        //
        lstrcpyn( zone->szStandardName,
                  keyname,
                  sizeof(zone->szStandardName) );
    }

    len = sizeof(zone->szDaylightName);

    if (RegQueryValueEx( key,
                         c_szTZDaylightName,
                         0,
                         NULL,
                         (LPBYTE)zone->szDaylightName,
                         &len ) != ERROR_SUCCESS)
    {
        return (FALSE);
    }

    len = sizeof(zone->Bias) +
          sizeof(zone->StandardBias) +
          sizeof(zone->DaylightBias) +
          sizeof(zone->StandardDate) +
          sizeof(zone->DaylightDate);

    if (RegQueryValueEx( key,
                         c_szTZI,
                         0,
                         NULL,
                         (LPBYTE)&zone->Bias,
                         &len ) != ERROR_SUCCESS)
    {
        return (FALSE);
    }

    len = sizeof(mapinfo);

    if (RegQueryValueEx( key,
                         c_szTZMapInfo,
                         0,
                         NULL,
                         (LPBYTE)mapinfo,
                         &len ) != ERROR_SUCCESS)
    {
        *mapinfo = TEXT('\0');
    }

    ParseMapInfo(zone, mapinfo);

    //
    //  Generate phony MapLeft and MapRight until they show up in the
    //  registry.
    //
    zone->MapLeft = ((zone->Bias * ZONE_IMAGE_SCALE) / ZONE_BIAS_SCALE) +
                    ZONE_IMAGE_LEFT;

    zone->MapWidth = ZONE_IMAGE_WIDTH;

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  AddZoneToList
//
//  Inserts a new time zone into a list, sorted by bias and then name.
//
////////////////////////////////////////////////////////////////////////////

void AddZoneToList(
    PTZINFO *list,
    PTZINFO zone)
{
    if (*list)
    {
        PTZINFO curr = NULL;
        PTZINFO next = *list;

        while (next && zone->Bias <= next->Bias)
        {
            if (zone->Bias == next->Bias)
            {
                if (CompareString( GetUserDefaultLCID(),
                                   0,
                                   zone->szDisplayName,
                                   -1,
                                   next->szDisplayName,
                                   -1 ) == CSTR_LESS_THAN)
                {
                    break;
                }
            }
            curr = next;
            next = curr->next;
        }

        zone->next = next;

        if (curr)
        {
            curr->next = zone;
        }
        else
        {
            *list = zone;
        }
    }
    else
    {
        *list = zone;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  FreeTimezoneList
//
//  Frees all time zones in the passed list, setting the head to NULL.
//
////////////////////////////////////////////////////////////////////////////

void FreeTimezoneList(
    PTZINFO *list)
{
    while (*list)
    {
        PTZINFO next = (*list)->next;

        LocalFree((HANDLE)*list);

        *list = next;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  ReadTimezones
//
//  Reads the time zone information from the registry.
//  Returns num read, -1 on failure.
//
////////////////////////////////////////////////////////////////////////////

int ReadTimezones(
    PTZINFO *list)
{
    HKEY key = NULL;
    int count = -1;

    *list = NULL;

    if (RegOpenKey( HKEY_LOCAL_MACHINE,
                    c_szTimeZones,
                    &key ) == ERROR_SUCCESS)
    {
        TCHAR name[TZNAME_SIZE];
        PTZINFO zone = NULL;
        int i;

        count = 0;

        for (i = 0;
             RegEnumKey(key, i, name, TZNAME_SIZE) == ERROR_SUCCESS;
             i++)
        {
            HKEY subkey = NULL;

            if (!zone &&
                ((zone = (PTZINFO)LocalAlloc(LPTR, sizeof(TZINFO))) == NULL))
            {
                zone = *list;
                *list = NULL;
                count = -1;
                break;
            }

            zone->next = NULL;

            if (RegOpenKey(key, name, &subkey) == ERROR_SUCCESS)
            {
                //
                //  Each sub key name under the Time Zones key is the
                //  "Standard" name for the Time Zone.
                //
                lstrcpyn(zone->szStandardName, name, TZNAME_SIZE);

                if (ReadZoneData(zone, subkey, name))
                {
                    AddZoneToList(list, zone);
                    zone = NULL;
                    count++;
                }

                RegCloseKey(subkey);
            }
        }

        FreeTimezoneList(&zone);
        RegCloseKey(key);
    }

    return (count);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitZoneMapping
//
//  Initializes map and map lookup for a specific time zone.
//
////////////////////////////////////////////////////////////////////////////

void InitZoneMapping(
    PTZINFO *lookup,
    PTZINFO list,
    HWND map)
{
    PTZINFO zone = list;    // not needed but more readable

    while (zone)
    {
        if (zone->SeaIndex >= 0)
        {
            lookup[zone->SeaIndex] = zone;
        }

        if (zone->LandIndex >= 0)
        {
            lookup[zone->LandIndex] = zone;
        }

        SetZoneState(map, zone, FALSE);
        zone = zone->next;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  BreakZonesIntoFamilies
//
//  Breaks the passed list into many circular lists.
//  Each list consists of all time zones with a particular bias.
//  Assumes the passed list is sorted by bias.
//
////////////////////////////////////////////////////////////////////////////

void BreakZonesIntoFamilies(
    PTZINFO head)
{
    PTZINFO subhead = NULL;
    PTZINFO last = NULL;
    PTZINFO zone = head;

    while (zone)
    {
        subhead = zone;

        do
        {
            last = zone;
            zone = zone->next;
        }
        while (zone && (zone->Bias == subhead->Bias));

        last->next = subhead;
    }

    //
    //  Merge -12 and +12 zones into a single group.
    //  Assumes populated registry and depends on sort order.
    //
    if ((subhead) &&
        (subhead->Bias == BIAS_PLUS_12) &&
        (head->Bias == BIAS_MINUS_12))
    {
        PTZINFO next = head;

        do
        {
            zone = next;
            next = zone->next;
        }
        while (next != head);

        zone->next = subhead;
        last->next = head;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  InitTimezones
//
//  Initializes time zone stuff, UI and otherwise.
//
////////////////////////////////////////////////////////////////////////////

BOOL InitTimezones(
    HWND page,
    PTZINFO *lookup)
{
    PTZINFO list = NULL;

    if ((g_nTimeZones = ReadTimezones(&list)) >= 0)
    {
        HWND combo = GetDlgItem(page, IDD_TIMEZONES);
        PTZINFO zone = list;

        SetWindowRedraw(combo, FALSE);

        while (zone)
        {
            int index = ComboBox_AddString(combo, zone->szDisplayName);

            if (index < 0)
            {
                break;
            }
            zone->ComboIndex = index;
            ComboBox_SetItemData(combo, index, (LPARAM)zone);
            zone = zone->next;
        }

        SetWindowRedraw(combo, TRUE);

        if (!zone)
        {
            InitZoneMapping(lookup, list, GetDlgItem(page, IDD_TIMEMAP));
            BreakZonesIntoFamilies(list);
            return (TRUE);
        }

        FreeTimezoneList(&list);
        ComboBox_ResetContent(combo);
    }

    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  ChangeZone
//
//  Updates the current zone, making sure new zone's family is highlighted.
//
////////////////////////////////////////////////////////////////////////////

void ChangeZone(
    HWND page,
    TZPAGE_STATE *state,
    PTZINFO zone)
{
    if (zone || state->zone)
    {
        BOOL newfamily = (!zone || !state->zone ||
                          (zone->Bias != state->zone->Bias));
        HWND map = GetDlgItem(page, IDD_TIMEMAP);
        BOOL dayval = (zone && (zone->StandardDate.wMonth != 0));

        if (newfamily && state->zone)
        {
            SetZoneFamilyState(map, state->zone, FALSE);
        }

        state->zone = zone;

        if (newfamily && state->zone)
        {
            SetZoneFamilyState(map, state->zone, TRUE);
        }

        if (newfamily)
        {
            MapControlInvalidateDirtyRegions(map);
        }

        ShowWindow(GetDlgItem(page, IDD_AUTOMAGIC), (dayval != 0 ? SW_SHOW : SW_HIDE));

        if (!state->initializing)
        {
            PropSheet_Changed(GetParent(page), page);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  HotTrackZone
//
//  Updates the map highlighting and combo selection for a given map index.
//  Expects to be called with dups.
//
////////////////////////////////////////////////////////////////////////////

void HotTrackZone(
    HWND page,
    TZPAGE_STATE *state,
    int index)
{
    PTZINFO zone = state->lookup[index];

    if (zone && (zone != state->zone))
    {
        ComboBox_SetCurSel( GetDlgItem(page, IDD_TIMEZONES),
                            (zone ? zone->ComboIndex : -1) );
        ChangeZone(page, state, zone);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CenterZone
//
//  Updates the map highlighting and combo selection for a given map index.
//  Expects to be called with dups.
//
////////////////////////////////////////////////////////////////////////////

void CenterZone(
    HWND page,
    TZPAGE_STATE *state,
    BOOL animate)
{
    PTZINFO zone = state->zone;

    if (zone)
    {
        HWND map = GetDlgItem(page, IDD_TIMEMAP);

        MapControlRotateTo(map, zone->MapLeft + zone->MapWidth / 2, animate);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  GetPTZ
//
//  Returns the pointer for the iItem time zone.
//  If iItem is -1 on entry, use the currently selected time zone.
//
////////////////////////////////////////////////////////////////////////////

PTZINFO GetPTZ(
    HWND hDlg,
    int iItem)
{
    HWND hCtl = GetDlgItem(hDlg, IDD_TIMEZONES);

    if (iItem == -1)
    {
        iItem = (int)ComboBox_GetCurSel(hCtl);
    }

    if (iItem < 0)
    {
        return (NULL);
    }

    return ((PTZINFO)ComboBox_GetItemData(hCtl, iItem));
}


////////////////////////////////////////////////////////////////////////////
//
//  GetAllowLocalTimeChange
//
////////////////////////////////////////////////////////////////////////////

TCHAR c_szRegPathTZControl[] = REGSTR_PATH_TIMEZONE;
TCHAR c_szRegValDisableTZUpdate[] = REGSTR_VAL_TZNOAUTOTIME;

BOOL GetAllowLocalTimeChange()
{
    //
    //  Assume allowed until we see a disallow flag.
    //
    BOOL result = TRUE;
    HKEY key;

    if (RegOpenKey( HKEY_LOCAL_MACHINE,
                    c_szRegPathTZControl,
                    &key ) == ERROR_SUCCESS)
    {
        //
        //  Assume no disallow flag until we see one.
        //
        DWORD value = 0;
        long len = sizeof(value);
        DWORD type;

        if ((RegQueryValueEx( key,
                              c_szRegValDisableTZUpdate,
                              NULL,
                              &type,
                              (LPBYTE)&value,
                              &len ) == ERROR_SUCCESS) &&
            ((type == REG_DWORD) || (type == REG_BINARY)) &&
            (len == sizeof(value)) && value)
        {
            //
            //  Okay, we have a nonzero value, it is either:
            //
            //  1) 0xFFFFFFFF
            //      this is set in an inf file for first boot to prevent
            //      the base from performing any cutovers during setup.
            //
            //  2) some other value
            //      this signifies that the user actualy disabled cutovers
            //     *return that local time changes are disabled
            //
            if (value != 0xFFFFFFFF)
            {
                result = FALSE;
            }
        }

        RegCloseKey(key);
    }

    return (result);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetAllowLocalTimeChange
//
////////////////////////////////////////////////////////////////////////////

void SetAllowLocalTimeChange(
    BOOL fAllow)
{
    HKEY key = NULL;

    if (fAllow)
    {
        //
        //  Remove the disallow flag from the registry if it exists.
        //
        if (RegOpenKey( HKEY_LOCAL_MACHINE,
                        c_szRegPathTZControl,
                        &key ) == ERROR_SUCCESS)
        {
            RegDeleteValue(key, c_szRegValDisableTZUpdate);
        }
    }
    else
    {
        //
        //  Add/set the nonzero disallow flag.
        //
        if (RegCreateKey( HKEY_LOCAL_MACHINE,
                          c_szRegPathTZControl,
                          &key ) == ERROR_SUCCESS)
        {
            DWORD value = 1;

            RegSetValueEx( key,
                           (LPCTSTR)c_szRegValDisableTZUpdate,
                           0UL,
                           REG_DWORD,
                           (LPBYTE)&value,
                           sizeof(value) );
        }
    }

    if (key)
    {
        RegCloseKey(key);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  InitTimeZonePage
//
//  This function initializes everything to do with the Time Zones.
//
////////////////////////////////////////////////////////////////////////////

BOOL InitTimeZonePage(
    HWND hDlg,
    TZPAGE_STATE *state)
{
    TIME_ZONE_INFORMATION tziCurrent;
    DWORD dwTZID;
    PTZINFO ptzi;
    int j ,iCurrentTZ;
    BOOL fForceSelection = FALSE;
    TCHAR temp[TZNAME_SIZE];
    TCHAR oldTzMapName[TZNAME_SIZE], newTzMapName[TZNAME_SIZE];


    //
    //  Get the current time zone information.
    //
    dwTZID = GetTimeZoneInformation(&tziCurrent);

    LoadString(g_hInst, IDS_ISRAELTIMEZONE, oldTzMapName, TZNAME_SIZE);
    LoadString(g_hInst, IDS_JERUSALEMTIMEZONE, newTzMapName, TZNAME_SIZE);
    
    // this is a hack for Win95 or WinNT 4 to Win98/Win2k migration. "Israel" became "Jerusalem"
#ifdef UNICODE
    if (!lstrcmpi(oldTzMapName, tziCurrent.StandardName))
    {
        lstrcpy(tziCurrent.StandardName, newTzMapName);
        fForceSelection = TRUE;
    }
#else
    if (!AnsiWideStrCmpI(oldTzMapName, tziCurrent.StandardName))
    {
        StrToWideStr(tziCurrent.StandardName, newTzMapName);
        fForceSelection = TRUE;
    }
#endif

    //
    //  Check for bogus time zone info.
    //
    if (dwTZID != TIME_ZONE_ID_INVALID)
    {
        //
        //  Copy the name out so we can check for first boot.
        //
#ifdef UNICODE
        lstrcpy(temp, tziCurrent.StandardName);
#else
        WideStrToStr(temp, tziCurrent.StandardName);
#endif
    }
    else
    {
        //
        //  Treat bogus time zones like first boot.
        //
        lstrcpy(temp, c_szFirstBootTZ);
    }

    if (lstrcmpi(temp, c_szFirstBootTZ) == 0)
    {
        //
        //  The 'default' value of the time zone key specifies the
        //  default zone.
        //
        TCHAR szDefaultName[TZNAME_SIZE];
        LONG len = sizeof(szDefaultName);

        if (RegQueryValue( HKEY_LOCAL_MACHINE,
                           c_szTimeZones,
                           szDefaultName,
                           &len ) == ERROR_SUCCESS)
        {
#ifdef UNICODE
            lstrcpy(tziCurrent.StandardName, szDefaultName);
#else
            StrToWideStr(tziCurrent.StandardName, szDefaultName);
#endif
        }
        else
        {
            tziCurrent.StandardName[0] = 0;
        }

        //
        //  If we can't find it by name, use GMT.
        //
        tziCurrent.StandardBias = tziCurrent.DaylightBias = tziCurrent.Bias = 0;

        //
        //  Force the user to make a valid choice before quitting.
        //
        fForceSelection = TRUE;
    }

    //
    //  Get the Time Zones from the registry.
    //
    InitTimezones(hDlg, state->lookup);

    //
    //  Try to select the 'current' one or some equivalent.
    //

    //
    //  Start with an invalid index.
    //
    iCurrentTZ = g_nTimeZones;

    //
    //  Try to find by name.
    //
    for (j = 0; j < g_nTimeZones; j++)
    {
        ptzi = GetPTZ(hDlg, j);

#ifdef UNICODE
        if (!lstrcmpi(ptzi->szStandardName, tziCurrent.StandardName))
#else
        if (!AnsiWideStrCmpI(ptzi->szStandardName, tziCurrent.StandardName))
#endif
        {
            iCurrentTZ = j;
            break;
        }
    }

    //
    //  If it hasn't been found yet, try to find a nearby zone using biases.
    //
    if (iCurrentTZ == g_nTimeZones)
    {
        int nBestHitCount = TZ_HIT_NONE;

        for (j = 0; j < g_nTimeZones; j++)
        {
            ptzi = GetPTZ(hDlg, j);

            if (ptzi->Bias == tziCurrent.Bias)
            {
                int nHitCount = TZ_HIT_BASE +
                            ((ptzi->StandardBias == tziCurrent.StandardBias) +
                             (ptzi->DaylightBias == tziCurrent.DaylightBias));

                if (nHitCount > nBestHitCount)
                {
                    nBestHitCount = nHitCount;
                    iCurrentTZ = j;

                    if (nHitCount >= TZ_HIT_EXACT)
                    {
                        break;
                    }
                }
            }
        }
    }

    //
    //  Still didn't find it?
    //
    if (iCurrentTZ == g_nTimeZones)
    {
        //
        //  Punt.
        //
        iCurrentTZ = 0;

        fForceSelection = TRUE;
    }

    //
    //  Set up the dialog using this time zone's info.
    //

    //
    //  Always use our rules for the allow-daylight muck.
    //
#ifndef WINNT
    if ((ptzi = GetPTZ(hDlg, iCurrentTZ)) != NULL)
    {
        tziCurrent.StandardDate = ptzi->StandardDate;
        tziCurrent.DaylightDate = ptzi->DaylightDate;
    }
#endif

    //
    //  If wMonth is 0, then this Time Zone does not support DST.
    //
    if ((tziCurrent.StandardDate.wMonth == 0) ||
        (tziCurrent.DaylightDate.wMonth == 0))
    {
        ShowWindow(GetDlgItem(hDlg, IDD_AUTOMAGIC), SW_HIDE);
    }

    //
    //  Always get "allow DLT" flag even if this zone is disabled.
    //
    CheckDlgButton(hDlg, IDD_AUTOMAGIC, GetAllowLocalTimeChange());

    ComboBox_SetCurSel(GetDlgItem(hDlg, IDD_TIMEZONES), iCurrentTZ);

    ChangeZone(hDlg, state, GetPTZ(hDlg, -1));
    CenterZone(hDlg, state, FALSE);

    if (fForceSelection || g_bFirstBoot)
    {
        PropSheet_Changed(GetParent(hDlg), hDlg);
        PropSheet_CancelToClose(GetParent(hDlg));
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetTheTimezone
//
//  Apply the User's time zone selection.
//
////////////////////////////////////////////////////////////////////////////

void SetTheTimezone(
    BOOL bAutoMagicTimeChange,
    BOOL bAutoMagicEnabled,
    PTZINFO ptzi)
{
    TIME_ZONE_INFORMATION tzi;
    HCURSOR hCurOld;

    if (!ptzi)
    {
        return;
    }

    tzi.Bias = ptzi->Bias;

#ifdef WINNT
    if ((bAutoMagicTimeChange == 0) ||
        (ptzi->StandardDate.wMonth == 0))
    {
        //
        //  Standard Only.
        //
        tzi.StandardBias = ptzi->StandardBias;
        tzi.DaylightBias = ptzi->StandardBias;
        tzi.StandardDate = ptzi->StandardDate;
        tzi.DaylightDate = ptzi->StandardDate;

#ifdef UNICODE
        lstrcpy(tzi.StandardName, ptzi->szStandardName);
        lstrcpy(tzi.DaylightName, ptzi->szStandardName);
#else
        StrToWideStr(tzi.StandardName, ptzi->szStandardName);
        StrToWideStr(tzi.DaylightName, ptzi->szStandardName);
#endif
    }
    else
#endif
    {
        //
        //  Automatically adjust for Daylight Saving Time.
        //
        tzi.StandardBias = ptzi->StandardBias;
        tzi.DaylightBias = ptzi->DaylightBias;
        tzi.StandardDate = ptzi->StandardDate;
        tzi.DaylightDate = ptzi->DaylightDate;

#ifdef UNICODE
        lstrcpy(tzi.StandardName, ptzi->szStandardName);
        lstrcpy(tzi.DaylightName, ptzi->szDaylightName);
#else
        StrToWideStr(tzi.StandardName, ptzi->szStandardName);
        StrToWideStr(tzi.DaylightName, ptzi->szDaylightName);
#endif
    }

    SetAllowLocalTimeChange(bAutoMagicTimeChange);

    SetTimeZoneInformation(&tzi);

    hCurOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

    SetCursor(hCurOld);
}


////////////////////////////////////////////////////////////////////////////
//
//  TimeZoneDlgProc
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK TimeZoneDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    TZPAGE_STATE *state = (TZPAGE_STATE *)GetWindowLongPtr(hDlg, DWLP_USER);

    int  i;

    switch (uMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            state = (TZPAGE_STATE *)LocalAlloc(LPTR, sizeof(TZPAGE_STATE));

            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)state);

            if (!state)
            {
                EndDialog(hDlg, -1);
                break;
            }

            state->initializing = TRUE;
            InitTimeZonePage(hDlg, state);
            state->initializing = FALSE;

            break;
        }
        case ( WM_DESTROY ) :
        {
            for (i = 0; i < g_nTimeZones; i++)
            {
                LocalFree((HLOCAL)GetPTZ(hDlg, i));
            }

            if (state)
            {
                LocalFree((HANDLE)state);
                SetWindowLongPtr(hDlg, DWLP_USER, 0L);
            }
            break;
        }
        case ( WM_NOTIFY ) :
        {
            switch (((NMHDR *)lParam)->idFrom)
            {
                case ( 0 ) :
                {
                    switch (((NMHDR *)lParam)->code)
                    {
                        case ( PSN_APPLY ) :
                        {
                            g_ptziCurrent = NULL;

                            //
                            //  Find out which listbox item was selected.
                            //
                            SetTheTimezone(
                                IsDlgButtonChecked(hDlg, IDD_AUTOMAGIC),
                                IsWindowVisible(GetDlgItem(hDlg, IDD_AUTOMAGIC)),
                                GetPTZ(hDlg, -1) );

                            //
                            // if the user had modified the time as well as the timezone,
                            // then we should honor the time that they gave us since they
                            // explicitly said this was the time.  If we don't then the
                            // time they entered will be offset by the timezone change
                            //
                       
                            if (g_WasModified)
                            {
                                g_WasModified = FALSE;
                                SetTime();
                            }
                            break;
                        }
                    }
                    break;
                }
                case ( IDD_TIMEMAP ) :
                {
                    NFYMAPEVENT *event = (NFYMAPEVENT *)lParam;

                    switch (event->hdr.code)
                    {
                        case ( MAPN_TOUCH ) :
                        {
                            HotTrackZone(hDlg, state, event->index);
                            break;
                        }
                        case ( MAPN_SELECT ) :
                        {
                            CenterZone(hDlg, state, TRUE);
                            break;
                        }
                    }
                    break;
                }
            }
            break;
        }
        case ( WM_COMMAND ) :
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case ( IDD_TIMEZONES ) :    // combo box
                {
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_SELCHANGE)
                    {
                        ChangeZone(hDlg, state, GetPTZ(hDlg, -1));
                        CenterZone(hDlg, state, TRUE);
                    }
                    break;
                }
                case ( IDD_AUTOMAGIC ) :    // check box
                {
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED)
                    {
                        PropSheet_Changed(GetParent(hDlg), hDlg);
                    }
                    break;
                }
            }
            break;
        }
        case ( WM_HELP ) :             // F1
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     NULL,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aDateTimeHelpIds );
            break;
        }
        case ( WM_CONTEXTMENU ) :      // right mouse click
        {
            WinHelp( (HWND)wParam,
                     NULL,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aDateTimeHelpIds );
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetClInt
//
//  Steal an int from the command line.
//
////////////////////////////////////////////////////////////////////////////

static int GetClInt(
    const TCHAR *p)
{
    BOOL neg = FALSE;
    int v = 0;

    //
    //  Skip spaces.
    //
    while (*p == TEXT(' '))
    {
        p++;
    }

    //
    //  See if it's negative.
    //
    if (*p == TEXT('-'))
    {
        //
        //  It's negative.  Remember that it's negative and skip the
        //  '-' char.
        //
        neg = TRUE;
        p++;
    }

    //
    //  Parse the absolute portion.  Digits only.
    //
    while ((*p >= TEXT('0')) && (*p <= TEXT('9')))
    {
        //
        //  Accumulate the value.
        //
        v = v * 10 + *p++ - TEXT('0');
    }

    //
    //  Return the result.
    //
    return (neg ? -v : v);
}


////////////////////////////////////////////////////////////////////////////
//
//  SelectZoneByName
//
////////////////////////////////////////////////////////////////////////////

BOOL SelectZoneByName(
    LPCTSTR cmdline)
{
    BOOL result = FALSE;
    HKEY key = NULL;

    while (*cmdline == TEXT(' '))
    {
        cmdline++;
    }

    if (!*cmdline)
    {
        return (FALSE);
    }

    if (RegOpenKey( HKEY_LOCAL_MACHINE,
                    c_szTimeZones,
                    &key ) == ERROR_SUCCESS)
    {
        TCHAR name[TZNAME_SIZE];
        HKEY subkey = NULL;
        TZINFO zone;

        //
        //  User can pass key name.
        //
        if (RegOpenKey(key, cmdline, &subkey) == ERROR_SUCCESS)
        {
            if (ReadZoneData(&zone, subkey, cmdline))
            {
                result = TRUE;
            }
        }
        else
        {
            //
            //  User can also pass display name.
            //
            int i;
            int CmdLen = lstrlen(cmdline);

            for (i = 0;
                 RegEnumKey(key, i, name, TZNAME_SIZE) == ERROR_SUCCESS;
                 i++)
            {
                if (RegOpenKey(key, name, &subkey) == ERROR_SUCCESS)
                {
                    LONG len = sizeof(zone.szDisplayName);

                    if ((RegQueryValueEx( subkey,
                                          c_szTZDisplayName,
                                          0,
                                          NULL,
                                          (LPBYTE)&zone.szDisplayName,
                                          &len ) == ERROR_SUCCESS) &&
                        (CompareString( GetUserDefaultLCID(),
                                        NORM_IGNORECASE  | NORM_IGNOREKANATYPE |
                                        NORM_IGNOREWIDTH | NORM_IGNORENONSPACE,
                                        zone.szDisplayName,
                                        (CmdLen < 15)
                                            ? -1
                                            : min(lstrlen(zone.szDisplayName),
                                                  CmdLen),
                                        cmdline,
                                        -1 ) == CSTR_EQUAL))
                    {
                        if (ReadZoneData(&zone, subkey, name))
                        {
                            result = TRUE;
                        }
                    }

                    RegCloseKey(subkey);
                }

                if (result)
                {
                    break;
                }
            }
        }

        RegCloseKey(key);

        if (result)
        {
            SetTheTimezone(1, 1, &zone);
        }
    }

    return (result);
}


////////////////////////////////////////////////////////////////////////////
//
//  OpenDateTimePropertySheet
//
//  Opens a DateTime property sheet.
//  Set the page for the property sheet.
//
////////////////////////////////////////////////////////////////////////////

BOOL OpenDateTimePropertySheet(
    HWND hwnd,
    LPCTSTR cmdline)
{
    //  Make this an array for multiple pages.
    PROPSHEETPAGE apsp[3];
    PROPSHEETHEADER psh;
    HDC hDC;
    HFONT   hFont;
    int wMaxDigitWidth;
    BOOL fReturn;
    HRESULT hrOle;

    hDC = GetDC(hwnd);

    wMaxDigitWidth = GetMaxSubstitutedCharWidth(hDC);
    ReleaseDC(hwnd, hDC);

    psh.nStartPage = (UINT)-1;

    if (cmdline && *cmdline)
    {
        if (*cmdline == TEXT('/'))
        {
            BOOL fAutoSet = FALSE;

            //
            //  Legend:
            //    zZ: first boot batch mode setup "/z pacific" etc
            //    fF: regular first boot
            //    mM: time zone change forced local time change message
            //
            switch (*++cmdline)
            {
                case ( TEXT('z') ) :
                case ( TEXT('Z') ) :
                {
                    fAutoSet = TRUE;

                    //
                    //  Fall thru...
                    //
                }
                case ( TEXT('f') ) :
                case ( TEXT('F') ) :
                {
                    g_bFirstBoot = TRUE;

                    if (fAutoSet && SelectZoneByName(cmdline + 1))
                    {
                        return (TRUE);
                    }

                    //
                    //  Start on time zone page.
                    //
                    psh.nStartPage = 1;
                    break;
                }
                case ( TEXT('m') ) :
                case ( TEXT('M') ) :
                {
                    MSGBOXPARAMS params =
                                  {
                                    sizeof(params),
                                    hwnd,
                                    g_hInst,
                                    MAKEINTRESOURCE(IDS_WARNAUTOTIMECHANGE),
                                    MAKEINTRESOURCE(IDS_WATC_CAPTION),
                                    MB_OK | MB_USERICON,
                                    MAKEINTRESOURCE(IDI_TIMEDATE),
                                    0,
                                    NULL,
                                    0
                                  };

                    MessageBoxIndirect(&params);

                    //
                    //  Show time/date page for user to verify.
                    //
                    psh.nStartPage = 0;

                    break;
                }
                default :
                {
                    //
                    //  Fall out, maybe it's a number...
                    //
                    break;
                }
            }
        }
    }

    if (psh.nStartPage == (UINT)-1)
    {
        if (cmdline && (*cmdline >= TEXT('0')) && (*cmdline <= TEXT('9')))
        {
            psh.nStartPage = GetClInt(cmdline);
        }
        else
        {
            psh.nStartPage = 0;
        }
    }

    //
    //  Register our classes.
    //
    ClockInit(g_hInst);
    CalendarInit(g_hInst);
    RegisterMapControlStuff(g_hInst);

    psh.dwSize = sizeof(psh);
    if (g_bFirstBoot)
    {
        //
        //  Disable Apply button for first boot.
        //
        psh.dwFlags = PSH_PROPTITLE | PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
    }
    else
    {
        psh.dwFlags = PSH_PROPTITLE | PSH_PROPSHEETPAGE;
    }
    psh.hwndParent = hwnd;
    psh.hInstance = g_hInst;
    psh.pszIcon = NULL;

    //
    //  psh.nStartPage is set above.
    //
    psh.pszCaption = MAKEINTRESOURCE(IDS_TIMEDATE);
    psh.nPages = 2;
    psh.ppsp = apsp;

    apsp[0].dwSize = sizeof(PROPSHEETPAGE);
    apsp[0].dwFlags = PSP_DEFAULT;
    apsp[0].hInstance = g_hInst;
    apsp[0].pszTemplate = wMaxDigitWidth > 8 ? MAKEINTRESOURCE(DLG_DATETIMEWIDE) : MAKEINTRESOURCE(DLG_DATETIME);
    apsp[0].pfnDlgProc = DateTimeDlgProc;
    apsp[0].lParam = 0;

    apsp[1].dwSize = sizeof(PROPSHEETPAGE);
    apsp[1].dwFlags = PSP_DEFAULT;
    apsp[1].hInstance = g_hInst;
    apsp[1].pszTemplate = MAKEINTRESOURCE(DLG_TIMEZONE);
    apsp[1].pfnDlgProc = TimeZoneDlgProc;
    apsp[1].lParam = 0;

    if (psh.nStartPage >= psh.nPages)
    {
        psh.nStartPage = 0;
    }

    // We use the HyperLink control and that requires OLE (for IAccessible)
    hrOle = CoInitialize(0);

    fReturn = (BOOL)PropertySheet(&psh);
    if (SUCCEEDED(hrOle))
    {
        CoUninitialize();
    }

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\utc\inettime.h ===
/*****************************************************************************\
    FILE: inettime.h

    DESCRIPTION:
        This file contains the code used to display UI allowing the user to
    control the feature that updates the computer's clock from an internet
    NTP time server.

    BryanSt 3/22/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _INETTIME_H
#define _INETTIME_H


#define WMUSER_ADDINTERNETTAB (WM_USER + 10)

#define SZ_COMPUTER_LOCAL                   NULL
#define SZ_NTPCLIENT                        L"NtpClient"


EXTERN_C HRESULT AddInternetPageAsync(HWND hDlg, HWND hwndDate);
EXTERN_C HRESULT AddInternetTab(HWND hDlg);


#endif // _INETTIME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\utc\main.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    worldmap.c

Abstract:

    This module implements the world map for the Date/Time applet.

Revision History:

--*/



//  Include Files.
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "timedate.h"
#include "rc.h"
#include <cpl.h>




//
//  Global Variables.
//

HINSTANCE g_hInst = NULL;
CRITICAL_SECTION g_csDll;    /* The shared critical section */




//
//  Function Prototypes.
//

extern BOOL OpenDateTimePropertySheet(HWND hwnd, LPCTSTR cmdline);

BOOL
EnableTimePrivilege(
    PTOKEN_PRIVILEGES *pPreviousState,
    ULONG *pPreviousStateLength);

BOOL
ResetTimePrivilege(
    PTOKEN_PRIVILEGES PreviousState,
    ULONG PreviousStateLength);

int DoMessageBox(
    HWND hWnd,
    DWORD wText,
    DWORD wCaption,
    DWORD wType);





////////////////////////////////////////////////////////////////////////////
//
//  LibMain
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI LibMain(
    HANDLE hDll,
    DWORD dwReason,
    LPVOID lpReserved)
{
    switch (dwReason)
    {
        case ( DLL_PROCESS_ATTACH ) :
        {
            g_hInst = hDll;
            DisableThreadLibraryCalls(hDll);
            InitializeCriticalSection(&g_csDll);
            break;
        }
        case ( DLL_PROCESS_DETACH ) :
        {
            DeleteCriticalSection(&g_csDll);
            break;
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CplApplet
//
//  The main applet information manager.
//
////////////////////////////////////////////////////////////////////////////

LONG WINAPI CPlApplet(
    HWND hwnd,
    UINT uMsg,
    LPARAM lParam1,
    LPARAM lParam2)
{
    static BOOL fReEntered = FALSE;

    switch (uMsg)
    {
        case ( CPL_INIT ) :
        {
            return (TRUE);
        }
        case ( CPL_GETCOUNT ) :
        {
            //
            //  How many applets are in this DLL?
            //
            return (1);
        }
        case ( CPL_INQUIRE ) :
        {
            //
            //  Fill the CPLINFO with the pertinent information.
            //
            #define lpOldCPlInfo ((LPCPLINFO)lParam2)

            switch (lParam1)
            {
                case ( 0 ) :
                {
                    lpOldCPlInfo->idIcon = IDI_TIMEDATE;
                    lpOldCPlInfo->idName = IDS_TIMEDATE;
                    lpOldCPlInfo->idInfo = IDS_TIMEDATEINFO;
                    break;
                }
            }

            lpOldCPlInfo->lData = 0L;
            return (TRUE);
        }
        case ( CPL_NEWINQUIRE ) :
        {
            #define lpCPlInfo ((LPNEWCPLINFO)lParam2)

            switch (lParam1)
            {
                case ( 0 ) :
                {
                    lpCPlInfo->hIcon = LoadIcon( g_hInst,
                                                 MAKEINTRESOURCE(IDI_TIMEDATE) );
                    LoadString( g_hInst,
                                IDS_TIMEDATE,
                                lpCPlInfo->szName,
                                sizeof(lpCPlInfo->szName) );
                    LoadString( g_hInst,
                                IDS_TIMEDATEINFO,
                                lpCPlInfo->szInfo,
                                sizeof(lpCPlInfo->szInfo) );
                    lpCPlInfo->dwHelpContext = 0;
                    break;
                }
            }

            lpCPlInfo->dwSize = sizeof(NEWCPLINFO);
            lpCPlInfo->lData = 0L;
            lpCPlInfo->szHelpFile[0] = 0;
            return (TRUE);
        }
        case ( CPL_DBLCLK ) :
        {
            lParam2 = (LPARAM)0;

            // fall thru...
        }
        case ( CPL_STARTWPARMS ) :
        {
            //
            //  Do the applet thing.
            //
            switch (lParam1)
            {
                case ( 0 ) :
                {
                    PTOKEN_PRIVILEGES PreviousState;
                    ULONG PreviousStateLength;

                    if (EnableTimePrivilege(&PreviousState, &PreviousStateLength))
                    {
                        OpenDateTimePropertySheet(hwnd, (LPCTSTR)lParam2);
                        ResetTimePrivilege(PreviousState, PreviousStateLength);
                    }
                    else
                    {
                        DoMessageBox( hwnd,
                                      IDS_NOTIMEERROR,
                                      IDS_CAPTION,
                                      MB_OK | MB_ICONINFORMATION );
                    }
                    break;
                }
            }
            break;
        }
        case ( CPL_EXIT ) :
        {
            fReEntered = FALSE;

            //
            //  Free up any allocations of resources made.
            //

            break;
        }
        default :
        {
            return (0L);
        }
    }

    return (1L);
}


////////////////////////////////////////////////////////////////////////////
//
//  EnableTimePrivilege
//
////////////////////////////////////////////////////////////////////////////

BOOL EnableTimePrivilege(
    PTOKEN_PRIVILEGES *pPreviousState,
    ULONG *pPreviousStateLength)
{
#ifndef WINNT
    return TRUE;
#else    
    NTSTATUS NtStatus;
    HANDLE Token;
    LUID SystemTimePrivilege;
    PTOKEN_PRIVILEGES NewState;

    //
    //  Open our own token.
    //
    NtStatus = NtOpenProcessToken( NtCurrentProcess(),
                                   TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                   &Token );
    if (!NT_SUCCESS(NtStatus))
    {
        return (FALSE);
    }

    //
    //  Initialize the adjustment structure.
    //
    SystemTimePrivilege = RtlConvertLongToLuid(SE_SYSTEMTIME_PRIVILEGE);

    NewState = (PTOKEN_PRIVILEGES)LocalAlloc(LPTR, 100);
    if (NewState == NULL)
    {
        return (FALSE);
    }

    NewState->PrivilegeCount = 1;
    NewState->Privileges[0].Luid = SystemTimePrivilege;
    NewState->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    *pPreviousState = (PTOKEN_PRIVILEGES)LocalAlloc(LPTR, 100);
    if (*pPreviousState == NULL)
    {
        LocalFree(NewState);
        return (FALSE);
    }

    //  Set the state of the privilege to ENABLED.
    NtStatus = NtAdjustPrivilegesToken( Token,                  // TokenHandle
                                        FALSE,                  // DisableAllPrivileges
                                        NewState,               // NewState
                                        100,                    // BufferLength
                                        *pPreviousState,        // PreviousState (OPTIONAL)
                                        pPreviousStateLength ); // ReturnLength

    //
    //  Clean up some stuff before returning.
    //
    LocalFree(NewState);

    if (NtStatus == STATUS_SUCCESS)
    {
        NtClose(Token);
        return (TRUE);
    }
    else
    {
        LocalFree(*pPreviousState);
        NtClose(Token);
        return (FALSE);
    }
#endif //WINNT
}


////////////////////////////////////////////////////////////////////////////
//
//  ResetTimePrivilege
//
//  Restore previous privilege state for setting system time.
//
////////////////////////////////////////////////////////////////////////////

BOOL ResetTimePrivilege(
    PTOKEN_PRIVILEGES PreviousState,
    ULONG PreviousStateLength)
{
#ifndef WINNT
    return TRUE;
#else
    NTSTATUS NtStatus;
    HANDLE Token;
    LUID SystemTimePrivilege;
    ULONG ReturnLength;

    if (PreviousState == NULL)
    {
        return (FALSE);
    }

    //  Open our own token.
    NtStatus = NtOpenProcessToken( NtCurrentProcess(),
                                   TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                   &Token);
    if (!NT_SUCCESS(NtStatus))
    {
        return (FALSE);
    }

    //  Initialize the adjustment structure.
    SystemTimePrivilege = RtlConvertLongToLuid(SE_SYSTEMTIME_PRIVILEGE);

    //  Restore previous state of the privilege.
    NtStatus = NtAdjustPrivilegesToken( Token,               // TokenHandle
                                        FALSE,               // DisableAllPrivileges
                                        PreviousState,       // NewState
                                        PreviousStateLength, // BufferLength
                                        NULL,                // PreviousState (OPTIONAL)
                                        &ReturnLength );     // ReturnLength

    //  Clean up some stuff before returning.
    LocalFree(PreviousState);
    NtClose(Token);

    return (NT_SUCCESS(NtStatus));
#endif //WINNT
}


////////////////////////////////////////////////////////////////////////////
//
//  DoMessageBox
//
////////////////////////////////////////////////////////////////////////////

int DoMessageBox(
    HWND hWnd,
    DWORD wText,
    DWORD wCaption,
    DWORD wType)
{
    TCHAR szText[2 * MAX_PATH];
    TCHAR szCaption[MAX_PATH];

    if (!LoadString(g_hInst, wText, szText, CharSizeOf(szText)))
    {
        return (0);
    }

    if (!LoadString(g_hInst, wCaption, szCaption, CharSizeOf(szCaption)))
    {
        return (0);
    }

    return ( MessageBox(hWnd, szText, szCaption, wType) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\utc\rc.h ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    rc.h

Abstract:

    This module contains the resource ids for the Date/Time applet.

Revision History:

--*/



#ifdef RC_INVOKED
  #define MAPCTL_CLASSNAME        "CplWorldMapClass"
  #define CALENDAR_CLASS          "CalWndMain"
  #define CLOCK_CLASS             "ClockWndMain"
#else
  #define MAPCTL_CLASSNAME        TEXT("CplWorldMapClass")
  #define CALENDAR_CLASS          TEXT("CalWndMain")
  #define CLOCK_CLASS             TEXT("ClockWndMain")
#endif

#define DLG_DATETIME              1
#define DLG_TIMEZONE              2
#define DLG_ADVANCED              3
#define DLG_DATETIMEWIDE          10

#define IDB_TIMEZONE              50

#define IDD_AUTOMAGIC             100
#define IDD_TIMEZONES             101
#define IDD_TIMEMAP               102
#define IDD_GROUPBOX1             103
#define IDD_GROUPBOX2             104

#define IDI_TIMEDATE              200

#define IDS_TIMEDATE              300
#define IDS_TIMEDATEINFO          301

#define IDS_WARNAUTOTIMECHANGE    302
#define IDS_WATC_CAPTION          303

#define IDS_CAPTION               304
#define IDS_NOTIMEERROR           305

#define IDS_ISRAELTIMEZONE        306
#define IDS_JERUSALEMTIMEZONE     307


// Internet Time Success/Error strings
#define IDS_IT_WAITFORSYNC        500
#define IDS_IT_NEXTSYNC           501
#define IDS_IT_SUCCESS            502
#define IDS_IT_SUCCESS2           503
#define IDS_IT_FAIL1              504
#define IDS_IT_FAIL2              505
#define IDS_IT_FAILLAST           506

#define IDS_TROUBLESHOOT_INTERNETIME 507
#define IDS_ERR_DATETOOWRONG      508
#define IDS_ERR_GETINFO_FAIL      509
#define IDS_NEVER_TRIED_TOSYNC    510
#define IDS_IT_FAIL3              511



//
//  The Order of HOUR, MINUTE, SECOND, MONTH, DAY, and YEAR
//  are critical.
//
#define DATETIME_STATIC			  -1
#define DATETIME                  700
#define DATETIME_HOUR             701
#define DATETIME_MINUTE           702
#define DATETIME_SECOND           703
#define DATETIME_MONTH            704
#define DATETIME_DAY              705
#define DATETIME_YEAR             706
#define DATETIME_TSEP1            707
#define DATETIME_TSEP2            708

#define DATETIME_TARROW           709
#define DATETIME_AMPM             710
#define DATETIME_CALENDAR         711
#define DATETIME_CLOCK            712
#define DATETIME_MONTHNAME        713

#define DATETIME_YARROW           714
#define DATETIME_TBORDER          715
#define DATETIME_CURTZ            716

#define DATETIME_AUTOSETFROMINTERNET        720
#define DATETIME_INTERNET_SERVER_EDIT       721
#define DATETIME_INTERNET_SERVER_LABLE      722
#define DATETIME_INFOTEXTTOP                723
#define DATETIME_INFOTEXTPROXY              724
#define DATETIME_INTERNET_ERRORTEXT         725
#define DATETIME_INTERNET_UPDATENOW         726
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\utc\inettime.cpp ===
/*****************************************************************************\
    FILE: inettime.cpp

    DESCRIPTION:
        This file contains the code used to display UI allowing the user to
    control the feature that updates the computer's clock from an internet
    NTP time server.

    BryanSt 3/22/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "timedate.h"
#include "inettime.h"
#include "rc.h"

#include <wininet.h>
#include <shlwapi.h>
#include <DSGetDC.h>            // For DsGetDcName
#include <help.h>               // For IDH_DATETIME_*
#include <Lm.h>                 // For NetGetJoinInformation() and NETSETUP_JOIN_STATUS
#include <Lmjoin.h>             // For NetGetJoinInformation() and NETSETUP_JOIN_STATUS
#include <shlobj.h>            
#include <shlobjp.h>
#include <w32timep.h>            // For Time APIs

#include <shellp.h>
#include <ccstock.h>
#include <shpriv.h>

#define DECL_CRTFREE
#include <crtfree.h>

#define DISALLOW_Assert             // Force to use ASSERT instead of Assert
#define DISALLOW_DebugMsg           // Force to use TraceMsg instead of DebugMsg
#include <debug.h>



// Reg Keys and Values
#define SZ_REGKEY_DATETIME                      TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\DateTime")
#define SZ_REGKEY_DATETIME_SERVERS              TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\DateTime\\Servers")
#define SZ_REGKEY_W32TIME_SERVICE               TEXT("System\\CurrentControlSet\\Services\\W32Time")
#define SZ_REGKEY_W32TIME_SERVICE_NTPCLIENT     SZ_REGKEY_W32TIME_SERVICE TEXT("\\TimeProviders\\NtpClient")
#define SZ_REGKEY_W32TIME_SERVICE_PARAMETERS    SZ_REGKEY_W32TIME_SERVICE TEXT("\\Parameters")

#define SZ_REGVALUE_INTERNET_FEATURE_AVAILABLE  TEXT("Support Internet Time")
#define SZ_REGVALUE_TEST_SIMULATENODC           TEXT("TestSimulateNoDC")        // Used to simulate home scenarios while we have a domain controller
#define SZ_REGVALUE_W32TIME_SYNCFROMFLAGS       TEXT("Type")
#define SZ_REGVALUE_W32TIME_STARTSERVICE        TEXT("Start")
#define SZ_REGVALUE_NTPSERVERLIST               TEXT("NtpServer")          // Was "ManualPeerList" in Whistler for a little while.

#define SZ_DEFAULT_NTP_SERVER                   TEXT("time.windows.gov")
#define SZ_INDEXTO_CUSTOMHOST                   TEXT("0")
#define SZ_SERVICE_W32TIME                      TEXT("w32time")
#define SZ_DIFFERENT_SYNCFREQUENCY              TEXT(",0x1")

#define SZ_SYNC_BOTH            TEXT("AllSync")
#define SZ_SYNC_DS              TEXT("NT5DS")
#define SZ_SYNC_NTP             TEXT("NTP")
#define SZ_SYNC_NONE            TEXT("NoSync")

#define SYNC_ONCE_PER_WEEK          0x93A80             // This is once a week.  (Sync every this many seconds)

// Flags for "System\CurrentControlSet\Services\W32Time\TimeProviders\NtpClient","SyncFromFlags"
#define NCSF_ManualPeerList     0x01            // This means use internet SNTP servers.
#define NCSF_DomainHierarchy    0x02            // This means get the time 

// this feature is turned off temporarily until we can get the perf hit reduced.
// The problem is that the call to DsGetDcName() can take up to 15 seconds if
// a domain controller can not be found.
#define FEATURE_INTERNET_TIME                   TRUE

#define MAX_URL_STRING      INTERNET_MAX_URL_LENGTH

#define WMUSER_UPDATED_STATUS_TEXT (WM_USER + 11)


// If we aren't using the new w32timep.h, then define it our selves.
// TODO: Nuke this after \nt\ds\ RIs into main.
#ifndef TimeSyncFlag_SoftResync

#define TimeSyncFlag_ReturnResult       0x02
#define TimeSyncFlag_Rediscover         0x04

#define ResyncResult_Success            0x00
#define ResyncResult_ChangeTooBig       0x04

typedef struct _W32TIME_NTP_PEER_INFO { 
    unsigned __int32    ulSize; 
    unsigned __int32    ulResolveAttempts;
    unsigned __int64    u64TimeRemaining;
    unsigned __int64    u64LastSuccessfulSync; 
    unsigned __int32    ulLastSyncError; 
    unsigned __int32    ulLastSyncErrorMsgId; 
    unsigned __int32    ulValidDataCounter;
    unsigned __int32    ulAuthTypeMsgId; 
#ifdef MIDL_PASS
    [string, unique]
    wchar_t            *wszUniqueName; 
#else // MIDL_PASS
    LPWSTR              wszUniqueName;
#endif // MIDL_PASS
    unsigned   char     ulMode;
    unsigned   char     ulStratum; 
    unsigned   char     ulReachability;
    unsigned   char     ulPeerPollInterval;
    unsigned   char     ulHostPollInterval;
}  W32TIME_NTP_PEER_INFO, *PW32TIME_NTP_PEER_INFO; 

typedef struct _W32TIME_NTP_PROVIDER_DATA { 
    unsigned __int32        ulSize; 
    unsigned __int32        ulError; 
    unsigned __int32        ulErrorMsgId; 
    unsigned __int32        cPeerInfo; 
#ifdef MIDL_PASS
    [size_is(cPeerInfo)]
#endif // MIDL_PASS
    W32TIME_NTP_PEER_INFO  *pPeerInfo; 
} W32TIME_NTP_PROVIDER_DATA, *PW32TIME_NTP_PROVIDER_DATA;

#endif // TimeSyncFlag_SoftResync

//============================================================================================================
// *** Globals ***
//============================================================================================================
const static DWORD aInternetTimeHelpIds[] = {
    DATETIME_AUTOSETFROMINTERNET,           IDH_DATETIME_AUTOSETFROMINTERNET,
    DATETIME_INTERNET_SERVER_LABLE,         IDH_DATETIME_SERVER_EDIT,
    DATETIME_INTERNET_SERVER_EDIT,          IDH_DATETIME_SERVER_EDIT,
    DATETIME_INFOTEXTTOP,                   IDH_DATETIME_INFOTEXT,
    DATETIME_INFOTEXTPROXY,                 IDH_DATETIME_INFOTEXT,

    DATETIME_INTERNET_ERRORTEXT,            IDH_DATETIME_INFOTEXT,
    DATETIME_INTERNET_UPDATENOW,            IDH_DATETIME_UPDATEFROMINTERNET,

    0, 0
};

#define SZ_HELPFILE_INTERNETTIME           TEXT("windows.hlp")

#define HINST_THISDLL           g_hInst

BOOL g_fCustomServer;
BOOL g_fWriteAccess = FALSE;                    // Does the user have the ACLs set correctly to change the HKLM setting to turn the service on/off or change the server hostname?
HINSTANCE g_hInstW32Time = NULL;

void _LoadW32Time(void)
{
    if (!g_hInstW32Time)
    {
        g_hInstW32Time = LoadLibrary(TEXT("w32time.dll"));
    }
}


HRESULT StrReplaceToken(IN LPCTSTR pszToken, IN LPCTSTR pszReplaceValue, IN LPTSTR pszString, IN DWORD cchSize)
{
    HRESULT hr = S_OK;
    LPTSTR pszTempLastHalf = NULL;
    LPTSTR pszNextToken = pszString;

    while (0 != (pszNextToken = StrStrI(pszNextToken, pszToken)))
    {
        // We found one.
        LPTSTR pszPastToken = pszNextToken + lstrlen(pszToken);

        Str_SetPtr(&pszTempLastHalf, pszPastToken);      // Keep a copy because we will overwrite it.

        pszNextToken[0] = 0;    // Remove the rest of the string.
        StrCatBuff(pszString, pszReplaceValue, cchSize);
        StrCatBuff(pszString, pszTempLastHalf, cchSize);

        pszNextToken += lstrlen(pszReplaceValue);
    }

    Str_SetPtr(&pszTempLastHalf, NULL);

    return hr;
}


typedef DWORD (* PFNW32TimeSyncNow) (IN LPCWSTR pwszServer, IN ULONG ulWaitFlag, IN ULONG ulFlags);
typedef DWORD (* PFNW32TimeQueryNTPProviderStatus) (IN LPCWSTR pwszServer, IN DWORD dwFlags, IN LPWSTR pwszProvider, OUT W32TIME_NTP_PROVIDER_DATA **ppNTPProviderData);
typedef void (* PFNW32TimeBufferFree) (IN LPVOID pvBuffer);
typedef HRESULT (* PFNW32TimeQueryConfig) (IN DWORD dwProperty, OUT DWORD * pdwType, IN OUT BYTE * pbConfig, IN OUT DWORD * pdwSize);
typedef HRESULT (* PFNW32TimeSetConfig) (IN DWORD dwProperty, IN DWORD dwType, IN BYTE * pbConfig, IN DWORD dwSize);

DWORD W32TimeSyncNowDDLoad(IN LPCWSTR pwszServer, IN ULONG ulWaitFlag, IN ULONG ulFlags)
{
    DWORD dwReturn = ERROR_UNEXP_NET_ERR;

    // Hand delay load until DS RIs.
    _LoadW32Time();
    if (g_hInstW32Time)
    {
        PFNW32TimeSyncNow pfnFunction = (PFNW32TimeSyncNow) GetProcAddress(g_hInstW32Time, "W32TimeSyncNow");

        if (pfnFunction)
        {
            dwReturn = pfnFunction(pwszServer, ulWaitFlag, ulFlags);
        }
    }

    return dwReturn;
}


DWORD W32TimeQueryNTPProviderStatusDDload(IN LPCWSTR pwszServer, IN DWORD dwFlags, IN LPWSTR pwszProvider, OUT W32TIME_NTP_PROVIDER_DATA **ppNTPProviderData)
{
    DWORD dwReturn = ERROR_UNEXP_NET_ERR;

    *ppNTPProviderData = NULL;

    // Hand delay load until DS RIs.
    _LoadW32Time();
    if (g_hInstW32Time)
    {
        PFNW32TimeQueryNTPProviderStatus pfnFunction = (PFNW32TimeQueryNTPProviderStatus) GetProcAddress(g_hInstW32Time, "W32TimeQueryNTPProviderStatus");

        if (pfnFunction)
        {
            dwReturn = pfnFunction(pwszServer, dwFlags, pwszProvider, ppNTPProviderData);
        }
    }

    return dwReturn;
}


void W32TimeBufferFreeDDload(IN LPVOID pvBuffer)
{
    // Hand delay load until DS RIs.
    _LoadW32Time();
    if (g_hInstW32Time)
    {
        PFNW32TimeBufferFree pfnFunction = (PFNW32TimeBufferFree) GetProcAddress(g_hInstW32Time, "W32TimeBufferFree");

        if (pfnFunction)
        {
            pfnFunction(pvBuffer);
        }
    }
}


HRESULT W32TimeQueryConfigDDload(IN DWORD dwProperty, OUT DWORD * pdwType, IN OUT BYTE * pbConfig, IN OUT DWORD * pdwSize)
{
    HRESULT hr = ResultFromWin32(ERROR_PROC_NOT_FOUND);

    // Hand delay load until DS RIs.
    _LoadW32Time();
    if (g_hInstW32Time)
    {
        PFNW32TimeQueryConfig pfnFunction = (PFNW32TimeQueryConfig) GetProcAddress(g_hInstW32Time, "W32TimeQueryConfig");

        if (pfnFunction)
        {
            hr = pfnFunction(dwProperty, pdwType, pbConfig, pdwSize);
        }
    }

    return hr;
}


HRESULT W32TimeSetConfigDDload(IN DWORD dwProperty, IN DWORD dwType, IN BYTE * pbConfig, IN DWORD dwSize)
{
    HRESULT hr = ResultFromWin32(ERROR_PROC_NOT_FOUND);

    // Hand delay load until DS RIs.
    _LoadW32Time();
    if (g_hInstW32Time)
    {
        PFNW32TimeSetConfig pfnFunction = (PFNW32TimeSetConfig) GetProcAddress(g_hInstW32Time, "W32TimeSetConfig");

        if (pfnFunction)
        {
            hr = pfnFunction(dwProperty, dwType, pbConfig, dwSize);
        }
    }

    return hr;
}

// Turn this on when vbl1 RIs and w32timep.h contains W32TimeQueryConfig, W32TimeSetConfig
//#define W32TIME_NEWAPIS


HRESULT GetW32TimeServer(BOOL fRemoveJunk, LPWSTR pszServer, DWORD cchSize)
{
    DWORD dwType = REG_SZ;
    DWORD cbSize = (sizeof(pszServer[0]) * cchSize);
    HRESULT hr = W32TimeQueryConfigDDload(W32TIME_CONFIG_MANUAL_PEER_LIST, &dwType, (BYTE *) pszServer, &cbSize);

    if (ResultFromWin32(ERROR_PROC_NOT_FOUND) == hr)
    {
        DWORD dwError = SHGetValue(HKEY_LOCAL_MACHINE, SZ_REGKEY_W32TIME_SERVICE_PARAMETERS, SZ_REGVALUE_NTPSERVERLIST, NULL, (BYTE *)pszServer, &cbSize);

        hr = ResultFromWin32(dwError);
    }

    if (SUCCEEDED(hr) && fRemoveJunk)
    {
        LPWSTR pszJunk = StrStr(pszServer, L",0x");

        if (pszJunk)
        {
            pszJunk[0] = 0;
        }

        pszJunk = StrStr(pszServer, L" ");
        if (pszJunk)
        {
            pszJunk[0] = 0;
        }
    }

    return hr;
}


HRESULT RemoveDuplicateServers(LPWSTR pszServer, DWORD cchSize)
{
    TCHAR szResults[MAX_URL_STRING];

    StrCpyN(szResults, pszServer, ARRAYSIZE(szResults));

    LPTSTR pszBeginning = szResults;
    LPTSTR pszEnd;
    while (NULL != (pszEnd = StrChr(pszBeginning, TEXT(' '))))
    {
        TCHAR szSearchStr[MAX_PATH];

        StrCpyN(szSearchStr, pszBeginning, (DWORD)min(ARRAYSIZE(szSearchStr), (pszEnd - pszBeginning + 1)));

        pszEnd++;    // Skip past the space

        StrCatBuff(szSearchStr, L" ", ARRAYSIZE(szSearchStr));
        StrReplaceToken(szSearchStr, TEXT(""), pszEnd, (ARRAYSIZE(szResults) - (DWORD)(pszEnd - pszBeginning)));
        szSearchStr[lstrlen(szSearchStr)-1] = 0;
        StrReplaceToken(szSearchStr, TEXT(""), pszEnd, (ARRAYSIZE(szResults) - (DWORD)(pszEnd - pszBeginning)));

        pszBeginning = pszEnd;
    }

    PathRemoveBlanks(szResults);

    StrCpyN(pszServer, szResults, cchSize);
    return S_OK;
}

BOOL ComparePeers(LPTSTR szPeer1, LPTSTR szPeer2) { 
    BOOL   fResult; 
    LPTSTR szFlags1;
    LPTSTR szFlags2;
    TCHAR  szSave1; 
    TCHAR  szSave2; 

    szFlags1 = StrChr(szPeer1, TEXT(',')); 
    if (NULL == szFlags1) 
    {
	szFlags1 = StrChr(szPeer1, TEXT(' ')); 
    }
    szFlags2 = StrChr(szPeer2, TEXT(','));
    if (NULL == szFlags2)
    {
	szFlags2 = StrChr(szPeer2, TEXT(' '));
    }

    if (NULL != szFlags1) { 
	szSave1 = szFlags1[0]; 
	szFlags1[0] = TEXT('\0'); 
    }
    if (NULL != szFlags2) { 
	szSave2 = szFlags2[0]; 
	szFlags2[0] = TEXT('\0'); 
    }

    fResult = 0 == StrCmpI(szPeer1, szPeer2); 

    if (NULL != szFlags1) { 
	szFlags1[0] = szSave1; 
    }
    if (NULL != szFlags2) { 
	szFlags2[0] = szSave2; 
    }

    return fResult; 
}

BOOL ContainsServer(LPWSTR pwszServerList, LPWSTR pwszServer) 
{
    DWORD dwNextServerOffset = 0; 
    LPWSTR pwszNext = pwszServerList; 

    while (NULL != pwszNext) 
    { 
	pwszNext += dwNextServerOffset; 
	if (ComparePeers(pwszNext, pwszServer)) 
	{ 
	    return TRUE; 
	}

	pwszNext = StrChr(pwszNext, TEXT(' ')); 
	dwNextServerOffset = 1; 
    }

    return FALSE; 
}


HRESULT AddTerminators(LPWSTR pszServer, DWORD cchSize)
{
    TCHAR szServer[MAX_URL_STRING];
    TCHAR szTemp[MAX_URL_STRING];

    szTemp[0] = 0;
    StrCpyN(szServer, pszServer, ARRAYSIZE(szServer));

    LPTSTR pszBeginning = szServer;
    LPTSTR pszEnd;
    while (NULL != (pszEnd = StrChr(pszBeginning, TEXT(' '))))
    {
        TCHAR szTemp2[MAX_PATH];

        pszEnd[0] = 0;

        if (!StrStrI(pszBeginning, L",0x"))
        {
            wnsprintf(szTemp2, ARRAYSIZE(szTemp2), TEXT("%s,0x1 "), pszBeginning);
            StrCatBuff(szTemp, szTemp2, ARRAYSIZE(szTemp));
        }
        else
        {
            StrCatBuff(szTemp, pszBeginning, ARRAYSIZE(szTemp));
            StrCatBuff(szTemp, L" ", ARRAYSIZE(szTemp));
        }

        pszBeginning = &pszEnd[1];
    }

    StrCatBuff(szTemp, pszBeginning, ARRAYSIZE(szTemp));
    if (pszBeginning[0] && szTemp[0] && !StrStrI(pszBeginning, L",0x"))
    {
        // We need to indicate which kind of sync method
        StrCatBuff(szTemp, L",0x1", ARRAYSIZE(szTemp));
    }

    StrCpyN(pszServer, szTemp, cchSize);
    return S_OK;
}


HRESULT SetW32TimeServer(LPCWSTR pszServer)
{
    TCHAR szServer[MAX_PATH];

    StrCpyN(szServer, pszServer, ARRAYSIZE(szServer));
    AddTerminators(szServer, ARRAYSIZE(szServer));
    RemoveDuplicateServers(szServer, ARRAYSIZE(szServer));

    DWORD cbSize = ((lstrlen(szServer) + 1) * sizeof(szServer[0]));
    HRESULT hr = W32TimeSetConfigDDload(W32TIME_CONFIG_MANUAL_PEER_LIST, REG_SZ, (BYTE *) szServer, cbSize);
    if (ResultFromWin32(ERROR_PROC_NOT_FOUND) == hr)
    {
        DWORD dwError = SHSetValue(HKEY_LOCAL_MACHINE, SZ_REGKEY_W32TIME_SERVICE_PARAMETERS, SZ_REGVALUE_NTPSERVERLIST, REG_SZ, (BYTE *)szServer, cbSize);

        hr = ResultFromWin32(dwError);
    }

    return hr;
}


HRESULT SetW32TimeSyncFreq(DWORD dwSyncFreq)
{
#ifndef W32TIME_NEWAPIS
    return S_OK;
#else // W32TIME_NEWAPIS
    return W32TimeSetConfig(W32TIME_CONFIG_SPECIAL_POLL_INTERVAL, REG_DWORD, (BYTE *) dwSyncFreq, sizeof(dwSyncFreq));
#endif // W32TIME_NEWAPIS
}



enum eBackgroundThreadAction
{
    eBKAWait        = 0,            // The bkthread should wait for a command
    eBKAGetInfo,                    // The bkthread should get the info on the last sync
    eBKAUpdate,                     // The bkthread should start synching
    eBKAUpdating,                   // The bkthread is synching now
    eBKAQuit,                       // The bkthread should shut down
};

class CInternetTime
{
public:
    // Forground methods
    BOOL IsInternetTimeAvailable(void);
    HRESULT AddInternetPage(void);

    INT_PTR _AdvancedDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

    CInternetTime(HWND hDlg, HWND hwndDate);
    virtual ~CInternetTime(void);


    // Background methods
    void AsyncCheck(void);

private:

    // Private Member Variables
    HWND m_hDlg;                               // hwnd of parent (property sheet).
    HWND m_hwndDate;                           // Date tab hwnd
    HWND m_hwndInternet;                       // InternetTime tab hwnd
    HCURSOR m_hCurOld;                         // The old cursor while we display the wait cursor
    LPTSTR m_pszStatusString;                  // CROSS-THREAD: This is used to pass between threads.
    LPTSTR m_pszNextSyncTime;                  // CROSS-THREAD: This is used to pass between threads.
    eBackgroundThreadAction m_eAction;         // CROSS-THREAD: This is used to pass between threads.

    // Private Member Functions
    // Forground methods
    HRESULT _InitAdvancedPage(HWND hDlg);
    HRESULT _OnUpdateButton(void);
    HRESULT _OnUpdateStatusString(void);
    HRESULT _OnSetFeature(HWND hDlg, BOOL fOn);
    HRESULT _OnToggleFeature(HWND hDlg);
    HRESULT _GoGetHelp(void);
    HRESULT _ResetServer(void);
    HRESULT _PersistInternetTimeSettings(HWND hDlg);
    HRESULT _StartServiceAndRefresh(BOOL fStartIfOff);

    INT_PTR _OnCommandAdvancedPage(HWND hDlg, WPARAM wParam, LPARAM lParam);
    INT_PTR _OnNotifyAdvancedPage(HWND hDlg, NMHDR * pNMHdr, int idControl);

    // Background methods
    HRESULT _ProcessBkThreadActions(void);
    HRESULT _SyncNow(BOOL fOnlyUpdateInfo);
    HRESULT _CreateW32TimeSuccessErrorString(DWORD dwError, LPTSTR pszString, DWORD cchSize, LPTSTR pszNextSync, DWORD cchNextSyncSize, LPTSTR pszServerToQuery);
    HRESULT _GetDateTimeString(FILETIME * pftTimeDate, BOOL fDate, LPTSTR pszString, DWORD cchSize);
};


CInternetTime * g_pInternetTime = NULL;



// This function is called on the forground thread.
CInternetTime::CInternetTime(HWND hDlg, HWND hwndDate)
{
    m_hDlg = hDlg;
    m_hwndDate = hwndDate;
    m_eAction = eBKAGetInfo;
    m_pszStatusString = NULL;
    m_hwndInternet = NULL;
    m_hCurOld = NULL;

    m_pszStatusString = NULL;
    m_pszNextSyncTime = NULL;
}


CInternetTime::~CInternetTime()
{
ENTERCRITICAL;
    if (m_pszStatusString)
    {
        LocalFree(m_pszStatusString);
        m_pszStatusString = NULL;
    }

    if (m_pszNextSyncTime)
    {
        LocalFree(m_pszNextSyncTime);
        m_pszNextSyncTime = NULL;
    }

    if (m_hCurOld)
    {
        SetCursor(m_hCurOld);
        m_hCurOld = NULL;
    }
LEAVECRITICAL;
}



HRESULT FormatMessageWedge(LPCWSTR pwzTemplate, LPWSTR pwzStrOut, DWORD cchSize, ...)
{
    va_list vaParamList;
    HRESULT hr = S_OK;

    va_start(vaParamList, cchSize);
    if (0 == FormatMessageW(FORMAT_MESSAGE_FROM_STRING, pwzTemplate, 0, 0, pwzStrOut, cchSize, &vaParamList))
    {
        hr = ResultFromLastError();
    }

    va_end(vaParamList);
    return hr;
}



/////////////////////////////////////////////////////////////////////
// Private Internal Helpers
/////////////////////////////////////////////////////////////////////
// This function is called on the forground thread.
HRESULT CInternetTime::_OnSetFeature(HWND hDlg, BOOL fOn)
{
    HWND hwndOnOffCheckbox = GetDlgItem(m_hwndInternet, DATETIME_AUTOSETFROMINTERNET);
    HWND hwndServerLable = GetDlgItem(m_hwndInternet, DATETIME_INTERNET_SERVER_LABLE);
    HWND hwndServerEdit = GetDlgItem(m_hwndInternet, DATETIME_INTERNET_SERVER_EDIT);

    CheckDlgButton(hDlg, DATETIME_AUTOSETFROMINTERNET, (fOn ? BST_CHECKED : BST_UNCHECKED));
    EnableWindow(hwndOnOffCheckbox, g_fWriteAccess);
    EnableWindow(hwndServerLable, (g_fWriteAccess ? fOn : FALSE));
    EnableWindow(hwndServerEdit, (g_fWriteAccess ? fOn : FALSE));
    EnableWindow(GetDlgItem(m_hwndInternet, DATETIME_INTERNET_ERRORTEXT), (g_fWriteAccess ? fOn : FALSE));
    EnableWindow(GetDlgItem(m_hwndInternet, DATETIME_INTERNET_UPDATENOW), (g_fWriteAccess ? fOn : FALSE));
    EnableWindow(GetDlgItem(m_hwndInternet, DATETIME_INFOTEXTTOP), (g_fWriteAccess ? fOn : FALSE));

    if (fOn)
    {
        // If the user just turned on the feature and the editbox is empty,
        // replace the text with the default server name.
        TCHAR szServer[INTERNET_MAX_HOST_NAME_LENGTH];

        if (!GetWindowText(hwndServerEdit, szServer, ARRAYSIZE(szServer)) ||
            !szServer[0])
        {
            SetWindowText(hwndServerEdit, SZ_DEFAULT_NTP_SERVER);
        }
    }

    return S_OK;
}


// This function is called on the forground thread.
HRESULT CInternetTime::_OnToggleFeature(HWND hDlg)
{
    BOOL fIsFeatureOn = ((BST_CHECKED == IsDlgButtonChecked(hDlg, DATETIME_AUTOSETFROMINTERNET)) ? TRUE : FALSE);
    PropSheet_Changed(GetParent(hDlg), hDlg);   // Say we need to enable the apply button

    return _OnSetFeature(hDlg, fIsFeatureOn);
}


// This function is called on the forground thread.
HRESULT AddServerList(HWND hwndCombo, HKEY hkey, int nIndex)
{
    TCHAR szServer[INTERNET_MAX_HOST_NAME_LENGTH];
    DWORD cbSizeServer = sizeof(szServer);
    TCHAR szIndex[MAX_PATH];
    DWORD dwType;

    wnsprintf(szIndex, ARRAYSIZE(szIndex), TEXT("%d"), nIndex);

    DWORD dwError = SHGetValue(hkey, NULL, szIndex, &dwType, (void *)szServer, &cbSizeServer);
    HRESULT hr = ResultFromWin32(dwError);
    if (SUCCEEDED(hr))
    {
        LPTSTR pszFlags = StrStr(szServer, SZ_DIFFERENT_SYNCFREQUENCY);

        if (pszFlags)
        {
            pszFlags[0] = 0;        // Remove the flags.
        }

        dwError = ComboBox_AddString(hwndCombo, szServer);
        if ((dwError == CB_ERR) || (dwError == CB_ERRSPACE))
        {
            hr = E_FAIL;
        }
    }

    return hr;
}


// This function is called on the forground thread.
HRESULT PopulateComboBox(IN HWND hwndCombo, IN BOOL * pfCustomServer)
{
    HRESULT hr;
    HKEY hkey;

    *pfCustomServer = FALSE;

    DWORD dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZ_REGKEY_DATETIME_SERVERS, 0, KEY_READ, &hkey);
    hr = ResultFromWin32(dwError);
    if (SUCCEEDED(hr))
    {
        // Try to add the custom slot.
        if (SUCCEEDED(AddServerList(hwndCombo, hkey, 0)))
        {
            // We do have an existing custom server, so let the caller know so
            // they know to increase the index by 1.
            *pfCustomServer = TRUE;
        }

        for (int nIndex = 1; SUCCEEDED(hr); nIndex++)
        {
            hr = AddServerList(hwndCombo, hkey, nIndex);
        }
    
        RegCloseKey(hkey);
    }

    return hr;
}


// This function is called on the forground thread.
HRESULT CInternetTime::_OnUpdateButton(void)
{
    HRESULT hr = S_OK;

ENTERCRITICAL;
    // We don't need to do anything if it's already working on another task.
    if (eBKAWait == m_eAction)
    {
        TCHAR szMessage[2 * MAX_PATH];
        TCHAR szTemplate[MAX_PATH];
        TCHAR szServer[MAX_PATH];

        if (!m_hCurOld)
        {
            m_hCurOld = SetCursor(LoadCursor(NULL, IDC_WAIT));
        }

        LoadString(HINST_THISDLL, IDS_IT_WAITFORSYNC, szTemplate, ARRAYSIZE(szTemplate));
        GetWindowText(GetDlgItem(m_hwndInternet, DATETIME_INTERNET_SERVER_EDIT), szServer, ARRAYSIZE(szServer));
        FormatMessageWedge(szTemplate, szMessage, ARRAYSIZE(szMessage), szServer);

        SetWindowText(GetDlgItem(m_hwndInternet, DATETIME_INTERNET_ERRORTEXT), szMessage);

        m_eAction = eBKAUpdate;
    }
LEAVECRITICAL;

    return hr;
}


// This function is called on the forground thread.
BOOL IsManualPeerListOn(void)
{
    BOOL fIsManualPeerListOn = TRUE;
    TCHAR szSyncType[MAX_PATH];
    DWORD cbSize = sizeof(szSyncType);
    DWORD dwType;

    if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, SZ_REGKEY_W32TIME_SERVICE_PARAMETERS, SZ_REGVALUE_W32TIME_SYNCFROMFLAGS, &dwType, (LPBYTE)szSyncType, &cbSize))
    {
        if (!StrCmpI(szSyncType, SZ_SYNC_DS) || !StrCmpI(szSyncType, SZ_SYNC_NONE))
        {
            fIsManualPeerListOn = FALSE;
        }
    }

    return fIsManualPeerListOn;
}


// This function is called on the forground thread.
HRESULT CInternetTime::_InitAdvancedPage(HWND hDlg)
{
    DWORD dwType;
    TCHAR szIndex[MAX_PATH];
    HWND hwndServerEdit = GetDlgItem(hDlg, DATETIME_INTERNET_SERVER_EDIT);
    HWND hwndOnOffCheckbox = GetDlgItem(hDlg, DATETIME_AUTOSETFROMINTERNET);
    DWORD cbSize = sizeof(szIndex);
    BOOL fIsFeatureOn = IsManualPeerListOn();

    m_hwndInternet = hDlg;
    HRESULT hr = PopulateComboBox(hwndServerEdit, &g_fCustomServer);

    // Does the user have access to change the setting in the registry?
    HKEY hKeyTemp;
    g_fWriteAccess = FALSE;
    DWORD dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZ_REGKEY_W32TIME_SERVICE_PARAMETERS, 0, KEY_WRITE, &hKeyTemp);
    if (ERROR_SUCCESS == dwError)
    {
        // We have access to read & write so we can enable the UI.
        RegCloseKey(hKeyTemp);
        dwError = RegCreateKeyEx(HKEY_LOCAL_MACHINE, SZ_REGKEY_DATETIME, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKeyTemp, NULL);
        if (ERROR_SUCCESS == dwError)
        {
            RegCloseKey(hKeyTemp);
            dwError = RegCreateKeyEx(HKEY_LOCAL_MACHINE, SZ_REGKEY_DATETIME_SERVERS, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKeyTemp, NULL);
            if (ERROR_SUCCESS == dwError)
            {
                g_fWriteAccess = TRUE;
                RegCloseKey(hKeyTemp);
            }
        }
    }

    dwError = SHGetValue(HKEY_LOCAL_MACHINE, SZ_REGKEY_DATETIME_SERVERS, NULL, &dwType, (void *) szIndex, &cbSize);
    hr = ResultFromWin32(dwError);
    if (SUCCEEDED(hr))
    {
        int nIndex = StrToInt(szIndex);

        if (!g_fCustomServer)
        {
            nIndex -= 1;        // We don't have slot zero (the custom server), so reduce the index.
        }

        ComboBox_SetCurSel(hwndServerEdit, nIndex);
    }

    _OnSetFeature(hDlg, fIsFeatureOn);

    if (fIsFeatureOn)
    {
        // The feature is on, so select the text and set focus
        // to the combobox.
        ComboBox_SetEditSel(hwndServerEdit, 0, (LPARAM)-1);     // Select all the Text
        SetFocus(hwndServerEdit); 
    }
    else
    {
        // The feature is off so set focus to the checkbox.
        SetFocus(hwndOnOffCheckbox); 
    }

ENTERCRITICAL;
    if (m_pszStatusString)
    {
        SetWindowText(GetDlgItem(m_hwndInternet, DATETIME_INTERNET_ERRORTEXT), m_pszStatusString);
    }

    if (m_pszNextSyncTime)
    {
        SetWindowText(GetDlgItem(m_hwndInternet, DATETIME_INFOTEXTTOP), m_pszNextSyncTime);
    }
LEAVECRITICAL;

    return S_OK;
}


// This function is called on the background thread.
HRESULT SetSyncFlags(DWORD dwSyncFromFlags)
{
    LPCTSTR pszFlags = SZ_SYNC_BOTH;

    switch (dwSyncFromFlags)
    {
    case NCSF_DomainHierarchy:
        pszFlags = SZ_SYNC_DS;
        break;
    case NCSF_ManualPeerList:
        pszFlags = SZ_SYNC_NTP;
        break;
    case 0x00000000:
        pszFlags = SZ_SYNC_NONE;
        break;
    };

    DWORD cbSize = ((lstrlen(pszFlags) + 1) * sizeof(pszFlags[0]));
    DWORD dwError = SHSetValue(HKEY_LOCAL_MACHINE, SZ_REGKEY_W32TIME_SERVICE_PARAMETERS, SZ_REGVALUE_W32TIME_SYNCFROMFLAGS, REG_SZ, (LPBYTE)pszFlags, cbSize);
    HRESULT hr = ResultFromWin32(dwError);

    return hr;
}


/*****************************************************************************\
    DESCRIPTION:

    The following reg keys determine if the W32Time service is on or off:
    HKLM,"System\CurrentControlSet\Services\W32Time\"
          "Start", 0x00000002 (Manual?) 0x0000003 (Automatic?)
          "Type", 0x00000020 (Nt5Ds?) 0x0000120 (NTP?)
    HKLM,"System\CurrentControlSet\Services\W32Time\Parameters"
          "LocalNTP", 0x00000000 (Off) 0x0000001 (On)
          "Type", "Nt5Ds" (NTP off) "NTP" (NTP?)
    HKLM,"System\CurrentControlSet\Services\W32Time\TimeProviders\NTPClient"
          "SyncFromFlags", 0x00000001 (???) 0x0000002 (???)
  
    The following reg keys determine which NTP server to use:
    HKLM,"System\CurrentControlSet\Services\W32Time\TimeProviders\NTPClient"
          "ManualPeerList", REG_SZ_EXPAND "time.nist.gov"
\*****************************************************************************/
// This function is called on the forground thread.
HRESULT CInternetTime::_PersistInternetTimeSettings(HWND hDlg)
{
    BOOL fIsFeatureOn = ((BST_CHECKED == IsDlgButtonChecked(hDlg, DATETIME_AUTOSETFROMINTERNET)) ? TRUE : FALSE);
    DWORD dwSyncFromFlags = (fIsFeatureOn ? NCSF_ManualPeerList : 0 /*none*/ );
    DWORD dwError;
    DWORD cbSize;

    HRESULT hr = SetSyncFlags(dwSyncFromFlags);

    HWND hwndServerEdit = GetDlgItem(hDlg, DATETIME_INTERNET_SERVER_EDIT);

    // No, so the editbox has a customer server.  We need to store the custom server.
    TCHAR szServer[INTERNET_MAX_HOST_NAME_LENGTH];
    TCHAR szServerReg[INTERNET_MAX_HOST_NAME_LENGTH];

    szServer[0] = 0;
    GetWindowText(hwndServerEdit, szServer, ARRAYSIZE(szServer));         

    // Here, we want to detect the case where someone typed in the same name as
    // in the drop down list.  So if "time.nist.gov" is in the list, we want to
    // select it instead of saving another "time.nist.gov" in the custom slot.
    int nDup = ComboBox_FindString(hwndServerEdit, 0, szServer);
    if (CB_ERR != nDup)
    {
        ComboBox_SetCurSel(hwndServerEdit, nDup);
    }

    // The ",0x1" denotes that we want to sync less frequently and not use the NTP RFC's
    // sync frequency.
    StrCpyN(szServerReg, szServer, ARRAYSIZE(szServerReg));
    StrCatBuff(szServerReg, SZ_DIFFERENT_SYNCFREQUENCY, ARRAYSIZE(szServerReg));

    // Write the default server name into "ManualPeerList", which is where the
    // service reads it from.
    SetW32TimeServer(szServerReg);
    if (!StrCmpI(szServerReg, L"time.windows.com"))
    {
        // We need time.windows.com to scale to a large number of users, so don't let it sync more frequently
        // than once a week.
        SetW32TimeSyncFreq(SYNC_ONCE_PER_WEEK);
    }

    int nIndex = ComboBox_GetCurSel(hwndServerEdit);
    if (CB_ERR == nIndex)                // Is anything selected?
    {
        cbSize = ((lstrlenW(szServer) + 1) * sizeof(szServer[0]));
        dwError = SHSetValueW(HKEY_LOCAL_MACHINE, SZ_REGKEY_DATETIME_SERVERS, SZ_INDEXTO_CUSTOMHOST, REG_SZ, (void *)szServer, cbSize);

        nIndex = 0;
    }
    else
    {
        if (!g_fCustomServer)
        {
            nIndex += 1;        // Push the index down by one because the listbox doesn't have a custom server
        }
    }

    TCHAR szIndex[MAX_PATH];
    wnsprintf(szIndex, ARRAYSIZE(szIndex), TEXT("%d"), nIndex);

    cbSize = ((lstrlenW(szIndex) + 1) * sizeof(szIndex[0]));
    dwError = SHSetValueW(HKEY_LOCAL_MACHINE, SZ_REGKEY_DATETIME_SERVERS, NULL, REG_SZ, (void *)szIndex, cbSize);

    _StartServiceAndRefresh(fIsFeatureOn);      // Make sure the service is on and make it update it's settings.

    return S_OK;
}


// This function is called on either the forground or background thread.
HRESULT CInternetTime::_StartServiceAndRefresh(BOOL fStartIfOff)
{
    HRESULT hr = S_OK;

    // We need to let the service know that settings may have changed.  If the user
    // wanted this feature on, then we should make sure the service starts.
    SC_HANDLE hServiceMgr = OpenSCManager(NULL, NULL, (SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE | SC_MANAGER_QUERY_LOCK_STATUS));
    if (hServiceMgr)
    {
        SC_HANDLE hService = OpenService(hServiceMgr, SZ_SERVICE_W32TIME, (/*SERVICE_START |*/ SERVICE_PAUSE_CONTINUE));
        DWORD dwServiceStartMode = 0x00000002;         // This will cause the service to start Automatically on reboot.

        DWORD dwError = SHSetValueW(HKEY_LOCAL_MACHINE, SZ_REGKEY_W32TIME_SERVICE, SZ_REGVALUE_W32TIME_STARTSERVICE, REG_DWORD, &dwServiceStartMode, sizeof(dwServiceStartMode));
        if (hService)
        {
            SERVICE_STATUS serviceStatus = {0};
            BOOL fSucceeded;

            if (fStartIfOff)
            {
                // We should start up the service in case it's not turned on.
                fSucceeded = StartService(hService, 0, NULL);
                hr = (fSucceeded ? S_OK : ResultFromLastError());
                if (ResultFromWin32(ERROR_SERVICE_ALREADY_RUNNING) == hr)
                {
                    hr = S_OK;  // We can ignore this err value because it's benign.
                }
            }

            // Tell the service to re-read the registry entry settings.
            fSucceeded = ControlService(hService, SERVICE_CONTROL_PARAMCHANGE, &serviceStatus);

            CloseServiceHandle(hService);
        }
        else
        {
            hr = ResultFromLastError();
        }

        CloseServiceHandle(hServiceMgr);
    }
    else
    {
        hr = ResultFromLastError();
    }

    return hr;
}


HRESULT CInternetTime::_OnUpdateStatusString(void)
{
    HRESULT hr = S_OK;

ENTERCRITICAL;       // Be safe while using m_pszStatusString
    SetWindowText(GetDlgItem(m_hwndInternet, DATETIME_INTERNET_ERRORTEXT), (m_pszStatusString ? m_pszStatusString : TEXT("")));
    SetWindowText(GetDlgItem(m_hwndInternet, DATETIME_INFOTEXTTOP), (m_pszNextSyncTime ? m_pszNextSyncTime : TEXT("")));

    if (m_hCurOld)
    {
        SetCursor(m_hCurOld);
        m_hCurOld = NULL;
    }
LEAVECRITICAL;

    return S_OK;
}


HRESULT HrShellExecute(HWND hwnd, LPCTSTR lpVerb, LPCTSTR lpFile, LPCTSTR lpParameters, LPCTSTR lpDirectory, INT nShowCmd)
{
    HRESULT hr = S_OK;
    HINSTANCE hReturn = ShellExecute(hwnd, lpVerb, lpFile, lpParameters, lpDirectory, nShowCmd);

    if ((HINSTANCE)32 > hReturn)
    {
        hr = ResultFromLastError();
    }

    return hr;
}


// This function is called on the forground thread.
HRESULT CInternetTime::_GoGetHelp(void)
{
    HRESULT hr = S_OK;
    TCHAR szCommand[MAX_PATH];

    LoadString(HINST_THISDLL, IDS_TROUBLESHOOT_INTERNETIME, szCommand, ARRAYSIZE(szCommand));
    HrShellExecute(m_hwndDate, NULL, szCommand, NULL, NULL, SW_NORMAL);

    return S_OK;
}


// This function is called on the forground thread.
INT_PTR CInternetTime::_OnCommandAdvancedPage(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    BOOL fHandled = 1;   // Not handled (WM_COMMAND seems to be different)
    WORD wMsg = GET_WM_COMMAND_CMD(wParam, lParam);
    WORD idCtrl = GET_WM_COMMAND_ID(wParam, lParam);

    switch (idCtrl)
    {
    case DATETIME_AUTOSETFROMINTERNET:
        switch (wMsg)
        {
            case BN_CLICKED:
                _OnToggleFeature(hDlg);
                break;
        }
        break;

    case DATETIME_INTERNET_SERVER_EDIT:
        switch (wMsg)
        {
            case EN_CHANGE:
            case CBN_EDITCHANGE:
            case CBN_SELCHANGE:
                PropSheet_Changed(GetParent(hDlg), hDlg);
                break;
        }
        break;

    case DATETIME_INTERNET_UPDATENOW:
        switch (wMsg)
        {
            case BN_CLICKED:
                _OnUpdateButton();
                break;
        }
        break;
    }

    return fHandled;
}


// This function is called on the forground thread.
INT_PTR CInternetTime::_OnNotifyAdvancedPage(HWND hDlg, NMHDR * pNMHdr, int idControl)
{
    BOOL fHandled = 1;   // Not handled (WM_COMMAND seems to be different)

    if (pNMHdr)
    {
        switch (pNMHdr->idFrom)
        {
        case 0:
        {
            switch (pNMHdr->code)
            {
            case PSN_APPLY:
                _PersistInternetTimeSettings(hDlg);
                break;
            }
            break;
        }
        default:
            switch (pNMHdr->code)
            {
            case NM_RETURN:
            case NM_CLICK:
            {
                PNMLINK pNMLink = (PNMLINK) pNMHdr;

                if (!StrCmpW(pNMLink->item.szID, L"HelpMe"))
                {
                    _GoGetHelp();
                }
                break;
            }
            }
            break;
        }
    }

    return fHandled;
}


// This function is called on the forground thread.
EXTERN_C INT_PTR CALLBACK AdvancedDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (g_pInternetTime)
    {
        return g_pInternetTime->_AdvancedDlgProc(hDlg, uMsg, wParam, lParam);
    }

    return (TRUE);
}


// This function is called on the forground thread.
INT_PTR CInternetTime::_AdvancedDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            _InitAdvancedPage(hDlg);
            break;

        case WM_DESTROY:
            break;

        case WM_NOTIFY:
            _OnNotifyAdvancedPage(hDlg, (NMHDR *)lParam, (int) wParam);
            break;

        case WM_COMMAND:
            _OnCommandAdvancedPage(hDlg, wParam, lParam);
            break;

        case WMUSER_UPDATED_STATUS_TEXT:
            _OnUpdateStatusString();
            break;

        case WM_HELP:
            WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle, SZ_HELPFILE_INTERNETTIME, HELP_WM_HELP, (DWORD_PTR)  aInternetTimeHelpIds);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, SZ_HELPFILE_INTERNETTIME, HELP_CONTEXTMENU, (DWORD_PTR)  aInternetTimeHelpIds);
            break;

        default:
            return FALSE;
    }

    return (TRUE);
}



// This function is called on the forground thread.
HRESULT CInternetTime::AddInternetPage(void)
{
    HRESULT hr = S_OK;
    PROPSHEETPAGE pspAdvanced;
    INITCOMMONCONTROLSEX initComctl32;

    initComctl32.dwSize = sizeof(initComctl32); 
    initComctl32.dwICC = (ICC_STANDARD_CLASSES | ICC_LINK_CLASS); 

    InitCommonControlsEx(&initComctl32);     // Register the comctl32 LinkWindow

    pspAdvanced.dwSize = sizeof(PROPSHEETPAGE);
    pspAdvanced.dwFlags = PSP_DEFAULT;
    pspAdvanced.hInstance = HINST_THISDLL;
    pspAdvanced.pszTemplate = MAKEINTRESOURCE(DLG_ADVANCED);
    pspAdvanced.pfnDlgProc = AdvancedDlgProc;
    pspAdvanced.lParam = (LPARAM) this;

    if (IsWindow(m_hDlg))
    {
        HPROPSHEETPAGE hPropSheet = CreatePropertySheetPage(&pspAdvanced);
        if (hPropSheet)
        {
            PropSheet_AddPage(m_hDlg, hPropSheet);
        }
    }

    return hr;
}





/////////////////////////////////////////////////////////////////////
// Background Thread Functions
/////////////////////////////////////////////////////////////////////


///////////
// These functions will cause the background thread to sync
///////////

#define SECONDS_FROM_100NS            10000000


//     ulResolveAttempts      --  the number of times the NTP provider has attempted to 
//                                resolve this peer unsuccessfully.  Setting this 
//                                value to 0 indicates that the peer has been successfully
//                                resolved. 
//     u64TimeRemaining       --  the number of 100ns intervals until the provider will
//                                poll this peer again
//     u64LastSuccessfulSync  --  the number of 100ns intervals since (0h 1-Jan 1601)
//     ulLastSyncError        --  S_OK if the last sync with this peer was successful, otherwise, 
//                                the error that occurred attempting to sync
//     ulLastSyncErrorMsgId   --  the resource identifier of a string representing the last
//                                error that occurred syncing from this peer.  0 if there is no
//                                string associated with this error. 
// This function is called on the background thread.
HRESULT W32TimeGetErrorInfoWrap(UINT * pulResolveAttempts, ULONG * pulValidDataCounter, UINT64 * pu64TimeRemaining, UINT64 * pu64LastSuccessfulSync, HRESULT * phrLastSyncError,
                                UINT * pulLastSyncErrorMsgId, LPTSTR pszServer, DWORD cchSize, LPTSTR pszServerToQuery)
{
    HRESULT hr = S_OK;

    *pulResolveAttempts = 0;
    *pulValidDataCounter = 0;
    *pu64TimeRemaining = 0;
    *pu64LastSuccessfulSync = 0;
    *phrLastSyncError = E_FAIL;
    *pulLastSyncErrorMsgId = 0;
    pszServer[0] = 0;

    // NOTE: Server should return ERROR_TIME_SKEW if time is too far out of date to sync.
    W32TIME_NTP_PROVIDER_DATA * pProviderInfo = NULL; 
    
    DWORD dwError = W32TimeQueryNTPProviderStatusDDload(SZ_COMPUTER_LOCAL, 0, SZ_NTPCLIENT, &pProviderInfo);
    if ((ERROR_SUCCESS == dwError) && pProviderInfo)
    {
        *phrLastSyncError = pProviderInfo->ulError;
        *pulLastSyncErrorMsgId = pProviderInfo->ulErrorMsgId;

	DWORD dwMostRecentlySyncdPeerIndex = 0xFFFFFFFF; 
	UINT64 u64LastSuccessfulSync = 0; 
        for (DWORD dwIndex = 0; dwIndex < pProviderInfo->cPeerInfo; dwIndex++)
	{ 
	    // Only want to query those peers which we explictly sync'd from.  
	    // If we haven't explicitly requested a sync, we'll just take the most recently sync'd peer. 
	    if (NULL == pszServerToQuery || ComparePeers(pszServerToQuery, pProviderInfo->pPeerInfo[dwIndex].wszUniqueName))
	    {
		if (u64LastSuccessfulSync <= pProviderInfo->pPeerInfo[dwIndex].u64LastSuccessfulSync)
		{
		    dwMostRecentlySyncdPeerIndex = dwIndex; 
		    u64LastSuccessfulSync = pProviderInfo->pPeerInfo[dwIndex].u64LastSuccessfulSync; 
		}
	    }
	}

	if (dwMostRecentlySyncdPeerIndex < pProviderInfo->cPeerInfo && pProviderInfo->pPeerInfo)
        {
            *pulResolveAttempts = pProviderInfo->pPeerInfo[dwMostRecentlySyncdPeerIndex].ulResolveAttempts;
            *pulValidDataCounter = pProviderInfo->pPeerInfo[dwMostRecentlySyncdPeerIndex].ulValidDataCounter;
            *pu64TimeRemaining = pProviderInfo->pPeerInfo[dwMostRecentlySyncdPeerIndex].u64TimeRemaining;
            *pu64LastSuccessfulSync = pProviderInfo->pPeerInfo[dwMostRecentlySyncdPeerIndex].u64LastSuccessfulSync;
            *phrLastSyncError = pProviderInfo->pPeerInfo[dwMostRecentlySyncdPeerIndex].ulLastSyncError;
            *pulLastSyncErrorMsgId = pProviderInfo->pPeerInfo[dwMostRecentlySyncdPeerIndex].ulLastSyncErrorMsgId;

            if (pProviderInfo->pPeerInfo[dwMostRecentlySyncdPeerIndex].wszUniqueName)
            {
                StrCpyN(pszServer, pProviderInfo->pPeerInfo[dwMostRecentlySyncdPeerIndex].wszUniqueName, cchSize);
                
		// Strip off non-user friendly information which may have been tacked on to the peer name:
                LPTSTR pszJunk = StrStrW(pszServer, L" (");
                if (pszJunk)
                {
                    pszJunk[0] = 0;
                }
		pszJunk = StrStrW(pszServer, L","); 
		if (pszJunk)
		{
		    pszJunk[0] = 0;
		}
            }
        }
	else
	{
	    *phrLastSyncError = HRESULT_FROM_WIN32(ERROR_TIMEOUT); 
	    if (NULL != pszServerToQuery) 
	    {
                StrCpyN(pszServer, pszServerToQuery, cchSize);
	    }
		
	}

        W32TimeBufferFreeDDload(pProviderInfo);
    }
    else
    {
        hr = ResultFromWin32(dwError);
    }

    return hr;
}


// pftTimeRemaining will be returned with the time/date of the next sync, not time from now.
HRESULT W32TimeGetErrorInfoWrapHelper(UINT * pulResolveAttempts, ULONG * pulValidDataCounter, FILETIME * pftTimeRemaining, FILETIME * pftLastSuccessfulSync, HRESULT * phrLastSyncError,
                                UINT * pulLastSyncErrorMsgId, LPTSTR pszServer, DWORD cchSize, LPTSTR pszServerToQuery)
{
    UINT64 * pu64LastSuccessfulSync = (UINT64 *) pftLastSuccessfulSync;
    UINT64 u64TimeRemaining;
    HRESULT hr = W32TimeGetErrorInfoWrap(pulResolveAttempts, pulValidDataCounter, &u64TimeRemaining, pu64LastSuccessfulSync, phrLastSyncError, pulLastSyncErrorMsgId, pszServer, cchSize, pszServerToQuery);

    if (SUCCEEDED(hr))
    {
        SYSTEMTIME stCurrent;
        FILETIME ftCurrent;

        GetSystemTime(&stCurrent);
        SystemTimeToFileTime(&stCurrent, &ftCurrent);

        ULONGLONG * pNextSync = (ULONGLONG *) pftTimeRemaining;
        ULONGLONG * pCurrent = (ULONGLONG *) &ftCurrent;
        *pNextSync = (*pCurrent + u64TimeRemaining);
    }

    return hr;
}


// This function is called on the background thread.
HRESULT CInternetTime::_GetDateTimeString(FILETIME * pftTimeDate, BOOL fDate, LPTSTR pszString, DWORD cchSize)
{
    HRESULT hr = S_OK;
    TCHAR szFormat[MAX_PATH];

    pszString[0] = 0;
    if (GetLocaleInfo(LOCALE_USER_DEFAULT, (fDate ? LOCALE_SSHORTDATE : LOCALE_STIMEFORMAT), szFormat, ARRAYSIZE(szFormat)))
    {
        SYSTEMTIME stTimeDate;

        if (FileTimeToSystemTime(pftTimeDate, &stTimeDate))
        {
            if (fDate)
            {
                if (!GetDateFormat(LOCALE_USER_DEFAULT, 0, &stTimeDate, szFormat, pszString, cchSize))
                {
                    hr = ResultFromLastError();
                }
            }
            else
            {
                if (!GetTimeFormat(LOCALE_USER_DEFAULT, TIME_NOSECONDS, &stTimeDate, szFormat, pszString, cchSize))
                {
                    hr = ResultFromLastError();
                }
            }
        }
        else
        {
            hr = ResultFromLastError();
        }
    }
    else
    {
        hr = ResultFromLastError();
    }

    return hr;
}


HRESULT _CleanUpErrorString(LPWSTR pszTemp4, DWORD cchSize)
{
    PathRemoveBlanks(pszTemp4);
    while (TRUE)
    {
        DWORD cchSizeTemp = lstrlen(pszTemp4);
        if (cchSizeTemp && ((TEXT('\n') == pszTemp4[cchSizeTemp-1]) ||
            (13 == pszTemp4[cchSizeTemp-1])))
        {
            pszTemp4[cchSizeTemp-1] = 0;
        }
        else
        {
            break;
        }
    }

    return S_OK;
}


// This function is called on the background thread.
HRESULT CInternetTime::_CreateW32TimeSuccessErrorString(DWORD dwError, LPTSTR pszString, DWORD cchSize, LPTSTR pszNextSync, DWORD cchNextSyncSize, LPTSTR pszServerToQuery)
{
    HRESULT hr = S_OK;
    UINT ulResolveAttempts = 0;
    FILETIME ftTimeRemainingUTC = {0};
    FILETIME ftLastSuccessfulSyncUTC = {0};
    FILETIME ftTimeRemaining = {0};
    FILETIME ftLastSuccessfulSync = {0};
    UINT ulLastSyncErrorMsgId = 0;
    TCHAR szServer[MAX_PATH];
    HRESULT hrLastSyncError = 0;
    ULONG ulValidDataCounter = 0;
    TCHAR szTemplate[MAX_PATH];
    TCHAR szTemp1[MAX_PATH];
    TCHAR szTemp2[MAX_PATH];
    TCHAR szTemp3[MAX_URL_STRING];
    TCHAR szTemp4[MAX_URL_STRING];

    pszString[0] = 0;
    pszNextSync[0] = 0;

    hr = W32TimeGetErrorInfoWrapHelper(&ulResolveAttempts, &ulValidDataCounter, &ftTimeRemainingUTC, &ftLastSuccessfulSyncUTC, &hrLastSyncError, &ulLastSyncErrorMsgId, szServer, ARRAYSIZE(szServer), pszServerToQuery);
    if (SUCCEEDED(hr))
    {
        // ftTimeRemaining and ftLastSuccessfulSync are stored in UTC, so translate to our time zone.
        FileTimeToLocalFileTime(&ftTimeRemainingUTC, &ftTimeRemaining);
        FileTimeToLocalFileTime(&ftLastSuccessfulSyncUTC, &ftLastSuccessfulSync);

        // Create the string showing the next time we plan on syncing.
        LoadString(HINST_THISDLL, IDS_IT_NEXTSYNC, szTemplate, ARRAYSIZE(szTemplate));
        if (SUCCEEDED(_GetDateTimeString(&ftTimeRemaining, TRUE, szTemp1, ARRAYSIZE(szTemp1))) &&           // Get the date
            SUCCEEDED(_GetDateTimeString(&ftTimeRemaining, FALSE, szTemp2, ARRAYSIZE(szTemp2))) &&          // Get the time
            FAILED(FormatMessageWedge(szTemplate, pszNextSync, cchNextSyncSize, szTemp1, szTemp2)))
        {
            pszNextSync[0] = 0;
        }

        if (ResyncResult_ChangeTooBig == dwError)
        {
            hrLastSyncError = E_FAIL;
        }

	if ((ResyncResult_NoData == dwError || ResyncResult_StaleData == dwError) && SUCCEEDED(hrLastSyncError))
	{
	    // We've synchronized from our peer, but it didn't provide good enough samples to update our clock. 
	    hrLastSyncError = HRESULT_FROM_WIN32(ERROR_TIMEOUT);  // approximately the right error
	}

	// We should never hit the following case.  But if the operation failed (NOT ResyncResult_Success)
        // then we need hrLastSyncError to be a failure value.
        if ((ResyncResult_Success != dwError) && SUCCEEDED(hrLastSyncError))
        {
            hrLastSyncError = E_FAIL;
        }

        switch (hrLastSyncError)
        {
        case S_OK:
            if (!ftLastSuccessfulSyncUTC.dwLowDateTime && !ftLastSuccessfulSyncUTC.dwHighDateTime)
            {
                // We have never sync from the server.
                LoadString(HINST_THISDLL, IDS_NEVER_TRIED_TOSYNC, pszString, cchSize);
            }
            else
            {
                if (szServer[0])
                {
                    // Format: "Successfully synchronized the clock on 12/23/2001 at 11:03:32am from time.windows.com."
                    LoadString(HINST_THISDLL, IDS_IT_SUCCESS, szTemplate, ARRAYSIZE(szTemplate));

                    if (SUCCEEDED(_GetDateTimeString(&ftLastSuccessfulSync, TRUE, szTemp1, ARRAYSIZE(szTemp1))) &&      // Get the date
                        SUCCEEDED(_GetDateTimeString(&ftLastSuccessfulSync, FALSE, szTemp2, ARRAYSIZE(szTemp2))) &&     // Get the time
                        FAILED(FormatMessageWedge(szTemplate, pszString, cchSize, szTemp1, szTemp2, szServer)))
                    {
                        pszString[0] = 0;
                    }
                }
                else
                {
                    // Format: "Successfully synchronized the clock on 12/23/2001 at 11:03:32am."
                    LoadString(HINST_THISDLL, IDS_IT_SUCCESS2, szTemplate, ARRAYSIZE(szTemplate));

                    if (SUCCEEDED(_GetDateTimeString(&ftLastSuccessfulSync, TRUE, szTemp1, ARRAYSIZE(szTemp1))) &&      // Get the date
                        SUCCEEDED(_GetDateTimeString(&ftLastSuccessfulSync, FALSE, szTemp2, ARRAYSIZE(szTemp2))) &&     // Get the time
                        FAILED(FormatMessageWedge(szTemplate, pszString, cchSize, szTemp1, szTemp2)))
                    {
                        pszString[0] = 0;
                    }
                }
            }
            break;

        case S_FALSE:
            pszString[0] = 0;
            break;

        default:
            if (ulValidDataCounter &&
                ((0 != ftLastSuccessfulSyncUTC.dwLowDateTime) || (0 != ftLastSuccessfulSyncUTC.dwHighDateTime)))
            {
                // Getting this far means we may have failed this last sync attempt, but we have succeeded
                // previously

                hr = E_FAIL;
                szTemp4[0] = 0; // This will be the error message.
                szTemp3[0] = 0;

                if (ResyncResult_ChangeTooBig == dwError)
                {
                    // If the date is too far off, we fail the sync for security reasons.  That happened
                    // here.
                    LoadString(HINST_THISDLL, IDS_ERR_DATETOOWRONG, szTemp4, ARRAYSIZE(szTemp4));
                }
                else if (ulLastSyncErrorMsgId)           // We have a bonus error string.
                {
                    _LoadW32Time();
                    if (g_hInstW32Time)
                    {
                        // Load the specific reason the sync failed.
                        if (!FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, (LPCVOID)g_hInstW32Time, ulLastSyncErrorMsgId, 0, szTemp4, ARRAYSIZE(szTemp4), NULL))
                        {
                            szTemp4[0] = 0;     // We will get the value below
                            hr = S_OK;
                        }
                        else
                        {
                            _CleanUpErrorString(szTemp4, ARRAYSIZE(szTemp4));
                        }
                    }
                }

                if (!szTemp4[0])
                {
                    if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, HRESULT_CODE(hrLastSyncError), 0, szTemp4, ARRAYSIZE(szTemp4), NULL))
                    {
                        _CleanUpErrorString(szTemp4, ARRAYSIZE(szTemp4));
                    }
                    else
                    {
                        szTemp4[0] = 0;
                    }
                }

                if (szTemp4[0])
                {
                    LoadString(HINST_THISDLL, IDS_IT_FAIL1, szTemplate, ARRAYSIZE(szTemplate));
                    if (FAILED(FormatMessageWedge(szTemplate, szTemp3, ARRAYSIZE(szTemp3), szServer, szTemp4)))
                    {
                        szTemp3[0] = 0;
                    }
                }
                else
                {
                    //  <------------------------------------------------------------->
                    // Format:
                    // "An error occurred synchronizing the clock from time.windows.com
                    //  on 2/3/2001 at 11:03:32am.  Unable to connect to the server."
                    LoadString(HINST_THISDLL, IDS_IT_FAIL2, szTemplate, ARRAYSIZE(szTemplate));
                    if (FAILED(FormatMessageWedge(szTemplate, szTemp3, ARRAYSIZE(szTemp3), szServer)))
                    {
                        szTemp3[0] = 0;
                    }

                    hr = S_OK;
                }

                LoadString(HINST_THISDLL, IDS_IT_FAILLAST, szTemplate, ARRAYSIZE(szTemplate));

                if (SUCCEEDED(_GetDateTimeString(&ftLastSuccessfulSync, TRUE, szTemp1, ARRAYSIZE(szTemp1))) &&      // Get the date
                    SUCCEEDED(_GetDateTimeString(&ftLastSuccessfulSync, FALSE, szTemp2, ARRAYSIZE(szTemp2))) &&     // Get the time
                    FAILED(FormatMessageWedge(szTemplate, szTemp4, ARRAYSIZE(szTemp4), szTemp1, szTemp2)))
                {
                    szTemp4[0] = 0;
                }

                wnsprintf(pszString, cchSize, TEXT("%s\n\n%s"), szTemp3, szTemp4);
            }
            else
            {
                // Getting this far means we may have failed to sync this time and we have never succeeded before.

                if (ulLastSyncErrorMsgId)           // We have a bonus error string.
                {
                    _LoadW32Time();

                    szTemp3[0] = 0;
                    if (g_hInstW32Time)
                    {
                        //  <------------------------------------------------------------->
                        // Format:
                        // "An error occurred synchronizing the clock from time.windows.com
                        //  on 2/3/2001 at 11:03:32am.  Unable to connect to the server."
                        if (!FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, (LPCVOID)g_hInstW32Time, ulLastSyncErrorMsgId, 0, szTemp4, ARRAYSIZE(szTemp4), NULL))
                        {
                            szTemp4[0] = 0;
                        }
                        else
                        {
                            _CleanUpErrorString(szTemp4, ARRAYSIZE(szTemp4));
                        }

                        if (szServer[0])
                        {
                            LoadString(HINST_THISDLL, IDS_IT_FAIL1, szTemplate, ARRAYSIZE(szTemplate));
                            if (FAILED(FormatMessageWedge(szTemplate, pszString, cchSize, szServer, szTemp4)))
                            {
                                pszString[0] = 0;
                            }
                        }
                        else
                        {
                            LoadString(HINST_THISDLL, IDS_IT_FAIL3, szTemplate, ARRAYSIZE(szTemplate));
                            if (FAILED(FormatMessageWedge(szTemplate, pszString, cchSize, szTemp4)))
                            {
                                pszString[0] = 0;
                            }
                        }
                    }
                }
                else
                {
                    //  <------------------------------------------------------------->
                    // Format:
                    // "An error occurred synchronizing the clock from time.windows.com
                    //  on 2/3/2001 at 11:03:32am.  Unable to connect to the server."
                    LoadString(HINST_THISDLL, IDS_IT_FAIL2, szTemplate, ARRAYSIZE(szTemplate));
                    if (FAILED(FormatMessageWedge(szTemplate, pszString, cchSize, szServer)))
                    {
                        pszString[0] = 0;
                    }
                }
            }
            break;
        };
    }
    else
    {
        LoadString(HINST_THISDLL, IDS_ERR_GETINFO_FAIL, szTemplate, ARRAYSIZE(szTemplate));
        if (!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, HRESULT_CODE(hr), 0, szTemp1, ARRAYSIZE(szTemp1), NULL))
        {
            szTemp1[0] = 0;
        }
        else
        {
            _CleanUpErrorString(szTemp1, ARRAYSIZE(szTemp1));
        }

        wnsprintf(pszString, cchSize, szTemplate, szTemp1);
    }

    return hr;
}


///////////
// These functions will cause the background thread to check if we should add the "Internet Time" tab.
///////////

// This function is called on the background thread.
DWORD CALLBACK _AsyncCheckDCThread(void * pv)
{
    if (g_pInternetTime)
    {
        g_pInternetTime->AsyncCheck();
    }

    return 0;
}



typedef DWORD (* PFN_NETGETJOININFORMATION) (IN LPCWSTR pszComputerName OPTIONAL, OUT LPWSTR * pszDomainName, IN PNETSETUP_JOIN_STATUS pJoinStatus);

// This function is called on the background thread.
DWORD NetGetJoinInformation_DelayLoad(
    IN LPCWSTR pszComputerName OPTIONAL,
    OUT LPWSTR * pszDomainName,
    IN PNETSETUP_JOIN_STATUS pJoinStatus)
{
    DWORD dwError = ERROR_INVALID_FUNCTION;
    HMODULE hmod = LoadLibrary(TEXT("NETAPI32.DLL"));

    if (hmod)
    {
        PFN_NETGETJOININFORMATION pfnDelayLoad = (PFN_NETGETJOININFORMATION)GetProcAddress(hmod, "NetGetJoinInformation");
        
        if (pfnDelayLoad)
        {
            dwError = pfnDelayLoad(pszComputerName, pszDomainName, pJoinStatus);
        }

        FreeLibrary(hmod);
    }
    else
    {
        dwError = GetLastError();
    }

    return dwError;
}



typedef DWORD (* PFN_DSGETDCNAME) (IN LPCTSTR ComputerName OPTIONAL, IN LPCTSTR DomainName OPTIONAL, IN GUID *DomainGuid OPTIONAL, IN LPCTSTR SiteName OPTIONAL,
    IN ULONG Flags, OUT PDOMAIN_CONTROLLER_INFO * DomainControllerInfo);

// This function is called on the background thread.
DWORD DsGetDcName_DelayLoad(
    IN LPCWSTR pszComputerName OPTIONAL,
    IN LPCWSTR pszDomainName OPTIONAL,
    IN GUID * pDomainGuid OPTIONAL,
    IN LPCWSTR pszSiteName OPTIONAL,
    IN ULONG pulFlags,
    OUT PDOMAIN_CONTROLLER_INFOW * pDomainControllerInfo)
{
    DWORD dwError = ERROR_INVALID_FUNCTION;
    HMODULE hmod = LoadLibrary(TEXT("NETAPI32.DLL"));

    if (hmod)
    {
        PFN_DSGETDCNAME pfnDelayLoad = (PFN_DSGETDCNAME)GetProcAddress(hmod, "DsGetDcNameW");
        
        if (pfnDelayLoad)
        {
            dwError = pfnDelayLoad(pszComputerName, pszDomainName, pDomainGuid, pszSiteName, pulFlags, pDomainControllerInfo);
        }

        FreeLibrary(hmod);
    }
    else
    {
        dwError = GetLastError();
    }

    return dwError;
}



typedef DWORD (* PFN_NETAPIBUFFERFREE) (IN LPVOID Buffer);

// This function is called on the background thread.
DWORD NetApiBufferFree_DelayLoad(IN LPVOID Buffer)
{
    DWORD dwError = FALSE;
    HMODULE hmod = LoadLibrary(TEXT("NETAPI32.DLL"));

    if (hmod)
    {
        PFN_NETAPIBUFFERFREE pfnDelayLoad = (PFN_NETAPIBUFFERFREE)GetProcAddress(hmod, "NetApiBufferFree");
        
        if (pfnDelayLoad)
        {
            dwError = pfnDelayLoad(Buffer);
        }

        FreeLibrary(hmod);
    }
    else
    {
        dwError = GetLastError();
    }

    return dwError;
}


// This function is called on the background thread.
BOOL CInternetTime::IsInternetTimeAvailable(void)
{
    return SHRegGetBoolUSValue(SZ_REGKEY_DATETIME, SZ_REGVALUE_INTERNET_FEATURE_AVAILABLE, FALSE, FEATURE_INTERNET_TIME);
}


// This function is called on the background thread.
EXTERN_C BOOL DoesTimeComeFromDC(void)
{
    BOOL fTimeFromDomain = FALSE;
    LPWSTR pszDomain = NULL;
    NETSETUP_JOIN_STATUS joinStatus = NetSetupUnknownStatus;
    DWORD dwError = NetGetJoinInformation_DelayLoad(NULL, &pszDomain, &joinStatus);

    // We will act like there isn't a DC if we have the test registry set.
    if (NERR_Success == dwError)
    {
        // If we are connected to a domain, we need to do the expensive net search
        // to see that is where we will get the time from.
        if (NetSetupDomainName == joinStatus)
        {
            PDOMAIN_CONTROLLER_INFO pdomainInfo = {0};

            dwError = DsGetDcName_DelayLoad(NULL, NULL, NULL, NULL, DS_TIMESERV_REQUIRED, &pdomainInfo);
            // We will act like there isn't a DC if we have the test registry set.
            if (ERROR_SUCCESS == dwError)
            {
                if (FALSE == SHRegGetBoolUSValue(SZ_REGKEY_DATETIME, SZ_REGVALUE_TEST_SIMULATENODC, FALSE, FALSE))
                {
                    fTimeFromDomain = TRUE;
                }

                NetApiBufferFree_DelayLoad(pdomainInfo);
            }
        }

        if (pszDomain)
        {
            NetApiBufferFree_DelayLoad(pszDomain);
        }
    }

    return fTimeFromDomain;
}


// This function is called on the background thread.
HRESULT CInternetTime::_SyncNow(BOOL fOnlyUpdateInfo)
{
    HRESULT hr = S_OK;

ENTERCRITICAL;
    BOOL fContinue = ((eBKAUpdate == m_eAction) || (eBKAGetInfo == m_eAction));
    if (fContinue)
    {
        m_eAction = eBKAUpdating;
    }
LEAVECRITICAL;

    if (fContinue)
    {
        hr = E_OUTOFMEMORY;
        DWORD cchSize = 4024;
        LPTSTR pszString = (LPTSTR) LocalAlloc(LPTR, sizeof(pszString[0]) * cchSize);

        if (pszString)
        {
            WCHAR szExistingServer[MAX_URL_STRING];
            HRESULT hrServer = E_FAIL;

	    TCHAR szNewServer[MAX_PATH]; 
            TCHAR szNextSync[MAX_PATH];
            DWORD dwError = 0;
	    DWORD dwSyncFlags;
	    
            if (!fOnlyUpdateInfo)
            {
                hrServer = GetW32TimeServer(FALSE, szExistingServer, ARRAYSIZE(szExistingServer));

                GetWindowText(GetDlgItem(m_hwndInternet, DATETIME_INTERNET_SERVER_EDIT), szNextSync, ARRAYSIZE(szNextSync));
		// save the new server away for future processing
		StrCpyN(szNewServer, szNextSync, ARRAYSIZE(szNewServer)); 
                if (!ContainsServer(szExistingServer, szNextSync))
                {
                    // The servers don't match.  We want to add the new server to the beginning of the list.  This
                    // will work around a problem in W32time.  If we don't do this, then:
                    // 1. It will cause a second sync with the original server (which is bad for perf and affects statistics)
                    // 2. The Last Updated sync time will then be from the wrong peer.  This is really bad because it's result is basic
                    //    on the user's previously bad time
                    // 3. It will do an extra DNS resolution causing slowness on our side, increasing server traffic, and dragging down
                    //    the intranet.
                    TCHAR szTemp[MAX_URL_STRING];

                    StrCpyN(szTemp, szNextSync, ARRAYSIZE(szTemp));
                    wnsprintf(szNextSync, ARRAYSIZE(szNextSync), TEXT("%s %s"), szTemp, szExistingServer);

		    dwSyncFlags = TimeSyncFlag_ReturnResult | TimeSyncFlag_UpdateAndResync; 
                } 
		else
		{
		    // We've already got this server in our list of servers.  Just cause our peers to resync. 
		    dwSyncFlags = TimeSyncFlag_ReturnResult | TimeSyncFlag_HardResync; 
		}

		SetW32TimeServer(szNextSync);
		
                // I will ignore the error value because I will get the error info in _CreateW32TimeSuccessErrorString.
                dwError = W32TimeSyncNowDDLoad(SZ_COMPUTER_LOCAL, TRUE /* Synchronous */, dwSyncFlags); 
		if ((ResyncResult_StaleData == dwError) && (0 == (TimeSyncFlag_HardResync & dwSyncFlags)))
		{
		    // We've got stale data preventing us from resyncing.  Try again with a full resync. 
		    dwSyncFlags = TimeSyncFlag_ReturnResult | TimeSyncFlag_HardResync; 
		    dwError = W32TimeSyncNowDDLoad(SZ_COMPUTER_LOCAL, TRUE /* Synchronous */, dwSyncFlags); 
		}
            }

            pszString[0] = 0;
            szNextSync[0] = 0;
	    
            hr = _CreateW32TimeSuccessErrorString(dwError, pszString, cchSize, szNextSync, ARRAYSIZE(szNextSync), (SUCCEEDED(hrServer) ? szNewServer : NULL));

            if (SUCCEEDED(hrServer))
            {
                SetW32TimeServer(szExistingServer);
                _StartServiceAndRefresh(TRUE);      // Make sure the service is on and make it update it's settings.
            }

ENTERCRITICAL;
            Str_SetPtr(&m_pszNextSyncTime, szNextSync);

            if (m_pszStatusString)
            {
                LocalFree(m_pszStatusString);
            }
            m_pszStatusString = pszString;

            PostMessage(m_hwndInternet, WMUSER_UPDATED_STATUS_TEXT, 0, 0);      // Tell the forground thread to pick up the new string.
            m_eAction = eBKAWait;
LEAVECRITICAL;
        }
    }

    return hr;
}


// This function is called on the background thread.
void CInternetTime::AsyncCheck(void)
{
    HRESULT hr = S_OK;

    if (m_hDlg && !DoesTimeComeFromDC())
    {
        // Tell the forground thread to add us.
        PostMessage(m_hwndDate, WMUSER_ADDINTERNETTAB, 0, 0);
        _ProcessBkThreadActions();
    }
}


// This function is called on the background thread.
HRESULT CInternetTime::_ProcessBkThreadActions(void)
{
    HRESULT hr = S_OK;

    while (eBKAQuit != m_eAction)           // Okay since we are only reading
    {
        switch (m_eAction)
        {
        case eBKAGetInfo:
            _SyncNow(TRUE);
            break;

        case eBKAUpdate:
            _SyncNow(FALSE);
            break;

        case eBKAUpdating:
        case eBKAWait:
        default:
            Sleep(300);     // We don't care if there is up to 100ms latency between button press and action starting.
            break;
        }
    }

    return hr;
}



/////////////////////////////////////////////////////////////////////
// Public Functions
/////////////////////////////////////////////////////////////////////
// This function is called on the forground thread.
EXTERN_C HRESULT AddInternetPageAsync(HWND hDlg, HWND hwndDate)
{
    HRESULT hr = E_OUTOFMEMORY;

    if (!g_pInternetTime)
    {
        g_pInternetTime = new CInternetTime(hDlg, hwndDate);
    }

    if (g_pInternetTime)
    {
        // We only want to add the page that allows the user to get the time from the internet if:
        // 1. The feature is turned on, and
        // 2. The user doesn't get the time from an intranet Domain Control.
        if (g_pInternetTime->IsInternetTimeAvailable())
        {
            // Start the thread to find out if we are in a domain and need the advanced page.  We need
            // to do this on a background thread because the DsGetDcName() API may take 10-20 seconds.
            hr = (SHCreateThread(_AsyncCheckDCThread, hDlg, (CTF_INSIST | CTF_FREELIBANDEXIT), NULL) ? S_OK : E_FAIL);
        }
    }

    return hr;
}


// This function is called on the forground thread.
EXTERN_C HRESULT AddInternetTab(HWND hDlg)
{
    HRESULT hr = E_OUTOFMEMORY;

    if (g_pInternetTime)
    {
        hr = g_pInternetTime->AddInternetPage();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\utc\mapctl.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    mapctl.c

Abstract:

    This module implements the map control for the Date/Time applet.

Revision History:

--*/



//
//  Include Files.
//

#include "timedate.h"
#include <commctrl.h>
#include "worldmap.h"
#include "mapctl.h"
#include "rc.h"




//
//  Constant Declarations.
//

#define MAPCTL_BITMAP_NAME          MAKEINTRESOURCE(IDB_TIMEZONE)

#define MAPCTL_ANIMATION_TIMER      1
#define MAPCTL_ANIMATION_INTERVAL   30
#define MAPCTL_ANIMATION_FACTOR     3

#define MAPCTL_DATA                 0


static const RGBQUAD c_SeaNormalColor       =  { 127,   0,   0,   0 };
static const RGBQUAD c_SeaHiliteColor       =  { 255,   0,   0,   0 };
static const RGBQUAD c_LandNormalColor      =  {   0, 127,   0,   0 };
static const RGBQUAD c_LandHiliteColor      =  {   0, 255,   0,   0 };

static const RGBQUAD c_MonoSeaNormalColor   =  { 255, 255, 255,   0 };
static const RGBQUAD c_MonoSeaHiliteColor   =  {   0,   0,   0,   0 };
static const RGBQUAD c_MonoLandNormalColor  =  {   0,   0,   0,   0 };
static const RGBQUAD c_MonoLandHiliteColor  =  { 255, 255, 255,   0 };




//
//  Typedef Declarations.
//

typedef struct tagMAPCTLDATA
{
    HWND        window;         // window handle for this control
    UINT_PTR    timer;          // timer id for this map control
    int         totaldelta;     // total delta we must cover to center stuff
    BOOL        slowdevice;
    BOOL        captured;
    WORLDMAP    map;            // world map object, at end of struct (>1k)

} MAPCTLDATA, *PMAPCTLDATA;




//
//  Function Prototypes.
//

PMAPCTLDATA
CreateMapControlData(
    HWND window);

void
DestroyMapControlData(
    PMAPCTLDATA ctldata);

LRESULT CALLBACK
MapControlWndProc(
    HWND window,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);

BOOL
MapControlNCCreate(
    PMAPCTLDATA ctldata,
    LPCREATESTRUCT cs);

BOOL
MapControlCreate(
    PMAPCTLDATA ctldata,
    LPCREATESTRUCT cs);

void
MapControlNCDestroy(
    PMAPCTLDATA ctldata);

BOOL
MapControlErase(
    PMAPCTLDATA ctldata,
    HDC dc);

void
MapControlPaint(
    PMAPCTLDATA ctldata);

void
MapControlMouseMove(
    PMAPCTLDATA ctldata,
    int x,
    int y,
    UINT flags);

void
MapControlMouseDown(
    PMAPCTLDATA ctldata,
    BOOL dblclk,
    int x,
    int y,
    UINT flags);

void
MapControlMouseUp(
    PMAPCTLDATA ctldata,
    int x,
    int y,
    UINT flags);

void
MapControlTimerProc(
    PMAPCTLDATA ctldata,
    UINT timer);

void
MapControlRotate(
    PMAPCTLDATA ctldata,
    int delta);

void
MapControlAnimateOneStep(
    PMAPCTLDATA ctldata);





////////////////////////////////////////////////////////////////////////////
//
//  SetMapControlData
//
////////////////////////////////////////////////////////////////////////////

__inline
void SetMapControlData(
    HWND window,
    PMAPCTLDATA ctldata)
{
    SetWindowLongPtr(window, MAPCTL_DATA, (LONG_PTR)ctldata);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetMapControlData
//
////////////////////////////////////////////////////////////////////////////

__inline
PMAPCTLDATA GetMapControlData(
    HWND window)
{
    return ( (PMAPCTLDATA)GetWindowLongPtr(window, MAPCTL_DATA) );
}


////////////////////////////////////////////////////////////////////////////
//
//  RegisterMapControlStuff
//
////////////////////////////////////////////////////////////////////////////

BOOL RegisterMapControlStuff(
    HINSTANCE instance)
{
    WNDCLASS wc;

    wc.style = 0;
    wc.lpfnWndProc = MapControlWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = sizeof(PMAPCTLDATA);
    wc.hInstance = instance;
    wc.hIcon = NULL;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName = NULL;
    wc.lpszClassName = MAPCTL_CLASSNAME;

    return ( RegisterClass(&wc) );
}


////////////////////////////////////////////////////////////////////////////
//
//  MapControlSetSeaRegionHighlight
//
////////////////////////////////////////////////////////////////////////////

void MapControlSetSeaRegionHighlight(
    HWND window,
    int index,
    BOOL highlighted,
    int x,
    int cx)
{
    ChangeWorldMapColor( &GetMapControlData(window)->map,
                         index,
#ifdef ENABLE_MAP
                         highlighted ? &c_SeaHiliteColor : &c_SeaNormalColor,
#else
                         &c_SeaNormalColor,
#endif
                         x,
                         cx );
}


////////////////////////////////////////////////////////////////////////////
//
//  MapControlSetLandRegionHighlight
//
////////////////////////////////////////////////////////////////////////////

void MapControlSetLandRegionHighlight(
    HWND window,
    int index,
    BOOL highlighted,
    int x,
    int cx)
{
    ChangeWorldMapColor( &GetMapControlData(window)->map,
                         index,
#ifdef ENABLE_MAP
                         highlighted ? &c_LandHiliteColor : &c_LandNormalColor,
#else
                         &c_LandNormalColor,
#endif
                         x,
                         cx );
}


////////////////////////////////////////////////////////////////////////////
//
//  _InvalidateProc
//
////////////////////////////////////////////////////////////////////////////

void _InvalidateProc(
    LPARAM data,
    int left,
    int right)
{
#define ctldata ((PMAPCTLDATA)data)
    RECT ri = { left, 0, right, ctldata->map.size.cy };

    InvalidateRect(ctldata->window, &ri, TRUE);
#undef ctldata
}


////////////////////////////////////////////////////////////////////////////
//
//  MapControlInvalidateDirtyRegions
//
////////////////////////////////////////////////////////////////////////////

void MapControlInvalidateDirtyRegions(
    HWND window)
{
    PMAPCTLDATA ctldata = GetMapControlData(window);

    EnumWorldMapDirtySpans( &ctldata->map,
                            _InvalidateProc,
                            (LPARAM)ctldata,
                            TRUE );
}


////////////////////////////////////////////////////////////////////////////
//
//  MapControlRotateTo
//
////////////////////////////////////////////////////////////////////////////

void MapControlRotateTo(
    HWND window,
    int x,
    BOOL animate)
{
    PMAPCTLDATA ctldata = GetMapControlData(window);

    if (ctldata->timer)
    {
        KillTimer(ctldata->window, ctldata->timer);
        ctldata->timer = 0;
    }

    ctldata->totaldelta = (ctldata->map.size.cx / 2) -
                          WorldMapGetDisplayedLocation(&ctldata->map, x);

    if (ctldata->totaldelta)
    {
        UpdateWindow(ctldata->window);

        if (animate)
        {
            ctldata->timer = SetTimer( ctldata->window,
                                       MAPCTL_ANIMATION_TIMER,
                                       MAPCTL_ANIMATION_INTERVAL,
                                       NULL );

            if (ctldata->timer)
            {
                MapControlAnimateOneStep(ctldata);
                return;
            }
        }

        MapControlRotate(ctldata, ctldata->totaldelta);
        ctldata->totaldelta = 0;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CreateMapControlData
//
////////////////////////////////////////////////////////////////////////////

PMAPCTLDATA CreateMapControlData(
    HWND window)
{
    PMAPCTLDATA ctldata = (PMAPCTLDATA)LocalAlloc(LPTR, sizeof(MAPCTLDATA));

    if (ctldata)
    {
        ctldata->window = window;
        SetMapControlData(window, ctldata);
    }

    return (ctldata);
}


////////////////////////////////////////////////////////////////////////////
//
//  DestroyMapControlData
//
////////////////////////////////////////////////////////////////////////////

void DestroyMapControlData(
    PMAPCTLDATA ctldata)
{
    if (ctldata)
    {
        SetMapControlData(ctldata->window, 0);
        LocalFree(ctldata);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  MapControlWndProc
//
////////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK MapControlWndProc(
    HWND window,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PMAPCTLDATA ctldata = (message == WM_NCCREATE)
                              ? CreateMapControlData(window)
                              : GetMapControlData(window);

    switch (message)
    {
        HANDLE_MSG(ctldata, WM_NCCREATE,    MapControlNCCreate);
        HANDLE_MSG(ctldata, WM_CREATE,      MapControlCreate);
        HANDLE_MSG(ctldata, WM_NCDESTROY,   MapControlNCDestroy);

        HANDLE_MSG(ctldata, WM_ERASEBKGND,  MapControlErase);
        HANDLE_MSG(ctldata, WM_PAINT,       MapControlPaint);

#ifdef ENABLE_MAP
        HANDLE_MSG(ctldata, WM_MOUSEMOVE,   MapControlMouseMove);
        HANDLE_MSG(ctldata, WM_LBUTTONDOWN, MapControlMouseDown);
        HANDLE_MSG(ctldata, WM_LBUTTONUP,   MapControlMouseUp);
#endif
        HANDLE_MSG(ctldata, WM_TIMER,       MapControlTimerProc);
    }

    return ( DefWindowProc(window, message, wParam, lParam) );
}


////////////////////////////////////////////////////////////////////////////
//
//  MapControlNCCreate
//
////////////////////////////////////////////////////////////////////////////

BOOL MapControlNCCreate(
    PMAPCTLDATA ctldata,
    LPCREATESTRUCT cs)
{
    if (!ctldata)
    {
        return (FALSE);
    }

    //
    //  NCDESTROY tries to nuke this if it's nonzero.
    //
    ctldata->timer = 0;

    if (!LoadWorldMap(&ctldata->map, g_hInst, MAPCTL_BITMAP_NAME))
    {
        return (FALSE);
    }

    ctldata->slowdevice = (ctldata->map.prepared.dc != NULL);
    ctldata->totaldelta = 0;
    ctldata->captured = FALSE;
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  MapControlCreate
//
////////////////////////////////////////////////////////////////////////////

BOOL MapControlCreate(
    PMAPCTLDATA ctldata,
    LPCREATESTRUCT cs)
{
    RECT rc = { 0, 0, ctldata->map.size.cx, ctldata->map.size.cy };

    if (AdjustWindowRectEx( &rc,
                            GetWindowLong(ctldata->window, GWL_STYLE),
                            FALSE,
                            GetWindowLong(ctldata->window, GWL_EXSTYLE)))
    {
        SIZE sz = { rc.right - rc.left, rc.bottom - rc.top };

        MoveWindow( ctldata->window,
                    cs->x + ((cs->cx - sz.cx) / 2),
                    cs->y + ((cs->cy - sz.cy) / 2 ),
                    sz.cx,
                    sz.cy,
                    FALSE );
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  MapControlNCDestroy
//
////////////////////////////////////////////////////////////////////////////

void MapControlNCDestroy(
    PMAPCTLDATA ctldata)
{
    if (ctldata)
    {
        if (ctldata->timer)
        {
            KillTimer(ctldata->window, ctldata->timer);
        }

        FreeWorldMap(&ctldata->map);
        DestroyMapControlData(ctldata);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  MapControlErase
//
////////////////////////////////////////////////////////////////////////////

BOOL MapControlErase(
    PMAPCTLDATA ctldata,
    HDC dc)
{
    RECT rce;

    GetClipBox(dc, &rce);

    DrawWorldMap( dc,
                  rce.left,
                  rce.top,
                  rce.right - rce.left,
                  rce.bottom - rce.top,
                  &ctldata->map,
                  rce.left,
                  rce.top,
                  SRCCOPY );

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  MapControlPaint
//
////////////////////////////////////////////////////////////////////////////

void MapControlPaint(
    PMAPCTLDATA ctldata)
{
    PAINTSTRUCT ps;

    BeginPaint(ctldata->window, &ps);
    EndPaint(ctldata->window, &ps);
}


////////////////////////////////////////////////////////////////////////////
//
//  MapControlMouseMove
//
////////////////////////////////////////////////////////////////////////////

void MapControlMouseMove(
    PMAPCTLDATA ctldata,
    int x,
    int y,
    UINT flags)
{
    if (ctldata->captured)
    {
        if (flags & MK_LBUTTON)
        {
            NFYMAPEVENT event;

            event.index = GetWorldMapColorIndex(&ctldata->map, x, y);

            SendNotify( GetParent(ctldata->window),
                        ctldata->window,
                        MAPN_TOUCH,
                        (NMHDR *)&event );
        }
        else
        {
            //
            //  No time to handle WM_CAPTURECHANGED.
            //
            ctldata->captured = FALSE;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  MapControlMouseDown
//
////////////////////////////////////////////////////////////////////////////

void MapControlMouseDown(
    PMAPCTLDATA ctldata,
    BOOL dblclk,
    int x,
    int y,
    UINT flags)
{
    NFYMAPEVENT event;

    SetCapture(ctldata->window);
    ctldata->captured = TRUE;

    if (ctldata->timer)
    {
        KillTimer(ctldata->window, ctldata->timer);
        ctldata->timer = 0;
    }

    event.index = GetWorldMapColorIndex(&ctldata->map, x, y);

    SendNotify( GetParent(ctldata->window),
                ctldata->window,
                MAPN_TOUCH,
                (NMHDR *)&event );
}


////////////////////////////////////////////////////////////////////////////
//
//  MapControlMouseUp
//
////////////////////////////////////////////////////////////////////////////

void MapControlMouseUp(
    PMAPCTLDATA ctldata,
    int x,
    int y,
    UINT flags)
{
    if (ctldata->captured)
    {
        NFYMAPEVENT event;
        int index = GetWorldMapColorIndex(&ctldata->map, x, y);

        ReleaseCapture();

        event.index = index;
        SendNotify( GetParent(ctldata->window),
                    ctldata->window,
                    MAPN_TOUCH,
                    (NMHDR *)&event );

        event.index = index;
        SendNotify( GetParent(ctldata->window),
                    ctldata->window,
                    MAPN_SELECT,
                    (NMHDR *)&event );
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  MapControlTimerProc
//
////////////////////////////////////////////////////////////////////////////

void MapControlTimerProc(
    PMAPCTLDATA ctldata,
    UINT timer)
{
    if (timer == MAPCTL_ANIMATION_TIMER)
    {
        if (ctldata->totaldelta)
        {
            MapControlAnimateOneStep(ctldata);
        }

        if (!ctldata->totaldelta && ctldata->timer)
        {
            KillTimer(ctldata->window, ctldata->timer);
            ctldata->timer = 0;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  MapControlRotate
//
////////////////////////////////////////////////////////////////////////////

void MapControlRotate(
    PMAPCTLDATA ctldata,
    int delta)
{
    RotateWorldMap(&ctldata->map, delta);
    ScrollWindow(ctldata->window, delta, 0, NULL, NULL);
}


////////////////////////////////////////////////////////////////////////////
//
//  MapControlAnimateOneStep
//
////////////////////////////////////////////////////////////////////////////

void MapControlAnimateOneStep(
    PMAPCTLDATA ctldata)
{
    //
    //  Check that we really need to do something.
    //
    if (ctldata->totaldelta)
    {
        //
        //  Try to create a deceleration effect...
        //
        int delta = ctldata->totaldelta / MAPCTL_ANIMATION_FACTOR;
        BOOL negative = (ctldata->totaldelta < 0);

        if (!delta)
        {
            delta = negative ? -1 : 1;
        }

        if (ctldata->slowdevice)
        {
            //
            //  Multiples of 8 will help on planar devices.
            //
            int preferred = ((delta + (negative ? 0 : 7)) & ~7);

            if (preferred)
            {
                delta = preferred;
            }
        }

        //
        //  Don't go too far.
        //
        if ((negative && (delta < ctldata->totaldelta)) ||
            (!negative && (delta > ctldata->totaldelta)))
        {
            delta = ctldata->totaldelta;
        }

        //
        //  Rotate the map and update the total delta left to go.
        //
        ctldata->totaldelta -= delta;
        MapControlRotate(ctldata, delta);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\utc\mapctl.h ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    mapctl.h

Abstract:

    This module contains the information for the map control of the
    Date/Time applet.

Revision History:

--*/



#ifndef _MAPCTL_H
#define _MAPCTL_H



//
//  Constant Declarations.
//

#define MAPN_TOUCH           0
#define MAPN_SELECT          1




//
//  Typedef Declarations.
//

typedef struct
{
    NMHDR hdr;
    int index;

} NFYMAPEVENT;

#define MAPCTL_MAX_INDICES  256




//
//  Function Prototypes.
//

BOOL
RegisterMapControlStuff(
    HINSTANCE instance);

void
MapControlSetSeaRegionHighlight(
    HWND window,
    int index,
    int value,
    int x,
    int cx);

void
MapControlSetLandRegionHighlight(
    HWND window,
    int index,
    BOOL highlighted,
    int x,
    int cx);

void
MapControlInvalidateDirtyRegions(
    HWND window);

void
MapControlRotateTo(
    HWND window,
    int x,
    BOOL animate);


#endif // _MAPCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\vidupgrd\deskcmmn.cpp ===
#include "migrate.h"
#include "..\..\common\deskcmmn.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\utc\timedate.h ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    timedate.h

Abstract:

    This module contains the header information for the Date/Time applet.

Revision History:

--*/



#ifndef STRICT
  #define STRICT
#endif



//
//  Include Files.
//

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <comctrlp.h>




//
//  Constant Declarations.
//

#define CharSizeOf(x)   (sizeof(x) / sizeof(x[0]))

//
//  Index into wDateTime.
//
#define  HOUR       0
#define  MINUTE     1
#define  SECOND     2
#define  MONTH      3
#define  DAY        4
#define  YEAR       5
#define  WEEKDAY    6




//
//  Typedef Declarations.
//

#define TIMESUF_LEN   9         // time suffix length + null terminator

typedef struct
{
    TCHAR  sCountry[24];        // country name
    int    iCountry;            // country code (phone ID)
    int    iDate;               // date mode (0: MDY, 1: DMY, 2: YMD)
    int    iTime;               // time mode (0: 12 hour clock, 1: 24 hour clock)
    int    iTLZero;             // leading zeros for hour (0: no, 1: yes)
    int    iCurFmt;             // currency mode (0: prefix, no separation
                                //                1: suffix, no separation
                                //                2: prefix, 1 char separation
                                //                3: suffix, 1 char separation)
    int    iCurDec;             // currency decimal place
    int    iNegCur;             // negative currency pattern:
                                //     ($1.23), -$1.23, $-1.23, $1.23-, etc.
    int    iLzero;              // leading zeros of decimal (0: no, 1: yes)
    int    iDigits;             // significant decimal digits
    int    iMeasure;            // 0: metric, 1: US
    TCHAR  s1159[TIMESUF_LEN];  // trailing string from 0:00 to 11:59
    TCHAR  s2359[TIMESUF_LEN];  // trailing string from 12:00 to 23:59
    TCHAR  sCurrency[6];        // currency symbol string
    TCHAR  sThousand[4];        // thousand separator string
    TCHAR  sDecimal[4];         // decimal separator string
    TCHAR  sDateSep[4];         // date separator string
    TCHAR  sTime[4];            // time separator string
    TCHAR  sList[4];            // list separator string
    TCHAR  sLongDate[80];       // long date picture string
    TCHAR  sShortDate[80];      // short date picture string
    TCHAR  sLanguage[4];        // language name
    short  iDayLzero;           // day leading zero for short date format
    short  iMonLzero;           // month leading zero for short date format
    short  iCentury;            // display full century in short date format
    short  iLDate;              // long date mode (0: MDY, 1: DMY, 2: YMD)
    LCID   lcid;                // locale id
    TCHAR  sTimeFormat[80];     // time format picture string
    int    iTimeMarker;         // time marker position (0: suffix, 1: prefix)
    int    iNegNumber;          // negative number pattern:
                                //     (1.1), -1.1, - 1.1, 1.1-, 1.1 -
    TCHAR  sMonThousand[4];     // monetary thousand separator string
    TCHAR  sMonDecimal[4];      // monetary decimal separator string

} INTLSTRUCT, *LPINTL;




//
//  Global Variables.
//

extern short wDateTime[7];             // values for first 7 date/time items
extern short wPrevDateTime[7];         // only repaint fields if necessary
extern BOOL  fDateDirty;
EXTERN_C HINSTANCE g_hInst;

extern INTLSTRUCT IntlDef;




//
//  Function Prototypes.
//

void
GetDateTime(void);

void
GetTime(void);

void
SetTime(void);

void
GetDate(void);

void
SetDate(void);

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\utc\worldmap.h ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    worldmap.h

Abstract:

    This module contains the information for the world map for the
    Date/Time applet.

Revision History:

--*/



#ifndef _WORLDMAP_H
#define _WORLDMAP_H


//
//  Constant Declarations.
//

#define WORLDMAP_MAX_DIRTY_SPANS       4
#define WORLDMAP_MAX_COLORS            256




//
//  Typedef Declarations.
//

typedef struct
{
    HDC dc;
    HBITMAP bitmap;
    HBITMAP defbitmap;

} CDC, *LPCDC;

typedef struct dirtyspan
{
    int left;
    int right;
    struct dirtyspan *next;

} DIRTYSPAN;

typedef struct
{
    int first;
    int last;
    DIRTYSPAN *spans;
    DIRTYSPAN *freespans;
    RGBQUAD colors[WORLDMAP_MAX_COLORS];

} DIRTYSTUFF;

typedef struct tagWORLDMAP
{
    CDC original;
    CDC prepared;
    SIZE size;
    BYTE *bits;
    LONG scanbytes;
    int rotation;
    HDC source;
    DIRTYSTUFF dirty;  // keep at end (>1k)

} WORLDMAP, *LPWORLDMAP;




//
//  Function Prototypes.
//

typedef void (*ENUMSPANPROC)(LPARAM data, int left, int right);

BOOL
LoadWorldMap(
    LPWORLDMAP map,
    HINSTANCE instance,
    LPCTSTR resource);

void
FreeWorldMap(
    LPWORLDMAP map);

void
SetWorldMapRotation(
    LPWORLDMAP map,
    int rotation);

void
RotateWorldMap(
    LPWORLDMAP map,
    int delta);

int
WorldMapGetDisplayedLocation(
    LPWORLDMAP map,
    int pos);

void
EnumWorldMapDirtySpans(
    LPWORLDMAP map,
    ENUMSPANPROC proc,
    LPARAM data,
    BOOL rotate);

void
ChangeWorldMapColor(
    LPWORLDMAP map,
    int index,
    const RGBQUAD *color,
    int x,
    int cx);

int
GetWorldMapColorIndex(
    LPWORLDMAP map,
    int x,
    int y);

void
DrawWorldMap(
    HDC dc,
    int xdst,
    int ydst,
    int cx,
    int cy,
    LPWORLDMAP map,
    int xmap,
    int ymap,
    DWORD rop);


#endif // _WORLDMAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\utc\worldmap.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    worldmap.c

Abstract:

    This module implements the world map for the Date/Time applet.

Revision History:

--*/



//
//  Include Files.
//

#include "timedate.h"
#include <commctrl.h>
#include "worldmap.h"





////////////////////////////////////////////////////////////////////////////
//
//  ZeroCDC
//
////////////////////////////////////////////////////////////////////////////

static void ZeroCDC(
    LPCDC cdc)
{
    cdc->dc = NULL;
    cdc->bitmap = cdc->defbitmap = NULL;
}


////////////////////////////////////////////////////////////////////////////
//
//  CreateCDC
//
////////////////////////////////////////////////////////////////////////////

static BOOL CreateCDC(
    LPCDC cdc,
    HBITMAP bitmap)
{
    cdc->dc = CreateCompatibleDC(NULL);
    cdc->bitmap = cdc->defbitmap = NULL;

    if (!bitmap)
    {
        return (FALSE);
    }

    if (!cdc->dc)
    {
        if (bitmap)
        {
            DeleteBitmap(bitmap);
        }
        return (FALSE);
    }

    if (bitmap)
    {
        SetLayout(cdc->dc, LAYOUT_BITMAPORIENTATIONPRESERVED); // to avoid mirroring on mirrored builds
        cdc->defbitmap = SelectBitmap(cdc->dc, cdc->bitmap = bitmap);
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  DestroyCDC
//
////////////////////////////////////////////////////////////////////////////

static void DestroyCDC(
    LPCDC cdc)
{
    if (cdc->dc)
    {
        if (cdc->defbitmap)
        {
            SelectBitmap(cdc->dc, cdc->defbitmap);
        }
        if (cdc->bitmap)
        {
            DeleteBitmap(cdc->bitmap);
        }
        DeleteDC(cdc->dc);
        cdc->dc = NULL;
    }

    cdc->bitmap = cdc->defbitmap = NULL;
}


////////////////////////////////////////////////////////////////////////////
//
//  LoadWorldMap
//
////////////////////////////////////////////////////////////////////////////

BOOL LoadWorldMap(
    LPWORLDMAP map,
    HINSTANCE instance,
    LPCTSTR resource)
{
    HDC tempdc = CreateDC(TEXT("DISPLAY"), NULL, NULL, NULL);
    BOOL result = FALSE;

    ZeroCDC(&map->original);
    ZeroCDC(&map->prepared);

    map->size.cx = map->size.cy = 0;
    map->rotation = 0;

    if (tempdc)
    {
        if (CreateCDC( &map->original,
                       LoadImage( instance,
                                  resource,
                                  IMAGE_BITMAP,
                                  0,
                                  0,
                                  LR_CREATEDIBSECTION ) ))
        {
            DIBSECTION ds;

            if (GetObject(map->original.bitmap, sizeof(DIBSECTION), &ds))
            {
                map->size.cx = ds.dsBm.bmWidth;
                map->size.cy = ds.dsBm.bmHeight;
                map->bits = (BYTE *)ds.dsBm.bmBits;
                map->scanbytes = ds.dsBm.bmWidthBytes;

                if (( (GetDeviceCaps(tempdc, BITSPIXEL) *
                       GetDeviceCaps(tempdc, PLANES)) > 4 ) ||
                    CreateCDC( &map->prepared,
                               CreateCompatibleBitmap( tempdc,
                                                       ds.dsBm.bmWidth,
                                                       ds.dsBm.bmHeight ) ))
                {
                    RGBQUAD init = { 127, 0, 0, 0 };
                    RGBQUAD *color = map->dirty.colors;
                    int i = WORLDMAP_MAX_COLORS;

                    while (i--)
                    {
                        *color++ = init;
                    }

                    //
                    //  Mark everything as dirty.
                    //
                    map->dirty.first = 0;
                    map->dirty.last = WORLDMAP_MAX_COLORS - 1;
                    map->dirty.spans = NULL;
                    map->dirty.freespans = NULL;

                    map->source = (map->prepared.dc)
                                      ? map->prepared.dc
                                      : map->original.dc;

                    result = TRUE;
                }
            }
            else
            {
                DestroyCDC(&map->original);
            }
        }

        DeleteDC(tempdc);
    }

    return (result);
}


////////////////////////////////////////////////////////////////////////////
//
//  FreeWorldMap
//
////////////////////////////////////////////////////////////////////////////

void FreeWorldMap(
    LPWORLDMAP map)
{
    DIRTYSPAN *span = map->dirty.spans;

    while (span)
    {
        DIRTYSPAN *next = span->next;

        LocalFree((HANDLE)span);
        span = next;
    }

    span = map->dirty.freespans;

    while (span)
    {
        DIRTYSPAN *next = span->next;

        LocalFree((HANDLE)span);
        span = next;
    }

    DestroyCDC(&map->original);
    DestroyCDC(&map->prepared);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetWorldMapRotation
//
////////////////////////////////////////////////////////////////////////////

void SetWorldMapRotation(
    LPWORLDMAP map,
    int rotation)
{
    rotation %= (int)map->size.cx;
    if (rotation < 0)
    {
        rotation += (int)map->size.cx;
    }
    map->rotation = rotation;
}


////////////////////////////////////////////////////////////////////////////
//
//  RotateWorldMap
//
////////////////////////////////////////////////////////////////////////////

void RotateWorldMap(
    LPWORLDMAP map,
    int delta)
{
    SetWorldMapRotation(map, map->rotation + delta);
}


////////////////////////////////////////////////////////////////////////////
//
//  WorldMapGetDisplayedLocation
//
////////////////////////////////////////////////////////////////////////////

int WorldMapGetDisplayedLocation(
    LPWORLDMAP map,
    int pos)
{
    return ( (pos + map->rotation) % map->size.cx );
}


////////////////////////////////////////////////////////////////////////////
//
//  EnumWorldMapDirtySpans
//
////////////////////////////////////////////////////////////////////////////

void EnumWorldMapDirtySpans(
    LPWORLDMAP map,
    ENUMSPANPROC proc,
    LPARAM data,
    BOOL rotate)
{
    DIRTYSPAN *span = map->dirty.spans;

    while (span)
    {
        if (rotate)
        {
            int left = (span->left + map->rotation) % map->size.cx;
            int right = left + span->right - span->left;

            if (right > map->size.cx)
            {
                proc(data, left, map->size.cx);

                left = 0;
                right -= map->size.cx;
            }

            proc(data, left, right);
        }
        else
        {
            proc(data, span->left, span->right);
        }

        span = span->next;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  GetWorldMapColorIndex
//
////////////////////////////////////////////////////////////////////////////

int GetWorldMapColorIndex(
    LPWORLDMAP map,
    int x,
    int y)
{
    //
    //  Protect against faulting.
    //
    if ( !map->bits ||
         (x < 0) || (x >= map->size.cx) ||
         (y < 0) || (y >= map->size.cy) )
    {
        return (-1);
    }

    //
    //  Correct source X coordinate for map's virtual rotation.
    //
    x += 2 * (int)map->size.cx - map->rotation;
    x %= (int)map->size.cx;

    //
    //  Correct for dib origin.
    //
    y = (LONG)map->size.cy - 1 - y;

    return ( map->bits[map->scanbytes * y + x] );
}


////////////////////////////////////////////////////////////////////////////
//
//  NewSpan
//
////////////////////////////////////////////////////////////////////////////

DIRTYSPAN *NewSpan(
    DIRTYSTUFF *dirty,
    DIRTYSPAN *a,
    DIRTYSPAN *b)
{
    DIRTYSPAN *span = dirty->freespans;

    if (span)
    {
        dirty->freespans = span->next;
    }
    else
    {
        if ((span = (DIRTYSPAN *)LocalAlloc(LPTR, sizeof(DIRTYSPAN))) == NULL)
        {
            return (NULL);
        }
    }

    span->next = b;

    if (a)
    {
        a->next = span;
    }
    else
    {
        dirty->spans = span;
    }

    return (span);
}


////////////////////////////////////////////////////////////////////////////
//
//  DeleteSpan
//
////////////////////////////////////////////////////////////////////////////

void DeleteSpan(
    DIRTYSTUFF *dirty,
    DIRTYSPAN *a,
    DIRTYSPAN *b)
{
    if (a)
    {
        a->next = b->next;
    }
    else
    {
        dirty->spans = b->next;
    }

    b->next = dirty->freespans;
    dirty->freespans = b;
}


////////////////////////////////////////////////////////////////////////////
//
//  AddDirtySpan
//
////////////////////////////////////////////////////////////////////////////

void AddDirtySpan(
    DIRTYSTUFF *dirty,
    int left,
    int cx)
{
    int right = left + cx;
    DIRTYSPAN *curr = dirty->spans;
    DIRTYSPAN *temp = NULL;
    DIRTYSPAN *span;

    cx = left - 1;
    while (curr && (cx > curr->right))
    {
        temp = curr;
        curr = curr->next;
    }

    cx = right + 1;
    if (curr && (cx >= curr->left))
    {
        if (left < curr->left)
        {
            curr->left = left;
        }
        span = temp = curr;

        if (right > curr->right)
        {
            curr->right = right;
            curr = curr->next;

            while (curr && (cx >= curr->left))
            {
                span->right = curr->right;

                DeleteSpan(dirty, temp, curr);
                temp = temp->next;
                curr = (temp ? temp->next : NULL);
            }
        }
    }
    else
    {
        if ((span = NewSpan(dirty, temp, curr)) == NULL)
        {
            if (!temp)
            {
                return;
            }
            span = temp;
            left = span->left;
        }

        span->left = left;
        span->right = right;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  ChangeWorldMapColor
//
////////////////////////////////////////////////////////////////////////////

void ChangeWorldMapColor(
    LPWORLDMAP map,
    int index,
    const RGBQUAD *color,
    int x,
    int cx)
{
    if ((index >= 0) && (index < WORLDMAP_MAX_COLORS))
    {
        //
        //  Store the new color.
        //
        map->dirty.colors[index] = *color;

        //
        //  Update the dirty markers to include this entry.
        //
        if (index < map->dirty.first)
        {
            map->dirty.first = index;
        }
        if (index > map->dirty.last)
        {
            map->dirty.last = index;
        }
    }

    while (((x + cx) > map->size.cx) && (x >= 0))
    {
        x -= map->size.cx;
    }

    if (x < 0)
    {
        AddDirtySpan(&map->dirty, map->size.cx + x, -x);
        cx += x;
        x = 0;
    }

    AddDirtySpan(&map->dirty, x, cx);
}


////////////////////////////////////////////////////////////////////////////
//
//  CommitChanges
//
////////////////////////////////////////////////////////////////////////////

void CommitChanges(
    LPWORLDMAP map)
{
    if (map->dirty.last >= 0)
    {
        SetDIBColorTable( map->original.dc,
                          map->dirty.first,
                          1 + map->dirty.last - map->dirty.first,
                          map->dirty.colors + map->dirty.first );

        //
        //  Reset the dirty markers.
        //
        map->dirty.first = WORLDMAP_MAX_COLORS;
        map->dirty.last = -1;
    }

    while (map->dirty.spans)
    {
        DIRTYSPAN *span = map->dirty.spans;

        if (map->prepared.dc)
        {
            BitBlt( map->prepared.dc,
                    span->left,
                    0,
                    span->right - span->left,
                    (int)map->size.cy,
                    map->original.dc,
                    span->left,
                    0,
                    SRCCOPY );
        }

        DeleteSpan(&map->dirty, NULL, span);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawWorldMap
//
////////////////////////////////////////////////////////////////////////////

void DrawWorldMap(
    HDC dc,
    int xdst,
    int ydst,
    int cx,
    int cy,
    LPWORLDMAP map,
    int xmap,
    int ymap,
    DWORD rop)
{
    CommitChanges(map);

    //
    //  Lop off extra Y stuff cause there's nothing there.
    //
    if ((ymap + cy) > (int)map->size.cy)
    {
        cy = (int)map->size.cy - ymap;
    }

    //
    //  Clip off extra X so we'll enter the case below only when we need to.
    //
    if (cx > (int)map->size.cx)
    {
        cx = (int)map->size.cx;
    }

    //
    //  Correct source X coordinate for map's virtual rotation.
    //
    xmap += 2 * (int)map->size.cx - map->rotation;
    xmap %= (int)map->size.cx;

    //
    //  See if the blt rect falls off the end of our flat little world.
    //
    if ((xmap + cx) > (int)map->size.cx)
    {
        //
        //  Compute the width of the first blt.
        //
        int firstcx = (int)map->size.cx - xmap;

        //
        //  See bits.  See bits blt.
        //
        BitBlt(dc, xdst, ydst, firstcx, cy, map->source, xmap, ymap, rop);

        //
        //  Adjust the params so the second blt does the right wrapping.
        //
        xdst += firstcx;
        cx -= firstcx;
        xmap = 0;
    }

    //
    //  blt bits blt!
    //
    BitBlt(dc, xdst, ydst, cx, cy, map->source, xmap, ymap, rop);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\vidupgrd\migrate.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    migrate.cpp

Environment:

    WIN32 User Mode

--*/


#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <initguid.h>
#include "migrate.h"
#include <regstr.h>


// this will change when the .h is moved to a public location
#include "comp.h"

const TCHAR szWhackDevice[] = TEXT("\\Device");


//
// Data
//

PFN_CM_LOCATE_DEVNODE gpfn_CM_Locate_DevNode = NULL;
PFN_SETUP_DI_ENUM_DEVICES_INTERFACES gpfn_SetupDiEnumDeviceInterfaces = NULL;
PFN_SETUP_DI_GET_DEVICE_INTERFACE_DETAIL gpfn_SetupDiGetDeviceInterfaceDetail = NULL;
PFN_SETUP_DI_CREATE_DEVICE_INTERFACE_REG_KEY gpfn_SetupDiCreateDeviceInterfaceRegKey = NULL;
PFN_SETUP_DI_OPEN_DEVICE_INTERFACE_REG_KEY gpfn_SetupDiOpenDeviceInterfaceRegKey = NULL;
PFN_SETUP_DI_CREATE_DEVICE_INTERFACE gpfn_SetupDiCreateDeviceInterface = NULL;


//
// DllMain
//

extern "C" {

BOOL APIENTRY
DllMain(HINSTANCE hDll,
        DWORD dwReason,
        LPVOID lpReserved)
{
    switch (dwReason) {

    case DLL_PROCESS_ATTACH:
        break;

    case DLL_PROCESS_DETACH:
    	break;

    case DLL_THREAD_DETACH:
        break;

    case DLL_THREAD_ATTACH:
        break;

    default:
    	break;
    }

    return TRUE;
}

}


BOOL
VideoUpgradeCheck(
    PCOMPAIBILITYCALLBACK CompatibilityCallback,
    LPVOID Context
    )
{
    DWORD dwDisposition;
    HKEY hKey = 0;
    OSVERSIONINFO osVer;
    DWORD cb;
    BOOL bSuccess = FALSE;

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                       SZ_UPDATE_SETTINGS,
                       0,
                       NULL,
                       REG_OPTION_NON_VOLATILE,
                       KEY_WRITE,
                       NULL,
                       &hKey,
                       &dwDisposition) != ERROR_SUCCESS) {

        //
        // Oh well, guess we can't write it, no big deal
        //

        hKey = 0;
        goto Cleanup;
    }

    ZeroMemory(&osVer, sizeof(OSVERSIONINFO));
    osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if (!GetVersionEx(&osVer)) {

        //
        // We can't get the version info, no big deal
        //

        goto Cleanup;
    }

    //
    // Get the current device caps and store them away for the
    // display applet to apply later.
    // Do it only if this is not a remote session.
    //

    if (!GetSystemMetrics(SM_REMOTESESSION)) {
        SaveDisplaySettings(hKey, &osVer);
    }

    //
    // Store the OS version we are upgrading from
    //

    SaveOsInfo(hKey, &osVer);

    //
    // Save info about the legacy driver
    //

    SaveLegacyDriver(hKey);

    //
    // Save the video services 
    //

    if ((osVer.dwPlatformId == VER_PLATFORM_WIN32_NT) &&
        (osVer.dwMajorVersion <= 4)) {
        
        SaveNT4Services(hKey);
    }

    //
    // Save the applet extensions
    //

    if ((osVer.dwPlatformId == VER_PLATFORM_WIN32_NT) &&
        (osVer.dwMajorVersion <= 5)) {

        SaveAppletExtensions(hKey);
    }

    bSuccess = TRUE;

Cleanup:

    if (hKey != 0) {
        RegCloseKey(hKey);
    }

    return bSuccess;
}


VOID
SaveOsInfo(
    HKEY hKey,
    POSVERSIONINFO posVer
    )
{
    DWORD cb;

    //
    // Can't just dump the struct into the registry b/c of the size
    // difference between CHAR and WCHAR (ie, szCSDVersion)
    //

    cb = sizeof(DWORD);
    RegSetValueEx(hKey,
                  SZ_UPGRADE_FROM_PLATFORM,
                  0,
                  REG_DWORD,
                  (PBYTE)&(posVer->dwPlatformId),
                  cb);

    cb = sizeof(DWORD);
    RegSetValueEx(hKey,
                  SZ_UPGRADE_FROM_MAJOR_VERSION,
                  0,
                  REG_DWORD,
                  (PBYTE)&(posVer->dwMajorVersion),
                  cb);

    cb = sizeof(DWORD);
    RegSetValueEx(hKey,
                  SZ_UPGRADE_FROM_MINOR_VERSION,
                  0,
                  REG_DWORD,
                  (PBYTE)&(posVer->dwMinorVersion),
                  cb);

    cb = sizeof(DWORD);
    RegSetValueEx(hKey,
                  SZ_UPGRADE_FROM_BUILD_NUMBER,
                  0,
                  REG_DWORD,
                  (PBYTE)&(posVer->dwBuildNumber),
                  cb);

    cb = lstrlen(posVer->szCSDVersion);
    RegSetValueEx(hKey,
                  SZ_UPGRADE_FROM_VERSION_DESC,
                  0,
                  REG_SZ,
                  (PBYTE)&(posVer->szCSDVersion),
                  cb);
}


VOID
SaveLegacyDriver(
    HKEY hKey
    )
{
    LPTSTR pszEnd;
    HKEY   hKeyMap, hKeyDriver;
    int    i = 0, num = 0;
    TCHAR  szValueName[128], szData[128];
    PTCHAR szPath;
    DWORD  cbValue, cbData, dwType;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     SZ_VIDEOMAP,
                     0,
                     KEY_READ,
                     &hKeyMap) !=  ERROR_SUCCESS) {
        return;
    }

    for (cbValue = (sizeof(szValueName) - 1) / sizeof(TCHAR),
         cbData = sizeof(szData) / sizeof(TCHAR);

         RegEnumValue(hKeyMap, i++, szValueName, &cbValue, NULL, &dwType,
                      (PBYTE) szData, &cbData) != ERROR_NO_MORE_ITEMS;

         cbValue = (sizeof(szValueName) - 1) / sizeof(TCHAR),
         cbData = sizeof(szData) / sizeof(TCHAR) ) {

        if ((REG_SZ != dwType) ||
            (_tcsicmp(szData, TEXT("VgaSave")) == 0)) {

            continue;
        }

        //
        // Make sure the value's name is \Device\XxxY
        //

        if ((cbValue < (DWORD) lstrlen(szWhackDevice)) ||
            _tcsnicmp(szValueName, szWhackDevice, lstrlen(szWhackDevice))) {

            continue;
        }

        szPath = SubStrEnd(SZ_REGISTRYMACHINE, szData);

        for (pszEnd = szPath + lstrlen(szPath);
             pszEnd != szPath && *pszEnd != TEXT('\\');
             pszEnd--) {
            ; // nothing
        }

        //
        // Remove the \DeviceX at the end of the path
        //

        *pszEnd = TEXT('\0');

        //
        // First check if their is a binary name in there that we should use.
        //

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         szPath,
                         0,
                         KEY_READ,
                         &hKeyDriver) ==  ERROR_SUCCESS) {

            //
            // Parse the device map and open the registry.
            //

            cbValue = sizeof(szValueName);
            if (RegQueryValueEx(hKeyDriver,
                                TEXT("ImagePath"),
                                NULL,
                                NULL,
                                (LPBYTE) szValueName,
                                &cbValue) == ERROR_SUCCESS) {

                //
                // This is a binary, extract the name, which will be of the form
                // ...\driver.sys
                //

                LPTSTR pszDriver, pszDriverEnd;

                pszDriver = szValueName;
                pszDriverEnd = pszDriver + lstrlen(pszDriver);

                while(pszDriverEnd != pszDriver &&
                      *pszDriverEnd != TEXT('.')) {
                    pszDriverEnd--;
                }

                *pszDriverEnd = UNICODE_NULL;

                while(pszDriverEnd != pszDriver &&
                      *pszDriverEnd != TEXT('\\')) {
                    pszDriverEnd--;
                }

                pszDriverEnd++;

                //
                // If pszDriver and pszDriverEnd are different, we now
                // have the driver name.
                //

                if (pszDriverEnd > pszDriver) {
                    if (_tcsicmp(pszDriverEnd, TEXT("vga")) != 0) {
                        RegCloseKey(hKeyDriver);
                        continue;
                    }

                    wsprintf(szValueName, TEXT("Driver%d"), num);
                    cbValue = lstrlen(pszDriverEnd);
                    RegSetValueEx(hKey,
                                  szValueName,
                                  0,
                                  REG_SZ,
                                  (PBYTE) pszDriverEnd,
                                  cbValue);
                }
            }

            RegCloseKey(hKeyDriver);
        }

        //
        // Get the actual service name
        //

        for( ; pszEnd > szPath && *pszEnd != TEXT('\\'); pszEnd--) {
            ;
        }
        pszEnd++;

        //
        // Save the service name
        //

        wsprintf(szValueName, TEXT("Service%d"), num++);
        cbValue = lstrlen(pszEnd);
        RegSetValueEx(hKey,
                      szValueName,
                      0,
                      REG_SZ,
                      (PBYTE) pszEnd,
                      cbValue);
    }

    cbValue = sizeof(DWORD);
    RegSetValueEx(hKey,
                  TEXT("NumDrivers"),
                  0,
                  REG_DWORD,
                  (PBYTE) &num,
                  cbValue);

    RegCloseKey(hKeyMap);
}


BOOL
SaveDisplaySettings(
    HKEY hKey,
    POSVERSIONINFO posVer
    )
{
    PVU_PHYSICAL_DEVICE pPhysicalDevice = NULL;
    BOOL bSuccess = FALSE;

    if ((posVer->dwPlatformId == VER_PLATFORM_WIN32_NT) &&
        (posVer->dwMajorVersion >= 5)) {

        //
        // Try the new way to get the display settings
        //

        CollectDisplaySettings(&pPhysicalDevice);
    }

    if (pPhysicalDevice == NULL) {

        //
        // Try the old way to get the display settings
        //

        LegacyCollectDisplaySettings(&pPhysicalDevice);
    }

    if (pPhysicalDevice != NULL) {

        //
        // Save the display settings to registry
        //

        bSuccess = WriteDisplaySettingsToRegistry(hKey, pPhysicalDevice);

        //
        // Cleanup
        //

        FreeAllNodes(pPhysicalDevice);
    }

    return bSuccess;
}


BOOL
GetDevInfoData(
    IN  LPTSTR pDeviceKey,
    OUT HDEVINFO* phDevInfo,
    OUT PSP_DEVINFO_DATA pDevInfoData
    )

/*

    Note: If this function retuns success, the caller is responsible
          to destroy the device info list returned in phDevInfo

*/

{
    LPWSTR pwInterfaceName = NULL;
    LPWSTR pwInstanceID = NULL;
    BOOL bSuccess = FALSE;

    ASSERT (pDeviceKey != NULL);

    if (AllocAndReadInterfaceName(pDeviceKey, &pwInterfaceName)) {

        bSuccess = GetDevInfoDataFromInterfaceName(pwInterfaceName,
                                                   phDevInfo,
                                                   pDevInfoData);
        LocalFree(pwInterfaceName);

    }

    if ((!bSuccess) &&
        AllocAndReadInstanceID(pDeviceKey, &pwInstanceID)) {

        bSuccess = GetDevInfoDataFromInstanceID(pwInstanceID,
                                                phDevInfo,
                                                pDevInfoData);
        LocalFree(pwInstanceID);

    }

    return bSuccess;
}


BOOL
GetDevInfoDataFromInterfaceName(
    IN  LPWSTR pwInterfaceName,
    OUT HDEVINFO* phDevInfo,
    OUT PSP_DEVINFO_DATA pDevInfoData
    )

/*

    Note: If this function retuns success, the caller is responsible
          to destroy the device info list returned in phDevInfo

*/

{
    LPWSTR pwDevicePath = NULL;
    HDEVINFO hDevInfo = INVALID_HANDLE_VALUE;
    SP_DEVINFO_DATA DevInfoData;
    SP_DEVICE_INTERFACE_DATA InterfaceData;
    PSP_DEVICE_INTERFACE_DETAIL_DATA pInterfaceDetailData = NULL;
    DWORD InterfaceIndex = 0;
    DWORD InterfaceSize = 0;
    BOOL bMatch = FALSE;

    ASSERT (pwInterfaceName != NULL);
    ASSERT (phDevInfo != NULL);
    ASSERT (pDevInfoData != NULL);

    ASSERT(gpfn_SetupDiEnumDeviceInterfaces != NULL);
    ASSERT(gpfn_SetupDiGetDeviceInterfaceDetail != NULL);

    //
    // Enumerate all display adapter interfaces
    //

    hDevInfo = SetupDiGetClassDevs(&GUID_DISPLAY_ADAPTER_INTERFACE,
                                   NULL,
                                   NULL,
                                   DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);

    if (hDevInfo == INVALID_HANDLE_VALUE) {
        goto Cleanup;
    }

    InterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
    while ((*gpfn_SetupDiEnumDeviceInterfaces)(hDevInfo,
                                               NULL,
                                               &GUID_DISPLAY_ADAPTER_INTERFACE,
                                               InterfaceIndex,
                                               &InterfaceData)) {

        //
        // Get the required size for the interface
        //

        InterfaceSize = 0;
        (*gpfn_SetupDiGetDeviceInterfaceDetail)(hDevInfo,
                                                &InterfaceData,
                                                NULL,
                                                0,
                                                &InterfaceSize,
                                                NULL);

        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            goto Cleanup;
        }

        //
        // Alloc memory for the interface
        //

        pInterfaceDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA)
            LocalAlloc(LPTR, InterfaceSize);
        if (pInterfaceDetailData == NULL)
            goto Cleanup;

        //
        // Get the interface
        //

        pInterfaceDetailData->cbSize =
            sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
        DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

        if ((*gpfn_SetupDiGetDeviceInterfaceDetail)(hDevInfo,
                                                    &InterfaceData,
                                                    pInterfaceDetailData,
                                                    InterfaceSize,
                                                    &InterfaceSize,
                                                    &DevInfoData)) {

            //
            // Is the InterfaceName the same as the DevicePath?
            //

#ifdef UNICODE
            pwDevicePath = pInterfaceDetailData->DevicePath;
#else
            {
                SIZE_T cch = strlen(pInterfaceDetailData->DevicePath) + 1;
                pwDevicePath = LocalAlloc(LPTR, cch * sizeof(WCHAR));
                if (pwDevicePath == NULL) {
                    goto Cleanup;
                }
                MultiByteToWideChar(CP_ACP, 0,
                                    pInterfaceDetailData->DevicePath,
                                    -1, pwDevicePath, cch);
            }
#endif

            //
            // The first 4 characters of the interface name are different
            // between user mode and kernel mode (e.g. "\\?\" vs "\\.\")
            // Therefore, ignore them.
            //

            bMatch = (_wcsnicmp(pwInterfaceName + 4,
                                pwDevicePath + 4,
                                wcslen(pwInterfaceName + 4)) == 0);

#ifndef UNICODE
            LocalFree(pwDevicePath);
            pwDevicePath = NULL;
#endif

            if (bMatch) {

                //
                // We found the device
                //

                *phDevInfo = hDevInfo;
                CopyMemory(pDevInfoData, &DevInfoData, sizeof(SP_DEVINFO_DATA));

                break;
            }
        }

        //
        // Clean-up
        //

        LocalFree(pInterfaceDetailData);
        pInterfaceDetailData = NULL;

        //
        // Next interface ...
        //

        InterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
        ++InterfaceIndex;
    }

Cleanup:

    if (pInterfaceDetailData != NULL) {
        LocalFree(pInterfaceDetailData);
    }

    //
    // Upon success, the caller is responsible to destroy the list
    //

    if (!bMatch && (hDevInfo != INVALID_HANDLE_VALUE)) {
        SetupDiDestroyDeviceInfoList(hDevInfo);
    }

    return bMatch;
}


BOOL
GetDevInfoDataFromInstanceID(
    IN  LPWSTR pwInstanceID,
    OUT HDEVINFO* phDevInfo,
    OUT PSP_DEVINFO_DATA pDevInfoData
    )

/*

    Note: If this function retuns success, the caller is responsible
          to destroy the device info list returned in phDevInfo

*/

{
    LPTSTR pInstanceID = NULL;
    HDEVINFO hDevInfo = INVALID_HANDLE_VALUE;
    DWORD DeviceIndex = 0;
    SP_DEVINFO_DATA DevInfoData;
    DEVINST DevInst;
    BOOL bSuccess = FALSE, bLocate = FALSE;

    ASSERT (pwInstanceID != NULL);
    ASSERT (phDevInfo != NULL);
    ASSERT (pDevInfoData != NULL);

    ASSERT (gpfn_CM_Locate_DevNode != NULL);

#ifdef UNICODE
    pInstanceID = pwInstanceID;
#else
    {
    SIZE_T cch = wcslen(pwInstanceID) + 1;
    pInstanceID = LocalAlloc(LPTR, cch * sizeof(CHAR));
    if (pInstanceID == NULL) {
        return FALSE;
    }
    WideCharToMultiByte(CP_ACP, 0,
                        pwDeviceID, -1,
                        pInstanceID, cch * sizeof(CHAR),
                        NULL, NULL);
    }
#endif

    bLocate =
        ((*gpfn_CM_Locate_DevNode)(&DevInst, pInstanceID, 0) == CR_SUCCESS);

#ifndef UNICODE
    LocalFree(pInstanceID);
    pInstanceID = NULL;
#endif

    if (!bLocate) {
        goto Cleanup;
    }

    //
    // Enumerate all display adapters
    //

    hDevInfo = SetupDiGetClassDevs((LPGUID)&GUID_DEVCLASS_DISPLAY,
                                   NULL,
                                   NULL,
                                   DIGCF_PRESENT);

    if (hDevInfo == INVALID_HANDLE_VALUE) {
        goto Cleanup;
    }

    DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    while (SetupDiEnumDeviceInfo(hDevInfo, DeviceIndex, &DevInfoData)) {

        if (DevInfoData.DevInst == DevInst) {

            //
            // We found it
            //

            *phDevInfo = hDevInfo;
            CopyMemory(pDevInfoData, &DevInfoData, sizeof(SP_DEVINFO_DATA));
            bSuccess = TRUE;

            break;
        }

        //
        // Next display adapter
        //

        ++DeviceIndex;
        DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    }

Cleanup:

    //
    // Upon success, the caller is responsible to destroy the list
    //

    if (!bSuccess && (hDevInfo != INVALID_HANDLE_VALUE)) {
        SetupDiDestroyDeviceInfoList(hDevInfo);
    }

    return bSuccess;
}


VOID
CollectDisplaySettings(
    PVU_PHYSICAL_DEVICE* ppPhysicalDevice
    )
{
    DISPLAY_DEVICE DisplayDevice;
    DEVMODE DevMode;
    PVU_LOGICAL_DEVICE pLogicalDevice = NULL;
    DWORD dwEnum = 0;
    BOOL bGoOn = FALSE;
    HDEVINFO hDevInfo = INVALID_HANDLE_VALUE;
    SP_DEVINFO_DATA DevInfoData;
    DWORD BusNumber = 0, Address = 0;
    LPTSTR pDeviceX = NULL, pX = NULL;
    HINSTANCE hinstSetupApi = NULL;
    BOOL bInserted = FALSE;
    HKEY hDeviceKey = NULL;
    BOOL bDummy;

    hinstSetupApi = LoadLibrary(TEXT("SETUPAPI.DLL"));

    if (hinstSetupApi == NULL) {
        goto Cleanup;
    }

#ifdef UNICODE

    gpfn_CM_Locate_DevNode = (PFN_CM_LOCATE_DEVNODE)
        GetProcAddress(hinstSetupApi, "CM_Locate_DevNodeW");

    gpfn_SetupDiGetDeviceInterfaceDetail = (PFN_SETUP_DI_GET_DEVICE_INTERFACE_DETAIL)
        GetProcAddress(hinstSetupApi, "SetupDiGetDeviceInterfaceDetailW");

    gpfn_SetupDiCreateDeviceInterfaceRegKey = (PFN_SETUP_DI_CREATE_DEVICE_INTERFACE_REG_KEY)
        GetProcAddress(hinstSetupApi, "SetupDiCreateDeviceInterfaceRegKeyW");

    gpfn_SetupDiCreateDeviceInterface = (PFN_SETUP_DI_CREATE_DEVICE_INTERFACE)
        GetProcAddress(hinstSetupApi, "SetupDiCreateDeviceInterfaceW");

#else // UNICODE

    gpfn_CM_Locate_DevNode = (PFN_CM_LOCATE_DEVNODE)
        GetProcAddress(hinstSetupApi, "CM_Locate_DevNodeA");

    gpfn_SetupDiGetDeviceInterfaceDetail = (PFN_SETUP_DI_GET_DEVICE_INTERFACE_DETAIL)
        GetProcAddress(hinstSetupApi, "SetupDiGetDeviceInterfaceDetailA");

    gpfn_SetupDiCreateDeviceInterfaceRegKey = (PFN_SETUP_DI_CREATE_DEVICE_INTERFACE_REG_KEY)
        GetProcAddress(hinstSetupApi, "SetupDiCreateDeviceInterfaceRegKeyA");

    gpfn_SetupDiCreateDeviceInterface = (PFN_SETUP_DI_CREATE_DEVICE_INTERFACE)
        GetProcAddress(hinstSetupApi, "SetupDiCreateDeviceInterfaceA");

#endif // UNICODE

    gpfn_SetupDiEnumDeviceInterfaces = (PFN_SETUP_DI_ENUM_DEVICES_INTERFACES)
        GetProcAddress(hinstSetupApi, "SetupDiEnumDeviceInterfaces");

    gpfn_SetupDiOpenDeviceInterfaceRegKey = (PFN_SETUP_DI_OPEN_DEVICE_INTERFACE_REG_KEY)
        GetProcAddress(hinstSetupApi, "SetupDiOpenDeviceInterfaceRegKey");

    if ((gpfn_CM_Locate_DevNode == NULL) ||
        (gpfn_SetupDiEnumDeviceInterfaces == NULL) ||
        (gpfn_SetupDiGetDeviceInterfaceDetail == NULL) ||
        (gpfn_SetupDiCreateDeviceInterfaceRegKey == NULL) ||
        (gpfn_SetupDiOpenDeviceInterfaceRegKey == NULL) ||
        (gpfn_SetupDiCreateDeviceInterface == NULL)) {

        goto Cleanup;
    }

    //
    // Enumerate all video devices
    //

    DisplayDevice.cb = sizeof(DISPLAY_DEVICE);
    while (EnumDisplayDevices(NULL, dwEnum, &DisplayDevice, 0)) {

        bInserted = FALSE;
        pLogicalDevice = NULL;

        //
        // Get the device info data corresponding to the current
        // video device
        //

        if (!GetDevInfoData(DisplayDevice.DeviceKey,
                            &hDevInfo,
                            &DevInfoData)) {

            goto NextDevice;
        }
        ASSERT (hDevInfo != INVALID_HANDLE_VALUE);

        //
        // Retrieve the bus number and address
        //

        bGoOn = SetupDiGetDeviceRegistryProperty(hDevInfo,
                                                 &DevInfoData,
                                                 SPDRP_BUSNUMBER,
                                                 NULL,
                                                 (PBYTE)&BusNumber,
                                                 sizeof(BusNumber),
                                                 NULL) &&
                SetupDiGetDeviceRegistryProperty(hDevInfo,
                                                 &DevInfoData,
                                                 SPDRP_ADDRESS,
                                                 NULL,
                                                 (PBYTE)&Address,
                                                 sizeof(Address),
                                                 NULL);

        SetupDiDestroyDeviceInfoList(hDevInfo);

        if (!bGoOn) {

            goto NextDevice;
        }

        //
        // Allocate memory for the logical device
        //

        pLogicalDevice = (PVU_LOGICAL_DEVICE)
            LocalAlloc(LPTR, sizeof(VU_LOGICAL_DEVICE));

        if (pLogicalDevice == NULL) {
            goto NextDevice;
        }

        //
        // DeviceX
        //

        pDeviceX = DisplayDevice.DeviceKey + _tcslen(DisplayDevice.DeviceKey);

        while ((pDeviceX != DisplayDevice.DeviceKey) &&
               (*pDeviceX != TEXT('\\'))) {
            pDeviceX--;
        }

        if (pDeviceX == DisplayDevice.DeviceKey) {
            goto NextDevice;
        }

        pX = SubStrEnd(SZ_DEVICE, pDeviceX);
        
        if (pX == pDeviceX) {

            //
            // The new key is used: CCS\Control\Video\[GUID]\000X
            //

            pX++;
            pLogicalDevice->DeviceX = _ttoi(pX);
        
        } else {

            //
            // The old key is used: CCS\Services\[SrvName]\DeviceX
            //
            
            pLogicalDevice->DeviceX = _ttoi(pX);
        }

        //
        // AttachedToDesktop
        //

        pLogicalDevice->AttachedToDesktop =
            ((DisplayDevice.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP) != 0);
        pLogicalDevice->ValidFields |= VU_ATTACHED_TO_DESKTOP;

        if (pLogicalDevice->AttachedToDesktop) {

            //
            // Get the current mode
            //

            DevMode.dmSize = sizeof(DEVMODE);
            if (EnumDisplaySettings(DisplayDevice.DeviceName,
                                    ENUM_CURRENT_SETTINGS,
                                    &DevMode)) {

                //
                // RelativeX, RelativeY, BitsPerPel, XResolution,
                // YResolution, VRefresh & Flags
                //

                pLogicalDevice->ValidFields |= VU_RELATIVE_X;
                pLogicalDevice->RelativeX = DevMode.dmPosition.x;

                pLogicalDevice->ValidFields |= VU_RELATIVE_Y;
                pLogicalDevice->RelativeY = DevMode.dmPosition.y;

                pLogicalDevice->ValidFields |= VU_BITS_PER_PEL;
                pLogicalDevice->BitsPerPel = DevMode.dmBitsPerPel;

                pLogicalDevice->ValidFields |= VU_X_RESOLUTION;
                pLogicalDevice->XResolution = DevMode.dmPelsWidth;

                pLogicalDevice->ValidFields |= VU_Y_RESOLUTION;
                pLogicalDevice->YResolution = DevMode.dmPelsHeight;

                pLogicalDevice->ValidFields |= VU_VREFRESH;
                pLogicalDevice->VRefresh = DevMode.dmDisplayFrequency;

                pLogicalDevice->ValidFields |= VU_FLAGS;
                pLogicalDevice->Flags = DevMode.dmDisplayFlags;

                //
                // Ignore the following settings for now:
                //     DefaultSettings.XPanning - DevMode.dmPanningWidth
                //     DefaultSettings.YPanning - DevMode.dmPanningHeight
                //     DefaultSettings.DriverExtra - DevMode.dmDriverExtra
                //
            }
        }

        if (GetDeviceRegKey(DisplayDevice.DeviceKey, 
                            &hDeviceKey, 
                            &bDummy))
        {
            DWORD dwTemp, cb;
            
            //
            // Hardware acceleration
            // 

            cb = sizeof(dwTemp);
            if (RegQueryValueEx(hDeviceKey,
                                SZ_HW_ACCELERATION,
                                NULL,
                                NULL,
                                (LPBYTE)&dwTemp,
                                &cb) == ERROR_SUCCESS) {

                pLogicalDevice->ValidFields |= VU_HW_ACCELERATION;
                pLogicalDevice->HwAcceleration = dwTemp;
            }
        
            //
            // Pruning mode
            // 

            cb = sizeof(dwTemp);
            if (RegQueryValueEx(hDeviceKey,
                                SZ_PRUNNING_MODE,
                                NULL,
                                NULL,
                                (LPBYTE)&dwTemp,
                                &cb) == ERROR_SUCCESS) {

                pLogicalDevice->ValidFields |= VU_PRUNING_MODE;
                pLogicalDevice->PruningMode = dwTemp;
            }

            RegCloseKey(hDeviceKey);
        }

        bInserted = InsertNode(ppPhysicalDevice,
                               pLogicalDevice,
                               0,
                               BusNumber,
                               Address);

NextDevice:

        if (!bInserted && (pLogicalDevice != NULL)) {

            LocalFree(pLogicalDevice);
            pLogicalDevice = NULL;
        }

        DisplayDevice.cb = sizeof(DISPLAY_DEVICE);
        ++dwEnum;
    }

Cleanup:

    if (hinstSetupApi != NULL) {

        gpfn_CM_Locate_DevNode = NULL;
        gpfn_SetupDiEnumDeviceInterfaces = NULL;
        gpfn_SetupDiGetDeviceInterfaceDetail = NULL;
        gpfn_SetupDiCreateDeviceInterfaceRegKey = NULL;
        gpfn_SetupDiOpenDeviceInterfaceRegKey = NULL;
        gpfn_SetupDiCreateDeviceInterface = NULL;

        FreeLibrary(hinstSetupApi);
    }
}


BOOL
InsertNode(
    PVU_PHYSICAL_DEVICE* ppPhysicalDevice,
    PVU_LOGICAL_DEVICE pLogicalDevice,
    DWORD Legacy,
    DWORD BusNumber,
    DWORD Address
    )
{
    PVU_PHYSICAL_DEVICE pPhysicalDevice = *ppPhysicalDevice;
    BOOL bSuccess = FALSE;
    PVU_LOGICAL_DEVICE pPrevLogicalDevice = NULL;
    PVU_LOGICAL_DEVICE pNextLogicalDevice = NULL;

    ASSERT (pLogicalDevice != NULL);
    ASSERT((Legacy == 0) || (*ppPhysicalDevice == NULL));

    if (Legacy == 0) {

        //
        // If not Legacy, try to find if there is a device
        // with the same bus location
        //

        while (pPhysicalDevice != NULL) {

            if ((pPhysicalDevice->BusNumber == BusNumber) &&
                (pPhysicalDevice->Address == Address)) {

                break;
            }

            pPhysicalDevice = pPhysicalDevice->pNextPhysicalDevice;
        }
    }

    if (pPhysicalDevice != NULL) {

        //
        // There is already a logical device with the same address
        //

        ASSERT (pPhysicalDevice->pFirstLogicalDevice != NULL);

        pPhysicalDevice->CountOfLogicalDevices++;

        pPrevLogicalDevice = pNextLogicalDevice =
            pPhysicalDevice->pFirstLogicalDevice;

        while (pNextLogicalDevice &&
               (pNextLogicalDevice->DeviceX <= pLogicalDevice->DeviceX)) {

            pPrevLogicalDevice = pNextLogicalDevice;
            pNextLogicalDevice = pNextLogicalDevice->pNextLogicalDevice;
        }

        if (pPrevLogicalDevice == pNextLogicalDevice) {

            ASSERT (pPrevLogicalDevice == pPhysicalDevice->pFirstLogicalDevice);

            pLogicalDevice->pNextLogicalDevice =
                pPhysicalDevice->pFirstLogicalDevice;
            pPhysicalDevice->pFirstLogicalDevice = pLogicalDevice;

        } else {

            pPrevLogicalDevice->pNextLogicalDevice = pLogicalDevice;
            pLogicalDevice->pNextLogicalDevice = pNextLogicalDevice;
        }

        bSuccess = TRUE;

    } else {

        //
        // This is a new physical device
        //

        pPhysicalDevice = (PVU_PHYSICAL_DEVICE)
            LocalAlloc(LPTR, sizeof(VU_PHYSICAL_DEVICE));

        if (pPhysicalDevice != NULL) {

            pPhysicalDevice->pNextPhysicalDevice = *ppPhysicalDevice;
            *ppPhysicalDevice = pPhysicalDevice;

            pPhysicalDevice->pFirstLogicalDevice = pLogicalDevice;
            pPhysicalDevice->CountOfLogicalDevices = 1;
            pPhysicalDevice->Legacy = Legacy;
            pPhysicalDevice->BusNumber = BusNumber;
            pPhysicalDevice->Address = Address;

            bSuccess = TRUE;
        }
    }

    return bSuccess;
}


VOID
FreeAllNodes(
    PVU_PHYSICAL_DEVICE pPhysicalDevice
    )
{
    PVU_PHYSICAL_DEVICE pTempPhysicalDevice = NULL;
    PVU_LOGICAL_DEVICE pLogicalDevice = NULL, pTempLogicalDevice = NULL;

    while (pPhysicalDevice != NULL) {

        pTempPhysicalDevice = pPhysicalDevice->pNextPhysicalDevice;
        pLogicalDevice = pPhysicalDevice->pFirstLogicalDevice;

        while (pLogicalDevice != NULL) {

            pTempLogicalDevice = pLogicalDevice->pNextLogicalDevice;
            LocalFree(pLogicalDevice);
            pLogicalDevice = pTempLogicalDevice;
        }

        LocalFree(pPhysicalDevice);
        pPhysicalDevice = pTempPhysicalDevice;
    }
}


BOOL
WriteDisplaySettingsToRegistry(
    HKEY hKey,
    PVU_PHYSICAL_DEVICE pPhysicalDevice
    )
{
    PVU_LOGICAL_DEVICE pLogicalDevice = NULL;
    DWORD CountOfPhysicalDevices = 0;
    DWORD CountOfLogicalDevices = 0;
    HKEY hPysicalDeviceKey = 0;
    HKEY hLogicalDeviceKey = 0;
    BOOL bSuccess = FALSE;
    TCHAR Buffer[20];

    while (pPhysicalDevice != NULL) {

        //
        // Create physical device subkey
        //

        _tcscpy(Buffer, SZ_VU_PHYSICAL);
        _stprintf(Buffer + _tcslen(Buffer), TEXT("%d"), CountOfPhysicalDevices);
        DeleteKeyAndSubkeys(hKey, Buffer);

        if (RegCreateKeyEx(hKey,
                           Buffer,
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           KEY_WRITE,
                           NULL,
                           &hPysicalDeviceKey,
                           NULL) != ERROR_SUCCESS) {

            hPysicalDeviceKey = 0;
            goto NextPhysicalDevice;
        }

        if (pPhysicalDevice->Legacy == 0) {

            //
            // BusNumber
            //

            if (RegSetValueEx(hPysicalDeviceKey,
                              SZ_VU_BUS_NUMBER,
                              0,
                              REG_DWORD,
                              (PBYTE)&pPhysicalDevice->BusNumber,
                              sizeof(pPhysicalDevice->BusNumber)) != ERROR_SUCCESS) {

                goto NextPhysicalDevice;
            }

            //
            // Address
            //

            if (RegSetValueEx(hPysicalDeviceKey,
                              SZ_VU_ADDRESS,
                              0,
                              REG_DWORD,
                              (PBYTE)&pPhysicalDevice->Address,
                              sizeof(pPhysicalDevice->Address)) != ERROR_SUCCESS) {

                goto NextPhysicalDevice;
            }

        }

        pLogicalDevice = pPhysicalDevice->pFirstLogicalDevice;
        CountOfLogicalDevices = 0;

        while (pLogicalDevice != NULL) {

            //
            // Create logical device subkey
            //

            _tcscpy(Buffer, SZ_VU_LOGICAL);
            _stprintf(Buffer + _tcslen(Buffer),  TEXT("%d"), CountOfLogicalDevices);
            if (RegCreateKeyEx(hPysicalDeviceKey,
                               Buffer,
                               0,
                               NULL,
                               REG_OPTION_NON_VOLATILE,
                               KEY_WRITE,
                               NULL,
                               &hLogicalDeviceKey,
                               NULL) != ERROR_SUCCESS) {

                hLogicalDeviceKey = 0;

                //
                // Cannot go on with this physical device.
                // The order of logical devices DOES matter in the dual-view case.
                //

                break;
            }

            //
            // AttachedToDesktop
            //

            if (pLogicalDevice->ValidFields & VU_ATTACHED_TO_DESKTOP) {

                RegSetValueEx(hLogicalDeviceKey,
                              SZ_VU_ATTACHED_TO_DESKTOP,
                              0,
                              REG_DWORD,
                              (PBYTE)&pLogicalDevice->AttachedToDesktop,
                              sizeof(pLogicalDevice->AttachedToDesktop));
            }

            //
            // RelativeX
            //

            if (pLogicalDevice->ValidFields & VU_RELATIVE_X) {

                RegSetValueEx(hLogicalDeviceKey,
                              SZ_VU_RELATIVE_X,
                              0,
                              REG_DWORD,
                              (PBYTE)&pLogicalDevice->RelativeX,
                              sizeof(pLogicalDevice->RelativeX));
            }

            //
            // RelativeY
            //

            if (pLogicalDevice->ValidFields & VU_RELATIVE_Y) {

            RegSetValueEx(hLogicalDeviceKey,
                          SZ_VU_RELATIVE_Y,
                          0,
                          REG_DWORD,
                          (PBYTE)&pLogicalDevice->RelativeY,
                          sizeof(pLogicalDevice->RelativeY));
            }

            //
            // BitsPerPel
            //

            if (pLogicalDevice->ValidFields & VU_BITS_PER_PEL) {

                RegSetValueEx(hLogicalDeviceKey,
                              SZ_VU_BITS_PER_PEL,
                              0,
                              REG_DWORD,
                              (PBYTE)&pLogicalDevice->BitsPerPel,
                              sizeof(pLogicalDevice->BitsPerPel));
            }

            //
            // XResolution
            //

            if (pLogicalDevice->ValidFields & VU_X_RESOLUTION) {

                RegSetValueEx(hLogicalDeviceKey,
                              SZ_VU_X_RESOLUTION,
                              0,
                              REG_DWORD,
                              (PBYTE)&pLogicalDevice->XResolution,
                              sizeof(pLogicalDevice->XResolution));
            }

            //
            // YResolution
            //

            if (pLogicalDevice->ValidFields & VU_Y_RESOLUTION) {

                RegSetValueEx(hLogicalDeviceKey,
                              SZ_VU_Y_RESOLUTION,
                              0,
                              REG_DWORD,
                              (PBYTE)&pLogicalDevice->YResolution,
                              sizeof(pLogicalDevice->YResolution));
            }

            //
            // VRefresh
            //

            if (pLogicalDevice->ValidFields & VU_VREFRESH) {

                RegSetValueEx(hLogicalDeviceKey,
                              SZ_VU_VREFRESH,
                              0,
                              REG_DWORD,
                              (PBYTE)&pLogicalDevice->VRefresh,
                              sizeof(pLogicalDevice->VRefresh));
            }

            //
            // Flags
            //

            if (pLogicalDevice->ValidFields & VU_FLAGS) {

                RegSetValueEx(hLogicalDeviceKey,
                              SZ_VU_FLAGS,
                              0,
                              REG_DWORD,
                              (PBYTE)&pLogicalDevice->Flags,
                              sizeof(pLogicalDevice->Flags));
            }

            //
            // Hardware acceleration
            // 

            if (pLogicalDevice->ValidFields & VU_HW_ACCELERATION) {

                RegSetValueEx(hLogicalDeviceKey,
                              SZ_HW_ACCELERATION,
                              0,
                              REG_DWORD,
                              (PBYTE)&pLogicalDevice->HwAcceleration,
                              sizeof(pLogicalDevice->HwAcceleration));
            }

            //
            // Pruning mode
            // 

            if (pLogicalDevice->ValidFields & VU_PRUNING_MODE) {

                RegSetValueEx(hLogicalDeviceKey,
                              SZ_PRUNNING_MODE,
                              0,
                              REG_DWORD,
                              (PBYTE)&pLogicalDevice->PruningMode,
                              sizeof(pLogicalDevice->PruningMode));
            }

            ++CountOfLogicalDevices;

            RegCloseKey(hLogicalDeviceKey);
            hLogicalDeviceKey = 0;

            pLogicalDevice = pLogicalDevice->pNextLogicalDevice;
        }

        if ((CountOfLogicalDevices > 0) &&
            (RegSetValueEx(hPysicalDeviceKey,
                           SZ_VU_COUNT,
                           0,
                           REG_DWORD,
                           (PBYTE)&CountOfLogicalDevices,
                           sizeof(CountOfLogicalDevices)) == ERROR_SUCCESS)) {

            ++CountOfPhysicalDevices;
        }

NextPhysicalDevice:

        if (hPysicalDeviceKey != 0) {

            RegCloseKey(hPysicalDeviceKey);
            hPysicalDeviceKey = 0;
        }

        pPhysicalDevice = pPhysicalDevice->pNextPhysicalDevice;
    }

    if (CountOfPhysicalDevices > 0) {

        bSuccess =
            (RegSetValueEx(hKey,
                           SZ_VU_COUNT,
                           0,
                           REG_DWORD,
                           (PBYTE)&CountOfPhysicalDevices,
                           sizeof(CountOfPhysicalDevices)) != ERROR_SUCCESS) ;
    }

    return bSuccess;
}


VOID
LegacyCollectDisplaySettings(
    PVU_PHYSICAL_DEVICE* ppPhysicalDevice
    )
{
    PVU_LOGICAL_DEVICE pLogicalDevice = NULL;
    DWORD cb;
    INT Width, Height, Index;
    BOOL useVga = FALSE;
    HDC hDisplay;
    POINT Res[] = {
            {  640,  480},
            {  800,  600},
            { 1024,  768},
            { 1152,  900},
            { 1280, 1024},
            { 1600, 1200},
            { 0, 0}         // end of table
        };

    ASSERT (*ppPhysicalDevice == NULL);

    //
    // Allocate memory for the logical device
    //

    pLogicalDevice = (PVU_LOGICAL_DEVICE)
        LocalAlloc(LPTR, sizeof(VU_LOGICAL_DEVICE));
    if (pLogicalDevice == NULL) {
        return;
    }

    Width = GetSystemMetrics(SM_CXSCREEN);
    Height = GetSystemMetrics(SM_CYSCREEN);

    if (Width == 0 || Height == 0) {

        //
        // Something went wrong, default to lowest common res
        //

        useVga = TRUE;
    }

    //
    // NT 4.0 multimon via driver vendor, not the OS ... adjust the width and height
    // back to normal values.  Once setup is complete, the second card will come
    // on line and it will be taken care of.  In both cases, the video area must
    // be rectangular, not like MM on 5.0 where we can have "holes"
    //

    else if (Width >= 2 * Height) {

        //
        // Wide
        //

        for (Index = 0; Res[Index].x != 0; Index++) {

            if (Res[Index].y == Height) {

                Width = Res[Index].x;
                break;
            }
        }

        useVga = (Res[Index].x == 0);

    } else if (Height > Width) {

        //
        // Tall
        //

        for (Index = 0; Res[Index].x != 0; Index++) {

            if (Res[Index].x == Width) {

                Height = Res[Index].y;
                break;
            }
        }

        useVga = (Res[Index].x == 0);
    }

    if (useVga) {

        //
        // No match, default to VGA
        //

        Width = 640;
        Height = 480;
    }

    pLogicalDevice->ValidFields |= VU_ATTACHED_TO_DESKTOP;
    pLogicalDevice->AttachedToDesktop = 1;

    pLogicalDevice->ValidFields |= VU_X_RESOLUTION;
    pLogicalDevice->XResolution = Width;

    pLogicalDevice->ValidFields |= VU_Y_RESOLUTION;
    pLogicalDevice->YResolution = Height;

    hDisplay = CreateDC(TEXT("DISPLAY"), NULL, NULL, NULL);
    if (hDisplay)
    {
        pLogicalDevice->ValidFields |= VU_BITS_PER_PEL;
        pLogicalDevice->BitsPerPel = GetDeviceCaps(hDisplay, BITSPIXEL);

        pLogicalDevice->ValidFields |= VU_VREFRESH;
        pLogicalDevice->VRefresh = GetDeviceCaps(hDisplay, VREFRESH);
        DeleteDC(hDisplay);
    }

    if (!InsertNode(ppPhysicalDevice,
                    pLogicalDevice,
                    1,
                    0,
                    0)) {

        //
        // Clean-up
        //

        LocalFree(pLogicalDevice);
    }
}


VOID  
SaveNT4Services(
    HKEY hKey
    )
{
    SC_HANDLE hSCManager = NULL;
    ENUM_SERVICE_STATUS* pmszAllServices = NULL;
    QUERY_SERVICE_CONFIG* pServiceConfig = NULL;
    SC_HANDLE hService = NULL;
    DWORD cbBytesNeeded = 0;
    DWORD ServicesReturned = 0;
    DWORD ResumeHandle = 0;
    DWORD ServiceLen = 0, TotalLen = 0, AllocatedLen = 128;
    PTCHAR pmszVideoServices = NULL, pmszTemp = NULL;

    //
    // Allocate initial memory
    //

    pmszVideoServices = (PTCHAR)LocalAlloc(LPTR, AllocatedLen * sizeof(TCHAR));
    if (pmszVideoServices == NULL) {
        goto Fallout;
    }
    
    //
    // Open the service control manager 
    //

    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    
    if (hSCManager == NULL) {
        goto Fallout;
    }

    //
    // Get the required size 
    //

    if ((!EnumServicesStatus(hSCManager,
                             SERVICE_DRIVER,
                             SERVICE_STATE_ALL,
                             NULL,
                             0,
                             &cbBytesNeeded,
                             &ServicesReturned,
                             &ResumeHandle)) &&
        (GetLastError() != ERROR_MORE_DATA)) {

        goto Fallout;
    }

    //
    // Allocate the memory
    //

    pmszAllServices = (ENUM_SERVICE_STATUS*)LocalAlloc(LPTR, cbBytesNeeded);

    if (pmszAllServices == NULL) {
        goto Fallout;
    }

    //
    // Get the services 
    //

    ServicesReturned = ResumeHandle = 0;
    if (!EnumServicesStatus(hSCManager,
                            SERVICE_DRIVER,
                            SERVICE_STATE_ALL,
                            pmszAllServices,
                            cbBytesNeeded,
                            &cbBytesNeeded,
                            &ServicesReturned,
                            &ResumeHandle)) {
        goto Fallout;
    }

    while (ServicesReturned--) {
        
        //
        // Open the service
        //

        hService = OpenService(hSCManager,
                               pmszAllServices[ServicesReturned].lpServiceName,
                               SERVICE_ALL_ACCESS);

        if (hService != NULL) {
        
            //
            // Get the required size to store the config info 
            //

            cbBytesNeeded = 0;
            if (QueryServiceConfig(hService,
                                   NULL,
                                   0,
                                   &cbBytesNeeded) ||
                (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
            
                //
                // Allocate the memory
                //

                pServiceConfig = (QUERY_SERVICE_CONFIG*)
                   LocalAlloc(LPTR, cbBytesNeeded);

                if (pServiceConfig != NULL) {
                    
                    //
                    // Get the config info 
                    //

                    if (QueryServiceConfig(hService,
                                           pServiceConfig,
                                           cbBytesNeeded,
                                           &cbBytesNeeded) &&
                        (pServiceConfig->dwStartType != SERVICE_DISABLED) &&
                        (_tcsicmp(pServiceConfig->lpLoadOrderGroup, TEXT("Video")) == 0)) {

                        ServiceLen = _tcslen(pmszAllServices[ServicesReturned].lpServiceName);
                        
                        if (TotalLen + ServiceLen + 2 > AllocatedLen) {

                            AllocatedLen = TotalLen + ServiceLen + 128;

                            pmszTemp = (PTCHAR)LocalAlloc(LPTR, AllocatedLen * sizeof(TCHAR));

                            if (pmszTemp == NULL) {
                                goto Fallout;
                            }

                            memcpy(pmszTemp, pmszVideoServices, TotalLen * sizeof(TCHAR));

                            LocalFree(pmszVideoServices);

                            pmszVideoServices = pmszTemp;
                            pmszTemp = NULL;
                        }

                        _tcscpy(pmszVideoServices + TotalLen, pmszAllServices[ServicesReturned].lpServiceName);
                        TotalLen += ServiceLen + 1;
                    }

                    LocalFree(pServiceConfig);
                    pServiceConfig = NULL;
                }
            }

            CloseServiceHandle(hService);
            hService = NULL;
        }
    }

    //
    // Save the services to the registry
    //

    pmszVideoServices[TotalLen++] = TEXT('\0');
    RegSetValueEx(hKey,
                  SZ_SERVICES_TO_DISABLE,
                  0,
                  REG_MULTI_SZ,
                  (BYTE*)pmszVideoServices,
                  TotalLen * sizeof(TCHAR));

Fallout:
    
    if (hService != NULL) {
        CloseServiceHandle(hService);
    }

    if (pServiceConfig != NULL) {
        LocalFree(pServiceConfig);
    }

    if (pmszAllServices != NULL) {
        LocalFree(pmszAllServices);
    }

    if (hSCManager != NULL) {
        CloseServiceHandle(hSCManager);
    }

    if (pmszVideoServices != NULL) {
        LocalFree(pmszVideoServices);
    }

} // SaveNT4Services


BOOL
DeleteKeyAndSubkeys(
    HKEY hKey,
    LPCTSTR lpSubKey
    )
{
    HKEY hkDeleteKey;
    TCHAR szChild[MAX_PATH + 1];
    BOOL bReturn = FALSE;

    if (RegOpenKey(hKey, lpSubKey, &hkDeleteKey) == ERROR_SUCCESS) {

        bReturn = TRUE;
        while (RegEnumKey(hkDeleteKey, 0, szChild, MAX_PATH) ==
               ERROR_SUCCESS) {
            if (!DeleteKeyAndSubkeys(hkDeleteKey, szChild)) {
                bReturn = FALSE;
                break;
            }
        }

        RegCloseKey(hkDeleteKey);

        if (bReturn)
            bReturn = (RegDeleteKey(hKey, lpSubKey) == ERROR_SUCCESS);
    }

    return bReturn;
}


VOID  
SaveAppletExtensions(
    HKEY hKey
    )
{
    PAPPEXT pAppExt = NULL;
    PAPPEXT pAppExtTemp;
    DWORD Len = 0;
    PTCHAR pmszAppExt = NULL;
    HKEY hkDisplay;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     REGSTR_PATH_CONTROLSFOLDER_DISPLAY_SHEX_PROPSHEET,
                     0,
                     KEY_READ,
                     &hkDisplay) == ERROR_SUCCESS) {

        DeskAESnapshot(hkDisplay, &pAppExt);
    }

    if (pAppExt == NULL)
        return;

    pAppExtTemp = pAppExt;
    while (pAppExtTemp) {
        
        Len += lstrlen(pAppExtTemp->szDefaultValue) + 1;
        pAppExtTemp = pAppExtTemp->pNext;
    }

    pmszAppExt = (PTCHAR)LocalAlloc(LPTR, (Len + 1) * sizeof(TCHAR));
    if (pmszAppExt != NULL) {
        
        pAppExtTemp = pAppExt;
        Len = 0;
        while (pAppExtTemp) {

            lstrcpy(pmszAppExt + Len, pAppExtTemp->szDefaultValue);
            Len += lstrlen(pAppExtTemp->szDefaultValue) + 1;
            pAppExtTemp = pAppExtTemp->pNext;
        }

        RegSetValueEx(hKey,
                      SZ_APPEXT_TO_DELETE,
                      0,
                      REG_MULTI_SZ,
                      (BYTE*)pmszAppExt,
                      (Len + 1) * sizeof(TCHAR));
    
        LocalFree(pmszAppExt);
    }

    DeskAECleanup(pAppExt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\vidupgrd\sources.inc ===
TARGETNAME=vidupgrd
TARGETPATH=obj
TARGETTYPE=DYNLINK
TARGETEXT=dll

INCLUDES=$(BASE_INC_PATH)

TARGETLIBS=$(SDK_LIB_PATH)\advapi32.lib     \
           $(SDK_LIB_PATH)\user32.lib       \
           $(SDK_LIB_PATH)\kernel32.lib     \
           $(SDK_LIB_PATH)\gdi32.lib        \
           $(SDK_LIB_PATH)\setupapi.lib     

USE_MSVCRT=1

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF

MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX
C_DEFINES=-DWIN32 -DW3 -DUNICODE -D_UNICODE

SOURCES=..\migrate.cpp   \
        ..\deskcmmn.cpp

DLLDEF=$(O)\vidupgrd.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\cpls\vidupgrd\migrate.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    migrate.h

Environment:

    WIN32 User Mode

--*/


#include <windows.h>
#include <tchar.h>
#include <setupapi.h>
#include <ole2.h>
#include <cfgmgr32.h>
#include <devguid.h>
#include <debug.h>
#include "..\common\deskcmmn.h"


#define VU_ATTACHED_TO_DESKTOP 0x00000001
#define VU_RELATIVE_X          0x00000002
#define VU_RELATIVE_Y          0x00000004
#define VU_BITS_PER_PEL        0x00000008
#define VU_X_RESOLUTION        0x00000010
#define VU_Y_RESOLUTION        0x00000020
#define VU_VREFRESH            0x00000040
#define VU_FLAGS               0x00000080
#define VU_HW_ACCELERATION     0x00000100
#define VU_PRUNING_MODE        0x00000200


typedef struct _VU_LOGICAL_DEVICE {
    
    struct _VU_LOGICAL_DEVICE *pNextLogicalDevice;
    DWORD DeviceX;
    DWORD ValidFields;

    DWORD AttachedToDesktop;
    DWORD RelativeX;
    DWORD RelativeY;
    DWORD BitsPerPel;
    DWORD XResolution;
    DWORD YResolution;
    DWORD VRefresh;
    DWORD Flags;
    DWORD HwAcceleration;
    DWORD PruningMode;

} VU_LOGICAL_DEVICE, *PVU_LOGICAL_DEVICE;


typedef struct _VU_PHYSICAL_DEVICE {
    
    struct _VU_PHYSICAL_DEVICE *pNextPhysicalDevice;
    PVU_LOGICAL_DEVICE pFirstLogicalDevice;
    DWORD CountOfLogicalDevices;
    DWORD Legacy;
    DWORD BusNumber;
    DWORD Address;

} VU_PHYSICAL_DEVICE, *PVU_PHYSICAL_DEVICE;


typedef CMAPI CONFIGRET (WINAPI *PFN_CM_LOCATE_DEVNODE)(
    OUT PDEVINST pdnDevInst,
    IN DEVINSTID pDeviceID,    OPTIONAL
    IN ULONG ulFlags
    );


typedef BOOL (WINAPI *PFN_SETUP_DI_ENUM_DEVICES_INTERFACES)(
    IN  HDEVINFO DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,     OPTIONAL
    IN  CONST GUID *InterfaceClassGuid,
    IN  DWORD MemberIndex,
    OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
    );


typedef BOOL (WINAPI *PFN_SETUP_DI_GET_DEVICE_INTERFACE_DETAIL)(
    IN  HDEVINFO DeviceInfoSet,
    IN  PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
    OUT PSP_DEVICE_INTERFACE_DETAIL_DATA DeviceInterfaceDetailData, OPTIONAL
    IN  DWORD DeviceInterfaceDetailDataSize,
    OUT PDWORD RequiredSize, OPTIONAL
    OUT PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    );


typedef HKEY (WINAPI *PFN_SETUP_DI_CREATE_DEVICE_INTERFACE_REG_KEY)(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
    IN DWORD Reserved,
    IN REGSAM samDesired,
    IN HINF InfHandle, OPTIONAL
    IN PCTSTR InfSectionName OPTIONAL
    );


typedef HKEY (WINAPI *PFN_SETUP_DI_OPEN_DEVICE_INTERFACE_REG_KEY)(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
    IN DWORD Reserved,
    IN REGSAM samDesired
    );


typedef HKEY (WINAPI *PFN_SETUP_DI_CREATE_DEVICE_INTERFACE)(
    IN  HDEVINFO DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  CONST GUID *InterfaceClassGuid,
    IN  PCTSTR ReferenceString, OPTIONAL
    IN  DWORD CreationFlags,
    OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData OPTIONAL
    );


VOID
SaveOsInfo(
    HKEY hKey,
    POSVERSIONINFO posVer
    );

VOID  
SaveLegacyDriver(
    HKEY hKey
    );

VOID  
SaveNT4Services(
    HKEY hKey
    );

VOID  
SaveAppletExtensions(
    HKEY hKey
    );

BOOL
SaveDisplaySettings(
    HKEY hKey,
    POSVERSIONINFO posVer
    );

VOID
CollectDisplaySettings(
    PVU_PHYSICAL_DEVICE* ppPhysicalDevice
    );

VOID
LegacyCollectDisplaySettings(
    PVU_PHYSICAL_DEVICE* ppPhysicalDevice
    );

BOOL
WriteDisplaySettingsToRegistry(
    HKEY hKey, 
    PVU_PHYSICAL_DEVICE pPhysicalDevice
    );

BOOL
InsertNode(
    PVU_PHYSICAL_DEVICE* ppPhysicalDevice, 
    PVU_LOGICAL_DEVICE pLogicalDevice,
    DWORD Legacy,
    DWORD BusNumber,
    DWORD Address
    );

VOID
FreeAllNodes(
    PVU_PHYSICAL_DEVICE pPhysicalDevice
    );

BOOL 
GetDevInfoData(
    IN  LPTSTR pDeviceKey,
    OUT HDEVINFO* phDevInfo,
    OUT PSP_DEVINFO_DATA pDevInfo
    );

BOOL 
GetDevInfoDataFromInterfaceName(
    IN  LPWSTR pwInterfaceName,
    OUT HDEVINFO* phDevInfo,
    OUT PSP_DEVINFO_DATA pDevInfo
    );

BOOL 
GetDevInfoDataFromInstanceID(
    IN  LPWSTR pwInstanceID,
    OUT HDEVINFO* phDevInfo,
    OUT PSP_DEVINFO_DATA pDevInfo
    );

BOOL
DeleteKeyAndSubkeys(
    HKEY hKey,
    LPCTSTR lpSubKey
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ddk\makefile.inc ===
!IFDEF PASS0ONLY
BuildDDK:

!ELSE

#
# Process only on the second pass
#

BuildDDK:
	call $(RAZZLETOOLPATH)\copyddkfiles.cmd ddk_shell.ini ddk $(PROJECT_ROOT)
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\drts\shdrt-sfstr\td_main.cpp ===
#include <objbase.h>

#include "sfstr.h"

#include "dbg.h"

#ifndef UNICODE
#error This has to be UNICODE
#endif

// from td_sfstr.cpp
int DoTest(int argc, wchar_t* argv[]);

extern "C"
{
int __cdecl wmain(int argc, wchar_t* argv[])
{
    return !DoTest(argc, argv);
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\drts\shdrt-sfstr\td_shdrt.cpp ===
#include <objbase.h>

#include "shelldrt.h"

#include "dbg.h"

static const WCHAR szTestName[] = TEXT("Safe String Test");

// from td_sfstr.cpp
int DoTest(int argc, wchar_t* argv[]);

BOOL CALLBACK SHTestProc()
{
    return DoTest(0, NULL);
}

// SHTESTLISTPROC
//
// Each test dll exports this function, which describes the tests
// it contains (or returns just a count if the arg passed to is is null

DWORD CALLBACK ListTestProcs(SHTESTDESCRIPTOR* prgpshtd)
{
    if (prgpshtd)
    {
        prgpshtd->_cbSize = sizeof(prgpshtd);
        prgpshtd->_pszTestName = szTestName;
        prgpshtd->_pfnTestProc = SHTestProc;

        // ????
        prgpshtd->_dwAttribs = 0;
    }

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\drts\shdrt-sfstr\td_sfstr.cpp ===
#include <tchar.h>
#include <stdio.h>
#include <io.h>
#include <objbase.h>

#include "sfstr.h"

#include "dbg.h"

#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))

const WCHAR szOne[] = TEXT("0");
const WCHAR szTwo[] = TEXT("01");
const WCHAR szThree[] = TEXT("012");
const WCHAR szFour[] = TEXT("0123");
const WCHAR szFive[] = TEXT("01234");

int DoTest(int , wchar_t* [])
{
    HRESULT hresTest = S_OK;

    // For all fcts call
    HRESULT hres;

    WCHAR szDestTwo[2];
    WCHAR szDestThree[3];
    WCHAR szDestFour[4];
    WCHAR szDestFive[5];
    WCHAR szDestSix[6];

///////////////////////////////////////////////////////////////////////////////
//
// SafeStrCxxN
    ///////////////////////////////////////////////////////////////////////////
    //
    // (1)
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyN(szDestFour, szThree, ARRAYSIZE(szDestFour));

        if (FAILED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    // (2)
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyN(szDestThree, szThree, ARRAYSIZE(szDestThree));

        if (SUCCEEDED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    // (3)
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyN(szDestFive, szThree, ARRAYSIZE(szDestFive));

        if (FAILED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    ///////////////////////////////////////////////////////////////////////////
    //
    // (1)
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyN(szDestSix, szThree, ARRAYSIZE(szDestSix));

        if (FAILED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCatN(szDestSix, szTwo, ARRAYSIZE(szDestSix));

        if (FAILED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    // (2)
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyN(szDestSix, szThree, ARRAYSIZE(szDestSix));

        if (FAILED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCatN(szDestSix, szThree, ARRAYSIZE(szDestSix));

        if (SUCCEEDED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    // (3)
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyN(szDestSix, szTwo, ARRAYSIZE(szDestSix));

        if (FAILED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCatN(szDestSix, szTwo, ARRAYSIZE(szDestSix));

        if (FAILED(hres))
        {
            hresTest = E_FAIL;
        }
    }

///////////////////////////////////////////////////////////////////////////////
//
// SafeStrCxxNEx
    ///////////////////////////////////////////////////////////////////////////
    //
    // (1)
    LPWSTR pszNext = 0;
    DWORD cchLeft = 0;

    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyNEx(szDestFour, szThree, ARRAYSIZE(szDestFour), &pszNext,
            &cchLeft);

        if (FAILED(hres) || (1 != cchLeft))
        {
            hresTest = E_FAIL;
        }
    }

    // (2)
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyNEx(szDestThree, szThree, ARRAYSIZE(szDestThree),
            &pszNext, &cchLeft);

        if (SUCCEEDED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    // (3)
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyNEx(szDestFive, szThree, ARRAYSIZE(szDestFive), &pszNext,
            &cchLeft);

        if (FAILED(hres) || (2 != cchLeft))
        {
            hresTest = E_FAIL;
        }
    }

    ///////////////////////////////////////////////////////////////////////////
    //
    // (1)
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyNEx(szDestSix, szThree, ARRAYSIZE(szDestSix), &pszNext,
            &cchLeft);

        if (FAILED(hres) || (3 != cchLeft))
        {
            hresTest = E_FAIL;
        }
    }

    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyN(pszNext, szTwo, cchLeft);

        if (FAILED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    // (2)
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyNEx(szDestSix, szThree, ARRAYSIZE(szDestSix), &pszNext,
            &cchLeft);

        if (FAILED(hres) || (3 != cchLeft))
        {
            hresTest = E_FAIL;
        }
    }

    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyN(pszNext, szThree, cchLeft);

        if (SUCCEEDED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    // (3)
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyNEx(szDestSix, szTwo, ARRAYSIZE(szDestSix), &pszNext,
            &cchLeft);

        if (FAILED(hres) || (4 != cchLeft))
        {
            hresTest = E_FAIL;
        }
    }

    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyN(pszNext, szTwo, cchLeft);

        if (FAILED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    ///////////////////////////////////////////////////////////////////////////
    //
    // (1)
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyN(szDestSix, szThree, ARRAYSIZE(szDestSix));

        if (FAILED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCatNEx(szDestSix, szTwo, ARRAYSIZE(szDestSix), &pszNext,
            &cchLeft);

        if (FAILED(hres) || (1 != cchLeft))
        {
            hresTest = E_FAIL;
        }
    }

    // (2)
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyN(szDestSix, szThree, ARRAYSIZE(szDestSix));

        if (FAILED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCatNEx(szDestSix, szThree, ARRAYSIZE(szDestSix), &pszNext,
            &cchLeft);

        if (SUCCEEDED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    // (3)
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyN(szDestSix, szTwo, ARRAYSIZE(szDestSix));

        if (FAILED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCatNEx(szDestSix, szTwo, ARRAYSIZE(szDestSix), &pszNext,
            &cchLeft);

        if (FAILED(hres) || (2 != cchLeft))
        {
            hresTest = E_FAIL;
        }
    }

///////////////////////////////////////////////////////////////////////////////
//
// SafeStrCpyNExact
    ///////////////////////////////////////////////////////////////////////////
    //
    // (1)
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyNExact(szDestFour, szThree, ARRAYSIZE(szDestFour), 1);

        if (FAILED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    //
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyNExact(szDestFour, szThree, ARRAYSIZE(szDestFour), 2);

        if (FAILED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    //
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyNExact(szDestFour, szThree, ARRAYSIZE(szDestFour), 3);

        if (FAILED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    //
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyNExact(szDestFour, szThree, ARRAYSIZE(szDestFour), 4);

        if (FAILED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    //
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyNExact(szDestFour, szThree, ARRAYSIZE(szDestFour), 5);

        if (SUCCEEDED(hres) || (E_SOURCEBUFFERTOOSMALL != hres))
        {
            hresTest = E_FAIL;
        }
    }

    //
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyNExact(szDestTwo, szThree, ARRAYSIZE(szDestTwo), 5);

        if (SUCCEEDED(hres) || (E_BUFFERTOOSMALL != hres))
        {
            hresTest = E_FAIL;
        }
    }

///////////////////////////////////////////////////////////////////////////////
//
// SafeStrCpyNExactEx
    ///////////////////////////////////////////////////////////////////////////
    //
    // (1)
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyNExactEx(szDestFour, szThree, ARRAYSIZE(szDestFour), 1, 
            &pszNext, &cchLeft);

        if (FAILED(hres) || (4 != cchLeft))
        {
            hresTest = E_FAIL;
        }
    }

    //
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyNExactEx(szDestFour, szThree, ARRAYSIZE(szDestFour), 2, 
            &pszNext, &cchLeft);

        if (FAILED(hres) || (3 != cchLeft))
        {
            hresTest = E_FAIL;
        }
    }

    //
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyNExactEx(szDestFour, szThree, ARRAYSIZE(szDestFour), 3, 
            &pszNext, &cchLeft);

        if (FAILED(hres) || (2 != cchLeft))
        {
            hresTest = E_FAIL;
        }
    }

    //
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyNExactEx(szDestFour, szThree, ARRAYSIZE(szDestFour), 4, 
            &pszNext, &cchLeft);

        if (FAILED(hres) || (1 != cchLeft))
        {
            hresTest = E_FAIL;
        }
    }

    //
    if (SUCCEEDED(hresTest))
    {
        hres = SafeStrCpyNExactEx(szDestFour, szThree, ARRAYSIZE(szDestFour), 5, 
            &pszNext, &cchLeft);

        if (SUCCEEDED(hres))
        {
            hresTest = E_FAIL;
        }
    }

    return SUCCEEDED(hresTest);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\drts\shdrt-shortcuts\shdrt-shortcuts.cpp ===
#include "stdafx.h"
#include <shelldrt.h>

//
// DLL Entry Point
//

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	return TRUE;
}

// ListTestProcs
//
// Describes the tests provided by the dll

DWORD CALLBACK ListTestProcs()
{
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\drts\shdrt-shortcuts\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File: stdafx.h : include file for standard system include files,            
//                   or project specific include files that are used 
//                   frequently, but are changed infrequently                               
//
//  History:  19-Feb-2000 Davepl 
//
//--------------------------------------------------------------------------


#if !defined(AFX_STDAFX_H__9FA15269_83BE_4D90_98EB_2B3BC53694DD__INCLUDED_)
#define AFX_STDAFX_H__9FA15269_83BE_4D90_98EB_2B3BC53694DD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#define INCLUDE_SHTL_SOURCE 1
#define USE_SHELL_AUTOPTR   1

#define _LOCALE_        // isdigit is redefined, I don't know why

#include <winuser.h>
#include <ccstock.h>
#include <shtl.h>
#include <autoptr.h>
#include <shlwapip.h>
#include <debug.h>
#include <shlobjp.h>

#undef max              // stl doesn't want the old C version of this

#include <map>
#include <limits>

//
// These operators allow me to mix int64 types with the old LARGE_INTEGER
// unions without messing with the QuadPart members in the code.
//

inline ULONGLONG operator + (const ULARGE_INTEGER i, const ULARGE_INTEGER j) 
{ 
    return i.QuadPart + j.QuadPart; 
}

inline ULONGLONG operator + (const ULONGLONG i, const ULARGE_INTEGER j)      
{ 
    return i + j.QuadPart; 
}

//inline ULONGLONG operator = (const ULONGLONG i, const ULARGE_INTEGER j)      
//{ 
//    return i = j.QuadPart; 
//}

#define TF_DLGDISPLAY   0x00010000  // messages related to display of the confirmation dialog
#define TF_DLGSTORAGE   0x00020000  // messages related to using the legacy IStorage to get dialog info
#define TF_DLGISF       0x00040000  // messages related to using IShellFolder to get dialog info

#define RECT_WIDTH(rc)  ((rc).right - (rc).left)
#define RECT_HEIGHT(rc) ((rc).bottom - (rc).top)

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__9FA15269_83BE_4D90_98EB_2B3BC53694DD__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\evtmon\inc\emact.h ===
/*****************************************************************************
    emact.h

    Owner: DaleG
    Copyright (c) 1997 Microsoft Corporation

    Delayed Action Interpreter mechanism, shared header file.

*****************************************************************************/

#ifndef _EMACT_H
#define _EMACT_H

#include "emrultk.h"


MSOEXTERN_C_BEGIN   // ***************** Begin extern "C" ********************

#define iactAllocMax        256


/* M  S  O  A  C  T */
/*----------------------------------------------------------------------------
    %%Structure: MSOACT
    %%Contact:   daleg

    Delayed-Action structure.  Used to pass argument values to functions
    delay-called from the rulebase.
----------------------------------------------------------------------------*/

typedef struct _MSOACT
    {
    union
        {
        struct
            {
            short           actt;                       // Action type
            MSOBF           fComposite : 1;             // Composite action?
            MSOBF           fValidate : 1;              // Check if act OK?
            MSOBF           fAdjust : 1;                // Adjusting CA?
            MSOBF           fDeferred : 1;              // Deferred eval?
            long            rgl[8];                     // Arg values, 1st rec
            struct _MSOACT *pactSublist;                // Child record
            } rec1;
        struct
            {
            long            hdrCA;                      // Shared rec1 header
            MSOCA           ca;                         // Edit range
            } rec1_ca;
        long                hdr;                        // Shared header
        long                rglSublist[10];             // Arg values, 2nd+ rec
        char               *rszSublist[10];             // Arg values, 2nd+ rec
        };
    struct _MSOACT         *pactNext;                   // Next record
    } MSOACT;


#define msoacttNil          (-1)                        // Out of range actt
#define msopactNULL         ((MSOACT *) (-1))           // End of list marker


// Return object pointer of (first record of) a pact
#define PObjectPact(pact) \
            ((pact)->rec1_ca.ca.pObject)

// Return cpFirst of (first record of) a pact
#define CpFirstPact(pact) \
            ((pact)->rec1_ca.ca.cpFirst)

// Return cpLim of (first record of) a pact
#define CpLimPact(pact) \
            ((pact)->rec1_ca.ca.cpLim)



/* M S O  A  C  T  B  L  K */
/*----------------------------------------------------------------------------
    %%Function: MSOACTBLK
    %%Contact: daleg

    Delayed-Action structure allocation block.
----------------------------------------------------------------------------*/

typedef struct _MSOACTBLK
    {
    struct _MSOACTBLK  *pactblkNext;                    // Next alloc block
    MSOACT              rgact[iactAllocMax];            // Array of MSOACTs
    } MSOACTBLK;



/* M  S  O  A  C  T  T  R  E  C */
/*----------------------------------------------------------------------------
    %%Function: MSOACTTREC
    %%Contact: daleg

    Action-type table record.  Holds flags associated with actt values.
----------------------------------------------------------------------------*/

typedef struct _MSOACTTREC
    {
    short               cargs;                          // Num of args to fn
    unsigned short      actf;                           // Action flags
    } MSOACTTREC;


// Base action flags
#define msoactfExclusiveEdit    0x0001                  // Truncates other acts
#define msoactfTruncatable      0x0002                  // Trucated by Excl act
#define msoactfNonExclPaired    0x0004                  // Trunc unless paired

// "User"-level action flags
#define msoactfNonEdit          0x0000                  // Not an edit
#define msoactfEdit             0x0003                  // e.g. Edits
#define msoactfProp             0x0002                  // e.g. Props
#define msoactfPairedProp       0x0004                  // Props paired w/edits
#define msoactfOverlapCalc      0x0007                  // Overlap calc necess
#define msoactfCond             0x0010                  // Cond exec next act
#define msoactfConposite        0x0020                  // Composite action

// Return whether the action is a composite, composed of multiple records
#define MsoFCompositeAct(actt, pacttbl) \
            MsoFActfActt(actt, msoactfConposite, pacttbl)

// Return whether ACT record has actf flag set
#define MsoFActfActt(actt, actfMask, pacttbl) \
            (MsoActfActt((actt), (pacttbl)) & (actfMask))

// Return whether ACT record has actf flag set
#define MsoFActfIs(actf, actfMask) \
            ((actf) & (actfMask))

// Return whether ACT record type has actf flag set
#define MsoFActfActtIs(actt, actfMatch, pacttbl) \
            (MsoActfActt((actt), (pacttbl)) == (actfMatch))

// Return whether ACT record type has actf flag set
#define MsoActfActt(actt, pacttbl) \
            (MsoPActtrec((actt), (pacttbl))->actf)

// Return action record (MSOACTTREC) associated with ACT record
#define MsoPActtrec(actt, pacttbl) \
            (&(pacttbl)->rgacttrec[actt])



/* M  S  O  A  C  T  T  B  L */
/*----------------------------------------------------------------------------
    %%Structure: MSOACTTBL
    %%Contact: daleg

    Action-type table.  Contains MSOACT state and action flags.
----------------------------------------------------------------------------*/

typedef struct _MSOACTTBL
    {
    const MSOACTTREC   *rgacttrec;                      // Per-action data
    MSOCP               cpFirstEditPrev;                // 1st CP of last edit
    MSOCP               dcpEditPrev;                    // dCP of last edit
    MSOCP               cpLimEdit;                      // cpLim, edit so far
    MSORULTKH          *prultkh;                        // Text Token cache
    MSOACT             *pactPending;                    // Pending actions
    MSOACT             *pactPendingPrev;                // Prev pending acts
    MSOACT             *pactFree;                       // Free list
    MSOACTBLK          *pactblkAlloc;                   // Allocation list
    } MSOACTTBL;



// Start a new MSOACT action list frame
#define MsoPushPactPending() \
            MsoBeginActSublist((_pacttbl), &(_pacttbl)->pactPendingPrev)


// End and close a new MSOACT sub-list, and return sublist
#define MsoPopPactPending(ppact) \
            (*(ppact) = (_pacttbl)->pactPending, \
             MsoEndActSublist((_pacttbl), &(_pacttbl)->pactPendingPrev))


// Start a new MSOACT action list frame
__inline void MsoBeginActSublist(MSOACTTBL *pacttbl, MSOACT **ppactPrev)
{
    *ppactPrev = pacttbl->pactPending;
    pacttbl->pactPending = (MSOACT *) NULL;
}


// End and close a new MSOACT sub-list
__inline void MsoEndActSublist(MSOACTTBL *pacttbl, MSOACT **ppactPrev)
{
    pacttbl->pactPending = *ppactPrev;
    *ppactPrev = (MSOACT *) NULL;
}



// Callback to evaluate the MSOACT
typedef long (WIN_CALLBACK * MSOPFNACT)(
    MSOACT             *pact,
    MSOACTTBL          *pacttbl,
    long               *pdcp,                           // IN, RETURN
    MSOCA              *pcaAdjusted,
    MSOACT           **ppactNext,                       // RETURN
    int                *pfDiscard                       // RETURN
    );


// Are there pending action records?
#define MsoPendingActions(pacttbl) \
            ((pacttbl)->pactPending)

// Return value for args 0-7
#define MsoLPact(pact, iarg) \
            ((pact)->rec1.rgl[iarg])

// Return value for args 8-17
#define MsoLPact2(pact, iarg) \
            ((pact)->rec1.pactSublist->rglSublist[(iarg) - 8])

// Return value for args 18-27
#define MsoLPact3(pact, iarg) \
            ((pact)->rec1.pactSublist-> \
            ((pact)->rec1.pactSublist->pactNext->rglSublist[(iarg) - 18])

// Return value for args 28-31
#define MsoLPact4(pact, iarg) \
            ((pact)->rec1.pactSublist->pactNext->pactNext \
                ->rglSublist[(iarg) - 28])


MSOCDECLAPI_(MSOACT *) MsoPact(                         // Build new MSOACT rec
    MSOACTTBL          *pacttbl,
    int actt,
    ...
    );
MSOCDECLAPI_(MSOACT *) MsoPactNq(                       // As above, not queued
    MSOACTTBL          *pacttbl,
    int actt,
    ...
    );
MSOCDECLAPI_(MSOACT *) MsoPactDtk(                      // Bld MSOACT rec w/tks
    MSOACTTBL          *pacttbl,
    int                 actt,
    int                 dtkStart,
    int                 dtk,
    ...
    );
MSOCDECLAPI_(MSOACT *) MsoPactDtkNq(                    // As above, not queued
    MSOACTTBL          *pacttbl,
    int                 actt,
    int                 dtkStart,
    int                 dtk,
    ...
    );
MSOCDECLAPI_(MSOACT *) MsoPactPca(                      // Bld MSOACT rec w/CPs
    MSOACTTBL          *pacttbl,
    int                 actt,
    MSOCA              *pca,
    ...
    );
MSOCDECLAPI_(MSOACT *) MsoPactPcaNq(                    // As above, not queued
    MSOACTTBL          *pacttbl,
    int                 actt,
    MSOCA              *pca,
    ...
    );
MSOAPI_(MSOACT *) MsoPactCompositeDtk(                  // Bld Composite action
    MSOACTTBL          *pacttbl,
    int                 actt,
    int                 dtkStart,
    int                 dtk,
    MSOACT            **ppactPrev
    );
void SetPactCaFromSublist(MSOACT *pact);                // Set CA of Comp pact
#define MsoReversePactPending(pacttbl) \
            MsoReversePact(&pacttbl->pactPending)       // Reverse pending acts
MSOAPI_(void) MsoReversePact(MSOACT **ppact);           // Reverse ACT list
MSOAPI_(long) MsoDcpDoActs(                             // Execute ACT list
    MSOACT            **ppact,
    MSOACTTBL          *pacttbl,
    long                dcp,
    int                 fDiscardActs,
    int                 dactLim,
    MSOPFNACT           pfnact                          // MSOACT handler
    );
MSOAPI_(MSOACT *) MsoPactDtkAp(                         // Bld MSOACT tks & ap
    MSOACTTBL          *pacttbl,
    int                 actt,
    int                 dtkStart,
    int                 dtk,
    va_list             ap
    );
MSOAPI_(MSOACT *) MsoPactPcaAp(                         // Bld MSOACT CPs & ap
    MSOACTTBL          *pacttbl,
    int                 actt,
    MSOCA               *pca,
    va_list             ap
    );
MSOAPI_(MSOACT *) MsoPactAp(                            // Bld MSOACT rec ap
    MSOACTTBL          *pacttbl,
    int                 actt,
    int                 cargsOffset,
    va_list             ap
    );
MSOAPI_(void) MsoInsertPact(                            // Insert ACT by MSOCA
    MSOACT             *pact,
    MSOACT            **ppactHead
    );
MSOAPI_(int) MsoFEnsurePactFirst(                       // Sort ACT 1st in rng
    MSOACT             *pact,
    MSOACTTBL          *pacttbl
    );
MSOAPI_(MSOACT *) MsoFindPactOfActt(                    // Find rec by actt
    short               actt,
    MSOACT             *pact,
    MSOCP               cpFirst,
    MSOCP               cpLim
    );
MSOAPI_(void) MsoDeletePact(                            // Remove & free act
    MSOACT             *pact,
    MSOACTTBL          *pacttbl
    );
MSOAPI_(void) MsoSkipNextPact(                          // Skip over next ACT
    MSOACT            **ppactNext,
    MSOACTTBL          *pacttbl
    );
MSOAPI_(MSOACT *) _MsoPactNew(MSOACTTBL *pacttbl);      // Create blk of MSOACT

_inline MSOACT *MsoPactNew(MSOACTTBL *pacttbl)          // Return new MSOACT
{
    MSOACT             *pact;

    if ((pact = pacttbl->pactFree))
        {
        pacttbl->pactFree = pact->pactNext;
        return pact;
        }
    return _MsoPactNew(pacttbl);
}

void ClearPactPending(MSOACTTBL *pacttbl);              // Free pending acts
MSOAPI_(void) MsoFreePact(                              // Free MSOACT rec
    MSOACT             *pact,
    MSOACTTBL          *pacttbl
    );

_inline int MsoFAllocPact(MSOACTTBL *pacttbl)           // Pre-alloc ACT list
{
    MSOACT             *pact;

    if ((pact = MsoPactNew(pacttbl)) == NULL)
        return FALSE;
    MsoFreePact(pact, pacttbl);
    return TRUE;
}

MSOAPI_(void) MsoFreeActMem(MSOACTTBL *pacttbl);        // Free act mem used
#ifdef DEBUG
MSOAPI_(void) MsoMarkActMem(MSOACTTBL *pacttbl);        // Mark act mem used
#endif // DEBUG

MSOEXTERN_C_END     // ****************** End extern "C" *********************

#endif /* !_EMACT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\evtmon\inc\emdyn.c ===
/*----------------------------------------------------------------------------
    %%File: EMDYN.C
    %%Unit: Event Monitor (mntr)
    %%Contact: daleg

    Event Monitor Sample Application, Main Program.

    The purpose of this application is to demonstrate how to process events
    using the Event Monitor's Rule Compiler and rule engine.
----------------------------------------------------------------------------*/

#include "mso.h"
#include "msoem.h"

#if FEATURE_NYI // include'er file will give name
DEBUGASSERTSZ
#endif

#include "emruloci.h"

#if FEATURE_DEAD
extern MSOKWTB vkwtbEmCHAR_KEYTABLE;
#endif


#include "emact.h"
#include "msolex.h"
#if 0
#include "emtest.h"
#include "emintf.c"
#include "emfn.c"
#endif


/* F  L O A D  D Y N  E M  R U L E S */
/*----------------------------------------------------------------------------
    %%Function: FLoadDynEmRules
    %%Contact: daleg

    Load rules dynamically from a file or a data structure, depending upon
    #ifdef
----------------------------------------------------------------------------*/

#ifdef DYN_RULES_FROM_STRUCT

#include "emruli.oci"

#endif /* DYN_RULES_FROM_STRUCT */



int FLoadDynEmRules(void)
{
    int                 docii;

#ifndef DYN_RULES_FROM_STRUCT

    /* Read opcodes from a disk file */
    if (!MsoFReadDynOciRules("em", &docii))
        return fFalse;

#else /* DYN_RULES_FROM_STRUCT */

    /* Get opcodes from a structure */
    vlpruls->pociiDynRules = (PV) vrgociiEm;
    docii = IMaxRg(vrgociiEm, MSOOCII);
    vlpruls->rgpchDynNames = _rgszEmRulNames;

#endif /* !DYN_RULES_FROM_STRUCT */

#define NON_CONST_OCI_VTABLE
#ifdef NON_CONST_OCI_VTABLE
    /* Insert Mso functions into OCI vtable */
    if (!MsoFCopyBaseRulRgpfnoci(vpfnociEm))
        return fFalse;
#endif /* NON_CONST_OCI_VTABLE */

    /* Generate rulebase nodes from opcode stream */
    return MsoFLoadDynRulesPocii(vlpruls->pociiDynRules, docii,
                                 vpfnociEm, vrgocadEm,
                                 vrgcbOciArgEm, IMaxRg(vpfnociEm, MSOPFNOCI),
                                 DebugElse(vlpruls->rgpchDynNames, pNil));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\evtmon\inc\emkwd.h ===
/*****************************************************************************
    emkwd.h

    Owner: DaleG
    Copyright (c) 1992-1997 Microsoft Corporation

    Keyword Table header file.

*****************************************************************************/

#ifndef KWD_H


MSOEXTERN_C_BEGIN   // ***************** Begin extern "C" ********************


// Limits
#define msoipkwdMax         997                         // Size of keywd hash



#ifndef KWD_HASH_ONLY

// Limits...
#define msoikwdAllocMax     100                         // Max num KWDs/batch
#define msoichKwdAllocMax   100                         // Max # kwd chs/batch



/*************************************************************************
    Types:

    kwdf        Keyword-table entry record fixed.
    kwd         Keyword-table entry record.
    kwtb        Keyword table.

 *************************************************************************/


#ifndef TK_DEFINED
// Definition of token type returned by lexer
typedef int TK;

#define TK_DEFINED
#endif /* !TK_DEFINED */


/* M  S  O  K  W  D */
/*----------------------------------------------------------------------------
    %%Structure: MSOKWD
    %%Contact: daleg

    Keyword-table entry record, and batch-allocation record.
----------------------------------------------------------------------------*/

// Look up as a string key value
typedef struct _MSOKWDSZ
    {
    const XCHAR        *pxch;                           // String key value
    short               cch;                            // Length of kwd string
    TK                  tk;                             // Token value
    } MSOKWDSZ;


// Hash-table look up as a string key value
typedef struct _MSOKWD
    {
    const XCHAR        *pxch;                           // String key value
    short               cch;                            // Length of kwd string
    TK                  tk;                             // Token value
    struct _MSOKWD     *pkwdNext;                       // Next key in hash row
    } MSOKWD;


// Batch allocation
typedef struct _MSOKWDBLK
    {
    struct _MSOKWDBLK  *pkwdblkNext;                    // Next in chain
    MSOKWD             *pkwdRg;                         // Rg of MSOKWDs
    } MSOKWDBLK;


// Look up as an integer key value
typedef struct _MSOKWDL
    {
    long                lValue;                         // Integer key value
    TK                  tk;                             // Token value
    } MSOKWDL;


// Hash-table look up as a integer key value
typedef struct _MSOKWDLH
    {
    long                lValue;                         // Integer key value
    TK                  tk;                             // Token value
    struct _MSOKWDLH   *pkwdlhNext;                     // Next key in hash row
    } MSOKWDLH;




/* M  S  O  K  W  T  B */
/*----------------------------------------------------------------------------
    %%Structure: MSOKWTB
    %%Contact: daleg

    Keyword table record, and batch-allocation record.
    The hash table is in rgpkwdHash.  It is an array of linked lists,
    of type MSOKWD.
    The string buffer pxchBuf contains the character strings, PLUS the
    MSOKWD records of the hash table at the end.

    REVIEW: rgpkwdHash, pxchBuf and pkwdStart should be moved to the end of
    this struct to avoid allocating excess space for non-hashed keytables.
    Mso*Lookup* routines should assert that input MSOKWTB* arguments are of
    suitable type.
----------------------------------------------------------------------------*/

typedef struct _MSOKWTB
    {
    // Table data
    int                 kwtbt;                          // Keytable type
    int                 ckwdMax;                        // Num of MSOKWD recs
    MSOKWD             *pkwdUnknown;                    // Returned when !found
    void               *pvTable;                        // Hash/Binary table

    // Allocation/Init info
    unsigned char       fStaticInit;                    // Static Init-ed?
    unsigned char       fDynAlloced : 1;                // MSOKWTB mem alloced?
    unsigned char       fHashTblAlloced : 1;            // pvTable mem alloced?
    unsigned char       fSpare : 1;

    // String support
    XCHAR              *pxchBuf;                        // String buffer
    MSOKWD             *pkwdStart;                      // First MSOKWD rec

    // Extensions
    int                 cxchKwdBufRemain;               // Num avail chars
    XCHAR              *pxchKwdNext;                    // Next avail string
    MSOKWD             *pkwdNextFree;                   // Next av MSOKWD rec
    struct _MSOKWDBLK  *pkwdblkNext;                    // List of extra KWDs
    struct _MSOKWSBLK  *pkwsblkNext;                    // List of extra bufs
    } MSOKWTB;


#define msokwtbtString          0x00
#define msokwtbtInteger         0x01
#define msokwtbtHashed          0x02
#define msokwtbtStringHashed    0x02
#define msokwtbtIntegerHashed   0x03


// String buffer batch allocation
typedef struct _MSOKWSBLK
    {
    struct _MSOKWSBLK  *pkwsblkNext;                    // Next in chain
    XCHAR              *pxchBuf;                        // String buffer
    } MSOKWSBLK;


/*************************************************************************
    STRING LOOKUP
 *************************************************************************/

// Lookup keyword
#define MsoTkLookupName(pxch, cchLen, pkwtb) \
            (MsoPkwdLookupName((pxch), (cchLen), (pkwtb))->tk)

MSOAPI_(MSOKWD *) MsoPkwdLookupName(                    // Lookup keyword
    const XCHAR        *pxchStr,
    int                 cchLen,
    MSOKWTB            *pkwtb
    );

MSOAPI_(MSOKWD *) MsoPkwdAddTkLookupName(               // Add kwd to table
    const XCHAR        *pxchStr,
    int                 cchLen,
    TK                  tk,
    MSOKWTB            *pkwtb,
    int                 fCopyStr
    );

MSOAPI_(int) MsoFRemoveTkLookupName(                    // Remove kwd from tbl
    const XCHAR        *pxchStr,
    int                 cchLen,
    MSOKWTB            *pkwtb,
    TK                 *ptk                             // RETURN
    );

MSOAPI_(void) MsoInitHashKwtb(MSOKWTB *pkwtb);          // Init a kwd hash tbl

MSOAPI_(MSOKWD *) _MsoPkwdNew(                          // Batch-alloc MSOKWDs
    int                 ikwdMax,
    MSOKWTB            *pkwtb
    );

int _FAddKwdRgchBuf(int ixchMax, MSOKWTB *pkwtb);       // Batch-alloc kwd stzs

MSOAPI_(MSOKWTB *) MsoPkwtbNew(void);                   // Create new kwd tbl

#ifdef DEBUG
void _DumpKwds(MSOKWTB *pkwtb);                         // Print kwd table
#endif /* DEBUG */


// Get a new MSOKWD record from free list
_inline MSOKWD *MsoPkwdNew(MSOKWTB *pkwtb)
{
    MSOKWD             *pkwd;

    return ((pkwtb)->pkwdNextFree
                ? (pkwd = (pkwtb)->pkwdNextFree,
                        (pkwtb)->pkwdNextFree = pkwd->pkwdNext,
                        pkwd->pkwdNext = (MSOKWD *) NULL,
                        pkwd)
                : _MsoPkwdNew(msoikwdAllocMax, (pkwtb)));
}

// Put an existing MSOKWD record onto the free list
#define MsoDiscardPkwd(pkwd, pkwtb) \
            ((pkwd)->pkwdNext = (pkwtb)->pkwdNextFree, \
                (pkwtb)->pkwdNextFree = (pkwd))

// Return address of first MSOKWD record for hash value in keyword lookup table
#define MsoPpkwdGetHashAddr(pkwtb, ikwd) \
            (&(MsoRgpkwdHashFromKwtb(pkwtb)[ikwd]))

// Return hash table from keytable
#define MsoRgpkwdHashFromKwtb(pkwtb) \
            ((MSOKWD **) (pkwtb)->pvTable)

// Return integer binary table from keytable
#define MsoPkwdlFromKwtb(pkwtb) \
            ((MSOKWDL *) (pkwtb)->pvTable)






/*************************************************************************
    INTEGER LOOKUP
 *************************************************************************/

// REVIEW: references to this function should become references to
// MsoPkwdlLookupL with an MSOKWTB
MSOAPI_(int) MsoWLookupKwdl(                            // Binary search lookup
    long                lValue,
    MSOKWDL const      *pkwdlTbl,
    int                 ikwdlMac
    );

MSOAPI_(MSOKWDL *) MsoPkwdlLookupL(                     // Nohash-lookup a long
    long                lValue,
    MSOKWTB            *pkwtb
    );

#ifdef DEBUG
#define MsoAssertKwtb(pkwtb) \
    MsoAssertKwtbSz(pkwtb, #pkwtb)
MSOAPI_(void) MsoAssertKwtbSz(MSOKWTB *pkwtb, char *szName); // Ensure sorted
#else
#define MsoAssertKwtb(pkwtb)
#endif // DEBUG

MSOAPI_(MSOKWDLH *) MsoPkwdlhLookupL(                   // Hash-lookup a long
    long                lValue,
    MSOKWTB            *pkwtb
    );

MSOAPI_(MSOKWDLH *) MsoPkwdlhAddTkLookupL(              // Add int hash lookup
    long                lValue,
    TK                  tk,
    MSOKWTB            *pkwtb
    );

MSOAPI_(MSOKWDLH *) _MsoPkwdlhNew(int ikwdMax, MSOKWTB *pkwtb);

// Return addr of first MSOKWDLH record for hash value in keyword lookup table
#define MsoPpkwdlhGetHashAddr(pkwtb, ikwd) \
            (&(MsoRgpkwdlhFromKwtb(pkwtb)[ikwd]))

// Return hash table from keytable
#define MsoRgpkwdlhFromKwtb(pkwtb) \
            ((MSOKWDLH **) (pkwtb)->pvTable)


// Get a new MSOKWDLH record from free list
_inline MSOKWDLH *MsoPkwdlhNew(MSOKWTB *pkwtb)
{
    MSOKWDLH           *pkwdlh;

    if (pkwtb->pkwdNextFree)
        {
        pkwdlh = (MSOKWDLH *) (pkwtb)->pkwdNextFree;
        pkwtb->pkwdNextFree = (MSOKWD *) pkwdlh->pkwdlhNext;
        pkwdlh->pkwdlhNext = (MSOKWDLH *) NULL;
        return pkwdlh;
        }
    else
        return _MsoPkwdlhNew(msoikwdAllocMax, pkwtb);
}

// Put an existing MSOKWDLH record onto the free list
#define MsoDiscardPkwdlh(pkwdlh, pkwtb) \
            ((pkwdlh)->pkwdlhNext = (MSOKWDLH *) (pkwtb)->pkwdNextFree, \
                (pkwtb)->pkwdNextFree = (MSOKWD *) (pkwdlh))


#endif /* !KWD_HASH_ONLY */


#ifndef ANSI_XCHAR
#define MsoIpkwdHashPxch(pch, cch)          MsoIpkwdHashPwch(pch, cch)
#define MsoXchUpper MsoWchToUpper
#else /* ANSI_XCHAR */
#define MsoIpkwdHashPxch(pch, cch)          MsoIpkwdHashPch(pch, cch)
#define MsoXchUpper MsoChToUpper
#endif /* !ANSI_XCHAR */



/* M S O  C H  T O  U P P E R */
/*----------------------------------------------------------------------------
    %%Function: MsoChToUpper
    %%Contact: daleg

    Convert ANSI character to uppercase.
----------------------------------------------------------------------------*/

_inline unsigned char MsoChToUpper(unsigned char ch)
{
    return (islower(ch) ? (unsigned char) toupper(ch) : ch);
}


/* M S O  I P K W D  H A S H  P C H */
/*----------------------------------------------------------------------------
    %%Function: MsoIpkwdHashPch
    %%Contact: daleg

    Return a hash index for the given string and length, case insensitive.
----------------------------------------------------------------------------*/

_inline int MsoIpkwdHashPch(const unsigned char *pchStr, int cchLen)
{
    /* Hash on first and last character of string, ignoring case */
    return ((MsoChToUpper(*pchStr) * 419)
                + (MsoChToUpper(*(pchStr + (cchLen - 1)/2)) * 467)
                + (MsoChToUpper(*(pchStr + cchLen - 1)) * 359))
            % msoipkwdMax;
}


/* M S O  I P K W D  H A S H  P W C H */
/*----------------------------------------------------------------------------
    %%Function: MsoIpkwdHashPwch
    %%Contact: daleg

    Return a hash index for the given string and length, case insensitive.
----------------------------------------------------------------------------*/

_inline int MsoIpkwdHashPwch(const WCHAR *pwchStr, int cchLen)
{
    /* Hash on first and last character of string, ignoring case */
    return ((MsoWchToUpper(*pwchStr) * 419)
                + (MsoWchToUpper(*(pwchStr + (cchLen - 1)/2)) * 467)
                + (MsoWchToUpper(*(pwchStr + cchLen - 1)) * 359))
            % msoipkwdMax;
}


/* M S O  I P K W D L H  H A S H */
/*----------------------------------------------------------------------------
    %%Function: MsoIpkwdlhHash
    %%Contact: daleg

    Return a hash index for the given integer value.
----------------------------------------------------------------------------*/

_inline int MsoIpkwdlhHash(long lValue)
{
    return (((lValue + (lValue >> 1)) & ~0x80000000) % msoipkwdMax);
}


MSOEXTERN_C_END     // ****************** End extern "C" *********************

#define KWD_H
#endif /* !KWD_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\drts\shdrt-shortcuts\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File: stdafx.cpp
//
//  Contents: stdafx.cpp : source file that includes just the standard includes 
//            stdafx.pch will be the pre-compiled header                        
//            stdafx.obj will contain the pre-compiled type information         
//
//  History:  19-Feb-2000 Davepl 
//
//--------------------------------------------------------------------------

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\evtmon\inc\emoci.h ===
/*****************************************************************************
    emoci.h

    Owner: DaleG
    Copyright (c) 1996-1997 Microsoft Corporation

    Op-Code Interpreter header file

*****************************************************************************/

#ifndef EMOCI_H
#define EMOCI_H

#include "emocii.h"


MSOEXTERN_C_BEGIN   // ***************** Begin extern "C" ********************

//############################################################################
//
// PUBLIC Interfaces
//
//############################################################################


// System Limits
#define msoilOciStackMax    2000



/* M  S  O  O  C  I  S */
/*----------------------------------------------------------------------------
    %%Struct: MSOOCIS
    %%Contact: daleg

    Op-Code Interpreter State structure
----------------------------------------------------------------------------*/

// The Interpreter op-code fns must always be compatible with MSOAPICALLTYPE
//  so that MSO-exported and app-local functions have the same type
#define MSOOCVAPI MSOOCV MSOAPICALLTYPE

// Define normal function: all args are evaluated and received on the stack
typedef MSOOCV (MSOAPICALLTYPE *MSOPFNOCI)(MSOOCV *pocvSP);

// Define function to return address of variable data
typedef MSOOCV *(MSOAPICALLTYPE *MSOPFNPOCV)(MSOOCII);


typedef struct _MSOOCIS
    {
    MSOPFNOCI const    *rgpfn;                          // Function ptr array
    MSOOCAD const      *rgocadArgDesc;                  // #Args/Offset arg len
    MSOOCV             *pocvSP;                         // Stack pointer
    MSOOCV             *pocvFP;                         // Frame pointer
    MSOOCV              rglStack[msoilOciStackMax];     // Call/Return stack
    unsigned char const*rgcbImmedArg;                   // Immediate arg lens
    void               *rgocvVar;                       // Variable array
    MSOPFNPOCV          pfnPocvGetVar;                  // Get addr of var data
#ifdef DEBUG
    unsigned char     **rgszFnNames;                    // Function names
#endif /* DEBUG */
    } MSOOCIS;


// Define non-evaluating function: it must interpret instructions itself
typedef MSOOCV (MSOAPICALLTYPE *MSOPFNOCI_NE)
                    (MSOOCII **ppocii, MSOOCIS *pocis);



/*************************************************************************
    Prototypes and macros
 *************************************************************************/

MSOAPI_(MSOOCIS *) MsoPocisInit(                        // Init Interp Fn tbl
    MSOOCIS            *pocis,
    MSOPFNOCI const    *rgpfn,                          // Function table
    MSOOCAD const      *rgocadArgDesc,                  // Arg descript table
    unsigned char const*rgcbImmedArg,                   // Immed arg desc tbl
    int                 ipfnMax,                        // Num builtin fns
    void               *rgocvVar,                       // Variable array
    MSOPFNPOCV          pfnPocvGetVar                   // Get addr of var data
    );

MSOAPI_(MSOOCV) MsoOcvEvalPocii(                        // Interpret 1 instr
    MSOOCII           **ppocii,
    MSOOCIS            *pocis
    );

MSOAPI_(MSOOCV *) MsoPocvPushVarArgs(                   // Push var args on stk
    int                 docvArgsFixed,
    MSOOCII           **ppocii,
    MSOOCIS            *pocis
    );


// NOTE:
// NOTE:  The macros below require the parent routine to declare pocvSP!!
// NOTE:

// Return the value of the iocv-th argment on the stack
#define MsoOcvArg(iocv) \
            (pocvSP[iocv])

// Return the value of the pointer in the iocv-th argment on the stack
#define MsoPvOcvArg(iocv) \
            ((void *) (pocvSP[iocv]))

// Convert the pointer value to a interpreter return type
#define MsoOcvFromPv(pv) \
            ((MSOOCV) (pv))

// Return the value of the char in the iocv-th argment on the stack
#define MsoChOcvArg(iocv) \
            ((char) (pocvSP[iocv]))

// Convert the char value to a interpreter return type
#define MsoOcvFromCh(ch) \
            ((MSOOCV) (ch))

// Return the value of the unsigned char in the iocv-th argment on the stack
#define MsoUchOcvArg(iocv) \
            ((unsigned char) (pocvSP[iocv]))

// Convert the unsigned char value to a interpreter return type
#define MsoOcvFromUch(uch) \
            ((MSOOCV) (uch))

// Return the value of the int in the iocv-th argment on the stack
#define MsoIntOcvArg(iocv) \
            ((int) (pocvSP[iocv]))

// Convert the integer value to a interpreter return type
#define MsoOcvFromInt(v) \
            ((MSOOCV) (v))

// Return the value of the unsigned int in the iocv-th argment on the stack
#define MsoUintOcvArg(iocv) \
            ((unsigned int) (pocvSP[iocv]))

// Convert the unsigned int value to a interpreter return type
#define MsoOcvFromUint(v) \
            ((MSOOCV) (v))

// Return the value of the short iocv-th argment on the stack
#define MsoWOcvArg(iocv) \
            ((short) (pocvSP[iocv]))

// Convert the short value to a interpreter return type
#define MsoOcvFromW(w) \
            ((MSOOCV) (w))

// Return the value of the unsigned short iocv-th argment on the stack
#define MsoUwOcvArg(iocv) \
            ((unsigned short) (pocvSP[iocv]))

// Convert the unsigned short value to a interpreter return type
#define MsoOcvFromWw(uw) \
            ((MSOOCV) (uw))

// Return the value of the long in the iocv-th argment on the stack
#define MsoLOcvArg(iocv) \
            ((long) (pocvSP[iocv]))

// Convert the long value to a interpreter return type
#define MsoOcvFromL(l) \
            ((MSOOCV) (l))

// Return the value of the unsigned long in the iocv-th argment on the stack
#define MsoUlOcvArg(iocv) \
            ((unsigned long) (pocvSP[iocv]))

// Convert the unsigned long value to a interpreter return type
#define MsoOcvFromUl(l) \
            ((MSOOCV) (l))

// Return the address of the event (var) of index iocv: Application callback
#define MsoOcvEventAddr(iocv, pocis) \
            ((*(pocis)->pfnPocvGetVar)(iocv))

// Return the address of the stack index
#define MsoOcvStackAddr(docv, pocis) \
            (&(pocis)->pocvFP[docv])

// Return the address of a global variable or function
#define MsoOciiGlobalAddr(ipv, pocis) \
            (&(pocis)->rgpfn[ipv])

// Return the value of iocv-th argment on the stack
#define MsoOcvStack(iocv) \
            ((long) (pocvSP[iocv]))

// Supply the rest of the calling arguments to a var-args function call
#define MsoOcv_varargs_0 \
          MsoOcvStack(0),  MsoOcvStack(1),  MsoOcvStack(2), MsoOcvStack(3), \
          MsoOcv_varargs_4

#define MsoOcv_varargs_1 \
                           MsoOcvStack(1),  MsoOcvStack(2),  MsoOcvStack(3), \
          MsoOcv_varargs_4

#define MsoOcv_varargs_2 \
                                            MsoOcvStack(2),  MsoOcvStack(3), \
          MsoOcv_varargs_4

#define MsoOcv_varargs_3 \
                                                             MsoOcvStack(3), \
          MsoOcv_varargs_4

#define MsoOcv_varargs_4 \
          MsoOcvStack(5),  MsoOcvStack(5),  MsoOcvStack(6),  MsoOcvStack(7), \
          MsoOcv_varargs_8

#define MsoOcv_varargs_5 \
                           MsoOcvStack(5),  MsoOcvStack(6),  MsoOcvStack(7), \
          MsoOcv_varargs_8

#define MsoOcv_varargs_6 \
                                            MsoOcvStack(6),  MsoOcvStack(7), \
          MsoOcv_varargs_8

#define MsoOcv_varargs_7 \
                                                             MsoOcvStack(7), \
          MsoOcv_varargs_8

#define MsoOcv_varargs_8 \
          MsoOcvStack(8),  MsoOcvStack(9),  MsoOcvStack(10), MsoOcvStack(11), \
          MsoOcv_varargs_12

#define MsoOcv_varargs_9 \
                           MsoOcvStack(9),  MsoOcvStack(10), MsoOcvStack(11), \
          MsoOcv_varargs_12

#define MsoOcv_varargs_10 \
                                            MsoOcvStack(10), MsoOcvStack(11), \
          MsoOcv_varargs_12

#define MsoOcv_varargs_11 \
                                                             MsoOcvStack(11), \
          MsoOcv_varargs_12

#define MsoOcv_varargs_12 \
          MsoOcvStack(12), MsoOcvStack(13), MsoOcvStack(14), MsoOcvStack(15), \
          MsoOcv_varargs_16

#define MsoOcv_varargs_13 \
                           MsoOcvStack(13), MsoOcvStack(14), MsoOcvStack(15), \
          MsoOcv_varargs_16

#define MsoOcv_varargs_14 \
                                            MsoOcvStack(14), MsoOcvStack(15), \
          MsoOcv_varargs_16

#define MsoOcv_varargs_15 \
                                                             MsoOcvStack(15), \
          MsoOcv_varargs_16

#define MsoOcv_varargs_16 \
          MsoOcvStack(16), MsoOcvStack(17), MsoOcvStack(18), MsoOcvStack(19), \
          MsoOcv_varargs_20

#define MsoOcv_varargs_17 \
                           MsoOcvStack(17), MsoOcvStack(18), MsoOcvStack(19), \
          MsoOcv_varargs_20

#define MsoOcv_varargs_18 \
                                            MsoOcvStack(18), MsoOcvStack(19), \
          MsoOcv_varargs_20

#define MsoOcv_varargs_19 \
                                                             MsoOcvStack(19), \
          MsoOcv_varargs_20

#define MsoOcv_varargs_20 \
          MsoOcvStack(20), MsoOcvStack(21), MsoOcvStack(22), MsoOcvStack(23), \
          MsoOcv_varargs_24

#define MsoOcv_varargs_21 \
                           MsoOcvStack(21), MsoOcvStack(22), MsoOcvStack(23), \
          MsoOcv_varargs_24

#define MsoOcv_varargs_22 \
                                            MsoOcvStack(22), MsoOcvStack(23), \
          MsoOcv_varargs_24

#define MsoOcv_varargs_23 \
                                                             MsoOcvStack(23), \
          MsoOcv_varargs_24

#define MsoOcv_varargs_24 \
          MsoOcvStack(24), MsoOcvStack(25), MsoOcvStack(26), MsoOcvStack(27), \
          MsoOcv_varargs_28

#define MsoOcv_varargs_25 \
                           MsoOcvStack(25), MsoOcvStack(26), MsoOcvStack(27), \
          MsoOcv_varargs_28

#define MsoOcv_varargs_26 \
                                            MsoOcvStack(26), MsoOcvStack(27), \
          MsoOcv_varargs_28

#define MsoOcv_varargs_27 \
                                                             MsoOcvStack(27), \
          MsoOcv_varargs_28

#define MsoOcv_varargs_28 \
          MsoOcvStack(28), MsoOcvStack(29), MsoOcvStack(30), MsoOcvStack(31)

#define MsoOcv_varargs_29 \
                           MsoOcvStack(29), MsoOcvStack(30), MsoOcvStack(31)

#define MsoOcv_varargs_30 \
                                            MsoOcvStack(30), MsoOcvStack(31)

#define MsoOcv_varargs_31 \
                                                             MsoOcvStack(31)



/*----------------------------------------------------------------------------
    Interpreter function list.
    Should be list in same order as enum for clarity.
----------------------------------------------------------------------------*/

MSOAPI_(MSOOCV) MsoOcv_log_and(
    MSOOCII           **ppocii,
    struct _MSOOCIS    *pocis
    );
MSOAPI_(MSOOCV) MsoOcv_log_or(
    MSOOCII           **ppocii,
    struct _MSOOCIS    *pocis
    );
MSOAPI_(MSOOCV) MsoOcv_log_not(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_less_than(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_less_eql(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_eql(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_gtr_eql(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_gtr_than(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_not_eql(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_assign(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_plus(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_minus(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_mult(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_divide(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_mod(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_increment(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_decrement(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_unary_plus(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_unary_minus(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_bitwise_not(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_bitwise_and(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_bitwise_or(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_bitwise_xor(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_shift_l(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_shift_r(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_dereference(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_addr_of(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_cast_as(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_if(
    MSOOCII           **ppocii,
    struct _MSOOCIS    *pocis
    );
MSOAPI_(MSOOCV) MsoOcv_inline_if(
    MSOOCII           **ppocii,
    struct _MSOOCIS    *pocis
    );
MSOAPI_(MSOOCV) MsoOcv_let(
    MSOOCII           **ppocii,
    struct _MSOOCIS    *pocis
    );
MSOAPI_(MSOOCV) MsoOcv_compound_stmt(
    MSOOCII           **ppocii,
    struct _MSOOCIS    *pocis
    );
MSOAPI_(MSOOCV) MsoOcv_progn(
    MSOOCII           **ppocii,
    struct _MSOOCIS    *pocis
    );
MSOAPI_(MSOOCV) MsoOcv_get_char(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_get_uchar(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_get_short(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_get_ushort(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_get_int(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_get_uint(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_get_long(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_get_ulong(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_get_float(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_get_double(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_get_ldouble(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_set_char(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_set_uchar(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_set_short(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_set_ushort(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_set_int(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_set_uint(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_set_long(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_set_ulong(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_set_float(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_set_double(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_set_ldouble(MSOOCV *pocvSP);




//############################################################################
//
// PRIVATE Interfaces
//
// To use, #define _OCI_PRIVATE
//
//############################################################################

#ifdef _OCI_PRIVATE


// Return the Argument descriptor associated with the function
#define OcadArgDecripOcii(ocii, pocis) \
            ((pocis)->rgocadArgDesc[ocii])

// Return the Argument descriptor list associated with the function
#define PcbArgFromOcad(ocad, pocis) \
            (&(pocis)->rgcbImmedArg[ocad])


#endif /* _OCI_PRIVATE */

MSOEXTERN_C_END     // ****************** End extern "C" *********************

#endif /* !EMOCI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\evtmon\inc\emrule.h ===
/*****************************************************************************
    emrule.h

    Owner: DaleG
    Copyright (c) 1992-1997 Microsoft Corporation

    General Rule-Network Propagation Engine functions and prototypes

----------------------------------------------------------------------------
    NOTE:

    1.  BAD CODE, but it works: FIsDelayFactor(),LpruldependFromCDelay() and
        CDelayFromLpruldepend() rely upon the fact (?) that pointers
        on the machines we support are never (?) small integers.  But if
        this should ever prove false, it would be bad.  We should rewrite
        this to either have a RULDEP structure (as does the rule compiler),
        or make the list of dependencies indexes to rules, rather than
        pointers.

*****************************************************************************/

#ifndef EMRULE_H

#include "msodbglg.h"
#include "emkwd.h"
#include "emrulini.h"
#include "emrultk.h"


MSOEXTERN_C_BEGIN   // ***************** Begin extern "C" ********************

// REVIEW: configure this in makefile, so emtest (for example) can build
// debug without dynamic rules
#ifdef DEBUG
#ifndef YY_NODYNRULES
#define DYN_RULES 1
#endif
#endif


/*----------------------------------------------------------------------------
    System limits
----------------------------------------------------------------------------*/

#define wDelayMax           100                         // Maximum delay poss
#define irultkRuleMax       256                         // Max events cached
#define iruldepAllocMax     256                         // Max ruldeps alloced
#define ichRulNameMax       128                         // Max trace name len
#define ichRulNameAllocMax  1024                        // Max name alloc


/*************************************************************************
    Types:

    irul        Rule node ID.
    ruldep      Rule node dependency link.
    ruldepblk   Rule node dependency link allocation structure.
    sv          Split Value structure.
    rul         Rule node structure.
    ruls        Rule state structure.

 *************************************************************************/


/* I R U L */
/*----------------------------------------------------------------------------
    %%Structure: IRUL
    %%Contact: daleg

    Rule Index definition
----------------------------------------------------------------------------*/

typedef short IRUL;

#define IrulFromTk(tk)      ((IRUL) (tk))
#define TkFromIrul(irul)    (irul)

// Lexer tokens: hard-coded rule node IDs
#define irulERROR       tkERROR
#ifdef tkNil
#define irulNil         tkNil
#else /* !tkNil */
#define irulNil         0
#endif /* tkNil */

// Is rule ID valid (not irulNil and not irulERROR)
#define FValidIrul(irul) \
            ((irul) > 0)




/* R  U  L  D  E  P */
/*----------------------------------------------------------------------------
    %%Structure: RULDEP
    %%Contact: daleg

    Rule node dependency structure.
    This structure holds the dependency information that links a rule node
    to its dependents.
----------------------------------------------------------------------------*/

typedef struct _RULDEP
    {
    struct _MSORUL             *prul;                   // Node referenced
    struct _RULDEP             *pruldepNext;            // Next dependency
//  int                         cDelay;                 // Delay in eval
    } RULDEP;


MSOAPI_(RULDEP *) _MsoPruldepNew(                       // Alloc blk of deps
    int                 cruldep,
    int                 fOnFreeList
    );


// Return a new ruldep record from the free list (requires local var pruldep)
// Operates in either sequential mode (vlpruls->lpruldepNextFree) or free list
#define LpruldepNew() \
            (vlpruls->lpruldepNextFree != NULL \
                ? (vlpruls->fSeqentialFreeRuldeps \
                    ? vlpruls->lpruldepNextFree++ \
                    : (pruldep = vlpruls->lpruldepNextFree, \
                            vlpruls->lpruldepNextFree \
                                    = pruldep->pruldepNext, \
                            pruldep->pruldepNext = NULL, \
                            pruldep)) \
                : _MsoPruldepNew(iruldepAllocMax, TRUE))

// Push a ruldep record onto the free list
#define PushLpruldepOnFreeList(pruldep) \
            ((pruldep)->pruldepNext = vlpruls->lpruldepNextFree, \
             vlpruls->lpruldepNextFree = (pruldep))



/* R  U  L  D  E  P  B  L  K */
/*----------------------------------------------------------------------------
    %%Structure: RULDEPBLK
    %%Contact: daleg

    Rule node dependency allocation block structure.
    This structure allows us to batch-allocate RULDEP records.
----------------------------------------------------------------------------*/

typedef struct _RULDEPBLK
    {
    struct _RULDEPBLK      *lpruldepblkNext;            // Next block
    RULDEP                  rgruldep[1];                // Array of ruldeps
    } RULDEPBLK;


/* R  U  L  C  X  T */
/*----------------------------------------------------------------------------
    %%Structure: RULCXT
    %%Contact: daleg

    (Rul)e (C)onte(x)t-group (T)able structure.
    This structure allows the rule engine to support cheap sparse dependents
    lists for special contexts.
    The callback function allows us to perform any desired side effects
    during the propagation, as well as offering the chance to optimize
    the lookup algorithm.
----------------------------------------------------------------------------*/

typedef struct _RULCXT
    {
    struct _RULCXT         *lprulcxtNext;               // Next context
    LPFNRULCXT              lpfnrulcxt;                 // Callback fn
    int                     iruldepMax;                 // Size of array
    struct _RULCXL         *rglprulcxl[1];              // Hash table
    } RULCXT;



/* R  U  L  C  X  L */
/*----------------------------------------------------------------------------
    %%Structure: RULCXL
    %%Contact: daleg

    (Rul)e (C)onte(x)t-group (L)ist item structure.
    This is the item used in the hash table of the RULCXT above.
----------------------------------------------------------------------------*/

typedef struct _RULCXL
    {
    IRUL                    irul;                       // Rule ID
    struct _RULDEP         *pruldep;                    // Dependent list
    struct _RULCXL         *lprulcxlNext;               // Next in hash chain
    } RULCXL;


#ifdef DEBUG
/* R  U  L  N  B  L  K */
/*----------------------------------------------------------------------------
    %%Structure: RULNBLK
    %%Contact: daleg

    (Rul)e (N)ame block
    Store dynamically constructed rule names.
----------------------------------------------------------------------------*/

typedef struct _RULNBLK
    {
    struct _RULNBLK        *lprulnblkNext;              // Next block
    char                    rgch[1];                    // Block of text
    } RULNBLK;


char *LszGenNameForLprul(                               // Gen dyn rule name
    struct _MSORUL     *prul,
    int                 irulAssert
    );
char *SzSaveRulName(char *szName);                      // Save node name sz
char *LpchRulNameNew(int dichNeeded);                   // Get new name lpch

#endif /* DEBUG */





/* M  S  O  R  U  L */
/*----------------------------------------------------------------------------
    %%Structure: MSORUL
    %%Contact: daleg

    Rule node structure.
    This structure holds the state information for a rule within the
    propagation network.

    ASSUMPTIONS:

        1.  The wDelayMask field only applies to rules, but it is (currently)
            faster to not have to test for whether a node is a rule, by
            merely leaving the field empty for values.
----------------------------------------------------------------------------*/

typedef long RULV;
typedef struct _MSORUL *MSOPRUL;

#pragma pack(2)

typedef struct _MSORUL
    {
    IRUL                        irul;                   // Rule ID
    char                        rultType;               // Type: rule/event
    char                        ipfnrulscSeqCheck;      // Fn to ensure contig
    short                       rulevl;                 // Evaluation level
    short                       birulDependsOn;         // Depends on: nodes
    SVL                         svl;                    // 32-bit storage area
#ifdef DEBUG
    char const                 *lpchName;               // Name or rule text
#endif /* DEBUG */
    IRUL                        irulNextChanged;        // Next changed value
    union
        {
        short                   ipociiInstrs;           // Interp instrs
        short                   USEME_IN_EVENTS;        // Unsed slot
        };
    short                       wIntervalCount;         // Ensure contig seqs
    short                       wDelayMask;             // Delays as bit pos's
    struct _MSORUL             *prulNext;               // Next node in queue
#ifdef DEBUG
    IRUL                        irulNextTrace;          // Next traced rule
    short                       wDebugFlags;            // Random debug flags
#endif /* DEBUG */
    } MSORUL;

#pragma pack()



// Allocate new nodes
MSOAPI_(MSORUL *) MsoPrulNew(void);                     // Allocate new node
MSOAPI_(int) MsoFEnsureIrulAllocated(int irulMax);      // Pre-allocated nodes

// Discard an existing rul node
#define DiscardIrul(irul) \
            (vlpruls->irulLim--)



#define msoprulNil      ((MSORUL *) -1)                 // NIL value for MSORUL
#define msoprulInactive ((MSORUL *) -2)                 // Node is deactivated
#define wRulTrue        1000
#define wRulFalse       0

// Rule node type flags: shared with emrulini.h and rulc.h
#define rultNil             0
#define rultRule            0x00                        // Rule
#define rultEvent           0x01                        // Event/Variable
#define rultPrimaryRule     0x02                        // Rule auto-scheduled
#define rultImmediateRule   0x04                        // Rule executes immed
#define rultPersistentRule  0x20                        // Rule not cleared
#define rultAlwaysPersist   0x40                        // Rule never cleared
#define rultSpecialKwd      0x80                        // Node is generic type

// Debug check that rule is not marked as both NonTerminal and Seq
#define rultRuleMask        0x19

#ifdef NEVER
#define FRultRuleIs(rult, rultExpected) \
            (((rult) & rultRuleMask) == ((rultExpected)))
#endif /* NEVER */


#ifdef DEBUG
#define rultDynActionRule   0x04                        // Dyn DEBUG only
#define rultNonTermRule     0x08                        // Dyn DEBUG only
#define rultSeqRule         0x10                        // Dyn DEBUG only
#endif /* DEBUG */


/* R  U  L  S */
/*----------------------------------------------------------------------------
    %%Structure: RULS
    %%Contact: daleg

    Rule state structure.
    This structure holds the state information for the rule engine.
----------------------------------------------------------------------------*/

typedef int (WIN_CALLBACK *LPFNRul)(IRUL irul);         // Rule Eval function
typedef short (WIN_CALLBACK *PFNRULSC)(void);           // Interval seq chk fn
typedef int (*PFNRULVT)(IRUL irul);                     // Rule V-Table

typedef struct _RULS
    {
    // Rule base limits
    RULLIMS             rullims;                        // Rule base limits
    int                 irulMax;                        // Num nodes allocated
    int                 irulLim;                        // Num nodes used

    // Rule base state information
    RULDEP           ***rgrgpruldepDependents;          // List of Dep lists
    RULDEP            **rgpruldepDependents;            // Active Dep lists
    MSORUL            **lrglprulBlk;                    // Array of node arrays
    int                 ilprulNodesLim;                 // #arrays of arrays
#ifdef DEBUG
    MSORUL            **rgprulNodes;                    // Debug node array
#endif /* DEBUG */
    const short        *prulgAppendTo;                  // Group linkages
    const short        *prulgAppendedFrom;              // Group linkages
    short const        *rgrulevlRulevt;                 // Event_type eval lvls
    int                *rgrulevlRulevtLast;             // Highest Q of rulevts
    MSORUL            **rgprulActiveQueues;             // Active eval queues
    MSORUL            **rgprulDelayedQueues;            // Delayed eval queues
    MSORUL             *lprulQPersistent;               // Temp Q: persistent
    int                *rgirulRulevtChanged;            // Nodes changed in evt
    int                *rgrulevtEval;                   // Pending rulevt eval
    MSORULTKH          *prultkhRulevtHistory;           // Ev history for type
    long               *rgdtkiRulevt;                   // #times enter rulevt
    const int          *rgrulevtFromRulevl;             // Trans lvls to evts
    const short        *lpgrpirulDependBack;            // Back dependencies
    LPFNRul             lpfnEvalRule;                   // Evaluate rule code
    PFNRULSC const     *rgpfnrulscSeqCheck;             // Interval seq chk fns
    MSOKWTB           **rgpkwtbKeyTables;               // Keyword tables

    // Allocation information
    WORD                fDynamicInit : 1;               // Structs alloced?
    WORD                fDynAlloced : 1;                // vlpruls alloced?
    WORD                fDependBackDynAlloced : 1;      // Back deps alloced?
    WORD                fRgDependDynAlloced : 1;        // Dep lists alloced?
    WORD                fDynRulesAlloced : 1;           // Dyn rulebase alloc?
    WORD                fRgrulevlRulevtAlloced : 1;     // Last lvl tbl alloc?
    WORD                fRgprulQueuesAlloced : 1;       // Eval queues alloc?
    WORD                fRgrulevtFromRulevlAlloced : 1; // Lvl-evt tbl alloc?
    WORD                fRgprulNodesAlloced : 1;        // DEBUG nd arr alloc?

    int                 rulgCurr;                       // Current rule group
    IRUL                irulSelf;                       // irulSelf under eval
    MSORUL             *prulEvent;                      // Event causing eval
    IRUL                irulPrimaryEvent;               // Primary ev of intvl
    RULDEP             *lpruldepNextFree;               // Next free dep rec
    RULDEPBLK          *lpruldepblkDependBlocks;        // List of dep blocks
    RULCXT             *lprulcxtActive;                 // Active context list
    RULCXT            **lrglprulcxtContexts;            // List of cntx groups
    int                 rulevtCurr;                     // Current event_type
    int                *prulevtEvalLim;                 // Num Ev types to eval
    MSORUL             *lprulQueue;                     // Current queue
    int                 rulevlRultevtMin;               // 1st eval lvl in evt
    int                 rulevlRulevtLast;               // Last eval lvl in evt
    void               *pociiDynRules;                  // Dyn-loaded rulebase
#ifdef DEBUG
    char               *lpchNames;                      // Name/string buf
    char const * const *rgpchDynNames;                  // Interp: node names
    int                 irulQTrace;                     // Backtrace list
    int                 dichNameFree;                   // Num chars avail
    char               *lpchNameNextFree;               // Next free name rgch
    RULNBLK            *lprulnblkNames;                 // Dyn name list
#endif /* DEBUG */

    // Run-time flags
    WORD                fInited : 1;                    // Rule base inited?
    WORD                fNew : 1;                       // Rule base new?
    WORD                fSeqentialFreeRuldeps : 1;      // Free ruldeps are seq
    WORD                fEvaluatingDeferred : 1;        // Evaling deferred nd?
    WORD                fEvaluating: 1;                 // Eval recursion check

    // Multiple Rule base support
    struct _RULS       *lprulsNext;                     // Next struct LIFO

    // Allocation info
    WORD                fAllocedSpare1 : 1;
    WORD                fAllocedSpare2 : 1;
    WORD                fAllocedSpare3 : 1;
    WORD                fAllocedSpare4 : 1;
    WORD                fAllocedSpare5 : 1;
    WORD                fAllocedSpare6 : 1;
    WORD                fAllocedSpare7 : 1;
    WORD                fAllocedSpare8 : 1;
    WORD                fAllocedSpare9 : 1;
    WORD                fAllocedSpare10 : 1;
    WORD                fAllocedSpare11 : 1;
    int                 ilprulNodesAllocFirstLim;       // Start alloc'd nds +1
    long                lReturn;                        // Return value
    LPV                 lpvSpare3;
    LPV                 lpvSpare4;
    LPV                 lpvSpare5;
    LPV                 lpvSpare6;
    LPV                 lpvSpare7;
    LPV                 lpvSpare8;
    LPV                 lpvSpare9;
    LPV                 lpvSpare10;
    LPV                 lpvSpare11;

    // Debug logging
#ifdef DEBUG
    unsigned int        grfDebugLogFilter;              // DEBUG: how to log
#endif /* DEBUG */

#ifdef DYN_RULES
    // Dynamically-loaded rulebase support
    struct _MSOOCIS    *pocis;                          // Op-Code Interp State
    short               irulRuleInterpLim;              // #Interpreted rules
    short               irulRuleInterpMac;              // #Alloced inter ptrs
    void              **rgpociiRules;                   // Rule instructions
#endif /* DYN_RULES */
    } RULS;

extern RULS            *vlpruls;                        // Global rule state


//----------------------------------------------------
// If using debugger, an rulebase node's value is given by:
//      rulv_<irul> == vlpruls->rgprulNodes[irul]->svl.lValue
//
// Or if the rulebase is statically initialized,    and
// DEBUG_RULE_POINTERS is #defined              then
//      event FOO   can be accessed as *prulFOO     and
//      rule 126    can be accessed as *prul126
//----------------------------------------------------

// Return the number of rules in rule base
#define IrulMax()               (vlpruls->irulMax)

// Return the number of compiled rules in rule base
#define IrulCompiledMax()       (vlpruls->rullims.irulRulesMax)

// Return the number of event_types in rule base
#define RulevtMax()             RulevtMaxPruls(vlpruls)

// Return the number of event_types in rule base
#define RulevtMaxPruls(pruls) \
            ((pruls)->rullims.rulevtMax)

// Return the number of evaluation levels in rule base
#define RulevlMax()         RulevlMaxPruls(vlpruls)

// Return the number of evaluation levels in rule base
#define RulevlMaxPruls(pruls) \
            ((pruls)->rullims.rulevlMax)

#define irulMaxAlloc        128                         // Max nodes/array
#define cbfIrulShift        7                           // #bits irulMaxAlloc
#define wIrulMask           0x7F                        // Mask: irulMaxAlloc
#define ilprulMaxAlloc      256L                        // Max arrays of arrys

///#define irulMaxAlloc     2048                        // Max nodes/array
///#define cbfIrulShift     11                          // #bits irulMaxAlloc
///#define wIrulMask        0x7FF                       // Mask: irulMaxAlloc
///#define ilprulMaxAlloc   100L                        // Max arrays of arrys

///#define irulMaxAlloc     1024                        // Max nodes/array
///#define cbfIrulShift     10                          // #bits irulMaxAlloc
///#define wIrulMask        0x3FF                       // Mask: irulMaxAlloc
///#define ilprulMaxAlloc   100L                        // Max arrays of arrys

// Return the rule node structure pointer for the rule ID
#define LprulFromIrul(irul) \
            (&vlpruls->lrglprulBlk \
                [(irul) >> cbfIrulShift] [(irul) & wIrulMask])

// Return the rule ID of the rule node structure pointer
#define IrulFromLprul(prul)  \
            ((prul)->irul)

// Return the Lim irul value for iruls that are contiguous with the irul
#define IrulLimContig(irul) \
            ((((irul) >> cbfIrulShift) << cbfIrulShift) + irulMaxAlloc)

// Return whether rule node is a primary rule
#define FPrimaryRule(prul)      ((prul)->rultType & rultPrimaryRule)

#ifdef NEVER
// Return whether rule node is a action rule
#define FActionRule(prul)       ((prul)->wDebugFlags & rultActionRule)
#endif /* NEVER */

#ifdef DEBUG
// Return whether rule node is a non-terminal rule (then)
#define FNonTermRule(prul)      ((prul)->wDebugFlags & rultNonTermRule)

// Return whether rule node is a sequence rule (...)
#define FSeqRule(prul)          ((prul)->wDebugFlags & rultSeqRule)
#endif /* DEBUG */

// Return whether the node ID refers to an event node
#define FIsEventIrul(irul)          FIsEventPrul(LprulFromIrul(irul))

// Return whether the node is an event node
#define FIsEventPrul(prul)          ((prul)->rultType & rultEvent)

// Return whether the node is a rule node
#define FIsRulePrul(prul)           (!FIsEventPrul(prul))

#define IMMEDIATE_RULES
#ifdef IMMEDIATE_RULES
// Return whether rule node is a sequence rule (...)
#define FImmediateRulePrul(prul)    ((prul)->rultType & rultImmediateRule)
#endif /* IMMEDIATE_RULES */

// Return whether the node is an *undefined* event
#define FSpecialKwdIrul(irul) \
            FSpecialKwdLprul(LprulFromIrul(irul))

// Return whether the node is an *undefined* event
#define SetFSpecialKwdIrul(irul) \
            SetFSpecialKwdLprul(LprulFromIrul(irul))

// Return whether the node is an *undefined* event
#define FSpecialKwdLprul(prul)      ((prul)->rultType & rultSpecialKwd)

// Return whether the node is an *undefined* event
#define SetFSpecialKwdLprul(prul)  \
            ((prul)->rultType |= rultSpecialKwd)

// Return whether rule node can persist in delayed queue in soft resets
#define FPersistentLprul(prul) \
            ((prul)->rultType & rultPersistentRule)

// Mark that rule node can persist in delayed queue in soft resets
#define SetFPersistentIrul(irul) \
            SetFPersistentLprul(LprulFromIrul(irul))

// Mark that rule node can persist in delayed queue in soft resets
#define SetFPersistentLprul(prul) \
            ((prul)->rultType |= rultPersistentRule)

// Return whether rule node can persist in delayed queue in all resets
#define FAlwaysPersistLprul(prul) \
            ((prul)->rultType & rultAlwaysPersist)

// Mark that rule node can persist in delayed queue in all resets
#define SetFAlwaysPersistIrul(irul) \
            SetFAlwaysPersistLprul(LprulFromIrul(irul))

// Mark that rule node can persist in delayed queue in all resets
#define SetFAlwaysPersistLprul(prul) \
            ((prul)->rultType |= rultAlwaysPersist)

// Return whether rule node can persist in delayed queue
#define FPersistLprulGrf(prul, grf) \
            ((prul)->rultType & (grf))

// Return the value for the current rule
#define RulvSelf() \
            RulvOfIrul(irulSelf)

// Set the value for the current rule
#define SetRulvSelf(rulv) \
            SetRulvOfIrul(irulSelf, (rulv))

// Increment the value for the current rule
#define IncrRulvSelf(drulv) \
            IncrRulvOfIrul(irulSelf, (drulv))


// Return the value1 for the current rule
#define Rulv1Self() \
            Rulv1OfIrul(irulSelf)

// Set the value1 for the current rule
#define SetRulv1Self(rulv) \
            SetRulv1OfIrul(irulSelf, (rulv))

// Increment the value1 for the current rule
#define IncrRulv1Self(drulv) \
            IncrRulv1OfIrul(irulSelf, (drulv))


// Return the value2 for the current rule
#define Rulv2Self() \
            Rulv2OfIrul(irulSelf)

// Set the value2 for the current rule
#define SetRulv2Self(rulv) \
            SetRulv2OfIrul(irulSelf, (rulv))

// Increment the value2 for the current rule
#define IncrRulv2Self(drulv) \
            IncrRulv2OfIrul(irulSelf, (drulv))


// Return the value for the rule ID
#define RulvOfIrul(irul) \
            (LprulFromIrul(irul)->svl.lValue)

// Set the value for the rule ID
#define SetRulvOfIrul(irul, rulv) \
            (LprulFromIrul(irul)->svl.lValue = (rulv))

// Increment the value1 field for the rule ID
#define IncrRulvOfIrul(irul, drulv) \
            IncrRulvOfLprul(LprulFromIrul(irul), (drulv))


// Return the lValue field for a rule node
#define RulvOfLprul(prul)               ((prul)->svl.lValue)

// Set the lValue field for a rule node
#define SetRulvOfLprul(prul, w)         ((prul)->svl.lValue = (w))

// Increment the value1 field for a rule node
#define IncrRulvOfLprul(prul, drulv)    ((prul)->svl.lValue += (drulv))


// Set the value for the rule ID
#define PlValueOfIrul(irul) \
            (&LprulFromIrul(irul)->svl.lValue)

// Return the value1 field for the rule ID
#define Rulv1OfIrul(irul) \
            Rulv1OfLprul(LprulFromIrul(irul))

// Set the value1 field for the rule ID
#define SetRulv1OfIrul(irul, rulv) \
            SetRulv1OfLprul(LprulFromIrul(irul), (rulv))

// Increment the value1 field for the rule ID
#define IncrRulv1OfIrul(irul, drulv) \
            IncrRulv1OfLprul(LprulFromIrul(irul), (drulv))

// Return the value2 field for the rule ID
#define Rulv2OfIrul(irul) \
            Rulv2OfLprul(LprulFromIrul(irul))

// Set the value2 field for the rule ID
#define SetRulv2OfIrul(irul, rulv) \
            SetRulv2OfLprul(LprulFromIrul(irul), (rulv))

// Increment the value2 field for the rule ID
#define IncrRulv2OfIrul(irul, drulv) \
            IncrRulv2OfLprul(LprulFromIrul(irul), (drulv))

// Return the value1 field for a rule node
#define Rulv1OfLprul(prul)              W1OfPsv(PsvOfLprul(prul))

// Set the value1 field for a rule node
#define SetRulv1OfLprul(prul, w)        SetW1OfPsv(PsvOfLprul(prul), (w))

// Increment the value1 field for a rule node
#define IncrRulv1OfLprul(prul, dw)      IncrW1OfPsv(PsvOfLprul(prul), (dw))


// Return the value2 field for a rule node
#define Rulv2OfLprul(prul)              W2OfPsv(PsvOfLprul(prul))

// Set the value2 field for a rule node
#define SetRulv2OfLprul(prul, w)        SetW2OfPsv(PsvOfLprul(prul), (w))

// Increment the value2 field for a rule node
#define IncrRulv2OfLprul(prul, dw)      IncrW2OfPsv(PsvOfLprul(prul), (dw))


// Return the Split Value pointer of a node
#define PsvOfLprul(prul)                (&(prul)->svl.sv)


// Return the value1 field for an rule node
#define Rulv1(rulv)                     W1OfPsv((SV *) &(rulv))

// Set the value1 field for a node
#define SetRulv1(rulv, w)               SetW1OfPsv(((SV *) &(rulv)), (w))

// Return the value2 field
#define Rulv2(rulv)                     W2OfPsv((SV *) &(rulv))

// Set the value2 field for a node
#define SetRulv2(rulv, w)               SetW2OfPsv(((SV *) &(rulv)), (w))


// Return the confidence value of a node node
#define WConfidence(prul)               Rulv1OfLprul(prul)

// Set the confidence value of a node node
#define SetConfidence(prul, wValue)     SetRulv1OfLprul((prul), (wValue))

// Return the doubt value of a node node
#define WDoubt(prul)                    Rulv2OfLprul(prul)

// Set the doubt value of a node node
#define SetDoubt(prul, wValue)          SetRulv2OfLprul((prul), (wValue))


// OBSOLETE FORMS OF MACROS
#define WValueOfIrul(irul)              RulvOfIrul(irul)
#define SetWValueOfIrul(irul, rulv)     SetRulvOfIrul(irul, rulv)
#define WRulValue1(prul)                Rulv1OfLprul(prul)
#define SetWRulValue1(prul, w)          SetRulv1OfLprul((prul), (w))
#define WRulValue2(prul)                Rulv2OfLprul(prul)
#define SetWRulValue2(prul, w)          SetRulv2OfLprul((prul), (w))

// Return the rule node for the rule value
#define LprulOfWValue(lplValue) \
            ((MSORUL *) \
                (((char *) lplValue) - CchStructOffset(MSORUL, svl.lValue)))

#ifdef DEBUG
// Return the value name or rule text of the rule node structure pointer
#define LpchRulName(prul)   ((prul)->lpchName)

// Return the value name or rule text of the rule node structure pointer
#define LpchIrulName(irul)  LpchRulName(LprulFromIrul(irul))

// Return debug rule name for dynamic rule
#define PszNameDynLprul(prul) \
            (vlpruls->rgpchDynNames[(prul)->irul - IrulCompiledMax()])
#endif /* DEBUG */

// Return the node evaluation level for the node
#define RulevlOfPrul(prul) \
            (prul->rulevl)

// Return the event_type for the node
#define RulevtOfLprul(prul) \
            RulevtOfRulevl(RulevlOfPrul(prul))

// Return the event_type for the evaluation level
#define RulevtOfRulevl(rulevl) \
            (vlpruls->rgrulevtFromRulevl[rulevl])

// Return the rule queue of the rule level
#define LplprulQueueOf(rulevl)  (&vlpruls->rgprulActiveQueues[rulevl])

// Return the delayed-evaluation rule queue of the event_type
#define LplprulDelayedQueueOf(rulevt) \
            (&vlpruls->rgprulDelayedQueues[rulevt])

// Return the minimum evaluation level of the event_type
#define RulevlMinOfRulevt(rulevt) \
            (vlpruls->rgrulevlRulevt[(rulevt)])

// Return the maximum evaluation level of the event_type
#define RulevlMaxOfRulevt(rulevt) \
            (vlpruls->rgrulevlRulevt[(rulevt) + 1])

// Return the list of dependent node references of node ID
#define LpruldepFromIrul(irul) \
            (vlpruls->rgpruldepDependents[irul])

// Return the list of dependent node references of node
#define LpruldepGetDependents(prul) \
            LpruldepFromIrul(IrulFromLprul(prul))

// Set the list of dependent node references of node ID
#define SetLpruldepFromIrul(irul, pruldep) \
            (vlpruls->rgpruldepDependents[irul] = (pruldep))

// Set the list of dependent node references of node
#define LpruldepSetDependents(prul, pruldep) \
            SetLpruldepFromIrul(IrulFromLprul(prul), (pruldep))

// Return the list of dependent node references of node ID for specific group
#define LpruldepFromRulgIrul(rulg, irul) \
            (*LplpruldepForRulgIrul(rulg, irul))

// Set the list of dependent node references of node ID for specific group
#define SetLpruldepFromRulgIrul(rulg, irul, pruldep) \
            (*LplpruldepForRulgIrul(rulg, irul) = (pruldep))

// Return the address of the start of a ruldep list for the irul and group
#define LplpruldepForRulgIrul(rulg, irul) \
            (&(vlpruls->rgrgpruldepDependents[rulg][irul]))

// Return whether a dependent reference is in fact a delay specfication
#define FIsDelayFactor(lprulDepend) \
            ((unsigned long) (lprulDepend) < wDelayMax)

// Return the delay value associated with the dependency record
#define CDelayFromLpruldepend(lprulDepend) \
            ((int) ((unsigned long) lprulDepend))

// Return a dependency record to represent the delay factor
#define LpruldependFromCDelay(cDelay) \
            ((MSORUL *) (cDelay))

// Add a delay to the delay field of a delayed rule
#define AddCDelayToLprul(prul, cDelay) \
            ((prul)->wDelayMask |= (cDelay))

// Return whether a rule has any delay factor
#define FHaveCDelay(prul) \
            ((prul)->wDelayMask)

// Return whether a rule has a specific delay factor
#define FHaveCDelayOf(prul, cDelay) \
            ((prul)->wDelayMask & (cDelay))

// Decrement the node's delay counts (by shifting right)
#define DecrementCDelaysOfLprul(prul) \
            ((prul)->wDelayMask >>= 1)


// Return whether the (event) node is marked for history recording
#define FHistoryRecordLprul(prul) \
            (TRUE)                                      // First version
//          ((prul)->fRecordHistory)                    // Correct version


// Return whether node must check interval counts to detect seq discontinuities
#define FIntervalsSeqCheckedPrul(prul) \
            ((prul)->ipfnrulscSeqCheck)

// Return interval counts associated with node that has sequence checking
#define WIntervalsSeqCheckedPrul(prul) \
            ((*vlpruls->rgpfnrulscSeqCheck[(prul)->ipfnrulscSeqCheck])())


// Return whether the rule base is initialized
#define FRulesInited(lpruls)    (lpruls != NULL  &&  lpruls->fInited)


// Return the op-code instructions for an interpreted rule ID
#define PociiForIrul(irul) \
            PociiForPrul(LprulFromIrul(irul))

// Return the op-code instructions for an interpreted rule
#define PociiForPrul(prul) \
            ((MSOOCII *) vlpruls->rgpociiRules[((prul)->ipociiInstrs)])

// Return any group(s) that append(s) the current group
#define RulgAppendedFrom(rulg) \
            (vlpruls->prulgAppendedFrom[rulg])

// Return the list of groups that append from other groups
#define PrulgAppendedFrom() \
            (vlpruls->prulgAppendedFrom)

// Return the group (if any) that the current group appends to
#define RulgAppendTo(rulg) \
            (vlpruls->prulgAppendTo[rulg])

// Return the list of groups that append to other groups
#define PrulgAppendTo() \
            (vlpruls->prulgAppendTo)


#define rulgNil         (-1)                            // "No" rule group
#define rulevtNil       (-1)                            // "No" event type

#ifdef DEBUG
// Return whether node is marked for automatic backtracing */
#define FTraceLprul(prul) \
            ((prul)->irulNextTrace != 0)
#endif /* DEBUG */

// Return the list of nodes that current node depends upon
#define LpirulGetDependsOn(prul) \
            (&vlpruls->lpgrpirulDependBack[(prul)->birulDependsOn])



/*************************************************************************
    Prototypes and macros for rule.c
 *************************************************************************/

#ifndef max
#define max(a,b)    ((a) > (b) ? (a) : (b))
#endif /* !max */
#ifndef min
#define min(a,b)    ((a) < (b) ? (a) : (b))
#endif /* !max */


// Push the node onto the queue
#define PushLprul(prul, lplprulQ)  \
            ((prul)->prulNext = *(lplprulQ), \
             *(lplprulQ) = (prul))

// Pop the node from the queue into the variable
#define PopLprul(lplprul, lplprulQ)  \
            (*lplprul = *lplprulQ, \
             *lplprulQ = (*lplprul)->prulNext, \
             (*lplprul)->prulNext = 0)

// Push event node into Auto-Clear (Changed) list
#define PushLpRulChanged(prul) \
            if ((prul)->irulNextChanged == 0) \
                { \
                int     rulevt = RulevtOfLprul(prul); \
                \
                (prul)->irulNextChanged \
                    = vlpruls->rgirulRulevtChanged[rulevt]; \
                vlpruls->rgirulRulevtChanged[rulevt] = IrulFromLprul(prul); \
                }

// Mark event as never Auto-Clearing
#define SetNoAutoClearRulv(rulv) \
            (LprulFromRulv(rulv)->irulNextChanged = irulNoAutoClear)
#define SetNoAutoClearLprul(prul) \
            ((prul)->irulNextChanged = irulNoAutoClear)

#define irulChangedNil      -1
#define irulNoAutoClear     -2

// Return the offset of a field from the start of its typedef'd structure
// NOTE: THIS IS TRICKY CODE, BUT COMPLETELY LEGAL C!!
//       To understand it, remember that 0 is a valid pointer for ALL types!
#define CchStructOffset(type, field) \
            (((char *) (&((type *) 0)->field)) - ((char *) 0))


// Call Rule Evaluation function provided by Application
#define FEvalRule(irul) \
            (*vlpruls->lpfnEvalRule)(irul)


#ifndef STATIC_LINK_EM
MSOAPI_(RULS **) MsoPvlprulsMirror(RULS **pvlprulsApp); // Exchange &vlpruls
#else /* STATIC_LINK_EM */
#define MsoPvlprulsMirror(pvlprulsApp)  pvlprulsApp
#endif /* !STATIC_LINK_EM */
MSOAPI_(int) MsoFInitRules(                             // Init rule base
    LPFNRulinit         lpfnRulInit,
    RULS               *lpruls
    );
IRUL IrulDefineEvent(int rulevt, char *szName);         // Define simple event
MSOAPI_(MSOKWD *) MsoFDefineStringKwdEvent(             // Define str kwd event
    int                 rulevt,
    char               *szName,
    XCHAR              *pxch,
    int                 cch,
    int                 ikwtb
    );
MSOAPI_(MSOKWDLH *) MsoFDefineIntegerKwdEvent(          // Define int kwd event
    int                 rulevt,
    char               *szName,
    long                lValue,
    int                 ikwtb
    );
MSOAPI_(void) MsoClearRules(void);                      // Clear nodes & state
MSOAPI_(void) MsoClearEventsForRulevts(                 // Clr rg of ev types
    int                 rulevtFirst,
    int                 drulevtCount,
    int                 fSavePersistentDelayed,
    int                 fClearChanged,
    int                 fClearIntervalCounts
    );
MSOAPI_(void) MsoRestorePersistentDelayedRules(void);   // Restore delayed Q
MSOAPI_(int) MsoFAddPruldepDependent(                   // Add dependent link
    IRUL                irul,
    MSORUL             *prulDependent,
    int                 cDelay,
    int                 rulg
    );
MSOAPI_(void) MsoFixUpPruldeps(                         // Fix up after insert
    IRUL                irul,
    int                 rulg,
    int                 rulgBase,
    RULDEP             *lpruldepOldList,
    RULDEP             *lpruldepNewList
    );
MSOAPI_(int) MsoFDelPruldepDependent(                   // Del dependent link
    IRUL                irul,
    MSORUL             *prulDependent,
    int                 rulg,
    int                 fDiscard
    );
MSOAPI_(void) MsoSetActiveRuls(RULS *pruls);            // Set curr vlpruls
MSOAPI_(void) MsoFreeRuleMem(RULS *pruls);              // Free rule memory
#ifdef OFFICE_BUILD
MSOAPI_(void) MsoMarkRuleMem(RULS *pruls);              // Mark rule mem used
#endif /* OFFICE_BUILD */
MSOAPI_(void) MsoSetEventTypeRulevt(int rulevt);        // Change event_types
MSOAPI_(void) MsoClearChangedEventsForRulevt(int rulevt);// Clr event_type vals
void RemoveLprulChanged(MSORUL *prul);                  // Un-auto-clear event
MSOAPI_(int) MsoEvaluateEvents(int rulevt);             // Event evaluation
MSOAPI_(int) MsoFEvalIrul(IRUL irul);                   // Eval single node
MSOAPI_(void) MsoDelaySignalIrul(                       // Signal node w/delay
    IRUL                irul,
    long                lValue,
    int                 cDelay
    );
MSOAPI_(void) MsoDelaySignalIrulFrom(                   // Signal node w/delay
    IRUL                irul,
    IRUL                irulFrom,
    int                 cDelay
    );
MSOAPI_(void) MsoSignalIrul(IRUL irul, long lValue);    // Cond schedule irul
#define PushIrulToEval(irul, lValue) \
            MsoSignalIrul(irul, lValue)
MSOAPI_(void) MsoScheduleIrul(IRUL irul, long lValue);  // Schedule rule to run
#ifdef DEBUG
MSOAPI_(void) MsoScheduleIrulDebug(IRUL irul, long lValue);// Log and schedule
MSOAPI_(void) MsoScheduleIrulDebugMso(IRUL irul, long lValue);//Log &sched MSO
#else
#define MsoScheduleIrulDebug    MsoScheduleIrul
#define MsoScheduleIrulDebugMso MsoScheduleIrul
#endif /* DEBUG */

MSOAPI_(void) MsoDelayScheduleIrul(                     // Schedule after delay
    IRUL                irul,
    long                lValue,
    int                 cDelay
    );
#ifdef DEBUG
MSOAPI_(void) MsoDelayScheduleIrulDebug(                // Log and schedule
    IRUL                irul,
    long                lValue,
    int                 cDelay
    );
#else
#define MsoDelayScheduleIrulDebug   MsoDelayScheduleIrul
#endif /* DEBUG */
MSOAPI_(void) MsoDelayScheduleIrulFrom(                 // Sched, pass value
    IRUL                irul,
    IRUL                irulFrom,
    int                 cDelay
    );
MSOAPI_(int) MsoFEvalIrulImmediately(                   // Eval irul now
    IRUL                irul,
    long                lValue
    );
MSOAPI_(void) MsoPushLprulDependents(MSORUL *prul);     // Push dependents
MSOAPI_(void) MsoPushDelayedEvalForRulevt(int rulevt);  // Push delayed nodes
MSOAPI_(void) MsoAutoClearIrul(IRUL irul);              // Mark node for clear
MSOAPI_(int) MsoFAliasPrulPrul(                         // Ret if 2 are aliases
    MSORUL             *prul,
    MSORUL             *prulTarget
    );
void RecordLprulHistory(MSORUL *prul);                  // Push ev into hist
#ifdef NEVER
MSOAPI_(int) MsoFIrulHistoryValueWas(                   // Look 4 event in hist
    int                 dirultkBackwards,
    long               *lpwVar
    );
#endif // NEVER
#ifdef NEED_AS_FUNCTION
void SetCurrRulg(int rulgGroup);                        // Set rule group
#endif /* NEED_AS_FUNCTION */
MSOAPI_(void) MsoSignalEventIrul(IRUL irul, long lValue);// Signal an event
MSOAPI_(void) MsoSignalEventIrulFrom(                   // Signal ev from node
    IRUL                irul,
    IRUL                irulFrom
    );
#ifdef NEVER
MSOAPI_(void) MsoSetRuleConfid(IRUL irul, int wFactor); // Set confidence val
#endif // NEVER

// Schedule a node for deferred evaluation, based upon a decision rule
//  This macro gets invoked twice.  See _MsoFDeferIrul() for details.
#define FDeferIrul(irul) \
            (vlpruls->fEvaluatingDeferred ||  _MsoFDeferIrul(irul))

#define FDeferIrulExpr(irul, lExpr) \
            (vlpruls->fEvaluatingDeferred \
                ||  (((int) lExpr)  &&  _MsoFDeferIrul(irul)))

#define FDeferIrulExprL(irul, lExpr, lValue) \
            (vlpruls->fEvaluatingDeferred \
                ||  (((int) lExpr)  &&  _MsoFDeferIrulL((irul), (lValue))))

#define IrulPickDeferred(irulDecision) \
            MsoIrulPickDeferred(irulDecision)

MSOAPI_(int) _MsoFDeferIrul(IRUL irul);                 // Add to defer list
MSOAPI_(int) _MsoFDeferIrulL(IRUL irul, long lValue);   // Add to defer w/value
MSOAPI_(IRUL) MsoIrulPickDeferred(IRUL irulDecision);   // Pick from defer list


MSOAPI_(void) MsoSetRulNotify(                          // Set up notification
    long                lExprValue,                     // Really an int
    IRUL                irulDecision,
    IRUL                irulNotify
    );
MSOAPI_(int) MsoFRulNotify(long wNotify);               // Notify on next eval
MSOAPI_(int) MsoFRulNotifyImmediately(long wNotify);    // Notify immediately
MSOAPI_(long) MsoRulvElement(IRUL irulArray, IRUL iirul);// Get value of array
MSOAPI_(void) MsoSetElementRulv(                        // Set value of array
    IRUL                irulArray,
    IRUL                iirul,
    long                lValue
    );
MSOAPI_(void) MsoSetAllElementsToRulv(                  // Set all vals of arr
    IRUL                irulArray,
    IRUL                cirul,
    long                lValue
    );


/* M S O  F  A C T I V A T E  I R U L */
/*----------------------------------------------------------------------------
    %%Function: MsoFActivateIrul
    %%Contact: daleg

    Activate a node in the rulebase
----------------------------------------------------------------------------*/

_inline int MsoFActivateIrul(IRUL irul)                 // Activate a node
{
    MSOPRUL             prul = LprulFromIrul(irul);

    if (prul->prulNext == msoprulInactive)
        {
        prul->prulNext = (MSOPRUL) NULL;
        return TRUE;
        }
    else
        return FALSE;
}


/* M S O  F  D E A C T I V A T E  I R U L */
/*----------------------------------------------------------------------------
    %%Function: MsoFDeactivateIrul
    %%Contact: daleg

    Deactivate a node in the rulebase
----------------------------------------------------------------------------*/

MSOAPI_(int) _MsoFDeactivateIrul(IRUL irul);            // Deactivate a node

_inline int MsoFDeactivateIrul(IRUL irul)
{
    MSOPRUL             prul = LprulFromIrul(irul);

    if (prul->prulNext == NULL)
        {
        prul->prulNext = msoprulInactive;
        return TRUE;
        }
    else
        return _MsoFDeactivateIrul(irul);
}


MSOAPI_(int) MsoFDeleteIrul(IRUL irul, int rulg);       // Delete a node


/*************************************************************************
    Prototypes and macros for rultest.c and rulconcl.c.
    These prototypes "Hungarianize" the rule code so that the rule
    authors do not have to know Hungarian, but it is preserved within
    the application code.
 *************************************************************************/

// Return the current interval number for the event_type
#define CIntervalsRulevt(rulevt) \
            (vlpruls->rgdtkiRulevt[rulevt])

// OBSOLETE: Return the current interval number for the event_type
#define CIntervalsRsct(rulevt)              CIntervalsRulevt(rulevt)

// Increment the current interval number for the event_type
#define IncrIntervalsRsct(rulevt, dc) \
            (vlpruls->rgdtkiRulevt[rulevt] += (dc))

#ifdef NEVER
// Set long value of a node and force propagation
#define SetValue(wVar, lValue) \
            SignalEvent(wVar, lValue)
#endif /* NEVER */

// Convert a "variable" event reference to an node address
#define LprulFromRulv(rulvVar) \
            LprulOfWValue(&(rulvVar))

// Notify a node, on its next evaluation pass
#define FNotify(rgwVar) \
            MsoFRulNotify(rgwVar)

// Notify an action rule, immediately
#define FNotifyImmediately(rgwVar) \
            MsoFRulNotifyImmediately(rgwVar)

// Indicate the next event_type to enter when current event_type is exited
#define SetNextEventType(rulevt) \
            if (vlpruls->prulevtEvalLim \
                    < vlpruls->rgrulevtEval + RulevtMax()) \
                (*vlpruls->prulevtEvalLim++ = (rulevt)); \
            else \
                AssertSz0(FALSE, "Exceeded max number of rulevts to eval");

// Force delayed evaluation of rule of given ID: GENERATED BY RULE COMPILER
#define DelayEvalIrul(irul, cDelay) \
            MsoDelayScheduleIrulFrom((irul), (irul), (cDelay))

// Return whether the dirultkBackwards'th previous value was the given event
#define ValueWas(dirultkBackwards, wVar) \
            MsoFIrulHistoryValueWas(dirultkBackwards, &(wVar))

// Find the given value in its event_type history, and return the (neg) offset
#define FindPrevValueFrom(dirultkBackwards, wVar) \
            DirultkFindPrevValueFrom(dirultkBackwards, &(wVar))

// Mark event/rule for automatic clearing on event_type exit
#define AutoClear(irul) \
            MsoAutoClearIrul(irul)

// Mark expression as exempt from dependency linkage in rule if
#define Value(expr) (expr)

// Push all dependents of node of ID onto their evaluation queues
#define Propagate(irul) \
            MsoPushLprulDependents(LprulFromIrul((int) irul))

// Evaluate the rule at normal time
#define GoToRule(irul) \
            MsoDelayScheduleIrul((irul), TRUE, 0 /* cDelay */)

// Evaluate the rule at normal time
#define GoToIrul(irul) \
            MsoDelayScheduleIrulFrom((IRUL) (irul), (irulSelf), 0 /* cDelay */)

// Evaluate the rule after delay of 1, incrementing value
#define GoToIrulNoValue(irul) \
            MsoDelayScheduleIrulFrom \
                ((IRUL) (irul), (IRUL) (irul), 1 /* cDelay */)

// Evaluate the rule at normal time
#define GoToDirul(dirul) \
            MsoDelayScheduleIrulFrom \
                ((IRUL) (irulSelf) + (dirul), (irulSelf), 0 /* cDelay */)

// Evaluate the rule after delay of 1
#define DelayGoToRule(irul) \
            DelayGoToIrulNoValue(irul)

// Signal the event with the given value
#define SignalIrul(irul, lValue) \
            MsoSignalIrul(irul, lValue)

// Signal the event with the given value
#define SignalEvent(wVar, lValue) \
            MsoSignalEventIrul(IrulFromLprul(LprulFromRulv(wVar)), (lValue))

// Signal the event with the given value
#define SignalEventIrul(irul, lValue) \
            MsoSignalEventIrul(irul, lValue)

// Signal the node with the value from the current rule
// REVIEW: THIS IS WRONG, NOT CONDITIONALLY SCHEDULING IF EVENT
#define SignalIrulSelf(irul) \
            MsoDelayScheduleIrulFrom((IRUL) (irul), (irulSelf), 0)

// Signal the event with the value from the current rule
#define SignalEventIrulSelf(irul) \
            MsoSignalEventIrulFrom((IRUL) (irul), (irulSelf))

// Evaluate the event after delay of 1
#define DelaySignalEventIrul(irul, lValue) \
            MsoDelayScheduleIrul((irul), (lValue), 1 /* cDelay */)

// Evaluate the event after specified delay
#define DelaySignalEventIrulAfter(irul, lValue, cDelay) \
            MsoDelayScheduleIrul((irul), (lValue), 1 << ((cDelay) - 1))

// Evaluate the node after delay of 1, getting value from rule
#define DelaySignalIrulSelf(irul) \
            MsoDelayScheduleIrulFrom((irul), (irulSelf), 1 /* cDelay */)

// Evaluate the event after delay of 1, getting value from rule
#define DelaySignalEventIrulSelf(irul) \
            MsoDelayScheduleIrulFrom((irul), (irulSelf), 1 /* cDelay */)

// Evaluate the event after delay of 1
// REVIEW daleg: OBSOLETE: USE DelaySignalEventIrul or "then ... (<event>)"
#define DelaySignalIrul(irul) \
            MsoDelayScheduleIrul((irul), TRUE, 1 /* cDelay */)

// Evaluate the event after delay of 1
#define DelaySignal(rulvVar) \
            DelaySignalRulv((rulvVar), TRUE)

// Evaluate the event after delay of 1
#define DelaySignalRulv(rulvVar, lValue) \
            CDelaySignalRulv((rulvVar), (lValue), 1 /* cDelay */)

// Evaluate the event after delay of 1
#define CDelaySignalRulv(rulvVar, lValue, cDelay) \
            MsoDelayScheduleIrul(LprulFromRulv(rulvVar)->irul, (lValue), \
                                 (cDelay))

// Evaluate the rule after delay of 1 passing TRUE as the value
#define DelayGoToIrul1(irul) \
            MsoDelayScheduleIrul((irul), TRUE, 1 /* cDelay */)

// Evaluate the rule after specified delay
#define DelayGoToIrulAfter(irul, cDelay) \
            MsoDelayScheduleIrul((irul), TRUE, 1 << ((cDelay) - 1))

// Evaluate the rule with value after specified delay
#define DelayGoToIrulWithRulvAfter(irul, lValue, cDelay) \
            MsoDelayScheduleIrul((irul), (lValue) - (cDelay) + 1, \
                                 1 << ((cDelay) - 1))

// Evaluate the rule after specified delay
#define DelayGoToDirulAfter(dirul, cDelay) \
            MsoDelayScheduleIrulFrom((IRUL) (irulSelf + (dirul)), (irulSelf), \
                                     1 << ((cDelay) - 1))

// Evaluate the rule after delay of 1, incrementing value
#define DelayGoToIrulNoValue(irul) \
            MsoDelayScheduleIrulFrom \
                ((IRUL) (irul), (IRUL) (irul), 1 /* cDelay */)

// Evaluate the rule after delay of 1, passing the value of the current node
#define DelayGoToIrul(irul) \
            MsoDelayScheduleIrulFrom((IRUL) (irul), (irulSelf), 1 /* cDelay */)

// Evaluate the rule (via relative offset) after delay of 1
#define DelayGoToDirul(dirul) \
            MsoDelayScheduleIrulFrom \
                ((IRUL) (irulSelf + (dirul)), (irulSelf), 1)

// Evaluate the rule (via relative offset) after delay of 1
#define DelayGoToDirulNoValue(dirul) \
            MsoDelayScheduleIrulFrom((IRUL) (irulSelf + (dirul)), \
                                     (IRUL) (irulSelf + (dirul)), 1)

// Evaluate the rule (via relative offset) after delay of 1, with value rulv
#define DelayGoToDirulWithRulv(dirul, rulv) \
            (SetRulvOfIrul(irulSelf + (dirul), (rulv)), \
             DelayGoToDirulNoValue(dirul))

// Evaluate the rule (via relative offset) after delay of 1, with value rulv2
#define DelayGoToDirulWithRulv2(dirul, rulv2) \
            (SetRulv2OfIrul(irulSelf + (dirul), (short) (rulv2)), \
             DelayGoToDirulNoValue(dirul))

// Evaluate the rule (via relative offset) after delay of 1, with value rulv2
#define DelayGoToDirulWithRulv1(dirul, rulv1) \
            (SetRulv1OfIrul(irulSelf + (dirul), (short) (rulv1)), \
             DelayGoToDirulNoValue(dirul))

// Evaluate the rule (via relative offset) after delay of 1, with values
#define DelayGoToDirulWithRulvs(dirul, rulv1, rulv2) \
            (SetRulv1OfIrul(irulSelf + (dirul), (short) (rulv1)), \
             SetRulv2OfIrul(irulSelf + (dirul), (short) (rulv2)), \
             DelayGoToDirulNoValue(dirul))

// Deactivate curr rule if the fTest value is FALSE: used in rule test clause
#define FAutoDeactivateSelf(fTest) \
            FAutoDeactivateIrul(irulSelf, (fTest))

// Deactivate the rule if the fTest value is FALSE: used in rule test clause
#define FAutoDeactivateIrul(irul, fTest) \
            ((fTest) ? FALSE : (_MsoFDeactivateIrul(irul), TRUE))

// Set the Rule Propagation Group to the given value
#define SetCurrRulg(rulgGroup) \
            (vlpruls->rgpruldepDependents \
                = vlpruls->rgrgpruldepDependents[vlpruls->rulgCurr \
                                                        = rulgGroup])

// Return the current main Rule Propagation Group
#define FCurrRulg(rulg) \
            (vlpruls->rulgCurr == (rulg))



/*************************************************************************
    Prototypes and macros for Debugging and Error Handling
 *************************************************************************/

#ifdef DEBUG
MSOAPI_(int) MsoFTraceIrul(IRUL irul, int fTraceOn);    // Trace a node
char *SzFromFixed3(long lValue, char *pchBuf);          // Fixed to sz conv

#define DebugDumpQueues(wTraceLvl, sz, lValue, wToLevel) \
            { \
            static const unsigned char      _szDump[] = sz; \
            \
            _DumpQueues(wTraceLvl, _szDump, lValue, wToLevel); \
            }
#define DebugDumpQueue(wTraceLvl, rulevl) \
            _DumpQueue(wTraceLvl, rulevl, LplprulQueueOf(rulevl))

#else /* !DEBUG */
#define DebugDumpQueues(wTraceLvl, sz, lValue, wToLevel)
#define DebugDumpQueue(wTraceLvl, rulevl)

#endif /* DEBUG */


MSOEXTERN_C_END     // ****************** End extern "C" *********************


#define EMRULE_H

#if !(defined(OFFICE_BUILD)  ||  defined(XL))

#ifdef DYN_RULES
int FLoadDynEmRules(void);                              // Load dyn rulebase
#include "emruloci.h"
#endif /* DYN_RULES */

#endif /* !OFFICE_BUILD */

#endif /* !EMRULE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\evtmon\inc\emrultk.h ===
/*****************************************************************************
    emrultk.h

    Owner: DaleG
    Copyright (c) 1992-1997 Microsoft Corporation

    Rule and Lexer-token history recording header file.

*****************************************************************************/

#ifndef EMRULTK_H
#define EMRULTK_H

MSOEXTERN_C_BEGIN   // ***************** Begin extern "C" ********************

#ifndef MSOCP_DEFINED
typedef long MSOCP;                                     // Character position
#define msocpNil ((MSOCP) -1)
#define msocp0 ((MSOCP) 0)
#define msocpMax ((MSOCP) 0x7FFFFFFF)
#define MSOCP_DEFINED
#endif /* !MSOCP_DEFINED */


/*************************************************************************
    Types:

    rultk       Rule/lexer-token history record.
    rultkh      Rule/lexer-token history cache.

 *************************************************************************/


/* M  S  O  R  U  L  T  K */
/*----------------------------------------------------------------------------
    %%Structure: MSORULTK
    %%Contact: daleg

    Rule/lexer-token history record.
----------------------------------------------------------------------------*/

typedef struct _MSORULTK
    {
    void               *pObject;                        // Object, e.g. doc
    MSOCP               cpFirst;                        // First CP of token
    MSOCP               dcp;                            // CP len of token
    int                 ich;                            // Char offset of tk
    long                dich;                           // Num of chars of tk
    long                wInterval;                      // Num intervals
    int                 tk;                             // Token number
    long                lValue;                         // Token value
    } MSORULTK;


#define irultkNil   (-2)


/* M  S  O  R  U  L  T  K  H */
/*----------------------------------------------------------------------------
    %%Structure: MSORULTKH
    %%Contact: daleg

    Rule/lexer-token history cache structure.
----------------------------------------------------------------------------*/

typedef struct _MSORULTKH
    {
    MSORULTK           *rgrultkCache;                   // History record list
    int                 irultkMac;                      // Lim of allocated
    int                 irultkMin;                      // User-defined marker
    int                 irultkLim;                      // Next cache index
    int                 irultkAbsBase;                  // Absolute irultk base
    } MSORULTKH;


/* M  S  O  C  A */
/*----------------------------------------------------------------------------
    %%Structure: MSOCA
    %%Contact: daleg

    Rule/lexer text range
----------------------------------------------------------------------------*/

typedef struct _MSOCA
    {
    void               *pObject;                        // Object, e.g. doc
    long                cpFirst;                        // First char pos
    long                cpLim;                          // Lim char pos
    } MSOCA;


// Define (D)elta of a (T)o(K)en cache index
typedef int DTK;

// Define (D)elta of a (T)o(K)en cache (I)nterval
typedef int DTKI;


// Token-history cache access
#define PrultkFromIrultk(irultk, prultk) \
            (&prultk[irultk])

// Move to next cache record, wrapping around if necessary
#define IncrPrultk(pprultk, pirultk, prultkHist, irultkMax) \
            if (++(*pirultk) >= (irultkMax)) \
                { \
                (*pirultk) = 0; \
                (*pprultk) = PrultkFromIrultk(0, prultkHist); \
                } \
            else \
                (*pprultk)++;

// Move to next cache record, wrapping around if necessary
#define DecrPrultk(pprultk, pirultk, prultkHist, irultkMax) \
            if (--(*pirultk) < 0) \
                { \
                (*pirultk) += (irultkMax); \
                (*pprultk) += (irultkMax) - 1; \
                } \
            else \
                (*pprultk)--;

// Move index to next cache record, wrapping around if necessary
#define IncrPirultk(pirultk, dirultk, irultkMax) \
            if (((*pirultk) += dirultk) >= (irultkMax)) \
                (*pirultk) -= (irultkMax);

// Move index to prev cache record, wrapping around if necessary
#define DecrPirultk(pirultk, dirultk, irultkMax) \
            if (((*pirultk) -= dirultk) < 0) \
                (*pirultk) += (irultkMax);

MSORULTK *PrultkExpand(                                 // Expand cache
    MSORULTK          **pprultkCache,
    int                *pirultkMax,
    int                 irultkMax,
    int                 irultkSplit
    );

// defines
#define msodtkNotFound      30000                       // arbitrarily lg. flag


MSOEXTERN_C_END     // ****************** End extern "C" *********************

#endif /* EMRULTK_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\evtmon\inc\emruloci.h ===
/*****************************************************************************
    emruloci.h

    Owner: DaleG
    Copyright (c) 1996-1997 Microsoft Corporation

    Header file of Interface of Op-Code Interpreter to Rulebase.

*****************************************************************************/

#ifndef EMRULOCI_H
#define EMRULOCI_H

#include "emoci.h"
#include "emkwd.h"
#include "emrule.h"


MSOEXTERN_C_BEGIN   // ***************** Begin extern "C" ********************


MSOAPI_(MSOOCV) MsoOcvEvalIrul(IRUL irul);              // Eval dyn rule instrs

MSOAPI_(int) MsoFReadDynOciRules(                       // Load oci file
    char               *szFilePrefix,
    int                *pdocii                          // RETURN
    );

MSOAPI_(int) MsoFLoadDynRulesPocii(                     // Load dyn rulebase
    MSOOCII            *pocii,
    int                 docii,
    MSOPFNOCI const    *rgpfn,
    MSOOCAD const      *rgocadArgDesc,
    unsigned char const*rgcbImmedArg,
    int                 ipfnMax,
    char const * const *rgpchDynNames                   // DEBUG ONLY
    );

MSOAPI_(int) MsoFCopyBaseRulRgpfnoci(MSOPFNOCI *rgpfn); // Set 1st n oci fns

MSOAPIX_(MSOOCV *) PocvOfIrul(short irul);              // Return addr of node

MSOAPI_(MSOOCV) MsoOcv_DelayGoToDirul(MSOOCV *pocvSP);  // DelayGoToDirul()

MSOAPI_(MSOOCV) MsoOcv_Signal(MSOOCV *pocvSP);          // Signal a node

MSOAPI_(MSOOCV) MsoOcv_SignalFrom(MSOOCV *pocvSP);      // Signal node from

MSOAPI_(MSOOCV) MsoOcv_RulParams(                       // Set RB params
    MSOOCII           **ppocii,
    MSOOCIS            *pocis
    );

MSOAPI_(MSOOCV) MsoOcv_MapEvalLevels(                   // map static rule lvls
    MSOOCII           **ppocii,
    MSOOCIS            *pocis
    );

MSOAPI_(MSOOCV) MsoOcv_DefEvent(                        // Define an event
    MSOOCII           **ppocii,
    MSOOCIS            *pocis
    );

MSOAPI_(MSOOCV) MsoOcv_DefRule(                         // Define a rule
    MSOOCII           **ppocii,
    MSOOCIS            *pocis
    );

MSOEXTERN_C_END     // ****************** End extern "C" *********************

#endif /* !EMRULOCI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\evtmon\inc\emocii.h ===
/*****************************************************************************
    emocii.h

    Owner: DaleG
    Copyright (c) 1996-1997 Microsoft Corporation

    OpCode Interpreter Instruction definition file

*****************************************************************************/

#ifndef EMOCII_H
#define EMOCII_H

MSOEXTERN_C_BEGIN   // ***************** Begin extern "C" ********************

// Define "Push Immediate" operations
#define ociiImmLong         (-1)                        // Push literal long
#define ociiImmULong        (-2)                        // Push literal ulong
#define ociiImmShort        (-3)                        // Push literal short
#define ociiImmUShort       (-4)                        // Push literal ushort
#define ociiImmChar         (-5)                        // Push literal char
#define ociiImmUChar        (-6)                        // Push literal uchar
#define ociiImmFloat        (-7)                        // Push literal float
#define ociiStackValue      (-8)                        // Push val from stack
#define ociiStackAddr       (-9)                        // Push addr from stack
#define ociiGlobalValue     (-10)                       // Push global value
#define ociiGlobalAddr      (-11)                       // Push addr of global
#define ociiEventValue      (-12)                       // Push event value
#define ociiEventAddr       (-13)                       // Push event address
#define ociiImmSz           (-14)                       // Push ptr to string
#define ociiImmRg           (-15)                       // Push ptr to array

#define ociiRulFirst        55                          // 1st emruloci.h fn

// Define builtin functions
#define ociiDelayGoToDirul  55                          // DelayGoToDirul()
#define ociiSignal          56                          // Signal a node
#define ociiSignalFrom      57                          // Signal node from 2nd
#define ociiRulParams       58                          // Set rulebase params
#define ociiDefEvent        59                          // Define an event
#define ociiDefRule         60                          // Define a rule
#define ociiMapEvalLevels   61                          // Map levels for oci


#define ociiUserFirst       62                          // 1st User-defined fn


// Define function argument "counts" that are not fixed
#define ocadNonEval         (-3)                        // Non-evaluating fn
#define ocadVarArgs         (-4)                        // Var-args function


/* M  S  O  O  C  I  I */
/*----------------------------------------------------------------------------
    %%Type: MSOOCII
    %%Contact: daleg

    Interpreter instruction definition.
----------------------------------------------------------------------------*/

typedef short MSOOCII;                                  // Interp instr

#define MSOOCV long                                     // Interp ret value
//typedef long MSOOCV;                                  // Interp ret value

typedef signed char MSOOCAD;                            // Arg descriptor


// Return whether the instruction pointer refers to a variable
#define FVarLpocii(pocii) \
            (*pocii == ociiEventValue)


// Define data types: these must have same order as access functions below
typedef enum
    {
    ocdtChar    =   0,  //  0
    ocdtUChar,          //  1
    ocdtShort,          //  2
    ocdtUShort,         //  3
    ocdtInt,            //  4
    ocdtUInt,           //  5
    ocdtLong,           //  6
    ocdtULong,          //  7
    ocdtFloat,          //  8
    ocdtDouble,         //  9
    ocdtLDouble,        //  10
    ocdtPointer,        //  11
    ocdtVoid,           //  12
    ocdtVarArg          //  13              (Take anything)
    } OCDT;


/*----------------------------------------------------------------------------
    Interpreter op-code value for functions.
    This must be maintained in the order that the functions will appear
    in the op-code v-table.
----------------------------------------------------------------------------*/

typedef enum
    {
    ipfnOcv_log_and = 0,                    //  0
    ipfnOcv_log_or,                         //  1
    ipfnOcv_log_not,                        //  2
    ipfnOcv_less_than,                      //  3
    ipfnOcv_less_eql,                       //  4
    ipfnOcv_eql,                            //  5
    ipfnOcv_gtr_eql,                        //  6
    ipfnOcv_gtr_than,                       //  7
    ipfnOcv_not_eql,                        //  8
    ipfnOcv_assign,                         //  9
    ipfnOcv_plus,                           //  10
    ipfnOcv_minus,                          //  11
    ipfnOcv_mult,                           //  12
    ipfnOcv_divide,                         //  13
    ipfnOcv_mod,                            //  14
    ipfnOcv_increment,                      //  15
    ipfnOcv_decrement,                      //  16
    ipfnOcv_unary_plus,                     //  17
    ipfnOcv_unary_minus,                    //  18
    ipfnOcv_bitwise_not,                    //  19
    ipfnOcv_bitwise_and,                    //  20
    ipfnOcv_bitwise_or,                     //  21
    ipfnOcv_bitwise_xor,                    //  22
    ipfnOcv_shift_l,                        //  23
    ipfnOcv_shift_r,                        //  24
    ipfnOcv_dereference,                    //  25
    ipfnOcv_addr_of,                        //  26
    ipfnOcv_cast_as,                        //  27
    ipfnOcv_if,                             //  28
    ipfnOcv_inline_if,                      //  29
    ipfnOcv_let,                            //  30
    ipfnOcv_progn,                          //  31
    ipfnOcv_compound_stmt,                  //  32
    ipfnOcv_get_char,                       //  33
    ipfnOcv_get_uchar,                      //  34
    ipfnOcv_get_short,                      //  35
    ipfnOcv_get_ushort,                     //  36
    ipfnOcv_get_int,                        //  37
    ipfnOcv_get_uint,                       //  38
    ipfnOcv_get_long,                       //  39
    ipfnOcv_get_ulong,                      //  40
    ipfnOcv_get_float,                      //  41
    ipfnOcv_get_double,                     //  42
    ipfnOcv_get_ldouble,                    //  43
    ipfnOcv_set_char,                       //  44
    ipfnOcv_set_uchar,                      //  45
    ipfnOcv_set_short,                      //  46
    ipfnOcv_set_ushort,                     //  47
    ipfnOcv_set_int,                        //  48
    ipfnOcv_set_uint,                       //  49
    ipfnOcv_set_long,                       //  50
    ipfnOcv_set_ulong,                      //  51
    ipfnOcv_set_float,                      //  52
    ipfnOcv_set_double,                     //  53
    ipfnOcv_set_ldouble,                    //  54
    } OCIT;

#define ipfnOcvGetTypeFirst         ipfnOcv_get_char
#define ipfnOcvSetTypeFirst         ipfnOcv_set_char

MSOEXTERN_C_END     // ****************** End extern "C" *********************

#endif /* !EMOCII_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\evtmon\inc\genem.c ===
/*----------------------------------------------------------------------------
    %%File: EMTEST.C
    %%Unit: Event Monitor (mntr)
    %%Contact: daleg

    Event Monitor Sample Application, Main Program.

    The purpose of this application is to demonstrate how to process events
    using the Event Monitor's Rule Compiler and rule engine.
----------------------------------------------------------------------------*/

//***   genem.c -- 'generic' evtmon client-side stuff
// DESCRIPTION
//  the client-side of an evtmon app has two parts:
//      - evtmon generic code (client-side)
//      - application-specific rules
//  this file is reusable (and semi-frozen) generic code.  it should be
//  #include'ed from the app.
// NOTES
//  WARNING: do *not* put app-specific code here.  put it in the
//  client (emclient/libem.c).  in fact in general, think twice before
//  modifying this file at all.

//***   YY_* -- generic rules support
//
#define YY_BASE     1   // base features (always needed)
#ifdef YY_BASE
// rulc.exe doesn't create all files if a given feature isn't used,
// so we can't unconditionally include these guys.  plus, we don't
// want the helper code if we don't need it.
// turn on these features here if you use them
#ifndef YY_DELAYED
#define YY_DELAYED  0   // delayed actions
#endif
#ifndef YY_CTOR
#define YY_CTOR     0   // action ctors
#endif
#ifndef YY_SEQCHECK
#define YY_SEQCHECK 0   // seq_check
#endif
#define YY_OTHER    0
//#define YY_BRKPT()
#endif

//***   FEATURE_* -- domain-specific rules support
// NOTES

#define FEATURE_DEMO    0   // demo code (e.g. wndproc test app)
#define FEATURE_SAMPLE  0   // sample code (e.g. joe-event firer)
#define FEATURE_OFFICE  0   // base office stuff
#define FEATURE_TEXT    0   // text parser
#define FEATURE_WORD    0   // format parser
#define FEATURE_DEAD    0   // unused/dead code
#define FEATURE_NYI     0

#include "mso.h"
#include "msoem.h"

DEBUGASSERTSZ


#include "msolex.h"
#include "emrule.h"
#include "emkwd.h"
#include "emact.h"

#if FEATURE_DEMO
#include "emtest.h"
#include "emres.h"
#endif

// { Files generated by Rule Compiler
#include "emdef.h"          // rules (#defines)
#if YY_CTOR // {
#include "emacts.h"         // ctor macro wrappers
#endif // }
#define DEBUG_RULE_POINTERS // Want ptrs to nodes
#include "emruli.h"         // rulebase
#if YY_SEQCHECK // seq_check
#include "emsqck.c_"        // sequences
#endif
// }


#if FEATURE_TEXT // {
// Constants
#define cbEditText  1024

#ifdef STATIC_INIT

#define grfLexFlagsEm    (MsoGrfLexFNoReset \
                        | MsoGrfLexFLookup \
                        | MsoGrfLexFLookupIntsAndSyms \
                        | MsoGrfLexFAllCapsAsFormat)

// EM data structures
MSORULTK rgrultkEmToken[200];                           // Text Token cache
MSORULTK rgrultkEmFormat[100];                          // Format Token cache
MSOLEXS vlexs =
    {
    &vkwtbEmTOKEN_KEYTABLE,                             // pkwtb
    {rgrultkEmToken, 200, },                            // rultkhToken
    {rgrultkEmFormat, 100, },                           // rultkhFormat
    fTrue,                                              // fInited
    isttblDefault,                                      // isttbl
    grfLexFlagsEm,                                      // grpfLexFlags
    _hObjectNil,                                        // hObjectNil
    MsoWchLexGetNextBufferDoc,                          // pfnlexbuf
    FGetNextLexRun,                                     // pfnlexrun
    FGetTokenTextObject,                                // pfnlextxt
    NULL,                                               // pfnlexfmt
    NULL,                                               // pfnlexrunDiscontig
    NULL,                                               // pfnlexrunForceCompl
    iNil,                                               // ichRun
    -1,                                                 // cchLookahead
    };
MSOLEXS *vplexs = &vlexs;                               // Global lexer state

#else /* !STATIC_INIT */

MSOLEXS     vlexs;                                      // Global lexer state
MSOLEXS    *vplexs;                                     // Global lexer state

#endif /* STATIC_INIT */
#endif // }

#if YY_BASE // {
// Global variables
RULS       *vlpruls = &vrulsEm;
#ifndef STATIC_LINK_EM
RULS      **_pvlprulsDLL = &vlpruls;                    // App's Global state
#endif /* !STATIC_LINK_EM */
#endif // }

#if FEATURE_DEMO // {
char        vszAppName[20];                             // Application name
HWND        vhInst;                                     // Instance
HWND        vhWndMain;                                  // Main window
HWND        vhWndDlg;                                   // Dialog window
char        vszEditText[cbEditText];                    // Text of edit control
int         vcchEditText;                               // #chs in edit control
static int  vcchPrev = 0;                               // Prev edit box len
static int  vcpIpPrev = 0;                              // Prev edit box ip
int         vfSettingDlgItem = fFalse;                  // Avoid Win recursion
#endif // }

#if YY_BASE // {
#if YY_DELAYED
#include "emactr.h"         // data tables
MSOACTTBL   vacttbl = {vrgacttrecEm};                   // Global action table
MSOACTTBL  *_pacttbl = &vacttbl;                        // Glob action tbl ptr
#endif
#endif // }

#if FEATURE_OFFICE // {
EMS         vems;                                       // EM global state
EMS        *vpems = &vems;                              // Ptr to global state
#endif // }

#if YY_BASE // {
#ifdef DEBUG
#ifndef STATIC_LINK_EM
int vwDebugLogFilter = fDebugFilterAll;
int vwDebugLogLvl = -2;
#endif // !STATIC_LINK_EM
// Pointers to global debug logging vars in Mso DLL
int *pvwDebugLogFilter = &vwDebugLogFilter;
int *pvwDebugLogLvl = &vwDebugLogLvl;
#endif /* DEBUG */
#endif // }


#if YY_BASE // {
#ifdef STATIC_INIT // {
/* F  I N I T  E M */
/*----------------------------------------------------------------------------
    %%Function: FInitEm
    %%Contact: daleg

    Initialize the static (compiled) Event Monitor rules.
----------------------------------------------------------------------------*/

int FInitEm(void)
{
#ifndef STATIC_LINK_EM
    /* Mirror global debug pointers in Mso97.dll */
    Debug(pvwDebugLogLvl = MsoPwDebugLogLvl(&pvwDebugLogFilter);)
#endif /* !STATIC_LINK_EM */
    Debug(*pvwDebugLogLvl = 7);

#ifndef STATIC_LINK_EM
    /* Mirror global pointers (vlpruls, etc) in Mso97.dll */
    _pvlprulsDLL = MsoPvlprulsMirror(&vlpruls);
    *_pvlprulsDLL = &vrulsEm;
#endif /* !STATIC_LINK_EM */

#ifdef DYN_RULES
    /* Load dynamic rules */
    FLoadDynEmRules();
#endif /* DYN_RULES */

#if FEATURE_OFFICE
    /* For performance reasons, action table is global */
    vacttbl.prultkh = &vplexs->rultkhToken;
#endif

#if FEATURE_DEMO
    /* Allow Event Drivers to run */
    EnableEM();
#endif

    /* Propagate the values through the rule network */
    MsoScheduleIrul(irul_YYSTD_INIT, fTrue);
#ifdef DYN_RULES
    MsoScheduleIrul(irul_YYSTD_LOADING_RULEBASE, fTrue);
#endif /* DYN_RULES */
    MsoEvaluateEvents(rulevtEm_YYSTD);

    return fTrue;
}
#else /* }{ !STATIC_INIT */
/* F  I N I T  E M */
/*----------------------------------------------------------------------------
    %%Function: FInitEm
    %%Contact: daleg

    Initialize the static (compiled) Event Monitor rules.
----------------------------------------------------------------------------*/

int FInitEm(void)
{
#ifndef STATIC_LINK_EM
    /* Mirror global debug pointers in Mso97.dll */
    Debug(pvwDebugLogLvl = MsoPwDebugLogLvl(&pvwDebugLogFilter);)
#endif /* !STATIC_LINK_EM */
    Debug(*pvwDebugLogLvl = 7);

    /* Initialize rule base, for performance reasons, rulebase is global */
    if (!MsoFInitStaticRuls(&vrulsEm, &vrulsEm))
        return fFalse;

#ifndef STATIC_LINK_EM
    /* Mirror global pointers (vlpruls, etc) in Mso97.dll */
    _pvlprulsDLL = MsoPvlprulsMirror(&vlpruls);
    *_pvlprulsDLL = &vrulsEm;
#endif /* !STATIC_LINK_EM */

#ifdef DYN_RULES
    /* Load dynamic rules */
    FLoadDynEmRules();
#endif /* DYN_RULES */

#if FEATURE_OFFICE
    /* Initialize the lexer to scan the doc */
    if (!(vplexs = MsoPlexsLexInitDoc
                        (&vlexs, _hObjectNil, FGetNextLexRun,
                        FGetTokenTextObject, NULL, NULL, 200, 100)))
        return fFalse;
    vplexs->pkwtb = &vkwtbEmTOKEN_KEYTABLE;

    /* For performance reasons, action table is global */
    vacttbl.prultkh = &vplexs->rultkhToken;
#endif

#if FEATURE_DEMO
    /* Allow Event Drivers to run */
    EnableEM();
#endif

    /* Propagate the values through the rule network */
    MsoScheduleIrul(irul_YYSTD_INIT, fTrue);
#ifdef DYN_RULES
    MsoScheduleIrul(irul_YYSTD_LOADING_RULEBASE, fTrue);
#endif /* DYN_RULES */
    MsoEvaluateEvents(rulevtEm_YYSTD);

    return fTrue;
}
#endif /* } STATIC_INIT */
#endif // }


#if YY_BASE // {
/* F  E V A L  E M  R U L E */
/*----------------------------------------------------------------------------
    %%Function: FEvalEmRule
    %%Contact: daleg

    Evaluate the rule associated with the given rule ID number.
    Return a boolean value for whether its value was TRUE or FALSE.
----------------------------------------------------------------------------*/

#include "emeval.c"
#endif // }




#if FEATURE_DEMO // {
/* W I N  M A I N */
/*----------------------------------------------------------------------------
    %%Function: WinMain
    %%Contact: daleg

    Main routine.
----------------------------------------------------------------------------*/

int CALLBACK WinMain(
    HANDLE              hInstance,
    HANDLE              hPrevInstance,
    LPSTR               lpszCmdLine,
    int                 nCmdShow
    )
{
    MSG                 msg;
    int                 nRc;
    char                szString[256];

    GdiSetBatchLimit(1);
    strcpy(vszAppName, "EMTEST");
    vhInst = hInstance;

    if (!hPrevInstance)
        {
        /* Register window classes if first instance of application */
        if ((nRc = nCwRegisterClasses()) == -1)
            {
            /* Put up msg if registering one of the windows failed */
            LoadString(vhInst, IDS_ERR_REGISTER_CLASS, szString,
                       sizeof(szString));
            MessageBox(NULL, szString, NULL, MB_ICONEXCLAMATION);
            return nRc;
            }
        }

    /* Create application's Main window */
    vhWndMain = CreateWindow(vszAppName,
                             NULL,
                             WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX
                                | WS_MAXIMIZEBOX | WS_THICKFRAME
                                | WS_CLIPCHILDREN | WS_OVERLAPPED,
                             0, 0, 400, 400,
                             NULL, NULL, vhInst, NULL);

    /* If could not create main window, be nice before quitting */
    if (vhWndMain == NULL)
        {
        LoadString(vhInst, IDS_ERR_CREATE_WINDOW, szString, sizeof(szString));
        MessageBox(NULL, szString, NULL, MB_ICONEXCLAMATION);
        return IDS_ERR_CREATE_WINDOW;
        }

    /* Initialize the rulebase */
    if (!FInitEm())
        return 1;

    /* Display main window */
    ShowWindow(vhWndMain, nCmdShow);

    /* Until WM_QUIT message */
    while (GetMessage(&msg, NULL, 0, 0))
        {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
        }

    /* Do clean up before exiting from the application */
    CwUnRegisterClasses();

    return msg.wParam;
}


/* W N D  P R O C */
/*----------------------------------------------------------------------------
    %%Function: WndProc
    %%Contact: daleg

    Windows proc for main window.
----------------------------------------------------------------------------*/

LONG CALLBACK WndProc(
    HWND                hWnd,
    UINT                Message,
    WPARAM              wParam,
    LPARAM              lParam
    )
{
    HMENU               hMenu = 0;
    int                 nRc = 0;

    switch (Message)
        {
    case WM_COMMAND:
        FEmEvalDialog(wParam);

        switch (LOWORD(wParam))
            {
        case IDM_DIALOG:
            /* Respond to the menu item named "Dialog" */
            {
            FARPROC     lpfnDIALOGSMsgProc;

            lpfnDIALOGSMsgProc = MakeProcInstance((FARPROC) DIALOGSMsgProc,
                                                  vhInst);
            nRc = DialogBox(vhInst, MAKEINTRESOURCE(IDM_DIALOG), hWnd,
                            lpfnDIALOGSMsgProc);
            FreeProcInstance(lpfnDIALOGSMsgProc);
            }
            break;

        default:
            return DefWindowProc(hWnd, Message, wParam, lParam);
            }
        break;

    case WM_CLOSE:
        /* Destroy child windows, modeless dialogs, then, this window */
        DestroyWindow(hWnd);

        /* Quit the application */
        if (hWnd == vhWndMain)
            PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hWnd, Message, wParam, lParam);
        }
    return 0L;
}


/* D  I  A  L  O  G  S  M S G  P R O C */
/*----------------------------------------------------------------------------
    %%Function: DIALOGSMsgProc
    %%Contact: daleg

    Dialog proc for inner window.
----------------------------------------------------------------------------*/

BOOL CALLBACK DIALOGSMsgProc(
    HWND                hWndDlg,
    UINT                Message,
    WPARAM              wParam,
    LPARAM              lParam
    )
{
    switch (Message)
        {
    case WM_INITDIALOG:
        cwCenter(hWndDlg, 0);
        vcchPrev = 0;
        vcpIpPrev = 0;
        vhWndDlg = hWndDlg;
        break;

    case WM_CLOSE:
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
            {
        case IDC_EDIT1:
            switch (HIWORD(wParam))
                {
            case EN_CHANGE:
                vcchEditText = GetDlgItemText(hWndDlg, IDC_EDIT1, vszEditText,
                                              cbEditText);
                if (!vfSettingDlgItem)
                    {
                    MSOCP   cpIp;
                    XCHAR   wch;

                    /* Get IP (Insertion Point) position */
                    SendDlgItemMessage(hWndDlg, IDC_EDIT1, EM_GETSEL, 0,
                                       (LPARAM)&cpIp);

                    /* Get character typed */
                    wch = (vcchEditText > vcchPrev
                            ? vszEditText[cpIp - 1]     // Char typed
                            : xchBackspace);            // Backspace

                    /* Notify Event Monitor CHAR driver */
                    FEmEvalChar(wch, cpIp, vszEditText, vcchEditText);

                    /* Track prev text positions for invalidation detect */
                    vcchPrev = vcchEditText;
                    vcpIpPrev = cpIp;
                    }
                break;
                }
            break;
        case IDC_BUTTON1:
        case IDC_BUTTON2:
        case IDC_START:
        case IDC_STOP:
        default:
            FEmEvalDialog(wParam);
            break;
        case IDOK:
            FEmEvalDialog(wParam);
            EndDialog(hWndDlg, FALSE);
            break;
            }
        break;

    default:
        return FALSE;
        }
    return TRUE;
}
#endif // }


#if FEATURE_SAMPLE // { joe event firer
/* F  E M  E V A L  D I A L O G */
/*----------------------------------------------------------------------------
    %%Function: FEmEvalDialog
    %%Contact: daleg

    Event Monitor Event Driver for DIALOG events.
----------------------------------------------------------------------------*/

int FEmEvalDialog(WPARAM wParam)
{
    short               idc = LOWORD(wParam);
    IRUL                irul;

#if FEATURE_DEMO
    /* Make sure we are enabled (e.g. macros not running) */
    if (FEmDisabled())
        return fFalse;
#endif

    /* Match the (sparse) dialog object to its associated (contig) event, if any */
    vlpruls->irulPrimaryEvent = irul
        = (IRUL) MsoPkwdlhLookupL(idc, &vkwtbEmIDC_KEYTABLE)->tk;

    debugEM1(2, "DIALOG EVENT: %-20.20s\n",
             LpchRulName(LprulFromIrul(irul)));

    /* Push event into appropriate queue (resets depth) */
    MsoScheduleIrul(irul, fTrue);
    MsoScheduleIrul(irulIDC_, idc);     // non-mapped event (autoclear global)

    /* Propagate the values through the rule network */
    MsoEvaluateEvents(rulevtEmDIALOG);
    // n.b. IDC_ is now autocleared

    /* Evaluate any pending actions */
    if (_pacttbl->pactPending)
        DoPendingActions();
}

/* F  E M  E V A L  C H A R */
/*----------------------------------------------------------------------------
    %%Function: FEmEvalChar
    %%Contact: daleg

    Event Driver for CHAR events in Event Monitor.
    Evaluate CHAR (KEYBOARD) events within the Event Monitor rulebase.
    Return whether or not it was handled.
----------------------------------------------------------------------------*/

int FEmEvalChar(
    XCHAR               wch,
    MSOCP               cpIp,
    XCHAR              *wz,
    int                 ichMac
    )
{
    IRUL                irul;

#if FEATURE_DEMO
    /* Make sure we are enabled (e.g. macros not running) */
    if (FEmDisabled())
        return fFalse;
#endif

    /* Primitive invalidation */
    if (FCheckIfMustReset(wch, ichMac, cpIp))
        InvalLex(vplexs);

    /* If our running state is still valid, adjust run variables */
    if (FInvalLex(vplexs))
        FResetEm((vplexs->cpIp = cpIp) - 1, wz, ichMac);

    /* Create a "lookahead" token to hold chars not yet scanned by lexer */
    vplexs->cchLookahead++;
    _CacheTkTextNext(vplexs);

    /* Look up character in keyword table */
    irul = (IRUL) MsoPkwdLookupName(&wch, 1, &vkwtbEmCHAR_KEYTABLE)->tk;

    debugEM3(2, "CHAR EVENT: %-20.20s for '%s' (0x%x)\n",
             LpchRulName(LprulFromIrul(irul)),
             MsoSzFromRgxchDebug(&wch, 1), wch);

    /* Push text token into appropriate queue (resets depth) */
    MsoScheduleIrul(irulCH_, wch);
    MsoScheduleIrul(vlpruls->irulPrimaryEvent = irul, fTrue);

    /* Propagate the values through the rule network */
    MsoEvaluateEvents(rulevtEmCHAR);

    /* Call TOKEN event driver to process any token events */
    FEmEvalToken(cpIp, wz, ichMac);
}

/* E M  E V A L  T K  I R U L */
/*----------------------------------------------------------------------------
    %%Function: EmEvalTkIrul
    %%Contact: daleg

    Evaluate a TOKEN event irul.
----------------------------------------------------------------------------*/

void EmEvalTkIrul(IRUL irul)
{
    MSORULTK           *prultk;

    debugEM2(2, "TOKEN EVENT: %-20.20s \"%.100s\"\n",
             LpchIrulName(irul), MsoSzLexTokenText(vplexs));

    /* Push pending token events into appropriate queues */
    prultk = PrultkFromTokenIrultk(vplexs, vplexs->rultkhToken.irultkMin);
    while (vplexs->rultkhToken.irultkMin != vplexs->rultkhToken.irultkLim)
        {
#ifdef DEBUG
        if (prultk->tk != irul)
            {
            debugEM2(4, "EXTRA TOKEN EVENT: %-20.20s %d\n",
                     LpchIrulName(prultk->tk), prultk->lValue);
            debugEM1(8, "  at CP %ld\n", prultk->cpFirst);
            }
#endif /* DEBUG */

        /* Push text token into appropriate queue (resets depth) */
        MsoSignalEventIrul(IrulFromTk(prultk->tk), prultk->lValue);

        /* Move to next cache record, wrapping around if necessary */
        IncrTokenPrultk(vplexs, &prultk, &vplexs->rultkhToken.irultkMin);
        }

    /* Push any applicable format tokens into appropriate queues */
    if (vplexs->rultkhFormat.irultkMin != vplexs->rultkhFormat.irultkLim)
        PushIrultkFormatPending();

    /* Push text token into appropriate queue (resets depth) */
    MsoScheduleIrul(irulTOKEN_, vlpruls->irulPrimaryEvent = irul);

    /* Propagate the values through the rule network */
    MsoEvaluateEvents(rulevtEmTOKEN);
}
#endif // }


#if FEATURE_SAMPLE // {
/* F  E M  E V A L  T O K E N */
/*----------------------------------------------------------------------------
    %%Function: FEmEvalToken
    %%Contact: daleg

    Event Monitor Event Driver for TOKEN events.
----------------------------------------------------------------------------*/

int FEmEvalToken(
    MSOCP               cpIp,
    XCHAR              *wz,
    int                 ichMac
    )
{
    IRUL                irul;

#if FEATURE_DEMO
    /* Make sure we are enabled (e.g. macros not running) */
    if (FEmDisabled())
        return fFalse;
#endif

    /* If our running state is still valid, adjust run variables */
    if (!FInvalLex(vplexs))
        {
        long            dwz = wz - vplexs->pxchBuffer;

        vplexs->pxchTkStart += dwz;
        vplexs->pxchNext += dwz;
        vplexs->pxchRun += dwz;
        vplexs->pxchBuffer += dwz;
        vplexs->cpIp = cpIp;
        vplexs->cpLim = ichMac;
        vplexs->cchRemain = vplexs->pxchBuffer + vplexs->cpLim
                - vplexs->pxchNext;
        }

    /* Else rescan back up to IP */
    else if (!FResetEm((vplexs->cpIp = cpIp) - 1, wz, ichMac))
        return fFalse;

    /* Inject and eval any complete tokens up to IP */
    while (FValidIrul(irul = IrulFromTk(MsoTkLexTextCpLim(vplexs, cpIp))))
        EmEvalTkIrul(irul);

    /* Evaluate any pending actions */
    if (_pacttbl->pactPending)
        DoPendingActions();

    /* All typed characters must now have been seen by the lexer */
    if (vplexs->cchLookahead > 0)
        vplexs->cchLookahead = 0;
}
#endif // }


#if FEATURE_TEXT // {
/* P U S H  I R U L T K  F O R M A T  P E N D I N G */
/*----------------------------------------------------------------------------
    %%Function: PushIrultkFormatPending
    %%Contact: daleg

    Push any pending format tokens into appropriate queues.
----------------------------------------------------------------------------*/

void PushIrultkFormatPending(void)
{
    MSORULTK           *prultk;

    debugEM1(8, "Checking for formatting before CP %ld\n",
             CpLexTokenFirst(vplexs));

    prultk = PrultkFormatFromIrultk(vplexs, vplexs->rultkhFormat.irultkMin);

    while (vplexs->rultkhFormat.irultkMin != vplexs->rultkhFormat.irultkLim
            &&  (prultk->cpFirst
                        < CpLexTokenFirst(vplexs) + DcpLexToken(vplexs)
                 ||  (DcpLexToken(vplexs) == 0
                        &&  prultk->cpFirst <= CpLexTokenFirst(vplexs))))
        {
        debugEM2(2, "FORMAT   : %-20.20s %ld\n",
                 LpchIrulName(prultk->tk), prultk->lValue);
        debugEM1(6, "  at CP %ld\n", prultk->cpFirst);

        /* Push format token into appropriate queue (resets depth) */
        MsoSignalEventIrul(IrulFromTk(prultk->tk), prultk->lValue);

        /* Move to next cache record, wrapping around if necessary */
        IncrFormatPrultk(vplexs, &prultk, &vplexs->rultkhFormat.irultkMin);
        }
}
#endif // }



#if FEATURE_TEXT // {
/* F  R E S E T  E M */
/*----------------------------------------------------------------------------
    %%Function: FResetEm
    %%Contact: daleg

    Reset the Event Monitor rules and lexer due to an IP (cursor) change,
    or due to some form of invalidation.
----------------------------------------------------------------------------*/

int FResetEm(
    MSOCP               cpIp,
    XCHAR              *wz,
    int                 ichMac
    )
{
    MSOCP               cpObject = 0;
    IRUL                irul;

    /* Initialize lexer to point to start of buffer */
    vplexs->pObjectIp = PObjectCur();
    vplexs->pxchBuffer = vplexs->pxchBufferIp = vplexs->pxchRun = wz;
    MsoLexSetPos(vplexs, cpObject, 0);

    debugEM0(0, "====================================================\n");
    debugEM3(0, "   FResetEm: RESETTING: pObjectIp %x cpLine %ld cp %ld\n",
             vplexs->pObjectIp, cpObject, cpIp);
    debugEM0(0, "====================================================\n");

    /* Reset rule base TOKEN state variables */
    MsoClearEventsForRulevts(rulevtEmTOKEN, drulevtToken,
                             (vpems->fInternalReset
                                ? rultPersistentRule | rultAlwaysPersist
                                : rultAlwaysPersist),
                             fTrue, fFalse);

    vplexs->wInterval = CIntervalsRulevt(rulevtEmTOKEN);

    /* Reset lexer base state */
    MsoResetLexState(vplexs, fTrue/*fFullReset*/);
    vplexs->cpLim = 0;
    vplexs->fInvalLexer = fFalse;

    /* Mark start of scan */
    MsoCacheTkText(vplexs, irulSTART, fTrue);
    MsoScheduleIrul(irulSTART, fTrue);

    /* Mark start of token cache, but not as events */
    MsoCacheTkText(vplexs, irulEND_OBJ, fTrue);
    vplexs->rultkhToken.irultkMin = vplexs->rultkhToken.irultkLim;

    /* Run only rules not marked as INTERACTIVE_ONLY */
    SetCurrRulg(rulgEmALWAYS);

    /* Inject and eval any complete tokens up to IP */
    while (FValidIrul(irul = IrulFromTk(MsoTkLexTextCpLim(vplexs, cpIp))))
        EmEvalTkIrul(irul);

    /* Run only rules not marked as INTERACTIVE_ONLY */
    SetCurrRulg(rulgEmINTERACTIVE_ONLY);

    /* Mark that we are synchronized */
    vplexs->cchLookahead = 0;

    return fTrue;
}


/* F  G E T  T O K E N  T E X T  O B J E C T */
/*----------------------------------------------------------------------------
    FGetTokenTextObject
    %%Contact: smueller

    Determine whether the text of the requested token needs to be fetched
    from the document.  If so, do so, leaving the results in ppxch and pcch,
    and return fTrue.  Otherwise, return fFalse.
----------------------------------------------------------------------------*/

int WIN_CALLBACK FGetTokenTextObject(
    MSORULTK           *prultk,
    const XCHAR       **ppxch,                          // RETURN
    int                *pcch,                           // RETURN
    struct _MSOLEXS    *plexs
    )
{
    if (plexs->pObject != NULL)
        {
        // NOT SUPPORTED YET
        return fTrue;
        }

    return fFalse;
}


/* F  G E T  N E X T  L E X  R U N */
/*----------------------------------------------------------------------------
    %%Function: FGetNextLexRun
    %%Contact: daleg

    Return next run of text within the current object , and set the lexer
    run-state variables.

    For this demo, there ain't any, but we will show a commented-out sample.
----------------------------------------------------------------------------*/

int WIN_CALLBACK FGetNextLexRun(MSOCP cpLim, MSOLEXS *plexs)
{
    int                 fStatus = fTrue;
    const XCHAR        *pxchPrevEnd = plexs->pxchNext;

    /* If prev run at end of current object, move to next object */
    if (FLexEndOfScan(vplexs))
        {
        /* If still have a pending token, complete it first */
        if (DcpLexCurr(vplexs) > 0)
            return fFalse;

        /* Create exactly one inter-object "created" tkEND_OBJ character */
        if (plexs->fCreateEndObjCh)
            {
            /* Make this run "created" text, i.e. no dcp */
            fStatus = fFalse;
            plexs->cpRun += plexs->ccpRun;
            plexs->ichRun += plexs->cchRun;
            plexs->cchRun = 1;
            plexs->ccpRun = 0;

#ifdef READY
            /* Mark run as "created", so dcp calcs will work properly */
            plexs->fAdjustTokenCps = fTrue;
            plexs->dcpCreated += 1;
            if (plexs->cpFirstCreated == 0L)
                plexs->cpFirstCreated = plexs->cpRun;
#endif /* READY */
            }

        /* Else get next object's text */
        else
            {
            if (!FGetNextLexObject(cpLim, plexs))
                return fFalse;

            /* If in object of IP has passed upper lim of scan, block lexer */
            if (plexs->pObject == plexs->pObjectIp  &&  cpLim != msocpMax
                    &&  cpLim <= 0 /* plexs->cpRun */)
                fStatus = fFalse;
            }
        }

    /* Else move to next run */
    else
        {
        plexs->cpRun += plexs->ccpRun;
        plexs->ichRun += plexs->cchRun;

#ifdef PORT_THIS
        plexs->cchRun = vcchEditText - plexs->ichRun;
#endif /* PORT_THIS */
        plexs->ccpRun = plexs->cchRun;

        // Reset buffer pointer if run in a different buffer
#ifdef PORT_THIS
        plexs->pxchBuffer = vszEditText;
#endif /* PORT_THIS */
        }

    /* Set Run length and pointer */
    plexs->cchRemain = plexs->cchRun;
    plexs->pxchNext = (plexs->pxchRun = plexs->pxchBuffer + plexs->ichRun);

    AssertSz0(pxchPrevEnd == plexs->pxchNext
                ||  pxchPrevEnd == plexs->pxchTkStart,
              "Discontiguous runs!");

    /* If run starts new text (line), reset non-cached tk start pointer */
    if (pxchPrevEnd == plexs->pxchTkStart)
        plexs->pxchTkStart = plexs->pxchNext;

    return fStatus;
}


/* F  G E T  N E X T  L E X  O B J E C T */
/*----------------------------------------------------------------------------
    %%Function: FGetNextLexObject
    %%Contact: daleg

    Set the "run" state variables to the first run of a new object, including
    the text buffer, and the run lengths.
----------------------------------------------------------------------------*/

int WIN_CALLBACK FGetNextLexObject(MSOCP cpLim, MSOLEXS *plexs)
{
    // If this is the first time thru, do initialization stuff
    if (plexs->ichRun == iNil)
        {
        // YOUR INITS HERE
        }

    // Fetch new object text
    plexs->pObject = PObjectCur();

    // Fetch new text (in our case, it is globally static)
    plexs->pxchBuffer = vszEditText;
    plexs->cchRun = plexs->cpLim = vcchEditText;
    plexs->pxchRun = plexs->pxchBuffer;

    // Set up other state variables
    plexs->ichRun = 0;
    plexs->cpRun = 0;
    plexs->cpObject = 0;
    plexs->ccpRun = plexs->cchRun;
    SetCpLexTokenFirst(vplexs, SetCpLexTokenNext(vplexs, 0));

    return fTrue;
}


/* F  L E X  F O R C E  C O M P L E T E */
/*----------------------------------------------------------------------------
    %%Function: FLexForceComplete
    %%Contact: daleg

    Force the current token to complete within the lexer.  This is a callback
    function that gets called when we wish to cause the lexer to finish a
    token without peeking at the next character.  This is generally when we
    are moving the IP out of a cell in a table, and wish to perform automatic
    actions anyway.

    Once we have completed the token, we clear the callback flag, to resume
    normal operation.

----------------------------------------------------------------------------*/

int WIN_CALLBACK FLexForceComplete(MSOCP cpLim, MSOLEXS *plexs)
{
    XCHAR               wch;

    /* If in the middle of a token complete it if next is EOO or delim */
    // REVIEW daleg: This should check for more than just spaces after
    if (plexs->iuState > 0
            &&  (cpLim == vplexs->cpLim
                    ||  (wch = *vplexs->pxchNext) == xchSpace))
        return fTrue;

    /* Do not call this routine next time */
    plexs->pfnlexrunForceComplete = NULL;

    /* Force an END_OBJ token (event) if we are at the cell boundary */
    return (cpLim == vplexs->cpLim);
}

#endif // }


#if YY_BASE // {

/* P A C T  P C A */
/*----------------------------------------------------------------------------
    %%Function: PactPca
    %%Contact: daleg

    Create a Delayed-Action record, using a MSOCA to define the edit range.
----------------------------------------------------------------------------*/

MSOACT *PactPca(
    MSOACTTBL          *pacttbl,
    int                 actt,
    MSOCA              *pca,
    ...
    )
{
    va_list             ap;
    MSOACT             *pact;

    /* Safety first: make sure we have an action structure */
    if (!pacttbl)
        return NULL;

    /* Start varargs */
    va_start(ap, pca);

    /* Create a new Delayed Action record, and push arg list into it */
    pact = MsoPactAp(pacttbl, actt,
                     (sizeof(MSOCA) + sizeof(long) - 1)/sizeof(long), ap);

    /* End varargs */
    va_end(ap);

    /* Calculate starting CP */
    pact->rec1_ca.ca = *pca;

    /* Insert the MSOACT record into the edit queue in CP sorted order */
    MsoInsertPact(pact, &pacttbl->pactPending);

    return pact;
}


#if YY_DELAYED // {
long WIN_CALLBACK DcpDoAct(
    MSOACT             *pact,
    MSOACTTBL          *pacttbl,
    long               *pdcp,
    MSOCA              *pca,
    MSOACT           **ppactNext,
    int                *pfDiscard
    );

/* D O  P E N D I N G  A C T I O N S */
/*----------------------------------------------------------------------------
    %%Function: DoPendingActions
    %%Contact: daleg

    Execute pending actions in delay action queue.
----------------------------------------------------------------------------*/

void DoPendingActions(void)
{
    _pacttbl->cpFirstEditPrev = -1;
    _pacttbl->dcpEditPrev = 0;
    _pacttbl->cpLimEdit = 0;
    MsoReversePact(&_pacttbl->pactPending);
    MsoDcpDoActs(&_pacttbl->pactPending, _pacttbl, 0, fTrue, -1, DcpDoAct);
}


/* D C P  D O  A C T */
/*----------------------------------------------------------------------------
    %%Function: DcpDoAct
    %%Contact: daleg

    Execute the action given by the MSOACT record.
----------------------------------------------------------------------------*/

long WIN_CALLBACK DcpDoAct(
    MSOACT             *pact,
    MSOACTTBL          *pacttbl,
    long               *pdcp,
    MSOCA              *pca,
    MSOACT           **ppactNext,
    int                *pfDiscard
    )
{
    switch (pact->rec1.actt)
        {
#include "emact.c_"
        }
    return 0;
}

#endif // }

#endif // }


#if FEATURE_DEMO // {
/* D C P  R E P L A C E  T E X T */
/*----------------------------------------------------------------------------
    %%Function: DcpReplaceText
    %%Contact: daleg

    Replace the text range given by the range of chars with the new string.
----------------------------------------------------------------------------*/

int DcpReplaceText(
    void               *pObject,
    int                 cpFirst,
    int                 cpLim,
    char               *sz
    )
{
    int                 cch = CchSz(sz);
    int                 dcp = cch - (cpLim - cpFirst);
    int                 cchOrig;
    char                rgch[cbEditText];
    MSOCP               cpIp;

    /* Get current edit control value */
    cchOrig = GetDlgItemText(vhWndDlg, IDC_EDIT1, rgch, cbEditText);

    /* Do not attempt to expand beyond control's capacity. */
    if (cchOrig + dcp >= cbEditText)
        return 0;

    /* Replace the string */
    CopyRgb(rgch + cpLim, rgch + cpLim + dcp, cchOrig - cpLim + 1);
    CopyRgbNo(sz, rgch + cpFirst, cch);

    /* Set the edit control value with the new string, preserving the IP */
    vfSettingDlgItem = fTrue;                           // Prevent recursion
    SendDlgItemMessage(vhWndDlg, IDC_EDIT1, EM_GETSEL, 0, (LPARAM)&cpIp);
    SendDlgItemMessage(vhWndDlg, IDC_EDIT1, WM_SETTEXT, 0, (LPARAM)&rgch[0]);
    SendDlgItemMessage(vhWndDlg, IDC_EDIT1, EM_SETSEL, cpIp + dcp, cpIp + dcp);
    vcchEditText += dcp;
    vfSettingDlgItem = fFalse;

    debugEM0(2, "Replaced text\n");

    return dcp;
}
#endif // }


#if FEATURE_TEXT // {
/* F  C H E C K  I F  M U S T  R E S E T */
/*----------------------------------------------------------------------------
    %%Function: FCheckIfMustReset
    %%Contact: daleg

    Do a primitive check to see if we should invalidate our running rulebase
    state, and do a full reset scan.

    THIS IS NOT A CANONICAL ROUTINE, but there should be something equivalent
    in each app.
----------------------------------------------------------------------------*/

int FCheckIfMustReset(XCHAR wch, int ichMac, MSOCP cpIp)
{
    if (wch == xchBackspace)
        return fTrue;

    /* If user typed a new character, emit character event */
    /* REVIEW: pasting will result in multiple new characters, of which we
       only notice the last */
    if (ichMac > vcchPrev)
        {
        Assert (cpIp > 0);

        /* Without notification of IP moves, there is no way to accurately
           identify when lexer needs invalidating; for safety, we could do so
           on every character.  For demonstrating the lexer, we'll do so only
           when the IP didn't move forward by exactly one character, which is
           a decent approximation of the right time. */
        /* REVIEW: find a more pleasant way to deal with this, like subclassing
           the edit control to get precise control over notifications. */

        if (cpIp != vcpIpPrev + 1)
            return fTrue;
        }

    return fFalse;
}
#endif // }


#if FEATURE_DEMO // {
/* N  C W  R E G I S T E R  C L A S S E S */
/*----------------------------------------------------------------------------
    %%Function: nCwRegisterClasses
    %%Contact: daleg

    Register window classes
----------------------------------------------------------------------------*/

int nCwRegisterClasses(void)
{
    WNDCLASS            wndclass;

    memset(&wndclass, 0x00, sizeof(WNDCLASS));

    /* load WNDCLASS with window's characteristics */
    wndclass.style = CS_HREDRAW | CS_VREDRAW | CS_BYTEALIGNWINDOW;
    wndclass.lpfnWndProc = WndProc;

    /* Extra storage for Class and Window objects */
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = vhInst;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);

    /* Create brush for erasing background */
    wndclass.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wndclass.lpszMenuName = vszAppName;   /* Menu Name is App Name */
    wndclass.lpszClassName = vszAppName; /* Class Name is App Name */
    if (!RegisterClass(&wndclass))
        return -1;

    return (0);
}


/* C W  C E N T E R */
/*----------------------------------------------------------------------------
    %%Function: cwCenter
    %%Contact: daleg

    Center the main window.
----------------------------------------------------------------------------*/

void cwCenter(hWnd, top)
HWND hWnd;
int top;
{
    POINT               pt;
    RECT                swp;
    RECT                rParent;
    int                 iwidth;
    int                 iheight;

    /* get the rectangles for the parent and the child */
    GetWindowRect(hWnd, &swp);
    GetClientRect(vhWndMain, &rParent);

    /* calculate the height and width for MoveWindow */
    iwidth = swp.right - swp.left;
    iheight = swp.bottom - swp.top;

    /* find the center point and convert to screen coordinates */
    pt.x = (rParent.right - rParent.left) / 2;
    pt.y = (rParent.bottom - rParent.top) / 2;
    ClientToScreen(vhWndMain, &pt);

    /* calculate the new x, y starting point */
    pt.x = pt.x - (iwidth / 2);
    pt.y = pt.y - (iheight / 2);

    /* top will adjust the window position, up or down */
    if (top)
        pt.y = pt.y + top;

    /* move the window */
    MoveWindow(hWnd, pt.x, pt.y, iwidth, iheight, FALSE);
}


/* C W  U N  R E G I S T E R  C L A S S E S */
/*----------------------------------------------------------------------------
    %%Function: CwUnRegisterClasses
    %%Contact: daleg

    Un-register the windows classes.
----------------------------------------------------------------------------*/

void CwUnRegisterClasses(void)
{
    WNDCLASS            wndclass;

    memset(&wndclass, 0x00, sizeof(WNDCLASS));

    UnregisterClass(vszAppName, vhInst);
}
#endif // }


#if FEATURE_DEAD // {
/* A S S E R T  L S Z  P R O C */
/*----------------------------------------------------------------------------
    %%Function: AssertLszProc
    %%Contact: daleg

    Print assertion message, and prompt for whether to (f)ail, or (i)gnore.
----------------------------------------------------------------------------*/

int AssertLszProc(
    const char         *szExtra,
    const char         *szFile,
    int                 line
    )
{
    Fail("ASSERTION FAILED: %s IN %s line %d\n", szExtra, szFile, line);
    return 1;
}


/* F A I L */
/*----------------------------------------------------------------------------
    %%Function: Fail
    %%Contact: daleg

    Emit a failure message and exit.
----------------------------------------------------------------------------*/

void __cdecl Fail(const char *sz, ...)
{
    va_list             ap;
    char                szBuf[256];

    /* Start variable arglist */
    va_start(ap, sz);

    wvsprintf(szBuf, sz, ap);
    OutputDebugString("FATAL ERROR: ");
    OutputDebugString(szBuf);
    OutputDebugString("\n");

    /* End variable arglist */
    va_end(ap);

//  _asm int 3;
    exit(1);
}
#endif // }


#if FEATURE_DEAD // {
/* F  N E  N C  L P C H */
/*----------------------------------------------------------------------------
    %%Function: FNeNcLpch
    %%Contact: daleg

    Compare two strings, case insensitive.
----------------------------------------------------------------------------*/

BOOL FNeNcLpch(
    register const uchar       *pch1,
    register const uchar       *pch2,
    register int                cch
    )
{
    while (cch-- > 0)
        {
        if (ChUpper(*pch1++) != ChUpper(*pch2++))
            return fTrue;
        }
    return fFalse;
}
#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\evtmon\inc\emutil.h ===
/*****************************************************************************
    emutil.h

    Owner: SMueller
    Copyright (c) 1997 Microsoft Corporation

    Miscellaneous event monitor utilities
*****************************************************************************/

#ifndef _EMUTIL_H
#define _EMUTIL_H

#include "emrule.h"

MSOEXTERN_C_BEGIN   // ***************** Begin extern "C" ********************

MSOCDECLAPI_(int) MsoIMatchIrul(IRUL irul, ...);
MSOAPI_(MSORULTK *) MsoPrultkFromDtk(int dtk, MSORULTKH* ptkh);
MSOAPI_(int) MsoDtkFromTokenDtki(int dtki, MSORULTKH* ptkh);
MSOAPI_(int) MsoDtkiFromTokenDtk(int dtk, MSORULTKH* ptkh);
MSOAPI_(int) MsoFTokenWas(int dtkStart, int irul, MSORULTKH* ptkh);
MSOAPI_(long) MsoCpLimOfDtk(int dtk, MSORULTKH* ptkh);
MSOAPI_(int) MsoDtkFindPrevToken(int dtkStart, int irul, MSORULTKH *ptkh);

// Get cpFirst of token from index to history
#define MsoCpFirstOfDtk(dtk, ptkh) \
        (MsoPrultkFromDtk(dtk, ptkh)->cpFirst)



#ifdef DEBUG

#if defined(OFFICE_BUILD)  ||  defined(STANDALONE_WORD)

#include "msosdm.h"

MSOAPI_(const char *) MsoSzFromDlmDebug(DLM dlm);

#endif /* OFFICE_BUILD  ||  STANDALONE_WORD */

MSOAPI_(const char *) MsoSzRulName(IRUL irul);

#endif // DEBUG

MSOEXTERN_C_END     // ****************** End extern "C" *********************

#endif // !_EMUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\evtmon\inc\mso.h ===
/*----------------------------------------------------------------------------
    %%File: mso.h
    %%Unit: Event Monitor
    %%Contact: daleg

    Typedef file for Rules Engine of Event Monitor.
----------------------------------------------------------------------------*/

#ifndef MSO_H
#define MSO_H

#ifndef MSOEXTERN_C_BEGIN
#if defined(__cplusplus)
    #define MSOEXTERN_C extern "C"
    #define MSOEXTERN_C_BEGIN extern "C" {
    #define MSOEXTERN_C_END }
#else
    #define MSOEXTERN_C
    #define MSOEXTERN_C_BEGIN
    #define MSOEXTERN_C_END
#endif
#endif // MSOEXTERN_C_BEGIN

#define FEWER_SEGS(sz)
#define VSZASSERT       static unsigned char    vszAssertFile[] = __FILE__;

typedef long IDS;                                       // emkwd.h
#define OFC_CALLBACK        MSOAPICALLTYPE
typedef unsigned short WCHAR;
typedef unsigned short WORD;
typedef unsigned int UINT;
#ifndef _WINDEF_    // windef.h makes uchar (same as mso.h w/ -J)
typedef char BYTE;
#endif
typedef int BOOL;
typedef unsigned long DWORD;

#ifndef cbXchar
#ifndef ANSI_XCHAR
typedef unsigned short XCHAR;
#define cbXchar    2

#else /* ANSI_XCHAR */

typedef unsigned char XCHAR;
#define cbXchar    1
#endif /* !ANSI_XCHAR */
#endif /* !cbXchar */

typedef WORD LID;
typedef DWORD LCID;

#define MSOAPICALLTYPE __stdcall
#define MSOCDECLCALLTYPE __cdecl

#ifndef MSOAPI_
#define MSOAPI_(t)              t MSOAPICALLTYPE
#endif /* !MSOAPI_ */

#ifndef MSOAPIX_
#define MSOAPIX_(t)             t MSOAPICALLTYPE
#endif /* !MSOAPIX_ */

#ifndef MSOCDECLAPI_
#define MSOCDECLAPI_(t)         t MSOCDECLCALLTYPE
#endif /* !MSOCDECLAPI_ */

#ifndef MSOMACAPI_
#define MSOMACAPI_(t)   t
#endif /* !MSOMACAPI_ */

#if !defined(WIN)  &&  defined(NT)
#define WIN
#endif /* !WIN  &&  NT */

#ifdef WIN
#define Win(foo) foo
#define WinMac(win,mac) win
#define WinElse(win,foo) win
#define Nt(foo) foo
#define NtElse(nt,notnt) nt
#else
#define Win(foo)
#define WinMac(win,mac) mac
#define WinElse(win,foo) foo
#define Nt(foo)
#define NtElse(nt,notnt) notnt
#endif

#ifdef MAC
#define Mac(foo) foo
#define MacElse(mac, notmac) mac
#define NotMac(foo)
#else
#define Mac(foo)
#define MacElse(mac, notmac) notmac
#define NotMac(foo) foo
#endif

#define _MAX_PATH   260 /* max. length of full pathname */
#define MsoStrcpy strcpy
#define MsoStrcat strcat
#define MsoStrlen strlen
#define MsoSzIndexRight strrchr
#define MsoMemcpy memcpy
#define MsoMemset memset
#define MsoMemcmp memcmp
#define MsoMemmove memmove

#define MsoCchSzLen(sz)         (strlen(sz))
#define MsoCchWzLen(xsz)        (wcslen(xsz))

#define MsoRgwchToRgch(rgchFrom, cchFrom, rgchTo, cchTo) \
            (PbCopyRgb((rgchFrom), (rgchTo), (cchFrom)), (cchFrom))


MSOAPI_(WCHAR) MsoWchToUpper(WCHAR wch);

#ifdef RULE_COMPILER
#define LANGIDFROMLCID(lcid)   ((WORD  )(lcid))
#define msoStrip 0x01                                   // REVIEW PREHASH
#endif /* RULE_COMPILER */

#define MsoWzToSz(p, rgch) (p)

#ifdef STANDALONE_WORD
#include "word.h"

#define TRUE    1
#define FALSE   0

#else /* !STANDALONE_WORD */

#include <windows.h>
#include <string.h>
///#include "sys.h"

#endif /* STANDALONE_WORD */

#include <ctype.h>

_inline ChUpper(unsigned char ch)
{
    return (islower(ch) ? toupper(ch) : ch);
}

void __cdecl Fail(const char *lsz, ...);                // Print failure msg

#ifndef FReportLszProc
#define FReportLszProc(lszExtra, lszFile, line)             TRUE
#endif /* !FReportLszProc */

/* Breaks into the debugger.  Works (more or less) on all supported
    systems. */
#ifndef MAC
    #define MsoDebugBreakInline() {__asm int 3}
#else /* MAC */
    #define MsoDebugBreakInline() Debugger()
#endif /* !MAC */
#endif /* !MSO_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\evtmon\inc\emrulini.h ===
/*****************************************************************************
    emrulini.h

    Owner: DaleG
    Copyright (c) 1992-1997 Microsoft Corporation

    General Rule-Network Propagation Engine initialization types.

*****************************************************************************/

#ifndef EMRULINI_H
#define EMRULINI_H

MSOEXTERN_C_BEGIN   // ***************** Begin extern "C" ********************

/*************************************************************************
    Types:

    rullims     Rule limits/sizes structure.
    ruldef      Rule node initial definition structure.
    rulinit     Rule initialization structure.

 *************************************************************************/


/* R  U  L  L  I  M  S */
/*----------------------------------------------------------------------------
    %%Structure: RULLIMS
    %%Contact: daleg

    Rule base limits structure.
----------------------------------------------------------------------------*/

typedef struct _RULLIMS
    {
    short               irulRulesMax;                   // Number of nodes
    short               irulVarsMax;                    // Number of var nds
    short               rulevtMax;                      // Num of event_types
    short               rulevlMax;                      // Num of eval levels
    short               rulgGroupMax;                   // Num dependency grps
    short               rulgRegularMax;                 // Num non-context grps
    short               clprulDependMax;                // Num forward depends
    short               clprulBackDependMax;            // Num backwrd depends
    short               ckwdMax;                        // Number of KWD recs
    short               cchKwdTextMax;                  // Len kwd text buffer
    unsigned short      cchNamesMax;                    // Name/string buf len
    } RULLIMS;



/* R  U  L  D  E  F */
/*----------------------------------------------------------------------------
    %%Structure: RULDEF
    %%Contact: daleg

    Rule base node initialization structure.
----------------------------------------------------------------------------*/

typedef struct _RULDEF
    {
    short               rulevl;                         // Event_type/Level
    short               bwDepend;                       // Fwd depend offset
    short               bwBackDepend;                   // Bkwd depend offset
    const XCHAR        *xstzKeywordName;                // Keyword string
    } RULDEF;



/* L  P  F  N  R  U  L  C  X  T */
/*----------------------------------------------------------------------------
    %%Structure: LPFNRULCXT
    %%Contact: daleg

    Rule base Context group callback function
----------------------------------------------------------------------------*/

typedef void (* LPFNRULCXT) (int irul, struct _RULCXT *lprulcxt);




/* R  U  L  I  N  I  T */
/*----------------------------------------------------------------------------
    %%Structure: RULINIT
    %%Contact: daleg

    Rule base global initialization structure.
----------------------------------------------------------------------------*/

typedef int (WIN_CALLBACK *PFNEVAL)(short irul);        // Rule Eval function

typedef struct _RULINIT
    {
    const RULLIMS      *lprullims;                      // Rulebase limits
    const RULDEF       *lprulinit;                      // Rulebase def
    const short        *rgrulevlRulevt;                 // Event_type eval lvls
    const short        *rgirultkRulevtHistoryMax;       // Evt history depths
    const short        *lprulgAppendTo;                 // Group linkages
    const short        *lprulgAppendedFrom;             // Group linkages
    const LPFNRULCXT   *lplpfnrulcxt;                   // Context grp callbks
    const short* const *lplpirulDependents;             // Dependent lists
    const short* const *lplpirulBackDependsOn;          // DependsOn lists
    PFNEVAL             lpfnEvalRule;                   // Evaluate rule code
    MSOKWTB           **rgpkwtbKeyTables;               // Keyword tables
    const char * const *lpszRulNames;                   // Node names
    } RULINIT;


typedef int (WIN_CALLBACK *LPFNRulinit)(struct _RULS *lpruls);


// Initialize pre-constructed rulebase of static nodes
MSOAPI_(int) MsoFInitStaticRuls(
    struct _RULS       *pruls,
    struct _RULS       *prulsInit
    );


// Create and initialize rulebase of static nodes from compressed rulebase
MSOAPI_(int) MsoFInitCompressedRulebase(
    struct _RULS       *lpruls,
    const RULINIT      *lprulinit
    );


#ifndef pNil
#define pNil    NULL
#endif /* !pNil */

#define IN_DATASEG
#define NOT_IN_DATASEG

// Rule node type flags: shared with rule.h
#define rultRule            0x00                        // Rule
#define rultEvent           0x01                        // Event/Variable
#define rultPrimaryRule     0x02                        // Rule auto-scheduled
#define rultActionRule      0x00                        // Not really a flag
///#define rultNonTermRule  0x08
///#define rultSeqRule      0x10

MSOEXTERN_C_END     // ****************** End extern "C" *********************

#endif /* EMRULINI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\evtmon\inc\msoem.h ===
/*****************************************************************************
    msoem.h

    Owner: DaleG
    Copyright (c) 1997 Microsoft Corporation

    Typedef file for Rules Engine of Event Monitor.

*****************************************************************************/

#ifndef MSOEM_H
#define MSOEM_H

#ifndef MSO_H
#pragma message ("MsoEM.h file included before Mso.h.  Including Mso.h.")
#include "mso.h"
#endif

MSOEXTERN_C_BEGIN   // ***************** Begin extern "C" ********************


#include "msoemtyp.h"



//---------------------------------------------------------------------------
// Define useful macros (mostly stolen from Word)
// REVIEW daleg: these need to be Mso-ized
//---------------------------------------------------------------------------

#if !WORD_BUILD  &&  !STANDALONE_WORD

#ifndef DEBUGASSERTSZ
#define DEBUGASSERTSZ       VSZASSERT
#endif /* !DEBUGASSERTSZ */

///#define FNeNcLpxch(lpch1, lpch2, cch) FNeNcRgxch(lpch1, lpch2, cch)
#define SzFromStz(stz)          ((stz)+1)
#define XszFromXstz(xstz)       ((xstz)+1)
#if !ACCESS_BUILD
#define CchSz(sz)               MsoCchSzLen(sz)
#ifndef CchWz
#define CchWz(wz)               MsoCchWzLen(wz)
#endif /* !CchWz */
#endif /* !ACCESS_BUILD */
#define XszFromXstz(xstz)       ((xstz)+1)
#define RgxchFromXstz(xstz)     ((xstz)+1)
#define CchXstz(xstz)           CchXst(xstz)
#define CchXst(xst)             (*xst)
#define cbMaxSz     256
#define cbMaxStz    257
#define cchMaxSz    255
#define cbMaxSz     256
#ifndef WORD_BUILD
#ifndef fTrue
#define fTrue 1
#endif
#ifndef fFalse
#define fFalse 0
#endif
#define tYes    1      /* much like fTrue */
#define tNo     0      /* much like fFalse */
#define tMaybe  (-1)   /* the "different" state */
#define iNil (-1)
#endif /* !WORD_BUILD */
#undef wValue
#define STATIC

// Return "low" value of a split value
#define W1OfPsv(psv)            ((psv)->wValue1)

// Set "low" value of a split value
#define SetW1OfPsv(psv, w)      ((psv)->wValue1 = (w))

// Increment "low" value of a split value
#define IncrW1OfPsv(psv, w)     ((psv)->wValue1 += (w))

// Return "high" value of a split value
#define W2OfPsv(psv)            ((psv)->wValue2)

// Set "high" value of a split value
#define SetW2OfPsv(psv, w)      ((psv)->wValue2 = (w))

// Increment "high" value of a split value
#define IncrW2OfPsv(psv, w)     ((psv)->wValue2 += (w))

// Merge two shorts into a long, compatible with SVL
#define SvlFromWW(wValue2, wValue1) \
            (((long) (wValue2) << 16) + ((long) (wValue1)))


#define PbCopyRgb(pbFrom, pbTo, cb) \
            (((unsigned char *) memmove((pbTo), (pbFrom), (cb))) + (cb))
#define PbCopyRgbNo(pbFrom, pbTo, cb) \
            (memcpy((pbTo), (pbFrom), (cb)), (pbTo) + (cb))
#define CopyRgb(pbFrom, pbTo, cb)       memmove(pbTo, pbFrom, cb)
#define CopyRgbNo(pbFrom, pbTo, cb)     memcpy(pbTo, pbFrom, cb)
#define CopyRgxch(pxchFrom, pxchTo, cch) \
            CopyRgb(pxchFrom,pxchTo,(cch)*cbXchar)

#define ClearLp(lpv, type) \
            MsoMemset((lpv), '\0', sizeof(type))

#define ClearLprg(lpv, type, iMax) \
            MsoMemset((lpv), '\0', sizeof(type) * (iMax))

#define CopyLprg(lpvFrom, lpvTo, type, iMax) \
            CopyRgb((lpvFrom), (lpvTo), (unsigned int)(sizeof(type) * (iMax)))

#define IMaxRg(dcl, type) \
            (sizeof(dcl) / sizeof(type))


#define ClearLprgBlocked(lpv, type, iMax) \
            MsoMemset((lpv), '\0', (sizeof(type) * (iMax) + sizeof(void *)))

#define IMaxRgBlocked(dcl, type) \
            ((sizeof(dcl) / sizeof(type)) - sizeof(void *))


#endif /* !WORD_BUILD */

// Allocate storage for a given type, return pointer
#define MsoPNewEm(type) \
            ((type *) MsoPvAllocEmCb((unsigned int) sizeof(type)))

// Zero storage for a type, given pointer
#define MsoClearPv(pv, type) \
            MsoClearPvCb((pv), sizeof(type))

// Zero storage for number bytes given
#define MsoClearPvCb(pv, cb) \
            MsoMemset((pv), '\0', (cb))

// Allocate storage for an array of a given type, return pointer
#define MsoPNewEmRg(type, iMax) \
            ((type *) MsoPvAllocEmCb((unsigned int)(sizeof(type) * (iMax))))

// Zero storage for an array of a type, given pointer
#define MsoClearRg(pv, type, iMax) \
            MsoMemset((pv), '\0', sizeof(type) * (iMax))

// Copy storage for an array of a type, given pointers
#define MsoCopyRg(rgFrom, rgTo, type, iMax) \
            MsoMemmove((rgTo), (rgFrom), sizeof(type) * (iMax))

// Copy storage for an array of a type, given pointers, checking for overlaps
#define MsoCopyRgNo(rgFrom, rgTo, type, iMax) \
            MsoMemcpy((rgTo), (rgFrom), sizeof(type) * (iMax))

// Copy an array of Unicode characters
#define MsoCopyRgwch(rgFrom, rgTo, cch) \
            MsoCopyRg((rgFrom), (rgTo), WCHAR, (cch))

// Return maximum number of bytes used by array, given *definition*
#define MsoIMaxRg(rg) \
            (sizeof(rg) / sizeof(rg[0]))

// Allocate storage for a given type, but specifying size, return pointer
#define MsoPNewEmCb(type, cb) \
            ((type *) MsoPvAllocEmCb((unsigned int)(cb)))

// Allocate (far) LINKED BLOCK storage for an array of type, return ptr
// This is a rg of the type, but with a pointer linking it to next alloc
#define MsoPNewEmRgBlocked(type_blk, type, iMax) \
            ((type_blk *) MsoPvAllocEmCb \
                ((unsigned int) (sizeof(type) * (iMax) + sizeof(void *))))

#define MsoPReallocEm(pv, type, cb) \
            ((type *) MsoPvReallocEmPvCb((pv), (unsigned int) (cb)))

#define MsoPReallocEmRg(pv, type, iMax) \
            ((type *) \
                MsoPvReallocEmPvCb \
                    ((pv), (unsigned int) (sizeof(type) * (iMax))))

#define MsoPvReallocEmPvCb(pv, cb) \
            (void *)MsoPvRealloc(pv, cb)

#define MsoPvAllocEmCb(cb)      (void *)MsoPvAlloc((cb), msodgMisc )
#define MsoFreeEmPv(pv)     { if (pv) MsoFreePv(pv); }
#define MsoFreeEmPvClear(pv)    MsoFreeEmPpv(&(pv))

#define MsoFreeEmPpv(ppv)   {   \
                                MsoFreeEmPv(*(void **) (ppv));  \
                                *(void * UNALIGNED *) (ppv) = NULL; \
                                }


#define MsoPbCopyRgb(pbFrom, pbTo, cb)  \
            (((unsigned char *) MsoMemmove((pbTo), (pbFrom), (cb))) + (cb))
#define MsoPbCopyRgbNo(pbFrom, pbTo, cb) \
            (MsoMemcpy((pbTo), (pbFrom), (cb)), (pbTo) + (cb))

// Return whether x is between lo and hi values, inclusive.
#define MsoFBetween(x, lo, hi)      ((x) >= (lo)  &&  (x) <= (hi))
// REVIEW: consider the following minutely faster but more dangerous version
//#define MsoFBetween(x, lo, hi)        ((unsigned)((x) - (lo)) <= (hi) - (lo))


#include "msodbglg.h"

#ifdef STANDALONE

#define MsoPvAlloc(cb, dg)      malloc(cb)
#define MsoFreePv(pv)           free(pv)
#define MsoPvRealloc(pv, cb)    realloc((pv), (cb))

#endif /* STANDALONE */


#if !defined(WORD_BUILD)  &&  !defined(WORD_H)

#ifndef CommSz
#define CommSz(sz)          OutputDebugStringA(sz)
#endif /* !CommSz */

#ifndef ACCESS_BUILD
typedef void           *DOC;                            // Define object
#define docNil  ((DOC) NULL)
#else /* ACCESS_BUILD */
#define pdocNil     ((DOC *) NULL)
#endif /* !ACCESS_BUILD */

#define cpNil ((MSOCP) -1)
#define cp0 ((MSOCP) 0)
///typedef unsigned short BF;

typedef unsigned char uchar;
typedef unsigned int uint;
typedef unsigned short ushort;
typedef unsigned long ulong;

#endif /* !WORD_BUILD  &&  !WORD_H */


#ifdef OFFICE_BUILD
MSOAPI_(BOOL) MsoFInitOfficeEm(struct MSOINST *pinst);  // Init MSO Em

// Query type in FEmNotifyAction(msoemssAppEm,..)
#define msonaAppEmUseMso        1                       // App needs MSO EM?
#endif /* !OFFICE_BUILD */

MSOAPI_(int) MsoLRuleParsePwch(                         // Parse string w/rules
    WCHAR              *pwch,
    int                 cch,
    int                 rulevt,
    int                 rulg
    );

#ifdef DEBUG
MSOAPI_(int) MsoLRuleParseFile(                         // Parse file w/rules
    char               *rgchPath,
    int                 rulevt,
    int                 rulg
    );
#ifdef OFFICE_BUILD
BOOL FWriteEmBe(LPARAM lParam, struct MSOINST *pinst);  // Mark MSO Em memory
#endif /* OFFICE_BUILD */
#endif /* DEBUG */

MSOEXTERN_C_END     // ****************** End extern "C" *********************

#endif /* !MSOEM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\evtmon\inc\msodbglg.h ===
/*----------------------------------------------------------------------------
    %%File: msodbglg.h
    %%Unit: Debug
    %%Contact: daleg

    Debugging macros and functions.

    The debug log mechanism automatically creates and manages a log file
    "debug.log".  By controlling a single variable, vwDebugLogLvl, we
    can route printf()-style output to a log file, or to the Comm port
    AND the log file.

    The log is created and written to whenever the run-time log level,
    vwDebugLogLvl >= wTraceLvl.  wTraceLvl is the declared, or compile-
    time log level, passed as an argument to MsoDebugLog().  It will NOT print
    if vwDebugLogLvl is LESS than the declared trace level.  If
    vwDebugLogLvl is an ODD number, anything written to the log file
    will also appear on the port used by OutputDebugString().

    NOTE:
        THE SPRINTF STRING MUST NOT EXPAND BEYOND 256 CHARACTERS!

    USAGE:

        There are several macros, debugXX0() thru debugXX6(), etc.,
        that are the main interface to MsoDebugLog(), where "XX" is the
        subsystem mneumonic.  EACH SUBSYSTEM GROUP SHOULD HAVE ITS OWN SET
        OF MACROS.  Thus the Event Monitor group adds debugEM0 thru
        debugEM6() and the Hyperlink group might add debugHL0 thru
        debugHL6, etc.  EACH SUBSYSTEM GETS ITS OWN LOG FILTER BIT,
        DEFINED BELOW (see fDebugFilterEm), which allows developers to
        see their logging info without having to wade through other logging
        output.

        MsoDebugLog() has a variable number of arguments, and is
        similar to the standard C sprintf() routine, and in fact calls it.
        The macros remove the need to enclose calls to MsoDebugLog() with
        #ifdef's, but C does not allow variable numbers of arguments in
        macros.  To overcome this (and also due to problems with CsConst'ing
        the format strings), each debugxx() macro has a fixed number of
        arguments, where xx indicates the number of arguments past the format
        string.

        Examples:

            debugXX0((fTrace ? 0 : 6), "Value is NOT chosen\n");
            debugXX1(6, "NEW SECTION: %d\n", wSection);
            debugXX4(2, "Paragraph %d (CP %ld thru %ld) has style %d\n",
                     iaftag, lpaftag->cpFirst, (lpaftag + 1)->cpFirst, istd);

        The first argument to the macros is the wTraceLvl, the declared
        trace-level.  In the three examples above, we are saying: the first
        should not print unless vwDebugLogLvl >= (fTrace ? 0 : 6),
        the second unless vwDebugLogLvl >= 6, and the third unless
        vwDebugLogLvl >= 2.

    CHOICE OF DECLARED TRACE LEVELS:

        In general, low declared trace levels should be used within discrete
        subsystems that are *not* shared, and high levels should be used
        within shared code.  Note that only EVEN numbers are used.  The
        reason will be explained below.

        THE HIGHER THE LEVEL NUMBER, THE MORE GOO YOU ARE GOING TO OUTPUT.

            Level       Generally used when:
            ------------------------------------------------------
            -1          Warning messages.

            0           Messages to be seen by testers.
            2           Message to be seen by rigorous testers.

            4           Structural changes, such as dialog boxes appearing,
                        Windows created, features beginning.

            6           Normal logging of a subsystem.
            8           Detailed logging of a subsystem.

            10          Major subsystem I/O, such as scanning CHRs, or
                        reading buffers.
            12          Minor subsystem I/O, such as reading characters.

            ...

            20          Shared subsystem, such as FormatLine, CachePara
                        or something else that we would call frequently,
                        and be buried under detail.

    RUN-TIME USAGE:

        Set vwDebugLogLvl to an ODD number, if you wish output via
        OutputDebugString() as well as the log file.  Set vwDebugLogLvl to an
        EVEN number if you wish output only to the log file.

        Set vwDebugLogLvl to a low level using the dialog box.  For
        higher levels (e.g. to debug FormatLine()), you should set a
        breakpoint in the debugger, and set vwDebugLogLvl when in the
        targeted routine.

        Example (from Word):

            1.  We set vwDebugLogLvl to 2 from the dialog box in the
                "Preferences" memu.  We also set a breakpoint within
                TkLexText().
            2.  We run the AutoFormatter, and when we hit the breakpoint,
                we set vwDebugLogLvl from the watch window to 8,
                so we will get a lot of output.
            3.  When we approach the interesting point of a problem, we
                change the vwDebugLogLvl to 9, so it will appear on
                the OutputDebugStringA() terminal.

----------------------------------------------------------------------------*/

#ifndef MSODBGLG_H
#define MSODBGLG_H

#include <stdarg.h>

#if defined(STANDALONE)  &&  !defined(MSOEXTERN_C_BEGIN)
#define MSOEXTERN_C_BEGIN
#define MSOEXTERN_C_END
#endif // STANDALONE

MSOEXTERN_C_BEGIN   // ***************** Begin extern "C" ********************

#ifndef UNIX
#if _MSC_VER <= 600
#ifndef __cdecl
#define __cdecl _cdecl
#endif /* !__cdecl */
#endif /* MSC_VER <= 600 */

#else
#define __cdecl
#define sprintf ansi_sprintf
#define vsprintf ansi_vsprintf
int ansi_sprintf(char *lpchBuf, const char *sz, ...);
int ansi_vsprintf(char *lpchBuf, const char *sz, va_list ap);
#define CommSz printf
#endif /* !UNIX */


// Define filters for MsoDebugLog()
// These values can overlap for different applications.
// However, Office reserves the lower 0x00FF bits.

#define fDebugFilterEm          0x0001U                 // App Event Monitor
#define fDebugFilterWc          0x0002U                 // Web Client
#define fDebugFilterAcb         0x0004U                 // Active ClipBoard
#define fDebugFilterEc          0x0008U                 // Exec Command (DOIT)
#define fDebugFilterMsoEm       0x0010U                 // MSO Event Monitor

#if defined(WORD_BUILD)
#define fDebugFilterPrint       0x0100U                 // Print
#define fDebugFilterReconcil    0x0200U                 // Reconcile
#define fDebugFilterHtmlIn      0x0400U                 // HTML in

#elif defined(EXCEL_BUILD)
#define fDebugFilterUnused1     0x0100U                 // Use me 1st in Excel

#elif defined(PPT_BUILD)
#define fDebugFilterUnused1     0x0100U                 // Use me 1st in PPT

#elif defined(ACCESS_BUILD)
#define fDebugFilterUnused1     0x0100U                 // Use me 1st in Access
#endif

#define fDebugFilterAll         0xFFFFU


#ifdef STANDALONE
#undef wsprintfA
#define wsprintfA sprintf
#undef wvsprintfA
#define wvsprintfA vsprintf
#include <stdio.h>
#endif /* STANDALONE */

#ifdef DEBUG
#ifndef WORD_BUILD
extern int vwDebugLogFilter;                            // Debug trace filter
extern int vwDebugLogLvl;                               // Debug trace level
#endif /* !WORD_BUILD */

#ifdef STANDALONE

#ifndef MSOAPI_
#define MSOAPI_(t)              t __stdcall
#endif /* !MSOAPI_ */

#ifndef MSOCDECLAPI_
#define MSOCDECLAPI_(t)         t __cdecl
#endif /* !MSOCDECLAPI_ */

#endif // STANDALONE

// Return the sz, or if null, return "(null)"
#define SzOrNull(sz) \
            ((sz) != NULL ? (sz) : "(null)")

MSOCDECLAPI_(void) MsoDebugLog(                         // Print debug msg
    int                 wTraceLvl,
    unsigned int        grfFilter,
    const unsigned char *sz,
    ...
    );
MSOCDECLAPI_(void) MsoAssertSzProcVar(                  // Assert with sprintf
    const char         *szFile,
    int                 line,
    const char         *sz,
    ...
    );
MSOCDECLAPI_(int) MsoFReportSzProcVar(                  // ReportSz w/ sprintf
    const char         *szFile,
    int                 line,
    const char         *sz,
    ...
    );
MSOCDECLAPI_(void) MsoCommSzVar(const char *sz, ...);   // CommSz with sprintf
MSOAPI_(void) MsoDebugLogAp(                            // Print debug msg
    int                 wTraceLvl,
    unsigned int        grfFilter,
    const unsigned char *sz,
    va_list             ap
    );
MSOAPI_(void) MsoDebugLogPch(                           // Print large msg
    int                 wTraceLvl,
    unsigned int        grfFilter,
    char               *pch,
    int                 cchLen,
    int                 fIsRgxch
    );
MSOAPI_(void) MsoAssertSzProcAp(                        // AssertSz using ap
    const char         *szFile,
    int                 line,
    const char         *sz,
    va_list             ap
    );
MSOAPI_(int) MsoFReportSzProcAp(                        // ReportSz using ap
    const char         *szFile,
    int                 line,
    const char         *sz,
    va_list             ap
    );
MSOAPI_(void) MsoCommSzAp(const char *sz, va_list ap);  // CommSz using ap
MSOAPI_(int) MsoFDebugLogCloseFile(void);               // Close log file
MSOAPI_(int *) MsoPwDebugLogLvl(int **ppwDebugLogFilter);// Return ptr to vars

// These *debug* routines are XCHAR (WCHAR on unicode builds and char on ANSI)
#ifndef ANSI_XCHAR
#ifdef cbXchar
MSOAPI_(XCHAR *) MsoXszFromRgxchDebug(                  // Convert pwch to wz
    XCHAR              *rgxch,
    int                 cch
    );
MSOAPI_(char *) MsoSzFromRgxchDebug(                    // Convert pwch to sz
    const XCHAR        *rgxch,
    int                 cch
    );
MSOAPI_(char *) MsoSzFromXszDebug(const XCHAR *xsz);    // Convert wz to sz
#endif /* cbXchar */
#else /* ANSI_XCHAR */
MSOAPI_(char *) MsoXszFromRgxchDebug(                   // Convert pwch to wz
    char               *rgxch,
    int                 cch
    );
MSOAPI_(char *) MsoSzFromRgxchDebug(                    // Convert pwch to sz
    const char         *rgxch,
    int                 cch
    );
#define MsoSzFromXszDebug(xsz) (xsz)
#endif /* !ANSI_XCHAR */



// NOTE: debugvar has to be called with 2 parenthesis...
#define debugvar(a)     MsoDebugLog a
#define Debug(e)        e
#define DebugElse(s, t) s
#define debuglog0(wLevel, grfFilter, sz) \
            do { \
            static const unsigned char      szDebug[] = sz; \
            MsoDebugLog(wLevel, grfFilter, szDebug); \
            } while (0)
#define debuglog1(wLevel, grfFilter, sz, a) \
            do { \
            static const unsigned char      szDebug[] = sz; \
            MsoDebugLog(wLevel, grfFilter, szDebug, a); \
            } while (0)
#define debuglog2(wLevel, grfFilter, sz, a, b) \
            do { \
            static const unsigned char      szDebug[] = sz; \
            MsoDebugLog(wLevel, grfFilter, szDebug, a, b); \
            } while (0)
#define debuglog3(wLevel, grfFilter, sz, a, b, c) \
            do { \
            static const unsigned char      szDebug[] = sz; \
            MsoDebugLog(wLevel, grfFilter, szDebug, a, b, c); \
            } while (0)
#define debuglog4(wLevel, grfFilter, sz, a, b, c, d) \
            do { \
            static const unsigned char      szDebug[] = sz; \
            MsoDebugLog(wLevel, grfFilter, szDebug, a, b, c, d); \
            } while (0)
#define debuglog5(wLevel, grfFilter, sz, a, b, c, d, e) \
            do { \
            static const unsigned char      szDebug[] = sz; \
            MsoDebugLog(wLevel, grfFilter, szDebug, a, b, c, d, e); \
            } while (0)
#define debuglog6(wLevel, grfFilter, sz, a, b, c, d, e, f) \
            do { \
            static const unsigned char      szDebug[] = sz; \
            MsoDebugLog(wLevel, grfFilter, szDebug, a, b, c, d, e, f); \
            } while (0)
#define debuglogPch(wLevel, grfFilter, pch, cch) \
            MsoDebugLogPch(wLevel, grfFilter, pch, cch, fFalse)
#define debuglogPwch(wLevel, grfFilter, pwch, cwch) \
            MsoDebugLogPch(wLevel, grfFilter, (char *)pwch, cwch, fTrue)

#ifndef DEBUGASSERTSZ
#define DEBUGASSERTSZ       VSZASSERT
#endif /* !DEBUGASSERTSZ */

#ifndef VSZASSERT
#define VSZASSERT           static unsigned char vszAssertFile[] = __FILE__;
#endif /* !VSZASSERT */

#ifndef Assert
#define Assert(f)       AssertSz0((f), #f)
#define AssertDo(f)     Assert((f) != 0)
#endif /* !Assert */

#ifndef AssertSz
#define AssertSz(f, sz)     AssertSz0(f, sz)
#endif /* !AssertSz */

#define AssertSz0(f, sz) \
            do { \
            static const char       szAssert[] = sz; \
            if (!(f)) \
                MsoAssertSzProcVar \
                    (vszAssertFile, __LINE__, szAssert); \
            } while (0)

#define AssertSz1(f, sz, a) \
            do { \
            static const char       szAssert[] = sz; \
            if (!(f)) \
                MsoAssertSzProcVar \
                    (vszAssertFile, __LINE__, szAssert, a); \
            } while (0)

#define AssertSz2(f, sz, a, b) \
            do { \
            static const char       szAssert[] = sz; \
            if (!(f)) \
                MsoAssertSzProcVar \
                    (vszAssertFile, __LINE__, szAssert, a, b); \
            } while (0)

#define AssertSz3(f, sz, a, b, c) \
            do { \
            static const char       szAssert[] = sz; \
            if (!(f)) \
                MsoAssertSzProcVar \
                    (vszAssertFile, __LINE__, szAssert, a, b, c); \
            } while (0)

#define AssertSz4(f, sz, a, b, c, d) \
            do { \
            static const char       szAssert[] = sz; \
            if (!(f)) \
                MsoAssertSzProcVar \
                    (vszAssertFile, __LINE__, szAssert, a, b, c, d); \
            } while (0)

#define AssertSz5(f, sz, a, b, c, d, e) \
            do { \
            static const char       szAssert[] = sz; \
            if (!(f)) \
                MsoAssertSzProcVar \
                    (vszAssertFile, __LINE__, szAssert, a, b, c, d, e); \
            } while (0)

#ifndef WORD_BUILD
#ifdef OFFICE_BUILD

#define AssertLszProc(szMsg, szFile, line) \
            do { \
            if (MsoFAssertsEnabled() && \
                    !MsoFAssert(szFile, line, (const CHAR*)(szMsg))) \
                MsoDebugBreakInline(); \
            } while (0)

#define FReportLszProc(szMsg, szFile, line) \
            MsoFReport(szFile, line, szMsg)

#else /* !OFFICE_BUILD */
int AssertLszProc(
    const char         *szExtra,
    const char         *szFile,
    int                 line
    );
#endif /* !OFFICE_BUILD */
#endif /* !WORD_BUILD */


#ifndef ReportSz
#define ReportSz(sz)    MsoReportSz(sz)
#endif /* !ReportSz */

#define MsoReportSz(sz) \
            do { \
            static const char szXXXXXXXFar[] = sz; \
            if (!MsoFReportSzProcVar(vszAssertFile, __LINE__, szXXXXXXXFar)) \
                MsoDebugBreakInline(); \
            } while (0)

#define ReportSz0If(f, sz) \
            if (!(f)) \
                { \
                static const char       szReport[] = sz; \
                if (!MsoFReportSzProcVar \
                    (vszAssertFile, __LINE__, szReport)) \
                        MsoDebugBreakInline(); \
                } \
            else

#define ReportSz1If(f, sz, a) \
            if (!(f)) \
                { \
                static const char       szReport[] = sz; \
                if (!MsoFReportSzProcVar \
                    (vszAssertFile, __LINE__, szReport, a)) \
                        MsoDebugBreakInline(); \
                } \
            else

#define ReportSz2If(f, sz, a, b) \
            if (!(f)) \
                { \
                static const char       szReport[] = sz; \
                if (!MsoFReportSzProcVar \
                    (vszAssertFile, __LINE__, szReport, a, b)) \
                        MsoDebugBreakInline(); \
                } \
            else

#define ReportSz3If(f, sz, a, b, c) \
            if (!(f)) \
                { \
                static const char       szReport[] = sz; \
                if (!MsoFReportSzProcVar \
                    (vszAssertFile, __LINE__, szReport, a, b, c)) \
                        MsoDebugBreakInline(); \
                } \
            else

#define CommSz0(sz) \
            do { \
            static const char       szComm[] = sz; \
            MsoCommSzVar(szComm); \
            } while (0)

#define CommSz1(sz, a) \
            do { \
            static const char       szComm[] = sz; \
            MsoCommSzVar(szComm, a); \
            } while (0)

#define CommSz2(sz, a, b) \
            do { \
            static const char       szComm[] = sz; \
            MsoCommSzVar(szComm, a, b); \
            } while (0)

#define CommSz3(sz, a, b, c) \
            do { \
            static const char       szComm[] = sz; \
            MsoCommSzVar(szComm, a, b, c); \
            } while (0)

#define CommSz4(sz, a, b, c, d) \
            do { \
            static const char       szComm[] = sz; \
            MsoCommSzVar(szComm, a, b, c, d); \
            } while (0)

#define CommSz5(sz, a, b, c, d, e) \
            do { \
            static const char       szComm[] = sz; \
            MsoCommSzVar(szComm, a, b, c, d, e); \
            } while (0)

#ifndef NotReached
#define NotReached()    AssertSz0(fFalse, "NotReached declaration was reached")
#endif /* !NotReached */

#else /* !DEBUG */

#define debugvar(a)
#define Debug(e)
#define DebugElse(s, t) t
#define debuglog0(wLevel, grfFilter, sz)
#define debuglog1(wLevel, grfFilter, sz, a)
#define debuglog2(wLevel, grfFilter, sz, a, b)
#define debuglog3(wLevel, grfFilter, sz, a, b, c)
#define debuglog4(wLevel, grfFilter, sz, a, b, c, d)
#define debuglog5(wLevel, grfFilter, sz, a, b, c, d, e)
#define debuglog6(wLevel, grfFilter, sz, a, b, c, d, e, f)
#define debuglogPch(wLevel, grfFilter, pch, cch)
#define debuglogPwch(wLevel, grfFilter, pwch, cwch)

#ifndef DEBUGASSERTSZ
#define DEBUGASSERTSZ
#endif /* !DEBUGASSERTSZ */

#ifndef VSZASSERT
#define VSZASSERT
#endif /* !VSZASSERT */

#ifndef Assert
#define Assert(f)
#define AssertDo(f)     (f)
#endif /* !Assert */

#ifndef AssertSz
#define AssertSz(f, sz)
#endif /* !AssertSz */

#define AssertSz0(f, sz)
#define AssertSz1(f, sz, a)
#define AssertSz2(f, sz, a, b)
#define AssertSz3(f, sz, a, b, c)
#define AssertSz4(f, sz, a, b, c, d)
#define AssertSz5(f, sz, a, b, c, d, e)

#define ReportSz(sz)
#define MsoReportSz(sz)
#define ReportSz0If(f, sz)
#define ReportSz1If(f, sz, a)
#define ReportSz2If(f, sz, a, b)
#define ReportSz3If(f, sz, a, b, c)

#define CommSz0(sz)
#define CommSz1(sz, a)
#define CommSz2(sz, a, b)
#define CommSz3(sz, a, b, c)
#define CommSz4(sz, a, b, c, d)
#define CommSz5(sz, a, b, c, d, e)

#ifndef NotReached
#define NotReached()
#endif /* !NotReached */

#endif /* DEBUG */

// Generic debug log macros - WARNING: THIS WILL BE SEEN BY EVERYONE
#define debug0(wLevel, sz) \
            debuglog0(wLevel, fDebugFilterAll, sz)
#define debug1(wLevel, sz, a) \
            debuglog1(wLevel, fDebugFilterAll, sz, a)
#define debug2(wLevel, sz, a, b) \
            debuglog2(wLevel, fDebugFilterAll, sz, a, b)
#define debug3(wLevel, sz, a, b, c) \
            debuglog3(wLevel, fDebugFilterAll, sz, a, b, c)
#define debug4(wLevel, sz, a, b, c, d) \
            debuglog4(wLevel, fDebugFilterAll, sz, a, b, c, d)
#define debug5(wLevel, sz, a, b, c, d, e) \
            debuglog5(wLevel, fDebugFilterAll, sz, a, b, c, d, e)
#define debug6(wLevel, sz, a, b, c, d, e, f) \
            debuglog6(wLevel, fDebugFilterAll, sz, a, b, c, d, e, f)
#define debugPch(wLevel, pch, cch)\
            debuglogPch(wLevel, fDebugFilterAll, pch, cch)
#define debugPwch(wLevel, pwch, cwch)\
            debuglogPwch(wLevel, fDebugFilterAll, pwch, cwch)

// Application Event Monitor debug log macros
#define debugEM0(wLevel, sz) \
            debuglog0(wLevel, fDebugFilterEm, sz)
#define debugEM1(wLevel, sz, a) \
            debuglog1(wLevel, fDebugFilterEm, sz, a)
#define debugEM2(wLevel, sz, a, b) \
            debuglog2(wLevel, fDebugFilterEm, sz, a, b)
#define debugEM3(wLevel, sz, a, b, c) \
            debuglog3(wLevel, fDebugFilterEm, sz, a, b, c)
#define debugEM4(wLevel, sz, a, b, c, d) \
            debuglog4(wLevel, fDebugFilterEm, sz, a, b, c, d)
#define debugEM5(wLevel, sz, a, b, c, d, e) \
            debuglog5(wLevel, fDebugFilterEm, sz, a, b, c, d, e)
#define debugEM6(wLevel, sz, a, b, c, d, e, f) \
            debuglog6(wLevel, fDebugFilterEm, sz, a, b, c, d, e, f)
#define debugEMPch(wLevel, pch, cch)\
            debuglogPch(wLevel, fDebugFilterEm, pch, cch)
#define debugEMPwch(wLevel, pwch, cwch)\
            debuglogPwch(wLevel, fDebugFilterEm, pwch, cwch)

// Application Rule Engine debug log macros
#define debugRL0(wLevel, sz) \
            debuglog0(wLevel, vlpruls->grfDebugLogFilter, sz)
#define debugRL1(wLevel, sz, a) \
            debuglog1(wLevel, vlpruls->grfDebugLogFilter, sz, a)
#define debugRL2(wLevel, sz, a, b) \
            debuglog2(wLevel, vlpruls->grfDebugLogFilter, sz, a, b)
#define debugRL3(wLevel, sz, a, b, c) \
            debuglog3(wLevel, vlpruls->grfDebugLogFilter, sz, a, b, c)
#define debugRL4(wLevel, sz, a, b, c, d) \
            debuglog4(wLevel, vlpruls->grfDebugLogFilter, sz, a, b, c, d)
#define debugRL5(wLevel, sz, a, b, c, d, e) \
            debuglog5(wLevel, vlpruls->grfDebugLogFilter, sz, a, b, c, d, e)
#define debugRL6(wLevel, sz, a, b, c, d, e, f) \
            debuglog6(wLevel,vlpruls->grfDebugLogFilter, sz, a, b, c, d, e, f)
#define debugRLPch(wLevel, pch, cch)\
            debuglogPch(wLevel, vlpruls->grfDebugLogFilter, pch, cch)
#define debugRLPwch(wLevel, pwch, cwch)\
            debuglogPwch(wLevel, vlpruls->grfDebugLogFilter, pwch, cwch)

// Web Client debug log macros
#define debugWC0(wLevel, sz) \
            debuglog0(wLevel, fDebugFilterWc, sz)
#define debugWC1(wLevel, sz, a) \
            debuglog1(wLevel, fDebugFilterWc, sz, a)
#define debugWC2(wLevel, sz, a, b) \
            debuglog2(wLevel, fDebugFilterWc, sz, a, b)
#define debugWC3(wLevel, sz, a, b, c) \
            debuglog3(wLevel, fDebugFilterWc, sz, a, b, c)
#define debugWC4(wLevel, sz, a, b, c, d) \
            debuglog4(wLevel, fDebugFilterWc, sz, a, b, c, d)
#define debugWC5(wLevel, sz, a, b, c, d, e) \
            debuglog5(wLevel, fDebugFilterWc, sz, a, b, c, d, e)
#define debugWC6(wLevel, sz, a, b, c, d, e, f) \
            debuglog6(wLevel, fDebugFilterWc, sz, a, b, c, d, e, f)
#define debugWCPch(wLevel, pch, cch)\
            debuglogPch(wLevel, fDebugFilterWc, pch, cch)
#define debugWCPwch(wLevel, pwch, cwch)\
            debuglogPwch(wLevel, fDebugFilterWc, pwch, cwch)

// Active Clip Board (C & C) debug log macros
#define debugACB0(wLevel, sz) \
            debuglog0(wLevel, fDebugFilterAcb, sz)
#define debugACB1(wLevel, sz, a) \
            debuglog1(wLevel, fDebugFilterAcb, sz, a)
#define debugACB2(wLevel, sz, a, b) \
            debuglog2(wLevel, fDebugFilterAcb, sz, a, b)
#define debugACB3(wLevel, sz, a, b, c) \
            debuglog3(wLevel, fDebugFilterAcb, sz, a, b, c)
#define debugACB4(wLevel, sz, a, b, c, d) \
            debuglog4(wLevel, fDebugFilterAcb, sz, a, b, c, d)
#define debugACB5(wLevel, sz, a, b, c, d, e) \
            debuglog5(wLevel, fDebugFilterAcb, sz, a, b, c, d, e)
#define debugACB6(wLevel, sz, a, b, c, d, e, f) \
            debuglog6(wLevel, fDebugFilterAcb, sz, a, b, c, d, e, f)
#define debugACBPch(wLevel, pch, cch)\
            debuglogPch(wLevel, fDebugFilterAcb, pch, cch)
#define debugACBPwch(wLevel, pwch, cwch)\
            debuglogPwch(wLevel, fDebugFilterAcb, pwch, cwch)

// Toolbar debug log macros
#define debugEC0(wLevel, sz) \
            debuglog0(wLevel, fDebugFilterEc, sz)
#define debugEC1(wLevel, sz, a) \
            debuglog1(wLevel, fDebugFilterEc, sz, a)
#define debugEC2(wLevel, sz, a, b) \
            debuglog2(wLevel, fDebugFilterEc, sz, a, b)
#define debugEC3(wLevel, sz, a, b, c) \
            debuglog3(wLevel, fDebugFilterEc, sz, a, b, c)
#define debugEC4(wLevel, sz, a, b, c, d) \
            debuglog4(wLevel, fDebugFilterEc, sz, a, b, c, d)
#define debugEC5(wLevel, sz, a, b, c, d, e) \
            debuglog5(wLevel, fDebugFilterEc, sz, a, b, c, d, e)
#define debugEC6(wLevel, sz, a, b, c, d, e, f) \
            debuglog6(wLevel, fDebugFilterEc, sz, a, b, c, d, e, f)
#define debugECPch(wLevel, pch, cch)\
            debuglogPch(wLevel, fDebugFilterEc, pch, cch)
#define debugECPwch(wLevel, pwch, cwch)\
            debuglogPwch(wLevel, fDebugFilterEc, pwch, cwch)

// MSO Internal Event Monitor debug log macros
#define debugMsoEM0(wLevel, sz) \
            debuglog0(wLevel, fDebugFilterMsoEm, sz)
#define debugMsoEM1(wLevel, sz, a) \
            debuglog1(wLevel, fDebugFilterMsoEm, sz, a)
#define debugMsoEM2(wLevel, sz, a, b) \
            debuglog2(wLevel, fDebugFilterMsoEm, sz, a, b)
#define debugMsoEM3(wLevel, sz, a, b, c) \
            debuglog3(wLevel, fDebugFilterMsoEm, sz, a, b, c)
#define debugMsoEM4(wLevel, sz, a, b, c, d) \
            debuglog4(wLevel, fDebugFilterMsoEm, sz, a, b, c, d)
#define debugMsoEM5(wLevel, sz, a, b, c, d, e) \
            debuglog5(wLevel, fDebugFilterMsoEm, sz, a, b, c, d, e)
#define debugMsoEM6(wLevel, sz, a, b, c, d, e, f) \
            debuglog6(wLevel, fDebugFilterMsoEm, sz, a, b, c, d, e, f)
#define debugMsoEMPch(wLevel, pch, cch)\
            debuglogPch(wLevel, fDebugFilterMsoEm, pch, cch)
#define debugMsoEMPwch(wLevel, pwch, cwch)\
            debuglogPwch(wLevel, fDebugFilterMsoEm, pwch, cwch)

#if defined(DEBUG) ||  defined(STANDALONE)
#define DebugStandalone(e)      e
#else /* !(DEBUG ||  STANDALONE) */
#define DebugStandalone(e)
#endif /* DEBUG ||  STANDALONE */

MSOEXTERN_C_END     // ****************** End extern "C" *********************

#endif // !MSODBGLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\explorer\atlstuff.h ===
// atlstuff.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#pragma once

// Change these values to use different versions
#define _RICHEDIT_VER	0x0100

#define _ATL_NO_MP_HEAP

#pragma warning(disable: 4530)  // C++ exception handling

#include <atlbase.h>

extern CComModule _Module;


#include <atlcom.h>

#include <hlink.h>
#include <shellapi.h>
#include <shlobj.h>
#include <shlobjp.h>

#include <atlapp.h>
#include <atlwin.h>

#include <atlres.h>
#include <atlframe.h>
#include <atlgdi.h>
#include <atlctrls.h>
#include <atldlgs.h>
#include <atlcrack.h>
#include <atlmisc.h>
#include <atlctrlx.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\evtmon\inc\msoemtyp.h ===
/*****************************************************************************
    msoemtyp.h

    Owner: DaleG
    Copyright (c) 1997 Microsoft Corporation

    Typedef file for Rules Engine of Event Monitor.

*****************************************************************************/

#ifndef MSOEMTYP_H
#define MSOEMTYP_H

#ifndef MSO_H
#pragma message ("MsoEMTyp.h file included before Mso.h.  Including Mso.h.")
#include "mso.h"
#endif

MSOEXTERN_C_BEGIN   // ***************** Begin extern "C" ********************

#ifndef MSOCP_DEFINED
typedef long MSOCP;                                     // Character position
#define msocpNil ((MSOCP) -1)
#define msocp0 ((MSOCP) 0)
#define msocpMax ((MSOCP) 0x7FFFFFFF)
#define MSOCP_DEFINED
#endif /* !MSOCP_DEFINED */


// Define Bit Field type
typedef unsigned short MSOBF;


#if !defined(WORD_BUILD)  &&  !defined(WIN_CALLBACK)
#define WIN_CALLBACK    OFC_CALLBACK
#endif /* !WORD_BUILD */


// Character Byte Manipulators
#define MsoLowByteWch(w)      (unsigned char)((w) & 0x00ff)
#define MsoHighByteWch(w)     (unsigned char)(((WORD)(w) >> 8) & 0x00ff)

#ifndef cbXchar
#ifndef ANSI_XCHAR
typedef unsigned short XCHAR;
#define cbXchar    2

#else /* ANSI_XCHAR */

typedef unsigned char XCHAR;
#define cbXchar    1
#endif /* !ANSI_XCHAR */
#endif /* !cbXchar */

#ifndef ANSI_XCHAR

#define MsoLowByteXch(xch)      MsoLowByteWch(xch)
#define MsoHighByteXch(xch)     MsoHighByteWch(xch)
#define CchXsz(xsz)             MsoCchWzLen(xsz)
#define SzFromXsz(xszFrom, szTo) \
            MsoWzToSz(xszFrom, szTo)
#define CchCopyRgxchToRgch  MsoRgwchToRgch
#define CopyRgxchToRgch(pxchSrc, pchDest, pcch) \
            (*pcch = MsoRgwchToRgch(pxchSrc, *pcch, pchDest, 2 * (*pcch)))

#else /* ANSI_XCHAR */

#define MsoLowByteXch(xch)      (xch)
#define MsoHighByteXch(xch)     (0)
#define CchXsz(xsz)             MsoCchSzLen(xsz)
#define SzFromXsz(xszFrom, szTo) \
            strcpy(szTo, xszFrom)
#define CchCopyRgxchToRgch(rgchFrom, cchFrom, rgchTo, cchTo) \
            (PbCopyRgb((rgchFrom), (rgchTo), (cchFrom)), (cchFrom))
#define CopyRgxchToRgch(pxchSrc, pchDest, pcch) \
            memmove(pchDest, pxchSrc, *(pcch))

#endif /* !ANSI_XCHAR */

int FNeNcRgxch(const XCHAR *pxch1, const XCHAR *pxch2, int cch);


#if !WORD_BUILD  &&  !STANDALONE_WORD

typedef void *LPV;

// Split value struct. Overlays two shorts on long, byte-reversable indifferent
typedef struct _SV
    {
#ifndef MAC
    short                   wValue1;                    // Low, short
    short                   wValue2;                    // High, long
#else /* MAC */
    short                   wValue2;                    // High, long
    short                   wValue1;                    // Low, short
#endif /* !MAC */
    } SV;

// SV as seen as chars
typedef struct _SVC
    {
#ifndef MAC
    char                    ch1;                        // Low, 1st byte
    char                    ch2;                        // 2nd byte
    char                    ch3;                        // 3rd byte
    char                    ch4;                        // 4th byte
#else /* MAC */
    char                    ch3;                        // 3rd byte
    char                    ch4;                        // 4th byte
    char                    ch1;                        // Low, 1st byte
    char                    ch2;                        // 2nd byte
#endif /* !MAC */
    } SVC;

// SV unioned with long
typedef union _SVL
    {
    long                    lValue;                     // As long
    SV                      sv;                         // Split version
    SVC                     svc;                        // As chars
    } SVL;

#endif /* !WORD_BUILD  &&  !STANDALONE_WORD */


#ifndef NORULES
#include "emrule.h"
#include "emutil.h"
#include "emact.h"
#ifdef DYN_RULES
#include "emruloci.h"
#endif /* DYN_RULES */
#endif /* !NORULES */


#if defined(DEBUG)  &&  !defined(STANDALONE)

MSOAPI_(void) MsoInitEmMemMark(                         // Init EM Mem marking
    struct MSOINST     *hMsoInst,
    long                lparam,
    int                 bt
    );
MSOAPI_(void) MsoMarkEmPv(void *pv);                    // Mark EM Memory

#else /* !DEBUG  ||  STANDALONE */

#define MsoInitEmMemMark(hMsoInst, lparam, bt)
#define MsoMarkEmPv(pv)

#endif /* DEBUG  &&  !STANDALONE */

MSOEXTERN_C_END     // ****************** End extern "C" *********************

#endif /* !MSOEMTYP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\evtmon\inc\msolex.h ===
/******************************************************************************
    MSOLEX.H

    Owner: smueller
    Copyright (c) 1997 Microsoft Corporation

    General Purpose Text Lexer definitions and prototypes

    There are currently multiple instances of this component in Office 9.
    Keep them in sync:
        %mso%\inc\msolex.h
        %otools%\src\em\emtest\msolex.h
        %ppt%\office\lexpp.h
        %word%\src\inc\lex.h

    FUTURE: some of these definitions don't need to be exported and could
    live in an msolex.i file.
******************************************************************************/

#ifndef MSOLEX_H
#define MSOLEX_H


/*----------------------------------------------------------------------------
    Enabled features
----------------------------------------------------------------------------*/

#define EM_MULT_DIM_SCAN


/*----------------------------------------------------------------------------
    System limits
----------------------------------------------------------------------------*/

#define ichTkLenMax         256                         // Max token str len
#define ichLexsCacheMax     (ichTkLenMax - 1)           // Mx num chars cached

#define dirultkNotFound     30000                       // arbitrarily lg. flag
#define dtkNotFound         dirultkNotFound             // alias


/*************************************************************************
    Types:

    tk          Token returned by the lexer.
    lexs        Lexer state structure.

 *************************************************************************/


// Define state tables used by lexer (use with plexs->isttbl)
#define isttblDefault   0                               // Default MUST be 0
#define isttblNoBlanks  1


/* T K */
/*----------------------------------------------------------------------------
    %%Structure: TK
    %%Contact: daleg

    Lexer token definitions.
----------------------------------------------------------------------------*/

#ifndef TK_DEFINED
// Definition of token type returned by lexer
typedef int TK;

#define TK_DEFINED
#endif /* !TK_DEFINED */


// Lexer tokens: Plain Text and Delimiters
#define tk_RESCAN_      (-2)                            // Dummy: force rescan
#define tkERROR         (-1)                            // Lexer error
#define tkNil           0                               // No token at all
#define tkEND_OBJ       1                               // End of object
#define tkPARA          2                               // 0xB6 (Para mark)
#define tkNEWLINE       3                               // \n
#define tkWSPC          4                               // Blanks, tabs
#define tkWSPCMULT      5                               // Multiple Blanks
#define tkTAB           6                               // Tab character
#define tkWORD          7                               // E.g. abc
#define tkINTEGER       8                               // E.g. 123
#define tkCOMMA         9                               // ,
#define tkPERIOD        10                              // .
#define tkEXCLAIM       11                              // !
#define tkPOUND         12                              // #
#define tkDOLLAR        13                              // $
#define tkPERCENT       14                              // %
#define tkAMPER         15                              // &
#define tkLPAREN        16                              // (
#define tkRPAREN        17                              // )
#define tkASTER         18                              // *
#define tkPLUS          19                              // +
#define tkMINUS         20                              // -
#define tkSLASH         21                              // /
#define tkCOLON         22                              // :
#define tkSEMI          23                              // ;
#define tkLESSTHAN      24                              // <
#define tkEQUAL         25                              // =
#define tkGREATER       26                              // >
#define tkQUEST         27                              // ?
#define tkATSIGN        28                              // @
#define tkLBRACK        29                              // [
#define tkRBRACK        30                              // ]
#define tkBSLASH        31                              // \ 
#define tkCARET         32                              // ^
#define tkUSCORE        33                              // _
#define tkBQUOTE        34                              // `
#define tkLBRACE        35                              // {
#define tkRBRACE        36                              // }
#define tkVBAR          37                              // |
#define tkTILDA         38                              // ~
#define tkDQUOTE        39                              // "
#define tkLDQUOTE       40                              // " left curly dbl
#define tkRDQUOTE       41                              // " right curly dbl
#define tkQUOTE         42                              // '
#define tkLQUOTE        43                              // ' left curly sgl
#define tkRQUOTE        44                              // ' right curly sgl
#define tkLCHEVRON      45                              // << French LDQuote
#define tkRCHEVRON      46                              // >> French RDQuote
#define tkENDASH        47                              // - en-dash
#define tkEMDASH        48                              // -- em-dash

// Lexer tokens: Plain-Text Symbol tokens
#define tkSYMBOL        49                              // Symbol char
#define tkBULLET        50                              // Std bullet char
#define tkFEWORD        51                              // FE word
#define tkFESYMBOL      52                              // FE symbol char
#define tkFESPACE       53                              // FE Space char

// Lexer tokens: Plain-text formatting info
#define tkSTARTCAP      54                              // Word is capitalized
#define tkALLCAPS       55                              // Word is all caps
#define tkHASCAPS       56                              // Word has 1+ CAPs


// Is TK valid (not tkNil and not tkERROR)
#define FValidTk(tk) \
            ((tk) > 0)



/* M  S  O  L  E  X  S */
/*----------------------------------------------------------------------------
    %%Structure: MSOLEXS
    %%Contact: daleg

    AutoFormat LEX State

    Contains information about the Event Monitor lexer's current position
    in the document.

    This information is initialized by LexReset(), and advanced by other
    lexer APIs.
----------------------------------------------------------------------------*/

// Callback typedefs
typedef XCHAR (OFC_CALLBACK *PFNLEXBUF)(MSOCP cpLim, struct _MSOLEXS *plexs);
typedef int (OFC_CALLBACK *PFNLEXRUN)(MSOCP cpLim, struct _MSOLEXS *plexs);
typedef int (OFC_CALLBACK *PFNLEXTXT)
    (MSORULTK *prultk, const XCHAR **ppxch, int *pcch, struct _MSOLEXS *plexs);
typedef void (OFC_CALLBACK *PFNLEXFMT)
    (int *pfForceTkBreak, struct _MSOLEXS *plexs);
typedef int (OFC_CALLBACK *PFNLEXCNT)(struct _MSOLEXS *plexs);


typedef struct _MSOLEXS
    {
    // --- values requiring initialization ---

    // Keyword lookup information
    struct _MSOKWTB    *pkwtb;                          // Keyword-lookup tbl

    // Token-history cache information
    MSORULTKH           rultkhToken;                    // Text Token cache

    // Formatting token-history cache information
    MSORULTKH           rultkhFormat;                   // Format Token cache

    // Init state
    MSOBF               fInited : 1;                    // Lexer inited?
    int                 isttbl;                         // Which STT?
    union
        {
        unsigned short  grpfLexFlags;
        struct
            {
            MSOBF       fNoReset : 1;                   // Reset leave alone
            MSOBF       fLookup : 1;                    // Lookup name as kwd?
            MSOBF       fLookupIntsAndSyms : 1;         // Lookup ints as kwd?
            MSOBF       fAllCapsAsFormat : 1;           // ALLCAPS as fmt tk?
            MSOBF       fRefetchOnOverscan : 1;         // Force fetch on OS?
            MSOBF       fSpare2 : 11;
            };
        };

    // Buffer management callback functions
    void               *hObjectNil;                     // Nil object
    PFNLEXBUF           pfnlexbuf;                      // Fetch next buffer
    PFNLEXRUN           pfnlexrun;                      // Fetch next run
    PFNLEXTXT           pfnlextxt;                      // Fetch token text
    PFNLEXFMT           pfnlexfmt;                      // Gen format tokens
    PFNLEXCNT           pfnlexrunDiscontig;             // Next run contiguous?
    PFNLEXRUN           pfnlexrunForceComplete;         // Force tk to complete

    // Run state information
    int                 ichRun;                         // Index to vfli.rgch
    int                 cchLookahead;                   // Num chars lookahead

    // --- values initially zero ---

    // Run state information
    int                 cchRemain;                      // Num chars unlexed
    MSOCP               cpRun;                          // CP of start of run
    MSOCP               ccpRun;                         // Num of CPs in run
    MSOCP               cpObject;                       // CP of start of obj
    int                 cchRun;                         // Num chars run

    // Token state information
    MSOCP               cpTokenFirst;                   // CP of first char
    MSOCP               dcpToken;                       // Num CPs in token
    MSOCP               cpTokenNext;                    // CP of next token
    int                 tkTokenIndirect;                // Indirect token
    int                 ichTokenFirst;                  // ich of first char
    const XCHAR        *pxchTkStart;                    // First char in token
    const XCHAR        *pxchNext;                       // Next char to lex
    const XCHAR        *pxchRun;                        // First char of run
    const XCHAR        *pxchBuffer;                     // Token string buffer
    const XCHAR        *pxchBufferIp;                   // Buffer of obj at IP
    union
        {
        unsigned short  grfCurTk;
        struct
            {
            MSOBF       fMustSyncLexDocBuffer : 1;      // Reset lexer?
            };
        };

    // Vanished/Created text handling
#ifdef EM_LEX_VANISHED
    MSOCP               cpFirstVanished;                // CP of vanished
    MSOCP               dcpVanished;                    // dcp of vanished txt
#endif /* EM_LEX_VANISHED */
    MSOCP               cpFirstCreated;                 // CP of created
    MSOCP               dcpCreated;                     // dcp of created txt
    union
        {
        unsigned short  grpfLineFlags;
        struct
            {
            MSOBF       fAdjustTokenCps : 1;            // Created/Vanished txt
            };
        };

    // Lexer state information
    int                 ichCache;                       // Num chars cached
    XCHAR               rgxchCache[ichTkLenMax];        // Cache leading chars
    XCHAR               rgxchHistToken[ichTkLenMax];    // Text of history tk
    void               *pObject;                        // Current object(cell)
    void               *pObjectIp;                      // Object at IP
#ifdef EM_MULT_DIM_SCAN
    long                iCol;                           // Column of cell
    long                iRow;                           // Row of cell
    long                iColIp;                         // Column of IP
    long                iRowIp;                         // Row of IP
    int                 dcellScanToIp;                  // #rows/cols 2 prescan
    int                 iScanDirection;                 // 0 == row, 1 == col
#endif /* EM_MULT_DIM_SCAN */
    MSOCP               cpFirst;                        // CP start of scan
    MSOCP               cpLim;                          // CP limit of scan
    MSOCP               cpFirstDoc;                     // CP limit of scan
    MSOCP               cpMacDoc;                       // CP limit of scan
    long                wInterval;                      // Count of intervals

    // Format lexer state information
    union
        {
        unsigned long   grpfFormatFlags;
        struct
            {
            MSOBF       fBold : 1;                      // Is text bold?
            MSOBF       fItalic : 1;                    // Is text italic?
            MSOBF       fUnderline : 1;                 // Is text underlined?
            MSOBF       fVanish : 1;                    // Is text hidden?
            MSOBF       ico : 5;                        // Is text colored?
            MSOBF       fSpareFmt : 7;
            };
        };
    union
        {
        unsigned short  grpfEndFlags;
        struct
            {
            MSOBF       fCreateEndObjCh : 1;            // Create EOO tk?
            MSOBF       fEOL : 1;                       // End of line?
            MSOBF       fEOP : 1;                       // End of paragraph?
            };
        };

    // Asynchronous lexer support
    unsigned short      iuState;                        // Async state
    MSOBF               fInvalLexer : 1;                // Lexer not synched?
    MSOBF               fBufferAlloced : 1;             // Obj buffer alloced?
    MSOBF               fAsyncSpare4 : 14;
    MSOCP               cpIp;                           // CP of IP if forced

    // Multiple lexical scan support
    MSOBF               fDynAlloced : 1;                // struct alloced?
    MSOBF               fTkCacheDynAlloced : 1;         // TK Cache alloced?
    MSOBF               fFmtTkCacheDynAlloced : 1;      // Format Che alloced?
    struct _MSOLEXS    *plexsNext;                      // Next struct LIFO

    // App-specific goo
    void               *pUserData;                      // Cast as desired
    } MSOLEXS;


// grpfLexFlags
#define MsoGrfLexFNoReset               (1 << 0)
#define MsoGrfLexFLookup                (1 << 1)
#define MsoGrfLexFLookupIntsAndSyms     (1 << 2)
#define MsoGrfLexFAllCapsAsFormat       (1 << 3)
#define MsoGrfLexFRefetchOnOverscan     (1 << 4)


extern unsigned short const **vppchtblCharTrans;        // Ptr to lexer ch tbl


#ifdef EM_MULT_DIM_SCAN
#define iScanVert       0
#define iScanHoriz      1
#endif /* EM_MULT_DIM_SCAN */

// Return the object the lexer is currently scanning
#define PobjectLexToken(plexs) \
            ((plexs)->pObject)

// Return the current lexer token starting CP value
#define CpLexTokenFirst(plexs) \
            ((plexs)->cpTokenFirst)

// Set the current lexer token starting CP value
#define SetCpLexTokenFirst(plexs, cp) \
            ((plexs)->cpTokenFirst = (cp))

// Return the next lexer token starting CP value
#define CpLexTokenNext(plexs) \
            ((plexs)->cpTokenNext)

// Set the next lexer token starting CP value
#define SetCpLexTokenNext(plexs, cp) \
            ((plexs)->cpTokenNext = (cp))

// Get the current lexer token dCP (length of CPs consumed)
#define DcpLexToken(plexs) \
            ((plexs)->dcpToken)

// Set the current lexer token dCP (length of CPs consumed)
#define SetDcpLexToken(plexs, dcp) \
            ((plexs)->dcpToken = (dcp))

// Update the current lexer token dCP (length of CPs consumed)
#define UpdateDcpLexToken(plexs, dcp) \
            IncrDcpLexToken(plexs, dcp)

// Update the current lexer token dCP (length of CPs consumed)
#define IncrDcpLexToken(plexs, dcp) \
            ((plexs)->dcpToken += (dcp))

#ifndef EM_LEX_VANISHED
// Update the current lexer token dCP (length of CPs consumed)
#define ClearDcpLexToken(plexs) \
            SetDcpLexToken(plexs, 0L)

#else /* EM_LEX_VANISHED */

// Update the current lexer token dCP (length of CPs consumed)
#define ClearDcpLexToken(plexs) \
            (SetDcpLexToken(plexs, 0L), \
             plexs->cpFirstVanished = 0L, \
             plexs->dcpVanished = 0L)
#endif /* !EM_LEX_VANISHED */


// Return the current lexer token *running* dCP (length of CPs consumed)
#define DcpLexCurr(plexs) \
            (DcpLexToken(plexs) + CchTokenLen(plexs))

// Return the current lexer CP value
#define CpLexCurr(plexs) \
            (CpLexTokenFirst(plexs) + DcpLexToken(plexs))

// Is this the last run, period?
#define FLexEndOfScan(plexs) \
            ((plexs)->cpRun + (plexs)->ccpRun >= (plexs)->cpLim)

#define CchTokenLen(plexs) \
            (CchTokenUncachedLen(plexs) + (plexs)->ichCache)
#define CchTokenUncachedLen(plexs) \
            ((plexs)->pxchNext - (plexs)->pxchTkStart)

// Return the index of the start of curr tk into line buffer (vfli.lrgxch)
#define IchLexTkFirst(plexs) \
            ((plexs)->pxchTkStart - (plexs)->pxchBuffer)

// Encode a relative TK index as an absolute number
#define _IrultkTokenAbsEncoded(plexs, dirultk) \
            ((plexs)->rultkhToken.irultkAbsBase \
                + (plexs)->irultkLim + (dirultk))

// Mark that the lexer must reset on next char typed
#define InvalLex(plexs) \
            ((plexs)->cchLookahead = -1)

// Return whether the lexer must reset on next char typed
#define FInvalLex(plexs) \
            ((plexs)->cchLookahead < 0)


// Mark lexer as probably out of synch with app buffer
#define InvalLexFetch(plexs) \
            ((plexs)->cchRemain = 0, \
             (plexs)->fInvalLexer = fTrue)

// Return whether lexer out of synch with app buffer
#define FInvalLexFetch(plexs) \
            ((plexs)->fInvalLexer)



/*************************************************************************
    Token History Cache
 *************************************************************************/

// Token-history cache access
#define PrultkFromTokenIrultk(plexs, irultk) \
            PrultkFromIrultk(irultk, (plexs)->rultkhToken.rgrultkCache)

// Increment pointer to token-history cache access
#define IncrTokenPrultk(plexs, pprultk, pirultkPrev) \
            IncrPrultk(pprultk, pirultkPrev, \
                        (plexs)->rultkhToken.rgrultkCache, \
                        (plexs)->rultkhToken.irultkMac)

// Decrement pointer to token-history cache access
#define DecrTokenPrultk(plexs, pprultk, pirultkPrev) \
            DecrPrultk(pprultk, pirultkPrev, \
                        (plexs)->rultkhToken.rgrultkCache, \
                        (plexs)->rultkhToken.irultkMac)

// Increment index to token-history cache access
#define IncrTokenPirultk(plexs, pirultk, dirultk) \
            IncrPirultk(pirultk, dirultk, (plexs)->rultkhToken.irultkMac)

// Increment index to token-history cache access
#define DecrTokenPirultk(plexs, pirultk, dirultk) \
            DecrPirultk(pirultk, dirultk, (plexs)->rultkhToken.irultkMac)

// Fill in next tk cache record even if incomplete.
#define _CacheTkTextNext(plexs) \
            { \
            MSORULTK   *prultk; \
            int         cchPartialTk = (plexs)->cchLookahead; \
             \
            prultk = PrultkFromTokenIrultk((plexs), \
                                           (plexs)->rultkhToken.irultkLim); \
            prultk->pObject = plexs->pObject; \
            prultk->cpFirst = CpLexTokenFirst(plexs); \
            prultk->dcp = DcpLexCurr(plexs) + cchPartialTk; \
            prultk->ich = (plexs)->pxchTkStart - (plexs)->pxchBuffer; \
            prultk->dich = CchTokenLen(plexs) + cchPartialTk; \
            prultk->wInterval = (plexs)->wInterval; \
            prultk->tk = tkNil; \
            }


/*************************************************************************
    Formatting Token History Cache
 *************************************************************************/

// Format token-history cache access
#define PrultkFormatFromIrultk(plexs, irultk) \
            PrultkFromIrultk(irultk, (plexs)->rultkhFormat.rgrultkCache)

// Increment pointer to Format token-history cache access
#define IncrFormatPrultk(plexs, pprultk, pirultkPrev) \
            IncrPrultk(pprultk, pirultkPrev, \
                       (plexs)->rultkhFormat.rgrultkCache, \
                       (plexs)->rultkhFormat.irultkMac)

// Increment pointer to Format token-history cache access
#define DecrFormatPrultk(plexs, pprultk, pirultkPrev) \
            DecrPrultk(pprultk, pirultkPrev, \
                        (plexs)->rultkhFormat.rgrultkCache, \
                        (plexs)->rultkhFormat.irultkMac)

// Increment index to Format token-history cache access
#define IncrFormatPirultk(pirultk, dirultk) \
            IncrPirultk(pirultk, dirultk, (plexs)->rultkhFormat.irultkMac)

// Increment index to Format token-history cache access
#define DecrFormatPirultk(pirultk, dirultk) \
            DecrPirultk(pirultk, dirultk, (plexs)->rultkhFormat.irultkMac)



/*************************************************************************
    Prototypes and macros for lex.c
 *************************************************************************/


// Get the next character from the input buffer
#define XchLexGetChar(plexs, cpLim) \
            ((plexs)->cchRemain-- > 0\
                ? *(plexs)->pxchNext++ \
                : XchLexGetNextBuffer(cpLim, plexs))

// Get the next input buffer
#define XchLexGetNextBuffer(cpLim, plexs) \
            ((*(plexs)->pfnlexbuf)(cpLim, plexs))

// Return last char to input buffer
#ifndef AS_FUNCTION
#define LexUngetChar(plexs, cch) \
            ((plexs)->pxchNext -= cch, (plexs)->cchRemain += cch)
#else
void LexUngetChar(MSOLEXS *plexs, int cch);
#endif /* !AS_FUNCTION */

// Peek at the next character from the input buffer
#define XchLexPeekChar(plexs) \
            ((plexs)->cchRemain > 0 \
                ? *(plexs)->pxchNext \
                : (XchLexGetNextBuffer(msocpMax, plexs), (plexs)->cchRemain++,\
                        *(--(plexs)->pxchNext)))

// Number of bytes to copy if we are "peeking" at next char via lexer
#define cbLexsPeek  (offset(MSOLEXS, ichCache))

// Define (CH)aracter Translation (T)a(BL)e
typedef unsigned short ISTT;                            // Col index to Lex STT
typedef ISTT const *CHTBL;                              // Char trans table
#ifndef VIEWER

// Definition of size of State Transition Table
#define WSttblNumRows       5                           // Num rows in Sttbl
#define WSttblNumCols       15                          // Num cols in Sttbl

typedef unsigned short const STTBL [WSttblNumCols];     // State trans table

extern unsigned short const rgsttblWsIndirect[WSttblNumRows][WSttblNumCols];
extern unsigned short const rgsttblWsDirect[WSttblNumRows][WSttblNumCols];

extern CHTBL _rgchtblNormal[256];                       // Normal ch trans tbl

// Based pointer to current Character Transition Table
extern CHTBL const *vpchtblCharTrans;                   // Curr ch trans table


// Translate a character into a column in the lexer STTBL
#define IsttFromXch(xch)    \
            vpchtblCharTrans[MsoHighByteXch(xch)][MsoLowByteXch(xch)]
#endif // !VIEWER


// Define Delimiter Lookup table
extern TK const * Win(const) vrgptkCharToken[256];

// Return delimiter token associated with character
#define TkDelimFromXch(xch) \
            vrgptkCharToken[MsoHighByteXch(xch)][MsoLowByteXch(xch)]


// Map a STT column index into a Character token value
extern TK vmpistttkCh[];



MSOAPI_(TK) MsoTkLexText(MSOLEXS *plexs);               // Get next token
MSOAPI_(TK) MsoTkLexTextCpLim(                          // Get next tk < CP
    MSOLEXS            *plexs,
    MSOCP               cpLim
    );
MSOAPI_(int) MsoFLexTokenCh(MSOLEXS *plexs, XCHAR xch); // Token ready?
void SetLexTokenLim(MSOLEXS *plexs);                    // Set token Lim
MSOCP DcpLexCurrAdjusted(MSOLEXS *plexs);               // Return dCP used
MSOAPI_(XCHAR) MsoWchLexGetNextBufferDoc(               // Reload char buf
    MSOCP               cpLim,
    MSOLEXS            *plexs
    );
void ForceLexEOF(void);                                 // FUTURE: Force EOF
MSOAPI_(MSOLEXS *) MsoPlexsLexInitDoc(                  // Init from doc
    MSOLEXS            *plexs,
    void               *hObjectNil,
    PFNLEXRUN           pfnlexrun,
    PFNLEXTXT           pfnlextxt,
    PFNLEXFMT           pfnlexfmt,
    PFNLEXCNT           pfnlexrunDiscontig,
    int                 irultkTokenMac,
    int                 irultkFormatMac
    );
#ifdef DEBUG
MSOAPI_(void) MsoAssertPlexsInitDoc(                    // Ensure doc init
    MSOLEXS            *plexs,
    void               *hObjectNil,
    PFNLEXRUN           pfnlexrun,
    PFNLEXTXT           pfnlextxt,
    PFNLEXFMT           pfnlexfmt,
    PFNLEXCNT           pfnlexrunDiscontig,
    int                 irultkTokenMac,
    int                 irultkFormatMac
    );
#endif // DEBUG
MSOAPI_(void) MsoLexSetPos(                             // Reposition in file
    MSOLEXS            *plexs,
    MSOCP               cpFirst,
    MSOCP               cpLim
    );
MSOAPI_(XCHAR) MsoWchLexGetNextBufferPxch(              // Gen EOF for rgch
    MSOCP               cpLim,
    MSOLEXS            *plexs
    );
MSOAPI_(MSOLEXS *) MsoPlexsLexInitPxch(                 // Init from rgch
    MSOLEXS            *plexs,
    XCHAR              *pxch,
    int                 cch,
    PFNLEXBUF           pfnlexbuf,
    int                 irultkTokenMac,
    int                 irultkFormatMac
    );
#ifdef DEBUG
MSOAPI_(void) MsoAssertPlexsInitPxch(                   // Ensure rgch init
    MSOLEXS            *plexs,
    XCHAR              *pxch,
    int                 cch,
    PFNLEXBUF           pfnlexbuf,
    int                 irultkTokenMac,
    int                 irultkFormatMac
    );
#endif // DEBUG
void LexFinishPch(void);                                // Complete rgch scan
STTBL *PsttblFromIsttbl(int isttbl);                    // table ptr from index
MSOLEXS *PlexsNew(void);                                // Alloc new MSOLEXS
MSOLEXS *PlexsInitLex(                                  // Init lexer memory
    MSOLEXS            *plexs,
    int                 irultkTokenMac,
    int                 irultkFormatMac
    );
#ifdef DEBUG
void AssertPlexsInit(                                   // Ensure lexer memory
    MSOLEXS            *plexs,
    int                 irultkTokenMac,
    int                 irultkFormatMac
    );
#endif
MSOAPI_(void) MsoResetLexState(                         // Reset lexer state
    MSOLEXS            *plexs,
    int                 fFullReset
    );
MSOAPI_(void) MsoFreeLexMem(MSOLEXS *plexs);            // Free lexer memory
#if defined(DEBUG)  &&  !defined(STANDALONE)
MSOAPI_(void) MsoMarkLexMem(MSOLEXS *plexs);            // Mark lexer mem used
#endif // DEBUG  &&  !STANDALONE
int FResetLexDocBuffer(                                 // Reset cpObject
    void               *pObject,
    MSOCP               cpObject,
    MSOCP               cpScan,
    MSOCP              *pcpObject                       // RETURN
    );

// Return token associated with string by looking up in keyword table
#define TkLookupNameLexs(pxchStr, cchLen, plexs) \
            MsoTkLookupName((pxchStr), (cchLen), (plexs)->pkwtb)

// Return token associated with string by looking up in keyword table
#define PkwdLookupNameLexs(pxchStr, cchLen, plexs) \
            MsoPkwdLookupName((pxchStr), (cchLen), (plexs)->pkwtb)

// Add a keyword to the lexer lookup table
#define PkwdAddTkLookupNameLexs(pxchStr, cchLen, tk, plexs, fCopyStr) \
            MsoPkwdAddTkLookupName((pxchStr), (cchLen), (tk), (plexs)->pkwtb,\
                                   (fCopyStr))

// Remove a keyword from the lexer lookup table
#define FRemoveTkLookupNameLexs(pxchStr, cchLen, plexs, ptk) \
            MsoFRemoveTkLookupName((pxchStr), (cchLen), (plexs)->pkwtb, (ptk))

void AppendRultkFormat(                                 // Append format token
    MSOLEXS            *plexs,
    TK                  tk,
    int                 dcp,
    long                lValue
    );
void InsertRultkFormat(                                 // Insert format token
    MSOLEXS            *plexs,
    TK                  tk,
    MSOCP               cp,
    long                lValue
    );
MSOAPI_(void) MsoCacheTkText(                           // Save text tokens
    MSOLEXS            *plexs,
    TK                  tk,
    long                lValue
    );
MSOAPI_(int) MsoCchTokenText(                           // Return token text
    MSOLEXS            *plexs,
    int                 dtk,
    const XCHAR       **ppxch                           // RETURN
    );
#define TokenLen(plexs, dtk) \
            MsoCchTokenText((plexs), (dtk), NULL)
MSOAPI_(MSOCA *) MsoPcaOfDtk(                           // Get CA of tk range
    MSOCA              *pca,
    int                 dtkStart,
    int                 dtk,
    MSOLEXS            *plexs
    );
MSOAPI_(MSOCA *) MsoPcaOfDtkExclusive(                  // Get CA inside tk rg
    MSOCA              *pca,
    int                 dtkStart,
    int                 dtk,
    MSOLEXS            *plexs
    );
#ifdef NEVER
int CchCopyTextOfDtk(                                   // Return mult tk text
    int                 dtkStart,
    int                 dtk,
    XCHAR              *rgxch,                          // IN, RETURN
    int                 cchMax,
    int                 fPartialTkOK
    );
#endif // NEVER
MSOAPI_(long) MsoLFromDtk(                              // Get integer value
    MSOLEXS            *plexs,
    int                 dtk,
    int                 fCheckForSign
    );
long LFromPxch(                                         // Convert str to long
    const XCHAR        *pxch,
    int                 cch,
    int                *pfOverflow
    );
int FUpperXch(XCHAR xch);                               // Char uppercase?
int FLowerXch(XCHAR xch);                               // Char lowercase?

#ifdef NEVER
int OFC_CALLBACK DxaOfDirultk(                          // Return tk coord,len
    int                 dtk,
    int                *pdxaLen                         // RETURN: optional
    );

TK TkFromXch(XCHAR xch);                                // Return tk from a ch
TK TkFromXchNoLookup(XCHAR xch);                        // Return tk from ch
XCHAR *PxchTkStartFromPxchReverse(XCHAR *, XCHAR *);
int FXchEndsTk(XCHAR);                                  // Does this xch end a tk?
TK TkFromChIsttbl(XCHAR xch, int isttbl);               // Return a tk from a char
int OFC_CALLBACK DtkCacheTkTextToCp(                    // Fill Text TK cache
    int                 dtk,
    MSOCP               cpLim,
    int                 fForce
    );
#endif // NEVER
void CopyTkTextToCache(MSOLEXS *plexs);                 // Flush pend lex text



#if defined(DEBUG)  ||  defined(STANDALONE)
char *SzFromPch(                                        // Temp make string
    const char         *pchStr,
    int                 cchLen,
    char               *rgchStrBuf
    );
XCHAR *XszFromPxch(                                     // Temp make string
    const XCHAR        *pxchStr,
    int                 cchLen,
    XCHAR              *rgxchStrBuf
    );
#ifndef STANDALONE
char *SzFromPxch(                                       // Temp make string
    const XCHAR        *pxchStr,
    int                 cchLen,
    char               *rgchStrBuf
    );
#else /* STANDALONE */
#define SzFromPxch(p1,p2,p3) SzFromPch(p1, p2, p3)
#endif /* !STANDALONE */
#endif // DEBUG  ||  STANDALONE


/*************************************************************************
    Utilities
 *************************************************************************/

#ifndef FAREAST
#define FWhitespaceXch(xch) \
            ((xch) == ' '  ||  (xch) == '\t'  ||  (xch) == xchColumnBreak)
#else /* FAREAST */
#define FWhitespaceXch(xch) \
            ((xch) == ' '  ||  (xch) == '\t'  ||  (xch) == xchColumnBreak \
                ||  (xch) == wchSpace)
#endif /* FAREAST */



/*************************************************************************
    Prototypes and macros for Debugging and Error Handling
 *************************************************************************/

const XCHAR *PxchLexTokenText(                          // Return tk text, len
    MSOLEXS            *plexs,
    int                *pwLen);
#ifdef DEBUG
MSOAPI_(XCHAR *) MsoLxszLexTokenText(MSOLEXS *plexs);   // Return token text
MSOAPI_(CHAR *) MsoSzLexTokenText(MSOLEXS *plexs);      // Return token sz
#endif // DEBUG

#endif // MSOLEX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\explorer\bandsite.cpp ===
#include "cabinet.h"
#include "rcids.h"
#include <shguidp.h>
#include "bandsite.h"
#include "shellp.h"
#include "shdguid.h"
#include "taskband.h"
#include "taskbar.h"
#include <regstr.h>
#include "util.h"

extern IStream *GetDesktopViewStream(DWORD grfMode, LPCTSTR pszName);

HRESULT PersistStreamLoad(IStream *pstm, IUnknown *punk);
HRESULT PersistStreamSave(IStream *pstm, BOOL fClearDirty, IUnknown *punk);

const TCHAR c_szTaskbarWinXP[] = TEXT("TaskbarWinXP");
const TCHAR c_szTaskbar[] = TEXT("Taskbar");

// {69B3F106-0F04-11d3-AE2E-00C04F8EEA99}
static const GUID CLSID_TrayBandSite = { 0x69b3f106, 0xf04, 0x11d3, { 0xae, 0x2e, 0x0, 0xc0, 0x4f, 0x8e, 0xea, 0x99 } };

// {8B4A02DB-97BB-4C1B-BE75-8827A7358CD0}
static const GUID CLSID_TipBand = { 0x8B4A02DB, 0x97BB, 0x4C1B, { 0xBE, 0x75, 0x88, 0x27, 0xA7, 0x35, 0x8C, 0xD0 } };


class CTrayBandSite : public IBandSite
                    , public IClassFactory
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IBandSite methods ***
    STDMETHOD(AddBand)          (THIS_ IUnknown* punk);
    STDMETHOD(EnumBands)        (THIS_ UINT uBand, DWORD* pdwBandID);
    STDMETHOD(QueryBand)        (THIS_ DWORD dwBandID, IDeskBand** ppstb, DWORD* pdwState, LPWSTR pszName, int cchName) ;
    STDMETHOD(SetBandState)     (THIS_ DWORD dwBandID, DWORD dwMask, DWORD dwState) ;
    STDMETHOD(RemoveBand)       (THIS_ DWORD dwBandID);
    STDMETHOD(GetBandObject)    (THIS_ DWORD dwBandID, REFIID riid, void ** ppvObj);
    STDMETHOD(SetBandSiteInfo)  (THIS_ const BANDSITEINFO * pbsinfo);
    STDMETHOD(GetBandSiteInfo)  (THIS_ BANDSITEINFO * pbsinfo);

    // *** IClassFactory methods ***
    HRESULT STDMETHODCALLTYPE CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
    {
        if (pUnkOuter != NULL)
            return CLASS_E_NOAGGREGATION;

        return QueryInterface(riid, ppvObj);
    }
    HRESULT STDMETHODCALLTYPE LockServer(BOOL fLock)
    {
        return S_OK;
    }
    
    IContextMenu3* GetContextMenu();
    void SetInner(IUnknown* punk);
    void SetLoaded(BOOL fLoaded) {_fLoaded = fLoaded;}
    BOOL HandleMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres);
    
protected:
    CTrayBandSite();
    virtual ~CTrayBandSite();

    BOOL _CreateBandSiteMenu(IUnknown* punk);
    HRESULT _AddRequiredBands();
    void _BroadcastExec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
    HRESULT _SetWindowTheme(LPWSTR pwzTheme);
    friend IBandSite* BandSite_CreateView();
    friend void BandSite_HandleDelayBootStuff(IUnknown* punk);
    friend void BandSite_Load();
    friend HRESULT BandSite_SetWindowTheme(IBandSite* pbs, LPWSTR pwzTheme);
    
    LONG _cRef;
    IUnknown *_punkInner;
    IBandSite *_pbsInner;

    // bandsite context menu
    IContextMenu3* _pcm;
    HWND _hwnd;
    BOOL _fLoaded;
    BOOL _fDelayBootStuffHandled;
    DWORD _dwClassObject;
    WCHAR* _pwzTheme;
};

CTrayBandSite* IUnknownToCTrayBandSite(IUnknown* punk)
{
    CTrayBandSite* ptbs;
    
    punk->QueryInterface(CLSID_TrayBandSite, (void **)&ptbs);
    ASSERT(ptbs);
    punk->Release();

    return ptbs;
}

CTrayBandSite::CTrayBandSite() : _cRef(1)
{
}

CTrayBandSite::~CTrayBandSite()
{
    if (_pcm)
        _pcm->Release();

    if (_pwzTheme)
        delete[] _pwzTheme;
    
    return;
}

ULONG CTrayBandSite::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CTrayBandSite::Release()
{
    ASSERT(_cRef > 0);
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    _cRef = 1000;               // guard against recursion
    
    if (_pbsInner) 
    {
        AddRef();
        _pbsInner->Release();
    }
    
    // this must come last
    if (_punkInner)
        _punkInner->Release();  // paired w/ CCI aggregation
    
    ASSERT(_cRef == 1000);

    delete this;
    return 0;
}

HRESULT CTrayBandSite::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CTrayBandSite, IBandSite),
        QITABENT(CTrayBandSite, IClassFactory),
        { 0 },
    };

    HRESULT hr = QISearch(this, qit, riid, ppvObj);

    if (FAILED(hr) && IsEqualIID(riid, CLSID_TrayBandSite))
    {
        *ppvObj = this;
        AddRef();
        hr = S_OK;
    }

    if (FAILED(hr) && _punkInner)
    {
        hr = _punkInner->QueryInterface(riid, ppvObj);
    }

    return hr;
}


static BOOL CALLBACK SetTransparency(HWND hwnd, LPARAM lParam)
{
    SetWindowStyleEx(hwnd, WS_EX_TRANSPARENT, (BOOL)lParam);

    return TRUE;
}

// *** IBandSite methods ***

HRESULT CTrayBandSite::AddBand(IUnknown* punk)
{
    CLSID clsid;
    HRESULT hr = S_OK;

    if (!_fDelayBootStuffHandled)
    {
        //
        // Tell the band to go into "delay init" mode.  When the tray
        // timer goes off we'll tell the band to finish up.  (See
        // BandSite_HandleDelayBootStuff).
        //
        IUnknown_Exec(punk, &CGID_DeskBand, DBID_DELAYINIT, 0, NULL, NULL);
    }

    if (c_tray.GetIsNoToolbarsOnTaskbarPolicyEnabled())
    {
        hr = IUnknown_GetClassID(punk, &clsid);
        if (SUCCEEDED(hr))
        {
            hr = IsEqualGUID(clsid, CLSID_TaskBand) ? S_OK : E_FAIL;
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = _pbsInner->AddBand(punk);

        if (SUCCEEDED(hr))
        {
            IShellFolderBand *pisfBand;
            HRESULT hrInner = punk->QueryInterface(IID_PPV_ARG(IShellFolderBand, &pisfBand));
            if (SUCCEEDED(hrInner)) 
            {
                BANDINFOSFB bi;
                bi.dwMask = ISFB_MASK_STATE;
                hrInner = pisfBand->GetBandInfoSFB(&bi);
                if (SUCCEEDED(hrInner))
                {
                    bi.dwState |= ISFB_STATE_BTNMINSIZE;
                    hrInner = pisfBand->SetBandInfoSFB(&bi);
                }
                pisfBand->Release();
            }


            // tell the band to use the taskbar theme
            if (_pwzTheme)
            {
                VARIANTARG var;
                var.vt = VT_BSTR;
                var.bstrVal = _pwzTheme;
                IUnknown_Exec(punk, &CGID_DeskBand, DBID_SETWINDOWTHEME, 0, &var, NULL);
            }

            if (GetWindowLong(_hwnd, GWL_EXSTYLE) & WS_EX_TRANSPARENT)
            {
                EnumChildWindows(_hwnd, SetTransparency, (LPARAM)TRUE);
            }
        }
    }

    return hr;
}

HRESULT CTrayBandSite::EnumBands(UINT uBand, DWORD* pdwBandID)
{
    return _pbsInner->EnumBands(uBand, pdwBandID);
}

HRESULT CTrayBandSite::QueryBand(DWORD dwBandID, IDeskBand** ppstb, DWORD* pdwState, LPWSTR pszName, int cchName) 
{
    return _pbsInner->QueryBand(dwBandID, ppstb, pdwState, pszName, cchName);
}


HRESULT CTrayBandSite::SetBandState(DWORD dwBandID, DWORD dwMask, DWORD dwState) 
{
    return _pbsInner->SetBandState(dwBandID, dwMask, dwState);
}


HRESULT CTrayBandSite::RemoveBand(DWORD dwBandID)
{
    return _pbsInner->RemoveBand(dwBandID);
}


HRESULT CTrayBandSite::GetBandObject(DWORD dwBandID, REFIID riid, void ** ppvObj)
{
    return _pbsInner->GetBandObject(dwBandID, riid, ppvObj);
}

HRESULT CTrayBandSite::SetBandSiteInfo (const BANDSITEINFO * pbsinfo)
{
    return _pbsInner->SetBandSiteInfo(pbsinfo);
}

HRESULT CTrayBandSite::GetBandSiteInfo (BANDSITEINFO * pbsinfo)
{
    return _pbsInner->GetBandSiteInfo(pbsinfo);
}

HRESULT CTrayBandSite::_AddRequiredBands()
{
    IDeskBand* pdb;
    HRESULT hr = CoCreateInstance(CLSID_TaskBand, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IDeskBand, &pdb));
    if (SUCCEEDED(hr))
    {
        hr = AddBand(pdb);
        pdb->Release();
    }

    return hr;
}

HRESULT CTrayBandSite::_SetWindowTheme(LPWSTR pwzTheme)
{
    if (_pwzTheme)
    {
        delete[] _pwzTheme;
        _pwzTheme = NULL;
    }

    if (pwzTheme)
    {
        int iLen = lstrlen(pwzTheme);
        _pwzTheme = new WCHAR[iLen + 1];
        if (_pwzTheme)
        {
            lstrcpy(_pwzTheme, pwzTheme);
        }
    }

    return S_OK;
}

HRESULT BandSite_TestBandCLSID(IBandSite *pbs, DWORD idBand, REFIID riid)
{
    HRESULT hr = E_FAIL;
    IPersist *pp;
    if (pbs)
    {
        hr = pbs->GetBandObject(idBand, IID_PPV_ARG(IPersist, &pp));
        if (SUCCEEDED(hr))
        {
            CLSID clsid;
            hr = pp->GetClassID(&clsid);
            if (SUCCEEDED(hr))
            {
                hr = IsEqualGUID(clsid, riid) ? S_OK : S_FALSE;
            }
            pp->Release();
        }
    }
    return hr;
}

HRESULT BandSite_SetWindowTheme(IBandSite* pbs, LPWSTR pwzTheme)
{
    HRESULT hr = E_FAIL;

    if (pbs)
    {
        CTrayBandSite* ptbs = IUnknownToCTrayBandSite(pbs);
        if (ptbs)
        {
            ptbs->_SetWindowTheme(pwzTheme);
        }

        DWORD dwBandID;
        BOOL fFound = FALSE;
        for (int i = 0; !fFound && SUCCEEDED(pbs->EnumBands(i, &dwBandID)); i++)
        {
            IUnknown* punk;
            HRESULT hrInner = pbs->GetBandObject(dwBandID, IID_PPV_ARG(IUnknown, &punk));
            if (SUCCEEDED(hrInner))
            {
                VARIANTARG var;
                var.vt = VT_BSTR;
                var.bstrVal = pwzTheme;

                IUnknown_Exec(punk, &CGID_DeskBand, DBID_SETWINDOWTHEME, 0, &var, NULL);
            }
        }
    }
    return hr;
}

HRESULT BandSite_RemoveAllBands(IBandSite* pbs)
{
    if (pbs)
    {
        DWORD dwBandID;
        while (SUCCEEDED(pbs->EnumBands(0, &dwBandID)))
        {
            pbs->RemoveBand(dwBandID);
        }
    }

    return S_OK;
}

HRESULT BandSite_FindBand(IBandSite* pbs, REFCLSID rclsid, REFIID riid, void **ppv, int *piCount, DWORD* pdwBandID)
{
    HRESULT hr = E_FAIL;

    int iCount = 0;

    if (pbs)
    {
        DWORD dwBandID;
        for (int i = 0; SUCCEEDED(pbs->EnumBands(i, &dwBandID)); i++)
        {
            if (BandSite_TestBandCLSID(pbs, dwBandID, rclsid) == S_OK)
            {
                iCount++;

                if (pdwBandID)
                {
                    *pdwBandID = dwBandID;
                }

                if (ppv)
                    hr = pbs->GetBandObject(dwBandID, riid, ppv);
                else
                    hr = S_OK;
            }
        }
    }

    if (piCount)
    {
        *piCount = iCount;
    }

    return hr;
}

void BandSite_Initialize(IBandSite* pbs)
{
    HWND hwnd = v_hwndTray;
    
    CTaskBar *pow = new CTaskBar();
    if (pow)
    {
        IDeskBarClient* pdbc;
        if (SUCCEEDED(pbs->QueryInterface(IID_PPV_ARG(IDeskBarClient, &pdbc))))
        {
            // we need to set a dummy tray IOleWindow
            pdbc->SetDeskBarSite(SAFECAST(pow, IOleWindow*));
            pdbc->GetWindow(&hwnd);
            if (hwnd)
            {
                // taskbar windows are themed under Taskbar subapp name
                SendMessage(hwnd, RB_SETWINDOWTHEME, 0, (LPARAM)c_wzTaskbarTheme);
                pow->_hwndRebar = hwnd;
            }
            pdbc->Release();
        }
        pow->Release();
    }
}

IContextMenu3* CTrayBandSite::GetContextMenu()
{
    if (!_pcm)
    {
        if (SUCCEEDED(CoCreateInstance(CLSID_BandSiteMenu, NULL,CLSCTX_INPROC_SERVER, 
                         IID_PPV_ARG(IContextMenu3, &_pcm))))
        {
            IShellService* pss;
            if (SUCCEEDED(_pcm->QueryInterface(IID_PPV_ARG(IShellService, &pss))))
            {
                pss->SetOwner(SAFECAST(this, IBandSite*));
                pss->Release();
            }
        }
    }
    if (_pcm)
        _pcm->AddRef();
    
    return _pcm;
}

HRESULT BandSite_AddMenus(IUnknown* punk, HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast)
{
    HRESULT hr = E_FAIL;

    CTrayBandSite* ptbs = IUnknownToCTrayBandSite(punk);
    
    IContextMenu3* pcm = ptbs->GetContextMenu();
    if (pcm)
    {
        hr = pcm->QueryContextMenu(hmenu, indexMenu, idCmdFirst, idCmdLast, CMF_ICM3);
        pcm->Release();
    }

    return hr;
}

void BandSite_HandleMenuCommand(IUnknown* punk, UINT idCmd)
{
    CTrayBandSite* ptbs = IUnknownToCTrayBandSite(punk);
    
    IContextMenu3* pcm = ptbs->GetContextMenu();

    if (pcm)
    {
        CMINVOKECOMMANDINFOEX ici =
        {
            sizeof(CMINVOKECOMMANDINFOEX),
            0L,
            NULL,
            (LPSTR)MAKEINTRESOURCE(idCmd),
            NULL, NULL,
            SW_NORMAL,
        };

        pcm->InvokeCommand((LPCMINVOKECOMMANDINFO)&ici);
        pcm->Release();
    }
}

void CTrayBandSite::SetInner(IUnknown* punk)
{
    _punkInner = punk;
    
    _punkInner->QueryInterface(IID_PPV_ARG(IBandSite, &_pbsInner));
    Release();
    
    ASSERT(_pbsInner);
}

IBandSite* BandSite_CreateView()
{
    IUnknown *punk;
    HRESULT hr = E_FAIL;

    // aggregate a TrayBandSite (from a RebarBandSite)
    CTrayBandSite *ptbs = new CTrayBandSite;
    if (ptbs)
    {
        hr = CoCreateInstance(CLSID_RebarBandSite, (IBandSite*)ptbs, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IUnknown, &punk));
        if (SUCCEEDED(hr))
        {
            ptbs->SetInner(punk);    // paired w/ Release in outer (TBS::Release)
            BandSite_Initialize(ptbs);
            return SAFECAST(ptbs, IBandSite*);
        }
        else
        {
            delete ptbs;
            return NULL;
        }
    }
    return NULL;
}

HRESULT BandSite_SaveView(IUnknown *pbs)
{
    HRESULT hr = E_FAIL;

    IStream *pstm = GetDesktopViewStream(STGM_WRITE, c_szTaskbarWinXP);
    if (pstm) 
    {
        hr = PersistStreamSave(pstm, TRUE, pbs);
        pstm->Release();
    }

    return hr;
}

BOOL CTrayBandSite::HandleMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    if (!_hwnd)
    {
        IUnknown_GetWindow(SAFECAST(this, IBandSite*), &_hwnd);
    }

    switch (uMsg)
    {
    case WM_INITMENUPOPUP:
    case WM_MEASUREITEM:
    case WM_DRAWITEM:
    case WM_MENUCHAR:
        if (_pcm)
        {
            _pcm->HandleMenuMsg2(uMsg, wParam, lParam, plres);
            return TRUE;
        }
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
        case NM_NCHITTEST:
            {
                NMMOUSE *pnm = (LPNMMOUSE)lParam;
                if (_hwnd == pnm->hdr.hwndFrom)
                {
                    if (pnm->dwHitInfo == RBHT_CLIENT || pnm->dwItemSpec == -1)
                    {
                        if (plres)
                            *plres = HTTRANSPARENT;
                    }
                    return TRUE;
                }
            }
            break;

        case RBN_MINMAX:
            *plres = SHRestricted(REST_NOMOVINGBAND);
            return TRUE;
        }
        break;
    }
        
    IWinEventHandler *pweh;
    if (SUCCEEDED(QueryInterface(IID_PPV_ARG(IWinEventHandler, &pweh))))
    {
        HRESULT hr = pweh->OnWinEvent(hwnd, uMsg, wParam, lParam, plres);
        pweh->Release();
        return SUCCEEDED(hr);
    }
    ASSERT(0);  // we know we support IWinEventHandler
    
    return FALSE;
}

void CTrayBandSite::_BroadcastExec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    // Broadcast an Exec to all child bands

    DWORD dwBandID;
    UINT uBand = 0;
    while (SUCCEEDED(EnumBands(uBand, &dwBandID)))
    {
        IOleCommandTarget* pct;
        if (SUCCEEDED(GetBandObject(dwBandID, IID_PPV_ARG(IOleCommandTarget, &pct))))
        {
            pct->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
            pct->Release();
        }
        uBand++;
    }
}

void BandSite_HandleDelayBootStuff(IUnknown* punk)
{
    if (punk)
    {
        CTrayBandSite* pbs = IUnknownToCTrayBandSite(punk);
        pbs->_fDelayBootStuffHandled = TRUE;
        pbs->_BroadcastExec(&CGID_DeskBand, DBID_FINISHINIT, 0, NULL, NULL);
    }
}

// returns true or false whether it handled it
BOOL BandSite_HandleMessage(IUnknown *punk, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    if (punk) 
    {
        CTrayBandSite* pbs = IUnknownToCTrayBandSite(punk);
        return pbs->HandleMessage(hwnd, uMsg, wParam, lParam, plres);
    }
    return FALSE;
} 

void BandSite_SetMode(IUnknown *punk, DWORD dwMode)
{
    IBandSite* pbs = (IBandSite*)punk;
    if (pbs) 
    {
        IDeskBarClient *pdbc;
        if (SUCCEEDED(pbs->QueryInterface(IID_PPV_ARG(IDeskBarClient, &pdbc))))
        {
            pdbc->SetModeDBC(dwMode);
            pdbc->Release();
        }
    }
} 

void BandSite_Update(IUnknown *punk)
{
    IBandSite* pbs = (IBandSite*)punk;
    if (pbs) 
    {
        IOleCommandTarget *pct;
        if (SUCCEEDED(pbs->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &pct))))
        {
            pct->Exec(&CGID_DeskBand, DBID_BANDINFOCHANGED, 0, NULL, NULL);
            pct->Release();
        }
    }
} 

void BandSite_UIActivateDBC(IUnknown *punk, DWORD dwState)
{
    IBandSite* pbs = (IBandSite*)punk;
    if (pbs)
    {
        IDeskBarClient *pdbc;
        if (SUCCEEDED(pbs->QueryInterface(IID_PPV_ARG(IDeskBarClient, &pdbc))))
        {
            pdbc->UIActivateDBC(dwState);
            pdbc->Release();
        }
    }
}

//***   PersistStreamLoad, PersistStreamSave
// NOTES
//  we don't insist on finding IPersistStream iface; absence of it is
//  assumed to mean there's nothing to init.
HRESULT PersistStreamLoad(IStream *pstm, IUnknown *punk)
{
    IPersistStream *pps;
    HRESULT hr = punk->QueryInterface(IID_PPV_ARG(IPersistStream, &pps));
    if (SUCCEEDED(hr))
    {
        hr = pps->Load(pstm);
        pps->Release();
    }
    else
        hr = S_OK;    // n.b. S_OK not hr (don't insist on IID_IPS)
    return hr;
}

HRESULT PersistStreamSave(IStream *pstm, BOOL fClearDirty, IUnknown *punk)
{
    HRESULT hr = E_FAIL;
    if (punk)
    {
        hr = S_OK;// n.b. S_OK not hr (don't insist on IID_IPS)
        IPersistStream *pps;
        if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IPersistStream, &pps))))
        {
            hr = pps->Save(pstm, fClearDirty);
            pps->Release();
        }
    }
    return hr;
}

HRESULT IUnknown_SimulateDrop(IUnknown* punk, IDataObject* pdtobj, DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect)
{
    HRESULT hr = E_FAIL;
    if (punk)
    {
        IDropTarget* pdt;
        hr = punk->QueryInterface(IID_PPV_ARG(IDropTarget, &pdt));
        if (SUCCEEDED(hr)) 
        {
            hr = pdt->DragEnter(pdtobj, grfKeyState, pt, pdwEffect);
            if (*pdwEffect) 
            {
                hr = pdt->Drop(pdtobj, grfKeyState, pt, pdwEffect);
            } 
            else 
            {
                pdt->DragLeave();
            }
            pdt->Release();
        }
    }

    return hr;
} 

LRESULT BandSite_OnMarshallBS(WPARAM wParam, LPARAM lParam)
{
    GUID *riid = (GUID *) wParam;
    IStream *pstm = NULL;

    // paired w/ matching Unmarshal in shdocvw (TM_MARSHALBS)
    HRESULT hr = CoMarshalInterThreadInterfaceInStream(*riid, c_tray._ptbs, &pstm);
    ASSERT(SUCCEEDED(hr));

    return (LRESULT) pstm;
}

IStream *GetDesktopViewStream(DWORD grfMode, LPCTSTR pszName)
{
    HKEY hkStreams;

    ASSERT(g_hkeyExplorer);

    if (RegCreateKey(g_hkeyExplorer, TEXT("Streams"), &hkStreams) == ERROR_SUCCESS)
    {
        IStream *pstm = OpenRegStream(hkStreams, TEXT("Desktop"), pszName, grfMode);
        RegCloseKey(hkStreams);
        return pstm;
    }
    return NULL;
}


BOOL Reg_GetString(HKEY hkey, LPCTSTR pszSubKey, LPCTSTR pszValue, LPTSTR psz, DWORD cb)
{
    BOOL fRet = FALSE;
    if (!g_fCleanBoot)
    {
        fRet = ERROR_SUCCESS == SHGetValue(hkey, pszSubKey, pszValue, NULL, psz, &cb);
    }
    return fRet;
}


void BandSite_Load()
{
    CTrayBandSite* ptbs = IUnknownToCTrayBandSite(c_tray._ptbs);
    HRESULT hr = E_FAIL;
    
    // 1st, try the WinXP presisted state
    IStream *pstm = GetDesktopViewStream(STGM_READ, c_szTaskbarWinXP);
    if (pstm)
    {
        hr = PersistStreamLoad(pstm, (IBandSite*)ptbs);
        pstm->Release();
    }

    if (FAILED(hr))
    {
        BandSite_RemoveAllBands((IBandSite*)ptbs);
        // 2nd, try the Win2K persisted state
        IStream *pstm = GetDesktopViewStream(STGM_READ, c_szTaskbar);
        if (pstm)
        {
            hr = PersistStreamLoad(pstm, (IBandSite*)ptbs);
            pstm->Release();
        }

        // 3rd, if there is none (or if version mismatch or other failure),
        // try settings from setup
        if (FAILED(hr))
        {
            BandSite_RemoveAllBands((IBandSite*)ptbs);
            LPTSTR pszValue;
            if (IsOS(OS_PERSONAL) || IsOS(OS_PROFESSIONAL) || SHRestricted(REST_CLASSICSHELL))
            {
                // use the no-quick-launch stream
                pszValue = TEXT("Default Taskbar (Personal)");
            }
            else
            {
                pszValue = TEXT("Default Taskbar");
            }

            // n.b. HKLM not HKCU
            // like GetDesktopViewStream but for HKLM
            pstm = OpenRegStream(HKEY_LOCAL_MACHINE,
                REGSTR_PATH_EXPLORER TEXT("\\Streams\\Desktop"),
                pszValue, STGM_READ);

            if (pstm)
            {
                hr = PersistStreamLoad(pstm, (IBandSite *)ptbs);
                pstm->Release();
            }
        }
    }

    // o.w., throw up our hands and force some hard-coded defaults
    // this is needed for a) unexpected failures; b) debug bootstrap;
    int iCount = 0;
    DWORD dwBandID;
    if (FAILED(hr) || FAILED(BandSite_FindBand(ptbs, CLSID_TaskBand, CLSID_NULL, NULL, &iCount, &dwBandID)))
    {
        //
        // note that for the CheckBands case, we're assuming that
        // a) AddBands adds only the missing guys (for now there's
        // only 1 [TaskBand] so we're ok); and b) AddBands doesn't
        // create dups if only some are missing (again for now there's
        // only 1 so no pblm)
        ptbs->_AddRequiredBands();
    }

    hr = BandSite_FindBand(ptbs, CLSID_TaskBand, CLSID_NULL, NULL, &iCount, &dwBandID);
    while ((iCount > 1) && SUCCEEDED(hr))
    {
        ptbs->RemoveBand(dwBandID);
        hr = BandSite_FindBand(ptbs, CLSID_TaskBand, CLSID_NULL, NULL, &iCount, &dwBandID);
    }

    // And one more: this is needed for the TipBand deskband for the TabletPC.
    iCount = 0;
    if (FAILED(hr) || FAILED(BandSite_FindBand(ptbs, CLSID_TipBand, CLSID_NULL, NULL, &iCount, &dwBandID)))
    {
        IDeskBand* pdb;
        HRESULT hr = CoCreateInstance(CLSID_TipBand, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IDeskBand, &pdb));
        if (SUCCEEDED(hr))
        {
            hr = ptbs->AddBand(pdb);
            pdb->Release();
        }
    } 
    hr = BandSite_FindBand(ptbs, CLSID_TipBand, CLSID_NULL, NULL, &iCount, &dwBandID);
    while ((iCount > 1) && SUCCEEDED(hr))
    {
        ptbs->RemoveBand(dwBandID);
        hr = BandSite_FindBand(ptbs, CLSID_TipBand, CLSID_NULL, NULL, &iCount, &dwBandID);
    }

    ptbs->SetLoaded(TRUE);
}

HRESULT CTrayBandSiteService_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk)
{
    if (punkOuter)
        return CLASS_E_NOAGGREGATION;

    if (c_tray._ptbs)
    {
        *ppunk = c_tray._ptbs;
        c_tray._ptbs->AddRef();
        return S_OK;
    }

    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\explorer\bandsite.h ===
#include "tray.h"

#ifndef _bandsite_h
#define _bandsite_h

void BandSite_HandleDelayBootStuff(IUnknown *punk);
BOOL BandSite_HandleMessage(IUnknown *punk, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres);
void BandSite_SetMode(IUnknown *punk, DWORD dwMode);
void BandSite_Update(IUnknown *punk);
void BandSite_UIActivateDBC(IUnknown *punk, DWORD dwState);
void BandSite_HandleMenuCommand(IUnknown* punk, UINT idCmd);
HRESULT BandSite_AddMenus(IUnknown* punk, HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast);
void BandSite_Load();
HRESULT BandSite_SetWindowTheme(IBandSite* pbs, LPWSTR pwzTheme);
HRESULT BandSite_FindBand(IBandSite* pbs, REFCLSID rclsid, REFIID riid, void **ppv, int* piCount, DWORD* pdwBandID);
HRESULT BandSite_TestBandCLSID(IBandSite *pbs, DWORD idBand, REFIID riid);

HRESULT IUnknown_SimulateDrop(IUnknown* punk, IDataObject* pdtobj, DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\explorer\cabinet.h ===
#ifndef _CABINET_H
#define _CABINET_H

#include <w4warn.h>
/*
 *   Level 4 warnings to be turned on.
 *   Do not disable any more level 4 warnings.
 */
#pragma warning(disable:4127)    // conditional expression is constant
#pragma warning(disable:4189)    // 'fIoctlSuccess' : local variable is initialized but not referenced
#pragma warning(disable:4201)    // nonstandard extension used : nameless struct/union
#pragma warning(disable:4245)    // conversion signed/unsigned mismatch
#pragma warning(disable:4509)    // nonstandard extension used: 'GetUserAssist' uses SEH and 'debug_crit' has destructor
#pragma warning(disable:4701)    // local variable 'hfontOld' may be used without having been initialized
#pragma warning(disable:4706)    // assignment within conditional expression
#pragma warning(disable:4328)    // indirection alignment of formal parameter 1(4) is greater than the actual argument alignment (1)


#define _WINMM_ // for DECLSPEC_IMPORT

#define STRICT
#define OEMRESOURCE

#define OVERRIDE_SHLWAPI_PATH_FUNCTIONS     // see comment in shsemip.h

#ifdef WINNT
#include <nt.h>         // Some of the NT specific code calls Rtl functions
#include <ntrtl.h>      // which requires all of these header files...
#include <nturtl.h>
#endif

#include <windows.h>
#include <commctrl.h>
#include <shfusion.h>
#include <msginaexports.h>

// if you include atlstuff.h, you don't get windowsx.h.  so we define needed functions here
__inline HBRUSH SelectBrush(HDC hdc, HBRUSH hbr) { return (HBRUSH)SelectObject(hdc, (HGDIOBJ)(HBRUSH)hbr); }
__inline HFONT SelectFont(HDC hdc, HFONT hfont) { return (HFONT)SelectObject(hdc, (HGDIOBJ)(HFONT)hfont); }
__inline HBITMAP SelectBitmap(HDC hdc, HBITMAP hbm)  { return (HBITMAP)SelectObject(hdc, (HGDIOBJ)(HBITMAP)hbm); }
__inline WNDPROC SubclassWindow(HWND hwnd, WNDPROC lpfn) { return (WNDPROC)SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LPARAM)lpfn); }

#include <windowsx.h>

#include <ole2.h>
#include <wininet.h>
#include <shlobj.h>     // Includes <fcext.h>
#include <shsemip.h>
#include <shellapi.h>
#include <cpl.h>
#include <ddeml.h>
#include <cfgmgr32.h>

#ifdef UNICODE
#define CP_WINNATURAL   CP_WINUNICODE
#else
#define CP_WINNATURAL   CP_WINANSI
#endif

#define DISALLOW_Assert
#include <debug.h>          // our version of Assert etc.
#include <port32.h>
#include <heapaloc.h>
#include <shellp.h>
#include <ccstock.h>
#include <shlobjp.h>
#include <shlwapi.h>
#include "dbt.h"
#include "trayp.h"
#include <shdocvw.h>
#include <uxtheme.h>
#include <tmschema.h>
#include <runonce.h>

#include "shguidp.h"
#include "ieguidp.h"
#include "shdguid.h"

#include "uastrfnc.h"
#include "vdate.h"      // buffer validation (debug only)

#include <desktopp.h>

//
// Trace/dump/break flags specific to explorer.
//   (Standard flags defined in shellp.h)
//

// Trace flags
#define TF_DDE              0x00000100      // DDE traces
#define TF_TARGETFRAME      0x00000200      // Target frame
#define TF_TRAYDOCK         0x00000400      // Tray dock
#define TF_TRAY             0x00000800      // Tray 

// "Olde names"
#define DM_DDETRACE         TF_DDE
#define DM_TARGETFRAME      TF_TARGETFRAME
#define DM_TRAYDOCK         TF_TRAYDOCK

// Function trace flags
#define FTF_DDE             0x00000001      // DDE functions
#define FTF_TARGETFRAME     0x00000002      // Target frame methods

// Dump flags
#define DF_DDE              0x00000001      // DDE package
#define DF_DELAYLOADDLL     0x00000002      // Delay load

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

//---------------------------------------------------------------------------
// Globals
extern HINSTANCE hinstCabinet;  // Instance handle of the app.

extern HWND v_hwndDesktop;

extern HKEY g_hkeyExplorer;

//
// Is Mirroring APIs enabled (BiDi Memphis and NT5 only)
//
extern BOOL g_bMirroredOS;

// Global System metrics.  the desktop wnd proc will be responsible
// for watching wininichanges and keeping these up to date.

extern int g_fCleanBoot;
extern BOOL g_fFakeShutdown;
extern int g_fDragFullWindows;
extern int g_cxEdge;
extern int g_cyEdge;
extern int g_cySize;
extern int g_cyTabSpace;
extern int g_cxTabSpace;
extern int g_cxBorder;
extern int g_cyBorder;
extern int g_cxPrimaryDisplay;
extern int g_cyPrimaryDisplay;
extern int g_cxDlgFrame;
extern int g_cyDlgFrame;
extern int g_cxFrame;
extern int g_cyFrame;
extern int g_cxMinimized;
extern int g_cxVScroll;
extern int g_cyHScroll;
extern BOOL g_fNoDesktop;
extern UINT g_uDoubleClick;


extern HWND v_hwndTray;
extern HWND v_hwndStartPane;
extern BOOL g_fDesktopRaised;

extern const WCHAR c_wzTaskbarTheme[];

// the order of these is IMPORTANT for move-tracking and profile stuff
// also for the STUCK_HORIZONTAL macro
#define STICK_FIRST     ABE_LEFT
#define STICK_LEFT      ABE_LEFT
#define STICK_TOP       ABE_TOP
#define STICK_RIGHT     ABE_RIGHT
#define STICK_BOTTOM    ABE_BOTTOM
#define STICK_LAST      ABE_BOTTOM
#define STICK_MAX       ABE_MAX
#define STUCK_HORIZONTAL(x)     (x & 0x1)

#if STUCK_HORIZONTAL(STICK_LEFT) || STUCK_HORIZONTAL(STICK_RIGHT) || \
   !STUCK_HORIZONTAL(STICK_TOP)  || !STUCK_HORIZONTAL(STICK_BOTTOM)
#error Invalid STICK_* constants
#endif

#define IsValidSTUCKPLACE(stick) IsInRange(stick, STICK_FIRST, STICK_LAST)

// initcab.cpp
HKEY GetSessionKey(REGSAM samDesired);
void RunStartupApps();
void WriteCleanShutdown(DWORD dwValue);


//
// Debug helper functions
//

void InvokeURLDebugDlg(HWND hwnd);

void Cabinet_InitGlobalMetrics(WPARAM, LPTSTR);


#define REGSTR_PATH_ADVANCED        REGSTR_PATH_EXPLORER TEXT("\\Advanced")
#define REGSTR_PATH_SMADVANCED      REGSTR_PATH_EXPLORER TEXT("\\StartMenu")
#define REGSTR_PATH_RUN_POLICY      REGSTR_PATH_POLICIES TEXT("\\Explorer\\Run")
#define REGSTR_EXPLORER_ADVANCED    REGSTR_PATH_ADVANCED
#define REGSTR_POLICIES_EXPLORER    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer")

#undef WinHelp
#define WinHelp SHWinHelp


#ifdef __cplusplus
};       /* End of extern "C" { */


#endif // __cplusplus

#define PERF_ENABLESETMARK
#ifdef PERF_ENABLESETMARK
void DoSetMark(LPCSTR pszMark, ULONG cbSz);
#define PERFSETMARK(text)   DoSetMark(text, sizeof(text))
#else
#define PERFSETMARK(text)
#endif  // PERF_ENABLESETMARK


#endif  // _CABINET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\explorer\debug.cpp ===
#include "cabinet.h"
#include "rcids.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "explorer"
#define SZ_MODULE           "EXPLORER"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\explorer\dlgprocs.h ===
//---------------------------------------------------------------------------
// All the various dialog procs go in here.
//---------------------------------------------------------------------------

int CALLBACK ViewFolderProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\explorer\libx.cpp ===
//***   libx.cpp -- 'source library' inclusions
// DESCRIPTION
//  there are some things that we share in source (rather than .obj or .dll)
// form.  this file builds them in the current directory.

#include "cabinet.h"
#include <shguidp.h>

#include "..\inc\uassist.cpp"       // 'safe' thunks and cache
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\explorer\explorer.inc ===
#
#  Common settings for explorer
#

# Turn structure validation ON in debug builds
#
!if "$(FREEBUILD)" == "0"
C_DEFINES       = $(C_DEFINES) -DVSTF
!endif

!if !defined(TARGET_WIN95)
USE_NEW_COMMCTRL=1
!endif

!if defined(USE_NEW_COMMCTRL)
C_DEFINES= $(C_DEFINES) -DUXCTRL_VERSION=0x0100
!endif

CCSHELL_DIR     = $(PROJECT_ROOT)

USE_STATIC_ATL  = 1

!include $(CCSHELL_DIR)\common.inc
SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

NO_BROWSER_FILE = 1

C_DEFINES       = $(C_DEFINES) -D_USRDLL

MSC_WARNING_LEVEL=/W4

#
# Need hydra headers only on NT
#
!if !defined(TARGET_WIN95)
INCLUDES        = $(INCLUDES);$(TERMSRV_INC_PATH)
!endif

# A bad application loads Explorer.exe as a library and this fails
# if relocations are not present. So for compat reasons we want fixups.
# App Name: Seagate Backup
LINKER_FLAGS    = $(LINKER_FLAGS) -FIXED:NO

!include $(CCSHELL_DIR)\common.inc

SOURCES_USED    =  $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

!if $(FREEBUILD)
# on retail builds we don't want to stack fault, so we reserve 56k of stack
LINKER_STACKCOMMITSIZE = 57344
!else
# on chk builds, we default to 36k so that we can find stack pigs and elimnate them
LINKER_STACKCOMMITSIZE = 36864
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\explorer\dlg.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dlg.rc
//
#define DLG_TRAY_OPTIONS                6
#define DLG_NOTIFY                      7
#define DLG_STARTMENU_CONFIG            9
#define ICO_STARTMENU                   107
#define ICO_DOCMENU                     108
#define DLG_START                       205
#define IDC_GROUPBOX                    300
#define IDC_NO_HELP_1                   650
#define IDC_NO_HELP_2                   651
#define IDC_NO_HELP_3                   652
#define IDC_NO_HELP_4                   653
#define IDC_NOTIFY_OFF                  1000
#define IDS_NOTIFYNAME                  1000
#define IDC_NOTIFYMAN                   1000
#define IDB_RESTORE                     1001
#define IDS_BEHAVIOR                    1001
#define IDS_AUTOMATIC                   1002
#define IDS_HIDDEN                      1003
#define IDS_VISIBLE                     1004
#define IDS_NOTIFY_FIRST                IDS_AUTOMATIC 
#define IDS_NOTIFY_LAST                 (IDS_VISIBLE + 1)
#define IDC_NOTIFY_ITEMS                1005
#define IDC_COMBO_ACTION                1006
#define IDC_CUSTOMIZE                   1007
#define IDC_TRAYOPTONTOP                1101
#define IDC_TRAYOPTAUTOHIDE             1102
#define IDC_TRAYOPTSHOWCLOCK            1103
#define IDC_GROUPITEMS                  1104
#define IDC_ENABLEMOVERESIZE            1105
#define IDC_LOCKTASKBAR                 1105
#define IDC_STATIC_NOTIFY               1106
#define IDC_QUICKLAUNCH                 1107

#define IDC_STARTMENUSETTINGS           1123
#define IDC_RESORT                      1124
#define IDC_KILLDOCUMENTS               1125
#define IDC_ADDSHORTCUT                 1126
#define IDC_DELSHORTCUT                 1127
#define IDC_EXPLOREMENUS                1128
#define IDC_OLDSTARTCUSTOMIZE           1130
#define IDC_NEWSTARTCUSTOMIZE           1131
#define IDC_NEWSCHOOL                   1132
#define IDC_OLDSCHOOL                   1133
#define IDC_STARTMENUPREVIEW            1134
#define IDC_NEWSCHOOLDESCRIPTION        1135

#define DLG_PAGE_SMGENERAL              1135
#define DLG_PAGE_SMADVANCED             1036

#define IDC_SPCUST_ICONSMALL            1300
#define IDC_SPCUST_ICONLARGE            1301
#define IDC_SPCUST_LARGE                1302
#define IDC_SPCUST_SMALL                1303
#define IDC_SPCUST_MINPROGS             1304
#define IDC_SPCUST_MINPROGS_ARROW       1305
#define IDC_SPCUST_HOVEROPEN            1306
// ------- UNUSED --------------------  1307
#define IDC_SPCUST_RECENT               1308
#define IDB_SPCUST_CLEARDOCS            1309
#define IDB_SPCUST_CLEARPROG            1310
#define IDS_SPCUST_TITLE                1311
#define IDC_SPCUST_RECENT_TEXT          1312
#define IDC_SPCUST_RECENT_GROUPBOX      1313
#define IDC_SPCUST_INTERNET             1320
#define IDC_SPCUST_INTERNETCB           1321
#define IDC_SPCUST_EMAIL                1322
#define IDC_SPCUST_EMAILCB              1323
// ------- UNUSED --------------------  1324
// ------- UNUSED --------------------  1325
#define IDC_SPCUST_NOTIFYNEW            1326

#define IDC_NOTIFY_TEXT                 1400
#define IDC_NOTIFY_TEXT2                1401
#define IDB_NOTIFY_RESTOREDEFAULTS	1402
#define IDS_NOTIFY_CURRENTITEMS         1403
#define IDS_NOTIFY_PASTITEMS            1404

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        207
#define _APS_NEXT_COMMAND_VALUE         32772
#define _APS_NEXT_CONTROL_VALUE         1008
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\explorer\classfac.cpp ===
#include "cabinet.h"

///////////////////////////////////////////////////////////////////////////////////////
//
// class factory for explorer.exe
//
// These objects do not exist in the registry but rather are registered dynamically at
// runtime.  Since ClassFactory_Start is called on the the tray's thread, all objects
// will be registered on that thread.
//
///////////////////////////////////////////////////////////////////////////////////////

typedef HRESULT (*LPFNCREATEOBJINSTANCE)(IUnknown* pUnkOuter, IUnknown** ppunk);

class CDynamicClassFactory : public IClassFactory
{                                                                      
public:                                                                
    // *** IUnknown ***
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv)
    {
        static const QITAB qit[] =
        {
            QITABENT(CDynamicClassFactory, IClassFactory),
            { 0 },
        };

        return QISearch(this, qit, riid, ppv);
    }

    STDMETHODIMP_(ULONG) AddRef() { return ++_cRef; }

    STDMETHODIMP_(ULONG) Release()
    {
        if (--_cRef > 0)
        {
            return _cRef;
        }
        delete this;
        return 0;
    }

    // *** IClassFactory ***
    STDMETHODIMP CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
    {
        *ppv = NULL;

        IUnknown *punk;
        HRESULT hr = _pfnCreate(punkOuter, &punk);
        if (SUCCEEDED(hr))
        {
            hr = punk->QueryInterface(riid, ppv);
            punk->Release();
        }

        return hr;
    }

    STDMETHODIMP LockServer(BOOL) { return S_OK; }

    // *** misc public methods ***
    HRESULT Register()
    {
        return CoRegisterClassObject(*_pclsid, this, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
                            REGCLS_MULTIPLEUSE, &_dwClassObject);
    }

    HRESULT Revoke()
    {
        HRESULT hr = CoRevokeClassObject(_dwClassObject);
        _dwClassObject = 0;
        return hr;
    }

    CDynamicClassFactory(CLSID const* pclsid, LPFNCREATEOBJINSTANCE pfnCreate) : _pclsid(pclsid),
                                                                    _pfnCreate(pfnCreate), _cRef(1) {}


private:

    CLSID const* _pclsid;
    LPFNCREATEOBJINSTANCE _pfnCreate;
    DWORD _dwClassObject;
    ULONG _cRef;
};

HRESULT CTaskBand_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk);
HRESULT CTrayBandSiteService_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk);
HRESULT CTrayNotifyStub_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk);

static const struct
{
    CLSID const* pclsid;
    LPFNCREATEOBJINSTANCE pfnCreate;
}
c_ClassParams[] =
{
    { &CLSID_TaskBand,            CTaskBand_CreateInstance },
    { &CLSID_TrayBandSiteService, CTrayBandSiteService_CreateInstance },
    { &CLSID_TrayNotify,          CTrayNotifyStub_CreateInstance },
};

CDynamicClassFactory* g_rgpcf[ARRAYSIZE(c_ClassParams)] = {0};


void ClassFactory_Start()
{
    for (int i = 0; i < ARRAYSIZE(c_ClassParams); i++)
    {
        g_rgpcf[i] = new CDynamicClassFactory(c_ClassParams[i].pclsid, c_ClassParams[i].pfnCreate);
        if (g_rgpcf[i])
        {
            g_rgpcf[i]->Register();
        }
    }
}

void ClassFactory_Stop()
{
    for (int i = 0; i < ARRAYSIZE(c_ClassParams); i++)
    {
        if (g_rgpcf[i])
        {
            g_rgpcf[i]->Revoke();

            g_rgpcf[i]->Release();
            g_rgpcf[i] = NULL;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\explorer\mixer.h ===
void Mixer_SetCallbackWindow(HWND hwndCallback);
MMRESULT Mixer_ToggleMute(void);
MMRESULT Mixer_SetVolume(int Increment);
MMRESULT Mixer_ToggleBassBoost(void);
MMRESULT Mixer_SetBass(int Increment);
MMRESULT Mixer_SetTreble(int Increment);

void Mixer_Shutdown();
void Mixer_DeviceChange(WPARAM wParam, LPARAM lParam);
void Mixer_ControlChange(WPARAM wParam, LPARAM lParam);
void Mixer_MMDeviceChange(void);

// default step size is 4% of max volume.
#define MIXER_DEFAULT_STEP        ((int)(65535/25))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\explorer\mixer.cpp ===
#include "cabinet.h"
#include "mixer.h"
#include <dbt.h>
#include "mmddkp.h"

///////////////////////////////////////
// External interface
//
///////////////////////////////////////
// Definitions
//

#define MMHID_VOLUME_CONTROL    0
#define MMHID_BASS_CONTROL      1
#define MMHID_TREBLE_CONTROL    2
#define MMHID_BALANCE_CONTROL   3
#define MMHID_MUTE_CONTROL      4
#define MMHID_LOUDNESS_CONTROL  5
#define MMHID_BASSBOOST_CONTROL 6
#define MMHID_NUM_CONTROLS      7

typedef struct _LINE_DATA
{
    MIXERLINE           MixerLine;      // The real deal MIXERLINE struct.
    DWORD               ControlType[MMHID_NUM_CONTROLS];
    BOOL                ControlPresent[MMHID_NUM_CONTROLS];
    MIXERCONTROL        Control[MMHID_NUM_CONTROLS];
} LINE_DATA, * PLINE_DATA, FAR * LPLINE_DATA;

typedef struct _MIXER_DATA
{
    HMIXER      hMixer;          // open handle to mixer
    HWND        hwndCallback;    // window to use for mixer callbacks
    LPWSTR      DeviceInterface; // DeviceInterface that implements the mixer
    double*     pdblCacheMix;    // Dynamic array of relative channel level percentages
    LPDWORD     pdwLastVolume;   // Last volume level set on mixer
    MMRESULT    mmr;             // last result      (iff dwReturn == MIXUI_MMSYSERR)
    LINE_DATA   LineData;        // BYDESIGN -  putting this here assumes only one
                                 //          mixer line for now. (first dest. line)

} MIXER_DATA, *PMIXER_DATA, FAR *LPMIXER_DATA;

/*++
 *  Globals
--*/
BOOL       g_fMixerStartup = TRUE;
HWND       g_hwndCallback;
MIXER_DATA g_MixerData;
BOOL       g_fMixerPresent = FALSE;

void Mixer_Close(MIXER_DATA *pMixerData);
BOOL Mixer_CheckMissing(void);

/*****************************************************************************
 *
 *  ACTIVE GET/SET CODE
 *
 *****************************************************************************/
#define VOLUME_MIN  0L
#define VOLUME_MAX  65535L


void RefreshMixCache (PMIXER_DATA pMixerData, LPDWORD padwVolume)
{

    if (pMixerData && padwVolume)
    {

        DWORD cChannels = pMixerData -> LineData.MixerLine.cChannels;
        if (1 > cChannels)
            return; // Weird!

        // Create cache if necessary
        if (!pMixerData -> pdblCacheMix)
            pMixerData -> pdblCacheMix = (double *)LocalAlloc(LPTR, cChannels * sizeof (double));

        // Refresh cache
        if (pMixerData -> pdblCacheMix)
        {

            UINT uiIndx;
            double* pdblMixPercent;
            DWORD dwVolume;

            // Get the maximum volume
            DWORD dwMaxVol = 0;
            for (uiIndx = 0; uiIndx < cChannels; uiIndx++)
                dwMaxVol = max (dwMaxVol, *(padwVolume + uiIndx));

            // Caculate the percentage distance each channel is away from the max
            // value. Creating this cache allows us to maintain the relative distance
            // of the channel levels from each other as the user adjusts the master
            // volume level.
            for (uiIndx = 0; uiIndx < cChannels; uiIndx++)
            {
                dwVolume       = *(padwVolume + uiIndx);
                pdblMixPercent = ((pMixerData -> pdblCacheMix) + uiIndx);

                // Caculate the percentage this value is from the max ...
                if (dwMaxVol == dwVolume)
                {
                    *pdblMixPercent = 1.0F;
                }
                else
                {
                    // Note: if 0 == dwMaxVol all values would be zero and this part
                    //       of the "if" statement will never execute.
                    *pdblMixPercent = ((double) dwVolume / (double) dwMaxVol);
                }
            }
        }
    }
}


static
MMRESULT
Mixer_GetVolume(
    LPMIXER_DATA pMixerData,
    LPDWORD      padwVolume
    )
/*++
Routine Description:

--*/
{
    MIXERCONTROLDETAILS mxcd;
    MMRESULT            mmr;

    if (!pMixerData->LineData.ControlPresent[MMHID_VOLUME_CONTROL]) return MIXERR_INVALCONTROL;

    mxcd.cbStruct       = sizeof(mxcd);
    mxcd.dwControlID    = pMixerData->LineData.Control[MMHID_VOLUME_CONTROL].dwControlID;
    mxcd.cChannels      = pMixerData->LineData.MixerLine.cChannels;
    mxcd.cMultipleItems = 0;
    mxcd.cbDetails      = sizeof(DWORD);
    mxcd.paDetails      = (LPVOID)padwVolume;

    mmr = mixerGetControlDetails((HMIXEROBJ)pMixerData->hMixer,
                                 &mxcd,
                                 MIXER_OBJECTF_HANDLE | MIXER_GETCONTROLDETAILSF_VALUE);
    return mmr;

}

MMRESULT
Mixer_ToggleMute(void)
/*++
Routine Description:

--*/
{
    MIXERCONTROLDETAILS mxcd;
    DWORD               fMute;
    MMRESULT            mmr;
    MIXER_DATA          *pMixerData = &g_MixerData;

    if (Mixer_CheckMissing())
    {
        return MMSYSERR_NODRIVER;
    }

    if (!pMixerData->LineData.ControlPresent[MMHID_MUTE_CONTROL]) return MMSYSERR_NOERROR;

    mxcd.cbStruct         = sizeof(mxcd);
    mxcd.dwControlID      = pMixerData->LineData.Control[MMHID_MUTE_CONTROL].dwControlID ;
    mxcd.cChannels        = 1;
    mxcd.cMultipleItems   = 0;
    mxcd.cbDetails        = sizeof(fMute);
    mxcd.paDetails        = (LPVOID)&fMute;

    mmr = mixerGetControlDetails((HMIXEROBJ)pMixerData->hMixer,
                                 &mxcd,
                                 MIXER_OBJECTF_HANDLE | MIXER_GETCONTROLDETAILSF_VALUE);

    if (!mmr) {

        fMute = fMute ? 0 : 1;

        mmr =  mixerSetControlDetails((HMIXEROBJ)pMixerData->hMixer,
                                      &mxcd,
                                      MIXER_OBJECTF_HANDLE | MIXER_SETCONTROLDETAILSF_VALUE);
    }

    return mmr;
}



MMRESULT
Mixer_ToggleLoudness(
    MIXER_DATA *    pMixerData
    )
/*++
Routine Description:

--*/
{
    MIXERCONTROLDETAILS mxcd;
    DWORD               fEnabled;
    MMRESULT            mmr;

    if (!pMixerData->LineData.ControlPresent[MMHID_LOUDNESS_CONTROL]) return MMSYSERR_NOERROR;

    mxcd.cbStruct         = sizeof(mxcd);
    mxcd.dwControlID      = pMixerData->LineData.Control[MMHID_LOUDNESS_CONTROL].dwControlID ;
    mxcd.cChannels        = 1;
    mxcd.cMultipleItems   = 0;
    mxcd.cbDetails        = sizeof(fEnabled);
    mxcd.paDetails        = (LPVOID)&fEnabled;

    mmr = mixerGetControlDetails((HMIXEROBJ)pMixerData->hMixer,
                                 &mxcd,
                                 MIXER_OBJECTF_HANDLE | MIXER_GETCONTROLDETAILSF_VALUE);


    if (!mmr) {

        fEnabled = fEnabled ? 0 : 1;

        mmr =  mixerSetControlDetails((HMIXEROBJ)pMixerData->hMixer,
                                      &mxcd,
                                      MIXER_OBJECTF_HANDLE | MIXER_SETCONTROLDETAILSF_VALUE);
    }
    return mmr;
}

MMRESULT Mixer_ToggleBassBoost(void)
/*++
Routine Description:

--*/
{
    MIXERCONTROLDETAILS mxcd;
    DWORD               fEnabled;
    MMRESULT            mmr;
    MIXER_DATA          *pMixerData = &g_MixerData;

    if (Mixer_CheckMissing())
    {
        return MMSYSERR_NODRIVER;
    }

    if (!pMixerData->LineData.ControlPresent[MMHID_BASSBOOST_CONTROL]) return MMSYSERR_NOERROR;

    mxcd.cbStruct         = sizeof(mxcd);
    mxcd.dwControlID      = pMixerData->LineData.Control[MMHID_BASSBOOST_CONTROL].dwControlID ;
    mxcd.cChannels        = 1;
    mxcd.cMultipleItems   = 0;
    mxcd.cbDetails        = sizeof(fEnabled);
    mxcd.paDetails        = (LPVOID)&fEnabled;

    mmr = mixerGetControlDetails((HMIXEROBJ)pMixerData->hMixer,
                                  &mxcd,
                                  MIXER_OBJECTF_HANDLE | MIXER_GETCONTROLDETAILSF_VALUE);

    if (!mmr) {

        fEnabled = fEnabled ? 0 : 1;

        mmr =  mixerSetControlDetails((HMIXEROBJ)pMixerData->hMixer,
                                      &mxcd,
                                      MIXER_OBJECTF_HANDLE | MIXER_SETCONTROLDETAILSF_VALUE);
    }
    return mmr;
}


MMRESULT
Mixer_SetVolume(
    int          Increment           // amount of volume change
    )
/*++
Routine Description:
    Change a mixerControl in response to a user event
--*/
{
    MMRESULT            mmr;
    MIXERCONTROLDETAILS mxcd;

    LPVOID      pvVolume;
    UINT        uiIndx;
    LPDWORD     pdwVolume;
    double      dblVolume;
    MIXER_DATA  *pMixerData = &g_MixerData;
    PLINE_DATA  pLineData;
    DWORD       cChannels;

    if (Mixer_CheckMissing())
    {
        return MMSYSERR_NODRIVER;
    }

    pLineData = &pMixerData->LineData;
    cChannels = pMixerData -> LineData.MixerLine.cChannels;

    if (!pMixerData->LineData.ControlPresent[MMHID_VOLUME_CONTROL]) return MMSYSERR_NOERROR;

    //
    // get current volume
    //
    ZeroMemory (&mxcd, sizeof (mxcd));
    mxcd.cbDetails = sizeof (DWORD);
    mxcd.paDetails = LocalAlloc(LPTR, cChannels * sizeof (DWORD));
    if (!mxcd.paDetails)
        return MMSYSERR_NOMEM;
    pvVolume = LocalAlloc(LPTR, cChannels * sizeof (DWORD));
    if (!pvVolume)
    {
        LocalFree(mxcd.paDetails);
        return MMSYSERR_NOMEM;
    }

    // Note: From here on, do not return without freeing 'mxcd.paDetails'
    //       and 'pvVolume'.

    // Get the current volume and any mix cache
    mmr = Mixer_GetVolume (pMixerData, (LPDWORD)mxcd.paDetails);
    if (MMSYSERR_NOERROR == mmr)
    {
        // Create cache if we don't already have one
        if (!pMixerData -> pdblCacheMix)
        {
            RefreshMixCache (pMixerData, (LPDWORD)mxcd.paDetails);
            if (!pMixerData -> pdblCacheMix)
                mmr = MMSYSERR_NOMEM;
            else
            {
                // Create last set volume cache
                if (!pMixerData -> pdwLastVolume)
                {
                    pMixerData -> pdwLastVolume = (DWORD *)LocalAlloc(LPTR, cChannels * sizeof (DWORD));
                    if (!pMixerData -> pdwLastVolume)
                        mmr = MMSYSERR_NOMEM;
                }
            }
        }
        else
        {
            //  HHMMM, speculating random ass fix for 167948/174466 since this
            //  is the ONLY branch where pdwLastVolume can be NULL and not
            //  generate an error.  Will have to talk to FrankYe
            //    -Fwong.

            if (!pMixerData -> pdwLastVolume)
            {
                pMixerData -> pdwLastVolume = (DWORD *)LocalAlloc(LPTR, cChannels * sizeof (DWORD));
                if (!pMixerData -> pdwLastVolume)
                    mmr = MMSYSERR_NOMEM;
            }
        }
    }

    // Don't allow incrementing past max vol