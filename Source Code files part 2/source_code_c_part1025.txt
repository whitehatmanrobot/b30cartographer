 We get 64
// unique event masks.
//

// Cluster Service Events

#define CLUSTER_EVENT_ONLINE                        0x0000000000000001
#define CLUSTER_EVENT_SHUTDOWN                      0x0000000000000002

// Node Events

#define CLUSTER_EVENT_NODE_UP                       0x0000000000000004
#define CLUSTER_EVENT_NODE_DOWN                     0x0000000000000008
        // state change
#define CLUSTER_EVENT_NODE_CHANGE                   0x0000000000000010
#define CLUSTER_EVENT_NODE_ADDED                    0x0000000000000020
#define CLUSTER_EVENT_NODE_DELETED                  0x0000000000000040
#define CLUSTER_EVENT_NODE_PROPERTY_CHANGE          0x0000000000000080
#define CLUSTER_EVENT_NODE_JOIN                     0x0000000000000100

// Group Events

#define CLUSTER_EVENT_GROUP_ONLINE                  0x0000000000000200
#define CLUSTER_EVENT_GROUP_OFFLINE                 0x0000000000000400
#define CLUSTER_EVENT_GROUP_FAILED                  0x0000000000000800
        // state change
#define CLUSTER_EVENT_GROUP_CHANGE                  0x0000000000001000
#define CLUSTER_EVENT_GROUP_ADDED                   0x0000000000002000
#define CLUSTER_EVENT_GROUP_DELETED                 0x0000000000004000
#define CLUSTER_EVENT_GROUP_PROPERTY_CHANGE         0x0000000000008000

// Resource Events

#define CLUSTER_EVENT_RESOURCE_ONLINE               0x0000000000010000
#define CLUSTER_EVENT_RESOURCE_OFFLINE              0x0000000000020000
#define CLUSTER_EVENT_RESOURCE_FAILED               0x0000000000040000
        // state change
#define CLUSTER_EVENT_RESOURCE_CHANGE               0x0000000000080000
#define CLUSTER_EVENT_RESOURCE_ADDED                0x0000000000100000
#define CLUSTER_EVENT_RESOURCE_DELETED              0x0000000000200000
#define CLUSTER_EVENT_RESOURCE_PROPERTY_CHANGE      0x0000000000400000

// Resource Type Events

#define CLUSTER_EVENT_RESTYPE_ADDED                 0x0000000000800000
#define CLUSTER_EVENT_RESTYPE_DELETED               0x0000000001000000

#define CLUSTER_EVENT_PROPERTY_CHANGE               0x0000000002000000

#define CLUSTER_EVENT_NETWORK_UNAVAILABLE           0x0000000004000000
#define CLUSTER_EVENT_NETWORK_DOWN                  0x0000000008000000
#define CLUSTER_EVENT_NETWORK_PARTITIONED           0x0000000010000000
#define CLUSTER_EVENT_NETWORK_UP                    0x0000000020000000
#define CLUSTER_EVENT_NETWORK_PROPERTY_CHANGE       0x0000000040000000
#define CLUSTER_EVENT_NETWORK_ADDED                 0x0000000080000000
#define CLUSTER_EVENT_NETWORK_DELETED               0x0000000100000000

#define CLUSTER_EVENT_NETINTERFACE_UNAVAILABLE      0x0000000200000000
#define CLUSTER_EVENT_NETINTERFACE_FAILED           0x0000000400000000
#define CLUSTER_EVENT_NETINTERFACE_UNREACHABLE      0x0000000800000000
#define CLUSTER_EVENT_NETINTERFACE_UP               0x0000001000000000
#define CLUSTER_EVENT_NETINTERFACE_PROPERTY_CHANGE  0x0000002000000000
#define CLUSTER_EVENT_NETINTERFACE_ADDED            0x0000004000000000
#define CLUSTER_EVENT_NETINTERFACE_DELETED          0x0000008000000000

#define CLUSTER_EVENT_NODE_DOWN_EX                  0x0000010000000000
#define CLUSTER_EVENT_API_NODE_UP                   0x0000020000000000
#define CLUSTER_EVENT_API_NODE_SHUTTINGDOWN         0x0000040000000000

#define CLUSTER_EVENT_RESTYPE_PROPERTY_CHANGE       0x0000080000000000

        // all events
#define CLUSTER_EVENT_ALL                           0x00000FFFFFFFFFFF



//**********************************
//
// Local Event Processor definitions
//
//**********************************


//
// Define Event Processor states
//

typedef enum _EVENT_PROCESSOR_STATE {
    EventProcessorStateIniting,
    EventProcessorStateOnline,
    EventProcessorStateExiting
} EVENT_PROCESS_STATE;

//
// Event Processor Dispatch Table for dispatching events
//

typedef struct _EVENT_DISPATCH_TABLE {
    CLUSTER_EVENT   EventMask;
    PEVENT_ROUTINE  EventRoutine;
} EVENT_DISPATCH_TABLE, *PEVENT_DISPATCH_TABLE;


#endif // _EVENT_PROCESSOR_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\inc\dm.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dm.h

Abstract:

    Public data structures and procedure prototypes for the
    Config Database Manager (DM) subcomponent of the NT Cluster Service

Author:

    John Vert (jvert) 24-Apr-1996

Revision History:

--*/

#ifndef _DM_H
#define _DM_H

#ifdef __cplusplus
extern "C" {
#endif

//
// Define public structures and types
//
typedef struct _HDMKEY *HDMKEY;

extern HDMKEY DmClusterParametersKey;
extern HDMKEY DmResourcesKey;
extern HDMKEY DmResourceTypesKey;
extern HDMKEY DmQuorumKey;
extern HDMKEY DmGroupsKey;
extern HDMKEY DmNodesKey;
extern HDMKEY DmNetworksKey;
extern HDMKEY DmNetInterfacesKey;

extern WCHAR DmpResourceListKeyName[];
extern WCHAR DmpResourceTypeListKeyName[];
extern WCHAR DmpGroupListKeyName[];
extern WCHAR DmpNodeListKeyName[];
extern WCHAR DmpTransportListKeyName[];
extern WCHAR DmpInterconnectListKeyName[];
extern const WCHAR DmpClusterParametersKeyName[];

extern DWORD gbIsQuoResEnoughSpace;

//define public cluster key value names
extern const WCHAR cszPath[];
extern const WCHAR cszMaxQuorumLogSize[];
extern const WCHAR cszParameters[];

//other const strings
extern const WCHAR cszClusFilePath[];
extern const WCHAR cszQuoFileName[];
extern const WCHAR cszQuoTombStoneFile[];
extern const WCHAR cszTmpQuoTombStoneFile[];

//local transaction handle
typedef HANDLE  HLOCALXSACTION;

//
// Define Macros
//


#define DmQuerySz(Key, ValueName, StringBuffer, StringBufferSize, StringSize) \
    DmQueryString( Key,                 \
                   ValueName,           \
                   REG_SZ,              \
                   StringBuffer,        \
                   StringBufferSize,    \
                   StringSize )

#define DmQueryMultiSz(Key,ValueName,StringBuffer,StringBufferSize,StringSize) \
    DmQueryString( Key,                 \
                   ValueName,           \
                   REG_MULTI_SZ,        \
                   StringBuffer,        \
                   StringBufferSize,    \
                   StringSize )

//
// Define public interfaces
//

DWORD
DmInitialize(
    VOID
    );

DWORD
DmShutdown(
    VOID
    );

VOID DmShutdownUpdates(
    VOID
    );

DWORD
DmFormNewCluster(
    VOID
    );

DWORD
DmJoin(
    IN RPC_BINDING_HANDLE RpcBinding,
    OUT DWORD *StartSequence
    );

DWORD
DmUpdateFormNewCluster(
    VOID
    );

DWORD
DmCompleteFormNewCluster(
    VOID
    );

DWORD
DmUpdateJoinCluster(
    VOID
    );

DWORD
DmWaitQuorumResOnline(
    VOID
    );

DWORD DmRollChanges(VOID);

DWORD DmPauseDiskManTimer(VOID);

DWORD DmRestartDiskManTimer(VOID);

DWORD DmPrepareQuorumResChange(
    IN PVOID        pResource,
    IN LPCWSTR      lpszQuorumLogPath,
    IN DWORD        dwMaxQuoLogSize
    );

DWORD DmCompleteQuorumResChange(
    IN LPCWSTR      lpszOldQuoResId,
    IN LPCWSTR      lpszOldQuoLogPath
    );

void DmSwitchToNewQuorumLog(
    IN LPCWSTR lpszQuorumLogPath
    );

DWORD DmReinstallTombStone(
    IN LPCWSTR  lpszQuoLogPath
    );

DWORD DmGetQuorumLogPath(
    IN LPWSTR lpszQuorumLogPath,
    IN DWORD dwSize
    );

DWORD DmGetQuorumLogMaxSize(
    OUT LPDWORD pdwLogSize
    );

DWORD DmBackupClusterDatabase(
    IN LPCWSTR  lpszPathName
    );


HDMKEY
DmGetRootKey(
    IN DWORD samDesired
    );

HDMKEY
DmCreateKey(
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD dwOptions,
    IN DWORD samDesired,
    IN OPTIONAL LPVOID lpSecurityDescriptor,
    OUT LPDWORD lpDisposition
    );

HDMKEY
DmOpenKey(
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD samDesired
    );

DWORD
DmCloseKey(
    IN HDMKEY hKey
    );

DWORD
DmEnumKey(
    IN HDMKEY hKey,
    IN DWORD dwIndex,
    OUT LPWSTR lpName,
    IN OUT LPDWORD lpcbName,
    OUT OPTIONAL PFILETIME lpLastWriteTime
    );

DWORD
DmSetValue(
    IN HDMKEY hKey,
    IN LPCWSTR lpValueName,
    IN DWORD dwType,
    IN CONST BYTE *lpData,
    IN DWORD cbData
    );

DWORD
DmDeleteValue(
    IN HDMKEY hKey,
    IN LPCWSTR lpValueName
    );

DWORD
DmQueryValue(
    IN HDMKEY hKey,
    IN LPCWSTR lpValueName,
    OUT LPDWORD lpType,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    );

DWORD
DmDeleteKey(
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey
    );

DWORD
DmGetKeySecurity(
    IN HDMKEY hKey,
    IN SECURITY_INFORMATION RequestedInformation,
    OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN LPDWORD lpcbSecurityDescriptor
    );

DWORD
DmSetKeySecurity(
    IN HDMKEY hKey,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );


DWORD
DmDeleteTree(
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey
    );

DWORD
DmEnumValue(
    IN HDMKEY hKey,
    IN DWORD dwIndex,
    OUT LPWSTR lpValueName,
    IN OUT LPDWORD lpcbValueName,
    OUT LPDWORD lpType,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    );

DWORD
DmQueryDword(
    IN  HDMKEY hKey,
    IN  LPCWSTR lpValueName,
    OUT LPDWORD lpValue,
    IN  LPDWORD lpDefaultValue OPTIONAL
    );

DWORD
DmQueryString(
    IN     HDMKEY   Key,
    IN     LPCWSTR  ValueName,
    IN     DWORD    ValueType,
    IN     LPWSTR  *StringBuffer,
    IN OUT LPDWORD  StringBufferSize,
    OUT    LPDWORD  StringSize
    );

LPWSTR
DmEnumMultiSz(
    IN LPWSTR  MszString,
    IN DWORD   MszStringLength,
    IN DWORD   StringIndex
    );

typedef
VOID
(WINAPI *PENUM_KEY_CALLBACK) (
    IN HDMKEY Key,
    IN PWSTR KeyName,
    IN PVOID Context
    );

VOID
DmEnumKeys(
    IN HDMKEY RootKey,
    IN PENUM_KEY_CALLBACK Callback,
    IN PVOID Context
    );

typedef
BOOL
(WINAPI *PENUM_VALUE_CALLBACK) (
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PVOID Context
    );

VOID
DmEnumValues(
    IN HDMKEY RootKey,
    IN PENUM_VALUE_CALLBACK Callback,
    IN PVOID Context
    );

DWORD
DmQueryInfoKey(
    IN  HDMKEY  hKey,
    OUT LPDWORD SubKeys,
    OUT LPDWORD MaxSubKeyLen,
    OUT LPDWORD Values,
    OUT LPDWORD MaxValueNameLen,
    OUT LPDWORD MaxValueLen,
    OUT LPDWORD lpcbSecurityDescriptor,
    OUT PFILETIME FileTime
    );

//
// Local registry modification routines for use in a GUM update handler.
//
HDMKEY
DmLocalCreateKey(
    IN HLOCALXSACTION   hLocalXsaction,
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD dwOptions,
    IN DWORD samDesired,
    IN OPTIONAL LPVOID lpSecurityDescriptor,
    OUT LPDWORD lpDisposition
    );

DWORD
DmLocalSetValue(
    IN HLOCALXSACTION   hLocalXsaction,
    IN HDMKEY hKey,
    IN LPCWSTR lpValueName,
    IN DWORD dwType,
    IN CONST BYTE *lpData,
    IN DWORD cbData
    );

DWORD
DmLocalDeleteValue(
    IN HLOCALXSACTION   hLocalXsaction,
    IN HDMKEY hKey,
    IN LPCWSTR lpValueName
    );

DWORD
DmLocalDeleteKey(
    IN HLOCALXSACTION   hLocalXsaction,
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey
    );

DWORD
DmLocalRemoveFromMultiSz(
    IN HLOCALXSACTION   hLocalXsaction,
    IN HDMKEY           hKey,
    IN LPCWSTR          lpValueName,
    IN LPCWSTR          lpString
    );

DWORD
DmLocalAppendToMultiSz(
    IN HLOCALXSACTION hLocalXsaction,
    IN HDMKEY hKey,
    IN LPCWSTR lpValueName,
    IN LPCWSTR lpString
    );

DWORD
DmLocalDeleteTree(
    IN HLOCALXSACTION hLocalXsaction,
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey
    );

HLOCALXSACTION
DmBeginLocalUpdate();

DWORD
DmCommitLocalUpdate(
    IN HLOCALXSACTION hLocalXsaction
    );

DWORD
DmAbortLocalUpdate(
    IN HLOCALXSACTION hLocalXsaction);



//
// Notification support.
//
// Supported completion filters are
//
//  CLUSTER_CHANGE_REGISTRY_NAME  - applies to changes in the namespace. (key creation and deletion).
//  CLUSTER_CHANGE_REGISTRY_ATTRIBUTES - applies to key attributes. The only key attribute is the
//                                       security descriptor.
//  CLUSTER_CHANGE_REGISTRY_VALUE - applies to creation, modification, or deletion of values.
//

//
// Notification callback routine
//
typedef VOID (*DM_NOTIFY_CALLBACK)(
    IN DWORD_PTR Context1,
    IN DWORD_PTR Context2,
    IN DWORD CompletionFilter,
    IN LPCWSTR RelativeName
    );

DWORD
DmNotifyChangeKey(
    IN HDMKEY hKey,
    IN ULONG CompletionFilter,
    IN BOOL WatchTree,
    IN OPTIONAL PLIST_ENTRY ListHead,
    IN DM_NOTIFY_CALLBACK NotifyCallback,
    IN DWORD_PTR Context1,
    IN DWORD_PTR Context2
    );

VOID
DmRundownList(
    IN PLIST_ENTRY ListHead
    );

//
// A few helper routines.
//
DWORD
DmAppendToMultiSz(
    IN HDMKEY hKey,
    IN LPCWSTR lpValueName,
    IN LPCWSTR lpString
    );

DWORD
DmRemoveFromMultiSz(
    IN HDMKEY hKey,
    IN LPCWSTR lpValueName,
    IN LPCWSTR lpString
    );

//
// Some routines for saving and restoring registry trees
//
DWORD
DmInstallDatabase(
    IN LPWSTR   FileName,
    IN OPTIONAL LPCWSTR Directory,
    IN BOOL     bDeleteSrcFile
    );

DWORD
DmGetDatabase(
    IN HKEY hKey,
    IN LPWSTR  FileName
    );

DWORD
DmCreateTempFileName(
    OUT LPWSTR FileName
    );

typedef struct _FILE_PIPE_STATE {
    unsigned long BufferSize;
    char __RPC_FAR *pBuffer;
    HANDLE hFile;
} FILE_PIPE_STATE;

typedef struct _FILE_PIPE {
    BYTE_PIPE Pipe;
    FILE_PIPE_STATE State;
} FILE_PIPE, *PFILE_PIPE;

VOID
DmInitFilePipe(
    IN PFILE_PIPE FilePipe,
    IN HANDLE hFile
    );

VOID
DmFreeFilePipe(
    IN PFILE_PIPE FilePipe
    );

DWORD
DmPushFile(
    IN LPCWSTR FileName,
    IN BYTE_PIPE Pipe
    );

DWORD
DmPullFile(
    IN LPCWSTR FileName,
    IN BYTE_PIPE Pipe
    );

DWORD
DmCommitRegistry(
    VOID
    );

DWORD
DmRollbackRegistry(
    VOID
    );


DWORD
DmRtlCreateKey(
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD dwOptions,
    IN DWORD samDesired,
    IN OPTIONAL LPVOID lpSecurityDescriptor,
    OUT HDMKEY  * phkResult,
    OUT LPDWORD lpDisposition
    );

DWORD
DmRtlOpenKey(
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD samDesired,
    OUT HDMKEY * phkResult
    );

DWORD
DmRtlLocalCreateKey(
    IN HLOCALXSACTION hLocalXsaction,
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD dwOptions,
    IN DWORD samDesired,
    IN OPTIONAL LPVOID lpSecurityDescriptor,
    OUT HDMKEY * phkResult,
    OUT LPDWORD lpDisposition
    );

    

#ifdef __cplusplus
}
#endif

#endif //_DM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\inc\gum.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    gum.h

Abstract:

    Public data structures and procedure prototypes for the
    Global Update Manager (Gum) subcomponent of the NT Cluster Service

Author:

    John Vert (jvert) 16-Apr-1996

Revision History:

--*/

#ifndef _GUM_H
#define _GUM_H

//
// Define public structures and types
//
#define PRE_GUM_DISPATCH    1
#define POST_GUM_DISPATCH   2


//marshalling macros
#define GET_ARG(b, x) (PVOID)(*((PULONG)(b) + (x)) + (PUCHAR)(b))

// if you add new modules to GUM, this number needs to get adjusted
#define GUM_UPDATE_JOINSEQUENCE	2

//
// Predefined update types. Add new update types before
// GumUpdateMaximum!
//
typedef enum _GUM_UPDATE_TYPE {
    GumUpdateFailoverManager,
    GumUpdateRegistry,
    GumUpdateMembership,
    GumUpdateTesting,
    GumUpdateMaximum
} GUM_UPDATE_TYPE;

//
// John Vert (jvert) 4/3/1997
// Update types used by FM. Temporarily here so the EP doesn't need its own
// update type
//
//
// Gum update message types.
//
// The first entries in this list are auto-marshalled through Gum...Ex.
// Any updates that are not auto-marshalled must come after FmUpdateMaxAuto
//

typedef enum {
    FmUpdateChangeResourceName = 0,
    FmUpdateChangeGroupName,
    FmUpdateDeleteResource,
    FmUpdateDeleteGroup,
    FmUpdateAddDependency,
    FmUpdateRemoveDependency,
    FmUpdateChangeClusterName,
    FmUpdateChangeQuorumResource,
    FmUpdateResourceState,
    FmUpdateGroupState,
    EmUpdateClusWidePostEvent,
    FmUpdateGroupNode,
    FmUpdatePossibleNodeForResType,
    FmUpdateGroupIntendedOwner,
    FmUpdateAssignOwnerToGroups,
    FmUpdateApproveJoin,
    FmUpdateCompleteGroupMove,
    FmUpdateCheckAndSetGroupOwner,
    FmUpdateUseRandomizedNodeListForGroups,
    FmUpdateMaxAuto = 0x10000,
    FmUpdateFailureCount,
    FmUpdateGroupOwner,
    FmUpdateCreateGroup,
    FmUpdateCreateResource,
    FmUpdateJoin,
    FmUpdateAddPossibleNode,
    FmUpdateRemovePossibleNode,
    FmUpdateCreateResourceType,
    FmUpdateDeleteResourceType,
    FmUpdateChangeGroup,
    FmUpdateMaximum
} FM_GUM_MESSAGE_TYPES;

DWORD
EpUpdateClusWidePostEvent(
    IN BOOL             SourceNode,
    IN PCLUSTER_EVENT   pEvent,
    IN LPDWORD          pdwFlags,
    IN PVOID            Context1,
    IN PVOID            Context2
    );


//
// Define public interfaces
//


//
// Initialization and shutdown
//
DWORD
WINAPI
GumInitialize(
    VOID
    );

DWORD
WINAPI
GumOnline(
    VOID
    );

VOID
WINAPI
GumShutdown(
    VOID
    );

DWORD
GumCreateRpcBindings(
    PNM_NODE  Node
    );

//
// Routines to send updates
//
DWORD
WINAPI
GumSendUpdate(
    IN GUM_UPDATE_TYPE UpdateType,
    IN DWORD Context,
    IN DWORD BufferLength,
    IN PVOID Buffer
    );

DWORD
WINAPI
GumPostUpdate(
    IN GUM_UPDATE_TYPE UpdateType,
    IN DWORD Context,
    IN DWORD BufferLength,
    IN PVOID Buffer
    );

DWORD
GumPostUpdateEx(
    IN GUM_UPDATE_TYPE UpdateType,
    IN DWORD DispatchIndex,
    IN DWORD ArgCount,
    ...
    );

DWORD
GumSendUpdateEx(
    IN GUM_UPDATE_TYPE UpdateType,
    IN DWORD DispatchIndex,
    IN DWORD ArgCount,
    ...
    );

DWORD
WINAPI
GumAttemptUpdate(
    IN DWORD Sequence,
    IN GUM_UPDATE_TYPE UpdateType,
    IN DWORD Context,
    IN DWORD BufferLength,
    IN PVOID Buffer
    );

DWORD
WINAPI
GumGetCurrentSequence(
    IN GUM_UPDATE_TYPE UpdateType
    );

VOID
WINAPI
GumSetCurrentSequence(
    IN GUM_UPDATE_TYPE UpdateType,
    DWORD Sequence
    );


PVOID GumMarshallArgs(
    OUT LPDWORD lpdwBufLength,
    IN  DWORD   dwArgCount,
    ...);


// logging routine
typedef
DWORD
(WINAPI *PGUM_LOG_ROUTINE) (
    IN DWORD dwGumDispatch,
    IN DWORD dwSequence,
    IN DWORD dwType,
    IN PVOID pVoid,
    IN DWORD dwDataSize
    );

//
// Routines to receive updates
//
typedef
DWORD
(WINAPI *PGUM_UPDATE_ROUTINE) (
    IN DWORD Context,
    IN BOOL SourceNode,
    IN DWORD BufferLength,
    IN PVOID Buffer
    );

#define GUM_MAX_DISPATCH_ARGS 5

typedef
DWORD
(WINAPI *PGUM_DISPATCH_ROUTINE1) (
    IN BOOL SourceNode,
    IN PVOID Arg1
    );

typedef
DWORD
(WINAPI *PGUM_DISPATCH_ROUTINE2) (
    IN BOOL SourceNode,
    IN PVOID Arg1,
    IN PVOID Arg2
    );

typedef
DWORD
(WINAPI *PGUM_DISPATCH_ROUTINE3) (
    IN BOOL SourceNode,
    IN PVOID Arg1,
    IN PVOID Arg2,
    IN PVOID Arg3
    );

typedef
DWORD
(WINAPI *PGUM_DISPATCH_ROUTINE4) (
    IN BOOL SourceNode,
    IN PVOID Arg1,
    IN PVOID Arg2,
    IN PVOID Arg3,
    IN PVOID Arg4
    );

typedef
DWORD
(WINAPI *PGUM_DISPATCH_ROUTINE5) (
    IN BOOL SourceNode,
    IN PVOID Arg1,
    IN PVOID Arg2,
    IN PVOID Arg3,
    IN PVOID Arg4,
    IN PVOID Arg5
    );

typedef struct _GUM_DISPATCH_ENTRY {
    DWORD ArgCount;
    union {
        PGUM_DISPATCH_ROUTINE1 Dispatch1;
        PGUM_DISPATCH_ROUTINE2 Dispatch2;
        PGUM_DISPATCH_ROUTINE3 Dispatch3;
        PGUM_DISPATCH_ROUTINE4 Dispatch4;
        PGUM_DISPATCH_ROUTINE5 Dispatch5;
    };
} GUM_DISPATCH_ENTRY, *PGUM_DISPATCH_ENTRY;


typedef struct _GUM_VOTE_DECISION_CONTEXT{
    GUM_UPDATE_TYPE     UpdateType;
    DWORD               dwContext;
    DWORD               dwInputBufLength;  //input data to make judgement upon
    PVOID               pInputBuf;  //size of the input data
    DWORD               dwVoteLength;
    PVOID               pContext;
}GUM_VOTE_DECISION_CONTEXT, *PGUM_VOTE_DECISION_CONTEXT;


//
// Routines to collect and dispatch vote
//
typedef
DWORD
(WINAPI *PGUM_VOTE_DECISION_CB) (
    IN PGUM_VOTE_DECISION_CONTEXT pDecisionContext,
    IN DWORD    dwVoteBufLength,
    IN PVOID    pVoteBuf,
    IN DWORD    dwNumVotes,
    IN BOOL     bDidAllActiveNodesVote,
    OUT LPDWORD pdwOutputBufSize,
    OUT PVOID   *pOutputBuf
    );

// routine to vote for a gum update type
typedef
DWORD
(WINAPI *PGUM_VOTE_ROUTINE) (
    IN  DWORD dwContext,
    IN  DWORD dwInputBufLength,
    IN  PVOID pInputBuf,
    IN  DWORD dwVoteLength,
    OUT PVOID pVoteBuf
    );

#define GUM_VOTE_VALID      0x00000001


#pragma warning( disable : 4200 ) // nonstandard extension used : zero-sized array in struct/union

typedef struct _GUM_VOTE_ENTRY{
    DWORD   dwFlags;
    DWORD   dwNodeId;
    DWORD   dwNumBytes;
    BYTE    VoteBuf[];
}GUM_VOTE_ENTRY, *PGUM_VOTE_ENTRY;

#pragma warning( default : 4200 )


#define GETVOTEFROMBUF(pVoteBuf, dwVoteLength, i, pdwNodeId) \
    (((((PGUM_VOTE_ENTRY)((PBYTE)pVoteBuf + ((sizeof(GUM_VOTE_ENTRY) + dwVoteLength) * ((i)-1))))->dwFlags) & GUM_VOTE_VALID) ?  \
    (PVOID)((PBYTE)pVoteBuf + (sizeof(GUM_VOTE_ENTRY) * (i)) + (dwVoteLength * ((i)-1))) : (NULL)),     \
    (*(pdwNodeId) = ((PGUM_VOTE_ENTRY)((PBYTE)pVoteBuf + ((sizeof(GUM_VOTE_ENTRY) + dwVoteLength) * ((i)-1))))->dwNodeId)

DWORD
GumSendUpdateOnVote(
    IN GUM_UPDATE_TYPE  UpdateType,
    IN DWORD            dwContext,
    IN DWORD            dwInputBufLength,
    IN PVOID            pInputBuffer,
    IN DWORD            dwVoteLength,
    IN PGUM_VOTE_DECISION_CB pfnGumDecisionCb,
    IN PVOID            pContext
    );



VOID
WINAPI
GumReceiveUpdates(
    IN BOOL IsJoining,
    IN GUM_UPDATE_TYPE UpdateType,
    IN PGUM_UPDATE_ROUTINE UpdateRoutine,
    IN PGUM_LOG_ROUTINE LogRoutine,
    IN DWORD DispatchCount,
    IN OPTIONAL PGUM_DISPATCH_ENTRY DispatchTable,
    IN OPTIONAL PGUM_VOTE_ROUTINE VoteRoutine
    );

VOID
WINAPI
GumIgnoreUpdates(
    IN GUM_UPDATE_TYPE UpdateType,
    IN PGUM_UPDATE_ROUTINE UpdateRoutine
    );


// Interface for a component to request gum to request NM
// shoot a node down to avoid consistency
VOID
GumCommFailure(
    IN GUM_UPDATE_TYPE GumUpdateType,
    IN DWORD NodeId,
    IN DWORD ErrorCode,
    IN BOOL Wait
    );

//
// Interfaces for special join updates
//
DWORD
WINAPI
GumBeginJoinUpdate(
    IN GUM_UPDATE_TYPE UpdateType,
    OUT DWORD *Sequence
    );

DWORD
WINAPI
GumEndJoinUpdate(
    IN DWORD Sequence,
    IN GUM_UPDATE_TYPE UpdateType,
    IN DWORD Context,
    IN DWORD BufferLength,
    IN PVOID Buffer
    );



#endif // _GUM_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\inc\evtlog.h ===
#ifndef _EVTLOG_H
#define _EVTLOG_H

/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    evtlog.h

Abstract:

    Header file for the eventlogging component for
    the NT Cluster Service

Author:

    Sunita Shrivastava (sunitas) 5-Dec-1996.

Revision History:

--*/


DWORD EvInitialize(void);
	
DWORD EvOnline(void);
	
DWORD EvShutdown(void);

DWORD EvCreateRpcBindings(PNM_NODE  Node);


#endif //_EVTLOG_H


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\inc\fm.h ===
#ifndef _FM_H
#define _FM_H

/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    fm.h

Abstract:

    Public data structures and procedure prototypes for
    the Failover Manager subcomponent of the NT Cluster Service

Author:

    John Vert (jvert) 7-Feb-1996

Revision History:

--*/

//
// Public structure definitions
//

//
// FM notifications
// The FM supports the following notifications to allow other
// cluster components to prepare and cleanup state.
//
//SS: for now add it here..but if this is needed externally
//move it to appropriate place
// these notifications are generated only on the node where the
// resource resides
#define NOTIFY_RESOURCE_PREONLINE               0x00000001
#define NOTIFY_RESOURCE_POSTONLINE              0x00000002
#define NOTIFY_RESOURCE_PREOFFLINE              0x00000004
#define NOTIFY_RESOURCE_POSTOFFLINE             0x00000008 //this is the same as offline
#define NOTIFY_RESOURCE_FAILED                  0x00000010
#define NOTIFY_RESOURCE_OFFLINEPENDING          0x00000020
#define NOTIFY_RESOURCE_ONLINEPENDING           0x00000040

//
// Resource type structure definition
//

// Define Flags
#define RESTYPE_DEBUG_CONTROL_FUNC  1

#define     RESTYPE_STATE_LOADS      0x00000001

typedef struct FM_RESTYPE {
    LPWSTR          DllName;
    DWORD           LooksAlivePollInterval;
    DWORD           IsAlivePollInterval;
    LPWSTR          DebugPrefix;
    DWORD           Flags;
    DWORD           State;
    DWORD           Class;
    LIST_ENTRY      PossibleNodeList;
} FM_RESTYPE, *PFM_RESTYPE;


//
// Resource Possible Owners structure
//

typedef struct RESTYPE_POSSIBLE_ENTRY {
    LIST_ENTRY      PossibleLinkage;
    PNM_NODE        PossibleNode;
} RESTYPE_POSSIBLE_ENTRY, *PRESTYPE_POSSIBLE_ENTRY;

#if CLUSTER_BETA
#define FM_MAX_LOCK_ENTRIES  8
#else
#define FM_MAX_LOCK_ENTRIES  4
#endif

//
// Group structure
//

typedef struct _LOCK_INFO {
    DWORD   Module: 5;
    DWORD   ThreadId: 11;
    DWORD   LineNumber: 16;
} LOCK_INFO, *PLOCK_INFO;

typedef struct FM_GROUP {
    DWORD               dwStructState;
    LIST_ENTRY          Contains;       // List of root resources in this Group
    LIST_ENTRY          PreferredOwners; // Ordered list of preferred owners
    LIST_ENTRY          DmRundownList;  // DM rundown list
    DWORD               OrderedOwners;  // # of ordered owners in above list
    CRITICAL_SECTION    Lock;           // Critical section for this Group
    DWORD               LockIndex;
    DWORD               UnlockIndex;
    LOCK_INFO           LockTable[FM_MAX_LOCK_ENTRIES];
    LOCK_INFO           UnlockTable[FM_MAX_LOCK_ENTRIES];
    CLUSTER_GROUP_STATE State;          // State of the Group
    PRESOURCE_ENUM      MovingList;     // Ptr to List of moving resources
    BOOL                Initialized;    // TRUE if registry parameters read
    BOOL                InitFailed;     // TRUE if a resource fails to init
    PNM_NODE            OwnerNode;      // Ptr to owner node. NULL if not known
    UCHAR               FailbackType;   // See AutoFailbackTypes
    UCHAR               FailbackWindowStart; // 0-24 hours
    UCHAR               FailbackWindowEnd; // 0-24 hours (0 is immediate)
    UCHAR               FailoverPeriod; // 1-24 hours (0 is infinite)
    DWORD               FailoverThreshold; // 1-N failovers (0 is infinite)
    CLUSTER_GROUP_STATE PersistentState;   // Preferred state of this group
    DWORD               FailureTime;    // Time of first failure
    DWORD               NumberOfFailures; // Number of failures.
    HDMKEY              RegistryKey;
    LIST_ENTRY          WaitQueue;          // chained FM_WAIT_BLOCK structures
    DWORD               StateSequence;
    HANDLE              hPendingEvent;
    PNM_NODE            pIntendedOwner;
    LPWSTR              lpszAntiAffinityClassName;   // Anti-affinity property
} FM_GROUP, *PFM_GROUP;


#define FM_GROUP_STRUCT_CREATED                     0x00000001
#define FM_GROUP_STRUCT_INITIALIZED                 0x00000002
#define FM_GROUP_STRUCT_MARKED_FOR_DELETE           0x00000004
#define FM_GROUP_STRUCT_MARKED_FOR_MOVE_ON_FAIL     0x00000008
#define FM_GROUP_STRUCT_MARKED_FOR_REGULAR_MOVE     0x00000010
#define FM_GROUP_STRUCT_MARKED_FOR_PENDING_ACTION   0x00000020

#define IS_VALID_FM_GROUP(pFmGroup)   \
    (!(pFmGroup->dwStructState & FM_GROUP_STRUCT_MARKED_FOR_DELETE))

//
#define IS_PENDING_FM_GROUP(pFmGroup)   \
    (pFmGroup->dwStructState & FM_GROUP_STRUCT_MARKED_FOR_PENDING_ACTION)

// Resource structure and types
//
//
// Resource structure
//

// Define Flags
#define RESOURCE_SEPARATE_MONITOR   1
#define RESOURCE_CREATED            2
#define RESOURCE_WAITING            4


typedef struct FM_RESOURCE {
    DWORD           dwStructState;
    LIST_ENTRY      DependsOn;
    LIST_ENTRY      ProvidesFor;
    LIST_ENTRY      PossibleOwners;     // List of possible owners
    LIST_ENTRY      ContainsLinkage;    // Linkage onto FM_GROUP.Contains
    LIST_ENTRY      DmRundownList;      // DM rundown list
    //SS: for now we dont use resource locks, so dont create it and leak it !
    //CRITICAL_SECTION Lock;
    RESID           Id;
    CLUSTER_RESOURCE_STATE  State;
    BOOL            QuorumResource;
    LPWSTR          Dependencies;
    LPWSTR          DebugPrefix;
    DWORD           DependenciesSize;
    struct RESMON   *Monitor;
    PFM_RESTYPE     Type;
    PFM_GROUP       Group;
    ULONG           Flags;
    DWORD           LooksAlivePollInterval;
    DWORD           IsAlivePollInterval;
    CLUSTER_RESOURCE_STATE PersistentState;
    DWORD           RestartAction;
    DWORD           RestartThreshold;
    DWORD           RestartPeriod;
    DWORD           NumberOfFailures;
    DWORD           PendingTimeout;
    HANDLE          PendingEvent;
    HDMKEY          RegistryKey;
    DWORD           FailureTime;
    PVOID           CheckpointState;            // for use by checkpoint manager
    DWORD           ExFlags;                    // Extrinsic flags
    DWORD           Characteristic;
    DWORD           StateSequence;
    BOOL            PossibleList;   // TRUE if possible list entries specified
    DWORD           BlockingQuorum; // 1 if shared lock held, blocking quorum
    HANDLE          hTimer;         // handle to timer used for delayed restart 
    DWORD           RetryPeriodOnFailure;    //Time,in milliseconds, after which a restart will be attempted
} FM_RESOURCE, *PFM_RESOURCE;


#define FM_RESOURCE_STRUCT_CREATED              0x00000001
#define FM_RESOURCE_STRUCT_INITIALIZED          0x00000002
#define FM_RESOURCE_STRUCT_MARKED_FOR_DELETE    0x00000004

#define IS_VALID_FM_RESOURCE(pFmResource)   \
    (!(pFmResource->dwStructState & FM_RESOURCE_STRUCT_MARKED_FOR_DELETE))


//
// Dependency structure
//
typedef struct dependency {
    LIST_ENTRY           DependentLinkage;
    PFM_RESOURCE         DependentResource;
    LIST_ENTRY           ProviderLinkage;
    PFM_RESOURCE         ProviderResource;
} DEPENDENCY, *PDEPENDENCY;

//
// AutoFailbackType
//

typedef enum {
    GroupNoFailback,
    GroupFailback
} GROUP_FAILBACK_TYPE;


//
// Group Preferred Owners structure
//

typedef struct PREFERRED_ENTRY {
    LIST_ENTRY      PreferredLinkage;
    PNM_NODE        PreferredNode;
} PREFERRED_ENTRY, *PPREFERRED_ENTRY;


//
// Resource Possible Owners structure
//

typedef struct POSSIBLE_ENTRY {
    LIST_ENTRY      PossibleLinkage;
    PNM_NODE        PossibleNode;
} POSSIBLE_ENTRY, *PPOSSIBLE_ENTRY;



//
// Public function interfaces
//

//
// Startup, online and shutdown
//
DWORD
WINAPI
FmInitialize(
    VOID
    );

BOOL
FmArbitrateQuorumResource(
    VOID
    );


VOID
FmHoldIO(
    VOID
    );


VOID
FmResumeIO(
    VOID
    );


DWORD
WINAPI
FmFindQuorumResource(
        OUT PFM_RESOURCE *ppResource
        );

DWORD FmBringQuorumOnline();

DWORD
WINAPI
FmFindQuorumOwnerNodeId(
        IN PFM_RESOURCE pResource
        );

DWORD
WINAPI
FmGetQuorumResource(
    OUT PFM_GROUP   *ppQuoGroup,
    OUT LPDWORD     lpdwSignature  OPTIONAL
    );


DWORD
WINAPI
FmSetQuorumResource(
    IN PFM_RESOURCE Resource,
    IN LPCWSTR  lpszLogPathName,
    IN DWORD    dwMaxQuorumLogSize
    );

DWORD
WINAPI
FmBackupClusterDatabase(
    IN LPCWSTR lpszPathName
    );


DWORD
WINAPI
FmFormNewClusterPhase1(
    IN PFM_GROUP pQuoGroup
    );

DWORD
WINAPI
FmFormNewClusterPhase2(
    VOID
    );

DWORD
WINAPI
FmJoinPhase1(
    VOID
    );

DWORD
WINAPI
FmJoinPhase2(
    VOID
    );

VOID
FmJoinPhase3(
    VOID
    );


VOID
FmShutdownGroups(
    VOID
    );

VOID
FmShutdown(
    VOID
    );


//
// Management APIs for groups
//

DWORD
WINAPI
FmOnlineGroup(
    IN PFM_GROUP Group
    );

DWORD
WINAPI
FmOfflineGroup(
    IN PFM_GROUP Group
    );

DWORD
WINAPI
FmMoveGroup(
    IN PFM_GROUP Group,
    IN PNM_NODE DestinationNode OPTIONAL
    );

PFM_GROUP
WINAPI
FmCreateGroup(
    IN LPWSTR GroupId,
    IN LPCWSTR GroupName
    );

DWORD
WINAPI
FmDeleteGroup(
    IN PFM_GROUP Group
    );

DWORD
WINAPI
FmSetGroupName(
    IN PFM_GROUP Group,
    IN LPCWSTR FriendlyName
    );

CLUSTER_GROUP_STATE
WINAPI
FmGetGroupState(
    IN PFM_GROUP Group,
    OUT LPWSTR NodeName,
    IN OUT PDWORD NameLength
    );


//
// Check if a cluster partition exists
//

BOOL
WINAPI
FmVerifyNodeDown(
    IN  PNM_NODE Node,
    OUT LPBOOL   IsDown
    );

DWORD
WINAPI
FmEvictNode(
    IN PNM_NODE Node
    );


//
// enumeration callback routine definitions
//
typedef BOOL (*FM_ENUM_GROUP_RESOURCE_ROUTINE)(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Resource,
    IN LPCWSTR Name
    );

DWORD
WINAPI
FmEnumerateGroupResources(
    IN PFM_GROUP Group,
    IN FM_ENUM_GROUP_RESOURCE_ROUTINE EnumerationRoutine,
    IN PVOID Context1,
    IN PVOID Context2
    );


//
// Management APIs for resources
//

PFM_RESOURCE
WINAPI
FmCreateResource(
    IN PFM_GROUP Group,
    IN LPWSTR ResourceId,
    IN LPCWSTR ResourceName,
    IN LPCWSTR ResourceType,
    IN DWORD dwFlags
    );

DWORD
WINAPI
FmOnlineResource(
    IN PFM_RESOURCE Resource
    );

DWORD
WINAPI
FmOfflineResource(
    IN PFM_RESOURCE Resource
    );

CLUSTER_RESOURCE_STATE
WINAPI
FmGetResourceState(
    IN PFM_RESOURCE Resource,
    OUT LPWSTR NodeName,
    IN OUT PDWORD NameLength
    );

DWORD
WINAPI
FmFailResource(
    IN PFM_RESOURCE Resource
    );

DWORD
WINAPI
FmDeleteResource(
    IN PFM_RESOURCE Resource
    );

DWORD
WINAPI
FmSetResourceName(
    IN PFM_RESOURCE Resource,
    IN LPCWSTR FriendlyName
    );

DWORD
WINAPI
FmAddResourceDependency(
    IN PFM_RESOURCE Resource,
    IN PFM_RESOURCE DependentResource
    );

DWORD
WINAPI
FmRemoveResourceDependency(
    IN PFM_RESOURCE Resource,
    IN PFM_RESOURCE DependentResource
    );

BOOL
FmDependentResource(
    IN PFM_RESOURCE Resource,
    IN PFM_RESOURCE DependentResource,
    IN BOOL ImmediateOnly
    );

DWORD
WINAPI
FmEnumResourceDependent(
    IN PFM_RESOURCE Resource,
    IN DWORD Index,
    OUT PFM_RESOURCE *DependentResource
    );

DWORD
WINAPI
FmEnumResourceProvider(
    IN PFM_RESOURCE Resource,
    IN DWORD Index,
    OUT PFM_RESOURCE *ProviderResource
    );

DWORD
WINAPI
FmEnumResourceNode(
    IN PFM_RESOURCE Resource,
    IN DWORD Index,
    OUT PNM_NODE *ProviderResource
    );

DWORD
WINAPI
FmChangeResourceNode(
    IN PFM_RESOURCE Resource,
    IN PNM_NODE Node,
    IN BOOL Add
    );

DWORD
FmCreateResourceType(
    IN LPCWSTR lpszTypeName,
    IN LPCWSTR lpszDisplayName,
    IN LPCWSTR lpszDllName,
    IN DWORD dwLooksAlive,
    IN DWORD dwIsAlive
    );

DWORD
WINAPI
FmDeleteResourceType(
    IN LPCWSTR TypeName
    );

DWORD
FmEnumResourceTypeNode(
    IN  PFM_RESTYPE  pResType,
    IN  DWORD        dwIndex,
    OUT PNM_NODE     *pPossibleNode
    );

DWORD
FmChangeResourceGroup(
    IN PFM_RESOURCE Resource,
    IN PFM_GROUP Group
    );

DWORD
FmChangeClusterName(
    IN LPCWSTR NewName
    );

DWORD
FmNetNameParseProperties(
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT LPWSTR *ppszClusterName
    );

DWORD
WINAPI
FmResourceControl(
    IN PFM_RESOURCE Resource,
    IN PNM_NODE Node OPTIONAL,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
WINAPI
FmResourceTypeControl(
    IN LPCWSTR ResourceTypeName,
    IN PNM_NODE Node OPTIONAL,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
WINAPI
FmGroupControl(
    IN PFM_GROUP Group,
    IN PNM_NODE Node OPTIONAL,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

//
// Routines for manipulating dependency trees
//
typedef struct FM_DEPENDENCY_TREE {
    LIST_ENTRY ListHead;
} FM_DEPENDENCY_TREE, *PFM_DEPENDENCY_TREE;

typedef struct FM_DEPENDTREE_ENTRY {
    LIST_ENTRY ListEntry;
    PFM_RESOURCE Resource;
} FM_DEPENDTREE_ENTRY, *PFM_DEPENDTREE_ENTRY;

PFM_DEPENDENCY_TREE
FmCreateFullDependencyTree(
    IN PFM_RESOURCE Resource
    );

VOID
FmDestroyFullDependencyTree(
    IN PFM_DEPENDENCY_TREE Tree
    );


BOOL
FmCheckNetworkDependency(
    IN LPCWSTR DependentNetwork
    );


DWORD
FmBuildWINS(
    IN  DWORD   dwFixUpType,
    OUT PVOID   *ppPropertyList,
    OUT LPDWORD pdwPropertyListSize,
    OUT LPWSTR *pszKeyName
    );

DWORD
FmBuildDHCP(
    IN  DWORD   dwFixUpType,
    OUT PVOID   *ppPropertyList,
    OUT LPDWORD pdwPropertyListSize,
    OUT LPWSTR * pszKeyName
    );

DWORD
FmBuildIIS(
    IN  DWORD   dwFixUpType,
    OUT PVOID   *ppPropertyList,
    OUT LPDWORD pdwPropertyListSize,
    OUT LPWSTR * pszKeyName
    );

DWORD
FmBuildSMTP(
    IN  DWORD   dwFixUpType,
    OUT PVOID   *ppPropertyList,
    OUT LPDWORD pdwPropertyListSize,
    OUT LPWSTR * pszKeyName
    );

DWORD
FmBuildNNTP(
    IN  DWORD   dwFixUpType,
    OUT PVOID   *ppPropertyList,
    OUT LPDWORD pdwPropertyListSize,
    OUT LPWSTR * pszKeyName
    );

DWORD
FmBuildMSDTC(
    IN  DWORD   dwFixUpType,
    OUT PVOID  * ppPropertyList,
    OUT LPDWORD pdwPropertyListSize,
    OUT LPWSTR * pszKeyName
    );

DWORD 
FmBuildNewMSMQ(
    IN  DWORD   dwFixUpType,
    OUT PVOID  * ppPropertyList,
    OUT LPDWORD pdwPropertyListSize,
    OUT LPWSTR * pszKeyName
    );

DWORD
FmBuildClusterProp(
    IN  DWORD   dwFixUpType,
    OUT PVOID  * ppPropertyList,
    OUT LPDWORD pdwPropertyListSize,
    OUT LPWSTR * pszKeyName
    );


DWORD
FmCreateRpcBindings(
    PNM_NODE Node
    );


//callback for registry fixups (resource type addition) 
DWORD
FmFixupNotifyCb(VOID);


//the callback registered for object notifications
typedef void (WINAPI *FM_ONLINE_ONTHISNODE_CB)(
    );

void FmCheckQuorumState(
    IN FM_ONLINE_ONTHISNODE_CB OnLineOnThisNodeCb, 
    OUT PBOOL pbQuorumOfflineOnThisNode
    );

DWORD FmDoesQuorumAllowJoin();

DWORD FmDoesQuorumAllowLogging();

//Fixup function for AdminExt value
DWORD
FmFixupAdminExt(VOID);

#endif //_FM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\inc\cp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    cp.h

Abstract:

    Public data structures and procedure prototypes for the
    Checkpoint Manager (CP) subcomponent of the NT Cluster Service

Author:

    John Vert (jvert) 1/14/1997

Revision History:

--*/

//
// Define public structures and types
//

//
// Define public interfaces
//
DWORD
CpInitialize(
    VOID
    );

DWORD
CpShutdown(
    VOID
    );

DWORD
CpCopyCheckpointFiles(
    IN LPCWSTR lpszPathName,
    IN BOOL IsFileChangeAttribute
    );

DWORD
CpCompleteQuorumChange(
    IN LPCWSTR lpszOldQuorumPath
    );

DWORD
CpSaveDataFile(
    IN PFM_RESOURCE Resource,
    IN DWORD dwCheckpointId,
    IN LPCWSTR lpszFileName,
    IN BOOLEAN fCryptoCheckpoint
    );

DWORD
CpGetDataFile(
    IN PFM_RESOURCE Resource,
    IN DWORD dwCheckpointId,
    IN LPCWSTR lpszFileName,
    IN BOOLEAN fCryptoCheckpoint
    );

//
// Interface for adding and removing registry checkpoints
//
DWORD
CpAddRegistryCheckpoint(
    IN PFM_RESOURCE Resource,
    IN LPCWSTR KeyName
    );

DWORD
CpDeleteRegistryCheckpoint(
    IN PFM_RESOURCE Resource,
    IN LPCWSTR KeyName
    );

DWORD
CpGetRegistryCheckpoints(
    IN PFM_RESOURCE Resource,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
CpRemoveResourceCheckpoints(
    IN PFM_RESOURCE Resource
    );

DWORD
CpckRemoveResourceCheckpoints(
    IN PFM_RESOURCE Resource
    );
    
DWORD
CpDeleteCheckpointFile(
    IN PFM_RESOURCE Resource,
    IN DWORD        dwCheckpointId,
    IN OPTIONAL LPCWSTR lpszQuorumPath
    );

DWORD CpRestoreCheckpointFiles(
    IN LPWSTR  lpszSourcePathName,
    IN LPWSTR  lpszSubDirName,
    IN LPCWSTR lpszQuoLogPathName 
    );

//
// Interface for adding and removing crypto checkpoints
//
DWORD
CpckAddCryptoCheckpoint(
    IN PFM_RESOURCE Resource,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
CpckDeleteCryptoCheckpoint(
    IN PFM_RESOURCE Resource,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
CpckGetCryptoCheckpoints(
    IN PFM_RESOURCE Resource,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\inc\init.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    init.h

Abstract:

    Public data structures and procedure prototypes for
    the INIT subcomponent of the NT Cluster Service

Author:

    John Vert (jvert) 7-Feb-1996

Revision History:

--*/


//
// Shutdown Types
//

typedef enum _SHUTDOWN_TYPE {
    CsShutdownTypeStop = 0,
    CsShutdownTypeShutdown,
    CsShutdownTypeMax
} SHUTDOWN_TYPE;

extern SHUTDOWN_TYPE CsShutdownRequest;

//
// A few interfaces for reporting of errors.
//

VOID
ClusterLogFatalError(
    IN ULONG LogModule,
    IN ULONG Line,
    IN LPSTR File,
    IN ULONG ErrCode
    );

VOID
ClusterLogEvent0(
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes
    );

VOID
ClusterLogEvent1(
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1
    );

VOID
ClusterLogEvent2(
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1,
    IN LPCWSTR Arg2
    );

VOID
ClusterLogEvent3(
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1,
    IN LPCWSTR Arg2,
    IN LPCWSTR Arg3
    );

//
// Convenient memory allocation routines
//
PVOID
CsAlloc(
    DWORD Size
    );

#define CsFree(_p_) LocalFree(_p_)

LPWSTR
CsStrDup(
    LPCWSTR String
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\inc\member.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    member.h

Abstract:

    Public data structures and procedure prototypes for
    the Membership subcomponent of the NT Cluster Service

Author:

    John Vert (jvert) 7-Feb-1996

Revision History:

--*/

DWORD
CmpInitNodes(
    VOID
    );

VOID
CmpCleanupNodes(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\inc\om.h ===
#ifndef _OM_H
#define _OM_H

/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    om.h

Abstract:

    Public data structures and procedure prototypes for the
    Object Manager (Om) subcomponent of the NT Cluster Service

Author:

    Rod Gamache (rodga) 13-Mar-1996

Revision History:

--*/

//
// Common object header
//
#define OM_TRACE_REF 0



//
// Delete object callback method
//
typedef VOID (*OM_DELETE_OBJECT_METHOD)(
    IN PVOID Object
    );

typedef OM_DELETE_OBJECT_METHOD *POM_DELETE_OBJECT_METHOD;

//
// Object Types
//

typedef enum _ObjectType {
    ObjectTypeResource = 1,
    ObjectTypeResType,
    ObjectTypeGroup,
    ObjectTypeNode,
    ObjectTypeCluster,
    ObjectTypeNetwork,
    ObjectTypeNetInterface,
    ObjectTypeMax
} OBJECT_TYPE;


//
// Object Type structure
//

typedef struct _OM_OBJECT_TYPE_INITIALIZE {
    DWORD           ObjectSize;
    DWORD           Signature;
    LPCWSTR         Name;
    OM_DELETE_OBJECT_METHOD DeleteObjectMethod;
} OM_OBJECT_TYPE_INITIALIZE, *POM_OBJECT_TYPE_INITIALIZE;

typedef struct _OM_OBJECT_TYPE {
    LIST_ENTRY      ListHead;
    LIST_ENTRY      CallbackListHead;
    DWORD           Signature;
    DWORD           Type;
    LPWSTR          Name;
    DWORD           ObjectSize;
    DWORD           EnumKey;            // If we ever run out, go to DWORDLONG
    CRITICAL_SECTION CriticalSection;
    OM_DELETE_OBJECT_METHOD DeleteObjectMethod;
} OM_OBJECT_TYPE, *POM_OBJECT_TYPE;


//
// Object flags
//
#define OM_FLAG_OBJECT_INSERTED  0x00000001

//the callback registered for object notifications
typedef void (WINAPI *OM_OBJECT_NOTIFYCB)(
    IN PVOID pContext,
    IN PVOID pObject,
    IN DWORD dwNotification
    );

// the notification record stored for an object
typedef struct _OM_NOTIFY_RECORD{
    LIST_ENTRY              ListEntry;
    OM_OBJECT_NOTIFYCB      pfnObjNotifyCb;
    DWORD                   dwNotifyMask;
    PVOID                   pContext;
}OM_NOTIFY_RECORD,*POM_NOTIFY_RECORD;


//
// Object header structure
//

typedef struct _OM_HEADER {
#if OM_TRACE_REF
    LIST_ENTRY  DeadListEntry;
#endif    
    LIST_ENTRY  ListEntry;
    DWORD       Signature;
    DWORD       RefCount;
    DWORD       Flags;
    LPWSTR      Id;
    LPWSTR      Name;
    POM_OBJECT_TYPE ObjectType;
    DWORD       EnumKey;
    LIST_ENTRY  CbListHead;
    DWORDLONG   Body;   // For alignment
} OM_HEADER, *POM_HEADER;

#define OmpObjectToHeader(pObject) CONTAINING_RECORD((pObject), OM_HEADER, Body)
#define OmpReferenceHeader(pOmHeader) InterlockedIncrement(&(pOmHeader)->RefCount)


#if OM_TRACE_REF

extern DWORDLONG *OmpMatchRef;

#define OmReferenceObject(pObject)  \
{                                   \
 CsDbgPrint(LOG_NOISE,              \
            "[OM] Reference object %1!lx! (new refcnt %2!d!) from file %3!s! line %4!u!.\n", \
            pObject,                \
            ((OmpObjectToHeader(pObject))->RefCount) + 1, \
            __FILE__,               \
            __LINE__ );            \
 OmpReferenceHeader(OmpObjectToHeader(pObject));\
}

#define OmDereferenceObject(pObject)    \
{                                       \
 CsDbgPrint(LOG_NOISE,                  \
            "[OM] DeReference object %1!lx! (new refcnt %2!d!) from file %3!s! line %4!u!.\n", \
            pObject,                    \
            ((OmpObjectToHeader(pObject))->RefCount) - 1, \
            __FILE__,                   \
            __LINE__ );                \
 OmpDereferenceObject(pObject);         \
} 

//SS: Dont use this in an initialization assignment! This includes a comma, expression
#define OmReferenceObjectByName(ObjectType, Name)   \
    ((CsDbgPrint(LOG_NOISE,                         \
            "[OM] Reference object name %1!ws! from file %2!s! line %3!u!.\n", \
            Name,                                   \
            __FILE__,                               \
            __LINE__ )),                           \
    (OmpReferenceObjectByName(ObjectType, Name)))   \

//SS: Dont use this in an initialization assignment! This includes a comma, expression
#define OmReferenceObjectById(ObjectType, Id)   \
    ((CsDbgPrint(LOG_NOISE,                     \
            "[OM] Reference object Id %1!ws! from file %2!s! line %3!u!.\n", \
            Id,                                 \
            __FILE__,                           \
            __LINE__ )),                       \
    (OmpReferenceObjectById(ObjectType, Id)))   \

#else

#define OmReferenceObject(pObject) OmpReferenceHeader(OmpObjectToHeader(pObject))
#define OmDereferenceObject(pObject) OmpDereferenceObject(pObject)

//SS: Dont use these in an initialization assignment! This includes a comma, expression
// when the OM_TRACE_REF flag is on
#define OmReferenceObjectById(ObjectType, Id)    OmpReferenceObjectById(ObjectType, Id)
#define OmReferenceObjectByName(ObjectType, Name) OmpReferenceObjectByName(ObjectType, Name)

#endif

#define OmObjectSignature(pObject) (OmpObjectToHeader(pObject))->Signature


//
// Read-only access to object name, Id, and type
//
#define OmObjectId(pObject) ((LPCWSTR)(OmpObjectToHeader(pObject)->Id))
#define OmObjectName(pObject) ((LPCWSTR)(OmpObjectToHeader(pObject)->Name))
#define OmObjectType(pObject) (OmpObjectToHeader(pObject)->ObjectType->Type)

#define OmObjectInserted(pObject) ((BOOL)(OmpObjectToHeader(pObject)->Flags & OM_FLAG_OBJECT_INSERTED))


//
// Enumeration callback routine definitions
//
typedef BOOL (*OM_ENUM_OBJECT_ROUTINE)(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Object,
    IN LPCWSTR Name
    );


//
// Global Functions
//


//
// Startup and shutdown
//

DWORD
WINAPI
OmInitialize(
    VOID
    );

VOID
OmShutdown(
    VOID
    );

//
// Object types
//

DWORD
WINAPI
OmCreateType(
    IN OBJECT_TYPE ObjectType,
    IN POM_OBJECT_TYPE_INITIALIZE ObjectTypeInitialize
    );

//
// Objects management
//

PVOID
WINAPI
OmCreateObject(
    IN OBJECT_TYPE ObjectType,
    IN LPCWSTR ObjectId,
    IN LPCWSTR ObjectName OPTIONAL,
    OUT PBOOL  Created OPTIONAL
    );


DWORD
WINAPI
OmInsertObject(
    IN PVOID Object
    );

DWORD
WINAPI
OmRemoveObject(
    IN PVOID Object
    );

PVOID
WINAPI
OmpReferenceObjectById(
    IN OBJECT_TYPE ObjectType,
    IN LPCWSTR Id
    );

PVOID
WINAPI
OmpReferenceObjectByName(
    IN OBJECT_TYPE ObjectType,
    IN LPCWSTR Name
    );


DWORD
WINAPI
OmCountObjects(
    IN OBJECT_TYPE ObjectType,
    OUT LPDWORD NumberOfObjects
    );

DWORD
WINAPI
OmEnumObjects(
    IN OBJECT_TYPE ObjectType,
    IN OM_ENUM_OBJECT_ROUTINE EnumerationRoutine,
    IN PVOID Context1,
    IN PVOID Context2
    );

VOID
OmpDereferenceObject(
    IN PVOID Object
    );

DWORD
WINAPI
OmSetObjectName(
    IN PVOID Object,
    IN LPCWSTR ObjectName
    );


DWORD
WINAPI
OmRegisterNotify(
    IN PVOID                            pObject,
    IN PVOID                            pContext,
    IN DWORD                            dwNotifyMask,
    IN OM_OBJECT_NOTIFYCB       pfnObjNotifyCb
    );


DWORD
WINAPI
OmDeregisterNotify(
    IN PVOID                            pObject,
    IN OM_OBJECT_NOTIFYCB       lpfnObjNotifyCb
    );

DWORD
WINAPI
OmRegisterTypeNotify(
    IN OBJECT_TYPE ObjectType,
    IN PVOID Context,
    IN DWORD NotifyMask,
    IN OM_OBJECT_NOTIFYCB lpfnObjNotifyCb
    );

DWORD
WINAPI
OmNotifyCb(
    IN PVOID pObject,
    IN DWORD dwNotification
    );


#endif //ifndef _OM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\inc\logman.h ===
#ifndef _LM_H
#define _LM_H

/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    logman.h

Abstract:

    Private header file for the cluster registry

Author:

    John Vert (jvert) 15-Dec-1995

Revision History:

--*/
//
// Define interfaces used by the logger component
//

//
// Well-known Resource Manager IDs
//
typedef DWORD   RMTYPE; //the record type stored in the flags
typedef DWORD   LSN;
typedef HANDLE  HLOG;
typedef int     TRID;
typedef HANDLE  HXSACTION;

typedef enum _RMID {
    RMPageEnd,          // reserved - signifies end of a log page
    RMBeginChkPt,       // reserved - signifies a start chkpoint record
    RMEndChkPt,         // reserved - signifies the end chk point record
    RMInvalidated,      // an invalidated record is marked at mount
    RMAny,
    RMRegistryMgr
} RMID;

typedef enum _TRTYPE {
    TTDontCare,     //log management specific routines use this type
    TTStartXsaction,
    TTCommitXsaction,
    TTAbortXsaction,
    TTXsactionUnit,
    TTCompleteXsaction,
}TRTYPE;    

typedef enum _TRSTATE{
    XsactionAborted,
    XsactionCommitted,
    XsactionUnknown
}TRSTATE;

#define LOG_MAX_FILENAME_LENGTH         MAX_PATH

#define NULL_LSN 0


/****
@typedef    BOOL (WINAPI *PLOG_GETCHECKPOINT_CALLBACK) | 
			Supplies the routine to be called back in order to obtain a check
    		point file once the log manager is asked to record a checkpoint in
    		the log file.

@parm       IN LPCWSTR | lpszPath | The path where to create the checkpoint file.
           
@parm		IN PVOID | Context| Supplies the checkpoint CallbackContext specified 
			to LogCreate().

@parm		IN PVOID | pszFileName | Supplies the name of file to take the checkpt in.

@parm		OUT TRID | *pChkPtTransaction | Supplies the transaction identifier of the checkpoint.

@xref       <f LogCreate>
****/
typedef
DWORD
(WINAPI *PLOG_GETCHECKPOINT_CALLBACK) (
    IN LPCWSTR  lpszPath,
    IN PVOID    pContext,
    IN LPWSTR   pszChkPtFile,
    OUT TRID    *pChkPtTransaction
    );

HLOG
LogCreate(
    IN LPWSTR   lpFileName,
    IN DWORD    dwMaxFileSize,
    IN PLOG_GETCHECKPOINT_CALLBACK CallbackRoutine,
    IN PVOID    pGetChkPtContext,
    IN BOOL     bForceCreate,
    OPTIONAL OUT LSN *pLastLsn
    );

DWORD
LogClose(
    IN HLOG LogFile
    );

DWORD
LogCommitSize(
    IN HLOG     hLog,
    IN RMID     ResourceId,
    IN DWORD    dwDataSize
    );

LSN
LogWrite(
    IN HLOG LogFile,
    IN TRID TransactionId,
    IN TRTYPE TransactionType,
    IN RMID ResourceId,
    IN RMTYPE ResourceFlags,
    IN PVOID LogData,
    IN DWORD DataSize
    );

LSN
LogFlush(
    IN HLOG LogFile,
    IN LSN MinLsn
    );

LSN
LogRead(
    IN HLOG LogFile,
    IN LSN CurrentLsn,
    OUT RMID *Resource,
    OUT RMTYPE *ResourceFlags,
    OUT TRID *Transaction,
    OUT TRTYPE *TrType,
    OUT PVOID LogData,
    IN OUT DWORD *DataSize
    );

typedef
BOOL
(WINAPI *PLOG_SCAN_CALLBACK) (
    IN PVOID    Context,
    IN LSN      Lsn,
    IN RMID     Resource,
    IN RMTYPE   ResourceFlags,
    IN TRID     Transaction,
    IN TRTYPE   TransactionType,
    IN const PVOID LogData,
    IN DWORD DataLength
    );


typedef
BOOL
(WINAPI *PLOG_SCANXSACTION_CALLBACK) (
    IN PVOID    Context,
    IN LSN      Lsn,
    IN RMID     Resource,
    IN RMTYPE   ResourceFlags,
    IN TRID     Transaction,
    IN const PVOID LogData,
    IN DWORD DataLength
    );

DWORD
LogScan(
    IN HLOG LogFile,
    IN LSN FirstLsn,
    IN BOOL ScanForward,
    IN PLOG_SCAN_CALLBACK CallbackRoutine,
    IN PVOID CallbackContext
    );


DWORD
LogCheckPoint(
    IN HLOG     LogFile,
    IN BOOL     bAllowReset,
    IN LPCWSTR  lpszInChkPtFile,
    IN DWORD    dwChkPtSeq
    );

DWORD
LogReset(
    IN HLOG LogFile
    );

DWORD
LogGetLastChkPoint(
        IN HLOG         LogFile,
        IN LPWSTR       pszChkPtFileName,
        OUT TRID        *pTransaction,
        OUT LSN         *pChkPtLsn
);

DWORD LogGetInfo(
    IN  HLOG    hLog,
    OUT LPWSTR  szFileName,
    OUT LPDWORD pdwCurLogSize,
    OUT LPDWORD pdwMaxLogSize
    );

DWORD LogSetInfo(
    IN  HLOG    hLog,
    IN  DWORD   dwMaxLogSize
    );

//Local Xsaction related routines    
DWORD
LogFindXsactionState(
   IN   HLOG    hLog,
   IN   LSN     Lsn,
   IN   TRID    TrId,
   OUT  TRSTATE *pTrState
   );

DWORD
LogScanXsaction(
    IN HLOG     hLog,
    IN LSN      StartXsactionLsn,
    IN TRID     StartXsactionId,
    IN PLOG_SCANXSACTION_CALLBACK CallbackRoutine,
    IN PVOID    pContext
    );

HXSACTION
LogStartXsaction(
    IN HLOG     hLog,
    IN TRID     TrId,
    IN RMID     ResourceId,
    IN RMTYPE   ResourceFlags
    );

DWORD WINAPI LogCommitXsaction(
    IN HLOG         hLog,
    IN HXSACTION    hXsaction,
    IN RMTYPE       ResourceFlags
    );

DWORD
LogAbortXsaction(
    IN HLOG         hLog,
    IN HXSACTION    TrId,
    IN RMTYPE       ResourceFlags
    );


LSN
LogWriteXsaction(
    IN HLOG         hLog,
    IN HXSACTION    hXsaction,
    IN RMTYPE       ResourceFlags,
    IN PVOID        pLogData,
    IN DWORD        dwDataSize
    );

//Logmanager initialization/shutdown
DWORD   LmInitialize();

DWORD LmShutdown();

//Timer Activity Functions- these are generic functions
typedef
void
(WINAPI *PFN_TIMER_CALLBACK)(
        IN HANDLE   hTimer,
        IN PVOID    pContext
        );

DWORD
AddTimerActivity(
        IN HANDLE               hTimer,
        IN DWORD                dwInterval,
        IN LONG                 lPeriod,
        IN PFN_TIMER_CALLBACK   pfnTimerCallback,
        IN PVOID                pContext
);


DWORD
RemoveTimerActivity(
        IN HANDLE       hTimer
);

DWORD
UnpauseTimerActivity(
        IN HANDLE       hTimer
);

DWORD
PauseTimerActivity(
        IN HANDLE       hTimer
);

#endif //_LM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\inc\nm.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    nm.h

Abstract:

    Public interface definitions for the Node Manager component.

Author:

    Mike Massa (mikemas) 12-Mar-1996


Revision History:

--*/


#ifndef _NM_INCLUDED
#define _NM_INCLUDED


//
// Types
//

typedef struct _NM_NODE *PNM_NODE;
typedef struct _NM_NETWORK *PNM_NETWORK;
typedef struct _NM_INTERFACE *PNM_INTERFACE;


//the callback registered for object notifications
typedef DWORD (WINAPI *NM_FIXUP_NOTIFYCB)(
    IN DWORD    dwFixupType,
    OUT PVOID   *ppPropertyList,
    OUT LPDWORD pdwPropertyListSize,
    OUT LPWSTR  * szKeyName
    );


//
// Data
//
#define NM_DEFAULT_NODE_LIMIT 2   // This is the default if
                                  // MaxNodesInCluster is not set



#define NM_FORM_FIXUP       1
#define NM_JOIN_FIXUP       2

extern ULONG                NmMaxNodes;
extern CL_NODE_ID           NmMaxNodeId;
extern CL_NODE_ID           NmLocalNodeId;
extern PNM_NODE             NmLocalNode;
extern WCHAR                NmLocalNodeName[];
extern WCHAR                NmLocalNodeIdString[];
extern HANDLE               NmClusnetHandle;
extern BOOL                 NmLocalNodeVersionChanged;
extern RESUTIL_PROPERTY_ITEM NmJoinFixupSDProperties[];
extern RESUTIL_PROPERTY_ITEM NmJoinFixupWINSProperties[];
extern RESUTIL_PROPERTY_ITEM NmJoinFixupDHCPProperties[];
extern RESUTIL_PROPERTY_ITEM NmJoinFixupSMTPProperties[];
extern RESUTIL_PROPERTY_ITEM NmJoinFixupNNTPProperties[];
extern RESUTIL_PROPERTY_ITEM NmJoinFixupIISProperties[];
extern RESUTIL_PROPERTY_ITEM NmJoinFixupNewMSMQProperties[];
extern RESUTIL_PROPERTY_ITEM NmJoinFixupMSDTCProperties[];
extern RESUTIL_PROPERTY_ITEM NmFixupVersionInfo[];
extern RESUTIL_PROPERTY_ITEM NmFixupClusterProperties[];
//
// Macros
//
#define NmIsValidNodeId(_id)    ( ((_id) >= ClusterMinNodeId) && \
                                  ((_id) <= NmMaxNodeId) )


//
// Init/Shutdown Routines
//
DWORD
NmInitialize(
    VOID
    );

VOID
NmShutdown(
    VOID
    );

DWORD
NmFormNewCluster(
    VOID
    );

DWORD
NmJoinCluster(
    IN RPC_BINDING_HANDLE  SponsorBinding
    );

DWORD
NmJoinComplete(
    OUT DWORD *EndSeq
    );

VOID
NmLeaveCluster(
    VOID
    );

DWORD
NmCreateNodeBindings(
    IN LPCWSTR lpszNodeId,
    IN LPCWSTR SponsorNetworkId
    );

BOOL
NmCreateActiveNodeBindingsCallback(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Object,
    IN LPCWSTR Name
    );

DWORD
NmJoinNodeToCluster(
    CL_NODE_ID  JoiningNodeId
    );

VOID
NmTimerTick(
    IN DWORD  MsTickInterval
    );

DWORD
NmGetJoinSequence(
    VOID
    );


DWORD NmGetClusterOperationalVersion(
    OUT LPDWORD pdwClusterHighestVersion,
    OUT LPDWORD pdwClusterLowestVersion,
    OUT LPDWORD pdwFlags
    );

//
// Node Object Management Routines
//
PNM_NODE
NmReferenceNodeById(
    IN DWORD NodeId
    );

CLUSTER_NODE_STATE
NmGetNodeState(
    IN PNM_NODE Node
    );

DWORD
NmPauseNode(
    IN PNM_NODE Node
    );

DWORD
NmResumeNode(
    IN PNM_NODE Node
    );

DWORD
NmEvictNode(
    IN PNM_NODE Node
    );

VOID
NmAdviseNodeFailure(
    IN DWORD NodeId,
    IN DWORD ErrorCode
    );

DWORD
NmEnumNodeInterfaces(
    IN  PNM_NODE          Node,
    OUT LPDWORD           InterfaceCount,
    OUT PNM_INTERFACE *   InterfaceList[]
    );

DWORD
NmGetNodeId(
    IN PNM_NODE Node
    );

DWORD
NmGetCurrentNumberOfNodes(
    void
    );

DWORD
NmGetMaxNodeId(
);

PNM_NODE
NmReferenceJoinerNode(
    IN DWORD       JoinerSequence,
    IN CL_NODE_ID  NodeId
    );

VOID
NmDereferenceJoinerNode(
    PNM_NODE  JoinerNode
    );

DWORD
WINAPI
NmNodeControl(
    IN PNM_NODE Node,
    IN PNM_NODE HostNode OPTIONAL,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

//
// Network Object Management Routines
//
CLUSTER_NETWORK_STATE
NmGetNetworkState(
    IN  PNM_NETWORK  Network
    );

DWORD
NmSetNetworkName(
    IN PNM_NETWORK   Network,
    IN LPCWSTR       Name
    );

DWORD
NmSetNetworkPriorityOrder(
    IN DWORD     NetworkCount,
    IN LPWSTR *  NetworkIdList
    );

DWORD
NmEnumInternalNetworks(
    OUT LPDWORD         NetworkCount,
    OUT PNM_NETWORK *   NetworkList[]
    );

DWORD
NmEnumNetworkInterfaces(
    IN  PNM_NETWORK       Network,
    OUT LPDWORD           InterfaceCount,
    OUT PNM_INTERFACE *   InterfaceList[]
    );

DWORD
WINAPI
NmNetworkControl(
    IN PNM_NETWORK Network,
    IN PNM_NODE HostNode OPTIONAL,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

//
// Interface Object Management Routines
//
CLUSTER_NETINTERFACE_STATE
NmGetInterfaceState(
    IN  PNM_INTERFACE  Interface
    );

DWORD
NmGetInterfaceForNodeAndNetwork(
    IN     LPCWSTR    NodeName,
    IN     LPCWSTR    NetworkName,
    OUT    LPWSTR *   InterfaceName
    );

DWORD
WINAPI
NmInterfaceControl(
    IN PNM_INTERFACE Interface,
    IN PNM_NODE HostNode OPTIONAL,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD NmPerformFixups(
    IN DWORD dwFixupType
    );

DWORD
    NmFixupNotifyCb(VOID);

//
// PnP Routines
//
VOID
NmPostPnpEvent(
    IN  CLUSNET_EVENT_TYPE   EventType,
    IN  DWORD                Context1,
    IN  DWORD                Context2
    );

//
// Connectoid related routines
//
VOID
NmCloseConnectoidAdviseSink(
    VOID
    );

DWORD
NmGetNodeHighestVersion(
    IN PNM_NODE Node
    );

DWORD
NmSetExtendedNodeState(
    IN CLUSTER_NODE_STATE State
    );

CLUSTER_NODE_STATE
NmGetExtendedNodeState(
    IN PNM_NODE Node
    );

//
// Intracluster RPC Monitoring and cancellation routines
//

VOID NmStartRpc(
    IN DWORD NodeId
    );

VOID NmEndRpc(
    IN DWORD NodeId
    );

// RPC ext error info dumping routine

VOID NmDumpRpcExtErrorInfo(
    RPC_STATUS status
    );

#endif  // _NM_INCLUDED

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\inc\tstpoint.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tstpoint.h

Abstract:

    Public interfaces for creating and manipulating cluster test points

Author:

    John Vert (jvert) 11/25/1996

Revision History:

--*/

#ifdef CLUSTER_TESTPOINT

typedef enum _TESTPOINT_TRIGGER {
    TestTriggerNever=0,
    TestTriggerAlways=1,
    TestTriggerOnce=2,
    TestTriggerTargetCount=3
} TESTPOINT_TRIGGER;

typedef enum _TESTPOINT_ACTION {
    TestActionTrue=0,
    TestActionExit=1,
    TestActionDebugBreak=2
} TESTPOINT_ACTION;

typedef WCHAR TESTPOINT_NAME[64];

typedef struct _TESTPOINT_ENTRY {
    TESTPOINT_NAME    TestPointName;
    TESTPOINT_TRIGGER Trigger;
    TESTPOINT_ACTION Action;
    DWORD HitCount;
    DWORD TargetCount;
} TESTPOINT_ENTRY, *PTESTPOINT_ENTRY;

//SS: when you add a testpoint, add the corresponding name in init\tstpoint.c
typedef enum _TESTPOINT {
    TestpointJoinFailPetition=0,
    TpFailNmJoinCluster=1,
    TpFailRegisterIntraClusterRpc=2,
    TpFailJoinCreateBindings=3,
    TpFailJoinPetitionForMembership=4,
    TpFailNmJoin=5,
    TpFailDmJoin=6,
    TpFailApiInitPhase1=7,
    TpFailFmJoinPhase1=8,
    TpFailDmUpdateJoinCluster=9,
    TpFailEvInitialize=10,
    TpFailNmJoinComplete=11,
    TpFailApiInitPhase2=12,
    TpFailFmJoinPhase2=13,
    TpFailLogCommitSize=14,
    TpFailClusterShutdown=15,
    TpFailLocalXsaction=16,
    TpFailOnlineResource=17,
    TpFailSecurityInit=18,
    TpFailOmInit=19,
    TpFailEpInit=20,
    TpFailDmInit=21,
    TpFailNmInit=22,
    TpFailGumInit=23,
    TpFailFmInit=24,
    TpFailLmInit=25,
    TpFailCpInit=26,
    TpFailNmPauseNode=27,
    TpFailNmResumeNode=28,
    TpFailNmEvictNodeAbort=29,
    TpFailNmEvictNodeHalt=30,
    TpFailNmCreateNetwork=31,
    TpFailNmSetNetworkPriorityOrder=32,
    TpFailNmSetNetworkPriorityOrder2=33,
    TpFailNmSetNetworkCommonProperties = 34,
    TpFailNmSetInterfaceInfoAbort=35,
    TpFailNmSetInterfaceInfoHalt=36,
    TpFailPreMoveWithNodeDown=37,
    TpFailPostMoveWithNodeDown=38,
    TpFailFormNewCluster=39,
    TestpointMax=40
} TESTPOINT;



#define TESTPT(x) if (TestpointCheck(x))

VOID
TestpointInit(
    VOID
    );

VOID
TestpointDeInit(
    VOID
    );

BOOL
TestpointCheck(
    IN TESTPOINT Testpoint
    );

#else // CLUSTER_TESTPOINT

#define TestpointInit()
#define TestpointDeInit()

#define TESTPT(x) if (0)

#endif // CLUSTER_TESTPOINT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\inc\mmapi.h ===
#ifndef  _MMAPI_H_
#define  _MMAPI_H_
/* ---------------------- MMapi.h ----------------------- */

/* This module contains cluster Membership Manager (MM) functions.
 *
 * These functions are for the sole use of the ClusterManager (CM).
 * All are privileged and local; no user can call them. Security is
 * not checked.  The module is not thread-aware; only a single thread
 * can use these functions at a time (unless otherwise noted).
 * Higher levels must ensure this. Blocking characteristics of the routines are
 * noted.
 *
 *
 * All nodes of the cluster must know their own unique nodenumber
 * within that cluster (a small int in the range 0..some_max-1). This
 * number is defined for the node at configuration time (either by the
 * user or by the setup code; this module doesn't care which) and is
 * essentially permanent.  (The node number allows indexing and
 * bitmask operations easily, where names and non-small ints don't).
 * There is no code in MM to detect illegal use of nodenumber, staleness
 * of node number, etc.
 *
 * Clusters may also be named and/or numbered. Nodes are named. This
 * module makes no use of such facilities; it is based entirely on
 * node-number.
 *
 * It is assumed that all use of routines here is done on nodes which
 * agree to be members of the same cluster. This module does not check
 * such things.
 *
 * Cluster network connectivity must also be provided:
 *
 * - A node N must specify the various paths by which it can
 *   communicate with every other node; each other node must define
 *   its communication paths back to N. Full connectivity must be
 *   guaranteed; each node must be able to talk directly to every
 *   other node (and the reverse); for fault-tolerance, communication
 *   paths must not only be replicated (minimally, duplicated) but
 *   must also use entirely independent wiring and drivers. TCP/IP
 *   lans and async connections are suggested.  Heartbeat traffic
 *   (which establishes cluster membership) may travel on any or all
 *   of the connectivity paths.  [Cluster management traffic may
 *   travel on any or all of the connectivity paths, but may be
 *   restricted to high-performance paths (eg, tcp/ip)].
 *
 * - A node must know the address of the cluster as a whole. This is
 *   an IP address which failsover (or a netbios name which fails
 *   over.. TBD) such that connecting to that cluster address provides
 *   a way to talk to a valid active member of the cluster, here
 *   called the PCM.
 *
 * Note that cluster connectivity is not defined by this interface;
 * it is assumed to be in a separate module. This module deals only in
 * communication to the cluster or communication to a nodenumber
 * within that cluster; it does not care about the details of how such
 * communication is done.
 *
 * Cluster connectivity must be known to all nodes in the cluster
 * and to a joining node, before the join attempt is made.
 *
 */
#ifdef __cplusplus
   extern "C" {
#endif /* __cplusplus */

#include <windows.h>
#include <bitset.h>
/* The following errors can be returned from the MM module: */

enum {
   MM_OK        = 0,  /* operation competed successfully           */
   MM_TIMEOUT   = 1,  /* operation timed out                       */
   MM_TRANSIENT = 2,  /* Transient failure; operation should be
                         retried                                   */
   MM_FAULT     = 3,  /* Illegal parameter; impossible condition,
                         etc.  NOTE: not all illegal calling
                         sequences will be detected.  Correct use
                         of the MM functions is a responsibility
                         of the CM caller.                         */
   MM_ALREADY   = 4,  /* node is already in the desired condition  */
   MM_NOTMEMBER = 5,  /* node needs to be a cluster member to
                         perform this operation                    */
     };


/* A node can be Up or Down */

typedef enum {  NODE_UP      = 1,
                NODE_DOWN    = 2
             }  NODESTATUS;


/* this type defines the cluster */

typedef struct tagCLUSTERINFO {
   DWORD      NumActiveNodes;   /* Number of nodes currently
                                   participating in this cluster   */
   LPDWORD    UpNodeList;       /* pointer to a <NumActiveNodes>
                                   sized array of node#s in the
                                   cluster which are up            */

   DWORD      clockPeriod;      /* current setting                 */
   DWORD      sendHBRate;       /* current setting                 */
   DWORD      rcvHBRate;        /* current setting                 */
} CLUSTERINFO, *LPCLUSTERINFO;

/*
 * UpNodeList is the array of active cluster members, in numeric order. The pointer
 * may be null. If non-null, it is assumed that the space is big enough.
 *
 */


/* the following are the typedefs for the callback functions from MM to
   the higher-level Cluster Mgr layer. */

typedef DWORD (*MMNodeChange)(IN DWORD node, IN NODESTATUS newstatus);

/* MMNodeChange is a function which will be called in this Up node
 *   whenever the MM declares another node Up or Down. This occurs after
 *   changing the current cluster membership (available via ClusterInfo) and
 *   in the last stage of Regroup. The CM may then
 *   initiate failovers, device ownership changes, user node status
 *   events, etc. This routine must be quick and must not block
 *   (acceptible time TBD).  Note that this will happen on all nodes
 *   of the cluster; it is up to the CM design to decide whether to
 *   issue events from only the PCM or from each CM node.
 *
 *   A node receives a NODE_UP callback for itself.
 *
 */

typedef DWORD (*MMNodesDown)(IN BITSET nodes);

/* MMNodesDown is a function that will be called at the end
 * of the regroup to indicate that node/multiple nodes is/are down.
 *
 * MMNodeChange is called only to indicate whether the node is up
 *
 */

typedef BOOL (*MMQuorumSelect)(void);

/* This is a callback to deal with the special case where only 2 members of the
 * cluster existed, and a Regroup incident occurred such that only one
 * member now survives OR there is a partition and both members survive (but cannot
 * know that). The intent of the Quorum function is to determine whether the other
 * node is alive or not, using mechanisms other than the normal heartbeating over the
 * normal comm links (eg, to do so by using non-heartbeat communication paths, such as
 * SCSI reservations). This function is called only in the case of where cluster
 * membership was previously exactly two nodes; and is called on any surviving node
 * of these two (which might mean it is called on one node or on both partitioned
 * nodes).
 *
 * If this routine returns TRUE, then the calling node stays in the cluster. If the
 * quorum algorithm determines that this node must die (because the other cluster member
 * exists), then this function should return FALSE;this will initiate an orderly
 * shutdown of the cluster services.
 *
 * In the case of a true partition, exactly one node should return TRUE.
 *
 * This routine may block and take a long time to execute (>2 secs).
 *
 */
typedef void (*MMHoldAllIO)(void);

/* This routine is called early (prior to Stage 1) in a Regroup incident.
 * It suspends all cluster IO (to all cluster-owned devices), and any relevant
 * intra-cluster messages, until resumed (or until this node dies).
 */

typedef void (*MMResumeAllIO)(void);

/* This is called during Regroup after the new cluster membership has been
 * determined, when it is known that this node will remain a member of the cluster (early in
 * Stage 4). All IO previously suspended by MMHoldAllIO should be resumed.
 */


typedef void (*MMMsgCleanup1) (IN DWORD deadnode);

/* This is called as the first part of intra-cluster message system cleanup (in stage 4).
 * It cancels all incoming messages from a failed node. In the case where multiple nodes are
 * evicted from the cluster, this function is called repeatedly, once for each node.
 *
 * This routine is synchronous and Regroup is suspended until it returns.
 * It must execute quickly.
 *
 */


typedef void (*MMMsgCleanup2)(IN BITSET nodes);

/* This is the second phase of message system cleanup (in stage 5). It cancels all outgoing
 * messages to dead nodes. Characteristics are as for Cleanup1.
 */



typedef void (*MMHalt)(IN DWORD haltcode);

/* This function is called whenever the MM detects that this node should immediately leave
 * the cluster (eg, on receipt of a poison packet or at some impossible error situation).
 * The HALT function should immediately initiate Cluster Management shutdown.
 * No MM functions should be called after this, other than MMShutdown.
 *
 * haltcode is a number identifying the halt reason.
 */

typedef void (*MMJoinFailed)(void);

/* This is called on a node being joined into the cluster when the join attempt in the PCM
 * fails. Following this callback, the node may petition to
 * join again, after cleaning up via a call to MMLeave.
 */


/* The operations on clusters are defined below: */

DWORD MMInit(
    IN DWORD             mynode,
    IN DWORD             MaxNodes,
    IN MMNodeChange      UpDownCallback,
    IN MMQuorumSelect    QuorumCallback,
    IN MMHoldAllIO       HoldIOCallback,
    IN MMResumeAllIO     ResumeIOCallback,
    IN MMMsgCleanup1     MsgCleanup1Callback,
    IN MMMsgCleanup2     MsgCleanup2Callback,
    IN MMHalt            HaltCallback,
    IN MMJoinFailed      JoinFailedCallback,
    IN MMNodesDown       NodesDownCallback
    );


/* This initialises various local MM data structures. It should be
 * called exactly once at CM startup time on every node. It must preceed any other
 * MM call. It sends no messages; the node need not have connectivity defined yet.
 * It does not block.
 *
 * Mynode is the node# of this node within the cluster.  This is
 *   assumed to be unique (but cannot be checked here to be so).
 *
 * The callbacks are described above.
 *
 *  Error returns:
 *
 *     MM_OK        Success.
 *
 *     MM_FAULT     Something impossible happened.
 *
 */


DWORD MMJoin(
    IN DWORD  joiningNode,
    IN DWORD  clockPeriod,
        IN DWORD  sendHBRate,
        IN DWORD  rcvHBRate,
    IN DWORD  joinTimeout
           );

/*
 *
 * This causes the specified node to join the active cluster.
 *
 * This routine should be issued by only one node of the cluster (the
 * PCM); all join attempts must be single-threaded (by code outside
 * this module).
 *
 * This routine may block and take a long time to execute.
 *
 *  [Prior to this being called:
 *     - joiningNode has communicated to the PCM of the cluster
 *       that it wants to join.
 *     - checks on validity of clustername, nodenumber, etc have been
 *       made; any security checks have been done;
 *     - connectivity paths have been established to/from the cluster
 *       and joiningNode.
 *     - the Registry etc has been downloaded.
 *  ]
 *
 *  joiningNode is the node number of the node being brought into
 *     the cluster.
 *
 *     If joiningNode = self (as passed in via MMinit), then the node
 *     will become the first member of a new cluster; if not, the node
 *     will be brought into the existing cluster.
 *
 *  clockPeriod, sendRate, and rcvRate can only be set by the first call (ie
 *     when the cluster is formed); later calls (from joining members)
 *     inherit the original cluster values. The entire cluster therefore operates
 *     with the same values.
 *
 *  clockPeriod is the basic clock interval which drives all internal
 *     MM activities, such as the various stages
 *     of membership reconfiguration, and eventually user-perceived
 *     recovery time. Unit= ms. This must be between the min and max
 *     allowed (values TBD; current best setting = 300ms).  Note that
 *     clockperiod is path independent and node independent. All
 *     cluster members regroup at the same rate over any/all available
 *     paths; all periods are identical in all nodes.
 *     A value of 0 implies default setting (currently 300ms).
 *
 *  sendHBrate is the multiple of clockPeriod at which heartbeats are sent. This
 *     must be between the min and max allowed (values TBD; current best setting = 4).
 *     A value of 0 implies default setting (currently 4).
 *
 *  rcvHBrate is the multiple of sendRate during which a heartbeat must arrive, or the
 *     node initiates a Regroup (probably resulting in some node leaving the cluster).
 *     This must be between min and max; (values TBD; current best setting = 2).
 *     A value of 0 implies default setting (currently 2).
 *
 *  The combination of these variables controls overall node-failure detection time,
 *  Regroup time, and the sensitivity of MM to transient comm errors. There are
 *  important considerations to be understood when changing these values; these,
 *  and then formula for calculating recovery times etc, are given elsewhere.
 *
 *
 *---  NOTES:
 *---     safe and appropriate min and max values for these have yet to be chosen.
 *---     Changing the values from the defaults is currently UNSUPPORTED and can have
 *---     serious consequences.
 *
 *  JoinTimeout is an overall timer on the entire Join attempt. If the
 *     node has not achieved full cluster membership in this time, the
 *     attempt is abandoned.
 *
 *
 *  Error returns:
 *
 *     MM_OK        Success; cluster joined. During or soon after the join, a
 *                  node-up callback will soon occur on this
 *                  and on all cluster member nodes (including the new member).
 *                  The CM is then safe to
 *                  assign ownership to cluster-owned devices on the
 *                  node, and to start failover/failback processing.
 *
 *                  Note: this routine establishes cluster membership.
 *                  However, it is usually inadvisable to start high
 *                  level CM failbacks immediately, because other
 *                  cluster members are often still joining. The CM
 *                  should typically wait a while to see whether other
 *                  nodes arrive in the cluster soon.
 *  Failure cases:
 *
 *  In the joiningNode, a joinFail callback occurs if the joiningNode node was
 *  in the middle of joining when the PCM's join attempt failed.(However, the callback
 *  is not guaranteed to happen; the joiningNode may not have started the
 *  join event yet). Any failure of the joiningNode to join the cluster
 *  should be followed by a call to MMLeave() (ignoring the return code);
 *  such failures may be from the JoinFail callback or just from overall
 *  timeouts on the entire join operation. Any subsequent attempt by
 *  joiningNode to re-join the cluster must be preceeded by a call to leave().
 *
 *     MM_ALREADY   The node is already a cluster member. This can
 *                  happen if a node reboots (or a CM is restarted)
 *                  and rejoins even before the cluster determines
 *                  that it has disappeared.  The CM should Leave and
 *                  reJoin.
 *
 *     MM_FAULT     Permanent failure; something is very bad:  the
 *                  node# is duplicated; some parameter is some
 *                  entirely illegal value.  The CM is in deep weeds.
 *
 *     MM_TRANSIENT Transient failure. The cluster state changed
 *                  during the operation (eg a node left the cluster).
 *                  The operation should be retried.
 *
 *     MM_TIMEOUT   Timeout; cluster membership not achieved in time.
 *
 *
 *
 */

DWORD MmSetRegroupAllowed( IN BOOL allowed);
 /* This function can be used to allow/disallow regroup participation
  * for the current node.
  *
  * Originally regroup was allowed immediately after receiving RGP_START
  * event. Since this happens before join is complete 
  * joiner can arbitrate and win, leaving
  * the other side without a quorum device.
  *
  * It is required to add MmSetRegroupAllowed(TRUE) at the very end
  * of the ClusterJoin. The node doesn't need to call MmSetRegroupAllowed(TRUE)
  * for ClusterForm, since MMJoin will call
  * MmSetRegroupAllowed(TRUE) for the cluster forming node
  *
  * MmSetRegroupAllowed(FALSE) can be used to disable regroup
  * participation during shutdown.
  *
  *
  * Errors:
  *
  *   MM_OK        : successful completition
  *
  *   MM_TRANSIENT : disallowing regroup when regroup is in progress
  *
  *   MM_ALREADY   : node is already in the desired condition
  *
  *
  */

void MMShutdown (void);


/* This shuts down the MM and Regroup services. Prior to this, the node should
 * voluntarily have left the cluster. Following this, all membership services
 * are non-functional; no further MM call may occur.
 *
 * THIS CALL MUST BE PRECEDED BY INCOMING MESSAGE CALLBACK SHUTDOWN.
 */


DWORD  MMLeave(void);

/*
 *
 * This function causes the current node to leave the active cluster (go to
 * Down state). The node no longer sends Regroup or Heartbeats to other cluster members.
 * A NodeDown event will not be generated in this node. A Regroup is triggered in the
 * remaining nodes (if this node was a member of the cluster).
 * A node-down callback will occur on all remaining cluster members.
 *
 * This initiates a clean, voluntary, leave operation.  For safety, prior to this,
 * the calling node's CM should arrange to lose ownership of all cluster-owned
 * devices assigned to this node (and so cause failovers, etc).
 *
 * This routine returns normally. The caller (the CM) should then shutdown
 * the cluster. MMShutdown or MMHalt may occur after this call, or
 * the node may be re-joined to the cluster. All apply-to-the-PCM-to-join
 * attempts by a node must be preceded by a call to MMleave().
 *
 * This routine may block.
 *
 * Errors:
 *
 *    MM_OK        :  Elvis has left the cluster.
 *
 *    MM_NOTMEMBER :  the node is not currently a cluster member.
 *
 */


DWORD MMEject( IN DWORD node );

/*
 *
 * This function causes the specified node to be ejected from the active cluster. The
 * targetted node will be sent a poison packet and will enter its MMHalt code. A Regroup
 * incident will be initiated. A node-down callback will occur on all remaining cluster
 * members.
 *
 *
 * Note that the targetted node is Downed before that node has
 * a chance to call any remove-ownership or voluntary failover code. As
 * such, this is very dangerous. This call is provided only as a last
 * resort in removing an insane node from the cluster; normal removal
 * of a node from the cluster should occur by CM-CM communication,
 * followed by the node itself doing a voluntary Leave on itself.
 *
 * This routine returns when the node has been told to die. Completion of the removal
 * occurs asynchronously, and a NodeDown event will be generated when successful.
 *
 * This routine may block.
 *
 * Errors:
 *
 *    MM_OK        :  The node has been told to leave the cluster.
 *
 *    MM_NOTMEMBER :  the node is not currently a cluster member.
 *
 *        MM_TRANSIENT :  My node state is in transition. OK to retry.
 *
 */

 DWORD MMNodeUnreachable (IN DWORD node);

/* This should be called by the CM's messaging module when a node
 * becomes unreachable FROM this node via all paths. This affects the connectivity
 * algorithm of the next Regroup incident. This function returns quickly
 * and without blocking.
 *
 * Errors:
 *
 *   Always MM_OK
 *
 */

 
/* info about the cluster */

//[Fixed] : NmAdviseNodeFailure doesnt seem to cause a regroup
//SS: this is a workaround
DWORD MMForceRegroup( IN DWORD node );



DWORD MMClusterInfo (IN OUT LPCLUSTERINFO clinfo);

/* Returns the current cluster information.
 *
 * This can be called in nodes which are not members of the cluster;
 * such calls always return NumActiveNodes = 0, because Down nodes
 * have no knowledge of current cluster membership.
 *
 * If called during a Regroup incident, this returns the currently known
 * membership. If membership changes, the Up/Down events are delivered
 * after the information used by ClusterInfo is updated. Users should be aware of
 * the inherent race condition between these two, and (if using both) should be aware
 * that Up and Down events may be seen from nodes which were already In or Not In
 * the cluster. (Typically, these events should just be discarded).
 *
 * This routine need not be single-threaded and does not block.
 *
 * Errors:
 *
 *   Always MM_OK
 *
 *
 */

BOOL MMIsNodeUp(IN DWORD node);

/* Returns true iff the node is a member of the current cluster.
 */

/* debugging and test only */


DWORD MMDiag(
        IN OUT  LPCSTR  messageBuffer,  // Diagnostic message
    IN          DWORD   maximumLength,  // maximum size of buffer
        IN OUT  LPDWORD ActualLength    // length of messageBuffer going in and coming out
           );

/* This function is called with "diagnostic" messages that are to be handled by the
 * membership manager.  The result of handling these messages is returned in the
 * buffer. This is for test purposes only.
 */

DWORD MMMapStatusToDosError(IN DWORD MMStatus);
DWORD MMMapHaltCodeToDosError(IN DWORD HaltCode);

#define MM_STOP_REQUESTED 1002 // Alias of RGP_SHUTDOWN_DURING_RGP in jrgpos.h

#define MM_INVALID_NODE 0

/* !!!!!!!! The following two functions return Dos error codes, not MmStatus codes */

DWORD MMSetQuorumOwner(
    IN DWORD NodeId,
    IN BOOL Block,
    OUT PDWORD pdwSelQuoOwnerId
    );
/*++

Routine Description:

    Inform Membership engine about changes in ownership of
    the quorum resource.

Arguments:

    NodeId - Node number to be set as a quorum owner.
             Code assumes that Node is either equal to MyNodeId.
             In this case the current node is about to become a
             quorum owner or it has a value MM_INVALID_NODE, when
             the owner decides to relinquish the quorum ownership

    Block -  if the quorum owner needs to relinquish the 
             quorum immediately no matter what (RmTerminate, RmFail),
             this parameter should be set to FALSE and to TRUE otherwise.

    pdwSelQuoOwnerId - If a regroup was in progress, this contains the 
            node id of the node that was chosen for arbitrating for the
            quorum in the last regroup.  If none was chosen, this contains
            MM_INVALID_NODE.

Return Value:

    ERROR_SUCCESS - QuorumOwner variable is set to specified value
    ERROR_RETRY - Regroup was in progress when this function
      was called and regroup engine decision conflicts with current assignment.

Comments:

 This function needs to be called before calls to
 RmArbitrate, RmOnline, RmOffline, RmTerminate, RmFailResource

 Depending on the result, the caller should either proceed with 
 Arbitrate/Online or Offline or return an error if MM_TRANSIENT is returned.

 If Block is set to TRUE, the call will block until the end of the regroup if
 the regroup was in progress on the moment of the call
 */

DWORD MMGetArbitrationWinner(
    OUT PDWORD NodeId
    );
/*++

Routine Description:

    Returns the node that won the arbitration during the last regroup
    or MM_INVALID_NODE if there was no arbitration performed.
    
Arguments:

    NodeId - a pointer to a variable that receives nodeid of 
             arbitration winner.
             
Return Value:

    ERROR_SUCCESS - success
    ERROR_RETRY - Regroup was in progress when this function
      was called. 
      
 */

VOID MMApproxArbitrationWinner(
    OUT PDWORD NodeId
    );
/*++

Routine Description:

    Returns the node that won the arbitration during the last regroup
    that was doing arbitration.

    The call will block if the regroup is in progress.
    
Arguments:

    NodeId - a pointer to a variable that receives nodeid of 
             arbitration winner.
             
Return Value:

    none
 */

VOID MMBlockIfRegroupIsInProgress(
    VOID
    );
/*++

Routine Description:

    The call will block if the regroup is in progress.
    
Arguments:

Return Value:

    none
 */

extern DWORD MmQuorumArbitrationTimeout;
extern DWORD MmQuorumArbitrationEqualizer;
/*++

    MmQuorumArbitrationTimeout (in seconds)

        How many seconds a node is allowed to spent arbitrating for the quorum,
        before giving up

    MmQuorumArbitrationEqualizer (in seconds)

        If quourum arbitration took less than specified number of seconds
        regroup engine will delay, so that the total arbitration time will 
        be equal MmQuorumArbitrationEqualizer. 
 */

#ifdef __cplusplus
}
#endif /* __cplusplus */

/* -------------------------- end ------------------------------- */
#endif /* _MMAPI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\inc\service.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    service.h

Abstract:

    Common top-level definitions for Cluster Service.

Author:

    Mike Massa (mikemas) 2-Jan-1996

Revision History:

--*/

#ifndef _SERVICE_INCLUDED
#define _SERVICE_INCLUDED

#define UNICODE 1
//#define CLUSTER_TESTPOINT

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <cluster.h>
#include <resapi.h>
#include <stdlib.h>
#include <wchar.h>
#include <tstpoint.h>
#include <clusverp.h>

//
// RPC protocols and endpoints used by the various RPC servers and clients
//
#define CLUSTER_RPC_PROTSEQ     L"ncadg_cluster"
#define CLUSTER_RPC_PORT        L"2"

#define CLUSTER_INTRACLUSTER_RPC_COM_TIMEOUT    RPC_C_BINDING_DEFAULT_TIMEOUT
#define CLUSTER_EXTROCLUSTER_RPC_COM_TIMEOUT    RPC_C_BINDING_DEFAULT_TIMEOUT
#define CLUSTER_JOINVERSION_RPC_COM_TIMEOUT     RPC_C_BINDING_DEFAULT_TIMEOUT

//
// Component header files
//
#include "clusrpc.h"
#include "ep.h"
#include "init.h"
#include "nm.h"
#include "config.h"
#include "om.h"
#include "gum.h"
#include "dm.h"
#include "fm.h"
#include "cp.h"
#include "api.h"
#include "logman.h"
#include "mmapi.h"
#include "clmsg.h"
#include "cnetapi.h"
#include "evtlog.h"

//
// Service Message IDs
//
#include "clusvmsg.h"

//
// Global Data
//
extern SERVICE_STATUS       CsServiceStatus;
extern PCLRTL_WORK_QUEUE    CsDelayedWorkQueue;
extern PCLRTL_WORK_QUEUE    CsCriticalWorkQueue;
extern LPWSTR               CsClusterName;
extern RPC_BINDING_VECTOR * CsRpcBindingVector;
extern RPC_BINDING_HANDLE   CsJoinSponsorBinding;
extern DWORD                CsClusterHighestVersion;
extern DWORD                CsClusterLowestVersion;
extern DWORD                CsClusterNodeLimit;
extern DWORD                CsMyHighestVersion;
extern DWORD                CsMyLowestVersion;
extern SUITE_TYPE           CsMyProductSuite;
extern BOOL                 CsUseAuthenticatedRPC;
extern LPWSTR               CsServiceDomainAccount;
extern DWORD                CsRPCSecurityPackage[];
extern LPWSTR               CsRPCSecurityPackageName[];
extern LONG                 CsRPCSecurityPackageIndex;
extern DWORD                CsNumberOfRPCSecurityPackages;

//
// Macros
//

#if NO_SHARED_LOCKS
//assume the lock is a critical section
#define INITIALIZE_LOCK(ResLock)         \
        InitializeCriticalSection(&(ResLock))

#define ACQUIRE_EXCLUSIVE_LOCK(ResLock)     \
        EnterCriticalSection(&(ResLock))

#define ACQUIRE_SHARED_LOCK(ResLock)          \
        EnterCriticalSection(&(ResLock))

#define RELEASE_LOCK(ResLock)                \
        LeaveCriticalSection(&(ResLock))

#define DELETE_LOCK(ResLock)                \
        DeleteCriticalSection(&(ResLock))

#else  // NO_SHARED_LOCKS
//assume the lock is a rtl resource

#define INITIALIZE_LOCK(ResLock)         \
        RtlInitializeResource(&(ResLock))

#define ACQUIRE_EXCLUSIVE_LOCK(ResLock)     \
        RtlAcquireResourceExclusive(&(ResLock), TRUE)

#define ACQUIRE_SHARED_LOCK(ResLock)          \
        RtlAcquireResourceShared(&(ResLock), TRUE)

#define RELEASE_LOCK(ResLock)                \
        RtlReleaseResource(&(ResLock))

#define DELETE_LOCK(ResLock)                \
        RtlDeleteResource(&(ResLock))

#endif // NO_SHARED_LOCKS
//
// Cluster initialization
//

//
// Service Control Routines
//
VOID
CsAnnounceServiceStatus(
    VOID
    );

VOID
CsRunService(
    VOID
    );

VOID
CsStopService(
    VOID
    );

DWORD
ClusterRegisterIntraclusterRpcInterface(
    VOID
    );

VOID
CsInconsistencyHalt(
    IN DWORD Status
    );


VOID CsGetClusterVersionInfo(
    IN PCLUSTERVERSIONINFO pClusterVersionInfo
    );

DWORD
WINAPI
CsClusterControl(
    IN PNM_NODE HostNode OPTIONAL,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

//
// Debugging
//
#if DBG

//
// Global Debug Flags
//
extern ULONG CsDebugFlags;

#define IF_DEBUG(arg)   if ( CS_DBG_## arg & CsDebugFlags)

#define CS_DBG_ALL           0xFFFFFFFF

#define CS_DBG_ERROR         0x00000001
#define CS_DBG_INIT          0x00000002
#define CS_DBG_CLEANUP       0x00000004

#else // DBG

#define IF_DEBUG(arg)  if (FALSE )

#endif // DBG

//
// Helpful macros for logging cluster service events
//

#define CsLogEvent(_level_, _msgid_)                \
    ClusterLogEvent0(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                0,                                  \
                NULL)

#define CsLogEvent1(_level_, _msgid_, _arg1_)       \
    ClusterLogEvent1(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                0,                                  \
                NULL,                               \
                (_arg1_))

#define CsLogEvent2(_level_, _msgid_, _arg1_, _arg2_)       \
    ClusterLogEvent2(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                0,                                  \
                NULL,                               \
                (_arg1_),                           \
                (_arg2_))

#define CsLogEvent3(_level_, _msgid_, _arg1_, _arg2_, _arg3_)       \
    ClusterLogEvent3(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                0,                                  \
                NULL,                               \
                (_arg1_),                           \
                (_arg2_),                           \
                (_arg3_))

#define CsLogEventData(_level_, _msgid_, _dwBytes_, _pData_)                \
    ClusterLogEvent0(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                (_dwBytes_),                        \
                (_pData_))

#define CsLogEventData1(_level_, _msgid_, _dwBytes_, _pData_, _arg1_)       \
    ClusterLogEvent1(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                (_dwBytes_),                        \
                (_pData_),                          \
                (_arg1_))

#define CsLogEventData2(_level_, _msgid_, _dwBytes_, _pData_, _arg1_, _arg2_)       \
    ClusterLogEvent2(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                (_dwBytes_),                        \
                (_pData_),                          \
                (_arg1_),                           \
                (_arg2_))

#define CsLogEventData3(_level_, _msgid_, _dwBytes_, _pData_, _arg1_, _arg2_, _arg3_)       \
    ClusterLogEvent3(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                (_dwBytes_),                        \
                (_pData_),                          \
                (_arg1_),                           \
                (_arg2_),                           \
                (_arg3_))

extern BOOL   CsDebugResmon;
extern LPWSTR CsResmonDebugCmd;
extern BOOL   CsNoVersionCheck;
extern BOOL   CsUpgrade;
extern BOOL   CsFirstRun;
extern BOOL   CsNoQuorumLogging;
extern BOOL   CsUserTurnedOffQuorumLogging;
extern BOOL   CsNoQuorum;
extern BOOL   CsResetQuorumLog;
extern BOOL   CsForceQuorum;
extern LPWSTR CsForceQuorumNodes;
extern BOOL   CsCommandLineForceQuorum;
extern BOOL   CsNoRepEvtLogging;
extern BOOL   CsDatabaseRestore;
extern LPWSTR CsDatabaseRestorePath;
extern BOOL   CsForceDatabaseRestore;
extern LPWSTR CsQuorumDriveLetter;
extern BOOL   CsRunningAsService;


#ifdef CLUSTER_TESTPOINT
//
// Test Points
//
// Codes:
//     Init   1-99
//     NM     100-199
//

extern DWORD CsTestPoint;
extern DWORD CsTestTrigger;
extern DWORD CsTestAction;
extern BOOL  CsPersistentTestPoint;

#define TESTPTMSG  \
            CsDbgPrint(LOG_NOISE, ("Hit test point %1!u!\n", CsTestPoint));

#define TESTPTCLEAR   if (!CsPersistentTestPoint) (CsTestPoint = 0)

#endif // CLUSTER_TESTPOINT

#endif // SERVICE_INCLUDED




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\init\excprpt.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    excprt.c
    
Abstract:

    This module uses imagehlp.dll to dump the stack when an exception occurs.

Author:

    Sunita Shrivastava(sunitas) 11/5/1997

Revision History:

--*/
#include "initp.h"
#include "dbghelp.h"


// Make typedefs for some IMAGEHLP.DLL functions so that we can use them
// with GetProcAddress
typedef BOOL (__stdcall * SYMINITIALIZEPROC)( HANDLE, LPSTR, BOOL );
typedef BOOL (__stdcall *SYMCLEANUPPROC)( HANDLE );

typedef BOOL (__stdcall * STACKWALKPROC)
           ( DWORD, HANDLE, HANDLE, LPSTACKFRAME, LPVOID,
            PREAD_PROCESS_MEMORY_ROUTINE,
            PFUNCTION_TABLE_ACCESS_ROUTINE,
            PGET_MODULE_BASE_ROUTINE, PTRANSLATE_ADDRESS_ROUTINE );

typedef LPVOID (__stdcall *SYMFUNCTIONTABLEACCESSPROC)( HANDLE, ULONG_PTR );

typedef ULONG_PTR (__stdcall *SYMGETMODULEBASEPROC)( HANDLE, ULONG_PTR );

typedef BOOL (__stdcall *SYMGETSYMFROMADDRPROC)
                            ( HANDLE, ULONG_PTR, PULONG_PTR, PIMAGEHLP_SYMBOL );



SYMINITIALIZEPROC _SymInitialize = 0;
SYMCLEANUPPROC _SymCleanup = 0;
STACKWALKPROC _StackWalk = 0;
SYMFUNCTIONTABLEACCESSPROC _SymFunctionTableAccess = 0;
SYMGETMODULEBASEPROC _SymGetModuleBase = 0;
SYMGETSYMFROMADDRPROC _SymGetSymFromAddr = 0;

//local prototypes for forward use
BOOL InitImagehlpFunctions();
void ImagehlpStackWalk( IN PCONTEXT pContext );
BOOL GetLogicalAddress(
        IN PVOID    addr, 
        OUT LPWSTR  szModule, 
        IN  DWORD   len, 
        OUT LPDWORD section, 
        OUT PULONG_PTR offset );

void GenerateExceptionReport(
    IN PEXCEPTION_POINTERS pExceptionInfo)
/*++

Routine Description:

    Top level exception handler for the cluster service process.
    Currently this just exits immediately and assumes that the
    cluster proxy will notice and restart us as appropriate.

Arguments:

    ExceptionInfo - Supplies the exception information

Return Value:

    None.

--*/
{    
    PCONTEXT pCtxt = pExceptionInfo->ContextRecord;


	
    if ( !InitImagehlpFunctions() )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                "[CS] Dbghelp.dll or its exported procs not found\r\n");

#if 0 
        #ifdef _M_IX86  // Intel Only!
        // Walk the stack using x86 specific code
        IntelStackWalk( pCtx );
        #endif
#endif        

        return;
    }

    ImagehlpStackWalk( pCtxt );

    _SymCleanup( GetCurrentProcess() );
	
}


BOOL InitImagehlpFunctions()
/*++

Routine Description:

    Initializes the imagehlp functions/data.

Arguments:

    None.

Return Value:

    None.

--*/
{
    HMODULE hModImagehlp = LoadLibraryW( L"DBGHELP.DLL" );

    
    if ( !hModImagehlp )
        return FALSE;

    _SymInitialize = (SYMINITIALIZEPROC)GetProcAddress( hModImagehlp,
                                                        "SymInitialize" );
    if ( !_SymInitialize )
        return FALSE;

    _SymCleanup = (SYMCLEANUPPROC)GetProcAddress( hModImagehlp, "SymCleanup" );
    if ( !_SymCleanup )
        return FALSE;

    _StackWalk = (STACKWALKPROC)GetProcAddress( hModImagehlp, "StackWalk" );
    if ( !_StackWalk )
        return FALSE;

    _SymFunctionTableAccess = (SYMFUNCTIONTABLEACCESSPROC)
                        GetProcAddress( hModImagehlp, "SymFunctionTableAccess" );

    if ( !_SymFunctionTableAccess )
        return FALSE;

    _SymGetModuleBase=(SYMGETMODULEBASEPROC)GetProcAddress( hModImagehlp,
                                                            "SymGetModuleBase");
                                                            
    if ( !_SymGetModuleBase )
        return FALSE;

    _SymGetSymFromAddr=(SYMGETSYMFROMADDRPROC)GetProcAddress( hModImagehlp,
                                                "SymGetSymFromAddr" );
    if ( !_SymGetSymFromAddr )
        return FALSE;

    if ( !_SymInitialize( GetCurrentProcess(), 0, TRUE ) )
        return FALSE;

    return TRUE;        
}


void ImagehlpStackWalk(
    IN PCONTEXT pContext )
/*++

Routine Description:

    Walks the stack, and writes the results to the report file 

Arguments:

    ExceptionInfo - Supplies the exception information

Return Value:

    None.

--*/
{
    STACKFRAME  sf;
    BYTE        symbolBuffer[ sizeof(IMAGEHLP_SYMBOL) + 512 ];
    PIMAGEHLP_SYMBOL pSymbol = (PIMAGEHLP_SYMBOL)symbolBuffer;
    ULONG_PTR symDisplacement = 0;      // Displacement of the input address,
                                        // relative to the start of the symbol
    DWORD       dwMachineType;                                        
    UCHAR       printBuffer[512];
    DWORD       nextPrtBufChar;

#if defined (_M_IX86)
    dwMachineType = IMAGE_FILE_MACHINE_I386;
#else if defined(_M_ALPHA)
    dwMachineType = IMAGE_FILE_MACHINE_ALPHA;
#endif    
    ClRtlLogPrint(LOG_CRITICAL,
               "[CS] CallStack:\r\n");

    ClRtlLogPrint(LOG_CRITICAL, 
               "[CS] Frame     Address\r\n");

    // Could use SymSetOptions here to add the SYMOPT_DEFERRED_LOADS flag

    memset( &sf, 0, sizeof(sf) );

#if defined (_M_IX86)
    // Initialize the STACKFRAME structure for the first call.  This is only
    // necessary for Intel CPUs, and isn't mentioned in the documentation.
    sf.AddrPC.Offset       = pContext->Eip;
    sf.AddrPC.Mode         = AddrModeFlat;
    sf.AddrStack.Offset    = pContext->Esp;
    sf.AddrStack.Mode      = AddrModeFlat;
    sf.AddrFrame.Offset    = pContext->Ebp;
    sf.AddrFrame.Mode      = AddrModeFlat;
#endif // _M_IX86

    while ( 1 )
    {
        if ( ! _StackWalk(  dwMachineType,
                            GetCurrentProcess(),
                            GetCurrentThread(),
                            &sf,
                            pContext,
                            0,
                            _SymFunctionTableAccess,
                            _SymGetModuleBase,
                            0 ) )
               break;
                            
        if ( 0 == sf.AddrFrame.Offset ) // Basic sanity check to make sure
            break;                      // the frame is OK.  Bail if not.

        nextPrtBufChar = sprintf(printBuffer,
                                 "     %08X  %08X  ",
                                  sf.AddrFrame.Offset, sf.AddrPC.Offset );

        // IMAGEHLP is wacky, and requires you to pass in a pointer to an
        // IMAGEHLP_SYMBOL structure.  The problem is that this structure is
        // variable length.  That is, you determine how big the structure is
        // at runtime.  This means that you can't use sizeof(struct).
        // So...make a buffer that's big enough, and make a pointer
        // to the buffer.  We also need to initialize not one, but TWO
        // members of the structure before it can be used.

        pSymbol->SizeOfStruct = sizeof(symbolBuffer);
        pSymbol->MaxNameLength = 512;
                        

        if ( _SymGetSymFromAddr(GetCurrentProcess(), sf.AddrPC.Offset,
                                &symDisplacement, pSymbol) )
        {
            sprintf(printBuffer+nextPrtBufChar,
                    "%hs+%p\n", 
                    pSymbol->Name, symDisplacement);
            
        }
        else    // No symbol found.  Print out the logical address instead.
        {
            WCHAR szModule[MAX_PATH] = L"";
            DWORD section = 0;
            ULONG_PTR offset = 0;

            GetLogicalAddress(  (PVOID)sf.AddrPC.Offset,
                                szModule, sizeof(szModule)/sizeof(WCHAR), 
                                &section, &offset );

            sprintf(printBuffer+nextPrtBufChar,
                    "%04X:%08p %s\n",
                    section, offset, szModule );
        }

        ClRtlLogPrint(LOG_CRITICAL,  "%1!hs!\n", printBuffer );
    }
}


BOOL GetLogicalAddress(
        IN PVOID addr, 
        OUT LPWSTR szModule, 
        IN DWORD len, 
        OUT LPDWORD section, 
        OUT PULONG_PTR offset )
/*++

Routine Description:

    Given a linear address, locates the module, section, and offset containing  
    that address.                                                               
    Note: the szModule paramater buffer is an output buffer of length specified 
    by the len parameter (in characters!)                                       

Arguments:

    ExceptionInfo - Supplies the exception information

Return Value:

    None.

--*/
{
    MEMORY_BASIC_INFORMATION mbi;
    ULONG_PTR hMod;
    // Point to the DOS header in memory
    PIMAGE_DOS_HEADER pDosHdr;
    // From the DOS header, find the NT (PE) header
    PIMAGE_NT_HEADERS pNtHdr;
    PIMAGE_SECTION_HEADER pSection;
    ULONG_PTR rva ;
    int   i;
    
    if ( !VirtualQuery( addr, &mbi, sizeof(mbi) ) )
        return FALSE;

    hMod = (ULONG_PTR)mbi.AllocationBase;

    if ( !GetModuleFileName( (HMODULE)hMod, szModule, len ) )
        return FALSE;

    rva = (ULONG_PTR)addr - hMod; // RVA is offset from module load address

    pDosHdr =  (PIMAGE_DOS_HEADER)hMod;
    pNtHdr = (PIMAGE_NT_HEADERS)(hMod + pDosHdr->e_lfanew);
    pSection = IMAGE_FIRST_SECTION( pNtHdr );
    
    // Iterate through the section table, looking for the one that encompasses
    // the linear address.
    for ( i = 0; i < pNtHdr->FileHeader.NumberOfSections;
            i++, pSection++ )
    {
        ULONG_PTR sectionStart = pSection->VirtualAddress;
        ULONG_PTR sectionEnd = sectionStart
                    + max(pSection->SizeOfRawData, pSection->Misc.VirtualSize);


        // Is the address in this section???
        if ( (rva >= sectionStart) && (rva <= sectionEnd) )
        {
            // Yes, address is in the section.  Calculate section and offset,
            // and store in the "section" & "offset" params, which were
            // passed by reference.
            *section = i+1;
            *offset = rva - sectionStart;
            return TRUE;
        }
    }

    return FALSE;   // Should never get here!
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\init\init.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    init.c

Abstract:

    This module provides the main cluster initialization.

Author:

    John Vert (jvert) 6/5/1996

Revision History:

--*/
extern "C" 
{
#include "initp.h"
#include <objbase.h>

RPC_STATUS ApipConnectCallback(
    IN RPC_IF_ID * Interface,
    IN void * Context
    );

}

#define CLUSTER_PRIORITY_CLASS HIGH_PRIORITY_CLASS

#include "CVssCluster.h"

//
// Global Data
//
RPC_BINDING_VECTOR *CsRpcBindingVector = NULL;
LPTOP_LEVEL_EXCEPTION_FILTER lpfnOriginalExceptionFilter = NULL;
BOOLEAN bFormCluster = TRUE;

//
// LocalData
//
BOOLEAN CspIntraclusterRpcServerStarted = FALSE;
HANDLE  CspMutex = NULL;
PCLRTL_WORK_QUEUE CspEventReportingWorkQueue = NULL;


//
// Prototypes
//
LONG
CspExceptionFilter(
    IN PEXCEPTION_POINTERS ExceptionInfo
    );


//
// Routines.
//

DWORD
CsGetServiceAccountInfo(
    VOID
    )
{
    DWORD status = ERROR_SUCCESS;
    SC_HANDLE schSCManager;
    SC_HANDLE serviceHandle = NULL;
    LPQUERY_SERVICE_CONFIG scConfigData = NULL;
    ULONG bytesNeeded;
    BOOL success;

    //
    // open a handle to the service controller manager to query the account
    // under which the cluster service was started
    //

    schSCManager = OpenSCManager(NULL,                   // machine (NULL == local)
                                 NULL,                   // database (NULL == default)
                                 SC_MANAGER_ALL_ACCESS); // access required

    if ( schSCManager == NULL ) {
        status = GetLastError();
        goto error_exit;
    }

    serviceHandle = OpenService(schSCManager,
                                CLUSTER_SERVICE_NAME,
                                SERVICE_ALL_ACCESS);

    if ( serviceHandle == NULL ) {
        status = GetLastError();
        goto error_exit;
    }

    success = QueryServiceConfig(serviceHandle, NULL, 0, &bytesNeeded);
    if ( !success ) {
        status = GetLastError();
        if ( status != ERROR_INSUFFICIENT_BUFFER ) {
            goto error_exit;
        } else {
            status = ERROR_SUCCESS;
        }
    }

    scConfigData = static_cast<LPQUERY_SERVICE_CONFIG>(LocalAlloc( LMEM_FIXED, bytesNeeded ));
    if ( scConfigData == NULL ) {
        status = GetLastError();
        goto error_exit;
    }

    success = QueryServiceConfig(serviceHandle,
                                 scConfigData,
                                 bytesNeeded,
                                 &bytesNeeded);
    if ( !success ) {
        status = GetLastError();
        goto error_exit;
    }

    CsServiceDomainAccount = static_cast<LPWSTR>( LocalAlloc(LMEM_FIXED,
                                        (wcslen( scConfigData->lpServiceStartName ) + 1 ) * sizeof(WCHAR)) );

    if ( CsServiceDomainAccount == NULL ) {
        status = GetLastError();
        goto error_exit;
    }

    wcscpy( CsServiceDomainAccount, scConfigData->lpServiceStartName );

error_exit:
    if ( serviceHandle != NULL ) {
        CloseServiceHandle( serviceHandle );
    }

    if ( schSCManager != NULL ) {
        CloseServiceHandle( schSCManager );
    }

    if ( scConfigData != NULL ) {
        LocalFree( scConfigData );
    }

    return status;
} // CsGetServiceAccountInfo



DWORD
EnableProcessPrivilege(
    LPWSTR PrivilegeName
    )
/*++

Routine Description:

    Enable the specified privilege for the process

Arguments:

    PrivilegeName - UNICODE name of privilege to enable

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD            status = ERROR_SUCCESS;
    HANDLE           hAccessToken;
    LUID             luidPrivilegeLUID;
    TOKEN_PRIVILEGES tpTokenPrivilege;

    if (!OpenProcessToken(GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                          &hAccessToken))
    {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[INIT] Failed to get process token, Status %1!u!.\n",
                    status);
        return status;
    }

    //
    // Get LUID of SeSecurityPrivilege privilege
    //
    if (!LookupPrivilegeValue(NULL,
                              PrivilegeName,
                              &luidPrivilegeLUID))
    {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[INIT] Failed to get LUID for privilege %1!ws!, Status %2!u!.\n",
                    PrivilegeName,
                    status);
        return status;
    }

    //
    // Enable the supplied privilege using the LUID just obtained
    //

    tpTokenPrivilege.PrivilegeCount = 1;
    tpTokenPrivilege.Privileges[0].Luid = luidPrivilegeLUID;
    tpTokenPrivilege.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    if (!AdjustTokenPrivileges(hAccessToken,
                               FALSE, // Do not disable all
                               &tpTokenPrivilege,
                               sizeof(TOKEN_PRIVILEGES),
                               NULL,
                               NULL))
    {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[INIT] Failed to adjust process token for privilege %1!ws!, Status %2!u!.\n",
                    PrivilegeName,
                    status);
    }

    return status;
} // EnableProcessPrivilege

VOID CspLogStartEvent(
    IN BOOL bJoin)
{
    LPWSTR  pszClusterName = NULL;
    LPWSTR  pszName = NULL;
    DWORD   dwClusterNameSize;
    DWORD   dwSize;
    DWORD   dwStatus;
    WCHAR   szUnknownClusterName[]=L"Unknown";
    
    pszClusterName = NULL;
    dwClusterNameSize = 0;
    dwStatus = DmQueryString(DmClusterParametersKey,
                          CLUSREG_NAME_CLUS_NAME,
                          REG_SZ,
                          &pszClusterName,
                          &dwClusterNameSize,
                          &dwSize);

    if (dwStatus != ERROR_SUCCESS)
    {
        //we dont treat this error as fatal, since
        //the cluster did start, but we really shouldnt get this
        ClRtlLogPrint(LOG_UNUSUAL,
            "[INIT] Couldnt get the cluster name, status=%1!u!\n",
                  dwStatus);
        pszName = szUnknownClusterName;                  
    }
    else
        pszName = pszClusterName;

    //log events in the cluster log to mark the start of the cluster server
    if (bJoin)
        CsLogEvent1(LOG_NOISE, SERVICE_SUCCESSFUL_JOIN, pszName);
    else
        CsLogEvent1(LOG_NOISE, SERVICE_SUCCESSFUL_FORM, pszName);

    if (pszClusterName)
        LocalFree(pszClusterName);
        
}            

DWORD
ClusterInitialize(
    VOID
    )
/*++

Routine Description:

    This is the main cluster initialization path. It calls the
    initialization routines of all the other components. It then
    attempts to join an existing cluster. If the existing cluster
    cannot be found, it forms a new cluster.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD       Status;
    DWORD       JoinStatus;
    DWORD       StringBufferSize = 0, StringSize = 0;
    SIZE_T      minWorkingSetSize;
    SIZE_T      maxWorkingSetSize;
    BOOL        bJoin;
    BOOL        bEvicted;
    PNM_NODE_ENUM2 pNodeEnum = NULL;
    HRESULT     hr = S_OK;

    ClRtlLogPrint(LOG_NOISE, "[INIT] ClusterInitialize called to start cluster.\n");

    //
    // give us a fighting chance on loaded server
    //

#if CLUSTER_PRIORITY_CLASS
    if ( !SetPriorityClass( GetCurrentProcess(), CLUSTER_PRIORITY_CLASS ) ) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[INIT] Failed to set cluster service priority class, Status %1!lx!.\n",
                   GetLastError() );
    }
#endif

    // initialize our product suite
    CsMyProductSuite = (SUITE_TYPE)ClRtlGetSuiteType();

    CL_ASSERT(CsMyProductSuite != 0);

    //
    // First check our OS to make sure it is ok to run.
    //
    if (!ClRtlIsOSValid() ||
        !ClRtlIsOSTypeValid()) {
        //
        // Bail out, machine is running something odd.
        //
        CsLogEvent(LOG_CRITICAL, SERVICE_FAILED_INVALID_OS);
        return(ERROR_REVISION_MISMATCH);
    }

    Status = ClRtlHasNodeBeenEvicted( &bEvicted );
    if ( Status != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
            "[CS] Unable to determine if this node was previously evicted or not, status %1!u!\n",
            Status);
        return Status;
    }

    if ( bEvicted != FALSE )
    {
        // This node has been evicted previously, but cleanup could not complete.
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[CS] This node has been evicted from the cluster, but cleanup was not completed. Restarting cleanup\n"
            );

        // Reinitiate cleanup
        hr = ClRtlCleanupNode(
                NULL,                   // Name of the node to be cleaned up (NULL means this node)
                60000,                  // Amount of time (in milliseconds) to wait before starting cleanup
                0                       // timeout interval in milliseconds
                );

        if ( FAILED( hr ) && ( hr != RPC_S_CALLPENDING ) )
        {
            Status = HRESULT_CODE( hr );
            ClRtlLogPrint(LOG_CRITICAL, 
                "[CS] Unable to reinitiate cleanup, status 0x%1!x!\n",
                hr);
        }
        else
        {
            Status = ERROR_SUCCESS;
        }

        return Status;
    }

    //
    // Acquire our named mutex in order to prevent multiple copies
    // of the cluster service from accidentally getting started.
    //
    CspMutex = CreateMutexW(
                   NULL,
                   FALSE,
                   L"ClusterServer_Running"
                   );

    if (CspMutex==NULL) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[CS] Unable to create cluster mutex, status %1!u!\n",
            Status);
        return Status;
    }

    if (WaitForSingleObject(CspMutex, 30000) == WAIT_TIMEOUT) {
        //
        // Somebody already has this mutex, exit immediately.
        //
        ClRtlLogPrint(LOG_CRITICAL, 
            "[CS] The Cluster Service is already running.\n");
        return(ERROR_SERVICE_ALREADY_RUNNING);
    }

    //
    // Set our unhandled exception filter so that if anything horrible
    // goes wrong, we can exit immediately.
    //
    lpfnOriginalExceptionFilter = SetUnhandledExceptionFilter(CspExceptionFilter);

    //
    // enabled the TCB privilege for the entire process
    //
    Status = EnableProcessPrivilege( SE_TCB_NAME );

    if ( Status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CS] Unable to set privilege %1!ws! for process, %2!u!\n",
                   SE_TCB_NAME,
                   Status);
        return(Status);
    }

    //
    // Next initialize the testpoint code
    //
    TestpointInit();

    g_pCVssWriterCluster = new CVssWriterCluster;
    if ( g_pCVssWriterCluster == NULL ) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CS] VSS: Unable to allocate VssWriter, %1!u!\n", Status);
        return(Status);
    }

    //
    // Create the global work queues.
    //
    CsDelayedWorkQueue = ClRtlCreateWorkQueue(CS_MAX_DELAYED_WORK_THREADS,
                                              THREAD_PRIORITY_NORMAL);
    if (CsDelayedWorkQueue == NULL) {
        Status = GetLastError();

        ClRtlLogPrint(LOG_CRITICAL,
                   "[CS] Unable to create delayed work queue, %1!u!\n",
                   Status);
        return(Status);
    }

    CsCriticalWorkQueue = ClRtlCreateWorkQueue(CS_MAX_CRITICAL_WORK_THREADS,
                                               THREAD_PRIORITY_ABOVE_NORMAL);
    if (CsCriticalWorkQueue == NULL) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CS] Unable to create critical work queue, %1!u!\n",
                   Status);
        return(Status);
    }

#if 0
    CspEventReportingWorkQueue = ClRtlCreateWorkQueue(1, THREAD_PRIORITY_NORMAL);
    if (CspEventReportingWorkQueue == NULL) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CS] Unable to create event reporting work queue, %1!u!\n",
                   Status);
        return(Status);
    }

    ClRtlEventLogSetWorkQueue( CspEventReportingWorkQueue );
#endif
    //
    // Init COM
    //

    Status = CoInitializeEx( NULL, COINIT_DISABLE_OLE1DDE | COINIT_MULTITHREADED );
    if ( !SUCCEEDED( Status )) {
        ClRtlLogPrint(LOG_CRITICAL, "[CS] Couldn't init COM %1!08X!\n", Status );
        return Status;
    }

    //
    // Initialize Object Manager
    //
    Status = OmInitialize();
#ifdef CLUSTER_TESTPOINT
    TESTPT( TpFailOmInit ) {
        Status = 99999;
    }
#endif

    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    //
    // Initialize Event Processor
    //
    Status = EpInitialize();
#ifdef CLUSTER_TESTPOINT
    TESTPT( TpFailEpInit ) {
        Status = 99999;
    }
#endif
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    //
    //  Chittur Subbaraman (chitturs) - 12/4/99
    //
    //  Initialize the restore database manager. This function is a NOOP
    //  if restore database is not being done. This function MUST be called
    //  before the DM is initialized.
    //
    Status = RdbInitialize();
    
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    //
    // Initialize Database Manager
    //
    Status = DmInitialize();
#ifdef CLUSTER_TESTPOINT
    TESTPT( TpFailDmInit ) {
        Status = 99999;
    }
#endif
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    //
    // Initialize Node Manager
    //
    Status = NmInitialize();
#ifdef CLUSTER_TESTPOINT
    TESTPT( TpFailNmInit ) {
        Status = 99999;
    }
#endif
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    //
    // Initialize Global Update Manager
    //
    Status = GumInitialize();
#ifdef CLUSTER_TESTPOINT
    TESTPT( TpFailGumInit ) {
        Status = 99999;
    }
#endif
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    //
    // Initialize the cluster wide event logging
    //
    if (!CsNoRepEvtLogging) {
        Status = EvInitialize();
            //if this fails, we still start the cluster service
        if ( Status != ERROR_SUCCESS ) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[INIT] Error calling EvInitialize, Status = %1!u!\n",
                Status
                );
        }
    }

    //
    // Initialize Failover Manager component
    //
    Status = FmInitialize();
#ifdef CLUSTER_TESTPOINT
    TESTPT( TpFailFmInit ) {
        Status = 99999;
    }
#endif
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    //
    // Initialize API
    //
    Status = ApiInitialize();
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    //
    // Initialize Log Manager component
    //
    Status = LmInitialize();
#ifdef CLUSTER_TESTPOINT
    TESTPT( TpFailLmInit ) {
        Status = 99999;
    }
#endif
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    //
    // Initialize the Checkpoint Manager component
    //
    Status = CpInitialize();
#ifdef CLUSTER_TESTPOINT
    TESTPT( TpFailCpInit ) {
        Status = 99999;
    }
#endif
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    //
    // find out what domain account we're running under. This is needed by
    // some packages
    //
    Status = ClRtlGetRunningAccountInfo( &CsServiceDomainAccount );
    if ( Status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_CRITICAL, "[CS] Couldn't determine Service Domain Account. status %1!u!\n",
                                  Status);
        return Status;
    }
    ClRtlLogPrint(LOG_NOISE, "[CS] Service Domain Account = %1!ws!\n",
                           CsServiceDomainAccount);

    //
    // Prepare the RPC server. This does not enable us to receive any calls.
    //
    Status = ClusterInitializeRpcServer();

    if (Status != ERROR_SUCCESS) {
       return(Status);
    }

    //
    // Read the cluster name from the database.
    //
    Status = DmQuerySz(
                 DmClusterParametersKey,
                 CLUSREG_NAME_CLUS_NAME,
                 &CsClusterName,
                 &StringBufferSize,
                 &StringSize
                 );

    if (Status != ERROR_SUCCESS) {
       ClRtlLogPrint(LOG_UNUSUAL, 
           "[CS] Unable to read cluster name from database. Service initialization failed.\n"
           );
       return(Status);
    }

    //
    // First, attempt to join the cluster.
    //
    ClRtlLogPrint(LOG_NOISE, 
        "[INIT] Attempting to join cluster %1!ws!\n",
        CsClusterName
        );

    bFormCluster = TRUE;
    JoinStatus = ClusterJoin();

    //
    // If this node was evicted when it was down, this error code is returned by the
    // sponsor when it tries to rejoin the cluster. In this case, initiate a cleanup
    // of this node and exit.
    //
    if ( JoinStatus == ERROR_CLUSTER_NODE_NOT_MEMBER )
    {
        DWORD   CleanupStatus;

        ClRtlLogPrint(LOG_UNUSUAL, 
            "[INIT] This node has been evicted from the cluster when it was unavailable. Initiating cleanup.\n"
            );

        // Initiate cleanup of this node.
        hr = ClRtlCleanupNode(
                NULL,                   // Name of the node to be cleaned up (NULL means this node)
                60000,                  // Amount of time (in milliseconds) to wait before starting cleanup
                0                       // timeout interval in milliseconds
                );

        if ( FAILED( hr ) && ( hr != RPC_S_CALLPENDING ) )
        {
            CleanupStatus = HRESULT_CODE( hr );
            ClRtlLogPrint(LOG_CRITICAL,
                "[INIT] Failed to initiate cleanup of this node, status 0x%1!x!\n",
                hr
                );
        }
        else
        {
            CleanupStatus = ERROR_SUCCESS;
        }

        return(CleanupStatus);
    }

    //
    //  Chittur Subbaraman (chitturs) - 10/27/98
    //
    //  If a database restore operation is requested, check whether
    //  you succeeded in establishing a connection. If so, check
    //  whether you are forced to restore the DB. If not, abort the
    //  whole operation and return. If you are forced to restore,
    //  you will first stop the service in other nodes and then
    //  try to form a cluster.
    //
    if ( CsDatabaseRestore == TRUE ) {
        if ( JoinStatus == ERROR_CLUSTER_NODE_UP ) {
            if ( CsForceDatabaseRestore == FALSE ) {
                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[INIT] Cannot restore DB while the cluster is up, service init failed\n"
                    );
                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[INIT] You may try to restart the service with the forcerestore option\n"
                    );
                RpcBindingFree(&CsJoinSponsorBinding);
                return(JoinStatus);
            }
            //
            //  At this point, a restore database operation is forced by
            //  the user. So, enumerate the cluster nodes with the help
            //  of the sponsor and then stop the services on all the
            //  cluster nodes.
            //
            Status = NmRpcEnumNodeDefinitions2(
                            CsJoinSponsorBinding,
                            0,
                            L"0",
                            &pNodeEnum
                     );
            RpcBindingFree(&CsJoinSponsorBinding);
            if ( Status != ERROR_SUCCESS ) {
               ClRtlLogPrint(LOG_UNUSUAL, 
                    "[INIT] Cannot force a restore DB: Unable to enumerate cluster nodes\n"
               );
               LocalFree( pNodeEnum );
               return (Status);
            }
            //
            //  Attempt to stop the clussvc on all nodes, except of course
            //  this node
            //
            Status = RdbStopSvcOnNodes (
                        pNodeEnum,
                        L"clussvc"
                     );
            LocalFree( pNodeEnum );
            if ( Status != ERROR_SUCCESS ) {
                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[INIT] Cannot force a restore DB: Unable to stop cluster nodes\n"
                );
                return(Status);
            } else {
                CL_LOGCLUSWARNING( CS_STOPPING_SVC_ON_REMOTE_NODES );
            }
        }
    }

    if (JoinStatus != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[INIT] Failed to join cluster, status %1!u!\n",
            JoinStatus
            );

        //
        // Forming a cluster will also attempt to arbitrate the quorum
        // resource.
        //
        bJoin = FALSE;

        //
        // If we failed join and found a sponsor, skip clusterform
        //
        if (bFormCluster == FALSE) {
            return (JoinStatus);
        }

        ClRtlLogPrint(LOG_NOISE, 
            "[INIT] Attempting to form cluster %1!ws!\n",
            CsClusterName
            );

        Status = ClusterForm();

        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[INIT] Failed to form cluster, status %1!u!.\n",
                Status
                );

            if (Status == ERROR_BUSY) {
                //
                // Couldn't arbitrate for the quorum disk. Return
                // the join status, since that is the real failure.
                //
                Status = JoinStatus;
            }

            CsLogEventData(
                LOG_CRITICAL,
                SERVICE_FAILED_JOIN_OR_FORM,
                sizeof(Status),
                &Status
                );

            return(Status);
        }
    }
    else {
        bJoin = TRUE;
    }

    //
    // We are now a full cluster member.
    //

    //
    // Register the ExtroCluster (join) RPC interface so we can sponsor a
    // joining node.
    //
    Status = ClusterRegisterExtroclusterRpcInterface();

    if (Status != RPC_S_OK) {
        return(Status);
    }

    //
    // Register the Join Version RPC interface so we can determine
    // the version of a joining node.
    //
    Status = ClusterRegisterJoinVersionRpcInterface();

    if (Status != RPC_S_OK) {
        return(Status);
    }

    //
    // Enable this node to participate in regroups.
    //
    MmSetRegroupAllowed(TRUE);

    //
    // Advertise that the node is fully up now
    //
    Status = NmSetExtendedNodeState( ClusterNodeUp );
    if (Status != ERROR_SUCCESS) {
        // NmSetExtendedNodeState logs an error //
        return(Status);
    }

    //
    // Node is UP, initialize and start listening for backup stuff.

    ClRtlLogPrint( LOG_NOISE, "[INIT] VSS: Initializing\n" );

    hr = g_pCVssWriterCluster->Initialize( g_VssIdCluster, // VSS_ID WriterId;
                                           L"Cluster Service Writer", // LPCWSTR WriterName;
                                           VSS_UT_SYSTEMSERVICE,  // VSS_USAGE_TYPE UsageType;
                                           VSS_ST_OTHER // VSS_SOURCE_TYPE SourceType;
                                           // <default> VSS_APPLICATION_LEVEL AppLevel;
                                           // <default> DWORD dwTimeoutFreeze
                                           );
    if ( FAILED( hr )) {
        ClRtlLogPrint( LOG_CRITICAL, "[INIT] VSS: Failed to initialize VSS, status 0x%1!x!\n", hr );
        Status = HRESULT_CODE( hr );
        return Status;
    }

    // Now we need to subscibe so that we get the events for backup.
    //
    ClRtlLogPrint( LOG_NOISE, "[INIT] VSS: Calling subscribe to register for backup events.\n" );
    hr = g_pCVssWriterCluster->Subscribe( );
    if ( FAILED( hr )) {
        ClRtlLogPrint( LOG_CRITICAL, "[INIT] VSS: Failed to subscribe to VSS, status 0x%1!x!\n", hr );
        Status = HRESULT_CODE( hr );
        return Status;
    } else {
        g_bCVssWriterClusterSubscribed = TRUE;
    }

    //
    // Chittur Subbaraman (chitturs) - 10/28/99
    //
    // Process FM join events that must be done AFTER this cluster
    // node is declared as fully UP.
    //
    if ( bJoin ) {
        FmJoinPhase3();
    }
    
    //
    // We are now going to attempt to increase our working set size. This,
    // plus the priority class boost, should allow the cluster service
    // to run a little better and be more responsive to cluster events.
    //
    if ( GetProcessWorkingSetSize( GetCurrentProcess(),
                                   &minWorkingSetSize,
                                   &maxWorkingSetSize ) )
    {
        if ( minWorkingSetSize < MIN_WORKING_SET_SIZE ) {
            minWorkingSetSize = MIN_WORKING_SET_SIZE;
        }

        if ( maxWorkingSetSize < MAX_WORKING_SET_SIZE ) {
            maxWorkingSetSize = MAX_WORKING_SET_SIZE;
        }

        if ( SetProcessWorkingSetSize( GetCurrentProcess(),
                                       minWorkingSetSize,
                                       maxWorkingSetSize ) )
        {
            //
            // now report what we set it to
            //
            if ( GetProcessWorkingSetSize( GetCurrentProcess(),
                                           &minWorkingSetSize,
                                           &maxWorkingSetSize ) )
            {
                ClRtlLogPrint(LOG_NOISE,
                              "[INIT] Working Set changed to [%1!u!, %2!u!].\n",
                              minWorkingSetSize,
                              maxWorkingSetSize);
            } else {
                ClRtlLogPrint(LOG_UNUSUAL,
                              "[INIT] Failed to re-read our working set size, Status %1!u!.\n",
                              GetLastError());
            }
        } else {
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[INIT] Failed to set our Min WS to %1!u!, Max WS to %2!u!, Status %3!u!.\n",
                          minWorkingSetSize,
                          maxWorkingSetSize,
                          GetLastError());
        }
    } else {
        ClRtlLogPrint(LOG_UNUSUAL, 
                   "[INIT] Failed to get our working set size, Status %1!u!.\n",
                    GetLastError()
                    );
    }

    CspLogStartEvent(bJoin);
    
#if 0
    //
    //  Chittur Subbaraman (chitturs) - 11/4/98
    //
    if ( CsForceDatabaseRestore == TRUE )
    {
        //
        //  If you stopped the service on any nodes for database restoration
        //  purposes, then start them now
        //
        RdbStartSvcOnNodes ( L"clussvc" );
    }
#endif

    {
        //
        // Vij Vasu (Vvasu) 24-AUG-2000
        //

        // Initiate the process that notifies interested listeners that the cluster
        // service has started up.
        HRESULT hr = ClRtlInitiateStartupNotification();

        if ( FAILED( hr ) ) {
            // If the process of notifying listeners could not be initiated, just log
            // the return code as a warning.

	    ClRtlLogPrint(LOG_UNUSUAL,
                          "[INIT] Error 0x%1!08lx! occurred trying to initiate cluster startup notifications.\n",
                          hr);
        }
    }

    ClRtlLogPrint(LOG_NOISE, "[INIT] Cluster started.\n");

    return(ERROR_SUCCESS);
}


VOID
ClusterShutdown(
    DWORD ExitCode
    )
/*++

Routine Description:

    Shuts down the cluster in reverse order than it was brought up.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    HRESULT hr = S_OK;
    //
    // Shutdown all components of the Cluster Service in approximately
    // the reverse order they we brought up.
    //
    ClRtlLogPrint(LOG_UNUSUAL,
               "[INIT] The cluster service is shutting down.\n");

    //
    // Enable this when we support ClusterShuttingDown state
    //
    // NmSetExtendedNodeState( ClusterNodeDown );               
    
#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailClusterShutdown) {
        return;
    }
#endif

    MmSetRegroupAllowed(FALSE);

    // if replicated event logging was initialized, shut it down
    if (!CsNoRepEvtLogging)
    {
        //
        // Shutdown the cluster eventlog manager- this deregisters with the
        // eventlog server.
        EvShutdown();
    }

    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

#if 0
    //
    //  Chittur Subbaraman (chitturs) - 5/8/2000
    //
    //  Don't shutdown DM updates for now so as to avoid spurious node shoot downs due to the locker
    //  node shutting down and hence the DM update succeeding when in fact it should fail.
    //
    DmShutdownUpdates();
#endif

    //
    // Move or offline all groups owned by this node. This will destroy
    // the resource monitors and the in-memory resource and group objects.
    //
    FmShutdownGroups();

    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();


    // Shutdown the dm- this flushes the log file and releases the dm hooks.
    DmShutdown();

    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

    // Unsubscribe from Vss
    //
    if ( g_bCVssWriterClusterSubscribed ) {
        ClRtlLogPrint( LOG_NOISE, "[INIT] VSS: Unsubscribing\n" );
        hr = g_pCVssWriterCluster->Unsubscribe( );
        if ( FAILED( hr ) ) {
            ClRtlLogPrint( LOG_CRITICAL, "[INIT] VSS: Failed to Unsubscribe from VSS, status 0x%1!x!\n", hr );
        } else {
            g_bCVssWriterClusterSubscribed = FALSE;
        }
    }

    // Delete our Vss instance if we have one (and if we are subscribed).
    //
    if (g_pCVssWriterCluster && (g_bCVssWriterClusterSubscribed == FALSE) ) {
        delete g_pCVssWriterCluster;
    }

    TestpointDeInit();

    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

    NmCloseConnectoidAdviseSink();

    CoUninitialize();

    //
    // Triger banishing regroup incident prompting
    // other nodes in the cluster to regroup this node out
    //
    MMLeave();

    //
    // Exit the process now... there are a number of circular dependencies
    // that have been built up during the 'life of the cluster'. There
    // is no easy way to unwind from here... so just exit out.
    //

    //
    // Announce that we are stopped only if we were successful in
    // initializing. The SC will not restart the service if we report that
    // we've stopped. Make sure the service status announcement is the last
    // thing done since there is a race between this thread and the main
    // thread that will prevent code after the announcement from being
    // executed.
    //


    ClRtlLogPrint(( ExitCode == ERROR_SUCCESS ) ? LOG_NOISE : LOG_CRITICAL, 
                  "[CS] Service Stopped. exit code = %1!u!\n\n", ExitCode);

    if ( ExitCode == ERROR_SUCCESS ) {
        CsLogEvent(LOG_NOISE, SERVICE_SUCCESSFUL_TERMINATION);

        CsServiceStatus.dwCurrentState = SERVICE_STOPPED;
        CsServiceStatus.dwControlsAccepted = 0;
        CsServiceStatus.dwCheckPoint = 0;
        CsServiceStatus.dwWaitHint = 0;
        CspSetErrorCode( ExitCode, &CsServiceStatus );

        CsAnnounceServiceStatus();
    } else {
        ExitCode = CspSetErrorCode( ExitCode, &CsServiceStatus );
    }

    //release the mutex so that the next one can acquire the mutex immediately
    ReleaseMutex(CspMutex);
    
    ExitProcess(ExitCode);

#if 0

    //
    // Everything after this point is what should happen in a clean shutdown.
    //

    // Shutdown the Failover Manager.
    FmShutdown();

    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

    //
    // Shutdown the Cluster Api.
    //
    ApiShutdown();

    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

    //
    // Stop the RPC server and deregister our endpoints & interfaces.
    //
    ClusterShutdownRpcServer();

    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

    //
    // At this point, all calls on the Intracluster and Extrocluster
    // RPC interfaces are complete and no more will be received.
    //
    // Note - Calls on the Clusapi interface are still possible.
    //

    //
    // Shutdown the Node Manager.
    //
    NmShutdown();

    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

    // Shutdown the Event Processor.
    EpShutdown();

    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

    LmShutdown();

    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

    CpShutdown();

    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

    //shutdown gum
    GumShutdown();

    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

    // Shutdown the Object Manager.
    OmShutdown();

    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();


    //
    // Destroy the global work queues
    //
    if (CsDelayedWorkQueue != NULL) {
        IF_DEBUG(CLEANUP) {
            ClRtlLogPrint(LOG_NOISE,"[CS] Destroying delayed work queue...\n");
        }

        ClRtlDestroyWorkQueue(CsDelayedWorkQueue);
        CsDelayedWorkQueue = NULL;
    }

    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

    if (CsCriticalWorkQueue != NULL) {
        IF_DEBUG(CLEANUP) {
            ClRtlLogPrint(LOG_NOISE,"[CS] Destroying critical work queue...\n");
        }

        ClRtlDestroyWorkQueue(CsCriticalWorkQueue);
        CsDelayedWorkQueue = NULL;
    }

    ClRtlEventLogSetWorkQueue( NULL );
    if (CspEventReportingWorkQueue != NULL) {
        IF_DEBUG(CLEANUP) {
            ClRtlLogPrint(LOG_NOISE,"[CS] Destroying event reporing work queue...\n");
        }

        ClRtlDestroyWorkQueue(CspEventReportingWorkQueue);
        CspEventReportingWorkQueue = NULL;
    }
    //
    // Free global data
    //
    LocalFree(CsClusterName);

    if (CspMutex != NULL) {
        CloseHandle(CspMutex);
        CspMutex = NULL;
    }

    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

    CsLogEvent(LOG_NOISE, SERVICE_SUCCESSFUL_TERMINATION);

#endif // 0

    return;
}


DWORD
ClusterForm(
    VOID
    )
/*++

Routine Description:

    Code path for initializing a new instance of the cluster. This
    is taken when there are no nodes active in the cluster.

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    DWORD       Status;
    PFM_GROUP   pQuoGroup;
    DWORD       dwError;
    DWORD       dwQuorumDiskSignature = 0;

    //
    // Initialize the event handler.
    //
    Status = EpInitPhase1();
    if ( Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CS] EpInitPhase1 failed, Status = %1!u!\n",
                   Status);
        return(Status);
    }

    //
    // The API server is required by FM, since it starts the resource monitor.
    //
    Status = ApiOnlineReadOnly();
    if ( Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CS] ApiInitPhase1 failed, Status = %1!u!\n",
                   Status);
        goto partial_form_exit;
    }

    //
    // Arbitrate for the quorum resource.
    //
    Status = FmGetQuorumResource(&pQuoGroup, &dwQuorumDiskSignature);

    if ( Status != ERROR_SUCCESS ) {
        if ( ( Status == ERROR_FILE_NOT_FOUND ) &&
             ( CsForceDatabaseRestore == TRUE ) ) {
            //
            //  Chittur Subbaraman (chitturs) - 10/30/98
            //
            //  Try to fix up the quorum disk signature and if successful
            //  try to get the quorum resource again. Note that the following
            //  function will attempt a fix up only if the CsForceDatabaseRestore
            //  flag is set.
            //
            if ( RdbFixupQuorumDiskSignature( dwQuorumDiskSignature ) ) {
                Status = FmGetQuorumResource( &pQuoGroup, NULL );
                if ( Status != ERROR_SUCCESS ) {
                    Status = ERROR_QUORUM_DISK_NOT_FOUND;
                    ClRtlLogPrint(LOG_CRITICAL,
                        "[INIT] Could not get quorum resource even after fix up, Status = %1!u!\n",
                        Status);
                    goto partial_form_exit;
                }
            } else {
                Status = ERROR_QUORUM_DISK_NOT_FOUND;
                ClRtlLogPrint(LOG_CRITICAL,
                   "[INIT] ClusterForm: Could not get quorum resource, Status = %1!u!\n",
                   Status);
                goto partial_form_exit;
            }
        } else {
            Status = ERROR_QUORUM_DISK_NOT_FOUND;
            ClRtlLogPrint(LOG_CRITICAL,
                   "[INIT] ClusterForm: Could not get quorum resource. No fixup attempted. Status = %1!u!\n",
                   Status);
            goto partial_form_exit;
        }
    }

    //
    // Call the Database Manager to update the cluster registry.
    //
    Status = DmFormNewCluster();
    if ( Status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CS] Error calling DmUpdateFormNewCluster, Status = %1!u!\n",
                   Status);
        goto partial_form_exit;
    }

    if (FmDoesQuorumAllowLogging() != ERROR_SUCCESS)
        CsNoQuorumLogging = TRUE;

    if (!CsNoQuorum)
    {
        // Bring the quorum resource online
        dwError  = FmBringQuorumOnline();
        if ((dwError == ERROR_IO_PENDING) || (dwError == ERROR_SUCCESS))
        {
            //this waits on an event for the quorum resorce to come online
            //when the quorum resource comes online, the log file is opened
            //if noquorumlogging flag is not specified
            if ((dwError = DmWaitQuorumResOnline()) != ERROR_SUCCESS)
            {
                ClRtlLogPrint(LOG_NOISE,
                    "[CS] Wait for quorum resource to come online failed, error=%1!u!\r\n",
                    dwError);
                Status = ERROR_QUORUM_RESOURCE_ONLINE_FAILED;
                goto partial_form_exit;
            }
        }
        else
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[CS] couldnt bring quorum resource online, Error =%1!u!\n",
                dwError);
            CL_LOGFAILURE(dwError);
            Status = ERROR_QUORUM_RESOURCE_ONLINE_FAILED;
            goto partial_form_exit;

        }
    }

    //update status with scm, the quorum resource may take a while to come online
    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

    if (!CsNoQuorumLogging)
    {
        //roll the Cluster Log File
        if ((Status = DmRollChanges()) != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[CS] Error calling DmRollChanges, Status = %1!u!\n",
                Status);
            goto partial_form_exit;
        }
    }

    //
    // Close the groups/resources created by fm except for the quorum
    // resource. The in memory data base needs to be created again with
    // the new rolled changes
    //
    Status = FmFormNewClusterPhase1(pQuoGroup);
    if ( Status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CS] Error calling FmOnline, Status = %1!u!\n",
                   Status);
        goto partial_form_exit;
    }

#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailFormNewCluster) {
        Status = 999999;
        goto partial_form_exit;
    }
#endif


    //
    // Start up the Node Manager. This will form a cluster at the membership
    // level.
    //
    Status = NmFormNewCluster();
    if ( Status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CS] Error calling NmOnline, Status = %1!u!\n",
                   Status);
        goto partial_form_exit;
    }

    //
    //call any registry fixup callbacks, if they are registered.
    //This is useful for upgrades/uninstalls if you want to clean up
    //the registry
    Status = NmPerformFixups(NM_FORM_FIXUP);
    if ( Status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CS] Error calling NmPerformFixups, Status = %1!u!\n",
                   Status);
        goto partial_form_exit;
    }

    //
    // The API server can now be brought fully online. This enables us
    // to receive calls.
    //
    Status = ApiOnline();
    if ( Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CS] ApiInitPhase2 failed, Status = %1!u!\n",
                   Status);
        goto partial_form_exit;
    }


    //update status for scm
    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

    //
    // Call the Failover Manager Phase 2 routine next.
    // Create the groups and resources.
    //
    Status = FmFormNewClusterPhase2();
    if ( Status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CS] Error calling FmOnline, Status = %1!u!\n",
                   Status);
        goto partial_form_exit;
    }
    
    //
    // Fire up the intracluster RPC server so we can receive calls.
    //
    Status = ClusterRegisterIntraclusterRpcInterface();

    if ( Status != ERROR_SUCCESS ) {
        goto partial_form_exit;
    }


    //
    // Finish initializing the cluster wide event logging
    //
    // ASSUMPTION: this is called after the NM has established cluster
    // membership.
    //
    if (!CsNoRepEvtLogging)
    {
        //is replicated logging is not disabled
        Status = EvOnline();

        if ( Status != ERROR_SUCCESS ) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CS] Error calling EvOnline, Status = %1!u!\n",
                       Status);
        }
    }
    if (!CsNoQuorumLogging)
    {
        //check if all nodes are up, if not take a checkpoint and
        //turn quorum logging on
        Status = DmUpdateFormNewCluster();
        if ( Status != ERROR_SUCCESS ) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CS] Error calling DmCompleteFormNewCluster, Status = %1!u!\n",
                       Status);
        }
    }

    ClRtlLogPrint(LOG_NOISE, "[INIT] Successfully formed a cluster.\n");

    return(ERROR_SUCCESS);


partial_form_exit:

    ClRtlLogPrint(LOG_NOISE, "[INIT] Cleaning up failed form attempt.\n");

    return(Status);
}



VOID
ClusterLeave(
    VOID
    )
/*++

Routine Description:

    Removes the local node from an active cluster or cleans up after
    a failed attempt to join or form a cluster.

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    ClRtlLogPrint(LOG_NOISE, "[INIT] Leaving cluster\n");

    //
    // Turn off the cluster API
    //
    ApiOffline();

    //
    // If we are a cluster member, leave now.
    //
    NmLeaveCluster();

    ClusterDeregisterRpcInterfaces();

    return;

}  // Cluster Leave


//
// RPC Server Control routines
//

RPC_STATUS
ClusterInitializeRpcServer(
    VOID
    )
/*++

Routine Description:

    Initializes the RPC server for the cluster service.

Arguments:

    None.

Return Value:

    RPC_S_OK if the routine succeeds. An RPC error code if it fails.

--*/
{
    RPC_STATUS          Status;
    SECURITY_DESCRIPTOR SecDescriptor;
    DWORD               i;
    DWORD               retry;
    DWORD               packagesRegistered = 0;

    ClRtlLogPrint(LOG_NOISE, "[CS] Initializing RPC server.\n");

    //
    // Enable authentication of calls to our RPC interfaces. For NTLM,
    // the PrincipleName is ignored, but we'll need to supply one if we
    // switch authentication services later on. Note that it is not
    // necessary to specify an authentication service for each interface.
    //

    for ( i = 0; i < CsNumberOfRPCSecurityPackages; ++i ) {

        Status = RpcServerRegisterAuthInfo(NULL,
                                           CsRPCSecurityPackage[ i ],
                                           NULL,
                                           NULL);

        if (Status == RPC_S_OK) {
            ++packagesRegistered;
        } else {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CS] Unable to register %1!ws! authentication for RPC, status %2!u!.\n",
                        CsRPCSecurityPackageName[ i ],
                        Status);
        }
    }

    if ( packagesRegistered == 0 ) {
        return ERROR_CLUSTER_NO_RPC_PACKAGES_REGISTERED;
    }

    //
    // Bind to UDP. This transport will be used by remote clients to
    // access the clusapi interface and by cluster nodes to
    // access the extrocluster (join) interface. This uses a dynamic
    // endpoint.
    //
    Status = RpcServerUseProtseq(
                 TEXT("ncadg_ip_udp"),
                 RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                 NULL);

    if (Status != RPC_S_OK) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[INIT] Unable to bind RPC to UDP, status %1!u!.\n",
            Status);
        return(Status);
    }

    //
    // Figure out which UDP endpoint we got so we can register it with
    // the endpoint mapper later. We must do this before we register any
    // other protocol sequences, or they will show up in the vector.
    // Groveling the binding vector for a specific transport is no fun.
    //
    CL_ASSERT( CsRpcBindingVector == NULL);

    Status = RpcServerInqBindings(&CsRpcBindingVector);

    if (Status != RPC_S_OK) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[INIT] Unable to obtain RPC binding vector, status %1!u!.\n",
            Status);
        return(Status);
    }


    // ncalrpc needs a security descriptor.



    InitializeSecurityDescriptor(
                    &SecDescriptor,
                    SECURITY_DESCRIPTOR_REVISION
                    );

    //get a null dacl
    if (!SetSecurityDescriptorDacl(&SecDescriptor, TRUE, NULL,FALSE))                 // Not defaulted
    {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[INIT] Unable to obtain a NULL dacl %1!u!.\n",
            Status);
        return(Status);
    }


    //
    // Bind to LPC. This transport will be used by clients running on this
    // system to access the clusapi interface. This uses a well-known
    // endpoint.
    //
    Status = RpcServerUseProtseqEp(
                 TEXT("ncalrpc"),
                 RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                 TEXT("clusapi"),
                 &SecDescriptor);

    if (Status != RPC_S_OK) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[INIT] Unable to bind RPC to LPC, status %1!u!.\n",
            Status);
        return(Status);
    }

    //
    // Bind to CDP (Cluster Datagram Protocol). This transport will be used
    // for the intracluster interface. This uses a well-known endpoint.
    //

    // GN: Sometimes it takes a couple of seconds for resrcmon to go away after
    // a clean shutdown. When SCM tries to restart the service the following call will fail.
    // In order to overcome this we will give up only if we couldn't bind RPC to CDP
    // 10 times with 1 second in between the calls
    //

    retry = 10;

    for (;;) {
        Status = RpcServerUseProtseqEp(
                     CLUSTER_RPC_PROTSEQ,
                     1,                      // Max calls
                     CLUSTER_RPC_PORT,
                     NULL);
        if (Status != RPC_S_DUPLICATE_ENDPOINT || retry == 0) {
            break;
        }
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[INIT] Unable to bind RPC to CDP, status %1!u!. Retrying...\n",
            Status);
        Sleep(1000);
        --retry;
    }

    if (Status != RPC_S_OK) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[INIT] Unable to bind RPC to CDP, status %1!u!.\n",
            Status);
        return(Status);
    }

    //
    // Start our RPC server. Note that we will not get any calls until
    // we register our interfaces.
    //
    Status = RpcServerListen(
                 CS_CONCURRENT_RPC_CALLS,
                 RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                 TRUE);

    if ((Status != RPC_S_OK) && (Status != RPC_S_ALREADY_LISTENING)) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[CS] Unable to start RPC server, status %1!u!.\n",
            Status
            );
        return(Status);
    }

    RpcSsDontSerializeContext();

    return(RPC_S_OK);
}



DWORD
ClusterRegisterIntraclusterRpcInterface(
    VOID
    )
{
    DWORD Status;

    Status = RpcServerRegisterIfEx(
                 s_IntraCluster_v2_0_s_ifspec,
                 NULL,
                 NULL,
                 0,
                 RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                 CsUseAuthenticatedRPC ? reinterpret_cast<RPC_IF_CALLBACK_FN(__stdcall *)>( ApipConnectCallback ) : NULL
                 //                 CsUseAuthenticatedRPC ? ApipConnectCallback : NULL
                 );

    if (Status != RPC_S_OK) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[INIT] Unable to register the IntraCluster interface, Status %1!u!.\n",
            Status
            );
        return(Status);
    }

    CspIntraclusterRpcServerStarted = TRUE;

    return(ERROR_SUCCESS);

}  // ClusterRegisterIntraclusterRpcInterface


DWORD
ClusterRegisterExtroclusterRpcInterface(
    VOID
    )
{
    DWORD Status;

    Status = RpcServerRegisterIfEx(
                 s_ExtroCluster_v2_0_s_ifspec,
                 NULL,
                 NULL,
                 0,
                 RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                 CsUseAuthenticatedRPC ? reinterpret_cast<RPC_IF_CALLBACK_FN( __stdcall *)>( ApipConnectCallback ) : NULL
                 // CsUseAuthenticatedRPC ? ApipConnectCallback : NULL
                 );

    if (Status != RPC_S_OK) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[INIT] Unable to register the ExtroCluster interface, status %1!u!.\n",
            Status
            );
        return(Status);
    }

    CL_ASSERT( CsRpcBindingVector != NULL);

    Status = RpcEpRegister(
                 s_ExtroCluster_v2_0_s_ifspec,
                 CsRpcBindingVector,
                 NULL,
                 L"Microsoft Extrocluster Interface"
                 );

    if (Status != RPC_S_OK) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[INIT] Unable to register the ExtroCluster interface endpoint, status %1!u!.\n",
            Status
            );
        NmDumpRpcExtErrorInfo(Status);
        return(Status);
    }

    return(ERROR_SUCCESS);

}  // ClusterRegisterExtroclusterRpcInterface


DWORD
ClusterRegisterJoinVersionRpcInterface(
    VOID
    )
{
    DWORD Status;

    Status = RpcServerRegisterIfEx(
                 s_JoinVersion_v2_0_s_ifspec,
                 NULL,
                 NULL,
                 0,
                 RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                 CsUseAuthenticatedRPC ? reinterpret_cast<RPC_IF_CALLBACK_FN *>( ApipConnectCallback ) : NULL
                 // CsUseAuthenticatedRPC ? ApipConnectCallback : NULL
                 );

    if (Status != RPC_S_OK) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[INIT] Unable to register the JoinVersion interface, status %1!u!.\n",
            Status
            );
        return(Status);
    }

    CL_ASSERT( CsRpcBindingVector != NULL);

    Status = RpcEpRegister(
                 s_JoinVersion_v2_0_s_ifspec,
                 CsRpcBindingVector,
                 NULL,
                 L"Microsoft JoinVersion Interface"
                 );

    if (Status != RPC_S_OK) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[INIT] Unable to register the JoinVersion interface endpoint, status %1!u!.\n",
            Status
            );
        NmDumpRpcExtErrorInfo(Status);
        return(Status);
    }

    return(ERROR_SUCCESS);

}  // ClusterRegisterJoinVersionRpcInterface


VOID
ClusterDeregisterRpcInterfaces(
    VOID
    )
{
    RPC_STATUS  Status;


    ClRtlLogPrint(LOG_NOISE, 
        "[INIT] Deregistering RPC endpoints & interfaces.\n"
        );

    //
    // Deregister the Extrocluster and JoinVersion interface endpoints.
    // There is no endpoint for the Intracluster interface.
    //
    if (CsRpcBindingVector != NULL) {
        Status = RpcEpUnregister(
                     s_ExtroCluster_v2_0_s_ifspec,
                     CsRpcBindingVector,
                     NULL
                     );

        if ((Status != RPC_S_OK) && (Status != EPT_S_NOT_REGISTERED)) {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[INIT] Failed to deregister endpoint for ExtroCluster interface, status %1!u!.\n",
                Status
                );
        }

        Status = RpcEpUnregister(
                     s_JoinVersion_v2_0_s_ifspec,
                     CsRpcBindingVector,
                     NULL
                     );

        if ((Status != RPC_S_OK) && (Status != EPT_S_NOT_REGISTERED)) {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[INIT] Failed to deregister endpoint for JoinVersion interface, status %1!u!.\n",
                Status
                );
        }
    }

    //
    // Deregister the interfaces
    //
    Status = RpcServerUnregisterIf(
                 s_ExtroCluster_v2_0_s_ifspec,
                 NULL,
                 1    // Wait for outstanding calls to complete
                 );

    if ((Status != RPC_S_OK) && (Status != RPC_S_UNKNOWN_IF)) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[INIT] Unable to deregister the ExtroCluster interface, Status %1!u!.\n",
            Status
            );
    }

    Status = RpcServerUnregisterIf(
                 s_JoinVersion_v2_0_s_ifspec,
                 NULL,
                 1    // Wait for outstanding calls to complete
                 );

    if ((Status != RPC_S_OK) && (Status != RPC_S_UNKNOWN_IF)) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[INIT] Unable to deregister the JoinVersion interface, Status %1!u!.\n",
            Status
            );
    }

    Status = RpcServerUnregisterIf(
                 s_IntraCluster_v2_0_s_ifspec,
                 NULL,
                 1   // Wait for outstanding calls to complete
                 );

    if ((Status != RPC_S_OK) && (Status != RPC_S_UNKNOWN_IF)) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[INIT] Unable to deregister the IntraCluster interface, Status %1!u!.\n",
            Status
            );
    }

    return;

}  // ClusterDeregisterRpcInterfaces


VOID
ClusterShutdownRpcServer(
    VOID
    )
{
    RPC_STATUS  Status;


    ClRtlLogPrint(LOG_NOISE, "[INIT] Shutting down RPC server.\n");

    ClusterDeregisterRpcInterfaces();

    Status = RpcMgmtStopServerListening(NULL);

    if ((Status != RPC_S_OK) && (Status != RPC_S_NOT_LISTENING)) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[INIT] Failed to shutdown RPC server, status %1!u!.\n",
            Status
            );
    }

#if 0

    //
    // Note - We really should wait for all outstanding calls to complete,
    //        but we can't because there is no way to shutdown any
    //        pending API GetNotify calls.
    //
    Status = RpcMgmtWaitServerListen();

    if ((Status != RPC_S_OK) && (Status != RPC_S_NOT_LISTENING)) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[INIT] Failed to wait for all RPC calls to complete, status %1!u!.\n",
            Status
            );
    }

#endif // 0

    if (CsRpcBindingVector != NULL) {
        RpcBindingVectorFree(&CsRpcBindingVector);
        CsRpcBindingVector = NULL;
    }

    return;

}  // ClusterShutdownRpcServer



LONG
CspExceptionFilter(
    IN PEXCEPTION_POINTERS ExceptionInfo
    )
/*++

Routine Description:

    Top level exception handler for the cluster service process.
    Currently this just exits immediately and assumes that the
    cluster proxy will notice and restart us as appropriate.

Arguments:

    ExceptionInfo - Supplies the exception information

Return Value:

    None.

--*/

{
    ClRtlLogPrint(LOG_CRITICAL,
               "[CS] Exception. Code = 0x%1!lx!, Address = 0x%2!lx!\n",
                ExceptionInfo->ExceptionRecord->ExceptionCode,
                ExceptionInfo->ExceptionRecord->ExceptionAddress);
    ClRtlLogPrint(LOG_CRITICAL,
                "[CS] Exception parameters: %1!lx!, %2!lx!, %3!lx!, %4!lx!\n",
                ExceptionInfo->ExceptionRecord->ExceptionInformation[0],
                ExceptionInfo->ExceptionRecord->ExceptionInformation[1],
                ExceptionInfo->ExceptionRecord->ExceptionInformation[2],
                ExceptionInfo->ExceptionRecord->ExceptionInformation[3]);

    GenerateExceptionReport(ExceptionInfo);

    if (lpfnOriginalExceptionFilter)
        lpfnOriginalExceptionFilter(ExceptionInfo);

    // the system level handler will be invoked if we return
    // EXCEPTION_CONTINUE_SEARCH - for debug dont terminate the process

    if ( IsDebuggerPresent()) {
        return(EXCEPTION_CONTINUE_SEARCH);
    } else {

#if !CLUSTER_BETA
        TerminateProcess( GetCurrentProcess(),
                          ExceptionInfo->ExceptionRecord->ExceptionCode );
#endif

        return(EXCEPTION_CONTINUE_SEARCH);
    }
}



VOID
CsInconsistencyHalt(
    IN DWORD Status
    )
{
    WCHAR  string[16];
    DWORD  status;
   
    //
    //  Chittur Subbaraman (chitturs) - 12/17/99
    //
    //  Announce your status to the SCM as SERVICE_STOP_PENDING so that 
    //  it does not affect restart. Also, it could let clients learn 
    //  of the error status.
    //
    CsServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
    CsServiceStatus.dwControlsAccepted = 0;
    CsServiceStatus.dwCheckPoint = 0;
    CsServiceStatus.dwWaitHint = 0;
    status = CspSetErrorCode( Status, &CsServiceStatus );

    CsAnnounceServiceStatus();

    wsprintfW(&(string[0]), L"%u", Status);

    ClRtlLogPrint(LOG_CRITICAL, 
        "[CS] Halting this node to prevent an inconsistency within the cluster. Error status = %1!u!\n",
        Status
        );

    CsLogEvent1(
        LOG_CRITICAL,
        CS_EVENT_INCONSISTENCY_HALT,
        string
        );

    //release the mutex so that the service when it starts can acqire the same
    //without a delay
    ReleaseMutex(CspMutex);
    ExitProcess(status); // return the fake error code
}


PVOID
CsAlloc(
    DWORD Size
    )
{
    PVOID p;
    p = LocalAlloc(LMEM_FIXED, Size);
    if (p == NULL) {
        CsInconsistencyHalt( ERROR_NOT_ENOUGH_MEMORY );
    }
    return(p);
}


LPWSTR
CsStrDup(
    LPCWSTR String
    )
{
    LPWSTR p;
    DWORD Len;

    Len = (lstrlenW(String)+1)*sizeof(WCHAR);
    p=static_cast<LPWSTR>(LocalAlloc(LMEM_FIXED, Len));
    if (p==NULL) {
        CsInconsistencyHalt( ERROR_NOT_ENOUGH_MEMORY );
    }
    CopyMemory(p,String,Len);
    return(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\init\initp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    initp.h

Abstract:

    Private header file for the initialization component of the
    NT Cluster Service

Author:

    John Vert (jvert) 6/5/1996

Revision History:

--*/
#include "service.h"
#include "stdio.h"
#include "stdlib.h"
#include "wchar.h"
#include "api_rpc.h"

#define LOG_CURRENT_MODULE LOG_MODULE_INIT

#define CS_CONCURRENT_RPC_CALLS 16

DWORD
ClusterInitialize(
    VOID
    );

VOID
ClusterShutdown(
    DWORD ExitCode
    );

DWORD
ClusterForm(
    VOID
    );

DWORD
ClusterJoin(
    VOID
    );

VOID
ClusterLeave(
    VOID
    );

RPC_STATUS
ClusterInitializeRpcServer(
    VOID
    );

DWORD
ClusterRegisterExtroclusterRpcInterface(
    VOID
    );

DWORD
ClusterRegisterJoinVersionRpcInterface(
    VOID
    );

VOID
ClusterDeregisterRpcInterfaces(
    VOID
    );

VOID
ClusterShutdownRpcServer(
    VOID
    );

DWORD
CspSetErrorCode(
    IN DWORD ErrorCode,
    OUT LPSERVICE_STATUS ServiceStatus
    );

VOID
GenerateExceptionReport(
  IN PEXCEPTION_POINTERS pExceptionInfo
    );

//
//  Restore database related functions
//
DWORD
RdbStopSvcOnNodes(
    IN PNM_NODE_ENUM2 pNodeEnum,
    IN LPCWSTR lpszServiceName
    );

VOID 
RdbGetRestoreDbParams( 
    IN HKEY hClusSvcKey 
    );

BOOL
RdbFixupQuorumDiskSignature(
    IN DWORD dwSignature
    );

DWORD
RdbpOpenDiskDevice(
    IN  LPCWSTR  lpDriveLetter,
    OUT PHANDLE  pFileHandle
    );

DWORD
RdbpCompareAndWriteSignatureToDisk(
    IN  HANDLE  hFile,
    IN  DWORD   dwSignature
    );

DWORD
RdbStartSvcOnNodes(
    IN LPCWSTR  lpszServiceName
    );

DWORD
RdbInitialize(
    VOID
    );

DWORD
RdbpUnloadClusterHive(
    VOID
    );

DWORD 
RdbpDeleteRestoreDbParams( 
    VOID
    );

//
// Private Constants
//
#define CS_MAX_DELAYED_WORK_THREADS    5
#define CS_MAX_CRITICAL_WORK_THREADS   1   // The critical queue is serialized

#define MIN_WORKING_SET_SIZE (1*1024*1024)
#define MAX_WORKING_SET_SIZE (2*MIN_WORKING_SET_SIZE)

extern BOOLEAN bFormCluster;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\init\ioctl.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

    Cluster control functions.

Author:

    Mike Massa (mikemas) 23-Jan-1998

Revision History:

--*/

#include "initp.h"


//
// Parameter block used for setting all cluster properties.
//
typedef struct {
    LPWSTR                  AdminExtensions;
    DWORD                   AdminExtensionsLength;
    CLUSTER_NETWORK_ROLE    DefaultNetworkRole;
    LPWSTR                  Description;
    LPBYTE                  Security;
    DWORD                   SecurityLength;
    LPBYTE                  SecurityDescriptor;
    DWORD                   SecurityDescriptorLength;
    LPWSTR                  GroupsAdminExtensions;
    DWORD                   GroupsAdminExtensionsLength;
    LPWSTR                  NetworksAdminExtensions;
    DWORD                   NetworksAdminExtensionsLength;
    LPWSTR                  NetworkInterfacesAdminExtensions;
    DWORD                   NetworkInterfacesAdminExtensionsLength;
    LPWSTR                  NodesAdminExtensions;
    DWORD                   NodesAdminExtensionsLength;
    LPWSTR                  ResourcesAdminExtensions;
    DWORD                   ResourcesAdminExtensionsLength;
    LPWSTR                  ResourceTypesAdminExtensions;
    DWORD                   ResourceTypesAdminExtensionsLength;
    DWORD                   EnableEventLogReplication;
    DWORD                   QuorumArbitrationTimeout;
    DWORD                   QuorumArbitrationEqualizer;
    DWORD                   DisableGroupPreferredOwnerRandomization;
} CS_CLUSTER_INFO, *PCS_CLUSTER_INFO;

//
// Parameter block used for setting the cluster 'Security Descriptor' property
//
typedef struct {
    LPBYTE                  Security;
    DWORD                   SecurityLength;
} CS_CLUSTER_SECURITY_INFO, *PCS_CLUSTER_SECURITY_INFO;

//
// Parameter block used for setting the cluster 'Security' property
//
typedef struct {
    LPBYTE                  SecurityDescriptor;
    DWORD                   SecurityDescriptorLength;
} CS_CLUSTER_SD_INFO, *PCS_CLUSTER_SD_INFO;


//
// Cluster Common properties.
//

//
// Read-Write Common Properties.
//
RESUTIL_PROPERTY_ITEM
CspClusterCommonProperties[] = {
    { CLUSREG_NAME_ADMIN_EXT,
      NULL,
      CLUSPROP_FORMAT_MULTI_SZ,
      0,
      0,
      0,
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, AdminExtensions)
    },
    { CLUSREG_NAME_CLUS_DEFAULT_NETWORK_ROLE,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      ClusterNetworkRoleClientAccess,
      ClusterNetworkRoleNone,
      ClusterNetworkRoleInternalAndClient,
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, DefaultNetworkRole)
    },
    { CLUSREG_NAME_CLUS_DESC,
      NULL,
      CLUSPROP_FORMAT_SZ,
      0,
      0,
      0,
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, Description)
    },
    { CLUSREG_NAME_CLUS_SECURITY,
      NULL,
      CLUSPROP_FORMAT_BINARY,
      0,
      0,
      0,
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, Security)
    },
    { CLUSREG_NAME_CLUS_SD,
      NULL,
      CLUSPROP_FORMAT_BINARY,
      0,
      0,
      0,
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, SecurityDescriptor)
    },
    { CLUSREG_KEYNAME_GROUPS L"\\" CLUSREG_NAME_ADMIN_EXT,
      NULL,
      CLUSPROP_FORMAT_MULTI_SZ,
      0,
      0,
      0,
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, GroupsAdminExtensions)
    },
    { CLUSREG_KEYNAME_NETWORKS L"\\" CLUSREG_NAME_ADMIN_EXT,
      NULL,
      CLUSPROP_FORMAT_MULTI_SZ,
      0,
      0,
      0,
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, NetworksAdminExtensions)
    },
    { CLUSREG_KEYNAME_NETINTERFACES L"\\" CLUSREG_NAME_ADMIN_EXT,
      NULL,
      CLUSPROP_FORMAT_MULTI_SZ,
      0,
      0,
      0,
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, NetworkInterfacesAdminExtensions)
    },
    { CLUSREG_KEYNAME_NODES L"\\" CLUSREG_NAME_ADMIN_EXT,
      NULL,
      CLUSPROP_FORMAT_MULTI_SZ,
      0,
      0,
      0,
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, NodesAdminExtensions)
    },
    { CLUSREG_KEYNAME_RESOURCES L"\\" CLUSREG_NAME_ADMIN_EXT,
      NULL,
      CLUSPROP_FORMAT_MULTI_SZ,
      0,
      0,
      0,
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, ResourcesAdminExtensions)
    },
    { CLUSREG_KEYNAME_RESOURCE_TYPES L"\\" CLUSREG_NAME_ADMIN_EXT,
      NULL,
      CLUSPROP_FORMAT_MULTI_SZ,
      0,
      0,
      0,
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, ResourceTypesAdminExtensions)
    },
    { CLUSREG_NAME_CLUS_EVTLOG_PROPAGATION,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      1, // default value //
      0, // min value //
      1, // max value //
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, EnableEventLogReplication)
    },
    { CLUSREG_NAME_QUORUM_ARBITRATION_TIMEOUT,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      60,      // default value //
      1,       // min value //
      60 * 60, // max value // One hour for arbitration. Should be enough
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, QuorumArbitrationTimeout)
    },
    { CLUSREG_NAME_QUORUM_ARBITRATION_EQUALIZER,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      7,       // default value //
      0,       // min value //
      60 * 60, // max value // One hour for arbitration. Should be enough
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, QuorumArbitrationEqualizer)
    },
    { CLUSREG_NAME_DISABLE_GROUP_PREFERRED_OWNER_RANDOMIZATION,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      0,       // default value // don't disable randomization
      0,       // min value //
      1,       // max value //
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, DisableGroupPreferredOwnerRandomization)
    },
    { NULL, NULL, 0, 0, 0, 0, 0 } };

//
// Property table used for setting the cluster 'Security Descriptor' property
//
RESUTIL_PROPERTY_ITEM
CspClusterSDProperty[] = {
    { CLUSREG_NAME_CLUS_SD,
      NULL,
      CLUSPROP_FORMAT_BINARY,
      0,
      0,
      0,
      0,
      FIELD_OFFSET(CS_CLUSTER_SD_INFO, SecurityDescriptor)
    },
    { NULL, NULL, 0, 0, 0, 0, 0 } };

//
// Property table used for setting the cluster 'Security' property
//
RESUTIL_PROPERTY_ITEM
CspClusterSecurityProperty[] = {
    { CLUSREG_NAME_CLUS_SECURITY,
      NULL,
      CLUSPROP_FORMAT_BINARY,
      0,
      0,
      0,
      0,
      FIELD_OFFSET(CS_CLUSTER_SECURITY_INFO, Security)
    },
    { NULL, NULL, 0, 0, 0, 0, 0 } };


//
// Read-Only Common Properties.
//
RESUTIL_PROPERTY_ITEM
CspClusterROCommonProperties[] = {
    { NULL, NULL, 0, 0, 0, 0, 0 } };

//
// Cluster registry API function pointers.
//
CLUSTER_REG_APIS
CspClusterRegApis = {
    (PFNCLRTLCREATEKEY) DmRtlCreateKey,
    (PFNCLRTLOPENKEY) DmRtlOpenKey,
    (PFNCLRTLCLOSEKEY) DmCloseKey,
    (PFNCLRTLSETVALUE) DmSetValue,
    (PFNCLRTLQUERYVALUE) DmQueryValue,
    (PFNCLRTLENUMVALUE) DmEnumValue,
    (PFNCLRTLDELETEVALUE) DmDeleteValue,
    NULL,
    NULL,
    NULL
};


//
// Local Functions
//

DWORD
CspClusterControl(
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
CspClusterEnumCommonProperties(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
CspClusterGetCommonProperties(
    IN BOOL ReadOnly,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
CspClusterValidateCommonProperties(
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
CspClusterSetCommonProperties(
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
CspClusterEnumPrivateProperties(
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
CspClusterGetPrivateProperties(
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
CspClusterValidatePrivateProperties(
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
CspClusterSetPrivateProperties(
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );


DWORD
WINAPI
CsClusterControl(
    IN PNM_NODE HostNode OPTIONAL,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a cluster.

Arguments:

    HostNode - Supplies the host node on which the cluster control should
           be delivered. If this is NULL, the local node is used. Not honored!

    ControlCode- Supplies the control code that defines the
        structure and action of the cluster control.
        Values of ControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    InBuffer- Supplies a pointer to the input buffer to be passed
        to the cluster.

    InBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer..

    OutBuffer- Supplies a pointer to the output buffer to be
        filled in by the cluster..

    OutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    BytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the cluster.

    Required - Returns the number of bytes if the OutBuffer is not big
        enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD   status;

    //
    // In the future - we should verify the access mode!
    //
    if ( CLUSCTL_GET_CONTROL_OBJECT( ControlCode ) != CLUS_OBJECT_CLUSTER ) {
        return(ERROR_INVALID_FUNCTION);
    }

    status = CspClusterControl(
                 ControlCode,
                 InBuffer,
                 InBufferSize,
                 OutBuffer,
                 OutBufferSize,
                 BytesReturned,
                 Required
                 );

    return(status);

} // CsClusterControl



DWORD
CspClusterControl(
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a node.

Arguments:

    ControlCode- Supplies the control code that defines the
        structure and action of the cluster control.
        Values of ControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    InBuffer- Supplies a pointer to the input buffer to be passed
        to the cluster.

    InBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    OutBuffer- Supplies a pointer to the output buffer to be
        filled in by the cluster.

    OutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    BytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the cluster.

    Required - Returns the number of bytes if the OutBuffer is not big
        enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD                    status;
    CLUSPROP_BUFFER_HELPER   props;
    DWORD                    bufSize;
    BOOL                     success;
    DWORD                    nameLen;

    if (DmClusterParametersKey == NULL) {
        return(ERROR_SHARING_PAUSED);
    }

    switch ( ControlCode ) {

    case CLUSCTL_CLUSTER_UNKNOWN:
        *BytesReturned = 0;
        status = ERROR_SUCCESS;
        break;

    case CLUSCTL_RESOURCE_GET_COMMON_PROPERTY_FMTS:
        status = ClRtlGetPropertyFormats( CspClusterCommonProperties,
                                          OutBuffer,
                                          OutBufferSize,
                                          BytesReturned,
                                          Required );
            break;

    case CLUSCTL_CLUSTER_GET_FQDN:
    // Return the fully qualified cluster name
        *BytesReturned = OutBufferSize;
        nameLen = lstrlenW( CsClusterName ) * sizeof(UNICODE_NULL);
        success = GetComputerNameEx( ComputerNameDnsDomain,
                                     (LPWSTR)OutBuffer,
                                     BytesReturned );


        *BytesReturned = *BytesReturned * sizeof(UNICODE_NULL);
        if ( success ) {
            status = STATUS_SUCCESS;
            //
            // Okay - append Cluster Name now. With a dot.
            //
            if ( (*BytesReturned + nameLen + 2*sizeof(UNICODE_NULL)) <= OutBufferSize ) {
                lstrcatW( (LPWSTR)OutBuffer, L"." );
                lstrcatW( (LPWSTR)OutBuffer, CsClusterName );
                *BytesReturned = *BytesReturned + nameLen + 2*sizeof(UNICODE_NULL);
            } else {
                *Required = *BytesReturned + nameLen + 2*sizeof(UNICODE_NULL);
                *BytesReturned = 0;
                status = ERROR_MORE_DATA;
            }
        } else {
            *Required = *BytesReturned + nameLen + sizeof(UNICODE_NULL);
            *BytesReturned = 0;
            status = GetLastError();
        }
        break;

    case CLUSCTL_CLUSTER_ENUM_COMMON_PROPERTIES:
        status = CspClusterEnumCommonProperties(
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );
        break;

    case CLUSCTL_CLUSTER_GET_RO_COMMON_PROPERTIES:
        status = CspClusterGetCommonProperties(
                     TRUE, // ReadOnly
                     DmClusterParametersKey,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );
        break;

    case CLUSCTL_CLUSTER_GET_COMMON_PROPERTIES:
        status = CspClusterGetCommonProperties(
                     FALSE, // ReadOnly
                     DmClusterParametersKey,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );
        break;

    case CLUSCTL_CLUSTER_VALIDATE_COMMON_PROPERTIES:
        status = CspClusterValidateCommonProperties(
                     DmClusterParametersKey,
                     InBuffer,
                     InBufferSize
                     );
        break;

    case CLUSCTL_CLUSTER_SET_COMMON_PROPERTIES:
        status = CspClusterSetCommonProperties(
                     DmClusterParametersKey,
                     InBuffer,
                     InBufferSize
                     );
        break;

    case CLUSCTL_CLUSTER_ENUM_PRIVATE_PROPERTIES:
        status = CspClusterEnumPrivateProperties(
                     DmClusterParametersKey,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );
        break;

    case CLUSCTL_CLUSTER_GET_RO_PRIVATE_PROPERTIES:
        if ( OutBufferSize < sizeof(DWORD) ) {
            *BytesReturned = 0;
            *Required = sizeof(DWORD);
            if ( OutBuffer == NULL ) {
                status = ERROR_SUCCESS;
            } else {
                status = ERROR_MORE_DATA;
            }
        } else {
            LPDWORD ptrDword = (LPDWORD) OutBuffer;
            *ptrDword = 0;
            *BytesReturned = sizeof(DWORD);
            status = ERROR_SUCCESS;
        }
        break;

    case CLUSCTL_CLUSTER_GET_PRIVATE_PROPERTIES:
        status = CspClusterGetPrivateProperties(
                     DmClusterParametersKey,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );
        break;

    case CLUSCTL_CLUSTER_VALIDATE_PRIVATE_PROPERTIES:
        status = CspClusterValidatePrivateProperties(
                     DmClusterParametersKey,
                     InBuffer,
                     InBufferSize
                     );
        break;

    case CLUSCTL_CLUSTER_SET_PRIVATE_PROPERTIES:
        status = CspClusterSetPrivateProperties(
                     DmClusterParametersKey,
                     InBuffer,
                     InBufferSize
                     );
        break;

    default:
        status = ERROR_INVALID_FUNCTION;
        break;
    }

    return(status);

} // CspClusterControl



DWORD
CspClusterEnumCommonProperties(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Enumerates the common property names for a given node.

Arguments:

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    //
    // Get the common properties.
    //
    status = ClRtlEnumProperties(
                 CspClusterCommonProperties,
                 OutBuffer,
                 OutBufferSize,
                 BytesReturned,
                 Required
                 );

    return(status);

} // CspClusterEnumCommonProperties



DWORD
CspClusterGetCommonProperties(
    IN BOOL ReadOnly,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the common properties for a given cluster.

Arguments:

    ReadOnly - TRUE if the read-only properties should be read.
               FALSE otherwise.

    RegistryKey - Supplies the registry key for this cluster.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD                   status;
    PRESUTIL_PROPERTY_ITEM  propertyTable;

    if ( ReadOnly ) {
        propertyTable = CspClusterROCommonProperties;
    } else {
        propertyTable = CspClusterCommonProperties;
    }

    //
    // Get the common properties.
    //
    status = ClRtlGetProperties( RegistryKey,
                                 &CspClusterRegApis,
                                 propertyTable,
                                 OutBuffer,
                                 OutBufferSize,
                                 BytesReturned,
                                 Required );

    return(status);

} // CspClusterGetCommonProperties



DWORD
CspClusterValidateCommonProperties(
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Validates the common properties for a given cluster.

Arguments:

    Node - Supplies the cluster object.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD   status;

    //
    // Validate the property list.
    //
    status = ClRtlVerifyPropertyTable( CspClusterCommonProperties,
                                       NULL,     // Reserved
                                       FALSE,    // Don't allow unknowns
                                       InBuffer,
                                       InBufferSize,
                                       NULL );

    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint( LOG_CRITICAL,
                    "[CS] ValidateCommonProperties, error in verify routine.\n");
    }

    return(status);

} // CspClusterValidateCommonProperties



DWORD
CspClusterSetCommonProperties(
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Sets the common properties for a given cluster.

Arguments:

    Node - Supplies the cluster object.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD                   status;

    PSECURITY_DESCRIPTOR    pSecurityDescriptor = NULL;
    DWORD                   cbSecurityDescriptorSize = 0;

    PRESUTIL_PROPERTY_ITEM  pOtherPropertyTable = NULL;
    LPBYTE                  pOtherParameterBlock = NULL;

    BOOL                    bSDFound = FALSE;
    BOOL                    bSecurityFound = FALSE;

    DWORD                   dwValue;

    //
    // Only one of securityInfo or sdInfo is going to be used at at time.
    // So use a union.
    //
    union
    {
        CS_CLUSTER_SECURITY_INFO    securityInfo;
        CS_CLUSTER_SD_INFO          sdInfo;

    } paramBlocks;


    //
    // Dummy do-while loop to avoid gotos
    //
    do
    {
        //
        // Validate the property list.
        //
        status = ClRtlVerifyPropertyTable(
                        CspClusterCommonProperties,
                        NULL,    // Reserved
                        FALSE,   // Don't allow unknowns
                        InBuffer,
                        InBufferSize,
                        NULL );

        if ( status != ERROR_SUCCESS ) {
            ClRtlLogPrint( LOG_CRITICAL,
                           "[CS] ClusterSetCommonProperties, error trying to verify property table. %1!u!\n",
                           status);
            break;
        }

        //
        // Set all the properties that were passed in.
        //
        status = ClRtlSetPropertyTable(
                        NULL,
                        RegistryKey,
                        &CspClusterRegApis,
                        CspClusterCommonProperties,
                        NULL,    // Reserved
                        FALSE,   // Don't allow unknowns
                        InBuffer,
                        InBufferSize,
                        FALSE,   // bForceWrite
                        NULL
                        );

        if ( status != ERROR_SUCCESS ) {
            ClRtlLogPrint( LOG_CRITICAL,
                           "[CS] ClusterSetCommonProperties, error trying to set properties in table. %1!u!\n",
                           status);
            break;
        }

        //
        // Clear the parameter blocks.
        //
        ZeroMemory( &paramBlocks, sizeof( paramBlocks ) );

        //
        // See if the "Security Descriptor" property exists in the input
        // property list. If so, set the 'Security' property also.

        status = ClRtlFindBinaryProperty(
                        InBuffer,
                        InBufferSize,
                        CLUSREG_NAME_CLUS_SD,
                        (LPBYTE *) &pSecurityDescriptor,
                        &cbSecurityDescriptorSize
                        );

        if ( status == ERROR_SUCCESS ) {
            //
            // The 'Security Descriptor' property is present.
            // Choose this over the 'Security' property.
            //
            if ( cbSecurityDescriptorSize > 0 ) {
                //
                // A security descriptor of nonzero size has been found.
                // Check if this is a valid security descriptor.
                //
                if ( IsValidSecurityDescriptor( pSecurityDescriptor ) == FALSE ) {
                    //
                    // Return the most appropriate error code, since IsValidSecurityDescriptor
                    // does not provide extended error information.
                    //
                    ClRtlLogPrint( LOG_CRITICAL,
                                   "[CS] ClusterSetCommonProperties, Invalid security descriptor.\n");
                    status = ERROR_INVALID_DATA;
                    break;
                }

                paramBlocks.securityInfo.Security = ClRtlConvertClusterSDToNT4Format( pSecurityDescriptor );
                paramBlocks.securityInfo.SecurityLength = GetSecurityDescriptorLength(
                                                                paramBlocks.securityInfo.Security );
            }
            else {
                //
                // The security string could have been passed in, but it may be
                // a zero length buffer. In this case, we will delete the
                // Security property too.
                //
                paramBlocks.securityInfo.Security = NULL;
                paramBlocks.securityInfo.SecurityLength = 0;
            }

            bSDFound = TRUE;
            pOtherPropertyTable = CspClusterSecurityProperty;
            pOtherParameterBlock = (LPBYTE) &paramBlocks.securityInfo;
        }
        else {
            //
            // We haven't found a valid security descriptor so far.
            //
            PSECURITY_DESCRIPTOR    pSecurity = NULL;
            DWORD                   cbSecuritySize = 0;

            status = ClRtlFindBinaryProperty(
                            InBuffer,
                            InBufferSize,
                            CLUSREG_NAME_CLUS_SECURITY,
                            (LPBYTE *) &pSecurity,
                            &cbSecuritySize
                            );

            if ( status == ERROR_SUCCESS ) {
                if ( cbSecuritySize > 0 ) {
                    //
                    // A security descriptor of nonzero size has been found.
                    // Check if this is a valid security descriptor.
                    //
                    if ( IsValidSecurityDescriptor( pSecurity ) == FALSE ) {
                        //
                        // Return the most appropriate error code, since IsValidSecurityDescriptor
                        // does not provide extended error information.
                        //
                        ClRtlLogPrint( LOG_CRITICAL,
                                       "[CS] ClusterSetCommonProperties, Invalid security descriptor.\n");
                        status = ERROR_INVALID_DATA;
                        break;
                    }

                    //
                    // Since we will not be modifying the info pointed to by the parameter block,
                    // just point it to the right place in the input buffer itself.
                    // A valid NT4 security descriptor is valid for NT5 too.
                    //
                    paramBlocks.sdInfo.SecurityDescriptor = pSecurity;
                    paramBlocks.sdInfo.SecurityDescriptorLength = cbSecuritySize;
                }
                else {
                    //
                    // The security string could have been passed in, but it may be
                    // a zero length buffer. In this case, we will delete the
                    // Security Descriptor property too.
                    //
                    paramBlocks.sdInfo.SecurityDescriptor = NULL;
                    paramBlocks.sdInfo.SecurityDescriptorLength  = 0;
                }

                bSecurityFound = TRUE;
                pOtherPropertyTable = CspClusterSDProperty;
                pOtherParameterBlock = (LPBYTE) &paramBlocks.sdInfo;
            }
            else {
                //
                // We didn't find any security information.
                // Nevertheless, we were successful in setting the properties.
                //
                status = ERROR_SUCCESS;
            }
        }

        if ( ( bSDFound != FALSE ) || ( bSecurityFound != FALSE ) ) {
            PVOID                   pPropertyList = NULL;
            DWORD                   cbPropertyListSize = 0;
            DWORD                   cbBytesReturned = 0;
            DWORD                   cbBytesRequired = 0;

            //
            // Create a new property list to incorporate the changed security information.
            //
            status = ClRtlPropertyListFromParameterBlock(
                            pOtherPropertyTable,
                            NULL,                         // OUT PVOID pOutPropertyList
                            &cbPropertyListSize,          // IN OUT LPDWORD pcbOutPropertyListSize
                            pOtherParameterBlock,
                            &cbBytesReturned,
                            &cbBytesRequired
                            );

            if ( status != ERROR_MORE_DATA ) {
                //
                // We have passed in a NULL buffer, so the return code has to
                // be ERROR_MORE_DATA. Otherwise something else has gone wrong,
                // so abort.
                //
                ClRtlLogPrint( LOG_CRITICAL,
                               "[CS] ClusterSetCommonProperties, Error getting temporary "
                               "property list size. %1!u!\n",
                               status);
                break;
            }

            pPropertyList = LocalAlloc( LMEM_FIXED, cbBytesRequired );
            if ( pPropertyList == NULL ) {
                status = GetLastError();
                ClRtlLogPrint( LOG_CRITICAL,
                               "[CS] ClusterSetCommonProperties, Error allocating memory "
                               "for property list. %1!u!\n",
                               status);
                break;
            }
            cbPropertyListSize = cbBytesRequired;

            status = ClRtlPropertyListFromParameterBlock(
                            pOtherPropertyTable,
                            pPropertyList,
                            &cbPropertyListSize,
                            pOtherParameterBlock,
                            &cbBytesReturned,
                            &cbBytesRequired
                            );

            if ( status == ERROR_SUCCESS ) {
                status = ClRtlSetPropertyTable(
                                NULL,
                                RegistryKey,
                                &CspClusterRegApis,
                                pOtherPropertyTable,
                                NULL,    // Reserved
                                FALSE,   // Don't allow unknowns
                                pPropertyList,
                                cbPropertyListSize,
                                FALSE,   // bForceWrite
                                NULL
                                );
            }
            else {
                ClRtlLogPrint( LOG_CRITICAL,
                               "[CS] ClusterSetCommonProperties, Error creating property list. %1!u!\n",
                               status);

                LocalFree( pPropertyList );
                break;
            }

            LocalFree( pPropertyList );

            if ( status != ERROR_SUCCESS ) {
                ClRtlLogPrint( LOG_CRITICAL,
                               "[CS] ClusterSetCommonProperties, error in setting property table. %1!u!\n",
                               status);
                break;
            }
        }
    }
    while ( FALSE ); // do-while: dummy loop to avoid gotos

    if (status == ERROR_SUCCESS) {
        if ( ERROR_SUCCESS == ClRtlFindDwordProperty(
                InBuffer,
                InBufferSize,
                CLUSREG_NAME_QUORUM_ARBITRATION_TIMEOUT,
                &dwValue) )
        {
            ClRtlLogPrint( LOG_UNUSUAL, "[CS] Arbitration Timeout is changed %1!d! => %2!d!.\n",
                MmQuorumArbitrationTimeout, dwValue);
            MmQuorumArbitrationTimeout = dwValue;
        }
        if ( ERROR_SUCCESS == ClRtlFindDwordProperty(
                InBuffer,
                InBufferSize,
                CLUSREG_NAME_QUORUM_ARBITRATION_EQUALIZER,
                &dwValue) )
        {
            ClRtlLogPrint( LOG_UNUSUAL, "[CS] Arbitration Equalizer is changed %1!d! => %2!d!.\n",
                MmQuorumArbitrationEqualizer, dwValue);
            MmQuorumArbitrationEqualizer = dwValue;
        }
        if ( ClRtlFindDwordProperty(
                InBuffer,
                InBufferSize,
                CLUSREG_NAME_DISABLE_GROUP_PREFERRED_OWNER_RANDOMIZATION,
                &dwValue ) == ERROR_SUCCESS )
        {
            ClRtlLogPrint(LOG_NOISE, "[CS] Cluster common property %1!ws! is changed to %2!u!...\n",
                          CLUSREG_NAME_DISABLE_GROUP_PREFERRED_OWNER_RANDOMIZATION, 
                          dwValue);
        }        
    }

    //
    // If the 'Security Descriptor' property was found, free the memory allocated,
    // to store the NT4 security descriptor.
    //
    if ( bSDFound != FALSE ) {
        LocalFree( paramBlocks.securityInfo.Security );
    }

    return(status);

} // CspClusterSetCommonProperties



DWORD
CspClusterEnumPrivateProperties(
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Enumerates the private property names for a given cluster.

Arguments:

    RegistryKey - Registry key for the cluster.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    HDMKEY      parametersKey;
    DWORD       totalBufferSize = 0;
    DWORD       status;

    *BytesReturned = 0;
    *Required = 0;

    //
    // Clear the output buffer
    //
    ZeroMemory( OutBuffer, OutBufferSize );

    //
    // Open the cluster cluster parameters key.
    //
    parametersKey = DmOpenKey( RegistryKey,
                               CLUSREG_KEYNAME_PARAMETERS,
                               MAXIMUM_ALLOWED );

    if ( parametersKey == NULL ) {
        status = GetLastError();
        if ( status == ERROR_FILE_NOT_FOUND ) {
            status = ERROR_SUCCESS;
        }
        return(status);
    }

    //
    // Enum the private properties for the cluster.
    //
    status = ClRtlEnumPrivateProperties( parametersKey,
                                         &CspClusterRegApis,
                                         OutBuffer,
                                         OutBufferSize,
                                         BytesReturned,
                                         Required );

    DmCloseKey( parametersKey );

    return(status);

} // CspClusterEnumPrivateProperties



DWORD
CspClusterGetPrivateProperties(
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the private properties for a given cluster.

Arguments:

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HDMKEY      parametersKey;
    DWORD       totalBufferSize = 0;

    *BytesReturned = 0;
    *Required = 0;

    //
    // Clear the output buffer
    //
    ZeroMemory( OutBuffer, OutBufferSize );

    //
    // Open the cluster\parameters key.
    //
    parametersKey = DmOpenKey( RegistryKey,
                               CLUSREG_KEYNAME_PARAMETERS,
                               MAXIMUM_ALLOWED );
    if ( parametersKey == NULL ) {
        status = GetLastError();
        if ( status == ERROR_FILE_NOT_FOUND ) {
            //
            // If we don't have a parameters key, then return an
            // item count of 0 and an endmark.
            //
            totalBufferSize = sizeof(DWORD) + sizeof(CLUSPROP_SYNTAX);
            if ( OutBufferSize < totalBufferSize ) {
                *Required = totalBufferSize;
                status = ERROR_MORE_DATA;
            } else {
                // This is somewhat redundant since we zero the
                // buffer above, but it's here for clarity.
                CLUSPROP_BUFFER_HELPER buf;
                buf.pb = OutBuffer;
                buf.pList->nPropertyCount = 0;
                buf.pdw++;
                buf.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
                *BytesReturned = totalBufferSize;
                status = ERROR_SUCCESS;
            }
        }
        return(status);
    }

    //
    // Get private properties for the cluster.
    //
    status = ClRtlGetPrivateProperties( parametersKey,
                                        &CspClusterRegApis,
                                        OutBuffer,
                                        OutBufferSize,
                                        BytesReturned,
                                        Required );

    DmCloseKey( parametersKey );

    return(status);

} // CspClusterGetPrivateProperties



DWORD
CspClusterValidatePrivateProperties(
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Validates the private properties for a given cluster.

Arguments:

    RegistryKey - Registry key for the cluster.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    //
    // Validate the property list.
    //
    status = ClRtlVerifyPrivatePropertyList( InBuffer,
                                             InBufferSize );

    return(status);

} // CspClusterValidatePrivateProperties



DWORD
CspClusterSetPrivateProperties(
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Sets the private properties for a given cluster.

Arguments:

    RegistryKey - Registry key for the cluster.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HDMKEY      parametersKey;
    DWORD       disposition;

    //
    // Validate the property list.
    //
    status = ClRtlVerifyPrivatePropertyList( InBuffer,
                                             InBufferSize );

    if ( status == ERROR_SUCCESS ) {

        //
        // Open the cluster\parameters key
        //
        parametersKey = DmOpenKey( RegistryKey,
                                   CLUSREG_KEYNAME_PARAMETERS,
                                   MAXIMUM_ALLOWED );
        if ( parametersKey == NULL ) {
            status = GetLastError();
            if ( status == ERROR_FILE_NOT_FOUND ) {
                //
                // Try to create the parameters key.
                //
                parametersKey = DmCreateKey( RegistryKey,
                                             CLUSREG_KEYNAME_PARAMETERS,
                                             0,
                                             KEY_READ | KEY_WRITE,
                                             NULL,
                                             &disposition );
                if ( parametersKey == NULL ) {
                    status = GetLastError();
                    return(status);
                }
            }
        }

        status = ClRtlSetPrivatePropertyList( NULL, // IN HANDLE hXsaction
                                              parametersKey,
                                              &CspClusterRegApis,
                                              InBuffer,
                                              InBufferSize );

        DmCloseKey( parametersKey );
    }

    return(status);

} // CspClusterSetPrivateProperties
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\init\service.c ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    service.c

Abstract:

    Service control functions for the Cluster Service.

Author:

    Mike Massa (mikemas) 2-Jan-1996


Revision History:

--*/

#include <initp.h>
#include <shellapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <clusverp.h>

//
// Public data
//
#define CLUSTER_SERVICE_CONTROLS    (SERVICE_ACCEPT_STOP | \
                                     SERVICE_ACCEPT_SHUTDOWN )

ULONG                CsLogLevel=LOG_UNUSUAL;
PCLRTL_WORK_QUEUE    CsDelayedWorkQueue = NULL;
PCLRTL_WORK_QUEUE    CsCriticalWorkQueue = NULL;
LPWSTR               CsClusterName = NULL;
SERVICE_STATUS       CsServiceStatus = {
                         SERVICE_WIN32_OWN_PROCESS, // dwServiceType
                         SERVICE_STOPPED,           // dwCurrentState
                         CLUSTER_SERVICE_CONTROLS,  // dwControlsAccepted
                         ERROR_SUCCESS,             // dwWin32ExitCode
                         ERROR_SUCCESS,             // dwServiceSpecificExitCode
                         1,                         // dwCheckPoint
                         90000                      // dwWaitHint - 90 seconds -nm uses 90 sec timeout
                         };

//
// internal cluster versions. The major version is bumped during
// product releases (which could include service pack releases).
//
DWORD CsMyHighestVersion = CLUSTER_MAKE_VERSION(
                                    CLUSTER_INTERNAL_CURRENT_MAJOR_VERSION,
                                    VER_PRODUCTBUILD);

DWORD CsMyLowestVersion = CLUSTER_INTERNAL_PREVIOUS_HIGHEST_VERSION;

//initialize by calling an rtl funcion
SUITE_TYPE CsMyProductSuite; 

DWORD CsClusterHighestVersion;

DWORD CsClusterLowestVersion;

DWORD CsClusterNodeLimit;

SHUTDOWN_TYPE CsShutdownRequest = CsShutdownTypeStop;

//
// used to turn authenticated RPC on or off
//
// This should always be defined, since none of the other code has
// the checks for this variable conditionalized
//
BOOL CsUseAuthenticatedRPC = TRUE;

//
// domain and user account under which the service is run
//
LPWSTR  CsServiceDomainAccount;

//
// security packages to use during the join for authenticated RPC; JoinVersion
// determines which package will be used by the ExtroCluster interface.
// CsRPCSecurityPackageInUse reflects that choice. The package used for the
// Intracluster interface is negotiated separately.
//

//
// when using kerberos with RPC, RPC calls fail with 1825 (sec. pkg error)
// somewhere between 30 minutes and 12 hours. For beta 2, we'll revert back to
// NTLM where expiration is not a problem.
//

//DWORD   CsRPCSecurityPackage[] = { RPC_C_AUTHN_GSS_KERBEROS, RPC_C_AUTHN_WINNT };
//LPWSTR  CsRPCSecurityPackageName[] = { L"Kerberos", L"NTLM" };

DWORD   CsRPCSecurityPackage[] = { RPC_C_AUTHN_WINNT };
LPWSTR  CsRPCSecurityPackageName[] = { L"NTLM" };
DWORD   CsNumberOfRPCSecurityPackages = sizeof( CsRPCSecurityPackage ) / sizeof( CsRPCSecurityPackage[0] );
LONG    CsRPCSecurityPackageIndex = -1;

//
// Public Debug Data
//
#if 1 // CLUSTER_BETA

BOOL   CsDebugResmon = FALSE;
LPWSTR CsResmonDebugCmd;

BOOL   CsNoVersionCheck = FALSE;
#endif

#if DBG // DBG

ULONG  CsDebugFlags = CS_DBG_ALL;

#endif // DBG

#ifdef CLUSTER_TESTPOINT

DWORD  CsTestPoint = 0;
DWORD  CsTestTrigger = TestTriggerNever;
DWORD  CsTestAction = TestActionTrue;
BOOL   CsPersistentTestPoint = FALSE;

#endif // CLUSTER_TESTPOINT

BOOL   CsUpgrade = FALSE;
BOOL   CsFirstRun = FALSE;
BOOL   CsNoQuorumLogging = FALSE;
BOOL   CsUserTurnedOffQuorumLogging = FALSE;
BOOL   CsNoQuorum = FALSE;
BOOL   CsResetQuorumLog = FALSE;
BOOL   CsForceQuorum = FALSE;
LPWSTR CsForceQuorumNodes = NULL;
BOOL   CsCommandLineForceQuorum = FALSE;
BOOL   CsNoRepEvtLogging = FALSE;
LPWSTR CsDatabaseRestorePath = NULL;
BOOL   CsDatabaseRestore = FALSE;
BOOL   CsForceDatabaseRestore = FALSE;
LPWSTR CsQuorumDriveLetter = NULL;
DWORD  CspInitStatus;
BOOL   CsRunningAsService = TRUE;

//
// Private Data
//
SERVICE_STATUS_HANDLE   CspServiceStatusHandle = 0;
HANDLE                  CspStopEvent = NULL;


//
// Private service initialization & cleanup routines.
//


DWORD
CspSetErrorCode(
    IN DWORD ErrorCode,
    OUT LPSERVICE_STATUS ServiceStatus
    )
/*++

Routine Description:

    Sets the correct error return for the Service Control Manager.

  Problem:

    The original cluster error codes overlap with many of the network error
    codes. For those overlaps, this function will return the error code as a
    service specific error code.

Inputs:

    EerrorCode - the correct error code to set.
    ServiceStatus - pointer to the service status for SCM

Outputs:

    ServiceStatus - Sets the correct error code in the service status.

--*/

{
    DWORD   status;

    if ( ( ErrorCode > 5000 ) && ( ErrorCode < 5090 ) ) {
        ServiceStatus->dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
        ServiceStatus->dwServiceSpecificExitCode = ErrorCode;
        status = ERROR_SERVICE_SPECIFIC_ERROR;
    } else {
        ServiceStatus->dwWin32ExitCode = ErrorCode;
        ServiceStatus->dwServiceSpecificExitCode = ErrorCode;
        status = ErrorCode;
    }
    
    return (status);

} // CspSetErrorCode



VOID
CspCleanup(
    VOID
    )
/*++

 Routine Description:

     Main Cluster Manager cleanup routine. Called when the service is
     stopping.

 Arguments:

     None.

 Return Value:

     None.

--*/

{
    //
    // Cleanup & shutdown the service
    //

    IF_DEBUG(CLEANUP) {
        ClRtlLogPrint(LOG_NOISE,"[CS] Cleaning up\n");
    }

    //
    // Free the stop event
    //
    if (CspStopEvent != NULL) {
        CloseHandle(CspStopEvent);
        CspStopEvent = NULL;
    }
    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

    if ( CsDatabaseRestorePath != NULL ) {
        LocalFree ( CsDatabaseRestorePath );
    }

    if ( CsQuorumDriveLetter != NULL ) {
        LocalFree ( CsQuorumDriveLetter );
    }

    if ( CsForceQuorumNodes != NULL && !CsCommandLineForceQuorum ) {
        LocalFree ( CsForceQuorumNodes );
    }

    IF_DEBUG(CLEANUP) {
        ClRtlLogPrint(LOG_NOISE,"[CS] Cleanup complete.\n");
    }

    return;
} // CspCleanup


//
// Public service control routines.
//
VOID
CsWaitForStopEvent(
    VOID
    )
/*++

 Routine Description:

     Main body of the Cluster Manager service. Called when the service
     has been successfully started.

 Arguments:

     None.

 Return Value:

     A Win32 status code.

--*/

{
    DWORD           status;


    CL_ASSERT(CsRunningAsService);
    if (CsRunningAsService) {
        //
        // Announce that we're up and running.
        //
        CsServiceStatus.dwCurrentState = SERVICE_RUNNING;
        CsServiceStatus.dwControlsAccepted = CLUSTER_SERVICE_CONTROLS;
        CsServiceStatus.dwCheckPoint = 0;
        CsServiceStatus.dwWaitHint = 0;

        CsAnnounceServiceStatus();
    }

    IF_DEBUG(INIT) {
        ClRtlLogPrint(LOG_NOISE,"[CS] Service Started.\n\n");
    }


    //
    // Wait for the service to be stopped.
    //
    WaitForSingleObject(CspStopEvent,   // handle
                        INFINITE        // no timeout
                        );


    return;
} // CsWaitForStopEvent


VOID
CsStopService(
    VOID
    )
/*++

 Routine Description:

     Handler for a service controller STOP message. Initiates the process
     of stopping the Cluster Manager service.

 Arguments:

     None.

 Return Value:

     None.

--*/

{
    if (CsRunningAsService) {
        //
        // Announce that we are stopping.
        //
        CsServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
        CsServiceStatus.dwCheckPoint = 1;
        CsServiceStatus.dwWaitHint = 20000;  // 20 seconds
        CsAnnounceServiceStatus();
    }

    //
    // Wake up the main service thread.
    //
    SetEvent(CspStopEvent);

    return;
}



VOID
CsAnnounceServiceStatus (
    VOID
    )

/*++

Routine Description:

    Announces the service's status to the service controller.

Arguments:

    None.

Return Value:

    None.

--*/

{

    //
    // Don't announce our status if running as a console app.
    //
    if (!CsRunningAsService) {
        return;
    }

    //
    // Service status handle is NULL if RegisterServiceCtrlHandler failed.
    //
    if ( CspServiceStatusHandle == 0 ) {
        return;
    }

    //
    // Call SetServiceStatus, ignoring any errors.
    //
    SetServiceStatus(CspServiceStatusHandle, &CsServiceStatus);

    return;

} // CsAnnounceServiceStatus



//
// Private routines for executing as a Win32 service.
//
VOID WINAPI
CspControlHandler(
    DWORD ControlCode
    )
/*++

 Routine Description:

     Handler for Service Controller messages.

 Arguments:

     ControlCode - The code indicating the Service Controller's request.

 Return Value:

     None.

--*/

{
    switch(ControlCode){

    case SERVICE_CONTROL_SHUTDOWN:

        CsShutdownRequest = CsShutdownTypeShutdown;

        // Fall Through

    case SERVICE_CONTROL_STOP:
        IF_DEBUG(CLEANUP) {
            ClRtlLogPrint(LOG_NOISE,
                       "[CS] Received %1!ws! command\n",
                        (ControlCode == SERVICE_CONTROL_STOP ? L"STOP" : L"SHUTDOWN"));
        }

        CsStopService();
        break;

    case SERVICE_CONTROL_INTERROGATE:
        CsAnnounceServiceStatus();
        break;

    case SERVICE_CONTROL_CONTINUE:
    case SERVICE_CONTROL_PAUSE:
        break;

    default:
        ClRtlLogPrint(LOG_NOISE,
            "[CS] Received unknown service command %1!u!\n",
            ControlCode
            );

        break;
    }

    return;

} // CspControlHandler

DWORD CspGetFirstRunState(
    OUT LPDWORD pdwFirstRun
    )
{
    HKEY  hKey = NULL;
    DWORD dwStatus;     // returned by registry API functions
    DWORD dwClusterInstallState;
    DWORD dwValueType;
    DWORD dwDataBufferSize = sizeof( DWORD );

    *pdwFirstRun = 0;
    // Read the registry key that indicates whether cluster files are installed.

    dwStatus = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                                L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Cluster Server",
                                0,         // reserved
                                KEY_READ,
                                &hKey );

    // Was the registry key opened successfully ?
    if ( dwStatus != ERROR_SUCCESS )
    {
        if ( dwStatus == ERROR_FILE_NOT_FOUND )
        {
            *pdwFirstRun = 1;
            dwStatus = ERROR_SUCCESS;
            goto FnExit;
        }
    }

    // Read the entry.
    dwStatus = RegQueryValueExW( hKey,
                                  L"ClusterFirstRun",
                                  0, // reserved
                                  &dwValueType,
                                  (LPBYTE) pdwFirstRun,
                                  &dwDataBufferSize );

    // Was the value read successfully ?
    if ( dwStatus != ERROR_SUCCESS )
    {
        if ( dwStatus == ERROR_FILE_NOT_FOUND )
        {
            *pdwFirstRun = 1;
            dwStatus = ERROR_SUCCESS;
            goto FnExit;
        }
    }

FnExit:    
    // Close the registry key.
    if ( hKey )
    {
        RegCloseKey( hKey );
    }

    return ( dwStatus );

} //*** CspGetFirstRunState

DWORD CspGetServiceParams()
{
    HKEY  hClusSvcKey = NULL;
    DWORD Length;
    DWORD Type;
    DWORD Status;
    eClusterInstallState eState;

    //
    // Open key to SYSTEM\CurrentControlSet\Services\ClusSvc\Parameters
    //
    Status = RegOpenKeyW(HKEY_LOCAL_MACHINE,
                         CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
                         &hClusSvcKey);

    Length = sizeof(DWORD);
    Status = RegQueryValueExW(hClusSvcKey,
                              CLUSREG_NAME_SVC_PARAM_NOVER_CHECK,
                              0,
                              &Type,
                              (LPBYTE)&CsNoVersionCheck,
                              &Length);

    // by default, version checking is turned on
    if (Status != ERROR_SUCCESS) {
        CsNoVersionCheck = FALSE;
        Status = ERROR_SUCCESS;
    }

    Length = sizeof(DWORD);
    Status = RegQueryValueExW(hClusSvcKey,
                              CLUSREG_NAME_SVC_PARAM_NOREP_EVTLOGGING,
                              0,
                              &Type,
                              (LPBYTE)&CsNoRepEvtLogging,
                              &Length);
    //For now, default is to turn eventlogging on
    if (Status != ERROR_SUCCESS) {
        CsNoRepEvtLogging = FALSE;
        Status = ERROR_SUCCESS;
    }

    //figure out if this is the first run on upgrade or fresh install
    Status = CspGetFirstRunState((LPDWORD)&CsFirstRun);
    CL_ASSERT(Status == ERROR_SUCCESS);

    //if there is upgrade, this must be the first run
    Status = ClRtlGetClusterInstallState( NULL, &eState );
    if (eState == eClusterInstallStateUpgraded)
    {
        CsUpgrade = TRUE;
        CsFirstRun = TRUE;
    }

    //
    //  Check the registry to see whether RestoreDatabase option is
    //  chosen. If so, get the params and save them in global variables.
    //
    RdbGetRestoreDbParams( hClusSvcKey );

    //
    // See if the force quorum option has been set.  Unfortunately we
    // need two calls to get the size and do the alloc.  Note that if
    // we have command line stuff already then this overrides registry
    // parameters.  If we have command line stuff then CsForceQuorum
    // will be set.  Care is needed since we could be unlucky with the
    // time between the two calls.
    //
    if ( !CsForceQuorum ) {
GetForceQuorum:
        Length = 0;
        Status = RegQueryValueExW( hClusSvcKey,
                                   CLUSREG_NAME_SVC_PARAM_FORCE_QUORUM,
                                   0,
                                   &Type,
                                   NULL,
                                   &Length);
        if (Status == ERROR_SUCCESS) {
        
            // Got the length, check the type before allocating
            //
            if ( Type != REG_SZ ) {
                ClRtlLogPrint( LOG_ERROR,"[CS] Error in startup param, type was not REG_SZ.\r\n" );
                Status = ERROR_INVALID_PARAMETER;
                goto ret;
            }
            // Got a valid type so force quorum is set, check the length.
            // If the length is 0 then we have the key but no data which
            // is OK.  Otherwise alloc and read the data.
            //
            CsForceQuorum = TRUE;
            if ( Length == 0 )
                goto ret;
            CsForceQuorumNodes = (LPWSTR) LocalAlloc( LMEM_FIXED, Length );
            Status = RegQueryValueExW( hClusSvcKey,
                                       CLUSREG_NAME_SVC_PARAM_FORCE_QUORUM,
                                       0,
                                       &Type,
                                       (LPBYTE) CsForceQuorumNodes,
                                       &Length);
            if ( Status == ERROR_MORE_DATA || Type != REG_SZ ) {
                LocalFree( CsForceQuorumNodes );
                CsForceQuorumNodes = NULL;
                CsForceQuorum = FALSE;
                goto GetForceQuorum;
            }
            if ( Status != ERROR_SUCCESS )
                goto ret;
        } else {
            Status = ERROR_SUCCESS;
        }
    }
ret:
    //close the key
    if (hClusSvcKey) RegCloseKey(hClusSvcKey);

    return(Status);
}


BOOL CspResetFirstRunState(DWORD dwFirstRunState)
{
    //initialize return to FALSE
    BOOL     fReturnValue = FALSE;

    // Set the state of the ClusterInstallationState registry key to indicate
    // that Cluster Server has been configured.

    HKEY     hKey;

    DWORD    dwStatus;     // returned by registry API functions

    // Attempt to open an existing key in the registry.

    dwStatus = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                                L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Cluster Server",
                                0,         // reserved
                                KEY_WRITE,
                                &hKey );

    // Was the regustry key opened successfully ?

    if ( dwStatus == ERROR_SUCCESS )
    {
        // set the first run state to 0.

        DWORD dwFirstRun = 0;

        DWORD dwValueType = REG_DWORD;
        DWORD dwDataBufferSize = sizeof( DWORD );

        dwStatus = RegSetValueExW( hKey,
                                    L"ClusterFirstRun",
                                    0, // reserved
                                    dwValueType,
                                    (LPBYTE) &dwFirstRun,
                                    dwDataBufferSize );

        // Close the registry key.

        RegCloseKey( hKey );

        // Was the value set successfully?

        if ( dwStatus == ERROR_SUCCESS )
        {
            fReturnValue = TRUE;
        }
    }

    return ( fReturnValue );

} //*** CspResetFirstRunState

DWORD
CspSetInstallAndFirstRunState(
    VOID
    )

/*++

Routine Description:

    Sets the cluster state to Configured.  Called
    after the service has started running after the first upgrade.
    If it is a fresh install, Cluscfg sets the state of this to 
    Configured before starting the cluster service

Arguments:

    None

Return Value:

    ERROR_SUCCESS if everything worked ok

--*/
{
    DWORD Status = ERROR_SUCCESS;

    if (CsUpgrade)
    {

        if (!ClRtlSetClusterInstallState(eClusterInstallStateConfigured))
        {
            Status = GetLastError();
        }

    }

    if (CsFirstRun)
    {
        CspResetFirstRunState(0);    
    }
    return(Status);

} // CspResetUpgradeBit


void CspGetServiceCmdLineParams(
    DWORD  argc,
    LPTSTR argv[]
)
{
    DWORD i;
    
    if ((argc > 1) && ((*argv[1] == '-') || (*argv[1] == '/')))
    {
        for (i=1; i<argc; i++)
        {                                                                      
                                                                         
            if (!lstrcmpi(argv[i]+1,L"noquorumlogging"))                       
            {                                                                  
              CsNoQuorumLogging = TRUE;
              CsUserTurnedOffQuorumLogging = TRUE;
              ClRtlLogPrint(LOG_NOISE,"[CS] quorum logging is off\r\n");  
            }                                                                  
            else if (!lstrcmpi(argv[i]+1,L"fixquorum"))                        
            {                                                                  
              CsNoQuorum = TRUE;  
              CsNoQuorumLogging = TRUE;
              CsUserTurnedOffQuorumLogging = TRUE;
              ClRtlLogPrint(LOG_NOISE,
                    "[CS] quorum is not arbitrated or brought online\r\n");
            }
            else if (!lstrcmpi(argv[i]+1,L"resetquorumlog"))                        
            {                                                                  
              CsResetQuorumLog = TRUE;  
              ClRtlLogPrint(LOG_NOISE,
                    "[CS] force reset quorum log\r\n");
            }
            else if (!lstrcmpi(argv[i]+1,L"forcequorum"))                        
            {
                CsForceQuorum = TRUE;
                CsCommandLineForceQuorum = TRUE;
                if (( argc < i+2 )
                    || ( *argv[i+1] == L'-' ) 
                    || ( *argv[i+1] == L'/' )) {

                    CsForceQuorumNodes = NULL;
                } else {
                    CsForceQuorumNodes = argv[++i]; /* increment i to ensure we skip the node list. */
                }
                ClRtlLogPrint(LOG_NOISE, "[CS] force node quorum for nodes %1\r\n", CsForceQuorumNodes);
            }
            else if ( lstrcmpiW( L"debugresmon", argv[i]+1 ) == 0 ) {
                CsDebugResmon = TRUE;
                //
                // check for optional, non-NULL command string
                //
                if ( argc >= i+2  ) {
                    if ( *argv[i+1] != L'-' && *argv[i+1] != L'/' && *argv[i+1] != UNICODE_NULL ) {
                        CsResmonDebugCmd = argv[++i];
                    }
                }
            }

        }
    }
}  


VOID WINAPI
CspServiceMain(
    DWORD  argc,
    LPTSTR argv[]
    )
{
    DWORD               status;

    ClRtlLogPrint(LOG_NOISE,"[CS] Service Starting...\n");

    if ( CspInitStatus == ERROR_SUCCESS ) {
        CsServiceStatus.dwCurrentState = SERVICE_START_PENDING;
    } else {
        CsServiceStatus.dwCurrentState = SERVICE_STOPPED;
        CsServiceStatus.dwWin32ExitCode = CspInitStatus;
    }

    //
    // Initialize server to receive service requests by registering the
    // control handler.
    //

    CspServiceStatusHandle = RegisterServiceCtrlHandler(
                                   CLUSTER_SERVICE_NAME,
                                   CspControlHandler
                                   );

    if ( CspServiceStatusHandle == 0 ) {
        status = GetLastError();
        ClRtlLogPrint(LOG_NOISE,"[CS] Service Registration failed, %1!u!\n", status);
        CL_UNEXPECTED_ERROR( status );
        return;
    }

    IF_DEBUG(INIT) {
        ClRtlLogPrint(LOG_NOISE,"[CS] Service control handler registered\n");
    }

    CsAnnounceServiceStatus();

    if ( CspInitStatus != ERROR_SUCCESS ) {
        return;
    }

    CspGetServiceCmdLineParams(argc, argv);

    //
    // Initialize the cluster. If this succeeds, wait for
    // the SC mgr to stop us
    //
    status = ClusterInitialize();
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, "[CS] ClusterInitialize failed %1!d!\n",
                                  status);
    } else {
        CspSetInstallAndFirstRunState();
        CsWaitForStopEvent();
    }

    //
    // Announce that we're stopping
    //
    IF_DEBUG(CLEANUP) {
        ClRtlLogPrint(LOG_NOISE,"[CS] Service Stopping...\n");
    }

    CsServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
    CsServiceStatus.dwCheckPoint = 1;
    CsServiceStatus.dwWaitHint = 20000;  // 20 seconds
    CspSetErrorCode( status, &CsServiceStatus );

    CsAnnounceServiceStatus();

    //
    // ClusterShutdown currently never returns
    //

    ClusterShutdown(status);

#if 0
    CspCleanup();

    //
    // Announce that we are stopped.
    //
    CsServiceStatus.dwCurrentState = SERVICE_STOPPED;
    CsServiceStatus.dwControlsAccepted = 0;
    CsServiceStatus.dwCheckPoint = 0;
    CsServiceStatus.dwWaitHint = 0;
    CspSetErrorCode( status, &CsServiceStatus );

    CsAnnounceServiceStatus();

    ClRtlLogPrint(LOG_NOISE,"[CS] Service Stopped.\n\n");

    //
    // Can't call ClRtlLogPrint after this point.
    //
    ClRtlCleanup();

    return;
#endif
} // CspServiceMain



//
// Private routines for executing as a console application.
//
BOOL WINAPI
CspConsoleHandler(
    DWORD dwCtrlType
    )
/*++

 Routine Description:

     Handler for console control events when running the service as
     a console application.

 Arguments:

     dwCtrlType - Indicates the console event to handle.

 Return Value:

     TRUE if the event was handled, FALSE otherwise.

--*/

{
    switch( dwCtrlType )
    {
        case CTRL_BREAK_EVENT:  // use Ctrl+C or Ctrl+Break to simulate
        case CTRL_C_EVENT:      // SERVICE_CONTROL_STOP in debug mode
            printf("Stopping service...\n");
            CsStopService();
            return TRUE;
            break;

    }

    return FALSE;
}



DWORD
CspDebugService(
    int         argc,
    wchar_t **  argv
    )
/*++

 Routine Description:

     Runs the service as a console application

 Arguments:

     Standard command-line arguments.

 Return Value:

     None.

--*/

{
    DWORD status;

    SetConsoleCtrlHandler( CspConsoleHandler, TRUE );

    status = ClusterInitialize();

    if (status == ERROR_SUCCESS) {

        CspSetInstallAndFirstRunState();

        //
        // Wait for ctrl-c to initiate shutdown.
        //
        WaitForSingleObject(CspStopEvent, INFINITE);

    } else {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CS] ClusterInitialize failed %1!d!\n",
                   status);
    }

    ClusterShutdown(status);

    CspCleanup();

    //
    // Can't call ClRtlLogPrint after this point.
    //
    ClRtlCleanup();

    return(status);
}


//
// Main program routines
//

VOID
CspUsage(
    VOID
    )
{
#if DBG

    printf("\nCluster Service\n");
    printf("\n");
    printf("Start with 'net start' to run as a Win32 service\n");
    printf("\n");
    printf("Command line options:\n");
    printf("\t-loglevel N           set the debugging log level.\n");
    printf("\t-debug                run as a console app.\n");
    printf("\t-debugresmon [dbgcmd] enable debugging of resrcmon process using optional command.\n");
    printf("\t                          use quotes to include args, i.e., -debugresmon \"ntsd -d\"\n");
    printf("\t-fixquorum            no quorum device, no quorum logging.\n");
    printf("\t-noquorumlogging      no quorum logging.\n");
    printf("\t-forcequorum N1,...,Nn force a quorum of nodes for node N1 up to Nn inclusive.\n");
    printf("\t-restoredatabase D    restore cluster DB to quorum disk from dir D.\n");
    printf("\t-forcerestore         force a restore DB operation by performing fixups.\n"); 
    printf("\t-resetquorumlog       force a form despite a missing quorum log file.\n"); 
    printf("\t-quodriveletter Q     drive letter for a replacement quorum disk\n"); 
    printf("\t-norepevtlogging      no replication of event log entries.\n");
    printf("\t-novercheck           ignore join version checking.\n");
    printf("\t-testpt N             enable test point N.\n");
    printf("\t-persistent           make test points persistent.\n");
    printf("\t-trigger N            sets test point trigger type.\n");
    printf("\t                          (0-never (default), 1-always, 2-once, 3-count)\n");
    printf("\t-action N             sets trigger action.\n");
    printf("\t                          (0-true (default), 1-exit, 2-break)\n");
    printf("\n");

#else // DBG

    ClRtlMsgPrint(CS_COMMAND_LINE_HELP);

#endif // DBG
    exit(1);
}





int __cdecl
wmain(
    int     argc,
    wchar_t **argv
    )
{
    DWORD                   Status;
    int                     i;
    LPWSTR                  LogLevel;
    BOOLEAN                 debugFlagFound = FALSE;
    OSVERSIONINFOEXW        Version;
    DWORD                   dwLen;
    BOOL                    success;
    PWCHAR                  suiteInfo;
    SYSTEMTIME              localTime;
    BOOLEAN                 dbgOutputToConsole;
    UINT                    errorMode;
    DWORD                   dwMask;

    SERVICE_TABLE_ENTRY dispatchTable[] = {
        { CLUSTER_SERVICE_NAME, (LPSERVICE_MAIN_FUNCTION)CspServiceMain },
        { NULL, NULL }
    };

    //
    //  BUGBUG - 06/23/2000
    //
    //  This is a temporary change to let the cluster service and resource monitor process run 
    //  despite 64-bit alignment faults.  This will be removed as soon as all alignment issues 
    //  are fixed.
    //
    errorMode = SetErrorMode( SEM_NOALIGNMENTFAULTEXCEPT );

    SetErrorMode( SEM_NOALIGNMENTFAULTEXCEPT | errorMode );

    LogLevel = _wgetenv(L"ClusterLogLevel");

    if (LogLevel != NULL) {
        swscanf(LogLevel, L"%u", &CsLogLevel);
    }

    if ( (argc > 1) && ((*argv[1] == L'-') || (*argv[1] == L'/')) ) {
        //
        // Invoked from the command line.
        //
        CsRunningAsService = FALSE;
        dbgOutputToConsole = TRUE;
    } else {
        //
        // Invoked by the Service Controller
        //
        CsRunningAsService = TRUE;
        dbgOutputToConsole = FALSE;
    }

    //
    // initialize the run time library
    //
    Status = ClRtlInitialize( dbgOutputToConsole, &CsLogLevel );
    if (Status != ERROR_SUCCESS) {
        if (Status == ERROR_PATH_NOT_FOUND) {
            CsLogEvent( LOG_CRITICAL, SERVICE_CLUSRTL_BAD_PATH );
        } else {
            PWCHAR  msgString;
            DWORD   msgStatus;

            msgStatus = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                       FORMAT_MESSAGE_FROM_SYSTEM,
                                       NULL,
                                       Status,
                                       0,
                                       (LPWSTR)&msgString,
                                       0,
                                       NULL);

            if ( msgStatus != 0 ) {
                CsLogEventData1(LOG_CRITICAL,
                                SERVICE_CLUSRTL_ERROR,
                                sizeof(Status),
                                (PVOID)&Status,
                                msgString);
                LocalFree( msgString);
            }
        }

        goto init_failed;
    }

    ClRtlInitWmi(L"Clustering Service");
    //
    // Log the version number
    //
    ClRtlLogPrint( LOG_NOISE, "\n\n");
    ClRtlLogPrint( LOG_NOISE,
                "[CS] Cluster Service started - Cluster Node Version %1!u!.%2!u!\n",
                 CLUSTER_GET_MAJOR_VERSION( CsMyHighestVersion ),
                 CLUSTER_GET_MINOR_VERSION( CsMyHighestVersion ));

    Version.dwOSVersionInfoSize = sizeof(Version);
    success = GetVersionExW((POSVERSIONINFOW)&Version);

    if ( success ) {
    //
    // Log the System version number
    //
        if ( Version.wSuiteMask & VER_SUITE_DATACENTER ) {
            suiteInfo = L"DTC";
        } else if ( Version.wSuiteMask & VER_SUITE_ENTERPRISE ) {
            suiteInfo = L"ADS";
        } else if ( Version.wSuiteMask & VER_SUITE_EMBEDDEDNT ) {
            suiteInfo  = L"EMB";
        } else if ( Version.wProductType & VER_NT_WORKSTATION ) {
            suiteInfo = L"WS";
        } else if ( Version.wProductType & VER_NT_DOMAIN_CONTROLLER ) {
            suiteInfo = L"DC";
        } else if ( Version.wProductType & VER_NT_SERVER ) {
            suiteInfo = L"SRV";  // otherwise - some non-descript Server
        } else {
            suiteInfo = L"";
        }

        dwMask = (Version.wProductType << 24) | Version.wSuiteMask;

        ClRtlLogPrint(LOG_NOISE,
                   "                               OS Version %1!u!.%2!u!.%3!u!%4!ws!%5!ws! (%6!ws! %7!08XL!)\n",
                    Version.dwMajorVersion,
                    Version.dwMinorVersion,
                    Version.dwBuildNumber,
                    *Version.szCSDVersion ? L" - " : L"",
                    Version.szCSDVersion,
                    suiteInfo,
                    dwMask);
    } else {
        ClRtlLogPrint( LOG_UNUSUAL,
                    "                               OS Version not available! (error %1!u!)\n",
                     GetLastError()
                     );
    }

    //
    // log the local time so we can correlate other logs which show local time
    //
    GetLocalTime( &localTime );
    ClRtlLogPrint( LOG_NOISE,
                "                               Local Time is "\
                 " %1!02d!/%2!02d!/%3!02d!-%4!02d!:%5!02d!:%6!02d!.%7!03d!\n",
                 localTime.wYear,
                 localTime.wMonth,
                 localTime.wDay,
                 localTime.wHour,
                 localTime.wMinute,
                 localTime.wSecond,
                 localTime.wMilliseconds);

    Status = ClRtlBuildClusterServiceSecurityDescriptor( NULL );
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, "[CS] Failed to build cluster security descriptor %1!x!\n",
                                  Status);
        goto init_failed;
    }

    //get params set in the registry
    Status = CspGetServiceParams();
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, "[CS] Failed to read service params %1!d!\n",
                                  Status);
        goto init_failed;
    }

    //the params on the command line over ride the ones in the registry
    if (CsRunningAsService == FALSE) {
        for (i=1; i<argc; i++) {
            if (lstrcmpiW( L"loglevel", argv[i]+1) == 0) {
                if (argc < i+2) {
                    CspUsage();
                }

                CsLogLevel = _wtoi(argv[++i]);
            }
#ifdef CLUSTER_TESTPOINT
            else if (lstrcmpiW( L"testpt", argv[i]+1 ) == 0 ) {
                if (argc < i+2) {
                    CspUsage();
                }

                CsTestPoint = _wtoi(argv[++i]);
            }
            else if ( lstrcmpiW( L"persistent", argv[i]+1 ) == 0 ) {
                CsPersistentTestPoint = TRUE;
            }
            else if ( lstrcmpiW( L"trigger", argv[i]+1 ) == 0 ) {
                if ( argc < i+2  ) {
                    CspUsage();
                }
                CsTestTrigger = _wtoi(argv[++i]);
            }
            else if ( lstrcmpiW( L"action", argv[i]+1 ) == 0 ) {
                if ( argc < i+2  ) {
                    CspUsage();
                }
                CsTestAction = _wtoi(argv[++i]);
            }

#endif // CLUSTER_TESTPOINT

#if CLUSTER_BETA
            else if ( lstrcmpiW( L"norpcauth", argv[i]+1 ) == 0 ) {
                CsUseAuthenticatedRPC = FALSE;
            }
#endif // CLUSTER_BETA

            else if ( lstrcmpiW( L"debugresmon", argv[i]+1 ) == 0 ) {
                CsDebugResmon = TRUE;
                //
                // check for optional, non-NULL command string
                //
                if ( argc >= i+2  ) {
                    if ( *argv[i+1] != L'-' && *argv[i+1] != L'/' && *argv[i+1] != UNICODE_NULL ) {
                        CsResmonDebugCmd = argv[++i];
                    }
                }
            }
            else if ( lstrcmpiW( L"novercheck", argv[i]+1 ) == 0 ) {
                CsNoVersionCheck = TRUE;
            }
            else if ( lstrcmpiW( L"noquorumlogging", argv[i]+1 ) == 0 ) {
                CsNoQuorumLogging = TRUE;
                CsUserTurnedOffQuorumLogging = TRUE;
            }
            else if ( lstrcmpiW( L"fixquorum", argv[i]+1 ) == 0 ) {
                CsNoQuorum = TRUE;
                CsNoQuorumLogging = TRUE;
                CsUserTurnedOffQuorumLogging = TRUE;
            }
            else if ( lstrcmpiW( L"resetquorumlog", argv[i]+1 ) == 0 ) {
                CsResetQuorumLog = TRUE;
            }
            else if ( lstrcmpiW( L"forcequorum", argv[i]+1 ) == 0 ) {
                CsForceQuorum = TRUE;
                CsCommandLineForceQuorum = TRUE;
                if (( argc < i+2 )
                    || ( *argv[i+1] == L'-' ) 
                    || ( *argv[i+1] == L'/' )) {

                    CsForceQuorumNodes = NULL;
                } else {
                    CsForceQuorumNodes = argv[++i];
                }
            }
            else if ( lstrcmpiW( L"norepevtlogging", argv[i]+1 ) == 0 ) {
                CsNoRepEvtLogging = TRUE;
            }

            else if ( lstrcmpiW( L"debug", argv[i]+1 ) == 0 ) {
                debugFlagFound = TRUE;
            }
            else if ( lstrcmpiW( L"restoredatabase", argv[i]+1 ) == 0 ) {
                if ( ( argc < i+2 ) ||
                     ( *argv[i+1] == L'-' ) ||
                     ( *argv[i+1] == L'/' ) )
                {
                    printf("\n\n*** restoredatabase option needs a path parameter ***\n\n");
                    CspUsage();
                }

                if ( !ClRtlIsPathValid( argv[i+1] )) {
                    printf( "\n\n*** restoredatabase path is invalid ***\n\n" );
                    CspUsage();
                }

                if ( !ClRtlPathFileExists( argv[i+1] )) {
                    printf( "\n\n*** restoredatabase file cannot be accessed ***\n\n" );
                    CspUsage();
                }

                dwLen = lstrlenW ( argv[++i] );
                CsDatabaseRestorePath = (LPWSTR) LocalAlloc (LMEM_FIXED,
                                            ( dwLen + 1 ) * sizeof ( WCHAR ) );
                if ( CsDatabaseRestorePath == NULL ) {
                    printf("Error %d in allocating storage for restoredatabase path name (%ws)...\n",
                            GetLastError(),
                            argv[i]);
                    CspUsage();
                }
                wcscpy( CsDatabaseRestorePath, argv[i] );
                CsDatabaseRestore = TRUE;
            }
            else if ( lstrcmpiW( L"quodriveletter", argv[i]+1 ) == 0 ) {
                if ( ( argc < i+2 ) ||
                     ( *argv[i+1] == L'-' ) ||
                     ( *argv[i+1] == L'/' ) )
                {
                    printf("\n\n*** quodriveletter option needs a drive letter parameter ***\n\n");
                    CspUsage();
                }

                dwLen = lstrlenW ( argv[++i] );
                if ( ( dwLen != 2 ) ||
                     !iswalpha( *argv[i] ) ||
                     ( *( argv[i]+1 ) != L':' ) ) {
                    printf("\n\n*** invalid drive letter %ws supplied with quodriveletter option ***\n\n",
                            argv[i]);
                    CspUsage();
                }

                CsQuorumDriveLetter = (LPWSTR) LocalAlloc (LMEM_FIXED,
                                            ( dwLen + 1 ) * sizeof ( WCHAR ) );
                if ( CsQuorumDriveLetter == NULL ) {
                    printf("Error %d in allocating storage for quodriveletter option (%ws)...\n\n",
                            GetLastError(),
                            argv[i]);
                    CspUsage();
                }
                wcscpy( CsQuorumDriveLetter,  argv[i] );
            }
            else if ( lstrcmpiW( L"forcerestore", argv[i]+1 ) == 0 ) {
                CsForceDatabaseRestore = TRUE;
            }
            else {
                CspUsage();
            }
        }

        if (!debugFlagFound && !CspStopEvent) {
            CspUsage();
        }

        if ( CsDatabaseRestore == TRUE ) {
            if ( CsNoQuorumLogging || CsNoQuorum ) {
                printf("\n\n**** restoredatabase cannot be used with noquorumlogging/fixquorum options ****\n\n");
                CspUsage();
            }
        } else if ( CsForceDatabaseRestore ) {
            printf("\n\n**** forcerestore cannot be used without restoredatabase option ****\n\n");
            CspUsage();
        } 

        if ( ( CsQuorumDriveLetter != NULL ) && !CsForceDatabaseRestore ) {
            printf("\n\n**** quodriveletter cannot be used without forcerestore option ****\n\n");
            CspUsage();
        }
    }

    //
    // Create our stop event
    //
    Status = ERROR_SUCCESS;
    if (!CspStopEvent)
    {
        CspStopEvent = CreateEvent(
                        NULL,   // default security
                        FALSE,  // auto-reset
                        FALSE,  // initial state is non-signalled
                        NULL    // unnamed event
                        );

        if (CspStopEvent == NULL) {
            Status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                "[CS] Unable to create stop event, %1!u!\n",
                Status);
        }
    }

    //
    // we can't fire up our main routine if we're running as a service until
    // now (race conditions between reading startup params out of the registry
    // versus whether we're running as a service at all, etc.). Note that we
    // failed initialization so if we are running as a service, we'll detect
    // it in CspServiceMain and issue the stop
    //
init_failed:
    CspInitStatus = Status;

    //
    // Run the service.
    //
    if (CsRunningAsService) {
        if (!StartServiceCtrlDispatcher(dispatchTable)) {
            Status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                "[CS] Unable to dispatch to SC, %1!u!\n",
                Status);
            CL_UNEXPECTED_ERROR( Status );
        }
    }
    else if ( CspInitStatus == ERROR_SUCCESS ) {
        Status = CspDebugService(argc, argv);
    }

    ClRtlFreeClusterServiceSecurityDescriptor( );

    return(Status);
}



void CsGetClusterVersionInfo(
    IN PCLUSTERVERSIONINFO pClusterVersionInfo)
{
    OSVERSIONINFOW   OsVersionInfo;

    pClusterVersionInfo->dwVersionInfoSize = sizeof(CLUSTERVERSIONINFO);
    pClusterVersionInfo->MajorVersion = (WORD)VER_PRODUCTVERSION_W >> 8;
    pClusterVersionInfo->MinorVersion = (WORD)VER_PRODUCTVERSION_W & 0xff;
    pClusterVersionInfo->BuildNumber = (WORD)CLUSTER_GET_MINOR_VERSION(CsMyHighestVersion);

    mbstowcs(pClusterVersionInfo->szVendorId, VER_CLUSTER_PRODUCTNAME_STR,
        (lstrlenA(VER_CLUSTER_PRODUCTNAME_STR)+1));

    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionExW(&OsVersionInfo);
    lstrcpynW(pClusterVersionInfo->szCSDVersion, OsVersionInfo.szCSDVersion,
        (sizeof(pClusterVersionInfo->szCSDVersion)/sizeof(WCHAR)));
    pClusterVersionInfo->dwReserved = 0;
    NmGetClusterOperationalVersion(&(pClusterVersionInfo->dwClusterHighestVersion),
        &(pClusterVersionInfo->dwClusterLowestVersion),&(pClusterVersionInfo->dwFlags));


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\init\restore.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    restore.c

Abstract:

    Functions supporting the restoration of the cluster database 
    to the quorum disk

Author:

    Chittur Subbaraman (chitturs) 27-Oct-1998


Revision History:

--*/
#include "initp.h"
#include "winioctl.h"
#include <stdio.h>
#include <stdlib.h>

//
//  Static global variables used only in this file
//
//  static LPWSTR  szRdbpNodeNameList = NULL;
//  static DWORD   dwRdbpNodeCount = 0;

/****
@func       DWORD | RdbStopSvcOnNodes | Stop the requested service
            on the given node list

@parm       IN PNM_NODE_ENUM2 | pNodeEnum | Pointer to the list of
            nodes in which the requested service has to be stopped.
            
@rdesc      Returns a Win32 error code on failure. ERROR_SUCCESS on success.

@comm       This function attempts to stop the chosen service on the chosen
            list of nodes. If it fails in stopping the service on any
            one of the nodes, it returns a Win32 error code.

            At this time, this function DOES NOT STOP a cluster service
            which is run as a process in a remote node.

@xref       <f RdbStartSvcOnNodes> 
****/
DWORD
RdbStopSvcOnNodes(
    IN PNM_NODE_ENUM2 pNodeEnum,
    IN LPCWSTR lpszServiceName
    )
{
    SC_HANDLE       hService;
    SC_HANDLE       hSCManager;
    DWORD           dwStatus = ERROR_SUCCESS;
    DWORD           dwRetryTime;
    DWORD           dwRetryTick;
    SERVICE_STATUS  serviceStatus;
    WCHAR           szNodeName[CS_MAX_NODE_NAME_LENGTH + 1];
    DWORD           i;
    BOOL            bStopCommandGiven;

    //
    //  Chittur Subbaraman (chitturs) - 10/30/98
    //
#if 0
    //  
    //  Allocate storage for the node names which you would use to
    //  start the service later. Memory is freed in RdbpStartSvcOnNodes
    //
    if ( pNodeEnum->NodeCount > 0 )
    {
        szRdbpNodeNameList = ( LPWSTR ) LocalAlloc( LMEM_FIXED,
                                                      sizeof ( WCHAR) *
                                                      ( CS_MAX_NODE_NAME_LENGTH + 1 ) *
                                                      pNodeEnum->NodeCount );
        if ( szRdbpNodeNameList == NULL )
        {            
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[INIT] RdbStopSvcOnNodes: Unable to allocate memory for node names, Error = %1!d!\n",
                  GetLastError());
        } 
    }
#endif
    //
    //  Walk through the list of nodes
    //
    for ( i=0; i<pNodeEnum->NodeCount; i++ )
    {  
        lstrcpyW( szNodeName, pNodeEnum->NodeList[i].NodeName );
        //
        //  Skip the local node, if it is included in the list
        //
        if ( ( lstrcmpW ( szNodeName, NmLocalNodeName ) == 0 ) )
        {
            continue;
        }
        // 
        //  Try for 2 minutes max to stop the service on a node. Retry
        //  in steps of 5 secs.
        //
        dwRetryTime = 120 * 1000;
        dwRetryTick = 05 * 1000;

        //
        //  Open a handle to the service control manager
        //
        hSCManager = OpenSCManager( szNodeName,
                                    NULL,
                                    SC_MANAGER_ALL_ACCESS );
        if ( hSCManager == NULL ) 
        {
            dwStatus = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[INIT] RdbStopSvcOnNodes: Unable to open SC manager on node %1!ws!, Error = %2!d!\n",
                  szNodeName,
                  dwStatus);
            continue;
        }

        //
        //  Open a handle to the service
        //
        hService = OpenService( hSCManager,
                                lpszServiceName,
                                SERVICE_ALL_ACCESS );
                                     
        CloseServiceHandle( hSCManager );
        
        if ( hService == NULL ) 
        {
            dwStatus = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[INIT] RdbStopSvcOnNodes: Unable to open handle to %1!ws! service on node %2!ws!, Error = %3!d!\n",
                  lpszServiceName,
                  szNodeName,
                  dwStatus);
            continue;
        }

        //
        //  Check whether the service is already in the SERVICE_STOPPED
        //  state.
        //
        if ( QueryServiceStatus( hService,
                                 &serviceStatus ) ) 
        {
            if ( serviceStatus.dwCurrentState == SERVICE_STOPPED )
            {
                ClRtlLogPrint(LOG_NOISE, 
                    "[INIT] RdbStopSvcOnNodes: %1!ws! on node %2!ws! already stopped\n",
                      lpszServiceName,
                      szNodeName);
                CloseServiceHandle( hService );
                continue;
            }
        }
        
        bStopCommandGiven = FALSE;
        
        while ( TRUE ) 
        {
            dwStatus = ERROR_SUCCESS;
            if ( bStopCommandGiven == TRUE )
            {
                if ( QueryServiceStatus( hService,
                                         &serviceStatus ) ) 
                {
                    if ( serviceStatus.dwCurrentState == SERVICE_STOPPED )
                    {
                        //
                        //  Succeeded in stopping the service
                        //
                        ClRtlLogPrint(LOG_NOISE, 
                            "[INIT] RdbStopSvcOnNodes: %1!ws! on node %2!ws! stopped successfully\n",
                            lpszServiceName,
                            szNodeName);
                        break;                    
                    }
                } else
                {
                    dwStatus = GetLastError();
                    ClRtlLogPrint(LOG_ERROR, 
                        "[INIT] RdbStopSvcOnNodes: Error %3!d! in querying status of %1!ws! on node %2!ws!\n",
                        lpszServiceName,
                        szNodeName,
                        dwStatus);
                }
            } else
            {
                if ( ControlService( hService,
                                     SERVICE_CONTROL_STOP,
                                     &serviceStatus ) ) 
                {
                    bStopCommandGiven = TRUE;
                    dwStatus = ERROR_SUCCESS;
                } else
                {
                    dwStatus = GetLastError();
                    ClRtlLogPrint(LOG_ERROR, 
                        "[INIT] RdbStopSvcOnNodes: Error %3!d! in trying to stop %1!ws! on node %2!ws!\n",
                        lpszServiceName,
                        szNodeName,
                        dwStatus);
                }
            }

            if ( ( dwStatus == ERROR_EXCEPTION_IN_SERVICE ) ||
                 ( dwStatus == ERROR_PROCESS_ABORTED ) ||
                 ( dwStatus == ERROR_SERVICE_NOT_ACTIVE ) ) 
            {
                //
                //  The service is essentially in a terminated state
                //
                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[INIT] RdbStopSvcOnNodes: %1!ws! on node %2!ws! died/inactive\n",
                        lpszServiceName,
                        szNodeName);
                dwStatus = ERROR_SUCCESS;
                break;
            }

            if ( ( dwRetryTime -= dwRetryTick ) <= 0 ) 
            {
                //
                //  All tries to stop the service failed, exit from this
                //  function with an error code
                //
                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[INIT] RdbStopSvcOnNodes: Service %1!ws! service on node %2!ws! did not stop, giving up...\n",
                        lpszServiceName,
                        szNodeName);
                dwStatus = ERROR_TIMEOUT;
                break;
            }

            ClRtlLogPrint(LOG_NOISE, 
                   "[INIT] RdbStopSvcOnNodes: Trying to stop %1!ws! on node %2!ws!\n",
                     lpszServiceName,
                     szNodeName);
            //
            //  Sleep for a while and retry stopping the service
            //
            Sleep( dwRetryTick );
        } // while
    
        CloseServiceHandle( hService );
        
        if ( dwStatus != ERROR_SUCCESS )
        {
            goto FnExit;
        }
#if 0
        //
        //  Save the node name for later use when starting the service
        //
        if ( szRdbpNodeNameList != NULL )
        {
            lstrcpyW( szRdbpNodeNameList + dwRdbpNodeCount *
                                           ( CS_MAX_NODE_NAME_LENGTH + 1 ), 
                      szNodeName );
            dwRdbpNodeCount++;
        }
#endif
    } // for

FnExit:
    return( dwStatus );   
}

/****
@func       DWORD | RdbGetRestoreDbParams | Check the registry and see
            whether the restore database option is set. If so, get the
            params.

@parm       IN HKEY | hKey | Handle to the cluster service parameters key
            
@comm       This function attempts read the registry and return the 
            parameters for the restore database operation.

@xref       <f CspGetServiceParams> 
****/
VOID 
RdbGetRestoreDbParams( 
    IN HKEY hClusSvcKey 
    )
{
    DWORD   dwLength = 0;
    DWORD   dwType;
    DWORD   dwStatus;
    DWORD   dwForceDatabaseRestore;

    //
    //  Chittur Subbaraman (chitturs) - 10/30/98
    //
    if ( hClusSvcKey == NULL ) 
    {
        return;
    }

    //  
    //  Try to query the clussvc parameters key. If the RestoreDatabase
    //  value is present, then get the length of the restore database
    //  path. 
    //
    if ( ClRtlRegQueryString( hClusSvcKey,
                              CLUSREG_NAME_SVC_PARAM_RESTORE_DB,
                              REG_SZ,
                              &CsDatabaseRestorePath,
                              &dwLength,
                              &dwLength ) != ERROR_SUCCESS )
    {
        goto FnExit; 
    }

    ClRtlLogPrint(LOG_NOISE, 
              "[INIT] RdbGetRestoreDbparams: Restore Cluster Database is in progress...\n");

    CsDatabaseRestore = TRUE;
    
    //  
    //  Try to query the clussvc parameters key for the ForceRestoreDatabase
    //  value. Don't bother to delete the param, since the 
    //  RestoreClusterDatabase API will do it.
    //
    if ( ClRtlRegQueryDword(  hClusSvcKey,
                              CLUSREG_NAME_SVC_PARAM_FORCE_RESTORE_DB,
                              &dwForceDatabaseRestore,
                              NULL ) != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_NOISE, 
                      "[INIT] RdbGetRestoreDbparams: ForceRestoreDatabase params key is absent or unreadable\n"
                      );
        goto FnExit;
    }
            
    CsForceDatabaseRestore = TRUE; 

    //  
    //  Try to query the clussvc parameters key for the NewQuorumDriveLetter
    //  value. Check for the validity of the drive letter later when
    //  you attempt to fix up stuff. 
    //
    dwLength = 0;
    if ( ClRtlRegQueryString( hClusSvcKey,
                              CLUSREG_NAME_SVC_PARAM_QUORUM_DRIVE_LETTER,
                              REG_SZ,
                              &CsQuorumDriveLetter,
                              &dwLength,
                              &dwLength ) != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_NOISE, 
                      "[INIT] RdbGetRestoreDbparams: NewQuorumDriveLetter params key is absent or unreadable\n"
                      );
    }

FnExit:
    //
    //  Make sure you delete these registry values read above. It is OK if you fail in finding
    //  some of these values. Note that the RestoreClusterDatabase API will also try to clean
    //  up these values. We cannot assume that the API will clean up these values since the
    //  values could be set by (a) ASR (b) A user by hand, and not always by the API.
    //
    RdbpDeleteRestoreDbParams();
}

/****
@func       DWORD | RdbFixupQuorumDiskSignature | Fixup the quorum disk
            signature with the supplied value, if necessary

@parm       IN DWORD | dwSignature | The new signature which must be
            written to the quorum disk.
            
@rdesc      Returns a non-zero value if successful. 0 on failure.

@comm       This function attempts to write the given signature into
            the physical quorum disk, if necessary.

@xref       <f RdbStartSvcOnNodes> 
****/
BOOL
RdbFixupQuorumDiskSignature(
    IN DWORD dwSignature
    )
{
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    DWORD       dwStatus;
    BOOL        bStatus = 1;

    //
    //  Chittur Subbaraman (chitturs) - 10/30/98
    //
    if ( ( dwSignature == 0 ) ||
         ( lstrlenW ( CsQuorumDriveLetter ) != 2 ) ||
         ( !iswalpha( CsQuorumDriveLetter[0] ) ) ||
         ( CsQuorumDriveLetter[1] != L':' ) )
    {
        bStatus = 0;
        goto FnExit;
    }

    //
    //  Now try to open the quorum disk device
    //
    if ( ( dwStatus = RdbpOpenDiskDevice ( CsQuorumDriveLetter, &hFile ) ) 
            != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_ERROR, 
            "[INIT] RdbFixupQuorumDiskSignature: Error %1!d! in opening %2!ws!\n",
                dwStatus,
                CsQuorumDriveLetter
            );
        bStatus = 0;
        goto FnExit;
    }

    //
    //  Get the signature from the drive, compare it with the input
    //  parameter and if they are different, write new signature to
    //  disk.
    //
    if ( ( dwStatus = RdbpCompareAndWriteSignatureToDisk( hFile, dwSignature ) )
            != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_ERROR, 
            "[INIT] RdbFixupQuorumDiskSignature: Error %1!d! in attempting to write signature to %2!ws!\n",
                dwStatus,
                CsQuorumDriveLetter
            );
        bStatus = 0;
        goto FnExit;     
    }
    
FnExit:
    if ( hFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( hFile );
    }
    return ( bStatus );   
}

/****
@func       DWORD | RdbpOpenDiskDevice | Open and get a handle
            to a physical disk device

@parm       IN LPCWSTR | lpDriveLetter | The disk drive letter.

@parm       OUT PHANDLE | pFileHandle | Pointer to the handle to the open 
            device.
            
@rdesc      Returns ERROR_SUCCESS if successful. A Win32 error code on 
            failure.

@comm       This function attempts to open a disk device and return a
            handle to it. Different ways are used to open the device.
          
@xref       <f RdbFixupQuorumDiskSignature> 
****/
DWORD
RdbpOpenDiskDevice(
    IN  LPCWSTR  lpDriveLetter,
    OUT PHANDLE  pFileHandle
    )
{
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    DWORD               accessMode;
    DWORD               shareMode;
    DWORD               dwStatus;
    BOOL                bFailed = FALSE;
    WCHAR               deviceNameString[128];

    //
    //  Chittur Subbaraman (chitturs) - 10/30/98
    //
    //  Note it is important to access the device with 0 access mode 
    //  so that the file open code won't do extra I/O to the device.
    //
    shareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
    accessMode = GENERIC_READ | GENERIC_WRITE;

    lstrcpyW( deviceNameString, L"\\\\.\\" );
    lstrcatW( deviceNameString, lpDriveLetter );

    hFile = CreateFileW( deviceNameString,
                         accessMode,
                         shareMode,
                         NULL,
                         OPEN_EXISTING,
                         0,
                         NULL );

    if ( hFile == INVALID_HANDLE_VALUE ) 
    {
        dwStatus = GetLastError();
        goto FnExit;
    }

    dwStatus = ERROR_SUCCESS;
    *pFileHandle = hFile;

FnExit:
    return( dwStatus );
}

/****
@func       DWORD | RdbpCompareAndWriteSignatureToDisk | Compare the
            signature on disk with the input parameter and if they
            are not the same, write the input parameter as a new signature.

@parm       IN HANDLE | hFile | Handle to the disk device.

@parm       IN DWORD | dwSignature | Signature to be compared with
            exisiting disk signature.
            
@rdesc      Returns ERROR_SUCCESS if successful. A Win32 error code on 
            failure.

@comm       This function attempts to first get the drive layout, read the
            signature information, and then if necessary write back a
            new signature to the drive. [This code is stolen from Rod's 
            clusdisk\test\disktest.c and then adapted to suit our needs.]
          
@xref       <f RdbFixupQuorumDiskSignature> 
****/
DWORD
RdbpCompareAndWriteSignatureToDisk(
    IN  HANDLE  hFile,
    IN  DWORD   dwSignature
    )
{
    DWORD                       dwStatus;
    DWORD                       dwBytesReturned;
    DWORD                       dwDriveLayoutSize;
    PDRIVE_LAYOUT_INFORMATION   pDriveLayout = NULL;

    //
    //  Chittur Subbaraman (chitturs) - 10/30/98
    //
    if ( !ClRtlGetDriveLayoutTable( hFile, &pDriveLayout, &dwBytesReturned )) {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_ERROR, 
            "[INIT] RdbpCompareAndWriteSignatureToDisk: Error %1!d! in getting "
             "drive layout from %2!ws!\n",
             dwStatus,
             CsQuorumDriveLetter
            );
        goto FnExit;
    }

    dwDriveLayoutSize = sizeof( DRIVE_LAYOUT_INFORMATION ) +
                          ( sizeof( PARTITION_INFORMATION ) *
                                ( pDriveLayout->PartitionCount - 1 ) );

    if ( dwBytesReturned < dwDriveLayoutSize ) 
    {
        ClRtlLogPrint(LOG_ERROR,
          "[INIT] RdbpCompareAndWriteSignatureToDisk: Error reading driveLayout information. Expected %1!u! bytes, got %2!u! bytes.\n",
            dwDriveLayoutSize, 
            dwBytesReturned
          );
        dwStatus = ERROR_INSUFFICIENT_BUFFER;
        goto FnExit;
    }

    if ( pDriveLayout->Signature == dwSignature )
    {
        dwStatus = ERROR_SUCCESS;
        ClRtlLogPrint(LOG_NOISE,
          "[INIT] RdbpCompareAndWriteSignatureToDisk: Disk %1!ws! signature is same as in registry. No fixup needed\n",
             CsQuorumDriveLetter
          );
        goto FnExit;
    }
    //
    //  Change just the signature field and send an ioctl down
    //
    pDriveLayout->Signature = dwSignature;
    
    if ( !DeviceIoControl( hFile,
                           IOCTL_DISK_SET_DRIVE_LAYOUT,
                           pDriveLayout,
                           dwDriveLayoutSize,
                           NULL,
                           0,
                           &dwBytesReturned,
                           FALSE ) )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_ERROR, 
            "[INIT] RdbpCompareAndWriteSignatureToDisk: Error %1!d! in setting drive layout to %2!ws!\n",
                dwStatus,
                CsQuorumDriveLetter
            );
        goto FnExit;
    }

    dwStatus = ERROR_SUCCESS;

    ClRtlLogPrint(LOG_NOISE, 
              "[INIT] RdbpCompareAndWriteSignatureToDisk: Quorum disk signature fixed successfully\n"
              );

FnExit:
    if ( pDriveLayout != NULL ) {
        LocalFree( pDriveLayout );
    }

    return( dwStatus );
}

#if 0
/****
@func       DWORD | RdbStartSvcOnNodes | Start the cluster service on
            the nodes in which you stopped the service.

@parm       IN LPCWSTR | lpszServiceName | Name of the service to start.
           
@rdesc      Returns a Win32 error code on failure. ERROR_SUCCESS on success.

@comm       This function attempts to start the service on the nodes on
            which it stopped the service for a restoration operation.

@xref       <f RdbStopSvcOnNodes> 
****/
DWORD
RdbStartSvcOnNodes(
    IN LPCWSTR  lpszServiceName
    )
{
    SC_HANDLE       hService;
    SC_HANDLE       hSCManager;
    DWORD           dwStatus = ERROR_SUCCESS;
    SERVICE_STATUS  serviceStatus;
    WCHAR           szNodeName[CS_MAX_NODE_NAME_LENGTH + 1];
    DWORD           i;
    //
    //  Chittur Subbaraman (chitturs) - 11/4/98
    //
    //  Walk through the list of nodes
    //
    for ( i=0; i<dwRdbpNodeCount; i++ )
    {  
        lstrcpyW( szNodeName, szRdbpNodeNameList + i *
                                                   ( CS_MAX_NODE_NAME_LENGTH + 1 ) );
        
        //
        //  Open a handle to the service control manager
        //
        hSCManager = OpenSCManager( szNodeName,
                                    NULL,
                                    SC_MANAGER_ALL_ACCESS );
        if ( hSCManager == NULL ) 
        {
            dwStatus = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[INIT] RdbStartSvcOnNodes: Unable to open SC manager on node %1!ws!, Error = %2!d!\n",
                  szNodeName,
                  dwStatus);
            continue;
        }

        //
        //  Open a handle to the service
        //
        hService = OpenService( hSCManager,
                                lpszServiceName,
                                SERVICE_ALL_ACCESS );
                                     
        CloseServiceHandle( hSCManager );
        
        if ( hService == NULL ) 
        {
            dwStatus = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[INIT] RdbStartSvcOnNodes: Unable to open handle to %1!ws! service on node %2!ws!, Error = %3!d!\n",
                  lpszServiceName,
                  szNodeName,
                  dwStatus);
            continue;
        }

        //
        //  Check whether the service is already started.
        //
        if ( QueryServiceStatus( hService,
                                 &serviceStatus ) ) 
        {
            if ( ( serviceStatus.dwCurrentState == SERVICE_RUNNING ) ||
                 ( serviceStatus.dwCurrentState == SERVICE_START_PENDING ) )
            {
                ClRtlLogPrint(LOG_NOISE, 
                    "[INIT] RdbStartSvcOnNodes: %1!ws! on node %2!ws! already started\n",
                      lpszServiceName,
                      szNodeName);
                CloseServiceHandle( hService );
                continue;
            }
        }
        
        //
        //  Now, start the cluster service
        //
        if ( !StartService( hService,
                            0,
                            NULL ) )
        {
            dwStatus = GetLastError();
            ClRtlLogPrint(LOG_ERROR, 
                      "[INIT] RdbStartSvcOnNodes: Unable to start cluster service on %1!ws!\n",
                        szNodeName
                      );  
        } else
        {
            ClRtlLogPrint(LOG_ERROR, 
                      "[INIT] RdbStartSvcOnNodes: Cluster service started on %1!ws!\n",
                        szNodeName
                      );  
        }
        //
        //  And, close the current handle
        //
        CloseServiceHandle( hService );   
   } // for

   //
   //  Now free the memory
   //
   LocalFree( szRdbpNodeNameList );

   return( dwStatus );   
}
#endif

/****
@func       DWORD | RdbInitialize | This function performs the
            initialization steps necessary for the restore database
            manager. Specifically, copy the most recent checkpoint
            file from the backup path to the cluster directory overwriting
            the CLUSDB there.
                      
@rdesc      Returns a Win32 error code if the operation is 
            unsuccessful. ERROR_SUCCESS on success.

@xref       <f DmInitialize>     
****/
DWORD
RdbInitialize(
    VOID
    )
{
    HANDLE                      hFindFile = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW            FindData;
    DWORD                       dwStatus;
    WCHAR                       szDestFileName[MAX_PATH];
    LPWSTR                      szSourceFileName = NULL;
    LPWSTR                      szSourcePathName = NULL;
    DWORD                       dwLen;
    WIN32_FILE_ATTRIBUTE_DATA   FileAttributes;
    LARGE_INTEGER               liFileCreationTime;
    LARGE_INTEGER               liMaxFileCreationTime;
    WCHAR                       szCheckpointFileName[MAX_PATH];
    WCHAR                       szClusterDir[MAX_PATH];
    LPCWSTR                     lpszPathName = CsDatabaseRestorePath;


    //
    //  Chittur Subbaraman (chitturs) - 12/4/99
    //

    //
    //  If there is no cluster database restore in progress, don't do anything.
    //
    if( CsDatabaseRestore == FALSE ) 
    {
        return( ERROR_SUCCESS );
    }

    ClRtlLogPrint(LOG_NOISE, "[INIT] RdbInitialize: Entry...\n");

    dwLen = lstrlenW ( lpszPathName );
    //  
    //  It is safer to use dynamic memory allocation for user-supplied
    //  path since we don't want to put restrictions on the user
    //  on the length of the path that can be supplied. However, as
    //  far as our own destination path is concerned, it is system-dependent
    //  and static memory allocation for that would suffice.
    //
    szSourcePathName = (LPWSTR) LocalAlloc ( LMEM_FIXED, 
                                 ( dwLen + 25 ) *
                                 sizeof ( WCHAR ) );

    if ( szSourcePathName == NULL )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[INIT] RdbInitialize: Error %1!d! in allocating memory for %2!ws!\n",
                      dwStatus,
                      lpszPathName); 
        goto FnExit;
    }
    
    lstrcpyW ( szSourcePathName,  lpszPathName );
  
    //
    //  If the client-supplied path is not already terminated with '\', 
    //  then add it.
    //
    if ( szSourcePathName [dwLen-1] != L'\\' )
    {
        szSourcePathName [dwLen++] = L'\\';
        szSourcePathName [dwLen] = L'\0';
    }

    lstrcatW ( szSourcePathName, L"CLUSBACKUP.DAT" );

    //
    //  Try to find the CLUSBACKUP.DAT file in the directory
    //
    hFindFile = FindFirstFileW( szSourcePathName, &FindData );
    //
    //  Reuse the source path name variable
    //
    szSourcePathName[dwLen] = L'\0';
    if ( hFindFile == INVALID_HANDLE_VALUE )
    {
        dwStatus = GetLastError();
        if ( dwStatus != ERROR_FILE_NOT_FOUND )
        {
            ClRtlLogPrint(LOG_UNUSUAL, 
                          "[INIT] RdbInitialize: Path %1!ws! unavailable, Error = %2!d!\n",
                          szSourcePathName,
                          dwStatus); 
        } else
        {
            dwStatus = ERROR_DATABASE_BACKUP_CORRUPT;
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[INIT] RdbInitialize: Backup procedure from %1!ws! not fully" 
                          " successful, can't restore checkpoint to CLUSDB, Error = %2!d! !!!\n",
                          szSourcePathName,
                          dwStatus); 
        }
        goto FnExit;
    }
    FindClose ( hFindFile );

    lstrcatW( szSourcePathName, L"chk*.tmp" );

    //
    //  Try to find the first chk*.tmp file in the directory
    //
    hFindFile = FindFirstFileW( szSourcePathName, &FindData );
    //
    //  Reuse the source path name variable
    //
    szSourcePathName[dwLen] = L'\0';
    if ( hFindFile == INVALID_HANDLE_VALUE )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL, 
                      "[INIT] RdbInitialize: Error %2!d! in trying"
                      "to find chk*.tmp file in path %1!ws!\r\n",
                      szSourcePathName,
                      dwStatus); 
        goto FnExit;
    }

    szSourceFileName = (LPWSTR) LocalAlloc ( LMEM_FIXED, 
                                    ( lstrlenW ( szSourcePathName ) + MAX_PATH ) *
                                    sizeof ( WCHAR ) );

    if ( szSourceFileName == NULL )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL, 
                  "[INIT] RdbInitialize: Error %1!d! in allocating memory for source file name\n",
                   dwStatus); 
        goto FnExit;
    }   
   
    dwStatus = ERROR_SUCCESS;
    liMaxFileCreationTime.QuadPart = 0;
    
    //
    //  Now, find the most recent chk*.tmp file from the source path
    //
    while ( dwStatus == ERROR_SUCCESS )
    {
        if ( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
        {
            goto skip;
        }
        
        lstrcpyW( szSourceFileName, szSourcePathName );
        lstrcatW( szSourceFileName, FindData.cFileName );
        if ( !GetFileAttributesExW( szSourceFileName,
                                    GetFileExInfoStandard,
                                    &FileAttributes ) )
        {
            dwStatus = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL, "[INIT] RdbInitialize: Error %1!d! in getting file" 
                       " attributes for %2!ws!\n",
                         dwStatus,
                         szSourceFileName); 
            goto FnExit;
        }
        
        liFileCreationTime.HighPart = FileAttributes.ftCreationTime.dwHighDateTime;
        liFileCreationTime.LowPart  = FileAttributes.ftCreationTime.dwLowDateTime;
        if ( liFileCreationTime.QuadPart > liMaxFileCreationTime.QuadPart )
        {
            liMaxFileCreationTime.QuadPart = liFileCreationTime.QuadPart;
            lstrcpyW( szCheckpointFileName, FindData.cFileName );
        }
skip:
        if ( FindNextFileW( hFindFile, &FindData ) )
        {
            dwStatus = ERROR_SUCCESS;
        } else
        {
            dwStatus = GetLastError();
        }
    }
    
    if ( dwStatus == ERROR_NO_MORE_FILES )
    {
        dwStatus = ERROR_SUCCESS;
    } else
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[INIT] RdbInitialize: FindNextFile failed, error=%1!d!\n",
                      dwStatus);
        goto FnExit;
    }

    //
    //  Get the directory where the cluster is installed
    //
    if ( ( dwStatus = ClRtlGetClusterDirectory( szClusterDir, MAX_PATH ) )
                    != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[INIT] RdbInitialize: Error %1!d! in getting cluster dir !!!\n",
                      dwStatus);
        goto FnExit;
    }

    lstrcpyW( szSourceFileName, szSourcePathName );
    lstrcatW( szSourceFileName, szCheckpointFileName );

    lstrcpyW( szDestFileName, szClusterDir );
    dwLen = lstrlenW( szDestFileName );
    if ( szDestFileName[dwLen-1] != L'\\' )
    {
        szDestFileName[dwLen++] = L'\\';
        szDestFileName[dwLen] = L'\0';
    }

#ifdef   OLD_WAY
    lstrcatW ( szDestFileName, L"CLUSDB" );
#else    // OLD_WAY
    lstrcatW ( szDestFileName, CLUSTER_DATABASE_NAME );
#endif   // OLD_WAY

    //
    //  Set the destination file attribute to normal. Continue even 
    //  if you fail in this step because you will fail in the
    //  copy if this error is fatal.
    //
    SetFileAttributesW( szDestFileName, FILE_ATTRIBUTE_NORMAL );

    //
    //  Now try to copy the checkpoint file to CLUSDB
    //
    dwStatus = CopyFileW( szSourceFileName, szDestFileName, FALSE );
    if ( !dwStatus ) 
    {
        //
        //  You failed in copying. Check whether you encountered a
        //  sharing violation. If so, try unloading the cluster hive and
        //  then retry.
        //
        dwStatus = GetLastError();
        if ( dwStatus == ERROR_SHARING_VIOLATION )
        {
            dwStatus = RdbpUnloadClusterHive( );
            if ( dwStatus == ERROR_SUCCESS )
            {
                SetFileAttributesW( szDestFileName, FILE_ATTRIBUTE_NORMAL );
                dwStatus = CopyFileW( szSourceFileName, szDestFileName, FALSE );
                if ( !dwStatus ) 
                {
                    dwStatus = GetLastError();
                    ClRtlLogPrint(LOG_UNUSUAL, 
                              "[INIT] RdbInitialize: Unable to copy file %1!ws! "
                              "to %2!ws! for a second time, Error = %3!d!\n",
                                szSourceFileName,
                                szDestFileName,
                                dwStatus);
                    goto FnExit;
                }
            } else
            {
                ClRtlLogPrint(LOG_UNUSUAL, 
                              "[INIT] RdbInitialize: Unable to unload cluster hive, Error = %1!d!\n",
                              dwStatus);
                goto FnExit;
            }
        } else
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[INIT] RdbInitialize: Unable to copy file %1!ws! "
                          "to %2!ws! for the first time, Error = %3!d!\n",
                          szSourceFileName,
                          szDestFileName,
                          dwStatus);
            goto FnExit;
        }
    }  

    //
    //  Set the destination file attribute to normal. 
    //
    if ( !SetFileAttributesW( szDestFileName, FILE_ATTRIBUTE_NORMAL ) )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL, 
                  "[INIT] RdbInitialize: Unable to change the %1!ws! "
                    "attributes to normal, Error = %2!d!\n",
                     szDestFileName,
                     dwStatus);
        goto FnExit;
    }
    
    dwStatus = ERROR_SUCCESS;
FnExit:
    if ( hFindFile != INVALID_HANDLE_VALUE )
    {
        FindClose( hFindFile );
    }
    
    LocalFree( szSourcePathName );
    LocalFree( szSourceFileName );

    ClRtlLogPrint(LOG_NOISE, 
              "[INIT] RdbInitialize: Exit with Status = %1!d!...\n",
               dwStatus);

    return( dwStatus );
}

/****
@func       DWORD | RdbpUnloadClusterHive | Unload the cluster hive
                   
@rdesc      Returns a Win32 error code if the operation is 
            unsuccessful. ERROR_SUCCESS on success.

@xref       <f RdbInitialize>     
****/
DWORD
RdbpUnloadClusterHive(
    VOID
    )
{
    BOOLEAN  bWasEnabled;
    DWORD    dwStatus;

    //
    //  Chittur Subbaraman (chitturs) - 12/4/99
    //
    dwStatus = ClRtlEnableThreadPrivilege( SE_RESTORE_PRIVILEGE,
                                           &bWasEnabled );
                                
    if ( dwStatus != ERROR_SUCCESS ) 
    {
        if ( dwStatus == STATUS_PRIVILEGE_NOT_HELD ) 
        {
            ClRtlLogPrint(LOG_UNUSUAL, 
                          "[INIT] RdbpUnloadClusterHive: Restore privilege not held by client\n");
        } else 
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[INIT] RdbpUnloadClusterHive: Attempt to enable restore "
                          "privilege failed, Error = %1!d!\n",
                          dwStatus);
        }
        goto FnExit;
    }

    dwStatus = RegUnLoadKeyW( HKEY_LOCAL_MACHINE,
                              CLUSREG_KEYNAME_CLUSTER );

    ClRtlRestoreThreadPrivilege( SE_RESTORE_PRIVILEGE,
                                 bWasEnabled );   
FnExit:
    return( dwStatus );
}

/****
@func       DWORD | RdbpDeleteRestoreDbParams | Clean up the restore parameters stored
            under HKLM\System\CCC\Services\Clussvc\Parameters. The RestoreClusterDatabase
            API will also attempt to do this.
       
@comm       This function attempts clean the registry parameters for the restore database 
            operation. 

@rdesc      Returns a Win32 error code if the opening of the params key is unsuccessful. 
            ERROR_SUCCESS on success.

@xref       <f RdbGetRestoreDbParams> 
****/
DWORD 
RdbpDeleteRestoreDbParams( 
    VOID
    )
{
    HKEY    hClusSvcKey = NULL;
    DWORD   dwStatus;

    //
    //  Chittur Subbaraman (chitturs) - 08/28/2000
    //
    if( CsDatabaseRestore == FALSE ) 
    {
        return( ERROR_SUCCESS );
    }

    ClRtlLogPrint(LOG_NOISE, "[INIT] RdbDeleteRestoreDbParams: Entry...\n");

    //
    // Open key to SYSTEM\CurrentControlSet\Services\ClusSvc\Parameters
    //
    dwStatus = RegOpenKeyW( HKEY_LOCAL_MACHINE,
                            CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
                            &hClusSvcKey );

    if( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_UNUSUAL, 
                  "[INIT] RdbDeleteRestoreDbParams: Unable to open clussvc params key, error=%1!u!...\n",
                  dwStatus);    
        goto FnExit;
    }

    //
    //  Try to delete the values you set. You may fail in these steps, because all these values need
    //  not be present in the registry.
    //
    dwStatus = RegDeleteValueW( hClusSvcKey, 
                                CLUSREG_NAME_SVC_PARAM_RESTORE_DB ); 

    if ( ( dwStatus != ERROR_SUCCESS ) && ( dwStatus != ERROR_FILE_NOT_FOUND ) )
    {
        ClRtlLogPrint(LOG_NOISE, 
                  "[INIT] RdbDeleteRestoreDbParams: Unable to delete %2!ws! param value, error=%1!u!...\n",
                  dwStatus,
                  CLUSREG_NAME_SVC_PARAM_RESTORE_DB);    
    }
    
    dwStatus = RegDeleteValueW( hClusSvcKey, 
                                CLUSREG_NAME_SVC_PARAM_FORCE_RESTORE_DB ); 

    if ( ( dwStatus != ERROR_SUCCESS ) && ( dwStatus != ERROR_FILE_NOT_FOUND ) )
    {
        ClRtlLogPrint(LOG_NOISE, 
                  "[INIT] RdbDeleteRestoreDbParams: Unable to delete %2!ws! param value, error=%1!u!...\n",
                  dwStatus,
                  CLUSREG_NAME_SVC_PARAM_FORCE_RESTORE_DB);    
    }

    dwStatus = RegDeleteValueW( hClusSvcKey, 
                                CLUSREG_NAME_SVC_PARAM_QUORUM_DRIVE_LETTER );

    if ( ( dwStatus != ERROR_SUCCESS ) && ( dwStatus != ERROR_FILE_NOT_FOUND ) )
    {
        ClRtlLogPrint(LOG_NOISE, 
                  "[INIT] RdbDeleteRestoreDbParams: Unable to delete %2!ws! param value, error=%1!u!...\n",
                  dwStatus,
                  CLUSREG_NAME_SVC_PARAM_QUORUM_DRIVE_LETTER);    
    }

    dwStatus = ERROR_SUCCESS;
    
FnExit:
    if ( hClusSvcKey != NULL )
    {
        RegCloseKey( hClusSvcKey );
    }

    ClRtlLogPrint(LOG_NOISE, "[INIT] RdbDeleteRestoreDbParams: Exit with status=%1!u!...\n",
              dwStatus);

    return( dwStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\init\join.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    join.c

Abstract:

    This module handles the initialization path where a newly booted
    node joins an existing cluster.

Author:

    John Vert (jvert) 6/6/1996

Revision History:

--*/
#include "initp.h"
#include "lmcons.h"
#include "lmremutl.h"
#include "lmapibuf.h"

#include <clusverp.h>


//
// Local types
//
typedef struct {
    LPWSTR   Name;
    LPWSTR   NetworkId;
} JOIN_SPONSOR_CONTEXT, *PJOIN_SPONSOR_CONTEXT;


//
// Local data
//
CRITICAL_SECTION    CsJoinLock;
HANDLE              CsJoinEvent = NULL;
DWORD               CsJoinThreadCount = 0;
DWORD               CsJoinStatus=ERROR_SUCCESS;
RPC_BINDING_HANDLE  CsJoinSponsorBinding = NULL;
LPWSTR              CsJoinSponsorName = NULL;


//
// Local function prototypes
//
VOID
JoinpEnumNodesAndJoinByAddress(
    IN HDMKEY  Key,
    IN PWSTR   NodeId,
    IN PVOID   Context
    );

VOID
JoinpEnumNodesAndJoinByHostName(
    IN HDMKEY  Key,
    IN PWSTR   NodeId,
    IN PVOID   Context
    );

VOID
JoinpConnectToSponsor(
    IN PWSTR   SponsorName
    );

DWORD WINAPI
JoinpConnectThread(
    LPVOID   Parameter
    );

DWORD
JoinpAttemptJoin(
    LPWSTR               SponsorName,
    RPC_BINDING_HANDLE   JoinMasterBinding
    );

BOOL
JoinpAddNodeCallback(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Object,
    IN LPCWSTR Name
    );

BOOL
JoinpEnumNetworksToSetPriority(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Object,
    IN LPCWSTR Name
    );


DWORD
ClusterJoin(
    VOID
    )
/*++

Routine Description:

    Called to attempt to join a cluster that already exists.

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    LPWSTR ClusterIpAddress = NULL;
    LPWSTR ClusIpAddrResource = NULL;
    LPWSTR ClusterNameId = NULL;
    DWORD idMaxSize = 0;
    DWORD idSize = 0;
    HDMKEY hClusNameResKey = NULL;
    HDMKEY hClusIPAddrResKey = NULL;

    //
    // Try connecting using the cluster IP address first. get the cluster
    // name resource, looking up its dependency for the cluster IP addr
    //

    Status = DmQuerySz(DmClusterParametersKey,
                       CLUSREG_NAME_CLUS_CLUSTER_NAME_RES,
                       &ClusterNameId,
                       &idMaxSize,
                       &idSize);

    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[JOIN] failed to get cluster name resource, error %1!u!.\n",
                   Status);
        goto error_exit;
    }

    //
    // open name resource key and read its DependsOn key
    //

    hClusNameResKey = DmOpenKey( DmResourcesKey, ClusterNameId, KEY_READ );

    if ( hClusNameResKey == NULL ) {

        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[JOIN] failed to open Cluster Name resource key, error %1!u!.\n",
                   Status);
        goto error_exit;
    }

    //
    // allocate enough space for the GUID and the Parameters string
    //

    idMaxSize = ( CS_NETWORK_ID_LENGTH + sizeof( CLUSREG_KEYNAME_PARAMETERS ) + 2)
        * sizeof(WCHAR);
    ClusIpAddrResource = LocalAlloc( LMEM_FIXED, idMaxSize );

    if ( ClusIpAddrResource == NULL ) {

        Status = ERROR_NOT_ENOUGH_MEMORY;

        ClRtlLogPrint(LOG_CRITICAL,
                   "[JOIN] no memory for Cluster Ip address resource ID!\n");
        goto error_exit;
    }

    Status = DmQueryMultiSz(hClusNameResKey,
                            CLUSREG_NAME_RES_DEPENDS_ON,
                            &ClusIpAddrResource,
                            &idMaxSize,
                            &idSize);

    if ( Status != ERROR_SUCCESS ) {

        ClRtlLogPrint(LOG_CRITICAL,
                   "[JOIN] failed to get Cluster Ip address resource ID, error %1!u!.\n",
                   Status);
        goto error_exit;
    }

    lstrcatW( ClusIpAddrResource, L"\\" );
    lstrcatW( ClusIpAddrResource, CLUSREG_KEYNAME_PARAMETERS );
    hClusIPAddrResKey = DmOpenKey( DmResourcesKey, ClusIpAddrResource, KEY_READ );

    if ( hClusIPAddrResKey == NULL ) {

        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[JOIN] failed to open Cluster IP Address resource key, error %1!u!.\n",
                   Status);
        goto error_exit;
    }

    //
    // get the IP Address; note that these value names are not defined
    // in a global way. if they are changed, this code will break
    //

    idMaxSize = idSize = 0;
    Status = DmQuerySz(hClusIPAddrResKey,
                       L"Address",
                       &ClusterIpAddress,
                       &idMaxSize,
                       &idSize);

    if ( Status != ERROR_SUCCESS ) {

        ClRtlLogPrint(LOG_CRITICAL,
                   "[JOIN] failed to get Cluster Ip address, error %1!u!.\n",
                   Status);
        goto error_exit;
    }

    //
    // Spawn threads to find a sponsor. We will try the make connections using
    // the cluster IP address, the IP address of each node on each network, and
    // the name of each node in the cluster. The connects will proceed in
    // parallel. We'll use the first one that succeeds.
    //
    CsJoinEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (CsJoinEvent == NULL) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[JOIN] failed to create join event, error %1!u!.\n",
            Status
            );
        goto error_exit;
    }

    CsJoinThreadCount = 1;
    InitializeCriticalSection(&CsJoinLock);
    EnterCriticalSection(&CsJoinLock);

    DmEnumKeys(DmNetInterfacesKey, JoinpEnumNodesAndJoinByAddress, NULL);

    DmEnumKeys(DmNodesKey, JoinpEnumNodesAndJoinByHostName, NULL);

    //
    // give the other threads a chance to start since using the cluster IP
    // address to join with is problematic when the resource moves in the
    // middle of a join
    //
    Sleep( 1000 );
    JoinpConnectToSponsor(ClusterIpAddress);

    //update status for scm
    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();


    if(CsJoinThreadCount == 1)
        SetEvent(CsJoinEvent);

    LeaveCriticalSection(&CsJoinLock);

    Status = WaitForSingleObject(CsJoinEvent, INFINITE);
    CL_ASSERT(Status == WAIT_OBJECT_0);


    EnterCriticalSection(&CsJoinLock);
    ClRtlLogPrint(LOG_NOISE, 
        "[JOIN] Got out of the join wait, CsJoinThreadCount = %1!u!.\n",
        CsJoinThreadCount
        );

    if(--CsJoinThreadCount == 0) {
        CloseHandle(CsJoinEvent);
        DeleteCriticalSection(&CsJoinLock);
    }
    else
        LeaveCriticalSection(&CsJoinLock);

    //
    // All of the threads have failed or one of them made a connection,
    // use it to join.
    //
    if (CsJoinSponsorBinding != NULL) {
        CL_ASSERT(CsJoinSponsorName != NULL);

        ClRtlLogPrint(LOG_UNUSUAL, 
            "[JOIN] Attempting join with sponsor %1!ws!.\n",
            CsJoinSponsorName
            );

        //
        //  Chittur Subbaraman (chitturs) - 10/27/98
        //
        //  If the database restore operation is requested, then
        //  refuse to join the cluster and return an error code.
        //
        if ( CsDatabaseRestore == TRUE ) {
            Status = ERROR_CLUSTER_NODE_UP;
            LocalFree(CsJoinSponsorName);
            goto error_exit;
        }


        Status = JoinpAttemptJoin(CsJoinSponsorName, CsJoinSponsorBinding);

        RpcBindingFree(&CsJoinSponsorBinding);
        LocalFree(CsJoinSponsorName);
    }
    else {
        Status = ERROR_BAD_NETPATH;
        ClRtlLogPrint(LOG_CRITICAL, 
            "[JOIN] Unable to connect to any sponsor node.\n"
            );

        //
        // rajdas: If the join did not suceed due to version mismatch we shouldn't try to form a cluster.
        // Bug ID: 152229
        //
        if(CsJoinStatus == ERROR_CLUSTER_INCOMPATIBLE_VERSIONS)
            bFormCluster = FALSE;
    }


error_exit:
    if ( ClusterNameId ) {
        LocalFree( ClusterNameId );
    }

    if ( ClusterIpAddress ) {
        LocalFree( ClusterIpAddress );
    }

    if ( ClusIpAddrResource ) {
        LocalFree( ClusIpAddrResource );
    }

    if ( hClusNameResKey ) {
        DmCloseKey( hClusNameResKey );
    }

    if ( hClusIPAddrResKey ) {
        DmCloseKey( hClusIPAddrResKey );
    }

    return(Status);
}


VOID
JoinpEnumNodesAndJoinByAddress(
    IN HDMKEY  Key,
    IN PWSTR   NetInterfaceId,
    IN PVOID   Context
    )

/*++

Routine Description:

    Attempts to establish an RPC connection to a specified
    node using its IP address

Arguments:

    Key - pointer to the node key handle

    NetInterfaceId - pointer to string representing net IF ID (guid)

    Context - pointer to a location to return the final status

Return Value:

    None

--*/

{
    DWORD       status;
    LPWSTR      NetIFNodeID = NULL;
    LPWSTR      NetIFIpAddress = NULL;
    DWORD       idMaxSize = 0;
    DWORD       idSize = 0;


    //
    // get the NodeId Value from the NetIF key and if it's us,
    // skip this netIF
    //

    status = DmQuerySz(Key,
                       CLUSREG_NAME_NETIFACE_NODE,
                       &NetIFNodeID,
                       &idMaxSize,
                       &idSize);

    if ( status == ERROR_SUCCESS ) {

        if (lstrcmpiW(NetIFNodeID, NmLocalNodeIdString) != 0) {

            //
            // it's not us so get the address and try it...
            //

            idMaxSize = idSize = 0;
            status = DmQuerySz(Key,
                               CLUSREG_NAME_NETIFACE_ADDRESS,
                               &NetIFIpAddress,
                               &idMaxSize,
                               &idSize);

            if ( status != ERROR_SUCCESS ) {

                ClRtlLogPrint(LOG_CRITICAL,
                    "[JOIN] failed to get NetInterface Address, error %1!u!.\n",
                     status);
                goto error_exit;
            }

            //
            // attempt the join with this address
            //
            JoinpConnectToSponsor(NetIFIpAddress);
        }
    }
    else {
        ClRtlLogPrint(LOG_CRITICAL,
            "[JOIN] failed to get NetInterface Node ID, error %1!u!.\n",
             status);
    }

error_exit:
    DmCloseKey(Key);

    if ( NetIFNodeID ) {
        LocalFree( NetIFNodeID );
    }

    if ( NetIFIpAddress ) {
        LocalFree( NetIFIpAddress );
    }

    return;
}


VOID
JoinpEnumNodesAndJoinByHostName(
    IN HDMKEY  Key,
    IN PWSTR   NodeId,
    IN PVOID   Context
    )

/*++

Routine Description:

    Attempts to establish an RPC connection to a specified node using
    its host name

Arguments:

    Key - pointer to the node key handle

    NodeId - pointer to string representing node ID (number)

    Context - pointer to a location to return the final status

Return Value:

    None

--*/

{
    DWORD       status;
    LPWSTR      nodeName=NULL;
    DWORD       nodeNameLen=0;
    DWORD       nodeNameSize=0;

    //
    // Try to connect if this is not us
    //
    if (lstrcmpiW(NodeId, NmLocalNodeIdString) != 0) {

        status = DmQuerySz(Key,
                           CLUSREG_NAME_NODE_NAME,
                           &nodeName,
                           &nodeNameLen,
                           &nodeNameSize);

        if (status == ERROR_SUCCESS) {

            JoinpConnectToSponsor(nodeName);
            LocalFree(nodeName);
        }
    }

    DmCloseKey(Key);

    return;
}


VOID
JoinpConnectToSponsor(
    IN PWSTR   SponsorName
    )
/*++

Routine Description:

    Attempts to establish an RPC connection to a specified node.

Arguments:

    SponsorName - The name (or IP address) of the target sponsor.

Return Value:

    ERROR_SUCCESS if an RPC connection is successfully made to the sponsor.
    An RPC error code otherwise.

--*/

{
    HANDLE                  threadHandle;
    DWORD                   status = ERROR_SUCCESS;
    DWORD                   threadId;
    LPWSTR                  name;
    BOOL                    setEvent = FALSE;


    ClRtlLogPrint(LOG_UNUSUAL, 
       "[JOIN] Spawning thread to connect to sponsor %1!ws!\n",
        SponsorName
        );

    name = LocalAlloc( LMEM_FIXED, (lstrlenW(SponsorName) + 1 ) * sizeof(WCHAR) );

    if (name != NULL) {
        lstrcpyW(name, SponsorName);

        CsJoinThreadCount++;

        threadHandle = CreateThread(
                           NULL,
                           0,
                           JoinpConnectThread,
                           name,
                           0,
                           &threadId
                           );

        if (threadHandle != NULL) {
            CloseHandle(threadHandle);
        }
        else {
            status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL, 
                "[JOIN] Failed to spawn connect thread, error %1!u!.\n",
                status
                );

            --CsJoinThreadCount;
        }
    }
    else {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[JOIN] Failed to allocate memory.\n"
            );
    }

    return;

}  // JoinpConnectToSponsor


DWORD WINAPI
VerifyJoinVersionData(
    LPWSTR  sponsorName
    )

/*++

Routine Description:

    Verify that the sponsor and the joiner are compatible

Arguments:

    sponsorName - pointer to text string of sponsor to use

Return Value:

    ERROR_SUCCESS - if ok to continue join

--*/

{
    DWORD                   status;
    LPWSTR                  bindingString = NULL;
    RPC_BINDING_HANDLE      bindingHandle = NULL;
    DWORD                   SponsorNodeId;
    DWORD                   ClusterHighestVersion;
    DWORD                   ClusterLowestVersion;
    DWORD                   JoinStatus;
    DWORD                   packageIndex;

    //
    // Attempt to connect to the sponsor's JoinVersion RPC interface.
    //
    status = RpcStringBindingComposeW(
                 L"6e17aaa0-1a47-11d1-98bd-0000f875292e",
                 L"ncadg_ip_udp",
                 sponsorName,
                 NULL,
                 NULL,
                 &bindingString);

    if (status != RPC_S_OK) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[JOIN] Unable to compose JoinVersion string binding for sponsor %1!ws!, status %2!u!.\n",
            sponsorName,
            status
            );
        goto error_exit;
    }

    status = RpcBindingFromStringBindingW(bindingString, &bindingHandle);

    RpcStringFreeW(&bindingString);

    if (status != RPC_S_OK) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[JOIN] Unable to build JoinVersion binding for sponsor %1!ws!, status %2!u!.\n",
            sponsorName,
            status
            );
        goto error_exit;
    }

    //
    // under load, the sponsor might take a while to respond back to the
    // joiner. The default timeout is at 30 secs and this seems to work
    // ok. Note that this means the sponsor has 30 secs to reply to either
    // the RPC request or ping. As long it makes any reply, then the joiner's
    // RPC will continue to wait and not time out the sponsor.
    //

    status = RpcMgmtSetComTimeout( bindingHandle, CLUSTER_JOINVERSION_RPC_COM_TIMEOUT );

    if (status != RPC_S_OK) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[JOIN] Unable to set JoinVersion com timeout for sponsor %1!ws!, status %2!u!.\n",
            sponsorName,
            status
            );
    }

    status = RpcEpResolveBinding(bindingHandle, JoinVersion_v2_0_c_ifspec);

    if (status != RPC_S_OK) {
        if ( (status == RPC_S_SERVER_UNAVAILABLE) ||
             (status == RPC_S_NOT_LISTENING) ||
             (status == EPT_S_NOT_REGISTERED)
           )
        {
            ClRtlLogPrint(LOG_NOISE, 
                "[JOIN] Sponsor %1!ws! is not available (JoinVersion), status=%2!u!.\n",
                sponsorName,
                status
                );
        }
        else {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[JOIN] Unable to resolve JoinVersion endpoint for sponsor %1!ws!, status %2!u!.\n",
                sponsorName,
                status
                );
        }
        goto error_exit;
    }

    if ( CsUseAuthenticatedRPC ) {
        //
        // run through the list of RPC security packages, trying to establish
        // a security context with this binding.
        //

        for (packageIndex = 0;
             packageIndex < CsNumberOfRPCSecurityPackages;
             ++packageIndex )
        {
            status = RpcBindingSetAuthInfoW(bindingHandle,
                                            CsServiceDomainAccount,
                                            RPC_C_AUTHN_LEVEL_CONNECT,
                                            CsRPCSecurityPackage[ packageIndex ],
                                            NULL,
                                            RPC_C_AUTHZ_NAME);

            if (status != RPC_S_OK) {
                ClRtlLogPrint(LOG_UNUSUAL,
                           "[JOIN] Unable to set JoinVersion AuthInfo using %1!ws! package, status %2!u!.\n",
                            CsRPCSecurityPackageName[packageIndex],
                            status);
                continue;
            }

            status = CsRpcGetJoinVersionData(bindingHandle,
                                             NmLocalNodeId,
                                             CsMyHighestVersion,
                                             CsMyLowestVersion,
                                             &SponsorNodeId,
                                             &ClusterHighestVersion,
                                             &ClusterLowestVersion,
                                             &JoinStatus);

            if ( status == RPC_S_OK ) {
                break;
            } else {
                ClRtlLogPrint(LOG_UNUSUAL,
                           "[JOIN] Unable to get join version data from sponsor %1!ws! using %2!ws! package, status %3!u!.\n",
                            sponsorName,
                            CsRPCSecurityPackageName[packageIndex],
                            status);
            }
        }
    } else {

        //
        // get the version data from the sponsor and determine if we
        // should continue to join
        //

        status = CsRpcGetJoinVersionData(bindingHandle,
                                         NmLocalNodeId,
                                         CsMyHighestVersion,
                                         CsMyLowestVersion,
                                         &SponsorNodeId,
                                         &ClusterHighestVersion,
                                         &ClusterLowestVersion,
                                         &JoinStatus);

        if ( status != RPC_S_OK ) {
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[JOIN] Unable to get join version data from sponsor %1!ws!, status %2!u!.\n",
                        sponsorName,
                        status);
        }
    }

    //
    // jump out now if nothing work (as in the case of a form)
    //
    if ( status != ERROR_SUCCESS ) {
        goto error_exit;
    }

    //
    // use the join lock to set the RPC package index
    //
    EnterCriticalSection( &CsJoinLock );

    if ( CsRPCSecurityPackageIndex < 0 ) {
        CsRPCSecurityPackageIndex = packageIndex;
    }

    LeaveCriticalSection( &CsJoinLock );

    //
    // check the sponsor was in agreement with the join
    //
    if ( JoinStatus != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[JOIN]  Sponsor %1!ws! has discontinued join, status %2!u!.\n",
            sponsorName,
            JoinStatus);
        if (JoinStatus == ERROR_CLUSTER_INCOMPATIBLE_VERSIONS)
        {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[JOIN] Join version data from sponsor %1!ws! doesn't match: JH: 0x%2!08X! JL: 0x%3!08X! SH: 0x%4!08X! SL: 0x%5!08X!.\n",
                sponsorName,
                CsMyHighestVersion,
                CsMyLowestVersion,
                ClusterHighestVersion,
                ClusterLowestVersion);
            //
            // rajdas: In this case I have managed to contact a sponsor, but there is a version mismatch. If all the join
            // threads meet the same fate, clussvc should not try to form a cluster.
            // BUG ID: 152229
            //
            CsJoinStatus = ERROR_CLUSTER_INCOMPATIBLE_VERSIONS;
                
        }
        goto error_exit;
    }

    // SS: we will leave this check because win2K clusters didnt do the 
    // server side check, so the client must continue to do it
    //
    // now check that it is ok to join. We want this node to run
    // at the highest level of compatibility possible. One of the
    // following conditions must be true:
    //
    // 1) the High versions match exactly (major and build number)
    // 2) our Highest matches the sponsor's Lowest exactly, downgrading
    //    the sponsor to our level of compatibility
    // 3) our Lowest matches the sponsor's Highest, downgrading ourselves
    //    to the sponsor's level of compatibility
    //
    // note that the minor (build) version must match as well. The previous
    // version numbers are "well known" and shouldn't change when a newer
    // version is available/implemented.
    //

    if ( CsMyHighestVersion == ClusterHighestVersion ||
         CsMyHighestVersion == ClusterLowestVersion  ||
         CsMyLowestVersion == ClusterHighestVersion
#if 1 // CLUSTER_BETA
         || CsNoVersionCheck
#endif
         )
    {
        status = ERROR_SUCCESS;

    } else {

        ClRtlLogPrint(LOG_CRITICAL, 
            "[JOIN] Join version data from sponsor %1!ws! doesn't match: JH: 0x%2!08X! JL: 0x%3!08X! SH: 0x%4!08X! SL: 0x%5!08X!.\n",
            sponsorName,
            CsMyHighestVersion,
            CsMyLowestVersion,
            ClusterHighestVersion,
            ClusterLowestVersion);

        status = ERROR_CLUSTER_INCOMPATIBLE_VERSIONS;

        //
        // rajdas: In this case I have managed to contact a sponsor, but there is a version mismatch. If all the join
        // threads meet the same fate, clussvc should not try to form a cluster.
        // BUG ID: 152229
        //
        CsJoinStatus = ERROR_CLUSTER_INCOMPATIBLE_VERSIONS;
    }

error_exit:
    if (bindingHandle != NULL) {
        RpcBindingFree(&bindingHandle);
    }

    return status;
}

DWORD WINAPI
JoinpConnectThread(
    LPVOID   Parameter
    )
{
    LPWSTR                  sponsorName = Parameter;
    DWORD                   status;
    LPWSTR                  bindingString = NULL;
    RPC_BINDING_HANDLE      bindingHandle = NULL;
    BOOL                    setEvent = FALSE;

    //
    // Try to connect to the specified node.
    //
    ClRtlLogPrint(LOG_UNUSUAL, 
       "[JOIN] Asking %1!ws! to sponsor us.\n",
        sponsorName
        );

    //
    // connect to the JoinVersion interface first to see if we should progress
    // any further. since this is the first RPC call to the other node, we can
    // determine which security package should be used for the other interfaces.
    //

    status = VerifyJoinVersionData( sponsorName );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[JOIN] JoinVersion data for sponsor %1!ws! is invalid, status %2!u!.\n",
            sponsorName,
            status
            );
        goto error_exit;
    }

    //
    // Attempt to connect to the sponsor's extrocluster (join) RPC interface.
    //
    status = RpcStringBindingComposeW(
                 L"ffe561b8-bf15-11cf-8c5e-08002bb49649",
                 L"ncadg_ip_udp",
                 sponsorName,
                 NULL,
                 NULL,
                 &bindingString);

    if (status != RPC_S_OK) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[JOIN] Unable to compose ExtroCluster string binding for sponsor %1!ws!, status %2!u!.\n",
            sponsorName,
            status
            );
        goto error_exit;
    }

    status = RpcBindingFromStringBindingW(bindingString, &bindingHandle);

    RpcStringFreeW(&bindingString);

    if (status != RPC_S_OK) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[JOIN] Unable to build ExtroCluster binding for sponsor %1!ws!, status %2!u!.\n",
            sponsorName,
            status
            );
        goto error_exit;
    }

    //
    // under load, the sponsor might take a while to respond back to the
    // joiner. The default timeout is at 30 secs and this seems to work
    // ok. Note that this means the sponsor has 30 secs to reply to either
    // the RPC request or ping. As long it makes any reply, then the joiner's
    // RPC will continue to wait and not time out the sponsor.
    //

    status = RpcMgmtSetComTimeout( bindingHandle, CLUSTER_EXTROCLUSTER_RPC_COM_TIMEOUT );

    if (status != RPC_S_OK) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[JOIN] Unable to set ExtroCluster com timeout for sponsor %1!ws!, status %2!u!.\n",
            sponsorName,
            status
            );
    }

    status = RpcEpResolveBinding(bindingHandle, ExtroCluster_v2_0_c_ifspec);

    if (status != RPC_S_OK) {
        if ( (status == RPC_S_SERVER_UNAVAILABLE) ||
             (status == RPC_S_NOT_LISTENING) ||
             (status == EPT_S_NOT_REGISTERED)
           )
        {
            ClRtlLogPrint(LOG_NOISE, 
                "[JOIN] Sponsor %1!ws! is not available (ExtroCluster), status=%2!u!.\n",
                sponsorName,
                status
                );
        }
        else {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[JOIN] Unable to resolve ExtroCluster endpoint for sponsor %1!ws!, status %2!u!.\n",
                sponsorName,
                status
                );
        }
        goto error_exit;
    }

    if ( CsUseAuthenticatedRPC ) {

        //
        // establish a security context with this binding.
        //
        status = RpcBindingSetAuthInfoW(bindingHandle,
                                        CsServiceDomainAccount,
                                        RPC_C_AUTHN_LEVEL_CONNECT,
                                        CsRPCSecurityPackage[ CsRPCSecurityPackageIndex ],
                                        NULL,
                                        RPC_C_AUTHZ_NAME);

        if (status != RPC_S_OK) {
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[JOIN] Unable to set ExtroCluster AuthInfo using %1!ws! package, status %2!u!.\n",
                        CsRPCSecurityPackageName[ CsRPCSecurityPackageIndex ],
                        status);

            goto error_exit;
        }
    }

error_exit:

    EnterCriticalSection(&CsJoinLock);

    if (status == RPC_S_OK) {
        if (CsJoinSponsorBinding == NULL) {
            //
            // This is the first successful connection.
            //
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[JOIN] Selecting %1!ws! as join sponsor.\n",
                sponsorName
                );

            CsJoinSponsorBinding = bindingHandle;
            bindingHandle = NULL;
            CsJoinSponsorName = sponsorName;
            sponsorName = NULL;
            SetEvent(CsJoinEvent);
        }
        else {
            ClRtlLogPrint(LOG_NOISE, 
                "[JOIN] Closing connection to sponsor %1!ws!.\n",
                sponsorName
                );
        }
    }

    if (--CsJoinThreadCount == 0) {
        CloseHandle(CsJoinEvent);
        DeleteCriticalSection(&CsJoinLock);
    }
    else if (CsJoinThreadCount == 1) {
        SetEvent(CsJoinEvent);
        LeaveCriticalSection(&CsJoinLock);
    }
    else
        LeaveCriticalSection(&CsJoinLock);

    if (bindingHandle != NULL) {
        RpcBindingFree(&bindingHandle);
    }

    if (sponsorName != NULL) {
        LocalFree(sponsorName);
    }

    return(status);

}  // JoinpConnectThread



DWORD
JoinpAttemptJoin(
    LPWSTR               SponsorName,
    RPC_BINDING_HANDLE   JoinMasterBinding
    )
/*++

Routine Description:

    Called to attempt to join a cluster that already exists.

Arguments:

    SponsorName - The name (or IP address) of the target sponsor.

    JoinMasterBinding - RPC binding to use to perform join.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    NET_API_STATUS netStatus;
    LPTIME_OF_DAY_INFO tod = NULL;
    SYSTEMTIME systemTime;
    PNM_NETWORK network;
    DWORD startseq, endseq;


#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailNmJoinCluster) {
        Status = 999999;
        goto error_exit;
    }
#endif

    Status = NmJoinCluster(JoinMasterBinding);

    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[JOIN] NmJoinCluster failed, status %1!u!.\n",
                   Status
                   );
        goto error_exit;
    }

    //
    // Synchronize the registry database
    //
#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailDmJoin) {
        Status = 999999;
        goto error_exit;
    }
#endif

    Status = DmJoin(JoinMasterBinding, &startseq);

    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[JOIN] DmJoin failed, error %1!d!\n",
                   Status);
        goto error_exit;
    }



    //
    // Initialize the event handler, needs to register with gum for cluster wide
    //events.
    Status = EpInitPhase1();
    if ( Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[JOIN] EpInitPhase1 failed, Status = %1!u!\n",
                   Status);
        return(Status);
    }

#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailApiInitPhase1) {
        Status = 999999;
        goto error_exit;
    }
#endif

    //
    // Bring the API online in read-only mode. There is no join phase for
    // the API. The API is required by FmOnline, which starts the
    // resource monitor.
    //
    Status = ApiOnlineReadOnly();
    if ( Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[JOIN] ApiOnlineReadOnly failed, error = %1!u!\n",
            Status);
        goto error_exit;
    }

#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailFmJoinPhase1) {
        Status = 999999;
        goto error_exit;
    }
#endif

    //update status for scm
    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

    //
    // Resynchronize the FM. We cannot enable the Groups until after the
    // the API is fully operational. See below.
    //
    Status = FmJoinPhase1();
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[JOIN] FmJoinPhase1 failed, error %1!d!\n",
                   Status);
        goto error_exit;
    }

#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailDmUpdateJoinCluster) {
        Status = 999999;
        goto error_exit;
    }
#endif

    // Call the DM to hook the notifications for quorum resource and
    //event handler
    Status = DmUpdateJoinCluster();
    if (Status != ERROR_SUCCESS)
    {
            ClRtlLogPrint(LOG_CRITICAL,
            "[JOIN] DmUpdateJoin failed, error = %1!u!\n",
            Status);
            goto error_exit;
    }



#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailNmJoinComplete) {
        Status = 999999;
        goto error_exit;
    }
#endif

    //
    // We are now fully online, call NM to globally change our state.
    //
    Status = NmJoinComplete(&endseq);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[JOIN] NmJoinComplete failed, error %1!d!\n",
                   Status);
        goto error_exit;
    }

#if 0
//
// This check is flawed. Network state updates can occur during
// the join process, causing this check to fail unnecessarily.
//
    if (startseq + GUM_UPDATE_JOINSEQUENCE != endseq) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[JOIN] Sequence mismatch, start %1!d! end %2!d!\n",
                   startseq, endseq);
	Status = ERROR_CLUSTER_DATABASE_SEQMISMATCH;
        goto error_exit;
    }
#endif // 0

    //perform the fixup for the AdminExt value on both Nt4 and Nt5 nodes.
    Status=FmFixupAdminExt();
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[JOIN] FmFixupAdminExt failed, error %1!d!\n",
                   Status);
        goto error_exit;
    }


    //perform the fixups after the registry is downloaded
    //walk the list of fixups
    Status = NmPerformFixups(NM_JOIN_FIXUP);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[JOIN] NmPerformFixups failed, error %1!d!\n",
                   Status);
        goto error_exit;
    }

#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailApiInitPhase2) {
        Status = 999999;
        goto error_exit;
    }
#endif



    //
    // Finally enable the full API.
    //
    Status = ApiOnline();
    if ( Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[JOIN] ApiOnline failed, error = %1!u!\n",
            Status);
        goto error_exit;
    }

#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailFmJoinPhase2) {
        Status = 999999;
        goto error_exit;
    }
#endif

    //update status for scm
    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

    //
    // Call back the Failover Manager to enable and move groups.
    // The full registry is now available, so all groups/resources/resource
    // types can be created (since they use the registry calls).
    //
    Status = FmJoinPhase2();
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[JOIN] FmJoinPhase2 failed, status %1!d!.\n",
                   Status);
        goto error_exit;
    }


#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailEvInitialize) {
        Status = 999999;
        goto error_exit;
    }
#endif
    //
    // Finish initializing the cluster wide event logging
    //
    // ASSUMPTION: this is called after the NM has established cluster
    // membership.
    //
    if (!CsNoRepEvtLogging)
    {
        Status = EvOnline();
            //if this fails, we still start the cluster service
        if ( Status != ERROR_SUCCESS ) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[JOIN] Error calling EvOnline, Status = %1!u!\n",
                Status);
        }
    }

    return(ERROR_SUCCESS);


error_exit:

    ClRtlLogPrint(LOG_NOISE, "[INIT] Cleaning up failed join attempt.\n");

    ClusterLeave();

    return(Status);

}





BOOL
JoinpAddNodeCallback(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Object,
    IN LPCWSTR Name
    )
/*++

Routine Description:

    Callback enumeration routine for adding a new node. This callback
    figures out what node IDs are available.

Arguments:

    Context1 - Supplies a pointer to an array of BOOLs. The node ID for
        the enumerated node is set to FALSE.

    Context2 - Not used.

    Object - A pointer to the node object.

    Name - The node name.

Return Value:

     TRUE

--*/

{
    PBOOL Avail;
    DWORD Id;

    Id = NmGetNodeId(Object);
    CL_ASSERT(NmIsValidNodeId(Id));

    Avail = (PBOOL)Context1;

    Avail[Id] = FALSE;


    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\init\tstpoint.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tstpoint.c

Abstract:

    Implementation of cluster test points

Author:

    John Vert (jvert) 11/25/1996

Revision History:

--*/
#include "initp.h"

#ifdef CLUSTER_TESTPOINT

PTESTPOINT_ENTRY TestArray=NULL;
HANDLE           gTestPtFileMapping;

extern DWORD CsTestPoint;
extern DWORD CsTestTrigger;
extern DWORD CsTestAction;

TESTPOINT_NAME TestPointNames[TestpointMax]={
    L"JoinFailPetition",                  //0
    L"FailNmJoinCluster",                 //1
    L"FailRegisterIntraClusterRpc",       //2
    L"FailJoinCreateBindings",            //3
    L"FailJoinPetitionForMembership",     //4
    L"FailNmJoin",                        //5
    L"FailDmJoin",                        //6
    L"FailApiInitPhase1",                 //7
    L"FailFmJoinPhase1",                  //8
    L"FailDmUpdateJoinCluster",           //9
    L"FailEvInitialize",                  //10
    L"FailNmJoinComplete",                //11
    L"FailApiInitPhase2",                 //12
    L"FailFmJoinPhase2",                  //13
    L"FailLogCommitSize",                 //14
    L"FailClusterShutdown",               //15
    L"FailLocalXsaction",                 //16
    L"FailOnlineResource",                //17
    L"FailSecurityInit",                  //18
    L"FailOmInit",                        //19
    L"FailEpInit",                        //20
    L"FailDmInit",                        //21
    L"FailNmInit",                        //22
    L"FailGumInit",                       //23
    L"FailFmInit",                        //24
    L"FailLmInit",                        //25
    L"FailCpInit",                        //26
    L"FailNmPauseNode",                   //27
    L"FailNmResumeNode",                  //28
    L"FailNmEvictNodeAbort",              //29
    L"FailNmEvictNodeHalt",               //30
    L"FailNmCreateNetwork",               //31
    L"FailNmSetNetworkPriorityOrder",     //32
    L"FailNmSetNetworkPriorityOrder2",    //33
    L"FailNmSetNetworkCommonProperties",  //34
    L"FailNmSetInterfaceInfoAbort",       //35
    L"FailNmSetInterfaceInfoHalt",        //36
    L"FailPreMoveWithNodeDown",           //37
    L"FailPostMoveWithNodeDown",          //38
    L"FailFormNewCluster"                 //39
};


VOID
TestpointInit(
    VOID
    )
/*++

Routine Description:

    Initializes the testpoint code.

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD ArraySize;
    DWORD i;

    //
    // Create the array of testpoint entries in named shared memory.
    //
    ArraySize = sizeof(TESTPOINT_ENTRY)*TestpointMax;
    gTestPtFileMapping = CreateFileMapping((HANDLE)-1,
                                    NULL,
                                    PAGE_READWRITE,
                                    0,
                                    ArraySize,
                                    L"Cluster_Testpoints");
    if (gTestPtFileMapping == NULL) {
        CL_UNEXPECTED_ERROR( GetLastError() );
        return;
    }

    TestArray = MapViewOfFile(gTestPtFileMapping,
                              FILE_MAP_READ | FILE_MAP_WRITE,
                              0,0,
                              ArraySize);
    if (TestArray == NULL) {
        CL_UNEXPECTED_ERROR( GetLastError() );
        return;
    }

    //
    // Initialize test point array
    //
    for (i=0; i<TestpointMax; i++) {
        lstrcpyW(TestArray[i].TestPointName,TestPointNames[i]);
        if ( i == CsTestPoint ) {
            TestArray[i].Trigger = CsTestTrigger;
            TestArray[i].Action = CsTestAction;
        } else {
            TestArray[i].Trigger = TestTriggerNever;
            TestArray[i].Action = TestActionTrue;
        }
        TestArray[i].HitCount = 0;
        TestArray[i].TargetCount = 0;
    }

    return;
}

void TestpointDeInit()
{

    if (TestArray) UnmapViewOfFile(TestArray);
    if (gTestPtFileMapping) CloseHandle(gTestPtFileMapping);
    return;
}



BOOL
TestpointCheck(
    IN TESTPOINT Testpoint
    )
/*++

Routine Description:

    Checks a testpoint to see if it should fire.

Arguments:

    Testpoint - Supplies the testpoint number.

Return Value:

    TRUE if the testpoint has fired.

    FALSE otherwise

--*/

{
    PTESTPOINT_ENTRY Entry;

    if (TestArray == NULL) {
        return(FALSE);
    }
    Entry = &TestArray[Testpoint];
    Entry->HitCount += 1;

    switch (Entry->Trigger) {
        case TestTriggerNever:
            return(FALSE);

        case TestTriggerAlways:
            break;

        case TestTriggerOnce:
            Entry->Trigger = TestTriggerNever;
            break;

        case TestTriggerTargetCount:
            if (Entry->HitCount == Entry->TargetCount) {
                Entry->HitCount = 0;
                break;
            } else {
                return(FALSE);
            }

        default:
            CL_UNEXPECTED_ERROR( Entry->Trigger );

    }

    CsDbgPrint(LOG_CRITICAL,
               "[TP] Testpoint %1!ws! being executed.\n",
               TestPointNames[Testpoint] );

    //
    // The testpoint has fired, figure out what we are supposed to do.
    //
    switch (Entry->Action) {
        case TestActionTrue:
            return(TRUE);
        case TestActionExit:
            ExitProcess(Testpoint);
            break;

        case TestActionDebugBreak:
            DebugBreak();
            break;

    }
    return(FALSE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\lm\lmmgmt.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    lmmgmt.c

Abstract:

    Provides the maintenance functions for the log manager.

Author:

    Sunita Shrivastava (sunitas) 10-Nov-1995

Revision History:

--*/
#include "service.h"
#include "lmp.h"



/****
@doc	EXTERNAL INTERFACES CLUSSVC LM
****/



/****
@func	 	DWORD | LmInitialize| It initializes structures for log file
			management and creates a timer thread to process timer activities.

@rdesc 		ERROR_SUCCESS if successful. Win32 error code if something horrible happened.

@comm		This function is called when the cluster components are initialized.

@xref		<f LmShutdown> <f ClTimerThread>
****/
DWORD
LmInitialize()
{
	DWORD dwError = ERROR_SUCCESS;
	DWORD dwThreadId;
	
	//we need to create a thread to general log management
	//later this may be used by other clussvc client components
	ClRtlLogPrint(LOG_NOISE,
		"[LM] LmInitialize Entry. \r\n");

    if ((dwError = TimerActInitialize()) != ERROR_SUCCESS)
    {
        goto FnExit;
    }
	

	
FnExit:
	return(dwError);
}


/****
@func	 	DWORD | LmShutdown | Deinitializes the Log manager.

@rdesc 		ERROR_SUCCESS if successful. Win32 error code if something horrible happened.

@comm		This function notifies the timer thread to shutdown down and closes
			all resources associated with timer activity management.
@xref		<f LmInitialize>
****/
DWORD
LmShutdown(
    )
{

    ClRtlLogPrint(LOG_NOISE,
    	"[LM] LmShutDown : Entry \r\n");

    TimerActShutdown();
    

	ClRtlLogPrint(LOG_NOISE,
    	"[LM] LmShutDown : Exit\r\n");

	//clean up the activity structure
    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\lm\dmplog.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dmplog.c

Abstract:

    Test app for the cluster registry logging component

    Dumps out a log file

Author:

    John Vert (jvert) 15-Dec-1995


Revision History:

--*/
#include "windows.h"
#include "lmp.h"
#include "stdio.h"
#include "stdlib.h"

#define CsLogModule     0xffff

HLOG MyLog;
LPWSTR LogName = L"c:\\TLOG.LOG";

BOOL WINAPI ScanCb (
    IN PVOID Context,
    IN RMID RmId,
    IN TRID Trid,
    IN const PVOID Buffer,
    IN DWORD DataSize
    );

int __cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    LSN CurrentLsn;
    LSN NextLsn;
    DWORD Status;
    DWORD i,j;
    PDWORD Buffer;
    RMID RmId;
    RMTYPE RmType;
    DWORD DataSize;
    TRID Trid;
    LSN LastLsn;

    MyLog = LogCreate(LogName, 0, NULL, NULL, &LastLsn);
    if (MyLog == INVALID_HANDLE_VALUE) {
        fprintf(stderr, "DMPLOG: LogCreate failed %d\n",GetLastError());
        return(0);
    }

    if (LastLsn == NULL_LSN) {
        fprintf(stderr, "DMPLOG: Log file did not exist\n",LastLsn);
        return(0);
    }

    Buffer = malloc(1000 * sizeof(DWORD));
    if (Buffer == NULL) {
        fprintf(stderr, "DMPLOG: couldn't allocate buffer\n");
        return(0);
    }

        if (argc == 1)
        {
                //read all the records
        CurrentLsn = NULL_LSN;
        do {
                DataSize = 1000 * sizeof(DWORD);
                NextLsn = LogRead(MyLog,
                                CurrentLsn,
                                &RmId,
                                &RmType,
                                &Trid,
                                &TrType,
                                Buffer,
                                &DataSize);
                if (NextLsn != NULL_LSN) {
                printf("LSN %08lx: RMID %d \tTRID %d size: %d",
                        CurrentLsn,
                        RmId,
                        Trid,
                        DataSize);
                for (i=0; i<DataSize/sizeof(DWORD); i++) {
                        if ((i % 4) == 0) {
                        printf("\n\t");
                        }
                        printf("%08lx ",Buffer[i]);
                }
                printf("\n");
                } else {
                printf("END OF LOG\n");
                }


                CurrentLsn = NextLsn;
        } while ( CurrentLsn != NULL_LSN );
        }
        else
        {
                CurrentLsn = atoi(argv[1]);
                //scan the records from the lsn specified
                if (LogScan(MyLog, CurrentLsn, TRUE, (PLOG_SCAN_CALLBACK)ScanCb, NULL) != ERROR_SUCCESS)
                        printf("LogScan returned error\r\n");

        }

    Status = LogClose(MyLog);
    if (Status != ERROR_SUCCESS) {
        fprintf(stderr, "DMPLOG: LogClose failed %d\n",Status);
        return(0);
    }

}



BOOL WINAPI ScanCb (
    IN PVOID Context,
    IN RMID RmId,
    IN TRID Trid,
    IN const PVOID Buffer,
    IN DWORD DataSize
    )
{
        int     i;
        PDWORD  pData=Buffer;

        if (!pData)
        {
                printf("Error - scancb got a null buffer\r\n");
        }
    printf("LSN %08lx: RMID %d \tTRID %d size: %d",
        (LSN)(*pData),
        RmId,
        Trid,
        DataSize);
    for (i=0; i<(int)(DataSize/sizeof(DWORD)); i++) {
        if ((i % 4) == 0) {
            printf("\n\t");
        }
        printf("%08lx ",pData[i]);
    }
    printf("\n");
        return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\lm\lmp.h ===
#ifndef _LMP_H
#define _LMP_H

/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    lmp.h

Abstract:

    Private header file for quorum logging

Author:

    John Vert (jvert) 15-Dec-1995

Revision History:

--*/
#include "windows.h"
#include "service.h"
#include "imagehlp.h"

#define LOG_CURRENT_MODULE LOG_MODULE_LM

//
// Definitions for the behavior of the logger
//
#define MAXNUMPAGES_PER_RECORD      16
#define GROWTH_CHUNK (MAXNUMPAGES_PER_RECORD * 2 * 1024)                 // size to grow file by when we need to reserve space
#define SECTOR_SIZE             1024
#define LOG_MANAGE_INTERVAL     (2 * 60 * 1000) //1 minute..log management functions are performed
//
// Definitions of on-disk structures. The first sector of a log
// file is a LOG_HEADER structure, followed by a sequence of LOGPAGE structures.
// Each LOGPAGE is a size that is a multiple of the sector
// size of the drive. Each LOGPAGE contains a series of LOG_RECORDs, which
// contain the data logged by the client.
//

//
// Define log structure
//
#define LOG_HEADER_SIG 'GOLC'            // "CLOG"
#define LOG_SIG         'GOLH'               // "HLOG"
#define LOGREC_SIG      'SAQS'                          // "random"
#define XSACTION_SIG    'CASX'          // "XSAC"
#define CHKSUM_SIG      L"SKHC"         // "CHKS"          


//SS:size of logrecord is 48 bytes
typedef struct _LOGRECORD {
    DWORD               Signature;      //we need the signature to validate the record
    LSN                 CurrentLsn;
    LSN                 PreviousLsn;
    DWORD               RecordSize;
    RMID                ResourceManager;
    TRID                Transaction;
    TRTYPE              XsactionType;
    DWORD               Flags;
    FILETIME            Timestamp;
    DWORD               NumPages; // set to 1 if not a large record, else set to the number of pages required by the large record.
    DWORD               DataSize;   //date size
    BYTE                Data[];
} LOGRECORD, *PLOGRECORD;

typedef struct _LOGPAGE {
    DWORD       Offset;
    DWORD       Size;
    LOGRECORD   FirstRecord;
} LOGPAGE, *PLOGPAGE;

//
// LOG_HEADER structure is the first 512 bytes of every log
// file. The structure below is carefully computed to be 512
// bytes long.
//
typedef struct _LOG_HEADER {
    DWORD       Signature;                                    // LOG_HEADER_SIG = "CLOG"
    DWORD       HeaderSize;
    FILETIME    CreateTime;
    LSN         LastChkPtLsn;  //points to the lsn of the endchkpt record of the last lsn
    WCHAR       FileName[256-(sizeof(DWORD)*2+sizeof(LSN)+sizeof(FILETIME))];
} LOG_HEADER, *PLOG_HEADER;

typedef struct _LOG_CHKPTINFO{
    WCHAR       szFileName[LOG_MAX_FILENAME_LENGTH];
    LSN         ChkPtBeginLsn; //points to the lsn of the begin chkptrecord for this chkpt.
    DWORD       dwCheckSum;    //checksum for the checkpoint file
}LOG_CHKPTINFO,*PLOG_CHKPTINFO;

//
// Define in-memory structure used to contain current log data
// The HLOG returned to callers by LogCreate is actually a pointer
// to this structure.
//

typedef struct _LOG {
    DWORD       LogSig;                       // "HLOG"
    LPWSTR      FileName;
    HANDLE      FileHandle;
    DWORD       SectorSize;
    PLOGPAGE    ActivePage;
    LSN         NextLsn;
    LSN         FlushedLsn;
    DWORD       FileSize;                     // physical size of file
    DWORD       FileAlloc;                    // total filespace used (always <= FileSize)
    DWORD		MaxFileSize;
    PLOG_GETCHECKPOINT_CALLBACK			pfnGetChkPtCb;
    PVOID		pGetChkPtContext;		//this is passed back to the checkpoint callback function.
    OVERLAPPED  Overlapped;              // use for overlapped I/O
    CRITICAL_SECTION Lock;
    HANDLE      hTimer;                 //timer for managing this lock
} LOG, *PLOG;


typedef struct _XSACTION{
    DWORD       XsactionSig;    //signature for this structure
    LSN         StartLsn;            //the LSN for the start xsaction record
    TRID        TrId;           //the transaction id for the LSN
    RMID        RmId;           //the id of the resource Manager
} XSACTION, *PXSACTION;    
    
//
// Define macros for creating and translating LSNs
//

//
// LSN
// MAKELSN(
//      IN PLOGPAGE Page,
//      IN PLOGRECORD Pointer
//      );
//
// Given a pointer to a page, and a pointer to a log record within that page, generates
// the LSN.
//
#define MAKELSN(Page,Pointer) (LSN)((Page)->Offset + ((ULONG_PTR)Pointer - (ULONG_PTR)Page))

//
// DWORD
// LSNTOPAGE(
//      IN LSN Lsn
//      );
//
// Given an LSN returns the page that contains it.
//
#define LSNTOPAGE(Lsn) ((Lsn) >> 10)

//
// GETLOG(
//      PLOG pLog,
//      HLOG hLog
//      );
//
// Translates an HLOG handle to a pointer to a LOG structure
//
#define GETLOG(plog, hlog) (plog) = (PLOG)(hlog); \
                           CL_ASSERT((plog)->LogSig == LOG_SIG)



// Given a pointer to a record, it fetches the LSN of the next or
// previous record
//
#define GETNEXTLSN(pLogRecord,ScanForward) ((ScanForward) ?     \
    (pLogRecord->CurrentLsn + pLogRecord->RecordSize) :         \
    (pLogRecord->PreviousLsn))


//
// GETXSACTION(
//      PXSACTION pXsaction,
//      HXSACTION hXsaction
//      );
//
// Translates an HLOG handle to a pointer to a LOG structure
//
#define GETXSACTION(pXsaction, hXsaction) (pXsaction) = (PXSACTION)(hXsaction); \
                           CL_ASSERT((pXsaction)->XsactionSig == XSACTION_SIG)


// given the header of the log file, check its validity.
//
#define ISVALIDHEADER(Header) ((Header).Signature == LOG_HEADER_SIG)

//
// Private helper macros
//

#define CrAlloc(size) LocalAlloc(LMEM_FIXED, (size))
#define CrFree(size)  LocalFree((size))

#define AlignAlloc(size) VirtualAlloc(NULL, (size), MEM_COMMIT, PAGE_READWRITE)
#define AlignFree(ptr) VirtualFree((ptr), 0, MEM_RELEASE)



//Timeractivity related stuff

#define MAX_TIMER_ACTIVITIES            5

#define TIMER_ACTIVITY_SHUTDOWN         1
#define TIMER_ACTIVITY_CHANGE           2

//state values for timer activity structure management
#define ACTIVITY_STATE_READY    1   //AddTimerActivity sets it to ready
#define ACTIVITY_STATE_DELETE   2   //RemoveTimerActivity sets it to delete
#define ACTIVITY_STATE_PAUSED   3   //PauseTimerActivity sets it to pause

typedef struct _TIMER_ACTIVITY {
    LIST_ENTRY          ListEntry;
    DWORD               dwState;
    HANDLE              hWaitableTimer;
    LARGE_INTEGER       Interval;
    PVOID               pContext;
    PFN_TIMER_CALLBACK  pfnTimerCb;
}TIMER_ACTIVITY, *PTIMER_ACTIVITY;

//
//  Extern variables
//
extern BOOL bLogExceedsMaxSzWarning;


//inline functions
_inline
DWORD
LSNOFFSETINPAGE(
    IN PLOGPAGE Page,
    IN LSN Lsn
    );

//_inline
DWORD
RECORDOFFSETINPAGE(
    IN PLOGPAGE Page,
    IN PLOGRECORD LogRecord
    );

//_inline
PLOGRECORD
LSNTORECORD(
     IN PLOGPAGE Page,
     IN LSN Lsn
     );

//
// Define function prototypes local to this module
//
PLOG
LogpCreate(
    IN LPWSTR lpFileName,
    IN DWORD  dwMaxFileSize,
    IN PLOG_GETCHECKPOINT_CALLBACK CallbackRoutine,
    IN PVOID  pGetChkPtContext,
    IN BOOL     bForceReset,
    OPTIONAL OUT LSN *LastLsn
    );

DWORD
LogpMountLog(
    IN PLOG Log
    );

DWORD
LogpInitLog(
    IN PLOG Log
    );

DWORD
LogpGrowLog(
    IN PLOG Log,
    IN DWORD GrowthSize
    );

PLOGPAGE
LogpAppendPage(
    IN PLOG         Log,
    IN DWORD        Size,
    OUT PLOGRECORD  *Record,
    OUT BOOL        *pbMaxFileSizeReached,
    OUT DWORD       *pdwNumPages
    );

DWORD
LogpRead(IN PLOG pLog,
    OUT PVOID       pBuf,
    IN DWORD        dwBytesToRead,
    OUT PDWORD      pdwBytesRead
    );

DWORD
LogpWrite(
    IN PLOG pLog,
    IN PVOID pData,
    IN DWORD dwBytesToWrite,
    IN DWORD *pdwBytesWritten);

void WINAPI
LogpManage(
    IN HANDLE   hTimer,
    IN PVOID    pContext);

DWORD
LogpWriteLargeRecordData(
    IN PLOG pLog,
    IN PLOGRECORD pLogRecord,
    IN PVOID pLogData,
    IN DWORD dwDataSize);

DWORD LogpCheckFileHeader(
    IN  PLOG        pLog,
    OUT LPDWORD     pdwHeaderSize,
    OUT FILETIME    *HeaderCreateTime,
    OUT LSN         *pChkPtLsn
    );

DWORD LogpValidateChkPoint(
    IN PLOG         pLog,
    IN LSN          ChkPtLsn,
    IN LSN          LastChkPtLsn
    );

DWORD LogpValidateLargeRecord(
    IN PLOG         pLog, 
    IN PLOGRECORD   pRecord, 
    OUT LSN         *pNextLsn
    ) ;

DWORD LogpInvalidatePrevRecord(
    IN PLOG         pLog, 
    IN PLOGRECORD   pRecord 
    );

DWORD LogpEnsureSize(
    IN PLOG     pLog, 
    IN DWORD    dwTotalSize,
    IN BOOL     bForce
    );

DWORD LogpReset(
    IN PLOG Log,
    IN LPCWSTR  lpszInChkPtFile
    );

VOID
LogpWriteWarningToEvtLog(
    IN DWORD dwWarningType,
    IN LPCWSTR  lpszLogFileName
    );


//timer activity functions
DWORD
TimerActInitialize(VOID);

DWORD
TimerActShutdown(VOID);

#endif //_LMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\lm\lmutils.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    lmutils.c
    
Abstract:

    Provides the utility functions used by the logger.
    
Author:

    Sunita Shrivastava (jvert) 30-Mar-1997

Revision History:

--*/
#include "service.h"
#include "lmp.h"

BOOL bLogExceedsMaxSzWarning = FALSE;

/****
@doc    EXTERNAL INTERFACES CLUSSVC LM
****/

//
// DWORD
// LSNOFFSETINPAGE(
//      IN PLOGPAGE Page,
//      IN LSN Lsn
//      );
//
// Given a pointer to a page and an LSN within that page, computes the offset into the
// page that the log record starts at.
//
_inline
DWORD
LSNOFFSETINPAGE(
    IN PLOGPAGE Page,
    IN LSN Lsn
    )
{
    DWORD Offset;

    Offset = (DWORD)(Lsn - Page->Offset);
    CL_ASSERT(Offset < Page->Size);
    return(Offset);
}


//
// PLOGRECORD
// LSNTORECORD(
//      IN PLOGPAGE Page,
//      IN LSN Lsn
//      );
//
// Given a pointer to a page and an LSN within that page, generates a pointer to the log record
//

//_inline
PLOGRECORD
LSNTORECORD(
     IN PLOGPAGE Page,
     IN LSN Lsn
     )
{
    CL_ASSERT(Lsn != NULL_LSN);
    return((PLOGRECORD)((ULONG_PTR)Page + LSNOFFSETINPAGE(Page,Lsn)));
}

//
// DWORD
// RECORDOFFSETINPAGE(
//      IN PLOGPAGE Page,
//      IN PLOGRECORD LogRecord
//      );
//
// Given a pointer to a page and a log record within that page, computes the offset into the
// page that the log record starts at.
//

//_inline
DWORD
RECORDOFFSETINPAGE(
    IN PLOGPAGE Page,
    IN PLOGRECORD LogRecord
    )
{
    DWORD Offset;

    Offset = (DWORD)((ULONG_PTR)(LogRecord) - (ULONG_PTR)Page);
    CL_ASSERT(Offset < Page->Size);
    return(Offset);
}


/****
@func       PLOG | LogpCreate| Internal entry point for LogCreate.Creates or opens a log file. If the file
            does not exist, it will be created. If the file already exists, and is
            a valid log file, it will be opened.

@parm       IN LPWSTR | lpFileName | Supplies the name of the log file to create or open.

@parm       IN DWORD | dwMaxFileSize | Supplies the maximum file size in bytes, must be
            greater than 8K and smaller than 4 gigabytes.  If the file is exceeds this
            size, the reset function will be called. If 0, the maximum log file size limit
            is set to the default maximum size.

@parm       IN PLOG_GETCHECKPOINT_CALLBACK | CallbackRoutine | The callback routine that
            will provide a checkpoint file and the transaction associated with that checkpoint
            file when LogCheckPoint() is called for this log file.  If this is NULL, then the checkpointing capabilities are
            not associated with the log file.

@parm       IN PVOID | pGetChkPtContext | Supplies an arbitrary context pointer, which will be
            passed to the CallbackRoutine.

@parm       IN BOOL | bForceReset | If true, this function creates an empty log file 
            if the log file doesnt exist or if it is corrupt.
            
@parm       LSN | *LastLsn | If present, Returns the last LSN written to the log file.
              (NULL_LSN if the log file was created)

@rdesc      Returns a pointer to a PLOG structure.  NUll in the case of an error.

@xref       <f LogCreate>
****/

PLOG
LogpCreate(
    IN LPWSTR lpFileName,
    IN DWORD  dwMaxFileSize,
    IN PLOG_GETCHECKPOINT_CALLBACK CallbackRoutine,
    IN PVOID  pGetChkPtContext,
    IN BOOL   bForceReset,
    OPTIONAL OUT LSN *LastLsn
    )
{
    //create a timer activity for this
    PLOG    pLog = NULL;
    LPWSTR  FileName = NULL;
    DWORD   Status;
    BOOL    Success;
    BOOL    FileExists;
    //
    // Capture the filename string
    //
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpCreate : Entry \r\n");

    if (dwMaxFileSize == 0) dwMaxFileSize = CLUSTER_QUORUM_DEFAULT_MAX_LOG_SIZE;

    //SS: we dont put a upper limit on the MaxFileSize that a user may choose.
    FileName = CrAlloc((lstrlenW(lpFileName) + 1) * sizeof(WCHAR));
    if (FileName == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        CL_LOGFAILURE(Status);
        goto ErrorExit;
    }
    lstrcpyW(FileName, lpFileName);

    //
    // Allocate the log file data structure
    //
    pLog = CrAlloc(sizeof(LOG));
    if (pLog == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        CL_LOGFAILURE(Status);
        goto ErrorExit;
    }
    pLog->FileHandle = INVALID_HANDLE_VALUE;
    pLog->Overlapped.hEvent = NULL;
    pLog->ActivePage = NULL;
    pLog->hTimer = NULL;
    pLog->FileName = FileName;
    pLog->LogSig = LOG_SIG;
    pLog->MaxFileSize = dwMaxFileSize;
    pLog->pfnGetChkPtCb = CallbackRoutine;
    pLog->pGetChkPtContext = pGetChkPtContext;
    InitializeCriticalSection(&pLog->Lock);

    ZeroMemory(&(pLog->Overlapped), sizeof(OVERLAPPED));
    //
    // Create the event used to synchronize our overlapped I/O.
    //
    pLog->Overlapped.hEvent = CreateEvent(NULL,
                                         TRUE,
                                         TRUE,
                                         NULL);
    if (pLog->Overlapped.hEvent == NULL) {
        Status = GetLastError();
        CL_LOGFAILURE(Status);
        goto ErrorExit;
    }


    //
    // Create the file
    //
    //SS: we want to create this file with write through since
    //we control the flushing of log pages to the log file
    pLog->FileHandle = CreateFileW(pLog->FileName,
                                  GENERIC_READ | GENERIC_WRITE,
                                  FILE_SHARE_READ,
    //                            0,
                                  NULL,
                                  OPEN_ALWAYS,
                                  FILE_FLAG_WRITE_THROUGH | FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED,
    //                            FILE_FLAG_WRITE_THROUGH | FILE_FLAG_OVERLAPPED,
    //                            0,
                                  NULL);
    if (pLog->FileHandle == INVALID_HANDLE_VALUE) {
        Status = GetLastError();
        CL_LOGFAILURE(Status);
        goto ErrorExit;
    }

    FileExists = (GetLastError() == ERROR_ALREADY_EXISTS);

    pLog->SectorSize = SECTOR_SIZE;

    if (FileExists)
    {
        //
        // Log already exists, open it up, validate it,
        // and set everything up so that we can read and
        // write the log records.
        //
        Status = LogpMountLog(pLog);
        if (Status != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[LM] LogCreate : LogpMountLog failed, Error=%1!u!\r\n",
                Status);
                
            //
            // Chittur Subbaraman (chitturs) - 12/4/1999
            //
            // Try and blow away the corrupt log and create a new one
            // if the bForceReset flag is TRUE, else exit with error 
            // status.
            //
            if (Status == ERROR_CLUSTERLOG_CORRUPT)
            {               
                if (!bForceReset)
                {
                    CL_LOGFAILURE(Status);
                    CL_LOGCLUSERROR1(LM_QUORUM_LOG_CORRUPT, pLog->FileName);
                    goto ErrorExit;
                }

                //truncate the file
                Status = SetFilePointer(pLog->FileHandle,
                                        0,
                                        NULL,
                                        FILE_BEGIN);
                if (Status == 0xFFFFFFFF) {
                    Status = GetLastError();
                    CL_LOGFAILURE(Status);
                    goto ErrorExit;
                }

                if (!SetEndOfFile(pLog->FileHandle)) {
                    Status = GetLastError();
                    CL_LOGFAILURE(Status);
                    goto ErrorExit;
                }
                //create a new one
                Status = LogpInitLog(pLog);
                *LastLsn = NULL_LSN;
            }
        }
        else
        {
            *LastLsn = pLog->NextLsn;
        }
    }
    else
    {
        //
        // Log has been created, write out header
        // page and set everything up for writing.
        //
        if (bForceReset)
        {
            Status = LogpInitLog(pLog);
            *LastLsn = NULL_LSN;
        }
        else
        {
            //
            //  The user has not allowed a reset. So, log a
            //  message to the event log and exit with error status.
            //
            Status = ERROR_CLUSTER_QUORUMLOG_NOT_FOUND;
            *LastLsn = NULL_LSN;
            CloseHandle(pLog->FileHandle);
            pLog->FileHandle = INVALID_HANDLE_VALUE;
            DeleteFileW(pLog->FileName);
            CL_LOGCLUSERROR1(LM_QUORUM_LOG_NOT_FOUND, pLog->FileName);
        }
    }

ErrorExit:

    if (Status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_NOISE,
            "[LM] LogpCreate : Exit Error=0x%1!08lx!\r\n",
            Status);
        if (FileName != NULL) {
            CrFree(FileName);
        }
        if (pLog != NULL) {
            DeleteCriticalSection(&pLog->Lock);
            if (pLog->FileHandle != INVALID_HANDLE_VALUE) {
                CloseHandle(pLog->FileHandle);
            }
            if (pLog->Overlapped.hEvent != NULL) {
                Success = CloseHandle(pLog->Overlapped.hEvent);
                CL_ASSERT(Success);
            }
            if (pLog->ActivePage !=NULL)
                AlignFree(pLog->ActivePage);
            CrFree(pLog);
        }
        SetLastError(Status);
        return(NULL);

    }
    else {
        ClRtlLogPrint(LOG_NOISE,
            "[LM] LogpCreate : Exit with success\r\n");
        return(pLog);
    }

}


/****
@func       DWORD | LogpManage | This is the callback registered to perform
            periodic management functions like flushing for quorum log files.

@parm       HLOG | hLog | Supplies the identifier of the log.

@rdesc      ERROR_SUCCESS if successful. Win32 error code if something horrible happened.

@xref       <f LogCreate>
****/
void WINAPI LogpManage(
    IN HANDLE hTimer, 
    IN PVOID pContext)
{

    HLOG    hLog;
    PLOG    pLog;

/*
    //avoid clutter in cluster log as this is called periodically
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpManage : Entry pContext=0x%1!08lx!\r\n",
        pContext);
*/

    //
    //LogpRaiseAlert();
    hLog = (HLOG)pContext;
    GETLOG(pLog, hLog);

    LogFlush(hLog, pLog->NextLsn);

/*
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpManage : Exit\r\n");
*/

}


/****
@func   DWORD | LogpEnsureSize | This ensures that there is space on
        the disk to commit a record of the given size.

@parm   IN HLOG | hLog | Supplies the identifier of the log.

@parm   IN DWORD |dwSize |  The size of the record.

@parm   IN BOOL |bForce |  If FALSE, the size is not committed if it
        exceeds the file size.  If TRUE, commit the size irrespective
        of the file size.

@comm   This function checks if the disk space for the given record is
        already committed.  If not, it tries to grow the file.  
        
        
@rdesc  ERROR_SUCCESS if successful in commiting disk space or Win32 
        error code if something horrible happened.

@xref   <f LogCommitSize>
****/
DWORD
LogpEnsureSize(
    IN PLOG         pLog,
    IN DWORD        dwSize,
    IN BOOL         bForce
    )
{
    PLOGPAGE    pPage;
    PLOGRECORD  pRecord;
    DWORD       Status=ERROR_SUCCESS;
    DWORD       dwNumPages;
    DWORD       dwNewSize;
    DWORD       dwError;
    //
    // Nobody should ever write less than one log record
    //
    CL_ASSERT(dwSize >= sizeof(LOGRECORD));
    dwNumPages = 0;   //typically zero for small records

    pPage = pLog->ActivePage;
    //
    // Nobody should ever write more than the page size until we
    // support dynamically sized pages.
    //
    if (dwSize > pPage->Size - (sizeof(LOGRECORD) + sizeof(LOGPAGE))) 
    {
        //this is a large record
        //calculate the total number of pages required 
        //sizeof(LOGPAGE) includes space for one record header
        //that will account for the eop written after a large record
        dwNumPages = (sizeof(LOGPAGE) + sizeof(LOGRECORD) + dwSize)/pPage->Size;
        if ((sizeof(LOGPAGE) + sizeof(LOGRECORD) + dwSize) % pPage->Size)
            dwNumPages += 1;
        ClRtlLogPrint(LOG_NOISE,
            "[LM] LogpEnsureSize : Large record Size=%1!u! dwNumPages=%2!u!\r\n",
            dwSize, dwNumPages);
        /*
        //SS: dont restrict record size here- if the registry takes it
        //make the best effort to log it 

        if (dwNumPages > MAXNUMPAGES_PER_RECORD)
        {
            Status = ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE;
            goto FnExit;
        } 
        */
    }

    pRecord = LSNTORECORD(pPage, pLog->NextLsn);

    //
    // There must always be enough space remaining in the page to write
    // an end-of-page log record.
    //
    CL_ASSERT((RECORDOFFSETINPAGE(pPage, pRecord) + sizeof(LOGRECORD)) <= pPage->Size);

    //
    // If there is not enough space in this page for the requested data and
    // the end-of-page log record, commit size for the new page.
    //
    if ((RECORDOFFSETINPAGE(pPage, pRecord) + dwSize + sizeof(LOGRECORD)) > pPage->Size) 
    {

        //make sure there is enough room in the disk for the new page
        //if there isnt grow the file.
        //if the file has reached its max ceiling, return error
        if (pLog->FileAlloc + ((dwNumPages+1) * pLog->SectorSize) > 
            pLog->FileSize) 
        {
            dwNewSize = pLog->FileSize + GROWTH_CHUNK;
            CL_ASSERT(dwNewSize > pLog->FileSize);         // bummer, log file is >4GB

            //check if the file can be grown, if not, may be a reset
            //is required
            // if the force flag is set, then allow the file
            // to grow the file beyond its max size
            if (dwNewSize > pLog->MaxFileSize && !bForce)
            {
                LogpWriteWarningToEvtLog(LM_LOG_EXCEEDS_MAXSIZE, pLog->FileName);
                Status = ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE;
                goto FnExit;
            }
            //
            // Grow the file.
            //

            dwError = SetFilePointer(pLog->FileHandle,
                                    dwNewSize,
                                    NULL,
                                    FILE_BEGIN);
            if (dwError == 0xFFFFFFFF) 
            {
                Status = GetLastError();
                CL_LOGFAILURE(Status);
                goto FnExit;
            }
            
            if (!SetEndOfFile(pLog->FileHandle)) 
            {
                Status = GetLastError();
                CL_LOGFAILURE(Status);
                goto FnExit;
            }
            pLog->FileSize += GROWTH_CHUNK;
 
        }

    }
    
FnExit:
    return(Status);

}


PLOGPAGE
LogpAppendPage(
    IN PLOG         Log,
    IN DWORD        Size,
    OUT PLOGRECORD  *Record,
    OUT BOOL        *pbMaxFileSizeReached,
    OUT DWORD       *pdwNumPages
    )

/*++

Routine Description:

    Finds the next available log record. If this is in the current
    log page, it is returned directly. If the requested size is too
    large for the remaining space in the current log page, the current
    log page is written to disk and a new log page allocated.

Arguments:

    Log - Supplies the log to be appended to

    Size - Supplies the total size in bytes of the log record to append

    Record - Returns a pointer to the log record.

    pbMaxFileSizeReached - if the maximum file size is reached, this is set to
            TRUE.

    pdwNumPages - number of partial or complete pages consumed by this record, if this
        is a large record.  Else it is set to zero.
    
Return Value:

    Returns a pointer to the current log page.

    NULL if something horrible happened.

--*/

{
    PLOGPAGE    pPage;
    PLOGRECORD  Last;
    PLOGRECORD  Current;
    DWORD       Status=ERROR_SUCCESS;
    BOOL        Success;
    DWORD       BytesWritten;
    LSN         LastLsn;
    PLOGPAGE    pRetPage=NULL;

    //
    // Nobody should ever write less than one log record
    //
    CL_ASSERT(Size >= sizeof(LOGRECORD));
    *pdwNumPages = 0;   //typically zero for small records
    *pbMaxFileSizeReached = FALSE;

    pPage = Log->ActivePage;
    //
    // Nobody should ever write more than the page size until we
    // support dynamically sized pages.
    //
    if (Size > pPage->Size - (sizeof(LOGRECORD) + sizeof(LOGPAGE))) 
    {
        //this is a large record
        //calculate the total number of pages required 
        //sizeof(LOGPAGE) includes space for one record header
        //that will account for the eop written after a large record
        *pdwNumPages = (sizeof(LOGPAGE) + sizeof(LOGRECORD) + Size)/pPage->Size;
        if ((sizeof(LOGPAGE) + sizeof(LOGRECORD) + Size) % pPage->Size)
            *pdwNumPages += 1;
        ClRtlLogPrint(LOG_NOISE,
            "[LM] LogpAppendPage : Large record Size=%1!u! dwNumPages=%2!u!\r\n",
            Size, *pdwNumPages);
        /*
        //SS: dont restrict record size here- if the registry takes it
        //make the best effort to log it 
        if (*pdwNumPages > MAXNUMPAGES_PER_RECORD)
        {
            Status = ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE;
            goto FnExit;
        } 
        */
    }

    Current = LSNTORECORD(pPage, Log->NextLsn);

    //
    // There must always be enough space remaining in the page to write
    // an end-of-page log record.
    //
    CL_ASSERT((RECORDOFFSETINPAGE(pPage, Current) + sizeof(LOGRECORD)) <= pPage->Size);

    //
    // If there is not enough space in this page for the requested data and
    // the end-of-page log record, write the end-of-page record, send the
    // page off to disk, and allocate a new page.
    //
    if ((RECORDOFFSETINPAGE(pPage, Current) + Size + sizeof(LOGRECORD)) > pPage->Size) {

        //
        // Create an end-of-page record
        //
        Current->Signature = LOGREC_SIG;
        Current->RecordSize = pPage->Size - RECORDOFFSETINPAGE(pPage, Current) + (sizeof(LOGPAGE)-sizeof(LOGRECORD));
        Current->ResourceManager = RMPageEnd;
        Current->Transaction = 0;                 
        Current->Flags = 0;
        GetSystemTimeAsFileTime(&Current->Timestamp);
        Current->NumPages = 0;
        //
        // PERFNOTE John Vert (jvert) 18-Dec-1995
        //      No reason this has to be synchronous, there is no commit
        //      necessary here. If we were smart, we would just post these
        //      writes and have them complete to a queue which would free
        //      up or recycle the memory.
        //

        ClRtlLogPrint(LOG_NOISE,
            "[LM] LogpAppendPage : Writing %1!u! bytes to disk at offset 0x%2!08lx!\r\n",
            pPage->Size, pPage->Offset);

        //
        // Write the current page to disk.
        //
        Log->Overlapped.Offset = pPage->Offset;
        Log->Overlapped.OffsetHigh = 0;
        Status = LogpWrite(Log, pPage, pPage->Size, &BytesWritten);
        if (Status != ERROR_SUCCESS)
        {
            CL_LOGFAILURE(Status);
            goto FnExit;

        }

        LastLsn = Current->CurrentLsn;
        //set the flushed LSN as the LSN of the last record that was committed
        Log->FlushedLsn = Log->NextLsn;
        Log->NextLsn = LastLsn + Current->RecordSize;

        //
        // Create new page
        //
        pPage->Offset += pPage->Size;             // voila, new page!
        Current = &pPage->FirstRecord;           // log record immediately following page header
        Current->PreviousLsn = LastLsn;
        Current->CurrentLsn = Log->NextLsn;

        //make sure there is enough room in the disk for the new page
        //if there isnt grow the file.
        //if the file has reached its max ceiling, pbMaxFileSizeReached is set to true
        //At this point, we try and reset the log file
        //SS:Note that if a log file max size is smaller than the number of pages
        //required to contain the record, then we will not be able to grow it
        //even after resetting it.  This means that that right will fail
        if ((Status = LogpGrowLog(Log, (*pdwNumPages+1) * Log->SectorSize)) != ERROR_SUCCESS)
        {
            if (Status == ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE)
                *pbMaxFileSizeReached = TRUE;
            goto FnExit;
        }
    }
    *Record = Current;
    
    //if the record is a large record but does not use the second last page
    //completely, extend it to fill the second last page completely and add the
    //size of the logpage so that offset+currentsize points to the eop record.
    if ((*pdwNumPages) && 
        ((Size + sizeof(LOGPAGE) - sizeof(LOGRECORD)) <= 
            ((*pdwNumPages - 1) * pPage->Size)))
    {
        CL_ASSERT(*pdwNumPages > 1);
        //large records always start on the beginning of the first page
        //the next lsn now points to the first record on the next page
        Size = pPage->Size * (*pdwNumPages - 1);
        ClRtlLogPrint(LOG_NOISE,
            "[LM] LogpAppendPage : the record fits in one page but not with an eop\r\n");
    }
    Current->RecordSize = Size;

    

    // Advance to next LSN 
    LastLsn = Current->CurrentLsn;
    Log->NextLsn = LastLsn + Current->RecordSize;
    
    //fill in its LSN header
    if (*pdwNumPages == 0)
    {
        //for a large record, logpWriteLargeRecord, will set the next
        //lsn
        Current = LSNTORECORD(pPage, Log->NextLsn);
        Current->PreviousLsn = LastLsn;
        Current->CurrentLsn = Log->NextLsn;
    }
    pRetPage = pPage;
FnExit:
    if (Status != ERROR_SUCCESS)
        SetLastError(Status);
    return(pRetPage);

}


DWORD
LogpInitLog(
    IN PLOG pLog
    )

/*++

Routine Description:

    Initializes a newly created log file.

Arguments:

    Log - Supplies the log to be created.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code if unsuccessful.

--*/

{
    PLOG_HEADER     Header=NULL;
    PLOGPAGE        pPage=NULL;
    PLOGRECORD      Record;
    LPWSTR          FileName;
    DWORD           NameLen;
    DWORD           MaxLen;
    DWORD           Status;
    DWORD           dwBytesWritten;

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpInitLog : Entry pLog=0x%1!08lx!\r\n",
        pLog);

    //
    // Grow the file to accomodate header and the first log page.
    //
    pLog->FileSize = pLog->FileAlloc = 0;
    Status = LogpGrowLog(pLog, 2 * pLog->SectorSize);
    if (Status != ERROR_SUCCESS)
    {
        goto FnExit;
    }

    //
    // Allocate and initialize log header.
    //
    Header = AlignAlloc(pLog->SectorSize);
    if (Header == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }
    Header->Signature = LOG_HEADER_SIG;
    Header->HeaderSize = pLog->SectorSize;
    Header->LastChkPtLsn = NULL_LSN;
    GetSystemTimeAsFileTime(&(Header->CreateTime));
    FileName = pLog->FileName;
    NameLen = lstrlenW(FileName);
    MaxLen = sizeof(Header->FileName) / sizeof(WCHAR) - 1;
    if (NameLen > MaxLen) {
        FileName += (NameLen - MaxLen);
    }
    lstrcpyW(Header->FileName,FileName);

    //
    // Write header to disk
    //
    pLog->Overlapped.Offset = 0;
    pLog->Overlapped.OffsetHigh = 0;

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpAppendPage : Writing %1!u! bytes to disk at offset 0x%2!08lx!\r\n",
        Header->HeaderSize, pLog->Overlapped.Offset);

    if ((Status = LogpWrite(pLog, Header, Header->HeaderSize, &dwBytesWritten))
        != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                "[LM] LogpInitLog: failed to write the file header, Error=0x%1!08lx!\r\n",
                Status);
        CL_LOGFAILURE(Status);
        goto FnExit;
    }

    //
    // Allocate and initialize next log page.
    //
    pPage = AlignAlloc(pLog->SectorSize);
    if (pPage == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }
    pLog->ActivePage = pPage;


    pPage->Offset = Header->HeaderSize;
    pPage->Size = pLog->SectorSize;

    Record = &pPage->FirstRecord;
    Record->PreviousLsn = NULL_LSN;
    Record->CurrentLsn = pLog->NextLsn = MAKELSN(pPage, Record);

    pLog->FlushedLsn = pLog->NextLsn;

#if DBG    
    {
        DWORD dwOldProtect;
        DWORD Status;
        BOOL VPWorked;

        VPWorked = VirtualProtect(pPage, pLog->SectorSize, PAGE_READONLY, & dwOldProtect);
        Status = GetLastError();
        CL_ASSERT( VPWorked );
    }        
#endif        

    ClRtlLogPrint(LOG_NOISE,
    "[LM] LogpInitLog : NextLsn=0x%1!08lx! FileAlloc=0x%2!08lx! ActivePageOffset=0x%3!08lx!\r\n",
        pLog->NextLsn, pLog->FileAlloc, pPage->Offset);

FnExit:
    if (Header) {
        AlignFree(Header);
    }
    return(Status);

}


/****
@func       DWORD | LogpMountLog| Mounts an existing log file. Reads the log
            header, verifies the log integrity, and sets up
            the LOG structure to support further operations.

@parm       IN PLOG | pLog | Supplies a pointer to the log structure.

@rdesc      Returns ERROR_SUCCESS if successful, else returns the error code.  If
            the log file doesnt look correct, it returns ERROR_LOG_CORRUPT.

@comm       This is called by LogCreate() to mount an existing log file.
            LogCreate() calls LogpInitLog(), if this function returns
            ERROR_CLUSTERLOG_CORRUPT.

@xref       <f LogCreate>
****/
DWORD
LogpMountLog(
    IN PLOG pLog
    )
{
    DWORD       dwError = ERROR_SUCCESS;
    DWORD       dwFileSizeHigh;
    PLOGRECORD  pRecord;
    PLOGPAGE    pPage;
    DWORD       Status;
    LSN         Lsn,PrevLsn;
    int         PageIndex, OldPageIndex;
    BOOL        bLastRecord;
    DWORD       dwBytesRead;
    TRID        OldTransaction;
    FILETIME    LastTimestamp;
    LSN         ChkPtLsn = NULL_LSN;    //the checkptlsn read from the header
    LSN         LastChkPtLsn = NULL_LSN; // the last checkptlsn record seen while validating

    
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpMountLog : Entry pLog=0x%1!08lx!\r\n",
        pLog);

    //check the size
    pLog->FileSize = GetFileSize(pLog->FileHandle, &dwFileSizeHigh);

    if ((pLog->FileSize == 0xFFFFFFFF) &&
        ((dwError = GetLastError()) != NO_ERROR))
    {
        CL_UNEXPECTED_ERROR(dwError);
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogpMountLog GetFileSize returned error=0x%1!08lx!\r\n",
            dwError);
        goto FnExit;

    }

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpMountLog::Quorumlog File size=0x%1!08lx!\r\n",
        pLog->FileSize);

    //dont let the file grow more than  4 gigabytes or the max limit
    if ((dwFileSizeHigh != 0 ) || (pLog->FileSize > pLog->MaxFileSize))
    {
        //set in the eventlog
        dwError = ERROR_CLUSTERLOG_CORRUPT;
        CL_LOGCLUSWARNING1(LM_LOG_CORRUPT, pLog->FileName);
        goto FnExit;
    }

    //if filesize is zero, the file exists but essentially needs to
    //be created, this is needed for reset functionality
    if (!pLog->FileSize)
    {
        dwError = LogpInitLog(pLog);
        goto FnExit;
    }

    //check if the file is atleast as big as one page.
    //assume a fixed sector size
    if (pLog->FileSize < pLog->SectorSize)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogpMountLog::file is smaller than log header, error=0x%1!08lx!\r\n",
            dwError);
        //set in the eventlog
        dwError = ERROR_CLUSTERLOG_CORRUPT;
        CL_LOGCLUSWARNING1(LM_LOG_CORRUPT, pLog->FileName);
        goto FnExit;
    }

    //allocate memore for the active page
    pPage = AlignAlloc(pLog->SectorSize);
    if (pPage == NULL)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        CL_LOGFAILURE(dwError);
        goto FnExit;
    }

    //validate the file header, returns the time stamp of the header
    dwError = LogpCheckFileHeader(pLog, &(pPage->Offset),&LastTimestamp, 
        &ChkPtLsn);
    if (dwError != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogpMountLog::LogpCheckFileHeader failed, error=0x%1!08lx!\r\n",
            dwError);
        goto FnExit;
    }

    //traverse the chain of records, to find the active page
    //find the next lsn while validating the records.
    //pPageOffset is set by LogpCheckFileHeader
    pPage->Size = pLog->SectorSize;
    pRecord = &pPage->FirstRecord;
    OldPageIndex = -1;
    OldTransaction = 0;
    bLastRecord = FALSE;
    Lsn = MAKELSN(pPage, pRecord);
    PrevLsn = NULL_LSN;
    
    while (!bLastRecord)
    {
        //
        // Translate LSN to a page number and offset within the page
        //
        PageIndex = LSNTOPAGE(Lsn);

        if (PageIndex != OldPageIndex)
        {
            //read the page
            (pLog->Overlapped).Offset = PageIndex * pLog->SectorSize;
            (pLog->Overlapped).OffsetHigh = 0;

            ClRtlLogPrint(LOG_NOISE,
                "[LM] LogpMountLog::reading %1!u! bytes at offset 0x%2!08lx!\r\n",
                pLog->SectorSize, PageIndex * pLog->SectorSize);

            dwError = LogpRead(pLog, pPage, pLog->SectorSize, &dwBytesRead);
            //if it is the last page, then set the new page as the active
            //page
            if (dwError)
            {
                if (dwError == ERROR_HANDLE_EOF)
                {

                    ClRtlLogPrint(LOG_NOISE,
                        "[LM] LogpMountLog::eof detected, extend this file,setting this page active\r\n");

                    //find the current allocated size,
                    //file alloc is currently at the end of the previous page
                    pLog->FileAlloc = PageIndex * pLog->SectorSize;
                    //extend the file to accomodate this page
                    Status = LogpGrowLog(pLog, pLog->SectorSize);
                    if (Status != ERROR_SUCCESS)
                    {
                        //set in the eventlog
                        dwError = ERROR_CLUSTERLOG_CORRUPT;
                        CL_LOGCLUSWARNING1(LM_LOG_CORRUPT,pLog->FileName);
                        goto FnExit;
                    }
                    //file alloc should now point to the end of the current page

                    //not fatal, set this page as current page
                    dwError = ERROR_SUCCESS;

                    pPage->Offset = (pLog->Overlapped).Offset;
                    pPage->Size = pLog->SectorSize;

                    //set the LSN to be the first LSN on this page.
                    pRecord = &pPage->FirstRecord;
                    pRecord->PreviousLsn = PrevLsn;
                    Lsn = pRecord->CurrentLsn = MAKELSN(pPage, pRecord);
                    bLastRecord = TRUE;
                    continue;
                }
                else
                    goto FnExit;
            }
            //the read may succeed and the page may have invalid data
            //since the last log writes may not be flushed
            if ((pPage->Offset != (pLog->Overlapped).Offset) ||
                (pPage->Size != pLog->SectorSize))
            {

                ClRtlLogPrint(LOG_NOISE,
                    "[LM] LogpMountLog::unflushed page detected, set as active\r\n");

                pPage->Offset = (pLog->Overlapped).Offset;
                pPage->Size = pLog->SectorSize;

                pRecord = &pPage->FirstRecord;
                pRecord->PreviousLsn = PrevLsn;
                Lsn = pRecord->CurrentLsn = MAKELSN(pPage, pRecord);
                bLastRecord = TRUE;
                continue;
            }
            //set the new page index to the old one
            OldPageIndex = PageIndex;

        }
        ClRtlLogPrint(LOG_NOISE,
            "[LM] LogpMountLog::checking LSN 0x%1!08lx!\r\n",
            Lsn);
        pRecord = LSNTORECORD(pPage, Lsn);

        //if the record is doesnt look valid then set the active
        //record and page as the current one
        if ((pRecord->Signature != LOGREC_SIG) || (pRecord->CurrentLsn != Lsn))
        {
            ClRtlLogPrint(LOG_NOISE,
                          "[LM] LogpMountLog: Reached last record, RecordLSN=0x%1!08lx!...\n",
                          pRecord->CurrentLsn);
            bLastRecord = TRUE;
            continue;
        }
        //if the new time stamp is smaller, then log a message
        if (CompareFileTime(&LastTimestamp, &(pRecord->Timestamp)) > 0)
        {
            //
            //  Chittur Subbaraman (chitturs) - 3/7/2001
            //
            //  Do not compare the timestamps for monotonic increase. Due to clocks between nodes
            //  not being as close in sync as they should be, we run into situation in which
            //  we stop mounting the log after a certain LSN. This leads the subsequent LogpValidateCheckpoint
            //  to believe that the log is corrupted when in fact it is just time-screwed.
            //
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[LM] LogpMountLog: Timestamp in log is not monotonically increasing, LastTS=0x%1!08lx!, NewTS=0x%2!08lx!\n",
                          LastTimestamp,
                          pRecord->Timestamp);
#if 0
            bLastRecord = TRUE;
            continue;
#endif
        }
        //if it is a log management record
        if (pRecord->ResourceManager < RMAny)
        {
            // This record is a logmanagement record
            // if it is an end checkpoint record, remember that just in case
            // the header doesnt indicate that
            if (pRecord->ResourceManager == RMEndChkPt)
                LastChkPtLsn = Lsn;

            // Adjust the LSN to the next one

            PrevLsn = Lsn;
            Lsn = GETNEXTLSN(pRecord, TRUE);
            LastTimestamp = pRecord->Timestamp;
            continue;
        }


        //SS : should we also validate transaction ids on write
        //check that the transaction id is greater
        if (pRecord->Transaction < OldTransaction)
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[LM] LogpMountLog: Current Xid less than last Xid, CurXid=0x%1!08lx!, LastXid=0x%2!08lx!...\n",
                          pRecord->Transaction,
                          OldTransaction);
            bLastRecord = TRUE;
            continue;
        }

        
        //save the current LSN,go the the next record if this is valid
        PrevLsn = Lsn;

        //if this is a large record, skip the eop on the last page
        //but look for an eop to ensure that the large record is valid
        //SS: Have checksums for phase 2
        if (pRecord->NumPages)
        {
            //if the record is not valid, then set this as the current
            //record
            if (LogpValidateLargeRecord(pLog, pRecord, &Lsn) != ERROR_SUCCESS)
            {
                ClRtlLogPrint(LOG_NOISE,
                    "[LM] LogpMountLog::Invalid large record at LSN 0x%1!08lx!\r\n",
                    Lsn);
                bLastRecord = TRUE;
                continue;
            }
            
            
        }
        else
        {
            Lsn = GETNEXTLSN(pRecord, TRUE);
        }
        //this is a valid record, if the transaction id is the same as the last id
        //invalidate the previous LSN
        //SS: local xsactions have the same id, 
        if ((pRecord->Transaction == OldTransaction) && 
            ((pRecord->XsactionType ==  TTCommitXsaction) || 
            (pRecord->XsactionType == TTCompleteXsaction)))
             LogpInvalidatePrevRecord(pLog, pRecord);

        //save the the old transaction id for completed or committed records
        //save the time stamp and the transaction id of the current record
        LastTimestamp = pRecord->Timestamp;
        if ((pRecord->XsactionType == TTCompleteXsaction) ||
            (pRecord->XsactionType == TTCommitXsaction))
            OldTransaction = pRecord->Transaction;
    }

    // set the active page and the next record
    pLog->NextLsn = Lsn;
    pLog->ActivePage = pPage;

      //set the file alloc size, to the end of the current page
    pLog->FileAlloc = pPage->Offset + pPage->Size;
    CL_ASSERT(pLog->FileAlloc <= pLog->FileSize);

    //make sure that the next lsn is prepared
    pRecord = LSNTORECORD(pPage, Lsn);
    pRecord->PreviousLsn = PrevLsn;
    pRecord->CurrentLsn = Lsn;

    pLog->FlushedLsn = Lsn;

    //validate the chkpoint record
    //either it should be null or there should be a valid checkpoint record in there
    dwError = LogpValidateChkPoint(pLog, ChkPtLsn, LastChkPtLsn);
    
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpMountLog : NextLsn=0x%1!08lx! FileAlloc=0x%2!08lx! ActivePageOffset=0x%3!08lx!\r\n",
        pLog->NextLsn, pLog->FileAlloc, pPage->Offset);

#if DBG    
    {
        DWORD dwOldProtect;
        DWORD Status;
        BOOL VPWorked;

        VPWorked = VirtualProtect(pPage, pLog->SectorSize, PAGE_READONLY, & dwOldProtect);
        Status = GetLastError();
        CL_ASSERT( VPWorked );
    }
#endif        

FnExit:
    return(dwError);

}


/****
@func       DWORD | LogpMountLog| Mounts an existing log file. Reads the log
            header, verifies the log integrity, and sets up
            the LOG structure to support further operations.

@parm       IN PLOG | pLog | Supplies a pointer to the log structure.
@parm       OUT LPDWORD | pdwLogHeaderSize | Returns the size of the log header structure.
@parm       OUT FILETIME | *pHeaderTimestamp | Returns the time when the log header 
            was created.
            
@rdesc      Returns ERROR_SUCCESS if successful, else returns the error code.  If
            the log file doesnt look correct, it returns ERROR_CLUSTERLOG_CORRUPT.

@comm       This is called by LogpMountLog() to validate the header of a log file.

@xref       <f LogpMountLog>
****/
DWORD LogpCheckFileHeader(
    IN PLOG         pLog,
    OUT LPDWORD     pdwLogHeaderSize,
    OUT FILETIME    *pHeaderTimestamp,
    OUT LSN         *pChkPtLsn
    )
{
    PLOG_HEADER pLogHeader;
    DWORD       dwError = ERROR_SUCCESS;
    DWORD       dwBytesRead;

    
    pLogHeader = AlignAlloc(pLog->SectorSize);
    if (pLogHeader == NULL) {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }


    //read the header
    (pLog->Overlapped).Offset = 0;
    (pLog->Overlapped).OffsetHigh = 0;

    if ((dwError = LogpRead(pLog, pLogHeader, pLog->SectorSize, &dwBytesRead))
        != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogpCheckFileHeader::Read of the log header failed, error=0x%1!08lx!\r\n",
            dwError);
        dwError = ERROR_CLUSTERLOG_CORRUPT;            
        CL_LOGCLUSWARNING1(LM_LOG_CORRUPT,pLog->FileName);
        goto FnExit;
    }

    if (dwBytesRead != pLog->SectorSize)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogpCheckFileHeader::Failed to read the complete header,bytes read 0x%1!u!\r\n",
            dwBytesRead);
        dwError = ERROR_CLUSTERLOG_CORRUPT;
        CL_LOGCLUSWARNING1(LM_LOG_CORRUPT,pLog->FileName);
        goto FnExit;

    }
    //validate the header
    if (!ISVALIDHEADER((*pLogHeader)))
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogpCheckFileHeader::the file header is corrupt.\r\n");
        dwError = ERROR_CLUSTERLOG_CORRUPT;
        CL_LOGCLUSWARNING1(LM_LOG_CORRUPT,pLog->FileName);
        goto FnExit;
    }

    *pdwLogHeaderSize = pLogHeader->HeaderSize;
    *pHeaderTimestamp = pLogHeader->CreateTime;
    *pChkPtLsn = pLogHeader->LastChkPtLsn;
FnExit:
    if (pLogHeader) 
    {
        AlignFree(pLogHeader);
    }
    return(dwError);
}

/****
@func       DWORD | LogpValidateChkPt| This checks that the header points to the
            last checkpoint.  If not, it scans the log file from the end
            and if it finds a checkpoint, updates the header with that information.
            If no valid checkpoint exists, it sets the header Checkpt LSN to
            NULL_LSN.

@parm       IN PLOG | pLog | Supplies a pointer to the log structure.
@parm       IN LSN | ChkPtLsn | Supplies the ChkPtLsn read from the log header
@parm       IN LSN | LastChkPtLsn | Supplies the last valid chkpoint record found
                during the mount process.

@rdesc      Returns ERROR_SUCCESS if successful, else returns the error code.  If
            the log file doesnt look correct, it returns ERROR_CLUSTERLOG_CORRUPT.

@comm       This is called by LogpMountLog() to validate the header of a log file.

@xref       <f LogpMountLog>
****/
DWORD LogpValidateChkPoint(
    IN PLOG         pLog,
    IN LSN          ChkPtLsn,
    IN LSN          LastChkPtLsn)
{
    PLOG_HEADER     pLogHeader = NULL;
    DWORD           dwError = ERROR_SUCCESS;
    DWORD           dwNumBytes;
    DWORD           Status;
    RMID            Resource;
    RMTYPE          RmType;
    TRTYPE          TrType;
    LOG_CHKPTINFO   ChkPtInfo;
    TRID            TrId;
    HANDLE          hChkPtFile = INVALID_HANDLE_VALUE;

    
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpValidateChkPoint: Entry\r\n");

    CL_ASSERT(LastChkPtLsn < pLog->NextLsn);
    
    //if the header indicates that there is a checkpoint
    //and the most recent checkpoint record is the same as the one in the header
    //there is nothing to do, return success.
    if ((ChkPtLsn == LastChkPtLsn) && (ChkPtLsn < pLog->NextLsn))
    {
        goto ValidateChkPtFile;
    }        
    //if the header indicates there is a check point but it wasnt mounted, 
    //log corruption in the event log
    if (ChkPtLsn >= pLog->NextLsn)
    {
        ClRtlLogPrint(LOG_NOISE,
            "[LM] LogpValidateChkPoint: ChkptLsn in header wasnt validated by mount\r\n");
        //but the mount procedure failed to validate that record
        CL_LOGCLUSWARNING1(LM_LOG_CORRUPT, pLog->FileName);
#if DBG
        if (IsDebuggerPresent())
            DebugBreak();
#endif            
            
    }            

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpValidateChkPoint: Updating header with the LastChkPtLsn=0x%1!08lx!\r\n",
        LastChkPtLsn);

    //if not it could be that a checkpoint was taken but the header couldnt
    //be flushed with the last chkpt
    
    pLogHeader = (PLOG_HEADER)AlignAlloc(pLog->SectorSize);
    if (pLogHeader == NULL) {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }


    //read the header
    (pLog->Overlapped).Offset = 0;
    (pLog->Overlapped).OffsetHigh = 0;

    if ((dwError = LogpRead(pLog, pLogHeader, pLog->SectorSize, &dwNumBytes))
        != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogpValidateChkPoint::Read of the log header failed, error=0x%1!08lx!\r\n",
            dwError);
        dwError = ERROR_CLUSTERLOG_CORRUPT;            
        CL_LOGCLUSWARNING1(LM_LOG_CORRUPT,pLog->FileName);
        goto FnExit;
    }

    //recheck the header signature
    if (!ISVALIDHEADER((*pLogHeader)))
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogpCheckFileHeader::the file header is corrupt.\r\n");
        dwError = ERROR_CLUSTERLOG_CORRUPT;
        CL_LOGCLUSWARNING1(LM_LOG_CORRUPT,pLog->FileName);
        goto FnExit;
    }

    //set the last lsn
    pLogHeader->LastChkPtLsn = LastChkPtLsn;

    //write the header back        
    pLog->Overlapped.Offset = 0;
    pLog->Overlapped.OffsetHigh = 0;

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpValidateChkPoint : Writing %1!u! bytes to disk at offset 0x%2!08lx!\r\n",
        pLogHeader->HeaderSize, pLog->Overlapped.Offset);


    if ((dwError = LogpWrite(pLog, pLogHeader, pLogHeader->HeaderSize, &dwNumBytes))
        != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                "[LM] LogpInitLog: failed to write the file header, Error=0x%1!08lx!\r\n",
                dwError);
        dwError = ERROR_CLUSTERLOG_CORRUPT;
        CL_LOGCLUSWARNING1(LM_LOG_CORRUPT,pLog->FileName);
        goto FnExit;
    }

ValidateChkPtFile:
    //no need to verify that the checkpoint file exists
    if (LastChkPtLsn == NULL_LSN)
        goto FnExit;
    dwNumBytes = sizeof(LOG_CHKPTINFO);
    if ((LogRead((HLOG)pLog , LastChkPtLsn, &Resource, &RmType, 
        &TrId, &TrType, &ChkPtInfo, &dwNumBytes)) == NULL_LSN)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogpValidateChkPt::LogRead for chkpt lsn 0x%1!08lx! failed\r\n",
            pLogHeader->LastChkPtLsn);
        dwError = ERROR_CLUSTERLOG_CORRUPT;
        CL_LOGCLUSWARNING1(LM_LOG_CORRUPT,pLog->FileName);
        goto FnExit;
    }
    if (Resource != RMEndChkPt)
    {
        dwError = ERROR_CLUSTERLOG_CORRUPT;
        CL_LOGFAILURE(dwError);
        CL_LOGCLUSERROR1(LM_LOG_CORRUPT, pLog->FileName);
        goto FnExit;
    }

    //get the file name, try and open it
    hChkPtFile = CreateFileW(ChkPtInfo.szFileName,
                                  GENERIC_READ ,
                                  FILE_SHARE_READ|FILE_SHARE_WRITE,
                                  NULL,
                                  OPEN_EXISTING,
                                  0,
                                  NULL);

    if (hChkPtFile == INVALID_HANDLE_VALUE)
    {        
        ClRtlLogPrint(LOG_UNUSUAL,
                "[LM] LogpValidateChkPoint: The checkpt file %1!ws! could not be opened. Error=%2!u!\r\n",
                ChkPtInfo.szFileName, GetLastError());       
        dwError = ERROR_CLUSTERLOG_CORRUPT;
        CL_LOGCLUSWARNING1(LM_LOG_CORRUPT,pLog->FileName);
        goto FnExit;
    }

    
FnExit:
    ClRtlLogPrint(LOG_NOISE,
            "[LM] LogpValidateChkPoint: Exit, returning 0x%1!08lx!\r\n", 
            dwError);
    if (hChkPtFile != INVALID_HANDLE_VALUE)
        CloseHandle(hChkPtFile);
    if (pLogHeader) AlignFree(pLogHeader);
    return(dwError);
}


/****
@func       DWORD | LogpValidateLargeRecord| Validates a large record and advances
            the LSN to the record following the eop record which marks the end of
            a large record.

@parm       IN PLOG | pLog | Supplies a pointer to the log structure.
@parm       IN PLOGRECORD | pRecord| Supplies a pointer to the large record.
@parm       IN PLOGRECORD | pNextLsn| The LSN of the record following the
            EOP record after the large record is returned.

@rdesc      If a valid EOP record exists after the large record, the large
            record is considered valid and this function returns ERROR_SUCCESS,
            else it returns an error code.           

@comm       This is called by LogpMountLog() to validate large records.

@xref       <f LogpMountLog>
****/
DWORD LogpValidateLargeRecord(
    IN PLOG         pLog, 
    IN PLOGRECORD   pRecord, 
    OUT LSN         *pNextLsn) 
{

    DWORD       dwError = ERROR_SUCCESS;
    LSN         EopLsn;
    PLOGRECORD  pEopRecord;
    PLOGPAGE    pPage = NULL;
    DWORD       dwBytesRead;
    DWORD       dwPageIndex;

    //traverse the chain of records, to find the active page
    //find the next lsn
    pPage = AlignAlloc(pLog->SectorSize);
    if (pPage == NULL)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        CL_LOGFAILURE(dwError);
        goto FnExit;
    }

    dwPageIndex = LSNTOPAGE(pRecord->CurrentLsn);
    dwPageIndex = (dwPageIndex + pRecord->NumPages - 1);
    //read the last page for the large record
    (pLog->Overlapped).Offset = dwPageIndex * pLog->SectorSize;
    (pLog->Overlapped).OffsetHigh = 0;

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpValidateLargeRecord::reading %1!u! bytes at offset 0x%2!08lx!\r\n",
        pLog->SectorSize, dwPageIndex * pLog->SectorSize);

    dwError = LogpRead(pLog, pPage, pLog->SectorSize, &dwBytesRead);
    //if there are no errors, then check the last record
    if (dwError == ERROR_SUCCESS)
    {
        //read the page, make sure that the eop record follows the 
        //large record
        EopLsn = GETNEXTLSN(pRecord,TRUE);
        CL_ASSERT(LSNTOPAGE(EopLsn) == dwPageIndex);
        pEopRecord = (PLOGRECORD)((ULONG_PTR) pPage + 
            (EopLsn - (pLog->Overlapped).Offset));
        if ((pEopRecord->Signature == LOGREC_SIG) && 
            (pEopRecord->ResourceManager == RMPageEnd) &&
            (CompareFileTime(&(pRecord->Timestamp),&(pEopRecord->Timestamp)) <= 0)
            )
        {
            //move to the next page 
            *pNextLsn = GETNEXTLSN(pEopRecord, TRUE);
        }
        else
            dwError = ERROR_CLUSTERLOG_CORRUPT;
        
    }
FnExit:
    if (pPage) 
        AlignFree(pPage);
    return(dwError);
}



/****
@func       DWORD | LogpInvalidatePrevRecord| This function is called at mount time to 
            invalidate a previous record with the same transaction id.

@parm       IN PLOG | pLog | Supplies a pointer to the log structure.
@parm       IN PLOGRECORD | pRecord| Supplies a pointer to the record.

@rdesc      Returns ERROR_SUCCESS on success, else returns error code.

@comm       This is called by LogpMountLog() to invalidate a record with the same transaction
            id.  This is because the locker node may write a transaction record to the 
            log and die before it can be propagated to other nodes. This transaction record
            is then invalid.

@xref       <f LogpMountLog>
****/
DWORD LogpInvalidatePrevRecord(
    IN PLOG         pLog, 
    IN PLOGRECORD   pRecord 
) 
{

    DWORD       dwError = ERROR_SUCCESS;
    PLOGRECORD  pPrevRecord;
    LSN         PrevLsn;
    PLOGPAGE    pPage = NULL;
    DWORD       dwBytesRead;
    DWORD       dwPageIndex;
    TRID        TrId;
    BOOL        bPrevRecordFound = FALSE;
    
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpInvalidatePrevRecord : Entry, TrId=%1!08lx!\r\n",
        pRecord->Transaction);

    //allocate a page to read the record headers
    pPage = AlignAlloc(SECTOR_SIZE);
    if (pPage == NULL) 
    {
        CL_LOGFAILURE(dwError = ERROR_NOT_ENOUGH_MEMORY);
        goto FnExit;
    }
    TrId = pRecord->Transaction;

    //try and find the last valid transaction with the same id, there should be one
    pPrevRecord = pRecord;       
    while (!bPrevRecordFound)
    {
        PrevLsn = pPrevRecord->PreviousLsn;

        if (PrevLsn == NULL_LSN)
            break;
            
        dwPageIndex = LSNTOPAGE(PrevLsn);

        pLog->Overlapped.Offset = dwPageIndex * pLog->SectorSize;
        pLog->Overlapped.OffsetHigh = 0;

        dwError = LogpRead(pLog, pPage, pLog->SectorSize, &dwBytesRead);

        if (dwError != ERROR_SUCCESS)
            goto FnExit;

        pPrevRecord = LSNTORECORD(pPage, PrevLsn);

        if (pPrevRecord->ResourceManager < RMAny)
            continue;
        if ((pPrevRecord->ResourceManager == pRecord->ResourceManager) && 
            (pPrevRecord->Transaction == TrId) &&
            ((pPrevRecord->XsactionType == TTCompleteXsaction) || 
             (pPrevRecord->XsactionType == TTCommitXsaction)))
        {
            bPrevRecordFound = TRUE;                
            pPrevRecord->ResourceManager = RMInvalidated;
            //write the new page out
            dwError = LogpWrite(pLog, pPage, pLog->SectorSize, &dwBytesRead);
            if (dwError != ERROR_SUCCESS)
            {
                goto FnExit;
            }
            ClRtlLogPrint(LOG_NOISE,
                "[LM] LogpInvalidatePrevRecord : record at LSN=%1!08lx! invalidated\r\n",
                PrevLsn);
        }
            
    }
    
FnExit:    
    if (pPage) AlignFree(pPage);
    return(dwError);
}


DWORD
LogpRead(
    IN PLOG     pLog,
    OUT PVOID   pBuf,
    IN DWORD    dwBytesToRead,
    OUT PDWORD  pdwBytesRead
    )

/*++

Routine Description:

    Reads a page(pLog->SectorSize) from the log file from the offsets set in pLog->Overlapped
    structure.

Arguments:

    Log - Supplies the log to be grown.

    pBuf - Supplies the buffer to read into

    dwBytesToRead - bytes to read

    pdwBytesRead - pointer where the bytes read are returned


Return Value:

    ERROR_SUCCESS if successful

    Win32 error code if unsuccessful. ERROR_HANDLE_EOF if the end of file is
    reached.

--*/
{
    DWORD   dwError=ERROR_SUCCESS;
    BOOL    Success;

    *pdwBytesRead = 0;

    //
    // Make sure input buffer is aligned
    //
    CL_ASSERT(((ULONG_PTR)pBuf % 512) == 0);

    Success = ReadFile(pLog->FileHandle,
                   pBuf,
                   dwBytesToRead,
                   pdwBytesRead,
                   &(pLog->Overlapped));
//                   NULL);


    if (!Success)
    {

        // deal with the error code
        switch (dwError = GetLastError())
        {
            case ERROR_IO_PENDING:
            {
                // asynchronous i/o is still in progress
                // check on the results of the asynchronous read
                Success = GetOverlappedResult(pLog->FileHandle,
                                      &(pLog->Overlapped),
                                      pdwBytesRead,
                                      TRUE);

                // if there was a problem ...
                if (!Success)
                {

                    // deal with the error code
                    switch (dwError = GetLastError())
                    {
                        //ss:for end of file dont log error
                        case ERROR_HANDLE_EOF:
                            break;

                        default:
                            // deal with other error cases
                            CL_LOGFAILURE(dwError);
                            break;
                    }
                }
                else
                    dwError = ERROR_SUCCESS;
                break;
            }

            case ERROR_HANDLE_EOF:
                break;

            default:
                CL_UNEXPECTED_ERROR(dwError);
                break;
        }
    }
    return(dwError);
}

DWORD
LogpWrite(
    IN PLOG pLog,
    IN PVOID pData,
    IN DWORD dwBytesToWrite,
    IN DWORD *pdwBytesWritten)

{

    DWORD   dwError=ERROR_SUCCESS;
    BOOL    Success;

    *pdwBytesWritten = 0;

#if DBG
    if (pLog->Overlapped.Offset == 0)
    {
        ClRtlLogPrint(LOG_NOISE,
            "[LM] LogpWrite : Writing the file header, CheckPtLsn=0x%1!08lx!\r\n",
            ((PLOG_HEADER)pData)->LastChkPtLsn);

    }
#endif    
    Success = WriteFile(pLog->FileHandle,
                   pData,
                   dwBytesToWrite,
                   pdwBytesWritten,
                   &(pLog->Overlapped));


    if (!Success)
    {

        // deal with the error code
        switch (dwError = GetLastError())
        {
            case ERROR_IO_PENDING:
            {
                // asynchronous i/o is still in progress
                // check on the results of the asynchronous read
                Success = GetOverlappedResult(pLog->FileHandle,
                                      &(pLog->Overlapped),
                                      pdwBytesWritten,
                                      TRUE);

                // if there was a problem ...
                if (!Success)
                    CL_LOGFAILURE((dwError = GetLastError()));
                else
                    dwError = ERROR_SUCCESS;
                break;
            }

            default:
                CL_LOGFAILURE(dwError);
                break;
        }
    }
    return(dwError);


}

/****
@func   DWORD | LogpWriteLargeRecordData | Writes thru the data for a 
        large record.

@parm   PLOG | pLog | The pointer to the log.        
@parm   PLOGRECORD | pLogRecord | Supplies the logrecord where this record starts. The 
        record header is already written.
@parm   PVOID | pLogData | A pointer to the large record data.
@parm   DWORD | dwDataSize | The size of the large record data.

@comm   Called by LogWrite() to write a large record.  The maximum size is
        restricted by the growth chunk size.
        
@xref   <f LogCreate> 
****/

DWORD
LogpWriteLargeRecordData(
    IN PLOG pLog,
    IN PLOGRECORD pLogRecord, 
    IN PBYTE pLogData, 
    IN DWORD dwDataSize)        
{    
    DWORD       dwBytesWritten;
    DWORD       dwDataBytesWritten;
    DWORD       dwDataBytesLeft;
    DWORD       dwNumPagesLeft;    //pages written
    DWORD       dwError=ERROR_SUCCESS;
    PLOGRECORD  Current;
    DWORD       Status;
    LSN         LastLsn;
    DWORD       dwOldOffset;
    PLOGPAGE    pPage;
    PBYTE       pLargeBuffer=NULL;
    
    ClRtlLogPrint(LOG_UNUSUAL,
        "[LM] LogpWriteLargeRecordData::dwDataSize=%1!u!\r\n",
        dwDataSize);
        

    pPage = pLog->ActivePage;

    //write as much data into the current page as you possibly can    
    dwDataBytesWritten = pPage->Size - sizeof(LOGPAGE);
    if (dwDataBytesWritten > dwDataSize)
        dwDataBytesWritten = dwDataSize;
    dwDataBytesLeft = dwDataSize - dwDataBytesWritten;
    CopyMemory(&(pLogRecord->Data), pLogData, dwDataBytesWritten);
    
    //flush this page
    (pLog->Overlapped).Offset = pPage->Offset;
    (pLog->Overlapped).OffsetHigh = 0;

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpWriteLargeRecord : Writing(firstpageoflargerecord) %1!u! bytes to disk at offset 0x%2!08lx!\r\n",
        pPage->Size, pPage->Offset);

    if ((dwError = LogpWrite(pLog, pPage, pPage->Size, &dwBytesWritten))
            != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogpWriteLargeRecordData::LogpWrite returned error=0x%1!08lx!\r\n",
            dwError);
        CL_LOGFAILURE(dwError);
        goto FnExit;
    }
    //update the data pointer
    pLogData += dwDataBytesWritten;
    dwNumPagesLeft = pLogRecord->NumPages - 1;

    //if the number of bytes left is greater than a page
    //write everything but the last page
    if (dwNumPagesLeft > 1)
    {
        dwDataBytesWritten = (dwNumPagesLeft - 1) * pPage->Size;
        pLargeBuffer = AlignAlloc(dwDataBytesWritten);
        if (pLargeBuffer == NULL) 
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY ;
            CL_LOGFAILURE(ERROR_NOT_ENOUGH_MEMORY);
            goto FnExit;
        }
        if (dwDataBytesWritten > dwDataBytesLeft)
            dwDataBytesWritten = dwDataBytesLeft;
        dwDataBytesLeft -= dwDataBytesWritten;
        //continue writing from the next page
        (pLog->Overlapped).Offset = pPage->Size + pPage->Offset;
        (pLog->Overlapped).OffsetHigh = 0;

        CopyMemory(pLargeBuffer, pLogData, dwDataBytesWritten);

        ClRtlLogPrint(LOG_NOISE,
            "[LM] LogpWriteLargeRecord : Writing(restoflargerecord) %1!u! bytes to disk at offset 0x%2!08lx!\r\n",
            dwDataBytesWritten, (pLog->Overlapped).Offset);
        
        if ((dwError = LogpWrite(pLog, pLargeBuffer, 
            (dwNumPagesLeft - 1) * pPage->Size, &dwBytesWritten))
                != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[LM] LogpWriteLargeRecordData::LogpWrite returned error=0x%1!08lx!\r\n",
                dwError);
            CL_LOGFAILURE(dwError);
            goto FnExit;
        }
        //update the data pointer
        pLogData += dwDataBytesWritten;
        //now only the last page is left
        dwNumPagesLeft = 1;
    }
    
    //set the offset to the last page
    pPage->Offset += pPage->Size * (pLogRecord->NumPages - 1);
    Current = LSNTORECORD(pPage, pLog->NextLsn);
    Current->PreviousLsn = pLogRecord->CurrentLsn;
    Current->CurrentLsn = pLog->NextLsn;

    //write the last page, first write the eop data and then copy the
    //remaining user data into the page and then write to disk
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpWriteLargeRecord : Writing eoprecord of %1!u! bytes to disk at offset 0x%2!08lx!\r\n",
        pPage->Size, pPage->Offset);

    pLog->Overlapped.Offset = pPage->Offset;
    pLog->Overlapped.OffsetHigh = 0;

    //current points to the next record in the last page
    //this will be the eop record
    // Create an end-of-page record
    //
    Current->Signature = LOGREC_SIG;
    Current->RecordSize = pPage->Size - RECORDOFFSETINPAGE(pPage, Current) + (sizeof(LOGPAGE)-sizeof(LOGRECORD));
    Current->ResourceManager = RMPageEnd;
    Current->Transaction = 0;                 
    Current->Flags = 0;
    Current->NumPages = 1;
    GetSystemTimeAsFileTime(&Current->Timestamp);

    dwDataBytesWritten = dwDataBytesLeft;
    if (dwDataBytesWritten)
        dwDataBytesLeft -= dwDataBytesWritten;
    CL_ASSERT(dwDataBytesLeft == 0);
        
    //use dwDataBytesLeft to remember the page size
    //since we are now going to copy user data over it
    dwDataBytesLeft = pPage->Size;
    dwOldOffset = pPage->Offset;
    if (dwDataBytesWritten)
        CopyMemory(pPage, pLogData, dwDataBytesWritten);
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpWriteLargeRecord : Writing(lastpageoflargerecord) %1!u! bytes to disk at offset 0x%2!08lx!\r\n",
        dwDataBytesLeft, (pLog->Overlapped).Offset);

    //write the last page        
    dwError = LogpWrite(pLog, pPage, dwDataBytesLeft, &dwBytesWritten);
    if (dwError != ERROR_SUCCESS)
    {
        CL_LOGFAILURE(dwError);
        goto FnExit;

    }
    //restore page size and offset
    pPage->Size = dwDataBytesLeft;
    pPage->Offset = dwOldOffset;
    
    //set the next lsn to the first record on the next page
    LastLsn = Current->CurrentLsn;
    pLog->NextLsn = LastLsn + Current->RecordSize;
    pLog->FlushedLsn = pLog->NextLsn;

    // Create new page and keep the new record ready
    // note disk space for this record has already been commited
    pPage->Offset += pPage->Size;             // voila, new page!
    Current = &pPage->FirstRecord;           // log record immediately following page header
    Current->PreviousLsn = LastLsn;
    Current->CurrentLsn = pLog->NextLsn;

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpWriteLargeRecord : success pLog->NextLsn=0x%1!08lx!\r\n",
        pLog->NextLsn);
    

FnExit:
    if (pLargeBuffer) AlignFree(pLargeBuffer);
    return (dwError);
}



DWORD
LogpGrowLog(
    IN PLOG Log,
    IN DWORD GrowthSize
    )

/*++

Routine Description:

    Ensures that there is sufficient disk space to handle subsequent
    writes by preallocating the log file. Two variables, FileSize and
    FileAlloc are tracked in the LOG structure. This routine increases
    FileAlloc by the specified GrowthSize. Once FileAlloc exceeds
    FileSize, the file is grown to accomodate the new data.

    If this routine returns successfully, it guarantees that subsequent
    will not fail due to lack of disk space.

Arguments:

    Log - Supplies the log to be grown.

    GrowthSize - Supplies the number of bytes required.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code if unsuccessful.

--*/

{
    DWORD NewSize;
    DWORD Status;

    if(Log->FileAlloc > Log->FileSize)
    {
        return(ERROR_CLUSTERLOG_CORRUPT);       
    }

    if (Log->FileAlloc + GrowthSize <= Log->FileSize) 
    {
        Log->FileAlloc += GrowthSize;
        return(ERROR_SUCCESS);
    }


    NewSize = Log->FileSize + GROWTH_CHUNK;
    CL_ASSERT(NewSize > Log->FileSize);         // bummer, log file is >4GB

    //check if the file can be grown, if not, may be a reset
    //is required

    if (NewSize > Log->MaxFileSize)
    {
        LogpWriteWarningToEvtLog(LM_LOG_EXCEEDS_MAXSIZE, Log->FileName);
        return(ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE);
    }
    //
    // Grow the file.
    //

    Status = SetFilePointer(Log->FileHandle,
                            NewSize,
                            NULL,
                            FILE_BEGIN);
    if (Status == 0xFFFFFFFF) {
        Status = GetLastError();
        CL_LOGFAILURE(Status);
        return(Status);
    }

    if (!SetEndOfFile(Log->FileHandle)) {
        Status = GetLastError();
        CL_LOGFAILURE(Status);
        return(Status);
    }

    Log->FileAlloc += GrowthSize;
    Log->FileSize += GROWTH_CHUNK;
    return(ERROR_SUCCESS);

}

DWORD
LogpReset(
    IN PLOG Log,
    IN LPCWSTR  lpszInChkPtFile
    )
/*++

Routine Description:

    Resets the log file and takes a  new checkpoint if a NULL checkpoint
    file is specified as the second parameter.

Arguments:

    Log - Supplies the log to be reset.

    lpszInChkPtFile - Supplies the checkpoint file.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code if unsuccessful.

--*/
{
    PLOG        pLog;
    PLOG        pNewLog;
    DWORD       dwError=ERROR_SUCCESS;
    WCHAR       szPathName[MAX_PATH];
    WCHAR       szFilePrefix[MAX_PATH]=L"tquolog";
    WCHAR       szTmpFileName[MAX_PATH];
    WCHAR       szOldChkPtFileName[MAX_PATH];
    LSN         Lsn;
    TRID        Transaction;
    
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpReset entry...\r\n");

    pLog = Log;
   
    //
    // SS: the path name must be specified by the api as well,
    // here we assume it is hardcoded for the use for the quorum
    // log
    //
    dwError = DmGetQuorumLogPath(szPathName, sizeof(szPathName));
    if (dwError  != ERROR_SUCCESS)
    {
        dwError = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogpReset : DmGetQuorumLogPath failed, error=%1!u!\r\n",
            dwError);
        goto FnExit;
    }

    //
    //  Generate a tmp file name
    //
    if (!GetTempFileNameW(szPathName, szFilePrefix, 0, szTmpFileName))
    {
        dwError = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogpReset failed to generate a tmp file name,PathName=%1!ls!, FilePrefix=%2!ls!, error=%3!u!\r\n",
            szPathName, szFilePrefix, dwError);
        goto FnExit;
    }

    //
    //  Initialize the new log file, no timer is created
    //
    if (!(pNewLog = LogpCreate(szTmpFileName, pLog->MaxFileSize,
        pLog->pfnGetChkPtCb, pLog->pGetChkPtContext, TRUE, &Lsn)))
    {
        dwError = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogpReset failed to create the new log file, error=0x%1!08lx\n",
            dwError);
        //
        // Chittur Subbaraman (chitturs) - 2/18/99
        //
        // Make sure you get rid of the temp file. Otherwise, repeated
        // log resets can clog the disk.
        //
        if ( !DeleteFileW( szTmpFileName ) )
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[LM] LogpReset:: Unable to delete tmp file %1!ws! after failed log create, Error=%2!d!\r\n",
                szTmpFileName,
                GetLastError());
        }
        goto FnExit;
    }


    //
    //  Reset the log file
    //
    EnterCriticalSection(&pLog->Lock);

    //
    //  Get the name of the previous checkpoint file in the old log file
    //
    szOldChkPtFileName[0] = TEXT('\0');
    if (LogGetLastChkPoint((HLOG)pLog, szOldChkPtFileName, &Transaction, &Lsn)
        != ERROR_SUCCESS)
    {
        // 
        //  Continue, this only means there is no old file to delete
        //
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogReset:: no check point found in the old log file\r\n");
    }

    //
    //  write a check point to it, if there is a checkpoint function
    //
    if ((dwError = LogCheckPoint((HLOG)pNewLog, FALSE, lpszInChkPtFile, 0))
        != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogpReset:: Callback failed to return a checkpoint, error=%1!u!\r\n",
            dwError);
        CL_LOGFAILURE(dwError);
        LogClose((HLOG)pNewLog);
        LeaveCriticalSection(&pLog->Lock);
        //
        // Chittur Subbaraman (chitturs) - 2/18/99
        //
        // Make sure you get rid of the temp file. Otherwise, repeated
        // log resets can clog the disk.
        //
        if ( !DeleteFileW( szTmpFileName ) )
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[LM] LogpReset:: Unable to delete tmp file %1!ws! after failed checkpoint attempt, Error=%2!d!\r\n",
                szTmpFileName, 
                GetLastError());
        }
        goto FnExit;
    }

    //
    //  Get the name of the most recent checkpoint file in the new log file
    //
    szFilePrefix[0] = TEXT('\0');
    if (LogGetLastChkPoint((HLOG)pNewLog, szFilePrefix, &Transaction, &Lsn)
        != ERROR_SUCCESS)
    {
        //
        //  Continue, this only means there is no old file to delete
        //
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogpReset:: no check point found in the old log file\r\n");
    }

    //
    //  Close the old file handle so that we can move this temp file over
    //
    CloseHandle(pLog->FileHandle);
    CloseHandle(pNewLog->FileHandle);
    pNewLog->FileHandle = NULL;
    pLog->FileHandle = NULL;

    //
    //  Rename the new file to the log file
    //
    if (!MoveFileExW(szTmpFileName, pLog->FileName, MOVEFILE_REPLACE_EXISTING|MOVEFILE_WRITE_THROUGH))
    {
        dwError = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogpReset:: MoveFileExW failed. Error = 0x%1!08lx!\r\n",
            dwError);
        //
        //  Move failed, close the new log file
        //
        LogClose((HLOG)pNewLog);
        LeaveCriticalSection(&pLog->Lock);
        //
        // Chittur Subbaraman (chitturs) - 2/18/99
        //
        // Attempt to delete the temp file. You may not necessarily
        // succeed here.
        //
        DeleteFileW( szTmpFileName );
        goto FnExit;
    }

    //
    //  Open the new file again
    //
    pNewLog->FileHandle = CreateFileW(pLog->FileName,
                                  GENERIC_READ | GENERIC_WRITE,
                                  FILE_SHARE_READ,
    //                            0,
                                  NULL,
                                  OPEN_ALWAYS,
                                  FILE_FLAG_WRITE_THROUGH | FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED,
    //                            FILE_FLAG_WRITE_THROUGH | FILE_FLAG_OVERLAPPED,
    //                            0,
                                  NULL);
    if (pNewLog->FileHandle == INVALID_HANDLE_VALUE) {
        dwError = GetLastError();
        CL_LOGFAILURE(dwError);
        LeaveCriticalSection(&pLog->Lock);
        goto FnExit;
    }

    //
    //  Delete the last checkpoint in the old log file
    //
    if (szOldChkPtFileName[0] != TEXT('\0') && lstrcmpiW(szOldChkPtFileName, szFilePrefix))
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogpReset:: deleting previous checkpoint file %1!ls!\r\n",
            szOldChkPtFileName);
        DeleteFileW(szOldChkPtFileName);
    }

    //
    //  Free the old resources
    //
    CloseHandle(pLog->Overlapped.hEvent);
    AlignFree(pLog->ActivePage);
    
    //
    //  Update the old log structure with the new info
    //  retain the name, callback info and the critical section
    //  continue to manage this file with the old timer as well
    //
    pLog->FileHandle = pNewLog->FileHandle;
    pLog->SectorSize = pNewLog->SectorSize;
    pLog->ActivePage = pNewLog->ActivePage;
    pLog->NextLsn = pNewLog->NextLsn;
    pLog->FlushedLsn = pNewLog->FlushedLsn;
    pLog->FileSize = pNewLog->FileSize;
    pLog->FileAlloc = pNewLog->FileAlloc;
    pLog->MaxFileSize = pNewLog->MaxFileSize;
    pLog->Overlapped = pNewLog->Overlapped;

    //
    //  Delete the new pLog structure and associated memory for name
    //
    DeleteCriticalSection(&pNewLog->Lock);
    CrFree(pNewLog->FileName);
    CrFree(pNewLog);

    LeaveCriticalSection(&pLog->Lock);

FnExit:
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpReset exit, returning 0x%1!08lx!\r\n",
            dwError);
    return(dwError);
}

/****
@func   DWORD | LogpWriteWarningToEvtLog | Conditionally write a warning
        to the event log

@parm   DWORD | dwWarningType | Type of warning.
@parm   LPCWSTR | lpszLogFileName | The log file name.        

@comm   This function is added in order to prevent the event log from
        being filled with the same type of warning message.
        
@xref   
****/
VOID
LogpWriteWarningToEvtLog(
    IN DWORD dwWarningType,
    IN LPCWSTR  lpszLogFileName
    )
{
    //
    //  Chittur Subbaraman (chitturs) - 1/4/99
    //
    //  (Use switch-case for easy future expansion purposes)
    //
    switch( dwWarningType )
    {
        case LM_LOG_EXCEEDS_MAXSIZE:
            if( bLogExceedsMaxSzWarning == FALSE )
            {
                CL_LOGCLUSWARNING1( dwWarningType, lpszLogFileName );
                bLogExceedsMaxSzWarning = TRUE;
            }
            break;

        default:
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\lm\logger.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    logger.c

Abstract:

    Provides the persistent log used by the cluster registry service

    This is a very simple logger that supports writing arbitrarily
    sized chunks of data in an atomic fashion.

Author:

    John Vert (jvert) 15-Dec-1995

Revision History:
    sunitas : added mount, scan, checkpointing, reset functionality.
    sunitas : added large record support
--*/
#include "service.h"
#include "lmp.h"
#include "clusudef.h"
/****
@doc    EXTERNAL INTERFACES CLUSSVC LM
****/

/****
@func       HLOG | LogCreate| Creates or opens a log file. If the file
            does not exist, it will be created. If the file already exists, and is
            a valid log file, it will be opened.

@parm       IN LPWSTR | lpFileName | Supplies the name of the log file to create or open.

@parm       IN DWORD | dwMaxFileSize | Supplies the maximum file size in bytes, must be
            greater than 8K and    smaller than 4 gigabytes.  If the file is exceeds this
            size, the reset function will be called. If 0, the maximum log file size limit
            is set to the default maximum size.

@parm       IN PLOG_GETCHECKPOINT_CALLBACK | CallbackRoutine | The callback routine that
            will provide a checkpoint file and the transaction associated with that checkpoint
            file when LogCheckPoint() is called for this log file.  If this is NULL, then the checkpointing capabilities are
            not associated with the log file.

@parm       IN PVOID | pGetChkPtContext | Supplies an arbitrary context pointer, which will be
            passed to the CallbackRoutine.

@parm       IN BOOL | bForceReset | If true, this function creates an empty log file 
            if the log file doesnt exist or if it is corrupt.

@parm       LSN | *LastLsn | If present, Returns the last LSN written to the log file.
              (NULL_LSN if the log file was created)

@rdesc      Returns a handle suitable for use in subsequent log calls.  NUll in the case of an error.

@xref       <f LogClose>
****/
HLOG
LogCreate(
    IN LPWSTR lpFileName,
    IN DWORD  dwMaxFileSize,
    IN PLOG_GETCHECKPOINT_CALLBACK CallbackRoutine,
    IN PVOID  pGetChkPtContext,
    IN BOOL     bForceReset,
    OPTIONAL OUT LSN *pLastLsn
    )
{
    PLOG    pLog;
    
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogCreate : Entry FileName=%1!ls! MaxFileSize=0x%2!08lx!\r\n",
        lpFileName,dwMaxFileSize);

    //create the log structure
    pLog = LogpCreate(lpFileName, dwMaxFileSize, CallbackRoutine, 
        pGetChkPtContext, bForceReset, pLastLsn);

    if (pLog == NULL)       
        goto FnExit;

    //create a timer for this log
    //SS:TODO?? - currently we have a single timer perfile
    //if that is too much of an overhead, we can manage multiple
    //file with a single timer.
    //create a synchronization timer to manage this file
    pLog->hTimer = CreateWaitableTimer(NULL, FALSE, NULL);

    if (!(pLog->hTimer))
    {
    	CL_LOGFAILURE(GetLastError());
    	return (0);
    }

    //register the timer for this log with the periodic activity timer thread
    AddTimerActivity(pLog->hTimer, LOG_MANAGE_INTERVAL, 1, LogpManage, (HLOG)pLog);

FnExit:
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogCreate : Exit *LastLsn=0x%1!08lx! Log=0x%2!08lx!\r\n",
        *pLastLsn, pLog);
    return((HLOG)pLog);
}

/****
@func       DWORD | LogGetInfo | This is the callback registered to perform
            periodic management functions like flushing for quorum log files.

@parm       IN HLOG | hLog | Supplies the identifier of the log.

@parm       OUT LPWSTR | szFileName | Should be a pointer to a buffer MAX_PATH characters wide.

@parm       OUT LPDWORD | pdwCurLogSize | The current size of the log file
            is returned via this.

@parm       OUT LPDWORD | pdwMaxLogSize | The maximum size of the log file
            is returned via this.

@rdesc      ERROR_SUCCESS if successful. Win32 error code if something horrible happened.

@xref       <f LogCreate>
****/
DWORD LogGetInfo(
    IN  HLOG    hLog,
    OUT LPWSTR  szFileName,
    OUT LPDWORD pdwCurLogSize,
    OUT LPDWORD pdwMaxLogSize
    )
{
    PLOG    pLog;
    DWORD   dwError=ERROR_SUCCESS;
    
    GETLOG(pLog, hLog);

    EnterCriticalSection(&pLog->Lock);

    *pdwMaxLogSize = pLog->MaxFileSize;
    *pdwCurLogSize = pLog->FileSize;
    lstrcpyW(szFileName, pLog->FileName);

    LeaveCriticalSection(&pLog->Lock);

    return(dwError);
}

/****
@func       DWORD | LogSetInfo | This is the callback registered to perform
            periodic management functions like flushing for quorum log files.

@parm       IN HLOG | hLog | Supplies the identifier of the log.

@parm       OUT LPWSTR | szFileName | Should be a pointer to a buffer MAX_PATH characters wide.

@parm       OUT LPDWORD | pdwCurLogSize | The current size of the log file
            is returned via this.

@parm       OUT LPDWORD | pdwMaxLogSize | The maximum size of the log file
            is returned via this.

@rdesc      ERROR_SUCCESS if successful. Win32 error code if something horrible happened.

@xref       <f LogCreate>
****/
DWORD LogSetInfo(
    IN  HLOG    hLog,
    IN  DWORD   dwMaxLogSize
    )
{
    PLOG    pLog;
    DWORD   dwError=ERROR_SUCCESS;
    
    GETLOG(pLog, hLog);

    EnterCriticalSection(&pLog->Lock);

    if (dwMaxLogSize == 0) dwMaxLogSize = CLUSTER_QUORUM_DEFAULT_MAX_LOG_SIZE;

    pLog->MaxFileSize = dwMaxLogSize;

    LeaveCriticalSection(&pLog->Lock);

    return(dwError);
}

/****
@func       DWORD | LogClose | Closes an open log file. All pending log writes are
            committed, all allocations are freed, and all handles are closed.

@parm       HLOG | hLog | Supplies the identifier of the log.

@rdesc      ERROR_SUCCESS if successful. Win32 error code if something horrible happened.

@xref       <f LogCreate>
****/
DWORD
LogClose(
    IN HLOG LogFile
    )
{
    PLOG    pLog;
    LSN     NextLsn;
    BOOL    Success;

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogClose : Entry LogFile=0x%1!08lx!\r\n",
        LogFile);

    GETLOG(pLog, LogFile);

    //this will close the timer handle
    // we do this while not holding the log so that if a
    // timer event to flush fires it has an opportunity to finish
    if (pLog->hTimer) 
    {
        RemoveTimerActivity(pLog->hTimer);
        pLog->hTimer = NULL;
    }
    EnterCriticalSection(&pLog->Lock);

    
    //if the file is open, LogReset calls LogClose after closing the log handle
    if (pLog->FileHandle)
    {
        NextLsn = LogFlush(LogFile, pLog->NextLsn);
        //close the file handle
        Success = CloseHandle(pLog->FileHandle);
        CL_ASSERT(Success);
    }

    Success = CloseHandle(pLog->Overlapped.hEvent);
    CL_ASSERT(Success);


    AlignFree(pLog->ActivePage);
    CrFree(pLog->FileName);
    LeaveCriticalSection(&pLog->Lock);
    DeleteCriticalSection(&pLog->Lock);
    ZeroMemory(pLog, sizeof(LOG));                   // just in case somebody tries to
                                                    // use this log again.
    CrFree(pLog);

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogClose : Exit returning success\r\n");

    return(ERROR_SUCCESS);
}


/****
@func       LSN | LogWrite | Writes a log record to the log file. The record is not
            necessarily committed until LogFlush is called with an LSN greater or equal to the returned LSN.

@parm       HLOG | hLog | Supplies the identifier of the log.

@parm       TRID | TransactionId | Supplies a transaction ID of the record.

@parm       TRID | TransactionType | Supplies a transaction type, start/commit/complete/unit
            transaction.

@parm       RMID | ResourceId | Supplies the ID of the resource manager submitting the log record.

@parm       RMTYPE | ResourceFlags |Resource manager associated flags to be associated with this log record.

@parm       PVOID | LogData | Supplies a pointer to the data to be logged.

@parm       DWORD | DataSize | Supplies the number of bytes of data pointed to by LogData

@rdesc      The LSN of the log record that was created. NULL_LSN if something terrible happened.
            GetLastError() will provide the error code.

@xref       <f LogRead> <f LogFlush>
****/
LSN
LogWrite(
    IN HLOG     LogFile,
    IN TRID     TransactionId,
    IN TRTYPE   XsactionType,
    IN RMID     ResourceId,
    IN RMTYPE   ResourceFlags,
    IN PVOID    LogData,
    IN DWORD    DataSize
    )
{
    PLOGPAGE    Page;
    PLOG        Log;
    PLOGRECORD  LogRecord;
    LSN         Lsn=NULL_LSN;
    BOOL        bMaxFileSizeReached;
    DWORD       TotalSize;
    DWORD       dwError;
    DWORD       dwNumPages;
    
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogWrite : Entry TrId=%1!u! RmId=%2!u! RmType = %3!u! Size=%4!u!\r\n",
        TransactionId, ResourceId, ResourceFlags, DataSize);

    CL_ASSERT(ResourceId > RMAny);     // reserved for logger's use

    GETLOG(Log, LogFile);
    TotalSize = sizeof(LOGRECORD) + (DataSize + 7) & ~7;       // round up to qword size

    EnterCriticalSection(&Log->Lock);

#if DBG    
    {
        DWORD dwOldProtect;
        DWORD Status;
        BOOL VPWorked;

        VPWorked = VirtualProtect(Log->ActivePage, Log->SectorSize, PAGE_READWRITE, &dwOldProtect);
        Status = GetLastError();
        CL_ASSERT( VPWorked );
    }        
#endif        

    Page = LogpAppendPage(Log, TotalSize, &LogRecord, &bMaxFileSizeReached, &dwNumPages);
    //if a new page couldnt be allocated due to file size limits,
    //then try and reset the log
    if ((Page == NULL) && bMaxFileSizeReached)
    {
        //after resetting the log, try and allocate record space again
        LogpWriteWarningToEvtLog(LM_LOG_EXCEEDS_MAXSIZE, Log->FileName);
        dwError = LogReset(LogFile);
        //SS:LogReset sets the page to be readonly again
#if DBG    
        {
            DWORD dwOldProtect;
            DWORD Status;
            BOOL VPWorked;

            VPWorked = VirtualProtect(Log->ActivePage, Log->SectorSize, PAGE_READWRITE, &dwOldProtect);
            Status = GetLastError();
            CL_ASSERT( VPWorked );
        }        
#endif        
        if (dwError == ERROR_SUCCESS)
            Page = LogpAppendPage(Log, TotalSize, &LogRecord, &bMaxFileSizeReached, &dwNumPages);
        else
            SetLastError(dwError);
    }

    if (Page == NULL)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
        "[LM] LogWrite : LogpAppendPage failed.\r\n");
        goto FnExit;
    }

    CL_ASSERT(((ULONG_PTR)LogRecord & 0x7) == 0);      // ensure qword alignment
    Lsn = MAKELSN(Page, LogRecord);

    //
    // Fill in log record.
    //
    LogRecord->Signature = LOGREC_SIG;
    LogRecord->ResourceManager = ResourceId;
    LogRecord->Transaction = TransactionId;
    LogRecord->XsactionType = XsactionType;
    LogRecord->Flags = ResourceFlags;
    GetSystemTimeAsFileTime(&LogRecord->Timestamp);
    LogRecord->NumPages = dwNumPages;
    LogRecord->DataSize = DataSize;
    if (dwNumPages < 1)
        CopyMemory(&LogRecord->Data, LogData, DataSize);
    else
    {
        if (LogpWriteLargeRecordData(Log, LogRecord, LogData, DataSize) 
            != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[LM] LogWrite : LogpWriteLargeRecordData failed. Lsn=0x%1!08lx!\r\n",
                Lsn);
            Lsn = NULL_LSN;                
        }
    }

FnExit:
#if DBG    
    {
        DWORD dwOldProtect;
        DWORD Status;
        BOOL VPWorked;

        VPWorked = VirtualProtect(Log->ActivePage, Log->SectorSize, PAGE_READONLY, & dwOldProtect);
        Status = GetLastError();
        CL_ASSERT( VPWorked );
    }        
#endif        

    LeaveCriticalSection(&Log->Lock);
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogWrite : Exit returning=0x%1!08lx!\r\n",
        Lsn);

    return(Lsn);
}


/****
@func       LSN | LogCommitSize | Commits the size for a record of this size.

@parm       HLOG | hLog | Supplies the identifier of the log.

@parm       DWORD | dwSize | Supplies the size of the data that needs
            to be logged.

@rdesc      The LSN of the log record that was created. NULL_LSN if something terrible happened.
            GetLastError() will provide the error code.

@xref       <f LogRead> <f LogFlush>
****/
DWORD
LogCommitSize(
    IN HLOG     hLog,
    IN RMID     ResourceId,
    IN DWORD    dwDataSize
    )
{
    PLOGPAGE    Page;
    PLOG        pLog;
    PLOGRECORD  LogRecord;
    LSN         Lsn=NULL_LSN;
    BOOL        bMaxFileSizeReached;
    DWORD       dwTotalSize;
    DWORD       dwError = ERROR_SUCCESS;
    DWORD       dwNumPages;
    
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogCommitSize : Entry RmId=%1!u! Size=%2!u!\r\n",
        ResourceId, dwDataSize);

#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailLogCommitSize) {
        dwError = ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE;
        return(dwError);
    }
#endif

    CL_ASSERT(ResourceId > RMAny);     // reserved for logger's use

    GETLOG(pLog, hLog);
    dwTotalSize = sizeof(LOGRECORD) + (dwDataSize + 7) & ~7;       // round up to qword size

    EnterCriticalSection(&pLog->Lock);
    //dont force the file to grow beyond its max limit
    dwError = LogpEnsureSize(pLog, dwTotalSize, FALSE);
    if (dwError == ERROR_SUCCESS)
        goto FnExit;
    if (dwError == ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE)
    {
        //after resetting the log, try and allocate record space again
        LogpWriteWarningToEvtLog(LM_LOG_EXCEEDS_MAXSIZE, pLog->FileName);
        dwError = LogReset(hLog);
        if (dwError == ERROR_SUCCESS)
        {
            //this time force the file to grow beyond its max size if required
            //this is because we do want to log records greater than the max
            //size of the file
            dwError = LogpEnsureSize(pLog, dwTotalSize, TRUE);

        }        
    }
    if (dwError == ERROR_DISK_FULL)
    {
        //map error
        dwError = ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE;
    }
FnExit:
    LeaveCriticalSection(&pLog->Lock);

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogCommitSize : Exit, returning 0x%1!08lx!\r\n",
        dwError);

    return(dwError);
}

/****
@func       LSN | LogFlush | Ensures that the given LSN is committed to disk. If this
            routine returns successfully, the given LSN is safely stored on disk and
            is guaranteed to survive a system crash.

@parm       HLOG | hLog | Supplies the identifier of the log.

@parm       LSN | MinLsn | Supplies the minimum LSN to be committed to disk.

@rdesc      The last LSN actually committed to disk. This will always be >= the requested MinLsn.
            NULL_LSN on failure

@xref       <f LogWrite>
****/
LSN
LogFlush(
    IN HLOG LogFile,
    IN LSN MinLsn
    )
{
    PLOG        pLog;
    PLOGPAGE    pPage;
    PLOGRECORD  pRecord;
    LSN         Lsn;
    LSN         FlushedLsn = NULL_LSN;
    DWORD       dwBytesWritten;
    DWORD       dwError;

/*
    //SS: avoid clutter in cluster log
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogFlush : Entry LogFile=0x%1!08lx!\r\n",
        LogFile);

*/
    GETLOG(pLog, LogFile);

    EnterCriticalSection(&pLog->Lock);

    
    //if the MinLSN is greater than a record written to the log file
    if (MinLsn > pLog->NextLsn)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }


    //find the first record on the active page
    pPage = pLog->ActivePage;
    pRecord = &pPage->FirstRecord;
    Lsn = MAKELSN(pPage, pRecord);


    //if the lsn till which a flush is requested is on an unflushed page,
    //and there are records on the unflushed page and if the flush till
    // this lsn hasnt occured before, orchestrate a flush
    // SS: this scheme is not perfect though it shouldnt cause unnecessary
    // flushing as the flushing interval is 2 minutes..ideally we want to delay the
    // flush if the writes are in progress.
    if ((MinLsn >= Lsn) && (Lsn < pLog->NextLsn) &&  (MinLsn > pLog->FlushedLsn))
    {
        //there are uncommited records
        ClRtlLogPrint(LOG_NOISE,
            "[LM] LogFlush : pLog=0x%1!08lx! writing the %2!u! bytes for active page at offset 0x%3!08lx!\r\n",
            pLog, pPage->Size, pPage->Offset);

        (pLog->Overlapped).Offset = pPage->Offset;
        (pLog->Overlapped).OffsetHigh = 0;

        if ((dwError = LogpWrite(pLog, pPage, pPage->Size, &dwBytesWritten))
            != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[LM] LogFlush::LogpWrite failed, error=0x%1!08lx!\r\n",
                dwError);
            CL_LOGFAILURE(dwError);
            goto FnExit;
        }
        pLog->FlushedLsn = FlushedLsn = pLog->NextLsn;
    }


/*
    //SS: avoid clutter in cluster log
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogFlush : returning 0x%1!08lx!\r\n",
            pLog->NextLsn);
*/
FnExit:
    LeaveCriticalSection(&pLog->Lock);
    return(FlushedLsn);

}



/****
@func       LSN | LogRead | Reads a log record from the given log.

@parm       IN HLOG | hLog | Supplies the identifier of the log.

@parm       IN LSN | Lsn | The LSN of the record to be read.  If NULL_LSN, the first
            record is read.

@parm       OUT RMID | *ResourceId | Returns the resource ID of the requested log record.

@parm       OUT RMTYPE | *ResourceFlags |Returns the resource flags associated with the
            requested log record.

@parm       OUT TRID | *Transaction | Returns the TRID of the requested log record

@parm       TRID | TrType | Returns the transaction type, start/commit/complete/unit
            transaction.

@parm       OUT PVOID | LogData | Returns the data associated with the log record.

@parm       IN OUT DWORD | *DataSize | Supplies the available size of the LogData buffer.
               Returns the number of bytes of data in the log record

@rdesc      Returns the next LSN in the log file.  On failure, returns NULL_LSN.

@xref       <f LogWrite>
****/
LSN
LogRead(
    IN HLOG LogFile,
    IN LSN Lsn,
    OUT RMID *Resource,
    OUT RMTYPE *ResourceFlags,
    OUT TRID *Transaction,
    OUT TRTYPE *TrType,
    OUT PVOID LogData,
    IN OUT DWORD *DataSize
    )
{
    PLOG        pLog;
    DWORD       PageIndex;
    PLOGPAGE    pPage=NULL;
    BOOL        Success;
    DWORD       dwError=ERROR_SUCCESS;
    LSN         NextLsn=NULL_LSN;
    PLOGRECORD  pRecord;
    DWORD       BytesRead;
    LOGPAGE     Dummy;
    PLOGPAGE    pCurPage;
    
    
    GETLOG(pLog, LogFile);
    CL_ASSERT(pLog->SectorSize == SECTOR_SIZE);
    
    EnterCriticalSection(&pLog->Lock);

    Dummy.Size = SECTOR_SIZE;
    if (Lsn == NULL_LSN) 
    {
        Lsn = pLog->SectorSize + RECORDOFFSETINPAGE(&Dummy, &Dummy.FirstRecord);
    }

    if (Lsn >= pLog->NextLsn) 
    {
        CL_LOGFAILURE(dwError = ERROR_INVALID_PARAMETER);
        goto FnExit;
    }

    //
    // Translate LSN to a page number and offset within the page
    //
    PageIndex = LSNTOPAGE(Lsn);

    //if the record exists in the unflushed page, dont need to read 
    //from the disk
    if (pLog->ActivePage->Offset == PageIndex * pLog->SectorSize)
    {
        //if this data is being read, should we flush the page
        pCurPage = pLog->ActivePage;
        goto GetRecordData;
    }

    pPage = AlignAlloc(SECTOR_SIZE);
    if (pPage == NULL) 
    {
        CL_LOGFAILURE(dwError = ERROR_NOT_ENOUGH_MEMORY);
        goto FnExit;
    }

    pCurPage = pPage;

    //
    // Translate LSN to a page number and offset within the page
    //
    PageIndex = LSNTOPAGE(Lsn);

    pLog->Overlapped.Offset = PageIndex * pLog->SectorSize;
    pLog->Overlapped.OffsetHigh = 0;

    Success = ReadFile(pLog->FileHandle,
                       pCurPage,
                       SECTOR_SIZE,
                       &BytesRead,
                       &pLog->Overlapped);
    if (!Success && (GetLastError() == ERROR_IO_PENDING)) {
        Success = GetOverlappedResult(pLog->FileHandle,
                                      &pLog->Overlapped,
                                      &BytesRead,
                                      TRUE);
    }
    if (!Success)
    {
        CL_UNEXPECTED_ERROR(dwError = GetLastError());
        NextLsn = NULL_LSN;
        goto FnExit;
    }
    
GetRecordData:    
    pRecord = LSNTORECORD(pCurPage, Lsn);
    if (pRecord->Signature != LOGREC_SIG)
    {
        dwError = ERROR_CLUSTERLOG_CORRUPT;
        NextLsn = NULL_LSN;
        goto FnExit;
    }

    *Resource = pRecord->ResourceManager;
    *ResourceFlags = pRecord->Flags;
    *Transaction = pRecord->Transaction;
    *TrType = pRecord->XsactionType;
    if (LogData)
        CopyMemory(LogData, pRecord->Data, *DataSize);
    *DataSize = pRecord->RecordSize - sizeof(LOGRECORD);
    NextLsn = Lsn + pRecord->RecordSize;

    pRecord = LSNTORECORD(pCurPage, NextLsn);
    if (pRecord->ResourceManager == RMPageEnd) 
    {
        //
        // The next log record is the end of page marker
        // Adjust the LSN to be the one at the start of the
        // next page.
        //
        NextLsn = pCurPage->Offset + pCurPage->Size + 
            RECORDOFFSETINPAGE(pCurPage, &pCurPage->FirstRecord);
    }

FnExit:
    LeaveCriticalSection(&pLog->Lock);
    if (dwError !=ERROR_SUCCESS)
        SetLastError(dwError);
    if (pPage) AlignFree(pPage);
    return(NextLsn);

}

/****
@cb         BOOL |(WINAPI *PLOG_SCAN_CALLBACK)| The callback called by LogScan.

@parm       IN PVOID | Context | Supplies the CallbackContext specified to LogScan

@parm       IN LSN | Lsn | Supplies the LSN of the record.

@parm       IN RMID | Resource | Supplies the resource identifier of the log record

@parm       IN TRID | Transaction | Supplies the transaction identifier of the log record

@parm       IN PVOID | LogData | Supplies a pointer to the log data. This is a read-
            only pointer and may be referenced only until the callback returns.

@parm       IN DWORD | DataLength | Supplies the length of the log record.

@rdesc      Returns TRUE to  Continue scan or FALSE to Abort scan.

@xref       <f LogScan>
****/

/****
@func       LSN | LogScan| Initiates a scan of the log. The scan can be done either forwards (redo) or
            backwards (undo).

@parm       IN HLOG | hLog | Supplies the identifier of the log.

@parm       IN LSN | First | Supplies the first LSN to start with. If NULL_LSN is specified,
            the scan begins at the start (for a forward scan) or end (for
            a backwards scan) of the log.

@parm       IN BOOL | ScanForward | Supplies the direction to scan the log in.
                TRUE - specifies a forward (redo) scan
                FALSE - specifies a backwards (undo) scan.

@parm       IN PLOG_SCAN_CALLBACK | CallbackRoutine |Supplies the routine to be called for each log record.

@parm       IN PVOID | CaklbackContext | Supplies an arbitrary context pointer, which will be
            passed to the CallbackRoutine

@rdesc      ERROR_SUCCESS if successful.  Win32 status if something terrible happened.

@xref       <f LogRead> <f (WINAPI *PLOG_SCAN_CALLBACK)>
****/
DWORD
LogScan(
    IN HLOG LogFile,
    IN LSN FirstLsn,
    IN BOOL ScanForward,
    IN PLOG_SCAN_CALLBACK CallbackRoutine,
    IN PVOID CallbackContext
    )
{
    PLOG        pLog;
    PLOGRECORD  pRecord;
    LOGPAGE     Dummy;
    DWORD       dwError=ERROR_SUCCESS;
    PUCHAR      Buffer;
    PUCHAR      pLargeBuffer;
    PLOGPAGE    pPage;
    int         PageIndex;
    int         OldPageIndex;
    LSN         Lsn;
    DWORD       dwBytesRead;


    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogScan::Entry Lsn=0x%1!08lx! ScanForward=%2!u! CallbackRoutine=0x%3!08lx!\r\n",
        FirstLsn, ScanForward, CallbackRoutine);

    GETLOG(pLog, LogFile);
    CL_ASSERT(pLog->SectorSize == SECTOR_SIZE);

    Buffer = AlignAlloc(SECTOR_SIZE);
    if (Buffer == NULL) {
        CL_UNEXPECTED_ERROR( ERROR_NOT_ENOUGH_MEMORY );
    }

    Lsn = FirstLsn;
    if ((!CallbackRoutine) || (Lsn >= pLog->NextLsn))
    {
        //set to invaid param
        dwError = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    if (Lsn == NULL_LSN)
    {
        if (ScanForward)
        {
            Dummy.Size = SECTOR_SIZE;
            //get the Lsn for the first record
            if (Lsn == NULL_LSN)
                Lsn = pLog->SectorSize + RECORDOFFSETINPAGE(&Dummy, &Dummy.FirstRecord);
        }
        else
        {
            //get the Lsn for the last record
            pPage =pLog->ActivePage;
            pRecord = LSNTORECORD(pPage, pLog->NextLsn);
            Lsn = pRecord->PreviousLsn;
        }
    }

    //initialize to -1 so the first page is read
    OldPageIndex = -1;
    pPage = (PLOGPAGE)Buffer;
    //while there are more records that you can read
    //read the page

    //SS: For now we grab the crtitical section for entire duration
    //Might want to change that
    EnterCriticalSection(&pLog->Lock);

    while ((Lsn != NULL_LSN) & (Lsn < pLog->NextLsn))
    {

        //
        // Translate LSN to a page number and offset within the page
        //
        PageIndex = LSNTOPAGE(Lsn);


        if (PageIndex != OldPageIndex)
        {
            //if the record exists in the unflushed page, dont need to read 
            //from the disk
            if (pLog->ActivePage->Offset == PageIndex * pLog->SectorSize)
            {
                //if this data is being read, should we flush the page
                pPage = pLog->ActivePage;
            }
            else
            {
                //read the page
                pLog->Overlapped.Offset = PageIndex * pLog->SectorSize;
                pLog->Overlapped.OffsetHigh = 0;



                dwError = LogpRead(pLog, pPage, pLog->SectorSize, &dwBytesRead);
                //if it is the last page, then set the new page as the active
                //page
                if (dwError)
                {
                    if (dwError == ERROR_HANDLE_EOF)
                    {
                        //not fatal, set this page as current page
                        dwError = ERROR_SUCCESS;
                        //SS: assume that this page has no
                        //records, set the offset
                        //this will be the current page
                        Lsn = NULL_LSN;
                        continue;
                    }
                    else
                        goto FnExitUnlock;
                }
            }
            //read was successful, no need to read the page unless the
            //record falls on a different page
            OldPageIndex = PageIndex;
        }
        pRecord = LSNTORECORD(pPage, Lsn);

        //SS: skip checkpoint records
        //TBD:: what if the user wants to scan checkpoint records
        //as well
        if (pRecord->ResourceManager < RMAny)
        {
            //
            // The next log record is the end of page marker
            // Adjust the LSN to the next one
            //
            Lsn = GETNEXTLSN(pRecord, ScanForward);

            continue;
        }

        //check if the transaction types are the valid ones
        //for application.
        if ((pRecord->XsactionType != TTStartXsaction) && 
            (pRecord->XsactionType != TTCompleteXsaction))
        {
            //Cant assume that the record will fit in a small page
            //even a transaction unit may be large, even though transaction
            //units records are not returned by this call.
            if (pRecord->NumPages < 1)
            {
                Lsn = GETNEXTLSN(pRecord, ScanForward);
            }                
            else
            {
                //if it is a large record it should be followed by
                //an eop page record
                //get the lsn of the eop record
                Lsn = GETNEXTLSN(pRecord,TRUE);

                //get the page index of the page where the eop record resides
                PageIndex = PageIndex + pRecord->NumPages - 1;
                CL_ASSERT(LSNTOPAGE(Lsn) == (DWORD)PageIndex);
                //read the last page for the large record
                (pLog->Overlapped).Offset = PageIndex * pLog->SectorSize;
                (pLog->Overlapped).OffsetHigh = 0;

                ClRtlLogPrint(LOG_NOISE,
                    "[LM] LogScan::reading %1!u! bytes at offset 0x%2!08lx!\r\n",
                    pLog->SectorSize, PageIndex * pLog->SectorSize);

                dwError = LogpRead(pLog, pPage, pLog->SectorSize, &dwBytesRead);
                //if there are no errors, then check the last record
                if (dwError != ERROR_SUCCESS)
                {

                    goto FnExitUnlock;
                }

                //read the page, make sure that the eop record follows the 
                //large record
                pRecord = (PLOGRECORD)((ULONG_PTR) pPage + 
                    (Lsn - (pLog->Overlapped).Offset));
                CL_ASSERT((pRecord->Signature == LOGREC_SIG) && 
                        (pRecord->ResourceManager == RMPageEnd))
                Lsn = GETNEXTLSN(pRecord, TRUE);
            }
            continue;
        }
            
        ClRtlLogPrint(LOG_NOISE,
            "[LM] LogScan::Calling the scancb for Lsn=0x%1!08lx! Trid=%2!u! RecordSize=%3!u!\r\n",
            Lsn, pRecord->Transaction, pRecord->DataSize);

        if (pRecord->NumPages < 1)
        {
             //if the callback requests to stop scan
            if (!(*CallbackRoutine)(CallbackContext, Lsn, pRecord->ResourceManager,
                pRecord->Flags, pRecord->Transaction, pRecord->XsactionType,
                pRecord->Data, pRecord->DataSize))
            break;
            //else go the the next record
            Lsn = GETNEXTLSN(pRecord, ScanForward);

        }
        else
        {
            //for a large record you need to read in the entire data
            pLargeBuffer = AlignAlloc(pRecord->NumPages * SECTOR_SIZE);
            if (pLargeBuffer == NULL) 
            {
                //exit and put something in the eventlog
                dwError = ERROR_NOT_ENOUGH_MEMORY ;
                CL_LOGFAILURE(ERROR_NOT_ENOUGH_MEMORY);
                break;
            }
            //read the pages
            pLog->Overlapped.Offset = PageIndex * pLog->SectorSize;
            pLog->Overlapped.OffsetHigh = 0;

            dwError = LogpRead(pLog, pLargeBuffer, pRecord->NumPages *
                pLog->SectorSize, &dwBytesRead);
            //if it is the last page, then set the new page as the active
            //page
            if (dwError != ERROR_SUCCESS)
            {
                CL_LOGFAILURE(dwError);
                AlignFree(pLargeBuffer);
                break;
            }
            pRecord = LSNTORECORD((PLOGPAGE)pLargeBuffer, Lsn);

            //if the callback requests to stop scan
            if (!(*CallbackRoutine)(CallbackContext, Lsn, pRecord->ResourceManager,
                pRecord->Flags, pRecord->Transaction, pRecord->XsactionType,
                pRecord->Data, pRecord->DataSize))
            {    
                AlignFree(pLargeBuffer);
                break;
            }
            //the next record should be an eop buffer on the last page
            //of the large record, skip that
            Lsn = GETNEXTLSN(pRecord, ScanForward);
            //since this page doesnt begin with the typical page info,
            //you cant validate this
            pRecord = (PLOGRECORD)(
                (ULONG_PTR)(pLargeBuffer + (Lsn - (pLog->Overlapped).Offset)));

            CL_ASSERT(pRecord->ResourceManager == RMPageEnd);

            //go the the next record
            Lsn = GETNEXTLSN(pRecord, ScanForward);
            AlignFree(pLargeBuffer);
        }
    }

FnExitUnlock:
    LeaveCriticalSection(&pLog->Lock);

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogScan::Exit - Returning 0x%1!08lx!\r\n",
        dwError);

FnExit:
    AlignFree(Buffer);
    return(dwError);

}


/****
@func       LSN | LogCheckPoint| Initiates a chk point process in the log.

@parm       IN HLOG | hLog | Supplies the identifier of the log.

@parm       IN BOOL | bAllowReset | Allow the reset of log file to occur
            while checkpointing.  In general, this will be set to TRUE.  Since
            When LogReset() internally invokes LogCheckPoint(), this will be
            set to FALSE.

@parm       IN LPCWSTR | lpszChkPtFile | The checkpt file that should be saved.
            If NULL, the callback function registered for checkpointing is invoked
            to get the checkpoint.

@parm       IN DWORD | dwChkPtSeq | If lpszChkPtFile is not NULL, this should point
            to a valid sequence number associated with the checkpoint.

@rdesc      ERROR_SUCCESS if successful.  Win32 status if something terrible happened.

@comm       The log manager writes the start check point record. Then it invokes the call back to get the checkpoint data.  After writing the
            data to a checkpoint file, it records the lsn of the end checkpoint record in the header.

@xref       <f LogGetLastChkPoint>
****/
DWORD
LogCheckPoint(
    IN HLOG     LogFile,
    IN BOOL     bAllowReset,
    IN LPCWSTR  lpszInChkPtFile,
    IN DWORD    dwChkPtSeq
    )
{
    PLOG            pLog;
    PLOGPAGE        pPage;
    PLOG_HEADER     pLogHeader=NULL;
    DWORD           dwError=ERROR_SUCCESS;
    DWORD           dwTotalSize;
    PLOGRECORD      pLogRecord;
    TRID            ChkPtTransaction,Transaction;
    LSN             Lsn,ChkPtLsn;
    LOG_CHKPTINFO   ChkPtInfo;
    DWORD           dwBytesRead,dwBytesWritten;
    RMID            Resource;
    RMTYPE          RmType;
    BOOL            bMaxFileSizeReached;
    WCHAR           szNewChkPtFile[LOG_MAX_FILENAME_LENGTH];
    DWORD           dwNumPages;
    WCHAR           szPathName[MAX_PATH];
    TRTYPE          TrType;
    DWORD           dwCheckSum = 0;
    DWORD           dwHeaderSum = 0;
    DWORD           dwLen;
    
    GETLOG(pLog, LogFile);
    CL_ASSERT(pLog->SectorSize == SECTOR_SIZE);


    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogCheckPoint entry\r\n");

    ZeroMemory( &ChkPtInfo, sizeof(LOG_CHKPTINFO) );
    
    EnterCriticalSection(&pLog->Lock);
    
#if DBG    
    {
        DWORD dwOldProtect;
        DWORD Status;
        BOOL VPWorked;

        VPWorked = VirtualProtect(pLog->ActivePage, pLog->SectorSize, PAGE_READWRITE, & dwOldProtect);
        Status = GetLastError();
        CL_ASSERT( VPWorked );
    }        
#endif        


    //write the start chkpoint record
    dwTotalSize = sizeof(LOGRECORD) + 7 & ~7;       // round up to qword size
    pPage = LogpAppendPage(pLog, dwTotalSize, &pLogRecord, &bMaxFileSizeReached, &dwNumPages);
    if ((pPage == NULL) && (bMaxFileSizeReached) && (bAllowReset))
    {
        //try and reset the log file
        //the checkpoint will be taken as a part of the reset process
        //if no input checkpoint file is specified
        //SS:note here LogCheckPoint will be called recursively
        LeaveCriticalSection(&pLog->Lock);
        return(LogpReset(pLog, lpszInChkPtFile));
    }

    if (pPage == NULL)
    {
        CL_LOGFAILURE(dwError = GetLastError());
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogCheckPoint: LogpAppendPage failed, error=0x%1!08lx!\r\n",
            dwError);
        goto FnExit;
    }

    CL_ASSERT(((ULONG_PTR)pLogRecord & 0x7) == 0);     // ensure qword alignment
    Lsn = MAKELSN(pPage, pLogRecord);

    pLogRecord->Signature = LOGREC_SIG;
    pLogRecord->ResourceManager = RMBeginChkPt;
    pLogRecord->Transaction = 0;                 
    pLogRecord->XsactionType = TTDontCare;
    pLogRecord->Flags = 0;
    GetSystemTimeAsFileTime(&pLogRecord->Timestamp);
    pLogRecord->NumPages = dwNumPages;
    pLogRecord->DataSize = 0;
    
    //if chkpt is not specifed get one from input checkpoint
    if (!lpszInChkPtFile)
    {
        if (!pLog->pfnGetChkPtCb)
        {
            dwError = ERROR_INVALID_PARAMETER;
            CL_LOGFAILURE(dwError);
            goto FnExit;
        }

        // get a checkpoint
        dwError = DmGetQuorumLogPath(szPathName, sizeof(szPathName));
        if (dwError  != ERROR_SUCCESS)
        {
            dwError = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL,
                "[LM] LogCheckPoint: DmGetQuorumLogPath failed, error=%1!u!\r\n",
                dwError);
            goto FnExit;
        }

        szNewChkPtFile[0]= TEXT('\0');
        dwError = (*(pLog->pfnGetChkPtCb))(szPathName, pLog->pGetChkPtContext, szNewChkPtFile,
            & ChkPtTransaction);
        
        //if the chkptfile is created and if it could not be created because it
        //already existed, then we are set.
        if ((dwError != ERROR_SUCCESS)  &&
            ((dwError != ERROR_ALREADY_EXISTS) || (!szNewChkPtFile[0])))
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[LM] LogCheckPoint: Callback failed to return a checkpoint\r\n");
            CL_LOGCLUSERROR1(LM_CHKPOINT_GETFAILED, pLog->FileName);
            goto FnExit;
        }
    }
    else
    {
        //SS:we trust the application to not write a stale checkpoint
        lstrcpyW(szNewChkPtFile, lpszInChkPtFile);
        ChkPtTransaction = dwChkPtSeq;
    }

    //
    //  Chittur Subbaraman (chitturs) - 1/28/99 
    //
    //  Compute and save the checksum for the checkpoint file
    //
    dwError = MapFileAndCheckSumW( szNewChkPtFile, &dwHeaderSum, &dwCheckSum );
    if ( dwError != CHECKSUM_SUCCESS )  
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogCheckPoint: MapFileAndCheckSumW returned error=%1!u!\r\n",
              dwError);
        goto FnExit;
    }
    ChkPtInfo.dwCheckSum = dwCheckSum;  

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogCheckPoint: ChkPtFile=%1!ls! Chkpt Trid=%2!d! CheckSum=%3!d!\r\n",
        szNewChkPtFile, ChkPtTransaction, dwCheckSum);

    //prepare the chkpt info structure
    ChkPtInfo.ChkPtBeginLsn = Lsn;
    lstrcpyW(ChkPtInfo.szFileName, szNewChkPtFile);

    //
    //  Chittur Subbaraman (chitturs) - 1/29/99
    //
    //  Add a signature at the end of the file name to denote that
    //  a checksum has been taken.
    //
    dwLen = lstrlenW( ChkPtInfo.szFileName );
    if ( ( dwLen + lstrlenW( CHKSUM_SIG ) + 2 ) <= LOG_MAX_FILENAME_LENGTH )
    {
        lstrcpyW( &ChkPtInfo.szFileName[dwLen+1], CHKSUM_SIG );
    }

    dwTotalSize = sizeof(LOGRECORD) + (sizeof(LOG_CHKPTINFO) + 7) & ~7;       // round up to qword size
    //write the endchk point record to the file.
    pPage = LogpAppendPage(pLog, dwTotalSize, &pLogRecord, &bMaxFileSizeReached, &dwNumPages);
    if ((pPage == NULL) && bMaxFileSizeReached && bAllowReset)
    {
        //try and reset the log file
        ClRtlLogPrint(LOG_NOISE,
            "[LM] LogCheckPoint: Maxfilesize exceeded. Calling LogpReset\r\n");
        //the checkpoint will be taken as a part of the reset process
        //if no input checkpoint file is specified
        //SS:note here LogCheckPoint will be called recursively
        LeaveCriticalSection(&pLog->Lock);
        return(LogpReset(pLog, lpszInChkPtFile));
    }

    if (pPage == NULL) {
        CL_LOGFAILURE(dwError = GetLastError());
        goto FnExit;
    }

    CL_ASSERT(((ULONG_PTR)pLogRecord & 0x7) == 0);     // ensure qword alignment
    ChkPtLsn = MAKELSN(pPage, pLogRecord);

    pLogRecord->Signature = LOGREC_SIG;
    pLogRecord->ResourceManager = RMEndChkPt;
    pLogRecord->Transaction = ChkPtTransaction;    // transaction id associated with the chkpt
    pLogRecord->XsactionType = TTDontCare;
    pLogRecord->Flags = 0;
    GetSystemTimeAsFileTime(&pLogRecord->Timestamp);
    pLogRecord->NumPages = dwNumPages;
    pLogRecord->DataSize = sizeof(LOG_CHKPTINFO);
    
    CopyMemory(&pLogRecord->Data, (PBYTE)&ChkPtInfo, sizeof(LOG_CHKPTINFO));



    //flush the log file
    LogFlush(pLog,ChkPtLsn);

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogCheckPoint: EndChkpt written. EndChkPtLsn =0x%1!08lx! ChkPt Seq=%2!d! ChkPt FileName=%3!ls!\r\n",
        ChkPtLsn, ChkPtTransaction, ChkPtInfo.szFileName);

    //read the log header and get the old chk point sequence
    //if null
    pLogHeader = AlignAlloc(pLog->SectorSize);
    if (pLogHeader == NULL)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        CL_LOGFAILURE(dwError);
        ClRtlLogPrint(LOG_UNUSUAL,
                       "[LM] LogCheckPoint: couldn't allocate memory for the header\r\n");
        goto FnExit;
    }


    (pLog->Overlapped).Offset = 0;
    (pLog->Overlapped).OffsetHigh = 0;

    if ((dwError = LogpRead(pLog, pLogHeader, pLog->SectorSize, &dwBytesRead))
        != ERROR_SUCCESS)
    {
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[LM] LogCheckPoint: failed to read the header. Error=0x%1!08lx!\r\n",
                dwError);
            goto FnExit;
        }
    }

    if (dwBytesRead != pLog->SectorSize)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                "[LM] LogCheckPoint: failed to read the complete header\r\n");
        dwError = ERROR_CLUSTERLOG_CORRUPT;
        //SS: should we do an implicit reset here
        goto FnExit;

    }

    Lsn = pLogHeader->LastChkPtLsn;
    //if there was a previous chkpoint and in most cases
    //there should be one,except when the system just comes up
    ChkPtInfo.szFileName[0]= TEXT('\0');
    if (Lsn != NULL_LSN)
    {
        (pLog->Overlapped).Offset = LSNTOPAGE(Lsn) * pLog->SectorSize;
        (pLog->Overlapped).OffsetHigh = 0;

        //get the old check point file name
        dwBytesRead = sizeof(LOG_CHKPTINFO);
        if ((LogRead(pLog, Lsn, &Resource, &RmType, &Transaction, &TrType,
            &ChkPtInfo, &dwBytesRead)) == NULL_LSN)
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[LM] LogCheckPoint: failed to read the chkpt lsn. Error=0x%1!08lx!\r\n",
                dwError);
            goto FnExit;
        }
        if (Resource != RMEndChkPt)
        {
        //SS: this should not happen
#if DBG        
            if (IsDebuggerPresent())
                DebugBreak();
#endif                
            ChkPtInfo.szFileName[0]= TEXT('\0');
            CL_LOGCLUSERROR1(LM_LOG_CORRUPT, pLog->FileName);
        }
    }
    //update the last chkpoint lsn in the header
    pLogHeader->LastChkPtLsn = ChkPtLsn;

    //write the header
    (pLog->Overlapped).Offset = 0;
    (pLog->Overlapped).OffsetHigh = 0;

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpCheckpoint : Writing %1!u! bytes to disk at offset 0x%2!08lx!\r\n",
        pLog->SectorSize, pLog->Overlapped.Offset);

    if ((dwError = LogpWrite(pLog, pLogHeader, pLog->SectorSize, &dwBytesWritten))
        != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                "[LM] LogCheckPoint: failed to update header after checkpointing, Error=0x%1!08lx!\r\n",
                dwError);
        CL_LOGFAILURE(dwError);
        goto FnExit;
    }

    //flush the log file.

    FlushFileBuffers(pLog->FileHandle);

    //delete the old checkpoint file
    //the old checkpoint file may be the same as the current one, dont delete it, if so
    if (Lsn && (ChkPtInfo.szFileName[0]) &&
        (lstrcmpiW(szNewChkPtFile, ChkPtInfo.szFileName)))
        DeleteFile((LPCTSTR)(ChkPtInfo.szFileName));

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogCheckPoint Exit\r\n");


FnExit:
#if DBG    
    {
        DWORD dwOldProtect;
        DWORD Status;
        BOOL VPWorked;

        VPWorked = VirtualProtect(pLog->ActivePage, pLog->SectorSize, PAGE_READONLY, & dwOldProtect);
        Status = GetLastError();
        CL_ASSERT( VPWorked );
    }        
#endif        

    if (pLogHeader != NULL) {
        AlignFree(pLogHeader);
    }
    LeaveCriticalSection(&pLog->Lock);
    return(dwError);
}


/****
@func       LSN | LogReset| Resets the log file and takes a  new checkpoint.

@parm       IN HLOG | hLog | Supplies the identifier of the log.

@rdesc      ERROR_SUCCESS if successful.  Win32 status if something terrible happened.

@comm       The log manager creates a new log, takes a checkpoint and renames the old log file.

@xref       <f LogCheckPoint>
****/
DWORD
LogReset(
    IN HLOG LogFile
    )
{
    PLOG        pLog;
    DWORD       dwError;

    GETLOG(pLog, LogFile);
    CL_ASSERT(pLog->SectorSize == SECTOR_SIZE);

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogReset entry...\r\n");

    dwError = LogpReset (pLog, NULL);
    
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogReset exit, returning 0x%1!08lx!\r\n",
        dwError);
            
    return(dwError);
}


/****
@func       DWORD | LogGetLastChkPoint| This is a callback that is called on
            change of state on quorum resource.

@parm       HLOG | LogFile | A pointer to a DMLOGRECORD structure.
@parm       PVOID | szChkPtFileName | The name of the checkpoint file.
@parm       TRID | *pTransaction | The transaction id associated with the
            checkpoint.
@parm       LSN | *pChkPtLsn | The LSN of the start checkpoint record.

@rdesc      Returns a result code. ERROR_SUCCESS on success.  To find transactions,
            past this checkpoint, the application must scan from the LSN of the start
            checkpoint record.

@xref
****/
DWORD LogGetLastChkPoint(
    IN HLOG     LogFile,
    OUT LPWSTR   szChkPtFileName,
    OUT TRID    *pTransactionId,
    OUT LSN     *pChkPtLsn)
{
    PLOG_HEADER     pLogHeader=NULL;
    PLOG            pLog;
    DWORD           dwError = ERROR_SUCCESS;
    DWORD           dwBytesRead;
    RMID            Resource;
    RMTYPE          RmType;
    TRTYPE          TrType;
    LOG_CHKPTINFO   ChkPtInfo;
    DWORD           dwCheckSum = 0;
    DWORD           dwHeaderSum = 0;
    DWORD           dwLen;

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogGetLastChkPoint:: Entry\r\n");


    GETLOG(pLog, LogFile);
    CL_ASSERT(pLog->SectorSize == SECTOR_SIZE);


    EnterCriticalSection(&pLog->Lock);
    if (!szChkPtFileName || !pTransactionId || !pChkPtLsn)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }


    *pTransactionId = 0;
    *pChkPtLsn = NULL_LSN;

    pLogHeader = AlignAlloc(pLog->SectorSize);
    if (pLogHeader == NULL) {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        CL_LOGFAILURE(dwError);
        goto FnExit;
    }

    //read the header
    (pLog->Overlapped).Offset = 0;
    (pLog->Overlapped).OffsetHigh = 0;

    if (LogpRead(LogFile, pLogHeader, pLog->SectorSize, &dwBytesRead) != ERROR_SUCCESS)
    {
        dwError = ERROR_CLUSTERLOG_CORRUPT;
        goto FnExit;
    }

    if (dwBytesRead != pLog->SectorSize)
    {
        dwError = ERROR_CLUSTERLOG_CORRUPT;
        CL_LOGCLUSERROR1(LM_LOG_CORRUPT, pLog->FileName);
        goto FnExit;

    }
    //validate the header
    if (!ISVALIDHEADER((*pLogHeader)))
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogGetLastChkPoint::the file header is corrupt.\r\n");
        dwError = ERROR_CLUSTERLOG_CORRUPT;
        CL_LOGCLUSERROR1(LM_LOG_CORRUPT, pLog->FileName);
        goto FnExit;
    }

    //read the last Chkpoint end record
    if (pLogHeader->LastChkPtLsn != NULL_LSN)
    {
        dwBytesRead = sizeof(LOG_CHKPTINFO);
        if ((LogRead(LogFile , pLogHeader->LastChkPtLsn, &Resource, &RmType, 
            pTransactionId, &TrType, &ChkPtInfo, &dwBytesRead)) == NULL_LSN)
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[LM] LogGetLastChkPoint::LogRead for chkpt lsn 0x%1!08lx! failed\r\n",
                pLogHeader->LastChkPtLsn);
            dwError = GetLastError();
            goto FnExit;
        }
        if (Resource != RMEndChkPt)
        {
        //SS: This should not happen
#if DBG        
            if (IsDebuggerPresent())
                DebugBreak();
#endif                
            dwError = ERROR_CLUSTERLOG_CORRUPT;
            CL_LOGFAILURE(dwError);
            CL_LOGCLUSERROR1(LM_LOG_CORRUPT, pLog->FileName);
            goto FnExit;
        }
        //
        //  Chittur Subbaraman (chitturs) - 1/28/99
        //
        //  Check if the checkpoint file itself got corrupted. But first
        //  make sure that a checksum was indeed recorded.
        //
        dwLen = lstrlenW( ChkPtInfo.szFileName );
        if ( ( dwLen + lstrlenW( CHKSUM_SIG ) + 2 <= LOG_MAX_FILENAME_LENGTH ) &&
             ( lstrcmpW( &ChkPtInfo.szFileName[dwLen+1], CHKSUM_SIG ) == 0 ) )
        {
            dwError = MapFileAndCheckSumW( ChkPtInfo.szFileName, &dwHeaderSum, &dwCheckSum );
            if ( ( dwError != CHECKSUM_SUCCESS ) ||
                 ( dwCheckSum != ChkPtInfo.dwCheckSum ) ||
                 ( dwCheckSum == 0 ) )
            {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[LM] LogGetLastChkPoint - MapFileAndCheckSumW returned error=%1!u!\r\n",
                    dwError);
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[LM] LogGetLastChkPoint - Stored CheckSum=%1!u!, Retrieved CheckSum=%2!u!\r\n",
                    ChkPtInfo.dwCheckSum,
                    dwCheckSum);
                CL_LOGCLUSERROR1( LM_LOG_CHKPOINT_NOT_FOUND, ChkPtInfo.szFileName );
                dwError = ERROR_CLUSTERLOG_CORRUPT;
                goto FnExit;
            }
        }
   
        lstrcpyW(szChkPtFileName, ChkPtInfo.szFileName);
        *pChkPtLsn = ChkPtInfo.ChkPtBeginLsn;
        ClRtlLogPrint(LOG_NOISE,
                "[LM] LogGetLastChkPoint: ChkPt File %1!ls! ChkPtSeq=%2!d! ChkPtLsn=0x%3!08lx! Checksum=%4!d!\r\n",
                szChkPtFileName, *pTransactionId, *pChkPtLsn, dwCheckSum);
    }
    else
    {
        dwError = ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND;
        CL_LOGCLUSWARNING1(LM_LOG_CHKPOINT_NOT_FOUND, pLog->FileName);
    }

FnExit:
    if (pLogHeader) AlignFree(pLogHeader);
    LeaveCriticalSection(&pLog->Lock);

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogGetLastChkPoint exit, returning 0x%1!08lx!\r\n",
        dwError);

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\lm\xsaction.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    xsaction.c

Abstract:

    Provides basic xscational services for cluster logging.

Author:

    Sunita Shrivastava (sunitas) 17-Mar-1997

Revision History:
--*/
#include "service.h"
#include "lmp.h"


/****
@doc    EXTERNAL INTERFACES CLUSSVC LM
****/

/****
@func       HXSACTION | LogStartXsaction| Write a start transaction record to
            the log.

@parm       IN HLOG | hLog | Supplies the handle to the log.

@parm       IN TRID | TrId | Supplies the transaction id.

@parm       IN RMID | ResourceId | The resource id that identifies the
            resource manager.

@parm       IN RMTYPE | ResourceFlags | A dword of flags that the resource 
            manager may use to store any data it wants with this record.

@rdesc      Returns a handle suitable for use in subsequent log calls.  
            NUll in case failure. Call GetLastError() to get the error.

@xref       <f LogCommitXsaction> <f LogAbortXsaction>
****/
HXSACTION
LogStartXsaction(
    IN HLOG     hLog,
    IN TRID     TrId,
    IN RMID     ResourceId,
    IN RMTYPE   ResourceFlags
)
{
    PLOG        pLog;
    DWORD       dwError=ERROR_SUCCESS;
    LSN         Lsn = NULL_LSN;
    PLOGRECORD  pLogRecord;
    DWORD       dwNumPages;
    PLOGPAGE    pPage;
    DWORD       dwTotalSize;
    BOOL        bMaxFileSizeReached;
    PXSACTION   pXsaction = NULL;

    
    GETLOG(pLog, hLog);

    //write the record, dont allow resets to happen
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogStartXsaction : Entry TrId=%1!u! RmId=%2!u! RmType = %3!u!\r\n",
        TrId, ResourceId, ResourceFlags);

    EnterCriticalSection(&pLog->Lock);

    pXsaction = (PXSACTION)LocalAlloc(LMEM_FIXED, sizeof(XSACTION));
    if (!pXsaction)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }   
#if DBG    
    {
        DWORD dwOldProtect;
        DWORD Status;
        BOOL VPWorked;

        VPWorked = VirtualProtect(pLog->ActivePage, pLog->SectorSize, PAGE_READWRITE, &dwOldProtect);
        Status = GetLastError();
        CL_ASSERT( VPWorked );
    }        
#endif        
    //reset the file
    dwError = LogReset(hLog);

    if (dwError != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_NOISE,
            "[LM] LogStartXsaction : LogReset failed\r\n");
        goto FnExit;            
    }

#if DBG    
    {
        DWORD dwOldProtect;
        DWORD Status;
        BOOL VPWorked;

        VPWorked = VirtualProtect(pLog->ActivePage, pLog->SectorSize, PAGE_READWRITE, &dwOldProtect);
        Status = GetLastError();
        CL_ASSERT( VPWorked );
    }        
#endif        


    CL_ASSERT(ResourceId > RMAny);     // reserved for logger's use

    dwTotalSize = sizeof(LOGRECORD) +  7 & ~7;       // round up to qword size


    pPage = LogpAppendPage(pLog, dwTotalSize, &pLogRecord, &bMaxFileSizeReached, &dwNumPages);
    //we just reset the file, if it cant take the new startxsaction
    //record, something is awfully wrong !!!
    if (pPage == NULL)
    {
        dwError = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
            "[LM] LogStartXsaction : LogpAppendPage failed.\r\n");
        goto FnExit;
    }


    CL_ASSERT(((ULONG_PTR)pLogRecord & 0x7) == 0);     // ensure qword alignment
    Lsn = MAKELSN(pPage, pLogRecord);

    //
    // Fill in log record.
    //
    pLogRecord->Signature = LOGREC_SIG;
    pLogRecord->ResourceManager = ResourceId;
    pLogRecord->Transaction = TrId;
    pLogRecord->XsactionType = TTStartXsaction;
    pLogRecord->Flags = ResourceFlags;
    GetSystemTimeAsFileTime(&pLogRecord->Timestamp);
    pLogRecord->NumPages = dwNumPages;
    pLogRecord->DataSize = 0;

    pXsaction->XsactionSig = XSACTION_SIG;
    pXsaction->TrId = TrId;
    pXsaction->StartLsn = Lsn;
    pXsaction->RmId = ResourceId;
    
FnExit:
#if DBG    
    {
        DWORD dwOldProtect;
        DWORD Status;
        BOOL VPWorked;

        VPWorked = VirtualProtect(pLog->ActivePage, pLog->SectorSize, PAGE_READONLY, & dwOldProtect);
        Status = GetLastError();
        CL_ASSERT( VPWorked );
    }        
#endif        

    if (dwError != ERROR_SUCCESS)
    {
        if (pXsaction) {
            LocalFree(pXsaction);
            pXsaction = NULL;
        }
        SetLastError(dwError);
    }

    
    LeaveCriticalSection(&pLog->Lock);
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogStartXsaction : Exit returning=0x%1!08lx!\r\n",
        Lsn);

    return((HXSACTION)pXsaction);
}

/****
@func       LSN | LogWriteXsaction| Write a transaction unit record to
            the log.

@parm       IN HLOG | hLog | Supplies the handle to the log.

@parm       IN HXSACTION | hXsaction | Supplies the handle to the transaction.

@parm       IN RMTYPE | ResourceFlags | A dword of flags that the resource 
            manager may use to store any data it wants with this record.

@parm       IN PVOID | LogData | Supplies a pointer to the data to be logged.

@parm       DWORD | DataSize | Supplies the number of bytes of data pointed to by LogData

@rdesc      The LSN of the log record that was created. NULL_LSN if something terrible happened.
            GetLastError() will provide the error code.

@comm       This should use a transaction handle obtained from LogStartXsaction. This
            call is used to write the parts of a transaction to the quorum log.
            
@xref       <f LogStartXsaction>
****/
LSN
LogWriteXsaction(
    IN HLOG         hLog,
    IN HXSACTION    hXsaction,
    IN RMTYPE       ResourceFlags,
    IN PVOID        pLogData,
    IN DWORD        dwDataSize)
{
    PLOG        pLog;
    DWORD       dwError=ERROR_SUCCESS;
    LSN         Lsn = NULL_LSN;
    PLOGRECORD  pLogRecord;
    DWORD       dwNumPages;
    PLOGPAGE    pPage;
    DWORD       dwTotalSize;
    BOOL        bMaxFileSizeReached;
    PXSACTION   pXsaction = NULL;

    GETLOG(pLog, hLog);

    GETXSACTION(pXsaction, hXsaction);
    
    //write the record, dont allow resets to happen
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogWriteXsaction : Entry TrId=%1!u! RmId=%2!u! RmType = %3!u!\r\n",
        pXsaction->TrId, pXsaction->RmId, ResourceFlags);

#if DBG    
    {
        DWORD dwOldProtect;
        DWORD Status;
        BOOL VPWorked;

        VPWorked = VirtualProtect(pLog->ActivePage, pLog->SectorSize, PAGE_READWRITE, &dwOldProtect);
        Status = GetLastError();
        CL_ASSERT( VPWorked );
    }        
#endif        


    CL_ASSERT(pXsaction->RmId > RMAny);     // reserved for logger's use

    dwTotalSize = sizeof(LOGRECORD) + (dwDataSize+ 7) & ~7;       // round up to qword size

    EnterCriticalSection(&pLog->Lock);

    pPage = LogpAppendPage(pLog, dwTotalSize, &pLogRecord, &bMaxFileSizeReached, &dwNumPages);
    //we reset the file in logstartxsaction, if it cant take the new startxsaction
    //record, something is awfully wrong !!!
    if (pPage == NULL)
    {
        dwError = GetLastError();
        //assert if a complete local xsaction extends the log beyond its max size
        CL_ASSERT( dwError != ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE);
        ClRtlLogPrint(LOG_NOISE,
            "[LM] LogWriteXsaction : LogpAppendPage failed.\r\n");
        goto FnExit;
    }


    CL_ASSERT(((ULONG_PTR)pLogRecord & 0x7) == 0);     // ensure qword alignment
    Lsn = MAKELSN(pPage, pLogRecord);

    //
    // Fill in log record.
    //
    pLogRecord->Signature = LOGREC_SIG;
    pLogRecord->ResourceManager = pXsaction->RmId;
    pLogRecord->Transaction = pXsaction->TrId;
    pLogRecord->XsactionType = TTXsactionUnit;
    pLogRecord->Flags = ResourceFlags;
    GetSystemTimeAsFileTime(&pLogRecord->Timestamp);
    pLogRecord->NumPages = dwNumPages;
    pLogRecord->DataSize = dwDataSize;
    if (dwNumPages < 1)
        CopyMemory(&pLogRecord->Data, pLogData, dwDataSize);
    else
    {
        if (LogpWriteLargeRecordData(pLog, pLogRecord, pLogData, dwDataSize) 
            != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_NOISE,
                "[LM] LogWriteXsaction : LogpWriteLargeRecordData failed. Lsn=0x%1!08lx!\r\n",
                Lsn);
            Lsn = NULL_LSN;                
        }
    }

FnExit:
#if DBG    
    {
        DWORD dwOldProtect;
        DWORD Status;
        BOOL VPWorked;

        VPWorked = VirtualProtect(pLog->ActivePage, pLog->SectorSize, PAGE_READONLY, & dwOldProtect);
        Status = GetLastError();
        CL_ASSERT( VPWorked );
    }        
#endif        

    if (dwError != ERROR_SUCCESS)
        SetLastError(dwError);
    LeaveCriticalSection(&pLog->Lock);
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogWriteXsaction : Exit returning=0x%1!08lx!\r\n",
        Lsn);

    return(Lsn);

    
    
}


/****
@func       DWORD | LogCommitXsaction | This writes the commit transaction
            record to the log and flushes it.

@parm       IN HLOG | hLog | Supplies the handle to the log.

@parm       IN TRID | TrId | Supplies the transaction id.

@parm       IN RMID | ResourceId | The resource id that identifies the
            resource manager.

@parm       IN RMTYPE | ResourceFlags | A dword of flags that the resource 
            manager may use to store any data it wants with this record.

@comm       A commit record is written to the quorum log. The hXsaction handle 
            is invalidated at this point and should not be used after this call has
            been made.  The commit is record is used to identify committed transactions
            during rollback.
            
@rdesc      ERROR_SUCCESS if successful. Win32 error code if something horrible happened.

@xref       <f LogStartXsaction>
****/
DWORD WINAPI LogCommitXsaction(
    IN HLOG         hLog,
    IN HXSACTION    hXsaction,
    IN RMTYPE       ResourceFlags)
{
    DWORD       dwError = ERROR_SUCCESS;
    LSN         Lsn;
    PXSACTION   pXsaction;

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogCommitXsaction : Entry, hXsaction=0x%1!08lx!\r\n",
        hXsaction);

    GETXSACTION(pXsaction, hXsaction);
    
    Lsn = LogWrite(hLog, pXsaction->TrId, TTCommitXsaction, 
        pXsaction->RmId, ResourceFlags, NULL, 0);
        
    if (Lsn == NULL_LSN)
    {
        dwError = GetLastError();
        goto FnExit; 
    }

FnExit:  
    //free up the transation memory
    ZeroMemory(pXsaction, sizeof(XSACTION));                   // just in case somebody tries to
    LocalFree(pXsaction);

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogCommitXsaction : Exit, dwError=0x%1!08lx!\r\n",
        dwError);
    return(dwError);        
}

/****
@func       DWORD | LogAbortXsaction | Marks a given transaction as aborted in the 
            quorum log file.

@parm       IN HLOG | hLog | Supplies the handle to the log.

@parm       IN HXSACTION | hXsaction | Supplies the handle to the transaction.

@parm       IN RMTYPE | ResourceFlags | A dword of flags that the resource 
            manager may use to store any data it wants with this record.

@comm       An abort transaction is written to the quorum log.  This is used in 
            identifying aborted transactions during roll back. The hXsaction 
            handle is invalidated at this point and should not be used after this.

@rdesc      ERROR_SUCCESS if successful. Win32 error code if something horrible happened.

@xref       <f LogStartXsaction> <f LogCommitXsaction>
****/
DWORD
LogAbortXsaction(
    IN HLOG         hLog,
    IN HXSACTION    hXsaction,
    IN RMTYPE       ResourceFlags
    )
{
    PXSACTION   pXsaction;
    LSN         Lsn;
    DWORD       dwError = ERROR_SUCCESS;
    
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogAbortXsaction : Entry, hXsaction=0x%1!08lx!\r\n",
        hXsaction);

    GETXSACTION(pXsaction, hXsaction);

    Lsn = LogWrite(hLog, pXsaction->TrId, TTAbortXsaction, pXsaction->RmId,
            ResourceFlags, NULL, 0);

    if (Lsn == NULL_LSN)
    {
        dwError = GetLastError();
        goto FnExit;        
    }


FnExit:
    ZeroMemory(pXsaction, sizeof(XSACTION));                   // just in case somebody tries to
    LocalFree(pXsaction);

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogAbortXsaction : Exit, returning, dwError=0x%1!08lx!\r\n",
        dwError);
    return(dwError);
}

/****
@func       LSN | LogFindXsactionState | This fuctions scans the record and finds
            the state of a given transaction.

@parm       IN HLOG | hLog | Supplies the identifier of the log.

@parm       IN LSN | StartXsactionLsn | The LSN of the start transaction record.

@parm       IN TRID | XsactionId | The transaction id of the transaction.

@parm       OUT TRSTATE | *pXsactionState | The state of the transaction.

@comm       Transaction state is set to XsactionCommitted, XsactionAborted or XsactionUnknown.
            depending on whether a commit record, or abort record or no record is found
            for this record in the log.
            
@rdesc      ERROR_SUCCESS, else returns the error code if something horrible happens.

@xref       <f LogScanXsaction> 
****/
DWORD
LogFindXsactionState(
   IN HLOG      hLog,
   IN LSN       StartXsactionLsn,
   IN TRID      XsactionId,
   OUT TRSTATE *pXsactionState)
{
    PLOG        pLog;
    PLOGRECORD  pRecord, pEopRecord;
    DWORD       dwError = ERROR_SUCCESS;
    int         PageIndex, OldPageIndex;
    RMID        Resource;
    TRID        TrId;
    TRTYPE      TrType;
    LSN         Lsn, EopLsn;
    PLOGPAGE    pPage = NULL,pLargeBuffer = NULL;
    DWORD       dwBytesRead;
    RMTYPE      ResourceFlags;
    BOOL        bFound = FALSE;
    
    GETLOG(pLog, hLog);

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogWrite : Entry StartXLsn=0x%1!08lx! StartXId=%2!u!\r\n",
        StartXsactionLsn, XsactionId);

    EnterCriticalSection(&pLog->Lock);


    if (StartXsactionLsn >= pLog->NextLsn)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    //read this record
    dwBytesRead = 0;
    if ((Lsn = LogRead( hLog, StartXsactionLsn, &Resource, &ResourceFlags, &TrId, &TrType,
        NULL, &dwBytesRead)) == NULL_LSN)
    {
        dwError = GetLastError();
        goto FnExit;
    }

    //check the record
    if ((TrType != TTStartXsaction) ||
        (TrId != XsactionId))
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }


    pPage = (PLOGPAGE)AlignAlloc(SECTOR_SIZE);
    if (pPage == NULL) {
        CL_UNEXPECTED_ERROR( ERROR_NOT_ENOUGH_MEMORY );
    }

    //Lsn is now set to the next Lsn after the start
    //initialize this to -1 so that the first page is always read
    OldPageIndex = -1;
    while (Lsn < pLog->NextLsn && !bFound)
    {
        //
        // Scan From Next record to find either the commit or abort record
        //
        PageIndex = LSNTOPAGE(Lsn);


        if (PageIndex != OldPageIndex)
        {
            //read the page
            pLog->Overlapped.Offset = PageIndex * pLog->SectorSize;
            pLog->Overlapped.OffsetHigh = 0;

            dwError = LogpRead(pLog, pPage, pLog->SectorSize, &dwBytesRead);
            if (dwError)
            {
                goto FnExit;
            }
            //read was successful, no need to read the page unless the
            //record falls on a different page
            OldPageIndex = PageIndex;
        }
        pRecord = LSNTORECORD(pPage, Lsn);

        //skip other log management records     
        //these are small records by definition
        if (pRecord->ResourceManager < RMAny)
        {
            Lsn = GETNEXTLSN(pRecord, TRUE);
            continue;
        }
        //if the transaction id is the same, check the xsaction type
        if (pRecord->Transaction == XsactionId)
        {
            if ((pRecord->XsactionType == TTCommitXsaction) ||
                (pRecord->XsactionType == TTStartXsaction))
            {
                bFound = TRUE;
                continue;
            }
        }
        //handle large records
        if (pRecord->NumPages > 0)
        {
            EopLsn = GETNEXTLSN(pRecord,TRUE);
            
            PageIndex = LSNTOPAGE(EopLsn);

            //read the page
            pLog->Overlapped.Offset = PageIndex * pLog->SectorSize;
            pLog->Overlapped.OffsetHigh = 0;

            dwError = LogpRead(pLog, pPage, pLog->SectorSize, &dwBytesRead);
            if (dwError)
            {
                goto FnExit;
            }
            OldPageIndex = PageIndex;
            pEopRecord = (PLOGRECORD)((ULONG_PTR) pPage + 
                (EopLsn - (pLog->Overlapped).Offset));
            //move to the next page 
            Lsn = GETNEXTLSN(pEopRecord, TRUE);
        }
        else
        {
            Lsn = GETNEXTLSN(pRecord, TRUE);
        }            
    }

    if (bFound)
    {
        if (pRecord->XsactionType == TTCommitXsaction)
            *pXsactionState = XsactionCommitted;
        else
            *pXsactionState = XsactionAborted;
    }
    else
    {
        *pXsactionState = XsactionUnknown;
    }

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogFindXsactionState : Exit,State=%1!u!\r\n",
        *pXsactionState);

FnExit:
    LeaveCriticalSection(&pLog->Lock);
    if (pPage) AlignFree(pPage);
    return(dwError);
}


/****
@func       LSN | LogScanXsaction | This fuctions scans the multiple units
            of a transaction.

@parm       IN HLOG | hLog | Supplies the identifier of the log.

@parm       IN LSN | StartXsacionLsn | The LSN of the start transaction record.

@parm       IN TRID | XsactionId | The transaction id of the transaction.

@parm       IN PLOG_SCANXSACTION_CALLBACK | CallbackRoutine | The routine to call
            for every unit of a transaction.
            
@parm       IN PVOID | pContext | The context to be passed to state of the transaction.

@comm       Stops enumerating the transaction units if the callback function returns
            FALSE, or if the abort or commit record for this transaction is found or
            if the next transacion is found.

@rdesc      ERROR_SUCCESS if the state is found, else returns the error code.

@xref       <f LogFindXsactionState> 
****/
DWORD
LogScanXsaction(
    IN HLOG     hLog,
    IN LSN      StartXsactionLsn,
    IN TRID     XsactionId,
    IN PLOG_SCANXSACTION_CALLBACK CallbackRoutine,
    IN PVOID    pContext)
{
    PLOG        pLog;
    PLOGRECORD  pRecord;
    DWORD       dwError = ERROR_SUCCESS;
    int         PageIndex, OldPageIndex;
    RMID        Resource;
    TRID        TrId;
    TRTYPE      TrType;
    LSN         Lsn;
    PLOGPAGE    pPage = NULL;
    PUCHAR      pLargeBuffer;
    DWORD       dwBytesRead;
    RMTYPE      ResourceFlags;
    
    GETLOG(pLog, hLog);

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogScanXsaction : Entry StartXLsn=0x%1!08lx! StartXId=%2!u!\r\n",
        StartXsactionLsn, XsactionId);


    Lsn = StartXsactionLsn;
    if (Lsn >= pLog->NextLsn)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    //read this record
    dwBytesRead = 0;
    if (LogRead( hLog, Lsn, &Resource, &ResourceFlags, &TrId, &TrType,
        NULL, &dwBytesRead) == NULL_LSN)
    {
        dwError = GetLastError();
        goto FnExit;
    }

    //check the record
    if ((TrType != TTStartXsaction) ||
        (TrId != XsactionId))
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }


    pPage = (PLOGPAGE)AlignAlloc(SECTOR_SIZE);
    if (pPage == NULL) {
        CL_UNEXPECTED_ERROR( ERROR_NOT_ENOUGH_MEMORY );
    }

    //initialize this to -1 so that the first page is always read
    OldPageIndex = -1;
    while (Lsn < pLog->NextLsn)
    {
        //
        // Scan From Next record to find either the commit or abort record
        //
        PageIndex = LSNTOPAGE(Lsn);


        if (PageIndex != OldPageIndex)
        {
            //read the page
            pLog->Overlapped.Offset = PageIndex * pLog->SectorSize;
            pLog->Overlapped.OffsetHigh = 0;

            dwError = LogpRead(pLog, pPage, pLog->SectorSize, &dwBytesRead);
            if (dwError)
            {
                goto FnExit;
            }
            //read was successful, no need to read the page unless the
            //record falls on a different page
            OldPageIndex = PageIndex;
        }
        pRecord = LSNTORECORD(pPage, Lsn);

        //skip other log management records     
        if (pRecord->ResourceManager < RMAny)
        {
            Lsn = GETNEXTLSN(pRecord, TRUE);
            continue;
        }

        //stop if next transaction record is encountered
        if (pRecord->Transaction > XsactionId) 
        {
            break;
        } 
        //stop when a commit or abort record is found
        if ((pRecord->Transaction == XsactionId) &&
            ((pRecord->XsactionType == TTCommitXsaction) || 
            (pRecord->XsactionType == TTAbortXsaction)))
        {
            break;
        }

        //handle large records
        if (pRecord->NumPages > 0)
        {
            //if the transaction id is the same
            if ((pRecord->Transaction == XsactionId) && 
                (pRecord->XsactionType == TTXsactionUnit))
            {
                //read the whole record
                //for a large record you need to read in the entire data
                pLargeBuffer = AlignAlloc(pRecord->NumPages * SECTOR_SIZE);
                if (pLargeBuffer == NULL) 
                {
                    dwError = ERROR_NOT_ENOUGH_MEMORY ;
                    CL_LOGFAILURE(ERROR_NOT_ENOUGH_MEMORY);
                    break;
                }
                //read the pages
                pLog->Overlapped.Offset = PageIndex * pLog->SectorSize;
                pLog->Overlapped.OffsetHigh = 0;

                dwError = LogpRead(pLog, pLargeBuffer, pRecord->NumPages *
                    pLog->SectorSize, &dwBytesRead);
                //if it is the last page, then set the new page as the active
                //page
                if (dwError != ERROR_SUCCESS)
                {
                    CL_LOGFAILURE(dwError);
                    AlignFree(pLargeBuffer);
                    break;
                }
                pRecord = LSNTORECORD((PLOGPAGE)pLargeBuffer, Lsn);

                ClRtlLogPrint(LOG_NOISE,
                "[LM] LogScanXsaction::Calling the scancb for Lsn=0x%1!08lx! Trid=%2!u! RecordSize=%3!u!\r\n",
                    Lsn, pRecord->Transaction, pRecord->DataSize);

                //if the callback requests to stop scan
                if (!(*CallbackRoutine)(pContext, Lsn, pRecord->ResourceManager,
                    pRecord->Flags, pRecord->Transaction,
                    pRecord->Data, pRecord->DataSize))
                {    
                    AlignFree(pLargeBuffer);
                    break;
                }
            }
            //read the last page of the large record and advance
            Lsn = GETNEXTLSN(pRecord,TRUE);

            AlignFree(pLargeBuffer);
            PageIndex = LSNTOPAGE(Lsn);

            //read the page
            pLog->Overlapped.Offset = PageIndex * pLog->SectorSize;
            pLog->Overlapped.OffsetHigh = 0;

            dwError = LogpRead(pLog, pPage, pLog->SectorSize, &dwBytesRead);
            if (dwError)
            {
                goto FnExit;
            }
            OldPageIndex = PageIndex;
            pRecord = (PLOGRECORD)((ULONG_PTR) pPage + 
                (Lsn - (pLog->Overlapped).Offset));
            CL_ASSERT(pRecord->ResourceManager == RMPageEnd);
            //move to the next page 
            Lsn = GETNEXTLSN(pRecord, TRUE);

        }
        else
        {
            if ((pRecord->Transaction == XsactionId) && 
                (pRecord->XsactionType == TTXsactionUnit))
            {
                ClRtlLogPrint(LOG_NOISE,
                    "[LM] LogScanXsaction: Calling the scancb for Lsn=0x%1!08lx! Trid=%2!u! RecordSize=%3!u!\r\n",
                    Lsn, pRecord->Transaction, pRecord->DataSize);

                //call the callback
                if (!(*CallbackRoutine)(pContext, Lsn, pRecord->ResourceManager,
                    pRecord->Flags, pRecord->Transaction, 
                    pRecord->Data, pRecord->DataSize))
                {    
                    break;
                }
  
            }                

            Lsn = GETNEXTLSN(pRecord, TRUE);
        }            
    }


FnExit:
    if (pPage) AlignFree(pPage);
    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\mm\jrgpos.h ===
#ifndef  _JRGPOS_H_
#define  _JRGPOS_H_

#ifdef __TANDEM
#pragma columns 79
#pragma page "jrgpos.h - T9050 - OS-specific declarations for Regroup Module"
#endif

/* @@@@@@ START COPYRIGHT @@@@@@
**  Tandem Confidential:  Need to Know only
**  Copyright (c) 1995, Tandem Computers Incorporated
**  Protected as an unpublished work.
**  All Rights Reserved.
**
**  The computer program listings, specifications, and documentation
**  herein are the property of Tandem Computers Incorporated and shall
**  not be reproduced, copied, disclosed, or used in whole or in part
**  for any reason without the prior express written permission of
**  Tandem Computers Incorporated.
**
** @@@@@@ END COPYRIGHT @@@@@@
**/

/*---------------------------------------------------------------------------
 * This file (jrgpos.h) contains OS-specific declarations used by Regroup.
 * Use appropriate #includes to pull in declarations from other native
 * OS files.
 *---------------------------------------------------------------------------*/

#ifdef __cplusplus
   extern "C" {
#endif /* __cplusplus */


#ifdef NSK
#include <jmsgtyp.h>   /* to get "uint8", "uint16" and "uint32" */
#include <dmem.h>
#include <dcpuctl.h>
#include <jmsglit.h>

#define RGP_NULL_PTR       NIL_       /* Null pointer for use by RGP        */
#define MAX_CLUSTER_SIZE   MAX_CPUS   /* max # of nodes supported in system */
#define LOWEST_NODENUM     ((node_t)0)    /* starting node number           */
#define RGP_NULL_NODE      ((node_t)-1)   /* special node# for defaults     */
#define RGP_KEY_NODE       RGP_NULL_NODE  /* No node is special */
#endif /* NSK */

#if defined(LCU) || defined(UNIX) || defined(NT)
typedef unsigned char uint8;
typedef unsigned short uint16;
typedef unsigned int uint32;

#ifndef NULL
#define NULL ((void *)0)
#endif /* NULL */
#define RGP_NULL_PTR       NULL       /* Null pointer for use by RGP        */

#if defined(LCU) || defined(UNIX)
#define MAX_CLUSTER_SIZE   16         /* max # of nodes supported in system */
#define LOWEST_NODENUM     ((node_t)1)    /* starting node number           */
#endif

#if defined(NT)
#include "service.h"

#define MAX_CLUSTER_SIZE   ClusterDefaultMaxNodes
                                      /* max # of nodes supported in system */
#define LOWEST_NODENUM     ((node_t)ClusterMinNodeId)    /* starting node number           */
#endif

#define RGP_NULL_NODE      ((node_t)-1)
                                          /* special node# for defaults     */
#define RGP_KEY_NODE       RGP_NULL_NODE  /* No node is special             */

#define _priv       /* used only by NSK compilers */
#define _resident   /* used only by NSK compilers */

#endif /* LCU || UNIX || NT */


/*---------------------------------------------------------------
 * Unacknowledged packet subtypes used by regroup.
 * These are made visible to the OS for reporting and counting
 * purposes only.
 *---------------------------------------------------------------*/

/* Maximum payload of packets sent by Regroup is 56 bytes.
 * This allows a maximum transport overhead of 8 bytes in the
 * ServerNet interrupt packet which has a size of 64 bytes.
 */
#define RGP_UNACK_PKTLEN   56 /*bytes*/

typedef struct
{
   uint8 pktsubtype;
   uint8 subtype_specific[RGP_UNACK_PKTLEN - sizeof(uint8)];
} rgp_unseq_pkt_t;


/* Regroup unacknowledged packet subtypes */
#define RGP_UNACK_IAMALIVE   (uint8) 1    /* I am alive packet     */
#define RGP_UNACK_REGROUP    (uint8) 2    /* regroup status packet */
#define RGP_UNACK_POISON     (uint8) 3    /* poison packet         */


/*---------------------------------------------------------------*/
/* Processor status codes returned by the Service Processor (SP) */
/*---------------------------------------------------------------*/

#define RGP_NODE_UNREACHABLE     0

#define RGP_NODE_TIMED_OUT       1
#define RGP_NODE_FROZEN          2
#define RGP_NODE_HALTED          3
#define RGP_NODE_OPERATIONAL     4


/*----------------------*/
/* Processor halt codes */
/*----------------------*/

#ifdef NSK
#include <dhalt.h>
#endif /* NSK */

#if defined(LCU) || defined(UNIX) || defined(NT)
#define RGP_RELOADFAILED          1
#define RGP_INTERNAL_ERROR        2
#define RGP_MISSED_POLL_TO_SELF   3
#define RGP_AVOID_SPLIT_BRAIN     4
#define RGP_PRUNED_OUT            5
#define RGP_PARIAH                6
#define RGP_PARIAH_FIRST          RGP_PARIAH + LOWEST_NODENUM
#define RGP_PARIAH_LAST           RGP_PARIAH_FIRST + MAX_CLUSTER_SIZE - 1

#define RGP_ARBITRATION_FAILED    1000
#define RGP_ARBITRATION_STALLED   1001
#define RGP_SHUTDOWN_DURING_RGP   1002 // Alias of MM_STOP_REQUESTED in mmapi.h

#endif /* LCU || UNIX || NT */


/*-------------------------------------------------------------------------
 * Timing parameters for Regroup. Of these, RGP_IAMALIVE_TICKS can be
 * overridden at run time using the rgp_getrgpinfo(), rgp_setrgpinfo()
 * routine pair. This is useful to slow node failure detection during
 * kernel debug sessions.
 *-------------------------------------------------------------------------*/

#ifdef NSK
#define RGP_CLOCK_PERIOD          30   /* period between regroup ticks,
                                        * in units of 10 milliseconds */
#define RGP_PFAIL_TICKS           16   /* # of regroup ticks after a
                                        * power on event to forgive
                                        * missing self IamAlives */
#endif /* NSK */

#ifdef LCU
#define RGP_CLOCK_PERIOD          30   /* period between regroup ticks,
                                        * in units of 10 milliseconds */
#define RGP_PFAIL_TICKS           16   /* # of regroup ticks after a
                                        * power on event to forgive
                                        * missing self IamAlives */
#endif /* LCU */

#ifdef UNIX
#define RGP_CLOCK_PERIOD         100   /* period between regroup ticks,
                                        * in units of 10 milliseconds */
#define RGP_PFAIL_TICKS           16   /* # of regroup ticks after a
                                        * power on event to forgive
                                        * missing self IamAlives */
#endif /* UNIX */

#ifdef NT

#define RGP_INACTIVE_PERIOD        60000   /* period between regroup ticks in ms when
                                                                                * node is inactive. 1 minute period */
#define RGP_CLOCK_PERIOD         300   /* period between regroup ticks,
                                        * in units of milliseconds */
#define RGP_PFAIL_TICKS           16   /* # of regroup ticks after a
                                        * power on event to forgive
                                        * missing self IamAlives */
#endif /* NT */

/* The following timing parameters can be overridden at run time by using
 * the rgp_getrgpinfo(), rgp_setrgpinfo() routine pair.
 */

// Bug#328641
//
// Extend min_stage1 to approx 4 seconds to match NM values (check_ticks 2=>3)
// Extend connectivity ticks to 3 to 9 ticks
// adjust rgp_must_restart accordingly (20=>23) half conn_tick increase
//

#define RGP_IAMALIVE_TICKS         4   /* rgp clock ticks between IamAlives */
#define RGP_CHECK_TICKS            3   /* rgp clock ticks before at least 1 ImAlive received */
#define RGP_MIN_STAGE1_TICKS       (RGP_IAMALIVE_TICKS * RGP_CHECK_TICKS)

/* The following parameters can be made to be OS-dependent if needed.
 */

#define RGP_MUST_ENTER_STAGE2     32   /* must enter stage2 after this many
                                          ticks, regardless of conditions */
#define RGP_CONNECTIVITY_TICKS     9   /* max # of ticks to wait in stage 2
                                          to collect connectivity info */
#define RGP_MUST_RESTART          23   /* stall detector tick count; if no
                                          progress after this many ticks,
                                          abort and restart regroup. */
#define RGP_RESTART_MAX            3   /* maximum number of restarts
                                          allowed per regroup incident;
                                          if this is exceeded, the node
                                          halts. */

/*--------------------------------------*/
/* Definition of node and cluster types */
/*--------------------------------------*/

typedef short node_t;


/* The cluster_t data type is a bit array with MAX_CLUSTER_SIZE
 * bits. It is implemented as an array of MAX_CLUSTER_SIZE/8
 * (rounded up) uint8s.
 */
#define BYTEL 8 /* number of bits in a uint8 */
#define BYTES_IN_CLUSTER ((MAX_CLUSTER_SIZE + BYTEL - 1) / BYTEL)

typedef uint8 cluster_t [BYTES_IN_CLUSTER];


/************************************************************************
 * rgp_msgsys_t (shared by regroup and message system)
 * ---------------------------------------------------
 * This structure is used by Regroup and the Message System to co-ordinate
 * actions that are to be done by the Message System on behalf of Regroup.
 * Regroup posts work requests in timer or IPC interrupt context and the
 * message system performs these at appropriate times (from the
 * dispatcher in NSK).
 *
 *      ___________________________________________________________
 * wd0 |        flags (bitfields)    |       regroup_nodes         |
 *     |_____________________________|_____________________________|
 * wd1 |        iamalive_nodes       |        poison_nodes         |
 *     |_____________________________|_____________________________|
 * wd2 |                   *regroup_data                           |
 *     |___________________________________________________________|
 * wd3 |                   *iamalive_data                          |
 *     |___________________________________________________________|
 * wd4 |                   *poison_data                            |
 *     |___________________________________________________________|
 * wd5 |                   regroup_datalen                         |
 *     |___________________________________________________________|
 * wd6 |                   iamalive_datalen                        |
 *     |___________________________________________________________|
 * wd7 |                   poison_datalen                          |
 *     |___________________________________________________________|
 *
 *
 * flags:
 *
 * sendrgppkts           - have regroup status packets to send
 * sendiamalives         - have iamalive status packets to send
 * sendpoisons           - have poison packets to send
 * phase1_cleanup        - need to start phase1 cleanup due to node death
 * phase2_cleanup        - need to start phase2 cleanup due to node death
 *
 * regroup_nodes         - mask of nodes to send regroup pkts to
 * iamalive_nodes        - mask of nodes to send iamalives to
 * poison_nodes          - mask of nodes to send poison pkts to
 *
 * The following fields are used in NSK and the user-level UNIX
 * simulation only.
 *
 * regroup_data          - address of regroup pkt data to send
 * iamalive_data         - address of iamalive data to send
 * poison_data           - address of poison pkt data to send
 *
 * regroup_datalen       - length of regroup pkt data to send
 * iamalive_datalen      - length of iamalive data to send
 * poison_datalen        - length of poison pkt data to send
 *
 */

#ifdef  __TANDEM
#pragma fieldalign shared8 rgp_msgsys
#endif  /* __TANDEM */

typedef struct rgp_msgsys
{
   uint16 sendrgppkts         : 1;
   uint16 sendiamalives       : 1;
   uint16 sendpoisons         : 1;
   uint16 phase1_cleanup      : 1;
   uint16 phase2_cleanup      : 1;
   uint16 filler              : 11;

   cluster_t    regroup_nodes;
   cluster_t    iamalive_nodes;
   cluster_t    poison_nodes;
#if defined(NSK) || defined(UNIX) || defined(NT)
   void         *regroup_data;
   void         *iamalive_data;
   void         *poison_data;
   uint32       regroup_datalen;
   uint32       iamalive_datalen;
   uint32       poison_datalen;
#endif /* NSK || UNIX || NT */
} rgp_msgsys_t;

typedef struct rgp_msgsys *rgp_msgsys_p;


/*----------------------------------------------------------------------
 * OS-dependent routines used by Regroup.
 *
 * These are defined either in the regroup file srgpos.c or in other
 * modules in the OS.
 *----------------------------------------------------------------------*/

_priv _resident extern void rgp_init_OS(void);
_priv _resident extern void rgp_broadcast(uint8 packet_subtype);
_priv _resident extern void rgp_node_failed(node_t node);
_priv _resident extern void rgp_start_phase1_cleanup(void);
_priv _resident extern void rgp_start_phase2_cleanup(void);
_priv _resident extern void rgp_cleanup_complete(void);
_priv _resident extern void rgp_had_power_failure(node_t node);
_priv _resident extern int  rgp_status_of_node(node_t node);
_priv _resident extern void rgp_newnode_online(node_t newnode);
_priv _resident extern int  rgp_select_cluster(cluster_t cluster_choices[],
                                               int num_clusters);
_priv _resident extern int  rgp_select_cluster_ex(cluster_t cluster_choices[],
                                               int num_clusters, node_t keynode);
_priv _resident extern void rgp_cleanup_OS(void);

#ifdef NSK
#include <tsrtnvl.h>                                                             /*F40:MB06452.1*/
#include <tsdevdf.h>                                                             /*F40:MB06452.2*/
#include <tsport.h>                                                              /*F40:MB06452.3*/
#include <tsentry.h>                                                             /*F40:MB06452.4*/
                                                                                 /*F40:MB06452.5*/
#define rgp_hold_all_io      TSER_TRANSFER_PAUSE_                                /*F40:MB064514.1*/
#define rgp_resume_all_io    TSER_TRANSFER_CONTINUE_                             /*F40:MB064514.2*/
                                                                                 /*F40:MB06452.8*/
#else
   _priv _resident extern void rgp_hold_all_io(void);
   _priv _resident extern void rgp_resume_all_io(void);
#endif /* NSK */

/*
 * Macros to set and get the members of a cluster using a mask of
 * appropriate size.
 */
#define SetCluster(/* cluster_t */ cluster, /* uint16 */ mask) \
{ \
   cluster[0] = (uint8)(mask >> 8); \
   cluster[1] = (uint8)(mask & 0xFF); \
}

#define GetCluster(/* cluster_t */ cluster) \
   (((uint16)cluster[0] << 8) | (uint16)cluster[1])

/* Macro to combine two cluster masks into a uint32.
 * This is used in tracing regroup events.
 */
#define RGP_MERGE_TO_32( c1, c2 )    \
   ( ( GetCluster( c1 ) << 16 ) | ( GetCluster( c2 ) ) )

/*----------------------------------------------------------------------
 * OS-dependent routines used by the Regroup module.
 *
 * These are defined in srgpos.c.
 *----------------------------------------------------------------------*/

/* Routines to halt the node upon catastrophic errors. */

#ifdef NSK
#include <dutil.h>                                                               /*F40:MB06458.3*/
#define RGP_ERROR(/* uint16 */ halt_code) SYSTEM_FREEZE_(halt_code)
#else
_priv _resident extern void RGP_ERROR_EX (uint16 halt_code, char* fname, DWORD lineno);
#define RGP_ERROR(halt_code) RGP_ERROR_EX(halt_code, __FILE__, __LINE__)

#endif /* NSK */

#ifdef UNIX
_priv _resident extern void PrintRegroupStart();
_priv _resident extern void PrintPruningResult();
_priv _resident extern void PrintStage();
_priv _resident extern void PrintMatrix();
#endif /* UNIX */

#ifdef __cplusplus
}
#endif /* __cplusplus */


#if 0

History of changes to this file:
-------------------------------------------------------------------------
1995, December 13                                           F40:KSK0610          /*F40:KSK06102.1*/

This file is part of the portable Regroup Module used in the NonStop
Kernel (NSK) and Loosely Coupled UNIX (LCU) operating systems. There
are 10 files in the module - jrgp.h, jrgpos.h, wrgp.h, wrgpos.h,
srgpif.c, srgpos.c, srgpsm.c, srgputl.c, srgpcli.c and srgpsvr.c.
The last two are simulation files to test the Regroup Module on a
UNIX workstation in user mode with processes simulating processor nodes
and UDP datagrams used to send unacknowledged datagrams.

This file was first submitted for release into NSK on 12/13/95.
------------------------------------------------------------------------------
This change occurred on 19 Jan 1996                                              /*F40:MB06458.4*/
Changes for phase IV Sierra message system release. Includes:                    /*F40:MB06458.5*/
 - Some cleanup of the code                                                      /*F40:MB06458.6*/
 - Increment KCCB counters to count the number of setup messages and             /*F40:MB06458.7*/
   unsequenced messages sent.                                                    /*F40:MB06458.8*/
 - Fixed some bugs                                                               /*F40:MB06458.9*/
 - Disable interrupts before allocating broadcast sibs.                          /*F40:MB06458.10*/
 - Change per-packet-timeout to 5ms                                              /*F40:MB06458.11*/
 - Make the regroup and powerfail broadcast use highest priority                 /*F40:MB06458.12*/
   tnet services queue.                                                          /*F40:MB06458.13*/
 - Call the millicode backdoor to get the processor status from SP               /*F40:MB06458.14*/
 - Fixed expand bug in msg_listen_ and msg_readctrl_                             /*F40:MB06458.15*/
 - Added enhancement to msngr_sendmsg_ so that clients do not need               /*F40:MB06458.16*/
   to be unstoppable before calling this routine.                                /*F40:MB06458.17*/
 - Added new steps in the build file called                                      /*F40:MB06458.18*/
   MSGSYS_C - compiles all the message system C files                            /*F40:MB06458.19*/
   MSDRIVER - compiles all the MSDriver files                                    /*F40:MB06458.20*/
   REGROUP  - compiles all the regroup files                                     /*F40:MB06458.21*/
-----------------------------------------------------------------------          /*F40:MB06458.22*/

#endif    /* 0 - change descriptions */


#endif  /* _JRGPOS_H_ defined */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\lm\timeract.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    timeract.c

Abstract:

    Provides the timer activity functions.

Author:

    Sunita Shrivastava (sunitas) 10-Nov-1995

Revision History:

--*/
#include "service.h"
#include "lmp.h"

//global data
static LIST_ENTRY    gActivityHead;
static HANDLE        ghTimerCtrlEvent=NULL;
static HANDLE        ghTimerCtrlDoneEvent = NULL;       
static HANDLE        ghTimerThread=NULL;
static CRITICAL_SECTION    gActivityCritSec;
static HANDLE        grghWaitHandles[MAX_TIMER_ACTIVITIES];
static PTIMER_ACTIVITY    grgpActivity[MAX_TIMER_ACTIVITIES];
static DWORD        gdwNumHandles;
static DWORD        gdwTimerCtrl;

//internal prototypes
DWORD WINAPI ClTimerThread(PVOID pContext);
void ReSyncTimerHandles();

/****
@doc    EXTERNAL INTERFACES CLUSSVC LM
****/



/****
@func   DWORD | TimerActInitialize| It initializes structures for log file
            management and creates a timer thread to process timer activities.

@rdesc  ERROR_SUCCESS if successful. Win32 error code if something horrible happened.

@comm   This function is called when the cluster components are initialized.

@xref   <f TimerActShutdown> <f ClTimerThread>
****/
DWORD
TimerActInitialize()
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwThreadId;
    
    //we need to create a thread to general log management
    //later this may be used by other clussvc client components
    ClRtlLogPrint(LOG_NOISE,
        "[LM] TimerActInitialize Entry. \r\n");


    InitializeCriticalSection(&gActivityCritSec);
    
    //initialize the activity structures
    //when a log file is created, an activity structure
    //will be added to this list
    InitializeListHead(&gActivityHead);

    //create an auto-reset event to signal changes to the timer list
    ghTimerCtrlEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!ghTimerCtrlEvent)
    {
        dwError = GetLastError();
        CL_LOGFAILURE(dwError);
        goto FnExit;        
    }

    //create a manual reset event for the timer thread to signal
    //when it is done syncing the activitity list
    ghTimerCtrlDoneEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!ghTimerCtrlDoneEvent)
    {
        dwError = GetLastError();
        CL_LOGFAILURE(dwError);
        goto FnExit;        
    }

    
    gdwNumHandles = 1;
    grghWaitHandles[0] = ghTimerCtrlEvent;
    
    //create a thread to do the periodic management
    ghTimerThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ClTimerThread,
        NULL, 0, &dwThreadId);

    if (!ghTimerThread)
    {
        dwError = GetLastError();
        CL_LOGFAILURE(dwError);
    }

    
FnExit:
    if (dwError != ERROR_SUCCESS)
    {
        //free up resources
        if (ghTimerCtrlEvent)
        {
            CloseHandle(ghTimerCtrlEvent);
            ghTimerCtrlEvent = NULL;
        }            
        //free up resources
        if (ghTimerCtrlDoneEvent)
        {
            CloseHandle(ghTimerCtrlDoneEvent);
            ghTimerCtrlDoneEvent = NULL;
        }            
        
        DeleteCriticalSection(&gActivityCritSec);
    }
    return(dwError);
}


/****
@func         DWORD | ClTimerThread | This thread does a wait on all the 
            waitable timers registered within the cluster service.

@parm         PVOID | pContext | Supplies the identifier of the log.

@comm        When any of the timers is signaled, it calls the activity callback
            function corresponding to that timer.  When the timer control event
            is signaled, it either resyncs its wait handles or shuts down.
            
@rdesc         ERROR_SUCCESS if successful. Win32 error code if something horrible happened.

@xref        <f AddTimerActivity> <f RemoveTimerActivity>
****/
DWORD WINAPI ClTimerThread(PVOID pContext)
{

    HANDLE      hClTimer;
    DWORD       dwReturn;
    

    while (TRUE)
    {
        dwReturn = WaitForMultipleObjects(gdwNumHandles, grghWaitHandles, FALSE, INFINITE);
        //walk the activity list
        if (dwReturn == WAIT_FAILED)
        {
            //run down the activity lists and call the functions
            ClRtlLogPrint(LOG_UNUSUAL,
                "[LM] ClTimerThread: WaitformultipleObjects failed 0x%1!08lx!\r\n",
                GetLastError());

        }
        else if (dwReturn == 0)
        {
            //the first handle is the timer ctrl event
            if (gdwTimerCtrl == TIMER_ACTIVITY_SHUTDOWN)
            {
                ExitThread(0);
            }
            else if (gdwTimerCtrl == TIMER_ACTIVITY_CHANGE)
            {
                ReSyncTimerHandles();
            }
        }
        else
        {
            // SS::we got rid of holding the critsec by using the manual
            // reset event.
            if (dwReturn < gdwNumHandles) 
            {
                //if the activity has been set up for delete, we cant rely
                //on the context and callback being there!
                if (grgpActivity[dwReturn]->dwState == ACTIVITY_STATE_READY)
                {
                    //call the corresponding activity fn
                    (*((grgpActivity[dwReturn])->pfnTimerCb))
                        ((grgpActivity[dwReturn])->hWaitableTimer,
                        (grgpActivity[dwReturn])->pContext);
                }                        
            }                
                
        }
    }
    
    return(0);
}


/****
@func       DWORD | ReSyncTimerHandles | resyncs the wait handles,
            when the activity list changes.

@rdesc      ERROR_SUCCESS if successful. Win32 error code if something horrible happened.

@comm       This function is called by the timer thread to resync its
            wait handles according to the timer activities currently 
            registered.
            
@xref       <f ClTimerThread>
****/
void ReSyncTimerHandles()
{
    PLIST_ENTRY        pListEntry;
    PTIMER_ACTIVITY    pActivity;
    int                i = 1;
    
    ClRtlLogPrint(LOG_NOISE,
        "[LM] ReSyncTimerHandles Entry. \r\n");


    EnterCriticalSection(&gActivityCritSec);
    pListEntry = gActivityHead.Flink;


    gdwNumHandles = 1;
    
    //will resync the list of waitable timers and activities
    //depending on the activity list
    while ((pListEntry != &gActivityHead) && (i< MAX_TIMER_ACTIVITIES))
    {
        pActivity = CONTAINING_RECORD(pListEntry, TIMER_ACTIVITY, ListEntry);
        //goto the next link
        pListEntry = pListEntry->Flink;

        if (pActivity->dwState == ACTIVITY_STATE_DELETE)
        {
            ClRtlLogPrint(LOG_NOISE,
                "[LM] ResyncTimerHandles: removed Timer 0x%1!08lx!\r\n",
                pActivity->hWaitableTimer);
            RemoveEntryList(&pActivity->ListEntry);
            //close the timer handle here 
            CloseHandle(pActivity->hWaitableTimer);
            LocalFree(pActivity);
            continue;
        }
        //call the fn
        grghWaitHandles[i] = pActivity->hWaitableTimer;
        grgpActivity[i] = pActivity;
        gdwNumHandles++;
        i++;
    }
    LeaveCriticalSection(&gActivityCritSec);
    //now if timer activities were resynced, we need to 
    //signal all threads that might be waiting on this
    SetEvent(ghTimerCtrlDoneEvent);
    
    ClRtlLogPrint(LOG_NOISE,
        "[LM] ReSyncTimerHandles Exit gdwNumHandles=%1!u!\r\n",
        gdwNumHandles);

}


/****
@func       DWORD | AddTimerActivity | Adds a periodic Activity to the timer
            callback list.

@parm       HANDLE | hTimer | A handle to a waitaible timer object.

@parm       DWORD | dwInterval | The duration for this timer, in
            msecs.

@parm       LONG | lPeriod | If lPeriod is 0, the timer is signalled once
            if greater than 0, the timer is periodic. If less than zero, then
            error will be returned.
            
@parm       PFN_TIMER_CALLBACK | pfnTimerCb | A pointer to the callback function
            that will be called when this timer is signaled.

@parm       PVOID | pContext | A pointer to the callback data that will be
            passed to the callback function.

@rdesc      ERROR_SUCCESS if successful. Win32 error code if something horrible happened.

@comm       SetWaitableTimer() for the corresponding timer is called by this
            function for the given duration.  CreateWaitableTimer() must be used to 
            create this timer handle.
            
@xref       <f RemoveTimerActivity>
****/
DWORD AddTimerActivity(IN HANDLE hTimer, IN DWORD dwInterval,
    IN LONG lPeriod, IN PFN_TIMER_CALLBACK pfnTimerCb, IN PVOID pContext)
{
    PTIMER_ACTIVITY     pActivity = NULL;
    DWORD               dwError = ERROR_SUCCESS;
    LARGE_INTEGER       Interval;
    

    ClRtlLogPrint(LOG_NOISE,
        "[LM] AddTimerActivity: hTimer = 0x%1!08lx! pfnTimerCb=0x%2!08lx! dwInterval(in msec)=%3!u!\r\n",
        hTimer, pfnTimerCb, dwInterval);

    pActivity =(PTIMER_ACTIVITY) LocalAlloc(LMEM_FIXED,sizeof(TIMER_ACTIVITY));

    if (!pActivity)
    {
        
        dwError = GetLastError();
        CL_UNEXPECTED_ERROR(dwError);
        goto FnExit;
    }

    Interval.QuadPart = -10 * 1000 * (_int64)dwInterval;    //time in 100 nano secs

    ClRtlLogPrint(LOG_NOISE,
        "[LM] AddTimerActivity: Interval(high)=0x%1!08lx! Interval(low)=0x%2!08lx!\r\n",
        Interval.HighPart, Interval.LowPart);

    pActivity->hWaitableTimer = hTimer;
    memcpy(&(pActivity->Interval), (LPBYTE)&Interval, sizeof(LARGE_INTEGER));
    pActivity->pfnTimerCb = pfnTimerCb;
    pActivity->pContext = pContext;
    //set the timer
    if (lPeriod)
    {
        lPeriod = (LONG)dwInterval;
    }
    else
    {
        lPeriod = 0;
    }        
    if (!SetWaitableTimer(hTimer,  &Interval, lPeriod , NULL, NULL, FALSE))
    {
        CL_LOGFAILURE((dwError = GetLastError()));
        goto FnExit;
    };

    //add to the list of activities
    //and get the timer thread to resync
    EnterCriticalSection(&gActivityCritSec);
    pActivity->dwState = ACTIVITY_STATE_READY;
    InitializeListHead(&pActivity->ListEntry);
    InsertTailList(&gActivityHead, &pActivity->ListEntry);    
    gdwTimerCtrl = TIMER_ACTIVITY_CHANGE;
    LeaveCriticalSection(&gActivityCritSec);
    
    SetEvent(ghTimerCtrlEvent);


FnExit:
    if ( (dwError != ERROR_SUCCESS) &&
         pActivity ) {
        LocalFree(pActivity);
    }
    ClRtlLogPrint(LOG_NOISE,
        "[LM] AddTimerActivity: returns 0x%1!08lx!\r\n",
        dwError);
    return(dwError);
}


/****
@func       DWORD | RemoveTimerActivity | This functions removes the
            activity associated with a timer from the timer threads activity
            list.

@parm       HANDLE | hTimer | The handle to the timer whose related activity will
            be removed.  The handle is closed.
            
@rdesc      ERROR_SUCCESS if successful. Win32 error code if something horrible happened.

@comm       This function cancels the waitable timer and removes the activity 
            corresponding to it.  The calling component must not close the handle 
            to the timer. It is closed by the timer activity manager once this function is called.
@xref       <f AddTimerActivity>
****/
DWORD RemoveTimerActivity(HANDLE hTimer)
{

    PLIST_ENTRY         pListEntry;
    PTIMER_ACTIVITY     pActivity;
    PTIMER_ACTIVITY     pActivityToDel = NULL;
    DWORD               dwError = ERROR_SUCCESS;

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LmRemoveTimerActivity: Entry 0x%1!08lx!\r\n",
        hTimer);

    EnterCriticalSection(&gActivityCritSec);

    pListEntry = gActivityHead.Flink;
    while (pListEntry != &gActivityHead) {
        pActivity = CONTAINING_RECORD(pListEntry, TIMER_ACTIVITY, ListEntry);
        if (pActivity->hWaitableTimer == hTimer)
        {
            pActivityToDel = pActivity;
            break;
        }
        pListEntry = pListEntry->Flink;
    }
    if (!pActivityToDel)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LmRemoveTimerActivity: didnt find activity correspondint to 0x%1!08lx!\r\n",
            hTimer);
    }
    else
    {
        //will be deleted by resynctimerhandles
        CancelWaitableTimer(pActivityToDel->hWaitableTimer);
        pActivityToDel->dwState = ACTIVITY_STATE_DELETE;
    }
    //signal the timer thread to resync its array of wait handles
    //from this list
    SetEvent(ghTimerCtrlEvent);
    //do a manual reset on the done event so that we will wait on it
    //until the timer thread has done a resync of its array of
    //wait handles from the list after this thread leaves the critsec
    //note that we do this holding the critsec
    //now we are guaranteed that timer thread will wake us up
    ResetEvent(ghTimerCtrlDoneEvent);
    LeaveCriticalSection(&gActivityCritSec);
    //wait till the timer thread signals that done event
    WaitForSingleObject(ghTimerCtrlDoneEvent, INFINITE);

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LmRemoveTimerActivity:  Exit\r\n");

    return(dwError);
}

/****
@func       DWORD | PauseTimerActivity | This functions pauses the
            activity associated with a timer in the timer threads activity
            list.

@parm       HANDLE | hTimer | The handle to the timer whose related activity will
            be removed.
            
@rdesc      ERROR_SUCCESS if successful. Win32 error code if something horrible happened.

@comm       This function sets the timer into a paused state so that the timer 
            callbacks are not proccessed.
            
@xref       <f AddTimerActivity> <f 
****/
DWORD PauseTimerActivity(HANDLE hTimer)
{

    PLIST_ENTRY         pListEntry;
    PTIMER_ACTIVITY     pActivity;
    PTIMER_ACTIVITY     pActivityToDel = NULL;
    DWORD               dwError = ERROR_SUCCESS;

    ClRtlLogPrint(LOG_NOISE,
        "[LM] PauseTimerActivity:  Entry 0x%1!08lx!\r\n",
        hTimer);

    EnterCriticalSection(&gActivityCritSec);

    pListEntry = gActivityHead.Flink;
    while (pListEntry != &gActivityHead) {
        pActivity = CONTAINING_RECORD(pListEntry, TIMER_ACTIVITY, ListEntry);
        if (pActivity->hWaitableTimer == hTimer)
        {
            pActivityToDel = pActivity;
            break;
        }
        pListEntry = pListEntry->Flink;
    }
    if (!pActivityToDel)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] PauseTimerActivity:  didnt find activity correspondint to 0x%1!08lx!\r\n",
            hTimer);
    }
    else
    {
        CL_ASSERT(pActivity->dwState == ACTIVITY_STATE_READY);
        //set the state to be paused
        pActivityToDel->dwState = ACTIVITY_STATE_PAUSED;
    }
    LeaveCriticalSection(&gActivityCritSec);

    ClRtlLogPrint(LOG_NOISE,
        "[LM] PauseTimerActivity:  Exit\r\n");

    return(dwError);
}

/****
@func       DWORD | UnpauseTimerActivity | This functions unpauses the
            activity associated with a timer in the timer threads activity
            list.

@parm       HANDLE | hTimer | The handle to the timer whose related activity will
            be removed.
            
@rdesc      ERROR_SUCCESS if successful. Win32 error code if something horrible happened.

@comm       This function sets the activity into a ready state.
            
@xref       <f AddTimerActivity> <f 
****/
DWORD UnpauseTimerActivity(HANDLE hTimer)
{

    PLIST_ENTRY         pListEntry;
    PTIMER_ACTIVITY     pActivity;
    PTIMER_ACTIVITY     pActivityToDel = NULL;
    DWORD               dwError = ERROR_SUCCESS;

    ClRtlLogPrint(LOG_NOISE,
        "[LM] UnpauseTimerActivity:  Entry 0x%1!08lx!\r\n",
        hTimer);

    EnterCriticalSection(&gActivityCritSec);

    pListEntry = gActivityHead.Flink;
    while (pListEntry != &gActivityHead) {
        pActivity = CONTAINING_RECORD(pListEntry, TIMER_ACTIVITY, ListEntry);
        if (pActivity->hWaitableTimer == hTimer)
        {
            pActivityToDel = pActivity;
            break;
        }
        pListEntry = pListEntry->Flink;
    }
    if (!pActivityToDel)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] PauseTimerActivity:  didnt find activity correspondint to 0x%1!08lx!\r\n",
            hTimer);
    }
    else
    {
        CL_ASSERT(pActivity->dwState == ACTIVITY_STATE_PAUSED);
        //set the state to be paused
        pActivityToDel->dwState = ACTIVITY_STATE_READY;
    }
    LeaveCriticalSection(&gActivityCritSec);

    ClRtlLogPrint(LOG_NOISE,
        "[LM] UnpauseTimerActivity:  Exit\r\n");

    return(dwError);
}

/****
@func       DWORD | TimerActShutdown | Deinitializes the TimerActivity manager.

@rdesc      ERROR_SUCCESS if successful. Win32 error code if something horrible happened.

@comm       This function notifies the timer thread to shutdown down and closes
            all resources associated with timer activity management.
@xref       <f TimerActInitialize>
****/
DWORD
TimerActShutdown(
    )
{

    PLIST_ENTRY         pListEntry;
    PTIMER_ACTIVITY     pActivity;

    ClRtlLogPrint(LOG_NOISE,
        "[LM] TimerActShutDown : Entry \r\n");

    //check if we were initialized before
    if (ghTimerThread && ghTimerCtrlEvent)
    {
        //signal the timer thread to kill itself
        gdwTimerCtrl = TIMER_ACTIVITY_SHUTDOWN;
        SetEvent(ghTimerCtrlEvent);
        //wait for the thread to exit
        WaitForSingleObject(ghTimerThread,INFINITE);

        //close the timer thread control event
        CloseHandle(ghTimerCtrlEvent);
        ghTimerCtrlEvent = NULL;

        //close the timer thread control done event
        CloseHandle(ghTimerCtrlDoneEvent);
        ghTimerCtrlDoneEvent = NULL;
        
        CloseHandle(ghTimerThread);
        ghTimerThread = NULL;

        //clean up the activity structures, if there any left
        pListEntry = gActivityHead.Flink;
        while (pListEntry != &gActivityHead) 
        {
            pActivity = CONTAINING_RECORD(pListEntry, TIMER_ACTIVITY, ListEntry);
            CloseHandle(pActivity->hWaitableTimer);
            LocalFree(pActivity);
            pListEntry = pListEntry->Flink;
        }
        //reset the activity head structure
        InitializeListHead(&gActivityHead);

        DeleteCriticalSection(&gActivityCritSec);

    }

    ClRtlLogPrint(LOG_NOISE,
        "[LM] TimerActShutDown : Exit\r\n");

    
    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\lm\tlog.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    tlog.c

Abstract:

    Test app for the cluster registry logging component

Author:

    John Vert (jvert) 15-Dec-1995


Revision History:

--*/
#include "windows.h"
#include "lmp.h"
#include "stdio.h"
#include "stdlib.h"

HLOG MyLog;
LPWSTR LogName = L"c:\\TLOG.LOG";

#define LOG_RECORDS 1000

int __cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    LSN LastLsn;
    DWORD Status;
    int i,j;
    PDWORD Buffer;

    DeleteFileW(LogName);
    MyLog = LogCreate(LogName, 0,
    	NULL, NULL, &LastLsn);
    if (MyLog == INVALID_HANDLE_VALUE) {
        fprintf(stderr, "TLOG: LogCreate failed %d\n",GetLastError);
        return(0);
    }

    if (LastLsn != NULL_LSN) {
        fprintf(stderr, "TLOG: new log file returned LastLsn == %08lx\n",LastLsn);
        return(0);
    }

    Buffer = malloc(1000 * sizeof(DWORD));
    if (Buffer == NULL) {
        fprintf(stderr, "TLOG: couldn't allocate buffer\n");
        return(0);
    }
    for (i=0; i<1000; i++) {
        Buffer[i] = i;
    }

    LastLsn = NULL_LSN;
    for (i=0; i<LOG_RECORDS; i++) {
        Buffer[0] = LastLsn;
        printf("Logging TRID %d size %d\n",i,(sizeof(DWORD)*i));
        LastLsn = LogWrite(MyLog,
                           (TRID)i,
                           (RMID)3,
                           (RMTYPE)0,
                           Buffer,
                           sizeof(DWORD) * i);
        printf("LSN of the last record %d\r\n",LastLsn);
        if (LastLsn == NULL_LSN) {
            fprintf(stderr,
                    "TLOG: LogWrite TRID %d, %d bytes failed %d\n",
                    i,
                    sizeof(DWORD) * i,
                    GetLastError());
            return(0);
        }
    }

    Status = LogClose(MyLog);
    if (Status != ERROR_SUCCESS) {
        fprintf(stderr, "TLOG: LogClose failed %d\n",Status);
        return(0);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\mm\jrgp.h ===
#ifndef  _JRGP_H_
#define  _JRGP_H_

#ifdef __TANDEM
#pragma columns 79
#pragma page "jrgp.h - T9050 - external declarations for Regroup Module"
#endif

/* @@@ START COPYRIGHT @@@
**  Tandem Confidential:  Need to Know only
**  Copyright (c) 1995, Tandem Computers Incorporated
**  Protected as an unpublished work.
**  All Rights Reserved.
**
**  The computer program listings, specifications, and documentation
**  herein are the property of Tandem Computers Incorporated and shall
**  not be reproduced, copied, disclosed, or used in whole or in part
**  for any reason without the prior express written permission of
**  Tandem Computers Incorporated.
**
** @@@ END COPYRIGHT @@@
**/

/*---------------------------------------------------------------------------
 * This file (jrgp.h) contains all the type and function declarations exported
 * by Regroup.
 *---------------------------------------------------------------------------*/

#ifdef __cplusplus
   extern "C" {
#endif /* __cplusplus */


#include <jrgpos.h>

/*  The following literals define the various events that may impinge
 *  upon the regroup algorithm main state.
 */
enum
{
   RGP_EVT_POWERFAIL            = 1,
   RGP_EVT_NODE_UNREACHABLE     = 2,
   RGP_EVT_PHASE1_CLEANUP_DONE  = 3,
   RGP_EVT_PHASE2_CLEANUP_DONE  = 4,
   RGP_EVT_LATEPOLLPACKET       = 5,
   RGP_EVT_CLOCK_TICK           = 6,
   RGP_EVT_RECEIVED_PACKET      = 7,
   RGP_EVT_BANISH_NODE          = 8,
   RGP_EVT_IGNORE_MASK          = 9
};


/* Detailed description of event codes:
 * -----------------------------------
 *
 * RGP_EVT_POWERFAIL
 *
 *    After a power failure, regroup must start or be restarted.
 *    This event can also be used when a power fail shout packet
 *    indicating a power failure is received from another node,
 *    even though our own node hasn't detected a power failure.
 *
 * RGP_EVT_NODE_UNREACHABLE
 *
 *    When all paths to a node are down, the message system reports
 *    this event.
 *
 * RGP_EVT_PHASE1_CLEANUP_DONE,
 * RGP_EVT_PHASE2_CLEANUP_DONE
 *
 *    Regroup provides two phases for the message system or cluster manager
 *    to clean up messages on all nodes. The first phase of cleanup begins
 *    after regroup reports one or more node failures. The second phase
 *    begins when a node learns that all nodes have completed phase 1
 *    clean up.
 *
 *    The message system or cluster manager on each node must inform
 *    regroup when the local cleanup for each phase is complete using
 *    the following events.
 *
 *    The NSK message system uses phase 1 to cancel all incoming (server)
 *    messages and phase 2 to terminate all outgoing (requester) messages.
 *
 *
 * The remaining events are for internal use by the Regroup algorithm.
 * ------------------------------------------------------------------
 *
 * RGP_EVT_LATEPOLLPACKET
 *
 *    When a node is late with its IamAlive messages, regroup must start a
 *    new round of regrouping.
 *
 * RGP_EVT_CLOCK_TICK
 *
 *    Once regroup is active, it needs to get clock ticks at periodic
 *    intervals.
 *
 * RGP_EVT_RECEIVED_PACKET
 *
 *    When a regroup packet arrives, it must be processed.
 *
 * RGP_EVT_BANISH_NODE
 *
 *    When regroup is restarted with the reason RGP_EVT_BANISH_NODE,
 *    each node participating in this regroup event shall install the
 *    causing node into its Banished mask.
 *
 * RGP_EVT_IGNORE_MASK
 *
 *    When regroup's ignore mask has changed, the reason code is set
 *    to RGP_EVT_IGNORE_MASK. This will allow UnpackIgnoreScreen routine
 *    to process causingnode and reason fields in a special way.
 *    If the reason is less than RGP_EVT_IGNORE_MASK, ignore mask is
 *    considered to be empty.
 */


/************************************************************************
 * rgp_info_t (used to get and set regroup parameters)
 * ---------------------------------------------------
 * This structure is used to get the current regroup parameters in order to
 * pass them to a new node being brought up. The structure can also be
 * used to modify regroup timing parameters before a cluster is formed
 * (that is, more than one node is booted).
 *
 *      ___________________________________________________________
 * wd0 |                        version                            |
 *     |___________________________________________________________|
 * wd1 |                        seqnum                             |
 *     |___________________________________________________________|
 * wd2 |   a_tick                    |        imalive_ticks        |
 *     |_____________________________|_____________________________|
 * wd3 |   check_ticks 				 |        min_stage1_ticks     |
 *	   |_____________________________|_____________________________|
 * wd4 |   cluster       			 |        unused			   |
 *     |_____________________________|_____________________________|
 *
 *
 * version            - version# of this data structure
 * seqnum             - sequence number for coordinating regroup
 *                      incidents between nodes
 * a_tick             - regroup clockperiod. in milliseconds.
 * iamalive_ticks     - # of regroup clock ticks between IamAlive
 *                      messages
 * check_ticks        - # of imalive ticks by which at least 1 imalive must arrive
 * min_stage1_ticks   - precomputed to be (imalive_ticks*check_ticks)
 * cluster            - current cluster membership mask
 */

#ifdef __TANDEM
#pragma fieldalign shared8 rgpinfo
#endif /* __TANDEM */

typedef struct rgpinfo
{
   uint32      version;
   uint32      seqnum;
   uint16	   a_tick; /* in ms.== clockPeriod */
   uint16      iamalive_ticks; /* number of ticks between imalive sends == sendHBRate */
   uint16	   check_ticks; /* number of imalive ticks before at least 1 imalive == rcvHBRate */
   uint16	   Min_Stage1_ticks; /* precomputed to be imalive_ticks*check_ticks */
   cluster_t   cluster;
} rgpinfo_t;

typedef struct rgpinfo *rgpinfo_p;


/*---------------------------------------------------------------------------*/
/* Routines exported by the Regroup Module
 * ---------------------------------------
 *
 * These routine names are in upper case to enable them to be called from
 * routines written in the PTAL language which is case insensitive and
 * converts all symbols to upper case.
 */

_priv _resident extern int
RGP_ESTIMATE_MEMORY(void);
#define rgp_estimate_memory RGP_ESTIMATE_MEMORY

_priv _resident extern void
RGP_INIT(node_t          this_node,
         unsigned int    num_nodes,
         void            *rgp_buffer,
         int             rgp_buflen,
         rgp_msgsys_p    rgp_msgsys_p);
#define rgp_init RGP_INIT

_priv _resident extern void
RGP_CLEANUP(void);
#define rgp_cleanup RGP_CLEANUP

_priv _resident extern uint32
RGP_SEQUENCE_NUMBER(void);
#define rgp_sequence_number RGP_SEQUENCE_NUMBER

_priv _resident extern int
RGP_GETRGPINFO(rgpinfo_t *rgpinfo);
#define rgp_getrgpinfo RGP_GETRGPINFO

_priv _resident extern int
RGP_SETRGPINFO(rgpinfo_t *rgpinfo);
#define rgp_setrgpinfo RGP_SETRGPINFO

_priv _resident extern void
RGP_START(void (*nodedown_callback)(cluster_t failed_nodes),
          int (*select_cluster)(cluster_t cluster_choices[],
                                    int num_clusters));
#define rgp_start RGP_START

_priv _resident extern int
RGP_ADD_NODE(node_t node);
#define rgp_add_node RGP_ADD_NODE

_priv _resident extern int
RGP_MONITOR_NODE(node_t node);
#define rgp_monitor_node RGP_MONITOR_NODE

_priv _resident extern int
RGP_REMOVE_NODE(node_t node);
#define rgp_remove_node RGP_REMOVE_NODE

_priv _resident extern int
RGP_IS_PERTURBED(void);
#define rgp_is_perturbed RGP_IS_PERTURBED

_priv _resident extern void
RGP_PERIODIC_CHECK(void);
#define rgp_periodic_check RGP_PERIODIC_CHECK

_priv _resident extern void
RGP_RECEIVED_PACKET(node_t node, void *packet, int packetlen);
#define rgp_received_packet RGP_RECEIVED_PACKET

_priv _resident extern void
RGP_EVENT_HANDLER_EX(int event, node_t causingnode, void* arg);
#define RGP_EVENT_HANDLER(_event, _causingnode) RGP_EVENT_HANDLER_EX(_event, _causingnode, NULL)

#define rgp_event_handler RGP_EVENT_HANDLER
/*---------------------------------------------------------------------------*/

#ifdef __cplusplus
}
#endif /* __cplusplus */

#if 0

History of changes to this file:
-------------------------------------------------------------------------
1995, December 13                                           F40:KSK0610          /*F40:KSK06102.1*/

This file is part of the portable Regroup Module used in the NonStop
Kernel (NSK) and Loosely Coupled UNIX (LCU) operating systems. There
are 10 files in the module - jrgp.h, jrgpos.h, wrgp.h, wrgpos.h,
srgpif.c, srgpos.c, srgpsm.c, srgputl.c, srgpcli.c and srgpsvr.c.
The last two are simulation files to test the Regroup Module on a
UNIX workstation in user mode with processes simulating processor nodes
and UDP datagrams used to send unacknowledged datagrams.

This file was first submitted for release into NSK on 12/13/95.
------------------------------------------------------------------------------

#endif    /* 0 - change descriptions */

#endif /* _JRGP_H_ defined */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\mm\message.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    message.c

Abstract:

    Routines for the message passing interface for regroup

Author:

    John Vert (jvert) 5/30/1996

Revision History:

--*/
#include "service.h"
#include "sspi.h"
#include "issperr.h"
#include "clmsg.h"
#include "wrgp.h"
#include "wsclus.h"


//
// Private Constants
//
#define CLMSG_DATAGRAM_PORT         1
#define CLMSG_MAX_WORK_THREADS      2
#define CLMSG_WORK_THREAD_PRIORITY  THREAD_PRIORITY_ABOVE_NORMAL

//
// security package info
//
// For NT5, the security context generation code was rewritten to allow
// multiple packages to be specified. The packages are tried in order until
// there are no more packages or a context has been successfully
// generated.
//
// The default is the negotiate package in secur32.dll which will negotiate
// either kerberos or NTLM. Between NT5 systems, the actual package used
// depends on the veresion of the DC: NT5 DCs support kerberos while NT4 DCs
// use NTLM. Mixed mode clusters use NTLM. The NTLM portion of Negotiate
// doesn't interoperate with NT4 NTLM hence the need for trying NTLM directly.
//
// These routines use multi-leg style authentication, i.e., a security blob is
// passed between the client and server until the security routines indicate
// that they have succeeded or failed. Note that encryption is not specified
// for two reasons: we don't need it and it prevents the code from working on
// the non-US versions where NTLM doesn't have an encryption capability.
//
// The DLL and package values can be overridden via the registry.
//

#define DEFAULT_SSPI_DLL            TEXT("SECUR32.DLL")
WCHAR DefaultSspiPackageList[] = L"NTLM" L"\0";
//WCHAR DefaultSspiPackageList[] = L"negotiate" L"\0" L"NTLM" L"\0";

#define VALID_SSPI_HANDLE( _x )     ((_x).dwUpper != (ULONG_PTR)-1 && \
                                     (_x).dwLower != (ULONG_PTR)-1 )

#define INVALIDATE_SSPI_HANDLE( _x ) { \
        (_x).dwUpper = (ULONG_PTR)-1; \
        (_x).dwLower = (ULONG_PTR)-1; \
    }


//
// Private Types
//

//
// the Data array in CLMSG_DATAGRAM_CONTEXT contains the contents of the
// regroup message and the digital signature of the message. Currently, it is
// not possible to get the signature buffer size until a context is
// negotiated. A DCR has been submitted asking for a query that doesn't
// require a context. In lieu of that, we know that for kerberos, the sig
// buffer size is 35b while it is 16b for NTLM. When that feature is
// available, the DatagramContext allocation should be moved into
// ClMsgLoadSecurityProvider.
//

#define MAX_SIGNATURE_SIZE  64

typedef struct {
    CLRTL_WORK_ITEM    ClRtlWorkItem;
    DWORD              Flags;
    SOCKADDR_CLUSTER   SourceAddress;
    INT                SourceAddressLength;
    UCHAR              Data[ sizeof(rgp_msgbuf) + MAX_SIGNATURE_SIZE ];
} CLMSG_DATAGRAM_CONTEXT, *PCLMSG_DATAGRAM_CONTEXT;

typedef struct {
    CLRTL_WORK_ITEM    ClRtlWorkItem;
    CLUSNET_EVENT      EventData;
} CLMSG_EVENT_CONTEXT, *PCLMSG_EVENT_CONTEXT;

//
// info specific to a package. Many pair-wise context associations may use the
// same package. Package info is maintained in a single linked list.
//
typedef struct _CLUSTER_PACKAGE_INFO {
    struct _CLUSTER_PACKAGE_INFO * Next;
    LPWSTR                         Name;
    CredHandle                     OutboundSecurityCredentials;
    CredHandle                     InboundSecurityCredentials;
    ULONG                          SecurityTokenSize;
    ULONG                          SignatureBufferSize;
} CLUSTER_PACKAGE_INFO, *PCLUSTER_PACKAGE_INFO;

//
// pair-wise context data
//
typedef struct _CLUSTER_SECURITY_DATA {
    CtxtHandle              Outbound;
    CtxtHandle              Inbound;
    PCLUSTER_PACKAGE_INFO   PackageInfo;
    BOOL                    OutboundStable;
    BOOL                    InboundStable;
} CLUSTER_SECURITY_DATA, *PCLUSTER_SECURITY_DATA;

//
// Private Data
//
PCLRTL_WORK_QUEUE        WorkQueue = NULL;
PCLMSG_DATAGRAM_CONTEXT  DatagramContext = NULL;
PCLMSG_EVENT_CONTEXT     EventContext = NULL;
SOCKET                   DatagramSocket = INVALID_SOCKET;
HANDLE                   ClusnetHandle = NULL;
RPC_BINDING_HANDLE *     Session = NULL;
BOOLEAN                  ClMsgInitialized = FALSE;
HINSTANCE                SecurityProvider;
PSecurityFunctionTable   SecurityFuncs;
CRITICAL_SECTION         SecContextLock;
PCLUSTER_PACKAGE_INFO    PackageInfoList;

//
// [GorN 08/01/99]
//
// Every time CreateDefaultBinding is called we increase
// generation counter for the node.
//
// In DeleteDefaultBinding, we do a delete, only if generation
// number passed matches the binding generation of that node. 
//
// We use GenerationCritSect for synchronization. 
// [HACKHACK] We are not deleting GenerationCritSect.
// It will get cleaned up by ExitProcess <grin>
//
DWORD                   *BindingGeneration = NULL;
CRITICAL_SECTION         GenerationCritSect;

//
// the security context array is indexed using internal node numbering (0
// based) and protected by SecContextLock. For sending and recv'ing packets,
// the lock is held while the signature is created/verified. Locking gets
// trickier during the setup of a security context since it involves separate
// inbound and outbound contexts which cause messages to be sent between
// nodes. There is still a window where something bad could happen since
// verifying a signature with a partially setup context is bad. The
// {In,Out}boundStable vars are used to track whether the actual context
// handle can be checked for validity and then, if valid, used for signature
// operations.
//
// The joining node initially sets up an outbound context with its sponsor
// (inbound for sponsor). If that is successful, the sponsor sets up an
// outbound context with the joiner (inbound for joiner). This is done in such
// a way that SecContextLock cannot be held at a high level; it must be
// released when ever a message is sent via MmRpcEstablishSecurityContext.
// The lock may be held recursively (by the same thread obviously) during
// certain periods.
//

CLUSTER_SECURITY_DATA SecurityCtxtData[ ClusterDefaultMaxNodes ];

//
// Private Routines
//
VOID
ClMsgDatagramHandler(
    IN PCLRTL_WORK_ITEM   WorkItem,
    IN DWORD              Status,
    IN DWORD              BytesTransferred,
    IN ULONG_PTR          IoContext
    )
{
    WSABUF                   wsaBuf;
    int                      err;
    SecBufferDesc            BufferDescriptor;
    SecBuffer                SignatureDescriptor[2];
    ULONG                    fQOP;
    SECURITY_STATUS          SecStatus;
    PCLUSTER_SECURITY_DATA   SecurityData;
    DWORD                    retryCount;
    DWORD                    signatureBufferSize;
    PVOID                    signatureBuffer;
    rgp_msgbuf *             regroupMsg;

    PCLMSG_DATAGRAM_CONTEXT  datagramContext = CONTAINING_RECORD(
        WorkItem,
        CLMSG_DATAGRAM_CONTEXT,
        ClRtlWorkItem
        );

    UNREFERENCED_PARAMETER(IoContext);
    CL_ASSERT(WorkItem == &(datagramContext->ClRtlWorkItem));

    if (Status == ERROR_SUCCESS || Status == WSAEMSGSIZE ) {

        if (BytesTransferred == sizeof(rgp_msgbuf)) {
            // If clusnet verified the signature of a packet,
            // it sets sac_zero field of a source address to 1
            if (datagramContext->SourceAddress.sac_zero == 1) {
                ClRtlLogPrint(LOG_NOISE,
                              "[ClMsg] recv'd mcast from %1!u!\n",
                              datagramContext->SourceAddress.sac_node);
                RGP_LOCK;
                MMDiag((PVOID)datagramContext->Data,
                    BytesTransferred,
                    &BytesTransferred);
                RGP_UNLOCK;
            } else {
                ClRtlLogPrint(LOG_NOISE,
                              "[ClMsg] unrecognized packet from %1!u! discarded (%2!u!)\n",
                              datagramContext->SourceAddress.sac_node, datagramContext->SourceAddress.sac_zero);
            }
        } else {
            
            EnterCriticalSection( &SecContextLock );

            SecurityData = &SecurityCtxtData[ INT_NODE( datagramContext->SourceAddress.sac_node )];

            if ( SecurityData->InboundStable &&
                 VALID_SSPI_HANDLE( SecurityData->Inbound))
            {
                //
                // get pointer to  signature buffer at back of packet
                //
                regroupMsg = (rgp_msgbuf *)(datagramContext->Data);
                signatureBuffer = (PVOID)(regroupMsg + 1);
                signatureBufferSize = SecurityData->PackageInfo->SignatureBufferSize;
                CL_ASSERT( sizeof(rgp_msgbuf) == BytesTransferred - signatureBufferSize );

                //
                // Build the descriptors for the message and the
                // signature buffer
                //
                BufferDescriptor.cBuffers = 2;
                BufferDescriptor.pBuffers = SignatureDescriptor;
                BufferDescriptor.ulVersion = SECBUFFER_VERSION;

                SignatureDescriptor[0].BufferType = SECBUFFER_DATA;
                SignatureDescriptor[0].cbBuffer = BytesTransferred - signatureBufferSize;
                SignatureDescriptor[0].pvBuffer = (PVOID)regroupMsg;

                SignatureDescriptor[1].BufferType = SECBUFFER_TOKEN;
                SignatureDescriptor[1].cbBuffer = signatureBufferSize;
                SignatureDescriptor[1].pvBuffer = (PVOID)signatureBuffer;

                SecStatus = (*SecurityFuncs->VerifySignature)(
                                &SecurityData->Inbound,
                                &BufferDescriptor,
                                0,                       // no sequence number
                                &fQOP);                  // Quality of protection

                LeaveCriticalSection( &SecContextLock );

                if ( SecStatus == SEC_E_OK ) {

                    //
                    // only feed this buffer to MM if it hasn't been tampered
                    // with.  since we're running over a datagram transport, it
                    // will be possible to lose packets
                    //

                    RGP_LOCK;
                    MMDiag((PVOID)datagramContext->Data,
                           BytesTransferred - signatureBufferSize,
                           &BytesTransferred);
                    RGP_UNLOCK;
                } else {
                    ClRtlLogPrint(LOG_UNUSUAL,
                               "[ClMsg] Signature verify on message from node %1!u! failed, "
                                "status %2!08X!\n",
                                datagramContext->SourceAddress.sac_node,
                                SecStatus);
                }
            } else {

                LeaveCriticalSection( &SecContextLock );
                ClRtlLogPrint(LOG_UNUSUAL,
                           "[ClMsg] No security context to verify message from node %1!u!!\n",
                            datagramContext->SourceAddress.sac_node);
            }

        }
    }
    else {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[ClMsg] Receive datagram failed, status %1!u!\n",
            Status
            );
    }

    retryCount = 0;

    while ((Status != WSAENOTSOCK) && (retryCount++ < 10)) {
        //
        // Repost the request
        //
        ZeroMemory(datagramContext, sizeof(CLMSG_DATAGRAM_CONTEXT));

        datagramContext->ClRtlWorkItem.WorkRoutine = ClMsgDatagramHandler;
        datagramContext->ClRtlWorkItem.Context = datagramContext;

        datagramContext->SourceAddressLength = sizeof(SOCKADDR_CLUSTER);

        wsaBuf.len = sizeof( datagramContext->Data );
        wsaBuf.buf = (PCHAR)&datagramContext->Data;

        err = WSARecvFrom(
                  DatagramSocket,
                  &wsaBuf,
                  1,
                  &BytesTransferred,
                  &(datagramContext->Flags),
                  (struct sockaddr *) &(datagramContext->SourceAddress),
                  &(datagramContext->SourceAddressLength),
                  &(datagramContext->ClRtlWorkItem.Overlapped),
                  NULL
                  );

        if ((err == 0) || ((Status = WSAGetLastError()) == WSA_IO_PENDING)) {
            return;
        }

        ClRtlLogPrint(LOG_UNUSUAL, 
            "[ClMsg] Post of receive datagram failed, status %1!u!\n",
            Status
            );

        Sleep(100);
    }

    if (Status != WSAENOTSOCK) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClMsg] Post of receive datagram failed too many times. Halting.\n"
            );
        CL_UNEXPECTED_ERROR(Status);
        CsInconsistencyHalt(Status);
    }
    else {
        //
        // The socket was closed. Do nothing.
        //
        ClRtlLogPrint(LOG_NOISE, 
            "[ClMsg] Datagram socket was closed. status %1!u!\n",
            Status
            );
    }

    LocalFree(DatagramContext); DatagramContext = NULL;
    return;

}  // ClMsgDatagramHandler

#if defined(DBG)
int IgnoreJoinerNodeUp = MM_INVALID_NODE; // Fault Injection variable
#endif

VOID
ClMsgEventHandler(
    IN PCLRTL_WORK_ITEM   WorkItem,
    IN DWORD              Status,
    IN DWORD              BytesTransferred,
    IN ULONG_PTR          IoContext
    )
{
    PCLMSG_EVENT_CONTEXT  eventContext = CONTAINING_RECORD(
                                             WorkItem,
                                             CLMSG_EVENT_CONTEXT,
                                             ClRtlWorkItem
                                             );
    PCLUSNET_EVENT        event = &(eventContext->EventData);
    BOOL                  EpochsEqual;

    UNREFERENCED_PARAMETER(IoContext);
    CL_ASSERT(WorkItem == &(eventContext->ClRtlWorkItem));

    if (Status == ERROR_SUCCESS) {
        if (BytesTransferred == sizeof(CLUSNET_EVENT)) {

            //
            // handle the event. First make sure that the epoch in the event
            // matches MM's epoch. If not, ignore this event.
            //

            switch ( event->EventType ) {
            case ClusnetEventNodeUp:

                ClRtlLogPrint(LOG_NOISE, 
                    "[ClMsg] Received node up event for node %1!u!, epoch %2!u!\n",
                    event->NodeId,
                    event->Epoch
                    );
#if defined(DBG)
                if( IgnoreJoinerNodeUp == (node_t)event->NodeId ) {
                    ClRtlLogPrint(LOG_NOISE, 
                        "[ClMsg] Fault injection. Ignoring node up for %1!u!\n",
                        event->NodeId
                        );
                    break;
                }
#endif

                RGP_LOCK;
                EpochsEqual = ( event->Epoch == rgp->OS_specific_control.EventEpoch );

                if ( EpochsEqual ) {
                    rgp_monitor_node( (node_t)event->NodeId );
                    RGP_UNLOCK;
                } else {
                    RGP_UNLOCK;
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[ClMsg] Unequal Event Epochs. MM = %1!u! Clusnet = %2!u! !!!\n",
                         rgp->OS_specific_control.EventEpoch,
                         event->Epoch);
                }

                break;

            case ClusnetEventNodeDown:
                //
                // handle this the same as if the rgp periodic check had
                // detected a late IAmAlive packet
                //

                ClRtlLogPrint(LOG_NOISE, 
                    "[ClMsg] Received node down event for node %1!u!, epoch %2!u!\n",
                    event->NodeId,
                    event->Epoch
                    );

                RGP_LOCK;
                EpochsEqual = ( event->Epoch == rgp->OS_specific_control.EventEpoch );

                if ( EpochsEqual ) {
                    rgp_event_handler(RGP_EVT_LATEPOLLPACKET, (node_t)event->NodeId );
                    RGP_UNLOCK;
                } else {
                    RGP_UNLOCK;
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[ClMsg] Unequal Event Epochs. MM = %1!u! Clusnet = %2!u! !!!\n",
                         rgp->OS_specific_control.EventEpoch,
                         event->Epoch);
                }

                break;

            case ClusnetEventPoisonPacketReceived:
                ClRtlLogPrint(LOG_NOISE, 
                    "[ClMsg] Received poison event.\n",
                    event->NodeId,
                    event->Epoch
                    );

                RGP_ERROR((uint16) (RGP_PARIAH + event->NodeId));

                break;

            case ClusnetEventNetInterfaceUp:
            case ClusnetEventNetInterfaceUnreachable:
            case ClusnetEventNetInterfaceFailed:
                ClRtlLogPrint(LOG_NOISE, 
                    "[ClMsg] Received interface %1!ws! event for node %2!u! network %3!u!\n",
                    ( (event->EventType == ClusnetEventNetInterfaceUp) ?
                        L"up" :
                        ( ( event->EventType ==
                            ClusnetEventNetInterfaceUnreachable
                          ) ?
                          L"unreachable" :
                          L"failed"
                        )
                    ),
                    event->NodeId,
                    event->NetworkId
                    );

                NmPostPnpEvent(
                    event->EventType,
                    event->NodeId,
                    event->NetworkId
                    );

                break;

            case ClusnetEventAddAddress:
            case ClusnetEventDelAddress:
                ClRtlLogPrint(LOG_NOISE, 
                    "[ClMsg] Received %1!ws! address event, address %2!x!\n",
                    ((event->EventType == ClusnetEventAddAddress) ?
                        L"add" : L"delete"),
                     event->NetworkId
                     );

                NmPostPnpEvent(
                    event->EventType,
                    event->NetworkId,
                    0
                    );

                break;

            case ClusnetEventMulticastSet:
                ClRtlLogPrint(LOG_NOISE,
                    "[ClMsg] Received new multicast reachable node "
                    "set event: %1!x!.\n",
                    event->NodeId
                    );
                SetMulticastReachable(event->NodeId);
                break;

            default:
                ClRtlLogPrint(LOG_NOISE,
                    "[ClMsg] Received unhandled event type %1!u! node %2!u! network %3!u!\n",
                     event->EventType,
                     event->NodeId,
                     event->NetworkId
                     );

                break;
            }
        }
        else {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[ClMsg] Received event buffer of size %1!u! !!!\n",
                BytesTransferred
                );
            CL_ASSERT(BytesTransferred == sizeof(CLUSNET_EVENT));
        }

        //
        // Repost the request
        //
        ClRtlInitializeWorkItem(
            &(eventContext->ClRtlWorkItem),
            ClMsgEventHandler,
            eventContext
            );

        Status = ClusnetGetNextEvent(
                     ClusnetHandle,
                     &(eventContext->EventData),
                     &(eventContext->ClRtlWorkItem.Overlapped)
                     );

        if ((Status == ERROR_IO_PENDING) || (Status == ERROR_SUCCESS)) {
            return;
        }
    }

    //
    // Some kind of error occurred
    //
    if (Status != ERROR_OPERATION_ABORTED) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[ClMsg] GetNextEvent failed, status %1!u!\n",
            Status
            );
        CL_UNEXPECTED_ERROR(Status);
    }
    else {
        //
        // The control channel was closed. Do nothing.
        //
        ClRtlLogPrint(LOG_NOISE, "[ClMsg] Control Channel was closed.\n");
    }

    LocalFree(EventContext); EventContext = NULL;

    return;

}  // ClMsgEventHandler

DWORD
ClMsgInitializeSecurityPackage(
    LPCWSTR PackageName
    )

/*++

Routine Description:

    Find the specified security package and acquire inboud/outbound credential
    handles to it

Arguments:

    PackageName - package to find in security DLL

Return Value:

    ERROR_SUCCESS if everything worked ok...

--*/

{
    DWORD                status;
    ULONG                i;
    PWSTR                securityPackageName;
    DWORD                numPackages;
    PSecPkgInfo          secPackageInfoBase = NULL;
    PSecPkgInfo          secPackageInfo;
    TimeStamp            expiration;
    PCLUSTER_PACKAGE_INFO clusterPackageInfo;

    //
    // enumerate the packages provided by this provider and look through the
    // results to find one that matches the specified package name.
    //

    status = (*SecurityFuncs->EnumerateSecurityPackages)(&numPackages,
                                                         &secPackageInfoBase);

    if ( status != SEC_E_OK ) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClMsg] Can't enum security packages 0x%1!08X!\n",
            status
            );
        goto error_exit;
    }

    secPackageInfo = secPackageInfoBase;
    for ( i = 0; i < numPackages; ++i ) {

        if ( _wcsicmp( PackageName, secPackageInfo->Name ) == 0) {
            break;
        }

        ++secPackageInfo;
    }

    if ( i == numPackages ) {
        status = (DWORD)SEC_E_SECPKG_NOT_FOUND;            // [THINKTHINK] not a good choice

        ClRtlLogPrint(LOG_CRITICAL,
                   "[ClMsg] Couldn't find %1!ws! security package\n",
                    PackageName);
        goto error_exit;
    }

    //
    // allocate a blob to hold our package info and stuff it on the the list
    //
    clusterPackageInfo = LocalAlloc( LMEM_FIXED, sizeof(CLUSTER_PACKAGE_INFO));
    if ( clusterPackageInfo == NULL ) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[ClMsg] Couldn't allocate memory for package info (%1!u!)\n",
                    status);
        goto error_exit;
    }

    clusterPackageInfo->Name = LocalAlloc(LMEM_FIXED,
                                          (wcslen(secPackageInfo->Name)+1) * sizeof(WCHAR));

    if ( clusterPackageInfo->Name == NULL ) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[ClMsg] Couldn't allocate memory for package info name (%1!u!)\n",
                    status);
        goto error_exit;
    }
    wcscpy( clusterPackageInfo->Name, secPackageInfo->Name );

    if ( PackageInfoList == NULL ) {
        PackageInfoList = clusterPackageInfo;
    } else {
        PCLUSTER_PACKAGE_INFO nextPackage;

        nextPackage = PackageInfoList;
        while ( nextPackage->Next != NULL ) {
            nextPackage = nextPackage->Next;
        }
        nextPackage->Next = clusterPackageInfo;
    }
    clusterPackageInfo->Next = NULL;

    clusterPackageInfo->SecurityTokenSize = secPackageInfo->cbMaxToken;

    //
    // finally get a set of credential handles. Note that there is a bug in
    // the security packages that prevent using an in/outbound
    // credential. When/if that gets fixed, this code could be greatly
    // simplified.
    //

    status = (*SecurityFuncs->AcquireCredentialsHandle)(
                 NULL,
                 secPackageInfo->Name,
                 SECPKG_CRED_OUTBOUND,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 &clusterPackageInfo->OutboundSecurityCredentials,
                 &expiration);

    if ( status != SEC_E_OK ) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClMsg] Can't obtain outbound credentials %1!08X!\n",
            status
            );
        goto error_exit;
    }

    status = (*SecurityFuncs->AcquireCredentialsHandle)(
                 NULL,
                 secPackageInfo->Name,
                 SECPKG_CRED_INBOUND,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 &clusterPackageInfo->InboundSecurityCredentials,
                 &expiration);

    if ( status != SEC_E_OK ) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClMsg] Can't obtain inbound credentials %1!08X!\n",
            status
            );
    }

error_exit:
    if ( secPackageInfoBase != NULL ) {
        (*SecurityFuncs->FreeContextBuffer)( secPackageInfoBase );
    }

    return status;
} // ClMsgInitializeSecurityPackage

DWORD
ClMsgLoadSecurityProvider(
    VOID
    )

/*++

Routine Description:

    Load the security DLL and construct a list of packages to use for context
    establishment.

    This allows use of a set of registry keys to override the current security
    DLL/packages. This is not meant as a general mechanism since switching the
    security provider in a synchronized fashion through out all the nodes in
    the cluster has numerous issues. This is meant as a bailout for a customer
    that is stuck because of some random problem with security or has their
    own security package (the fools!)

Arguments:

    None

Return Value:

    ERROR_SUCCESS if everything worked ok...

--*/

{
    DWORD                   status;
    WCHAR                   securityProviderDLLName[ MAX_PATH ];
    DWORD                   securityDLLNameSize = sizeof( securityProviderDLLName );
    DWORD                   packageListSize = 0;
    INIT_SECURITY_INTERFACE initSecurityInterface;
    BOOL                    dllNameSpecified = TRUE;
    LPWSTR                  securityPackages = NULL;
    LPWSTR                  packageName;
    ULONG                   packagesLoaded = 0;
    ULONG                   i;
    HKEY                    hClusSvcKey = NULL;
    DWORD                   regType;

    //
    // see if a specific security DLL is named in the registry.  if not, fail
    // back to the default.
    //
    status = RegOpenKeyW(HKEY_LOCAL_MACHINE,
                         CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
                         &hClusSvcKey);

    if ( status == ERROR_SUCCESS ) {

        status = RegQueryValueExW(hClusSvcKey,
                                  CLUSREG_NAME_SECURITY_DLL_NAME,
                                  0,
                                  &regType,
                                  (LPBYTE)&securityProviderDLLName,
                                  &securityDLLNameSize);

        if (status != ERROR_SUCCESS ||
            securityDLLNameSize == sizeof( UNICODE_NULL ) ||
            regType != REG_SZ)
        {
            if ( status == ERROR_SUCCESS ) {
                if ( regType != REG_SZ ) {
                    ClRtlLogPrint(LOG_UNUSUAL,
                               "[ClMsg] The security DLL key must be of type REG_SZ. Using "
                                "%1!ws! as provider.\n",
                                DEFAULT_SSPI_DLL);
                } else if ( securityDLLNameSize == sizeof( UNICODE_NULL )) {
                    ClRtlLogPrint(LOG_UNUSUAL,
                               "[ClMsg] No value specified for security DLL key. Using "
                                "%1!ws! as provider.\n",
                                DEFAULT_SSPI_DLL);
                }
            } else  if ( status != ERROR_FILE_NOT_FOUND ) {
                ClRtlLogPrint(LOG_UNUSUAL,
                           "[ClMsg] Can't read security DLL key, status %1!u!. Using "
                            "%2!ws! as provider\n",
                            status,
                            DEFAULT_SSPI_DLL);
            }

            wcscpy( securityProviderDLLName, DEFAULT_SSPI_DLL );
            dllNameSpecified = FALSE;
        } else {
            ClRtlLogPrint(LOG_NOISE,
                       "[ClMsg] Using %1!ws! as the security provider DLL\n",
                        securityProviderDLLName);
        }
    } else {
        wcscpy( securityProviderDLLName, DEFAULT_SSPI_DLL );
        dllNameSpecified = FALSE;
    }

    SecurityProvider = LoadLibrary( securityProviderDLLName );

    if ( SecurityProvider == NULL ) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClMsg] Unable to load security provider %1!ws!, status %2!u!\n",
            securityProviderDLLName,
            status);
        goto error_exit;
    }

    //
    // get a pointer to the initialize function in the DLL
    //
    initSecurityInterface =
        (INIT_SECURITY_INTERFACE)GetProcAddress(SecurityProvider,
                                                SECURITY_ENTRYPOINT_ANSI);

    if ( initSecurityInterface == NULL ) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClMsg] Unable to get security init function, status %1!u!\n",
            status);
        goto error_exit;
    }

    //
    // now get a pointer to all the security funcs
    //
    SecurityFuncs = (*initSecurityInterface)();
    if ( SecurityFuncs == NULL ) {
        status = ERROR_INVALID_FUNCTION;
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClMsg] Unable to get security function table\n");
        goto error_exit;
    }

    if ( dllNameSpecified ) {

        //
        // If a DLL name was specified in the registry, then the package name
        // key must be specified as well. Get its size first.
        //
        status = RegQueryValueExW(hClusSvcKey,
                                  CLUSREG_NAME_SECURITY_PACKAGE_LIST,
                                  0,
                                  &regType,
                                  NULL,
                                  &packageListSize);

        if (status != ERROR_SUCCESS ||
            packageListSize == sizeof( UNICODE_NULL ) ||
            regType != REG_MULTI_SZ)
        {
            if ( status == ERROR_SUCCESS ) {
                if ( regType != REG_MULTI_SZ ) {
                    ClRtlLogPrint(LOG_CRITICAL,
                               "[ClMsg] The security package key must of type REG_MULTI_SZ.\n");
                } else if ( packageListSize == sizeof( UNICODE_NULL )) {
                    ClRtlLogPrint(LOG_CRITICAL,
                               "[ClMsg] No package names were specified for %1!ws!.\n",
                                securityProviderDLLName);
                }

                status = ERROR_INVALID_PARAMETER;
            } else {
                ClRtlLogPrint(LOG_CRITICAL,
                           "[ClMsg] Can't read security package key (%1!u!).\n",
                            status);
            }
            goto error_exit;
        }

        securityPackages = LocalAlloc( LMEM_FIXED, packageListSize );
        if ( securityPackages == NULL ) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[ClMsg] Can't allocate memory for package list.\n");

            status = GetLastError();
            goto error_exit;
        }

        status = RegQueryValueExW(hClusSvcKey,
                                  CLUSREG_NAME_SECURITY_PACKAGE_LIST,
                                  0,
                                  &regType,
                                  (PUCHAR)securityPackages,
                                  &packageListSize);
        CL_ASSERT( status == ERROR_SUCCESS );
    } else {
        securityPackages = LocalAlloc(LMEM_FIXED,
                                      sizeof( DefaultSspiPackageList ));

        if ( securityPackages == NULL ) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[ClMsg] Can't allocate memory for default package list.\n");

            status = GetLastError();
            goto error_exit;
        }

        memcpy(securityPackages,
               DefaultSspiPackageList,
               sizeof( DefaultSspiPackageList ));
    }

    //
    // initialize each package in the list
    //

    packageName = securityPackages;
    while ( *packageName != UNICODE_NULL ) {

        status = ClMsgInitializeSecurityPackage( packageName );
        if ( status == ERROR_SUCCESS ) {
            ++packagesLoaded;
            ClRtlLogPrint(LOG_NOISE,
                       "[ClMsg] Initialized %1!ws! package.\n",
                        packageName);
        } else {
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[ClMsg] %1!ws! package failed to initialize, status %2!08X!.\n",
                        packageName,
                        status);
        }

        packageName = packageName + wcslen( packageName ) + 1;;
    }

    if ( packagesLoaded == 0 ) {
        ClRtlLogPrint(LOG_CRITICAL, "[ClMsg] No security packages could be initialized.\n");
        status = ERROR_NO_SUCH_PACKAGE;
        goto error_exit;
    }

    //
    // initialize the individual client and server side security contexts.
    // a context handle is stable when it is marked as invalid.
    //

    for ( i = ClusterMinNodeId; i <= NmMaxNodeId; ++i ) {
        PCLUSTER_SECURITY_DATA SecurityData = &SecurityCtxtData[ INT_NODE( i )];

        SecurityData->InboundStable = TRUE;
        SecurityData->OutboundStable = TRUE;
        SecurityData->PackageInfo = NULL;
        INVALIDATE_SSPI_HANDLE( SecurityData->Outbound );
        INVALIDATE_SSPI_HANDLE( SecurityData->Inbound );
    }

error_exit:

    if ( hClusSvcKey != NULL ) {
        RegCloseKey(hClusSvcKey);
    }

    if ( securityPackages != NULL ) {
        LocalFree( securityPackages );
    }

    return status;
} // ClMsgLoadSecurityProvider

DWORD
ClMsgImportSecurityContexts(
    CL_NODE_ID  NodeId,
    LPWSTR      SecurityPackageName,
    DWORD       SignatureBufferSize
    )

/*++

Routine Description:

    Export the inbound/outbound security contexts for the specified node and
    ship them to clusnet for use in signing heartbeat and poison pkts

Arguments:

    NodeId - Id of the node whose contexts are being exported

    SecurityPackageName - name of package used with which to establish context

    SignatureBufferSize - number of bytes needed for the signature buffer

Return Value:

    ERROR_SUCCESS if everything worked ok...

--*/

{
    DWORD Status = ERROR_SUCCESS;
    SecBuffer ServerContext;
    SecBuffer ClientContext;
    CL_NODE_ID InternalNodeId = INT_NODE( NodeId );

    ClRtlLogPrint(LOG_NOISE, "[ClMsg] Importing security contexts from %1!ws! package.\n",
                           SecurityPackageName);

    Status = (*SecurityFuncs->ExportSecurityContext)(
                 &SecurityCtxtData[ InternalNodeId ].Inbound,
                 0,
                 &ServerContext,
                 0);

    if ( !NT_SUCCESS( Status )) {

        return Status;
    }

    Status = (*SecurityFuncs->ExportSecurityContext)(
                 &SecurityCtxtData[ InternalNodeId ].Outbound,
                 0,
                 &ClientContext,
                 0);

    if ( NT_SUCCESS( Status )) {
        CL_ASSERT( SignatureBufferSize > 0 );

        Status = ClusnetImportSecurityContexts(NmClusnetHandle,
                                               NodeId,
                                               SecurityPackageName,
                                               SignatureBufferSize,
                                               &ServerContext,
                                               &ClientContext);

        (*SecurityFuncs->FreeContextBuffer)( ClientContext.pvBuffer );
    }

    (*SecurityFuncs->FreeContextBuffer)( ServerContext.pvBuffer );

    return Status;

} // ClMsgImportSecurityContexts

DWORD
ClMsgEstablishSecurityContext(
    IN  DWORD JoinSequence,
    IN  DWORD TargetNodeId,
    IN  SECURITY_ROLE RoleOfClient,
    IN  PCLUSTER_PACKAGE_INFO PackageInfo
    )

/*++

Routine Description:

    try to establish an outbound security context with the other node using
    the specified package name. The initialized security blob is shipped to
    the other side via RPC. This process continues back and forth until the
    security APIs indicate that the context has been successfully generated or
    has failed.

Arguments:

    JoinSequence - Sequence number of the join. Used by the other node to
                   determine if this blob is the generation of a new context

    TargetNodeId - Id of the node with which to generate the context

    RoleOfClient - indicates whether the client establishing the security
                   context is acting as a cluster member or a joining
                   member. Determines when the client/server roles of
                   establishing a security context are reversed

    PackageInfo - pointer to security package info to be used

Return Value:

    ERROR_SUCCESS if everything worked ok...

--*/

{
    CtxtHandle          ClientContext;
    TimeStamp           Expiration;
    SecBufferDesc       ServerBufferDescriptor;
    SecBuffer           ServerSecurityToken;
    SecBufferDesc       ClientBufferDescriptor;
    SecBuffer           ClientSecurityToken;
    ULONG               ContextRequirements;
    ULONG               ContextAttributes;
    SECURITY_STATUS     OurStatus;
    SECURITY_STATUS     ServerStatus = SEC_I_CONTINUE_NEEDED;
    ULONG               passCount = 1;
    error_status_t      RPCStatus;
    DWORD               Status = ERROR_SUCCESS;
    DWORD               FacilityCode;
    PCLUSTER_SECURITY_DATA TargetSecurityData;

    ClRtlLogPrint(LOG_NOISE,"[ClMsg] Establishing outbound security context with the "
                          "%1!ws! package.\n",
                          PackageInfo->Name);

    //
    // obtain a security context with the target node by swapping token
    // buffers until the process is complete.
    //
    // Build the Client (caller of this function) and Server (target node)
    // buffer descriptors.
    //

    ServerBufferDescriptor.cBuffers = 1;
    ServerBufferDescriptor.pBuffers = &ServerSecurityToken;
    ServerBufferDescriptor.ulVersion = SECBUFFER_VERSION;

    ServerSecurityToken.BufferType = SECBUFFER_TOKEN;
    ServerSecurityToken.pvBuffer = LocalAlloc(LMEM_FIXED, PackageInfo->SecurityTokenSize);

    if ( ServerSecurityToken.pvBuffer == NULL ) {
        return GetLastError();
    }

    ClientBufferDescriptor.cBuffers = 1;
    ClientBufferDescriptor.pBuffers = &ClientSecurityToken;
    ClientBufferDescriptor.ulVersion = SECBUFFER_VERSION;

    ClientSecurityToken.BufferType = SECBUFFER_TOKEN;
    ClientSecurityToken.pvBuffer = LocalAlloc(LMEM_FIXED, PackageInfo->SecurityTokenSize);
    ClientSecurityToken.cbBuffer = 0;

    if ( ClientSecurityToken.pvBuffer == NULL ) {
        LocalFree( ServerSecurityToken.pvBuffer );
        return GetLastError();
    }

    //
    // Indicate context requirements. replay is necessary in order for the
    // context to generate valid signatures
    //
    ContextRequirements = ISC_REQ_MUTUAL_AUTH |
                          ISC_REQ_REPLAY_DETECT |
                          ISC_REQ_DATAGRAM;

    //
    // if there is an old outbound context, delete it now and mark it as
    // unstable
    //

    TargetSecurityData = &SecurityCtxtData[ INT_NODE( TargetNodeId )];

    EnterCriticalSection( &SecContextLock );

    if ( VALID_SSPI_HANDLE( TargetSecurityData->Outbound )) {
        (*SecurityFuncs->DeleteSecurityContext)( &TargetSecurityData->Outbound );
    }
    TargetSecurityData->OutboundStable = FALSE;

    LeaveCriticalSection( &SecContextLock );

    //
    // we obtain a blob from the SSPI provider, which is shiped over to the
    // other side where another blob is generated. This continues until the
    // two SSPI providers say we're done or an error has occurred.
    //

    do {

        //
        // init the output buffer each time we loop
        //
        ServerSecurityToken.cbBuffer = PackageInfo->SecurityTokenSize;

        EnterCriticalSection( &SecContextLock );

#if CLUSTER_BETA
        ClRtlLogPrint(LOG_NOISE,"[ClMsg] init pass %1!u!: server token size = %2!u!, "
                              "client = %3!u!\n",
                                passCount,
                                ServerSecurityToken.cbBuffer,
                                ClientSecurityToken.cbBuffer);
#endif

        OurStatus = (*SecurityFuncs->InitializeSecurityContext)(
                        &PackageInfo->OutboundSecurityCredentials,
                        passCount == 1 ? NULL : &TargetSecurityData->Outbound,
                        NULL, // CsServiceDomainAccount, BUGBUG Temporary Workaround See Bug 160108
                        ContextRequirements,
                        0,
                        SECURITY_NATIVE_DREP,
                        passCount == 1 ? NULL : &ClientBufferDescriptor,
                        0,
                        &TargetSecurityData->Outbound,
                        &ServerBufferDescriptor,
                        &ContextAttributes,
                        &Expiration);

#if CLUSTER_BETA
        ClRtlLogPrint(LOG_NOISE,"[ClMsg] after init pass %1!u!: status = %2!X!, server "
                              "token size = %3!u!, client = %4!u!\n",
                                passCount,
                                OurStatus,
                                ServerSecurityToken.cbBuffer,
                                ClientSecurityToken.cbBuffer);
#endif

        ClRtlLogPrint(LOG_NOISE,
                   "[ClMsg] The outbound security context to node %1!u! was %2!ws!, "
                    "status %3!08X!.\n",
                    TargetNodeId,
                    NT_SUCCESS( OurStatus ) ? L"initialized" : L"rejected",
                    OurStatus);

        if ( !NT_SUCCESS( OurStatus )) {

            if ( VALID_SSPI_HANDLE( TargetSecurityData->Outbound)) {

                (*SecurityFuncs->DeleteSecurityContext)( &TargetSecurityData->Outbound );
                INVALIDATE_SSPI_HANDLE( TargetSecurityData->Outbound );
            }

            LeaveCriticalSection( &SecContextLock );

            Status = OurStatus;
            break;
        }

        //
        // complete the blob if the Security package directs us as such
        //

        if ( OurStatus == SEC_I_COMPLETE_NEEDED ||
             OurStatus == SEC_I_COMPLETE_AND_CONTINUE ) {

            (*SecurityFuncs->CompleteAuthToken)(
                &TargetSecurityData->Outbound,
                &ServerBufferDescriptor
                );
        }

        LeaveCriticalSection( &SecContextLock );

        //
        // blobs are passed to the server side until it returns ok.
        //

        if (ServerStatus == SEC_I_CONTINUE_NEEDED ||
            ServerStatus == SEC_I_COMPLETE_AND_CONTINUE ) {

            ClientSecurityToken.cbBuffer = PackageInfo->SecurityTokenSize;

            RPCStatus = MmRpcEstablishSecurityContext(
                            Session[ TargetNodeId ],
                            JoinSequence,
                            NmLocalNodeId,
                            passCount == 1,
                            RoleOfClient,
                            ServerSecurityToken.pvBuffer,
                            ServerSecurityToken.cbBuffer,
                            ClientSecurityToken.pvBuffer,
                            &ClientSecurityToken.cbBuffer,
                            &ServerStatus);

            FacilityCode = HRESULT_FACILITY( ServerStatus );
            if (
                ( FacilityCode != 0 && !SUCCEEDED( ServerStatus ))
                ||
                ( FacilityCode == 0 && ServerStatus != ERROR_SUCCESS )
                ||
                RPCStatus != RPC_S_OK )
            {

                //
                // either the blob was rejected or we had an RPC failure. If
                // RPC, then ServerStatus is meaningless. Note that we don't
                // delete the security context on the side since that might
                // clobber an already negotiated context (i.e., the joiner has
                // already negotiated its outbound context and the sponsor is
                // in this routine trying to negotiate its outbound
                // context. If the sponsor negotiation fails at some point, we
                // don't want to whack the joiner's outbound context).
                //
                if ( RPCStatus != RPC_S_OK ) {
                    ServerStatus = RPCStatus;
                }

                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[ClMsg] The outbound security context was rejected by node %1!u!, "
                    "status 0x%2!08X!.\n",
                    TargetNodeId,
                    ServerStatus);

                EnterCriticalSection( &SecContextLock );

                if ( VALID_SSPI_HANDLE( TargetSecurityData->Outbound )) {
                    (*SecurityFuncs->DeleteSecurityContext)( &TargetSecurityData->Outbound );
                    INVALIDATE_SSPI_HANDLE( TargetSecurityData->Outbound );
                }

                LeaveCriticalSection( &SecContextLock );

                Status = ServerStatus;
                break;
            } else {
                ClRtlLogPrint(LOG_NOISE, 
                    "[ClMsg] The outbound security context was accepted by node %1!u!, "
                    "status 0x%2!08X!.\n",
                    TargetNodeId,
                    ServerStatus);
            }
        }

        ++passCount;

    } while ( ServerStatus == SEC_I_CONTINUE_NEEDED ||
              ServerStatus == SEC_I_COMPLETE_AND_CONTINUE ||
              OurStatus == SEC_I_CONTINUE_NEEDED ||
              OurStatus == SEC_I_COMPLETE_AND_CONTINUE );

    if ( OurStatus == SEC_E_OK && ServerStatus == SEC_E_OK ) {
        SecPkgContext_Sizes contextSizes;
        SecPkgContext_PackageInfo packageInfo;
        SYSTEMTIME localSystemTime;
        SYSTEMTIME renegotiateSystemTime;
        FILETIME expFileTime;
        FILETIME renegotiateFileTime;
        TIME_ZONE_INFORMATION timeZoneInfo;
        DWORD timeType;

#if 0
        //
        // convert the expiration time to something meaningful we can print in
        // the log.
        //
        timeType = GetTimeZoneInformation( &timeZoneInfo );

        if ( timeType != TIME_ZONE_ID_INVALID ) {
            expFileTime.dwLowDateTime = Expiration.LowPart;
            expFileTime.dwHighDateTime = Expiration.HighPart;
            if ( FileTimeToSystemTime( &expFileTime, &localSystemTime )) {
                PWCHAR timeDecoration = L"";

                if ( timeType == TIME_ZONE_ID_STANDARD ) {
                    timeDecoration = timeZoneInfo.StandardName;
                } else if ( timeType == TIME_ZONE_ID_DAYLIGHT ) {
                    timeDecoration = timeZoneInfo.DaylightName;
                }

                ClRtlLogPrint(LOG_NOISE,
                           "[ClMsg] Context expires at %1!u!:%2!02u!:%3!02u! %4!u!/%5!u!/%6!u! %7!ws!\n",
                            localSystemTime.wHour,
                            localSystemTime.wMinute,
                            localSystemTime.wSecond,
                            localSystemTime.wMonth,
                            localSystemTime.wDay,
                            localSystemTime.wYear,
                            timeDecoration);
            }
        }

        //
        // now compute the half life of the expiration and set a timer to go
        // off and renegotiate a context at that time
        //
#endif

        //
        // mark context data as usable and get the size of the signature
        // buffer
        //
        TargetSecurityData->InboundStable = TRUE;

        Status = (*SecurityFuncs->QueryContextAttributes)(
                     &TargetSecurityData->Inbound,
                     SECPKG_ATTR_SIZES,
                     &contextSizes);

        if ( !NT_SUCCESS( Status )) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[ClMsg] Unable to query signature size, status %1!08X!.\n",
                        Status);
            goto error_exit;
        }

        PackageInfo->SignatureBufferSize = contextSizes.cbMaxSignature;
        CL_ASSERT( contextSizes.cbMaxSignature <= MAX_SIGNATURE_SIZE );

        //
        // get the name of the negotiated package and import the contexts for
        // use in clusnet
        //
        Status = (*SecurityFuncs->QueryContextAttributes)(
                     &TargetSecurityData->Inbound,
                     SECPKG_ATTR_PACKAGE_INFO,
                     &packageInfo);

        if ( !NT_SUCCESS( Status )) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[ClMsg] Unable to query package info, status %1!08X!.\n",
                        Status);
            goto error_exit;
        }

        Status = ClMsgImportSecurityContexts(TargetNodeId,
                                             packageInfo.PackageInfo->Name,
                                             contextSizes.cbMaxSignature);

        (*SecurityFuncs->FreeContextBuffer)( packageInfo.PackageInfo );

        if ( Status != ERROR_SUCCESS ) {
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[ClMsg] Can't import node %1!u! security contexts on server, "
                        "status %2!08X!.\n",
                        TargetNodeId,
                        Status);
        }

        //
        // we have valid contexts with this package so record that this is the
        // one we're using
        //
        TargetSecurityData->PackageInfo = PackageInfo;
    }

error_exit:

    //
    // the context is stable (either good or invalid) at this point
    //

    EnterCriticalSection( &SecContextLock );
    TargetSecurityData->OutboundStable = TRUE;
    LeaveCriticalSection( &SecContextLock );

    //
    // free buffers used during this process
    //

    LocalFree( ClientSecurityToken.pvBuffer );
    LocalFree( ServerSecurityToken.pvBuffer );

    return Status;
} // ClMsgEstablishSecurityContext

//
// Exported Routines
//
DWORD
ClMsgInit(
    DWORD mynode
    )
{
    DWORD                status;
    SOCKADDR_CLUSTER     clusaddr;
    int                  err;
    DWORD                ignored;
    DWORD                bytesReceived = 0;
    WSABUF               wsaBuf;

    UNREFERENCED_PARAMETER(mynode);

    if (ClMsgInitialized == TRUE) {
        ClRtlLogPrint(LOG_NOISE, "[ClMsg] Already initialized!!!\n");
        return(ERROR_SUCCESS);
    }

    ClRtlLogPrint(LOG_NOISE, "[ClMsg] Initializing.\n");

    InitializeCriticalSection( &SecContextLock );

    //
    // load the security provider DLL and get the list of package names
    //
    status = ClMsgLoadSecurityProvider();
    if ( status != ERROR_SUCCESS ) {
        goto error_exit;
    }

    InitializeCriticalSection( &GenerationCritSect );
    
    //
    // Create the binding generation table.
    //
    BindingGeneration = LocalAlloc(
                  LMEM_FIXED,
                  sizeof(DWORD) * (NmMaxNodeId + 1)
                  );

    if (BindingGeneration == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    ZeroMemory(BindingGeneration, sizeof(DWORD) * (NmMaxNodeId + 1));
    
    //
    // Create the RPC binding handle table.
    //
    Session = LocalAlloc(
                  LMEM_FIXED,
                  sizeof(RPC_BINDING_HANDLE) * (NmMaxNodeId + 1)
                  );

    if (Session == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    ZeroMemory(Session, sizeof(RPC_BINDING_HANDLE) * (NmMaxNodeId + 1));

    //
    // Create a work queue to process overlapped I/O completions
    //
    WorkQueue = ClRtlCreateWorkQueue(
                    CLMSG_MAX_WORK_THREADS,
                    CLMSG_WORK_THREAD_PRIORITY
                    );

    if (WorkQueue == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[ClMsg] Unable to create work queue, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    //
    // Allocate a datagram receive context
    //
    DatagramContext = LocalAlloc(LMEM_FIXED, sizeof(CLMSG_DATAGRAM_CONTEXT));

    if (DatagramContext == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClMsg] Unable to allocate datagram receive buffer, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    //
    // Allocate an event receive context
    //
    EventContext = LocalAlloc(LMEM_FIXED, sizeof(CLMSG_EVENT_CONTEXT));

    if (EventContext == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClMsg] Unable to allocate event context, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    //
    // Open and bind the datagram socket
    //
    DatagramSocket = WSASocket(
                         AF_CLUSTER,
                         SOCK_DGRAM,
                         CLUSPROTO_CDP,
                         NULL,
                         0,
                         WSA_FLAG_OVERLAPPED
                         );

    if (DatagramSocket == INVALID_SOCKET) {
        status = WSAGetLastError();
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[ClMsg] Unable to create dgram socket, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    ZeroMemory(&clusaddr, sizeof(SOCKADDR_CLUSTER));

    clusaddr.sac_family = AF_CLUSTER;
    clusaddr.sac_port = CLMSG_DATAGRAM_PORT;
    clusaddr.sac_node = 0;

    err = bind(
              DatagramSocket,
              (struct sockaddr *) &clusaddr,
              sizeof(SOCKADDR_CLUSTER)
              );

    if (err == SOCKET_ERROR) {
        status = WSAGetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClMsg] Unable to bind dgram socket, status %1!u!\n",
            status
            );
        closesocket(DatagramSocket); DatagramSocket = INVALID_SOCKET;
        goto error_exit;
    }

    //
    // Tell the Cluster Transport to disable node state checks on
    // this socket.
    //
    err = WSAIoctl(
              DatagramSocket,
              SIO_CLUS_IGNORE_NODE_STATE,
              NULL,
              0,
              NULL,
              0,
              &ignored,
              NULL,
              NULL
              );

    if (err == SOCKET_ERROR) {
        status = WSAGetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClMsg] Ignore state ioctl failed, status %1!u!\n",
            status
            );
        closesocket(DatagramSocket); DatagramSocket = INVALID_SOCKET;
        goto error_exit;
    }

    //
    // Associate the socket with the work queue
    //
    status = ClRtlAssociateIoHandleWorkQueue(
                 WorkQueue,
                 (HANDLE) DatagramSocket,
                 0
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClMsg] Failed to associate socket with work queue, status %1!u!\n",
            status
            );
        closesocket(DatagramSocket); DatagramSocket = INVALID_SOCKET;
        goto error_exit;
    }

    //
    // Open a control channel to the Cluster Network driver.
    //
    ClusnetHandle = ClusnetOpenControlChannel(FILE_SHARE_READ);

    if (ClusnetHandle == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClMsg] Unable to open control channel to Cluster Network driver, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    //
    // Associate the control channel with the work queue
    //
    status = ClRtlAssociateIoHandleWorkQueue(
                 WorkQueue,
                 ClusnetHandle,
                 0
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClMsg] Failed to associate control channel with work queue, status %1!u!\n",
            status
            );
        CloseHandle(ClusnetHandle); ClusnetHandle = NULL;
        goto error_exit;
    }

    //
    // Post a receive on the socket
    //
    ZeroMemory(DatagramContext, sizeof(CLMSG_DATAGRAM_CONTEXT));

    DatagramContext->ClRtlWorkItem.WorkRoutine = ClMsgDatagramHandler,
    DatagramContext->ClRtlWorkItem.Context = DatagramContext;

    DatagramContext->SourceAddressLength = sizeof(SOCKADDR_CLUSTER);

    wsaBuf.len = sizeof( DatagramContext->Data );
    wsaBuf.buf = (PCHAR)&DatagramContext->Data;

    err = WSARecvFrom(
              DatagramSocket,
              &wsaBuf,
              1,
              &bytesReceived,
              &(DatagramContext->Flags),
              (struct sockaddr *) &(DatagramContext->SourceAddress),
              &(DatagramContext->SourceAddressLength),
              &(DatagramContext->ClRtlWorkItem.Overlapped),
              NULL
              );

    if (err == SOCKET_ERROR) {
        status = WSAGetLastError();

        if (status != WSA_IO_PENDING) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[ClMsg] Unable to post datagram receive, status %1!u!\n",
                status
                );
            goto error_exit;
        }
    }

    //
    // Enable delivery of all Cluster Network event types
    //
    status = ClusnetSetEventMask(ClusnetHandle, ClusnetEventAll);

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClMsg] Unable to set event mask, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    //
    // Post a work item to receive the next Cluster Network event
    //
    ClRtlInitializeWorkItem(
        &(EventContext->ClRtlWorkItem),
        ClMsgEventHandler,
        EventContext
        );

    status = ClusnetGetNextEvent(
                 ClusnetHandle,
                 &(EventContext->EventData),
                 &(EventContext->ClRtlWorkItem.Overlapped)
                 );

    if ((status != ERROR_IO_PENDING) && (status != ERROR_SUCCESS)) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[ClMsg] GetNextEvent failed, status %1!u!\n",
                status
                );
            goto error_exit;
    }

    ClMsgInitialized = TRUE;
    return(ERROR_SUCCESS);

error_exit:

    ClMsgCleanup();

    return(status);
} // ClMsgInit


VOID
ClMsgCleanup(
    VOID
    )
{
    ULONG                   i;
    PCLUSTER_PACKAGE_INFO   packageInfo;

    ClRtlLogPrint(LOG_NOISE, "[ClMsg] Cleaning up\n");

    if (Session != NULL) {
        LocalFree(Session); Session = NULL;
    }

    if (BindingGeneration != NULL) {
        LocalFree(BindingGeneration); BindingGeneration = NULL;
    }

    if (WorkQueue != NULL) {
        if (DatagramSocket != INVALID_SOCKET) {
            closesocket(DatagramSocket); DatagramSocket = INVALID_SOCKET;
        }
        else {
            if (DatagramContext != NULL) {
                LocalFree(DatagramContext); DatagramContext = NULL;
            }
        }

        if (ClusnetHandle != NULL) {
            CloseHandle(ClusnetHandle); ClusnetHandle = NULL;
        }
        else {
            if (EventContext != NULL) {
                LocalFree(EventContext); EventContext = NULL;
            }
        }

        ClRtlDestroyWorkQueue(WorkQueue); WorkQueue = NULL;
    }

    //
    // clean up the security related stuff
    //

    EnterCriticalSection( &SecContextLock );

    for ( i = ClusterMinNodeId; i <= NmMaxNodeId; ++i ) {
        PCLUSTER_SECURITY_DATA SecurityData = &SecurityCtxtData[ INT_NODE( i )];

        if ( VALID_SSPI_HANDLE( SecurityData->Outbound )) {

            (*SecurityFuncs->DeleteSecurityContext)( &SecurityData->Outbound );
            INVALIDATE_SSPI_HANDLE( SecurityData->Outbound );
        }

        if ( VALID_SSPI_HANDLE( SecurityData->Inbound )) {

            (*SecurityFuncs->DeleteSecurityContext)( &SecurityData->Inbound );
            INVALIDATE_SSPI_HANDLE( SecurityData->Inbound );
        }

        SecurityData->PackageInfo = NULL;
        SecurityData->InboundStable = TRUE;
        SecurityData->OutboundStable = TRUE;
    }

    LeaveCriticalSection( &SecContextLock );

    packageInfo = PackageInfoList;
    while ( packageInfo != NULL ) {
        PCLUSTER_PACKAGE_INFO lastInfo;

        if ( VALID_SSPI_HANDLE( packageInfo->OutboundSecurityCredentials )) {
            (*SecurityFuncs->FreeCredentialHandle)( &packageInfo->OutboundSecurityCredentials );
        }

        if ( VALID_SSPI_HANDLE( packageInfo->InboundSecurityCredentials )) {
            (*SecurityFuncs->FreeCredentialHandle)( &packageInfo->InboundSecurityCredentials );
        }

        LocalFree( packageInfo->Name );
        lastInfo = packageInfo;
        packageInfo = packageInfo->Next;
        LocalFree( lastInfo );
    }

    PackageInfoList = NULL;

    if ( SecurityProvider != NULL ) {
        FreeLibrary( SecurityProvider );
        SecurityProvider = NULL;
        SecurityFuncs = NULL;
    }

    ClMsgInitialized = FALSE;

    //
    // [REENGINEER] GorN 8/25/2000: if a join fails, ClMsgCleanup will be executed,
    // but some stray RPC thread can call s_MmRpcDeleteSecurityContext later.
    // s_MmRpcDeleteSecuryContext needs SecContextLock for synchronization
    // See bug #145746.
    // I traced the code and it seems that all code paths that execute ClMsgCleanup
    // will eventually lead to clustering service death, so it is valid (though ugly)
    // not to delete this critical section.
    //
    // DeleteCriticalSection( &SecContextLock );

    return;

}  // ClMsgCleanup


DWORD
ClMsgSendUnack(
    DWORD   DestinationNode,
    LPCSTR  Message,
    DWORD   MessageLength
    )

/*++

Description

    Send an unacknowledged datagram to the destintation node. The only
    packets coming through this function should be regroup packets.
    Heartbeats and poison packets originate in clusnet. Packets sent by
    MM as a result of the Join process are handled by MmRpcMsgSend, which
    is authenticated.

    A valid security context must be established between the local and
    destination node. The message is signed.

--*/
{
    DWORD                   status = ERROR_SUCCESS;
    SOCKADDR_CLUSTER        clusaddr;
    int                     bytesSent;
    SecBufferDesc           SignatureDescriptor;
    SecBuffer               SignatureSecBuffer[2];
    PUCHAR                  SignatureBuffer;
    WSABUF                  wsaBuf[2];
    SECURITY_STATUS         SecStatus;
    PCLUSTER_SECURITY_DATA  SecurityData;

    CL_ASSERT(ClMsgInitialized == TRUE);
    CL_ASSERT(DatagramSocket != INVALID_SOCKET);
    CL_ASSERT(DestinationNode <= NmMaxNodeId);

    if (DestinationNode == 0) {
        // no signing if multicasting
        
        ZeroMemory(&clusaddr, sizeof(SOCKADDR_CLUSTER));

        clusaddr.sac_family = AF_CLUSTER;
        clusaddr.sac_port = CLMSG_DATAGRAM_PORT;
        clusaddr.sac_node = DestinationNode;

        wsaBuf[0].len = MessageLength;
        wsaBuf[0].buf = (PCHAR)Message;

        status = WSASendTo(DatagramSocket,
                           wsaBuf,
                           1,
                           &bytesSent,
                           0,
                           (struct sockaddr *) &clusaddr,
                           sizeof(clusaddr),
                           NULL,
                           NULL);

        if (status == SOCKET_ERROR) {
            status = WSAGetLastError();
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[ClMsg] Multicast Datagram send failed, status %1!u!\n",
                        status
                        );
        }
        
    } else if (DestinationNode != NmLocalNodeId) {

        EnterCriticalSection( &SecContextLock );

        SecurityData = &SecurityCtxtData[ INT_NODE( DestinationNode )];
        CL_ASSERT( SecurityData->PackageInfo->SignatureBufferSize <= 256 );
        SignatureBuffer = _alloca( SecurityData->PackageInfo->SignatureBufferSize );
        if ( !SignatureBuffer ) {
            // if we fail - return error now
            LeaveCriticalSection( &SecContextLock );
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        if ( SecurityData->OutboundStable &&
             VALID_SSPI_HANDLE( SecurityData->Outbound)) {

            //
            // build a descriptor for the message and signature
            //

            SignatureDescriptor.cBuffers = 2;
            SignatureDescriptor.pBuffers = SignatureSecBuffer;
            SignatureDescriptor.ulVersion = SECBUFFER_VERSION;

            SignatureSecBuffer[0].BufferType = SECBUFFER_DATA;
            SignatureSecBuffer[0].cbBuffer = MessageLength;
            SignatureSecBuffer[0].pvBuffer = (PVOID)Message;

            SignatureSecBuffer[1].BufferType = SECBUFFER_TOKEN;
            SignatureSecBuffer[1].cbBuffer = SecurityData->PackageInfo->SignatureBufferSize;
            SignatureSecBuffer[1].pvBuffer = SignatureBuffer;

            //
            // generate the signature. We'll let the provider generate
            // the sequence number.
            //

            SecStatus = (*SecurityFuncs->MakeSignature)(
                            &SecurityData->Outbound,
                            0,
                            &SignatureDescriptor,
                            0);                        // no supplied sequence number

            LeaveCriticalSection( &SecContextLock );

            if ( NT_SUCCESS( SecStatus )) {

                ZeroMemory(&clusaddr, sizeof(SOCKADDR_CLUSTER));

                clusaddr.sac_family = AF_CLUSTER;
                clusaddr.sac_port = CLMSG_DATAGRAM_PORT;
                clusaddr.sac_node = DestinationNode;

                wsaBuf[0].len = MessageLength;
                wsaBuf[0].buf = (PCHAR)Message;

                wsaBuf[1].len = SecurityData->PackageInfo->SignatureBufferSize;
                wsaBuf[1].buf = (PCHAR)SignatureBuffer;

                status = WSASendTo(DatagramSocket,
                                   wsaBuf,
                                   2,
                                   &bytesSent,
                                   0,
                                   (struct sockaddr *) &clusaddr,
                                   sizeof(clusaddr),
                                   NULL,
                                   NULL);

                if (status == SOCKET_ERROR) {
                    status = WSAGetLastError();
                    ClRtlLogPrint(LOG_UNUSUAL,
                               "[ClMsg] Datagram send failed, status %1!u!\n",
                                status
                                );
                }
            } else {
                ClRtlLogPrint(LOG_UNUSUAL,
                           "[ClMsg] Couldn't create signature for packet to node %u. Status: %08X\n",
                            DestinationNode,
                            SecStatus);
            }
        } else {
            LeaveCriticalSection( &SecContextLock );
            status = ERROR_CLUSTER_NO_SECURITY_CONTEXT;

            ClRtlLogPrint(LOG_UNUSUAL,
                       "[ClMsg] No Security context for node %1!u!\n",
                        DestinationNode);
        }
    }
    else {
        MMDiag( (LPCSTR)Message, MessageLength, &MessageLength);
    }

    return(status);
} // ClMsgSendUnack


DWORD
ClMsgCreateRpcBinding(
    IN  PNM_NODE              Node,
    OUT RPC_BINDING_HANDLE *  BindingHandle,
    IN  DWORD                 RpcBindingOptions
    )
{
    DWORD                Status;
    RPC_BINDING_HANDLE   NewBindingHandle;
    WCHAR               *BindingString = NULL;
    CL_NODE_ID           NodeId = NmGetNodeId(Node);


    ClRtlLogPrint(LOG_NOISE, 
        "[ClMsg] Creating RPC binding for node %1!u!\n",
        NodeId
        );

    Status = RpcStringBindingComposeW(
                 L"e248d0b8-bf15-11cf-8c5e-08002bb49649",
                 CLUSTER_RPC_PROTSEQ,
                 (LPWSTR) OmObjectId(Node),
                 CLUSTER_RPC_PORT,
                 NULL,
                 &BindingString
                 );

    if (Status != RPC_S_OK) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClMsg] Failed to compose binding string for node %1!u!, status %2!u!\n",
            NodeId,
            Status
            );
        return(Status);
    }

    Status = RpcBindingFromStringBindingW(BindingString, &NewBindingHandle);

    RpcStringFreeW(&BindingString);

    if (Status != RPC_S_OK) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClMsg] Failed to compose binding handle for node %1!u!, status %2!u!\n",
            NodeId,
            Status
            );
        return(Status);
    }

    //
    // If we have RpcBindingOptions, then set them
    //
    if ( RpcBindingOptions ) {
        Status = RpcBindingSetOption(
                     NewBindingHandle,
                     RpcBindingOptions,
                     TRUE
                     );

        if (Status != RPC_S_OK) {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[ClMsg] Unable to set unique RPC binding option for node %1!u!, status %2!u!.\n",
                NodeId,
                Status
                );
        }
    }

    Status = RpcMgmtSetComTimeout(
                 NewBindingHandle,
                 CLUSTER_INTRACLUSTER_RPC_COM_TIMEOUT
                 );

    if (Status != RPC_S_OK) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[ClMsg] Unable to set RPC com timeout to node %1!u!, status %2!u!.\n",
            NodeId,
            Status
            );
    }

    Status = ClMsgVerifyRpcBinding(NewBindingHandle);

    if (Status == ERROR_SUCCESS) {
        *BindingHandle = NewBindingHandle;
    }

    return(Status);

} // ClMsgCreateRpcBinding


DWORD
ClMsgVerifyRpcBinding(
    IN RPC_BINDING_HANDLE  BindingHandle
    )
{
    DWORD    status = ERROR_SUCCESS;
    DWORD    packageIndex;


    if ( CsUseAuthenticatedRPC ) {

        //
        // establish a security context with for the intracluster binding. We
        // need a routine to call since datagram RPC doesn't set up the
        // context until the first call. MmRpcDeleteSecurityContext is
        // idempotent and won't do any damage in that respect.
        //
        for (packageIndex = 0;
             packageIndex < CsNumberOfRPCSecurityPackages;
             ++packageIndex )
        {
            status = RpcBindingSetAuthInfoW(
                         BindingHandle,
                         CsServiceDomainAccount,
                         RPC_C_AUTHN_LEVEL_CONNECT,
                         CsRPCSecurityPackage[ packageIndex ],
                         NULL,
                         RPC_C_AUTHZ_NAME
                         );

            if (status != RPC_S_OK) {
                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[ClMsg] Unable to set IntraCluster AuthInfo using %1!ws! "
                    "package, Status %2!u!.\n",
                    CsRPCSecurityPackageName[packageIndex],
                    status
                    );
                continue;
            }

            status = MmRpcDeleteSecurityContext(
                         BindingHandle,
                         NmLocalNodeId
                         );

            if ( status == RPC_S_OK ) {
                ClRtlLogPrint(LOG_NOISE, 
                    "[ClMsg] Using %1!ws! package for RPC security contexts.\n",
                    CsRPCSecurityPackageName[packageIndex]
                    );
                break;
            } else {
                ClRtlLogPrint(LOG_NOISE, 
                    "[ClMsg] Failed to establish RPC security context using %1!ws! package "
                    ", status %2!u!.\n",
                    CsRPCSecurityPackageName[packageIndex],
                    status
                    );
            }
        }
    }

    return(status);

} // ClMsgVerifyRpcBinding


VOID
ClMsgDeleteRpcBinding(
    IN RPC_BINDING_HANDLE  BindingHandle
    )
{
    RPC_BINDING_HANDLE  bindingHandle = BindingHandle;

    RpcBindingFree(&bindingHandle);

    return;

} // ClMsgDeleteRpcBinding


DWORD
ClMsgCreateDefaultRpcBinding(
    IN  PNM_NODE  Node,
    OUT PDWORD    Generation
    )
{
    DWORD                Status;
    RPC_BINDING_HANDLE   BindingHandle;
    CL_NODE_ID           NodeId = NmGetNodeId( Node );


    CL_ASSERT(Session != NULL);

    //
    // [GorN 08/01.99] InterlockedAdd will not work here,
    // see the code in ClMsgdeleteDefaultRpcBinding
    //
    EnterCriticalSection( &GenerationCritSect );
    
        *Generation = ++BindingGeneration[NodeId];
        
    LeaveCriticalSection( &GenerationCritSect );
    
    ClRtlLogPrint(LOG_NOISE, 
        "[ClMsg] BindingGeneration %1!u!\n",
        BindingGeneration[NodeId]
        );

    if (Session[NodeId] != NULL) {
        ClRtlLogPrint(LOG_NOISE, 
            "[ClMsg] Verifying old RPC binding for node %1!u!\n",
            NodeId
            );

        BindingHandle = Session[NodeId];

        Status = ClMsgVerifyRpcBinding(BindingHandle);
    }
    else {
        Status = ClMsgCreateRpcBinding(
                                Node,
                                &BindingHandle,
                                0 );

        if (Status == RPC_S_OK) {
            Session[NodeId] = BindingHandle;
        }
    }

    return(Status);

} // ClMsgCreateDefaultRpcBinding


VOID
ClMsgDeleteDefaultRpcBinding(
    IN PNM_NODE   Node,
    IN DWORD      Generation
    )
{
    CL_NODE_ID           NodeId = NmGetNodeId(Node);
    RPC_BINDING_HANDLE   BindingHandle;


    if (Session != NULL) {
        EnterCriticalSection( &GenerationCritSect );

        BindingHandle = Session[NodeId];
        
        if (Generation != BindingGeneration[NodeId]) {

            BindingHandle = NULL;
            
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[ClMsg] DeleteDefaultBinding. Gen %1!u! != BindingGen %2!u!\n",
                        Generation,
                        BindingGeneration[NodeId]);
            
        }
        
        LeaveCriticalSection( &GenerationCritSect );

        if (BindingHandle != NULL) {
            Session[NodeId] = NULL;
            ClMsgDeleteRpcBinding(BindingHandle);
        }
    }

    return;

} // ClMsgDeleteDefaultRpcBinding


DWORD
ClMsgCreateActiveNodeSecurityContext(
    IN DWORD     JoinSequence,
    IN PNM_NODE  Node
    )

/*++

Routine Description:

    Create security contexts between the joiner and the specified cluster
    member.

Arguments:

    JoinSequence - the current join sequence number. Used the sponsor to
                   determine if this is beginning of a new context generation
                   sequence

    Node - A pointer to the target node object.

Return Value:

    ERROR_SUCCESS if everything worked ok...

--*/

{
    DWORD               memberNodeId = NmGetNodeId( Node );
    CLUSTER_NODE_STATE  nodeState;
    DWORD               status = ERROR_SUCCESS;
    DWORD               internalMemberId;
    PCLUSTER_PACKAGE_INFO   packageInfo;

    nodeState = NmGetNodeState( Node );

    if (nodeState == ClusterNodeUp || nodeState == ClusterNodePaused) {

#if DBG
        CLUSNET_NODE_COMM_STATE   NodeCommState;

        status = ClusnetGetNodeCommState(
                     NmClusnetHandle,
                     memberNodeId,
                     &NodeCommState);

        CL_ASSERT(status == ERROR_SUCCESS);
        CL_ASSERT(NodeCommState == ClusnetNodeCommStateOnline);
#endif // DBG

        packageInfo = PackageInfoList;
        while ( packageInfo != NULL ) {

            status = ClMsgEstablishSecurityContext(JoinSequence,
                                                   memberNodeId,
                                                   SecurityRoleJoiningMember,
                                                   packageInfo);

            if ( status == ERROR_SUCCESS ) {
                break;
            }

            //
            // clean up if it didn't work
            //

            internalMemberId = INT_NODE( memberNodeId );

            EnterCriticalSection( &SecContextLock );

            if ( VALID_SSPI_HANDLE( SecurityCtxtData[ internalMemberId ].Outbound )) {
                (*SecurityFuncs->DeleteSecurityContext)(
                    &SecurityCtxtData[ internalMemberId ].Outbound);

                INVALIDATE_SSPI_HANDLE( SecurityCtxtData[ internalMemberId ].Outbound );
            }

            MmRpcDeleteSecurityContext(Session[ memberNodeId ],
                                       NmLocalNodeId);

            LeaveCriticalSection( &SecContextLock );
            packageInfo = packageInfo->Next;
        }
    }

    return status;
} // ClMsgCreateActiveNodeSecurityContext

error_status_t
s_TestRPCSecurity(
    IN handle_t IDL_handle
    )

/*++

Description:

    Dummy routine to make sure we don't get any failures due to
    authentication when calling other ExtroCluster interfaces

--*/

{
    return ERROR_SUCCESS;
} // s_TestRPCSecurity

error_status_t
s_MmRpcEstablishSecurityContext(
    IN handle_t IDL_handle,
    DWORD NmJoinSequence,
    DWORD EstablishingNodeId,
    BOOL FirstTime,
    SECURITY_ROLE RoleOfClient,
    const UCHAR *ServerContext,
    DWORD ServerContextLength,
    UCHAR *ClientContext,
    DWORD *ClientContextLength,
    HRESULT * ServerStatus
    )

/*++

Routine Description:

    Server side of the RPC interface for establishing a security context

Arguments:

    IDL_handle - RPC binding handle, not used.

    EstablishingNodeId - ID of node wishing to establish security context with us

    FirstTime - used for multi-leg authentication sequences

    RoleOfClient - indicates whether the client establishing the security
        context is acting as a cluster member or a joining member. Determines
        when the client/server roles of establishing a security context are
        reversed.

    ServerContext - security context buffer built by client and used as
        input by server

    ServerContextLength - size of ServerContext in bytes

    ClientContext - address of buffer used by Server in which to write
        context to be sent back to client

    ClientContextLength - pointer to size of ClientContext in bytes. Set by
        client on input to reflect length of ClientContext. Set by server to
        indicate length of ClientContext after AcceptSecurityContext is called.

    ServerStatus - pointer to value that receives status of security package
        call. This is not returned as a function value so as to distinguish
        between RPC errors and errors from this function.

Return Value:

    ERROR_SUCCESS if everything works ok.

--*/

{
    SecBufferDesc       ServerBufferDescriptor;
    SecBuffer           ServerSecurityToken;
    SecBufferDesc       ClientBufferDescriptor;
    SecBuffer           ClientSecurityToken;
    SECURITY_STATUS     Status = ERROR_SUCCESS;
    ULONG               ContextAttributes;
    TimeStamp           Expiration;
    PCLUSTER_SECURITY_DATA SecurityData;
    PNM_NODE            joinerNode = NULL;
    ULONG               contextRequirements;
    PCLUSTER_PACKAGE_INFO   clusterPackageInfo;
    static ULONG        passCount;

    CL_ASSERT(EstablishingNodeId >= ClusterMinNodeId &&
              EstablishingNodeId <= NmMaxNodeId );

    if (RoleOfClient == SecurityRoleJoiningMember) {
        //
        // The caller is a joining member.
        //
        joinerNode = NmReferenceJoinerNode(NmJoinSequence,
                                           EstablishingNodeId);

        if (joinerNode == NULL) {
            Status = GetLastError();
        }
    }
    else {
        //
        // The caller is a cluster member.
        //
        DWORD joinSequence = NmGetJoinSequence();
        CL_ASSERT(joinSequence == NmJoinSequence);

        if (joinSequence != NmJoinSequence) {
            //
            // This should never happen.
            //
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[NM] Received call to establish a security context from member node "
                        "%1!u! with bogus join sequence %2!u!.\n",
                        EstablishingNodeId,
                        NmJoinSequence);

            Status = ERROR_INVALID_PARAMETER;
        }
    }

    if ( Status != ERROR_SUCCESS ) {
        *ServerStatus = Status;
        return ERROR_SUCCESS;
    }

    if ( FirstTime ) {
        passCount = 1;

        ClRtlLogPrint(LOG_NOISE,
                   "[ClMsg] Establishing inbound security context with node %1!u!, sequence %2!u!\n",
                    EstablishingNodeId,
                    NmJoinSequence);
    } else {
        ++passCount;
    }

    SecurityData = &SecurityCtxtData[ INT_NODE( EstablishingNodeId )];
    EnterCriticalSection( &SecContextLock );

    //
    // if we have a leftover handle, try to zap it now
    //

    if ( FirstTime && VALID_SSPI_HANDLE( SecurityData->Inbound )) {

        (*SecurityFuncs->DeleteSecurityContext)( &SecurityData->Inbound );
        INVALIDATE_SSPI_HANDLE( SecurityData->Inbound );
        SecurityData->InboundStable = FALSE;
    }

    //
    // Build the input buffer descriptor.
    //

    ServerBufferDescriptor.cBuffers = 1;
    ServerBufferDescriptor.pBuffers = &ServerSecurityToken;
    ServerBufferDescriptor.ulVersion = SECBUFFER_VERSION;

    ServerSecurityToken.BufferType = SECBUFFER_TOKEN;
    ServerSecurityToken.cbBuffer = ServerContextLength;
    ServerSecurityToken.pvBuffer = (PUCHAR)ServerContext;

    //
    // Build the output buffer descriptor.
    //

    ClientBufferDescriptor.cBuffers = 1;
    ClientBufferDescriptor.pBuffers = &ClientSecurityToken;
    ClientBufferDescriptor.ulVersion = SECBUFFER_VERSION;

    ClientSecurityToken.BufferType = SECBUFFER_TOKEN;
    ClientSecurityToken.cbBuffer = *ClientContextLength;
    ClientSecurityToken.pvBuffer = ClientContext;

    contextRequirements = ASC_REQ_MUTUAL_AUTH |
                          ASC_REQ_REPLAY_DETECT |
                          ASC_REQ_DATAGRAM;

    //
    // we don't want to rely on version info to determine what type of package
    // the joiner is using, so we'll try to accept the context with all the
    // packages that are listed in the security package list.
    //
    if ( FirstTime ) {
        CL_ASSERT( PackageInfoList != NULL );

        clusterPackageInfo = PackageInfoList;
        while ( clusterPackageInfo != NULL ) {

            Status = (*SecurityFuncs->AcceptSecurityContext)(
                         &clusterPackageInfo->InboundSecurityCredentials,
                         NULL,
                         &ServerBufferDescriptor,
                         contextRequirements,
                         SECURITY_NATIVE_DREP,
                         &SecurityData->Inbound,   // receives new context handle
                         &ClientBufferDescriptor,  // receives output security token
                         &ContextAttributes,       // receives context attributes
                         &Expiration               // receives context expiration time
                         );

#if CLUSTER_BETA
            ClRtlLogPrint(LOG_NOISE,
                       "[ClMsg] pass 1 accept using %1!ws!: status = 0x%2!08X!, server "
                        "token size = %3!u!, client = %4!u!\n",
                        clusterPackageInfo->Name,
                        Status,
                        ServerSecurityToken.cbBuffer,
                        ClientSecurityToken.cbBuffer);
#endif

            ClRtlLogPrint(LOG_NOISE,
                       "[ClMsg] The inbound security context from node %1!u! using the "
                        "%2!ws! package was %3!ws!, status %4!08X!\n",
                        EstablishingNodeId,
                        clusterPackageInfo->Name,
                        NT_SUCCESS( Status ) ? L"accepted" : L"rejected",
                        Status);

            if ( NT_SUCCESS( Status )) {
                SecurityData->PackageInfo = clusterPackageInfo;
                break;
            }

            clusterPackageInfo = clusterPackageInfo->Next;
        }

        if ( !NT_SUCCESS( Status )) {
            goto error_exit;
        }
    } else {
        CL_ASSERT( SecurityData->PackageInfo != NULL );

        Status = (*SecurityFuncs->AcceptSecurityContext)(
                     &SecurityData->PackageInfo->InboundSecurityCredentials,
                     &SecurityData->Inbound,
                     &ServerBufferDescriptor,
                     contextRequirements,
                     SECURITY_NATIVE_DREP,
                     &SecurityData->Inbound,   // receives new context handle
                     &ClientBufferDescriptor,  // receives output security token
                     &ContextAttributes,       // receives context attributes
                     &Expiration               // receives context expiration time
                     );

#if CLUSTER_BETA
        ClRtlLogPrint(LOG_NOISE,
                   "[ClMsg] after pass %1!u! accept using %2!ws!: status = 0x%3!08X!, server "
                    "token size = %4!u!, client = %5!u!\n",
                    passCount,
                    SecurityData->PackageInfo->Name,
                    Status,
                    ServerSecurityToken.cbBuffer,
                    ClientSecurityToken.cbBuffer);
#endif

        ClRtlLogPrint(LOG_NOISE,
                   "[ClMsg] The inbound security context from node %1!u! using the %2!ws! package "
                    "was %3!ws!, status: %4!08X!\n",
                    EstablishingNodeId,
                    SecurityData->PackageInfo->Name,
                    NT_SUCCESS( Status ) ? L"accepted" : L"rejected",
                    Status);

        if ( !NT_SUCCESS( Status )) {
            goto error_exit;
        }
    }

    //
    // update the client's notion of how long its buffer is
    //

    *ClientContextLength = ClientSecurityToken.cbBuffer;

    if (Status == SEC_E_OK
        &&
        RoleOfClient == SecurityRoleJoiningMember)
    {

        //
        // now we have the server side (inbound) of a security context between
        // the joining node and its sponsor (the joining side may not be
        // completely done generating the context). This context is used by
        // the joining node to sign packets and by the sponsor to verify
        // them. Now we do the same thing with client/server roles reversed in
        // order to create an outbound security context which is used by the
        // sponsor to sign packets and by the joining node to verify those
        // packets.
        //
        // look up the package that was used to generate the inbound context
        // and use it for the outbound
        //
        SecPkgContext_PackageInfo packageInfo;

        Status = (*SecurityFuncs->QueryContextAttributes)(
                     &SecurityData->Inbound,
                     SECPKG_ATTR_PACKAGE_INFO,
                     &packageInfo);

        if ( !NT_SUCCESS( Status )) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[ClMsg] Unable to query inbound context package info, status %1!08X!.\n",
                        Status);
            goto error_exit;
        }

        clusterPackageInfo = PackageInfoList;
        while ( clusterPackageInfo != NULL ) {
            if (( wcscmp( clusterPackageInfo->Name, packageInfo.PackageInfo->Name ) == 0 )
                ||
                ( _wcsicmp( L"kerberos", packageInfo.PackageInfo->Name ) == 0
                  &&
                  _wcsicmp( L"negotiate", clusterPackageInfo->Name ) == 0
                ))
            {
                break;
            }

            clusterPackageInfo = clusterPackageInfo->Next;
        }

        if ( clusterPackageInfo == NULL ) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[ClMsg] Unable to find matching security package for %1!ws!.\n",
                        packageInfo.PackageInfo->Name);

            (*SecurityFuncs->FreeContextBuffer)( packageInfo.PackageInfo );
            Status = SEC_E_SECPKG_NOT_FOUND;
            goto error_exit;
        }

        (*SecurityFuncs->FreeContextBuffer)( packageInfo.PackageInfo );

        Status = ClMsgEstablishSecurityContext(NmJoinSequence,
                                               EstablishingNodeId,
                                               SecurityRoleClusterMember,
                                               clusterPackageInfo);
    }

    if ( !NT_SUCCESS( Status ) &&
         VALID_SSPI_HANDLE( SecurityData->Inbound)) {

        (*SecurityFuncs->DeleteSecurityContext)( &SecurityData->Inbound );
        INVALIDATE_SSPI_HANDLE( SecurityData->Inbound );
    }

    if (joinerNode != NULL) {
        NmDereferenceJoinerNode(joinerNode);
    }

error_exit:
    LeaveCriticalSection( &SecContextLock );
    *ServerStatus = Status;

    return ERROR_SUCCESS;
} // s_MmRpcEstablishSecurityContext

error_status_t
s_MmRpcDeleteSecurityContext(
    IN handle_t IDL_handle,
    DWORD NodeId
    )

/*++

Routine Description:

    Server side of the RPC interface for clearing a security context

Arguments:

    IDL_handle - RPC binding handle, not used.

    NodeId - Node ID of client wishing to tear down this context

Return Value:

    ERROR_SUCCESS

--*/

{
    PCLUSTER_SECURITY_DATA SecurityData;

    if ( NodeId >= ClusterMinNodeId && NodeId <= NmMaxNodeId ) {

        ClRtlLogPrint(LOG_NOISE,
                   "[ClMsg] Deleting security contexts for node %1!u!.\n",
                    NodeId);

        SecurityData = &SecurityCtxtData[ INT_NODE( NodeId )];

        EnterCriticalSection( &SecContextLock );

        if ( VALID_SSPI_HANDLE( SecurityData->Inbound)) {

            (*SecurityFuncs->DeleteSecurityContext)( &SecurityData->Inbound);
            INVALIDATE_SSPI_HANDLE( SecurityData->Inbound );
        }

        if ( VALID_SSPI_HANDLE( SecurityData->Outbound)) {

            (*SecurityFuncs->DeleteSecurityContext)( &SecurityData->Outbound);
            INVALIDATE_SSPI_HANDLE( SecurityData->Outbound );
        }

        SecurityData->OutboundStable = TRUE;
        SecurityData->InboundStable = TRUE;

        LeaveCriticalSection( &SecContextLock );
    }

    return ERROR_SUCCESS;
} // s_MmRpcDeleteSecurityContext

DWORD
ClSend(
    DWORD      targetnode,
    LPCSTR     buffer,
    DWORD      length,
    DWORD      timeout
    )
{

/* This sends the given message to the designated node, and receives
   an acknowledgement from the target to confirm good receipt. This
   function blocks until the msg is delivered to the target CM.
   The target node may not be Up at the time.

   The function will fail if the message is not acknowledged by the
   target node within <timeout> ms. <timeout> = -1 implies BLOCKING.


Errors:

xxx   No path to node; node went down.

xxx   Timeout
*/

    DWORD       status=RPC_S_OK;


    ClRtlLogPrint(LOG_NOISE, 
        "[ClMsg] send to node %1!u!\n",
        targetnode
        );

    if (targetnode != NmLocalNodeId) {
        CL_ASSERT(Session[targetnode] != NULL);

        NmStartRpc(targetnode);
        status = MmRpcMsgSend(
                     Session[targetnode],
                     buffer,
                     length);
        NmEndRpc(targetnode);

        if (status != ERROR_SUCCESS) {
            if (status == RPC_S_CALL_FAILED_DNE) {
                //
                // Try again since the first call to a restarted RPC server
                // will fail.
                //
                NmStartRpc(targetnode);
                status = MmRpcMsgSend(
                             Session[targetnode],
                             buffer,
                             length
                             );
                NmEndRpc(targetnode);

                if (status != ERROR_SUCCESS) {
                    ClRtlLogPrint(LOG_UNUSUAL, 
                        "[ClMsg] send failed, status %1!u!\n",
                        status
                        );
                }
            }
        }
        if(status != RPC_S_OK) {
            NmDumpRpcExtErrorInfo(status);
        }
    }
    else {
        MMDiag( (LPCSTR)buffer, sizeof(rgp_msgbuf), &length /* in/out */ );
        status = ERROR_SUCCESS;
    }

    return(status);
} // ClSend



error_status_t
s_MmRpcMsgSend(
    IN handle_t IDL_handle,
    IN const UCHAR *buffer,
    IN DWORD length
    )
/*++

Routine Description:

    Server side of the RPC interface for unacknowledge messages.

Arguments:

    IDL_handle - RPC binding handle, not used.

    buffer - Supplies a pointer to the message data.

    length - Supplies the length of the message data.

Return Value:

    ERROR_SUCCESS

--*/

{
    //
    // Dispatch the message.
    //
    MMDiag( (LPCSTR)buffer, sizeof(rgp_msgbuf), &length /* in/out */ );

    return(ERROR_SUCCESS);
} // s_MmRpcMsgSend


VOID
ClMsgBanishNode(
    IN CL_NODE_ID BanishedNodeId
    )

/*

  RPC to all the other cluster members that the specified node
  is banished. It must rejoin the cluster in order to participate
  in cluster activity

 */

{
    DWORD node;
    DWORD Status;
    node_t InternalNodeId;

    for (node = ClusterMinNodeId; node <= NmMaxNodeId; ++node ) {

        //
        // don't send this message to:
        // 1) us
        // 2) the banished node
        // 3) any other node we have marked as banished
        // 4) any node not part of the cluster
        //

        InternalNodeId = INT_NODE( node );

        if ( node != NmLocalNodeId &&
             node != BanishedNodeId &&
             !ClusterMember(
                 rgp->OS_specific_control.Banished,
                 InternalNodeId
                 ) &&
             ClusterMember( rgp->outerscreen, InternalNodeId ))
        {

            Status = MmRpcBanishNode( Session[node], BanishedNodeId );

            if( Status != ERROR_SUCCESS ) {
               ClRtlLogPrint(LOG_UNUSUAL, 
                   "[ClMsg] Node %1!u! failed request to banish node %2!u!, status %3!u!\n",
                   node, BanishedNodeId, Status
                   );
            }
        }
    }
}

error_status_t
s_MmRpcBanishNode(
    IN handle_t IDL_handle,
    IN DWORD BanishedNodeId
    )
{
    RGP_LOCK;

    if ( !ClusterMember (
             rgp->outerscreen,
             INT_NODE(BanishedNodeId) )
       )
    {
       int perturbed = rgp_is_perturbed();

       RGP_UNLOCK;

       if (perturbed) {
          ClRtlLogPrint(LOG_UNUSUAL, 
              "[MM] s_MmRpcBanishNode: %1!u!, banishing is already in progress.\n",
              BanishedNodeId
              );
       } else {
          ClRtlLogPrint(LOG_UNUSUAL, 
              "[MM] s_MmRpcBanishNode: %1!u! is already banished.\n",
              BanishedNodeId
              );
       }

       return MM_OK;
    }

    rgp_event_handler( RGP_EVT_BANISH_NODE, (node_t) BanishedNodeId );

    RGP_UNLOCK;

    return ERROR_SUCCESS;

} // s_MmRpcBanishNode

/************************************************************************
 *
 * MMiNodeDownCallback
 * ===================
 *
 * Description:
 *
 *     This Membership Manager internal routine is registered with the
 *     OS-independent portion of the regroup engine to get called when
 *     a node is declared down.  This routine will then call the "real"
 *     callback routine which was registered with the MMInit call.
 *
 * Parameters:
 *
 *     failed_nodes
 *         bitmask of the nodes that failed.
 *
 * Returns:
 *
 *   none
 *
 ************************************************************************/

void
MMiNodeDownCallback(
    IN cluster_t failed_nodes
    )
{
    BITSET bitset;
    node_t i;

    //
    // Translate cluster_t into Bitset
    // and call NodesDownCallback
    //
    BitsetInit(bitset);
    for ( i=0; i < (node_t) rgp->num_nodes; i++)
    {
        if ( ClusterMember(failed_nodes, i) ) {
           BitsetAdd(bitset, EXT_NODE(i));
        }
    }

    //
    // [Future] - Leave the binding handle in place so we can send back
    //          poison packets. Reinstate the delete when we have a
    //          real response mechanism.
    //
    // ClMsgDeleteNodeBinding(nodeId);

    if ( rgp->OS_specific_control.NodesDownCallback != RGP_NULL_PTR ) {
        (*(rgp->OS_specific_control.NodesDownCallback))( bitset );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\mm\srgpos.c ===
#ifdef __TANDEM
#pragma columns 79
#pragma page "srgpos.c - T9050 - OS-dependent routines for Regroup Module"
#endif

/* @@@ START COPYRIGHT @@@
**  Tandem Confidential:  Need to Know only
**  Copyright (c) 1995, Tandem Computers Incorporated
**  Protected as an unpublished work.
**  All Rights Reserved.
**
**  The computer program listings, specifications, and documentation
**  herein are the property of Tandem Computers Incorporated and shall
**  not be reproduced, copied, disclosed, or used in whole or in part
**  for any reason without the prior express written permission of
**  Tandem Computers Incorporated.
**
** @@@ END COPYRIGHT @@@
**/

/*---------------------------------------------------------------------------
 * This file (srgpos.c) contains OS-specific code used by Regroup.
 *---------------------------------------------------------------------------*/


#ifdef __cplusplus
   extern "C" {
#endif /* __cplusplus */


#include <wrgp.h>

#ifdef NSK
#include <pmsgrgp.h>
#endif /* NSK */

#if defined(NT)

DWORD
MmSetThreadPriority(
    VOID
    );

void
NT_timer_thread(
    void
    );

PWCHAR
RgpGetNodeNameFromId(
    node_t
    );

#endif // NT

/* The global pointer to regroup's internal data structure. */

#ifdef NSK
/* The global regroup pointer is #defined to a pointer in the message
 * system root structure.
 */
#endif

#if defined(LCU) || defined(UNIX) || defined(NT)
rgp_control_t *rgp = (rgp_control_t *) RGP_NULL_PTR;
DWORD  QuorumOwner = MM_INVALID_NODE; 
  /* quorum owner can be set by the forming node before rgp is initialized */
#endif /* LCU || UNIX || NT */


#ifdef LCU

/************************************************************************
 * rgp_lcu_serv_listen
 * ===================
 *
 * Description:
 *
 *    This is an LCU-specific routine that gets called in IPC interrupt
 *    context when a datagram addressed to the Regroup Module is received.
 *
 * Parameters:
 *
 *    void     *listen_callarg  - required param, unused by regroup
 *    lcumsg_t *lcumsgp         - pointer to message
 *    uint     moredata         - required param, unused by regroup
 *
 * Returns:
 *
 *    int - Always returns ELCU_OK
 *
 * Algorithm:
 *
 *    The routine simply picks apart the arguments and calls
 *    rgp_received_packet().
 *
 *
 ************************************************************************/
_priv _resident int
rgp_lcu_serv_listen(void *listen_callarg, lcumsg_t *lcumsgp, uint moredata)
{
   /* Ignore if the packet is not from the local system. */
   if (lcumsgp->lcu_sysnum == rgp->OS_specific_control.my_sysnum)
      rgp_received_packet(lcumsgp->lcu_node,
                lcumsgp->lcu_reqmbuf.lcu_ctrlbuf,
                lcumsgp->lcu_reqmbuf.lcu_ctrllen);
   return(ELCU_OK);
}


/************************************************************************
 * rgp_lcu_event_callback
 * ======================
 *
 * Description:
 *
 *    This is an LCU-specific routine that gets called in IPC interrupt
 *    context when the LCUEV_NODE_UNREACHABLE event is generated.
 *
 * Parameters:
 *
 *    ulong      event        -  event # (= LCUEV_NODE_UNREACHABLE)
 *    sysnum_t   sysnum       -  system # (= local system #)
 *    nodenum_t  node         -  # of node that is unreachable
 *    int        event_info   -  required parameter, unused by regroup
 *
 * Returns:
 *
 *    void - no return value
 *
 * Algorithm:
 *
 *    The routine simply transforms the LCU event into the regroup event
 *    RGP_EVT_NODE_UNREACHABLE and calls rgp_event_handler().
 *
 ************************************************************************/
_priv _resident void
rgp_lcu_event_callback(
   ulong      event,
   sysnum_t   sysnum,
   nodenum_t  node,
   int        event_info)
{
   /* Sanity checks:
    * (1) The event must be LCUEV_NODE_UNREACHABLE, the only event
    *     we asked for.
    * (1) The event must be for the local system, the only system
    *     we asked for.
    */
   if ((event != LCUEV_NODE_UNREACHABLE) ||
       (sysnum != rgp->OS_specific_control.my_sysnum))
      RGP_ERROR(RGP_INTERNAL_ERROR);

   rgp_event_handler(RGP_EVT_NODE_UNREACHABLE, node);
}

#endif /* LCU */


/************************************************************************
 * rgp_init_OS
 * ===========
 *
 * Description:
 *
 *    This routine does OS-dependent regroup initialization such as
 *    initializing the regroup data structure lock, requesting a
 *    periodic timer to be installed and registering the callback
 *    routine for receiving regroup's unacknowledged packets.
 *
 * Parameters:
 *
 *    None
 *
 * Returns:
 *
 *    void - no return value
 *
 * Algorithm:
 *
 *    OS-dependent initializations.
 *
 ************************************************************************/
_priv _resident void
rgp_init_OS(void)
{

#ifdef UNIX
   struct sigaction sig_action; /* to install signals */
#endif
#ifdef LCU
   sysnum_t sysnum;
   lcumsg_t *lcumsgp;
#endif
#ifdef NT
   HANDLE       tempHandle;
   DWORD        threadID = 0;
#endif

#if defined(NSK) || defined(UNIX) || defined(NT)
   /*
    * In NSK, the regroup caller ensures that timer and IPC interrupts
    * are disabled before the regroup routines are called. Therefore,
    * there is no regroup lock initialization. Also, rather than using
    * registration of callback routines, the appropriate routine names
    * are hard coded into routines that must call them. Thus, the timer
    * routine is called from POLLINGCHECK, the periodic message system
    * routine, and the packet reception routine is called from the
    * IPC interrupt handler.
    */

   /* Initialize the unchanging fields in the rgp_msgsys struct. */

   rgp->rgp_msgsys_p->regroup_data = (void *) &(rgp->rgppkt_to_send);
   rgp->rgp_msgsys_p->regroup_datalen = RGPPKTLEN;
   rgp->rgp_msgsys_p->iamalive_data = (void *) &(rgp->iamalive_pkt);
   rgp->rgp_msgsys_p->iamalive_datalen = IAMALIVEPKTLEN;
   rgp->rgp_msgsys_p->poison_data = (void *) &(rgp->poison_pkt);
   rgp->rgp_msgsys_p->poison_datalen = POISONPKTLEN;

#endif /* NSK || UNIX || NT */

#ifdef LCU

   if (itimeout(rgp_periodic_check,
                NULL, /* parameter pointer */
                ((RGP_CLOCK_PERIOD * HZ) / 100) | TO_PERIODIC,
                plstr /* interrupt priority level */
               ) == 0)
      RGP_ERROR(RGP_INTERNAL_ERROR);
   if (lcuxprt_listen(LCU_RGP_PORT,
                      rgp_lcu_serv_listen,
                      NULL /* no call arg */,
                      NULL /* no options */
                     ) != ELCU_OK)
      RGP_ERROR(RGP_INTERNAL_ERROR);

   if (lcuxprt_config(LCU_GET_MYSYSNUM, &sysnum) != ELCU_OK)
      RGP_ERROR(RGP_INTERNAL_ERROR);
   rgp->OS_specific_control.my_sysnum = sysnum;

   /* Allocate 3 message buffers to send regroup packets, iamalive packets
    * and poison packets.
    */
   if ((lcumsgp = lcuxprt_msg_alloc(LCU_UNACKMSG, LCU_RGP_FLAGS)) == NULL)
      RGP_ERROR(RGP_INTERNAL_ERROR); /* no memory */
   rgp->OS_specific_control.lcumsg_regroup_p = lcumsgp;
   lcumsgp->lcu_tag = NULL;
   lcumsgp->lcu_sysnum = sysnum;
   lcumsgp->lcu_port = LCU_RGP_PORT;
   lcumsgp->lcu_flags = LCUMSG_CRITICAL;
   lcumsgp->lcu_reqmbuf.lcu_ctrllen = RGPPKTLEN;
   lcumsgp->lcu_reqmbuf.lcu_ctrlbuf = (char *)&(rgp->rgppkt_to_send);

   if ((lcumsgp = lcuxprt_msg_alloc(LCU_UNACKMSG, LCU_RGP_FLAGS)) == NULL)
      RGP_ERROR(RGP_INTERNAL_ERROR); /* no memory */
   rgp->OS_specific_control.lcumsg_iamalive_p = lcumsgp;
   lcumsgp->lcu_tag = NULL;
   lcumsgp->lcu_sysnum = sysnum;
   lcumsgp->lcu_port = LCU_RGP_PORT;
   lcumsgp->lcu_reqmbuf.lcu_ctrllen = IAMALIVEPKTLEN;
   lcumsgp->lcu_reqmbuf.lcu_ctrlbuf = (char *)&(rgp->iamalive_pkt);

   if ((lcumsgp = lcuxprt_msg_alloc(LCU_UNACKMSG, LCU_RGP_FLAGS)) == NULL)
      RGP_ERROR(RGP_INTERNAL_ERROR); /* no memory */
   rgp->OS_specific_control.lcumsg_poison_p = lcumsgp;
   lcumsgp->lcu_tag = NULL;
   lcumsgp->lcu_sysnum = sysnum;
   lcumsgp->lcu_port = LCU_RGP_PORT;
   lcumsgp->lcu_reqmbuf.lcu_ctrllen = POISONPKTLEN;
   lcumsgp->lcu_reqmbuf.lcu_ctrlbuf = (char *)&(rgp->poison_pkt);

   /* Register to get the LCUEV_NODE_UNREACHABLE event. */
   if (lcuxprt_events(LCU_CATCH_EVENTS, sysnum, LCUEV_NODE_UNREACHABLE,
                      rgp_lcu_event_callback) != ELCU_OK)
      RGP_ERROR(RGP_INTERNAL_ERROR);

#endif /* LCU */

#ifdef UNIX
   /* For testing on UNIX at user level, we use alarm() to simulate timer
    * ticks. */
   /* Install the alarm handler. */
   sig_action.sa_flags = 0;
   sig_action.sa_handler = alarm_handler;
   sigemptyset(&(sig_action.sa_mask));
   /* Block messages when handling timer pops. */
   sigaddset(&(sig_action.sa_mask), SIGPOLL);
   sigaction(SIGALRM, &sig_action, NULL);

   alarm_callback = rgp_periodic_check;

   /* Round up the alarm period to the next higher second. */
   alarm_period = (RGP_CLOCK_PERIOD + 99) / 100;

   /* Get first timer tick as soon as possible; subsequent ones will be
    * at alarm_period.
    */
   alarm(1);
#endif /* UNIX */

#ifdef NT
   /* On NT we create a separate thread that will be our timer. */
   /* The Timer Thread waits on TimerSignal Event to indicate an RGP rate change. */
   /* An RGP rate of 0 is a signal for the Timer Thread to exit */

   tempHandle = CreateEvent ( NULL,         /* no security */
                              FALSE,        /* Autoreset */
                              TRUE,         /* Initial State is Signalled */
                              NULL);        /* No name */
   if ( !tempHandle )
   {
           RGP_ERROR (RGP_INTERNAL_ERROR);
   }
   rgp->OS_specific_control.TimerSignal = tempHandle;
   
   tempHandle = CreateEvent ( NULL,         /* no security */
                              TRUE,         /* Manual reset */
                              TRUE,         /* Initial State is Signalled */
                              NULL);        /* No name */
   if ( !tempHandle )
   {
           RGP_ERROR (RGP_INTERNAL_ERROR);
   }
   rgp->OS_specific_control.Stabilized = tempHandle;
   rgp->OS_specific_control.ArbitrationInProgress = FALSE;
   rgp->OS_specific_control.ArbitratingNode = MM_INVALID_NODE;
   rgp->OS_specific_control.ApproxArbitrationWinner = MM_INVALID_NODE;
   rgp->OS_specific_control.ShuttingDown = FALSE;

   tempHandle = CreateThread( 0,                /* security */
                              0,                /* stack size - use same as primary thread */
                              (LPTHREAD_START_ROUTINE)NT_timer_thread,      /* starting point */
                              (VOID *) NULL,    /* no parameter */
                              0,                /* create flags - start immediately */
                              &threadID );      /* thread ID returned here */
   if ( !tempHandle )
   {
                RGP_ERROR( RGP_INTERNAL_ERROR );        /* at least for now */
   }
   rgp->OS_specific_control.TimerThread = tempHandle;
   rgp->OS_specific_control.TimerThreadId = threadID;

   rgp->OS_specific_control.UpDownCallback = RGP_NULL_PTR;
   rgp->OS_specific_control.NodesDownCallback = RGP_NULL_PTR;
   rgp->OS_specific_control.EventEpoch = 0;

#if defined TDM_DEBUG
   rgp->OS_specific_control.debug.frozen = 0;
   rgp->OS_specific_control.debug.reload_in_progress = 0;
   rgp->OS_specific_control.debug.timer_frozen = 0;
   rgp->OS_specific_control.debug.doing_tracing = 0;
   rgp->OS_specific_control.debug.MyTestPoints.TestPointWord = 0;

   // seed the random number function used in testing
   srand((unsigned) time( NULL ) );
#endif

#endif /* NT */



}

/************************************************************************
 * rgp_cleanup_OS
 * ===========
 *
 * Description:
 *
 *    This routine does OS-dependent cleanup of regroup structures
 *    and timer thread activity to ready for a new JOIN attempt.
 *
 * Parameters:
 *
 *    None
 *
 * Returns:
 *
 *    void - no return value
 *
 * Algorithm:
 *
 *    OS-dependent initializations.
 *
 ************************************************************************/
_priv _resident void
rgp_cleanup_OS(void)
{
#if defined (NT)
        // Tell Timer Thread to restart RGP Timer
        // a_tick might have changed.
        SetEvent( rgp->OS_specific_control.TimerSignal);
#endif // NT
}


/************************************************************************
 * rgp_update_regroup_packet
 * =========================
 *
 * Description:
 *
 *    Macro to copy the current regroup status into the regroup packet
 *    sending buffer.
 *
 * Parameters:
 *
 *    None
 *
 * Algorithm:
 *
 *    Copies the status (which is already in the form of a regroup status
 *    packet) into the packet buffer. Then, if we should let others (and
 *    ourselves) know of our stage, the current knownstage field is
 *    updated to include the local node number.
 *
 ************************************************************************/
#define rgp_update_regroup_packet                                        \
do                                                                       \
{                                                                        \
   /* Copy the regroup status to the sending packet area. */             \
   rgp->rgppkt_to_send = rgp->rgppkt;                                    \
                                                                         \
   /* If we should let others know of our stage, we must modify the      \
    * current stage mask to include ourselves.                           \
    */                                                                   \
   if (rgp->sendstage)                                                   \
      switch (rgp->rgppkt.stage)                                         \
      {                                                                  \
         case RGP_ACTIVATED:                                             \
            ClusterInsert(rgp->rgppkt_to_send.knownstage1, rgp->mynode); \
            break;                                                       \
         case RGP_CLOSING:                                               \
            ClusterInsert(rgp->rgppkt_to_send.knownstage2, rgp->mynode); \
            break;                                                       \
         case RGP_PRUNING:                                               \
            ClusterInsert(rgp->rgppkt_to_send.knownstage3, rgp->mynode); \
            break;                                                       \
         case RGP_PHASE1_CLEANUP:                                        \
            ClusterInsert(rgp->rgppkt_to_send.knownstage4, rgp->mynode); \
            break;                                                       \
         case RGP_PHASE2_CLEANUP:                                        \
            ClusterInsert(rgp->rgppkt_to_send.knownstage5, rgp->mynode); \
            break;                                                       \
         default:                                                        \
            break;                                                       \
      }                                                                  \
} while(0)


/************************************************************************
 * rgp_update_poison_packet
 * ========================
 *
 * Description:
 *
 *    Macro to copy the current regroup status into the poison packet
 *    sending buffer.
 *
 * Parameters:
 *
 *    None
 *
 * Algorithm:
 *
 *    Copies the appropriate regroup status fields into the poison
 *    packet buffer to help debugging when a dump of a poisoned
 *    node is examined.
 *
 ************************************************************************/
#define rgp_update_poison_packet                                         \
do                                                                       \
{                                                                        \
   rgp->poison_pkt.seqno = rgp->rgppkt.seqno;                            \
   rgp->poison_pkt.reason = rgp->rgppkt.reason;                          \
   rgp->poison_pkt.activatingnode = rgp->rgppkt.activatingnode;          \
   rgp->poison_pkt.causingnode = rgp->rgppkt.causingnode;                \
   ClusterCopy(rgp->poison_pkt.initnodes, rgp->initnodes);               \
   ClusterCopy(rgp->poison_pkt.endnodes, rgp->endnodes);                 \
} while(0)


/************************************************************************
 * rgp_broadcast
 * =============
 *
 * Description:
 *
 *    This routine asks the message system to broadcast an unacknowledged
 *    packet of subtype "packet_subtype" to a set of nodes indicated in
 *    an appropriate field in the rgp control struct. How the broadcast
 *    is implemented depends on the OS.
 *
 * Parameters:
 *
 *    uint8 packet_subtype - type of unsequenced packet to send
 *
 * Returns:
 *
 *    void - no return value
 *
 * Algorithm:
 *
 *    The same data packet is to be sent to the set of nodes indicated
 *    in the rgp control struct field. The sending can be done by queueing
 *    the packets directly to the send engine or the send can be deferred
 *    to a lower priority interrupt level. The former approach reduces
 *    the latency for sending these urgent packets while the latter
 *    approach may reduce the number of sends if several requests to
 *    send the same type of packets (this is true only of regroup
 *    packets) are made in quick succession. In this case, previous
 *    requests are overwritten by later requests. This is OK since the
 *    regroup algorithm has enough redundancy in packet sending.
 *
 *    In NSK, the message system provides a broadcast facility for
 *    unacknowledged packets. It copies regroup's packet into its own
 *    buffer and issues multiple requests to the SNet services layer.
 *    When it copies the buffer, it disables the timer and IPC
 *    interrupts ensuring that there will be no contention with Regroup.
 *    Therefore, this routine can safely update the packet area here
 *    without checking if the sending apparatus has completed sending
 *    the previous packet.
 *
 *    This is not true of LCU where the message system does not
 *    provide a broadcast facility. In LCU, the updating of the packet
 *    buffer can be done only when the send engine has completed
 *    sending. This is assured only in the send completion interrupt
 *    handler (rgp_msgsys_work).
 *
 ************************************************************************/
_priv _resident void
rgp_broadcast(uint8 packet_subtype)
{
   cluster_t temp_cluster;

   switch (packet_subtype)
   {
      case RGP_UNACK_REGROUP :

         /* Trace the queueing of regroup status packets. */
         RGP_TRACE( "RGP Send packets",
                    rgp->rgppkt.stage,                             /* TRACE */
                    RGP_MERGE_TO_32( rgp->status_targets,          /* TRACE */
                                     rgp->rgppkt.knownstage1 ),    /* TRACE */
                    RGP_MERGE_TO_32( rgp->rgppkt.knownstage2,      /* TRACE */
                                     rgp->rgppkt.knownstage3 ),    /* TRACE */
                    RGP_MERGE_TO_32( rgp->rgppkt.knownstage4,      /* TRACE */
                                     rgp->rgppkt.knownstage5 ) );  /* TRACE */

#if defined(NSK) || defined(UNIX) || defined(NT)
         /* In NSK, the packet buffer can be updated even if the send
          * engine is working on the previous send. See algorithm
          * description above.
          */

         if ((rgp->rgppkt.reason == MM_EVT_LEAVE) &&
                         (rgp->rgppkt.causingnode == rgp->mynode))
                         // If a LEAVE event is in progress exclude our node from knownstage mask
                         rgp->rgppkt_to_send = rgp->rgppkt;
                 else
                         // copy regroup packet and insert our node number into knownstage mask
                         rgp_update_regroup_packet;
#endif /* NSK || UNIX || NT */

         ClusterUnion(rgp->rgp_msgsys_p->regroup_nodes,
                      rgp->status_targets,
                      rgp->rgp_msgsys_p->regroup_nodes);

         /* Clear the targets field in the rgp_control struct after
          * copying this info. The message system must clear the target
          * bits in the common regroup/msgsys struct after sending the
          * packets.
          */
         ClusterInit(rgp->status_targets);

         rgp->rgp_msgsys_p->sendrgppkts = 1;

         break;

      case RGP_UNACK_IAMALIVE :

         /* Count number of IamAlive requests queued. */
         RGP_INCREMENT_COUNTER( QueuedIAmAlive );

         ClusterUnion(rgp->rgp_msgsys_p->iamalive_nodes,
                      rgp->rgpinfo.cluster,
                      rgp->rgp_msgsys_p->iamalive_nodes);
         rgp->rgp_msgsys_p->sendiamalives = 1;

         /* No targets field to clear in the rgp_control struct.
          * The message system must clear the target bits in the common
          * regroup/msgsys struct after sending the packets.
          */
         break;

      case RGP_UNACK_POISON :

         /* Trace the sending of poison packets. */
         RGP_TRACE( "RGP Send poison ",
                    rgp->rgppkt.stage,                             /* TRACE */
                    RGP_MERGE_TO_32( rgp->poison_targets,          /* TRACE */
                                     rgp->rgppkt.knownstage1 ),    /* TRACE */
                    RGP_MERGE_TO_32( rgp->rgppkt.knownstage2,      /* TRACE */
                                     rgp->rgppkt.knownstage3 ),    /* TRACE */
                    RGP_MERGE_TO_32( rgp->rgppkt.knownstage4,      /* TRACE */
                                     rgp->rgppkt.knownstage5 ) );  /* TRACE */

         /* The poison packet targets must NOT be considered alive. */

         ClusterIntersection(temp_cluster, rgp->rgpinfo.cluster,
                             rgp->poison_targets);

         ClusterDifference(temp_cluster,
                           temp_cluster,
                           rgp->OS_specific_control.Banished);

         if (ClusterNumMembers(temp_cluster) != 0)
               RGP_ERROR(RGP_INTERNAL_ERROR);

#if defined(NSK) || defined(NT)
         /* In NSK, the packet buffer can be updated even if the send
          * engine is working on the previous send. See algorithm
          * description above.
          */
         rgp_update_poison_packet;
#endif /* NSK || NT */

         ClusterUnion(rgp->rgp_msgsys_p->poison_nodes,
                      rgp->poison_targets,
                      rgp->rgp_msgsys_p->poison_nodes);

         /* Clear the targets field in the rgp_control struct after
          * copying this info. The message system must clear the target
          * bits in the common regroup/msgsys struct after sending the
          * packets.
          */
         ClusterInit(rgp->poison_targets);

         rgp->rgp_msgsys_p->sendpoisons = 1;

         break;

      default :

         RGP_ERROR(RGP_INTERNAL_ERROR);
         break;
   }

   QUEUESEND; /* invoke OS-specific sending function/macro */
}


/************************************************************************
 * rgp_had_power_failure
 * =====================
 *
 * Description:
 *
 *    Tells the OS at the end of a regroup incident if a surviving node
 *    had a power failure. The message system can use this to clear all
 *    bus errors collected so far to node because node seems to have
 *    had a power failure and has now recovered from it.  Perhaps, the
 *    bus errors were due to the power failure.
 *
 * Parameters:
 *
 *    None
 *
 * Returns:
 *
 *    void - no return value
 *
 * Algorithm:
 *
 *    Calls a message system routine to perform any error clearing.
 *
 ************************************************************************/
_priv _resident void
rgp_had_power_failure(node_t node)
{
   /* Currently, there is nothing to do. */
   RGP_TRACE( "RGP Power fail  ", node, 0, 0, 0);
}


/************************************************************************
 * rgp_status_of_node
 * ==================
 *
 * Description:
 *
 *    Ask the SP to return the status of a node. The SP must return the
 *    current status and not return a stale status. This routine is
 *    called by the split-brain avoidance algorithm in the two-node
 *    case, for the non-tie-breaker to get the status of the tie-breaker
 *    node.
 *
 * Parameters:
 *
 *    node_t node
 *       the node whose status is to be obtained.
 *
 * Returns:
 *
 *    int - the status code of the node returned by the SP, appropriately
 *    encoded into one of the values known to regroup.
 *
 * Algorithm:
 *
 *    Calls a millicode routine to ask the SP for the status of the node.
 *
 ************************************************************************/
_priv _resident int
rgp_status_of_node(node_t node)
{
#if defined(NT)
        /* noone home */
        return RGP_NODE_UNREACHABLE;
#else
        return _get_remote_cpu_state_( node );                                        /*F40:MB06452.1*/
#endif
}


/************************************************************************
 * rgp_newnode_online
 * ==================
 *
 * Description:
 *
 *    This routine is called if the first IamAlive is received from a
 *    newly booted node before the cluster manager gets a chance to
 *    call rgp_monitor_node(). The OS can use this routine to mark the
 *    node as up if it does not have any other means to detect that
 *    a node has come up.
 *
 * Parameters:
 *
 *    node_t node -
 *       the new node that has just been detected to be up
 *
 * Returns:
 *
 *    void - no return value
 *
 * Algorithm:
 *
 *    This routine marks the state of the node as up as seen by the
 *    native OS.
 *
 *    In NSK, on the reloader node, the marking of the reloadee as up
 *    is done by the message system when the initial address handshake
 *    packet is received from the reloadee. NSK does not require the
 *    regroup module to report the fact that the reloadee is online.
 *
 *    The above is probably true for LCU as well. However, the details
 *    are not yet worked out. For now, this routine is a no-op for LCU.
 *
 ************************************************************************/
_priv _resident void
rgp_newnode_online(node_t newnode)
{
   RGP_TRACE( "RGP New node up ", newnode, 0, 0, 0);
}


/************************************************************************
 * rgp_select_cluster_ex
 * =====================
 *
 * Description:
 *
 *    Given an array of cluster choices, this routine picks the best
 *    cluster to keep alive. cluster_choices[] is the array of choices
 *    and num_clusters is the number of entries in the array.
 *
 * Parameters:
 *
 *    cluster_t cluster_choices[]
 *       array of cluster choices
 *
 *    int num_clusters
 *       number of entries (choices) in the array
 *
 *    node_t key_node
 *       internal node number of the key node or RGP_NULL_NODE
 *
 * Returns:
 *
 *    int - the index of the selected cluster; if no cluster
 *    is viable, -1 is returned.
 *
 * Algorithm:
 *
 *    By default, the best cluster is defined as the largest cluster.
 *    Optionally, a node called key_node can be required to be present
 *    for a cluster to be viable. key_node can be set to RGP_NULL_NODE
 *    to imply that no specific node is required to be present.  The
 *    routine returns the index of the best cluster and -1 if none of
 *    the clusters is viable (that is, does not include the key node).
 *
 ************************************************************************/
_priv _resident int
rgp_select_cluster_ex(cluster_t cluster_choices[], int num_clusters, node_t key_node)
{

   int max_members = 0, num_members;
   int cluster_selected = -1;
   int i;

#if defined(UNIX)
   printf("rgp_select_cluster() called with %d choices:", num_clusters);
   for (i = 0; i < num_clusters; i++)
   {
      node_t j;
      printf("(");
      for (j = 0; j < (node_t) rgp->num_nodes; j++)
      {
         if (ClusterMember(cluster_choices[i], j))
            printf("%d,", EXT_NODE(j));
      }
      printf(")");
   }
   printf("\n");
   fflush(stdout);
#endif /* UNIX */

   for (i = 0; i < num_clusters; i++)
   {
      /* Skip the current cluster if a key node is defined and is not
       * in the cluster.
       */
      if ((key_node != RGP_NULL_NODE) &&
          !ClusterMember(cluster_choices[i], key_node))
         continue;

      if ((num_members = ClusterNumMembers(cluster_choices[i])) > max_members)
      {
         cluster_selected = i;
         max_members = num_members;
      }
   }

#if defined(UNIX)
   printf("Node %d: rgp_select_cluster() returned %d.\n",
          EXT_NODE(rgp->mynode), cluster_selected);
   fflush(stdout);
#endif /* UNIX */

   return (cluster_selected);
}

/************************************************************************
 * rgp_select_cluster
 * ==================
 *
 * Description:
 *
 *    Given an array of cluster choices, this routine picks the best
 *    cluster to keep alive. cluster_choices[] is the array of choices
 *    and num_clusters is the number of entries in the array.
 *
 * Parameters:
 *
 *    cluster_t cluster_choices[]
 *       array of cluster choices
 *
 *    int num_clusters
 *       number of entries (choices) in the array
 *
 * Returns:
 *
 *    int - the index of the selected cluster; if no cluster
 *    is viable, -1 is returned.
 *
 * Algorithm:
 *
 *    By default, the best cluster is defined as the largest cluster.
 *    Optionally, a node called RGP_KEY_NODE can be required to be present
 *    for a cluster to be viable. RGP_KEY_NODE can be set to RGP_NULL_NODE
 *    to imply that no specific node is required to be present.  The
 *    routine returns the index of the best cluster and -1 if none of
 *    the clusters is viable (that is, does not include the key node).
 *
 ************************************************************************/
_priv _resident int
rgp_select_cluster(cluster_t cluster_choices[], int num_clusters)
{
    node_t key_node;
    if (RGP_KEY_NODE == RGP_NULL_NODE) {
        key_node = RGP_NULL_NODE;
    } else {
        key_node = INT_NODE(RGP_KEY_NODE);
    }
    return rgp_select_cluster_ex(cluster_choices , num_clusters, key_node);
}


#ifdef LCU
/************************************************************************
 * rgp_msgsys_work
 * ===============
 *
 * Description:
 *
 *    LCU-specific routine that implements broadcasting of packets by
 *    sending them serially.
 *
 *    This routine is called from rgp_broadcast() to initiate new sends.
 *    It is also the packet send completion interrupt handler (callback
 *    routine), invoked by the LCU message system when the packet buffer
 *    can be reused.
 *
 * Parameters:
 *
 *    lcumsg_t *lcumsgp -
 *       pointer to lcu message if called from the transport's send
 *       completion interrupt handler; NULL if called from
 *       rgp_broadcast() to send a new packet.
 *
 *    int status -
 *       the message completion status if called from the transport's
 *       send completion interrupt handler; 0 if called from
 *       rgp_broadcast() to send a new packet.
 *
 * Returns:
 *
 *    void - no return value
 *
 * Algorithm:
 *
 *    If called from the send completion interrupt, the routine checks
 *    to see if the packet buffer needs to be refreshed. This is true
 *    if the appropriate bit in the rgp_msgsys struct is set. If so,
 *    the buffer is updated with the current info (using an update
 *    macro). This update is relevant to regroup status packets and
 *    poison packets, but not to IamAlives packets whose contents are
 *    always the same. The bit is cleared after the packet is updated.
 *
 *    Next, the routine checks if there are more destinations to send
 *    the packet to. If so, it finds the next higher numbered node to
 *    send to, issues a send and returns.
 *
 *    If invoked from rgp_broadcast() to start a new broadcast, the
 *    routine first checks to see if the previous broadcast of the
 *    same packet is complete. This is indicated by the tag field in
 *    the message struct. The tag is NULL if the broadcast has
 *    completed or has not been initiated. In this case, the tag is
 *    set to a non-NULL value and a new broadcast initiated, with
 *    this routine specified as the callback routine.
 *
 *    If the previous broadcast has not completed, nothing needs to
 *    be done. The completion interrupt will cause the buffer to be
 *    refreshed and the broadcast to be continued. The broadcast
 *    will then include new targets that may be included in this
 *    new request.
 *
 ************************************************************************/
_priv _resident void
rgp_msgsys_work(lcumsg_t *lcumsgp, int status)
{
   rgp_unseq_pkt_t   *packet;
   cluster_t         *sending_cluster;
   node_t            node;

   if (lcumsgp == NULL)
   {
      /* New work requested. Only one type of work is requested at
       * a time.
       */

      if (rgp->rgp_msgsys_p->sendrgppkts)
      {

         /* Have new regroup status packets to send. First check
          * if the last regroup status send completed. If so,
          * we can update the packet and initiate a new send.
          * If not, we must defer to the completion interrupt
          * (invocation of this routine with a non-NULL lcumsgp).
          */

         lcumsgp = rgp->OS_specific_control.lcumsg_regroup_p;
         if (lcumsgp->lcu_tag == NULL)
         {
            /* Last send completed. Initiate new send. */

            rgp_update_regroup_packet;
            rgp->rgp_msgsys_p->sendrgppkts = 0;

            for (node = 0; node < rgp->num_nodes; node++)
            {
               if (ClusterMember(rgp->rgp_msgsys_p->regroup_nodes, node))
               {
                  ClusterDelete(rgp->rgp_msgsys_p->regroup_nodes, node);
                  lcumsgp->lcu_node = node;
                  lcumsgp->lcu_tag = &(rgp->rgp_msgsys_p->regroup_nodes);
                  if (lcuxprt_msg_send(lcumsgp, NULL, rgp_msgsys_work, 0) !=
                     ELCU_OK)
                     RGP_ERROR(RGP_INTERNAL_ERROR);
                  break; /* can send only to one node at a time */
               }
            }
         }
      }

      else if (rgp->rgp_msgsys_p->sendiamalives)
      {
         /* Need to send IamAlives again. First check if the last
          * IamAlive send completed. If so, we can initiate a new send.
          * If not, we must defer to the completion interrupt
          * (invocation of this routine with a non-NULL lcumsgp).
          */

         lcumsgp = rgp->OS_specific_control.lcumsg_iamalive_p;
         if (lcumsgp->lcu_tag == NULL)
         {
            /* Last send completed. Initiate new send. */

            rgp->rgp_msgsys_p->sendiamalives = 0;

            for (node = 0; node < rgp->num_nodes; node++)
            {
               if (ClusterMember(rgp->rgp_msgsys_p->iamalive_nodes, node))
               {
                  ClusterDelete(rgp->rgp_msgsys_p->iamalive_nodes, node);
                  lcumsgp->lcu_node = node;
                  lcumsgp->lcu_tag = &(rgp->rgp_msgsys_p->iamalive_nodes);
                  if (lcuxprt_msg_send(lcumsgp, NULL, rgp_msgsys_work, 0) !=
                     ELCU_OK)
                     RGP_ERROR(RGP_INTERNAL_ERROR);
                  break; /* can send only to one node at a time */
               }
            }
         }
      }

      else if (rgp->rgp_msgsys_p->sendpoisons)
      {
         /* Have new poison packets to send. First check
          * if the last poison packet send completed. If so,
          * we can update the packet and initiate a new send.
          * If not, we must defer to the completion interrupt
          * (invocation of this routine with a non-NULL lcumsgp).
          */

         lcumsgp = rgp->OS_specific_control.lcumsg_poison_p;
         if (lcumsgp->lcu_tag == NULL)
         {
            /* Last send completed. Initiate new send. */

            rgp_update_poison_packet;
            rgp->rgp_msgsys_p->sendpoisons = 0;

            for (node = 0; node < rgp->num_nodes; node++)
            {
               if (ClusterMember(rgp->rgp_msgsys_p->poison_nodes, node))
               {
                  ClusterDelete(rgp->rgp_msgsys_p->poison_nodes, node);
                  lcumsgp->lcu_node = node;
                  lcumsgp->lcu_tag = &(rgp->rgp_msgsys_p->poison_nodes);
                  if (lcuxprt_msg_send(lcumsgp, NULL, rgp_msgsys_work, 0) !=
                     ELCU_OK)
                     RGP_ERROR(RGP_INTERNAL_ERROR);
                  break; /* can send only to one node at a time */
               }
            }
         }
      }

   } /* new work */

   else
   {
      /* Send completion interrupt; continue the broadcast if
       * there are targets remaining.
       */

      RGP_LOCK;

      /* Find what type of packet completed; send the same type. */

      packet = (rgp_unseq_pkt_t *) lcumsgp->lcu_reqmbuf.lcu_ctrlbuf;

      switch (packet->pktsubtype)
      {
         case RGP_UNACK_REGROUP :

            /* Check if packet needs to be updated. */
            if (rgp->rgp_msgsys_p->sendrgppkts)
            {
               rgp_update_regroup_packet;
               rgp->rgp_msgsys_p->sendrgppkts = 0;
            }
            break;

         case RGP_UNACK_IAMALIVE :
            break;

         case RGP_UNACK_POISON :

            /* Check if packet needs to be updated. */
            if (rgp->rgp_msgsys_p->sendpoisons)
            {
               rgp_update_poison_packet;
               rgp->rgp_msgsys_p->sendpoisons = 0;
            }
            break;
      }

      /* Check if there is any more node to send the same packet
       * type to. If not, set the tag to NULL and return.
       */
      sending_cluster = (cluster_t *) (lcumsgp->lcu_tag);
      if (ClusterNumMembers(*sending_cluster) == 0)
      {
         lcumsgp->lcu_tag = NULL; /* indicate that broadcast is complete. */
         return;
      }

      /* There is at least one more node to send to. Start with
       * the node with the next higher number than the node we
       * just finished sending to.
       *
       * The loop terminates after posting a send to the next
       * node to send to. We know there is at least one such node.
       */
      for (node = lcumsgp->lcu_node + 1; node < rgp->num_nodes + 1; node++)
      {
         if (node == rgp->num_nodes)
            node = 0;  /* continue the search starting at node 0 */
         if (ClusterMember(*sending_cluster, node))
         {
            ClusterDelete(*sending_cluster, node);
            lcumsgp->lcu_node = node;
            if (lcuxprt_msg_send(lcumsgp, NULL, rgp_msgsys_work, 0) !=
               ELCU_OK)
               RGP_ERROR(RGP_INTERNAL_ERROR);
            break; /* can send only to one node at a time */
         }
      }

      RGP_UNLOCK;
   }
}
#endif /* LCU */

/*---------------------------------------------------------------------------*/

#if defined(LCU) || defined(UNIX) || defined(NT)

/*---------------------------------------------------------------------------*/
void
rgp_hold_all_io(void)
/* Simulates the TNet services routine to pause IO. */
{
#if defined (NT)
   (*(rgp->OS_specific_control.HoldIOCallback))();
#endif
   RGP_TRACE( "RGP Hold all IO ", 0, 0, 0, 0);
}
/*---------------------------------------------------------------------------*/
void
rgp_resume_all_io(void)
/* Simulates the TNet services routine to resume IO. */
{
#if defined (NT)
   (*(rgp->OS_specific_control.ResumeIOCallback))();
#endif
   RGP_TRACE( "RGP Resume IO   ", 0, 0, 0, 0);
}
/*---------------------------------------------------------------------------*/
void
RGP_ERROR_EX (uint16 halt_code, char* fname, DWORD lineno)
/* Halt node with error code. */
{
   char *halt_string;
   node_t node = RGP_NULL_NODE;
#if defined( NT )
   char halt_buffer[ 256 ];
   DWORD eventMsgId;
   BOOL skipFormatting = FALSE;

   //
   // If a user initiated a shutdown, (s)he wants to see the node
   // to go down and wait for an explicit start command.
   //
   // We map RGP_RELOADFAILED to SHUTDOWN_DURING_REGROUP_ERROR since
   // HaltCallback does a graceful stop for the latter one.
   // SCM won't restart the node after a graceful stop unless
   // it is explicitly told to do so
   //
   if (halt_code == RGP_RELOADFAILED &&
       rgp->OS_specific_control.ShuttingDown)
   {
      halt_code = RGP_SHUTDOWN_DURING_RGP;
   }
#endif

   if (halt_code == RGP_RELOADFAILED) {
      halt_string = "[RGP] Node %d: REGROUP WARNING: reload failed.";
      eventMsgId = MM_EVENT_RELOAD_FAILED;
   }
   else if (halt_code ==  RGP_INTERNAL_ERROR) {
      halt_string = "[RGP] Node %d: REGROUP ERROR: consistency check failed in file %s, line %u.";
      eventMsgId = MM_EVENT_INTERNAL_ERROR;
      skipFormatting = TRUE;

      _snprintf(halt_buffer, sizeof( halt_buffer ) - 1,
                halt_string,
                EXT_NODE(rgp->mynode),
                fname,
                lineno);
   }
   else if (halt_code ==  RGP_MISSED_POLL_TO_SELF) {
      halt_string = "[RGP] Node %d: REGROUP ERROR: cannot talk to self.";
      eventMsgId = NM_EVENT_MEMBERSHIP_HALT;
   }
#if !defined(NT)
   else if (halt_code ==  RGP_AVOID_SPLIT_BRAIN) {
      halt_string = "[RGP] Node %d: REGROUP ERROR: commiting suicide to avoid split brain.";
   }
#endif
   else if (halt_code ==  RGP_PRUNED_OUT) {
      halt_string = "[RGP] Node %d: REGROUP ERROR: pruned out due to communication failure.";
      eventMsgId = MM_EVENT_PRUNED_OUT;
   }
   else if ((halt_code >=  RGP_PARIAH_FIRST) && (halt_code <= RGP_PARIAH_LAST)) {
       halt_string = "[RGP] Node %d: REGROUP ERROR: poison packet received from node %d.";
       eventMsgId = MM_EVENT_PARIAH;
       node = (node_t)(halt_code - RGP_PARIAH);
   }
   else if (halt_code ==  RGP_ARBITRATION_FAILED) {
      halt_string = "[RGP] Node %d: REGROUP ERROR: arbitration failed.";
      eventMsgId = MM_EVENT_ARBITRATION_FAILED;
   }
   else if (halt_code ==  RGP_ARBITRATION_STALLED) {
      halt_string = "[RGP] Node %d: REGROUP ERROR: arbitration stalled.";
      eventMsgId = MM_EVENT_ARBITRATION_STALLED;
   }
   else if (halt_code ==  RGP_SHUTDOWN_DURING_RGP) {
      halt_string = "[RGP] Node %d: REGROUP INFO: regroup engine requested immediate shutdown.";
      eventMsgId = MM_EVENT_SHUTDOWN_DURING_RGP;
   }
   else {
      halt_string = "[RGP] Node %d: REGROUP ERROR: unknown halt code (%d).";
      eventMsgId = NM_EVENT_MEMBERSHIP_HALT;
      node = halt_code;  // get it printed out by borrowing node
   }

#if defined(UNIX)
   printf(halt_string, EXT_NODE(rgp->mynode), node);
   fflush(stdout);
   /* Simulate a halt by dumping core and exiting the process. */
   abort();

#elif defined(NT)

   if ( !skipFormatting ) {
       _snprintf(halt_buffer, sizeof( halt_buffer ) - 1,
                 halt_string,
                 EXT_NODE(rgp->mynode),
                 node);
   }

#if CLUSTER_BETA
     ClRtlLogPrint(LOG_CRITICAL, "%1!hs!\t%2!hs!:%3!d!\n", halt_buffer, fname, lineno);
#else
     ClRtlLogPrint(LOG_CRITICAL, "%1!hs!\n", halt_buffer );
#endif

     if ((halt_code >=  RGP_PARIAH_FIRST) && (halt_code <= RGP_PARIAH_LAST)) {
         WCHAR  nodeString[ 16 ];
         PWCHAR nodeName;

         _snwprintf( nodeString, sizeof( nodeString ) / sizeof ( WCHAR ), L"%d", node );
         nodeName = RgpGetNodeNameFromId( node );
         CsLogEvent2( LOG_CRITICAL, eventMsgId, nodeString, nodeName );
         if ( nodeName != NULL ) {
             LocalFree( nodeName );
         }
     }
     else if ( eventMsgId == NM_EVENT_MEMBERSHIP_HALT ) {
         WCHAR  haltString[ 16 ];

         _snwprintf( haltString, sizeof( haltString ) / sizeof ( WCHAR ), L"%d", halt_code );
         CsLogEvent1( LOG_CRITICAL, eventMsgId, haltString );
     }
     else {
         CsLogEvent( LOG_CRITICAL, eventMsgId );
     }

   /* we rely on RGP_ERROR_EX to kill the node immediately 

      rgp_cleanup() can potentially slow us down.
      435977 showed that it can take upto 25 seconds, if we
      have a lot IP addr activity.

      since in the end of the function we execute HaltCallback which kills the cluster,
      we can safely omit doing rgp_cleanup and rgp_cleanup_OS

      If JoinFailedCallback will be ever enabled, the fate of rgp_cleanup and rgp_cleanup_OS
      should be reevaluated.
   */

#if 0
   rgp_cleanup();
   rgp_cleanup_OS();
   if (halt_code == RGP_RELOADFAILED)
           (*(rgp->OS_specific_control.JoinFailedCallback))();
   else
#endif
           (*(rgp->OS_specific_control.HaltCallback))(halt_code); // does not return */

#else
   cmn_err(CE_PANIC, halt_string, EXT_NODE(rgp->mynode), node);
#endif /* UNIX */
}
/*---------------------------------------------------------------------------*/
void
rgp_start_phase1_cleanup(void)
/* Tells the OS to start cleanup actions for all failed nodes. */
{
#if defined (NT)
    node_t i;
    //
    // On NT we saved the nodes to be downed bitmask in NeedsNodeDownCallback.
    //
    for ( i=0; i < (node_t) rgp->num_nodes; i++)
    {
        if ( ClusterMember( rgp->OS_specific_control.NeedsNodeDownCallback, i ) )
        {
            (*(rgp->OS_specific_control.MsgCleanup1Callback))(EXT_NODE(i));
        }
    }
#endif
   RGP_TRACE( "RGP Ph1 cleanup ", 0, 0, 0, 0);
   rgp_event_handler(RGP_EVT_PHASE1_CLEANUP_DONE, RGP_NULL_NODE);
}
/*---------------------------------------------------------------------------*/
void
rgp_start_phase2_cleanup(void)
/* The equivalent of NSK's regroupstage4action(). */
{
#if defined (NT)
    BITSET bitset;
    node_t i;
    //
    // On NT we saved the nodes to be downed bitmask in NeedsNodeDownCallback.
    //
    BitsetInit(bitset);
    for ( i=0; i < (node_t) rgp->num_nodes; i++)
    {
        if ( ClusterMember( rgp->OS_specific_control.NeedsNodeDownCallback, i ) )
        {
            BitsetAdd(bitset, EXT_NODE(i));
        }
    }

    (*(rgp->OS_specific_control.MsgCleanup2Callback))(bitset);
#endif
   RGP_TRACE( "RGP Ph2 cleanup ", 0, 0, 0, 0);
   rgp_event_handler(RGP_EVT_PHASE2_CLEANUP_DONE, RGP_NULL_NODE);
}
/*---------------------------------------------------------------------------*/
void
rgp_cleanup_complete(void)
/* The equivalent of NSK's regroupstage5action(). */
{
#if defined(NT)
#endif
   RGP_TRACE( "RGP completed   ", 0, 0, 0, 0);
}
/*---------------------------------------------------------------------------*/

#endif /* LCU || UNIX || NT */

#if defined(NT)

/************************************************************************
 * NT_timer_callback
 * =================
 *
 * Description:
 *
 *    This routine is the callback function that gets invoked whenever a
 *        timer pops.  The routine will call rgp_periodic_check.  This function
 *        is defined by the Win32 TimerProc procedure.
 *
 * Parameters:
 *
 *        See below.  We don't use any of them.
 *
 * Returns:
 *
 *    none.
 *
 * Algorithm:
 *
 *    This routine just calls rgp_periodic_check.  The existense of this
 *        routine is solely due to a fixed format callback defined by
 *        Microsoft.
 *
 ************************************************************************/
VOID CALLBACK NT_timer_callback(
        VOID
        )
{
#if defined(TDM_DEBUG)
    if ( !(rgp->OS_specific_control.debug.timer_frozen) &&
         !(rgp->OS_specific_control.debug.frozen) )
#endif
        rgp_periodic_check( );
}

 /************************************************************************
 * NT_timer_thread
 * ===============
 *
 * Description:
 *
 *    This routine is executed as a separate thread in the Windows NT
 *    implementation.  This thread controls generates periodic regroup
 *    clock ticks. It is signalled via an event whenever the rate changes
 *    or to cause termination.
 *
 * Parameters:
 *
 *    None.
 *
 * Returns:
 *
 *    This thread should not go away.
 *
 * Algorithm:
 *
 *    This routine is run as a separate thread.  It sets up a timer to pop
 *        every <time_interval> * 10 milliseconds.
 *
 ************************************************************************/
void NT_timer_thread( void  )
{
    BOOL Success;
    LARGE_INTEGER DueTime;
    DWORD Error, MyHandleIndex;
    HANDLE MyHandles[2]; /* for use by WaitForMultiple */
    DWORD status;
    DWORD msDueTime;

#define MyHandleSignalIx 0
#define MyHandleTimerIx  1

    MyHandles[MyHandleSignalIx] = rgp->OS_specific_control.TimerSignal; /* Event signals HB rate change */

    rgp->OS_specific_control.RGPTimer = CreateWaitableTimer(
                                            NULL,      // no security
                                            FALSE,     // Initial State FALSE
                                            NULL
                                            );     // No name

    if (rgp->OS_specific_control.RGPTimer == NULL) {
        Error = GetLastError();
        RGP_ERROR(RGP_INTERNAL_ERROR);
    }

    status = MmSetThreadPriority();

    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[MM] Unable to set timer thread priority, status %1!u!\n",
            status
            );

        RGP_ERROR((uint16) status);
        ExitThread(status);
    }

    MyHandles[MyHandleTimerIx] = rgp->OS_specific_control.RGPTimer;

    while (TRUE)
    {
        MyHandleIndex = WaitForMultipleObjects (
                            2,                /* Number of Events */
                            MyHandles,        /* Handle Array */
                            FALSE,            /* Wait for ANY event */
                            INFINITE );       /* Wait forever */

        if (MyHandleIndex == MyHandleSignalIx)  // Timer Change Signal Event
        {
            // RGP rate has changed
            CancelWaitableTimer ( rgp->OS_specific_control.RGPTimer );
            if ( rgp->rgpinfo.a_tick == 0 ) // Time to quit
            {
                CloseHandle ( rgp->OS_specific_control.RGPTimer );
                rgp->OS_specific_control.RGPTimer = 0;
                ExitThread ( 0 );
            }

            // a_tick has new RGP rate in milliseconds.
            msDueTime = rgp->rgpinfo.a_tick;
            DueTime.QuadPart = -10 * 1000 * msDueTime;
            Success = SetWaitableTimer(
                          rgp->OS_specific_control.RGPTimer,
                          &DueTime,
                          rgp->rgpinfo.a_tick,
                          NULL,
                          NULL,
                          FALSE);

            if (!Success) {
                Error = GetLastError();
                RGP_ERROR(RGP_INTERNAL_ERROR);
            }

        } // Timer Change Signal
        else
        {   // RGP Timer Tick
            NT_timer_callback();

            NmTimerTick(msDueTime);
        }
    } // while
}


PWCHAR
RgpGetNodeNameFromId(
    node_t NodeID
    )

/*++

Routine Description:

    given a node ID, issue a get name node control to get the computer name of
    the node. Returned buffer to be freed by caller.

Arguments:

    NodeID - ID ( 1, 2, 3, ..) of the node

Return Value:

    pointer to buffer containing name

--*/

{
    PWCHAR      buffer;
    DWORD       bufferSize = MAX_COMPUTERNAME_LENGTH * sizeof( WCHAR );
    DWORD       bytesReturned;
    DWORD       bytesRequired;
    PNM_NODE    node;

    buffer = LocalAlloc( LMEM_FIXED, bufferSize );
    if ( buffer != NULL ) {
        node = NmReferenceNodeById( NodeID );
        if ( node != NULL ) {
            NmNodeControl(node,
                          NULL,                     // HostNode OPTIONAL,
                          CLUSCTL_NODE_GET_NAME,
                          NULL,                     // InBuffer,
                          0,                        // InBufferSize,
                          (PUCHAR)buffer,
                          bufferSize,
                          &bytesReturned,
                          &bytesRequired);

            OmDereferenceObject( node );
        }
    }

    return buffer;
}

#endif /* NT */

#ifdef __cplusplus
}
#endif /* __cplusplus */


#if 0

History of changes to this file:
-------------------------------------------------------------------------
1995, December 13                                           F40:KSK0610          /*F40:KSK06102.2*/

This file is part of the portable Regroup Module used in the NonStop
Kernel (NSK) and Loosely Coupled UNIX (LCU) operating systems. There
are 10 files in the module - jrgp.h, jrgpos.h, wrgp.h, wrgpos.h,
srgpif.c, srgpos.c, srgpsm.c, srgputl.c, srgpcli.c and srgpsvr.c.
The last two are simulation files to test the Regroup Module on a
UNIX workstation in user mode with processes simulating processor nodes
and UDP datagrams used to send unacknowledged datagrams.

This file was first submitted for release into NSK on 12/13/95.
------------------------------------------------------------------------------
This change occurred on 19 Jan 1996                                              /*F40:MB06458.1*/
Changes for phase IV Sierra message system release. Includes:                    /*F40:MB06458.2*/
 - Some cleanup of the code                                                      /*F40:MB06458.3*/
 - Increment KCCB counters to count the number of setup messages and             /*F40:MB06458.4*/
   unsequenced messages sent.                                                    /*F40:MB06458.5*/
 - Fixed some bugs                                                               /*F40:MB06458.6*/
 - Disable interrupts before allocating broadcast sibs.                          /*F40:MB06458.7*/
 - Change per-packet-timeout to 5ms                                              /*F40:MB06458.8*/
 - Make the regroup and powerfail broadcast use highest priority                 /*F40:MB06458.9*/
   tnet services queue.                                                          /*F40:MB06458.10*/
 - Call the millicode backdoor to get the processor status from SP               /*F40:MB06458.11*/
 - Fixed expand bug in msg_listen_ and msg_readctrl_                             /*F40:MB06458.12*/
 - Added enhancement to msngr_sendmsg_ so that clients do not need               /*F40:MB06458.13*/
   to be unstoppable before calling this routine.                                /*F40:MB06458.14*/
 - Added new steps in the build file called                                      /*F40:MB06458.15*/
   MSGSYS_C - compiles all the message system C files                            /*F40:MB06458.16*/
   MSDRIVER - compiles all the MSDriver files                                    /*F40:MB06458.17*/
   REGROUP  - compiles all the regroup files                                     /*F40:MB06458.18*/
 - remove #pragma env libspace because we set it as a command line               /*F40:MB06458.19*/
   parameter.                                                                    /*F40:MB06458.20*/
-----------------------------------------------------------------------          /*F40:MB06458.21*/

#endif    /* 0 - change descriptions */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\mm\srgpif.c ===
#ifdef __TANDEM
#pragma columns 79
#pragma page "srgpif.c - T9050 - interface routines for Regroup Module"
#endif

/* @@@ START COPYRIGHT @@@
**  Tandem Confidential:  Need to Know only
**  Copyright (c) 1995, Tandem Computers Incorporated
**  Protected as an unpublished work.
**  All Rights Reserved.
**
**  The computer program listings, specifications, and documentation
**  herein are the property of Tandem Computers Incorporated and shall
**  not be reproduced, copied, disclosed, or used in whole or in part
**  for any reason without the prior express written permission of
**  Tandem Computers Incorporated.
**
** @@@ END COPYRIGHT @@@
**/

/*---------------------------------------------------------------------------
 * This file (srgpif.c) contains all the external interface routines
 * of Regroup.
 *---------------------------------------------------------------------------*/


#ifdef __cplusplus
   extern "C" {
#endif /* __cplusplus */


#include <wrgp.h>


/************************************************************************
 * rgp_estimate_memory
 * ===================
 *
 * Description:
 *
 *    Routine to find the number of bytes of memory needed by regroup.
 *    The only global memory used by Regroup is for the rgp_control structure.
 *    The caller must allocate and zero out a chunk of this much memory
 *    and then call rgp_init() with a pointer to this memory.
 *
 * Parameters:
 *
 *    None
 *
 * Returns:
 *
 *    int - number of bytes of locked down and initialized (to 0) memory
 *          needed by Regroup. The memory must be 4-byte aligned.
 *
 * Algorithm:
 *
 *    Uses the size of the rgp_control_t to calculate the number of
 *    bytes needed.
 *
 ************************************************************************/
_priv _resident int
RGP_ESTIMATE_MEMORY(void)
{
   return(sizeof(rgp_control_t));
}


/************************************************************************
 * rgp_init
 * ========
 *
 * Description:
 *
 *    Routine to initialize the global Regroup data structures.
 *
 * Parameters:
 *
 *    node_t this_node -
 *       node number of local node; regroup uses bit masks to represent
 *       nodes in the cluster and starts numbering nodes from 0. The OS
 *       starts numbering at LOWEST_NODENUM. This transformation is
 *       maintained in all the regroup interfaces to the OS.
 *
 *    unsigned int num_nodes -
 *       number of nodes in the configured node number space =
 *       (largest configured node number - LOWEST_NODENUM + 1).
 *
 *    void *rgp_buffer -
 *       pointer to a block of locked down memory initialized to 0; this is
 *       for use by Regroup as its global memory; must be 4-byte aligned
 *
 *    int rgp_buflen -
 *       length in bytes of the locked down buffer *rgp_buffer; must be equal
 *       to or greater than the number returned by rgp_estimate_memory()
 *
 *    rgp_msgsys_p rgp_msgsys_p -
 *       pointer to a common struct used by the message system and
 *       Regroup to co-ordinate regroup related work
 *
 * Returns:
 *
 *    void - no return value
 *
 * Algorithm:
 *
 *    Initializes the Regroup global data structure with default initial
 *    values and the parameters passed in.
 *
 ************************************************************************/
_priv _resident void
RGP_INIT(node_t this_node, unsigned int num_nodes,
         void *rgp_buffer, int rgp_buflen,
         rgp_msgsys_p rgp_msgsys_p)
{
   this_node = INT_NODE(this_node); /* adjust the node number by the offset */

   if ((num_nodes > MAX_CLUSTER_SIZE) ||
       (this_node >= (node_t) num_nodes) ||
       (rgp_buflen < rgp_estimate_memory()) /* buffer too small */ ||
       ((ULONG_PTR)rgp_buffer % 4) /* buffer not 4-byte aligned */
      )
      RGP_ERROR(RGP_INTERNAL_ERROR);

#ifdef NSK
   /* In NSK, the caller must set up the global rgp pointer. */
#else
   rgp = (rgp_control_t *) rgp_buffer;
#endif /* NSK */

   rgp->num_nodes = num_nodes; /* # of nodes configured */

   rgp->rgp_msgsys_p = rgp_msgsys_p; /* ptr to struct shared with Msgsys */

   rgp->mynode = this_node;

#if defined (NT)
    /* Initialize RGP_LOCK, the CRITICALSECTION object that will be used
         * to synchronize access within the regroup procedures */
   InitializeCriticalSection( &rgp->OS_specific_control.RgpCriticalSection );
#endif

   RGP_CLEANUP();

   /* We place a bit pattern in the IamAlive packet. This bit
    * pattern toggles all the bits.
    */
   rgp->iamalive_pkt.testpattern.words[0]  = 0x0055FF6D;
   rgp->iamalive_pkt.testpattern.words[1]  = 0x92CC33E3;
   rgp->iamalive_pkt.testpattern.words[2]  = 0x718E49F0;
   rgp->iamalive_pkt.testpattern.words[3]  = 0x92CC33E3;
   rgp->iamalive_pkt.testpattern.words[4]  = 0x0055FF6D;
   rgp->iamalive_pkt.testpattern.words[5]  = 0x0055FF6D;
   rgp->iamalive_pkt.testpattern.words[6]  = 0x92CC33E3;
   rgp->iamalive_pkt.testpattern.words[7]  = 0x718E49F0;
   rgp->iamalive_pkt.testpattern.words[8]  = 0x92CC33E3;
   rgp->iamalive_pkt.testpattern.words[9]  = 0x0055FF6D;
   rgp->iamalive_pkt.testpattern.words[10] = 0x55AA55AA;
   rgp->iamalive_pkt.testpattern.words[11] = 0x55AA55AA;
   rgp->iamalive_pkt.testpattern.words[12] = 0x55AA55AA;

   rgp->poison_pkt.pktsubtype = RGP_UNACK_POISON;

   rgp_init_OS();  /* OS-specific initializations */

   rgp_cleanup_OS(); /* OS-specific cleanup */

   /* Trace the call after the data structures have been initialized. */
   RGP_TRACE( "RGP Init called ", EXT_NODE(this_node), num_nodes,
              PtrToUlong(rgp_buffer), PtrToUlong(rgp_msgsys_p) ); /* TRACE */
}




/**************************************************************************
 * rgp_cleanup
 * ===========
 * Description:
 *
 *    This function cleans up the RGP structure such that this node is
 *    virtually returned to the state following RGP_INIT and ready to be
 *    "join"ed into the cluster.
 *
 * Parameters:
 *
 *      None
 *
 * Returns:
 *
 *      None
 **************************************************************************/
 _priv _resident void
RGP_CLEANUP(void)
{
   node_t i;

   RGP_LOCK;

/* Initialize the state of all possible nodes in the cluster. */
   for (i = 0; i < (node_t) rgp->num_nodes; i++)
   {
      rgp->node_states[i].status = RGP_NODE_DEAD;
      rgp->node_states[i].pollstate = AWAITING_IAMALIVE;
      rgp->node_states[i].lostHBs = 0;

#if defined( NT )
      ClusnetSetNodeMembershipState(NmClusnetHandle,
                                    EXT_NODE( i ),
                                    ClusnetNodeStateDead);
#endif // NT
   }
   for (i = (node_t)rgp->num_nodes; i < MAX_CLUSTER_SIZE; i++)
   {
      rgp->node_states[i].status = RGP_NODE_NOT_CONFIGURED;
      rgp->node_states[i].pollstate = AWAITING_IAMALIVE;
      rgp->node_states[i].lostHBs = 0;

#if defined( NT )
      ClusnetSetNodeMembershipState(NmClusnetHandle,
                                    EXT_NODE( i ),
                                    ClusnetNodeStateNotConfigured);
#endif // NT
   }

   rgp->rgpinfo.version = RGP_VERSION;
   rgp->rgpinfo.seqnum = RGP_INITSEQNUM;
   rgp->rgpinfo.iamalive_ticks = RGP_IAMALIVE_TICKS;
   rgp->rgpinfo.check_ticks = RGP_CHECK_TICKS;
   rgp->rgpinfo.Min_Stage1_ticks = RGP_MIN_STAGE1_TICKS;
   rgp->rgpinfo.a_tick = RGP_INACTIVE_PERIOD;

   ClusterInit(rgp->rgpinfo.cluster);

   rgp->rgppkt.stage = RGP_COLDLOADED;
   rgp->rgpcounter = 0;
   rgp->restartcount = 0;

   rgp->tiebreaker = rgp->mynode;

   /* Initialize the unacknowledged packet buffers */

   rgp->rgppkt.pktsubtype = RGP_UNACK_REGROUP;
   rgp->rgppkt.seqno = rgp->rgpinfo.seqnum;
   rgp->last_stable_seqno = rgp->rgpinfo.seqnum;

   ClusterCopy(rgp->OS_specific_control.CPUUPMASK, rgp->rgpinfo.cluster);
   ClusterCopy(rgp->outerscreen,           rgp->rgpinfo.cluster);
#if defined( NT )
   ClusnetSetOuterscreen( NmClusnetHandle, (ULONG)*((PUSHORT)rgp->outerscreen) );
#endif
   ClusterCopy(rgp->innerscreen,           rgp->rgpinfo.cluster);
   ClusterCopy(rgp->rgppkt.knownstage1,    rgp->rgpinfo.cluster);
   ClusterCopy(rgp->rgppkt.knownstage2,    rgp->rgpinfo.cluster);
   ClusterCopy(rgp->rgppkt.knownstage3,    rgp->rgpinfo.cluster);
   ClusterCopy(rgp->rgppkt.knownstage4,    rgp->rgpinfo.cluster);
   ClusterCopy(rgp->rgppkt.knownstage5,    rgp->rgpinfo.cluster);
   ClusterCopy(rgp->rgppkt.pruning_result, rgp->rgpinfo.cluster);
   MatrixInit(rgp->rgppkt.connectivity_matrix);

   rgp->rgppkt_to_send.pktsubtype = RGP_UNACK_REGROUP;

   rgp->iamalive_pkt.pktsubtype = RGP_UNACK_IAMALIVE;

   RGP_UNLOCK;
}

/***************************************************************************
 * rgp_sequence_number
 * ===================
 * Description:
 *
 *    This function returns the regroup sequence number.
 *
 *    This provides only a subset of the functionality provided by
 *    rgp_getrgpinfo(), but is a simpler function and has no structure
 *    parameters, making it easier to call from PTAL.
 *
 *    A regroup incident could be in progress when this routine is
 *    called.
 *
 * Parameters:
 *
 *      None
 *
 * Returns:
 *
 *     uint32 - the current regroup sequence number; this reflects
 *              how many regroup incidents have happened since
 *              the system came up. Since one incident can result in
 *              upto RGP_RESTART_MAX restarts each resulting in the
 *              sequence # being bumped, this number does not always
 *              equal the number of regroup incidents.
 *
 ***************************************************************************/
_priv _resident uint32
RGP_SEQUENCE_NUMBER(void)
{
    return(rgp->rgpinfo.seqnum);
}


/************************************************************************
 * rgp_getrgpinfo
 * ==============
 *
 * Description:
 *
 *    Routine to get Regroup parameters.
 *
 * Parameters:
 *
 *    rgpinfo_t *rgpinfo - pointer to struct to be filled with Regroup
 *                         parameters.
 *
 * Returns:
 *
 *    int - 0 if successful; -1 if Regroup is perturbed.
 *
 * Algorithm:
 *
 *    Copies the rgpinfo struct from the Regroup global memory into the
 *    struct passed in by the caller.
 *
 ************************************************************************/
_priv _resident int
RGP_GETRGPINFO(rgpinfo_t *rgpinfo)
{
   int error = 0;

   /* If no rgpinfo structure is passed OR rgp_init() has not been called
    * earlier, halt.
    */

   if ((rgpinfo == RGP_NULL_PTR) || (rgp == RGP_NULL_PTR))
      RGP_ERROR( RGP_INTERNAL_ERROR );

   RGP_LOCK;

   if (rgp_is_perturbed())
      error = -1;
   else
      /* Copy the rgpinfo structure from regroup's internal struct. */
      *rgpinfo = rgp->rgpinfo;

   RGP_UNLOCK;

   return(error);
}


/************************************************************************
 * rgp_setrgpinfo
 * ==============
 *
 * Description:
 *
 *    Routine to set Regroup parameters. This routine is to be called on
 *    newly booting nodes to set the Regroup parameters to the values
 *    in the master or reloading node. The parameters to be updated
 *    include Regroup timing parameters and the cluster membership;
 *    that is, the current set of nodes in the system.
 *
 *    This routine can also be called on the first node to boot to
 *    modify the Regroup timing parameters which are set to the default
 *    values when rgp_init() is called. Such modification has to be done
 *    before other nodes are added to the system.
 *
 * Parameters:
 *
 *    rgpinfo_t *rgpinfo - pointer to struct with Regroup parameters to
 *                         be modified.
 *
 * Returns:
 *
 *    int - 0 if successful; -1 if there is more than one node in the
 *    cluster. This is to prevent modification of timing parameters
 *    after the second node is added to the system.
 *
 * Algorithm:
 *
 *    Copies the contents of the user-passed struct into the one in the
 *    Regroup global memory and updates related parameters.
 *
 ************************************************************************/
_priv _resident int
RGP_SETRGPINFO(rgpinfo_t *rgpinfo)
{
   int error = 0;
   node_t i;

   /* If no rgpinfo structure is passed OR the version # of the
    * structure is not understood OR rgp_init() has not been called,
    * halt.
    */

   if ((rgpinfo == RGP_NULL_PTR) ||
       (rgpinfo->version != RGP_VERSION) ||
       (rgp == RGP_NULL_PTR))
      RGP_ERROR( RGP_INTERNAL_ERROR );

   RGP_LOCK;

   /* The following checks must be made before proceeding:
    *
    * 1. Regroup must not be perturbed.
    *
    * 2. If rgp_start() has been called (regroup is in the
    *    RGP_STABILIZED state), only the local node must be in the
    *    cluster when this routine is called.
    *
    * 3. If rgp_start() has been called, this routine can be used
    *    only to modify the timing parameters and not to specify the
    *    cluster.
    *
    * If these restrictions are not followed, return -1.
    */

   RGP_TRACE( "RGP SetRGPInfo  ",
              rgpinfo->version,                /* TRACE */
              rgpinfo->seqnum,                 /* TRACE */
              rgpinfo->iamalive_ticks,         /* TRACE */
              GetCluster( rgpinfo->cluster ) );/* TRACE */

   if (  rgp_is_perturbed() ||
         (  (rgp->rgppkt.stage == RGP_STABILIZED) &&
            (  (ClusterNumMembers(rgp->rgpinfo.cluster) > 1) ||
               !ClusterCompare(rgp->rgpinfo.cluster,rgpinfo->cluster)
            )
         )
      )
      error = -1;
   else
   {
      /* Copy the rgpinfo structure into regroup's internal struct. */
      rgp->rgpinfo = *rgpinfo;

      /* If iamalive_ticks is set to 0, use the default value instead. */        /*F40:KSK06102.2*/
      if (rgpinfo->iamalive_ticks == 0)                                          /*F40:KSK06102.3*/
         rgp->rgpinfo.iamalive_ticks = RGP_IAMALIVE_TICKS;                       /*F40:KSK06102.4*/
                                                                                 /*F40:KSK06102.5*/
          if (rgpinfo->check_ticks == 0)
          {
                 rgp->rgpinfo.check_ticks = RGP_CHECK_TICKS;
          }

          if (rgpinfo->Min_Stage1_ticks == 0)
                 rgp->rgpinfo.Min_Stage1_ticks =
                  (rgp->rgpinfo.iamalive_ticks * rgp->rgpinfo.check_ticks);

          if (rgpinfo->a_tick == 0)
                 rgp->rgpinfo.a_tick = RGP_CLOCK_PERIOD;

          // Tell Timer thread to restart RGP timer
          SetEvent (rgp->OS_specific_control.TimerSignal);


      /* The cluster should include the local node even if the cluster
       * field in the rgpinfo structure does not include it.
       */
      ClusterInsert(rgp->rgpinfo.cluster, rgp->mynode);

      /* Copy the sequence number into the regroup packet area. */
      rgp->rgppkt.seqno = rgp->rgpinfo.seqnum;

      /* If nodes have been added in the cluster field, they must be
       * added to all the screens and their status must be set to
       * alive.
       */

      ClusterCopy(rgp->OS_specific_control.CPUUPMASK, rgp->rgpinfo.cluster);
      ClusterCopy(rgp->outerscreen,           rgp->rgpinfo.cluster);
#if defined( NT )
      ClusnetSetOuterscreen( NmClusnetHandle, (ULONG)*((PUSHORT)rgp->outerscreen) );
      ClusterComplement(rgp->ignorescreen, rgp->outerscreen);
#endif
      ClusterCopy(rgp->innerscreen,           rgp->rgpinfo.cluster);
      ClusterCopy(rgp->rgppkt.knownstage1,    rgp->rgpinfo.cluster);
      ClusterCopy(rgp->rgppkt.knownstage2,    rgp->rgpinfo.cluster);
      ClusterCopy(rgp->rgppkt.knownstage3,    rgp->rgpinfo.cluster);
      ClusterCopy(rgp->rgppkt.knownstage4,    rgp->rgpinfo.cluster);
      ClusterCopy(rgp->rgppkt.knownstage5,    rgp->rgpinfo.cluster);
      ClusterCopy(rgp->rgppkt.pruning_result, rgp->rgpinfo.cluster);
      rgp->tiebreaker = rgp_select_tiebreaker(rgp->rgpinfo.cluster);

      for (i = 0; i < (node_t) rgp->num_nodes; i++)
      {
         if (ClusterMember(rgp->rgpinfo.cluster, i))
         {
            rgp->node_states[i].pollstate = IAMALIVE_RECEIVED;
            rgp->node_states[i].status = RGP_NODE_ALIVE;

#if defined( NT )
            ClusnetSetNodeMembershipState(NmClusnetHandle,
                                          EXT_NODE( i ),
                                          ClusnetNodeStateAlive);
#endif // NT
         }
      }
      /* Reset the clock counter so that IamAlives are sent when
       * the next timer tick arrives.
       */
      rgp->clock_ticks = 0;
   }

   RGP_UNLOCK;

   return(error);
}


/************************************************************************
 * rgp_start
 * =========
 *
 * Description:
 *
 *    This routine signals the end of node integration into the cluster.
 *    The node can now start participating in the Regroup algorithm.
 *
 * Parameters:
 *
 *    void (*rgp_node_failed)()
 *       pointer to a routine to be called when a node failure is
 *       detected.
 *
 *    int (*rgp_select_cluster)()
 *       pointer to an optional routine to be called when link failures
 *       cause multiple alternative clusters to be formed. This routine
 *       should select one from a list of suggested clusters.
 *
 * Returns:
 *
 *    void - no return value
 *
 * Algorithm:
 *
 *    Installs the callback routines in the global data structure and
 *    changes the Regroup state to RGP_STABILIZED.
 *
 ************************************************************************/
_priv _resident void
RGP_START(void (*nodedown_callback)(cluster_t failed_nodes),
          int (*select_cluster)(cluster_t cluster_choices[], int num_clusters)
         )
{
   if (rgp == RGP_NULL_PTR)
      RGP_ERROR( RGP_INTERNAL_ERROR );

   RGP_LOCK;

   RGP_TRACE( "RGP Start called",
              rgp->rgppkt.stage,                /* TRACE */
              PtrToUlong(nodedown_callback),    /* TRACE */
              PtrToUlong(select_cluster),       /* TRACE */
              0 );                              /* TRACE */

   /* Install callback routines for node failure notification and cluster
    * selection. If no routine is given by the caller, use default ones.
    */

   if (nodedown_callback == RGP_NULL_PTR)
   {
#ifdef NSK
      /* In NSK, rgp_start() is called from pTAL code and passing routine
       * addresses is cumbersome. So, RGP_NULL_PTR is passed and we
       * call the routine rgp_node_failed() which must be supplied by
       * the message system.
       */
      rgp->nodedown_callback = rgp_node_failed; /* hardcoded name */
#else
      /* A node down callback routine must be supplied. */
      RGP_ERROR( RGP_INTERNAL_ERROR );
#endif /* NSK */
   }
   else
      rgp->nodedown_callback = nodedown_callback;
#if 0
   /* The select cluster routine is optional. */
   if (select_cluster == RGP_NULL_PTR)
      rgp->select_cluster = rgp_select_cluster; /* supplied by regroup */
   else
#endif
   //
   // Calling rgp_select_cluster is
   // not a good idea since it doesn't take into the consideration
   // quorum owner node. 
   // If rgp->select_cluster == RGP_NULL_PTR, then  srgpsm.c uses
   //   rgp_select_cluster_ex, that will try to select the group
   // that contain the current quorum owner node

   rgp->select_cluster = select_cluster;

#if defined(NT)
   /* Call the node up callback.  This is where the local node gets
    * the node up callback for itself coming up.  Other nodes call
    * the callback, for this node coming up, in rgp_monitor_node.
    */

   ClusterInsert(rgp->rgpinfo.cluster, rgp->mynode);
   ClusterCopy(rgp->OS_specific_control.CPUUPMASK, rgp->rgpinfo.cluster);

   if ( rgp->OS_specific_control.UpDownCallback != RGP_NULL_PTR )
   {
      (*(rgp->OS_specific_control.UpDownCallback))(
          EXT_NODE(rgp->mynode),
          NODE_UP
          );
   }
#endif  /* NT */

   RGP_UNLOCK;

}

/************************************************************************
 * rgp_add_node
 * ============
 *
 * Description:
 *
 *    Called to add a newly booting node to the regroup masks. This prevents
 *    Regroup from sending poison packets to the new node when it tries to
 *    contact our node by sending IamAlive messages.
 *
 * Parameters:
 *
 *    node_t node - node to be added to the recognition masks
 *
 * Returns:
 *
 *    int - 0 on success and -1 on failure. The routine fails only if a
 *    regroup incident is in progress.
 *
 * Algorithm:
 *
 *    The node is added to all the recognition masks and its state is
 *    changed to RGP_NODE_COMING_UP.
 *
 ************************************************************************/
_priv _resident int
RGP_ADD_NODE(node_t node)
{
   int error = 0;

   RGP_LOCK;

   RGP_TRACE( "RGP Add node    ", node, rgp->rgppkt.stage,
              GetCluster(rgp->outerscreen),                 /* TRACE */
              GetCluster(rgp->rgpinfo.cluster) );           /* TRACE */

   /* Cannot add a node while regroup is perturbed. Return -1 in that case.
    * The new node booting should fail due to the regroup incident anyway.
    */
   if (rgp_is_perturbed())
      error = -1;
   else
   {
      node = INT_NODE(node); /* adjust the node number by the offset */

      ClusterInsert(rgp->outerscreen,           node);
#if defined( NT )
      ClusnetSetOuterscreen( NmClusnetHandle, (ULONG)*((PUSHORT)rgp->outerscreen) );
#endif
      ClusterInsert(rgp->innerscreen,           node);
      ClusterInsert(rgp->rgppkt.knownstage1,    node);
      ClusterInsert(rgp->rgppkt.knownstage2,    node);
      ClusterInsert(rgp->rgppkt.knownstage3,    node);
      ClusterInsert(rgp->rgppkt.knownstage4,    node);
      ClusterInsert(rgp->rgppkt.knownstage5,    node);
      ClusterInsert(rgp->rgppkt.pruning_result, node);
      rgp->node_states[node].pollstate = AWAITING_IAMALIVE;
      rgp->node_states[node].status = RGP_NODE_COMING_UP;
      rgp->node_states[node].lostHBs = 0;

#if defined( NT )
      ClusterDelete( rgp->OS_specific_control.Banished, node );

      //
      // Remove joining node from ignore screen
      //

      ClusterDelete( rgp->ignorescreen,                 node );
      PackIgnoreScreen(&rgp->rgppkt, rgp->ignorescreen);

      ClusnetSetNodeMembershipState(NmClusnetHandle,
                                    EXT_NODE( node ),
                                    ClusnetNodeStateJoining);
#endif // NT
   }

   RGP_UNLOCK;

   return(error);
}


/************************************************************************
 * rgp_monitor_node
 * ================
 *
 * Description:
 *
 *    Called by all running nodes to change the status of a newly booted node
 *    to UP. Can be called by the new node also; it is a no-op in this case.
 *
 * Parameters:
 *
 *    node_t node - number of node being declared up
 *
 * Returns:
 *
 *    int - 0 on success and -1 on failure. The routine fails only if the
 *    state of the node is neither RGP_NODE_COMING_UP nor RGP_NODE_ALIVE.
 *
 * Algorithm:
 *
 *    If the node is marked coming up, its state is changed to
 *    RGP_NODE_ALIVE. If the node has already been marked up,
 *    nothing is done.
 *
 ************************************************************************/
_priv _resident int
RGP_MONITOR_NODE(node_t node)
{
   int error = 0;

   RGP_LOCK;

   RGP_TRACE( "RGP Monitor node", node, rgp->rgppkt.stage,
              GetCluster(rgp->outerscreen),                 /* TRACE */
              GetCluster(rgp->rgpinfo.cluster) );           /* TRACE */

   node = INT_NODE(node); /* adjust the node number by the offset */

   /* Accept the request only if the state of the node is COMING_UP or UP. */

   if (rgp->node_states[node].status == RGP_NODE_COMING_UP)
   {
      ClusterInsert(rgp->rgpinfo.cluster, node);
      rgp->tiebreaker = rgp_select_tiebreaker(rgp->rgpinfo.cluster);
      rgp->node_states[node].pollstate = IAMALIVE_RECEIVED;
      rgp->node_states[node].status = RGP_NODE_ALIVE;
#if defined(NT)
      ClusterCopy(rgp->OS_specific_control.CPUUPMASK, rgp->rgpinfo.cluster);

      ClusnetSetNodeMembershipState(NmClusnetHandle,
                                    EXT_NODE( node ),
                                    ClusnetNodeStateAlive);

      /* A node came up.  Call the node up callback. */
      if ( rgp->OS_specific_control.UpDownCallback != RGP_NULL_PTR )
      {
         (*(rgp->OS_specific_control.UpDownCallback))(
             EXT_NODE(node),
             NODE_UP
             );
      }
#endif  /* NT */

   }
   else if (rgp->node_states[node].status != RGP_NODE_ALIVE)
      /* Perhaps the booting node failed and regroup has already marked
       * it down. The cluster manager may have invoked a global update
       * resulting in this call before regroup reporetd the failure
       * of the node.
       */
      error = -1;

   RGP_UNLOCK;

   return(error);
}


/************************************************************************
 * rgp_remove_node
 * ===============
 *
 * Description:
 *
 *    Called by the cluster manager to force out a booting node if booting
 *    fails. Regroup may or may not have already removed the booting node
 *    from the masks and declared it down, depending on what stage the
 *    booting is in and when the booting node failed.
 *
 *    Regroup can remove the node from the masks of all nodes in the cluster
 *    by simply starting a new incident of regroup with any event code. This
 *    will force all nodes to come to an agreement on cluster membership
 *    that excludes the booting node. If the booting node is alive, it will
 *    commit suicide since it will be in the incompetent (RGP_COLDLOADED)
 *    state.
 *
 *    Removing the new node from our masks is not necessary since regroup
 *    will detect the node failure and adjust the masks. If we do remove it
 *    from our masks BEFORE initiating regroup, regroup may complete quicker
 *    since we will not wait in stage 1 for the node to check in. Also, this
 *    could allow a node to be removed even after it is fully integrated.
 *    This is because our node will send a poison packet to the removed node
 *    if it tries to contact us.
 *
 *    But this "enhancement" is not implemented because it requires a new
 *    regroup event code which is examined by all nodes and processed
 *    specially. Currently, the regroup event code is used only for
 *    debugging info. Also, there is no guarantee that all nodes see the
 *    same regroup reason code. For instance, some may see a missing
 *    IamAlive while others may see a power failure.
 *
 * Parameters:
 *
 *    node_t node - node to be removed from the recognition masks
 *                  (in external format).
 *
 * Returns:
 *
 *    int - 0 on success and -1 on failure. The routine fails if a
 *    regroup incident is in progress or rgp_start() has not been
 *    called (as in a new node where the booting is not complete).
 *
 * Algorithm:
 *
 *    If the node is still in the recognition masks, a new regroup incident
 *    is started. This incident will result in all nodes declaring the node
 *    dead and removing it from the recognition masks.
 *
 ************************************************************************/
_priv _resident int
RGP_REMOVE_NODE(node_t node)
{
   int error = 0;

   RGP_LOCK;

   RGP_TRACE( "RGP Remove node ", node, rgp->rgppkt.stage,
              GetCluster(rgp->outerscreen),                 /* TRACE */
              GetCluster(rgp->rgpinfo.cluster) );           /* TRACE */

   if (rgp->rgppkt.stage == RGP_STABILIZED)
   {
      if (ClusterMember(rgp->outerscreen, INT_NODE(node)))
      {
         /* Node is currently in our screen. The node may have never come up
          * after rgp_add_node() was called OR regroup may not have figured
          * out yet that the node is down. In either case, the node must
          * be forced out and all nodes in the cluster notified (by a regroup
          * incident). If the node is still running, it will commit suicide
          * when this regroup incident starts.
          */

         rgp_event_handler(RGP_EVT_LATEPOLLPACKET, node);
      }
      else
      {
         /* Either the node was not added to the cluster OR regroup has
          * already figured out that the node is dead and reported this.
          * In either case, there is nothing more to do.
          */
      }
   }
   else
      error = -1;

   RGP_UNLOCK;

   return(error);
}


/************************************************************************
 * rgp_is_perturbed
 * ================
 *
 * Description:
 *
 *    Function to check if a regroup incident is in progress.
 *
 * Parameters:
 *
 *    None.
 *
 * Returns:
 *
 *    int - 0 if no regroup is quiescent; non-zero if a regroup incident
 *    is in progress.
 *
 * Algorithm:
 *
 *    Looks at the current state of the Regroup algorithm.
 *
 ************************************************************************/
_priv _resident int
RGP_IS_PERTURBED(void)
{
   uint8 stage = rgp->rgppkt.stage;

   return((stage != RGP_STABILIZED) && (stage != RGP_COLDLOADED));
}


/************************************************************************
 * rgp_periodic_check
 * ==================
 *
 * Description:
 *
 *    This routine is invoked every RGP_CLOCK_PERIOD by the timer interrupt
 *    handler of the native OS. It performs Regroups's periodic operations.
 *
 * Parameters:
 *
 *    None
 *
 * Returns:
 *
 *    void - no return value
 *
 * Algorithm:
 *
 *    This routine requests Iamalive packets to be sent, checks if
 *    IamAlives have been received (and calls rgp_event_handler() if
 *    not) and sends a clock tick to the regroup algorithm if it is in
 *    progress.
 *
 *    IamAlives are checked at twice the IamAlive period. The regroup
 *    global variable clock_ticks is incremented in each call. After
 *    the IamAlives are checked, clock_ticks is reset to 0. Thus, the
 *    ticker counts time modulo twice the IamAlive ticks.
 *
 ************************************************************************/
_priv _resident void
RGP_PERIODIC_CHECK(void)
{
   node_t  node;

   RGP_LOCK;

   /* If regroup is active, give it a shot at each regroup clock tick. */

   if ((rgp->rgppkt.stage != RGP_STABILIZED) &&
       (rgp->rgppkt.stage != RGP_COLDLOADED))
      rgp_event_handler(RGP_EVT_CLOCK_TICK, RGP_NULL_NODE);

#if !defined( NT )
   /* Send IamAlive messages at appropriate intervals. */

   if ( (rgp->clock_ticks == 0) ||
        (rgp->clock_ticks == rgp->rgpinfo.iamalive_ticks) )
   {
      rgp_broadcast(RGP_UNACK_IAMALIVE);
      rgp->clock_ticks++;
   }

   /* Check for missing IamAlives at IamAlive sending period,
    * But flag an error (LATE_POLL) only if "check_ticks" IamAlives missed.
    * The checking is offset from the sending by one clock tick.
    */

   else if ( rgp->clock_ticks >= (rgp->rgpinfo.iamalive_ticks - 1) )
   { /* check all nodes for IamAlives received */

      for (node = 0; node < (node_t) rgp->num_nodes; node++)
      {
         if (rgp->node_states[node].status == RGP_NODE_ALIVE)
         {
            if ( rgp->node_states[node].pollstate == IAMALIVE_RECEIVED )
            {  /* checked in in time */
#if defined(TDM_DEBUG)
               if ( rgp->OS_specific_control.debug.doing_tracing )
               {
                  printf ("Node %d: Node %d is alive. My rgp state=%d\n",
                     EXT_NODE(rgp->mynode), EXT_NODE(node), rgp->rgppkt.stage );
               }
#endif
               rgp->node_states[node].pollstate = AWAITING_IAMALIVE;
               rgp->node_states[node].lostHBs = 0;
            }
            else if ( rgp->node_states[node].lostHBs++ < rgp->rgpinfo.check_ticks )
               ;// allow upto (check_ticks-1) IamAlives to be lost.
            else
            {
               /* missing IamAlives */
               if (node == rgp->mynode) /* missed my own packets */
               {
                  /* We should be lenient if we just had a power failure.
                   */
                  if (rgp->pfail_state == 0) /* no recent power failure */
                     RGP_ERROR( RGP_MISSED_POLL_TO_SELF );
               }
               else
                  rgp_event_handler(RGP_EVT_LATEPOLLPACKET, EXT_NODE(node));
            }
         }
      }

      /* Reset the regroup tick counter after checking for IamAlives. */
      rgp->clock_ticks = 0;

   } /* check all nodes for IamAlives received */

   else
      rgp->clock_ticks++;

   /* rgp->pfail_state is set to a non-zero value when a pfail event
    * is reported to regroup. It is decremented at every regroup clock
    * tick till it reaches zero. While this number is non-zero, missing
    * self IamAlives are ignored and do not cause the node to halt.
    * This gives the sending hardware some time to recover from power
    * failures before self IamAlives are checked.
    */
   if (rgp->pfail_state)
      rgp->pfail_state--;

#endif // NT

   RGP_UNLOCK;

}  /* rgp_periodic_check */


/************************************************************************
 * rgp_received_packet
 * ===================
 *
 * Description:
 *
 *    Routine to be called by the message system when an unacknowledged
 *    packet sent by the Regroup module is received from any node. These
 *    packets include IamAlive packets, regroup status packets and poison
 *    packets.
 *
 * Parameters:
 *
 *    node_t node      - node from which a packet has been received
 *
 *    void   *packet   - address of the received packet data
 *
 *    int    packetlen - length in bytes of the received packet data
 *
 * Returns:
 *
 *    void - no return value
 *
 * Algorithm:
 *
 *    Does different things based on the packet subtype.
 *
 ************************************************************************/
_priv _resident void
RGP_RECEIVED_PACKET(node_t node, void *packet, int packetlen)
{
   rgp_unseq_pkt_t *unseq_pkt = (rgp_unseq_pkt_t *) packet;

   node = INT_NODE(node);

   /* If the packet is from a node that cannot be in our cluster,
    * simply ignore it.
    */
   if (node >= (node_t) rgp->num_nodes)
      return;

   /* If the sending node is excluded by the outer screen, then it is
    * not part of the current (most recently known) configuration.
    * Therefore the packet should not be honored, and a poison message
    * should be sent to try to kill this renegade processor unless
    * it is sending US a poison packet. If it is sending us a poison
    * packet, we cannot send it a poison in return because that results
    * in an infinite loop. In this case, we just halt because this
    * situation implies that there is a split brain situation and our
    * split brain avoidance algorithm has failed.
    */

   /* NT Notes
    *
    * even with poison pkts being sent and recv'ed in the kernel, we still
    * want to make these checks since clusnet doesn't have the regroup stage
    * info and regroup packets themselves find there way in here.
    */

   if (!ClusterMember(rgp->outerscreen, node)
#if defined( NT )
       ||
       ClusterMember(rgp->OS_specific_control.Banished, node)
#endif
      )
   {
       if (rgp->rgppkt.stage == RGP_COLDLOADED)
       {
           // We are doing this check in srgpsm.c
           // No need to do it here
           // RGP_ERROR(RGP_RELOADFAILED);
           //
       }
       else if (unseq_pkt->pktsubtype == RGP_UNACK_POISON)
       {
           RGP_ERROR((uint16) (RGP_PARIAH + EXT_NODE(node)));
       } else {
           /* Must send a poison packet to the sender.
            */
           ClusterInsert(rgp->poison_targets, node);
           rgp_broadcast(RGP_UNACK_POISON);
       }
       return;
   }

   switch (unseq_pkt->pktsubtype)
   {
      case RGP_UNACK_IAMALIVE :
      {
         /* Count the number of IamAlives received */
         if ( node == rgp->mynode )
             RGP_INCREMENT_COUNTER( RcvdLocalIAmAlive );
         else
             RGP_INCREMENT_COUNTER( RcvdRemoteIAmAlive );

         if (rgp->node_states[node].status == RGP_NODE_ALIVE)
            rgp->node_states[node].pollstate = IAMALIVE_RECEIVED;

         else if (rgp->node_states[node].status == RGP_NODE_COMING_UP)
         {
            /* If the node has not yet been marked fully up, it is time to
             * do so.
             */
            rgp_monitor_node(EXT_NODE(node));

            /* We must tell the OS that the new node is up in case the
             * OS needs the IamAlives to figure that out.
             */
            rgp_newnode_online(EXT_NODE(node));
         }
         else
            /* If the node state is neither alive nor coming up, it
             * must not be in our outerscreen. The outerscreen check
             * above must have passed and we should not get here.
             */
            RGP_ERROR(RGP_INTERNAL_ERROR);

         break;
      }
      case RGP_UNACK_REGROUP  :
      {
         /* Count the number of regroup status packets received. */
         RGP_INCREMENT_COUNTER( RcvdRegroup );

         /* Any good packet can be treated as an IamAlive packet. */
         rgp->node_states[node].pollstate = IAMALIVE_RECEIVED;

         RGP_EVENT_HANDLER_EX (RGP_EVT_RECEIVED_PACKET, EXT_NODE(node), (void*)unseq_pkt);
         break;
      }
      case RGP_UNACK_POISON   :
      {
         /* If our node is in RGP_PRUNING stage and have been pruned out,
          * the poison packet probably implies that the sender has gone
          * into the next stage and declared us down. In this case, use
          * the more appropriate RGP_PRUNED_OUT halt code. Otherwise,
          * use the poison packet halt code. In either case, we must halt.
          */
          if ( (rgp->rgppkt.stage == RGP_PRUNING) &&
               !ClusterMember(rgp->rgppkt.pruning_result, rgp->mynode) )
              RGP_ERROR(RGP_PRUNED_OUT);
          else
          {
              if (rgp->rgppkt.stage == RGP_COLDLOADED)
                  {
                      RGP_ERROR(RGP_RELOADFAILED);
                      return;
                  }
                  else
                      RGP_ERROR((uint16) (RGP_PARIAH + EXT_NODE(node)));
          }
          break;
      }
      default                   :
      {
         /* Ignore the unknown packet type. */
         break;
      }
   }
}
/*---------------------------------------------------------------------------*/

#ifdef __cplusplus
}
#endif /* __cplusplus */


#if 0

History of changes to this file:
-------------------------------------------------------------------------
1995, December 13                                           F40:KSK0610          /*F40:KSK06102.6*/

This file is part of the portable Regroup Module used in the NonStop
Kernel (NSK) and Loosely Coupled UNIX (LCU) operating systems. There
are 10 files in the module - jrgp.h, jrgpos.h, wrgp.h, wrgpos.h,
srgpif.c, srgpos.c, srgpsm.c, srgputl.c, srgpcli.c and srgpsvr.c.
The last two are simulation files to test the Regroup Module on a
UNIX workstation in user mode with processes simulating processor nodes
and UDP datagrams used to send unacknowledged datagrams.

This file was first submitted for release into NSK on 12/13/95.
------------------------------------------------------------------------------
This change occurred on 19 Jan 1996                                              /*F40:MB06458.1*/
Changes for phase IV Sierra message system release. Includes:                    /*F40:MB06458.2*/
 - Some cleanup of the code                                                      /*F40:MB06458.3*/
 - Increment KCCB counters to count the number of setup messages and             /*F40:MB06458.4*/
   unsequenced messages sent.                                                    /*F40:MB06458.5*/
 - Fixed some bugs                                                               /*F40:MB06458.6*/
 - Disable interrupts before allocating broadcast sibs.                          /*F40:MB06458.7*/
 - Change per-packet-timeout to 5ms                                              /*F40:MB06458.8*/
 - Make the regroup and powerfail broadcast use highest priority                 /*F40:MB06458.9*/
   tnet services queue.                                                          /*F40:MB06458.10*/
 - Call the millicode backdoor to get the processor status from SP               /*F40:MB06458.11*/
 - Fixed expand bug in msg_listen_ and msg_readctrl_                             /*F40:MB06458.12*/
 - Added enhancement to msngr_sendmsg_ so that clients do not need               /*F40:MB06458.13*/
   to be unstoppable before calling this routine.                                /*F40:MB06458.14*/
 - Added new steps in the build file called                                      /*F40:MB06458.15*/
   MSGSYS_C - compiles all the message system C files                            /*F40:MB06458.16*/
   MSDRIVER - compiles all the MSDriver files                                    /*F40:MB06458.17*/
   REGROUP  - compiles all the regroup files                                     /*F40:MB06458.18*/
 - remove #pragma env libspace because we set it as a command line               /*F40:MB06458.19*/
   parameter.                                                                    /*F40:MB06458.20*/
-----------------------------------------------------------------------          /*F40:MB06458.21*/

#endif    /* 0 - change descriptions */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\mm\setprior.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    setprior.c

Abstract:

    Set a threads priority.

Author:

    Rod Gamache (rodga) 3-Oct-1996

Revision History:

--*/

#include "nt.h"
#include "ntdef.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"


DWORD
MmSetThreadPriority(
    VOID
    )

/*++

Routine Description:

    Set the thread's priority.

Arguments:

    None.

Return Value:

    Status of the request.

--*/

{
    DWORD   priority = 15;

    if ( !SetThreadPriority( GetCurrentThread(),
                             priority ) ) {
        return(GetLastError());
    }

    return(ERROR_SUCCESS);

} // MmSetThreadPriority
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\mm\srgputl.c ===
#ifdef __TANDEM
#pragma columns 79
#pragma page "srgputl.c - T9050 - utility routines for Regroup Module"
#endif

/* @@@ START COPYRIGHT @@@
**  Tandem Confidential:  Need to Know only
**  Copyright (c) 1995, Tandem Computers Incorporated
**  Protected as an unpublished work.
**  All Rights Reserved.
**
**  The computer program listings, specifications, and documentation
**  herein are the property of Tandem Computers Incorporated and shall
**  not be reproduced, copied, disclosed, or used in whole or in part
**  for any reason without the prior express written permission of
**  Tandem Computers Incorporated.
**
** @@@ END COPYRIGHT @@@
**/

/*---------------------------------------------------------------------------
 * This file (srgputl.c) contains the cluster_t data type implementation
 * and the node pruning algorithm used by Regroup.
 *---------------------------------------------------------------------------*/

#ifdef __cplusplus
   extern "C" {
#endif /* __cplusplus */


#include <wrgp.h>

/************************************************************************
 * ClusterInit,
 * ClusterUnion,
 * ClusterIntersection,
 * ClusterDifference,
 * ClusterCompare,
 * ClusterSubsetOf,
 * ClusterComplement,
 * ClusterMember,
 * ClusterInsert,
 * ClusterDelete,
 * ClusterCopy,
 * ClusterSwap,
 * ClusterNumMembers
 * =================
 *
 * Description:
 *
 *    Functions that implement operations on the cluster_t type.
 *
 * Algorithm:
 *
 *    Operates on the byte array that is the cluster_t type.
 *
 ************************************************************************/
_priv _resident void
ClusterInit(cluster_t c)
{
   int i;

   for (i = 0; i < BYTES_IN_CLUSTER; i++)
      c[i] = 0;
}

_priv _resident void
ClusterUnion(cluster_t dst, cluster_t src1, cluster_t src2)
{
   int i;

   for (i = 0; i < BYTES_IN_CLUSTER; i++)
      dst[i] = src1[i] | src2[i];
}

_priv _resident void
ClusterIntersection(cluster_t dst, cluster_t src1, cluster_t src2)
{
   int i;
   for (i = 0; i < BYTES_IN_CLUSTER; i++)
      dst[i] = src1[i] & src2[i];
}

_priv _resident void
ClusterDifference(cluster_t dst, cluster_t src1, cluster_t src2)
{
   int i;
   for (i = 0; i < BYTES_IN_CLUSTER; i++)
      dst[i] = src1[i] & (~src2[i]);
}

_priv _resident int ClusterCompare(cluster_t c1, cluster_t c2)
{
   int identical, i;

   identical = 1;
   for (i = 0; i < BYTES_IN_CLUSTER; i++)
   {
      if (c1[i] != c2[i])
      {
         identical = 0;
         break;
      }
   }
   return(identical);
}

_priv _resident int ClusterSubsetOf(cluster_t big, cluster_t small)
/* Returns 1 if set small = set big or small is a subset of big. */
{
   int subset, i;

   subset = 1;
   for (i = 0; i < BYTES_IN_CLUSTER; i++)
   {
      if ( (big[i] != small[i]) && ((big[i] ^ small[i]) & small[i]) )
      {
         subset = 0;
         break;
      }
   }
   return(subset);
}

_priv _resident void ClusterComplement(cluster_t dst, cluster_t src)
{
   int i;
   for (i = 0; i < BYTES_IN_CLUSTER; i++)
      dst[i] = ~src[i];
}

_priv _resident int ClusterMember(cluster_t c, node_t i)
{
   return((BYTE(c,i) >> (BYTEL-1-BIT(i))) & 1);
}

_priv _resident void ClusterInsert(cluster_t c, node_t i)
{
   BYTE(c, i) |= (1 << (BYTEL-1-BIT(i)));
}

_priv _resident void ClusterDelete(cluster_t c, node_t i)
{
   BYTE(c, i) &= ~(1 << (BYTEL-1-BIT(i)));
}

_priv _resident void ClusterCopy(cluster_t dst, cluster_t src)
{
   int i;

   for (i = 0; i < BYTES_IN_CLUSTER; i++)
      dst[i] = src[i];
}

_priv _resident void ClusterSwap(cluster_t c1, cluster_t c2)
{
   int i;
   unsigned char temp;

   for (i = 0; i < BYTES_IN_CLUSTER; i++)
   {
      temp  = c1[i];
      c1[i] = c2[i];
      c2[i] = temp;
   }
}

_priv _resident int  ClusterNumMembers(cluster_t c)
/* Returns the number of nodes in the cluster. */
{
   int num_members = 0, i, j;

   for (i = 0; i < BYTES_IN_CLUSTER; i++)
   {
      if (c[i])
      {
         for (j = 0; j < BYTEL; j++)
            if (c[i] & (1 << j))
               num_members++;
      }
   }
   return(num_members);
}

/************************************************************************
 * ClusterEmpty
 * =================
 *
 * Description:
 *
 *    Checks that a cluster has no members
 *
 * Parameters:
 *
 *    cluster_t c
 *       cluster to be examined
 *
 * Returns:
 *
 *    0 - cluster contains at least one node
 *    1 - cluster is empty
 *
 * Comment:
 *
 *    The proper place for this function is in srgputl.c
 *
 ************************************************************************/
int ClusterEmpty(cluster_t c)
{
   int i;

   for (i = 0; i < BYTES_IN_CLUSTER; i++)
   {
      if (c[i])
      {
         return 0;
      }
   }
   return 1;
}


/************************************************************************
 * rgp_select_tiebreaker
 * =====================
 *
 * Description:
 *
 *    Simple algorithm to select the tie-breaker.
 *
 * Parameters:
 *
 *    cluster_t cluster -
 *       cluster from which a tie-breaker is to be selected
 *
 * Returns:
 *
 *    node_t - the node number of the selected tie-breaker
 *
 * Algorithm:
 *
 *    The tie-breaker is defined as the lowest numbered node in the
 *    cluster.
 *
 ************************************************************************/
_priv _resident node_t
rgp_select_tiebreaker(cluster_t cluster)
{
   node_t i;

   for (i = 0; (i < (node_t) rgp->num_nodes) && !ClusterMember(cluster, i); i++);

   /* If the cluster does not have any members, we have a problem! */
   if (i >= (node_t) rgp->num_nodes)
      RGP_ERROR(RGP_INTERNAL_ERROR);

   return(i);
}


/*---------------------------------------------------------------------------
 * Node pruning algorithm used by Regroup.
 *---------------------------------------------------------------------------
 */

/************************************************************************
 * group_exists
 * ============
 *
 * Description:
 *
 *    Check if a specific group already exists or is a subset of a
 *    group that already exists.
 *
 * Parameters:
 *
 *    cluster_t groups[] -
 *       array of groups to examine
 *
 *    int numgroups -
 *       number of groups discovered so far
 *
 *    cluster_t g -
 *       specific group to check
 *
 * Returns:
 *
 *    int - 1 if the specified group exists in the array; 0 therwise.
 *
 * Algorithm:
 *
 *    Goes through the array and calls ClusterSubsetOf to check if the
 *    specified group g is a subset of the the array element.
 *
 ************************************************************************/
#if !defined(NT)
_priv _resident static
int
#endif
group_exists(cluster_t groups[], int numgroups, cluster_t g)
{
   int exists, i;

   exists = 0;
   for (i = 0; i < numgroups; i++)
   {
      if (ClusterSubsetOf(groups[i],g))
      {
         exists = 1;
         break;
      }
   }
   return(exists);
}


/************************************************************************
 * prune
 * =====
 *
 * Description:
 *
 *    Algorithm to find all fully connected groups based on # of
 *    disconnects in the matrix.
 *
 * Parameters:
 *
 *    disconnect_array disconnects -
 *       input : array of disconnects
 *
 *    int D -
 *       input : size of disconnects array
 *
 *    cluster_t live_nodes -
 *       input : set of all live nodes
 *
 *    cluster_t groups[] -
 *       output: array of fully-connected groups
 *
 * Returns:
 *
 *    int - the number of groups made;  0 if no groups or other error
 *
 * Algorithm:
 *
 *    Start with one group that contains the set of live nodes.
 *    More groups will be generated as disconnects are examined.
 *
 *    Process each disconnect in the disconnects array by applying
 *    the disconnect to the current set of fully-connected groups.
 *
 *    The effect of a disconnect on a fully-conncted group depends on
 *    whether the end points of the disconnect are in the group or not.
 *
 *    If the group contains neither or only one of the endpoints of
 *    the disconnect, the disconnect has no effect on the group.
 *
 *    If both endpoints of the disconnect are in the group, then the
 *    group is split into two groups - the original group without
 *    endpoint 1 and the original group without endpoint 2.
 *    New groups so generated should be discarded if they already
 *    exist or are subsets of currently existing groups.
 *
 *    After every disconnect is processed, we end up with the final
 *    set of fully-connected groups.
 *
 ************************************************************************/
#if !defined(NT)
_priv _resident static
#endif
int
prune(
   disconnect_array   disconnects,
   int                D,
   cluster_t          live_nodes,
   cluster_t          groups[])
{
   int  numgroups = 1, i, j;

   ClusterCopy(groups[0], live_nodes);

   for (i = 0; i < D; i ++)
   {
      for (j = 0; j < numgroups; j++)
      {
         /* Split a group that has both ends of the disconnect. */
         if (ClusterMember(groups[j],disconnects[i][0]) &&
             ClusterMember(groups[j],disconnects[i][1]))
         {
            /* Correct current group in place.
             * Add new group at the end of the array.
             */
            numgroups++;
            ClusterCopy(groups[numgroups-1], groups[j]);
            ClusterDelete(groups[j], disconnects[i][0]);
            ClusterDelete(groups[numgroups-1], disconnects[i][1]);

            /* Check if the new groups already exist or are subgroups
             * of existing groups.
             */

            /* First, check the group added at the end of the array. */
            if (group_exists(groups, numgroups-1, groups[numgroups-1]))
               numgroups--;

            /* Next, check the modified group at j.
             * To simplify the checking, switch it with the last element
             * of the array. If the group already exists, it should be
             * removed. Since the group is now the last element of the
             * array, removal requires only decrementing the array count.
             */
            ClusterSwap(groups[j], groups[numgroups-1]);
            if (group_exists(groups, numgroups-1, groups[numgroups-1]))
               numgroups--;
            j--; /* The j-th entry has been switched with the last entry;
                    it has to be examined again */
         }
      }
   }

   return(numgroups);
}


/************************************************************************
 * select_group_with_designated_node
 * =================================
 *
 * Description:
 *
 *    Function to pick an arbitrary fully connected group that
 *    includes a specified node.
 *
 * Parameters:
 *
 *    connectivity_matrix_t c -
 *       input : cluster's connectivity info
 *
 *    node_t selected_node -
 *       input : just find a fully-connected group that includes this node
 *
 *    cluster_t *group -
 *       output: group that includes selected_node
 *
 * Returns:
 *
 *    int - returns 1 if the specified node is alive and 0 if it is not
 *
 * Algorithm:
 *
 *    Start with a group that includes just the selected node.
 *    Then, examine nodes starting with node 0 and go up till the
 *    largest node number. If a node is alive, include it in the group
 *    if and only if it is connected to all current members of the
 *    group.
 *
 *    When all nodes are examined, we get a fully-connected group that
 *    includes the selected node. This is only one of potentially many
 *    fully-connected groups and is not necessarily the largest
 *    solution.
 *
 *    This order of examining nodes gives higher priority to lower
 *    numbered nodes.
 *
 ************************************************************************/
#if !defined(NT)
_priv _resident static
#endif
int
select_group_with_designated_node(
   connectivity_matrix_t   c,
   node_t                  selected_node,
   cluster_t               *group)
{
   node_t i, j;

   if (!node_considered_alive(selected_node))
      return(0);
   else
   {
      ClusterInit(*group);
      ClusterInsert(*group, selected_node);
      for (i = 0; i < (node_t) rgp->num_nodes; i++)
      {
         if ((i != selected_node) &&
             node_considered_alive(i) &&
             connected(i, selected_node)
            )
         {
            /* Check if i is connected to all members of the group
             * built so far.
             */
            for (j = 0; j < i; j++)
            {
               if (ClusterMember(*group, j) && !connected(j, i))
                  break;
            }
            if (j == i)  /* i is connected to all current members*/
               ClusterInsert(*group, i);
         }
      }
      return(1);
   }
}


/************************************************************************
 * MatrixInit
 * ==========
 *
 * Description:
 *
 *    Initialize the matrix c to show 0 connectivity.
 *
 * Parameters:
 *
 *    connectivity_matrix_t c - matrix to be set to 0s.
 *
 * Returns:
 *
 *    void - no return value
 *
 * Algorithm:
 *
 *    Calls ClusterInit to initialize the clusters in the matrix.
 *
 ************************************************************************/
_priv _resident void
MatrixInit(connectivity_matrix_t c)
{
   int i;

   for (i = 0; i < (node_t) rgp->num_nodes; i++)
   {
      ClusterInit(c[i]);
   }
}


/************************************************************************
 * MatrixSet
 * =========
 *
 * Description:
 *
 *    Set matrix[row,column] to 1.
 *
 * Parameters:
 *
 *    connectivity_matrix_t c - matrix to be modified
 *
 *    int row - row number
 *
 *    int column - column number
 *
 * Returns:
 *
 *    void - no return value
 *
 * Algorithm:
 *
 *    Calls ClusterInsert to set the appropriate bit (column) in the
 *    appropriate cluster (row) in the matrix.
 *
 ************************************************************************/
_priv _resident void
MatrixSet(connectivity_matrix_t c, int row, int column)
{
   ClusterInsert(c[row], (node_t) column);
}


/************************************************************************
 * MatrixOr
 * ========
 *
 * Description:
 *
 *    matrix t := t OR s
 *
 * Parameters:
 *
 *    connectivity_matrix_t  t - target matrix
 *
 *    connectivity_matrix_t  s - source matrix to be ORed into target
 *
 * Returns:
 *
 *    void - no return value
 *
 * Algorithm:
 *
 *    Calls ClusterUnion to OR the appropriate clusters (rows) in the
 *    matrices.
 *
 ************************************************************************/
_priv _resident void
MatrixOr(connectivity_matrix_t t, connectivity_matrix_t s)
{
   int i;

   for (i = 0; i < (node_t) rgp->num_nodes; i++)
      ClusterUnion(t[i], s[i], t[i]);
}


/************************************************************************
 * connectivity_complete
 * =====================
 *
 * Description:
 *
 *    Boolean function that checks if a given connectivity matrix implies
 *    full connectivity (all nodes can talk to all others).
 *
 * Parameters:
 *
 *    connectivity_matrix_t c - connectivity matrix of the cluster
 *
 * Returns:
 *
 *    int - 0 if there are disconnects in the cluster; 1 if it has full
 *    connectivity.
 *
 * Algorithm:
 *
 *    Checks to see if there is any live node in the cluster that cannot
 *    communicate to another live node in the cluster. Node i is
 *    considered alive if c[i,i] is set. Nodes i and j are deemed to
 *    be able to communicate if c[i,j] and c[j,i] are both set.
 *
 ************************************************************************/
_priv _resident int
connectivity_complete(connectivity_matrix_t c)
{
   node_t i, j;

   for (i = 0; i < (node_t) rgp->num_nodes; i++)
   {
      if (node_considered_alive(i))
      {
         for (j = 0; j < i; j++)
         {
            if (node_considered_alive(j) && !connected(i, j))
            {
               /* i and j are a pair of live nodes which are not
                  connected. Thus, there is at least one disconnect.
                  Return 0. */
               return(0);
            }
         }
      }
   }

   /* No disconnects found; return 1. */
   return(1);
}


/************************************************************************
 * find_all_fully_connected_groups
 * ===============================
 *
 * Description:
 *
 *    Function to find all fully connected groups in a graph specified
 *    by a connectivity matrix. An optional "selected_node" can be
 *    used to simplify the search in case of too large a number of
 *    possibilities. In that case, a fully-connected group that
 *    includes selected_node is returned.
 *
 * Parameters:
 *
 *    connectivity_matrix_t c -
 *       input : cluster's connectivity info
 *
 *    node_t selected_node -
 *       input : if there are too many potential groups, just find one
 *       that includes this node; if all groups can be listed, ignore this.
 *
 *    cluster_t groups[] -
 *       output: array of potential clusters
 *
 * Returns:
 *
 *    int - the number of groups made;  0 if no groups or other error
 *
 * Algorithm:
 *
 *    First the set of live nodes and the set of disconnects in the
 *    cluster are evaluated. Then, if the number of live nodes and
 *    disconnects indicates a potentially large number of
 *    possibilities, select_group_with_designated_node() is called to
 *    limit the search to a group including the specified node.
 *    Otherwise, prune() is called to get the list of all possible
 *    fully-connected groups.
 *
 ************************************************************************/
_priv _resident int
find_all_fully_connected_groups(
   connectivity_matrix_t   c,
   node_t                  selected_node,
   cluster_t               groups[])
{
   disconnect_array disconnects;
   cluster_t live_nodes;
   int num_livenodes = 0, num_disconnects = 0;
   node_t i, j;

   ClusterInit(live_nodes);
   for (i = 0; i < (node_t) rgp->num_nodes; i++)
   {
      if (node_considered_alive(i))
      {
         ClusterInsert(live_nodes, i);
         num_livenodes++;
         for (j = 0; j < i; j++)
         {
            if (node_considered_alive(j) && !connected(i, j))
            {
               /* i and j are a pair of live nodes which are not
                  connected. */
               disconnects[num_disconnects][0] = i;
               disconnects[num_disconnects][1] = j;
               num_disconnects++;
            }
         }
         if (too_many_groups(num_livenodes, num_disconnects))
         {
            RGP_TRACE( "RGP Too many dis",
                       num_livenodes,                           /* TRACE */
                       num_disconnects,                         /* TRACE */
                       0, 0 );                                  /* TRACE */
            /* There may be too many choices to consider in reasonable
             * time/space. Just return a fully-connected group that
             * includes the selected node.
             */
            return(select_group_with_designated_node(c,selected_node,groups));
         }
      }
   }

   if (num_livenodes == 0)
      return(0);
   else
      return(prune(disconnects, num_disconnects, live_nodes, groups));
}
/*---------------------------------------------------------------------------*/

#ifdef __cplusplus
}
#endif /* __cplusplus */


#if 0

History of changes to this file:
-------------------------------------------------------------------------
1995, December 13                                           F40:KSK0610          /*F40:KSK06102.2*/

This file is part of the portable Regroup Module used in the NonStop
Kernel (NSK) and Loosely Coupled UNIX (LCU) operating systems. There
are 10 files in the module - jrgp.h, jrgpos.h, wrgp.h, wrgpos.h,
srgpif.c, srgpos.c, srgpsm.c, srgputl.c, srgpcli.c and srgpsvr.c.
The last two are simulation files to test the Regroup Module on a
UNIX workstation in user mode with processes simulating processor nodes
and UDP datagrams used to send unacknowledged datagrams.

This file was first submitted for release into NSK on 12/13/95.
------------------------------------------------------------------------------
This change occurred on 19 Jan 1996                                              /*F40:MB06458.1*/
Changes for phase IV Sierra message system release. Includes:                    /*F40:MB06458.2*/
 - Some cleanup of the code                                                      /*F40:MB06458.3*/
 - Increment KCCB counters to count the number of setup messages and             /*F40:MB06458.4*/
   unsequenced messages sent.                                                    /*F40:MB06458.5*/
 - Fixed some bugs                                                               /*F40:MB06458.6*/
 - Disable interrupts before allocating broadcast sibs.                          /*F40:MB06458.7*/
 - Change per-packet-timeout to 5ms                                              /*F40:MB06458.8*/
 - Make the regroup and powerfail broadcast use highest priority                 /*F40:MB06458.9*/
   tnet services queue.                                                          /*F40:MB06458.10*/
 - Call the millicode backdoor to get the processor status from SP               /*F40:MB06458.11*/
 - Fixed expand bug in msg_listen_ and msg_readctrl_                             /*F40:MB06458.12*/
 - Added enhancement to msngr_sendmsg_ so that clients do not need               /*F40:MB06458.13*/
   to be unstoppable before calling this routine.                                /*F40:MB06458.14*/
 - Added new steps in the build file called                                      /*F40:MB06458.15*/
   MSGSYS_C - compiles all the message system C files                            /*F40:MB06458.16*/
   MSDRIVER - compiles all the MSDriver files                                    /*F40:MB06458.17*/
   REGROUP  - compiles all the regroup files                                     /*F40:MB06458.18*/
 - remove #pragma env libspace because we set it as a command line               /*F40:MB06458.19*/
   parameter.                                                                    /*F40:MB06458.20*/
-----------------------------------------------------------------------          /*F40:MB06458.21*/

#endif    /* 0 - change descriptions */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\mm\srgpsm.c ===
#ifdef __TANDEM
#pragma columns 79
#pragma page "srgpsm.c - T9050 - Regroup Module state machine routines"
#endif

/* @@@ START COPYRIGHT @@@
**  Tandem Confidential:  Need to Know only
**  Copyright (c) 1995, Tandem Computers Incorporated
**  Protected as an unpublished work.
**  All Rights Reserved.
**
**  The computer program listings, specifications, and documentation
**  herein are the property of Tandem Computers Incorporated and shall
**  not be reproduced, copied, disclosed, or used in whole or in part
**  for any reason without the prior express written permission of
**  Tandem Computers Incorporated.
**
** @@@ END COPYRIGHT @@@
**/

/*---------------------------------------------------------------------------
 * This file (srgpsm.c) contains regroup state machine routines.
 *---------------------------------------------------------------------------*/

#ifdef __cplusplus
   extern "C" {
#endif /* __cplusplus */


#include <wrgp.h>


/*---------- arbitration algorithm ------------ */

DWORD MmQuorumArbitrationTimeout   = 60; // seconds
DWORD MmQuorumArbitrationEqualizer = 7;  // seconds

#define RGP_ARBITRATION_TIMEOUT             ((MmQuorumArbitrationTimeout * 100)/30) // tick == 300ms 
#define AVERAGE_ARBITRATION_TIME_IN_SECONDS (MmQuorumArbitrationEqualizer)

void enter_first_cleanup_stage();
void regroup_restart();
int ClusterEmpty(cluster_t c);

DWORD
DiskArbitrationThread(
    IN LPVOID param
    ) ;

_priv _resident static int
regroup_test_arbitrate_advance()
{
   cluster_t temp;
   int orig_numnodes    = ClusterNumMembers(rgp->rgpinfo.cluster);
   int current_numnodes = ClusterNumMembers(rgp->rgppkt.pruning_result);

   if( orig_numnodes == current_numnodes ) {
      return 1;
   }
   //
   // If somebody entered stage4 then our group owns the quorum
   //
   ClusterIntersection(
       temp,
       rgp->rgppkt.knownstage4,
       rgp->rgppkt.pruning_result
       );

   return ClusterNumMembers(temp) != 0;
}

_priv _resident static int
regroup_start_arbitrate()
{
   int orig_numnodes    = ClusterNumMembers(rgp->rgpinfo.cluster);
   int current_numnodes = ClusterNumMembers(rgp->rgppkt.pruning_result);

   if( orig_numnodes == current_numnodes ) {
      enter_first_cleanup_stage();
      return 0; // No Arbitration needed. Proceed to clean up stage //
   }
   else {
      cluster_t arbitrators;
      int       n_arbitrators;
      node_t    arbitrator;
      HANDLE    thread;
      DWORD     threadId;
      ULONG     epoch;

      RGP_LOCK;

      epoch = rgp->OS_specific_control.EventEpoch;

      if(rgp->arbitration_started) {
         RGP_UNLOCK;
         return 1; // stay in this stage for awhile
      }

      rgp->arbitration_ticks = 0;
      rgp->arbitration_started = 1;

      RGP_UNLOCK;

      ClusterIntersection(
          arbitrators,
          rgp->rgppkt.pruning_result,
          rgp->rgppkt.quorumowner
          );

      n_arbitrators = ClusterNumMembers(arbitrators);

      if(n_arbitrators == 0) {
         //
         // If there are no quorum owners in this group //
         // Let's take the guy with the lowest id       //
         //
         arbitrator = rgp_select_tiebreaker(rgp->rgppkt.pruning_result);
      } else {
         //
         // Otherwise we will take the quorum owner guy
         // with the lowest id
         //
         arbitrator = rgp_select_tiebreaker(arbitrators);

         if(n_arbitrators > 1) {
            RGP_TRACE( "RGP !!! More than one quorum owner",
                       EXT_NODE(arbitrator),                    /* TRACE */
                       GetCluster( rgp->rgpinfo.cluster ),      /* TRACE */
                       GetCluster( rgp->rgppkt.pruning_result ),/* TRACE */
                       GetCluster( rgp->rgppkt.knownstage2 ) ); /* TRACE */
            // Do we need to kill all other arbitrators?
            // No.
            // ClusterDelete(arbitrators, arbitrator);
            // ClusterUnion(
            //     rgp->poison_targets,
            //     rgp->poison_targets,
            //     arbitrators
            //     );
            // rgp_broadcast(RGP_UNACK_POISON);
         }
      }

      rgp->tiebreaker = arbitrator;

      //
      // Now we have an arbitrating node
      // We will run a thread that will run arbitration algorithm
      //

      RGP_TRACE( "RGP Arbitration Delegated to",
                 EXT_NODE(arbitrator),                    /* TRACE */
                 GetCluster( rgp->rgpinfo.cluster ),      /* TRACE */
                 GetCluster( rgp->rgppkt.pruning_result ),       /* TRACE */
                 GetCluster( rgp->rgppkt.knownstage2 ) ); /* TRACE */

      rgp->OS_specific_control.ArbitratingNode = (DWORD)EXT_NODE(arbitrator);

      if(arbitrator != rgp->mynode) {
         return 1;
      }

      thread = CreateThread( NULL, // security attributes
                             0,    // stack_size = default
                             DiskArbitrationThread,
                             ULongToPtr(epoch),
                             0,    // runs immediately
                             &threadId );
      if(thread == NULL) {
         //
         // Force Others to regroup //
         //
         RGP_LOCK;

         rgp_event_handler( RGP_EVT_BANISH_NODE, EXT_NODE(rgp->mynode) );

         RGP_UNLOCK;

         //
         // Kill this node
         //
         RGP_ERROR(RGP_ARBITRATION_FAILED);

         return FALSE;
      }

      CloseHandle(thread);
   }
   return TRUE;
}

DWORD
DiskArbitrationThread(
    IN LPVOID param
    )
{
   cluster_t current_participants;
   DWORD     status;
   int       participant_count;
   int       delay;
   ULONG_PTR startingEpoch = (ULONG_PTR) param;
   BOOL      EpochsEqual;
   int       orig_numnodes;
   int       current_numnodes;
   LONGLONG  Time1, Time2;
   
   ClusterCopy(current_participants, rgp->rgppkt.pruning_result);
   orig_numnodes = ClusterNumMembers(rgp->rgpinfo.cluster);
   current_numnodes = ClusterNumMembers(current_participants);

   RGP_LOCK;

   EpochsEqual = ( startingEpoch == rgp->OS_specific_control.EventEpoch );

   RGP_UNLOCK;

   if(!EpochsEqual)
      return 0;

   delay = (orig_numnodes+1)/2 - current_numnodes;

   if(delay < 0) delay = 0;

   Sleep(delay * 6000);

   RGP_LOCK;

   EpochsEqual = ( startingEpoch == rgp->OS_specific_control.EventEpoch );
   if (EpochsEqual) {
      rgp->OS_specific_control.ArbitrationInProgress += 1;
   }

   RGP_UNLOCK;

   if(!EpochsEqual)
      return 0;

   GetSystemTimeAsFileTime((LPFILETIME)&Time1);
   status = (*(rgp->OS_specific_control.QuorumCallback))();
   GetSystemTimeAsFileTime((LPFILETIME)&Time2);

   if (status != 0 
    && startingEpoch == rgp->OS_specific_control.EventEpoch)
   {
       // If we won the arbitration and we are in the same epoch (approx check)
       // we need to figure out whether we need to slow down a little
   
       Time2 -= Time1;

       // Convert to seconds

       Time2 = Time2 / 10 / 1000 / 1000;
       //
       // [HACKHACK] GorN Oct/30/1999
       //   We had a weird timejump in the middle of the arbitration
       //   Arbitration was completed before it started, we slept for 
       //   too long and regroup timed us out. Let's guard against it.
       //
       if ( (Time2 >= 0)
         && (Time2 < AVERAGE_ARBITRATION_TIME_IN_SECONDS) ) 
       {
       
          //
          // Don't need to be better than the average
          // If we are so fast, let's slow down
          //

          Time2 = AVERAGE_ARBITRATION_TIME_IN_SECONDS - Time2;
       
          RGP_TRACE( "RGP sleeping",
                  (ULONG)Time2,  /* TRACE */
                  0,      /* TRACE */
                  0,      /* TRACE */
                  0 );    /* TRACE */
          Sleep( (ULONG)(Time2 * 1000) );
       }
   }       
   

   RGP_LOCK;

   rgp->OS_specific_control.ArbitrationInProgress -= 1;

   EpochsEqual = ( startingEpoch == rgp->OS_specific_control.EventEpoch );

   if(!EpochsEqual) {
      RGP_UNLOCK;
      return 0;
   }

   if(status) {
      //
      // We own the quorum device
      // Let's proceed to the next stage
      //
      enter_first_cleanup_stage();
      RGP_UNLOCK;
      //
      // All the rest will see that we are in cleanup stage and
      // will proceed to it too
      //
   } else {
      //
      // Force Others to regroup //
      //
      rgp_event_handler( RGP_EVT_BANISH_NODE, EXT_NODE(rgp->mynode) );
      RGP_UNLOCK;

      //
      // Kill this node
      //
      RGP_ERROR(RGP_ARBITRATION_FAILED);
   }

   return 0;
}

/************************************************************************
 * rgp_check_packet
 * rgp_print_packet
 * =================
 *
 * Description:
 *
 *    Forward declarations of functions used in rgp_sanity_check macro
 *
 ************************************************************************/
void rgp_print_packet(rgp_pkt_t* pkt, char* label, int code);
int  rgp_check_packet(rgp_pkt_t* pkt);

/************************************************************************
 * rgp_sanity_check
 * =================
 *
 * Description:
 *
 *   This macro prints RGP packet if it has unreasonable values in
 *   powerfail, knownstages, pruning_result, and connectivity_matrix fields.
 *
 * Parameters:
 *
 *    rgp_pkt_t* pkt -
 *       packet to be checked
 *    char* label -
 *       label that will be printed together with a packet
 *
 * Returns:
 *
 *    VOID
 *
 ************************************************************************/

#define rgp_sanity_check(__pkt,__label)                    \
do {                                                       \
  int __code; __code = rgp_check_packet(__pkt);            \
  if( __code ) {rgp_print_packet(__pkt, __label, __code);} \
} while ( 0 )



/*---------------------------------------------------------------------------*/

/************************************************************************
 * split_brain_avoidance_algorithm
 * ===============================
 *
 * Description:
 *
 *    This algorithm ensures that, after a regroup incident completes,
 *    at most one group of nodes will survive regardless of connectivity
 *    failures.
 *
 * Parameters:
 *
 *    None
 *
 * Returns:
 *
 *    void - no return value; The algorithm results in either this node
 *    halting (with the RGP_AVOID_SPLIT_BRAIN halt code) or this group
 *    being the only group that survives.
 *
 * Algorithm:
 *
 *    The algorithm is described in detail in the Sierra Tech Memo S.84,
 *    "Modifications in Regroup Algorithm for Sierra".
 *
 *    The algorithm looks at the set of nodes currently visible from the
 *    local cluster and compares it to the set of nodes alive before
 *    the regroup incident started (outerscreen). The decision to survive
 *    or halt depends on the number of nodes in the current group compared
 *    to the number of nodes in the original group.
 *
 *    Case 1:
 *       If the current group contains > half the original number, this
 *       group survives.
 *
 *    Case 2:
 *       If the current group contains < half the original number, this
 *       node (and group) halts.
 *
 *    Case 3:
 *       If the current group contains exactly half the original number AND
 *       the current group has at least two members, then this group
 *       survives if and only if it contains the tie-breaker node (selected
 *       when the cluster is formed and after each regroup incident).
 *
 *    Case 4:
 *       If the current group contains exactly half the original number AND
 *       the current group has exactly one member, then we will call the
 *               QuromSelect procedure to check if the Quorum Disk is accessible
 *               from this node. If the procedure returns value TRUE we survive;
 *               else we halt.
 *
 *
 ************************************************************************/
_priv _resident static void
split_brain_avoidance_algorithm()
{
   int orig_numnodes, current_numnodes;

   RGP_TRACE( "RGP SpltBrainAlg",
              EXT_NODE(rgp->tiebreaker),               /* TRACE */
              GetCluster( rgp->rgpinfo.cluster ),      /* TRACE */
              GetCluster( rgp->outerscreen ),          /* TRACE */
              GetCluster( rgp->rgppkt.knownstage2 ) ); /* TRACE */

   /* Sanity checks:
    * 1. The current set of nodes must be a subset of the original set
    *    of nodes.
    * 2. My node must be in the current set. This was checked
    *    when stage2 was entered. No need to check again.
    */
   if (!ClusterSubsetOf(rgp->rgpinfo.cluster, rgp->rgppkt.knownstage2))
      RGP_ERROR(RGP_INTERNAL_ERROR);

   orig_numnodes    = ClusterNumMembers(rgp->rgpinfo.cluster);
   current_numnodes = ClusterNumMembers(rgp->rgppkt.knownstage2);

   if (orig_numnodes == current_numnodes)
      /* All nodes are alive. No split brain possibility. */
      return;

   else if (orig_numnodes == 2)  /* Special 2-node case */
   {
      if ((*(rgp->OS_specific_control.QuorumCallback))())
         return; /* we have access to Quorum disk. We survive. */
      else {
#if defined( NT )
          ClusnetHalt( NmClusnetHandle );
#endif
          RGP_ERROR(RGP_AVOID_SPLIT_BRAIN);
      }
   } /* Special 2-node case */

   else /* Multi (>2) node case */
   {
      if ((current_numnodes << 1) > orig_numnodes)
         /* Our group has more than half the nodes => we are the majority.
          * We can survive. Other group(s) will kill themselves.
          */
         return;
      else if ((current_numnodes << 1) < orig_numnodes)
         /* Our group has less than half the nodes => there may be a
          * larger group alive. We must halt and allow that group to
          * survive.
          */
         RGP_ERROR(RGP_AVOID_SPLIT_BRAIN);
      else
      {
         /* Our group has exactly half the number of processors;
          * We survive if we contain the tie-breaker node and halt otherwise.
          */
         if (ClusterMember(rgp->rgppkt.knownstage2, rgp->tiebreaker))
            return;
         else
            RGP_ERROR(RGP_AVOID_SPLIT_BRAIN);
      }
   } /* Multi (>2) node case */

}


/************************************************************************
 * regroup_restart
 * ===============
 *
 * Description:
 *
 *    Starts a new regroup incident.
 *
 * Parameters:
 *
 *    None
 *
 * Returns:
 *
 *    void - no return value
 *
 * Algorithm:
 *
 *    Sets the regroup state to RGP_ACTIVATED, pauses all IO and
 *    initializes the stage masks and connectivity matrix.
 *
 ************************************************************************/
_priv _resident static void
regroup_restart()
{
   cluster_t old_ignorescreen;
   UnpackIgnoreScreen(&rgp->rgppkt, old_ignorescreen);

   RGP_TRACE( "RGP (re)starting",
              rgp->rgppkt.seqno,                               /* TRACE */
              rgp->rgppkt.reason,                              /* TRACE */
              rgp->rgppkt.activatingnode,                      /* TRACE */
              rgp->rgppkt.causingnode );                       /* TRACE */

   RGP_TRACE( "RGP masks       ",
              RGP_MERGE_TO_32( rgp->outerscreen,               /* TRACE */
                               rgp->innerscreen ),             /* TRACE */
              RGP_MERGE_TO_32( rgp->rgppkt.knownstage1,        /* TRACE */
                               rgp->rgppkt.knownstage2 ),      /* TRACE */
              RGP_MERGE_TO_32( rgp->rgppkt.knownstage3,        /* TRACE */
                               rgp->rgppkt.knownstage4 ),      /* TRACE */
              RGP_MERGE_TO_32( rgp->rgppkt.knownstage5,        /* TRACE */
                               rgp->rgppkt.pruning_result ) ); /* TRACE */

   /* We are about to start a new pass of the regroup algorithm.
    * This does not necessarily mean we have finished the previous
    * pass; i.e., in an abort situation we may be starting over.
    * This may occur when some other node fails during the current
    * pass through the algorithm leaving us hung up at one of the
    * intermediate stages.
    */

   //
   // GN. When we do MM_LEAVE. Our state is COLDLOADED.
   //  Bailing out of regroup_restart here would prevent us from
   //  forming a regroup packet that would initate a banishing regroup incident
   //

   /* To avoid split brained nodes from corrupting data in storage
    * devices, we request the transport subsystem to hold all IO requests
    * in a queue and not transfer them over SNet. We will allow IO to
    * be resumed when regroup can guarantee that there can no longer be
    * split brains. This will be done when the final group is determined
    * and regroup enters the RGP_PHASE1_CLEANUP stage.
    */

   rgp_hold_all_io();

   /* The following is a bit of history from the NSK regroup algorithm from
    * pre-Sierra systems based on the InterProcessor Bus (IPB). Some of
    * the particulars mentioned here have changed, but the principle remains.
    *
    * Previously, we used to mark all the known stages as zero, except for
    * stage1. We used to mark only ourselves as in stage1. So, even if our
    * bus reception logic is screwed up, and we are not receiving packets
    * from anybody including ourselves, we would mark ourselves as being in
    * stage1. And after (what used to be) six ticks, we would proceed into
    * stage2 and mark ourselves as being in stage2. This would cause stage1
    * and stage2 to be equal, and our world would constitute just
    * ourselves. Thus we would go through regroup eliminating everybody
    * else. However, since we are not receiving packets from anybody else,
    * we would miss our own iamalive packets, and we too will soon die of
    * %4032. Thus the symptoms would constitute everybody else dying of
    * (%4040 + some node number), and that node dying with a %4032 halt.
    * See TPR S 88070112309628 for more details.
    *
    * To avoid this situation, we now do not mark ourselves as in a
    * particular stage until we get our own regroup packets indicating we
    * are in that stage. Thus, in regroup_restart, all the stages are
    * cleared. Previously, regroupbroadcaststatus in sendqueuedmessages
    * used to send directly from the regroup_control structures.
    * regroupbroadcaststatus has been modified to construct the unsequenced
    * packets on its stack. It would first copy the state from the
    * regroup_control structure, and then would LOR in our node into a known
    * stage, if requested to do so. When we receive that packet, we would
    * merge that information into our state, and thus we would be
    * guaranteed that our bus sending and reception logic is working, and
    * that we can legitimately mark ourselves as being in that stage. This
    * whole change avoids problems where bus sending logic works, but bus
    * reception logic is screwed up for both buses in a node.
    */

   rgp->sendstage = 0; /* Don't let anyone know I am in stage 1 until
                        * I have seen a regroup clock tick; this is to
                        * cause this node to halt if it is not getting
                        * clock ticks. I will halt when the other nodes
                        * advance without me and send me a status packet
                        * indicating this or send me a poison packet
                        * after declaring me down.
                        */


   rgp->rgpcounter = 0;
   ClusterInit(rgp->rgppkt.knownstage1);
   ClusterInit(rgp->rgppkt.knownstage2);
   ClusterInit(rgp->rgppkt.knownstage3);
   ClusterInit(rgp->rgppkt.knownstage4);
   ClusterInit(rgp->rgppkt.knownstage5);
   ClusterInit(rgp->rgppkt.pruning_result);

   MatrixInit(rgp->rgppkt.connectivity_matrix);
   MatrixInit(rgp->internal_connectivity_matrix);
   
   /* Just for ease of debugging, to send in our poison packets, we keep
    * the known nodes mask at the start of regroup. poison packets contain
    * known nodes at the beginning of regroup and at the end of it.
    */

   ClusterCopy(rgp->initnodes, rgp->rgpinfo.cluster);
   ClusterInit(rgp->endnodes);

#if defined( NT )
   //
   // increment the event epoch so we can detect stale events
   // from clusnet
   //
   ++rgp->OS_specific_control.EventEpoch;
#endif

   if ( (rgp->rgppkt.stage >= RGP_CLOSING) &&
        (rgp->rgppkt.stage <= RGP_PHASE2_CLEANUP) &&
        ClusterCompare(rgp->rgppkt.knownstage1,
                       rgp->rgppkt.knownstage2) ) 
   {
       //
       // If we were interrupted by this restart after we closed
       // 1st stage regroup window, then no nodes can be added to group w/o joining.
       //
       // Thus we will add missing nodes into our ignorescreen.
       // This will force the regroup not to wait for them in stage1
       cluster_t tmp;

       ClusterDifference(tmp, rgp->rgpinfo.cluster, rgp->innerscreen);
       ClusterUnion(rgp->ignorescreen, rgp->ignorescreen, tmp);
   }

   if ( ClusterMember(rgp->ignorescreen, rgp->mynode) ) {
       // We shouldn't have get here, but since we are here
       // Let's shield us from the outside world
       RGP_TRACE( "Self Isolation", 0, 0, 0, 0 );
       ClusterCopy(rgp->ignorescreen, rgp->rgpinfo.cluster);
       ClusterDelete(rgp->ignorescreen, rgp->mynode);
   }

   if ( !ClusterEmpty(rgp->ignorescreen) ) {
       // if we are ignoring somebody we have
       // to be cautious. I.e. we will stay longer in the
       // first stage to give a chance to everybody to learn about
       // our ignorescreen
       rgp->cautiousmode = 1;
   } 
   
   if ( !ClusterCompare(old_ignorescreen, rgp->ignorescreen) ) {
       // Ignore screen is changed, reset restart counter //
       RGP_TRACE( "Ignorescreen->", GetCluster(old_ignorescreen), GetCluster(rgp->ignorescreen), 0, 0 );
       rgp->restartcount = 0;
   }
   PackIgnoreScreen(&rgp->rgppkt, rgp->ignorescreen);

   rgp->arbitration_started = 0;

   rgp->OS_specific_control.ArbitrationInProgress = 1;
   rgp->OS_specific_control.ArbitratingNode = MM_INVALID_NODE;
   if ( !rgp_is_perturbed() ) {
       ResetEvent( rgp->OS_specific_control.Stabilized );
   }

   ClusterInit(rgp->rgppkt.quorumowner);
   if( QuorumOwner == (DWORD)EXT_NODE(rgp->mynode) ) {
      ClusterInsert(rgp->rgppkt.quorumowner, rgp->mynode);
   }


   if (rgp->rgppkt.stage == RGP_COLDLOADED)
   {
       if (!rgp->OS_specific_control.ShuttingDown) {
           //
           // Currently, RGP_RELOADFAILED calls ExitProcess
           // During clean shutdown we would like to send the regroup packet
           // out triggering a regroup. So we don't want to die.
           //
           // Since we are not resetting state to RGP_ACTIVATED, this
           // node will not be able to participate in the regroup.
           //
           RGP_ERROR(RGP_RELOADFAILED);
       }
   } else {
       rgp->rgppkt.stage = RGP_ACTIVATED;
   }

}

/************************************************************************
 * regroup_test_stage2_advance
 * ===========================
 *
 * Description:
 *
 *    Checks to see if we can advance to regroup stage 2.
 *
 * Parameters:
 *
 *    None
 *
 * Returns:
 *
 *    int - 1 if stage 2 can be entered and 0 if not.
 *
 * Algorithm:
 *
 *    Stage 2 can be entered if one of the following conditions is true.
 *
 *    (a) all nodes are present and accounted for and at least one
 *        regroup clock tick has occurred
 *    (b) we are not in cautious mode, all but one node are present
 *        and accounted for, AND a minimum number of ticks
 *        (rgp_quickdecisionlegit) have elapsed.
 *    (c) if RGP_MUST_ENTER_STAGE2 ticks have elapsed.
 *
 ************************************************************************/
_priv _resident static int
regroup_test_stage2_advance()
{

   cluster_t stragglers; /* set of nodes not yet checkd in */
   int num_stragglers;   /* # of nodes not yet checkd in   */

   /* Stage 2 must be entered after some interval regardless of any
    * other conditions.
    */
   if (rgp->rgpcounter == 0)
      return(0);
   if (rgp->rgpcounter >= RGP_MUST_ENTER_STAGE2)
   {
       RGP_TRACE( "RGP S->2cautious",
                  rgp->rgpcounter,                         /* TRACE */
                  rgp->cautiousmode,                       /* TRACE */
                  GetCluster( rgp->outerscreen ),          /* TRACE */
                  GetCluster( rgp->rgppkt.knownstage1 ) ); /* TRACE */
      return(1);
   }

   /* The number of ticks is between 1 and RGP_MUST_ENTER_STAGE2.
    * We need to examine the stage1 mask to decide if we can
    * advance.
    *
    * If every node in the old configuration has checked in, I can
    * advance at once. This is either a false alarm or caused by
    * power failure or connectivity failures.
    */

   /* Compute the set of nodes from the original configuration not yet
    * recognized.
    */
   ClusterDifference(stragglers, rgp->outerscreen,
                     rgp->rgppkt.knownstage1);

   //
   // We shouldn't wait for the nodes we are ignoring,
   // since we cannot get a packet from them anyway
   //
   ClusterDifference(stragglers, stragglers, 
                     rgp->ignorescreen);

   if ((num_stragglers = ClusterNumMembers(stragglers)) == 0)
   {
      RGP_TRACE( "RGP S->2 all in ",
                 rgp->rgpcounter,                        /* TRACE */
                 GetCluster( rgp->outerscreen ), 0, 0 ); /* TRACE */

      return(1);   /* all present and accounted for */
   }

   /* If stragglers is non-empty, perhaps I can still advance to stage 2
    * if I am not in cautious mode (no recent power fail and not
    * aborting and rerunning the regroup algorithm) AND all nodes but
    * one have checked in AND some minimum number of ticks have elapsed.
    *
    * The minimum number of ticks is selected to be 1 greater than the
    * the LATEPOLL inititiation period (allowed consecutive missed IamAlive time)
        * since that should guarantee that, if the
    * cluster has broken off into multiple disconnected clusters,
    * the other clusters would have detected the missing IamAlives,
    * started regroup and paused IO, thus preventing the possibility
    * of data corruption caused by a split brain situation.
    */

   if (!(rgp->cautiousmode) &&
       (num_stragglers == 1) &&
           (rgp->rgpcounter > rgp->rgpinfo.Min_Stage1_ticks))
   {
      RGP_TRACE( "RGP S->2 1 miss ",
                 rgp->rgpcounter,                            /* TRACE */
                 GetCluster( rgp->outerscreen ),             /* TRACE */
                 GetCluster( rgp->rgppkt.knownstage1 ), 0 ); /* TRACE */
      return(1);  /* advance - all but one checked in */
   }

   return(0); /* sorry cannot advance yet */

}


/************************************************************************
 * regroup_stage3_advance
 * ===========================
 *
 * Description:
 *
 *    This function is called after the split brain avoidance algorithm
 *    is run and the tie-breaker is selected in stage 2. It checks if
 *    we can proceed to stage 3 (RGP_PRUNING) and advances to stage 3
 *    if possible.
 *
 * Parameters:
 *
 *    None
 *
 * Returns:
 *
 *    int - 1 if the regroup stage has been advanced to RGP_PRUNING;
 *          0 if the stage cannot be advanced yet.
 *
 * Algorithm:
 *
 *    The algorithm depends on whether we are the tie-breaker or not.
 *
 *    On the tie-breaker node, we first check if there are any
 *    disconnects in the cluster. If there aren't any, there is no need
 *    for pruning. We can then set pruning_result to knownstage2,
 *    advance to the RGP_PRUNING stage and return 1. If there are
 *    disconnects, we must wait a certain number of ticks to collect
 *    connectivity info from all nodes. If the number of ticks have not
 *    passed, return 0. If the required number of ticks have elapsed,
 *    we must call the pruning algorithm to get the list of potential
 *    groups. After that, the select_cluster() routine is called to
 *    pick one from the set of possible clusters. After this is done,
 *    pruning_result is set to the selected cluster and we return 1.
 *
 *    On a non-tiebreaker node, nothing is done till a stage3 packet is
 *    received from the tie-breaker node or another node which got a
 *    stage 3 packet. If a stage 3 packet has not been received, we
 *    simply return 0. If a stage 3 packet is received, RGP_PRUNING
 *    stage is entered and we return 1.
 *
 ************************************************************************/
_priv _resident int
regroup_stage3_advance()
{
   int stage_advanced = 0, numgroups, groupnum;

   if (rgp->tiebreaker == rgp->mynode)
   {
      if (connectivity_complete(rgp->rgppkt.connectivity_matrix))
      {

         /* No disconnects. All nodes in knownstage2 survive. */
         rgp->rgppkt.stage = RGP_PRUNING;

         ClusterCopy(rgp->rgppkt.pruning_result,
                     rgp->rgppkt.knownstage2);
         stage_advanced = 1;

         RGP_TRACE( "RGP S->3 NoPrune", rgp->rgpcounter, 0, 0, 0 );
      }

      /* There are disconnects; must wait for connectivity
       * information to be complete. The info is deemed
       * complete after a fixed number of ticks have
       * elapsed.
       */

      else if (rgp->pruning_ticks >= RGP_CONNECTIVITY_TICKS)
      { /* connectivity info collection complete; enter stage 3 */

         RGP_TRACE( "RGP Con. matrix1",
              RGP_MERGE_TO_32( rgp->rgppkt.connectivity_matrix[0],   /*TRACE*/
                               rgp->rgppkt.connectivity_matrix[1] ), /*TRACE*/
              RGP_MERGE_TO_32( rgp->rgppkt.connectivity_matrix[2],   /*TRACE*/
                               rgp->rgppkt.connectivity_matrix[3] ), /*TRACE*/
              RGP_MERGE_TO_32( rgp->rgppkt.connectivity_matrix[4],   /*TRACE*/
                               rgp->rgppkt.connectivity_matrix[5] ), /*TRACE*/
              RGP_MERGE_TO_32( rgp->rgppkt.connectivity_matrix[6],   /*TRACE*/
                               rgp->rgppkt.connectivity_matrix[7])); /*TRACE*/
         RGP_TRACE( "RGP Con. matrix2",
              RGP_MERGE_TO_32( rgp->rgppkt.connectivity_matrix[8],   /*TRACE*/
                               rgp->rgppkt.connectivity_matrix[9] ), /*TRACE*/
              RGP_MERGE_TO_32( rgp->rgppkt.connectivity_matrix[10],  /*TRACE*/
                               rgp->rgppkt.connectivity_matrix[11]), /*TRACE*/
              RGP_MERGE_TO_32( rgp->rgppkt.connectivity_matrix[12],  /*TRACE*/
                               rgp->rgppkt.connectivity_matrix[13]), /*TRACE*/
              RGP_MERGE_TO_32( rgp->rgppkt.connectivity_matrix[14],  /*TRACE*/
                               rgp->rgppkt.connectivity_matrix[15]));/*TRACE*/

         numgroups = find_all_fully_connected_groups(
                        rgp->rgppkt.connectivity_matrix,
                        rgp->tiebreaker,
                        rgp->potential_groups);

         if ((void *)rgp->select_cluster == RGP_NULL_PTR)
         {
             node_t keynode;
             cluster_t temp;
             ClusterIntersection(
                 temp,
                 rgp->rgppkt.knownstage2,
                 rgp->rgppkt.quorumowner
                 );
             if ( ClusterEmpty(temp) ) {
                 keynode = RGP_NULL_NODE;
             } else {
                 keynode = rgp_select_tiebreaker(temp);
             }
             RGP_TRACE( "RGP keynode ng  ", keynode, numgroups, 0, 0); /*TRACE*/
            /* No callback specified; use regroup's own routine. */
            groupnum = rgp_select_cluster_ex(
                           rgp->potential_groups, numgroups, keynode);
         }
         else
         {
            /* Call routine specified at rgp_start() time. */
            groupnum = (*(rgp->select_cluster))(
                           rgp->potential_groups, numgroups);
         }

         if (groupnum >= 0)
            ClusterCopy(rgp->rgppkt.pruning_result,
                        rgp->potential_groups[groupnum]);
         else
            /* No group can survive. Can't halt yet.
             * Need to tell everyone else.
             */
            ClusterInit(rgp->rgppkt.pruning_result);

         rgp->rgppkt.stage = RGP_PRUNING;

         stage_advanced = 1;

         RGP_TRACE( "RGP S->3 Pruned ",
                    rgp->rgpcounter,                          /* TRACE */
                    GetCluster( rgp->rgppkt.knownstage2 ),    /* TRACE */
                    GetCluster( rgp->rgppkt.pruning_result ), /* TRACE */
                    numgroups );                              /* TRACE */

      } /* connectivity info collection complete; enter stage 3 */

   } /* tie-breaker node */

   else

   { /* not tie-breaker node */

      if (ClusterNumMembers(rgp->rgppkt.knownstage3) != 0)
      {
         /* We got a stage 3 packet from someone. Enter stage 3. */
         rgp->rgppkt.stage = RGP_PRUNING;

         stage_advanced = 1;

         RGP_TRACE( "RGP Got S3 pkt  ",
                    rgp->rgpcounter,                          /* TRACE */
                    GetCluster( rgp->rgppkt.knownstage2 ),    /* TRACE */
                    GetCluster( rgp->rgppkt.pruning_result ), /* TRACE */
                    GetCluster( rgp->rgppkt.knownstage3 ) );  /* TRACE */
      }

   } /* not tie-breaker node */

   return(stage_advanced);
}


/************************************************************************
 * enter_first_cleanup_stage
 * =========================
 *
 * Description:
 *
 *    This function performs the actions required when entering the
 *    first of the message clean up stages.
 *
 * Parameters:
 *
 *    None
 *
 * Returns:
 *
 *    void - no return value
 *
 * Algorithm:
 *
 *    There are many actions to be performed after the final cluster
 *    is selected. The actions are described in comments throughout
 *    this routine.
 *
 ************************************************************************/
_priv _resident void
enter_first_cleanup_stage()
{
   cluster_t banishees;
   node_t failer;

   rgp->rgppkt.stage = RGP_PHASE1_CLEANUP;

   RGP_TRACE( "RGP S->4        ", rgp->rgpcounter, 0, 0, 0 );

   /* The packets we send now will not indicate we are in the phase 1
    * cleanup stage yet. We indicate we are in this stage only after
    * we have completed the clean up action associated with the stage.
    * This is done in rgp_event_handler, under the
    * RGP_EVT_PHASE1_CLEANUP_DONE event.
    */
   rgp->sendstage = 0;

   /* Now, we can resume IO since we have passed the split brain danger.
    * New split brain situations will result in regroup restarting and
    * pausing IO again.
    */

   rgp_resume_all_io();

   /* Compute in banishees the set of nodes being lost from the old
    * configuration.
    */

   ClusterDifference(banishees, rgp->rgpinfo.cluster,
                     rgp->rgppkt.pruning_result);

   /* Install the new configuration into the masks. */

   ClusterCopy(rgp->outerscreen,     rgp->rgppkt.pruning_result);

#if defined( NT )
   ClusnetSetOuterscreen(
       NmClusnetHandle,
       (ULONG)*((PUSHORT)rgp->outerscreen)
       );
#endif

   ClusterCopy(rgp->innerscreen,     rgp->rgppkt.pruning_result);
   ClusterCopy(rgp->endnodes,        rgp->rgppkt.pruning_result);
   ClusterCopy(rgp->rgpinfo.cluster, rgp->rgppkt.pruning_result);

   /* Select a new tiebreaker because the previous one may have been    */
   /* pruned out. Note: tiebreaker_selected has already been set in S2. */
   rgp->tiebreaker =
      rgp_select_tiebreaker(rgp->rgppkt.pruning_result);
      /* F40 Bug FixID KCY0833 */

   /* Mark the state of the banishees as dead and invoke the
    * node down callback routine.
    */
   for (failer = 0; failer < (node_t) rgp->num_nodes; failer++)
      if (ClusterMember(banishees, failer)
          || rgp->node_states[failer].status == RGP_NODE_COMING_UP // fix bug#265069
          )
      {
         rgp->node_states[failer].status = RGP_NODE_DEAD;
         rgp->node_states[failer].pollstate = AWAITING_IAMALIVE;
         rgp->node_states[failer].lostHBs = 0;

#if !defined(NT)
         (*(rgp->nodedown_callback))(EXT_NODE(failer));
#else

         ClusnetSetNodeMembershipState(NmClusnetHandle,
                                       EXT_NODE( failer ),
                                       ClusnetNodeStateDead);

         //
         // On NT we do the nodedown callback at the end of stage 5.
         // This allows the cleanup phases to complete before we let
         // the "upper" layers know that a node went down.
         //
         if ( ClusterMember(rgp->OS_specific_control.CPUUPMASK,failer) )
            ClusterInsert(
                rgp->OS_specific_control.NeedsNodeDownCallback,
                failer
                );

#endif // !defined(NT)

      }

   /* If some nodes have been lost from the configuration, then I will
    * queue regroup status packets to them. This is a best efforts
    * attempt to ensure that they get quickly taken out if they
    * do in fact continue to run.
    */

   ClusterUnion(rgp->status_targets, banishees, rgp->status_targets);

   //
   // In NT, we are using rgp->rgppkt.hadpowerfail to transmit
   // quorum ownership information
   //
   #if !defined(NT)

   /* I should inform the message system of any node that experienced a
    * power on recovery. The message system can use this to clear error
    * counters so that a link will not be declared down due to errors
    * which may have been caused by the power failure.
    */

   for (failer = 0; failer < (node_t) rgp->num_nodes; failer++)
      if ((ClusterMember(rgp->rgppkt.hadpowerfail, failer)) &&
          !(ClusterMember(banishees, failer)))
         /* This survivor had a power failure. */
         rgp_had_power_failure( EXT_NODE(failer) );

   #endif // NT

   /* Tell the OS to start clean up operations for the failed nodes. */
   rgp_start_phase1_cleanup();
}


/************************************************************************
 * evaluatestageadvance
 * ====================
 *
 * Description:
 *
 *    This function evaluates whether additional state transitions are
 *    possible as a result of the info just received.
 *
 * Parameters:
 *
 *    None
 *
 * Returns:
 *
 *    void - no return value
 *
 * Algorithm:
 *
 *    To evaluate whether we can advance through the stages, a loop is
 *    used with a case entry for each stage. If an entry decides not to
 *    advance to the next stage, it must return from the function. If
 *    it does advance, it should not return but remain in the loop
 *    since it is possible to have cascaded stage transitions
 *    especially in a two node system. Thus, the loop is exited when no
 *    more stage transitions are possible.
 *
 ************************************************************************/
_priv _resident static void
evaluatestageadvance()
{
   cluster_t   temp_cluster;
   node_t      node;
   node_t          i;

   for (;;)  /* loop until someone exits by returning */
   {
      switch (rgp->rgppkt.stage)
      {

         case RGP_COLDLOADED :
         {
            if (!rgp->OS_specific_control.ShuttingDown) {
                RGP_ERROR(RGP_RELOADFAILED);
            }
            return;
         }


         case RGP_ACTIVATED :
         { /* evaluate whether to go to stage RGP_CLOSING */

            if (!regroup_test_stage2_advance())
               return;

            if (!ClusterMember(rgp->rgppkt.knownstage1, rgp->mynode))
               RGP_ERROR(RGP_MISSED_POLL_TO_SELF);

            rgp->rgppkt.stage = RGP_CLOSING;

            rgp->rgpcounter = 0;
            rgp->tiebreaker_selected = 0;

            /* If we abort the regroup, and there's somebody that everybody
             * banished on this regroup, the following line keeps him from
             * joining up on the next regroup.
             */
            ClusterCopy(rgp->innerscreen, rgp->rgppkt.knownstage1);

            break;

         } /* evaluate whether to go to stage RGP_CLOSING */


         case RGP_CLOSING :
         { /* evaluate whether to go to stage RGP_PRUNING */

            if (rgp->tiebreaker_selected)
            {
               if (regroup_stage3_advance())
                  break;  /* try to advance further */
               else
                  return; /* cannot advance any more */
            }

            if (!ClusterCompare(rgp->rgppkt.knownstage1,
                                rgp->rgppkt.knownstage2))
               return;

           //
           // In NT, we no longer use the split-brain avoidance algorithm.
           // We use a cluster-wide arbitration algorithm instead.
           //
           #if !defined(NT)
            /* When the known stage 1 and known stage 2 sets are the
             * same, we have the complete set of nodes that are
             * connected to us. It is time to execute the split-
             * brain avoidance algorithm. If we are a splinter group
             * cut off from the main group, we will not survive this
             * algorithm.
             */

           split_brain_avoidance_algorithm();

           #endif // NT

            /* We are the lucky survivors of the split brain avoidance
             * algorithm. Now, we must proceed to elect a new tie-breaker
             * since the current tie-breaker may no longer be with us.
             */

            rgp->tiebreaker =
               rgp_select_tiebreaker(rgp->rgppkt.knownstage2);

            rgp->tiebreaker_selected = 1;

            RGP_TRACE( "RGP S2 tiebr sel",
                       rgp->rgpcounter,               /* TRACE */
                       EXT_NODE(rgp->tiebreaker),     /* TRACE */
                       0, 0 );                        /* TRACE */

            rgp->pruning_ticks = 0;
            break;

         } /* evaluate whether to go to stage 3 */


         case RGP_PRUNING :
         { /* evaluate whether to go to RGP_PHASE1_CLEANUP stage */

            if (rgp->arbitration_started) {
               if (regroup_test_arbitrate_advance()) {
                  enter_first_cleanup_stage();
                  break;
               } else {
                  return; // Stay in this stage //
               }
            }

            if (rgp->has_unreachable_nodes)
            {
               RGP_TRACE( "RGP Unreach Node",
                  GetCluster( rgp->rgppkt.pruning_result ),     /* TRACE */
                  GetCluster( rgp->unreachable_nodes ), 0, 0 ); /* TRACE */

               /* Must check if the unreachable nodes are in the
                * selected final group. If so, we must restart
                * regroup.
                */
               ClusterIntersection(temp_cluster, rgp->unreachable_nodes,
                                   rgp->rgppkt.pruning_result);

               /* Clear the unreachable node mask and flag after examining
                * them. If we restart, we will start with a clean slate.
                */
               rgp->has_unreachable_nodes = 0;
               ClusterInit(rgp->unreachable_nodes);

               if (ClusterNumMembers(temp_cluster) != 0)
               {
                  /* We have a node unreachable event to a node
                   * selected to survive. We must regenerate
                   * the connectivity matrix and re-run the node
                   * pruning algorithm. Start a new regroup incident.
                   * All restarts are in cautious mode.
                   */
                  rgp->cautiousmode = 1;
                  rgp->rgppkt.seqno = rgp->rgppkt.seqno + 1;
                  rgp->rgppkt.reason = RGP_EVT_NODE_UNREACHABLE;
                  rgp->rgppkt.activatingnode = (uint8) EXT_NODE(rgp->mynode);

                  /* For causingnode, pick the first unreachable node
                   * in temp_cluster.
                   */
                  for (node = 0; node < (node_t) rgp->num_nodes; node++)
                  {
                     if (ClusterMember(temp_cluster, node))
                     {
                        rgp->rgppkt.causingnode = (uint8) EXT_NODE(node);
                        break;
                     }
                  }
                  regroup_restart();
                  return;
               }
            }

            if (!ClusterCompare(rgp->rgppkt.knownstage2,
                                rgp->rgppkt.knownstage3))
               return;

            /* All nodes in the connected cluster have been notified
             * of the pruning decision (entered stage 3). If we are
             * selected to survive, we can now enter stage 4. If we are
             * not in the selected group (pruning_result), we must halt.
             * Wait for at least one node in PRUNING_RESULT to get into
             * stage 4 before halting. This ensures that the algorithm
             * does not stall in stage 3 with all pruned out nodes
             * halting before ANY of the survivors finds that all nodes
             * entered stage 3.
             */

            if (!ClusterMember(rgp->rgppkt.pruning_result, rgp->mynode))
            {
               /* Wait for at least one node in PRUNING_RESULT
                * to get into stage 4 before halting. Since only
                * nodes in PRUNING_RESULT get into stage 4, it is
                * sufficient to check if knownstage4 has any members.
                */
               if (ClusterNumMembers(rgp->rgppkt.knownstage4) != 0)
                  RGP_ERROR(RGP_PRUNED_OUT);
                           return;
            }

            // proceed to second stage of pruning - arbitration
            if( regroup_start_arbitrate() ) {
               return; // stay in this stage
            } else {
               break;  // either proceed to the next, or restart
            }

            break;

         }  /* evaluate whether to go to RGP_PHASE1_CLEANUP stage */


         case RGP_PHASE1_CLEANUP :
         { /* evaluate whether to go to RGP_PHASE2_CLEANUP stage */

            if (!ClusterCompare(rgp->rgppkt.pruning_result,
                                rgp->rgppkt.knownstage4))
               return;

            rgp->rgppkt.stage = RGP_PHASE2_CLEANUP;

            RGP_TRACE( "RGP S->5        ", rgp->rgpcounter, 0, 0, 0 );

            /* The packets we send now will not indicate we are in the phase 2
             * cleanup stage yet. We indicate we are in this stage only after
             * we have completed the clean up action associated with the stage.
             * This is done in rgp_event_handler, under the
             * RGP_EVT_PHASE2_CLEANUP_DONE event.
             */
            rgp->sendstage = 0;

            rgp_start_phase2_cleanup();

            break;

         }   /* evaluate whether to go to RGP_PHASE2_CLEANUP stage */


         case RGP_PHASE2_CLEANUP :
         { /* evaluate whether to go to RGP_STABILIZED stage */

            if (!ClusterCompare(rgp->rgppkt.knownstage4,
                                rgp->rgppkt.knownstage5))
               return;

            RGP_LOCK;

            //
            // [HACKHACK] This is not necessary anymore, since we
            // are holding the lock in message.c when delivering 
            // regroup packet received event
            //
            if (RGP_PHASE2_CLEANUP != rgp->rgppkt.stage) {
                RGP_TRACE( "RGP S->6 (race) ", rgp->rgpcounter, rgp->rgppkt.stage, 0, 0 );
                break;
            }

            rgp->rgppkt.stage             = RGP_STABILIZED;

            RGP_TRACE( "RGP S->6        ", rgp->rgpcounter, 0, 0, 0 );

            rgp->rgpcounter        = 0;
            rgp->restartcount      = 0;

            /* Reset the regroup flags which have not yet been cleared. */
            rgp->cautiousmode      = 0;

            /* Clear the mask indicating nodes which own the quorum resrc. */
            ClusterInit(rgp->rgppkt.quorumowner);

            /* Copy the sequence number into the rgpinfo area. */
            rgp->rgpinfo.seqnum = rgp->rgppkt.seqno;

            SetEvent( rgp->OS_specific_control.Stabilized );
            if (rgp->OS_specific_control.ArbitratingNode != MM_INVALID_NODE) {
                // Somebody was arbitrating //
                rgp->OS_specific_control.ApproxArbitrationWinner =
                	rgp->OS_specific_control.ArbitratingNode;
                if (rgp->OS_specific_control.ArbitratingNode == (DWORD)EXT_NODE(rgp->mynode)) {
                    //
                    // [HackHack] To close 422405
                    // when 421828 is fixed, please uncomment the following line
                    //
                    // QuorumOwner = rgp->OS_specific_control.ArbitratingNode;
                } else {
                    if (QuorumOwner != MM_INVALID_NODE) {
                        ClRtlLogPrint(LOG_UNUSUAL, 
                            "[MM] : clearing quorum owner var (winner is %1!u!), %.\n", 
                            rgp->OS_specific_control.ArbitratingNode
                            );
                    }
                    QuorumOwner = MM_INVALID_NODE;
                }
            }

            rgp_cleanup_complete();

#if defined(NT)
            //
            // On NT we deferred doing the node down callback until all the
            // cleanup phases have been complete.
            //
            ClusterCopy(
                rgp->OS_specific_control.CPUUPMASK,
                rgp->rgpinfo.cluster
                );

            (*(rgp->nodedown_callback))(
                rgp->OS_specific_control.NeedsNodeDownCallback
                );

            //
            // Clear the down node mask
            //
            ClusterInit(rgp->OS_specific_control.NeedsNodeDownCallback);

            //
            // finally, tell clusnet that regroup has finished
            //
            ClusnetRegroupFinished(NmClusnetHandle,
                                   rgp->OS_specific_control.EventEpoch);

            rgp->last_stable_seqno = rgp->rgppkt.seqno;
            

            RGP_UNLOCK;
#endif

            return;

         } /* evaluate whether to go to RGP_STABILIZED stage */


         case RGP_STABILIZED :
            return;            /* stabilized, so I am all done */

                 default :
            RGP_ERROR(RGP_INTERNAL_ERROR);  /* unknown stage */

      } /* switch (rgp->rgppkt.stage) */

  } /* loop until someone exits by returning */
}


/************************************************************************
 * rgp_event_handler
 * =================
 *
 * Description:
 *
 *    The state machine and the heart of the regroup algorithm.
 *
 * Parameters:
 *
 *    int event -
 *       which event happened
 *
 *    node_t causingnode -
 *       node causing the event: node which sent a regroup status
 *       packet or whose IamAlives are missed; if the causing node is
 *       not relevant information, RGP_NULL_NODE can be passed and
 *       is ignored. *This node ID is in external format.*
 *
 * Returns:
 *
 *    void - no return value
 *
 * Algorithm:
 *
 *    The state machine is the heart of the regroup algorithm.
 *    It is organized as a switch statement with the regroup stage as
 *    the case label and the regroup event as the switch variable.
 *    Events could cause regroup to start a new incident, to advance
 *    through stages or to update information without advancing to
 *    another stage. This routine also arranges for regroup status
 *    packets to be sent to all relevant nodes including our own
 *    node.
 *
 ************************************************************************/
_priv _resident void
RGP_EVENT_HANDLER_EX(int event, node_t causingnode, void *arg)
{

   rgp_pkt_t    *rcvd_pkt_p;
   cluster_t    ignorescreen_rcvd;
   uint8        oldstage;
   int          send_status_pkts = 0;


    /* Note: arg is only used when event == RGP_EVENT_RECEIVED_PACKET.  It is the ptr to the packet */

   /* Trace unusual invocations of this routine. */
   if  (event != RGP_EVT_RECEIVED_PACKET  &&  event != RGP_EVT_CLOCK_TICK)
	  RGP_TRACE( "RGP Event       ", event, causingnode, rgp->rgppkt.stage, rgp->rgpcounter );  /* TRACE */

   switch (event)
   {
      case RGP_EVT_NODE_UNREACHABLE :
      { /* All paths to a node are unreachable */

         /* Ignore the event if the unreachable node has been eliminated
          * from our outerscreen. The message system probably doesn't
          * know it yet.
          */
         if (ClusterMember(rgp->outerscreen, INT_NODE(causingnode)))
         {
            /* Store this event and check after node pruning (when
             * entering the RGP_PRUNING stage). If a regroup incident
             * is in progress and we haven't entered the RGP_PRUNING
             * stage yet, this will happen in the current incident.
             * If not, it will happen in the next regroup incident
             * which will surely start soon due to this disconnect.
             *
             * We do not start a regroup incident for this event. We will
             * wait for IamAlives to be missed for starting a new regroup
             * incident. This is due to the requirement that, in case
             * of a total disconnect resulting in multiple groups, we must
             * stay in stage 1 till we can guarantee that the other group(s)
             * has started regroup and paused IO. We assume that the
             * regroup incident started at the IamAlive check tick and
             * use the periodic nature of the IamAlive sends and
             * IamAlive checks to limit the stage1 pause to the period
             * of IamAlive sends (+ 1 tick to drain IO). If we started
             * a regroup incident due to the node unreachable event, we
             * have to stay in stage1 longer.
             */
            rgp->has_unreachable_nodes = 1;
            ClusterInsert(rgp->unreachable_nodes, INT_NODE(causingnode));

            break;
         }
      } /* All paths to a node are unreachable */


      case RGP_EVT_PHASE1_CLEANUP_DONE :
      {
         /* The following checks are needed in case we restarted
          * regroup and asked for phase1 cleanup multiple times.
          * We must make sure that all such requests have been
          * completed.
          */
         if ( (rgp->rgppkt.stage == RGP_PHASE1_CLEANUP) &&
              (rgp->rgp_msgsys_p->phase1_cleanup == 0) )
         { /* all caught up */

            /* Let others and ourselves get packets indicating we are in
             * this stage. When we get that packet, we will update our
             * knownstage field. If our sending or receiving apparatus
             * failed meanwhile and we don't get our own packet, it
             * will cause regroup to be restarted.
             */
            rgp->sendstage = 1;
            send_status_pkts = 1;
            evaluatestageadvance();
         } /* all caught up */

         break;
      }


      case RGP_EVT_PHASE2_CLEANUP_DONE :
      {

         /* The following checks are needed in case we restarted
          * regroup and asked for phase2 cleanup multiple times.
          * We must make sure that all such requests have been
          * completed.
          */
         if ( (rgp->rgppkt.stage == RGP_PHASE2_CLEANUP) &&
              (rgp->rgp_msgsys_p->phase2_cleanup == 0) )
         { /* all caught up */
            /* Let others and ourselves get packets indicating we are
             * in this stage.
             */
            rgp->sendstage = 1;
            send_status_pkts = 1;
            evaluatestageadvance();
         } /* all caught up */
         break;
      }


      case RGP_EVT_LATEPOLLPACKET :
      { /* some node is late with IamAlives */

         RGP_LOCK; // to ensure that the packet receive does not initiate
                           // regroup asynchronously.
                 /* Start a new regroup incident if not already active. */
         if (rgp->rgppkt.stage == RGP_STABILIZED)
         {
            rgp->rgppkt.seqno = rgp->rgppkt.seqno + 1;
            rgp->rgppkt.reason = RGP_EVT_LATEPOLLPACKET;
            rgp->rgppkt.activatingnode = (uint8) EXT_NODE(rgp->mynode);
            rgp->rgppkt.causingnode = (uint8) causingnode;
            regroup_restart();
            send_status_pkts = 1;
         } else if (rgp->rgppkt.stage == RGP_COLDLOADED)
         {
            RGP_ERROR(RGP_RELOADFAILED);
         }
         RGP_UNLOCK;
         break;
      } /* some node is late with IamAlives */

      case MM_EVT_LEAVE:
         rgp->OS_specific_control.ShuttingDown = TRUE;
      case RGP_EVT_BANISH_NODE :
      { /* assumes that the lock is held */

         rgp->rgppkt.seqno = rgp->rgppkt.seqno + 1;
         rgp->rgppkt.activatingnode = (uint8) EXT_NODE(rgp->mynode);
         // Pack Ignore Screen in the regroup_restart will
         // fill reason and causingnode fields of the packet
         ClusterInsert(rgp->ignorescreen, INT_NODE(causingnode) );
         regroup_restart();
         send_status_pkts = 1;
         break;
      }
#if 0
      case MM_EVT_LEAVE: // this node needs to leave the cluster gracefully
      {
                // Initiate a Regroup Event amongst remaining members if any
                // Start a new regroup incident if not already active.
        if (rgp->rgppkt.stage == RGP_STABILIZED)
        {
           rgp->rgppkt.seqno = rgp->rgppkt.seqno + 1;
           rgp->rgppkt.reason = MM_EVT_LEAVE;
           rgp->rgppkt.activatingnode = (uint8) EXT_NODE(rgp->mynode);
           rgp->rgppkt.causingnode = (uint8) EXT_NODE(rgp->mynode);
           regroup_restart();
           send_status_pkts = 1;
        }
        break;
      }
#endif

      case RGP_EVT_CLOCK_TICK :
      { /* called on regroup clock tick when regroup is active */

         if( (rgp->rgppkt.stage == RGP_PRUNING) &&
             (rgp->arbitration_started)
           )
         {
            rgp->arbitration_ticks++;

            if (rgp->arbitration_ticks >= RGP_ARBITRATION_TIMEOUT) {
               //
               // Kill timed-out arbitrator
               //
               if(rgp->tiebreaker == rgp->mynode) {
                  //
                  // If this node was arbitrating, then die
                  //
                  if ( IsDebuggerPresent() ) {
                     DebugBreak();
                  }

                  RGP_ERROR(RGP_ARBITRATION_STALLED);
               }
               else {
                  //
                  // Kill the arbitrator and initiate another regroup
                  //
                  RGP_TRACE(
                      "RGP arbitration stalled     ",
                      rgp->rgppkt.stage, 0, 0, 0
                      );

                  rgp_event_handler(
                      RGP_EVT_BANISH_NODE,
                      EXT_NODE(rgp->tiebreaker)
                      );

                  break;
               }
            }

            evaluatestageadvance();

            //
            // No need to send packets while we are waiting for
            // the arbitrator to win
            //
            // send_status_pkts = rgp->rgppkt.stage != RGP_PRUNING;
            //
            // [GN] Wrong. We do have to send status packets.
            // If we have partial connectivity, we need to 
            // continue exchanging packets, so that the pruner,
            // can learn indirectly that all nodes got the pruning results.
            //
            send_status_pkts = 1;

            break;
         }
         else {
            rgp->rgpcounter++;  /* increment the counter */
         }

         if ( (rgp->rgppkt.stage == RGP_ACTIVATED) && (rgp->sendstage == 0) )
         {
            /* To detect the potential failure of my timer pop mechanism
             * (such as by the corruption of the time list), I wait for
             * at least one regroup clock tick before I let myself and
             * others know I am in stage 1.
             */
            // [GorN Jan14/2000] 
            //   We don't send our connectivity information,
            //   before we get the first clock tick.
            //   However we collect this information in
            //   rgp->internal_connectivity_matrix.
            //      Let's put it in the outgoing packet
            //   so that everybody will see what we think about them.
            
            MatrixOr(rgp->rgppkt.connectivity_matrix, 
                     rgp->internal_connectivity_matrix);
                     
            rgp->sendstage = 1; /* let everyone know we are in stage 1 */
         }
         else if ( (rgp->rgppkt.stage >= RGP_CLOSING) &&
              (rgp->rgppkt.stage <= RGP_PHASE2_CLEANUP) )
         { /* check for possible abort and restart */

            if (rgp->rgpcounter >= RGP_MUST_RESTART)
            {
              /* Stalled out. Probably someone died after starting
               * or another node is still in stage 1 cautious mode
               */

               if ( ++(rgp->restartcount) > RGP_RESTART_MAX ) {
                   // It is not a good idea to die, because somebody
                   // is stalling. Let's add stallees into ignore mask and restart
                   //
                   // RGP_ERROR(RGP_INTERNAL_ERROR); // [Fixed]
                   cluster_t tmp, *stage;

                   switch (rgp->rgppkt.stage) {
                   case RGP_CLOSING: stage = &rgp->rgppkt.knownstage2; break;
                   case RGP_PRUNING: stage = &rgp->rgppkt.knownstage3; break;
                   case RGP_PHASE1_CLEANUP: stage = &rgp->rgppkt.knownstage4; break;
                   case RGP_PHASE2_CLEANUP: stage = &rgp->rgppkt.knownstage5; break;
                   }
                   ClusterDifference(tmp, rgp->rgpinfo.cluster, *stage);

                   //
                   // If we stalled during closing, due to tiebraker running
                   // the pruning algorithn going bunkers, we can have tmp = 0
                   // In this case, we need to ignore somebody to guarantee that
                   // the algorithm completes.
                   //
                   if ( ClusterEmpty(tmp) && rgp->tiebreaker_selected) {
                       ClusterInsert(tmp, rgp->tiebreaker);
                   }

                   ClusterUnion(rgp->ignorescreen, rgp->ignorescreen, tmp);
               }

               /* If we are stalling in stage 3 and we have been pruned out,
                * it is possible that we are stalling because we have been
                * isolated from all other nodes. We must halt in this case.
                */
               if ( (rgp->rgppkt.stage == RGP_PRUNING) &&
                    !ClusterMember(rgp->rgppkt.pruning_result, rgp->mynode) )
                  RGP_ERROR(RGP_PRUNED_OUT);

               rgp->cautiousmode = 1;
               rgp->rgppkt.seqno = rgp->rgppkt.seqno + 1;

               RGP_TRACE( "RGP stalled     ", rgp->rgppkt.stage, 0, 0, 0 );

               regroup_restart();

            } /* Stalled out ... */
         } /* check for possible abort and restart */

         if ((rgp->rgppkt.stage == RGP_CLOSING) && rgp->tiebreaker_selected)
            rgp->pruning_ticks++;

         evaluatestageadvance();

         send_status_pkts = 1; /* send rgp packets regardless of progress */

         break;

      } /* called on regroup clock tick when regroup is active */


      case RGP_EVT_RECEIVED_PACKET :
      { /* received an rgp packet */

         /* If the sending node is excluded by the outer screen, then it is
          * not even part of the current (most recently known) configuration.
          * Therefore the packet should not be honored, and a poison message
          * should be sent to try to kill this renegade processor.
          * That is done in the calling routine that processes all incoming
          * regroup module packets (IamAlive, regroup and poison packets).
          */

         /* If the sending node was accepted by the outer screen but then
          * excluded by the inner screen, then the packet will be disregarded
          * but no poison message sent. This phenomenon may occur when this
          * node has entered stage 2 without having heard from (recognized)
          * the sending node and then a message arrives late from that
          * sending node. In this case the fate of the sending node, i.e.
          * whether it gets ruled out of the global configuration or not is
          * unknown at this point. If the sender can get itself recognized
          * by some node before that node enters stage 2, then it will be
          * saved. Otherwise it will be declared down and subsequently shot
          * with poison packets if it ever tries to assert itself.
          */

	  /* Remember the arg to this routine is the packet pointer */
         rcvd_pkt_p = (rgp_pkt_t *)arg; /* address of pkt just received */
	     if ( rgp->rgppkt.seqno != rcvd_pkt_p->seqno)
		     RGP_TRACE( "RGP Event       ", event, causingnode, rgp->rgppkt.stage, rgp->rgpcounter );  /* TRACE */

         UnpackIgnoreScreen(rcvd_pkt_p, ignorescreen_rcvd);
         if ( !ClusterEmpty(ignorescreen_rcvd) ) {
             RGP_TRACE( "RGP Incoming pkt", GetCluster(ignorescreen_rcvd), 
                        rcvd_pkt_p->seqno, rgp->rgppkt.stage, causingnode);
         }

         if ( !ClusterMember(rgp->innerscreen, INT_NODE(causingnode))) {
             RGP_TRACE( "RGP Ignoring !inner", causingnode, rgp->rgppkt.stage, 
                        GetCluster(rgp->innerscreen), GetCluster(ignorescreen_rcvd) );
             return;
         }

         RGP_LOCK; // To ensure that the timer thread does not initiate
                   // regroup asynchronously at this time.

//////////////////////////// New Ignore Screen Stuff /////////////////////////////////         
         
         if (ClusterMember(rgp->ignorescreen, INT_NODE(causingnode) )) {
             RGP_UNLOCK;
             RGP_TRACE( "RGP Ignoring", causingnode, rgp->rgppkt.stage, 
                        GetCluster(rgp->ignorescreen), GetCluster(ignorescreen_rcvd) );
             return;
         }

         if (rcvd_pkt_p->seqno < rgp->last_stable_seqno ) {
             RGP_UNLOCK;
             RGP_TRACE( "RGP old packet", causingnode, rcvd_pkt_p->seqno, rgp->last_stable_seqno, 0);
             // This is a late packet from the previous regroup incident
             // from the node that is currently in my outerscreen. 
             // This node could not have sent it now, this is probably a packet
             // that stuck somewhere and was delieverd eons later.
             // Simply ignore it.
             return;
         }


         if ( ClusterMember(ignorescreen_rcvd, rgp->mynode ) ) {
             //
             // Sender ignores me. We will do the same to him.
             //
             ClusterInsert(rgp->ignorescreen, INT_NODE(causingnode) );
             rgp->rgppkt.seqno = rgp->rgppkt.seqno + 1;
             regroup_restart();
             send_status_pkts = 1;
             RGP_UNLOCK;
             break;
         }

         if ( ClusterCompare(ignorescreen_rcvd, rgp->ignorescreen) ) {
             // We have the same ignore screen.
             // No work needs to be done
         } else if ( ClusterSubsetOf(rgp->ignorescreen, ignorescreen_rcvd) ) {
             // Incoming packet has smaller ignore screen
             // Ignore this packet, but reply to its sender with
             // our current regroup packet to force to upgrade to
             // our view of the world.
             
             // do so only if we are properly initialized
             if (rgp->rgppkt.stage == RGP_COLDLOADED && !rgp->OS_specific_control.ShuttingDown) {
                 RGP_ERROR(RGP_RELOADFAILED);
             }
         
             RGP_TRACE( "RGP smaller ignore mask ",
                        rgp->rgppkt.seqno, rcvd_pkt_p->seqno,   /* TRACE */
                        rgp->rgppkt.stage, rcvd_pkt_p->stage ); /* TRACE */
 
             ClusterInsert(rgp->status_targets, INT_NODE(causingnode));
             rgp_broadcast(RGP_UNACK_REGROUP);
             RGP_UNLOCK;
             return;
         } else if ( ClusterSubsetOf(ignorescreen_rcvd, rgp->ignorescreen) ) {
             RGP_TRACE( "RGP bigger ignore mask ",
                        GetCluster(ignorescreen_rcvd), GetCluster(rgp->ignorescreen),   /* TRACE */
                        rgp->rgppkt.stage, causingnode ); /* TRACE */
             // Incoming packet has bigger ignore screen.
             // Upgrade to this information and process the packet
             rgp->rgppkt.seqno = rcvd_pkt_p->seqno;
 
             /*  Somebody else activated regroup. So, let's just copy */
             /*  the sender's reason code and reason nodes.           */

             //
             // Ignore mask parts are in the reason and activatingnode fields
             //
 
             ClusterCopy(rgp->ignorescreen, ignorescreen_rcvd); // fix bug #328216
             rgp->rgppkt.reason = rcvd_pkt_p->reason;
             rgp->rgppkt.activatingnode = rcvd_pkt_p->activatingnode;
             rgp->rgppkt.causingnode = rcvd_pkt_p->causingnode;
             regroup_restart();
             send_status_pkts = 1;
         } else {
             RGP_TRACE( "RGP different ignore masks ",
                        GetCluster(ignorescreen_rcvd), GetCluster(rgp->ignorescreen),   /* TRACE */
                        rgp->rgppkt.stage, causingnode ); /* TRACE */
             // Ignore masks are different and neither of them is
             // a subset of another.
             //
             // We need to merge information out of these masks
             // and restart the regroup.
             //
             // Packet that we just received will be ignored

             ClusterUnion(rgp->ignorescreen, rgp->ignorescreen, ignorescreen_rcvd);
             rgp->rgppkt.seqno = max(rgp->rgppkt.seqno, rcvd_pkt_p->seqno) + 1;
             regroup_restart();
             send_status_pkts = 1;
             RGP_UNLOCK;
             break;
         }

//////////////////////////// End of new Ignore Screen Stuff ///////////////////////////////// 

         // Now ignorescreens of this node packet and incoming packet are the same //
         // proceed with regular regroup processing //
         
         /* Since the packet is acceptable, the regroup sequence number
          * must be compared to that of this node. If the incoming message
          * has a higher sequence number, then a new pass of the regroup
          * algorithm has started. This node must accept the new sequence
          * number, reinitialize its data, and start partcicipating in
          * the new pass. Also, the incoming message must be processed
          * since, once the algorithm reinitializes, the sequence numbers
          * now match.
          *
          * If the incoming packet has a matching sequence number, then it
          * should be accepted. The knowledge of the global state of the
          * algorithm it reflects must be merged with that already present
          * in this node. Then this node must evaluate whether further
          * state transitions are possible.
          *
          * Finally, if the incoming packet has a lower sequence number, then
          * it comes from a node unaware of the current level of the global
          * algorithm. The data in it should be ignored, but a packet should
          * be sent to it so that it will reinitialize its algorithm.
          *
          * The sequence number is a 32 bit algebraic value - hopefully it
          * will never wrap around.
          */


         if (rcvd_pkt_p->seqno < rgp->rgppkt.seqno)
         { /* sender below current level - ignore but let him know it*/

            RGP_TRACE( "RGP lower seqno ",
                       rgp->rgppkt.seqno, rcvd_pkt_p->seqno,   /* TRACE */
                       rgp->rgppkt.stage, rcvd_pkt_p->stage ); /* TRACE */

            ClusterInsert(rgp->status_targets, INT_NODE(causingnode));
            rgp_broadcast(RGP_UNACK_REGROUP);
                        RGP_UNLOCK;
            return;
         }

         if (rcvd_pkt_p->seqno > rgp->rgppkt.seqno)
         { /* sender above current level - I must upgrade to it*/

            // The node that forces a restart responsible for keeping
            // track of restarts and making a decision who will die/be ignored
            // if ( ++(rgp->restartcount) > RGP_RESTART_MAX )
            //   RGP_ERROR(RGP_INTERNAL_ERROR);

            if ( (rgp->rgppkt.stage != RGP_STABILIZED) ||
                 ((rcvd_pkt_p->seqno - rgp->rgppkt.seqno) > 1) )
            {
               RGP_TRACE( "RGP higher seqno",
                          rgp->rgppkt.seqno, rcvd_pkt_p->seqno,  /* TRACE */
                          rgp->rgppkt.stage, rcvd_pkt_p->stage );/* TRACE */
               rgp->cautiousmode = 1;
            }

            rgp->rgppkt.seqno = rcvd_pkt_p->seqno;

            /*  Somebody else activated regroup. So, let's just copy */
            /*  the sender's reason code and reason nodes.           */

            rgp->rgppkt.reason = rcvd_pkt_p->reason;
            rgp->rgppkt.activatingnode = rcvd_pkt_p->activatingnode;
            rgp->rgppkt.causingnode = rcvd_pkt_p->causingnode;
            regroup_restart();
            send_status_pkts = 1;

         } /* sender above current level - I must upgrade to it*/

         /* Now we are at the same level - even if we weren't at first.
          *
          * If the sender has already commited to a view of the world
          * that excludes me, I must halt in order to keep the system in
          * a consistent state.
          *
          * This is true even with the split brain avoidance algorithm.
          * The fact that stage1 = stage2 in the packet implies that the
          * sender has already run the split brain avoidance algorithm
          * and decided that he should survive.
          */

         if ( (rcvd_pkt_p->stage > RGP_ACTIVATED) &&
              ClusterCompare(rcvd_pkt_p->knownstage1,
                             rcvd_pkt_p->knownstage2) &&
              !ClusterMember(rcvd_pkt_p->knownstage1, rgp->mynode) )
         {
             ClusterInsert(rgp->ignorescreen, INT_NODE(causingnode) );
             rgp->rgppkt.seqno ++;
             regroup_restart();
             send_status_pkts = 1;
             RGP_UNLOCK;
//             /* I must die for overall consistency. */
//             RGP_ERROR((uint16) (RGP_PARIAH + causingnode)); // [Fixed]
             break;
         }
         RGP_UNLOCK;


         /* If I have terminated the active part of the algorithm, I
          * am in stage 6 and am not routinely broadcasting my status
          * anymore. If I get a packet from someone else who has not
          * yet terminated, then I must send him the word. But if he
          * has terminated, I must not send any packet or else there
          * will be an infinite loop of packets bouncing back and forth.
          */

         if (rgp->rgppkt.stage == RGP_STABILIZED)
         { /* I have terminated so can't learn anything more. */
            if (!ClusterCompare(rcvd_pkt_p->knownstage5,
                                rgp->rgppkt.knownstage5))
            { /* but sender has not so I must notify him */
               ClusterInsert(rgp->status_targets, INT_NODE(causingnode));
               rgp_broadcast(RGP_UNACK_REGROUP);
            }
            return;
         }

         /* At this point, the packet is from a legal node within the
          * current round of the algorithm and I have not terminated
          * at stage RGP_STABILIZED so I need to absorb whatever new
          * info is in this packet.
          *
          * The way to merge what this packet says with what I already
          * know is to just logically OR the known stage x fields
          * together.
          */
          {
              int seqno = rcvd_pkt_p->seqno&0xffff;
              int stage = rcvd_pkt_p->stage&0xffff;
              int trgs = *(int*)rgp->status_targets & 0xffff;
              int node = INT_NODE(causingnode)&0xffff;

              RGP_TRACE( "RGP recv pkt ",
                  ((seqno << 16) | stage),
                  RGP_MERGE_TO_32(
                      rcvd_pkt_p->knownstage1,
                      rcvd_pkt_p->knownstage2
                      ),
                  RGP_MERGE_TO_32(
                      rcvd_pkt_p->knownstage3,
                      rcvd_pkt_p->knownstage4
                      ),
                  (trgs << 16) | node
                  );
         }

         rgp_sanity_check(rcvd_pkt_p,  "RGP Received packet");
         rgp_sanity_check(&(rgp->rgppkt), "RGP Internal packet");

         ClusterUnion(rgp->rgppkt.quorumowner, rcvd_pkt_p->quorumowner,
                      rgp->rgppkt.quorumowner);
         ClusterUnion(rgp->rgppkt.knownstage1, rcvd_pkt_p->knownstage1,
                      rgp->rgppkt.knownstage1);
         ClusterUnion(rgp->rgppkt.knownstage2, rcvd_pkt_p->knownstage2,
                      rgp->rgppkt.knownstage2);
         ClusterUnion(rgp->rgppkt.knownstage3, rcvd_pkt_p->knownstage3,
                      rgp->rgppkt.knownstage3);
         ClusterUnion(rgp->rgppkt.knownstage4, rcvd_pkt_p->knownstage4,
                      rgp->rgppkt.knownstage4);
         ClusterUnion(rgp->rgppkt.knownstage5, rcvd_pkt_p->knownstage5,
                      rgp->rgppkt.knownstage5);
         ClusterUnion(rgp->rgppkt.pruning_result, rcvd_pkt_p->pruning_result,
                      rgp->rgppkt.pruning_result);

         /* But when I am in stage 2, it is possible that I can learn to
          * recognize some node I have not previously recognized by hearing
          * of it indirectly from some other node that I have recognized.
          * To handle this case, I always merge knownstage1 info into
          * the inner screen so that subsequent messages from the newly
          * recognized node will be accepted and processed.
          */
         if  ((rgp->rgppkt.stage == RGP_CLOSING) &&
              !(rgp->tiebreaker_selected))
            ClusterUnion(rgp->innerscreen, rgp->rgppkt.knownstage1,
                         rgp->innerscreen);

         /* In the first two stages of regroup, the inter-node connectivity
          * information is collected and propagated. When we get a regroup
          * packet, we turn ON the bit corresponding to the [our-node,
          * sender-node] entry in the connectivity matrix. We also OR in
          * the matrix sent by the sender node in the regroup packet.
          *
          * The matrix is not updated if we are in stage 1 and haven't
          * received the first clock tick. This is to prevent the
          * node pruning algorithm from considering us alive if our
          * timer mechanism is disrupted, but the IPC mechanism is OK.
          */

         /* [GorN 01/07/2000] If we are not collection connectivity information,
          * until we receive a first tick we can ran into problems if the node is
          * killed right after it send out its first timer driven packet 
          * (which doesn't have any connectivity info yet). This can cause a 
          * confusion. See bug 451792. 
          *
          * What we will do is we will collect connectivity information on
          * the side even when rgp->sendstage is FALSE and move it into the regroup
          * packet if we ever get a clock tick
          */

         if (rgp->rgppkt.stage < RGP_PRUNING && !rgp->sendstage)
         {
            MatrixSet(rgp->internal_connectivity_matrix,
                      rgp->mynode, INT_NODE(causingnode));
            if (causingnode != EXT_NODE(rgp->mynode))
               MatrixOr(rgp->internal_connectivity_matrix,
                        rcvd_pkt_p->connectivity_matrix);
         }

         if ((rgp->rgppkt.stage < RGP_PRUNING) && rgp->sendstage) 
         {
            MatrixSet(rgp->rgppkt.connectivity_matrix,
                      rgp->mynode, INT_NODE(causingnode));
            if (causingnode != EXT_NODE(rgp->mynode))
               MatrixOr(rgp->rgppkt.connectivity_matrix,
                        rcvd_pkt_p->connectivity_matrix);
         }

         /* Now, I can evaluate whether additional state transitions are
          * possible as a result of the info just received.
          */
         oldstage = rgp->rgppkt.stage;

//       QuorumCheck now runs in a separate thread
//         if (oldstage != RGP_CLOSING) // Cannot run Quorumcheck from here.
         evaluatestageadvance();

         /* To speed things up, let us broadcast our status if our
          * stage has changed and we are willing to let others and
          * ourselves see it.
          */

         if ( (oldstage != rgp->rgppkt.stage) && rgp->sendstage )
            send_status_pkts = 1; /* broadcast at once to speed things up */

         break;
      }   /* received an rgp packet */

      //
      // We do not support power failure notifications in NT
      //
      #if defined(NT)

      CL_ASSERT(event != RGP_EVT_POWERFAIL);
      //
      // Fall thru to default case
      //

      #else // NT

      case RGP_EVT_POWERFAIL :
      { /* Our node got a power up interrupt or an indication of power
         * failure from another node. */

         /* Note that this code will unconditionally abort and restart
          * the algorithm even if it was active before the power failure.
          * The new incident must be in cautious mode.
          */

         rgp->cautiousmode = 1;
         rgp->rgppkt.seqno = rgp->rgppkt.seqno + 1;
         rgp->rgppkt.reason = RGP_EVT_POWERFAIL;
         rgp->rgppkt.activatingnode = (uint8) EXT_NODE(rgp->mynode);
         rgp->rgppkt.causingnode = (uint8) causingnode;

         /* rgp->pfail_state is set to a non-zero value when a pfail event
          * is reported to regroup. It is decremented at every regroup clock
          * tick till it reaches zero. While this number is non-zero, missing
          * self IamAlives are ignored and do not cause the node to halt.
          * This gives the sending hardware some time to recover from power
          * failures before self IamAlives are checked.
          */
         if (causingnode == EXT_NODE(rgp->mynode))
            rgp->pfail_state = RGP_PFAIL_TICKS;

         /* Store the fact that causingnode experienced a PFAIL,
          * for reporting to the message system when regroup stabilizes.
          */
         ClusterInsert(rgp->rgppkt.hadpowerfail, INT_NODE(causingnode));

         regroup_restart();
         send_status_pkts = 1;
         break;
      } /* power failure */

      #endif // NT

      default :
      {
         RGP_ERROR(RGP_INTERNAL_ERROR);
      }
   }

   if (send_status_pkts) /* significant change - send status at once */
   {
      ClusterUnion(rgp->status_targets,
                   rgp->outerscreen, rgp->status_targets);
      rgp_broadcast(RGP_UNACK_REGROUP);
   }
}

/************************************************************************
 * rgp_check_packet
 * =================
 *
 * Description:
 *
 *  verifies that RGP packet has reasonable values in
 *  powerfail, knownstages, pruning_result, and connectivity_matrix fields
 *
 * Parameters:
 *
 *    rgp_pkt_t* pkt -
 *       packet to be checked
 *
 * Returns:
 *
 *    0 - packet looks good
 *    1,2,3... - strange looking packet
 *
 ************************************************************************/
int rgp_check_packet(rgp_pkt_t* pkt) {
   node_t       i;

   //
   // Verify that
   //   knownstage5 \subset knownstage4 \subset knownstage3 \subset
   //   knownstage2 \subset knownstage1 \subset rgp->rgpinfo.cluster
   //
   // int ClusterSubsetOf(cluster_t big, cluster_t small)
   //   Returns 1 if set small = set big or small is a subset of big.
   //

   if( !ClusterSubsetOf(pkt->knownstage4, pkt->knownstage5) ) {
      return 5;
   }
   if( !ClusterSubsetOf(pkt->knownstage3, pkt->knownstage4) ) {
      return 4;
   }
   if( !ClusterSubsetOf(pkt->knownstage2, pkt->knownstage3) ) {
      return 3;
   }
   if( !ClusterSubsetOf(pkt->knownstage1, pkt->knownstage2) ) {
      return 2;
   }
   if( !ClusterSubsetOf(rgp->rgpinfo.cluster, pkt->knownstage1) ) {
      return 1;
   }

   //
   // pruning_result has to be a subset of knownstage2
   //
   if( !ClusterSubsetOf(pkt->knownstage2, pkt->pruning_result) ) {
      return 9;
   }

   //
   // quorumowner has to be a subset of original cluster
   //
   if(!ClusterSubsetOf(rgp->rgpinfo.cluster, pkt->quorumowner)) {
      return 8;
   }
   //
   // Check connectivity matrix
   //
   for(i = 0; i < MAX_CLUSTER_SIZE; ++i) {
      if( ClusterMember( rgp->rgpinfo.cluster, i ) ) {
         //
         // Node i is a member of a cluster
         // Its connectivity bitmap has to be a subset of rgp->rgpinfo.cluster
         //
         if(!ClusterSubsetOf(rgp->rgpinfo.cluster, pkt->connectivity_matrix[i])) {
            return 10;
         }
      } else {
         //
         // Node i is not a member of a cluster
         // Its connectivity bitmap has to be 0
         //
         if(!ClusterEmpty(pkt->connectivity_matrix[i]))
            return 11;
      }
   }

   return 0;
}

/************************************************************************
 * rgp_print_packet
 * =================
 *
 * Description:
 *
 *    Prints RGP packet fields
 *
 * Parameters:
 *
 *    rgp_pkt_t* pkt -
 *       packet to be printed
 *    char* label -
 *       label to be printed together with a packet
 *    int code -
 *       a number to be printed together with a packet
 *
 * Returns:
 *
 *    VOID
 *
 ************************************************************************/
void rgp_print_packet(rgp_pkt_t* pkt, char* label, int code)
{
   uint8                   pktsubtype;
   uint8                   stage;
   uint16                  reason;
   uint32                  seqno;
   uint8                   activatingnode;
   uint8                   causingnode;
   cluster_t               quorumowner;

   RGP_TRACE( label,
              pkt->seqno,                               /* TRACE */
              code,
              (pkt->stage << 16) |
              (pkt->activatingnode  << 8) |
              (pkt->causingnode),                       /* TRACE */
              RGP_MERGE_TO_32( rgp->outerscreen,
                               rgp->innerscreen )
               );
   RGP_TRACE( "RGP CHK masks       ",
              RGP_MERGE_TO_32( rgp->rgpinfo.cluster,    /* TRACE */
                               pkt->quorumowner ),      /* TRACE */
              RGP_MERGE_TO_32( pkt->knownstage1,        /* TRACE */
                               pkt->knownstage2 ),      /* TRACE */
              RGP_MERGE_TO_32( pkt->knownstage3,        /* TRACE */
                               pkt->knownstage4 ),      /* TRACE */
              RGP_MERGE_TO_32( pkt->knownstage5,        /* TRACE */
                               pkt->pruning_result ) ); /* TRACE */
   RGP_TRACE( "RGP CHK Con. matrix1",
        RGP_MERGE_TO_32( pkt->connectivity_matrix[0],   /*TRACE*/
                         pkt->connectivity_matrix[1] ), /*TRACE*/
        RGP_MERGE_TO_32( pkt->connectivity_matrix[2],   /*TRACE*/
                         pkt->connectivity_matrix[3] ), /*TRACE*/
        RGP_MERGE_TO_32( pkt->connectivity_matrix[4],   /*TRACE*/
                         pkt->connectivity_matrix[5] ), /*TRACE*/
        RGP_MERGE_TO_32( pkt->connectivity_matrix[6],   /*TRACE*/
                         pkt->connectivity_matrix[7])); /*TRACE*/
   RGP_TRACE( "RGP CHK Con. matrix2",
        RGP_MERGE_TO_32( pkt->connectivity_matrix[8],   /*TRACE*/
                         pkt->connectivity_matrix[9] ), /*TRACE*/
        RGP_MERGE_TO_32( pkt->connectivity_matrix[10],  /*TRACE*/
                         pkt->connectivity_matrix[11]), /*TRACE*/
        RGP_MERGE_TO_32( pkt->connectivity_matrix[12],  /*TRACE*/
                         pkt->connectivity_matrix[13]), /*TRACE*/
        RGP_MERGE_TO_32( pkt->connectivity_matrix[14],  /*TRACE*/
                         pkt->connectivity_matrix[15]));/*TRACE*/
}


/************************************************************************
 * UnpackIgnoreScreen
 * =================
 *
 * Description:
 *
 *    Extracts ignorescreen out of regroup packet
 *
 * Parameters:
 *
 *    rgp_pkt_t* from -
 *       source packet 
 *    cluster_t to -
 *       target node set
 *
 * Returns:
 *
 *    VOID
 *
 * Comments:
 *
 *   If the packet is received from NT4 node, unpacked ignorescreen
 *   will ne always 0.
 *
 ************************************************************************/
void UnpackIgnoreScreen(rgp_pkt_t* from, cluster_t to) 
{
#pragma warning( push )
#pragma warning( disable : 4244 )
    if (from->reason < RGP_EVT_IGNORE_MASK) {
        ClusterInit(to);
    } else {
        to[0] = ((uint16)from->reason) >> 8;
        to[1] = (uint8)from->causingnode;
    }
#pragma warning( pop )
}

/************************************************************************
 * rgp_print_packet
 * =================
 *
 * Description:
 *
 *    Put an ignorescreen back into a regroup packet
 *
 * Parameters:
 *
 *    rgp_pkt_t* to -
 *       packet to be updated
 *    cluster_t from -
 *       source node set
 *
 * Returns:
 *
 *    VOID
 *
 ************************************************************************/
void PackIgnoreScreen(rgp_pkt_t* to, cluster_t from)
{
    if ( ClusterEmpty(from) ) {
        to->reason &= 255;
        to->causingnode = 0;
    } else {
        to->reason = (uint8)RGP_EVT_IGNORE_MASK | (from[0] << 8);
        to->causingnode = from[1];
    }
}



/*---------------------------------------------------------------------------*/

#ifdef __cplusplus
}
#endif /* __cplusplus */


#if 0

History of changes to this file:
-------------------------------------------------------------------------
1995, December 13                                           F40:KSK0610          /*F40:KSK06102.2*/

This file is part of the portable Regroup Module used in the NonStop
Kernel (NSK) and Loosely Coupled UNIX (LCU) operating systems. There
are 10 files in the module - jrgp.h, jrgpos.h, wrgp.h, wrgpos.h,
srgpif.c, srgpos.c, srgpsm.c, srgputl.c, srgpcli.c and srgpsvr.c.
The last two are simulation files to test the Regroup Module on a
UNIX workstation in user mode with processes simulating processor nodes
and UDP datagrams used to send unacknowledged datagrams.

This file was first submitted for release into NSK on 12/13/95.
------------------------------------------------------------------------------
This change occurred on 19 Jan 1996                                              /*F40:MB06458.1*/
Changes for phase IV Sierra message system release. Includes:                    /*F40:MB06458.2*/
 - Some cleanup of the code                                                      /*F40:MB06458.3*/
 - Increment KCCB counters to count the number of setup messages and             /*F40:MB06458.4*/
   unsequenced messages sent.                                                    /*F40:MB06458.5*/
 - Fixed some bugs                                                               /*F40:MB06458.6*/
 - Disable interrupts before allocating broadcast sibs.                          /*F40:MB06458.7*/
 - Change per-packet-timeout to 5ms                                              /*F40:MB06458.8*/
 - Make the regroup and powerfail broadcast use highest priority                 /*F40:MB06458.9*/
   tnet services queue.                                                          /*F40:MB06458.10*/
 - Call the millicode backdoor to get the processor status from SP               /*F40:MB06458.11*/
 - Fixed expand bug in msg_listen_ and msg_readctrl_                             /*F40:MB06458.12*/
 - Added enhancement to msngr_sendmsg_ so that clients do not need               /*F40:MB06458.13*/
   to be unstoppable before calling this routine.                                /*F40:MB06458.14*/
 - Added new steps in the build file called                                      /*F40:MB06458.15*/
   MSGSYS_C - compiles all the message system C files                            /*F40:MB06458.16*/
   MSDRIVER - compiles all the MSDriver files                                    /*F40:MB06458.17*/
   REGROUP  - compiles all the regroup files                                     /*F40:MB06458.18*/
 - remove #pragma env libspace because we set it as a command line               /*F40:MB06458.19*/
   parameter.                                                                    /*F40:MB06458.20*/
-----------------------------------------------------------------------          /*F40:MB06458.21*/

#endif    /* 0 - change descriptions */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\mm\wrgp.h ===
#ifndef  _WRGP_H_
#define  _WRGP_H_

#ifdef __TANDEM
#pragma columns 79
#pragma page "wrgp.h - T9050 - internal declarations for Regroup Module"
#endif

/* @@@ START COPYRIGHT @@@
**  Tandem Confidential:  Need to Know only
**  Copyright (c) 1995, Tandem Computers Incorporated
**  Protected as an unpublished work.
**  All Rights Reserved.
**
**  The computer program listings, specifications, and documentation
**  herein are the property of Tandem Computers Incorporated and shall
**  not be reproduced, copied, disclosed, or used in whole or in part
**  for any reason without the prior express written permission of
**  Tandem Computers Incorporated.
**
** @@@ END COPYRIGHT @@@
**/

/*---------------------------------------------------------------------------
 * This file (wrgp.h) contains the cluster_t data type and types used for the
 * node pruning algorithm and declares the routines exported by the Cluster
 * data type and the node pruning algorithm.
 *---------------------------------------------------------------------------*/

#ifdef __cplusplus
   extern "C" {
#endif /* __cplusplus */


#include <jrgp.h>
#include <wrgpos.h>
#include <bitset.h>

#define RGP_VERSION               1          /* version # of data structures */
#define RGP_INITSEQNUM            0          /* starting seq# # of regroup   */


#define RGPPKTLEN sizeof(rgp_pkt_t)          /* byte length of regroup pkts  */
#define IAMALIVEPKTLEN sizeof(iamalive_pkt_t)/* byte length of IamAlive pkts */
#define POISONPKTLEN sizeof(poison_pkt_t)    /* byte length of poison pkts   */


/*-------------------------------------------------------*/
/* The following are the stages of the regroup algorithm */
/*-------------------------------------------------------*/

#define   RGP_COLDLOADED               0
#define   RGP_ACTIVATED                1
#define   RGP_CLOSING                  2
#define   RGP_PRUNING                  3
#define   RGP_PHASE1_CLEANUP           4
#define   RGP_PHASE2_CLEANUP           5
#define   RGP_STABILIZED               6


/*--------------------------------------------------------------------*/
/* Macros to transform node numbers used by the OS to node numbers    */
/* used by the Regroup module and vice versa. Regroup's internal node */
/* numbers start at 0 while the OS starts node numbers at             */
/* LOWEST_NODENUM.                                                    */
/*--------------------------------------------------------------------*/
#define EXT_NODE(int_node) ((node_t)(int_node + LOWEST_NODENUM))
#define INT_NODE(ext_node) ((node_t)(ext_node - LOWEST_NODENUM))


/*----------------------------------------*/
/* Defines for the node pruning algorithm */
/*----------------------------------------*/

/* The data type "cluster_t" is a bit array of size equal to the maximum
 * number of nodes in the cluster. The bit array is implemented as an
 * array of uint8s.
 *
 * Given a node#, its bit position in the bit array is computed by first
 * locating the byte in the array (node# / BYTEL) and then the bit in
 * the byte. Bits in the byte are numbered 0..7 (from left to right).
 * Thus, node 0 is placed in byte 0, bit 0, which is the left-most bit
 * in the bit array.
 */
#define BYTE(cluster, node) ( (cluster)[(node) / BYTEL] ) /* byte# in array */
#define BIT(node)           ( (node) % BYTEL )            /* bit# in byte   */


/* The connectivity matrix is an array of elements of type cluster_t.
 * cluster_t is equivalent to a bit array with one bit per node. Thus the
 * matrix is equivalent to a two-dimensional bit array, with each
 * dimension being MAX_CLUSTER_SIZE large. A bit value of 1 for matrix[i][j]
 * represents a unidirectional connection between nodes i and j (a
 * regroup packet received on node i from node j).
 */

typedef cluster_t  connectivity_matrix_t[MAX_CLUSTER_SIZE];


#define connected(i,j) (ClusterMember(c[(int)i],j) && \
                        ClusterMember(c[(int)j],i))  /* bidirectional */

/* Should a node that cannot receive its own regroup packets be considered
 * dead? Not necessarily. It may be able to send packets to others and
 * be considered alive by everyone. There is no real need for the ability
 * to send to yourself on the network. Software bugs could result in
 * such a situation. Therefore, the correct way to check if a node is
 * alive would be to check if there is a non-zero bit in either the row
 * or column corresponding to the node; that is, if the node has
 * received regroup packets from or sent regroup packets to any node,
 * it may be considered alive. But for simplicity, we will assume in
 * the following macro that a node that does not receive its own
 * regroup packets will be considered dead.
 */

#define node_considered_alive(i)   ClusterMember(c[(int)i],i)

/* The upper bound on the number of potential fully-connected groups is
 * the lower of 2**N and 2**D where N is the number of live nodes and
 * D is the number of disconnects. If this number exceeds MAX_GROUPS,
 * do not attempt to exhaustively generate all possible groups;
 * just return an arbitrary fully-connected group which includes a
 * node selected by the cluster manager.
 */
#define MAX_GROUPS      256  /* if more than these, pick arbitrary group */
#define LOG2_MAX_GROUPS   8  /* log (base 2) of MAX_GROUPS               */

#define too_many_groups(nodes, disconnects) \
        ((nodes > LOG2_MAX_GROUPS) && (disconnects > LOG2_MAX_GROUPS))

/* The disconnect array is an array of (i,j) pairs which represent a
 * break in connectivity between nodes i and j.
 */

typedef node_t disconnect_array [LOG2_MAX_GROUPS * (LOG2_MAX_GROUPS-1)/2] [2];


/*---------------------------------------------------------------------------*/
/* Following are templates for three kinds of unacknowledged datagrams sent  */
/* by the regroup module (regroup pkts, IamAlive pkts and poison pkts).      */
/*---------------------------------------------------------------------------*/

//
// We already hand packed all on the wire structures.
// packon will instruct the compiler not to mess with field alignment (kind of)
//
#include <packon.h>

/************************************************************************
 * rgp_pkt_t (regroup status packet)
 * ---------------------------------
 * This structure is used to send the current state of the regroup state
 * machine to other nodes.
 *
 *      ___________________________________________________________
 * wd0 |  pktsubtype |  stage        |      reason   | Low8 ignscr |
 *     |_____________|_______________|_____________________________|
 * wd1 |                         seqno                             |
 *     |_____________________________|_____________________________|
 * wd2 |   activa-   | causingnode   |       quorumowner           |
 *     |   tingnode  |  Hi8  ignscr  |     (was hadpowerfail)      |
 *     |_____________|_______________|_____________________________|
 * wd3 |   knownstage1               |    knownstage2              |
 *     |_____________________________|_____________________________|
 * wd4 |   knownstage3               |    knownstage4              |
 *     |_____________________________|_____________________________|
 * wd5 |   knownstage5               |    pruning_result           |
 *     |_____________________________|_____________________________|
 * wd6 :                                                           :
 *     |               connectivity_matrix                         |
 *     :                                                           :
 * wd13|___________________________________________________________|
 *
 *
 * pktsubtype            - packet subtype = RGP_UNACK_REGROUP
 * stage                 - current stage (state) of the regroup algorithm
 * reason                - reason for the activation of regroup
 * seqno                 - sequence number of current regroup incident
 * activatingnode        - node that calls for a regroup incident
 * causingnode           - node whose poll packet was missed or which
 *                         had a power failure or otherwise caused
 *                         a regroup incident being called for
 * quorumowner           - mask of nodes that think they own the quorum resrc
 * knownstage1           - mask of nodes known to have entered stage 1
 * knownstage2           - mask of nodes known to have entered stage 2
 * knownstage3           - mask of nodes known to have entered stage 3
 * knownstage4           - mask of nodes known to have entered stage 4
 * knownstage5           - mask of nodes known to have entered stage 5
 * pruning_result        - result of node pruning by tie-breaker node
 * connectivity_matrix   - current connectivity info for entire cluster
 *
 */

#ifdef __TANDEM
#pragma fieldalign shared8 rgp_pkt
#endif /* __TANDEM */

typedef struct rgp_pkt
{
   uint8                   pktsubtype;
   uint8                   stage;
   uint16                  reason;
   uint32                  seqno;
   uint8                   activatingnode;
   uint8                   causingnode;
   cluster_t               quorumowner;
   cluster_t               knownstage1;
   cluster_t               knownstage2;
   cluster_t               knownstage3;
   cluster_t               knownstage4;
   cluster_t               knownstage5;
   cluster_t               pruning_result;
   connectivity_matrix_t   connectivity_matrix;
} rgp_pkt_t;

/************************************************************************
 * iamalive_pkt_t
 * --------------
 * This structure is used by a node to indicate to another node that it
 * is alive and well.
 *
 *      ___________________________________________________________
 * wd0 |  pktsubtype |     filler                                  |
 *     |_____________|_____________________________________________|
 * wd1 :                                                           :
 *     |                   testpattern                             |
 *     :                                                           :
 * wd13|___________________________________________________________|
 *
 *
 * pktsubtype            - packet subtype = RGP_UNACK_IAMALIVE
 * testpattern           - a bit pattern used for testing
 *
 */

#ifdef __TANDEM
#pragma fieldalign shared8 iamalive_pkt
#endif /* __TANDEM */

typedef struct iamalive_pkt
{
   uint8   pktsubtype;
   uint8   filler[3];
   union
   {
      uint8   bytes[RGP_UNACK_PKTLEN - 4];
      uint32  words[(RGP_UNACK_PKTLEN - 4)/4];
   } testpattern;
} iamalive_pkt_t;


/************************************************************************
 * poison_pkt_t
 * ------------
 * This structure is used to send a poison packet to another node to
 * force the other node to halt.
 *
 *      ___________________________________________________________
 * wd0 |  pktsubtype |  unused1      |      reason                 |
 *     |_____________|_______________|_____________________________|
 * wd1 |                         seqno                             |
 *     |_____________________________|_____________________________|
 * wd2 |   activa-   | causingnode   |                             |
 *     |   tingnode  |               |      unused2                |
 *     |_____________|_______________|_____________________________|
 * wd3 |   initnodes                 |      endnodes               |
 *     |_____________________________|_____________________________|
 *
 *
 * pktsubtype            - packet subtype = RGP_UNACK_POISON
 * reason                - reason for the last activation of regroup
 * seqno                 - current regroup sequence number
 *                         (sequence number of last regroup incident)
 * activatingnode        - node which called for last regroup incident
 * causingnode           - node whose poll packet was missed or which
 *                         had a power failure or otherwise caused
 *                         the last regroup incident being called for
 * initnodes             - mask of nodes at beginning of last regroup
 * endnodes              - mask of nodes at end of last regroup
 *
 */

#ifdef __TANDEM
#pragma fieldalign shared8 poison_pkt
#endif /* __TANDEM */

typedef struct poison_pkt
{
   uint8         pktsubtype;
   uint8         unused1;
   uint16        reason;
   uint32        seqno;
   uint8         activatingnode;
   uint8         causingnode;
   uint16        unused2;
   cluster_t     initnodes;
   cluster_t     endnodes;
} poison_pkt_t;

#include <packoff.h>

//
// There is no room for a 16 bit ignorescreen mask
// in rgp_pkt_t structure. We use a few bit from several
// fields to store the ignore screen.
// The following routines do packing and unpacking
// of ignorescreen from/into the packet
//

extern void PackIgnoreScreen(rgp_pkt_t* to, cluster_t from);
extern void UnpackIgnoreScreen(rgp_pkt_t* from, cluster_t to);
extern void SetMulticastReachable(uint32 mask);

/*---------------------------------------------------------------------------*/
/* This struct is keeps track of the state of each node in the cluster.      */
/*---------------------------------------------------------------------------*/
typedef struct
{
   uint16 status;        /* state of node - alive, dead etc.           */
   uint16 pollstate;     /* whether I'm alives have been received      */
   uint16 lostHBs;       /* tracks the number of consecutive I'm alives lost */
} node_state_t;

/* The status and pollstate fields of the node_state_t struct can have the
 * following values.
 */

/* Node status of nodes */

#define RGP_NODE_ALIVE            1          /* node is considered alive     */
#define RGP_NODE_COMING_UP        2          /* node is coming up            */
#define RGP_NODE_DEAD             3          /* node has failed              */
#define RGP_NODE_NOT_CONFIGURED   4          /* node is not even configured  */

/* IamAlive status codes of nodes */

#define AWAITING_IAMALIVE         1          /* awaiting IamAlives           */
#define IAMALIVE_RECEIVED         2          /* got IamAlive                 */

#define RGP_IAMALIVE_THRESHOLD  100          /* after getting this many Iam- *
                                              * Alives, we check if every    *
                                              * node has sent at least one   */


/************************************************************************
 * rgp_control_t (regroup's only global data structure)
 * ----------------------------------------------------
 * This structure holds all the Regroup state and other info.
 * This is the only global data structure used by Regroup.
 *
 * NOTE: The word offsets shown in this picture assume that
 *       MAX_CLUSTER_SIZE is 16.
 *
 *      ___________________________________________________________
 * wd0 |                                                           |
 *     :                    rgpinfo structure                      :
 *     :                                                           :
 *     |___________________________________________________________|
 * wd3 |   mynode                    |    tiebreaker               |
 *     |_____________________________|_____________________________|
 * wd4 |                    num_nodes                              |
 *     |___________________________________________________________|
 * wd5 |   clock_ticks               |    rgpcounter               |
 *     |_____________________________|_____________________________|
 * wd6 |   restartcount              |    pruning_ticks            |
 *     |_____________________________|_____________________________|
 * wd7 |   pfail_state               |    flags                    |
 *     |_____________________________|_____________________________|
 * wd8 |   outerscreen               |    innerscreen              |
 *     |_____________________________|_____________________________|
 * wd9 |   status_targets            |    poison_targets           |
 *     |_____________________________|_____________________________|
 * wd10|   initnodes                 |    endnodes                 |
 *     |_____________________________|_____________________________|
 * wd11|   unreachable_nodes         |    arbitration_ticks        |
 *     |_____________________________|_____________________________|
 * wd12|   ignorescreen              |    filler[0]                |
 *     |_____________________________|_____________________________|
 * wd13|   filler[1]                 |    filler[2]                |
 *     |_____________________________|_____________________________|
 * wd14|                                                           |
 *     :                    node_states[MAX_CLUSTER_SIZE]          :
 *     :                                                           :
 *     |___________________________________________________________|
 * wd30|                    *nodedown_callback()                   |
 *     |___________________________________________________________|
 * wd31|                    *select_cluster()                      |
 *     |___________________________________________________________|
 * wd32|                    *rgp_msgsys_p                          |
 *     |___________________________________________________________|
 * wd33|                    *received_pktaddr                      |
 *     |___________________________________________________________|
 * wd34|                                                           |
 *     :                    rgppkt                                 :
 *     :                                                           :
 *     |___________________________________________________________|
 * wd48|                                                           |
 *     :                    rgppkt_to_send                         :
 *     :                                                           :
 *     |___________________________________________________________|
 * wd62|                                                           |
 *     :                    iamalive_pkt                           :
 *     :                                                           :
 *     |___________________________________________________________|
 * wd76|                                                           |
 *     :                    poison_pkt                             :
 *     |___________________________________________________________|
 * wd80|                                                           |
 *     :                                                           :
 *     :                    potential_groups[MAX_GROUPS]           :
 *     :                                                           :
 *     |___________________________________________________________|
 *wd208|                                                           |
 *     :                    last_stable_seqno                      :
 *     |___________________________________________________________|
 *wd212|                                                           |
 *     :                    internal_connectivity_matrix           :
 *     |___________________________________________________________|
 *wdyyy|                                                           |
 *     :                    OS_specific_control                    :
 *wdxxx|___________________________________________________________|
 *
 *
 * rgpinfo    - contains regroup timing parameters and mask of
 *              fully-integrated cluster (to send IamAlives and monitor)
 *
 * mynode     - node number of local node
 *
 * tiebreaker - node selected to act as a tie-breaker in the
 *              split-brain avoidance algorithm and to run the
 *              pruning algorithm
 *
 * num_nodes  - number of nodes configured in the system, including
 *              any unused node numbers in the middle; this is equal
 *              to (the largest configured node# in the system -
 *              lowest possible node # + 1).
 *
 * clock_ticks- regroup's internal clock used for checking if it is
 *              time to send IamAlive packets and to check if IamAlives
 *              have been received. It is incremented every
 *              RGP_CLOCK_PERIOD and reset to 0 after checking
 *              for IamAlives.
 *
 * rgpcounter - counts regroup clock ticks in a regroup incident in
 *              order to detect if the algorithm is stalling.
 *              This is reset when a new regroup incident begins and
 *              is incremented at each regroup clock tick while
 *              regroup is perturbed.
 *
 * restartcount - counts # of regroup algorithm restarts in each regroup
 *                incident; the node is halted if there are too many
 *                restarts.
 *
 * pruning_ticks - number of regroup clock ticks after the tie-breaker
 *                 has been selected; if there are disconnects, the
 *                 tie-breaker should wait a fixed number of ticks
 *                 before running the pruning algorithm.
 *
 * pfail_state  - set to a +ve value when a pfail event is reported
 *                to regroup. It is decremented at every regroup
 *                clock tick till it reaches zero. While this number
 *                is +ve, missing self IamAlives are ignored and
 *                do not cause the node to halt. This gives the
 *                sending hardware some time to recover from power
 *                failures before self IamAlives are checked.
 *
 * outerscreen - outer recognition mask: nodes not in this mask are
 *               considered dead or outcasts; if they try to contact
 *               us, send them poison packets to make sure they stay down
 *
 * innerscreen - inner recognition mask: nodes not in this mask are
 *               considered tardy. Regroup packts from them will be
 *               ignored. They may survive if they can find some
 *               node which hasn't eliminated them from this screen.
 *
 * status_targets  - nodes to send regroup status packets to
 *
 * poison_targets  - nodes to send poison packets to
 *
 * initnodes   - nodes alive at the beginning of last regroup incident
 *
 * endnodes    - nodes alive at the end of last regroup incident
 *
 * unreachable_nodes - stores unreachable_node events till the events
 *                     can be processed
 *
 * arbitration_ticks     - number of regroup clock ticks after the arbitration
 *                         started. If arbitration_ticks counter exceeds
 *                         RGP_ARBITRATION_TIMEOUT number of ticks,
 *                         the arbitrating node will shoot itself, and the rest
 *                         of the group will restart the regroup ignoring stalled
 *                         arbitrator
 *
 * ignorescreen          - this is a local copy of ignorescreen passed as
 *                         a part of the regroup packet. The packets from
 *                         the nodes in this screen are ignored and no wait
 *                         for the nodes in ignorescreen is performed in stage 1
 *
 * last_stable_seqno      - this is a sequence number of the last successful regroup.
 *                         It allows to detect really outdated packets
 *
 * flags:
 *
 * cautiousmode          - need to be "cautious"; wait longer in stage 1
 *
 * sendstage             - This flag is used to indicate whether the
 *                         regroup status packets should indicate we
 *                         are in the current stage. When we enter the
 *                         cleanup stages, we don't let others know we
 *                         are in the stage until the cleanup actions
 *                         are completed.
 *
 *                         This flag is set when a new regroup incident
 *                         is started. It is then cleared when we enter
 *                         a cleanup stage and set again when the
 *                         cleanup operations are completed.
 *
 * tiebreaker_selected   - set in stage 2 after tie-breaker is selected
 *
 * has_unreachable_nodes - set when a node_unreachable event is detected
 *                         in stages 1 or 2. checked in stage 3.
 *
 * flags_unused          - 11 unused bits
 *
 * node_states[MAX_CLUSTER_SIZE] - state of all the nodes
 *
 * *nodedown_callback() - registered callback routine to be invoked
 *                        to report node failure
 *
 * *select_cluster()    - registered callback routine to be invoked
 *                        when multiple cluster options exist
 *
 * *rgp_msgsys_p - pointer to struct shared by regroup and message system
 *
 * *received_pktaddr - address of rgp packet received
 *
 * rgp_lock - lock to serialize access to this struct
 *
 * rgppkt       - regroup status in the form of a packet
 *
 * rgppkt_to_send - regroup packet to be broadcast
 *
 * iamalive_pkt - I am alive packet to be broadcast
 *
 * poison_pkt   - poison packet to be sent
 *
 * potential_groups[MAX_GROUPS] - scratch pad for pruning algorithm
 *
 */

#ifdef __TANDEM
#pragma fieldalign shared8 rgp_control
#endif /* __TANDEM */

typedef struct rgp_control
{
   /* timing parameters and cluster membership */
   rgpinfo_t rgpinfo;

   /* node numbers */
   node_t mynode;
   node_t tiebreaker;
   uint32 num_nodes;

   /* various counters counting clock ticks */
   uint16 clock_ticks;
   uint16 rgpcounter;
   uint16 restartcount;
   uint16 pruning_ticks;
   uint16 pfail_state;

   /* rgpflags */
   uint16 cautiousmode          :  1;
   uint16 sendstage             :  1;
   uint16 tiebreaker_selected   :  1;
   uint16 has_unreachable_nodes :  1;
   uint16 arbitration_started   :  1;
   uint16 flags_unused          : 11;

   /* cluster masks */
   cluster_t outerscreen;
   cluster_t innerscreen;
   cluster_t status_targets;
   cluster_t poison_targets;
   cluster_t initnodes;
   cluster_t endnodes;
   cluster_t unreachable_nodes;

   uint16    arbitration_ticks;
   cluster_t ignorescreen;

   uint16 filler[3]; /* for alignment and future use */

   /* node states */
   node_state_t node_states[MAX_CLUSTER_SIZE];

   /* callback routines */
   void (*nodedown_callback)(cluster_t failed_nodes);
   int  (*select_cluster)(cluster_t cluster_choices[], int num_clusters);

   /* pointers to other structures */
   rgp_msgsys_p rgp_msgsys_p;
   rgp_pkt_t *received_pktaddr;

   /* current status in the form of a regroup packet */
   rgp_pkt_t      rgppkt;

   /* packets to be sent */
   rgp_pkt_t      rgppkt_to_send;
   iamalive_pkt_t iamalive_pkt;
   poison_pkt_t   poison_pkt;

   /* scratch pad for node pruning algorithm */
   cluster_t potential_groups[MAX_GROUPS];

   /* The rest of the struct is an OS-specific substruct
    * (defined in wrgpos.h).
    */
   uint32 last_stable_seqno;

   /* temporary place to collect connectivity information
    * while send_stage = 0. (Can't use rgp_pkt conn.matrix,
    * because we don't want to see our info until we get
    * the first timer tick */

   connectivity_matrix_t internal_connectivity_matrix;
   OS_specific_rgp_control_t OS_specific_control;

} rgp_control_t;

/*---------------------------------------------------------------------------*/
/* Procedures exported by the Cluster type implementation */

_priv _resident extern void
ClusterInit(cluster_t c);
_priv _resident extern void
ClusterUnion(cluster_t dst, cluster_t src1, cluster_t src2);
_priv _resident extern void
ClusterIntersection(cluster_t dst, cluster_t src1, cluster_t src2);
_priv _resident extern void
ClusterDifference(cluster_t dst, cluster_t src1, cluster_t src2);
_priv _resident extern int
ClusterCompare(cluster_t c1, cluster_t c2);
_priv _resident extern int
ClusterSubsetOf(cluster_t big, cluster_t small);
_priv _resident extern void
ClusterComplement(cluster_t dst, cluster_t src);
_priv _resident extern int
ClusterMember(cluster_t c, node_t i);
_priv _resident extern void
ClusterInsert(cluster_t c, node_t i);
_priv _resident extern void
ClusterDelete(cluster_t c, node_t i);
_priv _resident extern void
ClusterCopy(cluster_t dst, cluster_t src);
_priv _resident extern void
ClusterSwap(cluster_t c1, cluster_t c2);
_priv _resident extern int
ClusterNumMembers(cluster_t c);
extern int 
ClusterEmpty(cluster_t c);


/*---------------------------------------------------------------------------*/
/* Function to select the tie-breaker node used in both the split-brain
 * avoidance and node pruning algorithms
 */
_priv _resident extern node_t
rgp_select_tiebreaker(cluster_t cluster);


/*---------------------------------------------------------------------------*/
/* Procedures exported by the node pruning algorithm */

_priv _resident extern void MatrixInit(connectivity_matrix_t c);
/* Initialize the matrix c to show 0 connectivity. */

_priv _resident extern void
MatrixSet(connectivity_matrix_t c, int row, int column);
/* Set c[row,column] to 1. */

_priv _resident extern void
MatrixOr(connectivity_matrix_t t, connectivity_matrix_t s);
/* OR in s into t. */

_priv _resident extern int connectivity_complete(connectivity_matrix_t c);
/* Returns 1 if all live nodes are connected to all other live nodes
 * and 0 if there is at least one disconnect.
 */

_priv _resident extern int
find_all_fully_connected_groups(connectivity_matrix_t c,
                                node_t selected_node,
                                cluster_t groups[]);
/* Analyzes the connectivity matrix and comes up with the list of
 * all maximal, fully-connected groups. Returns the number of
 * such groups found. 0 is returned iff there are no live nodes.
 */

/*---------------------------------------------------------------------------*/
/* Declaration of Regroup's global data structure */

#ifdef NSK
#include <wmsgsac.h>
#define rgp ((rgp_control_t *) MSGROOT->RegroupControlAddr)
#else
extern rgp_control_t *rgp;
#endif /* NSK */
/*---------------------------------------------------------------------------*/

#ifdef __cplusplus
}
#endif /* __cplusplus */


#if 0

History of changes to this file:
-------------------------------------------------------------------------
1995, December 13                                           F40:KSK0610          /*F40:KSK06102.1*/

This file is part of the portable Regroup Module used in the NonStop
Kernel (NSK) and Loosely Coupled UNIX (LCU) operating systems. There
are 10 files in the module - jrgp.h, jrgpos.h, wrgp.h, wrgpos.h,
srgpif.c, srgpos.c, srgpsm.c, srgputl.c, srgpcli.c and srgpsvr.c.
The last two are simulation files to test the Regroup Module on a
UNIX workstation in user mode with processes simulating processor nodes
and UDP datagrams used to send unacknowledged datagrams.

This file was first submitted for release into NSK on 12/13/95.
------------------------------------------------------------------------------

#endif    /* 0 - change descriptions */


#endif /* _WRGP_H_ defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\mm\mmapi.c ===
/* ---------------------- MMapi.c ----------------------- */

/* This module contains cluster Membership Manager (MM) functions.
 *
 * These functions are for the sole use of the ClusterManager (CM).
 * All are privileged and local; no user can call them. Security is
 * not checked.  The module is not thread-aware; only a single thread
 * can use these functions at a time. Higher levels must ensure this
 * before the calls.
 *
 *
 * All nodes of the cluster must know their own unique nodenumber
 * within that cluster (a small int in the range 1..some_max). This
 * number is defined for the node at configuration time (either by the
 * user or by the setup code; this module doesn't care which) and is
 * essentially permanent.  (The node number allows indexing and
 * bitmask operations easily, where names and non-small ints don't).
 * There is no code in MM to detect illegal use of nodenumber, staleness
 * of node number, etc.
 *
 * Clusters may also be named and/or numbered. Nodes are named. This
 * module makes no use of such facilities; it is based entirely on
 * node-number.
 *
 * It is assumed that all use of routines here is done on nodes which
 * agree to be members of the same cluster. This module does not check
 * such things.
 *
 * Cluster network connectivity must also be provided:
 *
 * - A node N must specify the various paths by which it can
 *   communicate with every other node; each other node must define
 *   its communication paths back to N. Full connectivity must be
 *   guaranteed; each node must be able to talk directly to every
 *   other node (and the reverse); for fault-tolerance, communication
 *   paths must not only be replicated (minimally, duplicated) but
 *   must also use entirely independent wiring and drivers. TCP/IP
 *   lans and async connections are suggested.  Heartbeat traffic
 *   (which establishes cluster membership) may travel on any or all
 *   of the connectivity paths.  [Cluster management traffic may
 *   travel on any or all of the connectivity paths, but may be
 *   restricted to high-performance paths (eg, tcp/ip)].
 *
 * - A node must know the address of the cluster as a whole. This is
 *   an IP address which failsover (or a netbios name which fails
 *   over.. TBD) such that connecting to that cluster address provides
 *   a way to talk to a valid active member of the cluster, here
 *   called the PCM.
 *
 * Note that cluster connectivity is not defined by this interface;
 * it is assumed to be in a separate module. This module deals only in
 * communication to the cluster or communication to a nodenumber
 * within that cluster; it does not care about the details of how such
 * communcation is done.
 *
 * Cluster connectivity must be known to all nodes in the cluster
 * and to a joining node, before the join attempt is made.
 *
 */
#ifdef __cplusplus
   extern "C" {
#endif /* __cplusplus */


#if defined (TDM_DEBUG)
#include <mmapi.h>
#else // WOLFPACK
#include <service.h>
#endif

//#include <windows.h>
#include <wrgp.h>

#include <clmsg.h>

// #define INCONSISTENT_REGROUP_MONITOR_FAILED 
// #define INCONSISTENT_REGROUP_ADD_FAILED 
// #define INCONSISTENT_REGROUP_IGNORE_JOINER 3

void
rgp_receive_events( rgp_msgbuf *rgpbuf );

void
MMiNodeDownCallback(IN cluster_t failed_nodes);


/************************************************************************
 *
 * MMInit
 * ======
 *
 * Description:
 *
 *     This initialises various local MM data structures. It should be
 *     called at CM startup time on every node. It sends no messages; the
 *     node need not have connectivity defined yet.
 *
 * Parameters:
 *
 *     mynode -
 *         is the node# of this node within the cluster.  This is
 *         assumed to be unique (but cannot be checked here to be so).
 *
 *     UpDownCallback -
 *         a function which will be called in this Up node
 *         whenever the MM declares another node Up or Down. The CM may then
 *         initiate failovers, device ownership changes, user node status
 *         events, etc. This routine must be quick and must not block
 *         (acceptible time TBD).  Note that this will happen on all nodes
 *         of the cluster; it is up to the CM design to decide whether to
 *         issue events from only the PCM or from each CM node.
 *
 *
 *     QuorumCallback -
 *         This is a callback to deal with the special case where only
 *         2 members of the cluster existed, and a Regroup incident occurred
 *         such that only one member now survives OR there is a partition
 *         and both members survive (but cannot know that). The intent of the
 *         Quorum function is to determine whether the other node is alive
 *         or not, using mechanisms other than the normal heartbeating over
 *         the normal comm links (eg, to do so by using non-heartbeat
 *         communication paths, such as SCSI reservations). This function is
 *         called only in the case of where cluster membership was previously
 *         exactly two nodes; and is called on any surviving node of these
 *         two (which might mean it is called on one node or on both
 *         partitioned nodes).
 *
 *         If this routine returns TRUE, then the calling node stays in the
 *         cluster. If the quorum algorithm determines that this node must
 *         die (because the other cluster member exists), then this function
 *         should return FALSE;this will initiate an orderly shutdown of the
 *         cluster services.
 *
 *         In the case of a true partition, exactly one node should
 *         return TRUE.
 *
 *         This routine may block and take a long time to execute (>2 secs).
 *
 *     HoldIOCallback -
 *         This routine is called early (prior to Stage 1) in a Regroup
 *         incident. It suspends all cluster IO (to all cluster-owned
 *         devices), and any relevant intra-cluster messages, until resumed
 *         (or until this node dies).
 *
 *     ResumeIOCallback -
 *         This is called during Regroup after the new cluster membership
 *         has been determined, when it is known that this node will remain
 *         a member of the cluster (early in Stage 4). All IO previously
 *         suspended by MMHoldAllIO should be resumed.
 *
 *     MsgCleanup1Callback -
 *         This is called as the first part of intra-cluster message system
 *         cleanup (in stage 4). It cancels all incoming messages from a
 *         failed node. In the case where multiple nodes are evicted from
 *         the cluster, this function is called repeatedly, once for each node.
 *
 *         This routine is synchronous and Regroup is suspended until it
 *         returns. It must execute quickly.
 *
 *     MsgCleanup2Callback -
 *         This is the second phase of message system cleanup (in stage 5). It
 *         cancels all outgoing messages to dead nodes. Characteristics are
 *         as for Cleanup1.
 *
 *     HaltCallback -
 *         This function is called whenever the MM detects that this node
 *         should immediately leave the cluster (eg, on receipt of a poison
 *         packet or at some impossible error situation). The HALT function
 *         should immediately initiate Cluster Management shutdown. No MM
 *         functions should be called after this, other than MMShutdown.
 *
 *         The parameter "haltcode" is a number identifying the halt reason.
 *
 *     JoinFailedCallback -
 *         This is called on a node being joined into the cluster when the
 *         join attempt in the PCM fails. Following this callback, the node
 *         may petition to join again, after cleaning up via a call to
 *         MMLeave.
 *
 *
 * Returns:
 *
 *     MM_OK        Success.
 *
 *     MM_FAULT     Something impossible happened.
 *
 ************************************************************************/


DWORD MMInit(
    IN DWORD             mynode,
    IN DWORD             MaxNodes,
    IN MMNodeChange      UpDownCallback,
    IN MMQuorumSelect    QuorumCallback,
    IN MMHoldAllIO       HoldIOCallback,
    IN MMResumeAllIO     ResumeIOCallback,
    IN MMMsgCleanup1     MsgCleanup1Callback,
    IN MMMsgCleanup2     MsgCleanup2Callback,
    IN MMHalt            HaltCallback,
    IN MMJoinFailed      JoinFailedCallback,
    IN MMNodesDown       NodesDownCallback
    )
{
#if !defined (TDM_DEBUG)
    DWORD            status;
    DWORD            dwValue;
#endif
    rgp_msgsys_t    *rgp_msgsys_ptr;
    rgp_control_t   *rgp_buffer_p;
    int              rgp_buffer_len;

    //
    // allocate/clear storage for the message system area
    //
    rgp_msgsys_ptr = ( rgp_msgsys_t *) calloc(1, sizeof(rgp_msgsys_t) );
    if ( rgp_msgsys_ptr == NULL ) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[MM] Unable to allocate msgsys_ptr.\n");
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    memset( rgp_msgsys_ptr, 0, sizeof(rgp_msgsys_t) );

    //
    // ask regroup how much memory it needs and then allocate/clear it.
    //
    rgp_buffer_len = rgp_estimate_memory();
    rgp_buffer_p = (rgp_control_t *) calloc( 1, rgp_buffer_len );
    if ( rgp_buffer_p == NULL ) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[MM] Unable to allocate buffer_p.\n");
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    memset(rgp_buffer_p, 0, rgp_buffer_len);

    //
    // let the regroup engine allocate and initialize its data structures.
    //
    rgp_init( (node_t)mynode,
              MaxNodes,
              (void *)rgp_buffer_p,
              rgp_buffer_len,
              rgp_msgsys_ptr );

#if !defined (TDM_DEBUG)
    //
    // Initialize message system
    //
    status = ClMsgInit(mynode);

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[MM] Unable to initialize comm interface, status %1!u!.\n",
            status
            );
        return(status);
    }
#endif // TDM_DEBUG


    if( ERROR_SUCCESS == DmQueryDword(
                 DmClusterParametersKey,
                 CLUSREG_NAME_QUORUM_ARBITRATION_TIMEOUT,
                 &dwValue, NULL) )
    {
        MmQuorumArbitrationTimeout = dwValue;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[MM] MmQuorumArbitrationTimeout %1!d!.\n", dwValue);
    }

    if( ERROR_SUCCESS == DmQueryDword(
                 DmClusterParametersKey,
                 CLUSREG_NAME_QUORUM_ARBITRATION_EQUALIZER,
                 &dwValue, NULL) )
    {
        MmQuorumArbitrationEqualizer = dwValue;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[MM] MmQuorumArbitrationEqualizer %1!d!.\n", dwValue);
    }

    //
    // Save the user's callback entrypoints
    //
    rgp->OS_specific_control.UpDownCallback = UpDownCallback;
    rgp->OS_specific_control.QuorumCallback = QuorumCallback;
    rgp->OS_specific_control.HoldIOCallback = HoldIOCallback;
    rgp->OS_specific_control.ResumeIOCallback = ResumeIOCallback;
    rgp->OS_specific_control.MsgCleanup1Callback = MsgCleanup1Callback;
    rgp->OS_specific_control.MsgCleanup2Callback = MsgCleanup2Callback;
    rgp->OS_specific_control.HaltCallback = HaltCallback;
    rgp->OS_specific_control.JoinFailedCallback = JoinFailedCallback;
    rgp->OS_specific_control.NodesDownCallback = NodesDownCallback;

    return MM_OK;
}

/************************************************************************
 * JoinNodeDelete
 * ==============
 *
 *
 * Internal MM procedure to assist in Join failure recovery.
 *
 *
 * Parameters:
 *
 *                              Node which failed to join.
 *
 * Returns:
 *                              none.
 *
 ************************************************************************/
void JoinNodeDelete ( joinNode)
{
    rgp_msgbuf  rgpbuf;
    node_t i;
    int status;
#if 1
    RGP_LOCK;
    rgp_event_handler( RGP_EVT_BANISH_NODE, (node_t) joinNode );
    RGP_UNLOCK;
#else
    // [HACKHACK] Remove this when you feel confident that
    // banishing is much better than the following code

    rgpbuf.event = RGP_EVT_REMOVE_NODE;
    rgpbuf.data.node = (node_t)joinNode;

    for ( i=0; i < (node_t) rgp->num_nodes; i++ )
    {
        if ( rgp->node_states[i].status == RGP_NODE_ALIVE)
        {
            if ( i == rgp->mynode )
                rgp_receive_events( &rgpbuf );    // take the quick route
            else
            {
                status = ClSend( EXT_NODE(i),
                                 (void *)&rgpbuf,
                                 sizeof(rgp_msgbuf),
                                 RGP_ACKMSG_TIMEOUT);

                if ( status ) RGP_TRACE( "ClSend failed to send Remove Node msg",
                                  rgp->rgppkt.stage,
                                  (uint32) EXT_NODE(i),
                                  (uint32) status,
                                  0 );
            }
        }
    }
#endif
}

/************************************************************************
 *
 * MMJoin
 * ======
 *
 * Description:
 *
 *     This causes the specified node to join the active cluster.
 *
 *     This routine should be issued by only one node of the cluster (the
 *     PCM); all join attempts must be single-threaded (by code outside
 *     this module).
 *
 *      [Prior to this being called:
 *         - joiningNode has communicated to the PCM of the cluster
 *           that it wants to join.
 *         - checks on validity of clustername, nodenumber, etc have been
 *           made; any security checks have been done;
 *         - connectivity paths have been established to/from the cluster
 *           and joiningNode.
 *         - the Registry etc has been downloaded.
 *      ]
 *
 * Parameters:
 *
 *     joiningNode
 *         is the node number of the node being brought into
 *         the cluster.
 *
 *         If joiningNode = self (as passed in via MMinit), then the node
 *         will become the first member of a new cluster; if not, the node
 *         will be brought into the existing cluster.
 *
 *     clockPeriod, sendRate, and rcvRate
 *         can only be set by the first call (ie
 *         when the cluster is formed); later calls (from joining members)
 *         inherit the original cluster values. The entire cluster therefore operates
 *         with the same values.
 *
 *     clockPeriod
 *         is the basic clock interval which drives all internal
 *         MM activities, such as the various stages
 *         of membership reconfiguration, and eventually user-perceived
 *         recovery time. Unit= ms. This must be between the min and max
 *         allowed (values TBD; current best setting = 300ms).  Note that
 *         clockperiod is path independent and node independent. All
 *         cluster members regroup at the same rate over any/all available
 *         paths; all periods are identical in all nodes.
 *         A value of 0 implies default setting (currently 300ms).
 *
 *     sendHBRate
 *         is the multiple of clockPeriod at which heartbeats are sent. This
 *         must be between the min and max allowed (values TBD; current best setting = 4).
 *         A value of 0 implies default setting (currently 4).
 *
 *     rcvHBRate
 *         is the multiple of sendRate during which a heartbeat must arrive, or the
 *         node initiates a Regroup (probably resulting in some node leaving the cluster).
 *         This must be between min and max; (values TBD; current best setting = 2).
 *         A value of 0 implies default setting (currently 2);
 *
 *     JoinTimeout
 *         is an overall timer in milliseconds on the entire Join attempt. If the
 *         node has not achieved full cluster membership in this time, the
 *         attempt is abandoned.
 *
 * Returns:
 *
 *     MM_OK        Success; cluster joined. The CM is then safe to
 *                  assign ownership to cluster-owned devices on this
 *                  node, and to start failover/failback processing.
 *
 *                  Note: this routine establishes cluster membership.
 *                  However, it is usually inadvisable to start high
 *                  level CM failbacks immediately, because other
 *                  cluster members are often still joining. The CM
 *                  should typically wait a while to see whether other
 *                  nodes arrive in the cluster soon.
 *
 *     MM_ALREADY   The node is already a cluster member. This can
 *                  happen if a node reboots (or a CM is restarted)
 *                  and rejoins even before the cluster determines
 *                  that it has disappeared.  The CM should Leave and
 *                  reJoin.
 *
 *     MM_FAULT     Permanent failure; something is very bad:  the
 *                  node# is duplicated; some parameter is some
 *                  entirely illegal value.  The CM is in deep weeds.
 *
 *     MM_TRANSIENT Transient failure. The cluster state changed
 *                  during the operation (eg a node left the cluster).
 *                  The operation should be retried.
 *
 *     MM_TIMEOUT   Timeout; cluster membership not achieved in time.
 *
 *
 *     more
 *      TBD
 *
 ************************************************************************/

DWORD MMJoin(
    IN DWORD  joiningNode,
    IN DWORD  clockPeriod,
    IN DWORD  sendHBRate,
    IN DWORD  rcvHBRate,
    IN DWORD  joinTimeout
           )
{
    node_t      my_reloadee_num = INT_NODE(joiningNode); // internal node #
    rgp_msgbuf  rgpbuf;                             // buffer to send messages
    node_t      i;
    rgpinfo_t   rgpinfo;
    int         status;
    BOOL        joinfailed = FALSE;
    uint32      myseqnum;

#if defined(TDM_DEBUG)
    int         randNode1,randNode2;
#endif
#if defined(INCONSISTENT_REGROUP_IGNORE_JOINER)
    extern int  IgnoreJoinerNodeUp;
#endif



    if ( my_reloadee_num >= (node_t) rgp->num_nodes )
            return MM_FAULT;

    //
    // If the caller is the joining node then we assume this is the
    // first member of the cluster.
    //
    if ( my_reloadee_num == rgp->mynode )
    {
        //
        // Set clockPeriod into the regroup information.
        //
        do {
            status = rgp_getrgpinfo( &rgpinfo );
        }
        while ( status == -1 /* regroup is perturbed */ );

        rgpinfo.a_tick = (uint16)clockPeriod;
        rgpinfo.iamalive_ticks = (uint16) sendHBRate;
        rgpinfo.check_ticks = (uint16) rcvHBRate;
        rgpinfo.Min_Stage1_ticks = (uint16) (sendHBRate * rcvHBRate);

        if ( rgp_setrgpinfo( &rgpinfo ) == -1 )
            RGP_ERROR( RGP_INTERNAL_ERROR );        // for now??

        //
        // Regroup can now start monitoring
        //
        rgp_start( MMiNodeDownCallback, RGP_NULL_PTR );
        MmSetRegroupAllowed(TRUE);

        return MM_OK;
    }

    //
    // Not the first system up.
    //
    if ( (rgp->node_states[my_reloadee_num].status == RGP_NODE_ALIVE) ||
         (rgp->node_states[my_reloadee_num].status == RGP_NODE_COMING_UP)
       )
       return MM_ALREADY;

    RGP_LOCK;
    myseqnum = rgp->rgppkt.seqno; // save rgp seq number to check for new rgp incident
    //
    // If regroup is perturbed wait until it stablizes.
    //

    while ( rgp_is_perturbed() )
    {
        RGP_UNLOCK;
        Sleep( 1 );             // wait a millisecond

        if ( --joinTimeout <= 0 )
            return MM_TIMEOUT;

        RGP_LOCK;
        myseqnum = rgp->rgppkt.seqno;
    }
    RGP_UNLOCK;


    //
    // First, we must tell all running nodes about the reloadee.
    //

    rgpbuf.event = RGP_EVT_ADD_NODE;
    rgpbuf.data.node = (node_t)joiningNode;

#if defined(TDM_DEBUG)
    randNode1 = rand() % MAX_CLUSTER_SIZE;
    randNode2 = rand() % MAX_CLUSTER_SIZE;
#endif

    for ( i=0; i < (node_t) rgp->num_nodes; i++ )
    {
#if defined(TDM_DEBUG)
        if (rgp->OS_specific_control.debug.MyTestPoints.TestPointBits.joinfailADD)
        {
            if ((node_t) randNode1 == i)
                rgp_event_handler(RGP_EVT_LATEPOLLPACKET, (node_t) randNode2);
        }
#endif
        if (myseqnum != rgp->rgppkt.seqno)
        {
                joinfailed = TRUE;
                break;
        }
        else if ( rgp->node_states[i].status == RGP_NODE_ALIVE )
        {
            if ( i == rgp->mynode )
               rgp_receive_events( &rgpbuf ); // take the quick route
            else
            {
#if defined(INCONSISTENT_REGROUP_ADD_FAILED)
                if (i != my_reloadee_num) {
                    joinfailed = TRUE;
                    break;
                }
#endif
                status = ClSend( EXT_NODE(i), (void *)&rgpbuf, sizeof(rgp_msgbuf), joinTimeout );
                if ( status )
                {
                    RGP_TRACE( "ClSend failed to send Add Node msg",
                               rgp->rgppkt.stage,
                               (uint32) EXT_NODE(i),
                               (uint32) status,
                               0 );
                    joinfailed = TRUE;
                    break;
                }
            }
        }
    }

    if (joinfailed)
    {
        JoinNodeDelete (joiningNode);
        return MM_TRANSIENT;
    }

    //
    // Next, we must tell the reloadee to come up.
    //

    rgpbuf.event = RGP_EVT_SETRGPINFO;
    do {
        status = rgp_getrgpinfo( &rgpbuf.data.rgpinfo );
    }
    while ( status == -1 /* regroup is perturbed */ );
    
#if defined(INCONSISTENT_REGROUP_IGNORE_JOINER)
    IgnoreJoinerNodeUp = INCONSISTENT_REGROUP_IGNORE_JOINER;
#endif
    
    status = ClSend( EXT_NODE(my_reloadee_num), (void *)&rgpbuf, sizeof(rgp_msgbuf), joinTimeout );
    if ( status )
    {
        RGP_TRACE( "ClSend failed to send Set Regroup Info msg",
                   rgp->rgppkt.stage,
                   (uint32) EXT_NODE(my_reloadee_num),
                   (uint32) status,
                   0 );
        JoinNodeDelete(joiningNode);
        return MM_FAULT;
    }
    // Wait until the reloadee has sent us the first IamAlive message
    // which changes the reloadee state to RGP_NODE_ALIVE.

    while (rgp->node_states[my_reloadee_num].status != RGP_NODE_ALIVE)
    {
        // The regroup messages will be handled by the message thread.  This
        // thread has nothing to do until the reloadee comes alive.

        Sleep( 1 );             // snooze for 1 millisecond

        // Check if timeout exceeded
        if ( --joinTimeout <= 0 )
        {
            // Reloadee hasn't started sending I'm alives.  Tell all the nodes
            // to remove it.
            JoinNodeDelete ( joiningNode);
            return MM_TIMEOUT;
        }

        if (myseqnum != rgp->rgppkt.seqno)
        {
            JoinNodeDelete ( joiningNode);
            return MM_TRANSIENT;
        }
    }

    //
    // Next, we must tell all running nodes that the reloadee is up.
    //

    rgpbuf.event = RGP_EVT_MONITOR_NODE;
    rgpbuf.data.node = (node_t)joiningNode;

    for ( i=0; i < (node_t) rgp->num_nodes; i++ )
    {
#if defined(TDM_DEBUG)
        if (rgp->OS_specific_control.debug.MyTestPoints.TestPointBits.joinfailMON)
        {
            if ((node_t) randNode1 == i)
                rgp_event_handler(RGP_EVT_LATEPOLLPACKET, (node_t) randNode2);
        }
#endif
        if (myseqnum != rgp->rgppkt.seqno)
        {
            joinfailed = TRUE;
            break;
        }
        else if ( rgp->node_states[i].status == RGP_NODE_ALIVE )
        {
            if ( i == rgp->mynode )
                rgp_receive_events( &rgpbuf );         // take the quick route
            else
            {
#if defined(INCONSISTENT_REGROUP_MONITOR_FAILED)
                if (i != my_reloadee_num) {
                    joinfailed = TRUE;
                    break;
                }
#endif

                status = ClSend( EXT_NODE(i), (void *)&rgpbuf, sizeof(rgp_msgbuf), joinTimeout );
                if ( status )
                {
                    RGP_TRACE( "ClSend failed to send Monitor Node msg",
                               rgp->rgppkt.stage,
                               (uint32) EXT_NODE(i),
                               (uint32) status,
                               0 );
                    joinfailed = TRUE;
                    break;
                }
            }
        }
    }

    if (joinfailed)
    {
        JoinNodeDelete (joiningNode);
        return MM_TRANSIENT;
    }

    //
    // Next, we must tell the reloadee that reload is complete.
    //

    rgpbuf.event = RGP_EVT_START;
    rgpbuf.data.node = (node_t)joiningNode;
    status = ClSend( EXT_NODE(my_reloadee_num), (void *)&rgpbuf, sizeof(rgp_msgbuf), joinTimeout );
    if ( status )
    {
        RGP_TRACE( "ClSend failed to send Start msg",
                   rgp->rgppkt.stage,
                   (uint32) EXT_NODE(my_reloadee_num),
                   (uint32) status,
                   0 );
        JoinNodeDelete(joiningNode);
        return MM_FAULT;
    }

    return MM_OK;
}

/************************************************************************
 *
 * MMLeave
 * =======
 *
 * Description:
 *     This function causes the current node to leave the active cluster (go to
 *     Down state). The node no longer sends Regroup or Heartbeats to other cluster members.
 *     A NodeDown event will not be generated in this node. A Regroup is triggered in the
 *     remaining nodes (if this node was a member of the cluster).
 *     A node-down callback will occur on all remaining cluster members.
 *
 *     This initiates a clean, voluntary, leave operation.  For safety, prior to this,
 *     the calling node's CM should arrange to lose ownership of all cluster-owned
 *     devices assigned to this node (and so cause failovers, etc).
 *
 *     This routine returns normally. The caller (the CM) should then shutdown
 *     the cluster. MMShutdown or MMHalt may occur after this call, or
 *     the node may be re-joined to the cluster. All apply-to-the-PCM-to-join
 *     attempts by a node must be preceded by a call to MMleave().
 *
 *     This routine may block.
 *

 *
 * Parameters:
 *              -
 *
 * Returns:
 *
 *    MM_OK        :  Elvis has left the cluster (but has been reportedly
 *                                        sighted on numerous occasions).
 *
 *    MM_NOTMEMBER :  the node is not currently a cluster member.
 *
 ************************************************************************/


DWORD  MMLeave( void )
{
    if (!rgp) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[MM] MMLeave is called when rgp=NULL.\n");
        return MM_FAULT;
    }
    
    if (! ClusterMember (rgp->OS_specific_control.CPUUPMASK, rgp->mynode) )
        return MM_NOTMEMBER;

    RGP_LOCK; // to ensure that we don't send in response to incoming pkt
    rgp_event_handler (MM_EVT_LEAVE, EXT_NODE(rgp->mynode));
    rgp_cleanup();
    rgp_cleanup_OS();
    RGP_UNLOCK;

    return MM_OK;
}


DWORD  MMForceRegroup( IN DWORD NodeId )
{
    if (! ClusterMember (rgp->OS_specific_control.CPUUPMASK, (node_t)NodeId) )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                "[MM] MMForceRegroup: NodeId %1!u! is not a clustermember\r\n",
                NodeId);
        return MM_NOTMEMBER;
        }
    rgp_event_handler(RGP_EVT_LATEPOLLPACKET, (node_t)NodeId);


    return MM_OK;
}

/************************************************************************
 *
 * MMNodeUnreachable
 * =================
 *
 * Description:
 *
 *     This should be called by the CM's messaging module when a node
 *     becomes unreachable from this node via all paths. It allows quicker
 *     detection of failures, but is otherwise equivalent to discovering
 *     that the node has disappeared as a result of lost heartbeats.
 *
 * Parameters:
 *
 *     node -
 *         specifies the node that is unreachable.
 *
 * Returns:
 *
 *   Always MM_OK
 *
 ************************************************************************/

DWORD MMNodeUnreachable( DWORD node )
{
    rgp_event_handler( RGP_EVT_NODE_UNREACHABLE, (node_t) node );

    return MM_OK;
}

/************************************************************************
 *
 * MMPowerOn
 * =========
 *
 * Description:
 *
 *     This routine is used on systems which support power-fail
 *     ride-throughs. When power is restored, this function should be
 *     called by the CM (on each node).
 *
 *     Power-on normally occurs on multiple nodes at about the same time.
 *     This routine temporarily changes the cluster integrity handling so
 *     that the cluster can better survive transient loss of heartbeats
 *     which accompany power-fail; in normal cases, the cluster will
 *     survive power-fails without cluster members being
 *     evicted because of lack of timely response.
 *
 * Parameters:
 *
 *     None.
 *
 * Returns:
 *
 *     Always MM_OK
 *
 ************************************************************************/

DWORD MMPowerOn( void )
{
   rgp_event_handler( RGP_EVT_POWERFAIL, EXT_NODE(rgp->mynode) );

   return MM_OK;
}

/************************************************************************
 *
 * MMClusterInfo
 * =============
 *
 * Description:
 *
 *     Returns the current cluster information.
 *
 *     This can be called in nodes which are not members of the cluster;
 *     such calls always return NumActiveNodes = 0, because Down nodes
 *     have no knowledge of current cluster membership.
 *
 * Parameters:
 *
 *     clinfo
 *         pointer to CLUSTERINFO structure that receives the cluster
 *         information.
 *
 * Returns:
 *
 *     Always MM_OK
 *
 ************************************************************************/

DWORD
MMClusterInfo(
    OUT  LPCLUSTERINFO clinfo
    )
{
    node_t i,j;
    cluster_t MyCluster;

    RGP_LOCK;
    clinfo->clockPeriod = rgp->rgpinfo.a_tick;
    clinfo->sendHBRate = rgp->rgpinfo.iamalive_ticks;
    clinfo->rcvHBRate = rgp->rgpinfo.check_ticks;

    ClusterCopy(MyCluster,rgp->OS_specific_control.CPUUPMASK);
    RGP_UNLOCK;

    for ( i=0,j=0; i < MAX_CLUSTER_SIZE; i++ )
    {
        if ( ClusterMember (MyCluster, i) )
        {
            if (clinfo->UpNodeList != RGP_NULL_PTR)
                clinfo->UpNodeList[j] = (DWORD)i;
            j++;
        }
    }
    clinfo->NumActiveNodes = j;

    return MM_OK;
}

/************************************************************************
 *
 * MMShutdown
 * ==========
 *
 * Description:
 *     This shuts down the MM and Regroup services. Prior to this, the node should
 *     voluntarily have left the cluster. Following this, all membership services
 *     are non-functional; no further MM call may occur.
 *
 *     THIS CALL MUST BE PRECEDED BY INCOMING MESSAGE CALLBACK SHUTDOWN.
 *
 * Parameters:
 *     None.
 *
 * Returns:
 *     None.
 *
 ************************************************************************/
void MMShutdown (void)
{
    rgp_cleanup();
    rgp_cleanup_OS();

    // terminate timer thread
    rgp->rgpinfo.a_tick = 0; // special value indicates exit request
    SetEvent( rgp->OS_specific_control.TimerSignal); // wake up Timer Thread

    // wait for timer thread to exit; clean up associated handles for good measure
    WaitForSingleObject( rgp->OS_specific_control.TimerThread, INFINITE );
    rgp->OS_specific_control.TimerThread = 0;

    if ( rgp->OS_specific_control.RGPTimer ) {
        CloseHandle ( rgp->OS_specific_control.RGPTimer );
        rgp->OS_specific_control.RGPTimer = 0;
    }

    if (rgp->OS_specific_control.TimerSignal) {
        CloseHandle ( rgp->OS_specific_control.TimerSignal );
        rgp->OS_specific_control.TimerSignal = 0;
    }

#if !defined (TDM_DEBUG)
    //
    // Uninitialize message system
    //
    ClMsgCleanup();

#endif // TDM_DEBUG

    // delete regroup's critical section object
    DeleteCriticalSection( &rgp->OS_specific_control.RgpCriticalSection );

    // delete calloc'd space
    free (rgp->rgp_msgsys_p);
    free (rgp);
    rgp = NULL;
}


/************************************************************************
 *
 * MMEject
 * =======
 *
 * Description:
 *
 *     This function causes the specified node to be ejected from the
 *     active cluster. The targetted node will be sent a poison packet and
 *     will enter its MMHalt code. A Regroup incident will be initiated. A
 *     node-down callback will occur on all remaining cluster members.
 *
 *     Note that the targetted node is Downed before that node has
 *     a chance to call any remove-ownership or voluntary failover code. As
 *     such, this is very dangerous. This call is provided only as a last
 *     resort in removing an insane node from the cluster; normal removal
 *     of a node from the cluster should occur by CM-CM communication,
 *     followed by the node itself doing a voluntary Leave on itself.
 *
 *     This routine returns when the node has been told to die. Completion
 *     of the removal occurs asynchronously, and a NodeDown event will be
 *     generated when successful.
 *
 *     This routine may block.
 *
 * Parameters:
 *
 *     Node Number.
 *
 * Returns:
 *
 *     MM_OK        :  The node has been told to leave the cluster.
 *
 *     MM_NOTMEMBER :  the node is not currently a cluster member.
 *
 *     MM_TRANSIENT :  My node state is in transition. OK to retry.
 *
 ************************************************************************/
DWORD MMEject( IN DWORD node )
{
    int i;
    RGP_LOCK;

    if (! ClusterMember (
              rgp->OS_specific_control.CPUUPMASK,
              (node_t) INT_NODE(node))
       )
    {
        RGP_UNLOCK;

        ClRtlLogPrint(LOG_UNUSUAL, 
            "[MM] MmEject failed. %1!u! is not a member of %2!04X!.\n",
            node, rgp->OS_specific_control.CPUUPMASK
            );

        return MM_NOTMEMBER;
    }

    if ( !ClusterMember (
             rgp->outerscreen,
             INT_NODE(node) )
       || ClusterMember(rgp->OS_specific_control.Banished, INT_NODE(node) )
       )
    {
        int perturbed = rgp_is_perturbed();

        RGP_UNLOCK;

        if (perturbed) {
           ClRtlLogPrint(LOG_UNUSUAL, 
               "[MM] MMEject: %1!u!, banishing is already in progress.\n",
               node
               );
        } else {
           ClRtlLogPrint(LOG_UNUSUAL, 
               "[MM] MmEject: %1!u! is already banished.\n",
               node
               );
        }

        return MM_OK;
    }

    //
    // Adding a node to a rgp->OS_specific_control.Banished mask
    // will cause us to send a poison packet as a reply to any
    // regroup packet coming from Banishee
    //
    ClusterInsert(rgp->OS_specific_control.Banished, (node_t)INT_NODE(node));

    if ( !ClusterMember(rgp->ignorescreen, (node_t)INT_NODE(node)) ) {
        //
        // It doesn't matter in what stage of the regroup
        // we are. If the node needs to be banished we have to
        // initiate a new regroup
        //
        rgp_event_handler( RGP_EVT_BANISH_NODE, (node_t) node );
        RGP_UNLOCK;
    } else {
        RGP_UNLOCK;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[MM] MmEject: %1!u! is already being ignored.\n",
            node
            );
    }


    RGP_TRACE( "RGP Poison sent ", node, 0, 0, 0 );
    fflush( stdout );
    //
    // Send 3 poison packets with half a second interval in between.
    // We hope that at least one of the will get through
    //
    ClusnetSendPoisonPacket( NmClusnetHandle, node );
    Sleep(500);
    ClusnetSendPoisonPacket( NmClusnetHandle, node );
    Sleep(500);
    ClusnetSendPoisonPacket( NmClusnetHandle, node );

    return MM_OK;
}

/************************************************************************
 * MMIsNodeUp
 * ==========
 *
 *
 * Returns true iff the node is a member of the current cluster.
 *
 * *** debugging and test only.
 *
 * Parameters:
 *     Node Number of interest.
 *
 * Returns:
 *     TRUE if Node is member of cluster else FALSE.
 *
 ************************************************************************/

BOOL MMIsNodeUp(IN DWORD node)
{
    return (ClusterMember(
                rgp->OS_specific_control.CPUUPMASK,
                (node_t) INT_NODE(node)
                )
           );
}

/************************************************************************
 *
 * MMDiag
 * ======
 *
 * Description:
 *
 *     Handles "diagnostic" messages.  Some of these messages will
 *     have responses that are returned.  This function is typically
 *     called by the Cluster Manager with connection oriented
 *     messages from CLI.
 *
 *
 * Parameters:
 *
 *     messageBuffer
 *             (IN) pointer to a buffer that contains the diagnostic message.
 *             (OUT) response to the diagnostic message
 *
 *     maximumLength
 *             maximum number of bytes to return in messageBuffer
 *
 *     ActualLength
 *             (IN) length of diagnostic message
 *             (OUT) length of response
 *
 * Returns:
 *
 *     Always MM_OK
 *
 ************************************************************************/

DWORD
MMDiag(
    IN OUT  LPCSTR  messageBuffer,  // Diagnostic message
    IN      DWORD   maximumLength,  // maximum size of buffer to return
    IN OUT  LPDWORD ActualLength    // length of messageBuffer going in and coming out
    )
{
    // ??? need to return info in the future

    rgp_receive_events( (rgp_msgbuf *)messageBuffer );

    return MM_OK;
}

/************************************************************************
 *
 * rgp_receive_events
 * ==================
 *
 * Description:
 *
 *     This routine is called from MMDiag and from the Cluster Manager
 *     message thread (via our callback) to handle regroup messages
 *     and diagnostic messages.
 *
 * Parameters:
 *
 *     rgpbuf
 *         the message that needs to be handled.
 *
 * Returns:
 *
 *   none
 *
 ************************************************************************/

void
rgp_receive_events(
    IN rgp_msgbuf *rgpbuf
    )
{
    int           event;
    rgpinfo_t     rgpinfo;
    poison_pkt_t  poison_pkt;  /* poison packet sent from stack */
    DWORD         status;

#if defined(TDM_DEBUG)
    extern  BOOL  GUIfirstTime;
    extern  HANDLE gGUIEvent;
#endif

    event = rgpbuf->event;

#if defined(TDM_DEBUG)
    if ( (rgp->OS_specific_control.debug.frozen) && (event != RGP_EVT_THAW) )
       return;  /* don't do anything if the node is frozen */
#endif

    if ( event == RGP_EVT_RECEIVED_PACKET )
    {
        //
        // Go handle the regroup packet.
        //
        rgp_received_packet(rgpbuf->data.node,
                            (void *) &(rgpbuf->unseq_pkt),
                            sizeof(rgpbuf->unseq_pkt) );
    }

    else if (event < RGP_EVT_FIRST_DEBUG_EVENT)
    {
        //
        // "regular" regroup message
        //
        rgp_event_handler(event, rgpbuf->data.node);
    }

    else
    {
        //
        // Debugging message
        //
        RGP_TRACE( "RGP Debug event ", event, rgpbuf->data.node, 0, 0 );

        switch (event)
        {
        case RGP_EVT_START          :
        {
           rgp_start( MMiNodeDownCallback, RGP_NULL_PTR );
           break;
        }
        case RGP_EVT_ADD_NODE       :
        {
           rgp_add_node( rgpbuf->data.node );
           break;
        }
        case RGP_EVT_MONITOR_NODE   :
        {
           rgp_monitor_node( rgpbuf->data.node );
           break;
        }
        case RGP_EVT_REMOVE_NODE    :
        {
           rgp_remove_node( rgpbuf->data.node );
           break;
        }
        case RGP_EVT_GETRGPINFO     :
        {
           rgp_getrgpinfo( &rgpinfo );
           RGP_TRACE( "RGP GetRGPInfo  ",
                      rgpinfo.version,                 /* TRACE */
                      rgpinfo.seqnum,                  /* TRACE */
                      rgpinfo.iamalive_ticks,          /* TRACE */
                      GetCluster( rgpinfo.cluster ) ); /* TRACE */
           break;
        }
        case RGP_EVT_SETRGPINFO     :
        {
           rgp_setrgpinfo( &(rgpbuf->data.rgpinfo) );

           /* This event is traced in rgp_setrgpinfo(). */

           break;
        }
        case RGP_EVT_HALT :
        {
           exit( 1 );
           break;
        }

#if defined(TDM_DEBUG)

        case RGP_EVT_FREEZE :
        {
           rgp->OS_specific_control.debug.frozen = 1;
           break;
        }
        case RGP_EVT_THAW :
        {
           rgp->OS_specific_control.debug.frozen = 0;
                        break;
        }
        case RGP_EVT_STOP_SENDING :
        {
            ClusterInsert( rgp->OS_specific_control.debug.stop_sending,
                       INT_NODE(rgpbuf->data.node) );
            /* Generate a node unreachable event to indicate that
             * we cannot send to this node.
             */
            rgp_event_handler( RGP_EVT_NODE_UNREACHABLE, rgpbuf->data.node );
            break;
        }
        case RGP_EVT_RESUME_SENDING :
        {
            ClusterDelete(rgp->OS_specific_control.debug.stop_sending,
                     INT_NODE(rgpbuf->data.node));
            break;
        }
        case RGP_EVT_STOP_RECEIVING :
        {
            ClusterInsert(rgp->OS_specific_control.debug.stop_receiving,
                          INT_NODE(rgpbuf->data.node));
            break;
        }
        case RGP_EVT_RESUME_RECEIVING :
        {
            ClusterDelete(rgp->OS_specific_control.debug.stop_receiving,
                          INT_NODE(rgpbuf->data.node));
            break;
        }
        case RGP_EVT_SEND_POISON :
        {
            poison_pkt.pktsubtype = RGP_UNACK_POISON;
            poison_pkt.seqno = rgp->rgppkt.seqno;
            poison_pkt.reason = rgp->rgppkt.reason;
            poison_pkt.activatingnode = rgp->rgppkt.activatingnode;
            poison_pkt.causingnode = rgp->rgppkt.causingnode;
            ClusterCopy(poison_pkt.initnodes, rgp->initnodes);
            ClusterCopy(poison_pkt.endnodes, rgp->endnodes);
            rgp_send( rgpbuf->data.node, (char *)&poison_pkt, POISONPKTLEN );
            break;
        }
        case RGP_EVT_STOP_TIMER_POPS :
        {
            rgp->OS_specific_control.debug.timer_frozen = 1;
            break;
        }
        case RGP_EVT_RESUME_TIMER_POPS :
        {
            rgp->OS_specific_control.debug.timer_frozen = 0;
            break;
        }
        case RGP_EVT_RELOAD :
        {

            if (rgp->OS_specific_control.debug.reload_in_progress)
            {
                RGP_TRACE( "RGP Rld in prog ", 0, 0, 0, 0 );
                return;
            }

            rgp->OS_specific_control.debug.reload_in_progress = 1;

            if (rgpbuf->data.node == RGP_NULL_NODE)
            {
                RGP_TRACE( "RGP Invalid join parms ", -1, 0, 0, 0 );
                return;
                // Not supported since this server doesn't know which ones
                // are currently running.
                /* Reload all down nodes */
                //for (i = 0; i < rgp->num_nodes; i++)
                    //MMJoin( EXT_NODE(i), 0 /*use default*/, -1 /*???*/ );
            }
            else
            {
               /* Reload the specified node */
               status = MMJoin( rgpbuf->data.node /* joiningNode */,
                                0 /* use default clockPeriod */,
                                0 /* use default sendHBRate */,
                                0 /* use default rcvHBRate */,
                                500 /*millisecond timeout*/ );
               if ( status != MM_OK )
               {
                   RGP_TRACE( "RGP Join Failed ",
                              rgpbuf->data.node,
                              status, 0, 0 );
                   Sleep( 1000 );        // stablize regroup for reload * case - testing purposes
               }
           }

           rgp->OS_specific_control.debug.reload_in_progress = 0;

           break;
        }
        case RGP_EVT_TRACING :
        {
            rgp->OS_specific_control.debug.doing_tracing =
                ( rgpbuf->data.node ? 1 : 0 );

            if (!rgp->OS_specific_control.debug.doing_tracing)
            {
                GUIfirstTime = TRUE;
                SetEvent( gGUIEvent );
            }
            break;
        }
#endif // TDM_DEFINED

        case RGP_EVT_INFO:
           // nop for now
           break;
        case MM_EVT_LEAVE:
            status = MMLeave(); // (self) leave cluster
            break;
        case MM_EVT_EJECT:
            status = MMEject (rgpbuf->data.node); // eject other node
            break;

#if defined(TDM_DEBUG)
        case MM_EVT_INSERT_TESTPOINTS:
            rgp->OS_specific_control.debug.MyTestPoints.TestPointWord =
                            rgpbuf->data.node;
            break;
#endif

        default :
        {
           RGP_TRACE( "RGP Unknown evt ", event, 0, 0, 0 );
           break;
        }
        } /* end switch */
    }
}

/************************************************************************
 *
 * rgp_send
 * ========
 *
 * Description:
 *
 *     This routine is called to send an unacknowledged message to
 *     the specified node.
 *
 * Parameters:
 *
 *     node
 *             node number to send the message to.
 *
 *     data
 *             pointer to the data to send
 *
 *     datasize
 *             number of bytes to send
 *
 * Returns:
 *
 *   none.
 *
 ************************************************************************/

void
rgp_send(
    IN node_t node,
    IN void *data,
    IN int datasize
    )
{
    rgp_msgbuf   rgpbuf;
    DWORD        status;

    if (rgp->node_states[rgp->mynode].status != RGP_NODE_ALIVE)
        return;  // suppress sending if we're not alive

#if defined(TDM_DEBUG)
    if ( ClusterMember( rgp->OS_specific_control.debug.stop_sending,
                        INT_NODE(node) ) )
        return;  /* don't send to this node */
#endif

    rgpbuf.event = RGP_EVT_RECEIVED_PACKET;
    rgpbuf.data.node = EXT_NODE(rgp->mynode);
    memmove( &(rgpbuf.unseq_pkt), data, datasize);

    switch (rgpbuf.unseq_pkt.pktsubtype) {
    case RGP_UNACK_REGROUP  :

        status = ClMsgSendUnack( node, (void *)&rgpbuf, sizeof(rgp_msgbuf) );

        if ( status && (status != WSAENOTSOCK) )
            {
                RGP_TRACE( "ClMsgSendUnack failed",
                           rgp->rgppkt.stage,
                           (uint32) node,
                           (uint32) status,
                           0 );

                fflush(stdout);
            }
        break;

    case RGP_UNACK_IAMALIVE :
        break;

    case RGP_UNACK_POISON   :
        RGP_TRACE( "RGP Poison sent ", node, 0, 0, 0 );
        fflush( stdout );
        ClusnetSendPoisonPacket( NmClusnetHandle, node );
        break;

    default                 :
        break;
    }
}

/************************************************************************
 *
 * SetMulticastReachable
 * ===============
 *
 * Description:
 *
 *              This routine is called by the message.c to update
 *              the info of which nodes are reachable thru multicast.
 *
 * Parameters:
 *
 *              none
 *
 * Returns:
 *
 *              none
 *
 ************************************************************************/
void SetMulticastReachable(uint32 mask)
{
    *(PUSHORT)rgp->OS_specific_control.MulticastReachable = (USHORT)mask;
}


/************************************************************************
 *
 * rgp_msgsys_work
 * ===============
 *
 * Description:
 *
 *              This routine is called by the regroup engine to broadcast
 *              messages.
 *
 * Parameters:
 *
 *              none
 *
 * Returns:
 *
 *              none
 *
 ************************************************************************/

void
rgp_msgsys_work( )
{
    node_t i;

    do  /* do while more regroup work to do */
    {
        if (rgp->rgp_msgsys_p->sendrgppkts)
        { /* broadcast regroup packets */
            rgp->rgp_msgsys_p->sendrgppkts = 0;
            if ( ClusterNumMembers(rgp->OS_specific_control.MulticastReachable) >= 1) 
            {
                cluster_t tmp;
                ClusterCopy(tmp, rgp->rgp_msgsys_p->regroup_nodes);
                ClusterDifference(rgp->rgp_msgsys_p->regroup_nodes, 
                               rgp->rgp_msgsys_p->regroup_nodes, 
                               rgp->OS_specific_control.MulticastReachable);

                RGP_TRACE( "RGP Multicast",
                    GetCluster(rgp->OS_specific_control.MulticastReachable),
                    GetCluster(tmp),
                    GetCluster(rgp->rgp_msgsys_p->regroup_nodes),
                    0);
                rgp_send( 0,
                          rgp->rgp_msgsys_p->regroup_data,
                          rgp->rgp_msgsys_p->regroup_datalen
                          );
            }    
            for (i = 0; i < (node_t) rgp->num_nodes; i++)
                if (ClusterMember(rgp->rgp_msgsys_p->regroup_nodes, i))
                {
                    ClusterDelete(rgp->rgp_msgsys_p->regroup_nodes, i);
                    RGP_TRACE( "RGP Unicast", EXT_NODE(i), 0,0,0);
                    rgp_send( EXT_NODE(i),
                              rgp->rgp_msgsys_p->regroup_data,
                              rgp->rgp_msgsys_p->regroup_datalen
                              );
                }
        } /* broadcast regroup packets */

        if (rgp->rgp_msgsys_p->sendiamalives)
        { /* broadcast iamalive packets */
            rgp->rgp_msgsys_p->sendiamalives = 0;
            for (i = 0; i < (node_t) rgp->num_nodes; i++)
                if (ClusterMember(rgp->rgp_msgsys_p->iamalive_nodes, i))
                {
                    ClusterDelete(rgp->rgp_msgsys_p->iamalive_nodes, i);
                    rgp_send( EXT_NODE(i),
                              rgp->rgp_msgsys_p->iamalive_data,
                              rgp->rgp_msgsys_p->iamalive_datalen
                              );
                }
        } /* broadcast iamalive packets */

        if (rgp->rgp_msgsys_p->sendpoisons)
        { /* send poison packets */
            rgp->rgp_msgsys_p->sendpoisons = 0;
            for (i = 0; i < (node_t) rgp->num_nodes; i++)
                if (ClusterMember(rgp->rgp_msgsys_p->poison_nodes, i))
                {
                    ClusterDelete(rgp->rgp_msgsys_p->poison_nodes, i);
                    rgp_send( EXT_NODE(i),
                              rgp->rgp_msgsys_p->poison_data,
                              rgp->rgp_msgsys_p->poison_datalen
                              );
                }
        } /* send poison packets */

    } while ((rgp->rgp_msgsys_p->sendrgppkts) ||
             (rgp->rgp_msgsys_p->sendiamalives) ||
             (rgp->rgp_msgsys_p->sendpoisons)
            );

}


DWORD
MMMapStatusToDosError(
    IN DWORD MMStatus
    )
{
    DWORD dosStatus;


    switch(MMStatus) {
    case MM_OK:
        dosStatus = ERROR_SUCCESS;
        break;

    case MM_TIMEOUT:
        dosStatus = ERROR_TIMEOUT;
        break;

    case MM_TRANSIENT:
        dosStatus = ERROR_RETRY;
        break;

    case MM_FAULT:
        dosStatus = ERROR_INVALID_PARAMETER;
        break;

    case MM_ALREADY:
        dosStatus = ERROR_SUCCESS;
        break;

    case MM_NOTMEMBER:
        dosStatus = ERROR_CLUSTER_NODE_NOT_MEMBER;
        break;
    }

    return(dosStatus);

}  // MMMapStatusToDosError

DWORD
MMMapHaltCodeToDosError(
    IN DWORD HaltCode
    )
{
    DWORD dosStatus;

    switch(HaltCode) {
    case RGP_SHUTDOWN_DURING_RGP:
    case RGP_RELOADFAILED:
        dosStatus = ERROR_CLUSTER_MEMBERSHIP_INVALID_STATE;
        break;
    default:        
        dosStatus = ERROR_CLUSTER_MEMBERSHIP_HALT;
    }

    return(dosStatus);

}  // MMMapHaltCodeToDosError

/* ----------------------------  */

DWORD MmSetRegroupAllowed( IN BOOL allowed )
 /* This function can be used to allow/disallow regroup participation
  * for the current node.
  *
  * Originally regroup was allowed immediately after receiving RGP_START
  * event. Since this happens before join is complete 
  * joiner can arbitrate and win, leaving
  * the other side without a quorum device.
  *
  * It is required to add MmSetRegroupAllowed(TRUE) at the very end
  * of the ClusterJoin. The node doesn't need to call MmSetRegroupAllowed(TRUE)
  * for ClusterForm, since MMJoin will call
  * MmSetRegroupAllowed(TRUE) for the cluster forming node
  *
  * MmSetRegroupAllowed(FALSE) can be used to disable regroup
  * participation during shutdown.
  *
  *
  * Errors:
  *
  *   MM_OK        : successful completition
  *
  *   MM_TRANSIENT : disallowing regroup when regroup is in progress
  *
  *   MM_ALREADY   : node is already in the desired condition
  *
  *
  */
{
   DWORD status;

   if (rgp) {

       RGP_LOCK;

       if (allowed) {
          if (rgp->rgppkt.stage == RGP_COLDLOADED) {
             rgp->rgppkt.stage = RGP_STABILIZED;
             status = MM_OK;
          } else {
             status = MM_ALREADY;
          }
       } else {
          if (rgp->rgppkt.stage == RGP_STABILIZED) {
             rgp->rgppkt.stage = RGP_COLDLOADED;
             status = MM_OK;
          } else if (rgp->rgppkt.stage == RGP_COLDLOADED) {
             status = MM_ALREADY;
          } else {
             //
             // Regroup is already in progress. Kill this node.
             //
             RGP_ERROR(RGP_SHUTDOWN_DURING_RGP);
          }
       }

       RGP_UNLOCK;

   } else if (allowed) {
      ClRtlLogPrint(LOG_UNUSUAL, 
          "[MM] SetRegroupAllowed(%1!u!) is called when rgp=NULL.\n",
          allowed
          );
      status = MM_FAULT;
   } else {
     // if rgp is null and the caller wants to disable regroup.
     status = MM_ALREADY;
   }

   return status;
}

DWORD MMSetQuorumOwner(
    IN DWORD NodeId,
    IN BOOL Block,
    OUT PDWORD pdwSelQuoOwnerId
    
    )
/*++

Routine Description:

    Inform Membership engine about changes in ownership of
    the quorum resource.

Arguments:

    NodeId - Node number to be set as a quorum owner.
             Code assumes that Node is either equal to MyNodeId.
             In this case the current node is about to become a
             quorum owner or it has a value MM_INVALID_NODE, when
             the owner decides to relinquish the quorum ownership

    Block -  if the quorum owner needs to relinquish the 
             quorum immediately no matter what (RmTerminate, RmFail),
             this parameter should be set to FALSE and to TRUE otherwise.

    pdwSelQuoOwnerId - if this was invoked while a regroup was in progress
            then this contains the id of the node that was chosen to 
            arbitrate for the quorum in that last regroup else it contains
            MM_INVALID_NODE.                

Return Value:

    ERROR_SUCCESS - QuorumOwner variable is set to specified value
    ERROR_RETRY - Regroup was in progress when this function
      was called and regroup engine decision conflicts with current assignment.

Comments:

 This function needs to be called before calls to
 RmArbitrate, RmOnline, RmOffline, RmTerminate, RmFailResource

 Depending on the result, the caller should either proceed with 
 Arbitrate/Online or Offline or return an error if MM_TRANSIENT is returned.

 If Block is set to TRUE, the call will block until the end of the regroup if
 the regroup was in progress on the moment of the call
 */
{
    DWORD MyNode;

    if (pdwSelQuoOwnerId)
    {
        *pdwSelQuoOwnerId = MM_INVALID_NODE;
    }        
    
    ClRtlLogPrint(LOG_NOISE, 
        "[MM] MmSetQuorumOwner(%1!u!,%2!u!), old owner %3!u!.\n", NodeId, Block, QuorumOwner
        );
    if (!rgp) {
        // we are called on the form path before MM was initialized
        QuorumOwner = NodeId;
        return ERROR_SUCCESS;
    }
    MyNode = (DWORD)EXT_NODE(rgp->mynode);
    RGP_LOCK
    if ( !rgp_is_perturbed() ) {
        QuorumOwner = NodeId;
        RGP_UNLOCK;
	    return ERROR_SUCCESS;
    }
    //
    // we have a regroup in progress
    if (!Block) {
        // caller doesn't want to wait //
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[MM] MmSetQuorumOwner: regroup is in progress, forcing the new value in.\n"
            );
        QuorumOwner = NodeId;
        RGP_UNLOCK;
        return ERROR_RETRY;
    }
    do {
        if(rgp->OS_specific_control.ArbitrationInProgress && NodeId == MyNode ) {
            // This is when MmSetQuorumOwner is called from within the regroup Arbitrate //
            QuorumOwner = MyNode;
            RGP_UNLOCK;
	        return ERROR_SUCCESS;
         }
         RGP_UNLOCK
         ClRtlLogPrint(LOG_UNUSUAL, 
             "[MM] MmSetQuorumOwner: regroup is in progress, wait until it ends\n"
                 );
         WaitForSingleObject(rgp->OS_specific_control.Stabilized, INFINITE);
         RGP_LOCK
    } while ( rgp_is_perturbed() );

    // Now we are in the stablilized state with RGP_LOCK held//
    // And we were blocked while regroup was in progress //
    // somebody else might become an owner of the quorum //
    // ArbitratingNode variable contains this information //
    // or it has MM_INVALID_NODE if there was no arbitration during the regroup //
    if (pdwSelQuoOwnerId)
    {
        *pdwSelQuoOwnerId = rgp->OS_specific_control.ArbitratingNode;
    }
    if (rgp->OS_specific_control.ArbitratingNode == MM_INVALID_NODE) {
        // No arbitration was done during  the last regroup
        QuorumOwner = NodeId;
        RGP_UNLOCK;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[MM] MmSetQuorumOwner: no arbitration was done\n"
                );
        return ERROR_SUCCESS;
    }

    // Somebody arbitrated for the quorum
    if (rgp->OS_specific_control.ArbitratingNode == MyNode 
     && NodeId == MM_INVALID_NODE) {
        // We were asked to bring the quorum offline, 
        // but during the the regroup, we were arbitrating and won the quorum.
        // Let's fail offline request
        RGP_UNLOCK;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[MM] MmSetQuorumOwner: offline request denied\n"
                );
	    return ERROR_RETRY;
    } else if (rgp->OS_specific_control.ArbitratingNode != MyNode
            && NodeId == MyNode ) {
        // We were going take bring the quorum online, but
        // during the regroup somebody else got the disk
        // Online. Let's fail online call in this case
        RGP_UNLOCK;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[MM] MmSetQuorumOwner: online request denied, %1!u! has the quorum.\n", 
            rgp->OS_specific_control.ArbitratingNode
            );
	    return ERROR_RETRY;

    }
    QuorumOwner = NodeId;
    RGP_UNLOCK;
    ClRtlLogPrint(LOG_UNUSUAL, 
        "[MM] MmSetQuorumOwner: new quorum owner is %1!u!.\n", 
        NodeId
        );
    return ERROR_SUCCESS;
}

DWORD MMGetArbitrationWinner(
    OUT PDWORD NodeId
    )
/*++

Routine Description:

    Returns the node that won the arbitration during the last regroup
    or MM_INVALID_NODE if there was no arbitration performed.
    
Arguments:

    NodeId - a pointer to a variable that receives nodeid of 
             arbitration winner.
             
Return Value:

    ERROR_SUCCESS - success
    ERROR_RETRY - Regroup was in progress when this function
      was called. 
      
 */
{
    DWORD status;
    CL_ASSERT(NodeId != 0);
    RGP_LOCK
    
    *NodeId = rgp->OS_specific_control.ArbitratingNode;
    status = rgp_is_perturbed() ? ERROR_RETRY : ERROR_SUCCESS;

    RGP_UNLOCK;
    return status;
}

VOID MMBlockIfRegroupIsInProgress(
    VOID
    )
/*++

Routine Description:

    The call will block if the regroup is in progress.
  */
{
    RGP_LOCK;
    while ( rgp_is_perturbed() ) {
         RGP_UNLOCK
         ClRtlLogPrint(LOG_UNUSUAL, 
             "[MM] MMBlockIfRegroupIsInProgress: regroup is in progress, wait until it ends\n"
                 );
         WaitForSingleObject(rgp->OS_specific_control.Stabilized, INFINITE);
         RGP_LOCK;
    }
    RGP_UNLOCK;
}

VOID MMApproxArbitrationWinner(
    OUT PDWORD NodeId
    )
/*++

Routine Description:

    Returns the node that won the arbitration during the last regroup
    that was doing arbitration.

    The call will block if the regroup is in progress.
    
Arguments:

    NodeId - a pointer to a variable that receives nodeid of 
             arbitration winner.
             
Return Value:

    none
 */
{
    if (!rgp) {
        // we are called on the form path before MM was initialized
        *NodeId = MM_INVALID_NODE;
        return;
    }
    RGP_LOCK;
    while ( rgp_is_perturbed() ) {
         RGP_UNLOCK
         ClRtlLogPrint(LOG_UNUSUAL, 
             "[MM] MMApproxArbitrationWinner: regroup is in progress, wait until it ends\n"
                 );
         WaitForSingleObject(rgp->OS_specific_control.Stabilized, INFINITE);
         RGP_LOCK;
    }

    // Now we are in the stablilized state with RGP_LOCK held//
    
    *NodeId = rgp->OS_specific_control.ApproxArbitrationWinner;
    RGP_UNLOCK;
}
#ifdef __cplusplus
}
#endif /* __cplusplus */

/* -------------------------- end ------------------------------- */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\mm\wrgpos.h ===
#ifndef  _WRGPOS_H_
#define  _WRGPOS_H_

#ifdef __TANDEM
#pragma columns 79
#pragma page "wrgpos.h - T9050 - OS-dependent external decs for Regroup Module"
#endif

/* @@@ START COPYRIGHT @@@
**  Tandem Confidential:  Need to Know only
**  Copyright (c) 1995, Tandem Computers Incorporated
**  Protected as an unpublished work.
**  All Rights Reserved.
**
**  The computer program listings, specifications, and documentation
**  herein are the property of Tandem Computers Incorporated and shall
**  not be reproduced, copied, disclosed, or used in whole or in part
**  for any reason without the prior express written permission of
**  Tandem Computers Incorporated.
**
** @@@ END COPYRIGHT @@@
**/

/*---------------------------------------------------------------------------
 * This file (wrgpos.h) contains OS-specific declarations used by
 * srgpos.c.
 *---------------------------------------------------------------------------*/

#ifdef __cplusplus
   extern "C" {
#endif /* __cplusplus */


/*-----------------------------------NSK section-----------------------------*/
#ifdef NSK

#include <dmilli.h>
#include <jmsgtrc.h>
#define QUEUESEND        _send_queued_()

/* Regroup tracing macro */
/* In NSK, regroup uses the trace buffer and macro provided by the
 * message system. Regroup puts TR_NODATA for the trace type.
 */
#define RGP_TRACE( str,            parm1, parm2, parm3, parm4 ) \
        TRACE_L1 ( str, TR_NODATA, parm1, parm2, parm3, parm4 )

/* Regroup counters */
/* In NSK, regroup uses the counter buffer and macro provided by the
 * message system.
 */
#define RGP_INCREMENT_COUNTER    TCount

/* Macros to lock and unlock the regroup data structure to prevent
 * access by interrupt handlers or other processors (in SMP nodes).
 */

/* On NSK with uniprocessor nodes, these macros must mask off the
 * interrupt handlers that can access the regroup structure, namely,
 * the IPC and timer interrupts.
 *
 * To avoid complexities due to nesting of MUTEXes, the regroup locks
 * are defined to be no-ops. The NSK caller of all regroup routines
 * (except the inquiry routines rgp_estimate_memory, rgp_sequence_number
 * and rgp_is_perturbed) must ensure that IPC and timer interrupts are
 * disabled before calling the regroup routine.
 */
#define RGP_LOCK      /* null; NSK must ensure that timer and IPC interrupts
                         are disabled before calling regroup routines. */
#define RGP_UNLOCK    /* null; NSK must ensure that timer and IPC interrupts
                         are disabled before calling regroup routines. */

#ifdef __TANDEM
#pragma fieldalign shared8 OS_specific_rgp_control
#endif /* __TANDEM */

typedef struct OS_specific_rgp_control
{
   uint32 filler; /* no special fields needed for NSK */
} OS_specific_rgp_control_t;

#endif /* NSK */
/*-----------------------------end of NSK section----------------------------*/


/*-----------------------------------LCU section-----------------------------*/
#ifdef LCU

#include <lcuxprt.h>
#define LCU_RGP_PORT     0           /* pick up from appropriate file */
#define HZ             100           /* pick up from appropriate file */
#define plstr            0           /* pick up from appropriate file */
#define TO_PERIODIC      0           /* pick up from appropriate file */
#define CE_PANIC         3           /* pick up from appropriate file */

#define LCU_RGP_FLAGS    (LCUF_SENDMSG || LCUF_NOSLEEP) /* msg alloc flags */

extern void rgp_msgsys_work(lcumsg_t *lcumsgp, int status);
#define QUEUESEND        rgp_msgsys_work(NULL, 0)

/* Regroup tracing macro */
#define RGP_TRACE( str, parm1, parm2, parm3, parm4 ) /* empty for now */

/* Regroup counters */
typedef struct
{
   uint32   QueuedIAmAlive;
   uint32   RcvdLocalIAmAlive;
   uint32   RcvdRemoteIAmAlive;
   uint32   RcvdRegroup;
} rgp_counter_t;
#define RGP_INCREMENT_COUNTER( field ) rgp->OS_specific_control.counter.field++

/* Regroup locks */

typedef struct rgp_lock
{
   uint32 var1;
   uint32 var2;
} rgp_lock_t;

/* Macros to lock and unlock the regroup data structure to prevent
 * access by interrupt handlers or other processors (in SMP nodes)
 */

#define RGP_LOCK      /* null for now; need to be filled in */
#define RGP_UNLOCK    /* null for now; need to be filled in */

typedef struct
{
   rgp_lock_t rgp_lock;         /* to serialize access               */

   rgp_counter_t counter;       /* to count events                   */

   lcumsg_t *lcumsg_regroup_p;  /* pointer to regroup status message */
   lcumsg_t *lcumsg_iamalive_p; /* pointer to iamalive message       */
   lcumsg_t *lcumsg_poison_p;   /* pointer to poison message         */

   sysnum_t my_sysnum;          /* local system number               */
} OS_specific_rgp_control_t;

#endif /* LCU */
/*-----------------------------end of LCU section----------------------------*/


/*----------------------------------UNIX section-----------------------------*/
#ifdef UNIX

extern void rgp_msgsys_work(void);
#define QUEUESEND  rgp_msgsys_work();

#include <jrgp.h>
#include <wrgp.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <errno.h>
#include <stdio.h>

extern int errno;

#define MSG_FLAGS      0     /* flags for message send/receive */
#define RGP_PORT_BASE  5757  /* for use with sockets */

typedef struct
{
   int event;
   union
   {
      node_t node;
      rgpinfo_t rgpinfo;
   } data;                /* depends on the event */
   rgp_unseq_pkt_t unseq_pkt;
} rgp_msgbuf;

#define BUFLEN sizeof(rgp_msgbuf)

/* Additional events created for testing regroup using process-level
 * simulation.
 */
#define RGP_EVT_START                   10
#define RGP_EVT_ADD_NODE                11
#define RGP_EVT_MONITOR_NODE            12
#define RGP_EVT_REMOVE_NODE             13
#define RGP_EVT_GETRGPINFO              14
#define RGP_EVT_SETRGPINFO              15

#define RGP_EVT_HALT                    16
#define RGP_EVT_FREEZE                  17
#define RGP_EVT_THAW                    18
#define RGP_EVT_STOP_SENDING            19
#define RGP_EVT_RESUME_SENDING          20
#define RGP_EVT_STOP_RECEIVING          21
#define RGP_EVT_RESUME_RECEIVING        22
#define RGP_EVT_SEND_POISON             23
#define RGP_EVT_STOP_TIMER_POPS         24
#define RGP_EVT_RESUME_TIMER_POPS       25
#define RGP_EVT_RELOAD                  26

#define RGP_EVT_FIRST_EVENT              1
#define RGP_EVT_FIRST_DEBUG_EVENT       10
#define RGP_EVT_LAST_EVENT              26

/* Regroup tracing macro */
#define RGP_TRACE( str, parm1, parm2, parm3, parm4 )                  \
   do                                                                 \
   {                                                                  \
      printf("Node %3d: %16s: 0x%8X, 0x%8X, 0x%8X, 0x%8X.\n",         \
             EXT_NODE(rgp->mynode), str, parm1, parm2, parm3, parm4); \
      fflush(stdout);                                                 \
   } while (0)

/* Regroup counters */
typedef struct
{
   uint32   QueuedIAmAlive;
   uint32   RcvdLocalIAmAlive;
   uint32   RcvdRemoteIAmAlive;
   uint32   RcvdRegroup;
} rgp_counter_t;
#define RGP_INCREMENT_COUNTER( field ) rgp->OS_specific_control.counter.field++

/* Macros to lock and unlock the regroup data structure to prevent
 * access by interrupt handlers or other processors (in SMP nodes)
 */
#define RGP_LOCK      /* null; all access done from one thread */
#define RGP_UNLOCK    /* null; all access done from one thread */

/* This struct keeps some debugging info. */
typedef struct rgpdebug
{
   uint32 frozen              :  1; /* node is frozen; ignore all events except
                                       the thaw command */
   uint32 reload_in_progress  :  1; /* reload in progess; if set, refuse
                                       new reload command */
   uint32 unused              : 30;
   cluster_t stop_sending;   /* stop sending to these nodes */
   cluster_t stop_receiving; /* stop receiving from these nodes */
} rgp_debug_t;

typedef struct
{
   rgp_counter_t    counter;     /* to count events                    */
   rgp_debug_t      debug;       /* for debugging purposes             */
} OS_specific_rgp_control_t;

/* Variables and routines provided by the srgpsvr.c driver program */

extern unsigned int alarm_period;

extern void alarm_handler(void);
extern void (*alarm_callback)();
extern void rgp_send(node_t node, void *data, int datasize);
extern void rgp_msgsys_work();

#endif /* UNIX */
/*----------------------------end of UNIX section----------------------------*/

/*----------------------------------NT section-----------------------------*/
#ifdef NT

extern void rgp_msgsys_work(void);
#define QUEUESEND  rgp_msgsys_work();

#if !defined (TDM_DEBUG)
#define LOG_CURRENT_MODULE LOG_MODULE_MM
#include <service.h>
#include <winsock2.h>
#else //TDM_DEBUG
#define _WIN32_WINNT 0x0400
#include <mmapi.h>
#include <time.h>
extern int errno;
#endif

#include <jrgp.h>
#include <wrgp.h>
#include <stdlib.h>
#include <sys/types.h>
#include <errno.h>
#include <stdio.h>
#include <windows.h>
#include <clmsg.h>

#undef small	// otherwise we have to change a bunch of our code


typedef struct
{
   int event;
   union
   {
      node_t node;
      rgpinfo_t rgpinfo;
   } data;                /* depends on the event */
   rgp_unseq_pkt_t unseq_pkt;
} rgp_msgbuf;

#define BUFLEN sizeof(rgp_msgbuf)

/* Additional events created for testing regroup using process-level
 * simulation.
 */
#define RGP_EVT_START                   10
#define RGP_EVT_ADD_NODE                11
#define RGP_EVT_MONITOR_NODE            12
#define RGP_EVT_REMOVE_NODE             13
#define RGP_EVT_GETRGPINFO              14
#define RGP_EVT_SETRGPINFO              15

#define RGP_EVT_HALT                    16
#define RGP_EVT_FREEZE                  17
#define RGP_EVT_THAW                    18
#define RGP_EVT_STOP_SENDING            19
#define RGP_EVT_RESUME_SENDING          20
#define RGP_EVT_STOP_RECEIVING          21
#define RGP_EVT_RESUME_RECEIVING        22
#define RGP_EVT_SEND_POISON             23
#define RGP_EVT_STOP_TIMER_POPS         24
#define RGP_EVT_RESUME_TIMER_POPS       25
#define RGP_EVT_RELOAD                  26
#define RGP_EVT_TRACING					27
#define RGP_EVT_INFO					28

// MM events

#define MM_EVT_EJECT					29
#define MM_EVT_LEAVE					30
#define MM_EVT_INSERT_TESTPOINTS		31

#define RGP_EVT_FIRST_EVENT              1
#define RGP_EVT_FIRST_DEBUG_EVENT       10
#define RGP_EVT_LAST_EVENT              31


/* internal timeout for acknowledged messages */
#define RGP_ACKMSG_TIMEOUT			  500    // 0.5 seconds


/* Regroup tracing macro */
#if defined (TDM_DEBUG)
#define RGP_TRACE( str, parm1, parm2, parm3, parm4 )                  \
 if ( rgp->OS_specific_control.debug.doing_tracing )				  \
   do                                                                 \
   {                                                                  \
      printf("Node %3d: %16hs: 0x%8X, 0x%8X, 0x%8X, 0x%8X.\n",         \
             EXT_NODE(rgp->mynode), str, parm1, parm2, parm3, parm4); \
      fflush(stdout);                                                 \
   } while (0)
#else  // WOLFPACK
#define RGP_TRACE( str, parm1, parm2, parm3, parm4 )                    \
    ClRtlLogPrint(LOG_NOISE,                                               \
               "[RGP] Node %1!d!: %2!16hs!: 0x%3!x!, 0x%4!x!, 0x%5!x!, 0x%6!x!.\n",  \
               EXT_NODE(rgp->mynode), str, parm1, parm2, parm3, parm4)
#endif

/* Regroup counters */
typedef struct
{
   uint32   QueuedIAmAlive;
   uint32   RcvdLocalIAmAlive;
   uint32   RcvdRemoteIAmAlive;
   uint32   RcvdRegroup;
} rgp_counter_t;
#define RGP_INCREMENT_COUNTER( field ) rgp->OS_specific_control.counter.field++

/* Macros to lock and unlock the regroup data structure to prevent
 * access from other concurrent threads.
 */
#define RGP_LOCK	EnterCriticalSection( &rgp->OS_specific_control.RgpCriticalSection );
#define RGP_UNLOCK	LeaveCriticalSection( &rgp->OS_specific_control.RgpCriticalSection );

#if defined(TDM_DEBUG)
typedef union {
		struct {
			uint32	joinfailADD		:	1;
			uint32	joinfailMON		:	1;
			uint32	description3	:	1;
			uint32	description4	:	1;
			uint32	description5	:	1;
			uint32	description6	:	1;
			uint32	description7	:	1;
			uint32	description8	:	1;
			uint32	description9	:	1;
			uint32	description10	:	1;
			uint32	description11	:	1;
			uint32	description12	:	1;
			uint32	description13	:	1;
			uint32	description14	:	1;
			uint32	description15	:	1;
			uint32	description16	:	1;
			uint32	morebits	:	16;	
		} TestPointBits;
		uint32	TestPointWord;
}TestPointInfo;

/* This struct keeps some debugging info. */
typedef struct rgpdebug
{
   uint32 frozen              :  1; /* node is frozen; ignore all events except
                                       the thaw command */
   uint32 reload_in_progress  :  1; /* reload in progess; if set, refuse
                                       new reload command */
   uint32 timer_frozen		  :  1; /* timer pops are ignored */
   uint32 doing_tracing		  :  1; /* whether or not RGP_TRACE is a nop */
   uint32 unused              : 28;
   cluster_t stop_sending;   /* stop sending to these nodes */
   cluster_t stop_receiving; /* stop receiving from these nodes */
   TestPointInfo MyTestPoints; /* Controls test points for error/other insertion */
} rgp_debug_t;

#endif // TDM_DEBUG

typedef struct
{
   rgp_counter_t    counter;     /* to count events                    */
   HANDLE			TimerThread; /* HANDLE of HeartBeat timer thread */
   DWORD			TimerThreadId;/* Thread ID of HeartBeat timer thread */
   HANDLE			TimerSignal; /* Event used to change HB rate and cause Terminate */
   HANDLE			RGPTimer; /* Regroup Timer - Used by timer thread */
   CRITICAL_SECTION	RgpCriticalSection; /* CriticalSection object for regroup activities */
   ULONG            EventEpoch; /* used to detect stale events from clusnet */
   MMNodeChange		UpDownCallback; /*Callback to announce node up and node down event*/
   MMQuorumSelect   QuorumCallback; /*Callback to check if Quorum disk accessible - split brain avoidance */
   MMHoldAllIO		HoldIOCallback; /*Callback to suspend all IO and message activity during early regroup */
   MMResumeAllIO	ResumeIOCallback; /*Callback to resume all IO and message activity after PRUNING stage */
   MMMsgCleanup1	MsgCleanup1Callback; /*Callback for Phase1 Message system cleanup from down node */
   MMMsgCleanup2	MsgCleanup2Callback; /*Callback for Phase2 Message system cleanup to down node */
   MMHalt			HaltCallback; /*Callback to announce internal error or Poison packet or cluster ejection */
   MMJoinFailed		JoinFailedCallback; /*Callback to announce failure to join cluster. Retry required */
   MMNodesDown      NodesDownCallback; /* Callback to announce failure of one or more nodes.*/
   cluster_t		CPUUPMASK;   /* Bitmask of UP Nodes for consistent Info api */
   cluster_t		NeedsNodeDownCallback;	/* node(s) went down, need to do UpDown callback */
   cluster_t        Banished; /* mask of banished nodes */

   HANDLE           Stabilized; /* event which is set when the regroup is not active */
   BOOL             ArbitrationInProgress; /* it is set to True while regroup waits for arbitate callback to return */
   DWORD            ArbitratingNode; /* MM_INVALID_NODE or the arbitrating node (last regroup)*/
   DWORD            ApproxArbitrationWinner; /* Like ArbitratingNode, but spans multiple regroups */
   BOOL             ShuttingDown; /* indicate that a node is shutting done */
   cluster_t          MulticastReachable; /* indicate which nodes can be reachable via mcast */

#if defined( TDM_DEBUG )
   rgp_debug_t      debug;       /* for debugging purposes             */
#endif

} OS_specific_rgp_control_t;

extern DWORD  QuorumOwner;  /* updated by SetQuorumOwner and successful arbitrator*/
  /* this variable can be set by the first node coming up before Mm is initialized */

/* Variables and routines provided by the srgpsvr.c driver program */

extern unsigned int alarm_period;

//extern void alarm_handler(void);
//extern void (*alarm_callback)();
extern void rgp_send(node_t node, void *data, int datasize);
extern void rgp_msgsys_work();

#endif /* NT */
/*----------------------------end of NT section----------------------------*/

#ifdef __cplusplus
}
#endif /* __cplusplus */


#if 0

History of changes to this file:
-------------------------------------------------------------------------
1995, December 13                                           F40:KSK0610          /*F40:KSK06102.1*/

This file is part of the portable Regroup Module used in the NonStop
Kernel (NSK) and Loosely Coupled UNIX (LCU) operating systems. There
are 10 files in the module - jrgp.h, jrgpos.h, wrgp.h, wrgpos.h,
srgpif.c, srgpos.c, srgpsm.c, srgputl.c, srgpcli.c and srgpsvr.c.
The last two are simulation files to test the Regroup Module on a
UNIX workstation in user mode with processes simulating processor nodes
and UDP datagrams used to send unacknowledged datagrams.

This file was first submitted for release into NSK on 12/13/95.
------------------------------------------------------------------------------

#endif    /* 0 - change descriptions */


#endif  /* _WRGPOS_H_ defined */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\nm\ifioctl.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ifioctl.c

Abstract:

    Network interface control functions.

Author:

    John Vert (jvert) 2-Mar-1997

Revision History:

--*/

#include "nmp.h"

//
// Read-Write Common Properties.
//
RESUTIL_PROPERTY_ITEM
NmpInterfaceCommonProperties[] =
    {
        {
            CLUSREG_NAME_NETIFACE_DESC, NULL, CLUSPROP_FORMAT_SZ,
            (DWORD_PTR) NmpNullString, 0, 0,
            0,
            FIELD_OFFSET(NM_NETWORK_INFO, Description)
        },
        { 0 }
    };

//
// Read-Only Common Properties.
//
RESUTIL_PROPERTY_ITEM
NmpInterfaceROCommonProperties[] =
    {
        { CLUSREG_NAME_NETIFACE_NAME, NULL, CLUSPROP_FORMAT_SZ,
          0, 0, 0,
          RESUTIL_PROPITEM_READ_ONLY,
          FIELD_OFFSET(NM_INTERFACE_INFO2, Name)
        },
        {
            CLUSREG_NAME_NETIFACE_NODE, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            RESUTIL_PROPITEM_READ_ONLY,
            FIELD_OFFSET(NM_INTERFACE_INFO2, NodeId)
        },
        {
            CLUSREG_NAME_NETIFACE_NETWORK, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            RESUTIL_PROPITEM_READ_ONLY,
            FIELD_OFFSET(NM_INTERFACE_INFO2, NetworkId)
        },
        {
            CLUSREG_NAME_NETIFACE_ADAPTER_NAME, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            RESUTIL_PROPITEM_READ_ONLY,
            FIELD_OFFSET(NM_INTERFACE_INFO2, AdapterName)
        },
        {
            CLUSREG_NAME_NETIFACE_ADAPTER_ID, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            RESUTIL_PROPITEM_READ_ONLY,
            FIELD_OFFSET(NM_INTERFACE_INFO2, AdapterId)
        },
        {
            CLUSREG_NAME_NETIFACE_ADDRESS, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            RESUTIL_PROPITEM_READ_ONLY,
            FIELD_OFFSET(NM_INTERFACE_INFO2, Address)
        },
        { 0 }
    };

//
// Cluster registry API function pointers.
// defined in ioctl.c
//
extern CLUSTER_REG_APIS NmpClusterRegApis;


//
// Local Functions
//

DWORD
NmpInterfaceControl(
    IN PNM_INTERFACE Interface,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
NmpInterfaceEnumCommonProperties(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
NmpInterfaceGetCommonProperties(
    IN PNM_INTERFACE Interface,
    IN BOOL ReadOnly,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
NmpInterfaceValidateCommonProperties(
    IN PNM_INTERFACE Interface,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PNM_INTERFACE_INFO2 InterfaceInfo  OPTIONAL
    );

DWORD
NmpInterfaceSetCommonProperties(
    IN PNM_INTERFACE Interface,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
NmpInterfaceEnumPrivateProperties(
    IN PNM_INTERFACE Interface,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
NmpInterfaceGetPrivateProperties(
    IN PNM_INTERFACE Interface,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
NmpInterfaceValidatePrivateProperties(
    IN PNM_INTERFACE Interface,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
NmpInterfaceSetPrivateProperties(
    IN PNM_INTERFACE Interface,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
NmpInterfaceGetFlags(
    IN PNM_INTERFACE Interface,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );


DWORD
WINAPI
NmInterfaceControl(
    IN PNM_INTERFACE Interface,
    IN PNM_NODE HostNode OPTIONAL,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a network interface.

Arguments:

    Interface - Supplies the network interface to be controlled.

    HostNode - Supplies the host node on which the resource control should
           be delivered. If this is NULL, the local node is used. Not honored!

    ControlCode- Supplies the control code that defines the
        structure and action of the resource control.
        Values of ControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    InBuffer- Supplies a pointer to the input buffer to be passed
        to the resource.

    InBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer..

    OutBuffer- Supplies a pointer to the output buffer to be
        filled in by the resource..

    OutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    BytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the resource..

    Required - Returns the number of bytes if the OutBuffer is not big
        enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD   status;

    //
    // Cluster service ioctls were designed to have access modes, e.g.
    // read-only, read-write, etc. These access modes are not implemented.
    // If eventually they are implemented, an access mode check should be
    // placed here.
    //
    if ( CLUSCTL_GET_CONTROL_OBJECT( ControlCode ) != CLUS_OBJECT_NETINTERFACE ) {
        return(ERROR_INVALID_FUNCTION);
    }

    if (NmpEnterApi(NmStateOnline)) {
        status = NmpInterfaceControl(
                     Interface,
                     ControlCode,
                     InBuffer,
                     InBufferSize,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );

        NmpLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process InterfaceControl request.\n"
            );
    }

    return(status);

} // NmInterfaceControl



DWORD
NmpInterfaceControl(
    IN PNM_INTERFACE Interface,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a network interface.

Arguments:

    Interface - Supplies the network interface to be controlled.

    ControlCode- Supplies the control code that defines the
        structure and action of the network interface control.
        Values of ControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    InBuffer- Supplies a pointer to the input buffer to be passed
        to the network interface.

    InBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    OutBuffer- Supplies a pointer to the output buffer to be
        filled in by the network interface.

    OutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    BytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the network interface.

    Required - Returns the number of bytes if the OutBuffer is not big
        enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD   status;
    HDMKEY  InterfaceKey;
    CLUSPROP_BUFFER_HELPER props;
    DWORD   bufSize;

    InterfaceKey = DmOpenKey(
                       DmNetInterfacesKey,
                       OmObjectId( Interface ),
                       MAXIMUM_ALLOWED
                       );

    if ( InterfaceKey == NULL ) {
        return(GetLastError());
    }

    switch ( ControlCode ) {

    case CLUSCTL_NETINTERFACE_UNKNOWN:
        *BytesReturned = 0;
        status = ERROR_SUCCESS;
        break;

    case CLUSCTL_NETINTERFACE_GET_NAME:
        NmpAcquireLock();
        if ( OmObjectName( Interface ) != NULL ) {
            props.pb = OutBuffer;
            bufSize = (lstrlenW( OmObjectName( Interface ) ) + 1) * sizeof(WCHAR);
            if ( bufSize > OutBufferSize ) {
                *Required = bufSize;
                *BytesReturned = 0;
                status = ERROR_MORE_DATA;
            } else {
                lstrcpyW( props.psz, OmObjectName( Interface ) );
                *BytesReturned = bufSize;
                *Required = 0;
                status = ERROR_SUCCESS;
            }
        } else {
            status = ERROR_NOT_READY;
        }
        NmpReleaseLock();
        break;

    case CLUSCTL_NETINTERFACE_GET_ID:
        NmpAcquireLock();
        if ( OmObjectId( Interface ) != NULL ) {
            props.pb = OutBuffer;
            bufSize = (lstrlenW( OmObjectId( Interface ) ) + 1) * sizeof(WCHAR);
            if ( bufSize > OutBufferSize ) {
                *Required = bufSize;
                *BytesReturned = 0;
                status = ERROR_MORE_DATA;
            } else {
                lstrcpyW( props.psz, OmObjectId( Interface ) );
                *BytesReturned = bufSize;
                *Required = 0;
                status = ERROR_SUCCESS;
            }
        } else {
            status = ERROR_NOT_READY;
        }
        NmpReleaseLock();
        break;

    case CLUSCTL_NETINTERFACE_GET_NODE:
        NmpAcquireLock();
        if ( (Interface->Node != NULL) && (OmObjectName( Interface->Node ) != NULL) ) {
            props.pb = OutBuffer;
            bufSize = (lstrlenW( OmObjectName( Interface->Node ) ) + 1) * sizeof(WCHAR);
            if ( bufSize > OutBufferSize ) {
                *Required = bufSize;
                *BytesReturned = 0;
                status = ERROR_MORE_DATA;
            } else {
                lstrcpyW( props.psz, OmObjectName( Interface->Node ) );
                *BytesReturned = bufSize;
                *Required = 0;
                status = ERROR_SUCCESS;
            }
        } else {
            status = ERROR_NOT_READY;
        }
        NmpReleaseLock();
        break;

    case CLUSCTL_NETINTERFACE_GET_NETWORK:
        NmpAcquireLock();
        if ( (Interface->Network != NULL) && (OmObjectName( Interface->Network ) != NULL) ) {
            props.pb = OutBuffer;
            bufSize = (lstrlenW( OmObjectName( Interface->Network ) ) + 1) * sizeof(WCHAR);
            if ( bufSize > OutBufferSize ) {
                *Required = bufSize;
                *BytesReturned = 0;
                status = ERROR_MORE_DATA;
            } else {
                lstrcpyW( props.psz, OmObjectName( Interface->Network ) );
                *BytesReturned = bufSize;
                *Required = 0;
                status = ERROR_SUCCESS;
            }
        } else {
            status = ERROR_NOT_READY;
        }
        NmpReleaseLock();
        break;

    case CLUSCTL_NETINTERFACE_ENUM_COMMON_PROPERTIES:
        status = NmpInterfaceEnumCommonProperties(
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );
        break;

    case CLUSCTL_NETINTERFACE_GET_RO_COMMON_PROPERTIES:
        status = NmpInterfaceGetCommonProperties(
                     Interface,
                     TRUE, // ReadOnly
                     InterfaceKey,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );
        break;

    case CLUSCTL_NETINTERFACE_GET_COMMON_PROPERTIES:
        status = NmpInterfaceGetCommonProperties(
                     Interface,
                     FALSE, // ReadOnly
                     InterfaceKey,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );
        break;

    case CLUSCTL_NETINTERFACE_VALIDATE_COMMON_PROPERTIES:
        status = NmpInterfaceValidateCommonProperties(
                     Interface,
                     InBuffer,
                     InBufferSize,
                     NULL
                     );
        break;

    case CLUSCTL_NETINTERFACE_SET_COMMON_PROPERTIES:
        status = NmpInterfaceSetCommonProperties(
                     Interface,
                     InterfaceKey,
                     InBuffer,
                     InBufferSize
                     );
        break;

    case CLUSCTL_NETINTERFACE_GET_RO_PRIVATE_PROPERTIES:
        if ( OutBufferSize < sizeof(DWORD) ) {
            *BytesReturned = 0;
            *Required = sizeof(DWORD);
            if ( OutBuffer == NULL ) {
                status = ERROR_SUCCESS;
            } else {
                status = ERROR_MORE_DATA;
            }
        } else {
            LPDWORD ptrDword = (LPDWORD) OutBuffer;
            *ptrDword = 0;
            *BytesReturned = sizeof(DWORD);
            status = ERROR_SUCCESS;
        }
        break;

    case CLUSCTL_NETINTERFACE_GET_PRIVATE_PROPERTIES:
        status = NmpInterfaceGetPrivateProperties(
                     Interface,
                     InterfaceKey,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );
        break;

    case CLUSCTL_NETINTERFACE_VALIDATE_PRIVATE_PROPERTIES:
        status = NmpInterfaceValidatePrivateProperties(
                     Interface,
                     InterfaceKey,
                     InBuffer,
                     InBufferSize
                     );
        break;

    case CLUSCTL_NETINTERFACE_SET_PRIVATE_PROPERTIES:
        status = NmpInterfaceSetPrivateProperties(
                     Interface,
                     InterfaceKey,
                     InBuffer,
                     InBufferSize
                     );
        break;

    case CLUSCTL_NETINTERFACE_GET_CHARACTERISTICS:
        if ( OutBufferSize < sizeof(DWORD) ) {
            *BytesReturned = 0;
            *Required = sizeof(DWORD);
            if ( OutBuffer == NULL ) {
                status = ERROR_SUCCESS;
            } else {
                status = ERROR_MORE_DATA;
            }
        } else {
            *BytesReturned = sizeof(DWORD);
            *(LPDWORD)OutBuffer = 0;
            status = ERROR_SUCCESS;
        }
        break;

    case CLUSCTL_NETINTERFACE_GET_FLAGS:
        status = NmpInterfaceGetFlags(
                     Interface,
                     InterfaceKey,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );
        break;

    case CLUSCTL_NETINTERFACE_ENUM_PRIVATE_PROPERTIES:
        status = NmpInterfaceEnumPrivateProperties(
                     Interface,
                     InterfaceKey,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );
        break;

    default:
        status = ERROR_INVALID_FUNCTION;
        break;
    }

    DmCloseKey( InterfaceKey );

    return(status);

} // NmpInterfaceControl



DWORD
NmpInterfaceEnumCommonProperties(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Enumerates the common property names for a given network interface.

Arguments:

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    //
    // Get the common properties.
    //
    status = ClRtlEnumProperties( NmpInterfaceCommonProperties,
                                  OutBuffer,
                                  OutBufferSize,
                                  BytesReturned,
                                  Required );

    return(status);

} // NmpInterfaceEnumCommonProperties



DWORD
NmpInterfaceGetCommonProperties(
    IN PNM_INTERFACE Interface,
    IN BOOL ReadOnly,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the common properties for a given network interface.

Arguments:

    Interface - Supplies the network interface.

    ReadOnly - TRUE if the read-only properties should be read. FALSE otherwise.

    RegistryKey - Supplies the registry key for this network interface.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD                    status;
    NM_INTERFACE_INFO2       interfaceInfo;
    PRESUTIL_PROPERTY_ITEM   propertyTable;
    DWORD                    outBufferSize = OutBufferSize;


    //
    // Fetch the properties from the object
    //
    ZeroMemory(&interfaceInfo, sizeof(interfaceInfo));

    NmpAcquireLock();

    status = NmpGetInterfaceObjectInfo(Interface, &interfaceInfo);

    if (status != ERROR_SUCCESS) {
        NmpReleaseLock();
        return(status);
    }

    if ( ReadOnly ) {
        LPCWSTR   name;
        DWORD     nameLength;


        propertyTable = NmpInterfaceROCommonProperties;

        //
        // Replace the network ID with a name
        //
        name = OmObjectName(Interface->Network);
        nameLength = NM_WCSLEN(name);
        MIDL_user_free(interfaceInfo.NetworkId);

        interfaceInfo.NetworkId = MIDL_user_allocate(nameLength);

        if (interfaceInfo.NetworkId != NULL) {
            wcscpy(interfaceInfo.NetworkId, name);

            //
            // Replace the node ID with a name
            //
            name = OmObjectName(Interface->Node);
            nameLength = NM_WCSLEN(name);
            MIDL_user_free(interfaceInfo.NodeId);

            interfaceInfo.NodeId = MIDL_user_allocate(nameLength);

            if (interfaceInfo.NodeId != NULL) {
                wcscpy(interfaceInfo.NodeId, name);
            }
            else {
                status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        else {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else {
        //
        // Construct a property list from the parameter block
        // for the read-write properties.
        //
        propertyTable = NmpInterfaceCommonProperties;
    }

    NmpReleaseLock();

    if (status == ERROR_SUCCESS) {
        status = ClRtlPropertyListFromParameterBlock(
                     propertyTable,
                     OutBuffer,
                     &outBufferSize,
                     (LPBYTE) &interfaceInfo,
                     BytesReturned,
                     Required
                     );
    }

    ClNetFreeInterfaceInfo(&interfaceInfo);

    return(status);

} // NmpInterfaceGetCommonProperties



DWORD
NmpInterfaceValidateCommonProperties(
    IN PNM_INTERFACE         Interface,
    IN PVOID                 InBuffer,
    IN DWORD                 InBufferSize,
    OUT PNM_INTERFACE_INFO2  InterfaceInfo  OPTIONAL
    )

/*++

Routine Description:

    Validates the common properties for a given network interface.

Arguments:

    Interface - Supplies the Interface object.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

    InterfaceInfo - An optional pointer to an interface information structure
                    to be filled in with the updated property set.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD                 status;
    NM_INTERFACE_INFO2    infoBuffer;
    PNM_INTERFACE_INFO2   interfaceInfo;
    LPCWSTR               interfaceId = OmObjectId(Interface);


    //
    // Check if there is input data.
    //
    if ( (InBuffer == NULL) ||
         (InBufferSize < sizeof(DWORD)) ) {
        return(ERROR_INVALID_DATA);
    }

    if (InterfaceInfo != NULL) {
        interfaceInfo = InterfaceInfo;
    }
    else {
        interfaceInfo = &infoBuffer;
    }

    ZeroMemory(interfaceInfo, sizeof(NM_INTERFACE_INFO2));

    //
    // Get a copy of the current interface parameters.
    //
    NmpAcquireLock();

    status = NmpGetInterfaceObjectInfo(Interface, interfaceInfo);

    if ( status != ERROR_SUCCESS ) {
        goto error_exit;
    }

    //
    // Validate the property list and update the parameter block.
    //
    status = ClRtlVerifyPropertyTable(
                 NmpInterfaceCommonProperties,
                 NULL,    // Reserved
                 FALSE,   // Don't allow unknowns
                 InBuffer,
                 InBufferSize,
                 (LPBYTE) interfaceInfo
                 );

    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint( LOG_CRITICAL, 
            "[NM] ValidateCommonProperties, error in verify routine.\n"
            );
        goto error_exit;
    }

    //
    // The change is valid.
    //

    CL_ASSERT(status == ERROR_SUCCESS);

error_exit:

    NmpReleaseLock();

    if ((status != ERROR_SUCCESS) || (interfaceInfo == &infoBuffer)) {
        ClNetFreeInterfaceInfo(interfaceInfo);
    }

    return(status);


} // NmpInterfaceValidateCommonProperties



DWORD
NmpInterfaceSetCommonProperties(
    IN PNM_INTERFACE Interface,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Sets the common properties for a given Interface.

Arguments:

    Interface - Supplies the Interface object.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD     status;
    LPCWSTR   interfaceId = OmObjectId(Interface);


    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Setting common properties for interface %1!ws!.\n",
        interfaceId
        );

    //
    // Issue a global update
    //
    status = GumSendUpdateEx(
                 GumUpdateMembership,
                 NmUpdateSetInterfaceCommonProperties,
                 3,
                 NM_WCSLEN(interfaceId),
                 interfaceId,
                 InBufferSize,
                 InBuffer,
                 sizeof(InBufferSize),
                 &InBufferSize
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Global update to set common properties for interface %1!ws! failed, status %2!u!.\n",
            interfaceId,
            status
            );
    }


    return(status);

} // NmpInterfaceSetCommonProperties



DWORD
NmpInterfaceEnumPrivateProperties(
    IN PNM_INTERFACE Interface,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Enumerates the private property names for a given network interface.

Arguments:

    Interface - Supplies the Interface object.

    RegistryKey - Registry key for the Interface.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HDMKEY      parametersKey;
    DWORD       totalBufferSize = 0;

    *BytesReturned = 0;
    *Required = 0;

    //
    // Clear the output buffer
    //
    ZeroMemory( OutBuffer, OutBufferSize );

    //
    // Open the cluster Interface parameters key.
    //
    parametersKey = DmOpenKey( RegistryKey,
                               CLUSREG_KEYNAME_PARAMETERS,
                               MAXIMUM_ALLOWED );
    if ( parametersKey == NULL ) {
        status = GetLastError();
        if ( status == ERROR_FILE_NOT_FOUND ) {
            status = ERROR_SUCCESS;
        }
        return(status);
    }

    //
    // Get private properties for the interface.
    //
    status = ClRtlEnumPrivateProperties( parametersKey,
                                         &NmpClusterRegApis,
                                         OutBuffer,
                                         OutBufferSize,
                                         BytesReturned,
                                         Required );

    DmCloseKey( parametersKey );

    return(status);

} // NmpInterfaceEnumPrivateProperties



DWORD
NmpInterfaceGetPrivateProperties(
    IN PNM_INTERFACE Interface,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the private properties for a given network interface.

Arguments:

    Interface - Supplies the Interface object.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HDMKEY      parametersKey;
    DWORD       totalBufferSize = 0;

    *BytesReturned = 0;
    *Required = 0;

    //
    // Clear the output buffer
    //
    ZeroMemory( OutBuffer, OutBufferSize );

    //
    // Open the cluster Interface parameters key.
    //
    parametersKey = DmOpenKey( RegistryKey,
                               CLUSREG_KEYNAME_PARAMETERS,
                               MAXIMUM_ALLOWED );
    if ( parametersKey == NULL ) {
        status = GetLastError();
        if ( status == ERROR_FILE_NOT_FOUND ) {
            //
            // If we don't have a parameters key, then return an
            // item count of 0 and an endmark.
            //
            totalBufferSize = sizeof(DWORD) + sizeof(CLUSPROP_SYNTAX);
            if ( OutBufferSize < totalBufferSize ) {
                *Required = totalBufferSize;
                status = ERROR_MORE_DATA;
            } else {
                // This is somewhat redundant since we zero the
                // buffer above, but it's here for clarity.
                CLUSPROP_BUFFER_HELPER buf;
                buf.pb = OutBuffer;
                buf.pList->nPropertyCount = 0;
                buf.pdw++;
                buf.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
                *BytesReturned = totalBufferSize;
                status = ERROR_SUCCESS;
            }
        }
        return(status);
    }

    //
    // Get private properties for the network interface.
    //
    status = ClRtlGetPrivateProperties( parametersKey,
                                        &NmpClusterRegApis,
                                        OutBuffer,
                                        OutBufferSize,
                                        BytesReturned,
                                        Required );

    DmCloseKey( parametersKey );

    return(status);

} // NmpInterfaceGetPrivateProperties



DWORD
NmpInterfaceValidatePrivateProperties(
    IN PNM_INTERFACE Interface,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Validates the private properties for a given Interface.

Arguments:

    Interface - Supplies the Interface object.

    RegistryKey - Registry key for the Interface.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    //
    // Validate the property list.
    //
    status = ClRtlVerifyPrivatePropertyList( InBuffer,
                                             InBufferSize );

    return(status);

} // NmpInterfaceValidatePrivateProperties



DWORD
NmpInterfaceSetPrivateProperties(
    IN PNM_INTERFACE Interface,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Sets the private properties for a given Interface.

Arguments:

    Interface - Supplies the Interface object.

    RegistryKey - Registry key for the Interface.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HDMKEY      parametersKey;
    DWORD       disposition;

    //
    // Validate the property list.
    //
    status = ClRtlVerifyPrivatePropertyList( InBuffer,
                                             InBufferSize );

    if ( status == ERROR_SUCCESS ) {

        //
        // Open the cluster Interface\xx\parameters key
        //
        parametersKey = DmOpenKey( RegistryKey,
                                   CLUSREG_KEYNAME_PARAMETERS,
                                   MAXIMUM_ALLOWED );
        if ( parametersKey == NULL ) {
            status = GetLastError();
            if ( status == ERROR_FILE_NOT_FOUND ) {
                //
                // Try to create the parameters key.
                //
                parametersKey = DmCreateKey( RegistryKey,
                                             CLUSREG_KEYNAME_PARAMETERS,
                                             0,
                                             KEY_READ | KEY_WRITE,
                                             NULL,
                                             &disposition );
                if ( parametersKey == NULL ) {
                    status = GetLastError();
                    return(status);
                }
            }
        }

        status = ClRtlSetPrivatePropertyList( NULL, // IN HANDLE hXsaction
                                              parametersKey,
                                              &NmpClusterRegApis,
                                              InBuffer,
                                              InBufferSize );
        DmCloseKey( parametersKey );
    }

    return(status);

} // NmpInterfaceSetPrivateProperties



DWORD
NmpInterfaceGetFlags(
    IN PNM_INTERFACE Interface,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the flags for a given Interface.

Arguments:

    Interface - Supplies the Interface.

    RegistryKey - Registry key for the Interface.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    *BytesReturned = 0;

    if ( OutBufferSize < sizeof(DWORD) ) {
        *Required = sizeof(DWORD);
        if ( OutBuffer == NULL ) {
            status = ERROR_SUCCESS;
        } else {
            status = ERROR_MORE_DATA;
        }
    } else {
        DWORD       valueType;

        //
        // Read the Flags value for the Interface.
        //
        *BytesReturned = OutBufferSize;
        status = DmQueryValue( RegistryKey,
                               CLUSREG_NAME_FLAGS,
                               &valueType,
                               OutBuffer,
                               BytesReturned );
        if ( status == ERROR_FILE_NOT_FOUND ) {
            *BytesReturned = sizeof(DWORD);
            *(LPDWORD)OutBuffer = 0;
            status = ERROR_SUCCESS;
        }
    }

    return(status);

} // NmpInterfaceGetFlags
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\nm\mcast.c ===
/*++

Copyright (c) 1996-2001  Microsoft Corporation

Module Name:

    mcast.c

Abstract:

    Implements the Node Manager's network multicast management routines.

Author:

    David Dion (daviddio) 15-Mar-2001


Revision History:

--*/


#include "nmp.h"
#include <align.h>


/////////////////////////////////////////////////////////////////////////////
//
// Constants
//
/////////////////////////////////////////////////////////////////////////////

//
// Multicast configuration types.
// - Manual: administrator configured address
// - Madcap: lease obtained from MADCAP server
// - Auto: address chosen after no MADCAP server detected
//
typedef enum {
    NmMcastConfigManual = 0,
    NmMcastConfigMadcap,
    NmMcastConfigAuto
} NM_MCAST_CONFIG, *PNM_MCAST_CONFIG;

//
// Lease status.
//
typedef enum {
    NmMcastLeaseValid = 0,
    NmMcastLeaseNeedsRenewal,
    NmMcastLeaseExpired
} NM_MCAST_LEASE_STATUS, *PNM_MCAST_LEASE_STATUS;

#define CLUSREG_NAME_CLUSTER_DISABLE_MULTICAST L"MulticastClusterDisable"

#define CLUSREG_NAME_NET_MULTICAST_ADDRESS     L"MulticastAddress"
#define CLUSREG_NAME_NET_DISABLE_MULTICAST     L"MulticastDisable"
#define CLUSREG_NAME_NET_MULTICAST_KEY_SALT    L"MulticastSalt"
#define CLUSREG_NAME_NET_MCAST_LEASE_OBTAINED  L"MulticastLeaseObtained"
#define CLUSREG_NAME_NET_MCAST_LEASE_EXPIRES   L"MulticastLeaseExpires"
#define CLUSREG_NAME_NET_MCAST_REQUEST_ID      L"MulticastRequestId"
#define CLUSREG_NAME_NET_MCAST_SERVER_ADDRESS  L"MulticastLeaseServer"
#define CLUSREG_NAME_NET_MCAST_CONFIG_TYPE     L"MulticastConfigType"
#define CLUSREG_NAME_NET_MCAST_RANGE_LOWER     L"MulticastAddressRangeLower"
#define CLUSREG_NAME_NET_MCAST_RANGE_UPPER     L"MulticastAddressRangeUpper"

#define NMP_MCAST_DISABLED_DEFAULT          0           // NOT disabled

#define NMP_SINGLE_SOURCE_SCOPE_ADDRESS     0x000000E8  // (232.*.*.*)
#define NMP_SINGLE_SOURCE_SCOPE_MASK        0x000000FF  // (255.0.0.0)

#define NMP_LOCAL_SCOPE_ADDRESS             0x0000FFEF  // (239.255.*.*)
#define NMP_LOCAL_SCOPE_MASK                0x0000FFFF  // (255.255.*.*)

#define NMP_ORG_SCOPE_ADDRESS               0x0000C0EF  // (239.192.*.*)
#define NMP_ORG_SCOPE_MASK                  0x0000FCFF  // (255.63.*.*)

#define NMP_MCAST_DEFAULT_RANGE_LOWER       0x0000FFEF  // (239.255.0.0)
#define NMP_MCAST_DEFAULT_RANGE_UPPER       0xFFFEFFEF  // (239.255.254.255)

#define NMP_MCAST_LEASE_RENEWAL_THRESHOLD   300         // 5 minutes
#define NMP_MCAST_LEASE_RENEWAL_WINDOW      1800        // 30 minutes
#define NMP_MADCAP_REQUERY_PERDIOD          3600 * 24   // 1 day

#define NMP_MCAST_CONFIG_STABILITY_DELAY    5 * 1000    // 5 seconds
#define NMP_MANUAL_DEFAULT_WAIT_INTERVAL    60 * 1000   // 2 minutes

//
// Minimum cluster node count in which to run multicast
//
#define NMP_MCAST_MIN_CLUSTER_NODE_COUNT    3

//
// MADCAP lease request/response buffer sizes. These sizes are based on
// IPv4 addresses.
//
#define NMP_MADCAP_REQUEST_BUFFER_SIZE \
        (ROUND_UP_COUNT(sizeof(MCAST_LEASE_REQUEST),TYPE_ALIGNMENT(DWORD)) + \
         sizeof(DWORD))
         
#define NMP_MADCAP_REQUEST_ADDR_OFFSET \
        (ROUND_UP_COUNT(sizeof(MCAST_LEASE_REQUEST),TYPE_ALIGNMENT(DWORD)))
         
#define NMP_MADCAP_RESPONSE_BUFFER_SIZE \
        (ROUND_UP_COUNT(sizeof(MCAST_LEASE_RESPONSE),TYPE_ALIGNMENT(DWORD)) + \
         sizeof(DWORD))
         
#define NMP_MADCAP_RESPONSE_ADDR_OFFSET \
        (ROUND_UP_COUNT(sizeof(MCAST_LEASE_RESPONSE),TYPE_ALIGNMENT(DWORD)))
        
//
// MADCAP lease times are in seconds. NM timers are in milliseconds.
//
#define NMP_MADCAP_TO_NM_TIME(_mc_time) ((_mc_time) * 1000)

//
// Force a time_t value into a DWORD.
//
#define NMP_TIME_TO_DWORD(_tm, _dw)                   \
    (_tm) = ((_tm) < 0) ? 0 : (_tm);                  \
    (_tm) = ((_tm) > MAXLONG) ? MAXLONG : (_tm);      \
    (_dw) = (DWORD) (_tm)


//
// Avoid trying to free a global NM string.
//
#define NMP_GLOBAL_STRING(_string)               \
    (((_string) == NmpNullMulticastAddress) ||   \
     ((_string) == NmpNullString))
     
//
// Conditions in which we release an address.
//
#define NmpNeedRelease(_Address, _Server, _RequestId, _Expires)    \
    (((_Address) != NULL) &&                                       \
     (NmpMulticastValidateAddress(_Address)) &&                    \
     ((_Server) != NULL) &&                                        \
     ((_RequestId)->ClientUID != NULL) &&                          \
     ((_RequestId)->ClientUIDLength != 0) &&                       \
     ((_Expires) != 0))

//
// Convert IPv4 addr DWORD into four arguments for a printf/log routine.
//
#define NmpIpAddrPrintArgs(_ip) \
    ((_ip >> 0 ) & 0xff),       \
    ((_ip >> 8 ) & 0xff),       \
    ((_ip >> 16) & 0xff),       \
    ((_ip >> 24) & 0xff)


/////////////////////////////////////////////////////////////////////////////
//
// Data
//
/////////////////////////////////////////////////////////////////////////////

LPWSTR                 NmpNullMulticastAddress = L"0.0.0.0";
BOOLEAN                NmpMadcapClientInitialized = FALSE;
BOOLEAN                NmpIsNT5NodeInCluster = FALSE;
BOOLEAN                NmpMulticastIsNotEnoughNodes = FALSE;

// MADCAP lease release node.
typedef struct _NM_NETWORK_MADCAP_ADDRESS_RELEASE {
    LIST_ENTRY             Linkage;
    LPWSTR                 McastAddress;
    LPWSTR                 ServerAddress;
    MCAST_CLIENT_UID       RequestId;
} NM_NETWORK_MADCAP_ADDRESS_RELEASE, *PNM_NETWORK_MADCAP_ADDRESS_RELEASE;

// Data structure for GUM update
typedef struct _NM_NETWORK_MULTICAST_UPDATE {
    DWORD                  Disabled;
    DWORD                  AddressOffset;
    DWORD                  SaltOffset;
    DWORD                  SaltLength;
    time_t                 LeaseObtained;
    time_t                 LeaseExpires;
    DWORD                  LeaseRequestIdOffset;
    DWORD                  LeaseRequestIdLength;
    DWORD                  LeaseServerOffset;
    NM_MCAST_CONFIG        ConfigType;
} NM_NETWORK_MULTICAST_UPDATE, *PNM_NETWORK_MULTICAST_UPDATE;

// Data structure for multicast parameters, converted to and from the
// GUM update data structure
typedef struct _NM_NETWORK_MULTICAST_PARAMETERS {
    DWORD                  Disabled;
    LPWSTR                 Address;
    PVOID                  Salt;
    DWORD                  SaltLength;
    PVOID                  Key;
    DWORD                  KeyLength;
    time_t                 LeaseObtained;
    time_t                 LeaseExpires;
    MCAST_CLIENT_UID       LeaseRequestId;
    LPWSTR                 LeaseServer;
    NM_MCAST_CONFIG        ConfigType;
} NM_NETWORK_MULTICAST_PARAMETERS, *PNM_NETWORK_MULTICAST_PARAMETERS;

// Data structure for multicast property validation
typedef struct _NM_NETWORK_MULTICAST_INFO {
    LPWSTR                  MulticastAddress;
    DWORD                   MulticastDisable;
    PVOID                   MulticastSalt;
    DWORD                   MulticastLeaseObtained;
    DWORD                   MulticastLeaseExpires;
    PVOID                   MulticastLeaseRequestId;
    LPWSTR                  MulticastLeaseServer;
    DWORD                   MulticastConfigType;
    LPWSTR                  MulticastAddressRangeLower;
    LPWSTR                  MulticastAddressRangeUpper;
} NM_NETWORK_MULTICAST_INFO, *PNM_NETWORK_MULTICAST_INFO;

RESUTIL_PROPERTY_ITEM
NmpNetworkMulticastProperties[] =
    {
        {
            CLUSREG_NAME_NET_MULTICAST_ADDRESS, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            0, // no flags - multicast address is writeable
            FIELD_OFFSET(NM_NETWORK_MULTICAST_INFO, MulticastAddress)
        },
        {
            CLUSREG_NAME_NET_DISABLE_MULTICAST, NULL, CLUSPROP_FORMAT_DWORD,
            NMP_MCAST_DISABLED_DEFAULT, 0, 0xFFFFFFFF,
            0, // no flags - disable is writeable
            FIELD_OFFSET(NM_NETWORK_MULTICAST_INFO, MulticastDisable)
        },
        {
            CLUSREG_NAME_NET_MULTICAST_KEY_SALT, NULL, CLUSPROP_FORMAT_BINARY,
            0, 0, 0,
            RESUTIL_PROPITEM_READ_ONLY,
            FIELD_OFFSET(NM_NETWORK_MULTICAST_INFO, MulticastSalt)
        },
        {
            CLUSREG_NAME_NET_MCAST_LEASE_OBTAINED, NULL, CLUSPROP_FORMAT_DWORD,
            0, 0, MAXLONG,
            RESUTIL_PROPITEM_READ_ONLY,
            FIELD_OFFSET(NM_NETWORK_MULTICAST_INFO, MulticastLeaseObtained)
        },
        {
            CLUSREG_NAME_NET_MCAST_LEASE_EXPIRES, NULL, CLUSPROP_FORMAT_DWORD,
            0, 0, MAXLONG,
            RESUTIL_PROPITEM_READ_ONLY,
            FIELD_OFFSET(NM_NETWORK_MULTICAST_INFO, MulticastLeaseExpires)
        },
        {
            CLUSREG_NAME_NET_MCAST_REQUEST_ID, NULL, CLUSPROP_FORMAT_BINARY,
            0, 0, 0,
            RESUTIL_PROPITEM_READ_ONLY,
            FIELD_OFFSET(NM_NETWORK_MULTICAST_INFO, MulticastLeaseRequestId)
        },
        {
            CLUSREG_NAME_NET_MCAST_SERVER_ADDRESS, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            RESUTIL_PROPITEM_READ_ONLY,
            FIELD_OFFSET(NM_NETWORK_MULTICAST_INFO, MulticastLeaseServer)
        },
        {
            CLUSREG_NAME_NET_MCAST_CONFIG_TYPE, NULL, CLUSPROP_FORMAT_DWORD,
            NmMcastConfigManual, NmMcastConfigManual, NmMcastConfigAuto,
            RESUTIL_PROPITEM_READ_ONLY,
            FIELD_OFFSET(NM_NETWORK_MULTICAST_INFO, MulticastConfigType)
        },
        {
            CLUSREG_NAME_NET_MCAST_RANGE_LOWER, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            0, // no flags - multicast address range is writeable
            FIELD_OFFSET(NM_NETWORK_MULTICAST_INFO, MulticastAddressRangeLower)
        },
        {
            CLUSREG_NAME_NET_MCAST_RANGE_UPPER, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            0, // no flags - multicast address range is writeable
            FIELD_OFFSET(NM_NETWORK_MULTICAST_INFO, MulticastAddressRangeUpper)
        },
        {
            0
        }
    };

//
// Cluster registry API function pointers. Need a separate collection
// of function pointers for multicast because nobody else (e.g. FM, NM) 
// fills in DmLocalXXX.
//
CLUSTER_REG_APIS
NmpMcastClusterRegApis = {
    (PFNCLRTLCREATEKEY) DmRtlCreateKey,
    (PFNCLRTLOPENKEY) DmRtlOpenKey,
    (PFNCLRTLCLOSEKEY) DmCloseKey,
    (PFNCLRTLSETVALUE) DmSetValue,
    (PFNCLRTLQUERYVALUE) DmQueryValue,
    (PFNCLRTLENUMVALUE) DmEnumValue,
    (PFNCLRTLDELETEVALUE) DmDeleteValue,
    (PFNCLRTLLOCALCREATEKEY) DmLocalCreateKey,
    (PFNCLRTLLOCALSETVALUE) DmLocalSetValue,
    (PFNCLRTLLOCALDELETEVALUE) DmLocalDeleteValue
};

//
// Restricted ranges: we cannot choose a multicast address out of these
// ranges, even if an administrator defines a selection range that
// overlaps with a restricted range.
//
// Note, however, that if an administrator manually configures an
// address, we accept it without question.
//
struct _NM_MCAST_RESTRICTED_RANGE {
    DWORD   Lower;
    DWORD   Upper;
    LPWSTR  Description;
} NmpMulticastRestrictedRange[] = 
    {
        // single-source scope
        { NMP_SINGLE_SOURCE_SCOPE_ADDRESS,
            NMP_SINGLE_SOURCE_SCOPE_ADDRESS | ~NMP_SINGLE_SOURCE_SCOPE_MASK,
            L"Single-Source IP Multicast Address Range" },

        // upper /24 of admin local scope
        { (NMP_LOCAL_SCOPE_ADDRESS | ~NMP_LOCAL_SCOPE_MASK) & 0x00FFFFFF,
            NMP_LOCAL_SCOPE_ADDRESS | ~NMP_LOCAL_SCOPE_MASK,
            L"Administrative Local Scope Relative Assignment Range" },

        // upper /24 of admin organizational scope
        { (NMP_ORG_SCOPE_ADDRESS | ~NMP_ORG_SCOPE_MASK) & 0x00FFFFFF,
            NMP_ORG_SCOPE_ADDRESS | ~NMP_ORG_SCOPE_MASK,
            L"Administrative Organizational Scope Relative Assignment Range" }
    };

DWORD NmpMulticastRestrictedRangeCount = 
          sizeof(NmpMulticastRestrictedRange) / 
          sizeof(struct _NM_MCAST_RESTRICTED_RANGE);

//
// Range intervals: intervals in the IPv4 class D address space
// from which we can choose an address.
//
typedef struct _NM_MCAST_RANGE_INTERVAL {
    LIST_ENTRY Linkage;
    DWORD      hlLower;
    DWORD      hlUpper;
} NM_MCAST_RANGE_INTERVAL, *PNM_MCAST_RANGE_INTERVAL;

#define NmpMulticastRangeIntervalSize(_interval) \
    ((_interval)->hlUpper - (_interval)->hlLower + 1)


/////////////////////////////////////////////////////////////////////////////
//
// Internal prototypes
//
/////////////////////////////////////////////////////////////////////////////

DWORD
NmpScheduleNetworkMadcapWorker(
    PNM_NETWORK   Network
    );

DWORD
NmpReconfigureMulticast(
    IN PNM_NETWORK        Network
    );

/////////////////////////////////////////////////////////////////////////////
//
// Initialization & cleanup routines
//
/////////////////////////////////////////////////////////////////////////////

DWORD
NmpCleanupMulticast(
    VOID
    )
/*++

Notes:

    Called with NM lock held.
    
--*/
{
    //
    // Cleanup the MADCAP client.
    //
    if (NmpMadcapClientInitialized) {
        McastApiCleanup();
        NmpMadcapClientInitialized = FALSE;
    }

    return(ERROR_SUCCESS);

} // NmpCleanupMulticast

/////////////////////////////////////////////////////////////////////////////
//
// Internal routines.
//
/////////////////////////////////////////////////////////////////////////////

#if CLUSTER_BETA
LPWSTR
NmpCreateLogString(
    IN   PVOID  Source,
    IN   DWORD  SourceLength
    )
{
    PWCHAR displayBuf, bufp;
    PCHAR  chp;
    DWORD  x, i;

    displayBuf = LocalAlloc(
                     LMEM_FIXED | LMEM_ZEROINIT, 
                     SourceLength * ( 7 * sizeof(WCHAR) )
                     );
    if (displayBuf == NULL) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Failed to allocate display buffer of size %1!u!.\n",
            SourceLength * sizeof(WCHAR)
            );
        goto error_exit;
    }

    bufp = displayBuf;
    chp = (PCHAR) Source;
    for (i = 0; i < SourceLength; i++) {
        x = (DWORD) (*chp);
        x &= 0xff;
        wsprintf(bufp, L"%02x ", x);
        chp++;
        bufp = &displayBuf[wcslen(displayBuf)];
    }

error_exit:

    return(displayBuf);

} // NmpCreateLogString
#endif // CLUSTER_BETA


BOOLEAN
NmpMulticastValidateAddress(
    IN   LPWSTR            McastAddress
    )
/*++

Routine Description:

    Determines whether McastAddress is a valid
    multicast address.
    
Notes:    
    
    IPv4 specific.
    
--*/
{
    DWORD        status;
    DWORD        address;

    status = ClRtlTcpipStringToAddress(McastAddress, &address);
    if (status == ERROR_SUCCESS) {

        address = ntohl(address);

        if (IN_CLASSD(address)) {
            return(TRUE);
        }
    }

    return(FALSE);

} // NmpMulticastValidateAddress


VOID
NmpFreeNetworkMulticastInfo(
    IN     PNM_NETWORK_MULTICAST_INFO McastInfo
    )
{
    NM_MIDL_FREE_OBJECT_FIELD(McastInfo, MulticastAddress);

    NM_MIDL_FREE_OBJECT_FIELD(McastInfo, MulticastSalt);

    NM_MIDL_FREE_OBJECT_FIELD(McastInfo, MulticastLeaseRequestId);

    NM_MIDL_FREE_OBJECT_FIELD(McastInfo, MulticastLeaseServer);

    NM_MIDL_FREE_OBJECT_FIELD(McastInfo, MulticastAddressRangeLower);

    NM_MIDL_FREE_OBJECT_FIELD(McastInfo, MulticastAddressRangeUpper);
    
    return;

} // NmpFreeNetworkMulticastInfo


DWORD
NmpStoreString(
    IN     LPWSTR    Source,
    IN OUT LPWSTR  * Dest,
    IN OUT DWORD   * DestLength   OPTIONAL
    )
{
    DWORD    sourceSize;
    DWORD    destLength;

    if (Source != NULL) {
        sourceSize = NM_WCSLEN(Source);
    } else {
        sourceSize = 0;
    }

    if (DestLength == NULL) {
        destLength = 0;
    } else {
        destLength = *DestLength;
    }

    if (*Dest != NULL && ((destLength < sourceSize) || (Source == NULL))) {

        MIDL_user_free(*Dest);
        *Dest = NULL;
    }

    if (*Dest == NULL) {

        if (sourceSize > 0) {
            *Dest = MIDL_user_allocate(sourceSize);
            if (*Dest == NULL) {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Failed to allocate buffer of size %1!u! "
                    "for source string %2!ws!.\n",
                    sourceSize, Source
                    );
                return(ERROR_NOT_ENOUGH_MEMORY);
            }
        }
        if (DestLength != NULL) {
            *DestLength = sourceSize;
        }
    }

    if (sourceSize > 0) {
        RtlCopyMemory(*Dest, Source, sourceSize);
    }

    return(ERROR_SUCCESS);

} // NmpStoreString


DWORD
NmpStoreRequestId(
    IN     LPMCAST_CLIENT_UID   Source,
    IN OUT LPMCAST_CLIENT_UID   Dest
    )
{
    DWORD status;
    DWORD len;

    len = Source->ClientUIDLength;
    if (Source->ClientUID == NULL) {
        len = 0;
    }

    if (Dest->ClientUID != NULL &&
        (Dest->ClientUIDLength < Source->ClientUIDLength || len == 0)) {

        MIDL_user_free(Dest->ClientUID);
        Dest->ClientUID = NULL;
        Dest->ClientUIDLength = 0;
    }

    if (Dest->ClientUID == NULL && len > 0) {
        
        Dest->ClientUID = MIDL_user_allocate(len);
        if (Dest->ClientUID == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto error_exit;
        }
    }

    if (len > 0) {
        RtlCopyMemory(
            Dest->ClientUID,
            Source->ClientUID, 
            len
            );
    }
    
    Dest->ClientUIDLength = len;
    
    status = ERROR_SUCCESS;

error_exit:

    return(status);

} // NmpStoreRequestId


VOID
NmpStartNetworkMulticastAddressRenewTimer(
    PNM_NETWORK  Network,
    DWORD        Timeout
    )
/*++

Notes:

    Must be called with NM lock held.
    
--*/
{
    LPCWSTR   networkId = OmObjectId(Network);
    LPCWSTR   networkName = OmObjectName(Network);

    if (Network->McastAddressRenewTimer != Timeout) {

        Network->McastAddressRenewTimer = Timeout;

        ClRtlLogPrint(LOG_NOISE,
            "[NM] %1!ws! multicast address lease renew "
            "timer (%2!u!ms) for network %3!ws! (%4!ws!)\n",
            ((Timeout == 0) ? L"Cleared" : L"Started"),
            Network->McastAddressRenewTimer,
            networkId,
            networkName
            );
    }

    return;

} // NmpStartNetworkMulticastAddressRenewTimer


DWORD
NmpGenerateMulticastKey(
    IN     PNM_NETWORK   Network,
    IN OUT PVOID       * Key,
    IN OUT ULONG       * KeyLength
    )
/*++

Routine Description:

    Obtain a secret key that all nodes in the cluster can 
    independently generate.
    
--*/
{
    DWORD     status;
    LPCWSTR   networkId = OmObjectId(Network);
    PVOID     key = NULL;
    DWORD     keyLength = 0;
    
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Obtaining multicast key for network %1!ws!.\n",
        networkId
        );

    status = NmpGetClusterKey(key, &keyLength);
    if (status != ERROR_SUCCESS) {

        if (status == ERROR_INSUFFICIENT_BUFFER) {

            key = MIDL_user_allocate(keyLength);
            if (key == NULL) {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Failed to allocate key buffer of "
                    "size %1!u! for network %2!ws!.\n",
                    keyLength, networkId
                    );
                return(ERROR_NOT_ENOUGH_MEMORY);
            }

            status = NmpGetClusterKey(key, &keyLength);
        }
    }

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to obtain multicast key for "
            "network %1!ws!, status %2!u!.\n",
            networkId, status
            );
        return(status);
    }
    
    *Key = key;
    *KeyLength = keyLength;

    return(ERROR_SUCCESS);

} // NmpGenerateMulticastKey


VOID
NmpMulticastFreeParameters(
    IN  PNM_NETWORK_MULTICAST_PARAMETERS Parameters
    )
{
    if (Parameters->Address != NULL) {
        if (!NMP_GLOBAL_STRING(Parameters->Address)) {
            MIDL_user_free(Parameters->Address);
        }
        Parameters->Address = NULL;
    }

    NM_MIDL_FREE_OBJECT_FIELD(Parameters, Salt);
    Parameters->SaltLength = 0;

    NM_MIDL_FREE_OBJECT_FIELD(Parameters, Key);
    Parameters->KeyLength = 0;

    NM_MIDL_FREE_OBJECT_FIELD(Parameters, LeaseRequestId.ClientUID);
    Parameters->LeaseRequestId.ClientUIDLength = 0;

    if (Parameters->LeaseServer != NULL) {
        if (!NMP_GLOBAL_STRING(Parameters->LeaseServer)) {
            MIDL_user_free(Parameters->LeaseServer);
        }
        Parameters->LeaseServer = NULL;
    }

    return;

} // NmpMulticastFreeParameters


DWORD
NmpMulticastCreateParameters(
    IN  DWORD                            Disabled,
    IN  LPWSTR                           Address,
    IN  PVOID                            Salt,
    IN  DWORD                            SaltLength,
    IN  PVOID                            Key,
    IN  DWORD                            KeyLength,
    IN  time_t                           LeaseObtained,
    IN  time_t                           LeaseExpires,
    IN  LPMCAST_CLIENT_UID               LeaseRequestId,
    IN  LPWSTR                           LeaseServer,
    IN  NM_MCAST_CONFIG                  ConfigType,
    OUT PNM_NETWORK_MULTICAST_PARAMETERS Parameters
    )
{
    DWORD status;

    RtlZeroMemory(Parameters, sizeof(*Parameters));

    // disabled
    Parameters->Disabled = Disabled;

    // address
    if (Address != NULL) {
        status = NmpStoreString(Address, &(Parameters->Address), NULL);
        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }
    }

    // salt
    if (Salt != NULL) {
        Parameters->Salt = MIDL_user_allocate(SaltLength);
        if (Parameters->Salt == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto error_exit;
        }
        RtlCopyMemory(Parameters->Salt, Salt, SaltLength);
        Parameters->SaltLength = SaltLength;
    }

    // key
    if (Key != NULL) {
        Parameters->Key = MIDL_user_allocate(KeyLength);
        if (Parameters->Key == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto error_exit;
        }
        RtlCopyMemory(Parameters->Key, Key, KeyLength);
        Parameters->KeyLength = KeyLength;
    }

    Parameters->LeaseObtained = LeaseObtained;
    Parameters->LeaseExpires = LeaseExpires;

    // lease request id
    if (LeaseRequestId->ClientUID != NULL) {
        status = NmpStoreRequestId(LeaseRequestId, &Parameters->LeaseRequestId);
        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }
    }
    
    // lease server address
    if (LeaseServer != NULL) {
        status = NmpStoreString(LeaseServer, &(Parameters->LeaseServer), NULL);
        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }
    }

    // config type
    Parameters->ConfigType = ConfigType;

    return(ERROR_SUCCESS);

error_exit:

    NmpMulticastFreeParameters(Parameters);

    return(status);

} // NmpMulticastCreateParameters


DWORD
NmpMulticastCreateParametersFromUpdate(
    IN     PNM_NETWORK                        Network,
    IN     PNM_NETWORK_MULTICAST_UPDATE       Update,
    IN     BOOLEAN                            GenerateKey,
    OUT    PNM_NETWORK_MULTICAST_PARAMETERS   Parameters
    )
/*++

Routine Description:

    Converts a data structure received in a GUM update
    into a locally allocated parameters data structure.
    The base Parameters data structure must be allocated
    by the caller, though the fields are allocated in
    this routine.
    
--*/
{
    DWORD            status;
    MCAST_CLIENT_UID requestId;

    requestId.ClientUID =
        ((Update->LeaseRequestIdOffset == 0) ? NULL :
         (LPBYTE)((PUCHAR)Update + Update->LeaseRequestIdOffset));
    requestId.ClientUIDLength = Update->LeaseRequestIdLength;

    status = NmpMulticastCreateParameters(
                 Update->Disabled,
                 ((Update->AddressOffset == 0) ? NULL :
                  (LPWSTR)((PUCHAR)Update + Update->AddressOffset)),
                 ((Update->SaltOffset == 0) ? NULL :
                  (PVOID)((PUCHAR)Update + Update->SaltOffset)),
                 Update->SaltLength,
                 NULL,
                 0,
                 Update->LeaseObtained,
                 Update->LeaseExpires,
                 &requestId,
                 ((Update->LeaseServerOffset == 0) ? NULL :
                  (LPWSTR)((PUCHAR)Update + Update->LeaseServerOffset)),
                 Update->ConfigType,
                 Parameters
                 );

    if (status == ERROR_SUCCESS && GenerateKey) {

        status = NmpGenerateMulticastKey(
                     Network,
                     &(Parameters->Key),
                     &(Parameters->KeyLength)
                     );
    }

    if (status != ERROR_SUCCESS) {
        NmpMulticastFreeParameters(Parameters);
    }

    return(status);

} // NmpMulticastCreateParametersFromUpdate


DWORD
NmpMulticastCreateUpdateFromParameters(
    IN  PNM_NETWORK                       Network,
    IN  PNM_NETWORK_MULTICAST_PARAMETERS  Parameters,
    OUT PNM_NETWORK_MULTICAST_UPDATE    * Update,
    OUT DWORD                           * UpdateSize
    )
{
    DWORD                            updateSize;
    PNM_NETWORK_MULTICAST_UPDATE     update;

    DWORD                            address = 0;
    DWORD                            salt = 0;
    DWORD                            requestId = 0;
    DWORD                            leaseServer = 0;

    //
    // Calculate the size of the update data buffer.
    //
    updateSize = sizeof(*update);

    // address
    if (Parameters->Address != NULL) {
        updateSize = ROUND_UP_COUNT(updateSize, TYPE_ALIGNMENT(LPWSTR));
        address = updateSize;
        updateSize += NM_WCSLEN(Parameters->Address);
    }

    // salt
    if (Parameters->Salt != NULL) {
        updateSize = ROUND_UP_COUNT(updateSize, TYPE_ALIGNMENT(PVOID));
        salt = updateSize;
        updateSize += Parameters->SaltLength;
    }

    // request id
    if (Parameters->LeaseRequestId.ClientUID != NULL) {
        updateSize = ROUND_UP_COUNT(updateSize, TYPE_ALIGNMENT(LPBYTE));
        requestId = updateSize;
        updateSize += Parameters->LeaseRequestId.ClientUIDLength;
    }

    // lease server
    if (Parameters->LeaseServer != NULL) {
        updateSize = ROUND_UP_COUNT(updateSize, TYPE_ALIGNMENT(LPWSTR));
        leaseServer = updateSize;
        updateSize += NM_WCSLEN(Parameters->LeaseServer);
    }

    //
    // Allocate the update buffer.
    //
    update = MIDL_user_allocate(updateSize);
    if (update == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Fill in the update buffer.
    //
    update->Disabled = Parameters->Disabled;
    
    update->AddressOffset = address;
    if (address != 0) {
        RtlCopyMemory(
            (PUCHAR)update + address,
            Parameters->Address,
            NM_WCSLEN(Parameters->Address)
            );
    }

    update->SaltOffset = salt;
    update->SaltLength = Parameters->SaltLength;
    if (salt != 0) {
        RtlCopyMemory(
            (PUCHAR)update + salt,
            Parameters->Salt,
            Parameters->SaltLength
            );
    }

    update->LeaseObtained = Parameters->LeaseObtained;
    update->LeaseExpires = Parameters->LeaseExpires;

    update->LeaseRequestIdOffset = requestId;
    update->LeaseRequestIdLength = Parameters->LeaseRequestId.ClientUIDLength;
    if (requestId != 0) {
        RtlCopyMemory(
            (PUCHAR)update + requestId,
            Parameters->LeaseRequestId.ClientUID,
            Parameters->LeaseRequestId.ClientUIDLength
            );
    }

    update->LeaseServerOffset = leaseServer;
    if (leaseServer != 0) {
        RtlCopyMemory(
            (PUCHAR)update + leaseServer,
            Parameters->LeaseServer,
            NM_WCSLEN(Parameters->LeaseServer)
            );
    }

    update->ConfigType = Parameters->ConfigType;

    *Update = update;
    *UpdateSize = updateSize;

    return(ERROR_SUCCESS);

} // NmpMulticastCreateUpdateFromParameters


VOID
NmpFreeMulticastAddressRelease(
    IN     PNM_NETWORK_MADCAP_ADDRESS_RELEASE Release
    )
{
    if (Release == NULL) {
        return;
    }

    if (Release->McastAddress != NULL && 
        !NMP_GLOBAL_STRING(Release->McastAddress)) {
        MIDL_user_free(Release->McastAddress);
        Release->McastAddress = NULL;
    }

    if (Release->ServerAddress != NULL && 
        !NMP_GLOBAL_STRING(Release->ServerAddress)) {
        MIDL_user_free(Release->ServerAddress);
        Release->ServerAddress = NULL;
    }

    if (Release->RequestId.ClientUID != NULL) {
        MIDL_user_free(Release->RequestId.ClientUID);
        Release->RequestId.ClientUID = NULL;
        Release->RequestId.ClientUIDLength = 0;
    }

    LocalFree(Release);

    return;

} // NmpFreeMulticastAddressRelease

DWORD
NmpCreateMulticastAddressRelease(
    IN  LPWSTR                               McastAddress,
    IN  LPWSTR                               ServerAddress,
    IN  LPMCAST_CLIENT_UID                   RequestId,
    OUT PNM_NETWORK_MADCAP_ADDRESS_RELEASE * Release
    )
/*++

Routine Description:

    Allocate and initialize an entry for an address
    release list.
    
--*/
{
    DWORD                              status;
    PNM_NETWORK_MADCAP_ADDRESS_RELEASE release = NULL;

    release = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(*release));
    if (release == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    status = NmpStoreString(McastAddress, &(release->McastAddress), NULL);
    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    status = NmpStoreString(ServerAddress, &(release->ServerAddress), NULL);
    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    status = NmpStoreRequestId(RequestId, &(release->RequestId));
    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    *Release = release;

    return(ERROR_SUCCESS);

error_exit:

    NmpFreeMulticastAddressRelease(release);

    return(status);

} // NmpCreateMulticastAddressRelease


VOID
NmpInitiateMulticastAddressRelease(
    IN PNM_NETWORK                         Network,
    IN PNM_NETWORK_MADCAP_ADDRESS_RELEASE  Release
    )
/*++

Routine Description:

    Stores an entry for the network multicast
    address release list on the list and schedules
    the release.
    
Notes:

    Called and returns with NM lock held.
    
--*/
{
    InsertTailList(&(Network->McastAddressReleaseList), &(Release->Linkage));

    NmpScheduleMulticastAddressRelease(Network);

    return;

} // NmpInitiateMulticastAddressRelease


DWORD
NmpQueryMulticastAddress(
    IN     PNM_NETWORK   Network,
    IN     HDMKEY        NetworkKey,
    IN OUT HDMKEY      * NetworkParametersKey,
    IN OUT LPWSTR      * McastAddr,
    IN OUT ULONG       * McastAddrLength
    )
{
    DWORD         status;
    LPCWSTR       networkId = OmObjectId(Network);
    HDMKEY        netParamKey = NULL;
    BOOLEAN       openedNetParamKey = FALSE;
    DWORD         size = 0;

    if (Network == NULL || NetworkKey == NULL) {
        status = ERROR_INVALID_PARAMETER;
        goto error_exit;
    }

#if CLUSTER_BETA
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Querying multicast address for "
        "network %1!ws! from cluster database.\n",
        networkId
        );
#endif // CLUSTER_BETA
    //
    // Open the network parameters key, if necessary.
    //
    netParamKey = *NetworkParametersKey;

    if (netParamKey == NULL) {

        netParamKey = DmOpenKey(
                          NetworkKey, 
                          CLUSREG_KEYNAME_PARAMETERS, 
                          MAXIMUM_ALLOWED
                          );
        if (netParamKey == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] Failed to find Parameters key "
                "for network %1!ws!, status %2!u!. Using default "
                "multicast parameters.\n",
                networkId, status
                );
            goto error_exit;
        } else {
            openedNetParamKey = TRUE;
        }
    }

    //
    // Query for the multicast address.
    //
    status = NmpQueryString(
                 netParamKey,
                 CLUSREG_NAME_NET_MULTICAST_ADDRESS,
                 REG_SZ,
                 McastAddr,
                 McastAddrLength,
                 &size
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to read multicast address for "
            "network %1!ws! from cluster database, "
            "status %2!u!. Using default.\n",
            networkId, status
            );
        goto error_exit;
    }

    *NetworkParametersKey = netParamKey;
    netParamKey = NULL;

#if CLUSTER_BETA
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Found multicast address %1!ws! for "
        "network %2!ws! in cluster database.\n",
        *McastAddr, networkId
        );
#endif // CLUSTER_BETA

error_exit:

    if (openedNetParamKey && netParamKey != NULL) {
        DmCloseKey(netParamKey);
        netParamKey = NULL;
    }

    return(status);

} // NmpQueryMulticastAddress


DWORD
NmpQueryMulticastDisabled(
    IN     PNM_NETWORK   Network,
    IN OUT HDMKEY      * ClusterParametersKey,  
    IN OUT HDMKEY      * NetworkKey,
    IN OUT HDMKEY      * NetworkParametersKey,
       OUT DWORD       * Disabled
    )
/*++

Routine Description:

    Checks whether multicast has been disabled for this
    network in the cluster database. Both the network
    paramters key and the cluster parameters key are
    checked. The order of precedence is as follows:
    
    - a value in the network parameters key has top
      precedence
      
    - if no value is found in the network parameters
      key, a value is checked in the cluster parameters
      key.
      
    - if no value is found in the cluster parameters
      key, return NMP_MCAST_DISABLED_DEFAULT.
      
    If an error is returned, the return value of 
    Disabled is undefined.
      
Notes:

    Must not be called with NM lock held.
    
--*/
{
    DWORD         status;
    LPCWSTR       networkId = OmObjectId(Network);
    DWORD         type;
    DWORD         disabled;
    DWORD         len = sizeof(disabled);
    BOOLEAN       found = FALSE;
    
    HDMKEY        clusParamKey = NULL;
    BOOLEAN       openedClusParamKey = FALSE;
    HDMKEY        networkKey = NULL;
    BOOLEAN       openedNetworkKey = FALSE;
    HDMKEY        netParamKey = NULL;
    BOOLEAN       openedNetParamKey = FALSE;


    //
    // Open the network key, if necessary.
    //
    networkKey = *NetworkKey;

    if (networkKey == NULL) {

        networkKey = DmOpenKey(
                         DmNetworksKey, 
                         networkId, 
                         MAXIMUM_ALLOWED
                         );
        if (networkKey == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] Failed to open key for network %1!ws!, "
                "status %2!u!\n",
                networkId, status
                );
            goto error_exit;
        } else {
            openedNetworkKey = TRUE;
        }
    }

    //
    // Open the network parameters key, if necessary.
    //
    netParamKey = *NetworkParametersKey;

    if (netParamKey == NULL) {

        netParamKey = DmOpenKey(
                          networkKey, 
                          CLUSREG_KEYNAME_PARAMETERS, 
                          MAXIMUM_ALLOWED
                          );
        if (netParamKey == NULL) {
            status = GetLastError();
#if CLUSTER_BETA
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] Failed to find Parameters key "
                "for network %1!ws!, status %2!u!. Using default "
                "multicast parameters.\n",
                networkId, status
                );
#endif // CLUSTER_BETA
        } else {
            openedNetParamKey = TRUE;
        }
    }

    //
    // If we found a network parameters key, check for the
    // disabled value.
    //
    if (netParamKey != NULL) {

        status = DmQueryValue(
                     netParamKey,
                     CLUSREG_NAME_NET_DISABLE_MULTICAST,
                     &type,
                     (LPBYTE) &disabled,
                     &len
                     );
        if (status == ERROR_SUCCESS) {
            if (type != REG_DWORD) {
                ClRtlLogPrint(LOG_NOISE, 
                    "[NM] Unexpected type (%1!u!) for network "
                    "%2!ws! %3!ws!, status %4!u!. Checking "
                    "cluster parameters ...\n",
                    type, networkId, 
                    CLUSREG_NAME_NET_DISABLE_MULTICAST, status
                    );
            } else {
                found = TRUE;
            }
        }
    }

    //
    // If we were unsuccessful at finding a value in the
    // network parameters key, try under the cluster
    // parameters key.
    //
    if (!found) {

        //
        // Open the cluster parameters key, if necessary.
        //
        clusParamKey = *NetworkParametersKey;

        if (clusParamKey == NULL) {

            clusParamKey = DmOpenKey(
                               DmClusterParametersKey, 
                               CLUSREG_KEYNAME_PARAMETERS, 
                               KEY_READ
                               );
            if (clusParamKey == NULL) {
                status = GetLastError();
#if CLUSTER_BETA
                ClRtlLogPrint(LOG_NOISE, 
                    "[NM] Failed to find cluster Parameters "
                    "key, status %1!u!.\n",
                    status
                    );
#endif // CLUSTER_BETA
            } else {
                openedClusParamKey = TRUE;
                
                //
                // Query the disabled value under the cluster parameters
                // key.
                //
                status = DmQueryValue(
                             clusParamKey,
                             CLUSREG_NAME_CLUSTER_DISABLE_MULTICAST,
                             &type,
                             (LPBYTE) &disabled,
                             &len
                             );
                if (status != ERROR_SUCCESS) {
#if CLUSTER_BETA
                    ClRtlLogPrint(LOG_NOISE, 
                        "[NM] Failed to read cluster "
                        "%1!ws! value, status %2!u!. "
                        "Using default value ...\n",
                        CLUSREG_NAME_CLUSTER_DISABLE_MULTICAST, status
                        );
#endif // CLUSTER_BETA
                }
                else if (type != REG_DWORD) {
                    ClRtlLogPrint(LOG_UNUSUAL, 
                        "[NM] Unexpected type (%1!u!) for cluster "
                        "%2!ws!, status %3!u!. "
                        "Using default value ...\n",
                        type, CLUSREG_NAME_CLUSTER_DISABLE_MULTICAST, status
                        );
                } else {
                    found = TRUE;
                }
            }
        }
    }

    //
    // Return what we found. If we didn't find anything, 
    // return the default.
    //
    if (found) {
        *Disabled = disabled;
    } else {
        *Disabled = NMP_MCAST_DISABLED_DEFAULT;
    }

    *NetworkKey = networkKey;
    networkKey = NULL;
    *NetworkParametersKey = netParamKey;
    netParamKey = NULL;
    *ClusterParametersKey = clusParamKey;
    clusParamKey = NULL;

    //
    // Even if we didn't find anything, we return success
    // because we have a default. Note that we return error
    // if a fundamental operation (such as locating the
    // network key) failed.
    //
    status = ERROR_SUCCESS;

error_exit:

    if (openedClusParamKey && clusParamKey != NULL) {
        DmCloseKey(clusParamKey);
        clusParamKey = NULL;
    }

    if (openedNetParamKey && netParamKey != NULL) {
        DmCloseKey(netParamKey);
        netParamKey = NULL;
    }

    if (openedNetworkKey && networkKey != NULL) {
        DmCloseKey(networkKey);
        networkKey = NULL;
    }

    return(status);

} // NmpQueryMulticastDisabled


DWORD
NmpQueryMulticastConfigType(
    IN     PNM_NETWORK        Network,
    IN     HDMKEY             NetworkKey,
    IN OUT HDMKEY           * NetworkParametersKey,
       OUT NM_MCAST_CONFIG  * ConfigType
    )
/*++

Routine Description:

    Reads the multicast config type from the cluster
    database.
    
--*/
{
    LPCWSTR       networkId = OmObjectId(Network);
    HDMKEY        netParamKey = NULL;
    BOOLEAN       openedNetParamKey = FALSE;
    DWORD         type;
    DWORD         len = sizeof(*ConfigType);
    DWORD         status;

#if CLUSTER_BETA
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Querying multicast address config type for "
        "network %1!ws! from cluster database.\n",
        networkId
        );
#endif // CLUSTER_BETA

    if (Network == NULL || NetworkKey == NULL) {
        status = ERROR_INVALID_PARAMETER;
        goto error_exit;
    }

    //
    // Open the network parameters key, if necessary.
    //
    netParamKey = *NetworkParametersKey;

    if (netParamKey == NULL) {

        netParamKey = DmOpenKey(
                          NetworkKey, 
                          CLUSREG_KEYNAME_PARAMETERS, 
                          MAXIMUM_ALLOWED
                          );
        if (netParamKey == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] Failed to find Parameters key "
                "for network %1!ws!, status %2!u!. Using default "
                "multicast parameters.\n",
                networkId, status
                );
            goto error_exit;
        } else {
            openedNetParamKey = TRUE;
        }
    }

    //
    // Read the config type.
    //
    status = DmQueryValue(
                 netParamKey,
                 CLUSREG_NAME_NET_MCAST_CONFIG_TYPE,
                 &type,
                 (LPBYTE) ConfigType,
                 &len
                 );
    if (status == ERROR_SUCCESS) {
        if (type != REG_DWORD) {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] Unexpected type (%1!u!) for network "
                "%2!ws! %3!ws!, status %4!u!. Checking "
                "cluster parameters ...\n",
                type, networkId, 
                CLUSREG_NAME_NET_MCAST_CONFIG_TYPE, status
                );
            status = ERROR_DATATYPE_MISMATCH;
            goto error_exit;
        }
    } else {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Failed to query network %2!ws! %3!ws! "
            "from cluster database, status %4!u!.\n",
            networkId, CLUSREG_NAME_NET_MCAST_CONFIG_TYPE, status
            );
        goto error_exit;
    }

    *NetworkParametersKey = netParamKey;
    netParamKey = NULL;

#if CLUSTER_BETA
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Found multicast address config type %1!u! "
        "for network %2!ws! in cluster database.\n",
        *ConfigType, networkId
        );
#endif // CLUSTER_BETA

error_exit:

    if (openedNetParamKey && netParamKey != NULL) {
        DmCloseKey(netParamKey);
        netParamKey = NULL;
    }

    return(status);

} // NmpQueryMulticastConfigType


DWORD
NmpQueryMulticastKeySalt(
    IN     PNM_NETWORK   Network,
    IN     HDMKEY        NetworkKey,
    IN OUT HDMKEY      * NetworkParametersKey,
    IN OUT PVOID       * Salt,
    IN OUT ULONG       * SaltLength
    )
/*++

Routine Description:

    Reads the multicast key salt from the cluster 
    database.
    
Notes:

    Must not be called with NM lock held.
    
--*/
{
    LPCWSTR       networkId = OmObjectId(Network);
    HDMKEY        netParamKey = NULL;
    BOOLEAN       openedNetParamKey = FALSE;
    DWORD         type;
    PUCHAR        salt = NULL;
    DWORD         saltLength;
    DWORD         status;

#if CLUSTER_BETA
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Querying multicast salt for "
        "network %1!ws! from cluster database.\n",
        networkId
        );
#endif // CLUSTER_BETA

    if (Network == NULL || NetworkKey == NULL) {
        status = ERROR_INVALID_PARAMETER;
        goto error_exit;
    }

    //
    // Open the network parameters key, if necessary.
    //
    netParamKey = *NetworkParametersKey;

    if (netParamKey == NULL) {

        netParamKey = DmOpenKey(
                          NetworkKey, 
                          CLUSREG_KEYNAME_PARAMETERS, 
                          MAXIMUM_ALLOWED
                          );
        if (netParamKey == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] Failed to find Parameters key "
                "for network %1!ws!, status %2!u!. Using default "
                "multicast parameters.\n",
                networkId, status
                );
            goto error_exit;
        } else {
            openedNetParamKey = TRUE;
        }
    }

    //
    // Allocate a buffer for the salt, if necessary.
    //
    salt = *Salt;
    saltLength = *SaltLength;

    if (salt != NULL && saltLength != sizeof(FILETIME)) {
        MIDL_user_free(salt);
        salt = NULL;
        saltLength = 0;
        *SaltLength = 0;
    }

    if (salt == NULL) {
        saltLength = sizeof(FILETIME);
        salt = MIDL_user_allocate(saltLength);
        if (salt == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to allocate buffer for multicast "
                "salt for network %1!ws!.\n",
                networkId
                );
            goto error_exit;
        }
    }

    //
    // Query the salt value from the cluster database.
    //
    status = DmQueryValue(
                 netParamKey,
                 CLUSREG_NAME_NET_MULTICAST_KEY_SALT,
                 &type,
                 (LPBYTE) salt,
                 &saltLength
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to read multicast key salt for "
            "network %1!ws! from cluster database, "
            "status %2!u!. Using default.\n",
            networkId, status
            );
        goto error_exit;
    } else if (type != REG_BINARY) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Unexpected type (%1!u!) for network "
            "%2!ws! %3!ws!. Using default.\n",
            type, networkId, CLUSREG_NAME_NET_MULTICAST_KEY_SALT
            );
        status = ERROR_DATATYPE_MISMATCH;
        goto error_exit;
    }

    *NetworkParametersKey = netParamKey;
    netParamKey = NULL;
    *Salt = salt;
    salt = NULL;
    *SaltLength = saltLength;

#if CLUSTER_BETA
    //
    // Display the salt.
    //
    {
        LPWSTR displayBuf = NULL;

        displayBuf = NmpCreateLogString(*Salt, *SaltLength);
        if (displayBuf != NULL) {

            ClRtlLogPrint(LOG_NOISE,
                "[NM] Found multicast key salt (length %1!u!): %2!ws!.\n",
                saltLength, displayBuf
                );

            LocalFree(displayBuf);
        }
    }
#endif // CLUSTER_BETA

error_exit:

    if (openedNetParamKey && netParamKey != NULL) {
        DmCloseKey(netParamKey);
        netParamKey = NULL;
    }

    if (salt != NULL) {
        MIDL_user_free(salt);
        salt = NULL;
    }

    return(status);

} // NmpQueryMulticastKeySalt


DWORD
NmpGenerateMulticastKeySalt(
    IN     PNM_NETWORK   Network,
    IN OUT PVOID       * Salt,
    IN OUT ULONG       * SaltLength
    )
/*++

Routine Description:

    Generates a default multicast key salt.
    
Notes:

    Must not be called with NM lock held.
    
--*/
{
    LPCWSTR       networkId = OmObjectId(Network);
    HDMKEY        netParamKey = NULL;
    DWORD         createDisposition;
    PUCHAR        salt;
    DWORD         saltLength;
    DWORD         status;

#if CLUSTER_BETA
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Generating multicast key salt for "
        "network %1!ws!.\n",
        networkId
        );
#endif // CLUSTER_BETA

    //
    // Allocate a buffer for the salt, if necessary.
    //
    salt = *Salt;
    saltLength = *SaltLength;

    if (salt != NULL && saltLength != sizeof(FILETIME)) {
        MIDL_user_free(salt);
        salt = NULL;
        saltLength = 0;
        *SaltLength = 0;
    }

    if (salt == NULL) {
        saltLength = sizeof(FILETIME);
        salt = MIDL_user_allocate(saltLength);
        if (salt == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to allocate buffer for multicast "
                "salt for network %1!ws!.\n",
                networkId
                );
            goto error_exit;
        }
    }

    //
    // Create the salt. Use the current time.
    //
    GetSystemTimeAsFileTime((LPFILETIME) salt);

    *Salt = salt;
    salt = NULL;
    *SaltLength = saltLength;

    status = ERROR_SUCCESS;

#if CLUSTER_BETA
    //
    // Display the salt.
    //
    {
        LPWSTR displayBuf = NULL;

        displayBuf = NmpCreateLogString(*Salt, *SaltLength);
        if (displayBuf != NULL) {

            ClRtlLogPrint(LOG_NOISE,
                "[NM] Generated multicast key salt (length %1!u!): %2!ws!.\n",
                saltLength, displayBuf
                );

            LocalFree(displayBuf);
        }
    }
#endif // CLUSTER_BETA

error_exit:

    if (salt != NULL) {
        MIDL_user_free(salt);
        salt = NULL;
    }

    return(status);

} // NmpGenerateMulticastKeySalt


DWORD
NmpMulticastNotifyConfigChange(
    IN     PNM_NETWORK                        Network,
    IN     HDMKEY                             NetworkKey,
    IN OUT HDMKEY                           * NetworkParametersKey,
    IN     PNM_NETWORK_MULTICAST_PARAMETERS   Parameters,
    IN     PVOID                              PropBuffer,
    IN     DWORD                              PropBufferSize
    )
/*++

Routine Description:

    Notify other cluster nodes of the new multicast
    configuration parameters by initiating a GUM
    update.
    
    If this is a manual update, there may be other
    properties to distribute in the GUM update.

Notes:

    Cannot be called with NM lock held.

--*/
{
    DWORD                        status = ERROR_SUCCESS;
    LPCWSTR                      networkId = OmObjectId(Network);
    PNM_NETWORK_MULTICAST_UPDATE update = NULL;
    DWORD                        updateSize = 0;


    ClRtlLogPrint(LOG_NOISE,
        "[NM] Notifying other nodes of type %1!u! multicast "
        "reconfiguration for network %2!ws!.\n",
        Parameters->ConfigType, networkId
        );

    status = NmpMulticastCreateUpdateFromParameters(
                 Network,
                 Parameters,
                 &update,
                 &updateSize
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to build GUM update for "
            "multicast configuration of network %1!ws!, "
            "status %2!u!.\n",
            networkId, status
            );
        goto error_exit;
    }

    //
    // BUGBUG: Disseminate database updates to downlevel
    //         nodes!
    //

    //
    // Send junk if the prop buffer is empty.
    //
    if (PropBuffer == NULL || PropBufferSize == 0) {
        PropBuffer = &updateSize;
        PropBufferSize = sizeof(updateSize);
    }

    //
    // Send the update.
    //
    status = GumSendUpdateEx(
                 GumUpdateMembership,
                 NmUpdateSetNetworkMulticastConfiguration,
                 4,
                 NM_WCSLEN(networkId),
                 networkId,
                 updateSize,
                 update,
                 PropBufferSize,
                 PropBuffer,
                 sizeof(PropBufferSize),
                 &PropBufferSize
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to send GUM update for "
            "multicast configuration of network %1!ws!, "
            "status %2!u!.\n",
            networkId, status
            );
        goto error_exit;
    }

error_exit:

    if (update != NULL) {
        MIDL_user_free(update);
        update = NULL;
    }

    return(status);

} // NmpMulticastNotifyConfigChange


DWORD
NmpWriteMulticastParameters(
    IN  PNM_NETWORK                      Network,
    IN  HDMKEY                           NetworkKey,
    IN  HDMKEY                           NetworkParametersKey,
    IN  HLOCALXSACTION                   Xaction,
    IN  PNM_NETWORK_MULTICAST_PARAMETERS Parameters
    )
{
    DWORD                       status = ERROR_SUCCESS;
    LPCWSTR                     networkId = OmObjectId(Network);
    LPWSTR                      failValueName = NULL;

    CL_ASSERT(NetworkKey != NULL);
    CL_ASSERT(NetworkParametersKey != NULL);
    CL_ASSERT(Xaction != NULL);

#if CLUSTER_BETA
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Writing multicast parameters for "
        "network %1!ws! to cluster database.\n",
        networkId
        );
#endif // CLUSTER_BETA

    //
    // Address.
    //
    if (Parameters->Address != NULL) {
        status = DmLocalSetValue(
                     Xaction,
                     NetworkParametersKey,
                     CLUSREG_NAME_NET_MULTICAST_ADDRESS,
                     REG_SZ,
                     (BYTE *) Parameters->Address,
                     NM_WCSLEN(Parameters->Address)
                     );
        if (status != ERROR_SUCCESS) {
            failValueName = CLUSREG_NAME_NET_MULTICAST_ADDRESS;
            goto error_exit;
        }
    }

    //
    // Salt.
    //
    if (Parameters->Salt != NULL) {
        status = DmLocalSetValue(
                     Xaction,
                     NetworkParametersKey,
                     CLUSREG_NAME_NET_MULTICAST_KEY_SALT,
                     REG_BINARY,
                     (BYTE *) Parameters->Salt,
                     Parameters->SaltLength
                     );
        if (status != ERROR_SUCCESS) {
            failValueName = CLUSREG_NAME_NET_MULTICAST_KEY_SALT;
            goto error_exit;
        }
    }

    //
    // Lease server address.
    //
    if (Parameters->LeaseServer != NULL) {

        status = DmLocalSetValue(
                     Xaction,
                     NetworkParametersKey,
                     CLUSREG_NAME_NET_MCAST_SERVER_ADDRESS,
                     REG_SZ,
                     (BYTE *) Parameters->LeaseServer,
                     NM_WCSLEN(Parameters->LeaseServer)
                     );
        if (status != ERROR_SUCCESS) {
            failValueName = CLUSREG_NAME_NET_MCAST_SERVER_ADDRESS;
            goto error_exit;
        }
    }

    //
    // Client request id.
    //
    if (Parameters->LeaseRequestId.ClientUID != NULL &&
        Parameters->LeaseRequestId.ClientUIDLength > 0) {

        status = DmLocalSetValue(
                     Xaction,
                     NetworkParametersKey,
                     CLUSREG_NAME_NET_MCAST_REQUEST_ID,
                     REG_BINARY,
                     (BYTE *) Parameters->LeaseRequestId.ClientUID,
                     Parameters->LeaseRequestId.ClientUIDLength
                     );
        if (status != ERROR_SUCCESS) {
            failValueName = CLUSREG_NAME_NET_MCAST_REQUEST_ID;
            goto error_exit;
        }
    }

    //
    // Lease obtained.
    //
    status = DmLocalSetValue(
                 Xaction,
                 NetworkParametersKey,
                 CLUSREG_NAME_NET_MCAST_LEASE_OBTAINED,
                 REG_DWORD,
                 (BYTE *) &(Parameters->LeaseObtained),
                 sizeof(Parameters->LeaseObtained)
                 );
    if (status != ERROR_SUCCESS) {
        failValueName = CLUSREG_NAME_NET_MCAST_LEASE_OBTAINED;
        goto error_exit;
    }

    //
    // Lease expires.
    //
    status = DmLocalSetValue(
                 Xaction,
                 NetworkParametersKey,
                 CLUSREG_NAME_NET_MCAST_LEASE_EXPIRES,
                 REG_DWORD,
                 (BYTE *) &(Parameters->LeaseExpires),
                 sizeof(Parameters->LeaseExpires)
                 );
    if (status != ERROR_SUCCESS) {
        failValueName = CLUSREG_NAME_NET_MCAST_LEASE_EXPIRES;
        goto error_exit;
    }

    //
    // Config type.
    //
    status = DmLocalSetValue(
                 Xaction,
                 NetworkParametersKey,
                 CLUSREG_NAME_NET_MCAST_CONFIG_TYPE,
                 REG_DWORD,
                 (BYTE *) &(Parameters->ConfigType),
                 sizeof(Parameters->ConfigType)
                 );
    if (status != ERROR_SUCCESS) {
        failValueName = CLUSREG_NAME_NET_MCAST_CONFIG_TYPE;
        goto error_exit;
    }

error_exit:
    
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to write %1!ws! value "
            "for network %2!ws!, status %3!u!.\n",
            failValueName, networkId, status
            );
    }

    return(status);

} // NmpWriteMulticastParameters


DWORD
NmpMulticastEnumerateScopes(
    IN  BOOLEAN              Requery,
    OUT PMCAST_SCOPE_ENTRY * ScopeList,
    OUT DWORD              * ScopeCount
    )
/*++

Routine Description:

    Call MADCAP API to enumerate multicast scopes.
    
--*/
{
    DWORD                    status;
    PMCAST_SCOPE_ENTRY       scopeList = NULL;
    DWORD                    scopeListLength;
    DWORD                    scopeCount = 0;

    //
    // Initialize MADCAP, if not done already.
    //
    if (!NmpMadcapClientInitialized) {
        DWORD madcapVersion = MCAST_API_CURRENT_VERSION;
        status = McastApiStartup(&madcapVersion);
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to initialize MADCAP API, "
                "status %1!u!.\n",
                status
                );
            return(status);
        }
        NmpMadcapClientInitialized = TRUE;
    }

    //
    // Enumerate the multicast scopes.
    //
    scopeList = NULL;
    scopeListLength = 0;

    do {

        PVOID   watchdogHandle;

        //
        // Set watchdog timer to try to catch bug 400242. Specify
        // timeout of 5 minutes (in milliseconds).
        //
        watchdogHandle = ClRtlSetWatchdogTimer(
                             5 * 60 * 1000,
                             L"McastEnumerateScopes (Bug 400242)"
                             );
        if (watchdogHandle == NULL) {
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Failed to set %1!u!ms watchdog timer for "
                "McastEnumerateScopes.\n",
                5 * 60 * 1000
                );
        }

        status = McastEnumerateScopes(
                     AF_INET,
                     Requery,
                     scopeList,
                     &scopeListLength,
                     &scopeCount
                     );

        //
        // Cancel watchdog timer.
        //
        if (watchdogHandle != NULL) {
            ClRtlCancelWatchdogTimer(watchdogHandle);
        }

        if ( (scopeList == NULL && status == ERROR_SUCCESS) ||
             (status == ERROR_MORE_DATA)
           ) {
            if (scopeList != NULL) {
                LocalFree(scopeList);
            }
            scopeList = LocalAlloc(LMEM_FIXED, scopeListLength);
            if (scopeList == NULL) {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Failed to allocate multicast scope list "
                    "of length %1!u!.\n",
                    scopeListLength
                    );
                status = ERROR_NOT_ENOUGH_MEMORY;
                break;
            } else {
                //
                // Call McastEnumerateScopes again with proper
                // size scopeList buffer.
                //
                Requery = FALSE;
                continue;
            }
        } else {
            //
            // McastEnumerateScopes failed with an unexpected
            // error. Bail out.
            //
            break;
        }

    } while (TRUE);

    if (status != ERROR_SUCCESS) {
        if (scopeList != NULL) {
            LocalFree(scopeList);
            scopeList = NULL;
            scopeCount = 0;
        }
    }

    *ScopeList = scopeList;
    *ScopeCount = scopeCount;

    return(status);

} // NmpMulticastEnumerateScopes


DWORD
NmpRandomizeLeaseRenewTime(
    IN     PNM_NETWORK        Network,
    IN     DWORD              BaseRenewTime,
    IN     DWORD              Window
    )
/*++

Routine Description:

    Randomizes the lease renew time within Window
    on either side of BaseRenewTime.
    
    Current algorithm favors the NM leader, which
    gets BaseRenewTime. Other nodes are
    spread out in the Window according to node id.
    The nodes are grouped tighter as the number
    of nodes grows, since the common case is only
    a few nodes.
    
Arguments:

    Network - network 
    
    BaseRenewTime - time when lease should be renewed
    
    Window - period on either side of BaseRenewTime
             during which lease could be renewed
             
Return value:

    Randomized lease renew time.
    
--*/
{
    DWORD         result = 0;
    DWORD         interval, delta;
    DWORD         index;
    static USHORT spread[] = 
        {0, 16, 8, 4, 12, 2, 6, 10, 14, 1, 3, 5, 7, 9, 11, 13, 15};

    if (BaseRenewTime == 0) {
        result = 0;
        goto error_exit;
    }

    if (Window == 0) {
        result = BaseRenewTime;
        goto error_exit;
    }

    interval = Window / ClusterDefaultMaxNodes;

    if (NmpLeaderNodeId == NmLocalNodeId) {
        result = BaseRenewTime;
    } else {
        if (interval == 0) {
            result = BaseRenewTime + Window;
        } else {
            if (NmLocalNodeId > sizeof(spread)/sizeof(spread[0]) - 1) {
                index = sizeof(spread)/sizeof(spread[0]) - 1;
            } else {
                index = NmLocalNodeId;
            }

            result = BaseRenewTime + spread[index] * interval;
        }
    }

error_exit:

    return(result);

} // NmpRandomizeLeaseRenewTime


DWORD
NmpCalculateLeaseRenewTime(
    IN     PNM_NETWORK        Network,
    IN     NM_MCAST_CONFIG    ConfigType,
    IN OUT time_t           * LeaseObtained,
    IN OUT time_t           * LeaseExpires
    )
/*++

Routine Description:

    Determines when to schedule a lease renewal, based
    on the lease obtained and expires times and whether
    the current lease was obtained from a MADCAP server.
    
    If the lease was obtained from a MADCAP server, the
    policy mimics DHCP client renewal behavior. A 
    renewal is scheduled for half the time until the
    lease expires. However, if the lease half-life is
    less than the renewal threshold, renew at the lease
    expiration time.
    
    If the address was selected after a MADCAP timeout,
    we still periodically query to make sure a MADCAP
    server doesn't suddenly appear on the network. In 
    this case, LeaseExpires and LeaseObtained will be 
    garbage, and we need to fill them in.
    
    If the address was configured by an administrator,
    return 0, indicating that the timer should not be set.
    
Return value:

    Relative NM ticks from current time that lease 
    renewal should be scheduled.
    
--*/
{
    time_t           currentTime;
    time_t           leaseExpires;
    time_t           leaseObtained;
    time_t           result = 0;
    time_t           window = 0;
    time_t           leaseHalfLife = 0;
    DWORD            dwResult = 0;
    DWORD            dwWindow = 0;

    currentTime = time(NULL);
    leaseExpires = *LeaseExpires;
    leaseObtained = *LeaseObtained;

    switch (ConfigType) {
    
    case NmMcastConfigManual:
        result = 0;
        *LeaseObtained = 0;
        *LeaseExpires = 0;
        break;
    
    case NmMcastConfigMadcap:
        if (leaseExpires < currentTime) {
            result = 1;
        } else if (leaseExpires <= leaseObtained) {
            result = 1;
        } else {
            leaseHalfLife = (leaseExpires - leaseObtained) / 2;
            if (leaseHalfLife < NMP_MCAST_LEASE_RENEWAL_THRESHOLD) {

                // The half life is too small.
                result = leaseExpires - currentTime;
                if (result == 0) {
                    result = 1;
                }
                window = result / 2;
            } else {

                // The half life is acceptable.
                result = leaseHalfLife;
                window = NMP_MCAST_LEASE_RENEWAL_WINDOW;
                if (result + window > leaseExpires) {
                    window = leaseExpires - result;
                }
            }
        }
        break;
    
    case NmMcastConfigAuto:
        result = NMP_MADCAP_REQUERY_PERDIOD;
        window = NMP_MCAST_LEASE_RENEWAL_WINDOW;

        //
        // Return the lease expiration time to be
        // written into the cluster database.
        //
        *LeaseObtained = currentTime;
        *LeaseExpires = currentTime + NMP_MADCAP_REQUERY_PERDIOD;
        break;
    
    default:
        CL_ASSERT(FALSE);
        result = 0;
        break;
    }

    NMP_TIME_TO_DWORD(result, dwResult);
    NMP_TIME_TO_DWORD(window, dwWindow);

    dwResult = NmpRandomizeLeaseRenewTime(
                   Network,
                   NMP_MADCAP_TO_NM_TIME(dwResult),
                   NMP_MADCAP_TO_NM_TIME(dwWindow)
                   );

    return(dwResult);

} // NmpCalculateLeaseRenewTime


VOID
NmpReportMulticastAddressLease(
    IN  PNM_NETWORK                      Network,
    IN  PNM_NETWORK_MULTICAST_PARAMETERS Parameters,
    IN  LPWSTR                           OldAddress
    )
/*++

Routine Description:

    Write an event log entry, if not repetitive,
    reporting that a multicast address lease was
    obtained.
    
    The repetitive criteria is that the address
    changed.
    
--*/
{
    BOOLEAN               writeLogEntry = FALSE;
    LPCWSTR               nodeName;
    LPCWSTR               networkName;

    if (Parameters->Address == NULL || Parameters->LeaseServer == NULL) {
        return;
    }

    if (OldAddress == NULL || wcscmp(Parameters->Address, OldAddress) != 0) {
        
        networkName = OmObjectName(Network);
        nodeName  = OmObjectName(Network->LocalInterface->Node);

        ClusterLogEvent4(
            LOG_NOISE,
            LOG_CURRENT_MODULE,
            __FILE__,
            __LINE__,
            NM_EVENT_OBTAINED_MULTICAST_LEASE,
            0,
            NULL,
            nodeName,
            Parameters->Address,
            networkName,
            Parameters->LeaseServer
            );
    }

    return;

} // NmpReportMulticastAddressLease


VOID
NmpReportMulticastAddressChoice(
    IN  PNM_NETWORK        Network,
    IN  LPWSTR             Address,
    IN  LPWSTR             OldAddress
    )
/*++

Routine Description:

    Write an event log entry, if not repetitive,
    reporting that a multicast address was
    automatically selected for this network.
    
    The repetitive criteria is that our previous
    config type was anything other than automatic
    selection or the chosen address is different.
    
Notes:

    Must not be called with NM lock held.    
    
--*/
{
    DWORD                 status;
    LPCWSTR               networkId = OmObjectId(Network);
    HDMKEY                networkKey = NULL;
    HDMKEY                netParamKey = NULL;

    NM_MCAST_CONFIG       configType;
    BOOLEAN               writeLogEntry = FALSE;
    LPCWSTR               nodeName;
    LPCWSTR               networkName;


    if (Address == NULL) {
        writeLogEntry = FALSE;
        goto error_exit;
    }

    if (OldAddress == NULL || wcscmp(Address, OldAddress) != 0) {
        writeLogEntry = TRUE;
    }

    if (!writeLogEntry) {

        //
        // Open the network key.
        //
        networkKey = DmOpenKey(
                         DmNetworksKey, 
                         networkId, 
                         MAXIMUM_ALLOWED
                         );
        if (networkKey == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] Failed to open key for network %1!ws!, "
                "status %2!u!\n",
                networkId, status
                );
            goto error_exit;
        }

        status = NmpQueryMulticastConfigType(
                     Network,
                     networkKey,
                     &netParamKey,
                     &configType
                     );
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] Failed to query multicast config type "
                "for network %1!ws!, status %2!u!\n",
                networkId, status
                );
            goto error_exit;
        }

        if (configType != NmMcastConfigAuto) {
            writeLogEntry = TRUE;
        }
    }

    if (writeLogEntry) {

        networkName = OmObjectName(Network);
        nodeName  = OmObjectName(Network->LocalInterface->Node);

        CsLogEvent3(
            LOG_NOISE,
            NM_EVENT_MULTICAST_ADDRESS_CHOICE,
            nodeName,
            Address,
            networkName
            );
    }

error_exit:

    if (networkKey != NULL) {
        DmCloseKey(networkKey);
        networkKey = NULL;
    }

    if (netParamKey != NULL) {
        DmCloseKey(netParamKey);
        netParamKey = NULL;
    }

    return;

} // NmpReportMulticastAddressChoice


VOID
NmpReportMulticastAddressFailure(
    IN  PNM_NETWORK               Network,
    IN  DWORD                     Error
    )
/*++

Routine Description:

    Write an event log entry reporting failure
    to obtain a multicast address for specified 
    network with specified error.
    
--*/
{
    LPCWSTR      nodeName = OmObjectName(Network->LocalInterface->Node);
    LPCWSTR      networkName = OmObjectName(Network);
    WCHAR        errorString[12];

    wsprintfW(&(errorString[0]), L"%u", Error);

    CsLogEvent3(
        LOG_UNUSUAL,
        NM_EVENT_MULTICAST_ADDRESS_FAILURE,
        nodeName,
        networkName,
        errorString
        );

    return;

} // NmpReportMulticastAddressFailure


DWORD
NmpGetMulticastAddressSelectionRange(
    IN     PNM_NETWORK            Network,
    IN     HDMKEY                 NetworkKey,
    IN OUT HDMKEY               * NetworkParametersKey,
    OUT    ULONG                * RangeLower,
    OUT    ULONG                * RangeUpper
    )
/*++

Routine Description:

    Queries the cluster database to determine if a selection
    range has been configured. If both lower and upper bounds
    of range are valid, returns that range. Otherwise, returns
    default range.
    
Notes:

    Must not be called with NM lock held.
    
--*/
{
    DWORD         status;
    LPCWSTR       networkId = OmObjectId(Network);
    HDMKEY        netParamKey = NULL;
    BOOLEAN       openedNetParamKey = FALSE;
    LPWSTR        addr = NULL;
    DWORD         addrLen;
    DWORD         size;
    DWORD         hllower, hlupper;

    if (Network == NULL || NetworkKey == NULL) {
        status = ERROR_INVALID_PARAMETER;
        goto error_exit;
    }

#if CLUSTER_BETA
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Querying multicast address selection range "
        "for network %1!ws! from cluster database.\n",
        networkId
        );
#endif // CLUSTER_BETA
    //
    // Open the network parameters key, if necessary.
    //
    netParamKey = *NetworkParametersKey;

    if (netParamKey == NULL) {

        netParamKey = DmOpenKey(
                          NetworkKey, 
                          CLUSREG_KEYNAME_PARAMETERS, 
                          MAXIMUM_ALLOWED
                          );
        if (netParamKey == NULL) {
            status = GetLastError();
#if CLUSTER_BETA
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] Failed to find Parameters key "
                "for network %1!ws!, status %2!u!. "
                "Using default multicast address range.\n",
                networkId, status
                );
#endif // CLUSTER_BETA
            goto usedefault;
        } else {
            openedNetParamKey = TRUE;
        }
    }

    //
    // Query for the lower bound of the range.
    //
    addr = NULL;
    addrLen = 0;
    size = 0;
    status = NmpQueryString(
                 netParamKey,
                 CLUSREG_NAME_NET_MCAST_RANGE_LOWER,
                 REG_SZ,
                 &addr,
                 &addrLen,
                 &size
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Failed to read lower bound of "
            "multicast address selection range for "
            "network %1!ws! from cluster database, "
            "status %2!u!. Using default.\n",
            networkId, status
            );
        goto usedefault;
    }

    status = ClRtlTcpipStringToAddress(addr, RangeLower);
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Failed to convert lower bound of "
            "multicast address selection range %1!ws! for "
            "network %2!ws! into TCP/IP address, "
            "status %3!u!. Using default.\n",
            addr, networkId, status
            );
        goto usedefault;
    }

    hllower = ntohl(*RangeLower);
    if (!IN_CLASSD(hllower)) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Lower bound of multicast address "
            "selection range %1!ws! for network %2!ws! "
            "is not a class D IPv4 address. "
            "Using default.\n",
            addr, networkId
            );
        goto usedefault;
    }

    //
    // Query for the upper bound of the range.
    //
    size = 0;
    status = NmpQueryString(
                 netParamKey,
                 CLUSREG_NAME_NET_MCAST_RANGE_UPPER,
                 REG_SZ,
                 &addr,
                 &addrLen,
                 &size
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Failed to read upper bound of "
            "multicast address selection range for "
            "network %1!ws! from cluster database, "
            "status %2!u!. Using default.\n",
            networkId, status
            );
        goto usedefault;
    }

    status = ClRtlTcpipStringToAddress(addr, RangeUpper);
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Failed to convert upper bound of "
            "multicast address selection range %1!ws! for "
            "network %2!ws! into TCP/IP address, "
            "status %3!u!. Using default.\n",
            addr, networkId, status
            );
        goto usedefault;
    }

    hlupper = ntohl(*RangeUpper);
    if (!IN_CLASSD(hlupper)) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Upper bound of multicast address "
            "selection range %1!ws! for network %2!ws! "
            "is not a class D IPv4 address. "
            "Using default.\n",
            addr, networkId
            );
        goto usedefault;
    }

    //
    // Make sure it's a legitimate range.
    //
    if (hllower >= hlupper) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Multicast address selection range "
            "[%1!u!.%2!u!.%3!u!.%4!u!, %5!u!.%6!u!.%7!u!.%8!u!] "
            "for network %2!ws! is not valid. "
            "Using default.\n",
            NmpIpAddrPrintArgs(*RangeLower), 
            NmpIpAddrPrintArgs(*RangeUpper), networkId
            );
        goto usedefault;
    }

    status = ERROR_SUCCESS;

    goto error_exit;

usedefault:

    *RangeLower = NMP_MCAST_DEFAULT_RANGE_LOWER;
    *RangeUpper = NMP_MCAST_DEFAULT_RANGE_UPPER;

    status = ERROR_SUCCESS;

error_exit:

    if (status == ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Using multicast address selection range "
            "[%1!u!.%2!u!.%3!u!.%4!u!, %5!u!.%6!u!.%7!u!.%8!u!] "
            "for network %9!ws! in cluster database.\n",
            NmpIpAddrPrintArgs(*RangeLower), 
            NmpIpAddrPrintArgs(*RangeUpper), networkId
            );

        *NetworkParametersKey = netParamKey;
        netParamKey = NULL;
    }

    if (openedNetParamKey && netParamKey != NULL) {
        DmCloseKey(netParamKey);
        netParamKey = NULL;
    }

    if (addr != NULL) {
        MIDL_user_free(addr);
        addr = NULL;
    }

    return(status);

} // NmpGetMulticastAddressSelectionRange


DWORD
NmpMulticastExcludeRange(
    IN OUT PLIST_ENTRY         SelectionRange,
    IN     DWORD               HlLower,
    IN     DWORD               HlUpper
    )
/*++

Routine Description:

    Exclude range defined by (HlLower, HlUpper) from
    list of selection intervals in SelectionRange.
    
Arguments:

    SelectionRange - sorted list of non-overlapping
                     selection intervals
    
    HlLower - lower bound of exclusion in host format
    
    HlUpper - upper bound of exclusion in host format
    
--*/
{
    PNM_MCAST_RANGE_INTERVAL interval;
    PNM_MCAST_RANGE_INTERVAL newInterval;
    PLIST_ENTRY              entry;

    // Determine if the exclusion overlaps with any interval.
    for (entry = SelectionRange->Flink;
         entry != SelectionRange;
         entry = entry->Flink) {

        interval = CONTAINING_RECORD(
                       entry,
                       NM_MCAST_RANGE_INTERVAL,
                       Linkage
                       );

        if (HlLower < interval->hlLower &&
            HlUpper < interval->hlUpper) {

            // Exclusion completely misses below interval.
            // Since list is sorted, there is no possibility
            // of a matching interval farther down list.
            break;
        }

        else if (HlLower > interval->hlUpper) {

            // Exclusion completely misses above interval.
            // There might be matching intervals later
            // in sorted list.
        }

        else if (HlLower <= interval->hlLower &&
                 HlUpper >= interval->hlUpper) {

            // Exclusion completely covers interval.
            // Remove interval.
            RemoveEntryList(entry);
        }

        else if (HlLower > interval->hlLower &&
                 HlUpper < interval->hlUpper) {

            // Exclusion splits interval.
            newInterval = LocalAlloc(LMEM_FIXED, sizeof(*newInterval));
            if (newInterval == NULL) {
                return(ERROR_NOT_ENOUGH_MEMORY);
            }

            newInterval->hlLower = HlUpper+1;
            newInterval->hlUpper = interval->hlUpper;

            interval->hlUpper = HlLower-1;

            // Insert the new interval after the current interval
            InsertHeadList(entry, &newInterval->Linkage);

            // We can skip the new interval because we already
            // know how it compares to the exclusion.
            entry = &newInterval->Linkage;
            continue;
        }

        else if (HlLower <= interval->hlLower) {

            // Exclusion overlaps lower part of interval. Shrink
            // interval from below.
            interval->hlLower = HlUpper + 1;
        }

        else {

            // Exclusion overlaps upper part of interval. Shrink
            // interval from above.
            interval->hlUpper = HlLower - 1;
        }
    }

    return(ERROR_SUCCESS);

} // NmpMulticastExcludeRange


BOOLEAN
NmpMulticastAddressInRange(
    IN  PLIST_ENTRY    SelectionRange,
    IN  LPWSTR         McastAddress
    )
/*++

Routine Description:

    Determines if McastAddress is in one of range intervals.
    
--*/
{
    DWORD                    mcastAddress;
    PNM_MCAST_RANGE_INTERVAL interval;
    PLIST_ENTRY              entry;

    // Convert the address from a string into an address.
    if (ClRtlTcpipStringToAddress(
            McastAddress, 
            &mcastAddress
            ) != ERROR_SUCCESS) {
        return(FALSE);
    }

    mcastAddress = ntohl(mcastAddress);

    // Walk the list of intervals.
    for (entry = SelectionRange->Flink;
         entry != SelectionRange;
         entry = entry->Flink) {

        interval = CONTAINING_RECORD(
                       entry,
                       NM_MCAST_RANGE_INTERVAL,
                       Linkage
                       );

        if (mcastAddress >= interval->hlLower &&
            mcastAddress <= interval->hlUpper) {
            return(TRUE);
        }

        else if (mcastAddress < interval->hlLower) {

            // Address is below current interval.
            // Since interval list is sorted in
            // increasing order, there is no chance
            // of a match later in list.
            break;
        }
    }

    return(FALSE);

} // NmpMulticastAddressInRange


DWORD
NmpMulticastAddressRangeSize(
    IN  PLIST_ENTRY  SelectionRange
    )
/*++

Routine Description:

    Returns size of selection range.
    
--*/
{
    PNM_MCAST_RANGE_INTERVAL interval;
    PLIST_ENTRY              entry;
    DWORD                    size = 0;

    // Walk the list of intervals.
    for (entry = SelectionRange->Flink;
         entry != SelectionRange;
         entry = entry->Flink) {

        interval = CONTAINING_RECORD(
                       entry,
                       NM_MCAST_RANGE_INTERVAL,
                       Linkage
                       );

        size += NmpMulticastRangeIntervalSize(interval);
    }

    return(size);

} // NmpMulticastAddressRangeSize


DWORD
NmpMulticastRangeOffsetToAddress(
    IN  PLIST_ENTRY          SelectionRange,
    IN  DWORD                Offset
    )
/*++

Routine Description:

    Returns the address that is Offset into the
    SelectionRange. The address is returned in
    host format.
    
    If SelectionRange is empty, returns 0.
    If Offset falls outside of non-empty range,
    returns upper or lower boundary of selection
    range.
    
--*/
{
    PNM_MCAST_RANGE_INTERVAL interval;
    PLIST_ENTRY              entry;
    DWORD                    address = 0;

    // Walk the list of intervals.
    for (entry = SelectionRange->Flink;
         entry != SelectionRange;
         entry = entry->Flink) {

        interval = CONTAINING_RECORD(
                       entry,
                       NM_MCAST_RANGE_INTERVAL,
                       Linkage
                       );

        address = interval->hlLower;

        if (address + Offset <= interval->hlUpper) {
            address = address + Offset;
            break;
        } else {
            address = interval->hlUpper;
            Offset -= NmpMulticastRangeIntervalSize(interval);
        }
    }

    return(address);

} // NmpMulticastRangeOffsetToAddress


VOID
NmpMulticastFreeSelectionRange(
    IN  PLIST_ENTRY   SelectionRange
    )
{
    PNM_MCAST_RANGE_INTERVAL interval;
    PLIST_ENTRY              entry;

    while (!IsListEmpty(SelectionRange)) {

        entry = RemoveHeadList(SelectionRange);
        
        interval = CONTAINING_RECORD(
                       entry,
                       NM_MCAST_RANGE_INTERVAL,
                       Linkage
                       );

        LocalFree(interval);
    }

    return;

} // NmpMulticastFreeSelectionRange


DWORD
NmpChooseMulticastAddress(
    IN  PNM_NETWORK                       Network,
    OUT PNM_NETWORK_MULTICAST_PARAMETERS  Parameters
    )
/*++

Routine Description:

    Choose a default multicast address and fill in 
    Parameters appropriately.
            
    If there is already a valid multicast address in
    the selection range stored in the cluster database, 
    continue to use it.
    
    If there is not already a valid multicast address,
    choose an address within the multicast address range
    by hashing on the last few bytes of the network id
    GUID.
    
Arguments:

    Network - network address is being chosen for

    Parameters - configuration parameters with new address    
    
--*/
{
    LPCWSTR                  networkId = OmObjectId(Network);
    DWORD                    status = ERROR_SUCCESS;
    HDMKEY                   networkKey = NULL;
    HDMKEY                   netParamKey = NULL;

    PMCAST_SCOPE_ENTRY       scopeList = NULL;
    DWORD                    scopeCount;

    LIST_ENTRY               selectionRange;
    PNM_MCAST_RANGE_INTERVAL interval;
    DWORD                    index;
    DWORD                    hlLower;
    DWORD                    hlUpper;
    DWORD                    networkAddress;
    DWORD                    networkSubnet;

    UUID                     networkIdGuid;
    DWORD                    rangeSize;
    DWORD                    offset;
    DWORD                    address;
    LPWSTR                   mcastAddress = NULL;
    DWORD                    mcastAddressLength = 0;
    MCAST_CLIENT_UID         requestId = { NULL, 0 };

    InitializeListHead(&selectionRange);

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Choosing multicast address for "
        "network %1!ws!.\n",
        networkId
        );

    networkKey = DmOpenKey(
                     DmNetworksKey, 
                     networkId, 
                     MAXIMUM_ALLOWED
                     );
    if (networkKey == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Failed to open key for network %1!ws!, "
            "status %2!u!\n",
            networkId, status
            );
        goto error_exit;
    }

    //
    // Build an array of selection intervals. These are intervals
    // in the IPv4 class D address space from which an address
    // can be selected.
    //

    // Start with the entire range.
    interval = LocalAlloc(LMEM_FIXED, sizeof(*interval));
    if (interval == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    InsertHeadList(&selectionRange, &interval->Linkage);

    //
    // Get the selection range.
    //
    status = NmpGetMulticastAddressSelectionRange(
                 Network,
                 networkKey,
                 &netParamKey,
                 &interval->hlLower,
                 &interval->hlUpper
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to determine multicast "
            "address selection range for network %1!ws!, "
            "status %2!u!.\n",
            networkId, status
            );
        goto error_exit;
    }

    interval->hlLower = ntohl(interval->hlLower);
    interval->hlUpper = ntohl(interval->hlUpper);

    //
    // Process exclusions from the multicast address 
    // selection range, starting with well-known exclusions.
    //
    for (index = 0; index < NmpMulticastRestrictedRangeCount; index++) {

        ClRtlLogPrint(LOG_NOISE,
            "[NM] Excluding %1!ws! "
            "[%2!u!.%3!u!.%4!u!.%5!u!, %6!u!.%7!u!.%8!u!.%9!u!] "
            "from multicast address range for network %10!ws!.\n",
            NmpMulticastRestrictedRange[index].Description,
            NmpIpAddrPrintArgs(NmpMulticastRestrictedRange[index].Lower),
            NmpIpAddrPrintArgs(NmpMulticastRestrictedRange[index].Upper),
            networkId
            );

        // Convert the exclusion to host format.
        hlLower = ntohl(NmpMulticastRestrictedRange[index].Lower);
        hlUpper = ntohl(NmpMulticastRestrictedRange[index].Upper);

        NmpMulticastExcludeRange(&selectionRange, hlLower, hlUpper);

        // If the selection range is now empty, there is no point
        // in examining other exclusions.
        if (IsListEmpty(&selectionRange)) {
            status = ERROR_INCORRECT_ADDRESS;
            goto error_exit;
        }
    }

    //
    // Process multicast scopes as exclusions. Specifically, any
    // scope whose interface matches this network is excluded
    // because it is conceivable that machines on the network are
    // already using addresses in these scopes.
    //
    status = ClRtlTcpipStringToAddress(
                 Network->Address,
                 &networkAddress
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to convert network address string "
            "%1!ws! into an IPv4 address, status %2!u!.\n",
            Network->Address, status
            );
        goto error_exit;
    }

    status = ClRtlTcpipStringToAddress(
                 Network->AddressMask,
                 &networkSubnet
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to convert network address mask string "
            "%1!ws! into an IPv4 address, status %2!u!.\n",
            Network->AddressMask, status
            );
        goto error_exit;
    }

    //
    // Query multicast scopes to determine if we should 
    // exclude any addresses from the selection range.
    //
    status = NmpMulticastEnumerateScopes(
                 FALSE,                 // do not force requery
                 &scopeList,
                 &scopeCount
                 );
    if (status != ERROR_SUCCESS) {
        scopeCount = 0;
    }

    for (index = 0; index < scopeCount; index++) {

        if (ClRtlAreTcpipAddressesOnSameSubnet(
                networkAddress,
                scopeList[index].ScopeCtx.Interface.IpAddrV4,
                networkSubnet
                )) {

            ClRtlLogPrint(LOG_NOISE,
                "[NM] Excluding MADCAP scope "
                "[%1!u!.%2!u!.%3!u!.%4!u!, %5!u!.%6!u!.%7!u!.%8!u!] "
                "from multicast address selection range for "
                "network %9!ws!.\n",
                NmpIpAddrPrintArgs(scopeList[index].ScopeCtx.ScopeID.IpAddrV4),
                NmpIpAddrPrintArgs(scopeList[index].LastAddr.IpAddrV4),
                networkId
                );

            hlLower = ntohl(scopeList[index].ScopeCtx.ScopeID.IpAddrV4);
            hlUpper = ntohl(scopeList[index].LastAddr.IpAddrV4);

            NmpMulticastExcludeRange(&selectionRange, hlLower, hlUpper);
        
            // If the selection range is empty, there is no point
            // in examining other exclusions.
            if (IsListEmpty(&selectionRange)) {
                status = ERROR_INCORRECT_ADDRESS;
                goto error_exit;
            }

        }
    }

    //
    // The range of intervals from which we can select an
    // address is now constructed.
    //
    // Before choosing an address, see if there is already an 
    // old one in the database that matches the selection range.
    //
    status = NmpQueryMulticastAddress(
                 Network,
                 networkKey,
                 &netParamKey,
                 &mcastAddress,
                 &mcastAddressLength
                 );
    if (status == ERROR_SUCCESS) {

        //
        // We found an address. See if it falls in the range.
        //
        if (!NmpMulticastAddressInRange(&selectionRange, mcastAddress)) {
            
            //
            // We can't use this address. Free the string.
            //
            MIDL_user_free(mcastAddress);
            mcastAddress = NULL;
        }
    } else {
        mcastAddress = NULL;
    }

    if (mcastAddress == NULL) {

        //
        // Calculate the size of the selection range.
        //
        rangeSize = NmpMulticastAddressRangeSize(&selectionRange);

        //
        // Calculate the range offset using the last DWORD of
        // the network id GUID.
        //
        status = UuidFromString((LPWSTR)networkId, &networkIdGuid);
        if (status == RPC_S_OK) {
            offset = (*((PDWORD)&(networkIdGuid.Data4[4]))) % rangeSize;
        } else {
            offset = 0;
        }

        //
        // Choose an address within the specified range.
        //
        address = NmpMulticastRangeOffsetToAddress(&selectionRange, offset);
        CL_ASSERT(address != 0);
        CL_ASSERT(IN_CLASSD(address));
        address = htonl(address);

        //
        // Convert the address to a string.
        //
        status = ClRtlTcpipAddressToString(address, &mcastAddress);
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to convert selected multicast "
                "address %1!u!.%2!u!.%3!u!.%4!u! for "
                "network %5!ws! to a TCP/IP "
                "address string, status %6!u!.\n",
                NmpIpAddrPrintArgs(address), networkId, status
                );
            goto error_exit;
        }
    }

    //
    // Build a parameters data structure for this address.
    //
    status = NmpMulticastCreateParameters(
                 0,                       // disabled
                 mcastAddress,
                 NULL,                    // salt
                 0,                       // salt length
                 NULL,                    // key
                 0,                       // key length
                 0,                       // lease obtained
                 0,                       // lease expires (filled in below)
                 &requestId, 
                 NmpNullMulticastAddress, // lease server
                 NmMcastConfigAuto,
                 Parameters
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to build multicast parameters "
            "for network %1!ws! after choosing address, "
            "status %2!u!.\n",
            networkId, status
            );
        goto error_exit;
    }

    //
    // Calculate the lease renew time. We don't need
    // the lease renew time right now, but a side
    // effect of this routine is to ensure that the
    // lease end time is set correctly (e.g. for 
    // manual or auto config).
    //
    NmpCalculateLeaseRenewTime(
        Network,
        NmMcastConfigAuto,
        &Parameters->LeaseObtained,
        &Parameters->LeaseExpires
        );
    
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Chose multicast address %1!ws! for "
        "network %2!ws!.\n",
        Parameters->Address, networkId
        );

error_exit:

    // 
    // If the list is empty, then the selection range 
    // is empty, and we could not choose an address.
    //
    if (IsListEmpty(&selectionRange)) {
        CL_ASSERT(status != ERROR_SUCCESS);
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Multicast address selection range for "
            "network %1!ws! is empty. Unable to select "
            "a multicast address.\n",
            networkId
            );
    } else {
        NmpMulticastFreeSelectionRange(&selectionRange);
    }

    if (networkKey != NULL) {
        DmCloseKey(networkKey);
        networkKey = NULL;
    }

    if (netParamKey != NULL) {
        DmCloseKey(netParamKey);
        netParamKey = NULL;
    }

    if (scopeList != NULL) {
        LocalFree(scopeList);
    }

    if (mcastAddress != NULL) {
        MIDL_user_free(mcastAddress);
        mcastAddress = NULL;
    }
    
    return(status);

} // NmpChooseMulticastAddress


VOID
NmpChooseBetterMulticastScope(
    IN     PIPNG_ADDRESS          LocalAddress,
    IN     PIPNG_ADDRESS          LocalMask,
    IN     PMCAST_SCOPE_ENTRY     CurrentScope,
       OUT BOOLEAN              * CurrentCorrectInterface,
    IN OUT PMCAST_SCOPE_ENTRY   * BestScope
    )
/*++

Routine Description:
    
    Try to choose a good scope using the following criteria:
    - the interface must match (same subnet) the network address.
    - the scope must not be single-source (232.*.*.*), as defined
      by the IANA
    - aim for link-local
    - aim for a scope with a large range, increasing the 
      probability that other clusters that may be on our subnet
      are assigned different group addresses
    - aim for the lowest TTL
    
Arguments:

    LocalAddress - local address for network
    
    LocalMask - subnet mask for network
    
    CurrentScope - scope under consideration
    
    CurrentCorrectInterface - indicates whether current scope
                              is on the same interface as the
                              local network interface
    
    BestScope - current best scope (may be NULL)
    
Return value:

    None.
    
--*/
{
    BOOL         bestLocal, currentLocal;
    DWORD        bestRange, currentRange;

    *CurrentCorrectInterface = FALSE;

    //
    // This scope is not a candidate if it is not on 
    // the correct interface or if it is single-source.
    //
    if (!ClRtlAreTcpipAddressesOnSameSubnet(
             CurrentScope->ScopeCtx.Interface.IpAddrV4,
             LocalAddress->IpAddrV4,
             LocalMask->IpAddrV4
             )) {
        return;
    }

    *CurrentCorrectInterface = TRUE;

    if (ClRtlAreTcpipAddressesOnSameSubnet(
            CurrentScope->ScopeCtx.Interface.IpAddrV4,
            NMP_SINGLE_SOURCE_SCOPE_ADDRESS,
            NMP_SINGLE_SOURCE_SCOPE_MASK
            )) {
        return;
    }

    //
    // If the current best scope is NULL, then this
    // is the first match.
    //
    if (*BestScope == NULL) {
        goto use_current;
    }

    //
    // If the current scope is an administrative
    // link-local and the current best is not,
    // then the current scope wins.
    //
    bestLocal = ClRtlAreTcpipAddressesOnSameSubnet(
                    (*BestScope)->ScopeCtx.Interface.IpAddrV4,
                    NMP_LOCAL_SCOPE_ADDRESS,
                    NMP_LOCAL_SCOPE_MASK
                    );
    currentLocal = ClRtlAreTcpipAddressesOnSameSubnet(
                       CurrentScope->ScopeCtx.Interface.IpAddrV4,
                       NMP_LOCAL_SCOPE_ADDRESS,
                       NMP_LOCAL_SCOPE_MASK
                       );
    if (currentLocal && !bestLocal) {
        goto use_current;
    } else if (bestLocal && !currentLocal) {
        return;
    }

    //
    // If the current scope has a larger range than
    // the current best, the current wins. The scope 
    // range is the last address minus the scope ID.
    // We do not consider exclusions.
    //
    bestRange = (*BestScope)->LastAddr.IpAddrV4 -
                (*BestScope)->ScopeCtx.ScopeID.IpAddrV4;
    currentRange = CurrentScope->LastAddr.IpAddrV4 - 
                   CurrentScope->ScopeCtx.ScopeID.IpAddrV4;
    if (currentRange > bestRange) {
        goto use_current;
    } else if (bestRange > currentRange) {
        return;
    }

    //
    // If the current scope has a smaller TTL than 
    // the current best, the current wins.
    //
    if (CurrentScope->TTL < (*BestScope)->TTL) {
        goto use_current;
    } else if ((*BestScope)->TTL < CurrentScope->TTL) {
        return;
    }

    //
    // Found no reason to replace BestScope.
    //
    return;

use_current:

    *BestScope = CurrentScope;

    return;

} // NmpChooseBetterMulticastScope


DWORD
NmpFindMulticastScope(
    IN  PNM_NETWORK       Network,
    OUT PMCAST_SCOPE_CTX  ScopeCtx,
    OUT BOOLEAN         * FoundInterfaceMatch
    )
{
    LPCWSTR            networkId = OmObjectId(Network);
    DWORD              status;

    PMCAST_SCOPE_ENTRY scopeList = NULL;
    DWORD              scopeCount;
    DWORD              scope;
    PMCAST_SCOPE_ENTRY bestScope;
    BOOLEAN            currentCorrectInterface = FALSE;
    BOOLEAN            foundInterfaceMatch = FALSE;

    IPNG_ADDRESS       networkAddress;
    IPNG_ADDRESS       networkSubnet;

    
    CL_ASSERT(ScopeCtx != NULL);

#if CLUSTER_BETA
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Finding multicast scope for "
        "network %1!ws!.\n",
        networkId
        );
#endif // CLUSTER_BETA

    status = NmpMulticastEnumerateScopes(
                 TRUE,        // force requery
                 &scopeList,
                 &scopeCount
                 );
    if (status != ERROR_SUCCESS) {
        if (status == ERROR_TIMEOUT || status == ERROR_NO_DATA) {
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Request to MADCAP server failed while "
                "enumerating scopes for network %1!ws! "
                "(status %2!u!). Assuming there are currently "
                "no MADCAP servers on the network.\n",
                networkId, status
                );
            goto error_exit;
        } else {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to enumerate multicast scopes for "
                "network %1!ws!, status %2!u!.\n",
                networkId, status
                );
            goto error_exit;
        }
    }

    if (scopeCount == 0) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Zero multicast scopes located in enumeration "
            "on network %1!ws!.\n",
            networkId
            );
        goto error_exit;
    }

    //
    // Try to choose the best scope among those enumerated.
    //
    // Note: this code is IPv4 specific in that it relies on the
    //       IP address fitting into a ULONG. It uses the 
    //       IPNG_ADDRESS data structure only to work with the 
    //       MADCAP API.
    //
    status = ClRtlTcpipStringToAddress(
                 Network->Address,
                 &(networkAddress.IpAddrV4)
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to convert network address string "
            "%1!ws! into an IPv4 address, status %2!u!.\n",
            status
            );
        goto error_exit;
    }

    status = ClRtlTcpipStringToAddress(
                 Network->AddressMask,
                 &(networkSubnet.IpAddrV4)
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to convert network address mask string "
            "%1!ws! into an IPv4 address, status %2!u!.\n",
            status
            );
        goto error_exit;
    }

#if CLUSTER_BETA
    ClRtlLogPrint(
        LOG_NOISE,
        "[NM] Trying to choose multicast scope for network "
        "%1!ws! with address %2!ws! and mask %3!ws!.\n",
        networkId, Network->Address, Network->AddressMask
        );
#endif // CLUSTER_BETA

    bestScope = NULL;
    for (scope = 0; scope < scopeCount; scope++) {

#if CLUSTER_BETA
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Examining scope on "
            "interface %1!u!.%2!u!.%3!u!.%4!u!, "
            "id %5!u!.%6!u!.%7!u!.%8!u!, "
            "last address %9!u!.%10!u!.%11!u!.%12!u!, "
            "from server %13!u!.%14!u!.%15!u!.%16!u!, with "
            "description %17!ws!.\n",
            NmpIpAddrPrintArgs(scopeList[scope].ScopeCtx.Interface.IpAddrV4),
            NmpIpAddrPrintArgs(scopeList[scope].ScopeCtx.ScopeID.IpAddrV4),
            NmpIpAddrPrintArgs(scopeList[scope].LastAddr.IpAddrV4),
            NmpIpAddrPrintArgs(scopeList[scope].ScopeCtx.ServerID.IpAddrV4),
            scopeList[scope].ScopeDesc.Buffer
            );
#endif // CLUSTER_BETA

        NmpChooseBetterMulticastScope(
            &networkAddress,
            &networkSubnet,
            &(scopeList[scope]),
            &currentCorrectInterface,
            &bestScope
            );

        foundInterfaceMatch = 
            (BOOLEAN)(foundInterfaceMatch || currentCorrectInterface);
    }

    if (bestScope == NULL) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to find multicast scope matching "
            "network id %1!ws!.\n",
            networkId
            );
        status = ERROR_NOT_FOUND;
        goto error_exit;
    } else {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Selecting MADCAP scope [%1!u!.%2!u!.%3!u!.%4!u!, "
            "%5!u!.%6!u!.%7!u!.%8!u!] from server "
            "%9!u!.%10!u!.%11!u!.%12!u! on interface "
            "%13!u!.%14!u!.%15!u!.%16!u! with description "
            "%17!ws! for network %18!ws!.\n",
            NmpIpAddrPrintArgs(bestScope->ScopeCtx.ScopeID.IpAddrV4),
            NmpIpAddrPrintArgs(bestScope->LastAddr.IpAddrV4),
            NmpIpAddrPrintArgs(bestScope->ScopeCtx.ServerID.IpAddrV4),
            NmpIpAddrPrintArgs(bestScope->ScopeCtx.Interface.IpAddrV4),
            bestScope->ScopeDesc.Buffer, networkId
            );
    }

    RtlCopyMemory(ScopeCtx, &(bestScope->ScopeCtx), sizeof(*ScopeCtx));

error_exit:

    *FoundInterfaceMatch = foundInterfaceMatch;

    if (scopeList != NULL) {
        LocalFree(scopeList);
    }
    
    return(status);

} // NmpFindMulticastScope


DWORD
NmpGenerateMulticastRequestId(
    IN OUT LPMCAST_CLIENT_UID   RequestId
    )
/*++

Routine Description:

    Allocate, if necessary, and generate a client request id
    data structure. If the buffer described by the input
    MCAST_CLIENT_UID data structure is too small, it is 
    deallocated.
    
Arguments:

    RequestId - IN: pointer to MCAST_CLIENT_UID data structure.
                    if ClientUID field is non-NULL, it points
                        to a buffer for the generated ID and
                        ClientUIDLength is the length of that
                        buffer.
                OUT: filled in MCAST_CLIENT_UID data structure.

--*/
{
    DWORD               status;
    LPBYTE              clientUid = NULL;
    MCAST_CLIENT_UID    requestId;
    DWORD               clientUidLength;

    CL_ASSERT(RequestId != NULL);

#if CLUSTER_BETA
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Generating MADCAP client request id.\n"
        );
#endif // CLUSTER_BETA

    //
    // Initialize MADCAP, if not done already.
    //
    if (!NmpMadcapClientInitialized) {
        DWORD madcapVersion = MCAST_API_CURRENT_VERSION;
        status = McastApiStartup(&madcapVersion);
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to initialize MADCAP API, "
                "status %1!u!.\n",
                status
                );
            goto error_exit;
        }
        NmpMadcapClientInitialized = TRUE;
    }

    //
    // Allocate a buffer for the client uid, if necessary.
    //
    clientUid = RequestId->ClientUID;
    clientUidLength = RequestId->ClientUIDLength;

    if (clientUid != NULL && clientUidLength < MCAST_CLIENT_ID_LEN) {
        MIDL_user_free(clientUid);
        clientUid = NULL;
        clientUidLength = 0;
        RequestId->ClientUID = NULL;
    }

    if (clientUid == NULL) {
        clientUidLength = MCAST_CLIENT_ID_LEN;
        clientUid = MIDL_user_allocate(clientUidLength);
        if (clientUid == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to allocate buffer for multicast "
                "clientUid.\n"
                );
            goto error_exit;
        }
    }

    //
    // Obtain a new ID.
    //
    requestId.ClientUID = clientUid;
    requestId.ClientUIDLength = clientUidLength;
    status = McastGenUID(&requestId);
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to obtain multicast address "
            "request client id, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    *RequestId = requestId;
    clientUid = NULL;

error_exit:

    if (clientUid != NULL) {
        MIDL_user_free(clientUid);
        clientUid = NULL;
    }

    return(status);

} // NmpGenerateMulticastRequestId


DWORD
NmpRequestMulticastAddress(
    IN     PNM_NETWORK                Network,
    IN     BOOLEAN                    Renew,
    IN     PMCAST_SCOPE_CTX           ScopeCtx,
    IN     LPMCAST_CLIENT_UID         RequestId,
    IN OUT LPWSTR                   * McastAddress,
    IN OUT DWORD                    * McastAddressLength,
    IN OUT LPWSTR                   * ServerAddress,
    IN OUT DWORD                    * ServerAddressLength,
       OUT time_t                   * LeaseStartTime,
       OUT time_t                   * LeaseEndTime,
       OUT BOOLEAN                  * NewMcastAddress
    )
/*++

Routine Description:

    Renew lease on multicast group address using MADCAP
    client API.
    
Arguments:

    Network - network on which address is used
    
    ScopeCtx - multicast scope (ignored if Renew)
    
    RequestId - client request id
    
    McastAddress - IN: address to renew (ignored if !Renew)
                   OUT: resulting address
                   
    McastAddressLength - length of McastAddress buffer
    
    ServerAddress - IN: address of server on which to renew
                        (ignored if !Renew)
                    OUT: address of address where renew occurred
                   
    ServerAddressLength - length of ServerAddress buffer
    
    LeaseStartTime - UTC lease start time in seconds (buffer
                     allocated by caller)
                     
    LeaseEndTime - UTC lease stop time in seconds (buffer 
                   allocated by caller)
                   
    NewMcastAddress - whether resulting mcast address is
                      new (different than request on renewal
                      and always true on successful request)
                   
--*/
{
    DWORD                     status;
    LPCWSTR                   networkId = OmObjectId(Network);
    UCHAR                     requestBuffer[NMP_MADCAP_REQUEST_BUFFER_SIZE];
    PMCAST_LEASE_REQUEST      request;
    UCHAR                     responseBuffer[NMP_MADCAP_RESPONSE_BUFFER_SIZE];
    PMCAST_LEASE_RESPONSE     response;
    LPWSTR                    address = NULL;
    DWORD                     addressSize;
    DWORD                     requestAddress = 0;

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Preparing to send multicast address %1!ws! "
        "for network %2!ws! to MADCAP server.\n",
        ((Renew) ? L"renewal" : L"request"), 
        OmObjectId(Network)
        );

    //
    // Initialize MADCAP, if not done already.
    //
    if (!NmpMadcapClientInitialized) {
        DWORD madcapVersion = MCAST_API_CURRENT_VERSION;
        status = McastApiStartup(&madcapVersion);
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to initialize MADCAP API, "
                "status %1!u!.\n",
                status
                );
            goto error_exit;
        }
        NmpMadcapClientInitialized = TRUE;
    }

    //
    // Fill in the request. All fields are zero except those
    // set below.
    //
    request = (PMCAST_LEASE_REQUEST) &requestBuffer[0];
    RtlZeroMemory(request, sizeof(requestBuffer));
    request->MinLeaseDuration = 0;       // currently ignored
    request->MinAddrCount = 1;           // currently ignored
    request->MaxLeaseStartTime = (LONG) time(NULL); // currently ignored
    request->AddrCount = 1;

    //
    // Set the renew parameters.
    //
    if (Renew) {

        request->pAddrBuf = (PBYTE)request + NMP_MADCAP_REQUEST_ADDR_OFFSET;

        status = ClRtlTcpipStringToAddress(
                     *McastAddress,
                     &requestAddress
                     );
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to convert requested address %1!ws! "
                "into a TCP/IP address, status %2!u!.\n",
                *McastAddress, status
                );
            goto error_exit;
        }
        *((PULONG) request->pAddrBuf) = requestAddress;

        status = ClRtlTcpipStringToAddress(
                     *ServerAddress,
                     (PULONG) &(request->ServerAddress.IpAddrV4)
                     );
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to convert server address %1!ws! "
                "into a TCP/IP address, status %2!u!.\n",
                *ServerAddress, status
                );
            goto error_exit;
        }
    }

    //
    // Set the address count and buffer fields in the response.
    //
    response = (PMCAST_LEASE_RESPONSE) &responseBuffer[0];
    RtlZeroMemory(response, sizeof(responseBuffer));
    response->AddrCount = 1;
    response->pAddrBuf = (PBYTE)(response) + NMP_MADCAP_RESPONSE_ADDR_OFFSET;

    //
    // Renew or request, as indicated.
    //
    if (Renew) {

        status = McastRenewAddress(
                     AF_INET,
                     RequestId,
                     request,
                     response
                     );
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to renew multicast address %1!ws! "
                "with server %2!ws!, status %3!u!.\n",
                *McastAddress, *ServerAddress, status
                );
            goto error_exit;
        }

    } else {

        status = McastRequestAddress(
                     AF_INET,
                     RequestId,
                     ScopeCtx,
                     request,
                     response
                     );
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to request multicast address on "
                "Scope ID %1!x!, Server ID %2!x!, Interface "
                "%3!x!, status %4!u!.\n",
                ScopeCtx->ScopeID.IpAddrV4, ScopeCtx->ServerID.IpAddrV4,
                ScopeCtx->Interface.IpAddrV4, status
                );
            goto error_exit;
        }
    }

    //
    // Return results through out parameters.
    //
    address = NULL;
    status = ClRtlTcpipAddressToString(
                 response->ServerAddress.IpAddrV4,
                 &address
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to convert server address %1!x! "
            "into a TCP/IP address string, status %2!u!.\n",
            response->ServerAddress.IpAddrV4, status
            );
        goto error_exit;
    }

    status = NmpStoreString(address, ServerAddress, ServerAddressLength);
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to store server address %1!ws! "
            "in return buffer, status %2!u!.\n",
            address, status
            );
        goto error_exit;
    }

    LocalFree(address);
    address = NULL;

    status = ClRtlTcpipAddressToString(
                 *((PULONG) response->pAddrBuf),
                 &address
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to convert leased address %1!x! "
            "into a TCP/IP address string, status %2!u!.\n",
            *((PULONG) response->pAddrBuf), status
            );
        goto error_exit;
    }

    status = NmpStoreString(address, McastAddress, McastAddressLength);
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to store leased address %1!ws! "
            "in return buffer, status %2!u!.\n",
            address, status
            );
        goto error_exit;
    }

    if (Renew) {
        if (*((PULONG) response->pAddrBuf) != requestAddress) {
            *NewMcastAddress = TRUE;
        } else {
            *NewMcastAddress = FALSE;
        }
    } else {
        *NewMcastAddress = TRUE;
    }

    *LeaseStartTime = response->LeaseStartTime;
    *LeaseEndTime = response->LeaseEndTime;

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Obtained lease on multicast address %1!ws! "
        "(%2!ws!) from MADCAP server %3!ws! for network %4!ws!.\n",
        *McastAddress, 
        ((*NewMcastAddress) ? L"new" : L"same"),
        *ServerAddress, networkId
        );

#if CLUSTER_BETA
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Lease starts at %1!u!, ends at %2!u!, "
        "duration %3!u!.\n",
        *LeaseStartTime, *LeaseEndTime, *LeaseEndTime - *LeaseStartTime
        );
#endif // CLUSTER_BETA

error_exit:

    if (address != NULL) {
        LocalFree(address);
        address = NULL;
    }

    return(status);

} // NmpRequestMulticastAddress
    

NM_MCAST_LEASE_STATUS
NmpCalculateLeaseStatus(
    IN     PNM_NETWORK   Network,
    IN     time_t        LeaseObtained,
    IN     time_t        LeaseExpires
    )
/*++

Routine Description:

    Calculate lease status based on current time
    and lease end time.
    
    Rely on the compiler's correct code generation for 
    time_t math!
    
Return value:

    Lease status
    
--*/
{
    LPCWSTR                  networkId = OmObjectId(Network);
    time_t                   currentTime;
    time_t                   halfLife;
    NM_MCAST_LEASE_STATUS    status;

    if (LeaseExpires == 0 || LeaseExpires <= LeaseObtained) {

        //
        // A lease expiration of 0 means we hold the lease
        // forever. Most likely, an administrator statically
        // configured the network with this address.
        //
        status = NmMcastLeaseValid;

    } else {

        time(&currentTime);

        if (currentTime > LeaseExpires) {
            status = NmMcastLeaseExpired;
        } else {
            
            halfLife = LeaseObtained + 
                       ((LeaseExpires - LeaseObtained) / 2);

            if (currentTime >= halfLife) {
                status = NmMcastLeaseNeedsRenewal;
            } else {
                status = NmMcastLeaseValid;
            }
        }
    }

#if CLUSTER_BETA
    if (LeaseExpires == 0 || LeaseExpires <= LeaseObtained) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Found that multicast address lease for "
            "network %1!ws! does not expire.\n",
            networkId
            );
    } else if (status == NmMcastLeaseExpired) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Found that multicast address lease for "
            "network %1!ws! expired %2!u! seconds ago.\n",
            networkId, currentTime - LeaseExpires
            );
    } else {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Found that multicast address lease for "
            "network %1!ws! expires in %2!u! seconds. With "
            "lease obtained %3!u! seconds ago, renewal is "
            "%4!ws!needed.\n",
            networkId, LeaseExpires - currentTime,
            currentTime - LeaseObtained,
            ((status > NmMcastLeaseValid) ? L"" : L"not ")
            );
    }
#endif // CLUSTER_BETA

    return(status);

} // NmpCalculateLeaseStatus

DWORD
NmpQueryMulticastAddressLease(
    IN     PNM_NETWORK             Network,
    IN     HDMKEY                  NetworkKey,
    IN OUT HDMKEY                * NetworkParametersKey,
       OUT NM_MCAST_LEASE_STATUS * LeaseStatus,
       OUT time_t                * LeaseObtained,
       OUT time_t                * LeaseExpires
    )
/*++

Routine Description:

    Query the lease obtained and expires times stored in the
    cluster database.
    
Return value:

    Error if lease times not found.
        
Notes:

    Must not be called with NM lock held.
    
--*/
{
    DWORD         status;
    LPCWSTR       networkId = OmObjectId(Network);
    HDMKEY        netParamKey = NULL;
    BOOLEAN       openedNetParamKey = FALSE;

    DWORD         type;
    DWORD         len;
    time_t        leaseExpires;
    time_t        leaseObtained;

#if CLUSTER_BETA
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Querying multicast address lease for "
        "network %1!ws!.\n",
        networkId
        );
#endif // CLUSTER_BETA

    if (Network == NULL || NetworkKey == NULL) {
        status = ERROR_INVALID_PARAMETER;
        goto error_exit;
    }

    //
    // Open the network parameters key, if necessary.
    //
    netParamKey = *NetworkParametersKey;

    if (netParamKey == NULL) {

        netParamKey = DmOpenKey(
                          NetworkKey, 
                          CLUSREG_KEYNAME_PARAMETERS, 
                          MAXIMUM_ALLOWED
                          );
        if (netParamKey == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] Failed to find Parameters key "
                "for network %1!ws!, status %2!u!. Using default "
                "multicast parameters.\n",
                networkId, status
                );
            goto error_exit;
        } else {
            openedNetParamKey = TRUE;
        }
    }

    //
    // Query the lease obtained and expires value from the 
    // cluster database.
    //
    len = sizeof(leaseObtained);
    status = DmQueryValue(
                 netParamKey,
                 CLUSREG_NAME_NET_MCAST_LEASE_OBTAINED,
                 &type,
                 (LPBYTE) &leaseObtained,
                 &len
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to read multicast lease obtained "
            " time for network %1!ws! from cluster database, "
            "status %2!u!.\n",
            networkId, status
            );
        goto error_exit;
    } else if (type != REG_DWORD) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Unexpected type (%1!u!) for network "
            "%2!ws! %3!ws!.\n",
            type, networkId, CLUSREG_NAME_NET_MCAST_LEASE_OBTAINED
            );
        status = ERROR_DATATYPE_MISMATCH;
        goto error_exit;
    }

    len = sizeof(leaseExpires);
    status = DmQueryValue(
                 netParamKey,
                 CLUSREG_NAME_NET_MCAST_LEASE_EXPIRES,
                 &type,
                 (LPBYTE) &leaseExpires,
                 &len
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to read multicast lease expiration "
            " time for network %1!ws! from cluster database, "
            "status %2!u!.\n",
            networkId, status
            );
        goto error_exit;
    } else if (type != REG_DWORD) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Unexpected type (%1!u!) for network "
            "%2!ws! %3!ws!.\n",
            type, networkId, CLUSREG_NAME_NET_MCAST_LEASE_EXPIRES
            );
        status = ERROR_DATATYPE_MISMATCH;
        goto error_exit;
    }

    *NetworkParametersKey = netParamKey;
    netParamKey = NULL;

    *LeaseStatus = NmpCalculateLeaseStatus(
                       Network, 
                       leaseObtained,
                       leaseExpires
                       );
    
    *LeaseObtained = leaseObtained;
    *LeaseExpires = leaseExpires;

error_exit:

    if (openedNetParamKey && netParamKey != NULL) {
        DmCloseKey(netParamKey);
        netParamKey = NULL;
    }

    return(status);

} // NmpQueryMulticastAddressLease


VOID
NmpCheckMulticastAddressLease(
    IN     PNM_NETWORK             Network,
       OUT NM_MCAST_LEASE_STATUS * LeaseStatus,
       OUT time_t                * LeaseObtained,
       OUT time_t                * LeaseExpires
    )
/*++

Routine Description:

    Check the lease parameters stored in the network
    object. Determine if a lease renew is required.
    
Notes:

    Called and returns with NM lock held.
    
--*/
{
#if CLUSTER_BETA
    LPCWSTR               networkId = OmObjectId(Network);

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Checking multicast address lease for "
        "network %1!ws!.\n",
        networkId
        );
#endif // CLUSTER_BETA

    //
    // Determine if we need to renew.
    // 
    *LeaseStatus = NmpCalculateLeaseStatus(
                       Network,
                       Network->MulticastLeaseObtained,
                       Network->MulticastLeaseExpires
                       );

    *LeaseObtained = Network->MulticastLeaseObtained;
    *LeaseExpires = Network->MulticastLeaseExpires;

    return;

} // NmpCheckMulticastAddressLease


DWORD
NmpMulticastGetDatabaseLeaseParameters(
    IN     PNM_NETWORK          Network,
    IN OUT HDMKEY             * NetworkKey,
    IN OUT HDMKEY             * NetworkParametersKey,
       OUT LPMCAST_CLIENT_UID   RequestId,            OPTIONAL
       OUT LPWSTR             * ServerAddress,        OPTIONAL
       OUT LPWSTR             * McastAddress          OPTIONAL
    )
/*++

Routine Description:

    Read parameters needed to renew a lease from the
    cluster database.
    
Return value:

    SUCCESS if all parameters were successfully read.
    
Notes:

    Must not be called with NM lock held.
    
--*/
{
    DWORD                 status;
    LPCWSTR               networkId = OmObjectId(Network);
    HDMKEY                networkKey = NULL;
    BOOLEAN               openedNetworkKey = FALSE;
    HDMKEY                netParamKey = NULL;
    BOOLEAN               openedNetParamKey = FALSE;

    DWORD                 type;
    DWORD                 len;

    MCAST_CLIENT_UID      requestId = { NULL, 0 };
    LPWSTR                serverAddress = NULL;
    DWORD                 serverAddressLength = 0;
    LPWSTR                mcastAddress = NULL;
    DWORD                 mcastAddressLength = 0;

    //
    // Open the network key, if necessary.
    //
    networkKey = *NetworkKey;

    if (networkKey == NULL) {

        networkKey = DmOpenKey(
                         DmNetworksKey, 
                         networkId, 
                         MAXIMUM_ALLOWED
                         );
        if (networkKey == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] Failed to open key for network %1!ws!, "
                "status %2!u!\n",
                networkId, status
                );
            goto error_exit;
        }
        openedNetworkKey = TRUE;
    }

    //
    // Open the network parameters key if necessary.
    //
    netParamKey = *NetworkParametersKey;

    if (netParamKey == NULL) {

        netParamKey = DmOpenKey(
                          networkKey,
                          CLUSREG_KEYNAME_PARAMETERS,
                          MAXIMUM_ALLOWED
                          );
        if (netParamKey == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] Failed to open Parameters key for "
                "network %1!ws!, status %2!u!\n",
                networkId, status
                );
            goto error_exit;
        }
        openedNetParamKey = TRUE;
    }

    //
    // Read the client request id.
    //
    if (RequestId != NULL) {
        requestId.ClientUIDLength = MCAST_CLIENT_ID_LEN;
        requestId.ClientUID = MIDL_user_allocate(requestId.ClientUIDLength);
        if (requestId.ClientUID == NULL) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to allocate buffer to read "
                "request id from Parameters database "
                "key for network %1!ws!.\n",
                networkId
                );
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto error_exit;
        }

        len = requestId.ClientUIDLength;
        status = DmQueryValue(
                     netParamKey,
                     CLUSREG_NAME_NET_MCAST_REQUEST_ID,
                     &type,
                     (LPBYTE) requestId.ClientUID,
                     &len
                     );
        if (status == ERROR_SUCCESS) {
            if (type != REG_BINARY) {
                ClRtlLogPrint(LOG_NOISE, 
                    "[NM] Unexpected type (%1!u!) for network "
                    "%2!ws! %3!ws!, status %4!u!.\n",
                    type, networkId, 
                    CLUSREG_NAME_NET_MCAST_REQUEST_ID, status
                    );
                goto error_exit;
            }
            requestId.ClientUIDLength = len;
        } else {
            goto error_exit;
        }
    }

    //
    // Read the address of the server that granted the
    // current lease.
    //
    if (ServerAddress != NULL) {
        serverAddress = NULL;
        serverAddressLength = 0;
        status = NmpQueryString(
                     netParamKey,
                     CLUSREG_NAME_NET_MCAST_SERVER_ADDRESS,
                     REG_SZ,
                     &serverAddress,
                     &serverAddressLength,
                     &len
                     );
        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }
    }

    //
    // Read the last known multicast address.
    //
    if (McastAddress != NULL) {
        status = NmpQueryMulticastAddress(
                     Network,
                     networkKey,
                     &netParamKey,
                     &mcastAddress,
                     &mcastAddressLength
                     );
        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }
        if (!NmpMulticastValidateAddress(mcastAddress)) {
            MIDL_user_free(mcastAddress);
            mcastAddress = NULL;
            mcastAddressLength = 0;
            goto error_exit;
        }
    }

    //
    // We found all the parameters.
    //
    *NetworkKey = networkKey;
    networkKey = NULL;
    *NetworkParametersKey = netParamKey;
    netParamKey = NULL;
    if (RequestId != NULL) {
        *RequestId = requestId;
        requestId.ClientUID = NULL;
        requestId.ClientUIDLength = 0;
    }
    if (ServerAddress != NULL) {
        *ServerAddress = serverAddress;
        serverAddress = NULL;
    }
    if (McastAddress != NULL) {
        *McastAddress = mcastAddress;
        mcastAddress = NULL;
    }

    status = ERROR_SUCCESS;

error_exit:

    if (requestId.ClientUID != NULL) {
        MIDL_user_free(requestId.ClientUID);
        requestId.ClientUID = NULL;
        requestId.ClientUIDLength = 0;
    }

    if (serverAddress != NULL) {
        MIDL_user_free(serverAddress);
        serverAddress = NULL;
    }

    if (mcastAddress != NULL) {
        MIDL_user_free(mcastAddress);
        mcastAddress = NULL;
    }

    if (openedNetworkKey && networkKey != NULL) {
        DmCloseKey(networkKey);
        networkKey = NULL;
    }

    if (openedNetParamKey && netParamKey != NULL) {
        DmCloseKey(netParamKey);
        netParamKey = NULL;
    }

    return(status);

} // NmpMulticastGetDatabaseLeaseParameters


DWORD
NmpMulticastGetNetworkLeaseParameters(
    IN     PNM_NETWORK          Network,
       OUT LPMCAST_CLIENT_UID   RequestId,
       OUT LPWSTR             * ServerAddress,
       OUT LPWSTR             * McastAddress
    )
/*++

Routine Description:

    Read parameters needed to renew a lease from the
    network object data structure.
    
Return value:

    SUCCESS if all parameters were successfully read.
    
Notes:

    Must be called with NM lock held.
    
--*/
{
    DWORD                 status;
    LPCWSTR               networkId = OmObjectId(Network);

    MCAST_CLIENT_UID      requestId = { NULL, 0 };
    LPWSTR                serverAddress = NULL;
    DWORD                 serverAddressLength = 0;
    LPWSTR                mcastAddress = NULL;
    DWORD                 mcastAddressLength = 0;
    
    
    if (Network->MulticastAddress == NULL ||
        Network->MulticastLeaseServer == NULL ||
        Network->MulticastLeaseRequestId.ClientUID == NULL) {
    
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Failed to locate multicast lease "
            "parameter in network object %1!ws!.\n",
            networkId
            );
        status = ERROR_NOT_FOUND;
        goto error_exit;
    }

    status = NmpStoreString(
                 Network->MulticastAddress,
                 &mcastAddress,
                 NULL
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to copy multicast address %1!ws! "
            "from network object %2!ws!, status %3!u!.\n",
            Network->MulticastAddress,
            networkId, status
            );
        goto error_exit;
    } 

    status = NmpStoreString(
                 Network->MulticastLeaseServer,
                 &serverAddress,
                 NULL
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to copy lease server address %1!ws! "
            "from network object %2!ws!, status %3!u!.\n",
            Network->MulticastLeaseServer,
            networkId, status
            );
        goto error_exit;
    } 

    status = NmpStoreRequestId(
                 &(Network->MulticastLeaseRequestId),
                 &requestId
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to copy lease request id "
            "from network object %1!ws!, status %2!u!.\n",
            networkId, status
            );
        goto error_exit;
    } 

    *RequestId = requestId;
    requestId.ClientUID = NULL;
    requestId.ClientUIDLength = 0;
    *ServerAddress = serverAddress;
    serverAddress = NULL;
    *McastAddress = mcastAddress;
    mcastAddress = NULL;

    status = ERROR_SUCCESS;

error_exit:

    if (requestId.ClientUID != NULL) {
        MIDL_user_free(requestId.ClientUID);
        RtlZeroMemory(&requestId, sizeof(requestId));
    }

    if (mcastAddress != NULL) {
        MIDL_user_free(mcastAddress);
        mcastAddress = NULL;
    }

    if (serverAddress != NULL) {
        MIDL_user_free(serverAddress);
        serverAddress = NULL;
    }

    return(status);

} // NmpMulticastGetNetworkLeaseParameters


DWORD
NmpMulticastNeedRetryRenew(
    IN     PNM_NETWORK                       Network,
    OUT    DWORD                           * DeferRetry
    )
/*++

Routine Description:

    Called after a MADCAP timeout, determines whether 
    a new MADCAP request should be sent after a delay.
    Specifically, a retry after delay is in order when
    the current address was obtained from a MADCAP
    server that might simply be temporarily unresponsive.
    
    The default is to not retry.
    
Arguments:

    Network - network
                            
    DeferRetry - OUT: seconds to defer until retrying
                      MADCAP query, or zero if should 
                      not retry
    
--*/
{
    DWORD                 status;
    LPCWSTR               networkId = OmObjectId(Network);
    HDMKEY                networkKey = NULL;
    HDMKEY                netParamKey = NULL;

    NM_MCAST_CONFIG       configType;
    NM_MCAST_LEASE_STATUS leaseStatus;
    time_t                leaseObtained;
    time_t                leaseExpires;
    time_t                currentTime;
    time_t                halfhalfLife;
    time_t                result;

    *DeferRetry = 0;

    //
    // Open the network key.
    //
    networkKey = DmOpenKey(
                     DmNetworksKey, 
                     networkId, 
                     MAXIMUM_ALLOWED
                     );
    if (networkKey == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Failed to open key for network %1!ws!, "
            "status %2!u!\n",
            networkId, status
            );
        goto error_exit;
    }

    status = NmpQueryMulticastConfigType(
                 Network,
                 networkKey,
                 &netParamKey,
                 &configType
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Failed to query multicast config type "
            "for network %1!ws!, status %2!u!\n",
            networkId, status
            );
        goto error_exit;
    }

    if (configType != NmMcastConfigMadcap) {
        goto error_exit;
    }

    status = NmpQueryMulticastAddressLease(
                 Network,
                 networkKey,
                 &netParamKey,
                 &leaseStatus,
                 &leaseObtained,
                 &leaseExpires
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Failed to query multicast lease expiration "
            "time for network %1!ws!, status %2!u!\n",
            networkId, status
            );
        goto error_exit;
    }

    //
    // Check if the lease has expired.
    //
    if (leaseStatus == NmMcastLeaseExpired) {
        goto error_exit;
    }

    //
    // Check if we are within the threshold of expiration.
    //
    currentTime = time(NULL);
    if (leaseExpires - currentTime < NMP_MCAST_LEASE_RENEWAL_THRESHOLD) {
        goto error_exit;
    }

    //
    // Calculate half the time until expiration.
    //
    halfhalfLife = currentTime + ((leaseExpires - currentTime) / 2);

    if (leaseExpires - halfhalfLife < NMP_MCAST_LEASE_RENEWAL_THRESHOLD) {
        result = leaseExpires - NMP_MCAST_LEASE_RENEWAL_THRESHOLD;
    } else {
        result = halfhalfLife - currentTime;
    }

    NMP_TIME_TO_DWORD(result, *DeferRetry);

    status = ERROR_SUCCESS;

error_exit:

    if (networkKey != NULL) {
        DmCloseKey(networkKey);
        networkKey = NULL;
    }

    if (netParamKey != NULL) {
        DmCloseKey(netParamKey);
        netParamKey = NULL;
    }

    return(status);

} // NmpMulticastNeedRetryRenew


DWORD
NmpGetMulticastAddress(
    IN     PNM_NETWORK                       Network,
    IN OUT LPWSTR                          * McastAddress,
    IN OUT LPWSTR                          * ServerAddress,
    IN OUT LPMCAST_CLIENT_UID                RequestId,
       OUT PNM_NETWORK_MULTICAST_PARAMETERS  Parameters
    )
/*++

Routine Description:

    Try to obtain a multicast address lease. If the 
    address, server, and request id are non-NULL, first 
    try to renew. If unsuccessful in renewing, try a
    new lease.
    
    Return lease parameters through Parameters.
    
    Free McastAddress, ServerAddress, and RequestId
    if new values are returned through Parameters.
    
Notes:

    Must not be called with NM lock held.
    
--*/
{
    DWORD                 status;
    LPCWSTR               networkId = OmObjectId(Network);
    BOOLEAN               renew = FALSE;
    BOOLEAN               retryFresh = FALSE;
    BOOLEAN               madcapTimeout = FALSE;
    BOOLEAN               newMcastAddress = FALSE;
    NM_MCAST_CONFIG       configType = NmMcastConfigAuto;

    MCAST_SCOPE_CTX       scopeCtx;
    BOOLEAN               interfaceMatch = FALSE;
    DWORD                 mcastAddressLength = 0;
    LPWSTR                serverAddress = NULL;
    DWORD                 serverAddressLength = 0;
    MCAST_CLIENT_UID      requestId = {NULL, 0};
    time_t                leaseStartTime;
    time_t                leaseEndTime;
    DWORD                 len;

    renew = (BOOLEAN)(*McastAddress != NULL &&
                      *ServerAddress != NULL &&
                      RequestId->ClientUID != NULL &&
                      NmpMulticastValidateAddress(*McastAddress) &&
                      lstrcmpW(*ServerAddress, NmpNullMulticastAddress) != 0
                      );

    do {

        if (!renew) {

            //
            // Find a scope.
            //
            status = NmpFindMulticastScope(
                         Network, 
                         &scopeCtx,
                         &interfaceMatch
                         );
            if (status != ERROR_SUCCESS) {
                if (status == ERROR_TIMEOUT) {
                    ClRtlLogPrint(LOG_NOISE,
                        "[NM] Attempt to contact MADCAP server timed "
                        "out while enumerating multicast scopes "
                        "(status %1!u!). Selecting default multicast "
                        "address for network %2!ws! ...\n",
                        status, networkId
                        );
                    madcapTimeout = TRUE;
                    goto error_exit;
                } else if (interfaceMatch) {
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NM] Failed to find viable multicast scope "
                        "for network %1!ws!, status %2!u!.\n",
                        networkId, status
                        );
                    goto error_exit;
                } else {
                    ClRtlLogPrint(LOG_NOISE,
                        "[NM] MADCAP server reported no multicast "
                        "scopes on interface for network %1!ws!. "
                        "Selecting default multicast address ... \n",
                        networkId
                        );
                    //
                    // Treat this situation as a MADCAP timeout,
                    // because there are likely no MADCAP servers
                    // for this network.
                    //
                    madcapTimeout = TRUE;
                    goto error_exit;
                }
            }

            //
            // Generate a client request id.
            //
            status = NmpGenerateMulticastRequestId(RequestId);
            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Failed to generate multicast client "
                    "request ID for network %1!ws!, status %2!u!.\n",
                    networkId, status
                    );
                goto error_exit;
            }        
        }

        //
        // Request a lease.
        //
        mcastAddressLength = 
            (*McastAddress == NULL) ? 0 : NM_WCSLEN(*McastAddress);
        serverAddressLength = 
            (*ServerAddress == NULL) ? 0 : NM_WCSLEN(*ServerAddress);
        status = NmpRequestMulticastAddress(
                     Network,
                     renew,
                     ((renew) ? NULL : &scopeCtx),
                     RequestId,
                     McastAddress,
                     &mcastAddressLength,
                     ServerAddress,
                     &serverAddressLength,
                     &leaseStartTime,
                     &leaseEndTime,
                     &newMcastAddress
                     );
        if (status != ERROR_SUCCESS) {
            if (status == ERROR_TIMEOUT) {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Attempt to contact MADCAP server timed "
                    "out while requesting a multicast address "
                    "(status %1!u!). Selecting default multicast "
                    "address for network %2!ws! ...\n",
                    status, networkId
                    );
                madcapTimeout = TRUE;
                goto error_exit;
            } else if (renew && !retryFresh) {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Failed to renew multicast address "
                    "for network %1!ws!, status %2!u!. Attempting "
                    "a fresh request ...\n",
                    networkId, status
                    );
                retryFresh = TRUE;
                renew = FALSE;
            } else {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Failed to request multicast address "
                    "for network %1!ws!, status %2!u!.\n",
                    networkId, status
                    );
                goto error_exit;
            }
        } else {
            //
            // Madcap config succeeded.
            //
            configType = NmMcastConfigMadcap;
            madcapTimeout = FALSE;

            //
            // Save lease renewal parameters.
            //
            requestId = *RequestId;
            serverAddress = *ServerAddress;

            //
            // Break out of loop.
            //
            retryFresh = FALSE;
        }

    } while ( retryFresh );

    //
    // Fill in the parameters data structure.
    //
    status = NmpMulticastCreateParameters(
                 0,      // disabled
                 *McastAddress,
                 NULL,   // salt
                 0,      // salt length
                 NULL,   // key
                 0,      // key length
                 leaseStartTime,
                 leaseEndTime,
                 &requestId,
                 serverAddress,
                 configType,
                 Parameters
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to create multicast parameters "
            "data structure for network %1!ws!, "
            "status %2!u!.\n",
            networkId, status
            );
        goto error_exit;
    }

    status = ERROR_SUCCESS;

error_exit:

    if (madcapTimeout) {
        status = ERROR_TIMEOUT;
    } 

    return(status);

} // NmpGetMulticastAddress


DWORD
NmpMulticastSetNullAddressParameters(
    IN  PNM_NETWORK                       Network,
    OUT PNM_NETWORK_MULTICAST_PARAMETERS  Parameters
    )
/*++

Routine Description:

    Called after failure to process multicast parameters.
    Changes only address field in parameters to turn
    off multicast in clusnet.
    
--*/
{
    LPCWSTR          networkId = OmObjectId(Network);
    
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Setting NULL multicast address (%1!ws!) "
        "for network %2!ws!.\n",
        NmpNullMulticastAddress, networkId
        );

    if (Parameters->Address != NULL) {
        MIDL_user_free(Parameters->Address);
    }
    
    Parameters->Address = NmpNullMulticastAddress;

    return(ERROR_SUCCESS);

} // NmpMulticastSetNullAddressParameters


DWORD
NmpMulticastSetNoAddressParameters(
    IN  PNM_NETWORK                       Network,
    OUT PNM_NETWORK_MULTICAST_PARAMETERS  Parameters
    )
/*++

Routine Description:

    Called after failure to obtain a multicast address.
    Fills in parameters data structure to reflect
    failure and to establish retry.
    
--*/
{
    NmpMulticastSetNullAddressParameters(Network, Parameters);

    Parameters->ConfigType = NmMcastConfigAuto;
    NmpCalculateLeaseRenewTime(
        Network,
        Parameters->ConfigType,
        &Parameters->LeaseObtained,
        &Parameters->LeaseExpires
        );

    return(ERROR_SUCCESS);
    
} // NmpMulticastSetNoAddressParameters


DWORD
NmpRenewMulticastAddressLease(
    IN  PNM_NETWORK   Network
    )
/*++

Routine Description:

    Renew a multicast address lease, as determined by lease
    parameters stored in the cluster database.
    
Notes:

    Called with NM lock held and must return with NM lock held.
    
--*/
{
    DWORD                           status;
    LPCWSTR                         networkId = OmObjectId(Network);
    HDMKEY                          networkKey = NULL;
    HDMKEY                          netParamKey = NULL;
    BOOLEAN                         lockAcquired = TRUE;
    
    MCAST_CLIENT_UID                requestId = { NULL, 0 };
    LPWSTR                          serverAddress = NULL;
    DWORD                           serverAddressLength = 0;
    LPWSTR                          mcastAddress = NULL;
    DWORD                           mcastAddressLength = 0;
    LPWSTR                          oldMcastAddress = NULL;

    NM_NETWORK_MULTICAST_PARAMETERS parameters;
    DWORD                           deferRetry = 0;
    BOOLEAN                         localInterface = FALSE;


    localInterface = (BOOLEAN)(Network->LocalInterface != NULL);

    if (localInterface) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Renewing multicast address lease for "
            "network %1!ws!.\n",
            networkId
            );
    } else {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Attempting to renew multicast address "
            "lease for network %1!ws! despite the lack of "
            "a local interface.\n",
            networkId
            );
    }

    RtlZeroMemory(&parameters, sizeof(parameters));

    //
    // Get the lease parameters from the network object.
    //
    status = NmpMulticastGetNetworkLeaseParameters(
                 Network,
                 &requestId,
                 &serverAddress,
                 &mcastAddress
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Failed to find multicast lease "
            "parameters in network object %1!ws!, "
            "status %2!u!.\n",
            networkId, status
            );
    }

    //
    // Release the NM lock.
    //
    NmpReleaseLock();
    lockAcquired = FALSE;

    //
    // Check if we found the parameters we need. If not,
    // try the cluster database.
    //
    if (status != ERROR_SUCCESS) {

        status = NmpMulticastGetDatabaseLeaseParameters(
                     Network,
                     &networkKey,
                     &netParamKey,
                     &requestId,
                     &serverAddress,
                     &mcastAddress
                     );
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to find multicast lease "
                "parameters for network %1!ws! in "
                "cluster database, status %2!u!.\n",
                networkId, status
                );
        }
    }

    //
    // Remember the old multicast address.
    //
    if (mcastAddress != NULL) {
        status = NmpStoreString(mcastAddress, &oldMcastAddress, NULL);
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to copy current multicast "
                "address (%1!ws!) for network %2!ws! "
                "during lease renewal, status %3!u!.\n",
                mcastAddress, networkId, status
                );
            //
            // Not a fatal error. Only affects event-log
            // decision.
            //
            oldMcastAddress = NULL;
        }
    }

    //
    // Get an address either by renewing a current 
    // lease or obtaining a new lease.
    //
    status = NmpGetMulticastAddress(
                 Network,
                 &mcastAddress,
                 &serverAddress,
                 &requestId,
                 &parameters
                 );
    if (status != ERROR_SUCCESS) {
        if (status == ERROR_TIMEOUT) {
            //
            // The MADCAP server, if it exists, is currently not
            // responding.
            //
            status = NmpMulticastNeedRetryRenew(
                         Network,
                         &deferRetry
                         );
            if (status != ERROR_SUCCESS || deferRetry == 0) {

                //
                // Choose an address, but only if there is a
                // local interface on this network. Otherwise,
                // we cannot assume that the MADCAP server is
                // unresponsive because we may have no way to 
                // contact it.
                //
                if (!localInterface) {
                    status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NM] Cannot choose a multicast address "
                        "for network %1!ws! because this node "
                        "has no local interface.\n",
                        networkId
                        );
                    goto error_exit;
                }
                
                status = NmpChooseMulticastAddress(
                             Network, 
                             &parameters
                             );
                if (status != ERROR_SUCCESS) {
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NM] Failed to choose a default multicast "
                        "address for network %1!ws!, status %2!u!.\n",
                        networkId, status
                        );
                    goto error_exit;
                } else {
                    NmpReportMulticastAddressChoice(
                        Network,
                        parameters.Address,
                        oldMcastAddress
                        );
                }
            } else {

                //
                // Set the renew timer once we reacquire the 
                // network lock.
                //
            }
        }
    } else {
        NmpReportMulticastAddressLease(
            Network,
            &parameters,
            oldMcastAddress
            );
    }

    if (deferRetry == 0) {

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to obtain a multicast "
                "address for network %1!ws! during "
                "lease renewal, status %2!u!.\n",
                networkId, status
                );
            NmpReportMulticastAddressFailure(Network, status);
            NmpMulticastSetNoAddressParameters(Network, &parameters);
        }

        //
        // This may be the first configuration for this
        // network for this cluster instantiation, so
        // generate a new salt value.
        //
        status = NmpGenerateMulticastKeySalt(
                     Network,
                     &parameters.Salt,
                     &parameters.SaltLength
                     );
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to generate multicast "
                "key salt for network %1!ws! during "
                "lease renewal, status %2!u!.\n",
                networkId, status
                );
            goto error_exit;
        }

        //
        // Disseminate the new multicast parameters.
        //
        status = NmpMulticastNotifyConfigChange(
                     Network,
                     networkKey,
                     &netParamKey,
                     &parameters,
                     NULL,
                     0
                     );
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to disseminate multicast "
                "configuration for network %1!ws! during "
                "lease renewal, status %2!u!.\n",
                networkId, status
                );
            goto error_exit;
        }
    }

error_exit:

    if (lockAcquired && (networkKey != NULL || netParamKey != NULL)) {
        NmpReleaseLock();
        lockAcquired = FALSE;
    }

    if (networkKey != NULL) {
        DmCloseKey(networkKey);
        networkKey = NULL;
    }

    if (netParamKey != NULL) {
        DmCloseKey(netParamKey);
        netParamKey = NULL;
    }

    if (requestId.ClientUID != NULL) {
        MIDL_user_free(requestId.ClientUID);
        RtlZeroMemory(&requestId, sizeof(requestId));
    }

    if (mcastAddress != NULL) {
        MIDL_user_free(mcastAddress);
        mcastAddress = NULL;
    }

    if (serverAddress != NULL) {
        MIDL_user_free(serverAddress);
        serverAddress = NULL;
    }

    if (oldMcastAddress != NULL) {
        MIDL_user_free(oldMcastAddress);
        oldMcastAddress = NULL;
    }

    NmpMulticastFreeParameters(&parameters);

    if (!lockAcquired) {
        NmpAcquireLock();
        lockAcquired = TRUE;
    }

    if (deferRetry != 0) {

        //
        // Now that the lock is held, start the timer to 
        // renew again.
        //
        NmpStartNetworkMulticastAddressRenewTimer(
            Network,
            NMP_MADCAP_TO_NM_TIME(deferRetry)
            );

        status = ERROR_SUCCESS;
    }

    return(status);

} // NmpRenewMulticastAddressLease


DWORD
NmpReleaseMulticastAddress(
    IN     PNM_NETWORK       Network
    )
/*++

Routine Description:

    Contacts MADCAP server to release a multicast address
    that was previously obtained in a lease.
    
    If multiple addresses need to be released, reschedules
    MADCAP worker thread.
    
Notes:

    Called and must return with NM lock held.
    
--*/
{
    DWORD                              status;
    LPCWSTR                            networkId = OmObjectId(Network);
    BOOLEAN                            lockAcquired = TRUE;
    PNM_NETWORK_MADCAP_ADDRESS_RELEASE releaseInfo = NULL;
    PLIST_ENTRY                        entry;

    UCHAR                     requestBuffer[NMP_MADCAP_REQUEST_BUFFER_SIZE];
    PMCAST_LEASE_REQUEST      request;

    //
    // Pop a lease data structure off the release list.
    //
    if (IsListEmpty(&(Network->McastAddressReleaseList))) {
        return(ERROR_SUCCESS);
    }

    entry = RemoveHeadList(&(Network->McastAddressReleaseList));
    releaseInfo = CONTAINING_RECORD(
                      entry,
                      NM_NETWORK_MADCAP_ADDRESS_RELEASE,
                      Linkage
                      );

    //
    // Release the network lock.
    //
    NmpReleaseLock();
    lockAcquired = FALSE;
    
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Releasing multicast address %1!ws! for "
        "network %2!ws!.\n",
        releaseInfo->McastAddress, networkId
        );

    //
    // Initialize MADCAP, if not done already.
    //
    if (!NmpMadcapClientInitialized) {
        DWORD madcapVersion = MCAST_API_CURRENT_VERSION;
        status = McastApiStartup(&madcapVersion);
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to initialize MADCAP API, "
                "status %1!u!.\n",
                status
                );
            goto error_exit;
        }
        NmpMadcapClientInitialized = TRUE;
    }

    //
    // Build the MADCAP request structure.
    //
    request = (PMCAST_LEASE_REQUEST) &requestBuffer[0];
    RtlZeroMemory(request, sizeof(requestBuffer));
    request->MinLeaseDuration = 0;       // currently ignored
    request->MinAddrCount = 1;           // currently ignored
    request->MaxLeaseStartTime = (LONG) time(NULL); // currently ignored
    request->AddrCount = 1;

    request->pAddrBuf = (PBYTE)request + NMP_MADCAP_REQUEST_ADDR_OFFSET;

    status = ClRtlTcpipStringToAddress(
                 releaseInfo->McastAddress,
                 ((PULONG) request->pAddrBuf)
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to convert requested address %1!ws! "
            "into a TCP/IP address, status %2!u!.\n",
            releaseInfo->McastAddress, status
            );
        goto error_exit;
    }

    status = ClRtlTcpipStringToAddress(
                 releaseInfo->ServerAddress,
                 (PULONG) &(request->ServerAddress.IpAddrV4)
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to convert server address %1!ws! "
            "into a TCP/IP address, status %2!u!.\n",
            releaseInfo->ServerAddress, status
            );
        goto error_exit;
    }

    //
    // Call MADCAP to release the address.
    //
    status = McastReleaseAddress(
                 AF_INET,
                 &releaseInfo->RequestId,
                 request
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to release multicast address %1!ws! "
            "through MADCAP server %2!ws!, status %3!u!.\n",
            releaseInfo->McastAddress, 
            releaseInfo->ServerAddress, 
            status
            );
        goto error_exit;
    }

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Successfully released multicast address "
        "%1!ws! for network %2!ws!.\n",
        releaseInfo->McastAddress, networkId
        );

error_exit:

    NmpFreeMulticastAddressRelease(releaseInfo);

    if (!lockAcquired) {
        NmpAcquireLock();
        lockAcquired = TRUE;
    }

    if (!IsListEmpty(&(Network->McastAddressReleaseList))) {
        NmpScheduleMulticastAddressRelease(Network);
    }

    return(status);

} // NmpReleaseMulticastAddress


DWORD
NmpProcessMulticastConfiguration(
    IN     PNM_NETWORK                      Network,
    IN     PNM_NETWORK_MULTICAST_PARAMETERS Parameters,
    OUT    PNM_NETWORK_MULTICAST_PARAMETERS UndoParameters
    )
/*++

Routine Description:

    Processes configuration changes and calls clusnet if
    appropriate.
    
    If multicast is disabled, the address, key, and
    salt may be NULL. In this case, choose defaults
    to send to clusnet, but do not commit the changes
    in the local network object.
    
Arguments:

    Network - network to process
    
    Parameters - parameters with which to configure Network.
                 If successful, Parameters data structure
                 is cleared.
                 
    UndoParameters - If successful, former multicast 
                 parameters of Network. Must be freed
                 by caller.
    
Notes:

    Called and returns with NM lock held.    
        
--*/
{
    DWORD   status = ERROR_SUCCESS;
    LPWSTR  networkId = (LPWSTR) OmObjectId(Network);
    BOOLEAN callClusnet = FALSE;
    LPWSTR  mcastAddress = NULL;
    DWORD   brand;
    PVOID   tdiMcastAddress = NULL;
    DWORD   tdiMcastAddressLength = 0;
    UUID    networkIdGuid;

    BOOLEAN mcastAddrChange = FALSE;
    BOOLEAN mcastKeyChange = FALSE;
    BOOLEAN mcastSaltChange = FALSE;

#if CLUSTER_BETA
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Processing multicast configuration parameters "
        "for network %1!ws!.\n",
        networkId
        /* , 
        ((Parameters->Address != NULL) ? Parameters->Address : L"<NULL>") */
        );
#endif // CLUSTER_BETA

    //
    // Zero the undo parameters so that freeing them is not
    // destructive.
    //
    RtlZeroMemory(UndoParameters, sizeof(*UndoParameters));

    //
    // If multicast is not disabled, we need valid parameters.
    //
    if (!Parameters->Disabled && 
        ((Parameters->Address == NULL) || 
         (Parameters->Key == NULL) || 
         (Parameters->Salt == NULL)
         )) {
        status = ERROR_INVALID_PARAMETER;
        goto error_exit;
    }
    
    //
    // First determine if we need to reconfigure clusnet.
    //
    if (Parameters->Address != NULL) {
        if (Network->MulticastAddress == NULL ||
            wcscmp(Network->MulticastAddress, Parameters->Address) != 0) {
            
            // The multicast address in the config parameters is 
            // different from the one in memory.
            mcastAddrChange = TRUE;
        }
        mcastAddress = Parameters->Address;
    } else {
        mcastAddress = NmpNullMulticastAddress;
    }

    if (Parameters->Key != NULL) {
        if (Network->MulticastKey == NULL ||
            (Network->MulticastKeyLength != Parameters->KeyLength ||
             RtlCompareMemory(
                 Network->MulticastKey,
                 Parameters->Key,
                 Parameters->KeyLength
                 ) != Parameters->KeyLength
             )) {

            // The key in the config parameters is different 
            // from the key in memory. 
            mcastKeyChange = TRUE;
        }
    }

    if (Parameters->Salt != NULL) {
        if (Network->MulticastKeySalt == NULL ||
            (Network->MulticastKeySaltLength != Parameters->SaltLength ||
             RtlCompareMemory(
                 Network->MulticastKeySalt,
                 Parameters->Salt,
                 Parameters->SaltLength
                 ) != Parameters->SaltLength
             )) {

            // The salt in the config parameters is different 
            // from the salt in memory.
            mcastSaltChange = TRUE;
        }
    }

    if (!Parameters->Disabled && 
        (NmpIsNetworkMulticastEnabled(Network))) {

        // Multicast is now enabled. Call clusnet with the new address.
        callClusnet = TRUE;
    }
    
    if (Parameters->Disabled && 
        (NmpIsNetworkMulticastEnabled(Network))) {

        // Multicast is now disabled. Call clusnet with NULL address
        // regardless of which address was specified in the 
        // parameters.
        mcastAddress = NmpNullMulticastAddress;
        callClusnet = TRUE;
    }

    if (!Parameters->Disabled && 
        (mcastAddrChange || mcastKeyChange || mcastSaltChange)) {

        // The multicast address, key, and/or salt changed and 
        // multicast is enabled.
        callClusnet = TRUE;
    }

    //
    // If this network does not have a local interface, do not
    // plumb the configuration into clusnet. If this network
    // does have a local interface, the network must already
    // be registered.
    //
    if (Network->LocalInterface != NULL) {
        //
        // Verify that the network is registered.
        //
        if (!NmpIsNetworkRegistered(Network)) {
            status = ERROR_CLUSTER_NETWORK_NOT_FOUND;
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] Cannot configure multicast parameters "
                "for unregistered network %1!ws!.\n",
                networkId
                );
            goto error_exit;
        }
    } else {
        //
        // Do not call clusnet, but don't fail call. Also, 
        // store new parameters in network object.
        //
        callClusnet = FALSE;
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Not configuring cluster network driver with "
            "multicast parameters because network %1!ws! "
            "has no local interface.\n",
            networkId
            );
    }

    //
    // Plumb the new configuration into clusnet. The new 
    // configuration will reflect the current parameters
    // block except for the address, which is stored in
    // temporary mcastAddress variable. mcastAddress points
    // either to the address in the parameters block or 
    // the NULL multicast address if we are disabling.
    //
    if (callClusnet) {

        //
        // Build a TDI address from the address string.
        //
        status = ClRtlBuildTcpipTdiAddress(
                     mcastAddress,
                     Network->LocalInterface->ClusnetEndpoint,
                     &tdiMcastAddress,
                     &tdiMcastAddressLength
                     );
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to build TCP/IP TDI multicast address "
                "%1!ws! port %2!ws! for network %3!ws!, "
                "status %4!u!.\n",
                mcastAddress, 
                Network->LocalInterface->ClusnetEndpoint,
                networkId, status
                );
            goto error_exit;
        }

        //
        // Use the lower bytes of the network GUID for the
        // brand.
        //
        status = UuidFromString(networkId, &networkIdGuid);
        if (status == RPC_S_OK) {
            brand = *((PDWORD)&(networkIdGuid.Data4[4]));
        } else {
            brand = 0;
        }

        ClRtlLogPrint(LOG_NOISE,
            "[NM] Configuring cluster network driver with "
            "multicast parameters for network %1!ws!.\n",
            networkId
            );

        status = ClusnetConfigureMulticast(
                     NmClusnetHandle,
                     Network->ShortId,
                     brand,
                     tdiMcastAddress,
                     tdiMcastAddressLength,
                     Parameters->Key, 
                     Parameters->KeyLength,
                     Parameters->Salt, 
                     Parameters->SaltLength
                     );
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] Failed to configure multicast parameters "
                "for network %1!ws!, status %2!u!.\n",
                networkId, status
                );
            goto error_exit;
        } else {
            if (!Parameters->Disabled) {
                Network->Flags |= NM_FLAG_NET_MULTICAST_ENABLED;
            } else {
                Network->Flags &= ~NM_FLAG_NET_MULTICAST_ENABLED;
            }
        }
    }

    //
    // If successful, commit the changes to the network object.
    // The old state of the network object will be stored in
    // the undo parameters, in case we need to undo this change.
    // The new state of the network object will reflect the 
    // paramters block, including the address (even if we
    // disabled).
    //
    UndoParameters->Address = Network->MulticastAddress;
    Network->MulticastAddress = Parameters->Address;

    UndoParameters->Key = Network->MulticastKey;
    Network->MulticastKey = Parameters->Key;
    UndoParameters->KeyLength = Network->MulticastKeyLength;
    Network->MulticastKeyLength = Parameters->KeyLength;

    UndoParameters->Salt = Network->MulticastKeySalt;
    Network->MulticastKeySalt = Parameters->Salt;
    UndoParameters->SaltLength = Network->MulticastKeySaltLength;
    Network->MulticastKeySaltLength = Parameters->SaltLength;

    UndoParameters->LeaseObtained = Network->MulticastLeaseObtained;
    Network->MulticastLeaseObtained = Parameters->LeaseObtained;
    UndoParameters->LeaseExpires = Network->MulticastLeaseExpires;
    Network->MulticastLeaseExpires = Parameters->LeaseExpires;

    UndoParameters->LeaseRequestId = Network->MulticastLeaseRequestId;
    Network->MulticastLeaseRequestId = Parameters->LeaseRequestId;

    UndoParameters->LeaseServer = Network->MulticastLeaseServer;
    Network->MulticastLeaseServer = Parameters->LeaseServer;

    //
    // Zero the parameters structure so that the memory now
    // pointed to by the network object is not freed.
    //
    RtlZeroMemory(Parameters, sizeof(*Parameters));

error_exit:

    if (tdiMcastAddress != NULL) {
        LocalFree(tdiMcastAddress);
        tdiMcastAddress = NULL;
    }

    return(status);

} // NmpProcessMulticastConfiguration


VOID
NmpNetworkMadcapWorker(
    IN PCLRTL_WORK_ITEM   WorkItem,
    IN DWORD              Status,
    IN DWORD              BytesTransferred,
    IN ULONG_PTR          IoContext
    )
/*++

Routine Description:

    Worker routine for deferred operations on network objects.
    Invoked to process items placed in the cluster delayed work queue.

Arguments:

    WorkItem - A pointer to a work item structure that identifies the
               network for which to perform work.

    Status - Ignored.

    BytesTransferred - Ignored.

    IoContext - Ignored.

Return Value:

    None.

Notes:

    This routine is run in an asynchronous worker thread.
    The NmpActiveThreadCount was incremented when the thread was
    scheduled. The network object was also referenced.

--*/
{
    DWORD         status;
    PNM_NETWORK   network = (PNM_NETWORK) WorkItem->Context;
    LPCWSTR       networkId = OmObjectId(network);
    BOOLEAN       rescheduled = FALSE;


    NmpAcquireLock();

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Worker thread processing MADCAP client requests "
        "for network %1!ws!.\n",
        networkId
        );

    if ((NmpState >= NmStateOnlinePending) && !NM_DELETE_PENDING(network)) {

        while (TRUE) {

            if (!(network->Flags & NM_NET_MADCAP_WORK_FLAGS)) {
                //
                // No more work to do - break out of loop.
                //
                break;
            }

            //
            // Reconfigure multicast if needed.
            //
            if (network->Flags & NM_FLAG_NET_RECONFIGURE_MCAST) {
                network->Flags &= ~NM_FLAG_NET_RECONFIGURE_MCAST;

                status = NmpReconfigureMulticast(network);
                if (status != ERROR_SUCCESS) {
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NM] Failed to reconfigure multicast "
                        "for network %1!ws!, status %2!u!.\n",
                        networkId, status
                        );
                } 
            }

            //
            // Renew an address lease if needed.
            //
            if (network->Flags & NM_FLAG_NET_RENEW_MCAST_ADDRESS) {
                network->Flags &= ~NM_FLAG_NET_RENEW_MCAST_ADDRESS;

                status = NmpRenewMulticastAddressLease(network);
                if (status != ERROR_SUCCESS) {
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NM] Failed to renew multicast address "
                        "lease for network %1!ws!, status %2!u!.\n",
                        networkId, status
                        );
                } 
            }

            //
            // Release an address lease if needed.
            //
            if (network->Flags & NM_FLAG_NET_RELEASE_MCAST_ADDRESS) {
                network->Flags &= ~NM_FLAG_NET_RELEASE_MCAST_ADDRESS;

                status = NmpReleaseMulticastAddress(network);
                if (status != ERROR_SUCCESS) {
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NM] Failed to release multicast address "
                        "lease for network %1!ws!, status %2!u!.\n",
                        networkId, status
                        );
                } 
            }

            if (!(network->Flags & NM_NET_MADCAP_WORK_FLAGS)) {
                //
                // No more work to do - break out of loop.
                //
                break;
            }

            //
            // More work to do. Resubmit the work item. We do this instead
            // of looping so we don't hog the worker thread. If
            // rescheduling fails, we will loop again in this thread.
            //
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] More MADCAP work to do for network %1!ws!. "
                "Rescheduling worker thread.\n",
                networkId
                );

            status = NmpScheduleNetworkMadcapWorker(network);

            if (status == ERROR_SUCCESS) {
                rescheduled = TRUE;
                break;
            }

        }
    
    } else {
        network->Flags &= ~NM_NET_MADCAP_WORK_FLAGS;
    }

    if (!rescheduled) {
        network->Flags &= ~NM_FLAG_NET_MADCAP_WORKER_RUNNING;
    }

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Worker thread finished processing MADCAP client "
        "requests for network %1!ws!.\n",
        networkId
        );

    NmpLockedLeaveApi();

    NmpReleaseLock();

    OmDereferenceObject(network);

    return;

} // NmpNetworkMadcapWorker

DWORD
NmpScheduleNetworkMadcapWorker(
    PNM_NETWORK   Network
    )
/*++

Routine Description:

    Schedule a worker thread to execute madcap client
    requests for this network

Arguments:

    Network - Pointer to the network for which to schedule a worker thread.

Return Value:

    A Win32 status code.

Notes:

    Called with the NM global lock held.

--*/
{
    DWORD     status;
    LPCWSTR   networkId = OmObjectId(Network);


    ClRtlInitializeWorkItem(
        &(Network->MadcapWorkItem),
        NmpNetworkMadcapWorker,
        (PVOID) Network
        );

    status = ClRtlPostItemWorkQueue(
                 CsDelayedWorkQueue,
                 &(Network->MadcapWorkItem),
                 0,
                 0
                 );

    if (status == ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Scheduled worker thread to execute MADCAP "
            "client requests for network %1!ws!.\n",
            networkId
            );

        NmpActiveThreadCount++;
        Network->Flags |= NM_FLAG_NET_MADCAP_WORKER_RUNNING;
        OmReferenceObject(Network);
    }
    else {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Failed to schedule worker thread to execute "
            "MADCAP client requests for network "
            "%1!ws!, status %2!u!\n",
            networkId,
            status
            );
    }

    return(status);

} // NmpScheduleNetworkMadcapWorker


VOID
NmpShareMulticastAddressLease(
    IN     PNM_NETWORK                        Network,
    IN     NM_MCAST_CONFIG                    ConfigType
    )
/*++

Routine description:

    Called after a non-manual refresh of the multicast
    configuration, sets a timer to renew the multicast 
    address lease for this network, if one exists.
    
Notes:

    Called and returns with NM lock held.    
    
--*/
{
    DWORD                 status;
    LPCWSTR               networkId = OmObjectId(Network);
    DWORD                 disabled;
    BOOLEAN               lockAcquired = TRUE;

    time_t                leaseObtained;
    time_t                leaseExpires;
    DWORD                 leaseTimer = 0;
    NM_MCAST_LEASE_STATUS leaseStatus = NmMcastLeaseValid;

#if CLUSTER_BETA
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Sharing ownership of multicast lease "
        "for network %1!ws!.\n",
        networkId
        );
#endif // CLUSTER_BETA

    NmpCheckMulticastAddressLease(
        Network,
        &leaseStatus,
        &leaseObtained,
        &leaseExpires
        );

    if (leaseStatus != NmMcastLeaseValid) {
        NmpScheduleMulticastAddressRenewal(Network);
    } else {
        leaseTimer = NmpCalculateLeaseRenewTime(
                         Network,
                         ConfigType,
                         &leaseObtained,
                         &leaseExpires
                         );

        NmpStartNetworkMulticastAddressRenewTimer(Network, leaseTimer);
    }

    return;

} // NmpShareMulticastAddressLease


DWORD
NmpMulticastFormManualConfigParameters(
    IN  PNM_NETWORK                        Network,
    IN  HDMKEY                             NetworkKey,
    IN  HDMKEY                             NetworkParametersKey,
    IN  BOOLEAN                            DisableConfig,
    IN  DWORD                              Disabled,
    IN  BOOLEAN                            McastAddressConfig,
    IN  LPWSTR                             McastAddress,
    OUT BOOLEAN                          * NeedUpdate, 
    OUT PNM_NETWORK_MULTICAST_PARAMETERS   Parameters
    )
/*++

Routine Description:

    Using parameters provided and those already configured, 
    form a parameters structure to reflect a manual 
    configuration.
    
Arguments:

    Network - network being configured
    
    NetworkKey - network key in cluster database
    
    NetworkParametersKey - network parameters key in cluster database
    
    DisableConfig - whether the disabled value was set
    
    Disabled - if DisableConfig, the value that was set
    
    McastAddressConfig - whether the multicast address value was set
    
    McastAddress - if McastAddressConfig, the value that was set
    
    NeedUpdate - indicates whether an update is needed, i.e. whether
                 anything changed
    
    Parameters - parameter structure, allocated by caller, to fill in
    
--*/
{
    DWORD                              status;
    LPCWSTR                            networkId = OmObjectId(Network);
    BOOLEAN                            lockAcquired = FALSE;
    DWORD                              netobjDisabled;
    BOOLEAN                            disabledChange = FALSE;
    BOOLEAN                            mcastAddressDefault = FALSE;
    BOOLEAN                            mcastAddressChange = FALSE;
    BOOLEAN                            getAddress = FALSE;
    DWORD                              len;
    BOOLEAN                            localInterface = FALSE;

    LPWSTR                             mcastAddress = NULL;
    LPWSTR                             serverAddress = NULL;
    MCAST_CLIENT_UID                   requestId = {NULL, 0};

    PNM_NETWORK_MADCAP_ADDRESS_RELEASE release = NULL;

    //
    // Validate incoming parameters.
    //
    // Any nonzero disabled value is set to 1 for simplification.
    //
    if (DisableConfig) {
        if (Disabled != 0) {
            Disabled = 1;
        }
    }

    //
    // Non-valid and NULL multicast addresses signify
    // revert-to-default.
    //
    if (McastAddressConfig &&
        (McastAddress == NULL || !NmpMulticastValidateAddress(McastAddress))) {
            
        mcastAddressDefault = TRUE;
        McastAddress = NULL;
    }
    
    //
    // Base decisions on the current status of the network
    // object.
    //
    NmpAcquireLock();
    lockAcquired = TRUE;

    netobjDisabled = (NmpIsNetworkMulticastEnabled(Network) ? 0 : 1);

    //
    // See if anything changed.
    //
    if (DisableConfig) {
        if (Disabled != netobjDisabled) {
            disabledChange = TRUE;
        }
    }
    
    if (McastAddressConfig) {
        if (mcastAddressDefault) {
            mcastAddressChange = TRUE;
        } else {
            if (Network->MulticastAddress != NULL) {
                if (lstrcmpW(Network->MulticastAddress, McastAddress) != 0) {
                    mcastAddressChange = TRUE;
                }
            } else {
                mcastAddressChange = TRUE;
            }
        }
    }

    if (!disabledChange && !mcastAddressChange) {
        *NeedUpdate = FALSE;
        status = ERROR_SUCCESS;
#if CLUSTER_BETA
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Private property update to network %1!ws! "
            "contains no multicast changes.\n",
            networkId
            );
#endif // CLUSTER_BETA
        goto error_exit;
    }

    //
    // Initialize the parameters from the network object.
    //
    status = NmpMulticastCreateParameters(
                 netobjDisabled,
                 Network->MulticastAddress,
                 NULL,  // salt
                 0,     // salt length
                 NULL,  // key
                 0,     // key length
                 Network->MulticastLeaseObtained,
                 Network->MulticastLeaseExpires,
                 &Network->MulticastLeaseRequestId,
                 Network->MulticastLeaseServer,
                 NmMcastConfigManual,
                 Parameters
                 );
    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    localInterface = (BOOLEAN)(Network->LocalInterface != NULL);

    NmpReleaseLock();
    lockAcquired = FALSE;

    if (mcastAddressChange) {

        //
        // Figure out what address to use.
        //
        if (!mcastAddressDefault) {

            //
            // An address was dictated.
            //
            // If we currently have a leased address, release it.
            //
            if (NmpNeedRelease(
                    Parameters->Address,
                    Parameters->LeaseServer,
                    &(Parameters->LeaseRequestId),
                    Parameters->LeaseExpires
                    )) {

                status = NmpCreateMulticastAddressRelease(
                             Parameters->Address,
                             Parameters->LeaseServer,
                             &(Parameters->LeaseRequestId),
                             &release
                             );
                if (status != ERROR_SUCCESS) {
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NM] Failed to create multicast address "
                        "release for address %1!ws! on network %2!ws! "
                        "during manual configuration, status %3!u!.\n",
                        ((Parameters->Address != NULL) ?
                         Parameters->Address : L"<NULL>"), 
                        networkId, status
                        );
                    goto error_exit;
                }
            }
            
            //
            // Store the new address in the parameters data structure.
            //
            status = NmpStoreString(
                         McastAddress,
                         &Parameters->Address,
                         NULL
                         );
            if (status != ERROR_SUCCESS) {
                goto error_exit;
            }

            Parameters->ConfigType = NmMcastConfigManual;
            Parameters->LeaseObtained = 0;
            Parameters->LeaseExpires = 0;

            //
            // Clear out the lease server.
            //
            len = (Parameters->LeaseServer != NULL) ?
                NM_WCSLEN(Parameters->LeaseServer) : 0;
            status = NmpStoreString(
                         NmpNullMulticastAddress,
                         &Parameters->LeaseServer,
                         &len
                         );
            if (status != ERROR_SUCCESS) {
                goto error_exit;
            }
        
        } else {

            //
            // Need to find an address elsewhere.
            //
            getAddress = TRUE;
        }
    }

    //
    // We also may need to renew the lease if we are moving from
    // disabled to enabled and an address was not specified, but
    // only if we don't already have a lease that doesn't expire.
    //
    if (disabledChange && !Disabled) {

        Parameters->Disabled = 0;

        if (!mcastAddressChange) {

            //
            // An address was not set. All we currently have is
            // what's in the network object (and copied to the
            // parameters block).
            //
            if (Parameters->Address != NULL &&
                NmpMulticastValidateAddress(Parameters->Address)) {

                //
                // We already have a valid multicast address, but
                // the lease may need to be renewed.
                //
                if (Parameters->LeaseExpires != 0) {
                    getAddress = TRUE;
                } else {
                    Parameters->ConfigType = NmMcastConfigManual;
                }
            
            } else {

                //
                // We have no valid multicast address. Get one.
                //
                getAddress = TRUE;
            }
        }
    }

    //
    // We don't bother renewing the lease if we are disabling.
    //
    if (Disabled) {
        getAddress = FALSE;
        Parameters->Disabled = Disabled;
    
        //
        // If we currently have a leased address that we haven't
        // already decided to release, release it.
        //
        if (release == NULL && NmpNeedRelease(
                                   Parameters->Address,
                                   Parameters->LeaseServer,
                                   &(Parameters->LeaseRequestId),
                                   Parameters->LeaseExpires
                                   )) {

            status = NmpCreateMulticastAddressRelease(
                         Parameters->Address,
                         Parameters->LeaseServer,
                         &(Parameters->LeaseRequestId),
                         &release
                         );
            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Failed to create multicast address "
                    "release for address %1!ws! on network %2!ws! "
                    "during manual configuration, status %3!u!.\n",
                    ((Parameters->Address != NULL) ?
                     Parameters->Address : L"<NULL>"), 
                    networkId, status
                    );
                goto error_exit;
            }

            //
            // Since we are releasing the address, there is not
            // much point in saving it. If we re-enable multicast
            // in the future, we will request a fresh lease.
            //
            len = (Parameters->LeaseServer != NULL) ?
                NM_WCSLEN(Parameters->LeaseServer) : 0;
            status = NmpStoreString(
                         NmpNullMulticastAddress,
                         &Parameters->LeaseServer,
                         &len
                         );
            if (status != ERROR_SUCCESS) {
                goto error_exit;
            }
            
            len = (Parameters->Address != NULL) ?
                NM_WCSLEN(Parameters->Address) : 0;
            status = NmpStoreString(
                         NmpNullMulticastAddress,
                         &Parameters->Address,
                         &len
                         );
            if (status != ERROR_SUCCESS) {
                goto error_exit;
            }

            // requestId is initialized to be blank
            status = NmpStoreRequestId(
                         &requestId, 
                         &Parameters->LeaseRequestId
                         );
            if (status != ERROR_SUCCESS) {
                goto error_exit;
            }

            //
            // Remember that this had been a MADCAP address.
            //
            Parameters->ConfigType = NmMcastConfigMadcap;
        
        } else if (!(mcastAddressChange && !mcastAddressDefault)) {
            
            //
            // If no address is being set, we may keep the former
            // address in the database even though it is not being
            // used. We also need to remember the way we got that
            // address in case it is ever used again. If we fail 
            // to determine the previous configuration, we need 
            // to set it to manual so that we don't lose a manual 
            // configuration.
            //
            status = NmpQueryMulticastConfigType(
                         Network,
                         NetworkKey,
                         &NetworkParametersKey,
                         &Parameters->ConfigType
                         );
            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Failed to query multicast address "
                    "config type for network %1!ws! during "
                    "manual configuration, status %2!u!.\n",
                    networkId, status
                    );
                Parameters->ConfigType = NmMcastConfigManual;
            }
        }        
    }

    //
    // Synchronously get a new address.
    //
    if (getAddress) {

        //
        // Create temporary strings for proposed address, lease
        // server, and request id.
        //
        status = NmpStoreString(Parameters->Address, &mcastAddress, NULL);
        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }
    
        status = NmpStoreString(Parameters->LeaseServer, &serverAddress, NULL);
        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }

        status = NmpStoreRequestId(&Parameters->LeaseRequestId, &requestId);
        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }

        //
        // Get the address.
        //
        status = NmpGetMulticastAddress(
                     Network,
                     &mcastAddress,
                     &serverAddress,
                     &requestId,
                     Parameters
                     );
        if (status != ERROR_SUCCESS) {
            if (status == ERROR_TIMEOUT) {
                //
                // MADCAP server is not responding. Choose an
                // address, but only if there is a local 
                // interface on this network. Otherwise, we 
                // cannot assume that the MADCAP server is
                // unresponsive because we may have no way to 
                // contact it.
                //
                if (!localInterface) {
                    status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NM] Cannot choose a multicast address "
                        "for network %1!ws! because this node "
                        "has no local interface.\n",
                        networkId
                        );
                }
                //
                status = NmpChooseMulticastAddress(
                             Network, 
                             Parameters
                             );
                if (status != ERROR_SUCCESS) {
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NM] Failed to choose a default multicast "
                        "address for network %1!ws!, status %2!u!.\n",
                        networkId, status
                        );
                } else {
                    NmpReportMulticastAddressChoice(
                        Network,
                        Parameters->Address,
                        NULL
                        );
                }
            }
        } else {
            NmpReportMulticastAddressLease(
                Network,
                Parameters,
                NULL
                );
        }

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to get multicast address for "
                "network %1!ws! during manual configuration, "
                "status %2!u!.\n",
                networkId, status
                );
            NmpReportMulticastAddressFailure(Network, status);
            NmpMulticastSetNoAddressParameters(Network, Parameters);
        }
    }

    //
    // If we are not disabling multicast, we will need 
    // a new salt value.
    //
    if (!Disabled) {
        status = NmpGenerateMulticastKeySalt(
                     Network,
                     &Parameters->Salt,
                     &Parameters->SaltLength
                     );
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to generate multicast "
                "key salt for network %1!ws! during "
                "manual configuration, status %2!u!.\n",
                networkId, status
                );
            goto error_exit;
        }
    }

    *NeedUpdate = TRUE;

    //
    // Check if we have an address to release.
    //
    if (release != NULL) {
        NmpAcquireLock();
        NmpInitiateMulticastAddressRelease(Network, release);
        release = NULL;
        NmpReleaseLock();
    }

error_exit:

    if (lockAcquired) {
        NmpReleaseLock();
        lockAcquired = FALSE;
    }

    if (requestId.ClientUID != NULL) {
        MIDL_user_free(requestId.ClientUID);
        RtlZeroMemory(&requestId, sizeof(requestId));
    }

    if (mcastAddress != NULL && !NMP_GLOBAL_STRING(mcastAddress)) {
        MIDL_user_free(mcastAddress);
        mcastAddress = NULL;
    }

    if (serverAddress != NULL && !NMP_GLOBAL_STRING(serverAddress)) {
        MIDL_user_free(serverAddress);
        serverAddress = NULL;
    }

    if (release != NULL) {
        NmpFreeMulticastAddressRelease(release);
    }

    return(status);

} // NmpMulticastFormManualConfigParameters


DWORD
NmpReconfigureMulticast(
    IN PNM_NETWORK        Network
    )
/*++

Routine Description:

    Create the multicast configuration for this network
    for the cluster. This includes the following:
    
    - Check the address lease and renew if necessary.
    - Generate a key.
    - Generate a salt.
    
    The address lease is checked first. If the lease
    needs to be renewed, schedule a worker thread to
    do it asynchronously.
    
Notes:

    Called and returns with NM lock held.
    
--*/
{
    DWORD                           status;
    LPWSTR                          networkId = (LPWSTR) OmObjectId(Network);    
    HDMKEY                          networkKey = NULL;
    HDMKEY                          netParamKey = NULL;
    HDMKEY                          clusParamKey = NULL;
    BOOLEAN                         lockAcquired = TRUE;

    NM_NETWORK_MULTICAST_PARAMETERS params = { 0 };
    NM_MCAST_LEASE_STATUS           leaseStatus = NmMcastLeaseValid;
    DWORD                           mcastAddressLength = 0;


    ClRtlLogPrint(LOG_NOISE,
        "[NM] Reconfiguring multicast for network %1!ws!.\n",
        networkId
        );

    NmpReleaseLock();
    lockAcquired = FALSE;

    //
    // Check if multicast is disabled. This has the side-effect,
    // on success, of opening at least the network key, and
    // possibly the network parameters key (if it exists) and
    // the cluster parameters key.
    //
    status = NmpQueryMulticastDisabled(
                 Network,
                 &clusParamKey,
                 &networkKey,
                 &netParamKey,
                 &params.Disabled
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to determine whether multicast "
            "is disabled for network %1!ws!, status %2!u!.\n",
            networkId, status
            );
        goto error_exit;
    }

    //
    // Read the address from the database. It may have 
    // been configured manually, and we do not want to
    // lose it.
    //
    status = NmpQueryMulticastAddress(
                 Network,
                 networkKey,
                 &netParamKey,
                 &params.Address,
                 &mcastAddressLength
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to read multicast address "
            "for network %1!ws! from cluster "
            "database, status %2!u!.\n",
            networkId, status
            );
    }
    
    //
    // Only proceed with lease renewal if multicast is
    // not disabled.
    //
    if (!params.Disabled) {
        
        //
        // Check the address lease.
        //
        status = NmpQueryMulticastAddressLease(
                     Network,
                     networkKey,
                     &netParamKey,
                     &leaseStatus,
                     &params.LeaseObtained,
                     &params.LeaseExpires
                     );
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to determine multicast address "
                "lease status for network %1!ws!, status %2!u!.\n",
                networkId, status
                );
            if (params.Address == NULL) {

                // We did not find an address. Assume we
                // should obtain an address automatically.
                params.LeaseObtained = time(NULL);
                params.LeaseExpires = time(NULL);
                leaseStatus = NmMcastLeaseExpired;
            } else {

                // We found an address but not any lease
                // parameters. Assume that the address
                // was manually configured.
                params.ConfigType = NmMcastConfigManual;
                params.LeaseObtained = 0;
                params.LeaseExpires = 0;
                leaseStatus = NmMcastLeaseValid;
            }
        }

        //
        // If we think we have a valid lease, check first
        // how we got it. If the address was selected
        // rather than obtained via MADCAP, go through 
        // the MADCAP query process again.
        // 
        if (leaseStatus == NmMcastLeaseValid) {
            status = NmpQueryMulticastConfigType(
                         Network,
                         networkKey,
                         &netParamKey,
                         &params.ConfigType
                         );
            if (status != ERROR_SUCCESS) {
                // 
                // Since we already have an address, stick
                // with whatever information we deduced
                // from the lease expiration.
                //
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Failed to determine the type of the "
                    "multicast address for network %1!ws!, "
                    "status %2!u!. Assuming manual configuration.\n",
                    networkId, status
                    );
            } else if (params.ConfigType == NmMcastConfigAuto) {
                leaseStatus = NmMcastLeaseNeedsRenewal;
            }
        }

        //
        // If we need to renew the lease, we may block
        // indefinitely due to the madcap API. Schedule
        // the renewal and defer configuration to when
        // it completes.
        //
        if (leaseStatus != NmMcastLeaseValid) {

            NmpAcquireLock();

            NmpScheduleMulticastAddressRenewal(Network);

            NmpReleaseLock();

            status = ERROR_IO_PENDING;

            goto error_exit;

        } else {

            //
            // Ensure that the lease expiration is set correctly 
            // (a side effect of calculating the lease renew time).
            // We don't actually set the lease renew timer
            // here. Instead, we wait for the notification
            // that the new parameters have been disseminated
            // to all cluster nodes.
            //
            NmpCalculateLeaseRenewTime(
                Network,
                params.ConfigType,
                &params.LeaseObtained,
                &params.LeaseExpires
                );
        }
    }
    
    //
    // Generate a new multicast salt.
    //
    status = NmpGenerateMulticastKeySalt(
                 Network,
                 &params.Salt,
                 &params.SaltLength
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to generate multicast key salt for "
            "network %1!ws!, status %2!u!.\n",
            networkId, status
            );
        goto error_exit;
    }

    //
    // Registry keys are no longer needed.
    //
    if (clusParamKey != NULL) {
        DmCloseKey(clusParamKey);
        clusParamKey = NULL;
    }

    if (netParamKey != NULL) {
        DmCloseKey(netParamKey);
        netParamKey = NULL;
    }

    if (networkKey != NULL) {
        DmCloseKey(networkKey);
        networkKey = NULL;
    }

    //
    // Disseminate the configuration.
    //
    status = NmpMulticastNotifyConfigChange(
                 Network,
                 networkKey,
                 &netParamKey,
                 &params,
                 NULL,
                 0
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to disseminate multicast "
            "configuration for network %1!ws!, "
            "status %2!u!.\n",
            networkId, status
            );
        goto error_exit;
    }

error_exit:


    if (clusParamKey != NULL || netParamKey != NULL || networkKey != NULL) {
        if (lockAcquired) {
            NmpReleaseLock();
            lockAcquired = FALSE;
        }

        if (clusParamKey != NULL) {
            DmCloseKey(clusParamKey);
            clusParamKey = NULL;
        }

        if (netParamKey != NULL) {
            DmCloseKey(netParamKey);
            netParamKey = NULL;
        }

        if (networkKey != NULL) {
            DmCloseKey(networkKey);
            networkKey = NULL;
        }
    }

    NmpMulticastFreeParameters(&params);

    if (!lockAcquired) {
        NmpAcquireLock();
        lockAcquired = TRUE;
    }

    return(status);

} // NmpReconfigureMulticast


DWORD
NmpReconfigureClusterMulticast(
    VOID
    )
/*++

Routine Description:

    Configures multicast from scratch for all networks in cluster.
    
--*/
{
    DWORD          status = ERROR_SUCCESS;
    PNM_NETWORK  * networkList;
    DWORD          networkCount;
    PNM_NETWORK    network;
    PLIST_ENTRY    entry;
    DWORD          i = 0;

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Reconfiguring multicast on all cluster networks.\n"
        );

    NmpAcquireLock();

    networkCount = NmpNetworkCount;
    networkList = (PNM_NETWORK *) LocalAlloc(
                                      LMEM_FIXED, 
                                      networkCount * sizeof(PNM_NETWORK)
                                      );
    if (networkList == NULL) {
        NmpReleaseLock();
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    for (entry = NmpNetworkList.Flink;
         entry != &NmpNetworkList;
         entry = entry->Flink
        )
    {
        network = CONTAINING_RECORD(
                      entry,
                      NM_NETWORK,
                      Linkage
                      );

        //
        // Place a pointer to the network in the network list,
        // and reference the network so it doesn't disappear.
        //
        networkList[i] = network;
        NmpReferenceNetwork(network);
        i++;
        CL_ASSERT(i <= networkCount);
    }

    NmpReleaseLock();

    for (i = 0; i < networkCount; i++) {

        status = NmpReconfigureMulticast(networkList[i]);
        if (status != ERROR_SUCCESS) {
            if (status == ERROR_IO_PENDING) {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Deferred multicast reconfiguration "
                    "for network %1!ws! to worker thread.\n",
                    OmObjectId(networkList[i])
                    );
                status = ERROR_SUCCESS;
            } else {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Failed to reconfigure multicast "
                    "for network %1!ws!, status %2!u!.\n",
                    OmObjectId(networkList[i]), status
                    );
                //
                // Not a de facto fatal error.
                //
                status = ERROR_SUCCESS;
            }
        }

        //
        // Drop the reference that was taken in the
        // enum routine.
        //
        NmpDereferenceNetwork(networkList[i]);
    }

    //
    // Deallocate the network list.
    //
    LocalFree(networkList);

    return(status);

} // NmpReconfigureClusterMulticast


VOID
NmpScheduleMulticastReconfiguration(
    IN PNM_NETWORK   Network
    )
/*++

Routine Description:

    Schedules a worker thread to reconfigure multicast
    for a network.
    
    Note that we do not use the network worker thread
    because the madcap API is unfamiliar and therefore
    unpredictable.

Arguments:

    A pointer to the network to renew.

Return Value:

    None.

Notes:

    This routine is called with the NM lock held.

--*/
{
    DWORD     status = ERROR_SUCCESS;

    //
    // Check if a worker thread is already scheduled to
    // service this network.
    //
    if (!NmpIsNetworkMadcapWorkerRunning(Network)) {
        status = NmpScheduleNetworkMadcapWorker(Network);
    }

    if (status == ERROR_SUCCESS) {
        //
        // We succeeded in scheduling a worker thread. Stop the
        // retry timer and set the registration work flag.
        //
        Network->McastAddressReconfigureRetryTimer = 0;
        Network->Flags |= NM_FLAG_NET_RECONFIGURE_MCAST;
    }
    else {
        //
        // We failed to schedule a worker thread. Set the retry
        // timer to expire on the next tick, so we can try again.
        //
        Network->McastAddressReconfigureRetryTimer = 1;
    }

    return;

} // NmpScheduleMulticastReconfiguration


/////////////////////////////////////////////////////////////////////////////
//
// Routines exported within NM.
//
/////////////////////////////////////////////////////////////////////////////

VOID
NmpMulticastInitialize(
    VOID
    )
/*++

Routine Description:

    Initialize multicast readiness variables.
    
--*/
{
    //
    // Figure out if this is a mixed NT5/NT5.1 cluster.
    //
    if (CLUSTER_GET_MAJOR_VERSION(CsClusterHighestVersion) == 3) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Enabling mixed NT5/NT5.1 operation.\n"
            );
        NmpIsNT5NodeInCluster = TRUE;
    }
    else {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Disabling mixed NT5/NT5.1 operation.\n"
            );
        NmpIsNT5NodeInCluster = FALSE;
    }

    //
    // Figure out if there are enough nodes in this cluster
    // to run multicast.
    //
    if (NmpNodeCount < NMP_MCAST_MIN_CLUSTER_NODE_COUNT) {
        NmpMulticastIsNotEnoughNodes = TRUE;
    } else {
        NmpMulticastIsNotEnoughNodes = FALSE;
    }

    return;

} // NmpMulticastInitialize


BOOLEAN
NmpIsClusterMulticastReady(
    IN BOOLEAN       CheckNodeCount
    )
/*++

Routine Description:

    Determines from the cluster version and the NM up node
    set whether multicast should be run in this cluster.
    
    Criteria: no nodes with version below Whistler
              at least three nodes configured (at this point,
                  we're not worried about how many nodes are
                  actually running)
                  
Arguments:

    CheckNodeCount - indicates whether number of nodes 
                     configured in cluster should be
                     considered                  
    
Return value:

    TRUE if multicast should be run.
    
Notes:

    Called and returns with NM lock held.
    
--*/
{
    LPWSTR    reason = NULL;

    //
    // First check for the lowest version.
    //
    if (NmpIsNT5NodeInCluster) {
        reason = L"there is at least one NT5 node configured "
                 L"in the cluster membership";
    }

    //
    // Count the nodes.
    //
    else if (CheckNodeCount && NmpMulticastIsNotEnoughNodes) {
        reason = L"there are not enough nodes configured "
                 L"in the cluster membership";
    }

    if (reason != NULL) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Multicast is not justified for this "
            "cluster because %1!ws!.\n",
            reason
            );
    }

    return((BOOLEAN)(reason == NULL));

} // NmpIsClusterMulticastReady


VOID
NmpMulticastProcessClusterVersionChange(
    VOID
    )
/*++

Routine Description:

    Called when the cluster version changes. Updates 
    global variables to track whether this is a mixed-mode
    cluster, and starts or stops multicast if necessary.
    
Notes:

    Called and returns with NM lock held.
    
--*/
{
    BOOLEAN checkReady = FALSE;
    BOOLEAN stop = FALSE;

    //
    // Figure out if there is a node in this cluster whose
    // version reveals that it doesn't speak multicast.
    //
    if (CLUSTER_GET_MAJOR_VERSION(CsClusterHighestVersion) < 4) {
        if (NmpIsNT5NodeInCluster == FALSE) {
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Disabling multicast in mixed-mode cluster.\n"
                );
            NmpIsNT5NodeInCluster = TRUE;
            stop = TRUE;
        }
    }
    else {
        if (NmpIsNT5NodeInCluster == TRUE) {
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Enabling multicast after upgrade from "
                "mixed-mode cluster.\n"
                );
            NmpIsNT5NodeInCluster = FALSE;
            checkReady = TRUE;        
        }
    }

    if (NmpNodeCount < NMP_MCAST_MIN_CLUSTER_NODE_COUNT) {
        if (NmpMulticastIsNotEnoughNodes == FALSE) {
            ClRtlLogPrint(LOG_NOISE,
                "[NM] There are no longer the minimum number of "
                "nodes configured in the cluster membership to "
                "justify multicast.\n"
                );
            NmpMulticastIsNotEnoughNodes = TRUE;
            stop = TRUE;
        }
    } else {
        if (NmpMulticastIsNotEnoughNodes == TRUE) {
            ClRtlLogPrint(LOG_NOISE,
                "[NM] The cluster is configured with enough "
                "nodes configured to justify multicast.\n"
                );
            NmpMulticastIsNotEnoughNodes = FALSE;
            checkReady = TRUE;
        }
    }

    if (stop) {
        
        //
        // Stop multicast, since we are no longer
        // multicast-ready.
        //
        NmpStopMulticast(NULL);
        
        //
        // Don't bother checking whether we are now
        // multicast-ready.
        //
        checkReady = FALSE;
    }

    //
    // Start multicast if this is the NM leader node
    // and we have now become multicast-ready.
    //
    if (checkReady && 
        NmpLeaderNodeId == NmLocalNodeId && 
        NmpIsClusterMulticastReady(TRUE)) {
        NmpStartMulticast(NULL);
    }

    return;

} // NmpMulticastProcessClusterVersionChange


VOID
NmpScheduleMulticastAddressRenewal(
    PNM_NETWORK   Network
    )
/*++

Routine Description:

    Schedules a worker thread to renew the multicast
    address lease for a network.
    
    Note that we do not use the network worker thread
    because the madcap API is unfamiliar and therefore
    unpredictable.

Arguments:

    A pointer to the network to renew.

Return Value:

    None.

Notes:

    This routine is called with the NM lock held.

--*/
{
    DWORD     status = ERROR_SUCCESS;

    //
    // Check if a worker thread is already scheduled to
    // service this network.
    //
    if (!NmpIsNetworkMadcapWorkerRunning(Network)) {
        status = NmpScheduleNetworkMadcapWorker(Network);
    }

    if (status == ERROR_SUCCESS) {
        //
        // We succeeded in scheduling a worker thread. Stop the
        // retry timer and set the registration work flag.
        //
        Network->McastAddressRenewTimer = 0;
        Network->Flags |= NM_FLAG_NET_RENEW_MCAST_ADDRESS;
    }
    else {
        //
        // We failed to schedule a worker thread. Set the retry
        // timer to expire on the next tick, so we can try again.
        //
        Network->McastAddressRenewTimer = 1;
    }

    return;

} // NmpScheduleMulticastAddressRenewal


VOID
NmpScheduleMulticastAddressRelease(
    PNM_NETWORK   Network
    )
/*++

Routine Description:

    Schedules a worker thread to renew the multicast
    address lease for a network.
    
    Note that we do not use the network worker thread
    because the madcap API is unfamiliar and therefore
    unpredictable.

Arguments:

    A pointer to the network to renew.

Return Value:

    None.

Notes:

    This routine is called with the NM lock held.

--*/
{
    DWORD     status = ERROR_SUCCESS;

    //
    // Check if a worker thread is already scheduled to
    // service this network.
    //
    if (!NmpIsNetworkMadcapWorkerRunning(Network)) {
        status = NmpScheduleNetworkMadcapWorker(Network);
    }

    if (status == ERROR_SUCCESS) {
        //
        // We succeeded in scheduling a worker thread. Stop the
        // retry timer and set the registration work flag.
        //
        Network->McastAddressReleaseRetryTimer = 0;
        Network->Flags |= NM_FLAG_NET_RELEASE_MCAST_ADDRESS;
    }
    else {
        //
        // We failed to schedule a worker thread. Set the retry
        // timer to expire on the next tick, so we can try again.
        //
        Network->McastAddressReleaseRetryTimer = 1;
    }

    return;

} // NmpScheduleMulticastAddressRelease


VOID
NmpFreeMulticastAddressReleaseList(
    IN     PNM_NETWORK       Network
    )
/*++

Routine Description:

    Free all release data structures on network list.
    
Notes:

    Assume that the Network object will not be accessed
    by any other threads during this call.
    
--*/
{
    PNM_NETWORK_MADCAP_ADDRESS_RELEASE releaseInfo = NULL;
    PLIST_ENTRY                        entry;

    while (!IsListEmpty(&(Network->McastAddressReleaseList))) {

        //
        // Simply free the memory -- don't try to release the
        // leases.
        //
        entry = RemoveHeadList(&(Network->McastAddressReleaseList));
        releaseInfo = CONTAINING_RECORD(
                          entry,
                          NM_NETWORK_MADCAP_ADDRESS_RELEASE,
                          Linkage
                          );
        NmpFreeMulticastAddressRelease(releaseInfo);
    }

    return;

} // NmpFreeMulticastAddressReleaseList


DWORD
NmpMulticastManualConfigChange(
    IN     PNM_NETWORK          Network,
    IN     HDMKEY               NetworkKey,
    IN     HDMKEY               NetworkParametersKey,
    IN     PVOID                InBuffer,
    IN     DWORD                InBufferSize,
       OUT BOOLEAN            * SetProperties
    )
/*++

Routine Description:

    Called by node that receives a clusapi request to set
    multicast parameters for a network. Generates a new
    multicast key salt. Then writes the new salt to the
    cluster database and sets the lease expiration to
    zero.
    
    This routine is a no-op in mixed-mode clusters.
    
Notes:

    Must not be called with NM lock held.
    
--*/
{
    DWORD                            status;
    LPCWSTR                          networkId = OmObjectId(Network);
    BOOLEAN                          disableConfig = FALSE;
    BOOLEAN                          addrConfig = FALSE;
    DWORD                            disabled;
    NM_NETWORK_MULTICAST_PARAMETERS  params;
    LPWSTR                           mcastAddress = NULL;
    BOOLEAN                          needUpdate = FALSE;

    if (!NmpIsClusterMulticastReady(TRUE)) {
        *SetProperties = TRUE;
        return(ERROR_SUCCESS);
    }

#if CLUSTER_BETA
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Examining update to private properties "
        "for network %1!ws!.\n",
        networkId
        );
#endif // CLUSTER_BETA

    RtlZeroMemory(&params, sizeof(params));

    //
    // Cannot proceed if either registry key is NULL.
    //
    if (NetworkKey == NULL || NetworkParametersKey == NULL) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Ignoring possible multicast changes in "
            "private properties update to network %1!ws! "
            "because registry keys are missing.\n",
            networkId
            );
        status = ERROR_INVALID_PARAMETER;
        goto error_exit;
    }

    //
    // If a writeable multicast parameter is among those properties 
    // being set, we may need to take action before the update is
    // disseminated.
    //
    // Check whether multicast is being disabled for this network.
    //
    status = ClRtlFindDwordProperty(
                 InBuffer,
                 InBufferSize,
                 CLUSREG_NAME_NET_DISABLE_MULTICAST,
                 &disabled
                 );
    if (status == ERROR_SUCCESS) {
        disableConfig = TRUE;
    } else {
        disabled = NMP_MCAST_DISABLED_DEFAULT;
    }

    //
    // Check whether a multicast address is being set for this
    // network.
    //
    status = ClRtlFindSzProperty(
                 InBuffer,
                 InBufferSize,
                 CLUSREG_NAME_NET_MULTICAST_ADDRESS,
                 &mcastAddress
                 );
    if (status == ERROR_SUCCESS) {
        addrConfig = TRUE;
    }

    if (disableConfig || addrConfig) {

        //
        // Multicast parameters are being written.
        //

        ClRtlLogPrint(LOG_NOISE,
            "[NM] Processing manual update to multicast "
            "configuration for network %1!ws!.\n",
            networkId
            );
        
        status = NmpMulticastFormManualConfigParameters(
                     Network,
                     NetworkKey,
                     NetworkParametersKey,
                     disableConfig,
                     disabled,
                     addrConfig,
                     mcastAddress,
                     &needUpdate,
                     &params
                     );
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to determine multicast "
                "configuration parameters for network "
                "%1!ws! during manual configuration, "
                "status %2!u!.\n",
                networkId, status
                );
            goto error_exit;
        }

        //
        // Notify other nodes of the config change.
        //
        if (needUpdate) {
            status = NmpMulticastNotifyConfigChange(
                         Network,
                         NetworkKey,
                         &NetworkParametersKey,
                         &params,
                         InBuffer,
                         InBufferSize
                         );
            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Failed to disseminate multicast "
                    "configuration for network %1!ws! during "
                    "manual configuration, status %2!u!.\n",
                    networkId, status
                    );
                goto error_exit;
            }
            
            //
            // The properties have been disseminated. There is
            // no need to set them again (in fact, if we changed
            // one of the multicast properties, it could be
            // overwritten).
            //
            *SetProperties = FALSE;
        }
    } 
    
    if (!needUpdate) {

        //
        // No multicast properties are affected. Set them
        // in the cluster database normally.
        //
        *SetProperties = TRUE;
        status = ERROR_SUCCESS;
    }

error_exit:

    if (mcastAddress != NULL) {
        LocalFree(mcastAddress);
        mcastAddress = NULL;
    }

    NmpMulticastFreeParameters(&params);

    //
    // If multicast config failed, default to setting properties.
    //
    if (status != ERROR_SUCCESS) {
        *SetProperties = TRUE;
    }

    return(status);

} // NmpMulticastManualConfigChange


DWORD
NmpUpdateSetNetworkMulticastConfiguration(
    IN    BOOL                          SourceNode,
    IN    LPWSTR                        NetworkId,
    IN    PVOID                         UpdateBuffer,
    IN    PVOID                         PropBuffer,
    IN    LPDWORD                       PropBufferSize
    )
/*++

Routine Description:

    Global update routine for multicast configuration.
    
    Starts a local transaction.
    Commits property buffer to local database.
    Commits multicast configuration to local database,
        possibly overwriting properties from buffer.
    Configures multicast parameters.
    Commits transaction.
    Backs out multicast configuration changes if needed.
    Starts lease renew timer if needed.
    
Arguments:

    SourceNode - whether this node is source of update.
    
    NetworkId - affected network
    
    Update - new multicast configuration
    
    PropBuffer - other properties to set in local 
                 transaction. may be absent.
                 
    PropBufferSize - size of property buffer.
    
Return value:

    SUCCESS if properties or configuration could not be
    committed. Error not necessarily returned if 
    multicast config failed.
    
--*/
{
    DWORD                            status;
    PNM_NETWORK                      network = NULL;
    PNM_NETWORK_MULTICAST_UPDATE     update = UpdateBuffer;
    NM_NETWORK_MULTICAST_PARAMETERS  params = { 0 };
    NM_NETWORK_MULTICAST_PARAMETERS  undoParams = { 0 };
    HLOCALXSACTION                   xaction = NULL;
    HDMKEY                           networkKey = NULL;
    HDMKEY                           netParamKey = NULL;
    DWORD                            createDisposition;
    BOOLEAN                          lockAcquired = FALSE;
    DWORD                            leaseRenewTime;
    NM_MCAST_CONFIG                  configType;

    if (!NmpEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process SetNetworkCommonProperties "
            "update.\n"
            );
        return(ERROR_NODE_NOT_AVAILABLE);
    }

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Received update to multicast configuration "
        "for network %1!ws!.\n",
        NetworkId
        );

    //
    // Find the network's object
    //
    network = OmReferenceObjectById(ObjectTypeNetwork, NetworkId);

    if (network == NULL) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Unable to find network %1!ws!.\n",
            NetworkId
            );
        status = ERROR_CLUSTER_NETWORK_NOT_FOUND;
        goto error_exit;
    }

    //
    // Convert the update into a parameters data structure.
    //
    status = NmpMulticastCreateParametersFromUpdate(
                 network,
                 update,
                 (BOOLEAN)(update->Disabled == 0),
                 &params
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to convert update parameters to "
            "multicast parameters for network %1!ws!, "
            "status %2!u!.\n",
            NetworkId, status
            );
        goto error_exit;
    }
    
    //
    // Open the network's database key
    //
    networkKey = DmOpenKey(DmNetworksKey, NetworkId, KEY_WRITE);

    if (networkKey == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to open database key for network %1!ws!, "
            "status %2!u!\n",
            NetworkId, status
            );
        goto error_exit;
    }

    //
    // Start a transaction - this must be done before acquiring the NM lock.
    //
    xaction = DmBeginLocalUpdate();

    if (xaction == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to begin a transaction, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    //
    // Open or create the network's parameters key.
    //
    netParamKey = DmLocalCreateKey(
                      xaction,
                      networkKey,
                      CLUSREG_KEYNAME_PARAMETERS,
                      0,   // registry options
                      MAXIMUM_ALLOWED,
                      NULL,
                      &createDisposition
                      );
    if (netParamKey == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to open/create Parameters database "
            "key for network %1!ws!, status %2!u!.\n",
            NetworkId, status
            );
        goto error_exit;
    }

    NmpAcquireLock(); 
    lockAcquired = TRUE;

    //
    // If we were given a property buffer, then this update was
    // caused by a manual configuration (setting of private
    // properties). Write those properties first, knowing that
    // they may get overwritten later when we write multicast
    // parameters.
    //
    if (*PropBufferSize > sizeof(DWORD)) {
        status = ClRtlSetPrivatePropertyList( 
                     xaction,
                     netParamKey,
                     &NmpMcastClusterRegApis,
                     PropBuffer,
                     *PropBufferSize
                     );
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to set private properties for "
                "network %1!ws! during a multicast configuration "
                "update, status %2!u!.\n",
                NetworkId, status
                );
            goto error_exit;
        }
    }

    //
    // Write the multicast configuration.
    //
    status = NmpWriteMulticastParameters(
                 network,
                 networkKey,
                 netParamKey,
                 xaction,
                 &params
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to write multicast configuration for "
            "network %1!ws!, status %2!u!.\n",
            NetworkId, status
            );
        goto error_exit;
    }

    //
    // Save the config type.
    //
    configType = params.ConfigType;

    //
    // Process the multicast configuration, including storing new
    // parameters in the network object and plumbing them into
    // clusnet.
    //
    status = NmpProcessMulticastConfiguration(network, &params, &undoParams);
    if (status == ERROR_SUCCESS) {
    
        //
        // Share renewal responsibility for this lease.
        //
        NmpShareMulticastAddressLease(network, configType);

    } else {

        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to process multicast configuration for "
            "network %1!ws!, status %2!u!. Attempting null "
            "multicast configuration.\n",
            NetworkId, status
            );
        
        NmpMulticastSetNullAddressParameters(network, &params);

        status = NmpProcessMulticastConfiguration(
                     network, 
                     &params,
                     &undoParams
                     );
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to process multicast configuration for "
                "network %1!ws!, status %2!u!.\n",
                NetworkId, status
                );
            goto error_exit;
        }
    }

error_exit:

    if (lockAcquired) {
        NmpLockedLeaveApi();
        NmpReleaseLock();
    }
    else {
        NmpLeaveApi();
    }

    //
    // Close the network parameters key, which was obtained with 
    // DmLocalCreateKey, before committing/aborting the transaction.
    //
    if (netParamKey != NULL) {
        DmCloseKey(netParamKey);
        netParamKey = NULL;
    }

    if (xaction != NULL) {
        
        //
        // Complete the transaction - this must be done after releasing
        //                            the NM lock.
        //
        if (status == ERROR_SUCCESS) {
            DmCommitLocalUpdate(xaction);
        }
        else {
            DmAbortLocalUpdate(xaction);
        }
    }

    NmpMulticastFreeParameters(&params);
    NmpMulticastFreeParameters(&undoParams);

    if (networkKey != NULL) {
        DmCloseKey(networkKey);
        networkKey = NULL;
    }

    if (network != NULL) {
        OmDereferenceObject(network);
    }

    return(status);

} // NmpUpdateSetNetworkMulticastConfiguration


DWORD
NmpRefreshMulticastConfiguration(
    IN PNM_NETWORK  Network
    )
/*++

Routine Description:

    NmpRefreshMulticastConfiguration enables multicast on 
    the specified Network according to parameters in the 
    cluster database.
    
Notes:

    Must not be called with the NM lock held.    
    
--*/
{
    LPWSTR                          networkId = (LPWSTR) OmObjectId(Network);
    DWORD                           status;
    
    HDMKEY                          networkKey = NULL;
    HDMKEY                          netParamKey = NULL;
    HDMKEY                          clusParamKey = NULL;

    NM_NETWORK_MULTICAST_PARAMETERS params = { 0 };
    NM_NETWORK_MULTICAST_PARAMETERS undoParams = { 0 };
    DWORD                           mcastAddrLength = 0;
    NM_MCAST_LEASE_STATUS           leaseStatus;
    NM_MCAST_CONFIG                 configType;
    DWORD                           disabled;


    ClRtlLogPrint(LOG_NOISE,
        "[NM] Configuring multicast for network %1!ws!.\n",
        networkId
        );

    //
    // Check if multicast is disabled. This has the side-effect,
    // on success, of opening at least the network key, and
    // possibly the network parameters key (if it exists) and
    // the cluster parameters key.
    //
    status = NmpQueryMulticastDisabled(
                 Network,
                 &clusParamKey,
                 &networkKey,
                 &netParamKey,
                 &params.Disabled
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to determine whether multicast "
            "is disabled for network %1!ws!, status %2!u!.\n",
            networkId, status
            );
        goto error_exit;
    }

    if (params.Disabled > 0) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Multicast is disabled for network %1!ws!.\n",
            networkId
            );
    }
        
    //
    // Determine what type of configuration this is.
    //
    status = NmpQueryMulticastConfigType(
                 Network,
                 networkKey,
                 &netParamKey,
                 &params.ConfigType
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to determine configuration type "
            "for network %1!ws!, status %2!u!.\n",
            networkId, status
            );
        goto error_exit;
    }

    //
    // Read the multicast address.
    //
    status = NmpQueryMulticastAddress(
                 Network,
                 networkKey,
                 &netParamKey,
                 &params.Address,
                 &mcastAddrLength
                 );
    if ( (status == ERROR_SUCCESS && 
          !NmpMulticastValidateAddress(params.Address)) ||
         (status != ERROR_SUCCESS)
       ) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to get valid multicast address "
            "for network %1!ws! from cluster database, "
            "status %2!u!, address %3!ws!.\n",
            networkId, status,
            ((params.Address != NULL) ? params.Address : L"<NULL>")
            );
        goto error_exit;
    }

    //
    // Only re-generate the key if multicast is not disabled.
    //
    if (!params.Disabled) {
        status = NmpGenerateMulticastKey(
                     Network, 
                     &params.Key, 
                     &params.KeyLength
                     );
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to generate multicast key for "
                "network %1!ws!, status %2!u!.\n",
                networkId, status
                );
            goto error_exit;
        }
    }

    //
    // Get the multicast salt.
    // 
    status = NmpQueryMulticastKeySalt(
                 Network,
                 networkKey,
                 &netParamKey,
                 &params.Salt,
                 &params.SaltLength
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to get multicast key salt for "
            "network %1!ws!, status %2!u!.\n",
            networkId, status
            );
        goto error_exit;
    }

    //
    // Get the lease parameters.
    //
    status = NmpQueryMulticastAddressLease(
                 Network,
                 networkKey,
                 &netParamKey,
                 &leaseStatus,
                 &params.LeaseObtained,
                 &params.LeaseExpires
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to get multicast address lease "
            "expiration for network %1!ws!, status %2!u!.\n",
            networkId, status
            );
        //
        // Not fatal.
        //
        params.LeaseObtained = 0;
        params.LeaseExpires = 0;
        status = ERROR_SUCCESS;
    }

    //
    // Remember parameters we will need later.
    //
    disabled = params.Disabled;
    configType = params.ConfigType;

    //
    // Process the configuration changes.
    //
    NmpAcquireLock();

    status = NmpProcessMulticastConfiguration(
                 Network,
                 &params,
                 &undoParams
                 );

    //
    // Check the lease renew parameters if this was not a
    // manual configuration.
    //
    if (!disabled && configType != NmMcastConfigManual) {

        NmpShareMulticastAddressLease(
            Network,
            configType
            );
    }

    NmpReleaseLock();

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to process multicast configuration "
            "for network %1!ws!, status %2!u!.\n",
            networkId, status
            );
        goto error_exit;
    }

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Multicast configuration for network %1!ws! "
        "was successful.\n",
        networkId
        );

error_exit:

    if (clusParamKey != NULL) {
        DmCloseKey(clusParamKey);
        clusParamKey = NULL;
    }

    if (netParamKey != NULL) {
        DmCloseKey(netParamKey);
        netParamKey = NULL;
    }

    if (networkKey != NULL) {
        DmCloseKey(networkKey);
        networkKey = NULL;
    }

    NmpMulticastFreeParameters(&params);
    NmpMulticastFreeParameters(&undoParams);

    return(status);

} // NmpRefreshMulticastConfiguration


DWORD
NmpRefreshClusterMulticastConfiguration(
    VOID
    )
/*++

Routine Description:

    Configures multicast on all networks in cluster.
    
--*/
{
    DWORD          status = ERROR_SUCCESS;
    PNM_NETWORK  * networkList;
    DWORD          networkCount;
    PNM_NETWORK    network;
    PLIST_ENTRY    entry;
    DWORD          i = 0;

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Configuring multicast on all cluster networks.\n"
        );

    NmpAcquireLock();

    networkCount = NmpNetworkCount;
    networkList = (PNM_NETWORK *) LocalAlloc(
                                      LMEM_FIXED, 
                                      networkCount * sizeof(PNM_NETWORK)
                                      );
    if (networkList == NULL) {
        NmpReleaseLock();
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    for (entry = NmpNetworkList.Flink;
         entry != &NmpNetworkList;
         entry = entry->Flink
        )
    {
        network = CONTAINING_RECORD(
                      entry,
                      NM_NETWORK,
                      Linkage
                      );

        //
        // Place a pointer to the network in the network list,
        // and reference the network so it doesn't disappear.
        //
        networkList[i] = network;
        NmpReferenceNetwork(network);
        i++;
        CL_ASSERT(i <= networkCount);
    }

    NmpReleaseLock();

    for (i = 0; i < networkCount; i++) {

        status = NmpRefreshMulticastConfiguration(networkList[i]);
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to configure multicast "
                "parameters for network, %1!ws!, "
                "status %2!u!.\n",
                OmObjectId(networkList[i]), status
                );
            //
            // Not a de facto fatal error.
            //
            status = ERROR_SUCCESS;
        }
        
        //
        // Drop the reference that was taken in the
        // enum routine.
        //
        NmpDereferenceNetwork(networkList[i]);
    }

    //
    // Deallocate the network list.
    //
    LocalFree(networkList);

    return(status);

} // NmpRefreshClusterMulticastConfiguration


DWORD
NmpMulticastValidatePrivateProperties(
    IN  PNM_NETWORK Network,
    IN  HDMKEY      NetworkKey,
    IN  PVOID       InBuffer,
    IN  DWORD       InBufferSize
    )
/*++

Routine Description:

    Called when a manual update to the private properties
    of a network is detected. Only called on the node
    that receives the clusapi clusctl request.
    
    Verifies that no read-only properties are being set.
    Determines whether the multicast configuration of
    the network will need to be refreshed after the
    update.
    
    This routine is a no-op in a mixed-mode cluster.
    
--*/
{
    DWORD                     status;
    LPCWSTR                   networkId = OmObjectId(Network);
    NM_NETWORK_MULTICAST_INFO mcastInfo;

    //
    // Enforce property-validation regardless of number of
    // nodes in cluster.
    //
    if (!NmpIsClusterMulticastReady(FALSE)) {
        return(ERROR_SUCCESS);
    }
    
    //
    // Don't allow any read-only properties to be set.
    //
    RtlZeroMemory(&mcastInfo, sizeof(mcastInfo));

    status = ClRtlVerifyPropertyTable(
                 NmpNetworkMulticastProperties,
                 NULL,    // Reserved
                 TRUE,    // Allow unknowns
                 InBuffer,
                 InBufferSize,
                 (LPBYTE) &mcastInfo
                 );
    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Error verifying private properties for "
            "network %1!ws!, status %2!u!.\n",
            networkId, status
            );
        goto error_exit;
    }

error_exit:

    NmpFreeNetworkMulticastInfo(&mcastInfo);

    return(status);

} // NmpMulticastValidatePrivateProperties


DWORD
NmpMulticastRegenerateKey(
    IN PNM_NETWORK        Network
    )
/*++

Routine Description:

    Regenerates the network multicast key, and reconfigures
    ClusNet with new key if it has changed.
    
Arguments:

    Network - network to regenerate key for, or NULL if
              key should be regenerated for all
              
Notes:

    Called and returns with NM lock held.              
              
--*/
{
    DWORD                           status = ERROR_SUCCESS;
    PLIST_ENTRY                     entry;
    PNM_NETWORK                     network;
    LPWSTR                          networkId;            
    NM_NETWORK_MULTICAST_PARAMETERS params = { 0 };
    NM_NETWORK_MULTICAST_PARAMETERS undoParams = { 0 };


    if (Network == NULL) {
    
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Regenerating key for all cluster networks.\n"
            );

        for (entry = NmpNetworkList.Flink;
             entry != &NmpNetworkList;
             entry = entry->Flink) {

            network = CONTAINING_RECORD(entry, NM_NETWORK, Linkage);

            NmpMulticastRegenerateKey(network);
        }

        status = ERROR_SUCCESS;
    
    } else if (NmpIsNetworkMulticastEnabled(Network)) {

        networkId = (LPWSTR) OmObjectId(Network);

        ClRtlLogPrint(LOG_NOISE,
            "[NM] Regenerating key for cluster network %1!ws!.\n",
            networkId
            );

        //
        // Create a parameters structure with the current
        // configuration.
        //
        status = NmpMulticastCreateParameters(
                     0,                   // disabled 
                     Network->MulticastAddress,
                     Network->MulticastKeySalt,
                     Network->MulticastKeySaltLength,
                     NULL,                // leave key blank
                     0,                   // leave key length blank
                     Network->MulticastLeaseObtained,
                     Network->MulticastLeaseExpires,
                     &(Network->MulticastLeaseRequestId),
                     Network->MulticastLeaseServer,
                     NmMcastConfigManual, // doesn't matter
                     &params
                     );
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to create multicast configuration "
                "parameter block for network %1!ws!, status %2!u!.\n",
                networkId, status
                );
            goto error_exit;
        }

        //
        // Generate the new key.
        //
        status = NmpGenerateMulticastKey(
                     Network,
                     &params.Key,
                     &params.KeyLength
                     );
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to generate multicast "
                "key for network %1!ws!, status %2!u!.\n",
                networkId, status
                );
            goto error_exit;
        }
        
        status = NmpProcessMulticastConfiguration(
                     Network,
                     &params,
                     &undoParams
                     );
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to process multicast "
                "configuration for network %1!ws! "
                "after key regeneration, status %2!u!.\n",
                networkId, status
                );

            NmpMulticastSetNullAddressParameters(Network, &params);

            status = NmpProcessMulticastConfiguration(
                         Network,
                         &params,
                         &undoParams
                         );
            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Failed to set null multicast "
                    "configuration for network %1!ws! "
                    "after key regeneration, status %2!u!.\n",
                    networkId, status
                    );
                goto error_exit;
            }
        }
    }

error_exit:

    if (status != ERROR_SUCCESS && Network != NULL) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Failed to regenerate multicast key for "
            "network %1!ws!, status %2!u!.\n",
            OmObjectId(Network), status
            );
    }

    NmpMulticastFreeParameters(&params);
    NmpMulticastFreeParameters(&undoParams);

    return(status);

} // NmpMulticastRegenerateKey


DWORD
NmpStartMulticast(
    IN PNM_NETWORK         Network         OPTIONAL
    )
/*++

Routine Description:

    Start multicast on a network by configuring multicast
    parameters and sending a GUM update. 
    
    Deferred to the network worker thread.
    
Arguments:

    Network - network on which to start multicast. If NULL,
              start multicast on all networks.
              
Notes:

    Must be called with NM lock held.
    
--*/
{
    PLIST_ENTRY                     entry;
    PNM_NETWORK                     network;
    LPWSTR                          networkId;

    CL_ASSERT(NmpLeaderNodeId == NmLocalNodeId);
    
    if (Network == NULL) {
    
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Starting multicast for all cluster networks.\n"
            );

        for (entry = NmpNetworkList.Flink;
             entry != &NmpNetworkList;
             entry = entry->Flink) {

            network = CONTAINING_RECORD(entry, NM_NETWORK, Linkage);

            NmpStartMulticast(network);
        }

    } else {

        networkId = (LPWSTR) OmObjectId(Network);

        ClRtlLogPrint(LOG_NOISE,
            "[NM] Starting multicast for cluster network %1!ws!.\n",
            networkId
            );

        NmpScheduleMulticastReconfiguration(Network);
    }

    return(ERROR_SUCCESS);

} // NmpStartMulticast


DWORD
NmpStopMulticast(
    IN PNM_NETWORK   Network           OPTIONAL
    )
/*++

Routine Description:

    Stop multicast on the local node by configuring clusnet
    with a NULL address. This routine should be called 
    from a GUM update or another barrier.
    
Routine Description:

    Network - network on which to stop multicast. If NULL,
              stop multicast on all networks.
              
Notes:

    Must be called with NM lock held.
    
--*/
{
    DWORD                           status = ERROR_SUCCESS;
    PLIST_ENTRY                     entry;
    PNM_NETWORK                     network;
    LPWSTR                          networkId;
    DWORD                           disabled;
    NM_NETWORK_MULTICAST_PARAMETERS params = { 0 };
    NM_NETWORK_MULTICAST_PARAMETERS undoParams = { 0 };
    
    if (Network == NULL) {
    
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Starting multicast for all cluster networks.\n"
            );

        for (entry = NmpNetworkList.Flink;
             entry != &NmpNetworkList;
             entry = entry->Flink) {

            network = CONTAINING_RECORD(entry, NM_NETWORK, Linkage);

            status = NmpStopMulticast(network);
        }

    } else {

        networkId = (LPWSTR) OmObjectId(Network);
        disabled = (NmpIsNetworkMulticastEnabled(Network) ? 0 : 1);

        //
        // Check if telling clusnet to stop multicast would 
        // be redundant.
        //
        if (disabled != 0 ||
            Network->MulticastAddress == NULL ||
            !wcscmp(Network->MulticastAddress, NmpNullMulticastAddress)) {

            ClRtlLogPrint(LOG_NOISE,
                "[NM] Not necessary to stop multicast for "
                "cluster network %1!ws! (disabled = %2!u!, "
                "multicast address = %3!ws!).\n",
                networkId, disabled,
                ((Network->MulticastAddress == NULL) ? 
                 L"<NULL>" : Network->MulticastAddress)
                );
            status = ERROR_SUCCESS;
        
        } else {

            ClRtlLogPrint(LOG_NOISE,
                "[NM] Stopping multicast for cluster network %1!ws!.\n",
                networkId
                );

            //
            // Create parameters from the current state of the network.
            // However, don't use any lease info, since we are stopping
            // multicast and will not be renewing.
            //
            status = NmpMulticastCreateParameters(
                         disabled,
                         NULL,     // blank address initially
                         Network->MulticastKeySalt,
                         Network->MulticastKeySaltLength,
                         Network->MulticastKey,
                         Network->MulticastKeyLength,
                         0,        // lease obtained
                         0,        // lease expires
                         NULL,     // lease request id
                         NULL,     // lease server
                         NmMcastConfigManual, // doesn't matter
                         &params
                         );
            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Failed to create multicast configuration "
                    "parameter block for network %1!ws!, status %2!u!, "
                    "while stopping multicast.\n",
                    networkId, status
                    );
                goto error_exit;
            }

            //
            // Nullify the address.
            //
            NmpMulticastSetNullAddressParameters(Network, &params);

            //
            // Send the parameters to clusnet.
            //
            status = NmpProcessMulticastConfiguration(
                         Network,
                         &params,
                         &undoParams
                         );
            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Failed to set null multicast "
                    "configuration for network %1!ws! "
                    "while stopping multicast, status %2!u!.\n",
                    networkId, status
                    );
                goto error_exit;
            }
        }

        //
        // Cancel the lease renew timer, if set.
        //
        NmpStartNetworkMulticastAddressRenewTimer(Network, 0);

        //
        // Clear multicast configuration work flags. Note 
        // that this is best effort -- we do not attempt 
        // to prevent race conditions where a multicast
        // configuration operation may already be in 
        // progress, since such conditions would not
        // affect the integrity of the cluster.
        //
        Network->Flags &= ~NM_FLAG_NET_RENEW_MCAST_ADDRESS;
        Network->Flags &= ~NM_FLAG_NET_RECONFIGURE_MCAST;
    }

error_exit:

    if (status != ERROR_SUCCESS && Network != NULL) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Failed to stop multicast for "
            "network %1!ws!, status %2!u!.\n",
            OmObjectId(Network), status
            );
    }

    NmpMulticastFreeParameters(&params);
    NmpMulticastFreeParameters(&undoParams);

    return(status);

} // NmpStopMulticast
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\nm\connsink.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N O T I F Y . H
//
//  Contents:   Implementation of INetConnectionNotifySink
//
//  Notes:
//
//  Author:     shaunco   21 Aug 1998
//
//----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#pragma once
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include "netconp.h"

class ATL_NO_VTABLE CConnectionNotifySink :
    public CComObjectRootEx <CComMultiThreadModel>,
    public INetConnectionNotifySink
{
private:
//    LPITEMIDLIST    m_pidlFolder;

public:
    BEGIN_COM_MAP(CConnectionNotifySink)
        COM_INTERFACE_ENTRY(INetConnectionNotifySink)
    END_COM_MAP()

    CConnectionNotifySink() { /*m_pidlFolder = NULL;*/ };
    ~CConnectionNotifySink();

    // INetConnectionNotifySink
    STDMETHOD(ConnectionAdded) (
        const NETCON_PROPERTIES_EX*    pPropsEx);

    STDMETHOD(ConnectionBandWidthChange) (
        const GUID* pguidId);

    STDMETHOD(ConnectionDeleted) (
        const GUID* pguidId);

    STDMETHOD(ConnectionModified) (
        const NETCON_PROPERTIES_EX* pPropsEx);

    STDMETHOD(ConnectionRenamed) (
        const GUID* pguidId,
        LPCWSTR     pszwNewName);

    STDMETHOD(ConnectionStatusChange) (
        const GUID*     pguidId,
        NETCON_STATUS   Status);

    STDMETHOD(RefreshAll) ();
    
    STDMETHOD(ConnectionAddressChange) (
        const GUID* pguidId );

    STDMETHOD(ShowBalloon) (
        IN const GUID* pguidId, 
        IN const BSTR  szCookie, 
        IN const BSTR  szBalloonText); 

    STDMETHOD(DisableEvents) (
        IN const BOOL  fDisable,
        IN const ULONG ulDisableTimeout);

public:
    static HRESULT CreateInstance (
        REFIID  riid,
        VOID**  ppv);
};

// Helper functions for external modules
//
HRESULT HrGetNotifyConPoint(
    IConnectionPoint **             ppConPoint);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\nm\connsink.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    connsink.c

Abstract:

    Implements a COM sink object on which to receive connection folder
    events

Author:

    CharlWi (Charlie Wickham) 11/30/98 - heavily ripped off from
        net\config\shell\folder\notify.cpp, originally authored by
        ShaunCo (Shaun Cox)


Revision History:

--*/

#define UNICODE 1

#include "connsink.h"
#include <iaccess.h>

extern "C" {
#include "nmp.h"

VOID
ProcessNameChange(
    GUID * GuidId,
    LPCWSTR NewName
    );
}

EXTERN_C const CLSID CLSID_ConnectionManager;
EXTERN_C const IID IID_INetConnectionNotifySink;

#define INVALID_COOKIE  -1

CComModule _Module;
DWORD AdviseCookie = INVALID_COOKIE;

//static
HRESULT
CConnectionNotifySink::CreateInstance (
    REFIID  riid,
    VOID**  ppv)
{
    HRESULT hr = E_OUTOFMEMORY;

    // Initialize the output parameter.
    //
    *ppv = NULL;

    CConnectionNotifySink* pObj;
    pObj = new CComObject <CConnectionNotifySink>;
    if (pObj)
    {
        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (SUCCEEDED(hr))
        {
            hr = pObj->QueryInterface (riid, ppv);
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }

    if ( FAILED( hr )) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[NM] Unable to create Net Connection Manager advise sink "
                    "object, status %08X.\n",
                    hr);
    }

    return hr;
} // CConnectionNotifySink::CreateInstance

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionNotifySink::~CConnectionNotifySink
//
//  Purpose:    Clean up the sink object
//
//  Arguments:
//      (none)
//
//  Returns:
//

CConnectionNotifySink::~CConnectionNotifySink()
{
}

//
// all we really care about are renaming events hence the rest of the routines
// are stubbed out
//
HRESULT
CConnectionNotifySink::ConnectionAdded (
    const NETCON_PROPERTIES_EX*    pPropsEx)
{
    return E_NOTIMPL;
}

HRESULT
CConnectionNotifySink::ConnectionBandWidthChange (
    const GUID* pguidId)
{
    return E_NOTIMPL;
}

HRESULT
CConnectionNotifySink::ConnectionDeleted (
    const GUID* pguidId)
{
    return E_NOTIMPL;
}

HRESULT
CConnectionNotifySink::ConnectionModified (
    const NETCON_PROPERTIES_EX* pPropsEx)
{
    ProcessNameChange(const_cast<GUID *>(&(pPropsEx->guidId)), pPropsEx->bstrName );
    return S_OK;
}

HRESULT
CConnectionNotifySink::ConnectionRenamed (
    const GUID* GuidId,
    LPCWSTR     NewName)
{

    ProcessNameChange(( GUID *)GuidId, NewName );
    return S_OK;
} // CConnectionNotifySink::ConnectionRenamed

HRESULT
CConnectionNotifySink::ConnectionStatusChange (
    const GUID*     pguidId,
    NETCON_STATUS   Status)
{
    return E_NOTIMPL;
}

HRESULT
CConnectionNotifySink::RefreshAll ()
{
    return E_NOTIMPL;
}

HRESULT CConnectionNotifySink::ConnectionAddressChange (
    const GUID* pguidId )
{
    return E_NOTIMPL;
}

HRESULT CConnectionNotifySink::ShowBalloon(
    IN const GUID* pguidId, 
    IN const BSTR szCookie, 
    IN const BSTR szBalloonText)
{
    return E_NOTIMPL;
}


HRESULT CConnectionNotifySink::DisableEvents(
    IN const BOOL  fDisable,
    IN const ULONG ulDisableTimeout)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetNotifyConPoint
//
//  Purpose:    Common code for getting the connection point for use in
//              NotifyAdd and NotifyRemove
//
//  Arguments:
//      ppConPoint [out]    Return ptr for IConnectionPoint
//
//  Returns:
//
//  Author:     jeffspr   24 Aug 1998
//
//  Notes:
//
HRESULT HrGetNotifyConPoint(
    IConnectionPoint **             ppConPoint)
{
    HRESULT                     hr;
    IConnectionPointContainer * pContainer  = NULL;

    CL_ASSERT(ppConPoint);

    // Get the debug interface from the connection manager
    //
    hr = CoCreateInstance(CLSID_ConnectionManager, NULL,
                          CLSCTX_LOCAL_SERVER,
                          IID_IConnectionPointContainer,
                          (LPVOID*)&pContainer);

    if (SUCCEEDED(hr)) {
        IConnectionPoint * pConPoint    = NULL;

        // Get the connection point itself and fill in the return param
        // on success
        //
        hr = pContainer->FindConnectionPoint(
            IID_INetConnectionNotifySink,
            &pConPoint);

        if (SUCCEEDED(hr)) {

            //
            // set up a proxy on the connection point interface that will
            // identify ourselves as ourselves.
            //
            hr = CoSetProxyBlanket(pConPoint,
                                   RPC_C_AUTHN_WINNT,      // use NT default security
                                   RPC_C_AUTHZ_NONE,       // use NT default authentication
                                   NULL,                   // must be null if default
                                   RPC_C_AUTHN_LEVEL_CALL, // call
                                   RPC_C_IMP_LEVEL_IMPERSONATE,
                                   NULL,                   // use process token
                                   EOAC_NONE);

            if (SUCCEEDED(hr)) {
                *ppConPoint = pConPoint;
            } else {
                ClRtlLogPrint(LOG_CRITICAL,
                           "[NM] Couldn't set proxy blanket on Net Connection "
                            "point, status %1!08X!.\n",
                            hr);
                pConPoint->Release();
            }
        } else {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[NM] Couldn't find notify sink connection point on Net Connection "
                        "Manager, status %1!08X!.\n",
                        hr);
        }

        pContainer->Release();
    } else {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[NM] Couldn't establish connection point with Net Connection "
                    "Manager, status %1!08X!.\n",
                    hr);
    }

    return hr;
}

EXTERN_C {

HRESULT	
NmpGrantAccessToNotifySink(
    VOID
    )

/*++

Routine Description:

    allow localsystem and cluster service account access to make callbacks
    into the service.

    stolen from private\admin\snapin\netsnap\remrras\server\remrras.cpp and
    code reviewed by SajiA

 Arguments:

    None

Return Value:

    ERROR_SUCCESS if everything went ok.

--*/

{
    IAccessControl*             pAccessControl = NULL;     
    SID_IDENTIFIER_AUTHORITY    siaNtAuthority = SECURITY_NT_AUTHORITY;
    PSID                        pSystemSid = NULL;
    HANDLE                      processToken = NULL;
    ULONG                       tokenUserSize;
    PTOKEN_USER                 processTokenUser = NULL;
    DWORD                       status;

    HRESULT hr = CoCreateInstance(CLSID_DCOMAccessControl,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IAccessControl,
                                  (void**)&pAccessControl);
    if(FAILED(hr)) {
    	goto Error;
    }

    //
    // Setup the property list. We use the NULL property because we are trying
    // to adjust the security of the object itself
    //
    ACTRL_ACCESSW access;
    ACTRL_PROPERTY_ENTRYW propEntry;
    access.cEntries = 1;
    access.pPropertyAccessList = &propEntry;

    ACTRL_ACCESS_ENTRY_LISTW entryList;
    propEntry.lpProperty = NULL;
    propEntry.pAccessEntryList = &entryList;
    propEntry.fListFlags = 0;

    //
    // Setup the access control list for the default property
    //
    ACTRL_ACCESS_ENTRYW entry[2];
    entryList.cEntries = 2;
    entryList.pAccessList = entry;

    //
    // Setup the access control entry for localsystem
    //
    entry[0].fAccessFlags = ACTRL_ACCESS_ALLOWED;
    entry[0].Access = COM_RIGHTS_EXECUTE;
    entry[0].ProvSpecificAccess = 0;
    entry[0].Inheritance = NO_INHERITANCE;
    entry[0].lpInheritProperty = NULL;

    // NT requires the system account to have access (for launching)
    entry[0].Trustee.pMultipleTrustee = NULL;
    entry[0].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    entry[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    entry[0].Trustee.TrusteeType = TRUSTEE_IS_USER;

    //
    // allocate and init the SYSTEM sid
    //
    if ( !AllocateAndInitializeSid( &siaNtAuthority,
                                    1,
                                    SECURITY_LOCAL_SYSTEM_RID,
                                    0, 0, 0, 0, 0, 0, 0,
                                    &pSystemSid ) ) {
        status = GetLastError();
        goto Error;
    }

    entry[0].Trustee.ptstrName = (PWCHAR)pSystemSid;;

    //
    // Setup the access control entry for cluster service account
    //
    entry[1].fAccessFlags = ACTRL_ACCESS_ALLOWED;
    entry[1].Access = COM_RIGHTS_EXECUTE;
    entry[1].ProvSpecificAccess = 0;
    entry[1].Inheritance = NO_INHERITANCE;
    entry[1].lpInheritProperty = NULL;

    entry[1].Trustee.pMultipleTrustee = NULL;
    entry[1].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    entry[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    entry[1].Trustee.TrusteeType = TRUSTEE_IS_USER;

    status = NtOpenProcessToken(
                NtCurrentProcess(),
                TOKEN_QUERY,
                &processToken
                );
    if (!NT_SUCCESS(status)) {
        goto Error;
    }

    //
    // find out the size of token, allocate and requery to get info
    //
    status = NtQueryInformationToken(
                processToken,
                TokenUser,
                NULL,
                0,
                &tokenUserSize
                );
    CL_ASSERT( status == STATUS_BUFFER_TOO_SMALL );
    if ( status != STATUS_BUFFER_TOO_SMALL ) {
        goto Error;
    }

    processTokenUser = (PTOKEN_USER) LocalAlloc( 0, tokenUserSize );
    if (( processToken == NULL ) || ( processTokenUser == NULL )) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    status = NtQueryInformationToken(
                processToken,
                TokenUser,
                processTokenUser,
                tokenUserSize,
                &tokenUserSize
                );
    if (!NT_SUCCESS(status)) {
        goto Error;
    }

    entry[1].Trustee.ptstrName = (PWCHAR)processTokenUser->User.Sid;

    //
    // grant access to this mess
    //
    hr = pAccessControl->GrantAccessRights(&access);
    if( SUCCEEDED(hr))
	{
        hr = CoInitializeSecurity(pAccessControl,
                                  -1,
                                  NULL,
                                  NULL, 
                                  RPC_C_AUTHN_LEVEL_CONNECT,
                                  RPC_C_IMP_LEVEL_IDENTIFY, 
                                  NULL,
                                  EOAC_ACCESS_CONTROL,
                                  NULL);
    }

Error:
	if(pAccessControl) {
	    pAccessControl->Release();
    }

    if (processTokenUser != NULL) {
        LocalFree( processTokenUser );
    }

    if (processToken != NULL) {
        NtClose(processToken);
    }

	return hr;
}

HRESULT
NmpInitializeConnectoidAdviseSink(
    VOID
    )

/*++

Routine Description:

    Get an instance pointer to the conn mgr's connection point object and hook
    up our advice sink so we can catch connectoid rename events

Arguments:

    None

Return Value:

    ERROR_SUCCESS if everything worked...

--*/

{
    HRESULT                     hr              = S_OK; // Not returned, but used for debugging
    IConnectionPoint *          pConPoint       = NULL;
    INetConnectionNotifySink *  pSink           = NULL;
    PSECURITY_DESCRIPTOR        sinkSD;

    hr = NmpGrantAccessToNotifySink();
    if ( SUCCEEDED( hr )) {

        hr = HrGetNotifyConPoint(&pConPoint);
        if (SUCCEEDED(hr)) {
            // Create the notify sink
            //
            hr = CConnectionNotifySink::CreateInstance(
                IID_INetConnectionNotifySink,
                (LPVOID*)&pSink);

            if (SUCCEEDED(hr)) {
                CL_ASSERT(pSink);

                hr = pConPoint->Advise(pSink, &AdviseCookie);

                if ( !SUCCEEDED( hr )) {
                    ClRtlLogPrint(LOG_UNUSUAL,
                               "[NM] Couldn't initialize Net Connection Manager advise "
                                "sink, status %1!08X!\n",
                                hr);
                }

                pSink->Release();
            } else {
                hr = GetLastError();
                ClRtlLogPrint(LOG_UNUSUAL,
                           "[NM] Couldn't create sink instance, status %1!08X!\n",
                            hr);
            }

            pConPoint->Release();
        }

    } else {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[NM] CoInitializeSecurity failed, status %1!08X!\n",
                    hr);
    }

    if ( FAILED( hr )) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[NM] Couldn't initialize Net Connection Manager advise "
                    "sink, status %1!08X!\n",
                    hr);
        AdviseCookie = INVALID_COOKIE;
    }

    return hr;
} // NmpInitializeConnectoidAdviseSink

VOID
NmCloseConnectoidAdviseSink(
    VOID
    )

/*++

Routine Description:

    close down the conn mgr event sink. this routine is public since it is
    called prior to CoUninitialize in ClusterShutdown()

Arguments:

    None

Return Value:

    None

--*/

{
    HRESULT             hr          = S_OK;
    IConnectionPoint *  pConPoint   = NULL;

    if ( AdviseCookie != INVALID_COOKIE ) {
        hr = HrGetNotifyConPoint(&pConPoint);
        if (SUCCEEDED(hr)) {
            // Unadvise
            //
            hr = pConPoint->Unadvise(AdviseCookie);
            AdviseCookie = INVALID_COOKIE;
            pConPoint->Release();
        }

        if ( FAILED( hr )) {
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[NM] Couldn't close Net Connection Manager advise sink, status %1!08X!\n",
                        hr);
        }
    }
} // NmCloseConnectoidAdviseSink


VOID
ProcessNameChange(
    GUID * GuidId,
    LPCWSTR NewName
    )

/*++

Routine Description:

    wrapper that enums the net interfaces

Arguments:

    GuidId - pointer to connectoid that changed

    NewName - pointer to new name of connectoid

Return Value:

    None

--*/

{
    RPC_STATUS   rpcStatus;
    LPWSTR       connectoidId = NULL;


    CL_ASSERT(GuidId);
    CL_ASSERT(NewName);

    rpcStatus = UuidToString( (GUID *) GuidId, &connectoidId);

    if ( rpcStatus == RPC_S_OK ) {
        PNM_INTERFACE     netInterface;
        DWORD             status;
        PLIST_ENTRY       entry;

        ClRtlLogPrint(LOG_NOISE,
                   "[NM] Received notification that name for connectoid %1!ws! was changed "
                    "to '%2!ws!'\n",
                    connectoidId,
                    NewName);

        NmpAcquireLock();

        //
        // enum the interfaces, looking for the connectoid GUID as the
        // adapter ID
        //
        for (entry = NmpInterfaceList.Flink;
             entry != &NmpInterfaceList;
             entry = entry->Flink
            )
        {
            netInterface = CONTAINING_RECORD(entry, NM_INTERFACE, Linkage);

            if ( lstrcmpiW( connectoidId , netInterface->AdapterId ) == 0 ) {
                PNM_NETWORK   network = netInterface->Network;
                LPWSTR        networkName = (LPWSTR) OmObjectName( network );


                if ( lstrcmpW( networkName, NewName ) != 0 ) {
                    NM_NETWORK_INFO netInfo;

                    //
                    // For some reason, OmReferenceObject causes a compiler
                    // error here. Likely a header ordering problem. The
                    // function has been wrappered as a  workaround.
                    //
                    NmpReferenceNetwork(network);

                    NmpReleaseLock();

                    netInfo.Id = (LPWSTR) OmObjectId( network );
                    netInfo.Name = (LPWSTR) NewName;

                    status = NmpSetNetworkName( &netInfo );

                    if ( status != ERROR_SUCCESS ) {
                        ClRtlLogPrint( LOG_UNUSUAL, 
                            "[NM] Couldn't rename network '%1!ws!' to '%2!ws!', status %3!u!\n",
                            networkName,
                            NewName,
                            status
                            );
                    
                        //If the error condition is due to the object
                        //already existing revert back to the old name.
                        if(status == ERROR_OBJECT_ALREADY_EXISTS) {
                            DWORD tempStatus = ERROR_SUCCESS;
                            INetConnection *connectoid;

                            ClRtlLogPrint(LOG_UNUSUAL, 
                                "[NM] Reverting back network name to '%1!ws!', from '%2!ws!\n",
                                networkName,
                                NewName
                                );

                            connectoid = ClRtlFindConnectoidByGuid(connectoidId);

                            if(connectoid != NULL){
                                tempStatus = ClRtlSetConnectoidName(
                                    connectoid,
                                    networkName);
                            }

                            if((tempStatus != ERROR_SUCCESS) ||
                               (connectoid == NULL)) {
                                ClRtlLogPrint(LOG_UNUSUAL, 
                                "[NM] Failed to set name of network connection"
                                "%1!ws!, status %2!u!\n",
                                networkName,
                                tempStatus);
                            }
                        }
                    }
                    NmpDereferenceNetwork(network);
                }
                else {
                    NmpReleaseLock();
                }

                break;
            }
        }

        if ( entry == &NmpInterfaceList ) {
            NmpReleaseLock();

            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] Couldn't find net interface for connectoid '%1!ws!'\n",
                connectoidId
                );
        }

        RpcStringFree( &connectoidId );
    }

    return;

} // ProcessNameChange

} // EXTERN_C
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\nm\netioctl.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    netioctl.c

Abstract:

    Network control functions.

Author:

    John Vert (jvert) 2-Mar-1997

Revision History:

--*/

#include "nmp.h"

//
// Network Common properties.
//

//
// Read-Write Common Properties.
//
RESUTIL_PROPERTY_ITEM
NmpNetworkCommonProperties[] =
    {
        {
            CLUSREG_NAME_NET_DESC, NULL, CLUSPROP_FORMAT_SZ,
            (DWORD_PTR) NmpNullString, 0, 0,
            0,
            FIELD_OFFSET(NM_NETWORK_INFO, Description)
        },
        {
            CLUSREG_NAME_NET_ROLE, NULL, CLUSPROP_FORMAT_DWORD,
            ClusterNetworkRoleClientAccess,
            ClusterNetworkRoleNone,
            ClusterNetworkRoleInternalAndClient,
            0,
            FIELD_OFFSET(NM_NETWORK_INFO, Role)
        },
        {
            0
        }
    };

//
// Read-Only Common Properties.
//
RESUTIL_PROPERTY_ITEM
NmpNetworkROCommonProperties[] =
    {
        {
            CLUSREG_NAME_NET_NAME, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            RESUTIL_PROPITEM_READ_ONLY,
            FIELD_OFFSET(NM_NETWORK_INFO, Name)
        },
        {
            CLUSREG_NAME_NET_ADDRESS, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            RESUTIL_PROPITEM_READ_ONLY,
            FIELD_OFFSET(NM_NETWORK_INFO, Address)
            },
        {
            CLUSREG_NAME_NET_ADDRESS_MASK, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            RESUTIL_PROPITEM_READ_ONLY,
            FIELD_OFFSET(NM_NETWORK_INFO, AddressMask)
        },
        {
            0
        }
    };

//
// Cluster registry API function pointers.
// defined in ioctl.c
//
extern CLUSTER_REG_APIS NmpClusterRegApis;


//
// Local Functions
//

DWORD
NmpNetworkControl(
    IN PNM_NETWORK Network,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
NmpNetworkEnumCommonProperties(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
NmpNetworkGetCommonProperties(
    IN PNM_NETWORK Network,
    IN BOOL ReadOnly,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
NmpNetworkValidateCommonProperties(
    IN  PNM_NETWORK               Network,
    IN  PVOID                     InBuffer,
    IN  DWORD                     InBufferSize,
    OUT PNM_NETWORK_INFO          NetworkInfo  OPTIONAL
    );

DWORD
NmpNetworkSetCommonProperties(
    IN PNM_NETWORK Network,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
NmpNetworkEnumPrivateProperties(
    IN PNM_NETWORK Network,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
NmpNetworkGetPrivateProperties(
    IN PNM_NETWORK Network,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
NmpNetworkValidatePrivateProperties(
    IN PNM_NETWORK Network,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
NmpNetworkSetPrivateProperties(
    IN PNM_NETWORK Network,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
NmpNetworkGetFlags(
    IN PNM_NETWORK Network,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );


DWORD
WINAPI
NmNetworkControl(
    IN PNM_NETWORK Network,
    IN PNM_NODE HostNode OPTIONAL,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a network.

Arguments:

    Network - Supplies the network to be controlled.

    HostNode - Supplies the host node on which the resource control should
           be delivered. If this is NULL, the local node is used. Not honored!

    ControlCode- Supplies the control code that defines the
        structure and action of the resource control.
        Values of ControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    InBuffer- Supplies a pointer to the input buffer to be passed
        to the resource.

    InBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer..

    OutBuffer- Supplies a pointer to the output buffer to be
        filled in by the resource..

    OutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    BytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the resource..

    Required - Returns the number of bytes if the OutBuffer is not big
        enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD   status;

    //
    // Cluster service ioctls were designed to have access modes, e.g.
    // read-only, read-write, etc. These access modes are not implemented.
    // If eventually they are implemented, an access mode check should be
    // placed here.
    //
    if ( CLUSCTL_GET_CONTROL_OBJECT( ControlCode ) != CLUS_OBJECT_NETWORK ) {
        return(ERROR_INVALID_FUNCTION);
    }

    if (NmpEnterApi(NmStateOnline)) {
        status = NmpNetworkControl(
                     Network,
                     ControlCode,
                     InBuffer,
                     InBufferSize,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );

        NmpLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process NetworkControl request.\n"
            );
    }

    return(status);

} // NmNetworkControl



DWORD
NmpNetworkControl(
    IN PNM_NETWORK Network,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a network.

Arguments:

    Network - Supplies the network to be controlled.

    ControlCode- Supplies the control code that defines the
        structure and action of the network control.
        Values of ControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    InBuffer- Supplies a pointer to the input buffer to be passed
        to the network.

    InBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    OutBuffer- Supplies a pointer to the output buffer to be
        filled in by the network.

    OutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    BytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the network.

    Required - Returns the number of bytes if the OutBuffer is not big
        enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD   status;
    HDMKEY  networkKey;
    CLUSPROP_BUFFER_HELPER props;
    DWORD   bufSize;

    networkKey = DmOpenKey( DmNetworksKey,
                            OmObjectId( Network ),
                            MAXIMUM_ALLOWED
                        );
    if ( networkKey == NULL ) {
        return(GetLastError());
    }

    switch ( ControlCode ) {

    case CLUSCTL_NETWORK_UNKNOWN:
        *BytesReturned = 0;
        status = ERROR_SUCCESS;
        break;

    case CLUSCTL_NETWORK_GET_NAME:
        if ( OmObjectName( Network ) == NULL ) {
            return(ERROR_NOT_READY);
        }
        props.pb = OutBuffer;
        bufSize = (lstrlenW( OmObjectName( Network ) ) + 1) * sizeof(WCHAR);
        if ( bufSize > OutBufferSize ) {
            *Required = bufSize;
            *BytesReturned = 0;
            status = ERROR_MORE_DATA;
        } else {
            lstrcpyW( props.psz, OmObjectName( Network ) );
            *BytesReturned = bufSize;
            *Required = 0;
            status = ERROR_SUCCESS;
        }
        break;

    case CLUSCTL_NETWORK_GET_ID:
        if ( OmObjectId( Network ) == NULL ) {
            return(ERROR_NOT_READY);
        }
        props.pb = OutBuffer;
        bufSize = (lstrlenW( OmObjectId( Network ) ) + 1) * sizeof(WCHAR);
        if ( bufSize > OutBufferSize ) {
            *Required = bufSize;
            *BytesReturned = 0;
            status = ERROR_MORE_DATA;
        } else {
            lstrcpyW( props.psz, OmObjectId( Network ) );
            *BytesReturned = bufSize;
            *Required = 0;
            status = ERROR_SUCCESS;
        }
        break;

    case CLUSCTL_NETWORK_ENUM_COMMON_PROPERTIES:
        status = NmpNetworkEnumCommonProperties(
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );
        break;

    case CLUSCTL_NETWORK_GET_RO_COMMON_PROPERTIES:
        status = NmpNetworkGetCommonProperties(
                     Network,
                     TRUE, // ReadOnly
                     networkKey,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );
        break;

    case CLUSCTL_NETWORK_GET_COMMON_PROPERTIES:
        status = NmpNetworkGetCommonProperties(
                     Network,
                     FALSE, // ReadOnly
                     networkKey,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );
        break;

    case CLUSCTL_NETWORK_VALIDATE_COMMON_PROPERTIES:
        NmpAcquireLock();

        status = NmpNetworkValidateCommonProperties(
                     Network,
                     InBuffer,
                     InBufferSize,
                     NULL
                     );

        NmpReleaseLock();

        break;

    case CLUSCTL_NETWORK_SET_COMMON_PROPERTIES:
        status = NmpNetworkSetCommonProperties(
                     Network,
                     networkKey,
                     InBuffer,
                     InBufferSize
                     );
        break;

    case CLUSCTL_NETWORK_GET_RO_PRIVATE_PROPERTIES:
        if ( OutBufferSize < sizeof(DWORD) ) {
            *BytesReturned = 0;
            *Required = sizeof(DWORD);
            if ( OutBuffer == NULL ) {
                status = ERROR_SUCCESS;
            } else {
                status = ERROR_MORE_DATA;
            }
        } else {
            LPDWORD ptrDword = (LPDWORD) OutBuffer;
            *ptrDword = 0;
            *BytesReturned = sizeof(DWORD);
            status = ERROR_SUCCESS;
        }
        break;

    case CLUSCTL_NETWORK_GET_PRIVATE_PROPERTIES:
        status = NmpNetworkGetPrivateProperties(
                     Network,
                     networkKey,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );
        break;

    case CLUSCTL_NETWORK_VALIDATE_PRIVATE_PROPERTIES:
        status = NmpNetworkValidatePrivateProperties(
                     Network,
                     networkKey,
                     InBuffer,
                     InBufferSize
                     );
        break;

    case CLUSCTL_NETWORK_SET_PRIVATE_PROPERTIES:
        status = NmpNetworkSetPrivateProperties(
                     Network,
                     networkKey,
                     InBuffer,
                     InBufferSize
                     );
        break;

    case CLUSCTL_NETWORK_GET_CHARACTERISTICS:
        if ( OutBufferSize < sizeof(DWORD) ) {
            *BytesReturned = 0;
            *Required = sizeof(DWORD);
            if ( OutBuffer == NULL ) {
                status = ERROR_SUCCESS;
            } else {
                status = ERROR_MORE_DATA;
            }
        } else {
            *BytesReturned = sizeof(DWORD);
            *(LPDWORD)OutBuffer = 0;
            status = ERROR_SUCCESS;
        }
        break;

    case CLUSCTL_NETWORK_GET_FLAGS:
        status = NmpNetworkGetFlags(
                     Network,
                     networkKey,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );
        break;

    case CLUSCTL_NETWORK_ENUM_PRIVATE_PROPERTIES:
        status = NmpNetworkEnumPrivateProperties(
                     Network,
                     networkKey,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );

        break;

    default:
        status = ERROR_INVALID_FUNCTION;
        break;
    }

    DmCloseKey( networkKey );

    return(status);

} // NmpNetworkControl



DWORD
NmpNetworkEnumCommonProperties(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Enumerates the common property names for a given network.

Arguments:

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    //
    // Get the common properties.
    //
    status = ClRtlEnumProperties( NmpNetworkCommonProperties,
                                  OutBuffer,
                                  OutBufferSize,
                                  BytesReturned,
                                  Required );

    return(status);

} // NmpNetworkEnumCommonProperties



DWORD
NmpNetworkGetCommonProperties(
    IN PNM_NETWORK Network,
    IN BOOL ReadOnly,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the common properties for a given network.

Arguments:

    Network - Supplies the network.

    ReadOnly - TRUE if the read-only properties should be read. FALSE otherwise.

    RegistryKey - Supplies the registry key for this network.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD                   status;
    NM_NETWORK_INFO         networkInfo;
    PRESUTIL_PROPERTY_ITEM  propertyTable;
    DWORD                   outBufferSize = OutBufferSize;


    //
    // Fetch the properties from the object
    //
    ZeroMemory(&networkInfo, sizeof(networkInfo));

    NmpAcquireLock();

    status = NmpGetNetworkObjectInfo(Network, &networkInfo);

    NmpReleaseLock();

    if (status == ERROR_SUCCESS) {

        if ( ReadOnly ) {
            propertyTable = NmpNetworkROCommonProperties;
        }
        else {
            propertyTable = NmpNetworkCommonProperties;
        }

        status = ClRtlPropertyListFromParameterBlock(
                     propertyTable,
                     OutBuffer,
                     &outBufferSize,
                     (LPBYTE) &networkInfo,
                     BytesReturned,
                     Required
                     );

        ClNetFreeNetworkInfo(&networkInfo);
    }

    return(status);

} // NmpNetworkGetCommonProperties



DWORD
NmpNetworkValidateCommonProperties(
    IN  PNM_NETWORK               Network,
    IN  PVOID                     InBuffer,
    IN  DWORD                     InBufferSize,
    OUT PNM_NETWORK_INFO          NetworkInfo  OPTIONAL
    )

/*++

Routine Description:

    Validates the common properties for a given network.

Arguments:

    Network - Supplies the network object.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

    NetworkInfo - On output, contains a pointer to a network 
                  information structure with the updates applied.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

Notes:

    Called with the NmpLock held.

--*/

{
    DWORD                    status;
    NM_NETWORK_INFO          infoBuffer;
    PNM_NETWORK_INFO         networkInfo;
    LPCWSTR                  networkId = OmObjectId(Network);


    //
    // Check if there is input data.
    //
    if ( (InBuffer == NULL) ||
         (InBufferSize < sizeof(DWORD)) ) {
        return(ERROR_INVALID_DATA);
    }

    if (NetworkInfo != NULL) {
        networkInfo = NetworkInfo;
    }
    else {
        networkInfo = &infoBuffer;
    }

    ZeroMemory(networkInfo, sizeof(NM_NETWORK_INFO));

    //
    // Get a copy of the current network parameters.
    //
    status = NmpGetNetworkObjectInfo(Network, networkInfo);

    if ( status != ERROR_SUCCESS ) {
        goto error_exit;
    }

    //
    // Validate the property list and update the parameter block.
    //
    status = ClRtlVerifyPropertyTable(
                 NmpNetworkCommonProperties,
                 NULL,    // Reserved
                 FALSE,   // Don't allow unknowns
                 InBuffer,
                 InBufferSize,
                 (LPBYTE) networkInfo
                 );

    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint( LOG_CRITICAL, 
            "[NM] ValidateCommonProperties, error in verify routine.\n"
            );
        goto error_exit;
    }

    CL_ASSERT(networkInfo->Role <= ClusterNetworkRoleInternalAndClient);

    //
    // If the role changed, ensure that the change is legal for this cluster.
    //
    if (Network->Role != ((CLUSTER_NETWORK_ROLE) networkInfo->Role)) {
        status = NmpValidateNetworkRoleChange(
                     Network,
                     networkInfo->Role
                     );

        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }
    }

    //
    // The change is valid.
    //

    CL_ASSERT(status == ERROR_SUCCESS);

error_exit:

    if ((status != ERROR_SUCCESS) || (networkInfo == &infoBuffer)) {
        ClNetFreeNetworkInfo(networkInfo);
    }

    return(status);

} // NmpNetworkValidateCommonProperties



DWORD
NmpNetworkSetCommonProperties(
    IN PNM_NETWORK Network,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Sets the common properties for a given network.

Arguments:

    Network - Supplies the network object.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD         status;
    LPCWSTR       networkId = OmObjectId(Network);


    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Setting common properties for network %1!ws!.\n",
        networkId
        );

    //
    // Issue a global update
    //
    status = GumSendUpdateEx(
                 GumUpdateMembership,
                 NmUpdateSetNetworkCommonProperties,
                 3,
                 NM_WCSLEN(networkId),
                 networkId,
                 InBufferSize,
                 InBuffer,
                 sizeof(InBufferSize),
                 &InBufferSize
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Global update to set common properties for network %1!ws! failed, status %2!u!.\n",
            networkId,
            status
            );
    }


    return(status);

} // NmpNetworkSetCommonProperties



DWORD
NmpNetworkEnumPrivateProperties(
    IN PNM_NETWORK Network,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Enumerates the private property names for a given network.

Arguments:

    Network - Supplies the network object.

    RegistryKey - Registry key for the network.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HDMKEY      parametersKey;
    DWORD       totalBufferSize = 0;

    *BytesReturned = 0;
    *Required = 0;

    //
    // Clear the output buffer
    //
    ZeroMemory( OutBuffer, OutBufferSize );

    //
    // Open the cluster network parameters key.
    //
    parametersKey = DmOpenKey( RegistryKey,
                               CLUSREG_KEYNAME_PARAMETERS,
                               MAXIMUM_ALLOWED );
    if ( parametersKey == NULL ) {
        status = GetLastError();
        if ( status == ERROR_FILE_NOT_FOUND ) {
            status = ERROR_SUCCESS;
        }
        return(status);
    }

    //
    // Enum private properties for the network.
    //
    status = ClRtlEnumPrivateProperties( parametersKey,
                                         &NmpClusterRegApis,
                                         OutBuffer,
                                         OutBufferSize,
                                         BytesReturned,
                                         Required );

    DmCloseKey( parametersKey );

    return(status);

} // NmpNetworkEnumPrivateProperties



DWORD
NmpNetworkGetPrivateProperties(
    IN PNM_NETWORK Network,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the private properties for a given network.

Arguments:

    Network - Supplies the network object.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HDMKEY      parametersKey;
    DWORD       totalBufferSize = 0;

    *BytesReturned = 0;
    *Required = 0;

    //
    // Clear the output buffer
    //
    ZeroMemory( OutBuffer, OutBufferSize );

    //
    // Open the cluster network parameters key.
    //
    parametersKey = DmOpenKey( RegistryKey,
                               CLUSREG_KEYNAME_PARAMETERS,
                               MAXIMUM_ALLOWED );
    if ( parametersKey == NULL ) {
        status = GetLastError();
        if ( status == ERROR_FILE_NOT_FOUND ) {
            //
            // If we don't have a parameters key, then return an
            // item count of 0 and an endmark.
            //
            totalBufferSize = sizeof(DWORD) + sizeof(CLUSPROP_SYNTAX);
            if ( OutBufferSize < totalBufferSize ) {
                *Required = totalBufferSize;
                status = ERROR_MORE_DATA;
            } else {
                // This is somewhat redundant since we zero the
                // buffer above, but it's here for clarity.
                CLUSPROP_BUFFER_HELPER buf;
                buf.pb = OutBuffer;
                buf.pList->nPropertyCount = 0;
                buf.pdw++;
                buf.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
                *BytesReturned = totalBufferSize;
                status = ERROR_SUCCESS;
            }
        }
        return(status);
    }

    //
    // Get private properties for the network.
    //
    status = ClRtlGetPrivateProperties( parametersKey,
                                        &NmpClusterRegApis,
                                        OutBuffer,
                                        OutBufferSize,
                                        BytesReturned,
                                        Required );

    DmCloseKey( parametersKey );

    return(status);

} // NmpNetworkGetPrivateProperties



DWORD
NmpNetworkValidatePrivateProperties(
    IN PNM_NETWORK Network,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Validates the private properties for a given network.

Arguments:

    Network - Supplies the network object.

    RegistryKey - Registry key for the network.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    //
    // Validate the property list.
    //
    status = ClRtlVerifyPrivatePropertyList( InBuffer,
                                             InBufferSize );

    return(status);

} // NmpNetworkValidatePrivateProperties



DWORD
NmpNetworkSetPrivateProperties(
    IN PNM_NETWORK Network,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Sets the private properties for a given network.

Arguments:

    Network - Supplies the network object.

    RegistryKey - Registry key for the network.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HDMKEY      parametersKey;
    DWORD       disposition;
    BOOLEAN     setProperties = TRUE;

    //
    // Validate the property list.
    //
    status = ClRtlVerifyPrivatePropertyList( InBuffer,
                                             InBufferSize );

    if ( status == ERROR_SUCCESS ) {

        //
        // Validate any multicast parameters being set.
        //
        status = NmpMulticastValidatePrivateProperties(
                     Network,
                     RegistryKey,
                     InBuffer,
                     InBufferSize
                     );
        if (status == ERROR_SUCCESS) {

            //
            // Open the cluster network\xx\parameters key
            //
            parametersKey = DmOpenKey( RegistryKey,
                                       CLUSREG_KEYNAME_PARAMETERS,
                                       MAXIMUM_ALLOWED );
            if ( parametersKey == NULL ) {
                status = GetLastError();
                if ( status == ERROR_FILE_NOT_FOUND ) {
                    //
                    // Try to create the parameters key.
                    //
                    parametersKey = DmCreateKey( RegistryKey,
                                                 CLUSREG_KEYNAME_PARAMETERS,
                                                 0,
                                                 KEY_READ | KEY_WRITE,
                                                 NULL,
                                                 &disposition );
                    if ( parametersKey == NULL ) {
                        status = GetLastError();
                        return(status);
                    }
                }
            }

            NmpMulticastManualConfigChange(
                Network,
                RegistryKey,
                parametersKey,
                InBuffer,
                InBufferSize,
                &setProperties
                );
            
            if (setProperties) {
                status = ClRtlSetPrivatePropertyList( 
                             NULL, // IN HANDLE hXsaction
                             parametersKey,
                             &NmpClusterRegApis,
                             InBuffer,
                             InBufferSize
                             );
            }

            DmCloseKey( parametersKey );
        }
    }

    return(status);

} // NmpNetworkSetPrivateProperties



DWORD
NmpNetworkGetFlags(
    IN PNM_NETWORK Network,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the flags for a given network.

Arguments:

    Network - Supplies the network.

    RegistryKey - Registry key for the network.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    *BytesReturned = 0;

    if ( OutBufferSize < sizeof(DWORD) ) {
        *Required = sizeof(DWORD);
        if ( OutBuffer == NULL ) {
            status = ERROR_SUCCESS;
        } else {
            status = ERROR_MORE_DATA;
        }
    } else {
        DWORD       valueType;

        //
        // Read the Flags value for the network.
        //
        *BytesReturned = OutBufferSize;
        status = DmQueryValue( RegistryKey,
                               CLUSREG_NAME_FLAGS,
                               &valueType,
                               OutBuffer,
                               BytesReturned );
        if ( status == ERROR_FILE_NOT_FOUND ) {
            *BytesReturned = sizeof(DWORD);
            *(LPDWORD)OutBuffer = 0;
            status = ERROR_SUCCESS;
        }
    }

    return(status);

} // NmpNetworkGetFlags
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\nm\interfac.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    interface.c

Abstract:

    Implements the Node Manager network interface management routines.

Author:

    Mike Massa (mikemas) 7-Nov-1996


Revision History:

--*/


#include "nmp.h"
#include <iphlpapi.h>
#include <iprtrmib.h>
#include <ntddndis.h>
#include <ndispnp.h>


/////////////////////////////////////////////////////////////////////////////
//
// Data
//
/////////////////////////////////////////////////////////////////////////////
#define    NM_MAX_IF_PING_ENUM_SIZE      10
#define    NM_MAX_UNION_PING_ENUM_SIZE    5


LIST_ENTRY          NmpInterfaceList = {NULL, NULL};
LIST_ENTRY          NmpDeletedInterfaceList = {NULL, NULL};
DWORD               NmpInterfaceCount = 0;
WCHAR               NmpUnknownString[] = L"<Unknown>";
WCHAR               NmpNullString[] = L"";


RESUTIL_PROPERTY_ITEM
NmpInterfaceProperties[] =
    {
        {
            L"Id", NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            0,
            FIELD_OFFSET(NM_INTERFACE_INFO2, Id)
        },
        {
            CLUSREG_NAME_NETIFACE_NAME, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            0,
            FIELD_OFFSET(NM_INTERFACE_INFO2, Name)
        },
        {
            CLUSREG_NAME_NETIFACE_DESC, NULL, CLUSPROP_FORMAT_SZ,
            (DWORD_PTR) NmpNullString, 0, 0,
            0,
            FIELD_OFFSET(NM_INTERFACE_INFO2, Description)
        },
        {
            CLUSREG_NAME_NETIFACE_NODE, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            0,
            FIELD_OFFSET(NM_INTERFACE_INFO2, NodeId)
        },
        {
            CLUSREG_NAME_NETIFACE_NETWORK, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            0,
            FIELD_OFFSET(NM_INTERFACE_INFO2, NetworkId)
        },
        {
            CLUSREG_NAME_NETIFACE_ADAPTER_NAME, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            0,
            FIELD_OFFSET(NM_INTERFACE_INFO2, AdapterName)
        },
        {
            CLUSREG_NAME_NET_ADDRESS, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            0,
            FIELD_OFFSET(NM_INTERFACE_INFO2, Address)
        },
        {
            CLUSREG_NAME_NETIFACE_ENDPOINT, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            0,
            FIELD_OFFSET(NM_INTERFACE_INFO2, ClusnetEndpoint)
        },
        {
            CLUSREG_NAME_NETIFACE_STATE, NULL, CLUSPROP_FORMAT_DWORD,
            0, 0, 0xFFFFFFFF,
            0,
            FIELD_OFFSET(NM_INTERFACE_INFO2, State)
        },
        {
            CLUSREG_NAME_NETIFACE_ADAPTER_ID, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            0,
            FIELD_OFFSET(NM_INTERFACE_INFO2, AdapterId)
        },
        {
            0
        }
    };


/////////////////////////////////////////////////////////////////////////////
//
// Initialization & cleanup routines
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmpInitializeInterfaces(
    VOID
    )
/*++

Routine Description:

    Initializes network interface resources.

Arguments:

    None.

Return Value:

   A Win32 status value.

--*/

{
    DWORD                       status;
    OM_OBJECT_TYPE_INITIALIZE   objectTypeInitializer;


    ClRtlLogPrint(LOG_NOISE,"[NM] Initializing network interfaces.\n");

    //
    // Create the network interface object type
    //
    ZeroMemory(&objectTypeInitializer, sizeof(OM_OBJECT_TYPE_INITIALIZE));
    objectTypeInitializer.ObjectSize = sizeof(NM_INTERFACE);
    objectTypeInitializer.Signature = NM_INTERFACE_SIG;
    objectTypeInitializer.Name = L"Network Interface";
    objectTypeInitializer.DeleteObjectMethod = &NmpDestroyInterfaceObject;

    status = OmCreateType(ObjectTypeNetInterface, &objectTypeInitializer);

    if (status != ERROR_SUCCESS) {
        WCHAR  errorString[12];
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent1(LOG_CRITICAL, CS_EVENT_ALLOCATION_FAILURE, errorString);
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Unable to create network interface object type, %1!u!\n",
            status
            );
    }

    return(status);

}  // NmpInitializeInterfaces


VOID
NmpCleanupInterfaces(
    VOID
    )
/*++

Routine Description:

    Destroys all existing network interface resources.

Arguments:

    None.

Return Value:

   None.

--*/

{
    PNM_INTERFACE  netInterface;
    PLIST_ENTRY    entry;
    DWORD          status;


    ClRtlLogPrint(
        LOG_NOISE, 
        "[NM] Interface cleanup starting...\n"
        );

    //
    // Now clean up all the interface objects.
    //
    NmpAcquireLock();

    while (!IsListEmpty(&NmpInterfaceList)) {

        entry = RemoveHeadList(&NmpInterfaceList);

        netInterface = CONTAINING_RECORD(entry, NM_INTERFACE, Linkage);
        CL_ASSERT(NM_OM_INSERTED(netInterface));

        NmpDeleteInterfaceObject(netInterface, FALSE);
    }

    NmpReleaseLock();

    ClRtlLogPrint(LOG_NOISE,"[NM] Network interface cleanup complete\n");

    return;

}  // NmpCleanupInterfaces


/////////////////////////////////////////////////////////////////////////////
//
// Top-level routines called during network configuration
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmpCreateInterface(
    IN RPC_BINDING_HANDLE    JoinSponsorBinding,
    IN PNM_INTERFACE_INFO2   InterfaceInfo
    )
/*++

Notes:

    Must not be called with NM lock held.

--*/
{
    DWORD   status;


    CL_ASSERT(InterfaceInfo->NetIndex == NmInvalidInterfaceNetIndex);

    if (JoinSponsorBinding != NULL) {
        //
        // We are joining a cluster. Ask the sponsor to do the dirty work.
        //
        status = NmRpcCreateInterface2(
                     JoinSponsorBinding,
                     NmpJoinSequence,
                     NmLocalNodeIdString,
                     InterfaceInfo
                     );
    }
    else if (NmpState == NmStateOnlinePending) {
        HLOCALXSACTION   xaction;

        //
        // We are forming a cluster. Add the definition directly to the
        // database. The corresponding object will be created later in
        // the form process.
        //

        //
        // Start a transaction - this must be done before acquiring the
        //                       NM lock.
        //
        xaction = DmBeginLocalUpdate();

        if (xaction == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Failed to start a transaction, status %1!u!\n",
                status
                );
            return(status);
        }

        status = NmpCreateInterfaceDefinition(InterfaceInfo, xaction);

        //
        // Complete the transaction - this must be done after releasing
        //                            the NM lock.
        //
        if (status == ERROR_SUCCESS) {
            DmCommitLocalUpdate(xaction);
        }
        else {
            DmAbortLocalUpdate(xaction);
        }
    }
    else {
        //
        // We are online. This is a PnP update.
        //
        NmpAcquireLock();

        status = NmpGlobalCreateInterface(InterfaceInfo);

        NmpReleaseLock();
    }

    return(status);

}  // NmpCreateInterface


DWORD
NmpSetInterfaceInfo(
    IN RPC_BINDING_HANDLE    JoinSponsorBinding,
    IN PNM_INTERFACE_INFO2   InterfaceInfo
    )
/*++

Notes:

    Must not be called with NM lock held.

--*/
{
    DWORD   status;


    if (JoinSponsorBinding != NULL) {
        //
        // We are joining a cluster. Ask the sponsor to do the dirty work.
        //
        status = NmRpcSetInterfaceInfo2(
                     JoinSponsorBinding,
                     NmpJoinSequence,
                     NmLocalNodeIdString,
                     InterfaceInfo
                     );
    }
    else if (NmpState == NmStateOnlinePending) {
        //
        // We are forming a cluster. Update the database directly.
        //
        HLOCALXSACTION   xaction;


        //
        // Start a transaction - this must be done before acquiring the
        //                       NM lock.
        //
        xaction = DmBeginLocalUpdate();

        if (xaction == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Failed to start a transaction, status %1!u!\n",
                status
                );
            return(status);
        }

        status = NmpSetInterfaceDefinition(InterfaceInfo, xaction);

        //
        // Complete the transaction - this must be done after releasing
        //                            the NM lock.
        //
        if (status == ERROR_SUCCESS) {
            DmCommitLocalUpdate(xaction);
        }
        else {
            DmAbortLocalUpdate(xaction);
        }
    }
    else {
        //
        // We are online. This is a PnP update.
        //
        NmpAcquireLock();

        status = NmpGlobalSetInterfaceInfo(InterfaceInfo);

        NmpReleaseLock();
    }

    return(status);

}  // NmpSetInterfaceInfo


DWORD
NmpDeleteInterface(
    IN     RPC_BINDING_HANDLE   JoinSponsorBinding,
    IN     LPWSTR               InterfaceId,
    IN     LPWSTR               NetworkId,
    IN OUT PBOOLEAN             NetworkDeleted
    )
/*++

Notes:

    Must not be called with NM lock held.

--*/
{
    DWORD                status;


    *NetworkDeleted = FALSE;

    if (JoinSponsorBinding != NULL) {
        //
        // We are joining a cluster. Ask the sponsor to perform the update.
        //
        status = NmRpcDeleteInterface(
                     JoinSponsorBinding,
                     NmpJoinSequence,
                     NmLocalNodeIdString,
                     InterfaceId,
                     NetworkDeleted
                     );
    }
    else if (NmpState == NmStateOnlinePending) {
        //
        // We are forming a cluster. Update the database directly.
        //
        HLOCALXSACTION  xaction;

        //
        // Start a transaction - this must be done before acquiring the
        //                       NM lock.
        //
        xaction = DmBeginLocalUpdate();

        if (xaction == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Failed to start a transaction, status %1!u!\n",
                status
                );
            return(status);
        }

        //
        // Delete the interface from the database.
        //
        status = DmLocalDeleteTree(xaction, DmNetInterfacesKey, InterfaceId);

        if (status == ERROR_SUCCESS) {
            PNM_INTERFACE_ENUM2   interfaceEnum = NULL;

            //
            // If this interface was the last one defined for the associated
            // network, delete the network.
            //
            status = NmpEnumInterfaceDefinitions(&interfaceEnum);

            if (status == ERROR_SUCCESS) {
                BOOLEAN              deleteNetwork = TRUE;
                PNM_INTERFACE_INFO2  interfaceInfo;
                DWORD                i;


                for (i=0; i<interfaceEnum->InterfaceCount; i++) {
                    interfaceInfo = &(interfaceEnum->InterfaceList[i]);

                    if (wcscmp(interfaceInfo->NetworkId, NetworkId) == 0) {
                        deleteNetwork = FALSE;
                        break;
                    }
                }

                if (deleteNetwork) {
                    status = DmLocalDeleteTree(
                                 xaction,
                                 DmNetworksKey,
                                 NetworkId
                                 );

                    if (status == ERROR_SUCCESS) {
                        *NetworkDeleted = TRUE;
                    }
                }

                ClNetFreeInterfaceEnum(interfaceEnum);
            }
        }

        //
        // Complete the transaction - this must be done after releasing
        //                            the NM lock.
        //
        if (status == ERROR_SUCCESS) {
            DmCommitLocalUpdate(xaction);
        }
        else {
            DmAbortLocalUpdate(xaction);
        }
    }
    else {
        //
        // We are online. This is a PnP update.
        //
        NmpAcquireLock();

        status = NmpGlobalDeleteInterface(
                     InterfaceId,
                     NetworkDeleted
                     );

        NmpReleaseLock();
    }

    return(status);

} // NmpDeleteInterface


/////////////////////////////////////////////////////////////////////////////
//
// Remote procedures called by active member nodes
//
/////////////////////////////////////////////////////////////////////////////
error_status_t
s_NmRpcReportInterfaceConnectivity(
    IN PRPC_ASYNC_STATE            AsyncState,
    IN handle_t                    IDL_handle,
    IN LPWSTR                      InterfaceId,
    IN PNM_CONNECTIVITY_VECTOR     ConnectivityVector
    )
{
    PNM_INTERFACE  netInterface;
    DWORD          status = ERROR_SUCCESS;
    RPC_STATUS     tempStatus;


    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)){
        netInterface = OmReferenceObjectById(
                           ObjectTypeNetInterface,
                           InterfaceId
                           );

        if (netInterface != NULL) {
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] Received connectivity report from node %1!u! (interface %2!u!) for network %3!ws! (%4!ws!).\n",
                netInterface->Node->NodeId,
                netInterface->NetIndex,
                OmObjectId(netInterface->Network),
                OmObjectName(netInterface->Network)
                );

            NmpProcessInterfaceConnectivityReport(
                netInterface,
                ConnectivityVector
                );

            OmDereferenceObject(netInterface);
        }
        else {
            status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] Received connectivity report from unknown interface %1!ws!.\n",
                InterfaceId
                );
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process connectivity report.\n"
            );
    }

    NmpReleaseLock();

    tempStatus = RpcAsyncCompleteCall(AsyncState, &status);

    if(tempStatus != RPC_S_OK)
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] s_NmRpcReportInterfaceConnectivity(), Error Completing Async RPC call, status %1!u!\n",
            tempStatus
            );

    return(status);

} // s_NmRpcReportInterfaceConnectivity


error_status_t
s_NmRpcGetInterfaceOnlineAddressEnum(
    IN handle_t             IDL_handle,
    IN LPWSTR               InterfaceId,
    OUT PNM_ADDRESS_ENUM *  OnlineAddressEnum
    )
{
    PNM_INTERFACE  netInterface;
    DWORD          status = ERROR_SUCCESS;


    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Received request to get online address enum for interface %1!ws!.\n",
        InterfaceId
        );

    *OnlineAddressEnum = NULL;

    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)){
        netInterface = OmReferenceObjectById(ObjectTypeNetInterface, InterfaceId);

        if (netInterface != NULL) {
            status = NmpBuildInterfaceOnlineAddressEnum(
                         netInterface,
                         OnlineAddressEnum
                         );

            OmDereferenceObject(netInterface);
        }
        else {
            status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] GetInterfaceOnlineAddressEnum: interface %1!ws! doesn't exist.\n",
                InterfaceId
                );
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process GetInterfaceOnlineAddressEnum request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

} // s_NmRpcGetInterfaceOnlineAddressEnum


error_status_t
s_NmRpcGetInterfacePingAddressEnum(
    IN handle_t             IDL_handle,
    IN LPWSTR               InterfaceId,
    IN PNM_ADDRESS_ENUM     OnlineAddressEnum,
    OUT PNM_ADDRESS_ENUM *  PingAddressEnum
    )
{
    PNM_INTERFACE  netInterface;
    DWORD          status = ERROR_SUCCESS;


    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Received request to get ping address enum for interface %1!ws!.\n",
        InterfaceId
        );

    *PingAddressEnum = NULL;

    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)){
        netInterface = OmReferenceObjectById(ObjectTypeNetInterface, InterfaceId);

        if (netInterface != NULL) {
            status = NmpBuildInterfacePingAddressEnum(
                         netInterface,
                         OnlineAddressEnum,
                         PingAddressEnum
                         );

            OmDereferenceObject(netInterface);
        }
        else {
            status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] GetInterfacePingAddressEnum: interface %1!ws! doesn't exist.\n",
                InterfaceId
                );
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process GetInterfacePingAddressEnum request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

} // s_NmRpcGetInterfacePingAddressEnum


//
// Note: s_NmRpcDoInterfacePing returns void rather than CallStatus
//       due to a MIDL compiler error in an early beta of W2K. Since
//       the CallStatus is the final parameter, the format on the 
//       wire is the same; however, the call works in its current
//       format, so there is no point in changing it now.
//
void
s_NmRpcDoInterfacePing(
    IN  PRPC_ASYNC_STATE     AsyncState,
    IN  handle_t             IDL_handle,
    IN  LPWSTR               InterfaceId,
    IN  PNM_ADDRESS_ENUM     PingAddressEnum,
    OUT BOOLEAN *            PingSucceeded,
    OUT error_status_t *     CallStatus
    )
{
    PNM_INTERFACE  netInterface;
    DWORD          status = ERROR_SUCCESS;
    RPC_STATUS     tempStatus;


    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Received request to ping targets for interface %1!ws!.\n",
        InterfaceId
        );

    *PingSucceeded = FALSE;

    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)){
        PNM_INTERFACE  netInterface = OmReferenceObjectById(
                                          ObjectTypeNetInterface,
                                          InterfaceId
                                          );

        if (netInterface != NULL) {
            PNM_NETWORK    network = netInterface->Network;

            if ( (network->LocalInterface == netInterface) &&
                 NmpIsNetworkRegistered(network)
               )
            {
                NmpReleaseLock();

                status = NmpDoInterfacePing(
                             netInterface,
                             PingAddressEnum,
                             PingSucceeded
                             );

                NmpAcquireLock();
            }
            else {
                status = ERROR_INVALID_PARAMETER;
                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[NM] RpcDoInterfacePing: interface %1!ws! isn't local.\n",
                    InterfaceId
                    );
            }

            OmDereferenceObject(netInterface);
        }
        else {
            status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] RpcDoInterfacePing: interface %1!ws! doesn't exist.\n",
                InterfaceId
                );
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process RpcDoInterfacePing request.\n"
            );
    }

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Finished pinging targets for interface %1!ws!.\n",
        InterfaceId
        );

    NmpReleaseLock();

    *CallStatus = status;

    tempStatus = RpcAsyncCompleteCall(AsyncState, NULL);

    if(tempStatus != RPC_S_OK)
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] s_NmRpcDoInterfacePing() Failed to complete Async RPC call, status %1!u!\n",
            tempStatus
            );


    return;

}  // s_NmRpcDoInterfacePing

/////////////////////////////////////////////////////////////////////////////
//
// Remote procedures called by joining nodes
//
/////////////////////////////////////////////////////////////////////////////
error_status_t
s_NmRpcCreateInterface(
    IN handle_t            IDL_handle,
    IN DWORD               JoinSequence,  OPTIONAL
    IN LPWSTR              JoinerNodeId,  OPTIONAL
    IN PNM_INTERFACE_INFO  InterfaceInfo1
    )
{
    DWORD                status;
    NM_INTERFACE_INFO2   interfaceInfo2;

    //
    // Translate and call the V2.0 procedure.
    //
    CopyMemory(&interfaceInfo2, InterfaceInfo1, sizeof(NM_INTERFACE_INFO));

    //
    // The NetIndex isn't used in this call.
    //
    interfaceInfo2.NetIndex = NmInvalidInterfaceNetIndex;

    //
    // Use the unknown string for the adapter ID.
    //
    interfaceInfo2.AdapterId = NmpUnknownString;

    status = s_NmRpcCreateInterface2(
                 IDL_handle,
                 JoinSequence,
                 JoinerNodeId,
                 &interfaceInfo2
                 );

    return(status);

}  // s_NmRpcCreateInterface


error_status_t
s_NmRpcCreateInterface2(
    IN handle_t             IDL_handle,
    IN DWORD                JoinSequence,  OPTIONAL
    IN LPWSTR               JoinerNodeId,  OPTIONAL
    IN PNM_INTERFACE_INFO2  InterfaceInfo2
    )
{
    DWORD  status = ERROR_SUCCESS;


    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)) {
        PNM_NODE joinerNode = NULL;

        ClRtlLogPrint(LOG_NOISE, 
            "[NMJOIN] Processing request to create new interface %1!ws! for joining node.\n",
            InterfaceInfo2->Id
            );

        if (lstrcmpW(JoinerNodeId, NmpInvalidJoinerIdString) != 0) {
            joinerNode = OmReferenceObjectById(
                             ObjectTypeNode,
                             JoinerNodeId
                             );

            if (joinerNode != NULL) {
                if ( (JoinSequence == NmpJoinSequence) &&
                     (NmpJoinerNodeId == joinerNode->NodeId) &&
                     (NmpSponsorNodeId == NmLocalNodeId) &&
                     !NmpJoinAbortPending
                   )
                {
                    CL_ASSERT(joinerNode->State == ClusterNodeJoining);
                    CL_ASSERT(NmpJoinerUp == FALSE);
                    CL_ASSERT(NmpJoinTimer != 0);

                    //
                    // Suspend the join timer while we are working on
                    // behalf of the joiner. This precludes an abort
                    // from occuring as well.
                    //
                    NmpJoinTimer = 0;
                }
                else {
                    status = ERROR_CLUSTER_JOIN_ABORTED;
                    ClRtlLogPrint(LOG_UNUSUAL, 
                        "[NMJOIN] CreateInterface call for joining node %1!ws! failed because the join was aborted.\n",
                        JoinerNodeId
                        );
                }
            }
            else {
                status = ERROR_CLUSTER_NODE_NOT_MEMBER;
                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[NMJOIN] CreateInterface call for joining node %1!ws! failed because the node is not a member of the cluster.\n",
                    JoinerNodeId
                    );
            }
        }

        if (status == ERROR_SUCCESS) {
            CL_ASSERT(InterfaceInfo2->NetIndex == NmInvalidInterfaceNetIndex);
            //
            // Just to be safe
            //
            InterfaceInfo2->NetIndex = NmInvalidInterfaceNetIndex;

            status = NmpGlobalCreateInterface(InterfaceInfo2);

            if (joinerNode != NULL) {
                //
                // Verify that the join is still in progress
                //
                if ( (JoinSequence == NmpJoinSequence) &&
                     (NmpJoinerNodeId == joinerNode->NodeId)
                   )
                {
                    CL_ASSERT(joinerNode->State == ClusterNodeJoining);
                    CL_ASSERT(NmpJoinerUp == FALSE);
                    CL_ASSERT(NmpSponsorNodeId == NmLocalNodeId);
                    CL_ASSERT(NmpJoinTimer == 0);
                    CL_ASSERT(NmpJoinAbortPending == FALSE);

                    if (status == ERROR_SUCCESS) {
                        //
                        // Restart the join timer.
                        //
                        NmpJoinTimer = NM_JOIN_TIMEOUT;

                    }
                    else {
                        //
                        // Abort the join
                        //
                        NmpJoinAbort(status, joinerNode);
                    }
                }
                else {
                    status = ERROR_CLUSTER_JOIN_ABORTED;
                    ClRtlLogPrint(LOG_UNUSUAL, 
                        "[NMJOIN] CreateInterface call for joining node %1!ws! failed because the join was aborted.\n",
                        JoinerNodeId
                        );
                }
            }
        }

        if (joinerNode != NULL) {
            OmDereferenceObject(joinerNode);
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE, 
            "[NMJOIN] Not in valid state to process CreateInterface request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

}  // s_NmRpcCreateInterface2


error_status_t
s_NmRpcSetInterfaceInfo(
    IN handle_t             IDL_handle,
    IN DWORD                JoinSequence,  OPTIONAL
    IN LPWSTR               JoinerNodeId,  OPTIONAL
    IN PNM_INTERFACE_INFO   InterfaceInfo1
    )
{
    DWORD                status;
    NM_INTERFACE_INFO2   interfaceInfo2;

    //
    // Translate and call the V2.0 procedure.
    //
    CopyMemory(&interfaceInfo2, InterfaceInfo1, sizeof(NM_INTERFACE_INFO));

    //
    // The NetIndex is not used in this call.
    //
    interfaceInfo2.NetIndex = NmInvalidInterfaceNetIndex;

    //
    // Use the unknown string for the adapter ID.
    //
    interfaceInfo2.AdapterId = NmpUnknownString;

    status = s_NmRpcSetInterfaceInfo2(
                 IDL_handle,
                 JoinSequence,
                 JoinerNodeId,
                 &interfaceInfo2
                 );

    return(status);

}  // s_NmRpcSetInterfaceInfo


error_status_t
s_NmRpcSetInterfaceInfo2(
    IN handle_t              IDL_handle,
    IN DWORD                 JoinSequence,  OPTIONAL
    IN LPWSTR                JoinerNodeId,  OPTIONAL
    IN PNM_INTERFACE_INFO2   InterfaceInfo2
    )
{
    DWORD      status = ERROR_SUCCESS;


    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)) {
        PNM_NODE joinerNode = NULL;

        ClRtlLogPrint(LOG_NOISE, 
            "[NMJOIN] Processing request to set info for interface %1!ws! for joining node.\n",
            InterfaceInfo2->Id
            );

        if (lstrcmpW(JoinerNodeId, NmpInvalidJoinerIdString) != 0) {
            joinerNode = OmReferenceObjectById(
                             ObjectTypeNode,
                             JoinerNodeId
                             );

            if (joinerNode != NULL) {
                if ( (JoinSequence == NmpJoinSequence) &&
                     (NmpJoinerNodeId == joinerNode->NodeId) &&
                     (NmpSponsorNodeId == NmLocalNodeId) &&
                     !NmpJoinAbortPending
                   )
                {
                    CL_ASSERT(joinerNode->State == ClusterNodeJoining);
                    CL_ASSERT(NmpJoinerUp == FALSE);
                    CL_ASSERT(NmpJoinTimer != 0);

                    //
                    // Suspend the join timer while we are working on
                    // behalf of the joiner. This precludes an abort
                    // from occuring as well.
                    //
                    NmpJoinTimer = 0;
                }
                else {
                    status = ERROR_CLUSTER_JOIN_ABORTED;
                    ClRtlLogPrint(LOG_UNUSUAL, 
                        "[NMJOIN] SetInterfaceInfo call for joining node %1!ws! failed because the join was aborted.\n",
                        JoinerNodeId
                        );
                }
            }
            else {
                status = ERROR_CLUSTER_NODE_NOT_MEMBER;
                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[NMJOIN] SetInterfaceInfo call for joining node %1!ws! failed because the node is not a member of the cluster.\n",
                    JoinerNodeId
                    );
            }
        }

        if (status == ERROR_SUCCESS) {
            status = NmpGlobalSetInterfaceInfo(InterfaceInfo2);

            if (joinerNode != NULL) {
                //
                // Verify that the join is still in progress
                //
                if ( (JoinSequence == NmpJoinSequence) &&
                     (NmpJoinerNodeId == joinerNode->NodeId)
                   )
                {
                    CL_ASSERT(joinerNode->State == ClusterNodeJoining);
                    CL_ASSERT(NmpJoinerUp == FALSE);
                    CL_ASSERT(NmpSponsorNodeId == NmLocalNodeId);
                    CL_ASSERT(NmpJoinTimer == 0);
                    CL_ASSERT(NmpJoinAbortPending == FALSE);

                    if (status == ERROR_SUCCESS) {
                        //
                        // Restart the join timer.
                        //
                        NmpJoinTimer = NM_JOIN_TIMEOUT;

                    }
                    else {
                        //
                        // Abort the join
                        //
                        NmpJoinAbort(status, joinerNode);
                    }
                }
                else {
                    status = ERROR_CLUSTER_JOIN_ABORTED;
                    ClRtlLogPrint(LOG_UNUSUAL, 
                        "[NMJOIN] SetInterfaceInfo call for joining node %1!ws! failed because the join was aborted.\n",
                        JoinerNodeId
                        );
                }
            }
        }

        if (joinerNode != NULL) {
            OmDereferenceObject(joinerNode);
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE, 
            "[NMJOIN] Not in valid state to process SetInterfaceInfo request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

}  // s_NmRpcSetInterfaceInfo2


error_status_t
s_NmRpcDeleteInterface(
    IN  handle_t   IDL_handle,
    IN  DWORD      JoinSequence,  OPTIONAL
    IN  LPWSTR     JoinerNodeId,  OPTIONAL
    IN  LPWSTR     InterfaceId,
    OUT BOOLEAN *  NetworkDeleted
    )
{
    DWORD           status = ERROR_SUCCESS;


    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)) {
        PNM_NODE joinerNode = NULL;

        ClRtlLogPrint(LOG_NOISE, 
            "[NMJOIN] Processing request to delete interface %1!ws! for joining node.\n",
            InterfaceId
            );

        if (lstrcmpW(JoinerNodeId, NmpInvalidJoinerIdString) != 0) {
            joinerNode = OmReferenceObjectById(
                             ObjectTypeNode,
                             JoinerNodeId
                             );

            if (joinerNode != NULL) {
                if ( (JoinSequence == NmpJoinSequence) &&
                     (NmpJoinerNodeId == joinerNode->NodeId) &&
                     (NmpSponsorNodeId == NmLocalNodeId) &&
                     !NmpJoinAbortPending
                   )
                {
                    CL_ASSERT(joinerNode->State == ClusterNodeJoining);
                    CL_ASSERT(NmpJoinerUp == FALSE);
                    CL_ASSERT(NmpJoinTimer != 0);

                    //
                    // Suspend the join timer while we are working on
                    // behalf of the joiner. This precludes an abort
                    // from occuring as well.
                    //
                    NmpJoinTimer = 0;
                }
                else {
                    status = ERROR_CLUSTER_JOIN_ABORTED;
                    ClRtlLogPrint(LOG_UNUSUAL, 
                        "[NMJOIN] DeleteInterface call for joining node %1!ws! failed because the join was aborted.\n",
                        JoinerNodeId
                        );
                }
            }
            else {
                status = ERROR_CLUSTER_NODE_NOT_MEMBER;
                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[NMJOIN] DeleteInterface call for joining node %1!ws! failed because the node is not a member of the cluster.\n",
                    JoinerNodeId
                    );
            }
        }

        if (status == ERROR_SUCCESS) {

            status = NmpGlobalDeleteInterface(
                         InterfaceId,
                         NetworkDeleted
                         );

            if (joinerNode != NULL) {
                //
                // Verify that the join is still in progress
                //
                if ( (JoinSequence == NmpJoinSequence) &&
                     (NmpJoinerNodeId == joinerNode->NodeId)
                   )
                {
                    CL_ASSERT(joinerNode->State == ClusterNodeJoining);
                    CL_ASSERT(NmpJoinerUp == FALSE);
                    CL_ASSERT(NmpSponsorNodeId == NmLocalNodeId);
                    CL_ASSERT(NmpJoinTimer == 0);
                    CL_ASSERT(NmpJoinAbortPending == FALSE);

                    if (status == ERROR_SUCCESS) {
                        //
                        // Restart the join timer.
                        //
                        NmpJoinTimer = NM_JOIN_TIMEOUT;
                    }
                    else {
                        //
                        // Abort the join
                        //
                        NmpJoinAbort(status, joinerNode);
                    }
                }
                else {
                    status = ERROR_CLUSTER_JOIN_ABORTED;
                    ClRtlLogPrint(LOG_UNUSUAL, 
                        "[NMJOIN] DeleteInterface call for joining node %1!ws! failed because the join was aborted.\n",
                        JoinerNodeId
                        );
                }
            }
        }

        if (joinerNode != NULL) {
            OmDereferenceObject(joinerNode);
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE, 
            "[NMJOIN] Not in valid state to process DeleteInterface request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

}  // s_NmRpcDeleteInterface


error_status_t
NmpEnumInterfaceDefinitionsForJoiner(
    IN  DWORD                  JoinSequence,   OPTIONAL
    IN  LPWSTR                 JoinerNodeId,   OPTIONAL
    OUT PNM_INTERFACE_ENUM  *  InterfaceEnum1,
    OUT PNM_INTERFACE_ENUM2 *  InterfaceEnum2
    )
{
    DWORD     status = ERROR_SUCCESS;
    PNM_NODE  joinerNode = NULL;


    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE, 
            "[NMJOIN] Supplying interface information to joining node.\n"
            );

        if (lstrcmpW(JoinerNodeId, NmpInvalidJoinerIdString) != 0) {
            joinerNode = OmReferenceObjectById(
                             ObjectTypeNode,
                             JoinerNodeId
                             );

            if (joinerNode != NULL) {
                if ( (JoinSequence == NmpJoinSequence) &&
                     (NmpJoinerNodeId == joinerNode->NodeId) &&
                     (NmpSponsorNodeId == NmLocalNodeId) &&
                     !NmpJoinAbortPending
                   )
                {
                    CL_ASSERT(joinerNode->State == ClusterNodeJoining);
                    CL_ASSERT(NmpJoinerUp == FALSE);
                    CL_ASSERT(NmpJoinTimer != 0);

                    //
                    // Suspend the join timer while we are working on
                    // behalf of the joiner. This precludes an abort
                    // from occuring as well.
                    //
                    NmpJoinTimer = 0;
                }
                else {
                    status = ERROR_CLUSTER_JOIN_ABORTED;
                    ClRtlLogPrint(LOG_UNUSUAL, 
                        "[NMJOIN] EnumInterfaceDefinitions call for joining node %1!ws! failed because the join was aborted.\n",
                        JoinerNodeId
                        );
                }
            }
            else {
                status = ERROR_CLUSTER_NODE_NOT_MEMBER;
                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[NMJOIN] EnumInterfaceDefinitions call for joining node %1!ws! failed because the node is not a member of the cluster.\n",
                    JoinerNodeId
                    );
            }
        }

        if (status == ERROR_SUCCESS) {
            if (InterfaceEnum1 != NULL) {
                status = NmpEnumInterfaceObjects1(InterfaceEnum1);
            }
            else {
                CL_ASSERT(InterfaceEnum2 != NULL);
                status = NmpEnumInterfaceObjects(InterfaceEnum2);
            }

            if (joinerNode != NULL) {
                if (status == ERROR_SUCCESS) {
                    //
                    // Restart the join timer.
                    //
                    NmpJoinTimer = NM_JOIN_TIMEOUT;
                }
                else {
                    ClRtlLogPrint(LOG_CRITICAL, 
                        "[NMJOIN] EnumInterfaceDefinitions failed, status %1!u!.\n",
                        status
                        );

                    //
                    // Abort the join
                    //
                    NmpJoinAbort(status, joinerNode);
                }
            }
        }

        if (joinerNode != NULL) {
            OmDereferenceObject(joinerNode);
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE, 
            "[NMJOIN] Not in valid state to process EnumInterfaceDefinitions request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

}  // NmpEnumInterfaceDefinitionsForJoiner


error_status_t
s_NmRpcEnumInterfaceDefinitions(
    IN  handle_t              IDL_handle,
    IN  DWORD                 JoinSequence,   OPTIONAL
    IN  LPWSTR                JoinerNodeId,   OPTIONAL
    OUT PNM_INTERFACE_ENUM *  InterfaceEnum1
    )
{
    error_status_t  status;

    status = NmpEnumInterfaceDefinitionsForJoiner(
                 JoinSequence,
                 JoinerNodeId,
                 InterfaceEnum1,
                 NULL
                 );

    return(status);

}  // s_NmRpcEnumInterfaceDefinitions

error_status_t
s_NmRpcEnumInterfaceDefinitions2(
    IN  handle_t               IDL_handle,
    IN  DWORD                  JoinSequence,   OPTIONAL
    IN  LPWSTR                 JoinerNodeId,   OPTIONAL
    OUT PNM_INTERFACE_ENUM2 *  InterfaceEnum2
    )
{
    error_status_t  status;

    status = NmpEnumInterfaceDefinitionsForJoiner(
                 JoinSequence,
                 JoinerNodeId,
                 NULL,
                 InterfaceEnum2
                 );

    return(status);

}  // s_NmRpcEnumInterfaceDefinitions2


error_status_t
s_NmRpcReportJoinerInterfaceConnectivity(
    IN handle_t                    IDL_handle,
    IN DWORD                       JoinSequence,
    IN LPWSTR                      JoinerNodeId,
    IN LPWSTR                      InterfaceId,
    IN PNM_CONNECTIVITY_VECTOR     ConnectivityVector
    )
{
    DWORD status = ERROR_SUCCESS;


    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)){
        PNM_NODE joinerNode = OmReferenceObjectById(
                                  ObjectTypeNode,
                                  JoinerNodeId
                                  );

        if (joinerNode != NULL) {
            //
            // If the node is still joining, forward the report to the
            // leader. Note that reports may race with the node transitioning
            // to the up state, so accept reports from up nodes as well.
            //
            if ( ( (JoinSequence == NmpJoinSequence) &&
                   (NmpJoinerNodeId == joinerNode->NodeId) &&
                   (NmpSponsorNodeId == NmLocalNodeId) &&
                   !NmpJoinAbortPending
                 )
                 ||
                 NM_NODE_UP(joinerNode)
               )
            {
                PNM_INTERFACE  netInterface = OmReferenceObjectById(
                                                  ObjectTypeNetInterface,
                                                  InterfaceId
                                                  );

                if (netInterface != NULL) {
                    PNM_NETWORK   network = netInterface->Network;
                    LPCWSTR       networkId = OmObjectId(network);

                    if (NmpLeaderNodeId == NmLocalNodeId) {
                        //
                        // This node is the leader. Process the report.
                        //
                        ClRtlLogPrint(LOG_NOISE, 
                            "[NM] Processing connectivity report from joiner"
                            "node %1!ws! for network %2!ws!.\n",
                            JoinerNodeId,
                            networkId
                            );

                        NmpProcessInterfaceConnectivityReport(
                            netInterface,
                            ConnectivityVector
                            );
                    }
                    else {

                        //
                        // Forward the report to the leader.
                        //
                        RPC_BINDING_HANDLE  binding;

                        ClRtlLogPrint(LOG_NOISE, 
                            "[NM] Forwarding connectivity report from joiner "
                            "node %1!ws! for network %2!ws! to leader.\n",
                            JoinerNodeId,
                            networkId
                            );

                        binding = Session[NmpLeaderNodeId];
                        CL_ASSERT(binding != NULL);

                        OmReferenceObject(network);

                        status = NmpReportInterfaceConnectivity(
                                     binding,
                                     InterfaceId,
                                     ConnectivityVector,
                                     (LPWSTR) networkId
                                     );

                        if (status != ERROR_SUCCESS) {
                            ClRtlLogPrint(LOG_UNUSUAL, 
                                "[NM] Failed to forward connectivity report "
                                "from joiner node %1!ws! for network %2!ws!"
                                "to leader, status %3!u!\n",
                                JoinerNodeId,
                                networkId,
                                status
                                );
                        }

                        OmDereferenceObject(network);
                    }

                    OmDereferenceObject(netInterface);
                }
                else {
                    ClRtlLogPrint(LOG_UNUSUAL, 
                        "[NMJOIN] Rejecting connectivity report from joining "
                        "node %1!ws! because interface %2!ws! does not "
                        "exist.\n",
                        JoinerNodeId,
                        InterfaceId
                        );
                    status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
                }
            }
            else {
                status = ERROR_CLUSTER_JOIN_ABORTED;
                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[NMJOIN] Ignoring connectivity report from joining "
                    "node %1!ws! because the join was aborted.\n",
                    JoinerNodeId
                    );
            }

            OmDereferenceObject(joinerNode);
        }
        else {
            status = ERROR_CLUSTER_NODE_NOT_MEMBER;
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NMJOIN] Ignoring connectivity report from joining node "
                "%1!ws! because the joiner is not a member of the cluster.\n",
                JoinerNodeId
                );
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE, 
            "[NMJOIN] Not in valid state to process connectivity report "
            "from joiner node %1!ws!.\n",
            JoinerNodeId
            );
    }

    NmpReleaseLock();

    return(status);

} // s_NmRpcReportJoinerInterfaceConnectivity


/////////////////////////////////////////////////////////////////////////////
//
// Routines used to make global configuration changes when the node
// is online.
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmpGlobalCreateInterface(
    IN PNM_INTERFACE_INFO2  InterfaceInfo
    )
/*++

Notes:

    Called with the NmpLock held.

--*/
{
    DWORD  status;
    DWORD  interfacePropertiesSize;
    PVOID  interfaceProperties;


    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Issuing global update to create interface %1!ws!.\n",
        InterfaceInfo->Id
        );

    //
    // Marshall the info structures into property lists.
    //
    status = NmpMarshallObjectInfo(
                 NmpInterfaceProperties,
                 InterfaceInfo,
                 &interfaceProperties,
                 &interfacePropertiesSize
                 );

    if (status == ERROR_SUCCESS) {

        NmpReleaseLock();

        //
        // Issue a global update
        //
        status = GumSendUpdateEx(
                     GumUpdateMembership,
                     NmUpdateCreateInterface,
                     2,
                     interfacePropertiesSize,
                     interfaceProperties,
                     sizeof(interfacePropertiesSize),
                     &interfacePropertiesSize
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Global update to create interface %1!ws! failed, status %2!u!.\n",
                InterfaceInfo->Id,
                status
                );
        }

        MIDL_user_free(interfaceProperties);

        NmpAcquireLock();
    }
    else {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to marshall properties for new interface %1!ws!, status %2!u!\n",
            InterfaceInfo->Id,
            status
            );
    }

    return(status);

}  // NmpGlobalCreateInterface


DWORD
NmpGlobalSetInterfaceInfo(
    IN PNM_INTERFACE_INFO2   InterfaceInfo
    )
/*++

Notes:

    Called with the NmpLock held.

--*/
{
    DWORD      status = ERROR_SUCCESS;
    DWORD      interfacePropertiesSize;
    PVOID      interfaceProperties;


    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Issuing global update to set info for interface %1!ws!.\n",
        InterfaceInfo->Id
        );

    //
    // Marshall the info structures into property lists.
    //
    status = NmpMarshallObjectInfo(
                 NmpInterfaceProperties,
                 InterfaceInfo,
                 &interfaceProperties,
                 &interfacePropertiesSize
                 );

    if (status == ERROR_SUCCESS) {
        NmpReleaseLock();

        //
        // Issue a global update
        //
        status = GumSendUpdateEx(
                     GumUpdateMembership,
                     NmUpdateSetInterfaceInfo,
                     2,
                     interfacePropertiesSize,
                     interfaceProperties,
                     sizeof(interfacePropertiesSize),
                     &interfacePropertiesSize
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Global update to set properties for interface %1!ws! failed, status %2!u!.\n",
                InterfaceInfo->Id,
                status
                );
        }

        MIDL_user_free(interfaceProperties);

        NmpAcquireLock();
    }
    else {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to marshall properties for interface %1!ws!, status %2!u!\n",
            InterfaceInfo->Id,
            status
            );
    }

    return(status);

}  // NmpGlobalSetInterfaceInfo


DWORD
NmpGlobalDeleteInterface(
    IN     LPWSTR    InterfaceId,
    IN OUT PBOOLEAN  NetworkDeleted
    )
/*++

Notes:

    Called with the NmpLock held.

--*/
{
    DWORD           status = ERROR_SUCCESS;
    PNM_INTERFACE   netInterface;


    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Issuing global update to delete interface %1!ws!.\n",
        InterfaceId
        );

    //
    // Find the interface object
    //
    netInterface = OmReferenceObjectById(ObjectTypeNetInterface, InterfaceId);

    if (netInterface != NULL) {
        NmpReleaseLock();

        //
        // Issue a global update
        //
        status = GumSendUpdateEx(
                     GumUpdateMembership,
                     NmUpdateDeleteInterface,
                     1,
                     (lstrlenW(InterfaceId)+1) * sizeof(WCHAR),
                     InterfaceId
                     );

        NmpAcquireLock();

        if (status == ERROR_SUCCESS) {
            //
            // Check if the network was deleted too
            //
            if (netInterface->Network->Flags & NM_FLAG_DELETE_PENDING) {
                *NetworkDeleted = TRUE;
            }
            else {
                *NetworkDeleted = FALSE;
            }
        }
        else {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Global update to delete interface %1!ws! failed, status %2!u!.\n",
                InterfaceId,
                status
                );
        }

        OmDereferenceObject(netInterface);
    }
    else {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Unable to find interface %1!ws!.\n",
            InterfaceId
            );
        status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
    }

    return(status);

}  // NmpGlobalDeleteInterface


/////////////////////////////////////////////////////////////////////////////
//
// Routines called by other cluster service components
//
/////////////////////////////////////////////////////////////////////////////
CLUSTER_NETINTERFACE_STATE
NmGetInterfaceState(
    IN  PNM_INTERFACE  Interface
    )
/*++

Routine Description:



Arguments:



Return Value:


Notes:

   Because the caller must have a reference on the object and the
   call is so simple, there is no reason to put the call through the
   EnterApi/LeaveApi dance.

--*/
{
    CLUSTER_NETINTERFACE_STATE  state;


    NmpAcquireLock();

    state = Interface->State;

    NmpReleaseLock();

    return(state);

} // NmGetInterfaceState


DWORD
NmGetInterfaceForNodeAndNetwork(
    IN     LPCWSTR    NodeName,
    IN     LPCWSTR    NetworkName,
    OUT    LPWSTR *   InterfaceName
    )
/*++

Routine Description:

    Returns the name of the interface which connects a specified node
    to a specified network.

Arguments:

    NodeName - A pointer to the unicode name of the node.

    NetworkName - A pointer to the unicode name of the network.

    InterfaceName - On output, contains a pointer to the unicode name of the
                    interface.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

--*/
{
    DWORD      status;


    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)) {
        PNM_NODE   node = OmReferenceObjectByName(ObjectTypeNode, NodeName);

        if (node != NULL) {
            PNM_NETWORK   network = OmReferenceObjectByName(
                                        ObjectTypeNetwork,
                                        NetworkName
                                        );

            if (network != NULL) {
                PLIST_ENTRY     entry;
                PNM_INTERFACE   netInterface;


                status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;

                for (entry = node->InterfaceList.Flink;
                     entry != &(node->InterfaceList);
                     entry = entry->Flink
                    )
                {
                    netInterface = CONTAINING_RECORD(
                                       entry,
                                       NM_INTERFACE,
                                       NodeLinkage
                                       );

                    if (netInterface->Network == network) {
                        LPCWSTR  interfaceId = OmObjectName(netInterface);
                        DWORD    nameLength = NM_WCSLEN(interfaceId);

                        *InterfaceName = MIDL_user_allocate(nameLength);

                        if (*InterfaceName != NULL) {
                            lstrcpyW(*InterfaceName, interfaceId);
                            status = ERROR_SUCCESS;
                        }
                        else {
                            status = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    }
                }

                OmDereferenceObject(network);
            }
            else {
                status = ERROR_CLUSTER_NETWORK_NOT_FOUND;
            }

            OmDereferenceObject(node);
        }
        else {
            status = ERROR_CLUSTER_NODE_NOT_FOUND;
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process GetInterfaceForNodeAndNetwork request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

}  // NmGetInterfaceForNodeAndNetwork


/////////////////////////////////////////////////////////////////////////////
//
// Handlers for global updates
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmpUpdateCreateInterface(
    IN BOOL     IsSourceNode,
    IN PVOID    InterfacePropertyList,
    IN LPDWORD  InterfacePropertyListSize
    )
/*++

Routine Description:

    Global update handler for creating a new interface. The interface
    definition is read from the cluster database, and a corresponding
    object is instantiated. The cluster transport is also updated if
    necessary.

Arguments:

    IsSourceNode  - Set to TRUE if this node is the source of the update.
                    Set to FALSE otherwise.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

    This routine must not be called with the NM lock held.

--*/
{
    DWORD                  status = ERROR_SUCCESS;
    NM_INTERFACE_INFO2     interfaceInfo;
    BOOLEAN                lockAcquired = FALSE;
    HLOCALXSACTION         xaction = NULL;
    PNM_INTERFACE          netInterface = NULL;


    if (!NmpEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process CreateInterface update.\n"
            );
        return(ERROR_NODE_NOT_AVAILABLE);
    }

    ZeroMemory(&interfaceInfo, sizeof(interfaceInfo));

    //
    // Unmarshall the property list.
    //
    status = NmpConvertPropertyListToInterfaceInfo(
                 InterfacePropertyList,
                 *InterfacePropertyListSize,
                 &interfaceInfo
                 );

    if (status == ERROR_SUCCESS) {
        //
        // Fake missing V2 fields
        //
        if (interfaceInfo.AdapterId == NULL) {
            interfaceInfo.AdapterId = NmpUnknownString;
        }

        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Received update to create interface %1!ws!.\n",
            interfaceInfo.Id
            );

        //
        // Start a transaction - this must be done before acquiring
        //                       the NM lock.
        //
        xaction = DmBeginLocalUpdate();

        if (xaction != NULL) {

            NmpAcquireLock(); lockAcquired = TRUE;

            status = NmpCreateInterfaceDefinition(&interfaceInfo, xaction);

            if (status == ERROR_SUCCESS) {
                CL_NODE_ID             joinerNodeId;


                joinerNodeId = NmpJoinerNodeId;

                NmpReleaseLock();

                netInterface = NmpCreateInterfaceObject(
                                   &interfaceInfo,
                                   TRUE  // Do retry on failure
                                   );

                NmpAcquireLock();

                if (netInterface != NULL) {
                    //
                    // If a node happens to be joining right now, flag
                    // the fact that it is now out of synch with the
                    // cluster config.
                    //
                    if ( ( (joinerNodeId != ClusterInvalidNodeId) &&
                           (netInterface->Node->NodeId != joinerNodeId)
                         ) ||
                         ( (NmpJoinerNodeId != ClusterInvalidNodeId) &&
                           (netInterface->Node->NodeId != NmpJoinerNodeId)
                         )
                       )
                    {
                        NmpJoinerOutOfSynch = TRUE;
                    }

                    ClusterEvent(
                        CLUSTER_EVENT_NETINTERFACE_ADDED,
                        netInterface
                        );
                }
                else {
                    status = GetLastError();
                    ClRtlLogPrint(LOG_CRITICAL, 
                        "[NM] Failed to create object for interface %1!ws!, "
                        "status %2!u!.\n",
                        interfaceInfo.Id,
                        status
                        );
                }
            }
            else {
                ClRtlLogPrint(LOG_CRITICAL, 
                    "[NM] Failed to write definition for interface %1!ws!, "
                    "status %2!u!.\n",
                    interfaceInfo.Id,
                    status
                    );
            }
        }
        else {
            status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Failed to begin a transaction, status %1!u!\n",
                status
                );
        }

        //
        // Remove faked V2 fields
        //
        if (interfaceInfo.AdapterId == NmpUnknownString) {
            interfaceInfo.AdapterId = NULL;
        }

        ClNetFreeInterfaceInfo(&interfaceInfo);
    }
    else {
        ClRtlLogPrint( LOG_CRITICAL, 
            "[NM] Failed to unmarshall properties for new interface, "
            "status %1!u!.\n",
            status
            );
    }

    if (lockAcquired) {
        NmpLockedLeaveApi();
        NmpReleaseLock();
    }
    else {
        NmpLeaveApi();
    }

    if (xaction != NULL) {
        //
        // Complete the transaction - this must be done after releasing
        //                            the NM lock.
        //
        if (status == ERROR_SUCCESS) {
            DmCommitLocalUpdate(xaction);
        }
        else {
            DmAbortLocalUpdate(xaction);
        }
    }

    if (netInterface != NULL) {
        //
        // Remove the reference put on by
        // NmpCreateInterfaceObject.
        //
        OmDereferenceObject(netInterface);
    }

    return(status);

} // NmpUpdateCreateInterface


DWORD
NmpUpdateSetInterfaceInfo(
    IN BOOL     IsSourceNode,
    IN PVOID    InterfacePropertyList,
    IN LPDWORD  InterfacePropertyListSize
    )
/*++

Routine Description:

    Global update handler for setting the properties of an interface.
    This update is issued in response to interface property changes that
    are detected internally.

Arguments:

    IsSourceNode  - Set to TRUE if this node is the source of the update.
                    Set to FALSE otherwise.

    InterfacePropertyList - A pointer to a property list that encodes the
                            new properties for the interface. All of the
                            string properties must be present, except those
                            noted in the code below.

    InterfacePropertyListSize - A pointer to a variable containing the size,
                                in bytes, of the property list described
                                by the InterfacePropertyList parameter.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

--*/
{
    DWORD                status;
    NM_INTERFACE_INFO2   interfaceInfo;


    if (!NmpEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process SetInterfaceInfo update.\n"
            );
        return(ERROR_NODE_NOT_AVAILABLE);
    }

    //
    // Unmarshall the property list so we can extract the interface ID.
    //
    status = NmpConvertPropertyListToInterfaceInfo(
                 InterfacePropertyList,
                 *InterfacePropertyListSize,
                 &interfaceInfo
                 );

    if (status == ERROR_SUCCESS) {
        PNM_INTERFACE  netInterface;

        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Received update to set properties for interface %1!ws!.\n",
            interfaceInfo.Id
            );

        //
        // Fake missing V2 fields
        //
        if (interfaceInfo.AdapterId == NULL) {
            interfaceInfo.AdapterId = NmpUnknownString;
        }

        //
        // Find the interface object
        //
        netInterface = OmReferenceObjectById(
                           ObjectTypeNetInterface,
                           interfaceInfo.Id
                           );

        if (netInterface != NULL) {
            HLOCALXSACTION   xaction;

            //
            // Begin a transaction - this must be done before acquiring the
            //                       NM lock.
            //
            xaction = DmBeginLocalUpdate();

            if (xaction != NULL) {

                NmpAcquireLock();

                //
                // Process the changes
                //
                status = NmpLocalSetInterfaceInfo(
                             netInterface,
                             &interfaceInfo,
                             xaction
                             );

                NmpReleaseLock();

                //
                // Complete the transaction - this must be done after
                //                            releasing the NM lock.
                //
                if (status == ERROR_SUCCESS) {
                    DmCommitLocalUpdate(xaction);
                }
                else {
                    DmAbortLocalUpdate(xaction);
                }
            }
            else {
                status = GetLastError();
                ClRtlLogPrint(LOG_CRITICAL, 
                    "[NM] Failed to begin a transaction, status %1!u!\n",
                    status
                    );
            }

            OmDereferenceObject(netInterface);
        }
        else {
            status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Unable to find interface %1!ws!.\n",
                interfaceInfo.Id
                );
        }

        //
        // Remove faked V2 fields
        //
        if (interfaceInfo.AdapterId == NmpUnknownString) {
            interfaceInfo.AdapterId = NULL;
        }

        ClNetFreeInterfaceInfo(&interfaceInfo);
    }
    else {
        ClRtlLogPrint( LOG_CRITICAL, 
            "[NM] Failed to unmarshall properties for interface update, "
            "status %1!u!.\n",
            status
            );
    }

    NmpLeaveApi();

    return(status);

} // NmpUpdateSetInterfaceInfo


DWORD
NmpUpdateSetInterfaceCommonProperties(
    IN BOOL     IsSourceNode,
    IN LPWSTR   InterfaceId,
    IN UCHAR *  PropertyList,
    IN LPDWORD  PropertyListLength
    )
/*++

Routine Description:

    Global update handler for setting the common properties of a interface.
    This update is issued in response to a property change request made
    through the cluster API.

Arguments:

    IsSourceNode  - Set to TRUE if this node is the source of the update.
                    Set to FALSE otherwise.

    InterfaceId - A pointer to a unicode string containing the ID of the
                  interface to update.

    PropertyList - A pointer to a property list that encodes the
                   new properties for the interface. The list might contain
                   only a partial property set for the object.

    PropertyListLength - A pointer to a variable containing the size,
                         in bytes, of the property list described
                         by the PropertyList parameter.



Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

--*/
{
    DWORD          status = ERROR_SUCCESS;
    PNM_INTERFACE  netInterface;


    if (!NmpEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process SetInterfaceCommonProperties "
            "update.\n"
            );
        return(ERROR_NODE_NOT_AVAILABLE);
    }

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Received update to set common properties for "
        "interface %1!ws!.\n",
        InterfaceId
        );

    //
    // Find the interface's object
    //
    netInterface = OmReferenceObjectById(
                       ObjectTypeNetInterface,
                       InterfaceId
                       );

    if (netInterface != NULL) {
        HLOCALXSACTION   xaction;

        //
        // Begin a transaction - this must be done before acquiring the
        //                       NM lock.
        //
        xaction = DmBeginLocalUpdate();

        if (xaction != NULL) {
            NM_INTERFACE_INFO2      interfaceInfo;


            ZeroMemory(&interfaceInfo, sizeof(interfaceInfo));

            NmpAcquireLock();

            //
            // Validate the property list and convert it to an
            // interface info struct. Properties that are not present
            // in the property list will be copied from the interface
            // object.
            //
            status = NmpInterfaceValidateCommonProperties(
                         netInterface,
                         PropertyList,
                         *PropertyListLength,
                         &interfaceInfo
                         );

            if (status == ERROR_SUCCESS) {
                //
                // Fake missing V2 fields
                //
                if (interfaceInfo.AdapterId == NULL) {
                    interfaceInfo.AdapterId = NmpUnknownString;
                }

                //
                // Apply the changes
                //
                status = NmpLocalSetInterfaceInfo(
                             netInterface,
                             &interfaceInfo,
                             xaction
                             );

                NmpReleaseLock();

                //
                // Remove faked V2 fields
                //
                if (interfaceInfo.AdapterId == NmpUnknownString) {
                    interfaceInfo.AdapterId = NULL;
                }

                ClNetFreeInterfaceInfo(&interfaceInfo);
            }
            else {
                NmpReleaseLock();

                ClRtlLogPrint(LOG_CRITICAL, 
                    "[NM] Update to set common properties for interface "
                    "%1!ws! failed because property list validation failed "
                    "with status %1!u!.\n",
                    InterfaceId,
                    status
                    );
            }

            //
            // Complete the transaction - this must be done after releasing
            //                            the NM lock.
            //
            if (status == ERROR_SUCCESS) {
                DmCommitLocalUpdate(xaction);
            }
            else {
                DmAbortLocalUpdate(xaction);
            }
        }
        else {
            status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Failed to begin a transaction, status %1!u!\n",
                status
                );
        }

        OmDereferenceObject(netInterface);
    }
    else {
        status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Unable to find interface %1!ws!.\n",
            InterfaceId
            );
    }

    NmpLeaveApi();

    return(status);

} // NmpUpdateSetInterfaceCommonProperties


DWORD
NmpUpdateDeleteInterface(
    IN BOOL     IsSourceNode,
    IN LPWSTR   InterfaceId
    )
/*++

Routine Description:

    Global update handler for deleting an interface. The corresponding
    object is deleted. The cluster transport is also updated if
    necessary.

Arguments:

    IsSourceNode  - Set to TRUE if this node is the source of the update.
                    Set to FALSE otherwise.

    InterfaceId - A pointer to a unicode string containing the ID of the
                  interface to delete.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

--*/
{
    DWORD            status;
    PNM_INTERFACE    netInterface;
    HLOCALXSACTION   xaction;


    if (!NmpEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process DeleteInterface update.\n"
            );
        return(ERROR_NODE_NOT_AVAILABLE);
    }

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Received update request to delete interface %1!ws!.\n",
        InterfaceId
        );

    xaction = DmBeginLocalUpdate();

    if (xaction != NULL) {
        //
        // Find the interface object
        //
        netInterface = OmReferenceObjectById(
                           ObjectTypeNetInterface,
                           InterfaceId
                           );

        if (netInterface != NULL) {
            BOOLEAN      deleteNetwork = FALSE;
            PNM_NETWORK  network;
            LPCWSTR      networkId;

            NmpAcquireLock();

            network = netInterface->Network;
            networkId = OmObjectId(network);

            //
            // Delete the interface definition from the database.
            //
            status = DmLocalDeleteTree(
                         xaction,
                         DmNetInterfacesKey,
                         InterfaceId
                         );

            if (status == ERROR_SUCCESS) {
                if (network->InterfaceCount == 1) {
                    //
                    // This is the last interface on the network.
                    // Delete the network too.
                    //
                    deleteNetwork = TRUE;

                    status = DmLocalDeleteTree(
                                 xaction,
                                 DmNetworksKey,
                                 networkId
                                 );

                    if (status != ERROR_SUCCESS) {
                        ClRtlLogPrint(LOG_CRITICAL, 
                            "[NM] Failed to delete definition for network "
                            "%1!ws!, status %2!u!.\n",
                            networkId,
                            status
                            );
                    }
                }
            }
            else {
                ClRtlLogPrint(LOG_CRITICAL, 
                    "[NM] Failed to delete definition for interface %1!ws!, "
                    "status %2!u!.\n",
                    InterfaceId,
                    status
                    );
            }

            if (status == ERROR_SUCCESS) {
                NmpDeleteInterfaceObject(netInterface, TRUE);

                if (deleteNetwork) {
                    NmpDeleteNetworkObject(network, TRUE);
                }
                else if (NmpIsNetworkRegistered(network)) {
                    //
                    // Schedule a connectivity report.
                    //
                    NmpScheduleNetworkConnectivityReport(network);
                }

                //
                // If a node happens to be joining right now, flag the
                // fact that it is now out of synch with the cluster
                // config.
                //
                if ( (NmpJoinerNodeId != ClusterInvalidNodeId) &&
                     (netInterface->Node->NodeId != NmpJoinerNodeId)
                   )
                {
                    NmpJoinerOutOfSynch = TRUE;
                }
            }

            NmpReleaseLock();

            OmDereferenceObject(netInterface);
        }
        else {
            status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] Unable to find interface %1!ws!.\n",
                InterfaceId
                );
        }

        //
        // Complete the transaction
        //
        if (status == ERROR_SUCCESS) {
            DmCommitLocalUpdate(xaction);
        }
        else {
            DmAbortLocalUpdate(xaction);
        }
    }
    else {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to begin a transaction, status %1!u!\n",
            status
            );
    }

    NmpLeaveApi();

    return(status);

} // NmpUpdateDeleteInterface


/////////////////////////////////////////////////////////////////////////////
//
// Update helper routines
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmpLocalSetInterfaceInfo(
    IN  PNM_INTERFACE         Interface,
    IN  PNM_INTERFACE_INFO2   InterfaceInfo,
    IN  HLOCALXSACTION        Xaction
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

    Called with the NmpLock held.

--*/
{
    DWORD          status = ERROR_SUCCESS;
    PNM_NETWORK    network = Interface->Network;
    LPCWSTR        interfaceId = OmObjectId(Interface);
    HDMKEY         interfaceKey = NULL;
    BOOLEAN        updateClusnet = FALSE;
    BOOLEAN        propertyChanged = FALSE;
    BOOLEAN        nameChanged = FALSE;
    LPWSTR         descString = NULL;
    LPWSTR         adapterNameString = NULL;
    LPWSTR         adapterIdString = NULL;
    LPWSTR         addressString = NULL;
    LPWSTR         endpointString = NULL;
    DWORD          size;
    ULONG          ifAddress;


    //
    // Open the interface's database key
    //
    interfaceKey = DmOpenKey(DmNetInterfacesKey, interfaceId, KEY_WRITE);

    if (interfaceKey == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to open database key for interface %1!ws!, "
            "status %2!u!\n",
            interfaceId,
            status
            );
        goto error_exit;
    }

    //
    // Check if the description changed.
    //
    if (wcscmp(Interface->Description, InterfaceInfo->Description) != 0) {
        size = NM_WCSLEN(InterfaceInfo->Description);

        //
        // Update the database
        //
        status = DmLocalSetValue(
                     Xaction,
                     interfaceKey,
                     CLUSREG_NAME_NETIFACE_DESC,
                     REG_SZ,
                     (CONST BYTE *) InterfaceInfo->Description,
                     size
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Set of name value failed for interface %1!ws!, "
                "status %2!u!.\n",
                interfaceId,
                status
                );
            goto error_exit;
        }

        //
        // Allocate new memory resources. The object will be updated when the
        // transaction commits.
        //
        descString = MIDL_user_allocate(size);

        if (descString == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            ClRtlLogPrint(LOG_CRITICAL, "[NM] Failed to allocate memory\n");
            goto error_exit;
        }

        wcscpy(descString, InterfaceInfo->Description);

        propertyChanged = TRUE;
    }

    //
    // Check if the adapter name changed.
    //
    if (wcscmp(Interface->AdapterName, InterfaceInfo->AdapterName) != 0) {
        size = NM_WCSLEN(InterfaceInfo->AdapterName);

        //
        // Update the database
        //
        status = DmLocalSetValue(
                     Xaction,
                     interfaceKey,
                     CLUSREG_NAME_NETIFACE_ADAPTER_NAME,
                     REG_SZ,
                     (CONST BYTE *) InterfaceInfo->AdapterName,
                     size
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Set of adapter name value failed for interface %1!ws!, "
                "status %2!u!.\n",
                interfaceId,
                status
                );
            goto error_exit;
        }

        //
        // Allocate new memory resources. The object will be updated when the
        // transaction commits.
        //
        adapterNameString = MIDL_user_allocate(size);

        if (adapterNameString == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            ClRtlLogPrint(LOG_CRITICAL, "[NM] Failed to allocate memory\n");
            goto error_exit;
        }

        wcscpy(adapterNameString, InterfaceInfo->AdapterName);

        propertyChanged = TRUE;
    }

    //
    // Check if the adapter Id changed.
    //
    if (wcscmp(Interface->AdapterId, InterfaceInfo->AdapterId) != 0) {
        size = NM_WCSLEN(InterfaceInfo->AdapterId);

        //
        // Update the database
        //
        status = DmLocalSetValue(
                     Xaction,
                     interfaceKey,
                     CLUSREG_NAME_NETIFACE_ADAPTER_ID,
                     REG_SZ,
                     (CONST BYTE *) InterfaceInfo->AdapterId,
                     size
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Set of adapter Id value failed for interface %1!ws!, "
                "status %2!u!.\n",
                interfaceId,
                status
                );
            goto error_exit;
        }

        //
        // Allocate new memory resources. The object will be updated when the
        // transaction commits.
        //
        adapterIdString = MIDL_user_allocate(size);

        if (adapterIdString == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            ClRtlLogPrint(LOG_CRITICAL, "[NM] Failed to allocate memory\n");
            goto error_exit;
        }

        wcscpy(adapterIdString, InterfaceInfo->AdapterId);

        propertyChanged = TRUE;
    }

    //
    // Check if the address changed.
    //
    if (wcscmp(Interface->Address, InterfaceInfo->Address) != 0) {

        status = ClRtlTcpipStringToAddress(
                     InterfaceInfo->Address,
                     &ifAddress
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] Failed to convert interface address string %1!ws! to "
                "binary, status %2!u!.\n",
                InterfaceInfo->Address,
                status
                );
            goto error_exit;
        }

        size = NM_WCSLEN(InterfaceInfo->Address);

        //
        // Update the database
        //
        status = DmLocalSetValue(
                     Xaction,
                     interfaceKey,
                     CLUSREG_NAME_NETIFACE_ADDRESS,
                     REG_SZ,
                     (CONST BYTE *) InterfaceInfo->Address,
                     size
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Set of address value failed for interface %1!ws!, "
                "status %2!u!.\n",
                interfaceId,
                status
                );
            goto error_exit;
        }

        //
        // Allocate new memory resources. The object will be updated when the
        // transaction commits.
        //
        addressString = MIDL_user_allocate(size);

        if (addressString == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            ClRtlLogPrint(LOG_CRITICAL, "[NM] Failed to allocate memory\n");
            goto error_exit;
        }

        wcscpy(addressString, InterfaceInfo->Address);

        updateClusnet = TRUE;
        propertyChanged = TRUE;
    }

    //
    // Check if the clusnet endpoint changed.
    //
    if (wcscmp(
            Interface->ClusnetEndpoint,
            InterfaceInfo->ClusnetEndpoint
            ) != 0
       )
    {
        size = NM_WCSLEN(InterfaceInfo->ClusnetEndpoint);

        //
        // Update the database
        //
        status = DmLocalSetValue(
                     Xaction,
                     interfaceKey,
                     CLUSREG_NAME_NETIFACE_ENDPOINT,
                     REG_SZ,
                     (CONST BYTE *) InterfaceInfo->ClusnetEndpoint,
                     size
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Set of endpoint value failed for interface %1!ws!, "
                "status %2!u!.\n",
                interfaceId,
                status
                );
            goto error_exit;
        }

        //
        // Allocate new memory resources. The object will be updated when the
        // transaction commits.
        //
        endpointString = MIDL_user_allocate(size);

        if (endpointString == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            ClRtlLogPrint(LOG_CRITICAL, "[NM] Failed to allocate memory\n");
            goto error_exit;
        }

        wcscpy(endpointString, InterfaceInfo->ClusnetEndpoint);

        updateClusnet = TRUE;
        propertyChanged = TRUE;
    }

    //
    // Check if the object name changed.
    //
    if (wcscmp(OmObjectName(Interface), InterfaceInfo->Name) != 0) {
        size = NM_WCSLEN(InterfaceInfo->Name);

        //
        // Update the database
        //
        status = DmLocalSetValue(
                     Xaction,
                     interfaceKey,
                     CLUSREG_NAME_NETIFACE_NAME,
                     REG_SZ,
                     (CONST BYTE *) InterfaceInfo->Name,
                     size
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Set of name value failed for interface %1!ws!, "
                "status %2!u!.\n",
                interfaceId,
                status
                );
            goto error_exit;
        }

        nameChanged = TRUE;
        propertyChanged = TRUE;
    }

#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailNmSetInterfaceInfoAbort) {
        status = 999999;
        goto error_exit;
    }
#endif

    //
    // Commit the changes
    //
    if (nameChanged) {
        status = OmSetObjectName(Interface, InterfaceInfo->Name);

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Failed to change name for interface %1!ws!, "
                "status %2!u!\n",
                interfaceId,
                status
                );
            goto error_exit;
        }
    }

    if (descString != NULL) {
        MIDL_user_free(Interface->Description);
        Interface->Description = descString;
    }

    if (adapterNameString != NULL) {
        MIDL_user_free(Interface->AdapterName);
        Interface->AdapterName = adapterNameString;
    }

    if (adapterIdString != NULL) {
        MIDL_user_free(Interface->AdapterId);
        Interface->AdapterId = adapterIdString;
    }

    if (addressString != NULL) {
        MIDL_user_free(Interface->Address);
        Interface->Address = addressString;
        Interface->BinaryAddress = ifAddress;
    }

    if (endpointString != NULL) {
        MIDL_user_free(Interface->ClusnetEndpoint);
        Interface->ClusnetEndpoint = endpointString;
    }

    //
    // Update the cluster transport if this network is active and the local
    // node is attached to it.
    //
    // This operation is not reversible. Failure is fatal for this node.
    //
    network = Interface->Network;

    if (updateClusnet && NmpIsNetworkRegistered(network)) {
        PNM_NODE     node = Interface->Node;
        LPCWSTR      networkId = OmObjectId(network);


        if (Interface == network->LocalInterface) {
            //
            // This is the local node's interface to the network.
            // We must deregister and then re-register the entire network.
            //
            NmpDeregisterNetwork(network);

            status = NmpRegisterNetwork(
                         network,
                         TRUE  // Do retry on failure
                         );
        }
        else {
            //
            // This is another node's interface to the network.
            // Deregister and then re-register the interface.
            //
            NmpDeregisterInterface(Interface);

            status = NmpRegisterInterface(
                         Interface,
                         TRUE   // Do retry on failure
                         );
        }

#ifdef CLUSTER_TESTPOINT
        TESTPT(TpFailNmSetInterfaceInfoHalt) {
            status = 999999;
        }
#endif

        if (status != ERROR_SUCCESS) {
            //
            // This is fatal.
            //
            CsInconsistencyHalt(status);
        }
    }

    if (propertyChanged) {
        ClusterEvent(CLUSTER_EVENT_NETINTERFACE_PROPERTY_CHANGE, Interface);

        //
        // If a node happens to be joining right now, flag the fact
        // that it is now out of synch with the cluster config.
        //
        if ( (NmpJoinerNodeId != ClusterInvalidNodeId) &&
             (Interface->Node->NodeId != NmpJoinerNodeId)
           )
        {
            NmpJoinerOutOfSynch = TRUE;
        }
    }

    return(ERROR_SUCCESS);

error_exit:

    if (descString != NULL) {
        MIDL_user_free(descString);
    }

    if (adapterNameString != NULL) {
        MIDL_user_free(adapterNameString);
    }

    if (adapterIdString != NULL) {
        MIDL_user_free(adapterIdString);
    }

    if (addressString != NULL) {
        MIDL_user_free(addressString);
    }

    if (endpointString != NULL) {
        MIDL_user_free(endpointString);
    }

    if (interfaceKey != NULL) {
        DmCloseKey(interfaceKey);
    }

    return(status);

} // NmpLocalSetInterfaceInfo


/////////////////////////////////////////////////////////////////////////////
//
// Database management routines
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmpCreateInterfaceDefinition(
    IN PNM_INTERFACE_INFO2   InterfaceInfo,
    IN HLOCALXSACTION        Xaction
    )
/*++

Routine Description:

    Creates a new network interface definition in the cluster database.

Arguments:

    InterfaceInfo - A structure containing the interface's definition.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

--*/
{
    DWORD     status;
    HDMKEY    interfaceKey = NULL;
    DWORD     valueLength;
    DWORD     disposition;


    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Creating database entry for interface %1!ws!\n",
        InterfaceInfo->Id
        );

    CL_ASSERT(InterfaceInfo->Id != NULL);

    interfaceKey = DmLocalCreateKey(
                        Xaction,
                        DmNetInterfacesKey,
                        InterfaceInfo->Id,
                        0,
                        KEY_WRITE,
                        NULL,
                        &disposition
                        );

    if (interfaceKey == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to create key for interface %1!ws!, status %2!u!\n",
            InterfaceInfo->Id,
            status
            );
        return(status);
    }

    CL_ASSERT(disposition == REG_CREATED_NEW_KEY);

    //
    // Write the network ID value for this interface.
    //
    valueLength = NM_WCSLEN(InterfaceInfo->NetworkId);

    status = DmLocalSetValue(
                 Xaction,
                 interfaceKey,
                 CLUSREG_NAME_NETIFACE_NETWORK,
                 REG_SZ,
                 (CONST BYTE *) InterfaceInfo->NetworkId,
                 valueLength
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Write of interface network ID failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Write the node ID value for this interface.
    //
    valueLength = NM_WCSLEN(InterfaceInfo->NodeId);

    status = DmLocalSetValue(
                 Xaction,
                 interfaceKey,
                 CLUSREG_NAME_NETIFACE_NODE,
                 REG_SZ,
                 (CONST BYTE *) InterfaceInfo->NodeId,
                 valueLength
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Write of interface node ID failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Write the rest of the parameters
    //
    status = NmpSetInterfaceDefinition(InterfaceInfo, Xaction);

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to set database definition for interface %1!ws!, status %2!u!.\n",
            InterfaceInfo->Id,
            status
            );
    }

error_exit:

    if (interfaceKey != NULL) {
        DmCloseKey(interfaceKey);
    }

    return(status);

} // NmpCreateInterfaceDefinition



DWORD
NmpGetInterfaceDefinition(
    IN  LPWSTR               InterfaceId,
    OUT PNM_INTERFACE_INFO2  InterfaceInfo
    )
/*++

Routine Description:

    Reads information about a defined cluster network interface from the
    cluster database and fills in a structure describing it.

Arguments:

    InterfaceId - A pointer to a unicode string containing the ID of the
                  interface to query.

    InterfaceInfo - A pointer to the structure to fill in with node
                    information. The ID, NetworkId, and NodeId fields of the
                    structure must already be filled in.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

--*/

{
    DWORD      status;
    HDMKEY     interfaceKey = NULL;
    DWORD      valueLength, valueSize;


    CL_ASSERT(InterfaceId != NULL);

    ZeroMemory(InterfaceInfo, sizeof(NM_INTERFACE_INFO2));

    interfaceKey = DmOpenKey(DmNetInterfacesKey, InterfaceId, KEY_READ);

    if (interfaceKey == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to open key for interface %1!ws!, status %2!u!\n",
            InterfaceId,
            status
            );
        return(status);
    }

    //
    // Copy the ID string
    //
    InterfaceInfo->Id = MIDL_user_allocate(NM_WCSLEN(InterfaceId));

    if (InterfaceInfo->Id == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to allocate memory for interface %1!ws!.\n",
            InterfaceId
            );
        goto error_exit;
    }

    wcscpy(InterfaceInfo->Id, InterfaceId);

    //
    // Read the Name for this interface.
    //
    valueLength = 0;

    status = NmpQueryString(
                 interfaceKey,
                 CLUSREG_NAME_NETIFACE_NAME,
                 REG_SZ,
                 &(InterfaceInfo->Name),
                 &valueLength,
                 &valueSize
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Query of network interface name failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Read the Description for this interface.
    //
    valueLength = 0;

    status = NmpQueryString(
                 interfaceKey,
                 CLUSREG_NAME_NETIFACE_DESC,
                 REG_SZ,
                 &(InterfaceInfo->Description),
                 &valueLength,
                 &valueSize
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Query of network interface description failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Read the Network ID for this interface.
    //
    valueLength = 0;

    status = NmpQueryString(
                 interfaceKey,
                 CLUSREG_NAME_NETIFACE_NETWORK,
                 REG_SZ,
                 &(InterfaceInfo->NetworkId),
                 &valueLength,
                 &valueSize
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Query of network id for interface %1!ws! failed, status %2!u!.\n",
            InterfaceId,
            status
            );
        goto error_exit;
    }

    //
    // Read the Node ID for this interface.
    //
    valueLength = 0;

    status = NmpQueryString(
                 interfaceKey,
                 CLUSREG_NAME_NETIFACE_NODE,
                 REG_SZ,
                 &(InterfaceInfo->NodeId),
                 &valueLength,
                 &valueSize
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Query of node Id for interface %1!ws! failed, status %2!u!.\n",
            InterfaceId,
            status
            );
        goto error_exit;
    }

    //
    // Read the adapter name value for this interface.
    //
    valueLength = 0;

    status = NmpQueryString(
                 interfaceKey,
                 CLUSREG_NAME_NETIFACE_ADAPTER_NAME,
                 REG_SZ,
                 &(InterfaceInfo->AdapterName),
                 &valueLength,
                 &valueSize
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Query of network interface adapter name failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Read the adapter Id value for this interface.
    //
    valueLength = 0;

    status = NmpQueryString(
                 interfaceKey,
                 CLUSREG_NAME_NETIFACE_ADAPTER_ID,
                 REG_SZ,
                 &(InterfaceInfo->AdapterId),
                 &valueLength,
                 &valueSize
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Query of network interface adapter Id failed, status %1!u!.\n",
            status
            );

        InterfaceInfo->AdapterId = midl_user_allocate(
                                       NM_WCSLEN(NmpUnknownString)
                                       );

        if (InterfaceInfo->AdapterId == NULL) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Failed to allocate memory for adapter Id.\n"
                );
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto error_exit;
        }

        lstrcpyW(InterfaceInfo->AdapterId, NmpUnknownString);
    }

    //
    // Read the address value for this interface.
    //
    valueLength = 0;

    status = NmpQueryString(
                 interfaceKey,
                 CLUSREG_NAME_NETIFACE_ADDRESS,
                 REG_SZ,
                 &(InterfaceInfo->Address),
                 &valueLength,
                 &valueSize
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Query of network interface address failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Read the ClusNet endpoint value for this interface.
    //
    valueLength = 0;

    status = NmpQueryString(
                 interfaceKey,
                 CLUSREG_NAME_NETIFACE_ENDPOINT,
                 REG_SZ,
                 &(InterfaceInfo->ClusnetEndpoint),
                 &valueLength,
                 &valueSize
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Query of ClusNet endpoint value for network interface failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    InterfaceInfo->State = ClusterNetInterfaceUnavailable;
    InterfaceInfo->NetIndex = NmInvalidInterfaceNetIndex;

    CL_ASSERT(status == ERROR_SUCCESS);

error_exit:

    if (status != ERROR_SUCCESS) {
        ClNetFreeInterfaceInfo(InterfaceInfo);
    }

    if (interfaceKey != NULL) {
        DmCloseKey(interfaceKey);
    }

    return(status);

}  // NmpGetInterfaceDefinition



DWORD
NmpSetInterfaceDefinition(
    IN PNM_INTERFACE_INFO2  InterfaceInfo,
    IN HLOCALXSACTION       Xaction
    )
/*++

Routine Description:

    Updates information for a network interface in the cluster database.

Arguments:

    InterfaceInfo - A pointer to a structure containing the
                    interface's definition.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

--*/
{
    DWORD     status;
    HDMKEY    interfaceKey = NULL;
    DWORD     valueLength;


    CL_ASSERT(InterfaceInfo->Id != NULL);

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Setting database entry for interface %1!ws!\n",
        InterfaceInfo->Id
        );

    interfaceKey = DmOpenKey(
                       DmNetInterfacesKey,
                       InterfaceInfo->Id,
                       KEY_WRITE
                       );

    if (interfaceKey == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to open key for interface %1!ws!, status %2!u!\n",
            InterfaceInfo->Id,
            status
            );
        return(status);
    }

    //
    // Write the name value for this interface.
    //
    valueLength = (wcslen(InterfaceInfo->Name) + 1) * sizeof(WCHAR);

    status = DmLocalSetValue(
                 Xaction,
                 interfaceKey,
                 CLUSREG_NAME_NETIFACE_NAME,
                 REG_SZ,
                 (CONST BYTE *) InterfaceInfo->Name,
                 valueLength
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Update of interface name failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Write the description value for this interface.
    //
    valueLength = (wcslen(InterfaceInfo->Description) + 1) * sizeof(WCHAR);

    status = DmLocalSetValue(
                 Xaction,
                 interfaceKey,
                 CLUSREG_NAME_NETIFACE_DESC,
                 REG_SZ,
                 (CONST BYTE *) InterfaceInfo->Description,
                 valueLength
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Update of interface description failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Write the adapter name value for this interface.
    //
    valueLength = (wcslen(InterfaceInfo->AdapterName) + 1) * sizeof(WCHAR);

    status = DmLocalSetValue(
                 Xaction,
                 interfaceKey,
                 CLUSREG_NAME_NETIFACE_ADAPTER_NAME,
                 REG_SZ,
                 (CONST BYTE *) InterfaceInfo->AdapterName,
                 valueLength
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Update of interface adapter name failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Write the adapter Id value for this interface.
    //
    valueLength = (wcslen(InterfaceInfo->AdapterId) + 1) * sizeof(WCHAR);

    status = DmLocalSetValue(
                 Xaction,
                 interfaceKey,
                 CLUSREG_NAME_NETIFACE_ADAPTER_ID,
                 REG_SZ,
                 (CONST BYTE *) InterfaceInfo->AdapterId,
                 valueLength
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Update of interface adapter Id failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Write the address value for this interface.
    //
    valueLength = (wcslen(InterfaceInfo->Address) + 1) * sizeof(WCHAR);

    status = DmLocalSetValue(
                 Xaction,
                 interfaceKey,
                 CLUSREG_NAME_NETIFACE_ADDRESS,
                 REG_SZ,
                 (CONST BYTE *) InterfaceInfo->Address,
                 valueLength
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Update of interface address failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Write the ClusNet endpoint value for this interface.
    //
    valueLength = (wcslen(InterfaceInfo->ClusnetEndpoint) + 1) * sizeof(WCHAR);

    status = DmLocalSetValue(
                 Xaction,
                 interfaceKey,
                 CLUSREG_NAME_NETIFACE_ENDPOINT,
                 REG_SZ,
                 (CONST BYTE *) InterfaceInfo->ClusnetEndpoint,
                 valueLength
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Update of interface endpoint name failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    CL_ASSERT(status == ERROR_SUCCESS);

error_exit:

    if (interfaceKey != NULL) {
        DmCloseKey(interfaceKey);
    }

    return(status);

}  // NmpSetInterfaceDefinition



DWORD
NmpEnumInterfaceDefinitions(
    OUT PNM_INTERFACE_ENUM2 *  InterfaceEnum
    )
/*++

Routine Description:

    Reads interface information from the cluster database and
    fills in an enumeration structure.

Arguments:

    InterfaceEnum -  A pointer to the variable into which to place a
                     pointer to the allocated interface enumeration.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

--*/

{
    DWORD                status;
    PNM_INTERFACE_ENUM2  interfaceEnum = NULL;
    PNM_INTERFACE_INFO2  interfaceInfo;
    WCHAR                interfaceId[CS_NETINTERFACE_ID_LENGTH + 1];
    DWORD                i;
    DWORD                valueLength;
    DWORD                numInterfaces;
    DWORD                ignored;
    FILETIME             fileTime;


    *InterfaceEnum = NULL;

    //
    // First count the number of interfaces.
    //
    status = DmQueryInfoKey(
                 DmNetInterfacesKey,
                 &numInterfaces,
                 &ignored,   // MaxSubKeyLen
                 &ignored,   // Values
                 &ignored,   // MaxValueNameLen
                 &ignored,   // MaxValueLen
                 &ignored,   // lpcbSecurityDescriptor
                 &fileTime
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to query NetworkInterfaces key information, status %1!u!\n",
            status
            );
        return(status);
    }

    if (numInterfaces == 0) {
        valueLength = sizeof(NM_INTERFACE_ENUM2);

    }
    else {
        valueLength = sizeof(NM_INTERFACE_ENUM2) +
                      (sizeof(NM_INTERFACE_INFO2) * (numInterfaces-1));
    }

    valueLength = sizeof(NM_INTERFACE_ENUM2) +
                  (sizeof(NM_INTERFACE_INFO2) * (numInterfaces-1));

    interfaceEnum = MIDL_user_allocate(valueLength);

    if (interfaceEnum == NULL) {
        ClRtlLogPrint(LOG_CRITICAL, "[NM] Failed to allocate memory.\n");
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    ZeroMemory(interfaceEnum, valueLength);

    for (i=0; i < numInterfaces; i++) {
        interfaceInfo = &(interfaceEnum->InterfaceList[i]);

        valueLength = sizeof(interfaceId);

        status = DmEnumKey(
                     DmNetInterfacesKey,
                     i,
                     &(interfaceId[0]),
                     &valueLength,
                     NULL
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Failed to enumerate interface key, status %1!u!\n",
                status
                );
            goto error_exit;
        }

        status = NmpGetInterfaceDefinition(interfaceId, interfaceInfo);

        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }

        interfaceEnum->InterfaceCount++;
    }

    *InterfaceEnum = interfaceEnum;

    return(ERROR_SUCCESS);


error_exit:

    if (interfaceEnum != NULL) {
        ClNetFreeInterfaceEnum(interfaceEnum);
    }

    return(status);

}  // NmpEnumInterfaceDefinitions


/////////////////////////////////////////////////////////////////////////////
//
// Object management routines
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmpCreateInterfaceObjects(
    IN PNM_INTERFACE_ENUM2    InterfaceEnum
    )
/*++

Routine Description:

    Processes an interface enumeration and creates interface objects.

Arguments:

    InterfaceEnum - A pointer to an interface enumeration structure.

Return Value:

    ERROR_SUCCESS if the routine completes successfully.
    A Win32 error code otherwise.

--*/
{
    DWORD                status = ERROR_SUCCESS;
    PNM_INTERFACE_INFO2  interfaceInfo;
    PNM_INTERFACE        netInterface;
    DWORD                i;


    for (i=0; i < InterfaceEnum->InterfaceCount; i++) {
        interfaceInfo = &(InterfaceEnum->InterfaceList[i]);

        netInterface = NmpCreateInterfaceObject(
                           interfaceInfo,
                           FALSE    // Don't retry on failure
                           );

        if (netInterface == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Failed to create interface %1!ws!, status %2!u!.\n",
                interfaceInfo->Id,
                status
                );
            break;
        }
        else {
            OmDereferenceObject(netInterface);
        }
    }

    return(status);

}  // NmpCreateInterfaceObjects


PNM_INTERFACE
NmpCreateInterfaceObject(
    IN PNM_INTERFACE_INFO2   InterfaceInfo,
    IN BOOLEAN               RetryOnFailure
    )
/*++

Routine Description:

    Creates an interface object.

Arguments:

    InterfacInfo - A pointer to a structure containing the definition for
                   the interface to create.

    RegisterWithClusterTransport - TRUE if this interface should be registered
                                   with the cluster transport.
                                   FALSE otherwise.

    IssueEvent - TRUE if an INTERFACE_ADDED event should be issued when this
                 object is created. FALSE otherwise.

Return Value:

    A pointer to the new interface object on success.
    NULL on failure.

--*/
{
    DWORD                        status;
    PNM_NETWORK                  network = NULL;
    PNM_NODE                     node = NULL;
    PNM_INTERFACE                netInterface = NULL;
    BOOL                         created = FALSE;
    PNM_CONNECTIVITY_MATRIX      matrixEntry;


    ClRtlLogPrint(LOG_NOISE,
        "[NM] Creating object for interface %1!ws! (%2!ws!).\n",
        InterfaceInfo->Id,
        InterfaceInfo->Name
        );

    status = NmpPrepareToCreateInterface(
                 InterfaceInfo,
                 &network,
                 &node
                 );

    if (status != ERROR_SUCCESS) {
        SetLastError(status);
        return(NULL);
    }

    //
    // Create the interface object.
    //
    netInterface = OmCreateObject(
                       ObjectTypeNetInterface,
                       InterfaceInfo->Id,
                       InterfaceInfo->Name,
                       &created
                       );

    if (netInterface == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to create object for interface %1!ws!, status %2!u!\n",
            InterfaceInfo->Id,
            status
            );
        goto error_exit;
    }

    CL_ASSERT(created == TRUE);

    //
    // Initialize the interface object.
    //
    ZeroMemory(netInterface, sizeof(NM_INTERFACE));

    netInterface->Network = network;
    netInterface->Node = node;
    netInterface->State = ClusterNetInterfaceUnavailable;

    netInterface->Description = MIDL_user_allocate(
                                    NM_WCSLEN(InterfaceInfo->Description)
                                    );

    if (netInterface->Description == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to allocate memory.\n"
            );
        goto error_exit;
    }

    wcscpy(netInterface->Description, InterfaceInfo->Description);

    netInterface->AdapterName = MIDL_user_allocate(
                                 (wcslen(InterfaceInfo->AdapterName) + 1) *
                                     sizeof(WCHAR)
                                 );

    if (netInterface->AdapterName == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to allocate memory.\n"
            );
        goto error_exit;
    }

    wcscpy(netInterface->AdapterName, InterfaceInfo->AdapterName);

    netInterface->AdapterId = MIDL_user_allocate(
                               (wcslen(InterfaceInfo->AdapterId) + 1) *
                                   sizeof(WCHAR)
                               );

    if (netInterface->AdapterId == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to allocate memory.\n"
            );
        goto error_exit;
    }

    wcscpy(netInterface->AdapterId, InterfaceInfo->AdapterId);

    netInterface->Address = MIDL_user_allocate(
                             (wcslen(InterfaceInfo->Address) + 1) *
                                 sizeof(WCHAR)
                             );

    if (netInterface->Address == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to allocate memory.\n"
            );
        goto error_exit;
    }

    wcscpy(netInterface->Address, InterfaceInfo->Address);

    status = ClRtlTcpipStringToAddress(
                 InterfaceInfo->Address,
                 &(netInterface->BinaryAddress)
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Failed to convert interface address string %1!ws! to binary, status %2!u!.\n",
            InterfaceInfo->Address,
            status
            );
        goto error_exit;
    }

    netInterface->ClusnetEndpoint =
        MIDL_user_allocate(
            (wcslen(InterfaceInfo->ClusnetEndpoint) + 1) * sizeof(WCHAR)
            );

    if (netInterface->ClusnetEndpoint == NULL) {

        status = ERROR_NOT_ENOUGH_MEMORY;
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to allocate memory.\n"
            );
        goto error_exit;
    }

    wcscpy(netInterface->ClusnetEndpoint, InterfaceInfo->ClusnetEndpoint);

    NmpAcquireLock();

    //
    // Assign an index into the network's connectivity vector.
    //
    if (InterfaceInfo->NetIndex == NmInvalidInterfaceNetIndex) {
        //
        // Need to pick an index for this interface. Search for a free
        // entry in the network's connectivity vector.
        //
        DWORD  i;
        PNM_CONNECTIVITY_VECTOR vector = network->ConnectivityVector;


        for ( i=0; i<vector->EntryCount; i++) {
            if ( vector->Data[i] ==
                 (NM_STATE_ENTRY) ClusterNetInterfaceStateUnknown
               )
            {
                break;
            }
        }

        netInterface->NetIndex = i;

        ClRtlLogPrint(LOG_NOISE, 
        "[NM] Assigned index %1!u! to interface %2!ws!.\n",
        netInterface->NetIndex,
        InterfaceInfo->Id
        );

    }
    else {
        //
        // Use the index that was already assigned by our peers.
        //
        netInterface->NetIndex = InterfaceInfo->NetIndex;

        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Using preassigned index %1!u! for interface %2!ws!.\n",
            netInterface->NetIndex,
            InterfaceInfo->Id
            );
    }

    if (netInterface->NetIndex >= network->ConnectivityVector->EntryCount) {
        //
        // Grow the connectivity vector by the required number of entries.
        //
        PNM_STATE_ENTRY              oldMatrixEntry, newMatrixEntry;
        DWORD                        i;
        PNM_CONNECTIVITY_VECTOR      oldConnectivityVector =
                                         network->ConnectivityVector;
        PNM_CONNECTIVITY_VECTOR      newConnectivityVector;
        PNM_STATE_WORK_VECTOR        oldStateVector = network->StateWorkVector;
        PNM_STATE_WORK_VECTOR        newStateVector;
        PNM_CONNECTIVITY_MATRIX      newMatrix;
        DWORD                        oldVectorSize =
                                         oldConnectivityVector->EntryCount;
        DWORD                        newVectorSize = netInterface->NetIndex + 1;


        //
        // Note that one vector entry is included
        // in sizeof(NM_CONNECTIVITY_VECTOR).
        //
        newConnectivityVector = LocalAlloc(
                                    LMEM_FIXED,
                                    ( sizeof(NM_CONNECTIVITY_VECTOR) +
                                      ( (newVectorSize - 1) *
                                        sizeof(NM_STATE_ENTRY)
                                      )
                                    ));

        if (newConnectivityVector == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            NmpReleaseLock();
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Failed to allocate memory for connectivity vector\n"
                );
            goto error_exit;
        }

        //
        // Initialize the new vector
        //
        newConnectivityVector->EntryCount = newVectorSize;

        CopyMemory(
            &(newConnectivityVector->Data[0]),
            &(oldConnectivityVector->Data[0]),
            oldVectorSize * sizeof(NM_STATE_ENTRY)
            );

        FillMemory(
            &(newConnectivityVector->Data[oldVectorSize]),
            (newVectorSize - oldVectorSize) * sizeof(NM_STATE_ENTRY),
            (UCHAR) ClusterNetInterfaceStateUnknown
            );

        //
        // Grow the state work vector
        //
        newStateVector = LocalAlloc(
                             LMEM_FIXED,
                             newVectorSize * sizeof(NM_STATE_WORK_ENTRY)
                             );

        if (newStateVector == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            NmpReleaseLock();
            LocalFree(newConnectivityVector);
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Failed to allocate memory for state work vector\n"
                );
            goto error_exit;
        }

        CopyMemory(
            &(newStateVector[0]),
            &(oldStateVector[0]),
            oldVectorSize * sizeof(NM_STATE_WORK_ENTRY)
            );

        for (i=oldVectorSize; i<newVectorSize; i++) {
            newStateVector[i].State =
                (NM_STATE_ENTRY) ClusterNetInterfaceStateUnknown;
        }

        //
        // Grow the network connecivitity matrix
        //
        newMatrix = LocalAlloc(
                        LMEM_FIXED,
                        NM_SIZEOF_CONNECTIVITY_MATRIX(newVectorSize)
                        );

        if (newMatrix == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            NmpReleaseLock();
            LocalFree(newConnectivityVector);
            LocalFree(newStateVector);
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Failed to allocate memory for connectivity matrix\n"
                );
            goto error_exit;
        }

        //
        // Initialize the new matrix
        //
        FillMemory(
            newMatrix,
            NM_SIZEOF_CONNECTIVITY_MATRIX(newVectorSize),
            (UCHAR) ClusterNetInterfaceStateUnknown
            );

        oldMatrixEntry = network->ConnectivityMatrix;
        newMatrixEntry = newMatrix;

        for (i=0; i<oldVectorSize; i++) {
            CopyMemory(
                newMatrixEntry,
                oldMatrixEntry,
                oldVectorSize * sizeof(NM_STATE_ENTRY)
                );

            //
            // Move the pointers to the next vector
            //
            oldMatrixEntry = NM_NEXT_CONNECTIVITY_MATRIX_ROW(
                                 oldMatrixEntry,
                                 oldVectorSize
                                 );

            newMatrixEntry = NM_NEXT_CONNECTIVITY_MATRIX_ROW(
                                 newMatrixEntry,
                                 newVectorSize
                                 );
        }

        //
        // Swap the pointers
        //
        LocalFree(network->ConnectivityVector);
        network->ConnectivityVector = newConnectivityVector;

        LocalFree(network->StateWorkVector);
        network->StateWorkVector = newStateVector;

        LocalFree(network->ConnectivityMatrix);
        network->ConnectivityMatrix = newMatrix;
    }

    //
    // Initialize the connectivity data for this interface
    //
    NmpSetInterfaceConnectivityData(
        network,
        netInterface->NetIndex,
        ClusterNetInterfaceUnavailable
        );

    //
    // Link the interface object onto the various object lists
    //
    InsertTailList(&(node->InterfaceList), &(netInterface->NodeLinkage));
    node->InterfaceCount++;

    InsertTailList(&(network->InterfaceList), &(netInterface->NetworkLinkage));
    network->InterfaceCount++;

    InsertTailList(&NmpInterfaceList, &(netInterface->Linkage));
    NmpInterfaceCount++;

    OmInsertObject(netInterface);
    netInterface->Flags |= NM_FLAG_OM_INSERTED;

    //
    // Remember the interface for the local node.
    //
    if (node == NmLocalNode) {
        network->LocalInterface = netInterface;
    }

    //
    // Register with the cluster transport if needed.
    //
    if (NmpIsNetworkEnabledForUse(network)) {
        if (node == NmLocalNode) {
            //
            // This is the local node. Register the network and all
            // its interfaces with the cluster transport.
            //
            status = NmpRegisterNetwork(network, RetryOnFailure);

            if (status != ERROR_SUCCESS) {
                NmpReleaseLock();
                goto error_exit;
            }
        }
        else if (NmpIsNetworkRegistered(network)) {
            //
            // Just register this interface.
            //
            status = NmpRegisterInterface(netInterface, RetryOnFailure);

            if (status != ERROR_SUCCESS) {
                NmpReleaseLock();
                goto error_exit;
            }
        }
    }

    //
    // Put an additional reference on the object for the caller.
    //
    OmReferenceObject(netInterface);

    NmpReleaseLock();

    return(netInterface);

error_exit:

    if (netInterface != NULL) {
        NmpAcquireLock();
        NmpDeleteInterfaceObject(netInterface, FALSE);
        NmpReleaseLock();
    }

    SetLastError(status);

    return(NULL);

}  // NmpCreateInterfaceObject



DWORD
NmpGetInterfaceObjectInfo1(
    IN     PNM_INTERFACE        Interface,
    IN OUT PNM_INTERFACE_INFO   InterfaceInfo1
    )
/*++

Routine Description:

    Reads information about a defined cluster network interface from the
    interface object and fills in a structure describing it.

Arguments:

    Interface     - A pointer to the interface object to query.

    InterfaceInfo - A pointer to the structure to fill in with node
                    information.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

    Called with NmpLock held.

--*/

{
    DWORD               status;
    NM_INTERFACE_INFO2  interfaceInfo2;


    //
    // Call the V2.0 routine and translate.
    //
    ZeroMemory(&interfaceInfo2, sizeof(interfaceInfo2));
    status = NmpGetInterfaceObjectInfo(Interface, &interfaceInfo2);

    if (status == ERROR_SUCCESS) {
        CopyMemory(InterfaceInfo1, &interfaceInfo2, sizeof(NM_INTERFACE_INFO));
    }

    //
    // Free the unused V2 fields
    //
    midl_user_free(interfaceInfo2.AdapterId);

    return(status);

}  // NmpGetInterfaceObjectInfo1



DWORD
NmpGetInterfaceObjectInfo(
    IN     PNM_INTERFACE        Interface,
    IN OUT PNM_INTERFACE_INFO2  InterfaceInfo
    )
/*++

Routine Description:

    Reads information about a defined cluster network interface from the
    interface object and fills in a structure describing it.

Arguments:

    Interface     - A pointer to the interface object to query.

    InterfaceInfo - A pointer to the structure to fill in with node
                    information.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

    Called with NmpLock held.

--*/

{
    LPWSTR     tmpString = NULL;
    LPWSTR     interfaceId = (LPWSTR) OmObjectId(Interface);
    LPWSTR     interfaceName = (LPWSTR) OmObjectName(Interface);
    LPWSTR     nodeId = (LPWSTR) OmObjectId(Interface->Node);
    LPWSTR     networkId = (LPWSTR) OmObjectId(Interface->Network);


    tmpString = MIDL_user_allocate(NM_WCSLEN(interfaceId));
    if (tmpString == NULL) {
        goto error_exit;
    }
    wcscpy(tmpString, interfaceId);
    InterfaceInfo->Id = tmpString;

    tmpString = MIDL_user_allocate(NM_WCSLEN(interfaceName));
    if (tmpString == NULL) {
        goto error_exit;
    }
    wcscpy(tmpString, interfaceName);
    InterfaceInfo->Name = tmpString;

    tmpString = MIDL_user_allocate(NM_WCSLEN(Interface->Description));
    if (tmpString == NULL) {
        goto error_exit;
    }
    wcscpy(tmpString, Interface->Description);
    InterfaceInfo->Description = tmpString;

    tmpString = MIDL_user_allocate(NM_WCSLEN(nodeId));
    if (tmpString == NULL) {
        goto error_exit;
    }
    wcscpy(tmpString, nodeId);
    InterfaceInfo->NodeId = tmpString;

    tmpString = MIDL_user_allocate(NM_WCSLEN(networkId));
    if (tmpString == NULL) {
        goto error_exit;
    }
    wcscpy(tmpString, networkId);
    InterfaceInfo->NetworkId = tmpString;

    tmpString = MIDL_user_allocate(NM_WCSLEN(Interface->AdapterName));
    if (tmpString == NULL) {
        goto error_exit;
    }
    wcscpy(tmpString, Interface->AdapterName);
    InterfaceInfo->AdapterName = tmpString;

    tmpString = MIDL_user_allocate(NM_WCSLEN(Interface->AdapterId));
    if (tmpString == NULL) {
        goto error_exit;
    }
    wcscpy(tmpString, Interface->AdapterId);
    InterfaceInfo->AdapterId = tmpString;

    tmpString = MIDL_user_allocate(NM_WCSLEN(Interface->Address));
    if (tmpString == NULL) {
        goto error_exit;
    }
    wcscpy(tmpString, Interface->Address);
    InterfaceInfo->Address = tmpString;

    tmpString = MIDL_user_allocate(NM_WCSLEN(Interface->ClusnetEndpoint));
    if (tmpString == NULL) {
        goto error_exit;
    }
    wcscpy(tmpString, Interface->ClusnetEndpoint);
    InterfaceInfo->ClusnetEndpoint = tmpString;

    InterfaceInfo->State = Interface->State;
    InterfaceInfo->NetIndex = Interface->NetIndex;

    return(ERROR_SUCCESS);


error_exit:

    ClNetFreeInterfaceInfo(InterfaceInfo);

    return(ERROR_NOT_ENOUGH_MEMORY);

}  // NmpGetInterfaceObjectInfo2


VOID
NmpDeleteInterfaceObject(
    IN PNM_INTERFACE  Interface,
    IN BOOLEAN        IssueEvent
    )
/*++

Notes:

    Called with NM global lock held.

--*/
{
    LPWSTR       interfaceId = (LPWSTR) OmObjectId(Interface);
    PNM_NETWORK  network = Interface->Network;


    if (NM_DELETE_PENDING(Interface)) {
        CL_ASSERT(!NM_OM_INSERTED(Interface));
        return;
    }

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] deleting object for interface %1!ws!\n",
        interfaceId
        );

    Interface->Flags |= NM_FLAG_DELETE_PENDING;

    if (NM_OM_INSERTED(Interface)) {
        //
        // Remove the interface from the various object lists.
        //
        DWORD   status = OmRemoveObject(Interface);
        CL_ASSERT(status == ERROR_SUCCESS);

        RemoveEntryList(&(Interface->Linkage));
        CL_ASSERT(NmpInterfaceCount > 0);
        NmpInterfaceCount--;

        RemoveEntryList(&(Interface->NetworkLinkage));
        CL_ASSERT(network->InterfaceCount > 0);
        network->InterfaceCount--;

        RemoveEntryList(&(Interface->NodeLinkage));
        CL_ASSERT(Interface->Node->InterfaceCount > 0);
        Interface->Node->InterfaceCount--;

        Interface->Flags &= ~NM_FLAG_OM_INSERTED;
    }

    //
    // Place the object on the deleted list
    //
#if DBG
    {
        PLIST_ENTRY  entry;

        for ( entry = NmpDeletedInterfaceList.Flink;
              entry != &NmpDeletedInterfaceList;
              entry = entry->Flink
            )
        {
            if (entry == &(Interface->Linkage)) {
                break;
            }
        }

        CL_ASSERT(entry != &(Interface->Linkage));
    }
#endif DBG

    InsertTailList(&NmpDeletedInterfaceList, &(Interface->Linkage));

    if (network != NULL) {
        if ( (Interface->Node != NULL) &&
             NmpIsNetworkEnabledForUse(network)
           )
        {
            DWORD status;

            //
            // Deregister the interface from the cluster transport
            //
            if ( (network->LocalInterface == Interface) &&
                 NmpIsNetworkRegistered(network)
               )
            {
                //
                // Deregister the network and all of its interfaces
                //
                NmpDeregisterNetwork(network);
            }
            else if (NmpIsInterfaceRegistered(Interface)) {
                //
                // Just deregister this interface
                //
                NmpDeregisterInterface(Interface);
            }
        }

        //
        // Invalidate the connectivity data for the interface.
        //
        NmpSetInterfaceConnectivityData(
            network,
            Interface->NetIndex,
            ClusterNetInterfaceStateUnknown
            );

        if (network->LocalInterface == Interface) {
            network->LocalInterface = NULL;
            network->Flags &= ~NM_NET_IF_WORK_FLAGS;
        }

        //
        // If this is not the last interface on the network,
        // then update the network state.
        //
        if ((network->InterfaceCount != 0) &&
            (NmpLeaderNodeId == NmLocalNodeId)) {
                NmpScheduleNetworkStateRecalc(network);
        }
    }

    if (IssueEvent) {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Issuing interface deleted event for interface %1!ws!.\n",
            interfaceId
            );

        ClusterEvent(CLUSTER_EVENT_NETINTERFACE_DELETED, Interface);
    }

    //
    // Remove the initial reference so the object can be destroyed.
    //
    OmDereferenceObject(Interface);

    return;

}  // NmpDeleteInterfaceObject


BOOL
NmpDestroyInterfaceObject(
    PNM_INTERFACE  Interface
    )
{
    DWORD  status;


    ClRtlLogPrint(LOG_NOISE, 
        "[NM] destroying object for interface %1!ws!\n",
        (LPWSTR) OmObjectId(Interface)
        );

    CL_ASSERT(NM_DELETE_PENDING(Interface));
    CL_ASSERT(!NM_OM_INSERTED(Interface));

    //
    // Remove the interface from the deleted list
    //
#if DBG
    {
        PLIST_ENTRY  entry;

        for ( entry = NmpDeletedInterfaceList.Flink;
              entry != &NmpDeletedInterfaceList;
              entry = entry->Flink
            )
        {
            if (entry == &(Interface->Linkage)) {
                break;
            }
        }

        CL_ASSERT(entry == &(Interface->Linkage));
    }
#endif DBG

    RemoveEntryList(&(Interface->Linkage));

    //
    // Dereference the node and network objects
    //
    if (Interface->Node != NULL) {
        OmDereferenceObject(Interface->Node);
    }

    if (Interface->Network != NULL) {
        OmDereferenceObject(Interface->Network);
    }

    //
    // Free storage used by the object fields.
    //
    NM_FREE_OBJECT_FIELD(Interface, Description);
    NM_FREE_OBJECT_FIELD(Interface, AdapterName);
    NM_FREE_OBJECT_FIELD(Interface, AdapterId);
    NM_FREE_OBJECT_FIELD(Interface, Address);
    NM_FREE_OBJECT_FIELD(Interface, ClusnetEndpoint);

    return(TRUE);

}  // NmpDestroyInterfaceObject



DWORD
NmpEnumInterfaceObjects1(
    OUT PNM_INTERFACE_ENUM *  InterfaceEnum1
    )
/*++

Routine Description:

    Reads interface information for all defined cluster networks
    and fills in an enumeration structure.

Arguments:

    InterfaceEnum1 -  A pointer to the variable into which to place a
                      pointer to the allocated interface enumeration.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

    Called with the NmpLock held.

--*/

{
    DWORD                status = ERROR_SUCCESS;
    PNM_INTERFACE_ENUM   interfaceEnum1 = NULL;
    DWORD                i;
    DWORD                valueLength;
    PLIST_ENTRY          entry;
    PNM_INTERFACE        netInterface;


    *InterfaceEnum1 = NULL;

    if (NmpInterfaceCount == 0) {
        valueLength = sizeof(NM_INTERFACE_ENUM);
    }
    else {
        valueLength =
            sizeof(NM_INTERFACE_ENUM) +
            (sizeof(NM_INTERFACE_INFO) * (NmpInterfaceCount - 1));
    }

    interfaceEnum1 = MIDL_user_allocate(valueLength);

    if (interfaceEnum1 == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    ZeroMemory(interfaceEnum1, valueLength);

    for (entry = NmpInterfaceList.Flink, i=0;
         entry != &NmpInterfaceList;
         entry = entry->Flink, i++
        )
    {
        netInterface = CONTAINING_RECORD(entry, NM_INTERFACE, Linkage);

        status = NmpGetInterfaceObjectInfo1(
                     netInterface,
                     &(interfaceEnum1->InterfaceList[i])
                     );

        if (status != ERROR_SUCCESS) {
            ClNetFreeInterfaceEnum1(interfaceEnum1);
            return(status);
        }
    }

    interfaceEnum1->InterfaceCount = NmpInterfaceCount;
    *InterfaceEnum1 = interfaceEnum1;

    return(ERROR_SUCCESS);

}  // NmpEnumInterfaceObjects1



DWORD
NmpEnumInterfaceObjects(
    OUT PNM_INTERFACE_ENUM2 *  InterfaceEnum
    )
/*++

Routine Description:

    Reads interface information for all defined cluster networks
    and fills in an enumeration structure.

Arguments:

    InterfaceEnum -  A pointer to the variable into which to place a
                     pointer to the allocated interface enumeration.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

    Called with the NmpLock held.

--*/

{
    DWORD                 status = ERROR_SUCCESS;
    PNM_INTERFACE_ENUM2   interfaceEnum = NULL;
    DWORD                 i;
    DWORD                 valueLength;
    PLIST_ENTRY           entry;
    PNM_INTERFACE         netInterface;


    *InterfaceEnum = NULL;

    if (NmpInterfaceCount == 0) {
        valueLength = sizeof(NM_INTERFACE_ENUM2);
    }
    else {
        valueLength =
            sizeof(NM_INTERFACE_ENUM2) +
            (sizeof(NM_INTERFACE_INFO2) * (NmpInterfaceCount - 1));
    }

    interfaceEnum = MIDL_user_allocate(valueLength);

    if (interfaceEnum == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    ZeroMemory(interfaceEnum, valueLength);

    for (entry = NmpInterfaceList.Flink, i=0;
         entry != &NmpInterfaceList;
         entry = entry->Flink, i++
        )
    {
        netInterface = CONTAINING_RECORD(entry, NM_INTERFACE, Linkage);

        status = NmpGetInterfaceObjectInfo(
                     netInterface,
                     &(interfaceEnum->InterfaceList[i])
                     );

        if (status != ERROR_SUCCESS) {
            ClNetFreeInterfaceEnum((PNM_INTERFACE_ENUM2) interfaceEnum);
            return(status);
        }
    }

    interfaceEnum->InterfaceCount = NmpInterfaceCount;
    *InterfaceEnum = interfaceEnum;

    return(ERROR_SUCCESS);

}  // NmpEnumInterfaceObjects


DWORD
NmpEnumInterfaceObjectStates(
    OUT PNM_INTERFACE_STATE_ENUM *  InterfaceStateEnum
    )
/*++

Routine Description:

    Reads state information for all defined cluster network interfaces
    and fills in an enumeration structure.

Arguments:

    InterfaceStateEnum -  A pointer to the variable into which to place a
                          pointer to the allocated interface enumeration.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

    Called with the NmpLock held.

--*/

{
    DWORD                      status = ERROR_SUCCESS;
    PNM_INTERFACE_STATE_ENUM   interfaceStateEnum = NULL;
    PNM_INTERFACE_STATE_INFO   interfaceStateInfo;
    DWORD                      i;
    DWORD                      valueLength;
    PLIST_ENTRY                entry;
    PNM_INTERFACE              netInterface;
    LPWSTR                     interfaceId;


    *InterfaceStateEnum = NULL;

    if (NmpInterfaceCount == 0) {
        valueLength = sizeof(NM_INTERFACE_STATE_ENUM);
    }
    else {
        valueLength =
            sizeof(NM_INTERFACE_STATE_ENUM) +
            (sizeof(NM_INTERFACE_STATE_INFO) * (NmpInterfaceCount - 1));
    }

    interfaceStateEnum = MIDL_user_allocate(valueLength);

    if (interfaceStateEnum == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    ZeroMemory(interfaceStateEnum, valueLength);

    for (entry = NmpInterfaceList.Flink, i=0;
         entry != &NmpInterfaceList;
         entry = entry->Flink, i++
        )
    {
        netInterface = CONTAINING_RECORD(entry, NM_INTERFACE, Linkage);
        interfaceId = (LPWSTR) OmObjectId(netInterface);
        interfaceStateInfo = &(interfaceStateEnum->InterfaceList[i]);

        interfaceStateInfo->State = netInterface->State;

        interfaceStateInfo->Id = MIDL_user_allocate(NM_WCSLEN(interfaceId));

        if (interfaceStateInfo->Id == NULL) {
            NmpFreeInterfaceStateEnum(interfaceStateEnum);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        lstrcpyW(interfaceStateInfo->Id, interfaceId);
    }

    interfaceStateEnum->InterfaceCount = NmpInterfaceCount;
    *InterfaceStateEnum = interfaceStateEnum;

    return(ERROR_SUCCESS);

}  // NmpEnumInterfaceObjectStates


/////////////////////////////////////////////////////////////////////////////
//
// State Management routines
//
/////////////////////////////////////////////////////////////////////////////
VOID
NmpSetInterfaceConnectivityData(
    PNM_NETWORK                  Network,
    DWORD                        InterfaceNetIndex,
    CLUSTER_NETINTERFACE_STATE   State
    )
{
    PNM_CONNECTIVITY_MATRIX   matrixEntry;


    Network->ConnectivityVector->Data[InterfaceNetIndex] =
        (NM_STATE_ENTRY) State;

    Network->StateWorkVector[InterfaceNetIndex].State =
        (NM_STATE_ENTRY) State;

    matrixEntry = NM_GET_CONNECTIVITY_MATRIX_ENTRY(
                      Network->ConnectivityMatrix,
                      InterfaceNetIndex,
                      InterfaceNetIndex,
                      Network->ConnectivityVector->EntryCount
                      );

    *matrixEntry = (NM_STATE_ENTRY)State;

    return;

}  // NmpSetInterfaceConnectivityData


VOID
NmpReportLocalInterfaceStateEvent(
    IN CL_NODE_ID     NodeId,
    IN CL_NETWORK_ID  NetworkId,
    IN DWORD          NewState
    )
{
    PNM_INTERFACE  netInterface;


    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnlinePending)){
        netInterface = NmpGetInterfaceForNodeAndNetworkById(
                           NodeId,
                           NetworkId
                           );

        if (netInterface != NULL) {
            NmpProcessLocalInterfaceStateEvent(netInterface, NewState);
        }

        NmpLockedLeaveApi();
    }

    NmpReleaseLock();

    return;

} // NmReportLocalInterfaceStateEvent


VOID
NmpProcessLocalInterfaceStateEvent(
    IN PNM_INTERFACE                Interface,
    IN CLUSTER_NETINTERFACE_STATE   NewState
    )
/*+

Notes:

    Called with the NmpLock held.

--*/
{
    DWORD                     status;
    PNM_NETWORK               network = Interface->Network;
    LPCWSTR                   interfaceId = OmObjectId(Interface);
    LPCWSTR                   networkId = OmObjectId(network);
    LPCWSTR                   networkName = OmObjectName(network);
    PNM_NODE                  node = Interface->Node;
    LPCWSTR                   nodeName = OmObjectName(node);
    PNM_CONNECTIVITY_VECTOR   vector = network->ConnectivityVector;
    DWORD                     ifNetIndex = Interface->NetIndex;


    //
    // Filter out stale reports for dead nodes.
    //
    if ((node == NmLocalNode) || (node->State != ClusterNodeDown)) {
        CL_ASSERT(
            vector->Data[ifNetIndex] !=
            (NM_STATE_ENTRY) ClusterNetInterfaceStateUnknown
            );

        //
        // Apply the change to the local connectivity vector.
        //
        vector->Data[ifNetIndex] = (NM_STATE_ENTRY) NewState;

        //
        // Log an event
        //
        switch (NewState) {

        case ClusterNetInterfaceUp:
            //
            // A local interface is now operational, or a remote interface
            // is now reachable. Schedule an immediate connectivity report,
            // since this event may avert failure of resources that depend
            // on the interface.
            //
            if (node != NmLocalNode) {
                ClRtlLogPrint(LOG_NOISE, 
                    "[NM] Communication was (re)established with "
                    "interface %1!ws! (node: %2!ws!, network: %3!ws!)\n",
                    interfaceId,
                    nodeName,
                    networkName
                    );

                CsLogEvent2(
                    LOG_NOISE,
                    NM_EVENT_NETINTERFACE_UP,
                    nodeName,
                    networkName
                    );
            }

            if (NmpLeaderNodeId == NmLocalNodeId) {
                //
                // This node is the leader. Call the handler routine
                // directly.
                //
                NmpReportNetworkConnectivity(network);
            }
            else {
                //
                // We need to report to the leader.
                // Defer to a worker thread.
                //
                NmpScheduleNetworkConnectivityReport(network);
            }

            break;

        case ClusterNetInterfaceUnreachable:
            //
            // A remote interface is unreachable.
            //
            if (node != NmLocalNode) {
                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[NM] Communication was lost with interface "
                    "%1!ws! (node: %2!ws!, network: %3!ws!)\n",
                    interfaceId,
                    nodeName,
                    networkName
                    );

                CsLogEvent2(
                    LOG_UNUSUAL,
                    NM_EVENT_NETINTERFACE_UNREACHABLE,
                    nodeName,
                    networkName
                    );
            }

            if (NmpLeaderNodeId == NmLocalNodeId) {
                //
                // This node is the leader. Call the handler routine
                // directly.
                //
                NmpReportNetworkConnectivity(network);
            }
            else {
                //
                // Schedule a delayed connectivity report in order to
                // aggregate multiple failures.
                //
                NmpStartNetworkConnectivityReportTimer(network);
            }

            break;

        case ClusterNetInterfaceFailed:
            //
            // A local interface has failed. Schedule an immediate
            // connectivity report.
            //
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] Local interface %1!ws! on network %2!ws! "
                "has failed\n",
                interfaceId,
                networkName
                );
            CsLogEvent1(
                LOG_UNUSUAL,
                NM_EVENT_NETINTERFACE_FAILED,
                networkName
                );

            if (NmpLeaderNodeId == NmLocalNodeId) {
                //
                // This node is the leader. Call the handler routine
                // directly.
                //
                NmpReportNetworkConnectivity(network);
            }
            else {
                //
                // We need to report to the leader. Defer to a worker thread.
                //
                NmpScheduleNetworkConnectivityReport(network);
            }

            break;

        default:
            break;
        }
    }
    else {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Ignoring stale report from clusnet for interface %1!ws! (node: %2!ws!, network: %3!ws!).\n",
            interfaceId,
            nodeName,
            networkName
            );
    }

    return;

} // NmpProcessLocalInterfaceStateEvent


DWORD
NmpReportInterfaceConnectivity(
    IN RPC_BINDING_HANDLE       RpcBinding,
    IN LPWSTR                   InterfaceId,
    IN PNM_CONNECTIVITY_VECTOR  ConnectivityVector,
    IN LPWSTR                   NetworkId
    )
/*++

Routine Description:

    Sends a network connectivity report to the leader node via RPC.

Arguments:

    RpcBinding - The RPC binding handle to use in the call to the leader.

    InterfaceId - A pointer to a string that identifies the interface
                  to which the report applies.

    ConnectivityVector - A pointer to the connectivity vector to be included
                         in the report.

    NetworkId - A pointer to a string that identifies the network with
                which the interface is associated.

Return Value:

    A Win32 status code.

Notes:

   Called with NM lock held.
   Releases & reacquires NM lock during processing.

--*/
{
    RPC_ASYNC_STATE                  rpcAsyncState;
    DWORD                            status;
    PNM_CONNECTIVITY_REPORT_CONTEXT  context;
    PNM_LEADER_CHANGE_WAIT_ENTRY     waitEntry;
    BOOL                             result;



    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Reporting connectivity to leader for network %1!ws!.\n",
        NetworkId
        );

    //
    // Allocate a context block for this report
    //
    context = LocalAlloc(
                  (LMEM_FIXED | LMEM_ZEROINIT),
                  sizeof(NM_CONNECTIVITY_REPORT_CONTEXT)
                  );

    if (context == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Failed to allocate connectivity report context, "
            "status %1!u!.\n",
            status
            );
        return(status);
    }

    context->ConnectivityReportEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (context->ConnectivityReportEvent == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Unable to create event for connectivity report, "
            "status %1!u!\n",
            status
            );
        goto error_exit;
    }

    waitEntry = &(context->LeaderChangeWaitEntry);

    waitEntry->LeaderChangeEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (waitEntry->LeaderChangeEvent == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Unable to create event for connectivity report, "
            "status %1!u!\n",
            status
            );
        goto error_exit;
    }

    //
    // Initialize the status block for the async RPC call
    //
    status = RpcAsyncInitializeHandle(
                 &rpcAsyncState,
                 sizeof(rpcAsyncState)
                 );

    if (status != RPC_S_OK) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Failed to initialize RPC status block for connectivity "
            "report, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    rpcAsyncState.NotificationType = RpcNotificationTypeEvent;
    rpcAsyncState.u.hEvent = context->ConnectivityReportEvent;
    result = ResetEvent(context->ConnectivityReportEvent);
    CL_ASSERT(result != 0);

    //
    // Hook changes in the node leadership.
    //
    result = ResetEvent(waitEntry->LeaderChangeEvent);
    CL_ASSERT(result != 0);
    InsertTailList(&NmpLeaderChangeWaitList, &(waitEntry->Linkage));

    NmpReleaseLock();

    //
    // Send the report to the leader
    //
    status = NmRpcReportInterfaceConnectivity(
                 &rpcAsyncState,
                 RpcBinding,
                 InterfaceId,
                 ConnectivityVector
                 );

    if (status == RPC_S_OK) {
        //
        // The call is pending.
        //
        HANDLE  waitHandles[2];
        DWORD   rpcStatus;


        //
        // Wait for the call to complete or a leadership change.
        //
        waitHandles[0] = context->ConnectivityReportEvent;
        waitHandles[1] = waitEntry->LeaderChangeEvent;

        status = WaitForMultipleObjects(
                     2,
                     waitHandles,
                     FALSE,
                     INFINITE
                     );

        if (status != WAIT_OBJECT_0) {
            //
            // The leadership changed. Cancel the RPC call.
            //
            // We would also go through this path if the wait failed for
            // some reason, but that really should not happen. Either way,
            // we should cancel the call.
            //
            CL_ASSERT(status == (WAIT_OBJECT_0 + 1));

            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] Leadership changed. Cancelling connectivity report for "
                "network %1!ws!.\n",
                NetworkId
                );

            rpcStatus = RpcAsyncCancelCall(&rpcAsyncState, TRUE);
            CL_ASSERT(rpcStatus == RPC_S_OK);

            //
            // Wait for the call to complete.
            //
            status = WaitForSingleObject(
                         context->ConnectivityReportEvent,
                         INFINITE
                         );
            CL_ASSERT(status == WAIT_OBJECT_0);
        }

        //
        // At this point, the call should be complete. Get the completion
        // status. Any RPC error will be returned in 'rpcStatus'. If there
        // was no RPC error, then any application error will be returned
        // in 'status'.
        //
        rpcStatus = RpcAsyncCompleteCall(&rpcAsyncState, &status);

        if (rpcStatus != RPC_S_OK) {
            //
            // Either the call was cancelled or an RPC error
            // occurred. The application status is irrelevant.
            //
            status = rpcStatus;
        }

        if (status == RPC_S_OK) {
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] Connectivity report completed successfully "
                "for network %1!ws!.\n",
                NetworkId
                );
        }
        else if (status == RPC_S_CALL_CANCELLED) {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] Connectivity report was cancelled for "
                "network %1!ws!.\n",
                NetworkId
                );
        }
        else {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] Connectivity report failed for network "
                "%1!ws!, status %2!u!.\n",
                NetworkId,
                status
                );

            CL_ASSERT(status != RPC_S_ASYNC_CALL_PENDING);
        }
    }
    else {
        //
        // A synchronous error was returned.
        //
        CL_ASSERT(status != RPC_S_ASYNC_CALL_PENDING);

        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Connectivity report failed for network %1!ws!, "
            "status %2!u!.\n",
            NetworkId,
            status
            );
    }

    NmpAcquireLock();

error_exit:

    //
    // Free the context block
    //
    if (context != NULL) {
        if (context->ConnectivityReportEvent != NULL) {
            CloseHandle(context->ConnectivityReportEvent);
        }

        if (waitEntry->LeaderChangeEvent != NULL) {
            //
            // Remove our leadership change notification hook.
            //
            if (waitEntry->Linkage.Flink != NULL) {
                RemoveEntryList(&(waitEntry->Linkage));
            }

            CloseHandle(waitEntry->LeaderChangeEvent);
        }

        LocalFree(context);
    }

    return(status);

} // NmpReportInterfaceConnectivity


VOID
NmpProcessInterfaceConnectivityReport(
    IN PNM_INTERFACE               SourceInterface,
    IN PNM_CONNECTIVITY_VECTOR     ConnectivityVector
    )
/*+

Notes:

    Called with NmpLock held.

--*/
{
    PNM_NETWORK              network = SourceInterface->Network;
    PNM_CONNECTIVITY_MATRIX  matrix = network->ConnectivityMatrix;
    DWORD                    entryCount;
    PNM_NODE                 node = SourceInterface->Node;
    PNM_CONNECTIVITY_VECTOR  vector = network->ConnectivityVector;
    DWORD                    ifNetIndex = SourceInterface->NetIndex;


    //
    // Filter out stale reports from dead nodes and for
    // disabled/deleted networks.
    //
    if ( ((node == NmLocalNode) || (node->State != ClusterNodeDown)) &&
         NmpIsNetworkEnabledForUse(network) &&
         !NM_DELETE_PENDING(network)
       )
    {
        //
        // Update the network's connectivity matrix
        //
        if (network->ConnectivityVector->EntryCount <= vector->EntryCount) {
            entryCount = network->ConnectivityVector->EntryCount;
        }
        else {
            //
            // An interface must have been added while this
            // call was in flight. Ignore the missing data.
            //
            entryCount = ConnectivityVector->EntryCount;
        }

        CopyMemory(
            NM_GET_CONNECTIVITY_MATRIX_ROW(
                matrix,
                ifNetIndex,
                entryCount
                ),
            &(ConnectivityVector->Data[0]),
            entryCount * sizeof(NM_STATE_ENTRY)
            );

        //
        // If this is the leader node, and no NT4 nodes are in the cluster,
        // schedule a state recalculation.
        //
        if (NmpLeaderNodeId == NmLocalNodeId) {
            NmpStartNetworkStateRecalcTimer(
                network,
                NM_NET_STATE_RECALC_TIMEOUT
                );
        }
    }
    else {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Ignoring stale connectivity report from interface %1!ws!.\n",
            OmObjectId(SourceInterface)
            );
    }

    return;

} // NmpProcessInterfaceConnectivityReport


VOID
NmpFreeInterfaceStateEnum(
    PNM_INTERFACE_STATE_ENUM   InterfaceStateEnum
    )
{
    PNM_INTERFACE_STATE_INFO  interfaceStateInfo;
    DWORD                     i;


    for (i=0; i<InterfaceStateEnum->InterfaceCount; i++) {
        interfaceStateInfo = &(InterfaceStateEnum->InterfaceList[i]);

        if (interfaceStateInfo->Id != NULL) {
            MIDL_user_free(interfaceStateInfo->Id);
        }
    }

    MIDL_user_free(InterfaceStateEnum);

    return;

} // NmpFreeInterfaceStateEnum


BOOL
NmpIsAddressInAddressEnum(
    ULONGLONG           Address,
    PNM_ADDRESS_ENUM    AddressEnum
    )
{
    DWORD    i;


    for (i=0; i<AddressEnum->AddressCount; i++) {
        if (AddressEnum->AddressList[i] == Address) {
            return(TRUE);
        }
    }

    return(FALSE);

}  // NmpIsAddressInAddressEnum


DWORD
NmpBuildInterfaceOnlineAddressEnum(
    PNM_INTERFACE       Interface,
    PNM_ADDRESS_ENUM *  OnlineAddressEnum
    )
/*++

    Called with NmpLock held and Interface referenced.

--*/
{
    DWORD                       status = ERROR_SUCCESS;
    PNM_ADDRESS_ENUM            onlineAddressEnum = NULL;
    DWORD                       onlineAddressEnumSize;
    PCLRTL_NET_ADAPTER_ENUM     adapterEnum = NULL;
    PCLRTL_NET_ADAPTER_INFO     adapterInfo = NULL;
    PCLRTL_NET_INTERFACE_INFO   adapterIfInfo = NULL;
    PNM_ADDRESS_ENUM            onlineEnum = NULL;
    DWORD                       onlineEnumSize;


    *OnlineAddressEnum = NULL;

    //
    // Get the local network configuration.
    //
    adapterEnum = ClRtlEnumNetAdapters();

    if (adapterEnum == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Failed to obtain local network configuration, status %1!u!.\n",
            status
            );
        return(status);
    }

    //
    // Find the adapter for this interface
    //
    adapterInfo = ClRtlFindNetAdapterById(
                      adapterEnum,
                      Interface->AdapterId
                      );

    if (adapterInfo == NULL) {
        status = ERROR_NOT_FOUND;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Failed to find adapter for interface %1!ws!, status %2!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Allocate an address enum structure.
    //
    if (adapterInfo->InterfaceCount == 0) {
        onlineEnumSize = sizeof(NM_ADDRESS_ENUM);
    }
    else {
        onlineEnumSize = sizeof(NM_ADDRESS_ENUM) +
                         ( (adapterInfo->InterfaceCount - 1) *
                           sizeof(ULONGLONG)
                         );
    }

    onlineEnum = midl_user_allocate(onlineEnumSize);

    if (onlineEnum == NULL) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Failed to allocate memory for ping list.\n"
            );
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    onlineEnum->AddressSize = sizeof(ULONG);
    onlineEnum->AddressCount = 0;

    for (adapterIfInfo = adapterInfo->InterfaceList;
         adapterIfInfo != NULL;
         adapterIfInfo = adapterIfInfo->Next
        )
    {
        //
        // Skip invalid addresses (0.0.0.0)
        //
        if (adapterIfInfo->InterfaceAddress != 0) {
            onlineEnum->AddressList[onlineEnum->AddressCount++] =
                (ULONGLONG) adapterIfInfo->InterfaceAddress;

                ClRtlLogPrint(LOG_NOISE, 
                    "[NM] Found address %1!ws! for interface %2!ws!.\n",
                    adapterIfInfo->InterfaceAddressString,
                    OmObjectId(Interface)
                    );
        }
    }

    *OnlineAddressEnum = onlineEnum;
    status = ERROR_SUCCESS;

error_exit:

    if (adapterEnum != NULL) {
        ClRtlFreeNetAdapterEnum(adapterEnum);
    }

    return(status);

} // NmpBuildInterfaceOnlineAddressEnum


DWORD
NmpBuildInterfacePingAddressEnum(
    IN  PNM_INTERFACE       Interface,
    IN  PNM_ADDRESS_ENUM    OnlineAddressEnum,
    OUT PNM_ADDRESS_ENUM *  PingAddressEnum
    )
/*++

    Called with NmpLock held and Interface referenced.

--*/
{
    DWORD                       status = ERROR_SUCCESS;
    PNM_NETWORK                 network = Interface->Network;
    PMIB_IPFORWARDTABLE         ipForwardTable = NULL;
    PMIB_IPFORWARDROW           ipRow, ipRowLimit;
    PMIB_TCPTABLE               tcpTable = NULL;
    PMIB_TCPROW                 tcpRow, tcpRowLimit;
    ULONG                       netAddress, netMask;
    DWORD                       allocSize, tableSize;
    BOOL                        duplicate;
    DWORD                       i;
    PNM_ADDRESS_ENUM            pingEnum = NULL;
    DWORD                       pingEnumSize;


    *PingAddressEnum = NULL;

    //
    // Convert the network address & mask strings to binary
    //
    status = ClRtlTcpipStringToAddress(network->Address, &netAddress);

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Failed to convert network address string %1!ws! to binary, status %2!u!.\n",
            network->Address,
            status
            );
        return(status);
    }

    status = ClRtlTcpipStringToAddress(network->AddressMask, &netMask);

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Failed to convert network address mask string %1!ws! to binary, status %2!u!.\n",
            network->AddressMask,
            status
            );
        return(status);
    }

    //
    // We don't need the lock for the rest of the function.
    //
    NmpReleaseLock();

    //
    // Allocate a ping enum structure
    //
    pingEnumSize = sizeof(NM_ADDRESS_ENUM) +
                   ((NM_MAX_IF_PING_ENUM_SIZE - 1) * sizeof(ULONGLONG));

    pingEnum = midl_user_allocate(pingEnumSize);

    if (pingEnum == NULL) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Failed to allocate memory for ping list.\n"
            );
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    pingEnum->AddressSize = sizeof(ULONG);
    pingEnum->AddressCount = 0;

    //
    // Fetch the IP Route Table
    //
    allocSize = sizeof(MIB_IPFORWARDTABLE) + (sizeof(MIB_IPFORWARDROW) * 20);

    do {
        if (ipForwardTable != NULL) {
            LocalFree(ipForwardTable);
        }

        ipForwardTable = LocalAlloc(LMEM_FIXED, allocSize);

        if (ipForwardTable == NULL) {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] Failed to allocate memory for IP route table.\n"
                );
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto error_exit;
        }

        tableSize = allocSize;

        status = GetIpForwardTable(
                     ipForwardTable,
                     &tableSize,
                     FALSE
                     );

        allocSize = tableSize;

    } while (status == ERROR_INSUFFICIENT_BUFFER);

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[ClNet] Failed to obtain IP route table, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Add the IP route entries to the ping list.
    //
    for ( ipRow = &(ipForwardTable->table[0]),
            ipRowLimit = ipRow + ipForwardTable->dwNumEntries;
          ipRow < ipRowLimit;
          ipRow++
        )
    {
        if ((ipRow->dwForwardNextHop & netMask) == netAddress) {
            //
            // Make sure this address isn't in the online address enum.
            //
            duplicate = NmpIsAddressInAddressEnum(
                            (ULONGLONG) ipRow->dwForwardNextHop,
                            OnlineAddressEnum
                            );

            if (!duplicate) {
                //
                // Make sure this address isn't already in the ping enum.
                //
                duplicate = NmpIsAddressInAddressEnum(
                                (ULONGLONG) ipRow->dwForwardNextHop,
                                pingEnum
                                );

                if (!duplicate) {
                    pingEnum->AddressList[pingEnum->AddressCount++] =
                        (ULONGLONG) ipRow->dwForwardNextHop;

                    if (pingEnum->AddressCount == NM_MAX_IF_PING_ENUM_SIZE) {
                        LocalFree(ipForwardTable);
                        *PingAddressEnum = pingEnum;
                        NmpAcquireLock();

                        return(ERROR_SUCCESS);
                    }
                }
            }
        }
    }

    LocalFree(ipForwardTable); ipForwardTable = NULL;

    //
    // Fetch the TCP Connection Table
    //
    allocSize = sizeof(MIB_TCPTABLE) + (sizeof(MIB_TCPROW) * 20);

    do {
        if (tcpTable != NULL) {
            LocalFree(tcpTable);
        }

        tcpTable = LocalAlloc(LMEM_FIXED, allocSize);

        if (tcpTable == NULL) {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] Failed to allocate memory for TCP conn table.\n"
                );
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto error_exit;
        }

        tableSize = allocSize;

        status = GetTcpTable(
                     tcpTable,
                     &tableSize,
                     FALSE
                     );

        allocSize = tableSize;

    } while (status == ERROR_INSUFFICIENT_BUFFER);

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[ClNet] Failed to obtain TCP conn table, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Add the TCP remote addresses to the ping list.
    //
    for ( tcpRow = &(tcpTable->table[0]),
            tcpRowLimit = tcpRow + tcpTable->dwNumEntries;
          tcpRow < tcpRowLimit;
          tcpRow++
        )
    {
        if ((tcpRow->dwRemoteAddr & netMask) == netAddress) {
            //
            // Make sure this address isn't in the online address enum.
            //
            duplicate = NmpIsAddressInAddressEnum(
                            (ULONGLONG) tcpRow->dwRemoteAddr,
                            OnlineAddressEnum
                            );

            if (!duplicate) {
                //
                // Make sure this address isn't already in the ping enum.
                //
                duplicate = NmpIsAddressInAddressEnum(
                                (ULONGLONG) tcpRow->dwRemoteAddr,
                                pingEnum
                                );

                if (!duplicate) {
                    pingEnum->AddressList[pingEnum->AddressCount++] =
                        (ULONGLONG) tcpRow->dwRemoteAddr;

                    if (pingEnum->AddressCount == NM_MAX_IF_PING_ENUM_SIZE) {
                        break;
                    }
                }
            }
        }
    }

    *PingAddressEnum = pingEnum; pingEnum = NULL;

error_exit:

    if (pingEnum != NULL) {
        midl_user_free(pingEnum);
    }

    if (ipForwardTable != NULL) {
        LocalFree(ipForwardTable);
    }

    if (tcpTable != NULL) {
        LocalFree(tcpTable);
    }

    NmpAcquireLock();

    return(status);

} // NmpBuildInterfacePingAddressEnum


NmpGetInterfaceOnlineAddressEnum(
    PNM_INTERFACE       Interface,
    PNM_ADDRESS_ENUM *  OnlineAddressEnum
    )
/*++

Notes:

    Called with NmpLock held and Interface referenced. Releases and
    reacquires NmpLock.

--*/
{
    DWORD               status;
    LPCWSTR             interfaceId = OmObjectId(Interface);
    PNM_NODE            node = Interface->Node;
    RPC_BINDING_HANDLE  rpcBinding = node->IsolateRpcBinding;


    if (node == NmLocalNode) {
        //
        // Call the internal routine directly
        //
        status = NmpBuildInterfaceOnlineAddressEnum(
                     Interface,
                     OnlineAddressEnum
                     );
    }
    else {
        OmReferenceObject(node);

        NmpReleaseLock();

        CL_ASSERT(rpcBinding != NULL);

        NmStartRpc(node->NodeId);
        status = NmRpcGetInterfaceOnlineAddressEnum(
                     rpcBinding,
                     (LPWSTR) interfaceId,
                     OnlineAddressEnum
                     );
        NmEndRpc(node->NodeId);
        if(status != RPC_S_OK) {
            NmDumpRpcExtErrorInfo(status);
        }

        NmpAcquireLock();

        OmDereferenceObject(node);
    }

    if (status == ERROR_SUCCESS) {
        if ((*OnlineAddressEnum)->AddressSize != sizeof(ULONG)) {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] Online enum address size is invalid for interface %1!ws!\n",
                interfaceId
                );
            status = ERROR_INCORRECT_ADDRESS;
            midl_user_free(*OnlineAddressEnum);
            *OnlineAddressEnum = NULL;
        }
        else {
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] Online enum for interface %1!ws! contains %2!u! addresses\n",
                interfaceId,
                (*OnlineAddressEnum)->AddressCount
                );
        }
    }
    else {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Failed to get online address enum for interface %1!ws!, status %2!u!\n",
            interfaceId,
            status
            );
    }

    return(status);

}  // NmpGetInterfaceOnlineAddressEnum


NmpGetInterfacePingAddressEnum(
    PNM_INTERFACE       Interface,
    PNM_ADDRESS_ENUM    OnlineAddressEnum,
    PNM_ADDRESS_ENUM *  PingAddressEnum
    )
/*++

Notes:

    Called with NmpLock held and Interface referenced. Releases and
    reacquires NmpLock.

--*/
{
    DWORD               status;
    LPCWSTR             interfaceId = OmObjectId(Interface);
    PNM_NODE            node = Interface->Node;
    RPC_BINDING_HANDLE  rpcBinding = node->IsolateRpcBinding;


    if (node == NmLocalNode) {
        //
        // Call the internal routine directly
        //
        status = NmpBuildInterfacePingAddressEnum(
                     Interface,
                     OnlineAddressEnum,
                     PingAddressEnum
                     );
    }
    else {
        OmReferenceObject(node);

        NmpReleaseLock();

        CL_ASSERT(rpcBinding != NULL);

        NmStartRpc(node->NodeId);
        status = NmRpcGetInterfacePingAddressEnum(
                     rpcBinding,
                     (LPWSTR) interfaceId,
                     OnlineAddressEnum,
                     PingAddressEnum
                     );
        NmEndRpc(node->NodeId);
        if(status != RPC_S_OK) {
            NmDumpRpcExtErrorInfo(status);
        }

        NmpAcquireLock();

        OmDereferenceObject(node);
    }

    if (status == ERROR_SUCCESS) {
        if ((*PingAddressEnum)->AddressSize != sizeof(ULONG)) {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] Ping enum address size is invalid for interface %1!ws!\n",
                interfaceId
                );
            status = ERROR_INCORRECT_ADDRESS;
            midl_user_free(*PingAddressEnum);
            *PingAddressEnum = NULL;
        }
        else {
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] Ping enum for interface %1!ws! contains %2!u! addresses\n",
                interfaceId,
                (*PingAddressEnum)->AddressCount
                );
        }
    }
    else {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Failed to get ping address enum for interface %1!ws!, status %2!u!\n",
            interfaceId,
            status
            );
    }

    return(status);

}  // NmpGetInterfacePingAddressEnum


DWORD
NmpDoInterfacePing(
    IN  PNM_INTERFACE     Interface,
    IN  PNM_ADDRESS_ENUM  PingAddressEnum,
    OUT BOOLEAN *         PingSucceeded
    )
/*++

Notes:

    Called with Interface referenced.

--*/
{
    DWORD     status = ERROR_SUCCESS;
    LPCWSTR   interfaceId = OmObjectId(Interface);
    LPWSTR    addressString;
    DWORD     maxAddressStringLength;
    DWORD     i;


    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Pinging targets for interface %1!ws!.\n",
        interfaceId
        );

    *PingSucceeded = FALSE;

    if (PingAddressEnum->AddressSize != sizeof(ULONG)) {
        return(ERROR_INCORRECT_ADDRESS);
    }

    ClRtlQueryTcpipInformation(
        &maxAddressStringLength,
        NULL,
        NULL
        );

    addressString = LocalAlloc(
                        LMEM_FIXED,
                        (maxAddressStringLength + 1) * sizeof(WCHAR)
                        );

    if (addressString == NULL) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to allocate memory for address string.\n"
            );
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    for (i=0; i<PingAddressEnum->AddressCount; i++) {
        status = ClRtlTcpipAddressToString(
                     (ULONG) PingAddressEnum->AddressList[i],
                     &addressString
                     );

        if (status == ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] Pinging host %1!ws!\n",
                addressString
                );
        }
        else {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] Failed to convert address %1!x! to string %2!u!.\n",
                (ULONG) PingAddressEnum->AddressList[i],
                status
                );
        }

        if ( ClRtlIsDuplicateTcpipAddress(
                 (ULONG) PingAddressEnum->AddressList[i])
           )
        {
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] Ping of host %1!ws! succeeded.\n",
                addressString
                );
            *PingSucceeded = TRUE;
            break;
        }
        else {
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] Ping of host %1!ws! failed.\n",
                addressString
                );
        }
    }

    LocalFree(addressString);

    return(status);

} // NmpDoInterfacePing


DWORD
NmpTestInterfaceConnectivity(
    PNM_INTERFACE  Interface1,
    PBOOLEAN       Interface1HasConnectivity,
    PNM_INTERFACE  Interface2,
    PBOOLEAN       Interface2HasConnectivity
    )
/*++

Notes:

    Called with NmpLock held. This routine releases and reacquires the
    NmpLock. It must be called with references on the target interfaces.

--*/
{
    DWORD               status, status1, status2;
    PNM_NETWORK         network = Interface1->Network;
    PNM_INTERFACE       localInterface = network->LocalInterface;
    LPCWSTR             networkId = OmObjectId(network);
    LPCWSTR             interface1Id = OmObjectId(Interface1);
    LPCWSTR             interface2Id = OmObjectId(Interface2);
    ULONG               interface1Address, interface2Address;
    PNM_ADDRESS_ENUM    pingEnum1 = NULL, pingEnum2 = NULL;
    PNM_ADDRESS_ENUM    onlineEnum1 = NULL, onlineEnum2 = NULL;
    PNM_ADDRESS_ENUM    unionPingEnum = NULL, unionOnlineEnum = NULL;
    DWORD               addressCount;
    RPC_ASYNC_STATE     async1, async2;
    HANDLE              event1 = NULL, event2 = NULL;
    RPC_BINDING_HANDLE  rpcBinding1 = NULL, rpcBinding2 = NULL;
    DWORD               i1, i2;
    BOOL                duplicate;


    //
    // Reference the nodes associated with the target interfaces so they
    // can't go away during this process.
    //
    OmReferenceObject(Interface1->Node);
    OmReferenceObject(Interface2->Node);

    if (localInterface != NULL) {
        OmReferenceObject(localInterface);
    }

    *Interface1HasConnectivity = *Interface2HasConnectivity = FALSE;

    //
    // Convert the interface address strings to binary form.
    //
    status = ClRtlTcpipStringToAddress(
                 Interface1->Address,
                 &interface1Address
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Failed to convert interface address string %1!ws! to binary, status %2!u!.\n",
            Interface1->Address,
            status
            );
        goto error_exit;
    }

    status = ClRtlTcpipStringToAddress(
                 Interface2->Address,
                 &interface2Address
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Failed to convert interface address string %1!ws! to binary, status %2!u!.\n",
            Interface2->Address,
            status
            );
        goto error_exit;
    }

    //
    // Fetch the online address list from each of the interfaces.
    // The NmpLock will be released when querying a remote interface.
    //
    status = NmpGetInterfaceOnlineAddressEnum(
                 Interface1,
                 &onlineEnum1
                 );

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    status = NmpGetInterfaceOnlineAddressEnum(
                 Interface2,
                 &onlineEnum2
                 );

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    //
    // Bail out if either of the interfaces was deleted while the NmpLock
    // was released.
    //
    if ((NM_DELETE_PENDING(Interface1) || NM_DELETE_PENDING(Interface2))) {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Aborting interface connectivity test on network %1!ws! "
            "because an interface was deleted.\n",
            networkId
            );
        status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
        goto error_exit;
    }

    //
    // Take the union of the two online lists
    //
    addressCount = onlineEnum1->AddressCount + onlineEnum2->AddressCount;

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Total online address count for network %1!ws! is %2!u!\n",
        networkId,
        addressCount
        );

    if (addressCount == 0) {
        unionOnlineEnum = LocalAlloc(LMEM_FIXED, sizeof(NM_ADDRESS_ENUM));
    }
    else {
        unionOnlineEnum = LocalAlloc(
                            LMEM_FIXED,
                            sizeof(NM_ADDRESS_ENUM) +
                                ((addressCount - 1) * sizeof(ULONGLONG))
                            );
    }

    if (unionOnlineEnum == NULL) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Failed to allocate memory for union ping list.\n"
            );
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    unionOnlineEnum->AddressSize = sizeof(ULONG);
    unionOnlineEnum->AddressCount = 0;

    if (onlineEnum1->AddressCount != 0) {
        CopyMemory(
            &(unionOnlineEnum->AddressList[0]),
            &(onlineEnum1->AddressList[0]),
            onlineEnum1->AddressCount * sizeof(ULONGLONG)
            );
        unionOnlineEnum->AddressCount = onlineEnum1->AddressCount;
    }

    if (onlineEnum2->AddressCount != 0) {
        CopyMemory(
            &(unionOnlineEnum->AddressList[unionOnlineEnum->AddressCount]),
            &(onlineEnum2->AddressList[0]),
            onlineEnum2->AddressCount * sizeof(ULONGLONG)
            );
        unionOnlineEnum->AddressCount += onlineEnum2->AddressCount;
    }

    midl_user_free(onlineEnum1); onlineEnum1 = NULL;
    midl_user_free(onlineEnum2); onlineEnum2 = NULL;

    //
    // Fetch the ping target list from each of the interfaces.
    // The NmpLock will be released when querying a remote interface.
    //
    status = NmpGetInterfacePingAddressEnum(
                 Interface1,
                 unionOnlineEnum,
                 &pingEnum1
                 );

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    status = NmpGetInterfacePingAddressEnum(
                 Interface2,
                 unionOnlineEnum,
                 &pingEnum2
                 );

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    //
    // Bail out if either of the interfaces was deleted while the NmpLock
    // was released.
    //
    if ((NM_DELETE_PENDING(Interface1) || NM_DELETE_PENDING(Interface2))) {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Aborting interface connectivity test on network %1!ws! "
            "because an interface was deleted.\n",
            networkId
            );
        status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
        goto error_exit;
    }

    NmpReleaseLock();

    //
    // Take the union of the two ping lists
    //
    addressCount = pingEnum1->AddressCount + pingEnum2->AddressCount;

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Total ping address count for network %1!ws! is %2!u!\n",
        networkId,
        addressCount
        );

    if (addressCount == 0) {
        status = ERROR_SUCCESS;
        goto error_lock_and_exit;
    }

    unionPingEnum = LocalAlloc(
                        LMEM_FIXED,
                        sizeof(NM_ADDRESS_ENUM) +
                            ( (NM_MAX_UNION_PING_ENUM_SIZE - 1) *
                              sizeof(ULONGLONG)
                            )
                        );


    if (unionPingEnum == NULL) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Failed to allocate memory for union ping list.\n"
            );
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_lock_and_exit;
    }

    unionPingEnum->AddressSize = sizeof(ULONG);
    unionPingEnum->AddressCount = 0;

    i1 = 0; i2 = 0;

    while (TRUE) {
        while (i1 < pingEnum1->AddressCount) {
            duplicate = NmpIsAddressInAddressEnum(
                            pingEnum1->AddressList[i1],
                            unionPingEnum
                            );

            if (!duplicate) {
                unionPingEnum->AddressList[unionPingEnum->AddressCount++] =
                    pingEnum1->AddressList[i1++];
                break;
            }
            else {
                i1++;
            }
        }

        if (unionPingEnum->AddressCount == NM_MAX_UNION_PING_ENUM_SIZE) {
            break;
        }

        while (i2 < pingEnum2->AddressCount) {
            duplicate = NmpIsAddressInAddressEnum(
                            pingEnum2->AddressList[i2],
                            unionPingEnum
                            );

            if (!duplicate) {
                unionPingEnum->AddressList[unionPingEnum->AddressCount++] =
                    pingEnum2->AddressList[i2++];
                break;
            }
            else {
                i2++;
            }
        }

        if ( (unionPingEnum->AddressCount == NM_MAX_UNION_PING_ENUM_SIZE) ||
             ( (i1 == pingEnum1->AddressCount) &&
               (i2 == pingEnum2->AddressCount)
             )
           )
        {
            break;
        }
    }

    midl_user_free(pingEnum1); pingEnum1 = NULL;
    midl_user_free(pingEnum2); pingEnum2 = NULL;

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Union ping list for network %1!ws! contains %2!u! addresses\n",
        networkId,
        unionPingEnum->AddressCount
        );

    //
    // Ask each interface to ping the list of targets using async RPC calls
    //

    //
    // Allocate resources for the async RPC calls
    //
    if (Interface1 != localInterface) {
        event1 = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (event1 == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] Failed to allocate event for async rpc, status %1!u!.\n",
                status
                );
            goto error_lock_and_exit;
        }

        status = RpcAsyncInitializeHandle(&async1, sizeof(async1));

        if (status != RPC_S_OK) {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] Failed to initialize RPC async state, status %1!u!.\n",
                status
                );
            goto error_lock_and_exit;
        }

        async1.NotificationType = RpcNotificationTypeEvent;
        async1.u.hEvent = event1;

        rpcBinding1 = Interface1->Node->IsolateRpcBinding;
    }

    if (Interface2 != localInterface) {
        event2 = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (event2 == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] Failed to allocate event for async rpc, status %1!u!.\n",
                status
                );
            goto error_lock_and_exit;
        }

        status = RpcAsyncInitializeHandle(&async2, sizeof(async2));

        if (status != RPC_S_OK) {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] Failed to initialize RPC async state, status %1!u!.\n",
                status
                );
            goto error_lock_and_exit;
        }

        async2.NotificationType = RpcNotificationTypeEvent;
        async2.u.hEvent = event2;

        rpcBinding2 = Interface2->Node->IsolateRpcBinding;
    }

    if (rpcBinding1 != NULL) {
        //
        // Issue the RPC for interface1 first. Then deal with interface2
        //

        //
        // We need the try-except until a bug is fixed in MIDL
        //
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Issuing RpcDoInterfacePing for interface %1!ws!\n",
            interface1Id
            );

        status = ERROR_SUCCESS;

        try {
            NmRpcDoInterfacePing(
                &async1,
                rpcBinding1,
                (LPWSTR) interface1Id,
                unionPingEnum,
                Interface1HasConnectivity,
                &status1
                );
        } except(I_RpcExceptionFilter(RpcExceptionCode())) {
            status = GetExceptionCode();
        }

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] DoPing RPC failed for interface %1!ws!, status %2!u!.\n",
                interface1Id,
                status
                );
            goto error_lock_and_exit;
        }

        if (rpcBinding2 != NULL) {
            //
            // Issue the RPC for interface2.
            //
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] Issuing RpcDoInterfacePing for interface %1!ws!\n",
                interface2Id
                );

            status = ERROR_SUCCESS;

            try {
                NmRpcDoInterfacePing(
                    &async2,
                    rpcBinding2,
                    (LPWSTR) interface2Id,
                    unionPingEnum,
                    Interface2HasConnectivity,
                    &status2
                    );
            } except(I_RpcExceptionFilter(RpcExceptionCode())) {
                status = GetExceptionCode();
            }

            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[NM] DoPing RPC failed for interface %1!ws!, status %2!u!.\n",
                    interface1Id,
                    status
                    );
                goto error_lock_and_exit;
            }

            //
            // Wait for the RPC for interface2 to complete
            //
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] Waiting for RpcDoInterfacePing for interface %1!ws! to complete\n",
                interface2Id
                );

            status = WaitForSingleObjectEx(event2, INFINITE, FALSE);
            CL_ASSERT(status == WAIT_OBJECT_0);

            status = RpcAsyncCompleteCall(
                         &async2,
                         &status2
                         );

            CL_ASSERT(status == RPC_S_OK);

            ClRtlLogPrint(LOG_NOISE, 
                "[NM] Wait for RpcDoInterfacePing for interface %1!ws! completed.\n",
                interface2Id
                );
        }
        else {
            //
            // Call the local routine for interface2.
            //
            status2 = NmpDoInterfacePing(
                          Interface2,
                          unionPingEnum,
                          Interface2HasConnectivity
                          );
        }

        //
        // Wait for the RPC for interface1 to complete
        //
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Waiting for RpcDoInterfacePing for interface %1!ws! to complete\n",
            interface1Id
            );

        status = WaitForSingleObjectEx(event1, INFINITE, FALSE);
        CL_ASSERT(status == WAIT_OBJECT_0);

        status = RpcAsyncCompleteCall(
                     &async1,
                     &status1
                     );

        CL_ASSERT(status == RPC_S_OK);

        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Wait for RpcDoInterfacePing for interface %1!ws! completed.\n",
            interface1Id
            );
    }
    else {
        //
        // Send the RPC to interface2 first. Then call the local
        // routine for interface1
        //
        CL_ASSERT(rpcBinding2 != NULL);

        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Issuing RpcDoInterfacePing for interface %1!ws!\n",
            interface2Id
            );

        status = ERROR_SUCCESS;

        try {
            NmRpcDoInterfacePing(
                &async2,
                rpcBinding2,
                (LPWSTR) interface2Id,
                unionPingEnum,
                Interface2HasConnectivity,
                &status2
                );
        } except(I_RpcExceptionFilter(RpcExceptionCode())) {
            status = GetExceptionCode();
        }

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] DoPing RPC failed for interface %1!ws!, status %2!u!.\n",
                interface1Id,
                status
                );
            goto error_lock_and_exit;
        }

        status1 = NmpDoInterfacePing(
                      Interface1,
                      unionPingEnum,
                      Interface1HasConnectivity
                      );

        //
        // Wait for the RPC for interface2 to complete
        //
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Waiting for RpcDoInterfacePing for interface %1!ws! to complete\n",
            interface2Id
            );

        status = WaitForSingleObject(event2, INFINITE);
        CL_ASSERT(status == WAIT_OBJECT_0);

        status = RpcAsyncCompleteCall(
                     &async2,
                     &status2
                     );

        CL_ASSERT(status == RPC_S_OK);

        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Wait for RpcDoInterfacePing for interface %1!ws! completed.\n",
            interface2Id
            );
    }

    if (status1 != RPC_S_OK) {
        status = status1;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] DoPing RPC failed for interface %1!ws!, status %2!u!.\n",
            interface1Id,
            status
            );
        goto error_lock_and_exit;
    }

    if (status2 != RPC_S_OK) {
        status = status2;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] DoPing RPC failed for interface %1!ws!, status %2!u!.\n",
            interface2Id,
            status
            );
        goto error_lock_and_exit;

    }

error_lock_and_exit:

    NmpAcquireLock();

    if ( (status == ERROR_SUCCESS) &&
         (NM_DELETE_PENDING(Interface1) || NM_DELETE_PENDING(Interface2))
       )
    {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Aborting interface connectivity test on network %1!ws! "
            "because an interface was deleted.\n",
            networkId
            );
        status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
    }

error_exit:

    OmDereferenceObject(Interface1->Node);
    OmDereferenceObject(Interface2->Node);

    if (localInterface != NULL) {
        OmDereferenceObject(localInterface);
    }

    if (onlineEnum1 != NULL) {
        midl_user_free(onlineEnum1);
    }

    if (onlineEnum2 != NULL) {
        midl_user_free(onlineEnum2);
    }

    if (unionOnlineEnum != NULL) {
        LocalFree(unionOnlineEnum);
    }

    if (pingEnum1 != NULL) {
        midl_user_free(pingEnum1);
    }

    if (pingEnum2 != NULL) {
        midl_user_free(pingEnum2);
    }

    if (unionPingEnum != NULL) {
        LocalFree(unionPingEnum);
    }

    if (event1 != NULL) {
        CloseHandle(event1);
    }

    if (event2 != NULL) {
        CloseHandle(event2);
    }

    return(status);

} // NmpTestInterfaceConnectivity


/////////////////////////////////////////////////////////////////////////////
//
// Miscellaneous routines
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmpRegisterInterface(
    IN PNM_INTERFACE  Interface,
    IN BOOLEAN        RetryOnFailure
    )
/*++

    Called with the NmpLock held.

--*/
{
    DWORD            status;
    LPWSTR           interfaceId = (LPWSTR) OmObjectId(Interface);
    PNM_NETWORK      network = Interface->Network;
    PVOID            tdiAddress = NULL;
    ULONG            tdiAddressLength = 0;
    NDIS_MEDIA_STATE mediaStatus;


    CL_ASSERT(!NmpIsInterfaceRegistered(Interface));

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Registering interface %1!ws! (%2!ws!) with cluster transport, "
        "addr %3!ws!, endpoint %4!ws!.\n",
        interfaceId,
        OmObjectName(Interface),
        Interface->Address,
        Interface->ClusnetEndpoint
        );

    status = ClRtlBuildTcpipTdiAddress(
                 Interface->Address,
                 Interface->ClusnetEndpoint,
                 &tdiAddress,
                 &tdiAddressLength
                 );

    if (status == ERROR_SUCCESS) {
        status = ClusnetRegisterInterface(
                     NmClusnetHandle,
                     Interface->Node->NodeId,
                     Interface->Network->ShortId,
                     0,
                     Interface->AdapterId,
                     wcslen(Interface->AdapterId) * sizeof(WCHAR),
                     tdiAddress,
                     tdiAddressLength,
                     (PULONG) &mediaStatus
                     );

        LocalFree(tdiAddress);

        if (status == ERROR_SUCCESS) {
            Interface->Flags |= NM_FLAG_IF_REGISTERED;
            network->RegistrationRetryTimeout = 0;

            //
            // If this is a local interface, and if its media status
            // indicates that it is connected, schedule a worker thread to
            // deliver an interface up notification. Clusnet does not
            // deliver interface up events for local interfaces.
            //
            if (network->LocalInterface == Interface) {
                if (mediaStatus == NdisMediaStateConnected) {
                    network->Flags |= NM_FLAG_NET_REPORT_LOCAL_IF_UP;
                    NmpScheduleNetworkConnectivityReport(network);
                } else {
                    ClRtlLogPrint(LOG_UNUSUAL, 
                        "[NM] Local interface %1!ws! reported "
                        "disconnected.\n",
                        interfaceId,
                        status
                        );
                    network->Flags |= NM_FLAG_NET_REPORT_LOCAL_IF_FAILED;
                    NmpScheduleNetworkConnectivityReport(network);
                }
            }
        }
        else {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Failed to register interface %1!ws! with cluster "
                "transport, status %2!u!.\n",
                interfaceId,
                status
                );
        }
    }
    else {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to build TDI bind address for interface %1!ws!, "
            "status %2!u!.\n",
            interfaceId,
            status
            );
    }

    if (status != ERROR_SUCCESS) {
        WCHAR  string[16];

        wsprintfW(&(string[0]), L"%u", status);

        CsLogEvent3(
            LOG_UNUSUAL,
            NM_EVENT_REGISTER_NETINTERFACE_FAILED,
            OmObjectName(Interface->Node),
            OmObjectName(Interface->Network),
            string
            );

        //
        // Retry if the error is transient
        //
        if ( RetryOnFailure &&
             ( (status == ERROR_INVALID_NETNAME) ||
               (status == ERROR_NOT_ENOUGH_MEMORY) ||
               (status == ERROR_NO_SYSTEM_RESOURCES)
             )
           )
        {
            NmpStartNetworkRegistrationRetryTimer(network);

            status = ERROR_SUCCESS;
        }
    }

    return(status);

}  // NmpRegisterInterface


VOID
NmpDeregisterInterface(
    IN  PNM_INTERFACE   Interface
    )
/*++

Routine Description:

    Deregisters an interface from the cluster transport.

Arguments:

    Interface - A pointer to the interface to deregister.

Return Value:

    None.

Notes:

    Called with the NmpLock held.

--*/
{
    DWORD status;


    CL_ASSERT(NmpIsInterfaceRegistered(Interface));

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Deregistering interface %1!ws! (%2!ws!) from cluster "
        "transport.\n",
        OmObjectId(Interface),
        OmObjectName(Interface)
        );

    status = ClusnetDeregisterInterface(
                 NmClusnetHandle,
                 Interface->Node->NodeId,
                 Interface->Network->ShortId
                 );

    CL_ASSERT(
        (status == ERROR_SUCCESS) ||
        (status == ERROR_CLUSTER_NETINTERFACE_NOT_FOUND)
        );

    Interface->Flags &= ~NM_FLAG_IF_REGISTERED;

    return;

} // NmpDeregisterNetwork


DWORD
NmpPrepareToCreateInterface(
    IN  PNM_INTERFACE_INFO2   InterfaceInfo,
    OUT PNM_NETWORK *         Network,
    OUT PNM_NODE *            Node
    )
{
    DWORD          status;
    PNM_INTERFACE  netInterface = NULL;
    PNM_NODE       node = NULL;
    PNM_NETWORK    network = NULL;
    PLIST_ENTRY    entry;


    *Node = NULL;
    *Network = NULL;

    //
    // Verify that the associated node and network objects exist.
    //
    network = OmReferenceObjectById(
                  ObjectTypeNetwork,
                  InterfaceInfo->NetworkId
                  );

    if (network == NULL) {
        status = ERROR_CLUSTER_NETWORK_NOT_FOUND;
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Network %1!ws! does not exist. Cannot create "
            "interface %2!ws!\n",
            InterfaceInfo->NetworkId,
            InterfaceInfo->Id
            );
        goto error_exit;
    }

    node = OmReferenceObjectById(ObjectTypeNode, InterfaceInfo->NodeId);

    if (node == NULL) {
        status = ERROR_CLUSTER_NODE_NOT_FOUND;
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Node %1!ws! does not exist. Cannot create interface %2!ws!\n",
            InterfaceInfo->NodeId,
            InterfaceInfo->Id
            );
        goto error_exit;
    }

    //
    // Verify that the interface doesn't already exist.
    //
    NmpAcquireLock();

    for ( entry = node->InterfaceList.Flink;
          entry != &(node->InterfaceList);
          entry = entry->Flink
        )
    {
        netInterface = CONTAINING_RECORD(entry, NM_INTERFACE, NodeLinkage);

        if (netInterface->Network == network) {
            status = ERROR_CLUSTER_NETINTERFACE_EXISTS;
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] An interface already exists for node %1!ws! on network %2!ws!\n",
                InterfaceInfo->NodeId,
                InterfaceInfo->NetworkId
                );
            NmpReleaseLock();
            goto error_exit;
        }
    }

    NmpReleaseLock();

    //
    // Verify that the specified interface ID is unique.
    //
    netInterface = OmReferenceObjectById(
                       ObjectTypeNetInterface,
                       InterfaceInfo->Id
                       );

    if (netInterface != NULL) {
        OmDereferenceObject(netInterface);
        status = ERROR_CLUSTER_NETINTERFACE_EXISTS;
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] An interface with ID %1!ws! already exists\n",
            InterfaceInfo->Id
            );
        goto error_exit;
    }

    *Node = node;
    *Network = network;

    return(ERROR_SUCCESS);


error_exit:

    if (network != NULL) {
        OmDereferenceObject(network);
    }

    if (node != NULL) {
        OmDereferenceObject(node);
    }

    return(status);

}  // NmpPrepareToCreateInterface


PNM_INTERFACE
NmpGetInterfaceForNodeAndNetworkById(
    IN  CL_NODE_ID     NodeId,
    IN  CL_NETWORK_ID  NetworkId
    )

/*++

Routine Description:

    Give the node Id and network short Id, return a pointer to
    the intersecting interface object

Arguments:

    NodeId - The ID of the node associated with this interface

    NetworkId - The short Id of the network associated with this interface

Return Value:

    A pointer to the interface object if successful.

    NULL if unsuccessful. Extended error information is available from
    GetLastError().

Notes:

    Called with the NmpLock held.

--*/
{
    DWORD      status;
    PNM_NODE   node = NmpIdArray[NodeId];


    if (node != NULL) {
        PLIST_ENTRY     entry;
        PNM_INTERFACE   netInterface;

        //
        // run down the list of interfaces associated with this node,
        // looking for one whose network matches the specified short ID
        //

        for (entry = node->InterfaceList.Flink;
             entry != &(node->InterfaceList);
             entry = entry->Flink
             )
        {
            netInterface = CONTAINING_RECORD(
                               entry,
                               NM_INTERFACE,
                               NodeLinkage
                               );

            if (netInterface->Network->ShortId == NetworkId) {
                return(netInterface);
            }
        }

        status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
    }
    else {
        status = ERROR_CLUSTER_NODE_NOT_FOUND;
    }

    SetLastError(status);

    return(NULL);

}  // NmpGetInterfaceForNodeAndNetworkById


DWORD
NmpConvertPropertyListToInterfaceInfo(
    IN PVOID              InterfacePropertyList,
    IN DWORD              InterfacePropertyListSize,
    PNM_INTERFACE_INFO2   InterfaceInfo
    )
{
    DWORD  status;

    //
    // Unmarshall the property list.
    //
    ZeroMemory(InterfaceInfo, sizeof(NM_INTERFACE_INFO2));

    status = ClRtlVerifyPropertyTable(
                 NmpInterfaceProperties,
                 NULL,    // Reserved
                 FALSE,   // Don't allow unknowns
                 InterfacePropertyList,
                 InterfacePropertyListSize,
                 (LPBYTE) InterfaceInfo
                 );

    if (status == ERROR_SUCCESS) {
        InterfaceInfo->NetIndex = NmInvalidInterfaceNetIndex;
    }

    return(status);

} // NmpConvertPropertyListToInterfaceInfo


BOOLEAN
NmpVerifyLocalInterfaceConnected(
    IN  PNM_INTERFACE     Interface
    )
/*++

Routine Description:

    Queries local interface adapter for current media
    status using an NDIS ioctl. 
    
Arguments:

    Interface - interface object for local adapter to query
    
Return value:

    TRUE if media status is connected or cannot be determined
    FALSE if media status is disconnected
    
Notes:

    Called and returns with NM lock acquired.
    
--*/
{
    PWCHAR             adapterDevNameBuffer = NULL;
    PWCHAR             adapterDevNamep, prefix, brace;
    DWORD              prefixSize, allocSize, adapterIdSize;
    DWORD              status = ERROR_SUCCESS;
    UNICODE_STRING     adapterDevName;
    NIC_STATISTICS     ndisStats;
    BOOLEAN            mediaConnected = TRUE;

    // verify parameters
    if (Interface == NULL || Interface->AdapterId == NULL) {
        return TRUE;
    }

    // the adapter device name is of the form
    //
    //     \Device\{AdapterIdGUID}
    //
    // the AdapterId field in the NM_INTERFACE structure is
    // currently not enclosed in braces, but we handle the
    // case where it is.

    // set up the adapter device name prefix
    prefix = L"\\Device\\";
    prefixSize = wcslen(prefix) * sizeof(WCHAR);

    // allocate a buffer for the adapter device name.
    adapterIdSize = wcslen(Interface->AdapterId) * sizeof(WCHAR);
    allocSize = prefixSize + adapterIdSize + sizeof(UNICODE_NULL);
    brace = L"{";
    if (*((PWCHAR)Interface->AdapterId) != *brace) {
        allocSize += 2 * sizeof(WCHAR);
    }
    adapterDevNameBuffer = LocalAlloc(LMEM_FIXED, allocSize);
    if (adapterDevNameBuffer == NULL) {
        ClRtlLogPrint(
            LOG_UNUSUAL, 
            "[NM] Failed to allocate device name buffer for "
            "adapter %1!ws!. Assuming adapter is connected.\n",
            Interface->AdapterId
            );        
        return(TRUE);
    }

    // build the adapter device name from the adapter ID
    ZeroMemory(adapterDevNameBuffer, allocSize);

    adapterDevNamep = adapterDevNameBuffer;

    CopyMemory(adapterDevNamep, prefix, prefixSize);

    adapterDevNamep += prefixSize / sizeof(WCHAR);

    if (*((PWCHAR)Interface->AdapterId) != *brace) {
        *adapterDevNamep = *brace;
        adapterDevNamep++;
    }

    CopyMemory(adapterDevNamep, Interface->AdapterId, adapterIdSize);

    if (*((PWCHAR)Interface->AdapterId) != *brace) {
        brace = L"}";
        adapterDevNamep += adapterIdSize / sizeof(WCHAR);
        *adapterDevNamep = *brace;
    }

    RtlInitUnicodeString(&adapterDevName, (LPWSTR)adapterDevNameBuffer);

    // query the adapter for NDIS statistics
    ZeroMemory(&ndisStats, sizeof(ndisStats));
    ndisStats.Size = sizeof(ndisStats);

    if (!NdisQueryStatistics(&adapterDevName, &ndisStats)) {

        status = GetLastError();
        ClRtlLogPrint(
            LOG_UNUSUAL, 
            "[NM] NDIS statistics query to adapter %1!ws! failed, "
            "error %2!u!. Assuming adapter is connected.\n",
            Interface->AdapterId, status
            );
    
    } else {

        if (ndisStats.MediaState == MEDIA_STATE_DISCONNECTED) {
            mediaConnected = FALSE;
        }
    }

    LocalFree(adapterDevNameBuffer);
    
    return(mediaConnected);

} // NmpVerifyLocalInterfaceConnected
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\nm\ioctl.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

    Node control functions.

Author:

    John Vert (jvert) 2-Mar-1997

Revision History:

--*/

#include "nmp.h"

//
// Node Common properties.
//

//
// Read-Write Common Properties.
//
RESUTIL_PROPERTY_ITEM
NmpNodeCommonProperties[] = {
    { CLUSREG_NAME_NODE_DESC, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, 0 },
    { CLUSREG_NAME_CLUS_EVTLOG_PROPAGATION, NULL, CLUSPROP_FORMAT_DWORD, 1, 0, 1, 0},
    { NULL, NULL, 0, 0, 0, 0, 0 } };

//
// Read-Only Common Properties.
//
RESUTIL_PROPERTY_ITEM
NmpNodeROCommonProperties[] = {
    { CLUSREG_NAME_NODE_NAME, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_READ_ONLY },
    { CLUSREG_NAME_NODE_HIGHEST_VERSION, NULL, CLUSPROP_FORMAT_DWORD, 0, 0, 0, RESUTIL_PROPITEM_READ_ONLY },
    { CLUSREG_NAME_NODE_LOWEST_VERSION, NULL, CLUSPROP_FORMAT_DWORD, 0, 0, 0, RESUTIL_PROPITEM_READ_ONLY },
    { CLUSREG_NAME_NODE_MAJOR_VERSION, NULL, CLUSPROP_FORMAT_DWORD, 0, 0, 0, RESUTIL_PROPITEM_READ_ONLY},
    { CLUSREG_NAME_NODE_MINOR_VERSION, NULL, CLUSPROP_FORMAT_DWORD, 0, 0, 0, RESUTIL_PROPITEM_READ_ONLY},
    { CLUSREG_NAME_NODE_BUILD_NUMBER, NULL, CLUSPROP_FORMAT_DWORD, 0, 0, 0, RESUTIL_PROPITEM_READ_ONLY},
    { CLUSREG_NAME_NODE_CSDVERSION, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_READ_ONLY},
    { NULL, NULL, 0, 0, 0, 0, 0 } };

//
// Cluster registry API function pointers.
//
CLUSTER_REG_APIS
NmpClusterRegApis = {
    (PFNCLRTLCREATEKEY) DmRtlCreateKey,
    (PFNCLRTLOPENKEY) DmRtlOpenKey,
    (PFNCLRTLCLOSEKEY) DmCloseKey,
    (PFNCLRTLSETVALUE) DmSetValue,
    (PFNCLRTLQUERYVALUE) DmQueryValue,
    (PFNCLRTLENUMVALUE) DmEnumValue,
    (PFNCLRTLDELETEVALUE) DmDeleteValue,
    NULL,
    NULL,
    NULL
};


//
// Local Functions
//

DWORD
NmpNodeControl(
    IN PNM_NODE Node,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
NmpNodeEnumCommonProperties(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
NmpNodeGetCommonProperties(
    IN PNM_NODE Node,
    IN BOOL ReadOnly,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
NmpNodeValidateCommonProperties(
    IN PNM_NODE Node,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
NmpNodeSetCommonProperties(
    IN PNM_NODE Node,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
NmpNodeEnumPrivateProperties(
    IN PNM_NODE Node,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
NmpNodeGetPrivateProperties(
    IN PNM_NODE Node,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
NmpNodeValidatePrivateProperties(
    IN PNM_NODE Node,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
NmpNodeSetPrivateProperties(
    IN PNM_NODE Node,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
NmpNodeGetFlags(
    IN PNM_NODE Node,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );


DWORD
WINAPI
NmNodeControl(
    IN PNM_NODE Node,
    IN PNM_NODE HostNode OPTIONAL,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a node.

Arguments:

    Node - Supplies the node to be controlled.

    HostNode - Supplies the host node on which the resource control should
           be delivered. If this is NULL, the local node is used. Not honored!

    ControlCode- Supplies the control code that defines the
        structure and action of the resource control.
        Values of ControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    InBuffer- Supplies a pointer to the input buffer to be passed
        to the resource.

    InBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer..

    OutBuffer- Supplies a pointer to the output buffer to be
        filled in by the resource..

    OutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    BytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the resource..

    Required - Returns the number of bytes if the OutBuffer is not big
        enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD   status;

    //
    // Cluster service ioctls were designed to have access modes, e.g.
    // read-only, read-write, etc. These access modes are not implemented.
    // If eventually they are implemented, an access mode check should be
    // placed here.
    //
    if ( CLUSCTL_GET_CONTROL_OBJECT( ControlCode ) != CLUS_OBJECT_NODE ) {
        return(ERROR_INVALID_FUNCTION);
    }

    if (NmpEnterApi(NmStateOnline)) {
        status = NmpNodeControl(
                     Node,
                     ControlCode,
                     InBuffer,
                     InBufferSize,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );

        NmpLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process NodeControl request.\n"
            );
    }

    return(status);

} // NmNodeControl



DWORD
NmpNodeControl(
    IN PNM_NODE Node,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a node.

Arguments:

    Node - Supplies the node to be controlled.

    ControlCode- Supplies the control code that defines the
        structure and action of the node control.
        Values of ControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    InBuffer- Supplies a pointer to the input buffer to be passed
        to the node.

    InBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    OutBuffer- Supplies a pointer to the output buffer to be
        filled in by the node.

    OutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    BytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the node.

    Required - Returns the number of bytes if the OutBuffer is not big
        enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD   status;
    HDMKEY  nodeKey;
    CLUSPROP_BUFFER_HELPER props;
    DWORD   bufSize;

    nodeKey = DmOpenKey( DmNodesKey,
                         OmObjectId( Node ),
                         MAXIMUM_ALLOWED
                        );
    if ( nodeKey == NULL ) {
        return(GetLastError());
    }

    switch ( ControlCode ) {

    case CLUSCTL_NODE_UNKNOWN:
        *BytesReturned = 0;
        status = ERROR_SUCCESS;
        break;

    case CLUSCTL_NODE_GET_NAME:
        if ( OmObjectName( Node ) == NULL ) {
            return(ERROR_NOT_READY);
        }
        props.pb = OutBuffer;
        bufSize = (lstrlenW( OmObjectName( Node ) ) + 1) * sizeof(WCHAR);
        if ( bufSize > OutBufferSize ) {
            *Required = bufSize;
            *BytesReturned = 0;
            status = ERROR_MORE_DATA;
        } else {
            lstrcpyW( props.psz, OmObjectName( Node ) );
            *BytesReturned = bufSize;
            *Required = 0;
            status = ERROR_SUCCESS;
        }
        break;

    case CLUSCTL_NODE_GET_ID:
        if ( OmObjectId( Node ) == NULL ) {
            return(ERROR_NOT_READY);
        }
        props.pb = OutBuffer;
        bufSize = (lstrlenW( OmObjectId( Node ) ) + 1) * sizeof(WCHAR);
        if ( bufSize > OutBufferSize ) {
            *Required = bufSize;
            *BytesReturned = 0;
            status = ERROR_MORE_DATA;
        } else {
            lstrcpyW( props.psz, OmObjectId( Node ) );
            *BytesReturned = bufSize;
            *Required = 0;
            status = ERROR_SUCCESS;
        }
        break;

    case CLUSCTL_NODE_ENUM_COMMON_PROPERTIES:
        status = NmpNodeEnumCommonProperties( OutBuffer,
                                              OutBufferSize,
                                              BytesReturned,
                                              Required );
        break;

    case CLUSCTL_NODE_GET_RO_COMMON_PROPERTIES:
        status = NmpNodeGetCommonProperties( Node,
                                             TRUE, // ReadOnly
                                             nodeKey,
                                             OutBuffer,
                                             OutBufferSize,
                                             BytesReturned,
                                             Required );
        break;

    case CLUSCTL_NODE_GET_COMMON_PROPERTIES:
        status = NmpNodeGetCommonProperties( Node,
                                             FALSE, // ReadOnly
                                             nodeKey,
                                             OutBuffer,
                                             OutBufferSize,
                                             BytesReturned,
                                             Required );
        break;

    case CLUSCTL_NODE_VALIDATE_COMMON_PROPERTIES:
        status = NmpNodeValidateCommonProperties( Node,
                                                  nodeKey,
                                                  InBuffer,
                                                  InBufferSize );
        break;

    case CLUSCTL_NODE_SET_COMMON_PROPERTIES:
        status = NmpNodeSetCommonProperties( Node,
                                             nodeKey,
                                             InBuffer,
                                             InBufferSize );
        break;

    case CLUSCTL_NODE_ENUM_PRIVATE_PROPERTIES:
        status = NmpNodeEnumPrivateProperties( Node,
                                               nodeKey,
                                               OutBuffer,
                                               OutBufferSize,
                                               BytesReturned,
                                               Required );
        break;

    case CLUSCTL_NODE_GET_RO_PRIVATE_PROPERTIES:
        if ( OutBufferSize < sizeof(DWORD) ) {
            *BytesReturned = 0;
            *Required = sizeof(DWORD);
            if ( OutBuffer == NULL ) {
                status = ERROR_SUCCESS;
            } else {
                status = ERROR_MORE_DATA;
            }
        } else {
            LPDWORD ptrDword = (LPDWORD) OutBuffer;
            *ptrDword = 0;
            *BytesReturned = sizeof(DWORD);
            status = ERROR_SUCCESS;
        }
        break;

    case CLUSCTL_NODE_GET_PRIVATE_PROPERTIES:
        status = NmpNodeGetPrivateProperties( Node,
                                              nodeKey,
                                              OutBuffer,
                                              OutBufferSize,
                                              BytesReturned,
                                              Required );
        break;

    case CLUSCTL_NODE_VALIDATE_PRIVATE_PROPERTIES:
        status = NmpNodeValidatePrivateProperties( Node,
                                                   nodeKey,
                                                   InBuffer,
                                                   InBufferSize );
        break;

    case CLUSCTL_NODE_SET_PRIVATE_PROPERTIES:
        status = NmpNodeSetPrivateProperties( Node,
                                              nodeKey,
                                              InBuffer,
                                              InBufferSize );
        break;

    case CLUSCTL_NODE_GET_CHARACTERISTICS:
        if ( OutBufferSize < sizeof(DWORD) ) {
            *BytesReturned = 0;
            *Required = sizeof(DWORD);
            if ( OutBuffer == NULL ) {
                status = ERROR_SUCCESS;
            } else {
                status = ERROR_MORE_DATA;
            }
        } else {
            *BytesReturned = sizeof(DWORD);
            *(LPDWORD)OutBuffer = 0;
            status = ERROR_SUCCESS;
        }
        break;

    case CLUSCTL_NODE_GET_FLAGS:
        status = NmpNodeGetFlags( Node,
                                  nodeKey,
                                  OutBuffer,
                                  OutBufferSize,
                                  BytesReturned,
                                  Required );
        break;

    default:
        status = ERROR_INVALID_FUNCTION;
        break;
    }

    DmCloseKey( nodeKey );

    return(status);

} // NmpNodeControl



DWORD
NmpNodeEnumCommonProperties(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Enumerates the common property names for a given node.

Arguments:

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    //
    // Get the common properties.
    //
    status = ClRtlEnumProperties( NmpNodeCommonProperties,
                                  OutBuffer,
                                  OutBufferSize,
                                  BytesReturned,
                                  Required );

    return(status);

} // NmpNodeEnumCommonProperties



DWORD
NmpNodeGetCommonProperties(
    IN PNM_NODE Node,
    IN BOOL ReadOnly,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the common properties for a given node.

Arguments:

    Node - Supplies the node.

    ReadOnly - TRUE if the read-only properties should be read. FALSE otherwise.

    RegistryKey - Supplies the registry key for this node.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD                   status;
    PRESUTIL_PROPERTY_ITEM  propertyTable;

    if ( ReadOnly ) {
        propertyTable = NmpNodeROCommonProperties;
    } else {
        propertyTable = NmpNodeCommonProperties;
    }

    //
    // Get the common properties.
    //
    status = ClRtlGetProperties( RegistryKey,
                                 &NmpClusterRegApis,
                                 propertyTable,
                                 OutBuffer,
                                 OutBufferSize,
                                 BytesReturned,
                                 Required );

    return(status);

} // NmpNodeGetCommonProperties



DWORD
NmpNodeValidateCommonProperties(
    IN PNM_NODE Node,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Validates the common properties for a given node.

Arguments:

    Node - Supplies the node object.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD   status;

    //
    // Validate the property list.
    //
    status = ClRtlVerifyPropertyTable( NmpNodeCommonProperties,
                                       NULL,     // Reserved
                                       FALSE,    // Don't allow unknowns
                                       InBuffer,
                                       InBufferSize,
                                       NULL );

    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint( LOG_CRITICAL,
                    "[NM] ValidateCommonProperties, error in verify routine.\n");
    }

    return(status);

} // NmpNodeValidateCommonProperties



DWORD
NmpNodeSetCommonProperties(
    IN PNM_NODE Node,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Sets the common properties for a given node.

Arguments:

    Node - Supplies the node object.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD   status;

    //
    // Validate the property list.
    //
    status = ClRtlVerifyPropertyTable( NmpNodeCommonProperties,
                                       NULL,    // Reserved
                                       FALSE,   // Don't allow unknowns
                                       InBuffer,
                                       InBufferSize,
                                       NULL );

    if ( status == ERROR_SUCCESS ) {

        status = ClRtlSetPropertyTable( NULL, 
                                        RegistryKey,
                                        &NmpClusterRegApis,
                                        NmpNodeCommonProperties,
                                        NULL,    // Reserved
                                        FALSE,   // Don't allow unknowns
                                        InBuffer,
                                        InBufferSize,
                                        FALSE,   // bForceWrite
                                        NULL );
        if ( status != ERROR_SUCCESS ) {
            ClRtlLogPrint( LOG_CRITICAL,
                       "[NM] SetCommonProperties, error in set routine.\n");
        }
    } else {
        ClRtlLogPrint( LOG_CRITICAL,
                    "[NM] SetCommonProperties, error in verify routine.\n");
    }

    return(status);

} // NmpNodeSetCommonProperties



DWORD
NmpNodeEnumPrivateProperties(
    IN PNM_NODE Node,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Enumerates the private property names for a given node.

Arguments:

    Node - Supplies the node object.

    RegistryKey - Registry key for the node.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HDMKEY      parametersKey;
    DWORD       totalBufferSize = 0;

    *BytesReturned = 0;
    *Required = 0;

    //
    // Clear the output buffer
    //
    ZeroMemory( OutBuffer, OutBufferSize );

    //
    // Open the cluster node parameters key.
    //
    parametersKey = DmOpenKey( RegistryKey,
                               CLUSREG_KEYNAME_PARAMETERS,
                               MAXIMUM_ALLOWED );
    if ( parametersKey == NULL ) {
        status = GetLastError();
        if ( status == ERROR_FILE_NOT_FOUND ) {
            status = ERROR_SUCCESS;
        }
        return(status);
    }

    //
    // Enum the private properties for the node.
    //
    status = ClRtlEnumPrivateProperties( parametersKey,
                                         &NmpClusterRegApis,
                                         OutBuffer,
                                         OutBufferSize,
                                         BytesReturned,
                                         Required );

    DmCloseKey( parametersKey );

    return(status);

} // NmpNodeEnumPrivateProperties



DWORD
NmpNodeGetPrivateProperties(
    IN PNM_NODE Node,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the private properties for a given node.

Arguments:

    Node - Supplies the node object.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HDMKEY      parametersKey;
    DWORD       totalBufferSize = 0;

    *BytesReturned = 0;
    *Required = 0;

    //
    // Clear the output buffer
    //
    ZeroMemory( OutBuffer, OutBufferSize );

    //
    // Open the cluster node parameters key.
    //
    parametersKey = DmOpenKey( RegistryKey,
                               CLUSREG_KEYNAME_PARAMETERS,
                               MAXIMUM_ALLOWED );
    if ( parametersKey == NULL ) {
        status = GetLastError();
        if ( status == ERROR_FILE_NOT_FOUND ) {
            //
            // If we don't have a parameters key, then return an
            // item count of 0 and an endmark.
            //
            totalBufferSize = sizeof(DWORD) + sizeof(CLUSPROP_SYNTAX);
            if ( OutBufferSize < totalBufferSize ) {
                *Required = totalBufferSize;
                status = ERROR_MORE_DATA;
            } else {
                // This is somewhat redundant since we zero the
                // buffer above, but it's here for clarity.
                CLUSPROP_BUFFER_HELPER buf;
                buf.pb = OutBuffer;
                buf.pList->nPropertyCount = 0;
                buf.pdw++;
                buf.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
                *BytesReturned = totalBufferSize;
                status = ERROR_SUCCESS;
            }
        }
        return(status);
    }

    //
    // Get private properties for the node.
    //
    status = ClRtlGetPrivateProperties( parametersKey,
                                        &NmpClusterRegApis,
                                        OutBuffer,
                                        OutBufferSize,
                                        BytesReturned,
                                        Required );

    DmCloseKey( parametersKey );

    return(status);

} // NmpNodeGetPrivateProperties



DWORD
NmpNodeValidatePrivateProperties(
    IN PNM_NODE Node,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Validates the private properties for a given node.

Arguments:

    Node - Supplies the node object.

    RegistryKey - Registry key for the node.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    //
    // Validate the property list.
    //
    status = ClRtlVerifyPrivatePropertyList( InBuffer,
                                             InBufferSize );

    return(status);

} // NmpNodeValidatePrivateProperties



DWORD
NmpNodeSetPrivateProperties(
    IN PNM_NODE Node,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Sets the private properties for a given node.

Arguments:

    Node - Supplies the node object.

    RegistryKey - Registry key for the node.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HDMKEY      parametersKey;
    DWORD       disposition;

    //
    // Validate the property list.
    //
    status = ClRtlVerifyPrivatePropertyList( InBuffer,
                                             InBufferSize );

    if ( status == ERROR_SUCCESS ) {

        //
        // Open the cluster node\xx\parameters key
        //
        parametersKey = DmOpenKey( RegistryKey,
                                   CLUSREG_KEYNAME_PARAMETERS,
                                   MAXIMUM_ALLOWED );
        if ( parametersKey == NULL ) {
            status = GetLastError();
            if ( status == ERROR_FILE_NOT_FOUND ) {
                //
                // Try to create the parameters key.
                //
                parametersKey = DmCreateKey( RegistryKey,
                                             CLUSREG_KEYNAME_PARAMETERS,
                                             0,
                                             KEY_READ | KEY_WRITE,
                                             NULL,
                                             &disposition );
                if ( parametersKey == NULL ) {
                    status = GetLastError();
                    return(status);
                }
            }
        }

        status = ClRtlSetPrivatePropertyList( NULL, // IN HANDLE hXsaction
                                              parametersKey,
                                              &NmpClusterRegApis,
                                              InBuffer,
                                              InBufferSize );

        DmCloseKey( parametersKey );
    }

    return(status);

} // NmpNodeSetPrivateProperties



DWORD
NmpNodeGetFlags(
    IN PNM_NODE Node,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the flags for a given node.

Arguments:

    Node - Supplies the node.

    RegistryKey - Registry key for the node.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    *BytesReturned = 0;

    if ( OutBufferSize < sizeof(DWORD) ) {
        *Required = sizeof(DWORD);
        if ( OutBuffer == NULL ) {
            status = ERROR_SUCCESS;
        } else {
            status = ERROR_MORE_DATA;
        }
    } else {
        DWORD       valueType;

        //
        // Read the Flags value for the node.
        //
        *BytesReturned = OutBufferSize;
        status = DmQueryValue( RegistryKey,
                               CLUSREG_NAME_FLAGS,
                               &valueType,
                               OutBuffer,
                               BytesReturned );
        if ( status == ERROR_FILE_NOT_FOUND ) {
            *BytesReturned = sizeof(DWORD);
            *(LPDWORD)OutBuffer = 0;
            status = ERROR_SUCCESS;
        }
    }

    return(status);

} // NmpNodeGetFlags
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\nm\member.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    member.c

Abstract:

    Cluster membership management routines for the Node Manager.

Author:

    Mike Massa (mikemas) 12-Mar-1996


Revision History:

--*/


#include "nmp.h"
#include <clusrtl.h>


//
// Data
//
BOOLEAN     NmpMembershipCleanupOk = FALSE;
BITSET      NmpUpNodeSet = 0;
LIST_ENTRY  NmpLeaderChangeWaitList = {NULL, NULL};


//
// Routines
//
VOID
NmpMarkNodeUp(
    CL_NODE_ID  NodeId
    )
/*++

Notes:

    Called with the NmpLock held.

--*/
{
    BitsetAdd(NmpUpNodeSet, NodeId);

    return;
}


VOID
NmpNodeUpEventHandler(
    IN PNM_NODE   Node
    )
/*++

Notes:

    Called with the NmpLock held.

--*/
{
    NmpMarkNodeUp(Node->NodeId);

    //
    // Don't declare the local node to be up. The join code will
    // take care of this.
    //
    if ((Node != NmLocalNode) && (Node->State == ClusterNodeJoining)) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NMJOIN] Joining node %1!u! is now participating in the cluster membership.\n",
            Node->NodeId
            );

        CL_ASSERT(NmpJoinerNodeId == Node->NodeId);
        CL_ASSERT(Node->State == ClusterNodeJoining);
        CL_ASSERT(NmpJoinTimer == 0);
        CL_ASSERT(NmpJoinAbortPending == FALSE);
        CL_ASSERT(NmpJoinerUp == FALSE);

        NmpJoinerUp = TRUE;
    }

    return;

}  // NmpNodeUpEventHandler


VOID
NmpNodeDownEventHandler(
    IN PNM_NODE   Node
    )
{
   NmpMultiNodeDownEventHandler( BitsetFromUnit(Node->NodeId) );
}


DWORD
NmpMultiNodeDownEventHandler(
    IN BITSET DownedNodeSet
    )
{
    CL_NODE_ID                    i;
    PNM_NODE                      node;
    DWORD                         status;
    BOOLEAN                       iAmNewLeader = FALSE;
    PNM_LEADER_CHANGE_WAIT_ENTRY  waitEntry;
    PLIST_ENTRY                   listEntry;


    ClRtlLogPrint(LOG_NOISE, "[NM] Down node set: %1!04X!.\n", DownedNodeSet);

    NmpAcquireLock();

    //
    // Compute the new up node set
    //
    BitsetSubtract(NmpUpNodeSet, DownedNodeSet);

    ClRtlLogPrint(LOG_NOISE, "[NM] New up node set: %1!04X!.\n", NmpUpNodeSet);

    //
    // Check for failure of a joining node.
    //
    if (NmpJoinerNodeId != ClusterInvalidNodeId) {

        if (NmpJoinerNodeId == NmLocalNodeId) {
            //
            // The joining node is the local node. Halt.
            //
            ClRtlLogPrint(LOG_NOISE, 
                "[NMJOIN] Aborting join because of change in membership.\n"
                );
            CsInconsistencyHalt(ERROR_CLUSTER_JOIN_ABORTED);
        }
        else if ( (BitsetIsMember(NmpJoinerNodeId, DownedNodeSet))
                  ||
                  ( (BitsetIsMember(NmpSponsorNodeId, DownedNodeSet)) &&
                    (!BitsetIsMember(NmpJoinerNodeId, DownedNodeSet))
                  )
                )
        {
            //
            // The joining node is down or the sponsor is down and the joiner
            // is not yet an active member. Cleanup the join state. If the
            // sponsor is down and the joiner is an active member, we will
            // clean up when we detect that the joiner has perished.
            //
            ClRtlLogPrint(LOG_NOISE, 
                "[NMJOIN] Aborting join of node %1!u! sponsored by node %2!u!\n",
                NmpJoinerNodeId,
                NmpSponsorNodeId
                );

	        //
	        // Reset joiner state if sponsor died
	        //
            if (BitsetIsMember(NmpSponsorNodeId, DownedNodeSet)) {
                node = NmpIdArray[NmpJoinerNodeId];
                node->State = ClusterNodeDown;
                // [GorN 4/3/2000] 
                // Without a node down, cluadmin won't refresh the state.
                // If this code is to be changed to emit CLUSTER_NODE_CHANGE_EVENT or
                // some other event, NmpUpdateJoinAbort has to be changed as well,
                // so that we will have the same join cleanup behavior 
                BitsetAdd(DownedNodeSet, NmpJoinerNodeId);
            }

            NmpJoinerNodeId = ClusterInvalidNodeId;
            NmpSponsorNodeId = ClusterInvalidNodeId;
            NmpJoinTimer = 0;
            NmpJoinAbortPending = FALSE;
            NmpJoinSequence = 0;
            NmpJoinerUp = FALSE;
            NmpJoinerOutOfSynch = FALSE;
        }
        else {
            //
            // Mark that the joiner is out of synch with the cluster
            // state. The sponsor will eventually abort the join.
            //
            ClRtlLogPrint(LOG_NOISE, 
                "[NMJOIN] Joiner node %1!u! is now out of synch with the cluster state.\n",
                NmpJoinerNodeId
                );
            NmpJoinerOutOfSynch = TRUE;
        }
    }

    //
    // Check if the leader node went down
    //
    if (BitsetIsMember(NmpLeaderNodeId, DownedNodeSet)) {
        BOOL  isEventSet;

        //
        // Elect a new leader - active node with the smallest ID.
        //
        for (i = ClusterMinNodeId; i <= NmMaxNodeId; i++) {
            if (BitsetIsMember(i, NmpUpNodeSet)) {
                NmpLeaderNodeId = i;
                break;
            }
        }

        CL_ASSERT(i <= NmMaxNodeId);

        if (NmpLeaderNodeId == NmLocalNodeId) {
            //
            // The local node is the new leader.
            //
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] This node is the new leader.\n"
                );

            iAmNewLeader = TRUE;
        }
        else {
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] Node %1!u! is the new leader.\n",
                NmpLeaderNodeId
                );
        }

        //
        // Wake up any threads waiting for an RPC call to the leader to
        // complete.
        //
        while (!IsListEmpty(&NmpLeaderChangeWaitList)) {
            listEntry = RemoveHeadList(&NmpLeaderChangeWaitList);

            //
            // NULL out the entry's links to indicate that it has been
            // dequeued. The users of the notification feature depend
            // on this action.
            //
            listEntry->Flink = NULL; listEntry->Blink = NULL;

            //
            // Wake up the waiting thread.
            //
            waitEntry = (PNM_LEADER_CHANGE_WAIT_ENTRY) listEntry;
            isEventSet = SetEvent(waitEntry->LeaderChangeEvent);
            CL_ASSERT(isEventSet != 0);
        }
    }

    //
    // First recovery pass - clean up node states and disable communication
    //
    for (i = ClusterMinNodeId; i <= NmMaxNodeId; i++) {
        node = NmpIdArray[i];

        if ( (node != NULL) && (BitsetIsMember(i, DownedNodeSet)) ) {
            node->State = ClusterNodeDown;

            status = ClusnetOfflineNodeComm(
                         NmClusnetHandle,
                         node->NodeId
                         );

            CL_ASSERT(
                (status == ERROR_SUCCESS) ||
                (status == ERROR_CLUSTER_NODE_ALREADY_DOWN)
                );
        }
    }

    //
    // Inform the rest of the service that these nodes are gone
    //
    ClusterEventEx(
        CLUSTER_EVENT_NODE_DOWN_EX,
        EP_CONTEXT_VALID,
        ULongToPtr(DownedNodeSet)
        );

    //
    // Second recovery pass - clean up network states and issue old-style
    // node down events
    //
    for (i = ClusterMinNodeId; i <= NmMaxNodeId; i++) {
        node = NmpIdArray[i];

        if ( (node != NULL) && (BitsetIsMember(i, DownedNodeSet)) ) {
            //
            // Issue an individual node down event.
            //
            ClusterEvent(CLUSTER_EVENT_NODE_DOWN, node);

            //
            // Now do Intracluster RPC cleanup...
            //
            NmpTerminateRpcsToNode(node->NodeId);

            //
            // Update the network and interface information.
            //
            NmpUpdateNetworkConnectivityForDownNode(node);

            //
            // Log an event
            //
            if (NmpLeaderNodeId == NmLocalNodeId) {
                LPCWSTR nodeName = OmObjectName(node);

                CsLogEvent1(
                    LOG_UNUSUAL,
                    NM_EVENT_NODE_DOWN,
                    nodeName
                    );
            }
        }
    }

    //
    // If this node is the new leader, schedule a state computation for all
    // networks. State reports may have been received before this node
    // assumed leadership duties.
    //
    if (iAmNewLeader) {
        NmpRecomputeNT5NetworkAndInterfaceStates();
    }

    NmpReleaseLock();

    return(ERROR_SUCCESS);

}  // NmpNodesDownEventHandler //



DWORD
NmpNodeChange(
    IN DWORD NodeId,
    IN NODESTATUS NewStatus
    )
{
    PNM_NODE  node;


    CL_ASSERT(
        (NodeId >= ClusterMinNodeId) &&
        (NodeId <= NmMaxNodeId)
        );

    NmpAcquireLock();

    node = NmpIdArray[NodeId];

    CL_ASSERT(node != NULL);

    if (node != NULL) {
        if (NewStatus == NODE_DOWN) {
           NmpNodeDownEventHandler(node);
        }
        else {
            CL_ASSERT(NewStatus == NODE_UP);
            NmpNodeUpEventHandler(node);
        }
    }

    NmpReleaseLock();

    return(ERROR_SUCCESS);

}  // NmpNodeChange


VOID
NmpHoldIoEventHandler(
    VOID
    )
{
    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Holding I/O.\n"
        );
#if defined(HOLD_IO_IS_SAFE_NOW)
    FmHoldIO();
#endif

    return;
}


VOID
NmpResumeIoEventHandler(
    VOID
    )
{
    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Resuming I/O.\n"
        );
#if defined(HOLD_IO_IS_SAFE_NOW)
    FmResumeIO();
#endif

    return;
}


BOOL
NmpCheckQuorumEventHandler(
    VOID
    )
{
    BOOL                       haveQuorum;

    //
    // daviddio 06/19/2000
    // 
    // Before asking FM to arbitrate, determine if we have any
    // viable network interfaces. If not, return failure to MM
    // and allow other cluster nodes to arbitrate. The SCM
    // will restart the cluster service, so that if no nodes
    // successfully arbitrate, we will get another shot.
    //
    if (NmpCheckForNetwork()) {

        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Checking if we own the quorum resource.\n"
            );

        haveQuorum = FmArbitrateQuorumResource();

        if (haveQuorum) {
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] We own the quorum resource.\n"
                );
        }
        else {
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] We do not own the quorum resource, status %1!u!.\n",
                GetLastError()
                );

            //[GN] ClusnetHalt( NmClusnetHandle ); => NmpHaltEventHandler
            //
        }
    
    } else {

        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Abdicating quorum because no valid network "
            "interfaces were detected.\n"
            );
        haveQuorum = FALSE;
    }


    return(haveQuorum);

}  // NmpCheckQuorumEventHandler


void
NmpMsgCleanup1(
    IN DWORD DeadNodeId
    )
{
    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Phase 1 message cleanup - node %1!u!.\n",
        DeadNodeId
        );

    return;
}


void
NmpMsgCleanup2(
    IN BITSET DownedNodeSet
    )
{
    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Phase 2 message cleanup - node %1!04X!.\n",
        DownedNodeSet
        );

    NmpAcquireLock();
    if ( NmpCleanupIfJoinAborted &&
         (NmpJoinerNodeId != ClusterInvalidNodeId) &&
         BitsetIsMember(NmpJoinerNodeId, DownedNodeSet) )
    {
        //
        // Since the joiner is in the DownedNodeSet mask
        // the node down will be delivered on this node by a regroup engine.
        // No need for NmpUpdateAbortJoin to issue a node down.
        //
        NmpCleanupIfJoinAborted = FALSE;
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] NmpCleanupIfJoinAborted is set to false. Joiner - %1!u!.\n",
            NmpJoinerNodeId
            );
    }
    NmpReleaseLock();

    //
    // Inform the rest of the service that these nodes are gone
    //
    ClusterSyncEventEx(
        CLUSTER_EVENT_NODE_DOWN_EX,
        EP_CONTEXT_VALID,
        ULongToPtr(DownedNodeSet)
        );

    return;
}


VOID
NmpHaltEventHandler(
    IN DWORD HaltCode
    )
{
    WCHAR  string[16];

    // Do a graceful stop if we are shutting down //

    if (HaltCode == MM_STOP_REQUESTED) {
        DWORD Status = ERROR_SUCCESS;
    
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Prompt shutdown is requested by a membership engine\n"
            );
        ClusnetHalt( NmClusnetHandle );

        CsLogEvent(LOG_NOISE, SERVICE_SUCCESSFUL_TERMINATION);

        CsServiceStatus.dwCurrentState = SERVICE_STOPPED;
        CsServiceStatus.dwControlsAccepted = 0;
        CsServiceStatus.dwCheckPoint = 0;
        CsServiceStatus.dwWaitHint = 0;
        CsServiceStatus.dwWin32ExitCode = Status;
        CsServiceStatus.dwServiceSpecificExitCode = Status;

        CsAnnounceServiceStatus();

        ExitProcess(Status);

    } else {

        wsprintfW(&(string[0]), L"%u", HaltCode);

        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Halting this node due to membership or communications error. Halt code = %1!u!\n",
            HaltCode
            );

        ClusnetHalt( NmClusnetHandle );

        //
        // Adjust membership code to win32 error code. (If mapping exits)
        //

        HaltCode = MMMapHaltCodeToDosError( HaltCode );

        CsInconsistencyHalt(HaltCode);
    }        
}


void
NmpJoinFailed(
    void
    )
{
    return;
}



DWORD
NmpGumUpdateHandler(
    IN DWORD Context,
    IN BOOL SourceNode,
    IN DWORD BufferLength,
    IN PVOID Buffer
    )
/*++

Routine Description:

    Handles GUM updates for membership events.

Arguments:

    Context - Supplies the update context. This is the message type

    SourceNode - Supplies whether or not the update originated on this node.

    BufferLength - Supplies the length of the update.

    Buffer - Supplies a pointer to the buffer.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD status;


    if (Context == NmUpdateJoinComplete) {
        status = NmpUpdateJoinComplete(Buffer);
    }
    else {
        status = ERROR_SUCCESS;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Discarding unknown gum request %1!u!\n",
            Context
            );
    }

    return(status);

}  // NmpUpdateGumHandler


DWORD
NmpMembershipInit(
    VOID
    )
{
    DWORD           status;


    ClRtlLogPrint(LOG_NOISE,"[NM] Initializing membership...\n");

    InitializeListHead(&NmpLeaderChangeWaitList);

    //
    // Initialize membership engine.
    //
    status = MMInit(
                 NmLocalNodeId,
                 NmMaxNodes,
                 NmpNodeChange,
                 NmpCheckQuorumEventHandler,
                 NmpHoldIoEventHandler,
                 NmpResumeIoEventHandler,
                 NmpMsgCleanup1,
                 NmpMsgCleanup2,
                 NmpHaltEventHandler,
                 NmpJoinFailed,
                 NmpMultiNodeDownEventHandler
                 );

    if (status != MM_OK) {
        status = MMMapStatusToDosError(status);
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Membership initialization failed, status %1!u!.\n",
            status
            );
        return(status);
    }

    NmpMembershipCleanupOk = TRUE;

    ClRtlLogPrint(LOG_NOISE,"[NM] Membership initialization complete.\n");

    return(ERROR_SUCCESS);

}  // NmpMembershipInit


VOID
NmpMembershipShutdown(
    VOID
    )
{
    if (NmpMembershipCleanupOk) {
        ClRtlLogPrint(LOG_NOISE,"[NM] Shutting down membership...\n");

        MMShutdown();

        NmpMembershipCleanupOk = FALSE;

        ClRtlLogPrint(LOG_NOISE,"[NM] Membership shutdown complete.\n");
    }

    return;

}  // NmpMembershipShutdown


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\nm\network.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    network.c

Abstract:

    Implements the Node Manager's network management routines.

Author:

    Mike Massa (mikemas) 7-Nov-1996


Revision History:

--*/


#include "nmp.h"


/////////////////////////////////////////////////////////////////////////////
//
// Data
//
/////////////////////////////////////////////////////////////////////////////

ULONG                  NmpNextNetworkShortId = 0;
LIST_ENTRY             NmpNetworkList = {NULL, NULL};
LIST_ENTRY             NmpInternalNetworkList = {NULL, NULL};
LIST_ENTRY             NmpDeletedNetworkList = {NULL, NULL};
DWORD                  NmpNetworkCount = 0;
DWORD                  NmpInternalNetworkCount = 0;
DWORD                  NmpClientNetworkCount = 0;
BOOLEAN                NmpIsConnectivityReportWorkerRunning = FALSE;
BOOLEAN                NmpNeedConnectivityReport = FALSE;
CLRTL_WORK_ITEM        NmpConnectivityReportWorkItem;


RESUTIL_PROPERTY_ITEM
NmpNetworkProperties[] =
    {
        {
            L"Id", NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            0,
            FIELD_OFFSET(NM_NETWORK_INFO, Id)
        },
        {
            CLUSREG_NAME_NET_NAME, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            0,
            FIELD_OFFSET(NM_NETWORK_INFO, Name)
        },
        {
            CLUSREG_NAME_NET_DESC, NULL, CLUSPROP_FORMAT_SZ,
            (DWORD_PTR) NmpNullString, 0, 0,
            0,
            FIELD_OFFSET(NM_NETWORK_INFO, Description)
        },
        {
            CLUSREG_NAME_NET_ROLE, NULL, CLUSPROP_FORMAT_DWORD,
            ClusterNetworkRoleClientAccess,
            ClusterNetworkRoleNone,
            ClusterNetworkRoleInternalAndClient,
            0,
            FIELD_OFFSET(NM_NETWORK_INFO, Role)
        },
        {
            CLUSREG_NAME_NET_PRIORITY, NULL, CLUSPROP_FORMAT_DWORD,
            0, 0, 0xFFFFFFFF,
            0,
            FIELD_OFFSET(NM_NETWORK_INFO, Priority)
        },
        {
            CLUSREG_NAME_NET_TRANSPORT, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            0,
            FIELD_OFFSET(NM_NETWORK_INFO, Transport)
        },
        {
            CLUSREG_NAME_NET_ADDRESS, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            0,
            FIELD_OFFSET(NM_NETWORK_INFO, Address)
        },
        {
            CLUSREG_NAME_NET_ADDRESS_MASK, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            0,
            FIELD_OFFSET(NM_NETWORK_INFO, AddressMask)
        },
        {
            0
        }
    };

/////////////////////////////////////////////////////////////////////////////
//
// Initialization & cleanup routines
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmpInitializeNetworks(
    VOID
    )
/*++

Routine Description:

    Initializes network resources.

Arguments:

    None.

Return Value:

   A Win32 status value.

--*/

{
    DWORD                       status;
    OM_OBJECT_TYPE_INITIALIZE   networkTypeInitializer;


    ClRtlLogPrint(LOG_NOISE,"[NM] Initializing networks.\n");

    //
    // Create the network object type
    //
    ZeroMemory(&networkTypeInitializer, sizeof(OM_OBJECT_TYPE_INITIALIZE));
    networkTypeInitializer.ObjectSize = sizeof(NM_NETWORK);
    networkTypeInitializer.Signature = NM_NETWORK_SIG;
    networkTypeInitializer.Name = L"Network";
    networkTypeInitializer.DeleteObjectMethod = &NmpDestroyNetworkObject;

    status = OmCreateType(ObjectTypeNetwork, &networkTypeInitializer);

    if (status != ERROR_SUCCESS) {
        WCHAR  errorString[12];
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent1(LOG_CRITICAL, CS_EVENT_ALLOCATION_FAILURE, errorString);
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Unable to create network object type, status %1!u!\n",
            status
            );
        return(status);
    }

    return(status);

}  // NmpInitializeNetworks


VOID
NmpCleanupNetworks(
    VOID
    )
/*++

Routine Description:

    Destroys all existing network resources.

Arguments:

    None.

Return Value:

   None.

--*/

{
    PNM_NETWORK  network;
    PLIST_ENTRY  entry;
    DWORD        status;


    ClRtlLogPrint(LOG_NOISE,"[NM] Network cleanup starting...\n");

    //
    // Now clean up all the network objects.
    //
    NmpAcquireLock();

    while (!IsListEmpty(&NmpNetworkList)) {

        entry = NmpNetworkList.Flink;

        network = CONTAINING_RECORD(entry, NM_NETWORK, Linkage);

        CL_ASSERT(NM_OM_INSERTED(network));

        NmpDeleteNetworkObject(network, FALSE);
    }

    NmpCleanupMulticast();

    NmpReleaseLock();

    ClRtlLogPrint(LOG_NOISE,"[NM] Network cleanup complete\n");

    return;

}  // NmpCleanupNetworks


/////////////////////////////////////////////////////////////////////////////
//
// Top-level routines called during network configuration
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmpCreateNetwork(
    IN RPC_BINDING_HANDLE    JoinSponsorBinding,
    IN PNM_NETWORK_INFO      NetworkInfo,
    IN PNM_INTERFACE_INFO2   InterfaceInfo
    )
/*++

Notes:

    Must not be called with NM lock held.

--*/
{
    DWORD            status;


    if (JoinSponsorBinding != NULL) {
        //
        // We are joining a cluster. Ask the sponsor to add the definition
        // to the cluster database. The sponsor will also prompt all active
        // nodes to instantiate a corresponding object. The object will be
        // instantiated locally later in the join process.
        //
        status = NmRpcCreateNetwork2(
                     JoinSponsorBinding,
                     NmpJoinSequence,
                     NmLocalNodeIdString,
                     NetworkInfo,
                     InterfaceInfo
                     );
    }
    else if (NmpState == NmStateOnlinePending) {
        HLOCALXSACTION   xaction;

        //
        // We are forming a cluster. Add the definitions to the database.
        // The corresponding object will be created later in
        // the form process.
        //

        //
        // Start a transaction - this must be done before acquiring the
        //                       NM lock.
        //
        xaction = DmBeginLocalUpdate();

        if (xaction == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Failed to start a transaction, status %1!u!\n",
                status
                );
            return(status);
        }

        status = NmpCreateNetworkDefinition(NetworkInfo, xaction);

        if (status == ERROR_SUCCESS) {
            status = NmpCreateInterfaceDefinition(InterfaceInfo, xaction);
        }

        //
        // Complete the transaction - this must be done after releasing
        //                            the NM lock.
        //
        if (status == ERROR_SUCCESS) {
            DmCommitLocalUpdate(xaction);
        }
        else {
            DmAbortLocalUpdate(xaction);
        }
    }
    else {
        //
        // We are online. This is a PnP update.
        //
        NmpAcquireLock();

        status = NmpGlobalCreateNetwork(NetworkInfo, InterfaceInfo);

        NmpReleaseLock();
    }

    return(status);

}  // NmpCreateNetwork

DWORD
NmpSetNetworkName(
    IN PNM_NETWORK_INFO     NetworkInfo
    )
/*++

Notes:

    Must not be called with NM lock held.

--*/
{
    DWORD            status;


    if (NmpState == NmStateOnlinePending) {
        HLOCALXSACTION   xaction;

        //
        // We are forming a cluster. The local connectoid name has
        // precedence. Fix the cluster network name stored in the
        // cluster database.
        //

        //
        // Start a transaction - this must be done before acquiring the
        //                       NM lock.
        //
        xaction = DmBeginLocalUpdate();

        if (xaction == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Failed to start a transaction, status %1!u!\n",
                status
                );
            return(status);
        }

        status = NmpSetNetworkNameDefinition(NetworkInfo, xaction);

        //
        // Complete the transaction - this must be done after releasing
        //                            the NM lock.
        //
        if (status == ERROR_SUCCESS) {
            DmCommitLocalUpdate(xaction);
        }
        else {
            DmAbortLocalUpdate(xaction);
        }
    }
    else {
        //
        // We are online. This is either a PnP update or we were called
        // back to indicate that a local connectoid name changed.
        // Issue a global update to set the cluster network name accordingly.
        //
        status = NmpGlobalSetNetworkName( NetworkInfo );
    }

    return(status);

}  // NmpSetNetworkName

/////////////////////////////////////////////////////////////////////////////
//
// Remote procedures called by joining nodes.
//
/////////////////////////////////////////////////////////////////////////////
error_status_t
s_NmRpcCreateNetwork(
    IN handle_t             IDL_handle,
    IN DWORD                JoinSequence,   OPTIONAL
    IN LPWSTR               JoinerNodeId,   OPTIONAL
    IN PNM_NETWORK_INFO     NetworkInfo,
    IN PNM_INTERFACE_INFO   InterfaceInfo1
    )
{
    DWORD                 status;
    NM_INTERFACE_INFO2    interfaceInfo2;


    //
    // Translate and call the V2.0 procedure. The NetIndex isn't used in this call.
    //
    CopyMemory(&interfaceInfo2, InterfaceInfo1, sizeof(NM_INTERFACE_INFO));
    interfaceInfo2.AdapterId = NmpUnknownString;
    interfaceInfo2.NetIndex = NmInvalidInterfaceNetIndex;

    status = s_NmRpcCreateNetwork2(
                 IDL_handle,
                 JoinSequence,
                 JoinerNodeId,
                 NetworkInfo,
                 &interfaceInfo2
                 );

    return(status);

}  // s_NmRpcCreateNetwork


error_status_t
s_NmRpcCreateNetwork2(
    IN handle_t              IDL_handle,
    IN DWORD                 JoinSequence,   OPTIONAL
    IN LPWSTR                JoinerNodeId,   OPTIONAL
    IN PNM_NETWORK_INFO      NetworkInfo,
    IN PNM_INTERFACE_INFO2   InterfaceInfo
    )
{
    DWORD  status = ERROR_SUCCESS;


    ClRtlLogPrint(LOG_NOISE, 
        "[NMJOIN] Received request to create new network %1!ws! for "
        "joining node.\n",
        NetworkInfo->Id
        );

    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)) {
        PNM_NODE joinerNode = NULL;

        if (lstrcmpW(JoinerNodeId, NmpInvalidJoinerIdString) != 0) {
            joinerNode = OmReferenceObjectById(
                             ObjectTypeNode,
                             JoinerNodeId
                             );

            if (joinerNode != NULL) {
                if ( (JoinSequence == NmpJoinSequence) &&
                     (NmpJoinerNodeId == joinerNode->NodeId) &&
                     (NmpSponsorNodeId == NmLocalNodeId) &&
                     !NmpJoinAbortPending
                   )
                {
                    CL_ASSERT(joinerNode->State == ClusterNodeJoining);
                    CL_ASSERT(NmpJoinerUp == FALSE);
                    CL_ASSERT(NmpJoinTimer != 0);

                    //
                    // Suspend the join timer while we are working on
                    // behalf of the joiner. This precludes an abort
                    // from occuring as well.
                    //
                    NmpJoinTimer = 0;
                }
                else {
                    status = ERROR_CLUSTER_JOIN_ABORTED;
                    ClRtlLogPrint(LOG_UNUSUAL, 
                        "[NMJOIN] CreateNetwork call for joining node %1!ws! "
                        "failed because the join was aborted.\n",
                        JoinerNodeId
                        );
                }
            }
            else {
                status = ERROR_CLUSTER_NODE_NOT_MEMBER;
                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[NMJOIN] CreateNetwork call for joining node %1!ws! "
                    "failed because the node is not a member of the "
                    "cluster.\n",
                    JoinerNodeId
                    );
            }
        }

        if (status == ERROR_SUCCESS) {

            status = NmpGlobalCreateNetwork(NetworkInfo, InterfaceInfo);

            if (joinerNode != NULL) {
                //
                // Verify that the join is still in progress
                //
                if ( (JoinSequence == NmpJoinSequence) &&
                     (NmpJoinerNodeId == joinerNode->NodeId)
                   )
                {
                    CL_ASSERT(joinerNode->State == ClusterNodeJoining);
                    CL_ASSERT(NmpJoinerUp == FALSE);
                    CL_ASSERT(NmpSponsorNodeId == NmLocalNodeId);
                    CL_ASSERT(NmpJoinTimer == 0);
                    CL_ASSERT(NmpJoinAbortPending == FALSE);

                    if (status == ERROR_SUCCESS) {
                        //
                        // Restart the join timer.
                        //
                        NmpJoinTimer = NM_JOIN_TIMEOUT;
                    }
                    else {
                        //
                        // Abort the join
                        //
                        NmpJoinAbort(status, joinerNode);
                    }
                }
                else {
                    status = ERROR_CLUSTER_JOIN_ABORTED;
                    ClRtlLogPrint(LOG_UNUSUAL, 
                        "[NMJOIN] CreateNetwork call for joining node %1!ws! "
                        "failed because the join was aborted.\n",
                        JoinerNodeId
                        );
                }
            }
        }

        if (joinerNode != NULL) {
            OmDereferenceObject(joinerNode);
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE, 
            "[NMJOIN] Not in valid state to process CreateNetwork request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

}  // s_NmRpcCreateNetwork2


error_status_t
s_NmRpcSetNetworkName(
    IN handle_t             IDL_handle,
    IN DWORD                JoinSequence,   OPTIONAL
    IN LPWSTR               JoinerNodeId,   OPTIONAL
    IN PNM_NETWORK_INFO     NetworkInfo
    )
{
    DWORD  status = ERROR_SUCCESS;


    ClRtlLogPrint(LOG_NOISE, 
        "[NMJOIN] Received request to set name of network %1!ws! from "
        "joining node %2!ws!.\n",
        NetworkInfo->Id,
        JoinerNodeId
        );

    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)) {
        PNM_NODE joinerNode = NULL;

        if (lstrcmpW(JoinerNodeId, NmpInvalidJoinerIdString) != 0) {
            joinerNode = OmReferenceObjectById(
                             ObjectTypeNode,
                             JoinerNodeId
                             );

            if (joinerNode != NULL) {
                if ( (JoinSequence == NmpJoinSequence) &&
                     (NmpJoinerNodeId == joinerNode->NodeId) &&
                     (NmpSponsorNodeId == NmLocalNodeId) &&
                     !NmpJoinAbortPending
                   )
                {
                    CL_ASSERT(joinerNode->State == ClusterNodeJoining);
                    CL_ASSERT(NmpJoinerUp == FALSE);
                    CL_ASSERT(NmpJoinTimer != 0);

                    //
                    // Suspend the join timer while we are working on
                    // behalf of the joiner. This precludes an abort
                    // from occuring as well.
                    //
                    NmpJoinTimer = 0;
                }
                else {
                    status = ERROR_CLUSTER_JOIN_ABORTED;
                    ClRtlLogPrint(LOG_UNUSUAL, 
                        "[NMJOIN] SetNetworkName call for joining node "
                        "%1!ws! failed because the join was aborted.\n",
                        JoinerNodeId
                        );
                }
            }
            else {
                status = ERROR_CLUSTER_NODE_NOT_MEMBER;
                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[NMJOIN] SetNetworkName call for joining node %1!ws! "
                    "failed because the node is not a member of the cluster.\n",
                    JoinerNodeId
                    );
            }
        }

        if (status == ERROR_SUCCESS) {

            status = NmpGlobalSetNetworkName( NetworkInfo );

            if (joinerNode != NULL) {
                //
                // Verify that the join is still in progress
                //
                if ( (JoinSequence == NmpJoinSequence) &&
                     (NmpJoinerNodeId == joinerNode->NodeId)
                   )
                {
                    CL_ASSERT(joinerNode->State == ClusterNodeJoining);
                    CL_ASSERT(NmpJoinerUp == FALSE);
                    CL_ASSERT(NmpSponsorNodeId == NmLocalNodeId);
                    CL_ASSERT(NmpJoinTimer == 0);
                    CL_ASSERT(NmpJoinAbortPending == FALSE);

                    if (status == ERROR_SUCCESS) {
                        //
                        // Restart the join timer.
                        //
                        NmpJoinTimer = NM_JOIN_TIMEOUT;
                    }
                    else {
                        //
                        // Abort the join
                        //
                        NmpJoinAbort(status, joinerNode);
                    }
                }
                else {
                    status = ERROR_CLUSTER_JOIN_ABORTED;
                    ClRtlLogPrint(LOG_UNUSUAL, 
                        "[NMJOIN] SetNetworkName call for joining node "
                        "%1!ws! failed because the join was aborted.\n",
                        JoinerNodeId
                        );
                }
            }
        }

        if (joinerNode != NULL) {
            OmDereferenceObject(joinerNode);
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE, 
            "[NMJOIN] Not in valid state to process SetNetworkName request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

}  // s_NmRpcSetNetworkName

error_status_t
s_NmRpcEnumNetworkDefinitions(
    IN  handle_t            IDL_handle,
    IN  DWORD               JoinSequence,   OPTIONAL
    IN  LPWSTR              JoinerNodeId,   OPTIONAL
    OUT PNM_NETWORK_ENUM *  NetworkEnum
    )
{
    DWORD    status = ERROR_SUCCESS;
    PNM_NODE joinerNode = NULL;


    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE, 
            "[NMJOIN] Supplying network information to joining node.\n"
            );

        if (lstrcmpW(JoinerNodeId, NmpInvalidJoinerIdString) != 0) {
            joinerNode = OmReferenceObjectById(
                             ObjectTypeNode,
                             JoinerNodeId
                             );

            if (joinerNode != NULL) {
                if ( (JoinSequence == NmpJoinSequence) &&
                     (NmpJoinerNodeId == joinerNode->NodeId) &&
                     (NmpSponsorNodeId == NmLocalNodeId) &&
                     !NmpJoinAbortPending
                   )
                {
                    CL_ASSERT(joinerNode->State == ClusterNodeJoining);
                    CL_ASSERT(NmpJoinerUp == FALSE);
                    CL_ASSERT(NmpJoinTimer != 0);

                    //
                    // Suspend the join timer while we are working on
                    // behalf of the joiner. This precludes an abort
                    // from occuring as well.
                    //
                    NmpJoinTimer = 0;
                }
                else {
                    status = ERROR_CLUSTER_JOIN_ABORTED;
                    ClRtlLogPrint(LOG_UNUSUAL, 
                        "[NMJOIN] EnumNetworkDefinitions call for joining "
                        "node %1!ws! failed because the join was aborted.\n",
                        JoinerNodeId
                        );
                }
            }
            else {
                status = ERROR_CLUSTER_NODE_NOT_MEMBER;
                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[NMJOIN] EnumNetworkDefinitions call for joining "
                    "node %1!ws! failed because the node is not a member "
                    "of the cluster.\n",
                    JoinerNodeId
                    );
            }
        }

        if (status == ERROR_SUCCESS) {
            status = NmpEnumNetworkObjects(NetworkEnum);

            if (joinerNode != NULL) {
                if (status == ERROR_SUCCESS) {
                    //
                    // Restart the join timer.
                    //
                    NmpJoinTimer = NM_JOIN_TIMEOUT;

                }
                else {
                    ClRtlLogPrint(LOG_CRITICAL, 
                        "[NMJOIN] Failed to enumerate network definitions, "
                        "status %1!u!.\n",
                        status
                        );

                    //
                    // Abort the join
                    //
                    NmpJoinAbort(status, joinerNode);
                }
            }
        }

        if (joinerNode != NULL) {
            OmDereferenceObject(joinerNode);
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE, 
            "[NMJOIN] Not in valid state to process EnumNetworkDefinitions "
            "request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

}  // s_NmRpcEnumNetworkDefinitions


error_status_t
s_NmRpcEnumNetworkAndInterfaceStates(
    IN  handle_t                    IDL_handle,
    IN  DWORD                       JoinSequence,
    IN  LPWSTR                      JoinerNodeId,
    OUT PNM_NETWORK_STATE_ENUM *    NetworkStateEnum,
    OUT PNM_INTERFACE_STATE_ENUM *  InterfaceStateEnum
    )
{
    DWORD     status = ERROR_SUCCESS;


    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)) {
        PNM_NODE  joinerNode = OmReferenceObjectById(
                                   ObjectTypeNode,
                                   JoinerNodeId
                                   );

        ClRtlLogPrint(LOG_NOISE, 
            "[NMJOIN] Supplying network and interface state information "
            "to joining node.\n"
            );

        if (joinerNode != NULL) {
            if ( (JoinSequence != NmpJoinSequence) ||
                 (NmpJoinerNodeId != joinerNode->NodeId) ||
                 (NmpSponsorNodeId != NmLocalNodeId) ||
                 NmpJoinAbortPending
               )
            {
                status = ERROR_CLUSTER_JOIN_ABORTED;
                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[NMJOIN] EnumNetworkAndInterfaceStates call for "
                    "joining node %1!ws! failed because the join was "
                    "aborted.\n",
                    JoinerNodeId
                    );
            }
            else {
                CL_ASSERT(joinerNode->State == ClusterNodeJoining);
                CL_ASSERT(NmpJoinerUp);
                CL_ASSERT(NmpJoinTimer == 0);
            }
        }
        else {
            status = ERROR_CLUSTER_NODE_NOT_MEMBER;
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NMJOIN] EnumNetworkAndInterfaceStates call for joining "
                "node %1!ws! failed because the node is not a member of "
                "the cluster.\n",
                JoinerNodeId
                );
        }

        if (status == ERROR_SUCCESS) {

            status = NmpEnumNetworkObjectStates(NetworkStateEnum);

            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_CRITICAL, 
                    "[NMJOIN] EnumNetworkAndInterfaceStates failed, "
                    "status %1!u!.\n",
                    status
                    );

                //
                // Abort the join
                //
                NmpJoinAbort(status, joinerNode);
            }

            status = NmpEnumInterfaceObjectStates(InterfaceStateEnum);

            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_CRITICAL, 
                    "[NMJOIN] EnumNetworkAndInterfaceStates failed, "
                    "status %1!u!.\n",
                    status
                    );

                //
                // Abort the join
                //
                NmpJoinAbort(status, joinerNode);

                NmpFreeNetworkStateEnum(*NetworkStateEnum);
                *NetworkStateEnum = NULL;
            }
        }

        OmDereferenceObject(joinerNode);

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE, 
            "[NMJOIN] Not in valid state to process "
            "EnumNetworkAndInterfaceStates request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

}  // s_NmRpcEnumNetworkAndInterfaceStates


/////////////////////////////////////////////////////////////////////////////
//
// Routines used to make global configuration changes when the node
// is online.
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmpGlobalCreateNetwork(
    IN PNM_NETWORK_INFO      NetworkInfo,
    IN PNM_INTERFACE_INFO2   InterfaceInfo
    )
/*++

Notes:

    Called with the NmpLock held.

--*/
{
    DWORD  status = ERROR_SUCCESS;
    DWORD  networkPropertiesSize;
    PVOID  networkProperties;


    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Issuing global update to create network %1!ws! and "
        "interface %2!ws!.\n",
        NetworkInfo->Id,
        InterfaceInfo->Id
        );

    //
    // Marshall the info structures into property lists.
    //
    status = NmpMarshallObjectInfo(
                 NmpNetworkProperties,
                 NetworkInfo,
                 &networkProperties,
                 &networkPropertiesSize
                 );

    if (status == ERROR_SUCCESS) {
        DWORD  interfacePropertiesSize;
        PVOID  interfaceProperties;

        status = NmpMarshallObjectInfo(
                     NmpInterfaceProperties,
                     InterfaceInfo,
                     &interfaceProperties,
                     &interfacePropertiesSize
                     );

        if (status == ERROR_SUCCESS) {
            NmpReleaseLock();

            //
            // Issue a global update to create the network
            //
            status = GumSendUpdateEx(
                         GumUpdateMembership,
                         NmUpdateCreateNetwork,
                         4,
                         networkPropertiesSize,
                         networkProperties,
                         sizeof(networkPropertiesSize),
                         &networkPropertiesSize,
                         interfacePropertiesSize,
                         interfaceProperties,
                         sizeof(interfacePropertiesSize),
                         &interfacePropertiesSize
                         );

            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_CRITICAL, 
                    "[NM] Global update to create network %1!ws! failed, "
                    "status %2!u!.\n",
                    NetworkInfo->Id,
                    status
                    );
            }

            NmpAcquireLock();

            MIDL_user_free(interfaceProperties);
        }
        else {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Failed to marshall properties for new interface "
                "%1!ws!, status %2!u!\n",
                InterfaceInfo->Id,
                status
                );
        }

        MIDL_user_free(networkProperties);
    }
    else {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to marshall properties for new network %1!ws!, "
            "status %2!u!\n",
            NetworkInfo->Id,
            status
            );
    }

    return(status);

} // NmpGlobalCreateNetwork


DWORD
NmpGlobalSetNetworkName(
    IN PNM_NETWORK_INFO NetworkInfo
    )

/*++

Routine Description:

    Changes the name of a network defined for the cluster.

Arguments:

    NetworkInfo - A pointer to info about the network to be modified.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

    Must not be called with NM lock held.

--*/

{
    DWORD  status = ERROR_SUCCESS;

    if (status == ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Processing request to set name for network %1!ws! "
            "to '%2!ws!'.\n",
            NetworkInfo->Id,
            NetworkInfo->Name
            );

        //
        // Issue a global update
        //
        status = GumSendUpdateEx(
                     GumUpdateMembership,
                     NmUpdateSetNetworkName,
                     2,
                     NM_WCSLEN(NetworkInfo->Id),
                     NetworkInfo->Id,
                     NM_WCSLEN( NetworkInfo->Name ),
                     NetworkInfo->Name
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Global update to set name of network %1!ws! "
                "failed, status %2!u!.\n",
                NetworkInfo->Id,
                status
                );
        }
    }
    else {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] New name parameter supplied for network %1!ws! is invalid\n",
            NetworkInfo->Id
            );
    }

    return(status);

}  // NmpGlobalSetNetworkName


DWORD
NmpGlobalSetNetworkAndInterfaceStates(
    PNM_NETWORK             Network,
    CLUSTER_NETWORK_STATE   NewNetworkState
    )
/*++

Notes:

    Called with NmpLock held and the Network referenced.

--*/
{
    DWORD            status;
    DWORD            i;
    LPCWSTR          networkId = OmObjectId(Network);
    DWORD            entryCount = Network->ConnectivityVector->EntryCount;
    DWORD            vectorSize = sizeof(NM_STATE_ENTRY) * entryCount;
    PNM_STATE_ENTRY  ifStateVector;


    ifStateVector = LocalAlloc(LMEM_FIXED, vectorSize);

    if (ifStateVector != NULL ) {

        for (i=0; i< entryCount; i++) {
            ifStateVector[i] = Network->StateWorkVector[i].State;
        }

        if (NmpState == NmStateOnline) {
            //
            // Issue a global state update for this network.
            //
            NmpReleaseLock();

            status = GumSendUpdateEx(
                         GumUpdateMembership,
                         NmUpdateSetNetworkAndInterfaceStates,
                         4,
                         NM_WCSLEN(networkId),
                         networkId,
                         sizeof(NewNetworkState),
                         &NewNetworkState,
                         vectorSize,
                         ifStateVector,
                         sizeof(entryCount),
                         &entryCount
                         );

            NmpAcquireLock();
        }
        else {
            CL_ASSERT(NmpState == NmStateOnlinePending);
            //
            // We're still in the form process. Bypass GUM.
            //
            NmpSetNetworkAndInterfaceStates(
                Network,
                NewNetworkState,
                ifStateVector,
                entryCount
                );

            status = ERROR_SUCCESS;
        }

        LocalFree(ifStateVector);
    }
    else {
        status = ERROR_NOT_ENOUGH_MEMORY;
    }

    return(status);

} // NmpGlobalSetNetworkAndInterfaceStates


/////////////////////////////////////////////////////////////////////////////
//
// Routines called by other cluster service components
//
/////////////////////////////////////////////////////////////////////////////
CLUSTER_NETWORK_STATE
NmGetNetworkState(
    IN  PNM_NETWORK  Network
    )
/*++

Routine Description:



Arguments:



Return Value:


Notes:

   Because the caller must have a reference on the object and the
   call is so simple, there is no reason to put the call through the
   EnterApi/LeaveApi dance.

--*/
{
    CLUSTER_NETWORK_STATE  state;


    NmpAcquireLock();

    state = Network->State;

    NmpReleaseLock();

    return(state);

} // NmGetNetworkState


DWORD
NmSetNetworkName(
    IN PNM_NETWORK   Network,
    IN LPCWSTR       Name
    )
/*++

Routine Description:

    Changes the name of a network defined for the cluster.

Arguments:

    Network - A pointer to the object for the network to be modified.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

    The network object must be referenced by the caller.

--*/

{
    DWORD  status = ERROR_SUCCESS;


    if (NmpEnterApi(NmStateOnline)) {
        LPCWSTR   networkId = OmObjectId(Network);
        DWORD     nameLength;


        //
        // Validate the name
        //
        try {
            nameLength = lstrlenW(Name);

            if (nameLength == 0) {
                status = ERROR_INVALID_PARAMETER;
            }
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            status = ERROR_INVALID_PARAMETER;
        }

        if (status == ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] Processing request to set name for network %1!ws! "
                "to %2!ws!.\n",
                networkId,
                Name
                );

            //
            // Issue a global update
            //
            status = GumSendUpdateEx(
                         GumUpdateMembership,
                         NmUpdateSetNetworkName,
                         2,
                         NM_WCSLEN(networkId),
                         networkId,
                         (nameLength + 1) * sizeof(WCHAR),
                         Name
                         );

            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_CRITICAL, 
                    "[NM] Global update to set name of network %1!ws! "
                    "failed, status %2!u!.\n",
                    networkId,
                    status
                    );
            }
        }
        else {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] New name parameter supplied for network %1!ws! "
                "is invalid\n",
                networkId
                );
        }

        NmpLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process SetNetworkName request.\n"
            );
    }

    return(status);

}  // NmSetNetworkName


DWORD
NmSetNetworkPriorityOrder(
    IN DWORD     NetworkCount,
    IN LPWSTR *  NetworkIdList
    )
/*++

Routine Description:

    Sets the priority ordering of internal networks.

Arguments:

    NetworkCount - Contains the count of items in NetworkIdList.

    NetworkIdList - A pointer to an array of pointers to unicode strings.
                    Each string contains the ID of one internal network.
                    The array is sorted in priority order. The highest
                    priority network is listed first in the array.

Return Value:

    ERROR_SUCCESS if the routine is successful.

    A Win32 error code othewise.

--*/
{
    DWORD  status = ERROR_SUCCESS;


    if (NetworkCount == 0) {
        return(ERROR_INVALID_PARAMETER);
    }

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Received request to set network priority order.\n"
        );

    if (NmpEnterApi(NmStateOnline)) {
        DWORD     i;
        DWORD     multiSzLength = 0;
        PVOID     multiSz = NULL;

        //
        // Marshall the network ID list into a MULTI_SZ.
        //
        for (i=0; i< NetworkCount; i++) {
            multiSzLength += NM_WCSLEN(NetworkIdList[i]);
        }

        multiSzLength += sizeof(UNICODE_NULL);

        multiSz = MIDL_user_allocate(multiSzLength);

        if (multiSz != NULL) {
            LPWSTR  tmp = multiSz;

            for (i=0; i< NetworkCount; i++) {
                lstrcpyW(tmp, NetworkIdList[i]);
                tmp += lstrlenW(NetworkIdList[i]) + 1;
            }

            *tmp = UNICODE_NULL;

            //
            // Issue a global update
            //
            status = GumSendUpdateEx(
                         GumUpdateMembership,
                         NmUpdateSetNetworkPriorityOrder,
                         1,
                         multiSzLength,
                         multiSz
                         );

            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_CRITICAL, 
                    "[NM] Global update to reprioritize networks failed, "
                    "status %1!u!.\n",
                    status
                    );
            }

            MIDL_user_free(multiSz);
        }
        else {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }

        NmpLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process a request to set the "
            "network priority order.\n"
            );
    }

    return(status);

}  // NmSetNetworkPriorityOrder


DWORD
NmEnumInternalNetworks(
    OUT LPDWORD         NetworkCount,
    OUT PNM_NETWORK *   NetworkList[]
    )
/*++

Routine Description:

    Returns a prioritized list of networks that are eligible to
    carry internal communication.

Arguments:

    NetworkCount - On output, contains the number of items in NetworkList.

    NetworkList - On output, points to an array of pointers to network
                  objects. The highest priority network is first in the
                  array. Each pointer in the array must be dereferenced
                  by the caller. The storage for the array must be
                  deallocated by the caller.

Return Value:

    ERROR_SUCCESS if the routine is successful.

    A Win32 error code othewise.

--*/
{
    DWORD  status;


    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)) {

        status = NmpEnumInternalNetworks(NetworkCount, NetworkList);

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process EnumInternalNetworks "
            "request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

}  // NmEnumInternalNetworks


DWORD
NmpEnumInternalNetworks(
    OUT LPDWORD         NetworkCount,
    OUT PNM_NETWORK *   NetworkList[]
    )
/*++

Routine Description:

    Returns a prioritized list of networks that are eligible to
    carry internal communication.

Arguments:

    NetworkCount - On output, contains the number of items in NetworkList.

    NetworkList - On output, points to an array of pointers to network
                  objects. The highest priority network is first in the
                  array. Each pointer in the array must be dereferenced
                  by the caller. The storage for the array must be
                  deallocated by the caller.

Return Value:

    ERROR_SUCCESS if the routine is successful.

    A Win32 error code othewise.

Notes:

    Called with NM Lock held.

--*/
{
    DWORD  status = ERROR_SUCCESS;


    if (NmpInternalNetworkCount > 0) {
        PNM_NETWORK *  networkList = LocalAlloc(
                                         LMEM_FIXED,
                                         ( sizeof(PNM_NETWORK) *
                                           NmpInternalNetworkCount)
                                         );

        if (networkList != NULL) {
            PNM_NETWORK   network;
            PLIST_ENTRY   entry;
            DWORD         networkCount = 0;

            //
            // The internal network list is sorted in priority order.
            // The highest priority network is at the head of the list.
            //
            for (entry = NmpInternalNetworkList.Flink;
                 entry != &NmpInternalNetworkList;
                 entry = entry->Flink
                )
            {
                network = CONTAINING_RECORD(
                              entry,
                              NM_NETWORK,
                              InternalLinkage
                              );

                CL_ASSERT(NmpIsNetworkForInternalUse(network));
                OmReferenceObject(network);
                networkList[networkCount++] = network;
            }

            CL_ASSERT(networkCount == NmpInternalNetworkCount);
            *NetworkCount = networkCount;
            *NetworkList = networkList;
        }
        else {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else {
        *NetworkCount = 0;
        *NetworkList = NULL;
    }

    return(status);

}  // NmpEnumInternalNetworks


DWORD
NmEnumNetworkInterfaces(
    IN  PNM_NETWORK       Network,
    OUT LPDWORD           InterfaceCount,
    OUT PNM_INTERFACE *   InterfaceList[]
    )
/*++

Routine Description:

    Returns the list of interfaces associated with a specified network.

Arguments:

    Network - A pointer to the network object for which to enumerate
              interfaces.

    InterfaceCount - On output, contains the number of items in InterfaceList.

    InterfaceList - On output, points to an array of pointers to interface
                    objects. Each pointer in the array must be dereferenced
                    by the caller. The storage for the array must be
                    deallocated by the caller.

Return Value:

    ERROR_SUCCESS if the routine is successful.

    A Win32 error code othewise.

--*/
{
    DWORD  status = ERROR_SUCCESS;


    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)) {
        if (Network->InterfaceCount > 0) {
            PNM_INTERFACE *  interfaceList = LocalAlloc(
                                                 LMEM_FIXED,
                                                 ( sizeof(PNM_INTERFACE) *
                                                   Network->InterfaceCount)
                                                 );

            if (interfaceList != NULL) {
                PNM_INTERFACE  netInterface;
                PLIST_ENTRY    entry;
                DWORD          i;

                for (entry = Network->InterfaceList.Flink, i=0;
                     entry != &(Network->InterfaceList);
                     entry = entry->Flink, i++
                    )
                {
                    netInterface = CONTAINING_RECORD(
                                       entry,
                                       NM_INTERFACE,
                                       NetworkLinkage
                                       );

                    OmReferenceObject(netInterface);
                    interfaceList[i] = netInterface;
                }

                *InterfaceCount = Network->InterfaceCount;
                *InterfaceList = interfaceList;
            }
            else {
                status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        else {
            *InterfaceCount = 0;
            *InterfaceList = NULL;
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Not in valid state to process EnumNetworkInterfaces "
            "request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

} // NmEnumNetworkInterfaces


/////////////////////////////////////////////////////////////////////////////
//
// Handlers for global updates
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmpUpdateCreateNetwork(
    IN BOOL     IsSourceNode,
    IN PVOID    NetworkPropertyList,
    IN LPDWORD  NetworkPropertyListSize,
    IN PVOID    InterfacePropertyList,
    IN LPDWORD  InterfacePropertyListSize
    )
/*++

Routine Description:

    Global update handler for creating a new network. The network
    definition is read from the cluster database, and a corresponding
    object is instantiated. The cluster transport is also updated if
    necessary.

Arguments:

    IsSourceNode  - Set to TRUE if this node is the source of the update.
                    Set to FALSE otherwise.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

    This routine must not be called with NM lock held.

--*/
{
    DWORD                  status;
    NM_NETWORK_INFO        networkInfo;
    NM_INTERFACE_INFO2     interfaceInfo;
    PNM_NETWORK            network = NULL;
    PNM_INTERFACE          netInterface = NULL;
    HLOCALXSACTION         xaction = NULL;
    BOOLEAN                isInternalNetwork = FALSE;
    BOOLEAN                isLockAcquired = FALSE;
    CL_NODE_ID             joinerNodeId;


    if (!NmpEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process CreateNetwork update.\n"
            );
        return(ERROR_NODE_NOT_AVAILABLE);
    }

    //
    // Unmarshall the property lists.
    //
    ZeroMemory(&networkInfo, sizeof(networkInfo));
    ZeroMemory(&interfaceInfo, sizeof(interfaceInfo));

    status = ClRtlVerifyPropertyTable(
                 NmpNetworkProperties,
                 NULL,    // Reserved
                 FALSE,   // Don't allow unknowns
                 NetworkPropertyList,
                 *NetworkPropertyListSize,
                 (LPBYTE) &networkInfo
                 );

    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint( LOG_CRITICAL, 
            "[NM] Failed to unmarshall properties for new network, "
            "status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    status = ClRtlVerifyPropertyTable(
                 NmpInterfaceProperties,
                 NULL,    // Reserved
                 FALSE,   // Don't allow unknowns
                 InterfacePropertyList,
                 *InterfacePropertyListSize,
                 (LPBYTE) &interfaceInfo
                 );

    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint( LOG_CRITICAL, 
            "[NM] Failed to unmarshall properties for new interface, "
            "status %1!u!.\n",
            status
            );
        goto error_exit;
    }


    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Received update to create network %1!ws! & interface %2!ws!.\n",
        networkInfo.Id,
        interfaceInfo.Id
        );

    //
    // Start a transaction - this must be done before acquiring the NM lock.
    //
    xaction = DmBeginLocalUpdate();

    if (xaction == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to begin a transaction, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    NmpAcquireLock(); isLockAcquired = TRUE;

    //
    // Fix up the network's priority, if needed.
    //
    if (networkInfo.Role & ClusterNetworkRoleInternalUse) {
        CL_ASSERT(networkInfo.Priority == 0xFFFFFFFF);

        //
        // The network's priority is one greater than that of the lowest
        // priority network already in the internal network list.
        //
        if (IsListEmpty(&NmpInternalNetworkList)) {
            networkInfo.Priority = 1;
        }
        else {
            PNM_NETWORK network = CONTAINING_RECORD(
                                      NmpInternalNetworkList.Blink,
                                      NM_NETWORK,
                                      InternalLinkage
                                      );

            CL_ASSERT(network->Priority != 0);
            CL_ASSERT(network->Priority != 0xFFFFFFFF);

            networkInfo.Priority = network->Priority + 1;
        }

        isInternalNetwork = TRUE;
    }

    //
    // Update the database.
    //
    status = NmpCreateNetworkDefinition(&networkInfo, xaction);

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    status = NmpCreateInterfaceDefinition(&interfaceInfo, xaction);

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    joinerNodeId = NmpJoinerNodeId;

    NmpReleaseLock(); isLockAcquired = FALSE;

    network = NmpCreateNetworkObject(&networkInfo);

    if (network == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to create object for network %1!ws!, "
            "status %2!u!.\n",
            networkInfo.Id,
            status
            );
        goto error_exit;
    }

    netInterface = NmpCreateInterfaceObject(
                       &interfaceInfo,
                       TRUE   // Do retry on failure
                       );

#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailNmCreateNetwork) {
        NmpAcquireLock();
        NmpDeleteInterfaceObject(netInterface, FALSE); netInterface = NULL;
        NmpReleaseLock();
        SetLastError(999999);
    }
#endif

    NmpAcquireLock(); isLockAcquired = TRUE;

    if (netInterface == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to create object for interface %1!ws!, "
            "status %2!u!.\n",
            interfaceInfo.Id,
            status
            );

        NmpDeleteNetworkObject(network, FALSE);
        OmDereferenceObject(network);

        goto error_exit;
    }

    //
    // If a node happens to be joining right now, flag the fact that
    // it is now out of synch with the cluster config.
    //
    if ( ( (joinerNodeId != ClusterInvalidNodeId) &&
           (netInterface->Node->NodeId != joinerNodeId)
         ) ||
         ( (NmpJoinerNodeId != ClusterInvalidNodeId) &&
           (netInterface->Node->NodeId != NmpJoinerNodeId)
         )
       )
    {
        NmpJoinerOutOfSynch = TRUE;
    }

    ClusterEvent(CLUSTER_EVENT_NETWORK_ADDED, network);
    ClusterEvent(CLUSTER_EVENT_NETINTERFACE_ADDED, netInterface);

    if (isInternalNetwork) {
        NmpIssueClusterPropertyChangeEvent();
    }

    OmDereferenceObject(netInterface);
    OmDereferenceObject(network);

    CL_ASSERT(status == ERROR_SUCCESS);

error_exit:

    if (isLockAcquired) {
        NmpLockedLeaveApi();
        NmpReleaseLock();
    }
    else {
        NmpLeaveApi();
    }

    if (xaction != NULL) {
        //
        // Complete the transaction - this must be done after releasing
        //                            the NM lock.
        //
        if (status == ERROR_SUCCESS) {
            DmCommitLocalUpdate(xaction);
        }
        else {
            DmAbortLocalUpdate(xaction);
        }
    }

    ClNetFreeNetworkInfo(&networkInfo);
    ClNetFreeInterfaceInfo(&interfaceInfo);

    return(status);

} // NmpUpdateCreateNetwork


DWORD
NmpUpdateSetNetworkName(
    IN BOOL     IsSourceNode,
    IN LPWSTR   NetworkId,
    IN LPWSTR   NewNetworkName
    )
/*++

Routine Description:

    Global update handler for setting the name of a network.

Arguments:

    IsSourceNode  - Set to TRUE if this node is the source of the update.
                    Set to FALSE otherwise.

    NetworkId - A pointer to a unicode string containing the ID of the
                  network to update.

    NewNetworkName - A pointer to a unicode string containing the new network name.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

    This routine must not be called with NM lock held.

--*/
{
    DWORD             status;
    DWORD             i;
    PLIST_ENTRY       entry;
    HLOCALXSACTION    xaction = NULL;
    HDMKEY            networkKey;
    HDMKEY            netInterfaceKey;
    PNM_NETWORK       network = NULL;
    PNM_INTERFACE     netInterface;
    LPCWSTR           netInterfaceId;
    LPCWSTR           netInterfaceName;
    LPCWSTR           networkName;
    LPCWSTR           nodeName;
    LPWSTR            oldNetworkName = NULL;
    LPWSTR *          oldNameVector = NULL;
    LPWSTR *          newNameVector = NULL;
    BOOLEAN           isLockAcquired = FALSE;
    DWORD             interfaceCount;


    if (!NmpEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process SetNetworkName update.\n"
            );
        return(ERROR_NODE_NOT_AVAILABLE);
    }

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Received update to set the name for network %1!ws! "
        "to '%2!ws!'.\n",
        NetworkId,
        NewNetworkName
        );

    //
    // Find the network's object
    //
    network = OmReferenceObjectById(ObjectTypeNetwork, NetworkId);

    if (network == NULL) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Unable to find network %1!ws!.\n",
            NetworkId
            );
        status = ERROR_CLUSTER_NETWORK_NOT_FOUND;
        goto error_exit;
    }

    //
    // Start a transaction - this must be done before acquiring the NM lock.
    //
    xaction = DmBeginLocalUpdate();

    if (xaction == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to begin a transaction, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    NmpAcquireLock(); isLockAcquired = TRUE;

    //
    // compare the names. If the same, return success
    //
    if ( _wcsicmp( OmObjectName( network ), NewNetworkName ) == 0 ) {
        ClRtlLogPrint(LOG_NOISE, "[NM] Network name does not need changing.\n");

        status = ERROR_SUCCESS;
        goto error_exit;
    }

    networkName = OmObjectName(network);

    oldNetworkName = LocalAlloc(LMEM_FIXED, NM_WCSLEN(networkName));

    if (oldNetworkName == NULL) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to allocate memory for network %1!ws! name change!\n",
            NetworkId
            );
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    wcscpy(oldNetworkName, networkName);

    //
    // Update the database.
    //
    // This processing can always be undone on error.
    //
    networkKey = DmOpenKey(DmNetworksKey, NetworkId, KEY_WRITE);

    if (networkKey == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to open database key for network %1!ws!, "
            "status %2!u!\n",
            NetworkId,
            status
            );
        goto error_exit;
    }

    status = DmLocalSetValue(
                 xaction,
                 networkKey,
                 CLUSREG_NAME_NET_NAME,
                 REG_SZ,
                 (CONST BYTE *) NewNetworkName,
                 NM_WCSLEN(NewNetworkName)
                 );

    DmCloseKey(networkKey);

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Set of name value failed for network %1!ws!, "
            "status %2!u!.\n",
            NetworkId,
            status
            );
        goto error_exit;
    }

    //
    // Update the names of all of the interfaces on this network
    //
    interfaceCount = network->InterfaceCount;

    oldNameVector = LocalAlloc(
                        LMEM_FIXED | LMEM_ZEROINIT,
                        interfaceCount * sizeof(LPWSTR)
                        );

    newNameVector = LocalAlloc(
                        LMEM_FIXED | LMEM_ZEROINIT,
                        interfaceCount * sizeof(LPWSTR)
                        );

    if ((oldNameVector == NULL) || (newNameVector == NULL)) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to allocate memory for net interface name change.\n"
            );
        goto error_exit;
    }

    for (entry = network->InterfaceList.Flink, i = 0;
         entry != &(network->InterfaceList);
         entry = entry->Flink, i++
        )
    {
        netInterface = CONTAINING_RECORD(entry, NM_INTERFACE, NetworkLinkage);
        netInterfaceId = OmObjectId(netInterface);
        netInterfaceName = OmObjectName(netInterface);
        nodeName = OmObjectName(netInterface->Node);

        oldNameVector[i] = LocalAlloc(
                               LMEM_FIXED,
                               NM_WCSLEN(netInterfaceName)
                               );

        newNameVector[i] = ClNetMakeInterfaceName(
                               NULL,
                               (LPWSTR) nodeName,
                               NewNetworkName
                               );

        if ((oldNameVector[i] == NULL) || (newNameVector[i] == NULL)) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Failed to allocate memory for net interface name "
                "change.\n"
                );
            goto error_exit;
        }

        wcscpy(oldNameVector[i], netInterfaceName);

        netInterfaceKey = DmOpenKey(
                              DmNetInterfacesKey,
                              netInterfaceId,
                              KEY_WRITE
                              );

        if (netInterfaceKey == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Failed to open database key for net interface "
                "%1!ws!, status %2!u!\n",
                netInterfaceId,
                status
                );
            goto error_exit;
        }

        status = DmLocalSetValue(
                     xaction,
                     netInterfaceKey,
                     CLUSREG_NAME_NETIFACE_NAME,
                     REG_SZ,
                     (CONST BYTE *) newNameVector[i],
                     NM_WCSLEN(newNameVector[i])
                     );

        DmCloseKey(netInterfaceKey);

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Set of name value failed for net interface %1!ws!, "
                "status %2!u!.\n",
                netInterfaceId,
                status
                );
            goto error_exit;
        }
    }

    //
    // Update the in-memory objects.
    //
    // This processing may not be undoable on error.
    //

    //
    // Update name of the network
    //
    status = OmSetObjectName(network, NewNetworkName);

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to change name for network %1!ws!, status %2!u!\n",
            NetworkId,
            status
            );
        goto error_exit;
    }

    //
    // Update the names of all of the interfaces on the network.
    //
    for (entry = network->InterfaceList.Flink, i = 0;
         entry != &(network->InterfaceList);
         entry = entry->Flink, i++
        )
    {
        netInterface = CONTAINING_RECORD(entry, NM_INTERFACE, NetworkLinkage);
        netInterfaceId = OmObjectId(netInterface);

        status = OmSetObjectName(netInterface, newNameVector[i]);

        if (status != ERROR_SUCCESS) {
            //
            // Try to undo what has already been done. If we fail, we must
            // commit suicide to preserve consistency.
            //
            DWORD        j;
            PLIST_ENTRY  entry2;
            DWORD        undoStatus;

            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Failed to change name for net interface %1!ws!, "
                "status %2!u!\n",
                netInterfaceId,
                status
                );

            //
            // Undo the update of the network name
            //
            undoStatus = OmSetObjectName(network, oldNetworkName);

            if (undoStatus != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_CRITICAL, 
                    "[NM] Failed to undo change of name for network %1!ws!, "
                    "status %2!u!\n",
                    NetworkId,
                    undoStatus
                    );
                CsInconsistencyHalt(undoStatus);
            }

            //
            // Undo update of network interface names
            //
            for (j = 0, entry2 = network->InterfaceList.Flink;
                 j < i;
                 j++, entry2 = entry2->Flink
                )
            {
                netInterface = CONTAINING_RECORD(
                                   entry2,
                                   NM_INTERFACE,
                                   NetworkLinkage
                                   );

                netInterfaceId = OmObjectId(netInterface);

                undoStatus = OmSetObjectName(netInterface, oldNameVector[i]);

                if (undoStatus != ERROR_SUCCESS) {
                    ClRtlLogPrint(LOG_CRITICAL, 
                        "[NM] Failed to undo change of name for net "
                        "interface %1!ws!, status %2!u!\n",
                        netInterfaceId,
                        undoStatus
                        );
                    CsInconsistencyHalt(undoStatus);
                }
            }

            goto error_exit;
        }
    }

    //
    // Set the corresponding connectoid object name if necessary.
    //
    if (network->LocalInterface != NULL) {
        INetConnection *  connectoid;
        LPWSTR            connectoidName;
        DWORD             tempStatus;

        connectoid = ClRtlFindConnectoidByGuid(
                         network->LocalInterface->AdapterId
                         );

        if (connectoid != NULL) {
            connectoidName = ClRtlGetConnectoidName(connectoid);

            if (connectoidName != NULL) {
                if (lstrcmpW(connectoidName, NewNetworkName) != 0) {
                    tempStatus = ClRtlSetConnectoidName(
                                     connectoid,
                                     NewNetworkName
                                     );

                    if (tempStatus != ERROR_SUCCESS) {
                        ClRtlLogPrint(LOG_UNUSUAL, 
                            "[NM] Failed to set name of Network Connection "
                            "Object for interface on cluster network %1!ws! "
                            "(%2!ws!), status %3!u!\n",
                            oldNetworkName,
                            NetworkId,
                            tempStatus
                            );
                    }
                }
            }
            else {
                tempStatus = GetLastError();
                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[NM] Failed to query name of Network Connection Object "
                    "for interface on cluster network %1!ws! (%2!ws!), "
                    "status %3!u!\n",
                    oldNetworkName,
                    NetworkId,
                    tempStatus
                    );
            }

            INetConnection_Release( connectoid );
        }
        else {
            tempStatus = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] Failed to find Network Connection Object for "
                "interface on cluster network %1!ws! (%2!ws!), "
                "status %3!u!\n",
                oldNetworkName,
                NetworkId,
                tempStatus
                );
        }
    }

    //
    // Issue property change events.
    //
    ClusterEvent(CLUSTER_EVENT_NETWORK_PROPERTY_CHANGE, network);

    for (entry = network->InterfaceList.Flink;
         entry != &(network->InterfaceList);
         entry = entry->Flink
        )
    {
        netInterface = CONTAINING_RECORD(entry, NM_INTERFACE, NetworkLinkage);

        ClusterEvent(
            CLUSTER_EVENT_NETINTERFACE_PROPERTY_CHANGE,
            netInterface
            );
    }

    CL_ASSERT(status == ERROR_SUCCESS);

error_exit:

    if (isLockAcquired) {
        NmpLockedLeaveApi();
        NmpReleaseLock();
    }
    else {
        NmpLeaveApi();
    }

    if (xaction != NULL) {
        //
        // Complete the transaction - this must be done after releasing
        //                            the NM lock.
        //
        if (status == ERROR_SUCCESS) {
            DmCommitLocalUpdate(xaction);
        }
        else {
            DmAbortLocalUpdate(xaction);
        }
    }

    if (network != NULL) {
        OmDereferenceObject(network);

        if (oldNetworkName != NULL) {
            LocalFree(oldNetworkName);
        }

        if (oldNameVector != NULL) {
            for (i=0; i < interfaceCount; i++) {
                if (oldNameVector[i] == NULL) {
                    break;
                }

                LocalFree(oldNameVector[i]);
            }

            LocalFree(oldNameVector);
        }

        if (newNameVector != NULL) {
            for (i=0; i < interfaceCount; i++) {
                if (newNameVector[i] == NULL) {
                    break;
                }

                LocalFree(newNameVector[i]);
            }

            LocalFree(newNameVector);
        }
    }

    return(status);

} // NmpUpdateSetNetworkName


DWORD
NmpUpdateSetNetworkPriorityOrder(
    IN BOOL      IsSourceNode,
    IN LPCWSTR   NetworkIdList
    )
{
    DWORD             status = ERROR_SUCCESS;
    PNM_NETWORK       network;
    PLIST_ENTRY       entry;
    DWORD             matchCount=0;
    DWORD             networkCount=0;
    PNM_NETWORK *     networkList=NULL;
    DWORD             i;
    DWORD             multiSzLength;
    LPCWSTR           networkId;
    HLOCALXSACTION    xaction = NULL;
    BOOLEAN           isLockAcquired = FALSE;


    if (!NmpEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process SetNetworkPriorityOrder "
            "update.\n"
            );
        return(ERROR_NODE_NOT_AVAILABLE);
    }

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Received update to set network priority order.\n"
        );

    //
    // Unmarshall the MULTI_SZ
    //
    try {
        multiSzLength = ClRtlMultiSzLength(NetworkIdList);

        for (i=0; ; i++) {
            networkId = ClRtlMultiSzEnum(
                            NetworkIdList,
                            multiSzLength,
                            i
                            );

            if (networkId == NULL) {
                break;
            }

            networkCount++;
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Hit exception while parsing network ID list for "
            "priority change\n"
            );
        status = ERROR_INVALID_PARAMETER;
        goto error_exit;
    }

    if (networkCount == 0) {
        status = ERROR_INVALID_PARAMETER;
        goto error_exit;
    }

    networkList = LocalAlloc(
                      LMEM_ZEROINIT| LMEM_FIXED,
                      networkCount * sizeof(PNM_NETWORK)
                      );

    if (networkList == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    //
    // Start a transaction - this must be done before acquiring the NM lock.
    //
    xaction = DmBeginLocalUpdate();

    if (xaction == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to start a transaction, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    NmpAcquireLock(); isLockAcquired = TRUE;

    if (NmpJoinerNodeId != ClusterInvalidNodeId) {
        status = ERROR_CLUSTER_JOIN_IN_PROGRESS;
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Cannot set network priority order because a node is "
            "joining the cluster.\n"
            );
        goto error_exit;
    }

    for (i=0; i<networkCount; i++) {
        networkId = ClRtlMultiSzEnum(
                        NetworkIdList,
                        multiSzLength,
                        i
                        );

        CL_ASSERT(networkId != NULL);

        networkList[i] = OmReferenceObjectById(
                             ObjectTypeNetwork,
                             networkId
                             );

        if (networkList[i] == NULL) {
            goto error_exit;
        }
    }

    //
    // Verify that all of the networks specified are internal, and
    // that all of the internal networks are specified.
    //
    if (networkCount != NmpInternalNetworkCount) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Supplied network count %1!u! doesn't match internal "
            "network count %2!u!\n",
            networkCount,
            NmpInternalNetworkCount
            );
        status = ERROR_INVALID_PARAMETER;
        goto error_exit;
    }

    for (entry = NmpInternalNetworkList.Flink, matchCount = 0;
         entry != &NmpInternalNetworkList;
         entry = entry->Flink
        )
    {
        network = CONTAINING_RECORD(entry, NM_NETWORK, InternalLinkage);

        if (NmpIsNetworkForInternalUse(network)) {
            for (i=0; i<networkCount; i++) {
                if (network == networkList[i]) {
                    matchCount++;
                    break;
                }
            }

            if (i == networkCount) {
                //
                // This network is not in the list.
                //
                ClRtlLogPrint(LOG_CRITICAL, 
                    "[NM] Internal use network %1!ws! is not in priority "
                    "list\n",
                    (LPWSTR) OmObjectId(network)
                    );
                status = ERROR_INVALID_PARAMETER;
                goto error_exit;
            }
        }
    }

    if (matchCount != networkCount) {
        //
        // Some of the specified networks are not internal use.
        //
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Some non-internal use networks are in priority list\n"
            );
        status = ERROR_INVALID_PARAMETER;
        goto error_exit;
    }

    //
    // The list is kosher. Set the priorities.
    //
    status = NmpSetNetworkPriorityOrder(networkCount, networkList, xaction);

error_exit:

    if (isLockAcquired) {
        NmpLockedLeaveApi();
        NmpReleaseLock();
    }
    else {
        NmpLeaveApi();
    }

    if (xaction != NULL) {
        //
        // Complete the transaction - this must be done after releasing
        //                            the NM lock.
        //
        if (status == ERROR_SUCCESS) {
            DmCommitLocalUpdate(xaction);
        }
        else {
            DmAbortLocalUpdate(xaction);
        }
    }

    if (networkList != NULL) {
        for (i=0; i<networkCount; i++) {
            if (networkList[i] != NULL) {
                OmDereferenceObject(networkList[i]);
            }
        }

        LocalFree(networkList);
    }

    return(status);

}  // NmpUpdateSetNetworkPriorityOrder


DWORD
NmpSetNetworkPriorityOrder(
    IN DWORD           NetworkCount,
    IN PNM_NETWORK *   NetworkList,
    IN HLOCALXSACTION  Xaction
    )
/*++

Notes:

    Called with NM Lock held.

--*/
{
    DWORD             status = ERROR_SUCCESS;
    PNM_NETWORK       network;
    DWORD             i;
    LPCWSTR           networkId;
    HDMKEY            networkKey;
    DWORD             priority;


    //
    // Update the database first.
    //
    for (i=0, priority = 1; i<NetworkCount; i++, priority++) {
        network = NetworkList[i];
        networkId = OmObjectId(network);

        CL_ASSERT(NmpIsNetworkForInternalUse(network));

        if (network->Priority != priority) {
            networkKey = DmOpenKey(DmNetworksKey, networkId, KEY_WRITE);

            if (networkKey == NULL) {
                status = GetLastError();
                ClRtlLogPrint(LOG_CRITICAL, 
                    "[NM] Failed to open database key for network %1!ws!, "
                    "status %2!u!\n",
                    networkId,
                    status
                    );
                return(status);
            }

            status = DmLocalSetValue(
                         Xaction,
                         networkKey,
                         CLUSREG_NAME_NET_PRIORITY,
                         REG_DWORD,
                         (CONST BYTE *) &priority,
                         sizeof(priority)
                         );

            DmCloseKey(networkKey);

            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_CRITICAL, 
                    "[NM] Set of priority value failed for network %1!ws!, "
                    "status %2!u!.\n",
                    networkId,
                    status
                    );
                return(status);
            }
        }
    }

#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailNmSetNetworkPriorityOrder) {
        status = 999999;
        return(status);
    }
#endif

    //
    // Update the in-memory representation
    //
    InitializeListHead(&NmpInternalNetworkList);

    for (i=0, priority = 1; i<NetworkCount; i++, priority++) {
        network = NetworkList[i];
        networkId = OmObjectId(network);

        InsertTailList(
            &NmpInternalNetworkList,
            &(network->InternalLinkage)
            );

        if (network->Priority != priority) {
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Set priority for network %1!ws! to %2!u!.\n",
                networkId,
                priority
                );

            network->Priority = priority;

            //
            // If the local node is attached to this network, set its
            // priority in the cluster transport
            //
            if (NmpIsNetworkRegistered(network)) {
                status = ClusnetSetNetworkPriority(
                             NmClusnetHandle,
                             network->ShortId,
                             network->Priority
                             );

#ifdef CLUSTER_TESTPOINT
                TESTPT(TpFailNmSetNetworkPriorityOrder2) {
                    status = 999999;
                }
#endif
                if (status != ERROR_SUCCESS) {
                    //
                    // We can't easily abort here. We must either continue
                    // or commit suicide. We choose to continue and log an
                    // event.
                    //
                    WCHAR  string[16];

                    wsprintfW(&(string[0]), L"%u", status);

                    CsLogEvent2(
                        LOG_UNUSUAL,
                        NM_EVENT_SET_NETWORK_PRIORITY_FAILED,
                        OmObjectName(network),
                        string
                        );

                    ClRtlLogPrint(LOG_CRITICAL, 
                        "[NM] Cluster transport failed to set priority for "
                        "network %1!ws!, status %2!u!\n",
                        networkId,
                        status
                        );

                    status = ERROR_SUCCESS;
                }
            }
        }
    }

    CL_ASSERT(status == ERROR_SUCCESS);

    //
    // Issue a cluster property change event.
    //
    NmpIssueClusterPropertyChangeEvent();

    return(ERROR_SUCCESS);

} // NmpSetNetworkPriorityOrder


DWORD
NmpUpdateSetNetworkCommonProperties(
    IN BOOL     IsSourceNode,
    IN LPWSTR   NetworkId,
    IN UCHAR *  PropertyList,
    IN LPDWORD  PropertyListLength
    )
/*++

Routine Description:

    Global update handler for setting the common properties of a network.

Arguments:

    IsSourceNode  - Set to TRUE if this node is the source of the update.
                    Set to FALSE otherwise.

    NetworkId - A pointer to a unicode string containing the ID of the
                  network to update.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

--*/
{
    DWORD                    status = ERROR_SUCCESS;
    NM_NETWORK_INFO          networkInfo;
    PNM_NETWORK              network = NULL;
    HLOCALXSACTION           xaction = NULL;
    HDMKEY                   networkKey = NULL;
    DWORD                    descSize = 0;
    LPWSTR                   descBuffer = NULL;
    BOOLEAN                  propertyChanged = FALSE;
    BOOLEAN                  isLockAcquired = FALSE;


    if (!NmpEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process SetNetworkCommonProperties "
            "update.\n"
            );
        return(ERROR_NODE_NOT_AVAILABLE);
    }

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Received update to set common properties for network %1!ws!.\n",
        NetworkId
        );

    ZeroMemory(&networkInfo, sizeof(NM_NETWORK_INFO));

    //
    // Find the network's object
    //
    network = OmReferenceObjectById(ObjectTypeNetwork, NetworkId);

    if (network == NULL) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Unable to find network %1!ws!.\n",
            NetworkId
            );
        status = ERROR_CLUSTER_NETWORK_NOT_FOUND;
        goto error_exit;
    }

    //
    // Open the network's database key
    //
    networkKey = DmOpenKey(DmNetworksKey, NetworkId, KEY_WRITE);

    if (networkKey == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to open database key for network %1!ws!, "
            "status %2!u!\n",
            NetworkId,
            status
            );
        goto error_exit;
    }

    //
    // Start a transaction - this must be done before acquiring the NM lock.
    //
    xaction = DmBeginLocalUpdate();

    if (xaction == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to begin a transaction, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    NmpAcquireLock(); isLockAcquired = TRUE;

    if (NmpJoinerNodeId != ClusterInvalidNodeId) {
        status = ERROR_CLUSTER_JOIN_IN_PROGRESS;
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Cannot set network common properties because a node is "
            "joining the cluster.\n"
            );
        goto error_exit;
    }

    //
    // Validate the property list and convert it to a network params struct.
    //
    status = NmpNetworkValidateCommonProperties(
                 network,
                 PropertyList,
                 *PropertyListLength,
                 &networkInfo
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Property list validation failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    CL_ASSERT(network->Priority == networkInfo.Priority);
    CL_ASSERT(wcscmp(NetworkId, networkInfo.Id) == 0);
    CL_ASSERT(wcscmp(OmObjectName(network), networkInfo.Name) == 0);
    CL_ASSERT(wcscmp(network->Transport, networkInfo.Transport) == 0);
    CL_ASSERT(wcscmp(network->Address, networkInfo.Address) == 0);
    CL_ASSERT(wcscmp(network->AddressMask, networkInfo.AddressMask) == 0);

    //
    // Check if the network's description has changed.
    //
    if (wcscmp(network->Description, networkInfo.Description) != 0) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Setting description for network %1!ws! to %2!ws!.\n",
            NetworkId,
            networkInfo.Description
            );

        //
        // Allocate a buffer for the description string
        //
        descSize = NM_WCSLEN(networkInfo.Description);

        descBuffer = MIDL_user_allocate(descSize);

        if (descBuffer == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto error_exit;
        }

        RtlMoveMemory(descBuffer, networkInfo.Description, descSize);

        //
        // Update the database
        //
        status = DmLocalSetValue(
                     xaction,
                     networkKey,
                     CLUSREG_NAME_NET_DESC,
                     REG_SZ,
                     (CONST BYTE *) networkInfo.Description,
                     descSize
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Set of description value failed for network %1!ws!, "
                "status %2!u!.\n",
                NetworkId,
                status
                );
            goto error_exit;
        }

        //
        // Updating the network object is deferred until the transaction
        // commits.
        //

        propertyChanged = TRUE;
    }

#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailNmSetNetworkCommonProperties) {
        status = 999999;
        goto error_exit;
    }
#endif

    //
    // Check if the network's role has changed.
    //
    //
    // NOTE: This operation is not guaranteed to be reversible, so it must
    //       be the last thing we do in this routine. If it succeeds, the
    //       update must be committed.
    //
    if ( network->Role != ((CLUSTER_NETWORK_ROLE) networkInfo.Role) ) {
        status = NmpSetNetworkRole(
                     network,
                     networkInfo.Role,
                     xaction,
                     networkKey
                     );

        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }

        propertyChanged = TRUE;
    }

    if (propertyChanged) {
        //
        // Commit the updates to the network object in memory
        //
        if (descBuffer != NULL) {
            MIDL_user_free(network->Description);
            network->Description = descBuffer;
            descBuffer = NULL;
        }

        //
        // Issue a network property change event.
        //
        if (propertyChanged && (status == ERROR_SUCCESS)) {
            ClusterEvent(CLUSTER_EVENT_NETWORK_PROPERTY_CHANGE, network);
        }
    }

    CL_ASSERT(status == ERROR_SUCCESS);

error_exit:

    if (isLockAcquired) {
        NmpLockedLeaveApi();
        NmpReleaseLock();
    }
    else {
        NmpLeaveApi();
    }

    if (xaction != NULL) {
        //
        // Complete the transaction - this must be done after releasing
        //                            the NM lock.
        //
        if (propertyChanged && (status == ERROR_SUCCESS)) {
            DmCommitLocalUpdate(xaction);
        }
        else {
            DmAbortLocalUpdate(xaction);
        }
    }

    ClNetFreeNetworkInfo(&networkInfo);

    if (descBuffer != NULL) {
        MIDL_user_free(descBuffer);
    }

    if (networkKey != NULL) {
        DmCloseKey(networkKey);
    }

    if (network != NULL) {
        OmDereferenceObject(network);
    }

    return(status);

} // NmpUpdateSetNetworkCommonProperties


DWORD
NmpUpdateSetNetworkAndInterfaceStates(
    IN BOOL                        IsSourceNode,
    IN LPWSTR                      NetworkId,
    IN CLUSTER_NETWORK_STATE *     NewNetworkState,
    IN PNM_STATE_ENTRY             InterfaceStateVector,
    IN LPDWORD                     InterfaceStateVectorSize
    )
{
    DWORD             status = ERROR_SUCCESS;
    PNM_NETWORK       network;


    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Received update to set state for network %1!ws!.\n",
            NetworkId
            );

        //
        // Find the network's object
        //
        network = OmReferenceObjectById(ObjectTypeNetwork, NetworkId);

        if (network != NULL) {
            NmpSetNetworkAndInterfaceStates(
                network,
                *NewNetworkState,
                InterfaceStateVector,
                *InterfaceStateVectorSize
                );

            OmDereferenceObject(network);
        }
        else {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Unable to find network %1!ws!.\n",
                NetworkId
                );
            status = ERROR_CLUSTER_NETWORK_NOT_FOUND;
        }
    }
    else {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process SetNetworkAndInterfaceStates "
            "update.\n"
            );
        status = ERROR_NODE_NOT_AVAILABLE;
    }

    NmpLockedLeaveApi();

    NmpReleaseLock();

    return(status);

} // NmpUpdateSetNetworkAndInterfaceStates


/////////////////////////////////////////////////////////////////////////////
//
// Helper routines for updates
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmpSetNetworkRole(
    PNM_NETWORK            Network,
    CLUSTER_NETWORK_ROLE   NewRole,
    HLOCALXSACTION         Xaction,
    HDMKEY                 NetworkKey
    )
/*++

    Called with the NmpLock acquired.

    This operation is not guaranteed to be reversible, so this
    function is coded such that it either succeeds and makes the update
    or it fails and no update is made.

--*/
{
    DWORD                        status = ERROR_SUCCESS;
    CLUSTER_NETWORK_ROLE         oldRole = Network->Role;
    DWORD                        dwordNewRole = (DWORD) NewRole;
    LPCWSTR                      networkId = OmObjectId(Network);
    DWORD                        oldPriority = Network->Priority;
    DWORD                        newPriority = oldPriority;
    BOOLEAN                      internalNetworkListChanged = FALSE;


    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Changing role for network %1!ws! to %2!u!\n",
        networkId,
        NewRole
        );

    CL_ASSERT(NewRole != oldRole);
    CL_ASSERT(
        NmpValidateNetworkRoleChange(Network, NewRole) == ERROR_SUCCESS
        );

    //
    // First, make any registry updates since these can be
    // aborted by the caller.
    //

    //
    // Update the role property.
    //
    status = DmLocalSetValue(
                 Xaction,
                 NetworkKey,
                 CLUSREG_NAME_NET_ROLE,
                 REG_DWORD,
                 (CONST BYTE *) &dwordNewRole,
                 sizeof(DWORD)
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Set of role value failed for network %1!ws!, "
            "status %2!u!.\n",
            networkId,
            status
            );
        return(status);
    }

    //
    // Update the priority property, if needed.
    //
    if (oldRole & ClusterNetworkRoleInternalUse) {
        if (!(NewRole & ClusterNetworkRoleInternalUse)) {
            //
            // This network is no longer used for internal communication.
            // Invalidate its priority value.
            //
            newPriority = 0xFFFFFFFF;
            internalNetworkListChanged = TRUE;
        }
    }
    else if (NewRole & ClusterNetworkRoleInternalUse) {
        //
        // This network is now used for internal communication.
        // The network's priority is one greater than that of the lowest
        // (numerically highest) priority network already in the list.
        //
        if (IsListEmpty(&NmpInternalNetworkList)) {
            newPriority = 1;
        }
        else {
            PNM_NETWORK network = CONTAINING_RECORD(
                                      NmpInternalNetworkList.Blink,
                                      NM_NETWORK,
                                      InternalLinkage
                                      );

            CL_ASSERT(network->Priority != 0);
            CL_ASSERT(network->Priority != 0xFFFFFFFF);

            newPriority = network->Priority + 1;
        }

        internalNetworkListChanged = TRUE;
    }

    if (newPriority != oldPriority) {
        status = DmLocalSetValue(
                     Xaction,
                     NetworkKey,
                     CLUSREG_NAME_NET_PRIORITY,
                     REG_DWORD,
                     (CONST BYTE *) &newPriority,
                     sizeof(newPriority)
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Failed to set priority value for network %1!ws!, "
                "status %2!u!.\n",
                networkId,
                status
                );
            return(status);
        }
    }

    //
    // Update the network object. Some of the subsequent subroutine calls
    // depend on this.
    //
    Network->Role = NewRole;
    Network->Priority = newPriority;

    //
    // Do other housekeeping based on the change.
    //
    // Note that the housekeeping work is coded such that none of it needs
    // to be reversed if an error occurs.
    //
    if (NewRole == ClusterNetworkRoleNone) {
        PLIST_ENTRY              entry;
        PNM_INTERFACE            netInterface;

        //
        // Case 1: This network is no longer used for clustering.
        //
        if (NmpIsNetworkRegistered(Network)) {
            //
            // Delete the network from the cluster transport.
            // This will delete all of its interfaces as well.
            //
            NmpDeregisterNetwork(Network);

            ClRtlLogPrint(LOG_NOISE, 
                "[NM] No longer hearbeating on network %1!ws!.\n",
                networkId
                );
        }

        //
        // Invalidate the connectivity data for all interfaces on
        // the network.
        //
        for ( entry = Network->InterfaceList.Flink;
              entry != &(Network->InterfaceList);
              entry = entry->Flink
            )
        {
            netInterface = CONTAINING_RECORD(
                               entry,
                               NM_INTERFACE,
                               NetworkLinkage
                               );

            NmpSetInterfaceConnectivityData(
                Network,
                netInterface->NetIndex,
                ClusterNetInterfaceUnavailable
                );
        }

        //
        // Clean up tracking data.
        //
        if (oldRole & ClusterNetworkRoleInternalUse) {
            RemoveEntryList(&(Network->InternalLinkage));
            CL_ASSERT(NmpInternalNetworkCount > 0);
            NmpInternalNetworkCount--;
        }

        if (oldRole & ClusterNetworkRoleClientAccess) {
            CL_ASSERT(NmpClientNetworkCount > 0);
            NmpClientNetworkCount--;
        }

        //
        // Use the NT5 state logic.
        //
        if (NmpLeaderNodeId == NmLocalNodeId) {
            //
            // Schedule an immediate state update.
            //
            NmpScheduleNetworkStateRecalc(Network);
        }
    }
    else if (oldRole == ClusterNetworkRoleNone) {
        //
        // Case 2: This network is now used for clustering.
        //
        if (Network->LocalInterface != NULL) {
            //
            // Register this network with the cluster transport.
            //
            // Note that this action will trigger a connectivity report,
            // which will in turn trigger a state update under the NT5 logic.
            //
            status = NmpRegisterNetwork(
                         Network,
                         TRUE  // Do retry on failure
                         );

            if (status != ERROR_SUCCESS) {
                goto error_exit;
            }

            ClRtlLogPrint(LOG_NOISE, 
                "[NM] Now heartbeating on network %1!ws!.\n",
                networkId
                );
        }
        else if (NmpLeaderNodeId == NmLocalNodeId) {
            //
            // Schedule a delayed state update in case none of the other
            // nodes attached to this network are up right now.
            //
            NmpStartNetworkStateRecalcTimer(
                Network,
                NM_NET_STATE_RECALC_TIMEOUT
                );
        }

        //
        // Update tracking data.
        //
        if (NewRole & ClusterNetworkRoleInternalUse) {
            InsertTailList(
                &NmpInternalNetworkList,
                &(Network->InternalLinkage)
                );
            NmpInternalNetworkCount++;
        }

        if (NewRole & ClusterNetworkRoleClientAccess) {
            NmpClientNetworkCount++;
        }
    }
    else {
        //
        // Case 3: We are using the network in a different way now.
        //         Note that the network is already registered with
        //         the cluster transport and will remain so. As a result,
        //         there is no need to perform a state update.
        //

        //
        //         First, examine the former and new use of the
        //         network for internal communication, and make any
        //         necessary updates to the cluster transport.
        //
        if (oldRole & ClusterNetworkRoleInternalUse) {
            if (!(NewRole & ClusterNetworkRoleInternalUse)) {
                //
                // This network is no longer used for internal communication.
                // It is used for client access.
                //
                CL_ASSERT(NewRole & ClusterNetworkRoleClientAccess);

                if (NmpIsNetworkRegistered(Network)) {
                    //
                    // Restrict the network to heartbeats only.
                    //
                    status = ClusnetSetNetworkRestriction(
                                 NmClusnetHandle,
                                 Network->ShortId,
                                 TRUE,  // Network is restricted
                                 0
                                 );

                    if (status != ERROR_SUCCESS) {
                        ClRtlLogPrint(LOG_CRITICAL, 
                            "[NM] Failed to restrict network %1!ws!, "
                            "status %2!u!.\n",
                            networkId,
                            status
                            );
                        goto error_exit;
                    }
                }

                //
                // Update tracking data
                //
                RemoveEntryList(&(Network->InternalLinkage));
                CL_ASSERT(NmpInternalNetworkCount > 0);
                NmpInternalNetworkCount--;
            }
        }
        else {
            //
            // The network is now used for internal communication.
            //
            CL_ASSERT(NewRole & ClusterNetworkRoleInternalUse);

            if (NmpIsNetworkRegistered(Network)) {
                //
                // Clear the restriction and set the priority.
                //
                status = ClusnetSetNetworkRestriction(
                             NmClusnetHandle,
                             Network->ShortId,
                             FALSE,      // Network is not restricted
                             newPriority
                             );

                if (status != ERROR_SUCCESS) {
                    ClRtlLogPrint(LOG_CRITICAL, 
                        "[NM] Failed to unrestrict network %1!ws!, "
                        "status %2!u!.\n",
                        networkId,
                        status
                        );
                    goto error_exit;
                }
            }

            //
            // Update the tracking data
            //
            InsertTailList(
                &NmpInternalNetworkList,
                &(Network->InternalLinkage)
                );
            NmpInternalNetworkCount++;
        }

        //
        // Now update the remaining tracking data based on former and
        // current use of the network for client access.
        //

        if (oldRole & ClusterNetworkRoleClientAccess) {
            if (!NewRole & ClusterNetworkRoleClientAccess) {
                //
                // This network is no longer used for client access.
                //
                CL_ASSERT(NmpClientNetworkCount > 0);
                NmpClientNetworkCount--;
            }
        }
        else {
            //
            // This network is now used for client access.
            //
            CL_ASSERT(NewRole & ClusterNetworkRoleClientAccess);
            NmpClientNetworkCount++;
        }
    }

    if (internalNetworkListChanged) {
        NmpIssueClusterPropertyChangeEvent();
    }

    return(ERROR_SUCCESS);

error_exit:

    //
    // Undo the updates to the network object.
    //
    Network->Role = oldRole;
    Network->Priority = oldPriority;

    return(status);

}   // NmpSetNetworkRole


VOID
NmpSetNetworkAndInterfaceStates(
    IN PNM_NETWORK                 Network,
    IN CLUSTER_NETWORK_STATE       NewNetworkState,
    IN PNM_STATE_ENTRY             InterfaceStateVector,
    IN DWORD                       VectorSize
    )
/*++

Notes:

    Called with NmpLock held.

    Because NM_STATE_ENTRY is an unsigned type, while
    CLUSTER_NETINTERFACE_STATE is a signed type, and
    ClusterNetInterfaceStateUnknown is defined to be -1, we cannot cast
    from NM_STATE_ENTRY to CLUSTER_NETINTERFACE_STATE and preserve the
    value of ClusterNetInterfaceStateUnknown.

--*/
{
    PLIST_ENTRY     entry;
    PNM_INTERFACE   netInterface;
    PNM_NODE        node;
    DWORD           logLevel, logCode;
    DWORD           ifNetIndex;
    LPCWSTR         netInterfaceId;
    LPCWSTR         nodeName;
    LPCWSTR         networkName = OmObjectName(Network);
    LPCWSTR         networkId = OmObjectId(Network);


    //
    // Examine each interface on this network to see if its state
    // has changed.
    //
    for ( entry = Network->InterfaceList.Flink;
          entry != &(Network->InterfaceList);
          entry = entry->Flink
        )
    {
        netInterface = CONTAINING_RECORD(
                           entry,
                           NM_INTERFACE,
                           NetworkLinkage
                           );

        ifNetIndex = netInterface->NetIndex;
        netInterfaceId = OmObjectId(netInterface);
        node = netInterface->Node;
        nodeName = OmObjectName(node);

        if ( (ifNetIndex < VectorSize) &&
             (InterfaceStateVector[ifNetIndex] !=
              (NM_STATE_ENTRY) netInterface->State
             )
           )
        {
            BOOLEAN          logEvent = FALSE;
            CLUSTER_EVENT    eventCode = 0;
            NM_STATE_ENTRY   newState = InterfaceStateVector[ifNetIndex];


            if (newState == (NM_STATE_ENTRY) ClusterNetInterfaceUnavailable) {
                //
                // Either the node has gone down or the network has been
                // disabled.
                //
                netInterface->State = ClusterNetInterfaceUnavailable;
                eventCode = CLUSTER_EVENT_NETINTERFACE_UNAVAILABLE;

                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[NM] Interface %1!ws! is unavailable (node: %2!ws!, "
                    "network: %3!ws!).\n",
                    netInterfaceId,
                    nodeName,
                    networkName
                    );
            }
            else if (newState == (NM_STATE_ENTRY) ClusterNetInterfaceUp) {
                netInterface->State = ClusterNetInterfaceUp;
                eventCode = CLUSTER_EVENT_NETINTERFACE_UP;
                logCode = NM_EVENT_CLUSTER_NETINTERFACE_UP;
                logLevel = LOG_NOISE;
                logEvent = TRUE;

                ClRtlLogPrint(LOG_NOISE, 
                    "[NM] Interface %1!ws! is up (node: %2!ws!, "
                    "network: %3!ws!).\n",
                    netInterfaceId,
                    nodeName,
                    networkName
                    );
            }
            else if ( newState ==
                      (NM_STATE_ENTRY) ClusterNetInterfaceUnreachable
                    )
            {
                netInterface->State = ClusterNetInterfaceUnreachable;
                eventCode = CLUSTER_EVENT_NETINTERFACE_UNREACHABLE;
                logCode = NM_EVENT_CLUSTER_NETINTERFACE_UNREACHABLE;
                logLevel = LOG_UNUSUAL;
                logEvent = TRUE;

                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[NM] Interface %1!ws! is unreachable (node: %2!ws!, "
                    "network: %3!ws!).\n",
                    netInterfaceId,
                    nodeName,
                    networkName
                    );
            }
            else if (newState == (NM_STATE_ENTRY) ClusterNetInterfaceFailed) {
                netInterface->State = ClusterNetInterfaceFailed;
                eventCode = CLUSTER_EVENT_NETINTERFACE_FAILED;
                logCode = NM_EVENT_CLUSTER_NETINTERFACE_FAILED;
                logLevel = LOG_UNUSUAL;
                logEvent = TRUE;

                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[NM] Interface %1!ws! failed (node: %2!ws!, "
                    "network: %3!ws!).\n",
                    netInterfaceId,
                    nodeName,
                    networkName
                    );
            }
            else if ( newState ==
                      (NM_STATE_ENTRY) ClusterNetInterfaceStateUnknown
                    )
            {
                //
                // This case can happen if a create update races with a
                // state update. This will be the new interface. Just
                // ignore it. Another state update will arrive shortly.
                //
                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[NM] State for interface %1!ws! is unknown "
                    "(node: %2!ws!, network: %3!ws!).\n",
                    netInterfaceId,
                    nodeName,
                    networkName
                    );
            }
            else {
                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[NM] UpdateInterfaceState: Invalid state %1!u! "
                    "specified for interface %2!ws!\n",
                    newState,
                    netInterfaceId
                    );
                CL_ASSERT(FALSE);
            }

            if (eventCode != 0) {
                ClusterEvent(eventCode, netInterface);
            }

            if (logEvent && (NmpLeaderNodeId == NmLocalNodeId)) {
                CsLogEvent2(
                    logLevel,
                    logCode,
                    nodeName,
                    networkName
                    );
            }
        }
    }

    if (Network->State != NewNetworkState) {
        BOOLEAN          logEvent = FALSE;
        CLUSTER_EVENT    eventCode = 0;


        if (NewNetworkState == ClusterNetworkUnavailable) {
            Network->State = ClusterNetworkUnavailable;
            eventCode = CLUSTER_EVENT_NETWORK_UNAVAILABLE;
        }
        else if (NewNetworkState == ClusterNetworkUp) {
            Network->State = ClusterNetworkUp;
            eventCode = CLUSTER_EVENT_NETWORK_UP;
            logCode = NM_EVENT_CLUSTER_NETWORK_UP;
            logLevel = LOG_NOISE;
            logEvent = TRUE;

            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] Network %1!ws! (%2!ws!) is up.\n",
                networkId,
                networkName
                );
        }
        else if (NewNetworkState == ClusterNetworkDown) {
            Network->State = ClusterNetworkDown;
            eventCode = CLUSTER_EVENT_NETWORK_DOWN;
            logCode = NM_EVENT_CLUSTER_NETWORK_DOWN;
            logLevel = LOG_UNUSUAL;
            logEvent = TRUE;

            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] Network %1!ws! (%2!ws!) is down.\n",
                networkId,
                networkName
                );
        }
        else if (NewNetworkState == ClusterNetworkPartitioned) {
            Network->State = ClusterNetworkPartitioned;
            eventCode = CLUSTER_EVENT_NETWORK_PARTITIONED;
            logCode = NM_EVENT_CLUSTER_NETWORK_PARTITIONED;
            logLevel = LOG_UNUSUAL;
            logEvent = TRUE;

            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] Network %1!ws! (%2!ws!) is partitioned.\n",
                networkId,
                networkName
                );
        }
        else {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] Invalid state %1!u! for network %2!ws!\n",
                Network->State,
                networkId
                );
            CL_ASSERT(FALSE);
        }

        if (eventCode != 0) {
            ClusterEvent(eventCode, Network);
        }

        if (logEvent && (NmpLeaderNodeId == NmLocalNodeId)) {
            CsLogEvent1(
                logLevel,
                logCode,
                networkName
                );
        }
    }

    return;

} // NmpSetNetworkAndInterfaceStates


/////////////////////////////////////////////////////////////////////////////
//
// Network state management routines
//
/////////////////////////////////////////////////////////////////////////////
VOID
NmpRecomputeNT5NetworkAndInterfaceStates(
    VOID
    )
{
    PNM_NETWORK   network;
    PLIST_ENTRY   entry;


    for (entry = NmpNetworkList.Flink;
         entry != &NmpNetworkList;
         entry = entry->Flink
        )
    {
        network = CONTAINING_RECORD(
                      entry,
                      NM_NETWORK,
                      Linkage
                      );

        NmpStartNetworkStateRecalcTimer(
            network,
            NM_NET_STATE_RECALC_TIMEOUT_AFTER_REGROUP
            );
    }

    return;

} // NmpRecomputeNT5NetworkAndInterfaceStates


BOOLEAN
NmpComputeNetworkAndInterfaceStates(
    IN  PNM_NETWORK               Network,
    IN  BOOLEAN                   IsolateFailure,
    OUT CLUSTER_NETWORK_STATE *   NewNetworkState
    )
/*++

Routine Description:

    Computes the state of a network and all of its interfaces based on
    connectivity reports from each constituent interface. Attempts
    to distinguish between failures of individual interfaces and
    failure of an entire network.

Arguments:

    Network - A pointer to the network object to be processed.

    IsolateFailure - Triggers failure isolation analysis if set to true.

    NewNetworkState - A pointer to a variable that, upon return, contains
                      the new state of the network.

Return Value:

    TRUE if either the state of the network or the state of at least one
    of its constituent interfaces changed. FALSE otherwise.

Notes:

    Called with NmpLock held and the network object referenced.

--*/
{
    DWORD                       numIfUnavailable = 0;
    DWORD                       numIfFailed = 0;
    DWORD                       numIfUnreachable = 0;
    DWORD                       numIfUp = 0;
    DWORD                       numIfReachable = 0;
    PNM_CONNECTIVITY_MATRIX     matrix = Network->ConnectivityMatrix;
    PNM_CONNECTIVITY_MATRIX     matrixEntry;
    PNM_STATE_WORK_VECTOR       workVector = Network->StateWorkVector;
    DWORD                       entryCount =
                                    Network->ConnectivityVector->EntryCount;
    DWORD                       reporter, ifNetIndex;
    BOOLEAN                     stateChanged = FALSE;
    LPCWSTR                     networkId = OmObjectId(Network);
    LPCWSTR                     netInterfaceId;
    PLIST_ENTRY                 entry;
    PNM_INTERFACE               netInterface;
    NM_STATE_ENTRY              state;
    BOOLEAN                     selfDeclaredFailure = FALSE;
    DWORD                       interfaceFailureTimeout = 0;
    BOOLEAN                     abortComputation = FALSE;


    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Beginning phase 1 of state computation for network %1!ws!.\n",
        networkId
        );

    //
    // Phase 1 - Compute the state of each interface from the data
    //           in the connectivity matrix.
    //
    for ( entry = Network->InterfaceList.Flink;
          entry != &(Network->InterfaceList);
          entry = entry->Flink
        )
    {
        netInterface = CONTAINING_RECORD(
                           entry,
                           NM_INTERFACE,
                           NetworkLinkage
                           );

        netInterfaceId = OmObjectId(netInterface);
        ifNetIndex = netInterface->NetIndex;
        workVector[ifNetIndex].ReachableCount = 0;

        if (NmpIsNetworkEnabledForUse(Network)) {
            //
            // First, check what the interface thinks its own state is
            //
            matrixEntry = NM_GET_CONNECTIVITY_MATRIX_ENTRY(
                              matrix,
                              ifNetIndex,
                              ifNetIndex,
                              entryCount
                              );

            if ( *matrixEntry ==
                 (NM_STATE_ENTRY) ClusterNetInterfaceStateUnknown
               )
            {
                //
                // This case should never happen.
                //
                // An existing interface cannot think its own state is
                // unknown. The reflexive entry is always initialized to
                // Unavailable whenever an interface is created.
                //
                ClRtlLogPrint(LOG_NOISE, 
                    "[NM] No data for interface %1!u! (%2!ws!) on network "
                    "%3!ws!\n",
                    ifNetIndex,
                    netInterfaceId,
                    networkId
                    );

                CL_ASSERT(
                    *matrixEntry !=
                     (NM_STATE_ENTRY) ClusterNetInterfaceStateUnknown
                     );

                state = ClusterNetInterfaceUnavailable;
                numIfUnavailable++;
            }
            else if ( *matrixEntry ==
                      (NM_STATE_ENTRY) ClusterNetInterfaceUnavailable
                    )
            {
                if (NM_NODE_UP(netInterface->Node)) {
                    //
                    // The node is up, but its connectivity report has
                    // not been received yet. This case may happen while a
                    // node is joining. It can also happen if this node has
                    // just become the new leader.
                    //
                    // Abort the state computation.
                    //
                    ClRtlLogPrint(LOG_NOISE, 
                        "[NM] Data is not yet valid for interface %1!u! "
                        "(%2!ws!) on network %3!ws!.\n",
                        ifNetIndex,
                        netInterfaceId,
                        networkId
                        );

                    abortComputation = TRUE;
                    break;
                }
                else {
                    //
                    // The owning node is down or joining.
                    // The interface is in the unavailable state.
                    //
                    ClRtlLogPrint(LOG_NOISE, 
                        "[NM] Node is down for interface %1!u! (%2!ws!) on "
                        "network %3!ws!\n",
                        ifNetIndex,
                        netInterfaceId,
                        networkId
                        );

                    state = ClusterNetInterfaceUnavailable;
                    numIfUnavailable++;
                }
            }
            else if ( *matrixEntry ==
                      (NM_STATE_ENTRY) ClusterNetInterfaceFailed
                    )
            {
                //
                // The node declared its own interface as failed.
                // The interface is in the failed state.
                //
                ClRtlLogPrint(LOG_NOISE, 
                    "[NM] Interface %1!u! (%2!ws!) has failed on network "
                    "%3!ws!\n",
                    ifNetIndex,
                    netInterfaceId,
                    networkId
                    );

                state = ClusterNetInterfaceFailed;
                numIfFailed++;
                if (netInterface->State == ClusterNetInterfaceUp) {
                    selfDeclaredFailure = TRUE;
                }
            }
            else {
                CL_ASSERT(
                    *matrixEntry == (NM_STATE_ENTRY) ClusterNetInterfaceUp
                    );
                //
                // The owning node thinks its interface is Up.
                //
                // If there are no other operational interfaces on the
                // network, then the interface is in the Up state.
                //
                // If there are other operational interfaces on the
                // network, but all of their reports are not yet valid,
                // then we defer calculating a new state for the interface.
                //
                // If there are other operational interfaces on the network,
                // and all of their reports are valid, then if at least one
                // of the operational interfaces reports that the interface
                // is unreachable, then then the interface is in the
                // Unreachable state. If all of the other operational
                // interfaces report that the interface is reachable, then
                // the interface is in the Up state.
                //
                ClRtlLogPrint(LOG_NOISE, 
                    "[NM] Examining connectivity data for interface %1!u! "
                    "(%2!ws!) on network %2!ws!.\n",
                    ifNetIndex,
                    netInterfaceId,
                    networkId
                    );

                //
                // Assume that the interface is Up until proven otherwise.
                //
                state = ClusterNetInterfaceUp;

                //
                // Examine the reports from other interfaces -
                // i.e. scan the matrix column - to see if any node with
                // an operational interface reports this interface to
                // be unreachable.
                //
                for (reporter=0; reporter<entryCount; reporter++) {

                    if (reporter == ifNetIndex) {
                        continue;
                    }

                    //
                    // First, see if the reporting interface is operational
                    // by checking what the repoerter thinks of its own
                    // interface.
                    //
                    matrixEntry = NM_GET_CONNECTIVITY_MATRIX_ENTRY(
                                      matrix,
                                      reporter,
                                      reporter,
                                      entryCount
                                      );

                    if (*matrixEntry == ClusterNetInterfaceUp) {
                        PNM_CONNECTIVITY_MATRIX   matrixEntry2;

                        //
                        // Both the reporter and the reportee believe that
                        // their respective interfaces are operational.
                        // Check if they agree on the state of their
                        // connectivity before going any further.
                        // ClusNet guarantees that eventually they will
                        // agree.
                        //
                        matrixEntry = NM_GET_CONNECTIVITY_MATRIX_ENTRY(
                                          matrix,
                                          reporter,
                                          ifNetIndex,
                                          entryCount
                                          );

                        matrixEntry2 = NM_GET_CONNECTIVITY_MATRIX_ENTRY(
                                           matrix,
                                           ifNetIndex,
                                           reporter,
                                           entryCount
                                           );

                        if (*matrixEntry == *matrixEntry2) {
                            //
                            // The two interfaces agree on the state of
                            // their connectivity. Check what they agree on.
                            //
                            if (*matrixEntry == ClusterNetInterfaceUp) {
                                //
                                // The interface is reported to be up.
                                //
                                ClRtlLogPrint(LOG_NOISE, 
                                    "[NM] Interface %1!u! reports interface "
                                    "%2!u! is up on network %3!ws!\n",
                                    reporter,
                                    ifNetIndex,
                                    networkId
                                    );

                                workVector[ifNetIndex].ReachableCount++;
                            }
                            else if ( *matrixEntry ==
                                      ClusterNetInterfaceUnreachable
                                    )
                            {
                                //
                                // The interface is reported to be
                                // unreachable.
                                //
                                ClRtlLogPrint(LOG_NOISE, 
                                    "[NM] Interface %1!u! reports interface "
                                    "%2!u! is unreachable on network %3!ws!\n",
                                    reporter,
                                    ifNetIndex,
                                    networkId
                                    );

                                state = ClusterNetInterfaceUnreachable;
                                
                                //
                                // If this interface is already in failed state do fault isolation immediately.
                                //
                                if(workVector[ifNetIndex].State == ClusterNetInterfaceFailed)
                                    IsolateFailure = TRUE;
                            }
                            else {
                                CL_ASSERT(
                                    *matrixEntry != ClusterNetInterfaceFailed
                                    );
                                //
                                // The interface report is not valid yet.
                                // Abort the computation.
                                //
                                ClRtlLogPrint(LOG_NOISE, 
                                    "[NM] Report from interface %1!u! for "
                                    "interface %2!u! is not valid yet on "
                                    "network %3!ws!.\n",
                                    reporter,
                                    ifNetIndex,
                                    *matrixEntry,
                                    networkId
                                    );
                                abortComputation = TRUE;
                                break;
                            }
                        }
                        else {
                            //
                            // The two interfaces do not yet agree on
                            // their connectivity. Abort the computation.
                            //
                            ClRtlLogPrint(LOG_NOISE, 
                                "[NM] Interface %1!u! and interface %2!u! do "
                                "not agree on their connectivity on network "
                                "%3!ws!\n",
                                reporter,
                                ifNetIndex,
                                networkId
                                );
                            abortComputation = TRUE;
                            break;
                        }
                    }
                    else {
                        //
                        // The reporter does not think its own interface is
                        // operational.
                        //
                        ClRtlLogPrint(LOG_NOISE, 
                            "[NM] The report from interface %1!u! is not "
                            "valid on network %2!ws!.\n",
                            reporter,
                            networkId
                            );
                    }
                } // end of connectivity matrix scan loop

                if (abortComputation) {
                    //
                    // Abort Phase 1 computation.
                    //
                    break;
                }

                if (state == ClusterNetInterfaceUp) {
                    ClRtlLogPrint(LOG_NOISE, 
                        "[NM] Interface %1!u! (%2!ws!) is up on network "
                        "%3!ws!.\n",
                        ifNetIndex,
                        netInterfaceId,
                        networkId
                        );
                    numIfUp++;
                }
                else {
                    CL_ASSERT(state == ClusterNetInterfaceUnreachable);

                    ClRtlLogPrint(LOG_NOISE, 
                        "[NM] Interface %1!u! (%2!ws!) is unreachable on "
                        "network %3!ws!\n",
                        ifNetIndex,
                        netInterfaceId,
                        networkId
                        );
                    numIfUnreachable++;
                }
            }
        }
        else {
            //
            // The network is disabled. It is in the Unavailable state.
            //
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] Interface %1!u! (%2!ws!) is unavailable because "
                "network %3!ws! is disabled. \n",
                ifNetIndex,
                netInterfaceId,
                networkId
                );
            state = ClusterNetInterfaceUnavailable;
            numIfUnavailable++;
        }

        workVector[ifNetIndex].State = state;

        //
        // Keep track of how many interfaces on the network are
        // reachable by at least one peer.
        //
        if ( (state == ClusterNetInterfaceUp) ||
             (workVector[ifNetIndex].ReachableCount > 0)
           ) {
            numIfReachable++;
        }

        if (netInterface->State != state) {
            stateChanged = TRUE;
        }

    } // end of phase one interface loop

    if (!abortComputation && !IsolateFailure && selfDeclaredFailure) {

        interfaceFailureTimeout = 
            NmpGetNetworkInterfaceFailureTimerValue(networkId);

        if (interfaceFailureTimeout > 0) {

            ClRtlLogPrint(LOG_NOISE, 
                "[NM] Delaying state computation for network %1!ws! "
                "for %2!u! ms to damp self-declared failure event.\n",
                networkId, interfaceFailureTimeout
                );

            NmpStartNetworkFailureIsolationTimer(
                Network,
                interfaceFailureTimeout
                );

            abortComputation = TRUE;
        }
    }

    if (abortComputation) {

        if (interfaceFailureTimeout == 0) {
            
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] Aborting state computation for network %1!ws! "
                " until connectivity data is valid.\n",
                networkId
                );
        }
    
        //
        // Undo any changes we made to the work vector.
        //
        for ( entry = Network->InterfaceList.Flink;
              entry != &(Network->InterfaceList);
              entry = entry->Flink
            )
        {
            netInterface = CONTAINING_RECORD(
                               entry,
                               NM_INTERFACE,
                               NetworkLinkage
                               );

            ifNetIndex = netInterface->NetIndex;
            workVector[ifNetIndex].State = (NM_STATE_ENTRY)
                                           netInterface->State;
        }

        *NewNetworkState = Network->State;

        return(FALSE);
    }

    //
    // Phase 2
    //
    // Try to determine the scope of any failures and recompute the
    // interface states. There are two cases in which we can isolate
    // failures.
    //
    //     Case 1: Three or more interfaces are operational. At least two
    //             interfaces can communicate with a peer. One or more
    //             interfaces cannot communicate with any peer.
    //             Those that cannot communicate at all have failed.
    //
    //     Case 2: Exactly two interfaces are operational and they cannot
    //             communicate with one another. If one interface can
    //             communicate with an external host while the other
    //             cannot communicate with any external host, then the one
    //             that cannot communicate has failed.
    //
    // In any other situation, we do nothing.
    //
    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Completed phase 1 of state computation for network "
        "%1!ws!.\n",
        networkId
        );

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Unavailable=%1!u!, Failed = %2!u!, Unreachable=%3!u!, "
        "Reachable=%4!u!, Up=%5!u! on network %6!ws! \n",
        numIfUnavailable,
        numIfFailed,
        numIfUnreachable,
        numIfReachable,
        numIfUp,
        networkId
        );

    if (numIfUnreachable > 0) {
        //
        // Some interfaces are unreachable.
        //
        if ( ((numIfUp + numIfUnreachable) >= 3)  && (numIfReachable >= 2) ) {
            if (IsolateFailure) {
                //
                // Case 1.
                //
                ClRtlLogPrint(LOG_NOISE, 
                    "[NM] Trying to determine scope of connectivity failure "
                    "for >3 interfaces on network %1!ws!.\n",
                    networkId
                    );

                //
                // Any operational interface that cannot communicate with at
                // least one other operational interface has failed.
                //
                for ( entry = Network->InterfaceList.Flink;
                      entry != &(Network->InterfaceList);
                      entry = entry->Flink
                    )
                {
                    netInterface = CONTAINING_RECORD(
                                       entry,
                                       NM_INTERFACE,
                                       NetworkLinkage
                                       );

                    ifNetIndex = netInterface->NetIndex;
                    netInterfaceId = OmObjectId(netInterface);

                    if ( ( workVector[ifNetIndex].State ==
                           ClusterNetInterfaceUnreachable
                         )
                         &&
                         (workVector[ifNetIndex].ReachableCount == 0)
                       )
                    {
                        ClRtlLogPrint(LOG_NOISE, 
                            "[NM] Interface %1!u! (%2!ws!) has failed on "
                            "network %3!ws!\n",
                            ifNetIndex,
                            netInterfaceId,
                            networkId
                            );
                        workVector[ifNetIndex].State =
                            ClusterNetInterfaceFailed;
                        numIfUnreachable--;
                        numIfFailed++;
                    }
                }

                //
                // If any interface, whose state is still unreachable, can see
                // all other reachable interfaces, change its state to up.
                //
                for ( entry = Network->InterfaceList.Flink;
                      entry != &(Network->InterfaceList);
                      entry = entry->Flink
                    )
                {
                    netInterface = CONTAINING_RECORD(
                                       entry,
                                       NM_INTERFACE,
                                       NetworkLinkage
                                       );

                    ifNetIndex = netInterface->NetIndex;

                    if ( ( workVector[ifNetIndex].State ==
                           ClusterNetInterfaceUnreachable
                         )
                         &&
                         ( workVector[ifNetIndex].ReachableCount ==
                           (numIfUp + numIfUnreachable - 1)
                         )
                       )
                    {
                        ClRtlLogPrint(LOG_NOISE, 
                            "[NM] Interface %1!u! (%2!ws!) is up on network "
                            "%3!ws!\n",
                            ifNetIndex,
                            netInterfaceId,
                            networkId
                            );
                        workVector[ifNetIndex].State = ClusterNetInterfaceUp;
                        numIfUnreachable--;
                        numIfUp++;
                    }
                }

                ClRtlLogPrint(LOG_NOISE, 
                    "[NM] Connectivity failure scope determination complete "
                    "for network %1!ws!.\n",
                    networkId
                    );

            }
            else {
                //
                // Schedule a failure isolation calculation to run later.
                // Declaring a failure can affect cluster resources, so we
                // don't want to do it unless we are sure. Delaying for a
                // while reduces the risk of a false positive.
                //
                NmpStartNetworkFailureIsolationTimer(Network,
                    NM_NET_STATE_FAILURE_ISOLATION_TIMEOUT);

            }
        }
        else if ((numIfUnreachable == 2) && (numIfUp == 0)) {
            if (IsolateFailure) {
                //
                // Case 2.
                //
                PNM_INTERFACE  interface1 = NULL;
                BOOLEAN        interface1HasConnectivity;
                LPCWSTR        interfaceId1;
                PNM_INTERFACE  interface2 = NULL;
                BOOLEAN        interface2HasConnectivity;
                LPCWSTR        interfaceId2;
                DWORD          status;


                ClRtlLogPrint(LOG_NOISE, 
                    "[NM] Trying to determine scope of connectivity failure "
                    "for 2 interfaces on network %1!ws!.\n",
                    networkId
                    );

                for ( entry = Network->InterfaceList.Flink;
                      entry != &(Network->InterfaceList);
                      entry = entry->Flink
                    )
                {
                    netInterface = CONTAINING_RECORD(
                                       entry,
                                       NM_INTERFACE,
                                       NetworkLinkage
                                       );

                    ifNetIndex = netInterface->NetIndex;

                    if ( workVector[ifNetIndex].State ==
                         ClusterNetInterfaceUnreachable
                       )
                    {
                        if (interface1 == NULL) {
                            interface1 = netInterface;
                            interfaceId1 = OmObjectId(interface1);

                            ClRtlLogPrint(LOG_NOISE, 
                                "[NM] Unreachable interface 1 = %1!ws! on "
                                "network %2!ws!\n",
                                interfaceId1,
                                networkId
                                );
                        }
                        else {
                            interface2 = netInterface;
                            interfaceId2 = OmObjectId(interface2);

                            ClRtlLogPrint(LOG_NOISE, 
                                "[NM] Unreachable interface 2 = %1!ws! on "
                                "network %2!ws!\n",
                                interfaceId2,
                                networkId
                                );
                            break;
                        }
                    }
                }

                //
                // NmpTestInterfaceConnectivity releases and reacquires
                // the NmpLock. We must reference the interface objects
                // to ensure that they are still valid upon return from
                // that routine.
                //
                OmReferenceObject(interface1);
                OmReferenceObject(interface2);

                status = NmpTestInterfaceConnectivity(
                             interface1,
                             &interface1HasConnectivity,
                             interface2,
                             &interface2HasConnectivity
                             );

                if (status == ERROR_SUCCESS) {
                    if ( interface1HasConnectivity &&
                         !interface2HasConnectivity
                       )
                    {
                        ClRtlLogPrint(LOG_NOISE, 
                            "[NM] Interface %1!u! (%2!ws!) has Failed on "
                            "network %3!ws!\n",
                            interface2->NetIndex,
                            interfaceId2,
                            networkId
                            );

                        workVector[interface2->NetIndex].State =
                            ClusterNetInterfaceFailed;
                        numIfUnreachable--;
                        numIfFailed++;

                        ClRtlLogPrint(LOG_NOISE, 
                            "[NM] Interface %1!u! (%2!ws!) is Up on network "
                            "%3!ws!\n",
                            interface1->NetIndex,
                            interfaceId1,
                            networkId
                            );

                        workVector[interface1->NetIndex].State =
                            ClusterNetInterfaceUp;
                        numIfUnreachable--;
                        numIfUp++;
                    }
                    else if ( !interface1HasConnectivity &&
                              interface2HasConnectivity
                            )
                    {
                        ClRtlLogPrint(LOG_NOISE, 
                            "[NM] Interface %1!u! (%2!ws!) has Failed on "
                            "network %3!ws!\n",
                            interface1->NetIndex,
                            interfaceId1,
                            networkId
                            );

                        workVector[interface1->NetIndex].State =
                            ClusterNetInterfaceFailed;
                        numIfUnreachable--;
                        numIfFailed++;

                        ClRtlLogPrint(LOG_NOISE, 
                            "[NM] Interface %1!u! (%2!ws!) is Up on network "
                            "%3!ws!\n",
                            interface2->NetIndex,
                            interfaceId2,
                            networkId
                            );

                        workVector[interface2->NetIndex].State =
                            ClusterNetInterfaceUp;
                        numIfUnreachable--;
                        numIfUp++;
                    }
                    else {
                        ClRtlLogPrint(LOG_UNUSUAL, 
                            "[NM] Network %1!ws! state is indeterminate, Scheduling"
                            " Failure Isolation poll\n",
                            networkId
                            );
                        NmpStartNetworkFailureIsolationTimer(Network, 
                            NmpGetIsolationPollTimerValue());
                    }
                }
                else {
                    ClRtlLogPrint(LOG_UNUSUAL, 
                    "[NM] Error in Interface Connectivity test for Network %1!ws!" 
                    ", Scheduling Failure Isolation poll\n",
                    networkId
                    );
                    NmpStartNetworkFailureIsolationTimer(Network,
                        NmpGetIsolationPollTimerValue()); 
                }

                OmDereferenceObject(interface1);
                OmDereferenceObject(interface2);

                ClRtlLogPrint(LOG_NOISE, 
                    "[NM] Connectivity failure scope determination complete "
                    "for network %1!ws!.\n",
                    networkId
                    );
            }
            else {
                //
                // Schedule a failure isolation calculation to run later.
                // Declaring a failure can affect cluster resources, so we
                // don't want to do it unless we are sure. Delaying for a
                // while reduces the risk of a false positive.
                //
                NmpStartNetworkFailureIsolationTimer(Network,
                    NM_NET_STATE_FAILURE_ISOLATION_TIMEOUT);
            }
        }
        else {
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] Cannot determine scope of connectivity failure on "
                "network %1!ws!.\n",
                networkId
                );
        }
    }
    else {
        //
        // No unreachable interfaces. Disable the failure isolation timer,
        // if it is running.
        //
        Network->FailureIsolationTimer = 0;
        Network->Flags &= ~NM_FLAG_NET_ISOLATE_FAILURE;
    }

    //
    // Phase 3 - Compute the new network state.
    //
    if (numIfUnavailable == Network->InterfaceCount) {
        //
        // All interfaces are unavailable.
        //
        *NewNetworkState = ClusterNetworkUnavailable;
    }
    else if (numIfUnreachable > 0) {
        //
        // Some operational interfaces have experienced
        // a loss of connectivity, but the fault could not be
        // isolated to them.
        //
        if (numIfReachable > 0) {
            CL_ASSERT(numIfReachable >= 2);
            //
            // At least two interfaces can still communicate
            // with each other, so the network is not completely down.
            //
            *NewNetworkState = ClusterNetworkPartitioned;
        }
        else {
            CL_ASSERT(numIfUp == 0);
            //
            // None of the operational interfaces can communicate
            //
            *NewNetworkState = ClusterNetworkDown;
        }
    }
    else if (numIfUp > 0) {
        //
        // Some interfaces are Up, all others are Failed or Unavailable
        //
        *NewNetworkState = ClusterNetworkUp;
    }
    else {
        //
        // Some interfaces are Unavailable, rest are Failed.
        //
        *NewNetworkState = ClusterNetworkDown;
    }

    if (Network->State != *NewNetworkState) {
        stateChanged = TRUE;

        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Network %1!ws! is now in state %2!u!\n",
            networkId,
            *NewNetworkState
            );
    }

    return(stateChanged);

} // NmpComputeNetworkAndInterfaceStates


DWORD
NmpGetIsolationPollTimerValue(
    VOID
    )
/*--
 * Reads the IsolationPollTimerValue Parameter from the registry if it's there
 * else returns default value.
 */
{

    DWORD value;
    DWORD type;
    DWORD len = sizeof(value);
    DWORD status;

	// Release NM Lock to avoid deadlock with DM lock
    NmpReleaseLock();
    
    status = DmQueryValue(
                DmClusterParametersKey,
                L"IsolationPollTimerValue",
                &type,
                (LPBYTE)&value,
                &len
                );

	NmpAcquireLock();
    if((status != ERROR_SUCCESS) || (type != REG_DWORD) ||
       (value < 10) || (value > 600000)) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Failed to read IsolationPollTimerValue or value out of range,"
            "status %1!u! using default %2!u! ms\n",
            status,
            NM_NET_STATE_FAILURE_ISOLATION_POLL
            );
        return NM_NET_STATE_FAILURE_ISOLATION_POLL;
    }
    else {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] IsolationPollTimerValue = %1!u!\n",
            value
            );
        return value;
    }
}

DWORD
NmpGetNetworkInterfaceFailureTimerValue(
    IN LPCWSTR   NetworkId
    )
/*++

Routine Description:

    Reads InterfaceFailure timer value from registry.
    If a value is located in the network key, it is used.
    Otherwise the cluster parameters key is checked.
    If no value is present, returns default.
    
Arguments:

    NetworkId - id of network whose timer value to determine
    
Return value:

    InterfaceFailure timer value
    
Notes:

    Called with NM lock held (from NmpComputeNetworkAndInterfaceStates).
    
    This routine queries the cluster database; hence, it drops the
    NM lock. Since NmpComputeNetworkAndInterfaceStates is always called
    in the context of the NmpWorkerThread, the Network is always 
    referenced during execution of this routine.
    
--*/
{
    HDMKEY  networkKey, paramKey;
    DWORD   status;
    DWORD   type;
    DWORD   value = NM_NET_STATE_INTERFACE_FAILURE_TIMEOUT;
    DWORD   len = sizeof(value);
    BOOLEAN found = FALSE;

    //
    // To avoid deadlock, the DM lock must be acquired before the
    // NM lock. Hence, release the NM lock prior to querying the
    // cluster database. 
    //
    NmpReleaseLock();

    //
    // First check the network key
    //
    networkKey = DmOpenKey(DmNetworksKey, NetworkId, KEY_READ);
    if (networkKey == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Failed to open key for network %1!ws!, "
            "status %1!u!\n",
            NetworkId, status
            );
    }
    else {
        paramKey = DmOpenKey(networkKey, L"Parameters", KEY_READ);
        if (paramKey == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] Failed to find Parameters key "
                "for network %1!ws!, status %2!u!. Checking "
                "cluster parameters ...\n",
                NetworkId, status
                );
        }
        else {
            status = DmQueryValue(
                         paramKey,
                         L"InterfaceFailureTimeout",
                         &type,
                         (LPBYTE) &value,
                         &len
                         );
            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_NOISE, 
                    "[NM] Failed to read InterfaceFailureTimeout "
                    "for network %1!ws!, status %2!u!. Checking "
                    "cluster parameters ...\n",
                    NetworkId, status
                    );
            }
            else if (type != REG_DWORD) {
                ClRtlLogPrint(LOG_NOISE, 
                    "[NM] Unexpected type (%1!u!) for network "
                    "%2!ws! InterfaceFailureTimeout, status %3!u!. "
                    "Checking cluster parameters ...\n",
                    type, NetworkId, status
                    );
            }
            else {
                found = TRUE;
            }
            
            DmCloseKey(paramKey);
        }
        
        DmCloseKey(networkKey);
    }


    //
    // If no value was found under the network key, check the
    // cluster parameters key.
    //
    if (!found) {

        paramKey = DmOpenKey(DmClusterParametersKey, L"Parameters", KEY_READ);
        if (paramKey == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] Failed to find cluster Parameters key, status %1!u!.\n",
                status
                );
        }
        else {
            status = DmQueryValue(
                         paramKey,
                         L"InterfaceFailureTimeout",
                         &type,
                         (LPBYTE) &value,
                         &len
                         );
            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_NOISE, 
                    "[NM] Failed to read cluster "
                    "InterfaceFailureTimeout, status %1!u!. "
                    "Using default value ...\n",
                    status
                    );
                value = NM_NET_STATE_INTERFACE_FAILURE_TIMEOUT;
            }
            else if (type != REG_DWORD) {
                ClRtlLogPrint(LOG_NOISE, 
                    "[NM] Unexpected type (%1!u!) for cluster "
                    "InterfaceFailureTimeout, status %2!u!. "
                    "Using default value ...\n",
                    type, status
                    );
                value = NM_NET_STATE_INTERFACE_FAILURE_TIMEOUT;
            }

            DmCloseKey(paramKey);
        }
    }

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Using InterfaceFailureTimeout of %1!u! ms "
        "for network %2!ws!.\n",
        value, NetworkId
        );

    //
    // Reacquire NM lock.
    //
    NmpAcquireLock();

    return(value);
}

VOID
NmpConnectivityReportWorker(
    IN PCLRTL_WORK_ITEM   WorkItem,
    IN DWORD              Status,
    IN DWORD              BytesTransferred,
    IN ULONG_PTR          IoContext
    )
/*++

Routine Description:

    Worker routine for deferred operations on network objects.
    Invoked to process items placed in the cluster delayed work queue.

Arguments:

    WorkItem - Ignored.

    Status - Ignored.

    BytesTransferred - Ignored.

    IoContext - Ignored.

Return Value:

    None.

Notes:

    This routine is run in an asynchronous worker thread.
    The NmpActiveThreadCount was incremented when the thread was
    scheduled.

--*/
{
    BOOLEAN       rescheduled = FALSE;


    NmpAcquireLock();

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Connectivity report worker thread running.\n"
        );

    CL_ASSERT(NmpIsConnectivityReportWorkerRunning == TRUE);
    CL_ASSERT(NmpNeedConnectivityReport == TRUE);

    if (NmpState >= NmStateOnlinePending) {
        PNM_NETWORK  network;
        LPCWSTR      networkId;
        PLIST_ENTRY  entry;
        DWORD        status;

        while(TRUE) {

            NmpNeedConnectivityReport = FALSE;

            for (entry = NmpNetworkList.Flink;
                 entry != &NmpNetworkList;
                 entry = entry->Flink
                )
            {
                network = CONTAINING_RECORD(entry, NM_NETWORK, Linkage);

                if (!NM_DELETE_PENDING(network)) {
                    networkId = OmObjectId(network);

                    //
                    // Deliver an InterfaceFailed event for the local interface
                    // if needed.
                    //
                    if (network->Flags & NM_FLAG_NET_REPORT_LOCAL_IF_FAILED) {
                        network->Flags &= ~NM_FLAG_NET_REPORT_LOCAL_IF_FAILED;

                        if (NmpIsNetworkRegistered(network)) {
                            ClRtlLogPrint(LOG_NOISE, 
                                "[NM] Processing local interface failed "
                                " event for network %1!ws!.\n",
                                networkId
                                );

                            NmpProcessLocalInterfaceStateEvent(
                                network->LocalInterface,
                                ClusterNetInterfaceFailed
                                );
                        }
                    }

                    //
                    // Deliver an InterfaceUp event for the local interface
                    // if needed.
                    //
                    if (network->Flags & NM_FLAG_NET_REPORT_LOCAL_IF_UP) {
                        network->Flags &= ~NM_FLAG_NET_REPORT_LOCAL_IF_UP;

                        if (NmpIsNetworkRegistered(network)) {
                            ClRtlLogPrint(LOG_NOISE, 
                                "[NM] Processing local interface up event "
                                "for network %1!ws!.\n",
                                networkId
                                );

                            NmpProcessLocalInterfaceStateEvent(
                                network->LocalInterface,
                                ClusterNetInterfaceUp
                                );
                        }
                    }

                    //
                    // Send a connectivity report if needed.
                    //
                    if (network->Flags & NM_FLAG_NET_REPORT_CONNECTIVITY) {
                        CL_NODE_ID   leaderNodeId = NmpLeaderNodeId;

                        network->Flags &= ~NM_FLAG_NET_REPORT_CONNECTIVITY;

                        //
                        // Report our connectivity to the leader.
                        //
                        status = NmpReportNetworkConnectivity(network);

                        if (status == ERROR_SUCCESS) {
                            //
                            // Clear the report retry count.
                            //
                            network->ConnectivityReportRetryCount = 0;
                        }
                        else {
                            if (NmpLeaderNodeId == leaderNodeId) {
                                if (network->ConnectivityReportRetryCount++ <
                                    NM_CONNECTIVITY_REPORT_RETRY_LIMIT
                                   )
                                {
                                    //
                                    // Try again in 500ms.
                                    //
                                    network->ConnectivityReportTimer = 500;
                                }
                                else {
                                    //
                                    // We have failed to communicate with
                                    // the leader for too long. Mutiny.
                                    //
                                    NmpAdviseNodeFailure(
                                        NmpIdArray[NmpLeaderNodeId],
                                        status
                                        );

                                    network->ConnectivityReportRetryCount = 0;
                                }
                            }
                            else {
                                //
                                // New leader, clear the retry count. We
                                // already scheduled another connectivity
                                // report in the node down handling.
                                //
                                network->ConnectivityReportRetryCount = 0;
                            }
                        }
                    }
                }
            } // end network for loop

            if (NmpNeedConnectivityReport == FALSE) {
                //
                // No more work to do - break out of loop.
                //
                break;
            }

            //
            // More work to do. Resubmit the work item. We do this instead
            // of looping so we don't hog the worker thread. If
            // rescheduling fails, we will loop again in this thread.
            //
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] More connectivity reports to send. Rescheduling "
                "worker thread.\n"
                );

            status = NmpScheduleConnectivityReportWorker();

            if (status == ERROR_SUCCESS) {
                rescheduled = TRUE;
                break;
            }
        } // end while(TRUE)
    }

    if (!rescheduled) {
        NmpIsConnectivityReportWorkerRunning = FALSE;
    }

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Connectivity report worker thread finished.\n"
        );

    //
    // Decrement active thread reference count.
    //
    NmpLockedLeaveApi();

    NmpReleaseLock();

    return;

} // NmpConnectivityReportWorker


VOID
NmpNetworkWorker(
    IN PCLRTL_WORK_ITEM   WorkItem,
    IN DWORD              Status,
    IN DWORD              BytesTransferred,
    IN ULONG_PTR          IoContext
    )
/*++

Routine Description:

    Worker routine for deferred operations on network objects.
    Invoked to process items placed in the cluster delayed work queue.

Arguments:

    WorkItem - A pointer to a work item structure that identifies the
               network for which to perform work.

    Status - Ignored.

    BytesTransferred - Ignored.

    IoContext - Ignored.

Return Value:

    None.

Notes:

    This routine is run in an asynchronous worker thread.
    The NmpActiveThreadCount was incremented when the thread was
    scheduled. The network object was also referenced.

--*/
{
    PNM_NETWORK   network = (PNM_NETWORK) WorkItem->Context;
    LPCWSTR       networkId = OmObjectId(network);
    BOOLEAN       rescheduled = FALSE;


    NmpAcquireLock();

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Worker thread processing network %1!ws!.\n",
        networkId
        );

    if ((NmpState >= NmStateOnlinePending) && !NM_DELETE_PENDING(network)) {
        DWORD     status;

        while(TRUE) {
            CL_ASSERT(network->Flags & NM_FLAG_NET_WORKER_RUNNING);

            //
            // Register the network if needed.
            //
            if (network->Flags & NM_FLAG_NET_NEED_TO_REGISTER) {
                network->Flags &= ~NM_FLAG_NET_NEED_TO_REGISTER;

                if (network->LocalInterface != NULL) {
                    (VOID) NmpRegisterNetwork(
                               network,
                               TRUE    // Do retry on failure
                               );
                }
            }

            //
            // Isolate a network failure if needed.
            //
            if (network->Flags & NM_FLAG_NET_ISOLATE_FAILURE) {

                BOOLEAN                stateChanged;
                CLUSTER_NETWORK_STATE  newNetworkState;
                
                network->Flags &= ~NM_FLAG_NET_ISOLATE_FAILURE;

                //
                // Turn off the state recalc timer and flag, since we will
                // do a recalc here.
                //
                network->Flags &= ~NM_FLAG_NET_RECALC_STATE;
                network->StateRecalcTimer = 0;

                CL_ASSERT(NmpLeaderNodeId == NmLocalNodeId);

                //
                // Recompute the interface and network states
                // with failure isolation enabled.
                //
                stateChanged = NmpComputeNetworkAndInterfaceStates(
                                    network,
                                    TRUE,
                                    &newNetworkState
                                    );

                if (stateChanged) {
                    //
                    // Broadcast the new network and interface states to
                    // all nodes
                    //
                    status = NmpGlobalSetNetworkAndInterfaceStates(
                                    network,
                                    newNetworkState
                                    );

                    if (status != ERROR_SUCCESS) {
                        //
                        // Try again in 1 second.
                        //
                        ClRtlLogPrint(LOG_NOISE, 
                            "[NM] Global update failed for network %1!ws!, "
                            "status %2!u! - restarting failure isolation "
                            "timer.\n",
                            networkId,
                            status
                            );

                        network->FailureIsolationTimer = 1000;
                    }
                }
            }

            //
            // Recalculate the network and interface states if needed.
            //
            if (network->Flags & NM_FLAG_NET_RECALC_STATE) {
                BOOLEAN                stateChanged;
                CLUSTER_NETWORK_STATE  newNetworkState;

                network->Flags &= ~NM_FLAG_NET_RECALC_STATE;

                CL_ASSERT(NmpLeaderNodeId == NmLocalNodeId);

                //
                // Recompute the interface and network states
                // with failure isolation disabled. It will be
                // enabled if needed.
                //
                stateChanged = NmpComputeNetworkAndInterfaceStates(
                                    network,
                                    FALSE,
                                    &newNetworkState
                                    );

                if (stateChanged) {
                    //
                    // Broadcast the new network and interface states to
                    // all nodes
                    //
                    status = NmpGlobalSetNetworkAndInterfaceStates(
                                    network,
                                    newNetworkState
                                    );

                    if (status != ERROR_SUCCESS) {
                        //
                        // Try again in 500ms.
                        //
                        ClRtlLogPrint(LOG_NOISE,
                            "[NM] NetworkStateUpdateWorker failed issue "
                            "global update for network %1!ws!, status "
                            "%2!u! - restarting update timer.\n",
                            networkId,
                            status
                            );

                        network->StateRecalcTimer = 500;
                    }
                }
            }

            if (!(network->Flags & NM_NET_WORK_FLAGS)) {
                //
                // No more work to do - break out of loop.
                //
                break;
            }

            //
            // More work to do. Resubmit the work item. We do this instead
            // of looping so we don't hog the worker thread. If
            // rescheduling fails, we will loop again in this thread.
            //
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] More work to do for network %1!ws!. Rescheduling "
                "worker thread.\n",
                networkId
                );

            status = NmpScheduleNetworkWorker(network);

            if (status == ERROR_SUCCESS) {
                rescheduled = TRUE;
                break;
            }
        }
    }
    else {
        network->Flags &= ~NM_NET_WORK_FLAGS;
    }

    if (!rescheduled) {
        network->Flags &= ~NM_FLAG_NET_WORKER_RUNNING;
    }

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Worker thread finished processing network %1!ws!.\n",
        networkId
        );

    NmpLockedLeaveApi();

    NmpReleaseLock();

    OmDereferenceObject(network);

    return;

}  // NmpNetworkWorker


VOID
NmpNetworkTimerTick(
    IN DWORD  MsTickInterval
    )
/*++

Routine Description:

    Called by NM periodic timer to decrement network timers.

Arguments:

    MsTickInterval - The number of milliseconds that have passed since
                     the last timer tick.

Return Value:

    None.

Notes:

    Called with NmpLock held.

--*/
{
    if (NmpLockedEnterApi(NmStateOnlinePending)) {
        PLIST_ENTRY   entry;
        PNM_NETWORK   network;


        //
        // Walk thru the list of networks and decrement any running timers.
        //
        for ( entry = NmpNetworkList.Flink;
              entry != &NmpNetworkList;
              entry = entry->Flink
            )
        {
            network = CONTAINING_RECORD(entry, NM_NETWORK, Linkage);

            //
            // Network registration retry timer.
            //
            if (network->RegistrationRetryTimer != 0) {
                if (network->RegistrationRetryTimer > MsTickInterval) {
                    network->RegistrationRetryTimer -= MsTickInterval;
                }
                else {
                    //
                    // The timer has expired. Schedule a worker thread
                    // to register the network.
                    //
                    LPCWSTR   networkId = OmObjectId(network);
                    LPCWSTR   networkName = OmObjectName(network);


                    ClRtlLogPrint(LOG_NOISE, 
                        "[NM] Registration retry timer expired for "
                        "network %1!ws! (%2!ws!).\n",
                        networkId,
                        networkName
                        );

                    NmpScheduleNetworkRegistration(network);
                }
            }

            //
            // Connectivity report generation timer.
            //
            if (network->ConnectivityReportTimer != 0) {
                if (network->ConnectivityReportTimer > MsTickInterval) {
                    network->ConnectivityReportTimer -= MsTickInterval;
                }
                else {
                    //
                    // The timer has expired. Schedule a worker thread
                    // to deliver a connectivity report.
                    //
                    LPCWSTR   networkId = OmObjectId(network);
                    LPCWSTR   networkName = OmObjectName(network);


                    ClRtlLogPrint(LOG_NOISE, 
                        "[NM] Connectivity report timer expired for "
                        "network %1!ws! (%2!ws!).\n",
                        networkId,
                        networkName
                        );

                    NmpScheduleNetworkConnectivityReport(network);
                }
            }

            //
            // Network state recalculation timer.
            //
            if (network->StateRecalcTimer != 0) {
                if (network->StateRecalcTimer > MsTickInterval) {
                    network->StateRecalcTimer -= MsTickInterval;
                }
                else {
                    //
                    // The timer has expired. Schedule a worker thread
                    // to recalculate the state of the network.
                    //
                    LPCWSTR   networkId = OmObjectId(network);
                    LPCWSTR   networkName = OmObjectName(network);


                    ClRtlLogPrint(LOG_NOISE, 
                        "[NM] State recalculation timer expired for "
                        "network %1!ws! (%2!ws!).\n",
                        networkId,
                        networkName
                        );

                    NmpScheduleNetworkStateRecalc(network);
                }
            }

            //
            // Network multicast address renewal timer.
            //
            if (network->McastAddressRenewTimer != 0) {
                if (network->McastAddressRenewTimer > MsTickInterval) {
                    network->McastAddressRenewTimer -= MsTickInterval;
                }
                else {
                    //
                    // The timer has expired. Schedule a worker thread
                    // to renew the network's multicast address.
                    //
                    LPCWSTR   networkId = OmObjectId(network);
                    LPCWSTR   networkName = OmObjectName(network);


                    ClRtlLogPrint(LOG_NOISE, 
                        "[NM] Multicast address lease renewal timer "
                        "expired for network %1!ws! (%2!ws!).\n",
                        networkId,
                        networkName
                        );

                    NmpScheduleMulticastAddressRenewal(network);
                }
            }

            //
            // Network multicast address release timer.
            //
            if (network->McastAddressReleaseRetryTimer != 0) {
                if (network->McastAddressReleaseRetryTimer > MsTickInterval) {
                    network->McastAddressReleaseRetryTimer -= MsTickInterval;
                }
                else {
                    //
                    // The timer has expired. Schedule a worker thread
                    // to release the network's multicast address.
                    //
                    LPCWSTR   networkId = OmObjectId(network);
                    LPCWSTR   networkName = OmObjectName(network);


                    ClRtlLogPrint(LOG_NOISE, 
                        "[NM] Multicast address release timer "
                        "expired for network %1!ws! (%2!ws!).\n",
                        networkId,
                        networkName
                        );

                    NmpScheduleMulticastAddressRelease(network);
                }
            }

            //
            // Network failure isolation timer.
            //
            if (network->FailureIsolationTimer != 0) {
                if (network->FailureIsolationTimer > MsTickInterval) {
                    network->FailureIsolationTimer -= MsTickInterval;
                }
                else {
                    //
                    // The timer has expired. Schedule a worker thread
                    // to perform failure isolation on the network.
                    //
                    DWORD     status = ERROR_SUCCESS;
                    LPCWSTR   networkId = OmObjectId(network);
                    LPCWSTR   networkName = OmObjectName(network);


                    ClRtlLogPrint(LOG_NOISE, 
                        "[NM] Failure isolation timer expired for network "
                        "%1!ws! (%2!ws!).\n",
                        networkId,
                        networkName
                        );

                    if (!NmpIsNetworkWorkerRunning(network)) {
                        status = NmpScheduleNetworkWorker(network);
                    }

                    //
                    // Zero out the timer if we succeeded in scheduling a
                    // worker thread. If we failed, leave the timer value
                    // non-zero and we'll try again on the next tick.
                    //
                    if (status == ERROR_SUCCESS) {
                        network->FailureIsolationTimer = 0;
                        network->Flags |= NM_FLAG_NET_ISOLATE_FAILURE;
                    }
                }
            }            
        }

        NmpLockedLeaveApi();
    }

    return;

} // NmpNetworkTimerTick


VOID
NmpStartNetworkConnectivityReportTimer(
    PNM_NETWORK Network
    )
/*++

Routine Description:

    Starts the connectivity report timer for a network. Connectivity
    reports are delayed in order to aggregate events when a failure
    occurs that affects multiple nodes.

Arguments:

    Network - A pointer to the network for which to start the timer.

Return Value

    None.

Notes:

    Called with NM lock held.

--*/
{
    //
    // Check if the timer is already running.
    //
    if (Network->ConnectivityReportTimer == 0) {
        //
        // Check how many nodes are attached to this network.
        //
        if (Network->InterfaceCount <= 2) {
            //
            // There is no point in waiting to aggregate reports when
            // only two nodes are connected to the network.
            // Just schedule a worker thread to deliver the report.
            //
            NmpScheduleNetworkConnectivityReport(Network);
        }
        else {
            //
            // More than two nodes are connected to this network.
            // Start the timer.
            //
            LPCWSTR   networkId = OmObjectId(Network);
            LPCWSTR   networkName = OmObjectName(Network);

            Network->ConnectivityReportTimer =
                NM_NET_CONNECTIVITY_REPORT_TIMEOUT;

                ClRtlLogPrint(LOG_NOISE,
                    "[NM] Started connectivity report timer (%1!u!ms) for "
                    "network %2!ws! (%3!ws!)\n",
                    Network->ConnectivityReportTimer,
                    networkId,
                    networkName
                    );
        }
    }

    return;

} // NmpStartNetworkConnectivityReportTimer


VOID
NmpStartNetworkStateRecalcTimer(
    PNM_NETWORK  Network,
    DWORD        Timeout
    )
{
    LPCWSTR   networkId = OmObjectId(Network);
    LPCWSTR   networkName = OmObjectName(Network);

    if (Network->StateRecalcTimer == 0) {
        Network->StateRecalcTimer = Timeout;

        ClRtlLogPrint(LOG_NOISE,
            "[NM] Started state recalculation timer (%1!u!ms) for "
            "network %2!ws! (%3!ws!)\n",
            Network->StateRecalcTimer,
            networkId,
            networkName
            );
    }

    return;

} // NmpStartNetworkStateRecalcTimer


VOID
NmpStartNetworkFailureIsolationTimer(
    PNM_NETWORK Network,
    DWORD Timeout
    )
{

    if (Network->FailureIsolationTimer == 0) {
        Network->FailureIsolationTimer = Timeout;

        ClRtlLogPrint(LOG_NOISE,
            "[NM] Started failure isolation timer (%1!u!ms) for "
            "network %2!ws! (%3!ws!)\n",
            Network->FailureIsolationTimer,
            OmObjectId(Network),
            OmObjectName(Network)
            );
    }

    return;

} // NmpStartNetworkFailureIsolationTimer


VOID
NmpStartNetworkRegistrationRetryTimer(
    PNM_NETWORK   Network
    )
{
    if (Network->RegistrationRetryTimer == 0) {
        if (Network->RegistrationRetryTimeout == 0) {
            Network->RegistrationRetryTimeout =
                NM_NET_MIN_REGISTRATION_RETRY_TIMEOUT;
        }
        else {
            //
            // Exponential backoff
            //
            Network->RegistrationRetryTimeout *= 2;

            if ( Network->RegistrationRetryTimeout >
                 NM_NET_MAX_REGISTRATION_RETRY_TIMEOUT
               )
            {
                Network->RegistrationRetryTimeout =
                    NM_NET_MAX_REGISTRATION_RETRY_TIMEOUT;
            }
        }

        Network->RegistrationRetryTimer = Network->RegistrationRetryTimeout;

        ClRtlLogPrint(LOG_NOISE,
            "[NM] Started registration retry timer (%1!u!ms) for "
            "network %2!ws! (%3!ws!)\n",
            Network->RegistrationRetryTimer,
            OmObjectId(Network),
            OmObjectName(Network)
            );
    }

    return;

} // NmpStartNetworkRegistrationRetryTimer


VOID
NmpScheduleNetworkConnectivityReport(
    PNM_NETWORK   Network
    )
/*++

Routine Description:

    Schedules a worker thread to deliver a connectivity report to
    the leader node for the specified network. Called when the
    ConnectivityReport timer expires for a network. Also called
    directly in some cases.

Arguments:

    A pointer to the network object for which to generate a report.

Return Value:

    None.

Notes:

    This routine is called with the NM lock held.

--*/
{
    DWORD status = ERROR_SUCCESS;

    //
    // Check if a worker thread is already scheduled.
    //
    if (!NmpIsConnectivityReportWorkerRunning) {
        status = NmpScheduleConnectivityReportWorker();
    }

    if (status == ERROR_SUCCESS) {
        //
        // We succeeded in scheduling a worker thread. Stop the
        // ConnectivityReport timer and set the work flag to generate
        // a report.
        //
        Network->ConnectivityReportTimer = 0;
        Network->Flags |= NM_FLAG_NET_REPORT_CONNECTIVITY;
        NmpNeedConnectivityReport = TRUE;
    }
    else {
        //
        // We failed to schedule a worker thread. Set the
        // ConnecivityReport timer to expire on the next tick, so we
        // can try again.
        //
        Network->ConnectivityReportTimer = 1;
    }

    return;

}  // NmpScheduleNetworkConnectivityReport


VOID
NmpScheduleNetworkStateRecalc(
    PNM_NETWORK   Network
    )
/*++

Routine Description:

    Schedules a worker thread to recalculate the state of the
    specified network and all of the network's interface. A network
    state recalculation can be triggered by the arrival of a connectivity
    report, the joining/death of a node, or a network role change.

Arguments:

    A pointer to the network object whose state is to be recalculated.

Return Value:

    None.

Notes:

    This routine is called with the NM lock held.

--*/
{
    DWORD     status = ERROR_SUCCESS;

    //
    // Check if a worker thread is already scheduled to
    // service this network.
    //
    if (!NmpIsNetworkWorkerRunning(Network)) {
        status = NmpScheduleNetworkWorker(Network);
    }

    if (status == ERROR_SUCCESS) {
        //
        // We succeeded in scheduling a worker thread. Stop the
        // StateRecalc timer and set the state recalculation work flag.
        //
        Network->StateRecalcTimer = 0;
        Network->Flags |= NM_FLAG_NET_RECALC_STATE;
    }
    else {
        //
        // We failed to schedule a worker thread. Set the StateRecalc
        // timer to expire on the next tick, so we can try again.
        //
        Network->ConnectivityReportTimer = 1;
    }

    return;

} // NmpScheduleNetworkStateRecalc


VOID
NmpScheduleNetworkRegistration(
    PNM_NETWORK   Network
    )
/*++

Routine Description:

    Schedules a worker thread to register a network with the cluster
    transport.

Arguments:

    A pointer to the network to register.

Return Value:

    None.

Notes:

    This routine is called with the NM lock held.

--*/
{
    DWORD     status = ERROR_SUCCESS;

    //
    // Check if a worker thread is already scheduled to
    // service this network.
    //
    if (!NmpIsNetworkWorkerRunning(Network)) {
        status = NmpScheduleNetworkWorker(Network);
    }

    if (status == ERROR_SUCCESS) {
        //
        // We succeeded in scheduling a worker thread. Stop the
        // retry timer and set the registration work flag.
        //
        Network->RegistrationRetryTimer = 0;
        Network->Flags |= NM_FLAG_NET_NEED_TO_REGISTER;
    }
    else {
        //
        // We failed to schedule a worker thread. Set the retry
        // timer to expire on the next tick, so we can try again.
        //
        Network->RegistrationRetryTimer = 1;
    }

    return;

} // NmpScheduleNetworkRegistration


DWORD
NmpScheduleConnectivityReportWorker(
    VOID
    )
/*++

Routine Description:

    Schedule a worker thread to deliver network connectivity reports.

Arguments:

    None.

Return Value:

    A Win32 status code.

Notes:

    Called with the NM global lock held.

--*/
{
    DWORD     status;


    ClRtlInitializeWorkItem(
        &NmpConnectivityReportWorkItem,
        NmpConnectivityReportWorker,
        NULL
        );

    status = ClRtlPostItemWorkQueue(
                 CsDelayedWorkQueue,
                 &NmpConnectivityReportWorkItem,
                 0,
                 0
                 );

    if (status == ERROR_SUCCESS) {
        NmpActiveThreadCount++;
        NmpIsConnectivityReportWorkerRunning = TRUE;

        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Scheduled network connectivity report worker thread.\n"
            );
    }
    else {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Failed to schedule network connectivity report worker "
            "thread, status %1!u!\n",
            status
            );
    }

    return(status);

}  // NmpScheduleConnectivityReportWorker


DWORD
NmpScheduleNetworkWorker(
    PNM_NETWORK   Network
    )
/*++

Routine Description:

    Schedule a worker thread to service this network

Arguments:

    Network - Pointer to the network for which to schedule a worker thread.

Return Value:

    A Win32 status code.

Notes:

    Called with the NM global lock held.

--*/
{
    DWORD     status;
    LPCWSTR   networkId = OmObjectId(Network);


    ClRtlInitializeWorkItem(
        &(Network->WorkItem),
        NmpNetworkWorker,
        (PVOID) Network
        );

    status = ClRtlPostItemWorkQueue(
                 CsDelayedWorkQueue,
                 &(Network->WorkItem),
                 0,
                 0
                 );

    if (status == ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Scheduled worker thread to service network %1!ws!.\n",
            networkId
            );

        NmpActiveThreadCount++;
        Network->Flags |= NM_FLAG_NET_WORKER_RUNNING;
        OmReferenceObject(Network);
    }
    else {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Failed to schedule worker thread to service network "
            "%1!ws!, status %2!u!\n",
            networkId,
            status
            );
    }

    return(status);

} // NmpScheduleNetworkWorker


DWORD
NmpReportNetworkConnectivity(
    IN PNM_NETWORK    Network
    )
/*+

Notes:

    Called with the NmpLock held.
    May be called by asynchronous worker threads.

--*/
{
    DWORD                    status = ERROR_SUCCESS;
    LPCWSTR                  networkId = OmObjectId(Network);


    //
    // Since this routine is called by asynchronous worker threads,
    // check if the report is still valid.
    //
    if (NmpIsNetworkRegistered(Network)) {
        PNM_CONNECTIVITY_VECTOR  vector = Network->ConnectivityVector;
        PNM_INTERFACE            localInterface = Network->LocalInterface;

        //
        // Record the information in our local data structures.
        //
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Updating local connectivity info for network %1!ws!.\n",
            networkId
            );

        NmpProcessInterfaceConnectivityReport(
            localInterface,
            vector
            );

        if (NmpLeaderNodeId != NmLocalNodeId) {
            //
            // Send the report to the leader via RPC.
            //
            PNM_CONNECTIVITY_VECTOR  tmpVector;
            DWORD                    vectorSize;
            LPCWSTR                  localInterfaceId =
                                         OmObjectId(localInterface);

            //
            // Allocate a temporary connectivity vector, since the
            // one in the network object can be resized during the
            // RPC call.
            //
            vectorSize = sizeof(NM_CONNECTIVITY_VECTOR) +
                         ((vector->EntryCount - 1) * sizeof(NM_STATE_ENTRY));

            tmpVector = LocalAlloc(LMEM_FIXED, vectorSize);

            if (tmpVector != NULL) {
                CopyMemory(tmpVector, vector, vectorSize);

                OmReferenceObject(Network);
                OmReferenceObject(localInterface);

                if (NM_NODE_UP(NmLocalNode) && (NmpState == NmStateOnline)) {
                    //
                    // This node is fully operational. Send the report
                    // directly to the leader.
                    //
                    PNM_NODE            node = NmpIdArray[NmpLeaderNodeId];
                    RPC_BINDING_HANDLE  rpcBinding = node->ReportRpcBinding;

                    OmReferenceObject(node);

                    status = NmpReportInterfaceConnectivity(
                                 rpcBinding,
                                 (LPWSTR) localInterfaceId,
                                 tmpVector,
                                 (LPWSTR) networkId
                                 );

                    OmDereferenceObject(node);
                }
                else if (CsJoinSponsorBinding != NULL) {
                    //
                    // This node is joining. Forward the report to the
                    // sponsor.
                    //
                    ClRtlLogPrint(LOG_UNUSUAL, 
                        "[NM] Reporting connectivity to sponsor for "
                        "network %1!ws!.\n",
                        networkId
                        );

                    NmpReleaseLock();

                    status = NmRpcReportJoinerInterfaceConnectivity(
                                 CsJoinSponsorBinding,
                                 NmpJoinSequence,
                                 NmLocalNodeIdString,
                                 (LPWSTR) localInterfaceId,
                                 tmpVector
                                 );

                    NmpAcquireLock();
                }
                else {
                    //
                    // This node must be shutting down
                    //
                    CL_ASSERT(NmpState == NmStateOfflinePending);
                    status = ERROR_SUCCESS;
                }

                if (status != ERROR_SUCCESS) {
                    ClRtlLogPrint(LOG_NOISE, 
                        "[NM] Failed to report connectivity for network "
                        "%1!ws!, status %2!u!.\n",
                        networkId,
                        status
                        );
                }

                LocalFree(tmpVector);

                OmDereferenceObject(localInterface);
                OmDereferenceObject(Network);
            }
            else {
                status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }

    return(status);

} // NmpReportNetworkConnectivity


VOID
NmpUpdateNetworkConnectivityForDownNode(
    PNM_NODE  Node
    )
/*++

Notes:

   Called with NmpLock held.

--*/
{
    PLIST_ENTRY              entry;
    PNM_NETWORK              network;
    LPCWSTR                  networkId;
    PNM_INTERFACE            netInterface;
    DWORD                    entryCount;
    DWORD                    i;
    PNM_CONNECTIVITY_MATRIX  matrixEntry;


    ClRtlLogPrint(LOG_NOISE,
        "[NM] Cleaning up network and interface states for dead node %1!u!\n",
        Node->NodeId
        );

    //
    // Walk the dead node's interface list and clean up the network and
    // interface states.
    //
    for (entry = Node->InterfaceList.Flink;
         entry != &(Node->InterfaceList);
         entry = entry->Flink
        )
    {
        netInterface = CONTAINING_RECORD(
                           entry,
                           NM_INTERFACE,
                           NodeLinkage
                           );

        network = netInterface->Network;
        networkId = OmObjectId(network);

        ClRtlLogPrint(LOG_NOISE,
            "[NM] Cleaning up state of network %1!ws!\n",
            networkId
            );

        //
        // Invalidate the connectivity data for this interface.
        //
        NmpSetInterfaceConnectivityData(
            network,
            netInterface->NetIndex,
            ClusterNetInterfaceUnavailable
            );

        //
        // If the local node is attached to the network, schedule a
        // connectivity report to the new leader.
        //
        if (NmpIsNetworkRegistered(network)) {
            NmpScheduleNetworkConnectivityReport(network);
        }

        //
        // If the local node is the (possibly new) leader, schedule
        // a state update. We explicitly enable this timer here in case
        // there are no active nodes attached to the network.
        //
        if (NmpLeaderNodeId == NmLocalNodeId) {
            NmpStartNetworkStateRecalcTimer(
                network,
                NM_NET_STATE_RECALC_TIMEOUT_AFTER_REGROUP
                );
        }
    }

    return;

}  // NmpUpdateNetworkConnectivityForDownNode


VOID
NmpFreeNetworkStateEnum(
    PNM_NETWORK_STATE_ENUM   NetworkStateEnum
    )
{
    PNM_NETWORK_STATE_INFO  networkStateInfo;
    DWORD                   i;


    for (i=0; i<NetworkStateEnum->NetworkCount; i++) {
        networkStateInfo = &(NetworkStateEnum->NetworkList[i]);

        if (networkStateInfo->Id != NULL) {
            MIDL_user_free(networkStateInfo->Id);
        }
    }

    MIDL_user_free(NetworkStateEnum);

    return;

}  // NmpFreeNetworkStateEnum


/////////////////////////////////////////////////////////////////////////////
//
// Database management routines
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmpCreateNetworkDefinition(
    IN PNM_NETWORK_INFO     NetworkInfo,
    IN HLOCALXSACTION       Xaction
    )
/*++

Routine Description:

    Creates a new network definition in the cluster database.

Arguments:

    NetworkInfo - A pointer to the information structure describing the
                  network to create.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code otherwise.

--*/
{
    DWORD     status;
    HDMKEY    networkKey = NULL;
    DWORD     valueLength;
    DWORD     disposition;


    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Creating database entry for network %1!ws!\n",
        NetworkInfo->Id
        );

    networkKey = DmLocalCreateKey(
                     Xaction,
                     DmNetworksKey,
                     NetworkInfo->Id,
                     0,
                     KEY_WRITE,
                     NULL,
                     &disposition
                     );

    if (networkKey == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to create network key, status %1!u!\n",
            status
            );
        return(status);
    }

    CL_ASSERT(disposition == REG_CREATED_NEW_KEY);

    //
    // Write the name value for this network
    //
    valueLength = (wcslen(NetworkInfo->Name) + 1) * sizeof(WCHAR);

    status = DmLocalSetValue(
                 Xaction,
                 networkKey,
                 CLUSREG_NAME_NET_NAME,
                 REG_SZ,
                 (CONST BYTE *) NetworkInfo->Name,
                 valueLength
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Set of network name value failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Write the description value for this network
    //
    valueLength = (wcslen(NetworkInfo->Description) + 1) * sizeof(WCHAR);

    status = DmLocalSetValue(
                 Xaction,
                 networkKey,
                 CLUSREG_NAME_NET_DESC,
                 REG_SZ,
                 (CONST BYTE *) NetworkInfo->Description,
                 valueLength
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Set of network description value failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Write the role value for this network
    //
    status = DmLocalSetValue(
                 Xaction,
                 networkKey,
                 CLUSREG_NAME_NET_ROLE,
                 REG_DWORD,
                 (CONST BYTE *) &(NetworkInfo->Role),
                 sizeof(DWORD)
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Set of network role value failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Write the priority value for this network
    //
    status = DmLocalSetValue(
                 Xaction,
                 networkKey,
                 CLUSREG_NAME_NET_PRIORITY,
                 REG_DWORD,
                 (CONST BYTE *) &(NetworkInfo->Priority),
                 sizeof(DWORD)
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Set of network priority value failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Write the transport value for this network
    //
    valueLength = (wcslen(NetworkInfo->Transport) + 1) * sizeof(WCHAR);

    status = DmLocalSetValue(
                 Xaction,
                 networkKey,
                 CLUSREG_NAME_NET_TRANSPORT,
                 REG_SZ,
                 (CONST BYTE *) NetworkInfo->Transport,
                 valueLength
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Set of network transport value failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Write the address value for this network
    //
    valueLength = (wcslen(NetworkInfo->Address) + 1) * sizeof(WCHAR);

    status = DmLocalSetValue(
                 Xaction,
                 networkKey,
                 CLUSREG_NAME_NET_ADDRESS,
                 REG_SZ,
                 (CONST BYTE *) NetworkInfo->Address,
                 valueLength
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Set of network address value failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Write the address mask value for this network
    //
    valueLength = (wcslen(NetworkInfo->AddressMask) + 1) * sizeof(WCHAR);

    status = DmLocalSetValue(
                 Xaction,
                 networkKey,
                 CLUSREG_NAME_NET_ADDRESS_MASK,
                 REG_SZ,
                 (CONST BYTE *) NetworkInfo->AddressMask,
                 valueLength
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Set of network address mask value failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    CL_ASSERT(status == ERROR_SUCCESS);

error_exit:

    if (networkKey != NULL) {
        DmCloseKey(networkKey);
    }

    return(status);

}  // NmpCreateNetworkDefinition


DWORD
NmpSetNetworkNameDefinition(
    IN PNM_NETWORK_INFO     NetworkInfo,
    IN HLOCALXSACTION       Xaction
    )

/*++

Routine Description:

    Changes the network name in the local database

Arguments:

    NetworkInfo - A pointer to the information structure describing the
                  network to create.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code otherwise.

--*/
{
    DWORD     status;
    HDMKEY    networkKey = NULL;
    DWORD     disposition;


    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Changing network name database entry for network %1!ws!\n",
        NetworkInfo->Id
        );

    //
    // Open the network's key.
    //
    networkKey = DmOpenKey(DmNetworksKey, NetworkInfo->Id, KEY_WRITE);

    if (networkKey == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to open network key, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    //
    // Write the name value for this network
    //

    status = DmLocalSetValue(
                 Xaction,
                 networkKey,
                 CLUSREG_NAME_NET_NAME,
                 REG_SZ,
                 (CONST BYTE *) NetworkInfo->Name,
                 NM_WCSLEN( NetworkInfo->Name )
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Set of network name value failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    CL_ASSERT(status == ERROR_SUCCESS);

error_exit:

    if (networkKey != NULL) {
        DmCloseKey(networkKey);
    }

    return(status);

}  // NmpSetNetworkNameDefinition


DWORD
NmpGetNetworkDefinition(
    IN  LPWSTR            NetworkId,
    OUT PNM_NETWORK_INFO  NetworkInfo
    )
/*++

Routine Description:

    Reads information about a defined cluster network from the cluster
    database and fills in a structure describing it.

Arguments:

    NetworkId   - A pointer to a unicode string containing the ID of the
                  network to query.

    NetworkInfo - A pointer to the network info structure to fill in.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

--*/

{
    DWORD                    status;
    HDMKEY                   networkKey = NULL;
    DWORD                    valueLength, valueSize;
    DWORD                    i;


    ZeroMemory(NetworkInfo, sizeof(NM_NETWORK_INFO));

    //
    // Open the network's key.
    //
    networkKey = DmOpenKey(DmNetworksKey, NetworkId, KEY_READ);

    if (networkKey == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to open network key, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    //
    // Copy the ID value.
    //
    NetworkInfo->Id = MIDL_user_allocate(NM_WCSLEN(NetworkId));

    if (NetworkInfo->Id == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    wcscpy(NetworkInfo->Id, NetworkId);

    //
    // Read the network's name.
    //
    valueLength = 0;

    status = NmpQueryString(
                 networkKey,
                 CLUSREG_NAME_NET_NAME,
                 REG_SZ,
                 &(NetworkInfo->Name),
                 &valueLength,
                 &valueSize
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Query of name value failed for network %1!ws!, "
            "status %2!u!.\n",
            NetworkId,
            status
            );
        goto error_exit;
    }

    //
    // Read the description value.
    //
    valueLength = 0;

    status = NmpQueryString(
                 networkKey,
                 CLUSREG_NAME_NET_DESC,
                 REG_SZ,
                 &(NetworkInfo->Description),
                 &valueLength,
                 &valueSize
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Query of description value failed for network %1!ws!, "
            "status %2!u!.\n",
            NetworkId,
            status
            );
        goto error_exit;
    }

    //
    // Read the role value.
    //
    status = DmQueryDword(
                 networkKey,
                 CLUSREG_NAME_NET_ROLE,
                 &(NetworkInfo->Role),
                 NULL
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Query of role value failed for network %1!ws!, "
            "status %2!u!.\n",
            NetworkId,
            status
            );
        goto error_exit;
    }

    //
    // Read the priority value.
    //
    status = DmQueryDword(
                 networkKey,
                 CLUSREG_NAME_NET_PRIORITY,
                 &(NetworkInfo->Priority),
                 NULL
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Query of priority value failed for network %1!ws!, "
            "status %2!u!.\n",
            NetworkId,
            status
            );
        goto error_exit;
    }

    //
    // Read the address value.
    //
    valueLength = 0;

    status = NmpQueryString(
                 networkKey,
                 CLUSREG_NAME_NET_ADDRESS,
                 REG_SZ,
                 &(NetworkInfo->Address),
                 &valueLength,
                 &valueSize
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Query of address value failed for network %1!ws!, "
            "status %2!u!.\n",
            NetworkId,
            status
            );
        goto error_exit;
    }

    //
    // Read the address mask.
    //
    valueLength = 0;

    status = NmpQueryString(
                 networkKey,
                 CLUSREG_NAME_NET_ADDRESS_MASK,
                 REG_SZ,
                 &(NetworkInfo->AddressMask),
                 &valueLength,
                 &valueSize
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Query of address mask value failed for network %1!ws!, "
            "status %2!u!.\n",
            NetworkId,
            status
            );
        goto error_exit;
    }

    //
    // Read the transport name.
    //
    valueLength = 0;

    status = NmpQueryString(
                 networkKey,
                 CLUSREG_NAME_NET_TRANSPORT,
                 REG_SZ,
                 &(NetworkInfo->Transport),
                 &valueLength,
                 &valueSize
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Query of transport value failed for network %1!ws!, "
            "status %2!u!.\n",
            NetworkId,
            status
            );
        goto error_exit;
    }

    CL_ASSERT(status == ERROR_SUCCESS);

error_exit:

    if (status != ERROR_SUCCESS) {
        ClNetFreeNetworkInfo(NetworkInfo);
    }

    if (networkKey != NULL) {
        DmCloseKey(networkKey);
    }

    return(status);

}  // NmpGetNetworkDefinition


DWORD
NmpEnumNetworkDefinitions(
    OUT PNM_NETWORK_ENUM *   NetworkEnum
    )
/*++

Routine Description:

    Reads information about defined cluster networks from the cluster
    database. and builds an enumeration structure to hold the information.

Arguments:

    NetworkEnum -  A pointer to the variable into which to place a pointer to
                   the allocated network enumeration.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

--*/

{
    DWORD              status;
    PNM_NETWORK_ENUM   networkEnum = NULL;
    PNM_NETWORK_INFO   networkInfo;
    WCHAR              networkId[CS_NETWORK_ID_LENGTH + 1];
    DWORD              i;
    DWORD              valueLength;
    DWORD              numNetworks;
    DWORD              ignored;
    FILETIME           fileTime;


    *NetworkEnum = NULL;

    //
    // First count the number of networks.
    //
    status = DmQueryInfoKey(
                 DmNetworksKey,
                 &numNetworks,
                 &ignored,   // MaxSubKeyLen
                 &ignored,   // Values
                 &ignored,   // MaxValueNameLen
                 &ignored,   // MaxValueLen
                 &ignored,   // lpcbSecurityDescriptor
                 &fileTime
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to query Networks key information, status %1!u!\n",
            status
            );
        return(status);
    }

    if (numNetworks == 0) {
        valueLength = sizeof(NM_NETWORK_ENUM);

    }
    else {
        valueLength = sizeof(NM_NETWORK_ENUM) +
                      (sizeof(NM_NETWORK_INFO) * (numNetworks-1));
    }

    valueLength = sizeof(NM_NETWORK_ENUM) +
                  (sizeof(NM_NETWORK_INFO) * (numNetworks-1));

    networkEnum = MIDL_user_allocate(valueLength);

    if (networkEnum == NULL) {
        ClRtlLogPrint(LOG_CRITICAL, "[NM] Failed to allocate memory.\n");
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    ZeroMemory(networkEnum, valueLength);

    for (i=0; i < numNetworks; i++) {
        networkInfo = &(networkEnum->NetworkList[i]);

        valueLength = sizeof(networkId);

        status = DmEnumKey(
                     DmNetworksKey,
                     i,
                     &(networkId[0]),
                     &valueLength,
                     NULL
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Failed to enumerate network key, status %1!u!\n",
                status
                );
            goto error_exit;
        }

        status = NmpGetNetworkDefinition(networkId, networkInfo);

        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }

        networkEnum->NetworkCount++;
    }

    *NetworkEnum = networkEnum;

    return(ERROR_SUCCESS);


error_exit:

    if (networkEnum != NULL) {
        ClNetFreeNetworkEnum(networkEnum);
    }

    return(status);
}


/////////////////////////////////////////////////////////////////////////////
//
// Object management routines
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmpCreateNetworkObjects(
    IN  PNM_NETWORK_ENUM    NetworkEnum
    )
/*++

Routine Description:

    Processes a network information enumeration and creates network objects.

Arguments:

    NetworkEnum - A pointer to a network information enumeration structure.

Return Value:

    ERROR_SUCCESS if the routine completes successfully.
    A Win32 error code otherwise.

--*/
{
    DWORD             status = ERROR_SUCCESS;
    PNM_NETWORK_INFO  networkInfo;
    PNM_NETWORK       network;
    DWORD             i;


    for (i=0; i < NetworkEnum->NetworkCount; i++) {
        networkInfo = &(NetworkEnum->NetworkList[i]);

        network = NmpCreateNetworkObject(networkInfo);

        if (network == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Failed to create network %1!ws!, status %2!u!.\n",
                networkInfo->Id,
                status
                );
            break;
        }
        else {
            OmDereferenceObject(network);
        }
    }

    return(status);

}  // NmpCreateNetworkObjects


PNM_NETWORK
NmpCreateNetworkObject(
    IN  PNM_NETWORK_INFO   NetworkInfo
    )
/*++

Routine Description:

    Instantiates a cluster network object.

Arguments:

    NetworkInfo - A pointer to a structure describing the network to create.

Return Value:

    A pointer to the new network object on success.
    NULL on failure.

--*/
{
    DWORD           status;
    PNM_NETWORK     network = NULL;
    BOOL            created = FALSE;
    DWORD           i;


    ClRtlLogPrint(LOG_NOISE,
        "[NM] Creating object for network %1!ws! (%2!ws!).\n",
        NetworkInfo->Id,
        NetworkInfo->Name
        );

    //
    // Make sure that an object with the same name doesn't already exist.
    //
    network = OmReferenceObjectById(ObjectTypeNetwork, NetworkInfo->Id);

    if (network != NULL) {
        OmDereferenceObject(network);
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] A network object named %1!ws! already exists. Cannot "
            "create a new network with the same name.\n",
            NetworkInfo->Id
            );
        SetLastError(ERROR_OBJECT_ALREADY_EXISTS);
        return(NULL);
    }

    //
    // Ensure that the IP (sub)network is unique in the cluster. Two
    // nodes can race to create a new network in some cases.
    //
    network = NmpReferenceNetworkByAddress(
                  NetworkInfo->Address
                  );

    if (network != NULL) {
        OmDereferenceObject(network);
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] A network object already exists for IP network %1!ws!. "
            "Cannot create a new network with the same address.\n",
            NetworkInfo->Address
            );
        SetLastError(ERROR_OBJECT_ALREADY_EXISTS);
        return(NULL);
    }

    //
    // Create a network object.
    //
    network = OmCreateObject(
                 ObjectTypeNetwork,
                 NetworkInfo->Id,
                 NetworkInfo->Name,
                 &created
                 );

    if (network == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to create object for network %1!ws! (%2!ws!), status %3!u!\n",
            NetworkInfo->Id,
            NetworkInfo->Name,
            status
            );
        goto error_exit;
    }

    CL_ASSERT(created == TRUE);

    //
    // Initialize the network object
    //
    ZeroMemory(network, sizeof(NM_NETWORK));

    network->ShortId = InterlockedIncrement(&NmpNextNetworkShortId);
    network->State = ClusterNetworkUnavailable;
    network->Role = NetworkInfo->Role;
    network->Priority = NetworkInfo->Priority;
    network->Description = NetworkInfo->Description;
    NetworkInfo->Description = NULL;
    network->Transport = NetworkInfo->Transport;
    NetworkInfo->Transport = NULL;
    network->Address = NetworkInfo->Address;
    NetworkInfo->Address = NULL;
    network->AddressMask = NetworkInfo->AddressMask;
    NetworkInfo->AddressMask = NULL;
    InitializeListHead(&(network->InterfaceList));
    InitializeListHead(&(network->McastAddressReleaseList));

    //
    // Allocate an initial connectivity vector.
    // Note that we get one vector entry as part of
    // the NM_CONNECTIVITY_VECTOR structure.
    //
#define NM_INITIAL_VECTOR_SIZE   2

    network->ConnectivityVector = LocalAlloc(
                                      LMEM_FIXED,
                                      ( sizeof(NM_CONNECTIVITY_VECTOR) +
                                        ( ((NM_INITIAL_VECTOR_SIZE) - 1) *
                                          sizeof(NM_STATE_ENTRY)
                                        )
                                      ));

    if (network->ConnectivityVector == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to allocate memory for connectivity vector\n"
            );
        goto error_exit;
    }

    network->ConnectivityVector->EntryCount = NM_INITIAL_VECTOR_SIZE;

    FillMemory(
        &(network->ConnectivityVector->Data[0]),
        NM_INITIAL_VECTOR_SIZE * sizeof(NM_STATE_ENTRY),
        (UCHAR) ClusterNetInterfaceStateUnknown
        );

    //
    // Allocate a state work vector
    //
    network->StateWorkVector = LocalAlloc(
                                   LMEM_FIXED,
                                   (NM_INITIAL_VECTOR_SIZE) *
                                     sizeof(NM_STATE_WORK_ENTRY)
                                   );

    if (network->StateWorkVector == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to allocate memory for state work vector\n"
            );
        goto error_exit;
    }

    //
    // Initialize the state work vector
    //
    for (i=0; i<NM_INITIAL_VECTOR_SIZE; i++) {
        network->StateWorkVector[i].State =
            (NM_STATE_ENTRY) ClusterNetInterfaceStateUnknown;
    }

    //
    // Put a reference on the object for the caller.
    //
    OmReferenceObject(network);

    NmpAcquireLock();

    //
    // Allocate the corresponding connectivity matrix
    //
    network->ConnectivityMatrix =
        LocalAlloc(
            LMEM_FIXED,
            NM_SIZEOF_CONNECTIVITY_MATRIX(NM_INITIAL_VECTOR_SIZE)
            );

    if (network->ConnectivityMatrix == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        NmpReleaseLock();
        OmDereferenceObject(network);
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to allocate memory for connectivity matrix\n"
            );
        goto error_exit;
    }

    //
    // Initialize the matrix
    //
    FillMemory(
        network->ConnectivityMatrix,
        NM_SIZEOF_CONNECTIVITY_MATRIX(NM_INITIAL_VECTOR_SIZE),
        (UCHAR) ClusterNetInterfaceStateUnknown
        );

    //
    // Make the network object available.
    //
    InsertTailList(&NmpNetworkList, &(network->Linkage));
    NmpNetworkCount++;

    if (NmpIsNetworkForInternalUse(network)) {
        NmpInsertInternalNetwork(network);
        NmpInternalNetworkCount++;
    }

    if (NmpIsNetworkForClientAccess(network)) {
        NmpClientNetworkCount++;
    }

    network->Flags |= NM_FLAG_OM_INSERTED;
    OmInsertObject(network);

    NmpReleaseLock();

    return(network);

error_exit:

    if (network != NULL) {
        NmpAcquireLock();
        NmpDeleteNetworkObject(network, FALSE);
        NmpReleaseLock();
    }

    SetLastError(status);

    return(NULL);

}  // NmpCreateNetworkObject



DWORD
NmpGetNetworkObjectInfo(
    IN  PNM_NETWORK        Network,
    OUT PNM_NETWORK_INFO   NetworkInfo
    )
/*++

Routine Description:

    Reads information about a defined cluster network from the
    network object and fills in a structure describing it.

Arguments:

    Network     - A pointer to the network object to query.

    NetworkInfo - A pointer to the structure to fill in with network
                    information.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

    Called with NmpLock held.

--*/

{
    DWORD      status = ERROR_NOT_ENOUGH_MEMORY;
    LPWSTR     tmpString = NULL;
    LPWSTR     networkId = (LPWSTR) OmObjectId(Network);
    LPWSTR     networkName = (LPWSTR) OmObjectName(Network);


    ZeroMemory(NetworkInfo, sizeof(NM_NETWORK_INFO));

    tmpString = MIDL_user_allocate(NM_WCSLEN(networkId));
    if (tmpString == NULL) {
        goto error_exit;
    }
    wcscpy(tmpString, networkId);
    NetworkInfo->Id = tmpString;

    tmpString = MIDL_user_allocate(NM_WCSLEN(networkName));
    if (tmpString == NULL) {
        goto error_exit;
    }
    wcscpy(tmpString, networkName);
    NetworkInfo->Name = tmpString;

    tmpString = MIDL_user_allocate(NM_WCSLEN(Network->Description));
    if (tmpString == NULL) {
        goto error_exit;
    }
    wcscpy(tmpString, Network->Description);
    NetworkInfo->Description = tmpString;

    NetworkInfo->Role = Network->Role;
    NetworkInfo->Priority = Network->Priority;

    tmpString = MIDL_user_allocate(NM_WCSLEN(Network->Transport));
    if (tmpString == NULL) {
        goto error_exit;
    }
    wcscpy(tmpString, Network->Transport);
    NetworkInfo->Transport = tmpString;

    tmpString = MIDL_user_allocate(NM_WCSLEN(Network->Address));
    if (tmpString == NULL) {
        goto error_exit;
    }
    wcscpy(tmpString, Network->Address);
    NetworkInfo->Address = tmpString;

    tmpString = MIDL_user_allocate(NM_WCSLEN(Network->AddressMask));
    if (tmpString == NULL) {
        goto error_exit;
    }
    wcscpy(tmpString, Network->AddressMask);
    NetworkInfo->AddressMask = tmpString;

    return(ERROR_SUCCESS);

error_exit:

    ClNetFreeNetworkInfo(NetworkInfo);

    return(status);

}  // NmpGetNetworkObjectInfo


VOID
NmpDeleteNetworkObject(
    IN PNM_NETWORK  Network,
    IN BOOLEAN      IssueEvent
    )
/*++

Routine Description:

    Deletes a cluster network object.

Arguments:

    Network - A pointer to the network object to delete.

    IssueEvent - TRUE if a NETWORK_DELETED event should be issued when this
                 object is created. FALSE otherwise.

Return Value:

    None.

Notes:

    Called with NM global lock held.

--*/
{
    DWORD           status;
    PLIST_ENTRY     entry;
    LPWSTR          networkId = (LPWSTR) OmObjectId(Network);
    BOOLEAN         wasInternalNetwork = FALSE;


    if (NM_DELETE_PENDING(Network)) {
        CL_ASSERT(!NM_OM_INSERTED(Network));
        return;
    }

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Deleting object for network %1!ws!.\n",
        networkId
        );

    CL_ASSERT(IsListEmpty(&(Network->InterfaceList)));

    Network->Flags |= NM_FLAG_DELETE_PENDING;

    //
    // Remove from the object lists
    //
    if (NM_OM_INSERTED(Network)) {
        status = OmRemoveObject(Network);
        CL_ASSERT(status == ERROR_SUCCESS);

        Network->Flags &= ~NM_FLAG_OM_INSERTED;

        RemoveEntryList(&(Network->Linkage));
        CL_ASSERT(NmpNetworkCount > 0);
        NmpNetworkCount--;

        if (NmpIsNetworkForInternalUse(Network)) {
            RemoveEntryList(&(Network->InternalLinkage));
            CL_ASSERT(NmpInternalNetworkCount > 0);
            NmpInternalNetworkCount--;
            wasInternalNetwork = TRUE;
        }

        if (NmpIsNetworkForClientAccess(Network)) {
            CL_ASSERT(NmpClientNetworkCount > 0);
            NmpClientNetworkCount--;
        }
    }

    //
    // Place the object on the deleted list
    //
#if DBG
    {
        PLIST_ENTRY  entry;

        for ( entry = NmpDeletedNetworkList.Flink;
              entry != &NmpDeletedNetworkList;
              entry = entry->Flink
            )
        {
            if (entry == &(Network->Linkage)) {
                break;
            }
        }

        CL_ASSERT(entry != &(Network->Linkage));
    }
#endif DBG

    InsertTailList(&NmpDeletedNetworkList, &(Network->Linkage));

    if (NmpIsNetworkEnabledForUse(Network)) {
        //
        // Deregister the network from the cluster transport
        //
        NmpDeregisterNetwork(Network);
    }

    //
    // Issue an event if needed
    //
    if (IssueEvent) {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Issuing network deleted event for network %1!ws!.\n",
            networkId
            );

        ClusterEvent(CLUSTER_EVENT_NETWORK_DELETED, Network);

        //
        // Issue a cluster property change event if this network was
        // used for internal communication. The network priority list
        // was changed.
        //
        if (wasInternalNetwork) {
            NmpIssueClusterPropertyChangeEvent();
        }
    }

    //
    // Remove the initial reference so the object can be destroyed.
    //
    OmDereferenceObject(Network);

    return;

}  // NmpDeleteNetworkObject


BOOL
NmpDestroyNetworkObject(
    PNM_NETWORK  Network
    )
{
    DWORD  status;


    ClRtlLogPrint(LOG_NOISE, 
        "[NM] destroying object for network %1!ws!\n",
        OmObjectId(Network)
        );

    CL_ASSERT(NM_DELETE_PENDING(Network));
    CL_ASSERT(!NM_OM_INSERTED(Network));
    CL_ASSERT(Network->InterfaceCount == 0);

    //
    // Remove the network from the deleted list
    //
#if DBG
    {
        PLIST_ENTRY  entry;

        for ( entry = NmpDeletedNetworkList.Flink;
              entry != &NmpDeletedNetworkList;
              entry = entry->Flink
            )
        {
            if (entry == &(Network->Linkage)) {
                break;
            }
        }

        CL_ASSERT(entry == &(Network->Linkage));
    }
#endif DBG

    RemoveEntryList(&(Network->Linkage));

    NM_FREE_OBJECT_FIELD(Network, Description);
    NM_FREE_OBJECT_FIELD(Network, Transport);
    NM_FREE_OBJECT_FIELD(Network, Address);
    NM_FREE_OBJECT_FIELD(Network, AddressMask);

    if (Network->ConnectivityVector != NULL) {
        LocalFree(Network->ConnectivityVector);
        Network->ConnectivityVector = NULL;
    }

    if (Network->StateWorkVector != NULL) {
        LocalFree(Network->StateWorkVector);
        Network->StateWorkVector = NULL;
    }

    if (Network->ConnectivityMatrix != NULL) {
        LocalFree(Network->ConnectivityMatrix);
        Network->ConnectivityMatrix = NULL;
    }

    NM_MIDL_FREE_OBJECT_FIELD(Network, MulticastAddress);
    NM_MIDL_FREE_OBJECT_FIELD(Network, MulticastKey);
    NM_MIDL_FREE_OBJECT_FIELD(Network, MulticastKeySalt);
    NM_MIDL_FREE_OBJECT_FIELD(Network, MulticastLeaseServer);
    NM_MIDL_FREE_OBJECT_FIELD(Network, MulticastLeaseRequestId.ClientUID);

    NmpFreeMulticastAddressReleaseList(Network);

    return(TRUE);

}  // NmpDestroyNetworkObject


DWORD
NmpEnumNetworkObjects(
    OUT PNM_NETWORK_ENUM *   NetworkEnum
    )
/*++

Routine Description:

    Reads information about defined cluster networks from the cluster
    objects and builds an enumeration structure to hold the information.

Arguments:

    NetworkEnum -  A pointer to the variable into which to place a pointer to
                   the allocated network enumeration.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

    Called with the NmpLock held.

--*/

{
    DWORD              status = ERROR_SUCCESS;
    PNM_NETWORK_ENUM   networkEnum = NULL;
    DWORD              i;
    DWORD              valueLength;
    PLIST_ENTRY        entry;
    PNM_NETWORK        network;


    *NetworkEnum = NULL;

    if (NmpNetworkCount == 0) {
        valueLength = sizeof(NM_NETWORK_ENUM);

    }
    else {
        valueLength = sizeof(NM_NETWORK_ENUM) +
                      (sizeof(NM_NETWORK_INFO) * (NmpNetworkCount - 1));
    }

    networkEnum = MIDL_user_allocate(valueLength);

    if (networkEnum == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    ZeroMemory(networkEnum, valueLength);

    for (entry = NmpNetworkList.Flink, i=0;
         entry != &NmpNetworkList;
         entry = entry->Flink, i++
        )
    {
        network = CONTAINING_RECORD(entry, NM_NETWORK, Linkage);

        status = NmpGetNetworkObjectInfo(
                     network,
                     &(networkEnum->NetworkList[i])
                     );

        if (status != ERROR_SUCCESS) {
            ClNetFreeNetworkEnum(networkEnum);
            return(status);
        }
    }

    networkEnum->NetworkCount = NmpNetworkCount;
    *NetworkEnum = networkEnum;
    networkEnum = NULL;

    return(ERROR_SUCCESS);

}  // NmpEnumNetworkObjects


DWORD
NmpEnumNetworkObjectStates(
    OUT PNM_NETWORK_STATE_ENUM *  NetworkStateEnum
    )
/*++

Routine Description:

    Reads state information for all defined cluster networks
    and fills in an enumeration structure.

Arguments:

    NetworkStateEnum -  A pointer to the variable into which to place a
                        pointer to the allocated interface enumeration.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

    Called with the NmpLock held.

--*/

{
    DWORD                      status = ERROR_SUCCESS;
    PNM_NETWORK_STATE_ENUM     networkStateEnum = NULL;
    PNM_NETWORK_STATE_INFO     networkStateInfo;
    DWORD                      i;
    DWORD                      valueLength;
    PLIST_ENTRY                entry;
    PNM_NETWORK                network;
    LPWSTR                     networkId;


    *NetworkStateEnum = NULL;

    if (NmpNetworkCount == 0) {
        valueLength = sizeof(NM_NETWORK_STATE_ENUM);
    }
    else {
        valueLength =
            sizeof(NM_NETWORK_STATE_ENUM) +
            (sizeof(NM_NETWORK_STATE_INFO) * (NmpNetworkCount - 1));
    }

    networkStateEnum = MIDL_user_allocate(valueLength);

    if (networkStateEnum == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    ZeroMemory(networkStateEnum, valueLength);

    for (entry = NmpNetworkList.Flink, i=0;
         entry != &NmpNetworkList;
         entry = entry->Flink, i++
        )
    {
        network = CONTAINING_RECORD(entry, NM_NETWORK, Linkage);
        networkId = (LPWSTR) OmObjectId(network);
        networkStateInfo = &(networkStateEnum->NetworkList[i]);

        networkStateInfo->State = network->State;

        networkStateInfo->Id = MIDL_user_allocate(NM_WCSLEN(networkId));

        if (networkStateInfo->Id == NULL) {
            NmpFreeNetworkStateEnum(networkStateEnum);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        lstrcpyW(networkStateInfo->Id, networkId);
    }

    networkStateEnum->NetworkCount = NmpNetworkCount;
    *NetworkStateEnum = networkStateEnum;

    return(ERROR_SUCCESS);

}  // NmpEnumNetworkObjectStates


/////////////////////////////////////////////////////////////////////////////
//
// Miscellaneous routines
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmpRegisterNetwork(
    IN PNM_NETWORK   Network,
    IN BOOLEAN       RetryOnFailure
    )
/*++

Routine Description:

    Registers a network and the associated interfaces with the
    cluster transport and brings the network online.

Arguments:

    Network - A pointer to the network to register.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code otherwise.

Notes:

    Called with the NmpLock held.

--*/
{
    PLIST_ENTRY     entry;
    PNM_INTERFACE   netInterface;
    DWORD           status = ERROR_SUCCESS;
    DWORD           tempStatus;
    PVOID           tdiAddress = NULL;
    ULONG           tdiAddressLength = 0;
    LPWSTR          networkId = (LPWSTR) OmObjectId(Network);
    PVOID           tdiAddressInfo = NULL;
    ULONG           tdiAddressInfoLength = 0;
    DWORD           responseLength;
    PNM_INTERFACE   localInterface = Network->LocalInterface;
    BOOLEAN         restricted = FALSE;
    BOOLEAN         registered = FALSE;


    if (Network->LocalInterface != NULL) {
        if (!NmpIsNetworkRegistered(Network)) {
            //
            // Register the network
            //
            ClRtlLogPrint(LOG_NOISE, 
                "[NM] Registering network %1!ws! (%2!ws!) with cluster "
                "transport.\n",
                networkId,
                OmObjectName(Network)
                );

            if (!NmpIsNetworkForInternalUse(Network)) {
                restricted = TRUE;
            }

            status = ClusnetRegisterNetwork(
                         NmClusnetHandle,
                         Network->ShortId,
                         Network->Priority,
                         restricted
                         );

            if (status == ERROR_SUCCESS) {
                registered = TRUE;

                //
                // Bring the network online.
                //
                ClRtlLogPrint(LOG_NOISE, 
                    "[NM] Bringing network %1!ws! online.\n",
                    networkId
                    );

                status = ClRtlBuildTcpipTdiAddress(
                             localInterface->Address,
                             localInterface->ClusnetEndpoint,
                             &tdiAddress,
                             &tdiAddressLength
                             );

                if (status == ERROR_SUCCESS) {
                    ClRtlQueryTcpipInformation(
                        NULL,
                        NULL,
                        &tdiAddressInfoLength
                        );

                    tdiAddressInfo = LocalAlloc(
                                         LMEM_FIXED,
                                         tdiAddressInfoLength
                                         );

                    if (tdiAddressInfo != NULL) {
                        responseLength = tdiAddressInfoLength;

                        status = ClusnetOnlineNetwork(
                                     NmClusnetHandle,
                                     Network->ShortId,
                                     L"\\Device\\Udp",
                                     tdiAddress,
                                     tdiAddressLength,
                                     localInterface->AdapterId,
                                     tdiAddressInfo,
                                     &responseLength
                                     );

                        if (status != ERROR_SUCCESS) {
                            ClRtlLogPrint(LOG_CRITICAL, 
                                "[NM] Cluster transport failed to bring "
                                "network %1!ws! online, status %2!u!.\n",
                                networkId,
                                status
                                );
                        }
                        else {
                            CL_ASSERT(responseLength == tdiAddressInfoLength);
                        }

                        LocalFree(tdiAddressInfo);
                    }
                    else {
                        status = ERROR_NOT_ENOUGH_MEMORY;
                        ClRtlLogPrint(LOG_UNUSUAL, 
                            "[NM] Failed to allocate memory to register "
                            "network %1!ws! with cluster transport.\n",
                            networkId
                            );
                    }

                    LocalFree(tdiAddress);
                }
                else {
                    ClRtlLogPrint(LOG_CRITICAL, 
                        "[NM] Failed to build address to register "
                        "network %1!ws! withh cluster transport, "
                        "status %2!u!.\n",
                        networkId,
                        status
                        );
                }
            }
            else {
                ClRtlLogPrint(LOG_CRITICAL, 
                    "[NM] Failed to register network %1!ws! with cluster "
                    "transport, status %2!u!.\n",
                    networkId,
                    status
                    );
            }

            if (status == ERROR_SUCCESS) {
                Network->Flags |= NM_FLAG_NET_REGISTERED;
                Network->RegistrationRetryTimeout = 0;
            }
            else {
                WCHAR  string[16];

                wsprintfW(&(string[0]), L"%u", status);

                CsLogEvent2(
                    LOG_UNUSUAL,
                    NM_EVENT_REGISTER_NETWORK_FAILED,
                    OmObjectName(Network),
                    string
                    );

                if (registered) {
                    NmpDeregisterNetwork(Network);
                }

                //
                // Retry if the error is transient.
                //
                if ( RetryOnFailure &&
                     ( (status == ERROR_INVALID_NETNAME) ||
                       (status == ERROR_NOT_ENOUGH_MEMORY) ||
                       (status == ERROR_NO_SYSTEM_RESOURCES)
                     )
                   )
                {
                    NmpStartNetworkRegistrationRetryTimer(Network);

                    status = ERROR_SUCCESS;
                }

                return(status);
            }
        }

        //
        // Register the network's interfaces.
        //
        for (entry = Network->InterfaceList.Flink;
             entry != &(Network->InterfaceList);
             entry = entry->Flink
            )
        {
            netInterface = CONTAINING_RECORD(
                               entry,
                               NM_INTERFACE,
                               NetworkLinkage
                               );

            if (!NmpIsInterfaceRegistered(netInterface)) {
                tempStatus = NmpRegisterInterface(
                                 netInterface,
                                 RetryOnFailure
                                 );

                if (tempStatus != ERROR_SUCCESS) {
                    status = tempStatus;
                }
            }
        }
    }


    return(status);

}  // NmpRegisterNetwork


VOID
NmpDeregisterNetwork(
    IN  PNM_NETWORK   Network
    )
/*++

Routine Description:

    Deregisters a network and the associated interfaces from the
    cluster transport.

Arguments:

    Network - A pointer to the network to deregister.

Return Value:

    None.

Notes:

    Called with the NmpLock held.

--*/
{
    DWORD           status;
    PNM_INTERFACE   netInterface;
    PLIST_ENTRY     entry;


    ClRtlLogPrint(LOG_NOISE,
        "[NM] Deregistering network %1!ws! (%2!ws!) from cluster transport.\n",
        OmObjectId(Network),
        OmObjectName(Network)
        );

    status = ClusnetDeregisterNetwork(
                 NmClusnetHandle,
                 Network->ShortId
                 );

    CL_ASSERT(
        (status == ERROR_SUCCESS) ||
        (status == ERROR_CLUSTER_NETWORK_NOT_FOUND)
        );

    //
    // Mark all of the network's interfaces as deregistered.
    //
    for (entry = Network->InterfaceList.Flink;
         entry != &(Network->InterfaceList);
         entry = entry->Flink
        )
    {
        netInterface = CONTAINING_RECORD(entry, NM_INTERFACE, NetworkLinkage);

        netInterface->Flags &= ~NM_FLAG_IF_REGISTERED;
    }

    //
    // Mark the network as deregistered
    //
    Network->Flags &= ~NM_FLAG_NET_REGISTERED;

    return;

} // NmpDeregisterNetwork


VOID
NmpInsertInternalNetwork(
    PNM_NETWORK   Network
    )
/*++

Routine Description:

    Inserts a network into internal networks list based on its priority.

Arguments:

    Network - A pointer to the network object to be inserted.

Return Value:

    None.

Notes:

    Called with the NmpLock held.

--*/
{
    PLIST_ENTRY    entry;
    PNM_NETWORK    network;


    //
    // Maintain internal networks in highest to lowest
    // (numerically lowest to highest) priority order.
    //
    for (entry = NmpInternalNetworkList.Flink;
         entry != &NmpInternalNetworkList;
         entry = entry->Flink
        )
    {
        network = CONTAINING_RECORD(entry, NM_NETWORK, InternalLinkage);

        if (Network->Priority < network->Priority) {
            break;
        }
    }

    //
    // Insert the network in front of this entry.
    //
    InsertTailList(entry, &(Network->InternalLinkage));

    return;

}  // NmpInsertNetwork


DWORD
NmpValidateNetworkRoleChange(
    PNM_NETWORK            Network,
    CLUSTER_NETWORK_ROLE   NewRole
    )
{
    if ( !(NewRole & ClusterNetworkRoleInternalUse) &&
         NmpIsNetworkForInternalUse(Network)
       )
    {
        //
        // This change eliminates an internal network. This is only
        // legal if we would still have at least one internal network
        // between all active nodes.
        //
        if ((NmpInternalNetworkCount < 2) || !NmpVerifyConnectivity(Network)) {
            return(ERROR_CLUSTER_LAST_INTERNAL_NETWORK);
        }
    }

    if ( ( !(NewRole & ClusterNetworkRoleClientAccess) )
         &&
         NmpIsNetworkForClientAccess(Network)
       )
    {
        BOOL  hasDependents;

        //
        // This change eliminates a public network. This is only
        // legal if there are no dependencies (IP address resources) on
        // the network.
        //
        NmpReleaseLock();

        hasDependents = FmCheckNetworkDependency(OmObjectId(Network));

        NmpAcquireLock();

        if (hasDependents) {
            return(ERROR_CLUSTER_NETWORK_HAS_DEPENDENTS);
        }
    }

    return(ERROR_SUCCESS);

}  // NmpValidateNetworkRoleChange


BOOLEAN
NmpVerifyNodeConnectivity(
    PNM_NODE      Node1,
    PNM_NODE      Node2,
    PNM_NETWORK   ExcludedNetwork
    )
{
    PLIST_ENTRY      ifEntry1, ifEntry2;
    PNM_NETWORK      network;
    PNM_INTERFACE    interface1, interface2;


    for (ifEntry1 = Node1->InterfaceList.Flink;
         ifEntry1 != &(Node1->InterfaceList);
         ifEntry1 = ifEntry1->Flink
        )
    {
        interface1 = CONTAINING_RECORD(
                         ifEntry1,
                         NM_INTERFACE,
                         NodeLinkage
                         );

        network = interface1->Network;

        if ( (network != ExcludedNetwork) &&
             NmpIsNetworkForInternalUse(network)
           )
        {
            for (ifEntry2 = Node2->InterfaceList.Flink;
                 ifEntry2 != &(Node2->InterfaceList);
                 ifEntry2 = ifEntry2->Flink
                )
            {
                interface2 = CONTAINING_RECORD(
                                 ifEntry2,
                                 NM_INTERFACE,
                                 NodeLinkage
                                 );

                if (interface2->Network == interface1->Network) {
                    ClRtlLogPrint(LOG_NOISE, 
                        "[NM] nodes %1!u! & %2!u! are connected over "
                        "network %3!ws!\n",
                        Node1->NodeId,
                        Node2->NodeId,
                        OmObjectId(interface1->Network)
                        );
                    return(TRUE);
                }
            }
        }
    }

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Nodes %1!u! & %2!u! are not connected over any internal "
        "networks\n",
        Node1->NodeId,
        Node2->NodeId
        );

    return(FALSE);

}  // NmpVerifyNodeConnectivity


BOOLEAN
NmpVerifyConnectivity(
    PNM_NETWORK   ExcludedNetwork
    )
{
    PLIST_ENTRY    node1Entry, node2Entry;
    PNM_NODE       node1, node2;


    ClRtlLogPrint(LOG_NOISE, "[NM] Verifying connectivity\n");

    for (node1Entry = NmpNodeList.Flink;
         node1Entry != &NmpNodeList;
         node1Entry = node1Entry->Flink
        )
    {
        node1 = CONTAINING_RECORD(
                         node1Entry,
                         NM_NODE,
                         Linkage
                         );

        if (NM_NODE_UP(node1)) {
            for (node2Entry = node1->Linkage.Flink;
                 node2Entry != &NmpNodeList;
                 node2Entry = node2Entry->Flink
                )
            {
                node2 = CONTAINING_RECORD(
                                 node2Entry,
                                 NM_NODE,
                                 Linkage
                                 );

                if (NM_NODE_UP(node2)) {
                    ClRtlLogPrint(LOG_NOISE, 
                        "[NM] Verifying nodes %1!u! & %2!u! are connected\n",
                        node1->NodeId,
                        node2->NodeId
                        );

                    if (!NmpVerifyNodeConnectivity(
                            node1,
                            node2,
                            ExcludedNetwork
                            )
                        )
                    {
                        return(FALSE);
                    }
                }
            }
        }
    }

    return(TRUE);

}  // NmpVerifyConnectivity


VOID
NmpIssueClusterPropertyChangeEvent(
    VOID
    )
{
    DWORD      status;
    DWORD      valueLength = 0;
    DWORD      valueSize = 0;
    PWCHAR     clusterName = NULL;


    //
    // The notification API expects a
    // cluster name to be associated with this event.
    //
    status = NmpQueryString(
                 DmClusterParametersKey,
                 CLUSREG_NAME_CLUS_NAME,
                 REG_SZ,
                 &clusterName,
                 &valueLength,
                 &valueSize
                 );

    if (status == ERROR_SUCCESS) {
        ClusterEventEx(
            CLUSTER_EVENT_PROPERTY_CHANGE,
            EP_CONTEXT_VALID | EP_FREE_CONTEXT,
            clusterName
            );

        //
        // clusterName will be freed by the event processing code.
        //
    }
    else {
        ClRtlLogPrint(LOG_WARNING, 
            "[NM] Failed to issue cluster property change event, "
            "status %1!u!.\n",
            status
            );
    }

    return;

}  // NmpIssueClusterPropertyChangeEvent


DWORD
NmpMarshallObjectInfo(
    IN  const PRESUTIL_PROPERTY_ITEM PropertyTable,
    IN  PVOID                        ObjectInfo,
    OUT PVOID *                      PropertyList,
    OUT LPDWORD                      PropertyListSize
    )
{
    DWORD   status;
    PVOID   propertyList = NULL;
    DWORD   propertyListSize = 0;
    DWORD   bytesReturned = 0;
    DWORD   bytesRequired = 0;


    status = ClRtlPropertyListFromParameterBlock(
                 PropertyTable,
                 NULL,
                 &propertyListSize,
                 (LPBYTE) ObjectInfo,
                 &bytesReturned,
                 &bytesRequired
                 );

    if (status != ERROR_MORE_DATA) {
        CL_ASSERT(status != ERROR_SUCCESS);
        return(status);
    }

    CL_ASSERT(bytesRequired > 0);

    propertyList = MIDL_user_allocate(bytesRequired);

    if (propertyList == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    propertyListSize = bytesRequired;

    status = ClRtlPropertyListFromParameterBlock(
                 PropertyTable,
                 propertyList,
                 &propertyListSize,
                 (LPBYTE) ObjectInfo,
                 &bytesReturned,
                 &bytesRequired
                 );

    if (status != ERROR_SUCCESS) {
        CL_ASSERT(status != ERROR_MORE_DATA);
        MIDL_user_free(propertyList);
    }
    else {
        CL_ASSERT(bytesReturned == propertyListSize);
        *PropertyList = propertyList;
        *PropertyListSize = bytesReturned;
    }

    return(status);

}  // NmpMarshallObjectInfo


VOID
NmpReferenceNetwork(
    PNM_NETWORK  Network
    )
{
    OmReferenceObject(Network);

    return;
}

VOID
NmpDereferenceNetwork(
    PNM_NETWORK  Network
    )
{
    OmDereferenceObject(Network);

    return;
}


PNM_NETWORK
NmpReferenceNetworkByAddress(
    LPWSTR  NetworkAddress
    )
/*++

Notes:

    Called with NM lock held.

--*/
{
    PNM_NETWORK   network;
    PLIST_ENTRY   entry;


    for ( entry = NmpNetworkList.Flink;
          entry != &NmpNetworkList;
          entry = entry->Flink
        )
    {
        network = CONTAINING_RECORD(entry, NM_NETWORK, Linkage);

        if (lstrcmpW(network->Address, NetworkAddress) == 0) {
            NmpReferenceNetwork(network);

            return(network);
        }
    }

    return(NULL);

} // NmpReferenceNetworkByAddress


BOOLEAN
NmpCheckForNetwork(
    VOID
    )
/*++

Routine Description:

    Checks whether at least one network on this node configured for MSCS
    has media sense.

Arguments:

    None.

Return Value:

    TRUE if a viable network is found. FALSE otherwise.

Notes:

    Called with and returns with no locks held.

--*/
{
    PLIST_ENTRY      entry;
    PNM_NETWORK      network;
    BOOLEAN          haveNetwork = FALSE;

    NmpAcquireLock();

    for (entry = NmpNetworkList.Flink;
         entry != &NmpNetworkList;
         entry = entry->Flink
        )
    {
        network = CONTAINING_RECORD(
                      entry,
                      NM_NETWORK,
                      Linkage
                      );

        // if a network's local interface is disabled, it is not
        // considered a viable network. in this case the 
        // LocalInterface field is NULL.
        if (network->LocalInterface != NULL) {
            if (NmpVerifyLocalInterfaceConnected(network->LocalInterface)) {

                haveNetwork = TRUE;
                break;

            } else {

                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[NM] Network adapter %1!ws! with address %2!ws! "
                    "reported not connected.\n",
                    network->LocalInterface->AdapterId,
                    network->Address
                    );
            }
        }
    }

    NmpReleaseLock();

    if (!haveNetwork) {
        SetLastError(ERROR_NETWORK_NOT_AVAILABLE);
    }

    return(haveNetwork);

} // NmpCheckForNetwork
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\nm\nminit.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    nminit.c

Abstract:

    Initialization, cluster join, and cluster form routines for the
    Node Manager.

Author:

    Mike Massa (mikemas)

Revision History:

    6/03/96   Created.

--*/

/*

General Implementation Notes:

    The functions DmBeginLocalUpdate, DmCommitLocalUpdate, and
    DmAbortLocalUpdate cannot be called while holding the NM lock, or
    a deadlock with the NmTimer thread may result during regroup when
    disk writes are stalled. These functions attempt to write to the
    quorum disk.

*/


#include "nmp.h"


//
// External Data
//
extern BOOL CsNoQuorum;

//
// Public Data
//
HANDLE            NmClusnetHandle = NULL;

//
// Private Data
//
CRITICAL_SECTION  NmpLock;
NM_STATE          NmpState = NmStateOffline;
DWORD             NmpActiveThreadCount = 0;
HANDLE            NmpShutdownEvent = NULL;
CL_NODE_ID        NmpJoinerNodeId = ClusterInvalidNodeId;
CL_NODE_ID        NmpSponsorNodeId = ClusterInvalidNodeId;
DWORD             NmpJoinTimer = 0;
BOOLEAN           NmpJoinAbortPending = FALSE;
DWORD             NmpJoinSequence = 0;
BOOLEAN           NmpJoinerUp = FALSE;
BOOLEAN           NmpJoinBeginInProgress = FALSE;
BOOLEAN           NmpJoinerOutOfSynch = FALSE;
LPWSTR            NmpClusnetEndpoint = NULL;
WCHAR             NmpInvalidJoinerIdString[] = L"0";
CL_NODE_ID        NmpLeaderNodeId = ClusterInvalidNodeId;
BOOL              NmpCleanupIfJoinAborted = FALSE;
BOOL              NmpSuccessfulMMJoin = FALSE;
DWORD             NmpAddNodeId = ClusterInvalidNodeId;
LPWSTR            NmpClusterInstanceId = NULL;

//externs

extern DWORD CsMyHighestVersion;
extern DWORD CsMyLowestVersion;
extern DWORD CsClusterHighestVersion;
extern DWORD CsClusterLowestVersion;

GUM_DISPATCH_ENTRY NmGumDispatchTable[] = {
    {1,                          NmpUpdateCreateNode},
    {1,                          NmpUpdatePauseNode},
    {1,                          NmpUpdateResumeNode},
    {1,                          NmpUpdateEvictNode},
    {4, (PGUM_DISPATCH_ROUTINE1) NmpUpdateCreateNetwork},
    {2, (PGUM_DISPATCH_ROUTINE1) NmpUpdateSetNetworkName},
    {1,                          NmpUpdateSetNetworkPriorityOrder},
    {3, (PGUM_DISPATCH_ROUTINE1) NmpUpdateSetNetworkCommonProperties},
    {2, (PGUM_DISPATCH_ROUTINE1) NmpUpdateCreateInterface},
    {2, (PGUM_DISPATCH_ROUTINE1) NmpUpdateSetInterfaceInfo},
    {3, (PGUM_DISPATCH_ROUTINE1) NmpUpdateSetInterfaceCommonProperties},
    {1,                          NmpUpdateDeleteInterface},
    {3, (PGUM_DISPATCH_ROUTINE1) NmpUpdateJoinBegin},
    {2, (PGUM_DISPATCH_ROUTINE1) NmpUpdateJoinAbort},
    //
    // Version 2 (NT 5.0) extensions that are understood by NT4 SP4
    //
    {5, (PGUM_DISPATCH_ROUTINE1) NmpUpdateJoinBegin2},
    {4, (PGUM_DISPATCH_ROUTINE1) NmpUpdateSetNetworkAndInterfaceStates},
    {2, (PGUM_DISPATCH_ROUTINE1) NmpUpdatePerformFixups},
    {5, (PGUM_DISPATCH_ROUTINE1) NmpUpdatePerformFixups2},
    //
    // Version 2 (NT 5.0) extensions that are not understood by NT4 SP4
    // These may not be called in a mixed NT4/NT5 cluster.
    //
    {5, (PGUM_DISPATCH_ROUTINE1) NmpUpdateAddNode},
    {2, (PGUM_DISPATCH_ROUTINE1) NmpUpdateExtendedNodeState},
    //
    // NT 5.1 extensions that are not understood by NT5 and
    // earlier. NT5 nodes will ignore these updates without
    // error.
    //
    {4, (PGUM_DISPATCH_ROUTINE1) NmpUpdateSetNetworkMulticastConfiguration},
    };

//
// Local prototypes
//
DWORD
NmpCreateRpcBindings(
    IN PNM_NODE  Node
    );

DWORD
NmpCreateClusterInstanceId(
    VOID
    );

//
// Component initialization routines.
//
DWORD
NmInitialize(
    VOID
    )
/*++

Routine Description:

    Initializes the Node Manager component.

Arguments:

    None

Return Value:

    A Win32 status code.

Notes:

    The local node object is created by this routine.

--*/
{
    DWORD                      status;
    OM_OBJECT_TYPE_INITIALIZE  nodeTypeInitializer;
    HDMKEY                     nodeKey = NULL;
    DWORD                      nameSize = CS_MAX_NODE_NAME_LENGTH + 1;
    HKEY                       serviceKey;
    DWORD                      nodeIdSize = (CS_MAX_NODE_ID_LENGTH + 1) *
                                            sizeof(WCHAR);
    LPWSTR                     nodeIdString = NULL;
    WSADATA                    wsaData;
    WORD                       versionRequested;
    int                        err;
    ULONG                      ndx;
    DWORD                      valueType;
    NM_NODE_INFO2              nodeInfo;
    WCHAR                      errorString[12];
    DWORD                      eventCode = 0;
    LPWSTR                     string;


    CL_ASSERT(NmpState == NmStateOffline);

    ClRtlLogPrint(LOG_NOISE,"[NM] Initializing...\n");

    //
    // Initialize globals.
    //
    InitializeCriticalSection(&NmpLock);

    InitializeListHead(&NmpNodeList);
    InitializeListHead(&NmpNetworkList);
    InitializeListHead(&NmpInternalNetworkList);
    InitializeListHead(&NmpDeletedNetworkList);
    InitializeListHead(&NmpInterfaceList);
    InitializeListHead(&NmpDeletedInterfaceList);

    NmMaxNodes = ClusterDefaultMaxNodes;
    NmMaxNodeId = ClusterMinNodeId + NmMaxNodes - 1;


    //
    // Initializing the RPC Recording/cancelling mechanism
    // NOTE - This should move if NmMaxNodeId Definition above moves.
    //
    NmpIntraClusterRpcArr = LocalAlloc(LMEM_FIXED,
                            sizeof(NM_INTRACLUSTER_RPC_THREAD) * (NmMaxNodeId +1));

    if(NmpIntraClusterRpcArr == NULL) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to allocate memory for RPC monitoring.\n"
            );
        status = ERROR_NOT_ENOUGH_MEMORY;
        eventCode = CS_EVENT_ALLOCATION_FAILURE;
        goto error_exit;
    }
    else {
        ZeroMemory(NmpIntraClusterRpcArr, 
            sizeof(NM_INTRACLUSTER_RPC_THREAD) * (NmMaxNodeId + 1));
        for(ndx = 0;ndx <= NmMaxNodeId;ndx++)
            InitializeListHead(&NmpIntraClusterRpcArr[ndx]);

        InitializeCriticalSection(&NmpRPCLock);
    }



    //
    // Initialize the network configuration package.
    //
    ClNetInitialize(
        ClNetPrint,
        ClNetLogEvent,
        ClNetLogEvent1,
        ClNetLogEvent2,
        ClNetLogEvent3
        );

    //
    // Initialize WinSock
    //
    versionRequested = MAKEWORD(2,0);

    err = WSAStartup(versionRequested, &wsaData);

    if (err != 0) {
        status = WSAGetLastError();
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent1(LOG_CRITICAL, NM_EVENT_WSASTARTUP_FAILED, errorString);
        ClRtlLogPrint(LOG_NOISE,"[NM] Failed to initialize Winsock, status %1!u!\n", status);
        return(status);
    }

    if ( (LOBYTE(wsaData.wVersion) != 2) || (HIBYTE(wsaData.wVersion) != 0)) {
        status = WSAVERNOTSUPPORTED;
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent1(LOG_CRITICAL, NM_EVENT_WSASTARTUP_FAILED, errorString);
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Found unexpected Windows Sockets version %1!u!\n",
            wsaData.wVersion
            );
        WSACleanup();
        return(status);
    }

    NmpShutdownEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (NmpShutdownEvent == NULL) {
        status = GetLastError();
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent1(LOG_CRITICAL, CS_EVENT_ALLOCATION_FAILURE, errorString);
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to create shutdown event, status %1!u!\n",
            status
            );
        WSACleanup();
        return(status);
    }

    NmpState = NmStateOnlinePending;

    //
    // Get the name of this node.
    //
    if (!GetComputerName(&(NmLocalNodeName[0]), &nameSize)) {
        status = GetLastError();
        eventCode = NM_EVENT_GETCOMPUTERNAME_FAILED;
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Unable to get local computername, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Local node name = %1!ws!.\n",
        NmLocalNodeName
        );

    //
    // Open a control channel to the Cluster Network driver
    //
    NmClusnetHandle = ClusnetOpenControlChannel(0);

    if (NmClusnetHandle == NULL) {
        status = GetLastError();
        eventCode = NM_EVENT_CLUSNET_UNAVAILABLE;
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Unable to open a handle to the Cluster Network driver, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    //
    // Tell the Cluster Network driver to shutdown when our handle is closed
    // in case the Cluster Service crashes.
    //
    status = ClusnetEnableShutdownOnClose(NmClusnetHandle);

    if (status != ERROR_SUCCESS) {
        eventCode = NM_EVENT_CLUSNET_ENABLE_SHUTDOWN_FAILED;
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Unable to register Cluster Network shutdown trigger, status %1!u!\n",
            status
            );

        goto error_exit;
    }

    //
    // Allocate the node ID array.
    //
    CL_ASSERT(NmpIdArray == NULL);

    NmpIdArray = LocalAlloc(
                     LMEM_FIXED,
                     (sizeof(PNM_NODE) * (NmMaxNodeId + 1))
                     );

    if (NmpIdArray == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        eventCode = CS_EVENT_ALLOCATION_FAILURE;
        goto error_exit;
    }

    ZeroMemory(NmpIdArray, (sizeof(PNM_NODE) * (NmMaxNodeId + 1)));

    //
    // Create the node object type
    //
    ZeroMemory(&nodeTypeInitializer, sizeof(OM_OBJECT_TYPE_INITIALIZE));
    nodeTypeInitializer.ObjectSize = sizeof(NM_NODE);
    nodeTypeInitializer.Signature = NM_NODE_SIG;
    nodeTypeInitializer.Name = L"Node";
    nodeTypeInitializer.DeleteObjectMethod = NmpDestroyNodeObject;

    status = OmCreateType(ObjectTypeNode, &nodeTypeInitializer);

    if (status != ERROR_SUCCESS) {
        eventCode = CS_EVENT_ALLOCATION_FAILURE;
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Unable to create node object type, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    //
    // Get the local node ID from the local registry.
    //
    status = RegCreateKeyW(
                 HKEY_LOCAL_MACHINE,
                 CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
                 &serviceKey
                 );

    if (status != ERROR_SUCCESS) {
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent2(
            LOG_CRITICAL,
            CS_EVENT_REG_OPEN_FAILED,
            CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
            errorString
            );
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to open cluster service parameters key, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    string = L"NodeId";
    status = RegQueryValueExW(
                 serviceKey,
                 string,
                 0,
                 &valueType,
                 (LPBYTE) &(NmLocalNodeIdString[0]),
                 &nodeIdSize
                 );

    RegCloseKey(serviceKey);

    if (status != ERROR_SUCCESS) {
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent2(
            LOG_CRITICAL,
            CS_EVENT_REG_QUERY_FAILED,
            string,
            errorString
            );
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to read local node ID from registry, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    if (valueType != REG_SZ) {
        status = ERROR_INVALID_PARAMETER;
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent2(
            LOG_CRITICAL,
            CS_EVENT_REG_QUERY_FAILED,
            string,
            errorString
            );
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Local Node ID registry value is not of type REG_SZ.\n"
            );
        goto error_exit;
    }

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Local node ID = %1!ws!.\n",
        NmLocalNodeIdString
        );

    NmLocalNodeId = wcstoul(NmLocalNodeIdString, NULL, 10);

    //
    // Get information about the local node.
    //
    wcscpy(&(nodeInfo.NodeId[0]), NmLocalNodeIdString);

    status = NmpGetNodeDefinition(&nodeInfo);

    if (status != ERROR_SUCCESS) {
       goto error_exit;
    }

    //
    // Create the local node object. We must do this here because GUM
    // requires the local node object to initialize.
    //
    status = NmpCreateLocalNodeObject(&nodeInfo);

    ClNetFreeNodeInfo(&nodeInfo);

    if (status != ERROR_SUCCESS) {
       goto error_exit;
    }

    //
    // Initialize the network and interface object types
    //
    status = NmpInitializeNetworks();

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    status = NmpInitializeInterfaces();

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    //
    // Initialize net PnP handling
    //
    status = NmpInitializePnp();

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    //
    // init the advise sink that tells when a connection object has been
    // renamed
    //
    status = NmpInitializeConnectoidAdviseSink();
    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    ClRtlLogPrint(LOG_NOISE,"[NM] Initialization complete.\n");

    return(ERROR_SUCCESS);


error_exit:

    if (eventCode != 0) {
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent1(LOG_CRITICAL, eventCode, errorString);
    }

    wsprintfW( &(errorString[0]), L"%u", status );
    CsLogEvent1(LOG_CRITICAL, NM_INIT_FAILED, errorString);

    ClRtlLogPrint(LOG_CRITICAL,"[NM] Initialization failed %1!d!\n",status);

    NmShutdown();

    return(status);

}  // NmInitialize


VOID
NmShutdown(
    VOID
    )
/*++

Routine Description:

    Terminates all processing - shuts down all sources of work for
    worker threads.

Arguments:



Return Value:



--*/
{
    DWORD status;


    if (NmpState == NmStateOffline) {
        return;
    }

    NmCloseConnectoidAdviseSink();

    NmpShutdownPnp();

    NmpAcquireLock();

    ClRtlLogPrint(LOG_NOISE,"[NM] Shutdown starting...\n");

    NmpState = NmStateOfflinePending;

    if (NmpActiveThreadCount > 0) {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Waiting for %1!u! active threads to terminate...\n",
            NmpActiveThreadCount
            );

        NmpReleaseLock();

        status = WaitForSingleObject(NmpShutdownEvent, INFINITE);

        CL_ASSERT(status == WAIT_OBJECT_0);

        ClRtlLogPrint(LOG_NOISE,
            "[NM] All active threads have completed. Continuing shutdown...\n"
            );

    }
    else {
        NmpReleaseLock();
    }

    NmLeaveCluster();

    NmpCleanupPnp();

    if (NmLocalNode != NULL) {
        NmpDeleteNodeObject(NmLocalNode, FALSE);
        NmLocalNode = NULL;
    }

    if (NmpIdArray != NULL) {
        LocalFree(NmpIdArray); NmpIdArray = NULL;
    }

    NmpFreeClusterKey();

    if (NmpClusterInstanceId != NULL) {
        MIDL_user_free(NmpClusterInstanceId);
        NmpClusterInstanceId = NULL;
    }

    if (NmClusnetHandle != NULL) {
        ClusnetCloseControlChannel(NmClusnetHandle);
        NmClusnetHandle = NULL;
    }

    CloseHandle(NmpShutdownEvent); NmpShutdownEvent = NULL;

    WSACleanup();

    //
    // As long as the GUM and Clusapi RPC interfaces cannot be
    //          shutdown, it is not safe to delete this critical section.
    //
    // DeleteCriticalSection(&NmpLock);

    NmpState = NmStateOffline;

    ClRtlLogPrint(LOG_NOISE,"[NM] Shutdown complete.\n");

    return;

}  // NmShutdown


VOID
NmLeaveCluster(
    VOID
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD status;


    if (NmLocalNode != NULL) {
        if ( (NmLocalNode->State == ClusterNodeUp) ||
             (NmLocalNode->State == ClusterNodePaused) ||
             (NmLocalNode->State == ClusterNodeJoining)
           )
        {
            //
            // Leave the cluster.
            //
            ClRtlLogPrint(LOG_NOISE,"[NM] Leaving cluster.\n");

            MMLeave();

#ifdef MM_IN_CLUSNET

            status = ClusnetLeaveCluster(NmClusnetHandle);
            CL_ASSERT(status == ERROR_SUCCESS);

#endif // MM_IN_CLUSNET

        }
    }

    NmpMembershipShutdown();

    NmpCleanupInterfaces();

    NmpCleanupNetworks();

    NmpCleanupNodes();

    //
    // Shutdown the Cluster Network driver.
    //
    if (NmClusnetHandle != NULL) {
        DWORD status = ClusnetShutdown(NmClusnetHandle);

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] Shutdown of the Cluster Network driver failed, status %1!u!\n",
                status
                );
        }
    }

    if (NmpClusnetEndpoint != NULL) {
        MIDL_user_free(NmpClusnetEndpoint);
        NmpClusnetEndpoint = NULL;
    }

    return;

}  // NmLeaveCluster


DWORD
NmpCreateClusterObjects(
    IN  RPC_BINDING_HANDLE  JoinSponsorBinding
    )
/*++

Routine Description:

    Creates objects to represent the cluster's nodes, networks, and
    interfaces.

Arguments:

    JoinSponsorBinding  - A pointer to an RPC binding handle for the sponsor
                          node if this node is joining a cluster. NULL if
                          this node is forming a cluster.

Return Value:

    ERROR_SUCCESS if the routine is successful.
    A Win32 error code otherwise.

Notes:

    This routine MUST NOT be called with the NM lock held.

--*/
{
    DWORD                status;
    PNM_NODE_ENUM2       nodeEnum = NULL;
    PNM_NETWORK_ENUM     networkEnum = NULL;
    PNM_INTERFACE_ENUM2  interfaceEnum = NULL;
    PNM_NODE             node = NULL;
    DWORD                matchedNetworkCount = 0;
    DWORD                newNetworkCount = 0;
    DWORD                InitRetry = 2;
    WCHAR                errorString[12];
    DWORD                eventCode = 0;
    BOOL                 renameConnectoids;


    while ( InitRetry-- ) {
        //
        // Initialize the Cluster Network driver. This will clean up
        // any old state that was left around from the last run of the
        // Cluster Service. Note that the local node object is registered in
        // this call.
        //
        status = ClusnetInitialize(
                     NmClusnetHandle,
                     NmLocalNodeId,
                     NmMaxNodes,
                     NULL,
                     NULL,
                     NULL,
                     NULL,
                     NULL,
                     NULL
                     );

        if (status == ERROR_SUCCESS) {
            break;
        } else {
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[NM] Shutting down Cluster Network driver before retrying Initialization, status %1!u!\n",
                        status);

            ClusnetShutdown( NmClusnetHandle );
        }
    };

    if ( status != ERROR_SUCCESS ) {
        eventCode = NM_EVENT_CLUSNET_INITIALIZE_FAILED;
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Initialization of the Cluster Network driver failed, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    //
    // Tell the Cluster Network driver to reserve the Cluster Network 
    // endpoint on this node.
    //
    status = ClusnetReserveEndpoint(
                 NmClusnetHandle,
                 NmpClusnetEndpoint
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Unable to reserve Clusnet Network endpoint %1!ws!, "
            "status %2!u!\n", NmpClusnetEndpoint, status
            );
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent2(
            LOG_CRITICAL,
            NM_EVENT_CLUSNET_RESERVE_ENDPOINT_FAILED,
            NmpClusnetEndpoint,
            errorString
            );
        goto error_exit;
    }

    //
    // Obtain the node portion of the cluster database.
    //
    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Synchronizing node information.\n"
        );

    if (JoinSponsorBinding == NULL) {
        status = NmpEnumNodeDefinitions(&nodeEnum);
    }
    else {
        status = NmRpcEnumNodeDefinitions2(
                     JoinSponsorBinding,
                     NmpJoinSequence,
                     NmLocalNodeIdString,
                     &nodeEnum
                     );
    }

    if (status != ERROR_SUCCESS) {
        eventCode = NM_EVENT_CONFIG_SYNCH_FAILED;
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Unable to synchronize node information, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Create the node objects.
    //
    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Creating node objects.\n"
        );

    status = NmpCreateNodeObjects(nodeEnum);

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    //
    // Obtain the networks portion of the cluster database.
    //
    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Synchronizing network information.\n"
        );

    if (JoinSponsorBinding == NULL) {
        status = NmpEnumNetworkDefinitions(&networkEnum);
    }
    else {
        status = NmRpcEnumNetworkDefinitions(
                     JoinSponsorBinding,
                     NmpJoinSequence,
                     NmLocalNodeIdString,
                     &networkEnum
                     );
    }

    if (status != ERROR_SUCCESS) {
        eventCode = NM_EVENT_CONFIG_SYNCH_FAILED;
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Unable to synchronize network information, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Obtain the interfaces portion of the cluster database.
    //
    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Synchronizing interface information.\n"
        );

    if (JoinSponsorBinding == NULL) {
        status = NmpEnumInterfaceDefinitions(&interfaceEnum);
    }
    else {
        status = NmRpcEnumInterfaceDefinitions2(
                     JoinSponsorBinding,
                     NmpJoinSequence,
                     NmLocalNodeIdString,
                     &interfaceEnum
                     );
    }

    if (status != ERROR_SUCCESS) {
        eventCode = NM_EVENT_CONFIG_SYNCH_FAILED;
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Unable to synchronize interface information, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    if ( CsUpgrade ) {
        //
        // If this is an upgrade from NT4 to Whistler, then fix up the
        // connectoid names so they align with the cluster network
        // names.
        //
        // REMOVE THIS PORTION AFTER WHISTLER HAS SHIPPED.
        //
        if ( CLUSTER_GET_MAJOR_VERSION( NmLocalNode->HighestVersion ) <= NT4SP4_MAJOR_VERSION ) {
            renameConnectoids = TRUE;
        } else {
            //
            // upgrade from W2K to Whistler. Nothing should have changed but
            // if it did, connectoids should have precedence
            //
            renameConnectoids = FALSE;
        }
    } else {
        //
        // THIS SECTION MUST ALWAYS BE HERE
        //
        // if forming, cluster network objects are renamed to its
        // corresponding connectoid name. During a join, the opposite is true.
        //
        if ( JoinSponsorBinding ) {
            renameConnectoids = TRUE;
        } else {
            renameConnectoids = FALSE;
        }
    }

    //
    // Post a PnP notification ioctl. If we receive a PnP notification
    // before we finish initializing, we must restart the process.
    //
    NmpWatchForPnpEvents();

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    //
    // Run the network configuration engine. This will update the
    // cluster database.
    //
    status = NmpConfigureNetworks(
                 JoinSponsorBinding,
                 NmLocalNodeIdString,
                 NmLocalNodeName,
                 &networkEnum,
                 &interfaceEnum,
                 NmpClusnetEndpoint,
                 &matchedNetworkCount,
                 &newNetworkCount,
                 renameConnectoids
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to configure networks & interfaces, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Matched %1!u! networks, created %2!u! new networks.\n",
        matchedNetworkCount,
        newNetworkCount
        );

    //
    // Get the updated network information from the database.
    //
    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Resynchronizing network information.\n"
        );

    if (JoinSponsorBinding == NULL) {
        status = NmpEnumNetworkDefinitions(&networkEnum);
    }
    else {
        status = NmRpcEnumNetworkDefinitions(
                     JoinSponsorBinding,
                     NmpJoinSequence,
                     NmLocalNodeIdString,
                     &networkEnum
                     );
    }

    if (status != ERROR_SUCCESS) {
        eventCode = NM_EVENT_CONFIG_SYNCH_FAILED;
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Unable to resynchronize network information, "
            "status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Get the updated interface information from the database.
    //
    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Resynchronizing interface information.\n"
        );

    if (JoinSponsorBinding == NULL) {
        status = NmpEnumInterfaceDefinitions(&interfaceEnum);
    }
    else {
        status = NmRpcEnumInterfaceDefinitions2(
                     JoinSponsorBinding,
                     NmpJoinSequence,
                     NmLocalNodeIdString,
                     &interfaceEnum
                     );
    }

    if (status != ERROR_SUCCESS) {
        eventCode = NM_EVENT_CONFIG_SYNCH_FAILED;
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Unable to resynchronize interface information, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Create the network objects.
    //
    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Creating network objects.\n"
        );

    status = NmpCreateNetworkObjects(networkEnum);

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to create network objects, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Fixup the priorities of the internal networks if we are forming
    // a cluster.
    //
    if (JoinSponsorBinding == NULL) {
        DWORD          networkCount;
        PNM_NETWORK *  networkList;

        status = NmpEnumInternalNetworks(&networkCount, &networkList);

        if ((status == ERROR_SUCCESS) && (networkCount > 0)) {
            DWORD             i;
            HLOCALXSACTION    xaction;


            //
            // Begin a transaction - this must not be done while holding
            //                       the NM lock.
            //
            xaction = DmBeginLocalUpdate();

            if (xaction == NULL) {
                status = GetLastError();
                ClRtlLogPrint(LOG_CRITICAL, 
                    "[NM] Failed to start a transaction, status %1!u!\n",
                    status
                    );
                goto error_exit;
            }

            status = NmpSetNetworkPriorityOrder(
                         networkCount,
                         networkList,
                         xaction
                         );

            if (status == ERROR_SUCCESS) {
                DmCommitLocalUpdate(xaction);
            }
            else {
                DmAbortLocalUpdate(xaction);
                goto error_exit;
            }

            for (i=0; i<networkCount; i++) {
                if (networkList[i] != NULL) {
                    OmDereferenceObject(networkList[i]);
                }
            }

            LocalFree(networkList);
        }
    }

    //
    // Create the interface objects.
    //
    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Creating interface objects.\n"
        );

    status = NmpCreateInterfaceObjects(interfaceEnum);

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to create interface objects, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    if (JoinSponsorBinding != NULL) {
        //
        // The node must have connectivity to all active cluster nodes
        // in order to join a cluster.
        //
        PNM_NODE unreachableNode;

        if (!NmpVerifyJoinerConnectivity(NmLocalNode, &unreachableNode)) {
            status = ERROR_CLUSTER_NETWORK_NOT_FOUND;
            CsLogEvent1(
                LOG_CRITICAL,
                NM_EVENT_NODE_UNREACHABLE,
                OmObjectName(unreachableNode),
                );
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Joining node cannot communicate with all other "
                "active nodes.\n"
                );
            goto error_exit;
        }
    }

    status = NmpMembershipInit();

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }


error_exit:

    if (eventCode != 0) {
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent1(LOG_CRITICAL, eventCode, errorString);
    }

    if (nodeEnum != NULL) {
        ClNetFreeNodeEnum(nodeEnum);
    }

    if (networkEnum != NULL) {
        ClNetFreeNetworkEnum(networkEnum);
    }

    if (interfaceEnum != NULL) {
        ClNetFreeInterfaceEnum(interfaceEnum);
    }

    return(status);

}  // NmpCreateClusterObjects

//
// Routines common to joining and forming.
//

DWORD
NmpCreateClusterInstanceId(
    VOID
    )
/*++

Routine Description:

    Checks the cluster database for the cluster instance id. Creates
    if not present.
    
--*/
{
    DWORD       status;
    LPWSTR      clusterInstanceId = NULL;
    DWORD       clusterInstanceIdBufSize = 0;
    DWORD       clusterInstanceIdSize = 0;
    BOOLEAN     found = FALSE;
    UUID        guid;

    do {

        status = NmpQueryString(
                     DmClusterParametersKey,
                     L"ClusterInstanceID",
                     REG_SZ,
                     &clusterInstanceId,
                     &clusterInstanceIdBufSize,
                     &clusterInstanceIdSize
                     );

        if (status == ERROR_SUCCESS) {
            found = TRUE;
        } else {

            ClRtlLogPrint(LOG_UNUSUAL,
                "[NMJOIN] Cluster Instance ID not found in "
                "cluster database, status %1!u!.\n",
                status
                );

            status = UuidCreate(&guid);
            if (status == RPC_S_OK) {

                status = UuidToString(&guid, &clusterInstanceId);
                if (status == RPC_S_OK) {

                    status = DmSetValue(
                                 DmClusterParametersKey,
                                 L"ClusterInstanceID",
                                 REG_SZ,
                                 (PBYTE) clusterInstanceId,
                                 NM_WCSLEN(clusterInstanceId)
                                 );
                    if (status != ERROR_SUCCESS) {

                        ClRtlLogPrint(LOG_UNUSUAL,
                            "[NMJOIN] Failed to store Cluster Instance ID "
                            "in cluster database, status %1!u!.\n",
                            status
                            );
                    }
                    
                    if (clusterInstanceId != NULL) {
                        RpcStringFree(&clusterInstanceId);
                        clusterInstanceId = NULL;
                    }
                } else {
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NMJOIN] Failed to convert Cluster Instance ID "
                        "GUID into string, status %1!u!.\n",
                        status
                        );
                }

            } else {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NMJOIN] Failed to create Cluster Instance ID GUID, "
                    "status %1!u!.\n",
                    status
                    );
            }
        }
    } while ( !found && (status == ERROR_SUCCESS) );

    if (status == ERROR_SUCCESS) {

        CL_ASSERT(clusterInstanceId != NULL);
        
        NmpAcquireLock();

        if (NmpClusterInstanceId == NULL) {
            NmpClusterInstanceId = clusterInstanceId;
            clusterInstanceId = NULL;
        }

        NmpReleaseLock();
    }

    if (clusterInstanceId != NULL) {
        midl_user_free(clusterInstanceId);
        clusterInstanceId = NULL;
    }

    return(status);

} // NmpCreateClusterInstanceId

//
// Routines for forming a new cluster.
//

DWORD
NmFormNewCluster(
    VOID
    )
{
    DWORD           status;
    DWORD           isPaused = FALSE;
    DWORD           pausedDefault = FALSE;
    HDMKEY          nodeKey;
    DWORD           valueLength, valueSize;
    WCHAR           errorString[12], errorString2[12];
    DWORD           eventCode = 0;
    PLIST_ENTRY     entry;
    PNM_NETWORK     network;


    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Beginning cluster form process.\n"
        );

    //
    // Since this node is forming the cluster, it is the leader.
    //
    NmpLeaderNodeId = NmLocalNodeId;

    //
    // Read the clusnet endpoint override value from the registry, if it
    // exists.
    //
    if (NmpClusnetEndpoint != NULL) {
        MIDL_user_free(NmpClusnetEndpoint);
        NmpClusnetEndpoint = NULL;
    }

    valueLength = 0;

    status = NmpQueryString(
                 DmClusterParametersKey,
                 L"ClusnetEndpoint",
                 REG_SZ,
                 &NmpClusnetEndpoint,
                 &valueLength,
                 &valueSize
                 );

    if (status == ERROR_SUCCESS) {
        USHORT  endpoint;

        //
        // Validate the value
        //
        status = ClRtlTcpipStringToEndpoint(
                     NmpClusnetEndpoint,
                     &endpoint
                     );

        if (status != ERROR_SUCCESS) {
            CsLogEvent2(
                LOG_UNUSUAL,
                NM_EVENT_INVALID_CLUSNET_ENDPOINT,
                NmpClusnetEndpoint,
                CLUSNET_DEFAULT_ENDPOINT_STRING
                );
            ClRtlLogPrint(
                LOG_CRITICAL, 
                "[NM] '%1!ws!' is not valid endpoint value. Using default value %2!ws!.\n",
                NmpClusnetEndpoint,
                CLUSNET_DEFAULT_ENDPOINT_STRING
                );
            MIDL_user_free(NmpClusnetEndpoint);
            NmpClusnetEndpoint = NULL;
        }
    }

    if (status != ERROR_SUCCESS) {
        NmpClusnetEndpoint = MIDL_user_allocate(
                                 NM_WCSLEN(CLUSNET_DEFAULT_ENDPOINT_STRING)
                                 );

        if (NmpClusnetEndpoint == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            wsprintfW(&(errorString[0]), L"%u", status);
            CsLogEvent1(LOG_CRITICAL, CS_EVENT_ALLOCATION_FAILURE, errorString);
            return(status);
        }

        lstrcpyW(NmpClusnetEndpoint, CLUSNET_DEFAULT_ENDPOINT_STRING);
    }

    //
    // Create the node, network, and interface objects
    //
    status = NmpCreateClusterObjects(NULL);

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    //
    // Perform version checking - check if we are compatible with the rest of the cluster
    //
    status = NmpIsNodeVersionAllowed(NmLocalNodeId, CsMyHighestVersion,
            CsMyLowestVersion, FALSE);
    if (status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Version of Node %1!ws! is no longer compatible with other members of the cluster.\n",
            NmLocalNodeIdString);
        goto error_exit;

    }

    //If the forming node's version has changed, fix it up
    status = NmpValidateNodeVersion(
                 NmLocalNodeIdString,
                 CsMyHighestVersion,
                 CsMyLowestVersion
                 );

    if (status == ERROR_REVISION_MISMATCH) 
    {
        //there was a version change, try and fix it up
        status = NmpFormFixupNodeVersion(
                     NmLocalNodeIdString,
                     CsMyHighestVersion,
                     CsMyLowestVersion
                     );
        NmLocalNodeVersionChanged = TRUE;
    }
    if (status != ERROR_SUCCESS)
    {
        goto error_exit;
    }


    //
    //at this point we ready to calculate the cluster version
    //all the node versions are in the registry, the fixups have
    //been made if neccessary
    //
    NmpResetClusterVersion(FALSE);

    NmpMulticastInitialize();

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Forming cluster membership.\n"
        );

    status = MMJoin(
                 NmLocalNodeId,
                 NM_CLOCK_PERIOD,
                 NM_SEND_HB_RATE,
                 NM_RECV_HB_RATE,
                 NM_MM_JOIN_TIMEOUT
                 );

    if (status != MM_OK) {
        status = MMMapStatusToDosError(status);
        eventCode = NM_EVENT_MM_FORM_FAILED;
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] Membership form failed, status %1!u!. Unable to form a cluster.\n",
            status
            );
        goto error_exit;
    }

#ifdef MM_IN_CLUSNET

    status = ClusnetFormCluster(
                 NmClusnetHandle,
                 NM_CLOCK_PERIOD,
                 NM_SEND_HB_RATE,
                 NM_RECV_HB_RATE
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NM] Failed to form a cluster, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

#endif // MM_IN_CLUSNET

    //
    // Check to see if we should come up in the paused state.
    //
    nodeKey = DmOpenKey(
                  DmNodesKey,
                  NmLocalNodeIdString,
                  KEY_READ
                  );

    if (nodeKey != NULL) {
        status = DmQueryDword(
                     nodeKey,
                     CLUSREG_NAME_NODE_PAUSED,
                     &isPaused,
                     &pausedDefault
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(
                LOG_UNUSUAL, 
                "[NM] Unable to query Paused value for local node, status %1!u!.\n",
                status
                );
        }

        DmCloseKey(nodeKey);
    }
    else {
        ClRtlLogPrint(
            LOG_UNUSUAL, 
            "[NM] Unable to open database key to local node, status %1!u!. Unable to determine Pause state.\n",
            status
            );
    }

    NmpAcquireLock();

    if (isPaused) {
        NmLocalNode->State = ClusterNodePaused;
    } else {
        NmLocalNode->State = ClusterNodeUp;
    }
    NmLocalNode->ExtendedState = ClusterNodeJoining;

    NmpState = NmStateOnline;

    NmpReleaseLock();

    //
    // If the cluster instance ID does not exist, create it now. The cluster
    // instance ID should be in the database unless this is the first uplevel
    // node.
    //
    NmpCreateClusterInstanceId();

    //
    // Create the cluster key.
    //
    status = NmpRegenerateClusterKey();
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to generate cluster key, status %1!u!. "
            "Allowing service to continue ...\n",
            status
            );
        status = ERROR_SUCCESS;
    }

    //
    // Enable communication for the local node.
    //
    status = ClusnetOnlineNodeComm(NmClusnetHandle, NmLocalNodeId);

    if (status != ERROR_SUCCESS) {

        wsprintfW(&(errorString[0]), L"%u", NmLocalNodeId);
        wsprintfW(&(errorString2[0]), L"%u", status);
        CsLogEvent2(
            LOG_CRITICAL,
            NM_EVENT_CLUSNET_ONLINE_COMM_FAILED,
            errorString,
            errorString2
            );

        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to enable communication for local node, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    GumReceiveUpdates(FALSE,
                      GumUpdateMembership,
                      NmpGumUpdateHandler,
                      NULL,
                      sizeof(NmGumDispatchTable)/sizeof(GUM_DISPATCH_ENTRY),
                      NmGumDispatchTable,
                      NULL
                      );

    //
    // Enable network PnP event handling.
    //
    // If a PnP event occured during the form process, an error code will
    // be returned, which will abort startup of the service.
    //
    status = NmpEnablePnpEvents();

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] A network PnP event occurred during form - abort.\n");
        goto error_exit;
    }

    //
    // Check if we formed without any viable networks. The form is still
    // allowed, but we record an entry in the system event log.
    //
    if (!NmpCheckForNetwork()) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] Formed cluster with no viable networks.\n"
            );
        CsLogEvent(LOG_UNUSUAL, NM_EVENT_FORM_WITH_NO_NETWORKS);
    }

    //
    // Force a reconfiguration of multicast parameters and plumb
    // the results in clusnet.
    //
    NmpAcquireLock();

    if (NmpIsClusterMulticastReady(TRUE)) {
        status = NmpStartMulticast(NULL);
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to start multicast "
                "on cluster networks, status %1!u!.\n",
                status
                );
            //
            // Not a de facto fatal error.
            //
            status = ERROR_SUCCESS;
        }
    }

    NmpReleaseLock();

error_exit:

    if (eventCode != 0) {
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent1(LOG_CRITICAL, eventCode, errorString);
    }

    return(status);

}  // NmFormNewCluster


//
//
// Client-side routines for joining a cluster.
//
//
DWORD
NmJoinCluster(
    IN RPC_BINDING_HANDLE  SponsorBinding
    )
{
    DWORD             status;
    DWORD             sponsorNodeId;
    PNM_INTERFACE     netInterface;
    PNM_NETWORK       network;
    PNM_NODE          node;
    PLIST_ENTRY       nodeEntry, ifEntry;
    WCHAR             errorString[12], errorString2[12];
    DWORD             eventCode = 0;
    DWORD             versionFlags = 0;
    extern BOOLEAN    bFormCluster;
    DWORD             retry;
    BOOLEAN           joinBegin3 = TRUE;
    LPWSTR            clusterInstanceId = NULL;

    ClRtlLogPrint(LOG_NOISE, 
        "[NMJOIN] Beginning cluster join process.\n"
        );

    // GN: If a node tries to restart immediately after a clean shutdown,
    // NmRpcJoinBegin2 can fail with ERROR_CLUSTER_NODE_UP. Since the regroup
    // incident caused by this node might not be finished.
    //
    // If we are getting error CLUSTER_NODE_UP, we will keep retrying for
    // 12 seconds, hoping that regroup will finish.

    retry = 120 / 3; // We sleep for 3 seconds. Need to wait 2 minutes //
    for (;;) {
        //
        // Get the join sequence number so we can tell if the cluster
        // configuration changes during the join process. We overload the
        // use of the NmpJoinSequence variable since it isn't used in the
        // sponsor capacity until the node joins.
        //

        //
        // Try NmRpcJoinBegin3. If it fails with an RPC procnum out of
        // range error, the sponsor is a downlevel node. Revert to 
        // NmRpcJoinBegin2.
        //
        if (joinBegin3) {

            // Only read the cluster instance ID from the registry on
            // the first try.
            if (clusterInstanceId == NULL) {

                DWORD       clusterInstanceIdBufSize = 0;
                DWORD       clusterInstanceIdSize = 0;    

                status = NmpQueryString(
                             DmClusterParametersKey,
                             L"ClusterInstanceID",
                             REG_SZ,
                             &clusterInstanceId,
                             &clusterInstanceIdBufSize,
                             &clusterInstanceIdSize
                             );
                if (status != ERROR_SUCCESS) {
                    ClRtlLogPrint(LOG_UNUSUAL, 
                        "[NMJOIN] Failed to read cluster instance ID from database, status %1!u!.\n",
                        status
                        );
                    // Try to join with the downlevel interface. It is 
                    // possible that this node was just upgraded and the
                    // last time it was in the cluster there was no 
                    // cluster instance ID.
                    joinBegin3 = FALSE;
                    continue;
                }
            }

            status = NmRpcJoinBegin3(
                         SponsorBinding,
                         clusterInstanceId,
                         NmLocalNodeIdString,
                         NmLocalNodeName,
                         CsMyHighestVersion,
                         CsMyLowestVersion,
                         0,   // joiner's major node version
                         0,   // joiner's minor node version
                         L"", // joiner's CsdVersion
                         0,   // joiner's product suite
                         &sponsorNodeId,
                         &NmpJoinSequence,
                         &NmpClusnetEndpoint
                         );
            if (status == RPC_S_PROCNUM_OUT_OF_RANGE) {
                // retry immediately with JoinBegin2
                joinBegin3 = FALSE;
                continue;
            }
        } else {
            
            status = NmRpcJoinBegin2(
                         SponsorBinding,
                         NmLocalNodeIdString,
                         NmLocalNodeName,
                         CsMyHighestVersion,
                         CsMyLowestVersion,
                         &sponsorNodeId,
                         &NmpJoinSequence,
                         &NmpClusnetEndpoint
                         );
        }
        
        if ( ((status != ERROR_CLUSTER_NODE_UP
            && status != ERROR_CLUSTER_JOIN_IN_PROGRESS) ) || retry == 0 )
        {
            break;
        }
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] Unable to begin join, status %1!u!. Retrying ...\n",
            status
            );
        CsServiceStatus.dwCheckPoint++;
        CsAnnounceServiceStatus();
        Sleep(3000);
        --retry;
    }

    // Free the cluster instance ID string, if necessary.
    if (clusterInstanceId != NULL) {
        midl_user_free(clusterInstanceId);
    }

    // [GORN Jan/7/2000]
    // If we are here, then we have already successfully talked to the sponsor
    // via JoinVersion interface. 
    //
    // We shouldn't try to form the cluster if NmRpcJoinBegin2 fails.
    // Otherwise we may steal the quorum on the move [452108]

    //
    // Past this point we will not try to form a cluster
    //
    bFormCluster = FALSE;

    if (status != ERROR_SUCCESS) {
        eventCode = NM_EVENT_BEGIN_JOIN_FAILED;
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NMJOIN] Unable to begin join, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    ClRtlLogPrint(LOG_NOISE, 
        "[NMJOIN] Sponsor node ID = %1!u!. Join sequence number = %2!u!, endpoint = %3!ws!.\n",
        sponsorNodeId,
        NmpJoinSequence,
        NmpClusnetEndpoint
        );

    //
    // Create all of the cluster objects for which we are responsible.
    //
    status = NmpCreateClusterObjects(SponsorBinding);

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    // The local node version might have changed, fix it
    // The sponsorer fixes it in the registry and tells other
    // nodes about it, however the joining node is not a part
    // of the cluster membership as yet.
    // The local node structure is created early on in NmInitialize()
    // hence it must get fixed up
    if ((NmLocalNode->HighestVersion != CsMyHighestVersion) ||
        (NmLocalNode->LowestVersion != CsMyLowestVersion))
    {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] Local Node version changed probably due to upgrade/deinstall\n");
        NmLocalNode->HighestVersion = CsMyHighestVersion;
        NmLocalNode->LowestVersion = CsMyLowestVersion;
        NmLocalNodeVersionChanged = TRUE;
    }

    //at this point we ready to calculate the cluster version
    //all the node objects contain the correct node versions
    NmpResetClusterVersion(FALSE);

    NmpMulticastInitialize();

    //
    // Enable communication for the local node.
    //
    status = ClusnetOnlineNodeComm(NmClusnetHandle, NmLocalNodeId);

    if (status != ERROR_SUCCESS) {
        wsprintfW(&(errorString[0]), L"%u", NmLocalNodeId);
        wsprintfW(&(errorString2[0]), L"%u", status);
        CsLogEvent2(
            LOG_CRITICAL, 
            NM_EVENT_CLUSNET_ONLINE_COMM_FAILED,
            errorString,
            errorString2
            );

        ClRtlLogPrint(LOG_CRITICAL, 
            "[NMJOIN] Unable to enable communication for local node, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Fire up the intracluster RPC server so we can perform the membership
    // join.
    //
    status = ClusterRegisterIntraclusterRpcInterface();

    if ( status != ERROR_SUCCESS ) {
        eventCode = CS_EVENT_RPC_INIT_FAILED;
        ClRtlLogPrint(LOG_CRITICAL, 
            "ClusSvc: Error starting intracluster RPC server, Status = %1!u!\n",
            status);
        goto error_exit;
    }

    //
    // Cycle through the list of cluster nodes and create mutual RPC bindings
    // for the intracluster interface with each.
    //
    for (nodeEntry = NmpNodeList.Flink;
         nodeEntry != &NmpNodeList;
         nodeEntry = nodeEntry->Flink
        )
    {
        node = CONTAINING_RECORD(nodeEntry, NM_NODE, Linkage);

        if ( (node != NmLocalNode)
             &&
             ( (node->State == ClusterNodeUp)
               ||
               (node->State == ClusterNodePaused)
             )
           )
        {
            ClRtlLogPrint(LOG_NOISE, 
                "[NMJOIN] Creating RPC bindings for member node %1!u!\n",
                node->NodeId
                );

            //
            //
            // Cycle through the target node's interfaces
            //
            for (ifEntry = node->InterfaceList.Flink;
                 ifEntry != &(node->InterfaceList);
                 ifEntry = ifEntry->Flink
                )
            {
                netInterface = CONTAINING_RECORD(
                                   ifEntry,
                                   NM_INTERFACE,
                                   NodeLinkage
                                   );

                network = netInterface->Network;

                if (NmpIsNetworkForInternalUse(network)) {
                    if ( (network->LocalInterface != NULL) &&
                         NmpIsInterfaceRegistered(network->LocalInterface) &&
                         NmpIsInterfaceRegistered(netInterface)
                       )
                    {
                        PNM_INTERFACE localInterface = network->LocalInterface;

                        ClRtlLogPrint(LOG_NOISE, 
                            "[NMJOIN] Attempting to use network %1!ws! to "
                            "create bindings for node %2!u!\n",
                            OmObjectName(network),
                            node->NodeId
                            );

                        status = NmpSetNodeInterfacePriority(
                                     node,
                                     0xFFFFFFFF,
                                     netInterface,
                                     1
                                     );

                        if (status == ERROR_SUCCESS) {

                            status = NmRpcCreateBinding(
                                         SponsorBinding,
                                         NmpJoinSequence,
                                         NmLocalNodeIdString,
                                         (LPWSTR) OmObjectId(localInterface),
                                         (LPWSTR) OmObjectId(node)
                                         );

                            if (status == ERROR_SUCCESS) {
                                //
                                // Create RPC bindings for the target node.
                                //
                               status = NmpCreateRpcBindings(node);

                                if (status == ERROR_SUCCESS) {
                                    ClRtlLogPrint(LOG_NOISE, 
                                        "[NMJOIN] Created binding for node "
                                        "%1!u!\n",
                                        node->NodeId
                                        );
                                    break;
                                }

                                wsprintfW(&(errorString[0]), L"%u", status);
                                CsLogEvent3(
                                    LOG_UNUSUAL,
                                    NM_EVENT_JOIN_BIND_OUT_FAILED,
                                    OmObjectName(node),
                                    OmObjectName(network),
                                    errorString
                                    );
                                ClRtlLogPrint(LOG_UNUSUAL, 
                                    "[NMJOIN] Unable to create binding for "
                                    "node %1!u!, status %2!u!.\n",
                                    node->NodeId,
                                    status
                                    );
                            }
                            else {
                                wsprintfW(&(errorString[0]), L"%u", status);
                                CsLogEvent3(
                                    LOG_UNUSUAL,
                                    NM_EVENT_JOIN_BIND_IN_FAILED,
                                    OmObjectName(node),
                                    OmObjectName(network),
                                    errorString
                                    );
                                ClRtlLogPrint(LOG_CRITICAL, 
                                    "[NMJOIN] Member node %1!u! failed to "
                                    "create binding to us, status %2!u!\n",
                                    node->NodeId,
                                    status
                                    );
                            }
                        }
                        else {
                            wsprintfW(&(errorString[0]), L"%u", node->NodeId);
                            wsprintfW(&(errorString2[0]), L"%u", status);
                            CsLogEvent2(
                                LOG_UNUSUAL,
                                NM_EVENT_CLUSNET_SET_INTERFACE_PRIO_FAILED,
                                errorString,
                                errorString2
                                );
                            ClRtlLogPrint(LOG_CRITICAL, 
                                "[NMJOIN] Failed to set interface priorities "
                                "for node %1!u!, status %2!u!\n",
                                node->NodeId,
                                status
                                );
                        }
                    }
                    else {
                        status = ERROR_CLUSTER_NODE_UNREACHABLE;
                        ClRtlLogPrint(LOG_NOISE, 
                            "[NMJOIN] No matching local interface for "
                            "network %1!ws!\n",
                            OmObjectName(netInterface->Network)
                            );
                    }
                }
                else {
                    status = ERROR_CLUSTER_NODE_UNREACHABLE;
                    ClRtlLogPrint(LOG_NOISE, 
                        "[NMJOIN] Network %1!ws! is not used for internal "
                        "communication.\n",
                        OmObjectName(netInterface->Network)
                        );
                }
            }

            if (status != ERROR_SUCCESS) {
                //
                // Cannot make contact with this node. The join fails.
                //
                CsLogEvent1(
                    LOG_CRITICAL,
                    NM_EVENT_NODE_UNREACHABLE,
                    OmObjectName(node)
                    );
                ClRtlLogPrint(LOG_NOISE, 
                    "[NMJOIN] Cluster node %1!u! is not reachable. Join "
                    "failed.\n",
                    node->NodeId
                    );
                goto error_exit;
            }
        }
    }

    CL_ASSERT(status == ERROR_SUCCESS);

    //
    // run through the active nodes again, this time establishing
    // security contexts to use in signing packets
    //

    ClRtlLogPrint(LOG_NOISE, 
        "[NMJOIN] Establishing security contexts with all active nodes.\n"
        );

    for (nodeEntry = NmpNodeList.Flink;
         nodeEntry != &NmpNodeList;
         nodeEntry = nodeEntry->Flink
        )
    {
        node = CONTAINING_RECORD(nodeEntry, NM_NODE, Linkage);

        status = ClMsgCreateActiveNodeSecurityContext(NmpJoinSequence, node);

        if ( status != ERROR_SUCCESS ) {
            wsprintfW(&(errorString[0]), L"%u", status);
            CsLogEvent2(
                LOG_UNUSUAL,
                NM_EVENT_CREATE_SECURITY_CONTEXT_FAILED,
                OmObjectName(node),
                errorString
                );
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NMJOIN] Unable to establish security context for node %1!u!, status 0x%2!08X!\n",
                 node->NodeId,
                 status
                 );
            goto error_exit;
        }
    }

    //
    // Finally, petition the sponsor for membership
    //
    ClRtlLogPrint(LOG_NOISE, 
        "[NMJOIN] Petitioning to join cluster membership.\n"
        );

#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailJoinPetitionForMembership) {
        status = 999999;
        goto error_exit;
    }
#endif

    status = NmRpcPetitionForMembership(
                 SponsorBinding,
                 NmpJoinSequence,
                 NmLocalNodeIdString
                 );

    if (status != ERROR_SUCCESS) {
        //
        // Our petition was denied.
        //
        eventCode = NM_EVENT_PETITION_FAILED;
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NMJOIN] Petition to join was denied %1!d!\n",
            status
            );
        goto error_exit;
    }

#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailNmJoin) {
        status = 999999;
        goto error_exit;
    }
#endif

    //
    // Reset the interface priorities for all nodes to default to
    // the priorities of the associated networks.
    //
    NmpAcquireLock();

    for (ifEntry = NmpInterfaceList.Flink;
         ifEntry != &NmpInterfaceList;
         ifEntry = ifEntry->Flink
        )
    {
        netInterface = CONTAINING_RECORD(ifEntry, NM_INTERFACE, Linkage);
        network = netInterface->Network;

        if ( NmpIsNetworkForInternalUse(network) &&
             NmpIsInterfaceRegistered(netInterface)
           )
        {
            status = ClusnetSetInterfacePriority(
                         NmClusnetHandle,
                         netInterface->Node->NodeId,
                         netInterface->Network->ShortId,
                         0
                         );

            CL_ASSERT(status == ERROR_SUCCESS);
        }
    }

    NmpState = NmStateOnline;

    NmpReleaseLock();

    //
    // Invoke other components to create RPC bindings for each node.
    //

    //
    // Enable our GUM update handler.
    //
    GumReceiveUpdates(
        TRUE,
        GumUpdateMembership,
        NmpGumUpdateHandler,
        NULL,
        sizeof(NmGumDispatchTable)/sizeof(GUM_DISPATCH_ENTRY),
        NmGumDispatchTable,
        NULL
        );

    return(ERROR_SUCCESS);

error_exit:

    if (eventCode != 0) {
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent1(LOG_CRITICAL, eventCode, errorString);
    }

    return(status);

} // NmJoinCluster


BOOLEAN
NmpVerifyJoinerConnectivity(
    IN  PNM_NODE    JoiningNode,
    OUT PNM_NODE *  UnreachableNode
    )
{
    PLIST_ENTRY    entry;
    PNM_NODE       node;


    ClRtlLogPrint(LOG_NOISE, 
        "[NMJOIN] Verifying connectivity to active cluster nodes\n"
        );

    *UnreachableNode = NULL;

    for (entry = NmpNodeList.Flink;
         entry != &NmpNodeList;
         entry = entry->Flink
        )
    {
        node = CONTAINING_RECORD(
                   entry,
                   NM_NODE,
                   Linkage
                   );

        if (NM_NODE_UP(node)) {
            if (!NmpVerifyNodeConnectivity(JoiningNode, node, NULL)) {
                *UnreachableNode = node;
                return(FALSE);
            }
        }
    }

    return(TRUE);

}  // NmpVerifyJoinerConnectivity


DWORD
NmGetJoinSequence(
    VOID
    )
{
    DWORD  sequence;


    NmpAcquireLock();

    sequence = NmpJoinSequence;

    NmpReleaseLock();

    return(sequence);

}  // NmGetJoinSequence



DWORD
NmJoinComplete(
    OUT DWORD *EndSeq
    )
/*++

Routine Description:

    This routine is called by the initialization sequence once a
    join has successfully completed and the node can transition
    from ClusterNodeJoining to ClusterNodeOnline.

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful

    Win32 error otherwise.


--*/

{
    DWORD Sequence;
    DWORD Status;
    PNM_JOIN_UPDATE JoinUpdate = NULL;
    DWORD UpdateLength;
    HDMKEY NodeKey = NULL;
    DWORD Default = 0;
    DWORD NumRetries=50;
    DWORD eventCode = 0;
    WCHAR errorString[12];
    PNM_NETWORK_STATE_ENUM    networkStateEnum = NULL;
    PNM_NETWORK_STATE_INFO    networkStateInfo;
    PNM_INTERFACE_STATE_ENUM  interfaceStateEnum = NULL;
    PNM_INTERFACE_STATE_INFO  interfaceStateInfo;
    DWORD i;
    PNM_NETWORK   network;
    PNM_INTERFACE netInterface;
    PLIST_ENTRY entry;
    DWORD moveCount;
    BOOLEAN mcast;


    UpdateLength = sizeof(NM_JOIN_UPDATE) +
                   (lstrlenW(OmObjectId(NmLocalNode))+1)*sizeof(WCHAR);

    JoinUpdate = LocalAlloc(LMEM_FIXED, UpdateLength);

    if (JoinUpdate == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        eventCode = CS_EVENT_ALLOCATION_FAILURE;
        ClRtlLogPrint(LOG_CRITICAL, "[NMJOIN] Unable to allocate memory.\n");
        goto error_exit;
    }

    JoinUpdate->JoinSequence = NmpJoinSequence;

    lstrcpyW(JoinUpdate->NodeId, OmObjectId(NmLocalNode));

    NodeKey = DmOpenKey(DmNodesKey, OmObjectId(NmLocalNode), KEY_READ);

    if (NodeKey == NULL) {
        Status = GetLastError();
        wsprintfW(&(errorString[0]), L"%u", Status);
        CsLogEvent2(
            LOG_CRITICAL,
            CS_EVENT_REG_OPEN_FAILED,
            OmObjectId(NmLocalNode),
            errorString
            );
        ClRtlLogPrint(
            LOG_CRITICAL, 
            "[NMJOIN] Unable to open database key to local node, status %1!u!.\n",
            Status
            );
        goto error_exit;
    }

retry:

    Status = GumBeginJoinUpdate(GumUpdateMembership, &Sequence);

    if (Status != ERROR_SUCCESS) {
        eventCode = NM_EVENT_GENERAL_JOIN_ERROR;
        goto error_exit;
    }

    //
    // Get the leader node ID from the sponsor.
    //
    Status = NmRpcGetLeaderNodeId(
                 CsJoinSponsorBinding,
                 NmpJoinSequence,
                 NmLocalNodeIdString,
                 &NmpLeaderNodeId
                 );

    if (Status != ERROR_SUCCESS) {
        if (Status == ERROR_CALL_NOT_IMPLEMENTED) {
            //
            // The sponsor is an NT4 node. Make this node the leader.
            //
            NmpLeaderNodeId = NmLocalNodeId;
        }
        else {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NMJOIN] Failed to get leader node ID from sponsor, status %1!u!.\n",
                Status
                );
            goto error_exit;
        }
    }

    ClRtlLogPrint(LOG_NOISE, 
        "[NMJOIN] Node %1!u! is the leader.\n",
        NmpLeaderNodeId
        );

    //
    // Fetch the network and interface states from the sponsor
    //
    Status = NmRpcEnumNetworkAndInterfaceStates(
                 CsJoinSponsorBinding,
                 NmpJoinSequence,
                 NmLocalNodeIdString,
                 &networkStateEnum,
                 &interfaceStateEnum
                 );

    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NMJOIN] Failed to get network and interface state values from sponsor, status %1!u!.\n",
            Status
            );
        goto error_exit;
    }

    NmpAcquireLock();

    for (i=0; i<networkStateEnum->NetworkCount; i++) {
        networkStateInfo = &(networkStateEnum->NetworkList[i]);

        network = OmReferenceObjectById(
                        ObjectTypeNetwork,
                        networkStateInfo->Id
                        );

        if (network == NULL) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NMJOIN] Cannot find network %1!ws! to update state.\n",
                networkStateInfo->Id
                );
            NmpReleaseLock();
            NmpFreeNetworkStateEnum(networkStateEnum);
            LocalFree(JoinUpdate);
            DmCloseKey(NodeKey);
            return(ERROR_CLUSTER_NETWORK_NOT_FOUND);
        }

        network->State = networkStateInfo->State;

        OmDereferenceObject(network);
    }

    for (i=0; i<interfaceStateEnum->InterfaceCount; i++) {
        interfaceStateInfo = &(interfaceStateEnum->InterfaceList[i]);

        netInterface = OmReferenceObjectById(
                           ObjectTypeNetInterface,
                           interfaceStateInfo->Id
                           );

        if (netInterface == NULL) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NMJOIN] Cannot find interface %1!ws! to update state.\n",
                interfaceStateInfo->Id
                );
            NmpReleaseLock();
            NmpFreeInterfaceStateEnum(interfaceStateEnum);
            LocalFree(JoinUpdate);
            DmCloseKey(NodeKey);
            return(ERROR_CLUSTER_NETINTERFACE_NOT_FOUND);
        }

        netInterface->State = interfaceStateInfo->State;

        OmDereferenceObject(netInterface);
    }

    NmpReleaseLock();

    NmpFreeInterfaceStateEnum(interfaceStateEnum);
    interfaceStateEnum = NULL;


    //
    // Check the registry to see if we should come up paused.
    //
    JoinUpdate->IsPaused = Default;

    Status = DmQueryDword(NodeKey,
                          CLUSREG_NAME_NODE_PAUSED,
                          &JoinUpdate->IsPaused,
                          &Default);

    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] Unable to query Paused value for local node, status %1!u!.\n",
            Status
            );
    }

    Status = GumEndJoinUpdate(Sequence,
                              GumUpdateMembership,
                              NmUpdateJoinComplete,
                              UpdateLength,
                              JoinUpdate);

    if (Status != ERROR_SUCCESS) {
        if (Status == ERROR_CLUSTER_JOIN_ABORTED) {
            //
            // The join was aborted by the cluster members. Don't retry.
            //
            CsLogEvent(LOG_CRITICAL, NM_EVENT_JOIN_ABORTED);
            goto error_exit;
        }

        ClRtlLogPrint(LOG_UNUSUAL,
                   "[NMJOIN] GumEndJoinUpdate with sequence %1!d! failed %2!d!\n",
                   Sequence,
                   Status
                   );

        if (--NumRetries == 0) {
            CsLogEvent(LOG_CRITICAL, NM_EVENT_JOIN_ABANDONED);
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[NMJOIN] Tried to complete join too many times. Giving up.\n"
                       );
            goto error_exit;
        }

        goto retry;
    }

    NmpAcquireLock();

    if (JoinUpdate->IsPaused != 0) {
        //
        // We should be coming up paused.
        //
        NmLocalNode->State = ClusterNodePaused;
    } else {
        //
        // Set our state to online.
        //
        NmLocalNode->State = ClusterNodeUp;
    }

    //
    // Remember whether this cluster meets multicast criteria.
    //
    mcast = NmpIsClusterMulticastReady(TRUE);

    NmpReleaseLock();

    //
    // If the cluster instance ID does not exist, create it now. The cluster
    // instance ID should be in the database unless this is the first uplevel
    // node.
    //
    NmpCreateClusterInstanceId();

    //
    // Create the cluster key.
    //
    Status = NmpRegenerateClusterKey();
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to generate cluster key, status %1!u!. "
            "Allowing service to continue ...\n",
            Status
            );
        Status = ERROR_SUCCESS;
    }

    //
    // Finally, enable network PnP event handling.
    //
    // If a PnP event occured during the join process, an error code will
    // be returned, which will abort startup of the service.
    //
    Status = NmpEnablePnpEvents();

    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] A network PnP event occurred during join - abort.\n");
        goto error_exit;
    }

    //
    // Mark end sequence
    *EndSeq = Sequence;

    ClRtlLogPrint(LOG_NOISE, "[NMJOIN] Join complete, node now online\n");

    if (mcast) {
        Status = NmpRefreshClusterMulticastConfiguration();
        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to refresh multicast configuration "
                "for cluster networks, status %1!u!.\n",
                Status
                );
            //
            // Not a de facto fatal error.
            //
            Status = ERROR_SUCCESS;
        }
    }

error_exit:

    if (JoinUpdate != NULL) {
        LocalFree(JoinUpdate);
    }

    if (NodeKey != NULL) {
        DmCloseKey(NodeKey);
    }

    if (eventCode != 0) {
        wsprintfW(&(errorString[0]), L"%u", Status);
        CsLogEvent1(LOG_CRITICAL, eventCode, errorString);
    }

    return(Status);

}  // NmJoinComplete


//
// Server-side routines for sponsoring a joining node.
//
/*

Notes On Joining:

    Only a single node may join the cluster at any time. A join begins with
    a JoinBegin global update. A join completes successfully with a
    JoinComplete global update. A join is aborted with a JoinAbort global
    update.

    A timer runs on the sponsor during a join. The timer is suspended
    while the sponsor is performing work on behalf of the joiner. If the
    timer expires, a worker thread is scheduled to initiate the abort
    process.


    If the sponsor goes down while a join is in progress, the node
    down handling code on each remaining node will abort the join.

*/

error_status_t
s_NmRpcJoinBegin(
    IN  handle_t  IDL_handle,
    IN  LPWSTR    JoinerNodeId,
    IN  LPWSTR    JoinerNodeName,
    OUT LPDWORD   SponsorNodeId,
    OUT LPDWORD   JoinSequenceNumber,
    OUT LPWSTR *  ClusnetEndpoint
    )
/*++

Routine Description:

    Called by a joining node to begin the join process.
    Issues a JoinBegin global update.

--*/
{

    DWORD   status=ERROR_CLUSTER_INCOMPATIBLE_VERSIONS;

    ClRtlLogPrint(LOG_NOISE,
        "[NMJOIN] Request by node %1!ws! to begin joining, refused. Using obsolete join interface\n",
        JoinerNodeId
        );

    if ( status != ERROR_SUCCESS ) {
        WCHAR  errorCode[16];

        wsprintfW( errorCode, L"%u", status );

        CsLogEvent2(
            LOG_CRITICAL,
            NM_EVENT_JOIN_REFUSED,
            JoinerNodeId,
            errorCode
            );
    }

    return(status);

} // s_NmRpcJoinBegin

//
// Server-side routines for sponsoring a joining node.
//
/*

Notes On Joining:




*/
//#pragma optimize("", off)

DWORD
NmpJoinBegin(
    IN  LPWSTR    JoinerNodeId,
    IN  LPWSTR    JoinerNodeName,
    IN  DWORD     JoinerHighestVersion,
    IN  DWORD     JoinerLowestVersion,
    OUT LPDWORD   SponsorNodeId,
    OUT LPDWORD   JoinSequenceNumber,
    OUT LPWSTR *  ClusnetEndpoint
    )
/*++

Routine Description:

    Called from s_NmRpcJoinBegin2 and s_NmRpcJoinBegin3.
    Contains functionality common to both JoinBegin versions.
    
Notes:

    Called with NM lock held and NmpLockedEnterApi already
    called.
    
--*/
{
    DWORD       status = ERROR_SUCCESS;
    PNM_NODE    joinerNode = NULL;
    LPWSTR      endpoint = NULL;

    joinerNode = OmReferenceObjectById(
                     ObjectTypeNode,
                     JoinerNodeId
                     );

    if (joinerNode == NULL) {
        status = ERROR_CLUSTER_NODE_NOT_MEMBER;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] Node %1!ws! is not a member of this cluster. Cannot join.\n",
            JoinerNodeId
            );
        goto FnExit;
    }

    endpoint = MIDL_user_allocate(NM_WCSLEN(NmpClusnetEndpoint));

    if (endpoint == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }

    lstrcpyW(endpoint, NmpClusnetEndpoint);

    if (NmpJoinBeginInProgress) {
        status = ERROR_CLUSTER_JOIN_IN_PROGRESS;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] Node %1!ws! cannot join because a join is already in progress.\n",
            JoinerNodeId
            );
        goto FnExit;
    }

    //
    //validate the nodes version's number
    //ie. check to see what the cluster database
    //claims this node's version is vs what the node
    //itself suggests
    status = NmpValidateNodeVersion(
                 JoinerNodeId,
                 JoinerHighestVersion,
                 JoinerLowestVersion
                 );

    //since this node joined, its version has changed
    //this may happen due to upgrades or reinstall
    //if this version cant join due to versioning,fail the join
    if (status == ERROR_REVISION_MISMATCH) {
        DWORD  id = NmGetNodeId(joinerNode);

        status = NmpIsNodeVersionAllowed(
                     id,
                     JoinerHighestVersion,
                     JoinerLowestVersion,
                     TRUE
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_NOISE, 
                "[NMJOIN] The version of the cluster prevents Node %1!ws! from joining the cluster\n",
                JoinerNodeId
                );
            goto FnExit;
        }
    }
    else if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_NOISE, 
            "[NMJOIN] The version of Node %1!ws! cannot be validated.\n",
            JoinerNodeId
            );
        goto FnExit;
    }

    //
    // Lock out other join attempts with this sponsor.
    //
    NmpJoinBeginInProgress = TRUE;
    NmpSuccessfulMMJoin = FALSE;

    NmpReleaseLock();

    status = GumSendUpdateEx(
                 GumUpdateMembership,
                 NmUpdateJoinBegin2,
                 5,
                 NM_WCSLEN(JoinerNodeId),
                 JoinerNodeId,
                 NM_WCSLEN(JoinerNodeName),
                 JoinerNodeName,
                 NM_WCSLEN(NmLocalNodeIdString),
                 NmLocalNodeIdString,
                 sizeof(DWORD),
                 &JoinerHighestVersion,
                 sizeof(DWORD),
                 &JoinerLowestVersion
                 );

    NmpAcquireLock();

    CL_ASSERT(NmpJoinBeginInProgress == TRUE);
    NmpJoinBeginInProgress = FALSE;

    if (status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] JoinBegin2 update for node %1!ws! failed, status %2!u!\n",
            JoinerNodeId,
            status
            );
        goto FnExit;
    }
    //
    // Verify that the join is still in progress with
    // this node as the sponsor.
    //
    if ( (NmpJoinerNodeId == joinerNode->NodeId) &&
         (NmpSponsorNodeId == NmLocalNodeId)
       )
    {
        //
        // Give the joiner parameters for future
        // join-related calls.
        //
        *SponsorNodeId = NmLocalNodeId;
        *JoinSequenceNumber = NmpJoinSequence;

        //
        // Start the join timer
        //
        NmpJoinTimer = NM_JOIN_TIMEOUT;

        ClRtlLogPrint(LOG_NOISE, 
            "[NMJOIN] Node %1!ws! has begun the join process.\n",
            JoinerNodeId
            );
    }
    else
    {
        status = ERROR_CLUSTER_JOIN_ABORTED;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] Begin join of node %1!ws! was aborted\n",
            JoinerNodeId
            );
    }

FnExit:
    if (joinerNode) {
        OmDereferenceObject(joinerNode);
    }

    if (status == ERROR_SUCCESS) {
        *ClusnetEndpoint = endpoint;
    }
    else {
        WCHAR  errorCode[16];

        if (endpoint) MIDL_user_free(endpoint);

        wsprintfW( errorCode, L"%u", status );

        CsLogEvent2(
            LOG_CRITICAL,
            NM_EVENT_JOIN_REFUSED,
            JoinerNodeId,
            errorCode
            );
    }

    return(status);

} // NmpJoinBegin

error_status_t
s_NmRpcJoinBegin2(
    IN  handle_t  IDL_handle,
    IN  LPWSTR    JoinerNodeId,
    IN  LPWSTR    JoinerNodeName,
    IN  DWORD     JoinerHighestVersion,
    IN  DWORD     JoinerLowestVersion,
    OUT LPDWORD   SponsorNodeId,
    OUT LPDWORD   JoinSequenceNumber,
    OUT LPWSTR *  ClusnetEndpoint
    )
/*++

Routine Description:

    Called by a joining node to begin the join process.
    Issues a JoinBegin global update.

--*/
{
    DWORD       status = ERROR_SUCCESS;

    status = FmDoesQuorumAllowJoin();
    if (status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_NOISE, 
            "[NMJOIN] Quorum Characteristics prevent the node %1!ws! to from joining, Status=%2!u!.\n",
            JoinerNodeId,
            status
            );
        return(status);            
        
    }

    NmpAcquireLock();

    ClRtlLogPrint(LOG_NOISE, 
        "[NMJOIN] Processing request by node %1!ws! to begin joining (2).\n",
        JoinerNodeId
        );

    if (!NmpLockedEnterApi(NmStateOnline)) {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] Cannot sponsor a joining node at this time.\n"
            );
        NmpReleaseLock();
        return(status);
    }

    status = NmpJoinBegin(
                 JoinerNodeId,
                 JoinerNodeName,
                 JoinerHighestVersion,
                 JoinerLowestVersion,
                 SponsorNodeId,
                 JoinSequenceNumber,
                 ClusnetEndpoint
                 );

    NmpLockedLeaveApi();

    NmpReleaseLock();

    return(status);

} // s_NmRpcJoinBegin2

error_status_t
s_NmRpcJoinBegin3(
    IN  handle_t  IDL_handle,
    IN  LPWSTR    JoinerClusterInstanceId,
    IN  LPWSTR    JoinerNodeId,
    IN  LPWSTR    JoinerNodeName,
    IN  DWORD     JoinerHighestVersion,
    IN  DWORD     JoinerLowestVersion,
    IN  DWORD     JoinerMajorVersion,
    IN  DWORD     JoinerMinorVersion,
    IN  LPWSTR    JoinerCsdVersion,
    IN  DWORD     JoinerProductSuite,
    OUT LPDWORD   SponsorNodeId,
    OUT LPDWORD   JoinSequenceNumber,
    OUT LPWSTR *  ClusnetEndpoint
    )
{
    DWORD       status = ERROR_SUCCESS;
    
    LPWSTR      clusterInstanceId = NULL;
    DWORD       clusterInstanceIdBufSize = 0;
    DWORD       clusterInstanceIdSize = 0;    

    ClRtlLogPrint(LOG_NOISE, 
        "[NMJOIN] Processing request by node %1!ws! to begin joining (3).\n",
        JoinerNodeId
        );

    status = FmDoesQuorumAllowJoin();
    if (status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_NOISE, 
            "[NMJOIN] Quorum Characteristics prevent node %1!ws! from joining, Status=%2!u!.\n",
            JoinerNodeId,
            status
            );
        return(status);            
        
    }

    //
    // Check our cluster instance ID against the joiner's.
    //
    if (NmpClusterInstanceId == NULL ||
        lstrcmpiW(NmpClusterInstanceId, JoinerClusterInstanceId) != 0) {

        WCHAR  errorCode[16];

        status = ERROR_CLUSTER_INSTANCE_ID_MISMATCH;

        ClRtlLogPrint(LOG_CRITICAL, 
            "[NMJOIN] Sponsor cluster instance ID %1!ws! does not match joiner cluster instance id %2!ws!.\n",
            ((NmpClusterInstanceId == NULL) ? L"<NULL>" : NmpClusterInstanceId),
            JoinerClusterInstanceId
            );

        wsprintfW( errorCode, L"%u", status );
        CsLogEvent2(
            LOG_CRITICAL,
            NM_EVENT_JOIN_REFUSED,
            JoinerNodeId,
            errorCode
            );

        return(status);

    } else {

        ClRtlLogPrint(LOG_NOISE, 
            "[NMJOIN] Sponsor cluster instance ID matches joiner cluster instance id (%1!ws!).\n",
            JoinerClusterInstanceId
            );
    }
    
    NmpAcquireLock();

    if (!NmpLockedEnterApi(NmStateOnline)) {
        
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] Cannot sponsor a joining node at this time.\n"
            );

    } else {
        
        status = NmpJoinBegin(
                     JoinerNodeId,
                     JoinerNodeName,
                     JoinerHighestVersion,
                     JoinerLowestVersion,
                     SponsorNodeId,
                     JoinSequenceNumber,
                     ClusnetEndpoint
                     );

        NmpLockedLeaveApi();
    }

    NmpReleaseLock();

    return(status);

} // s_NmRpcJoinBegin3

DWORD
NmpUpdateJoinBegin(
    IN  BOOL    SourceNode,
    IN  LPWSTR  JoinerNodeId,
    IN  LPWSTR  JoinerNodeName,
    IN  LPWSTR  SponsorNodeId
    )
{
    DWORD           status=ERROR_CLUSTER_INCOMPATIBLE_VERSIONS;

    ClRtlLogPrint(LOG_NOISE,
        "[NMJOIN] Failing update to begin join of node %1!ws! with "
        "sponsor %2!ws!. Using obsolete join interface.\n",
        JoinerNodeId,
        SponsorNodeId
        );

    return(status);

} // NmpUpdateJoinBegin


DWORD
NmpUpdateJoinBegin2(
    IN  BOOL      SourceNode,
    IN  LPWSTR    JoinerNodeId,
    IN  LPWSTR    JoinerNodeName,
    IN  LPWSTR    SponsorNodeId,
    IN  LPDWORD   JoinerHighestVersion,
    IN  LPDWORD   JoinerLowestVersion
    )
{
    DWORD           status = ERROR_SUCCESS;
    PNM_NODE        sponsorNode=NULL;
    PNM_NODE        joinerNode=NULL;
    HLOCALXSACTION  hXsaction=NULL;
    BOOLEAN         lockAcquired = FALSE;
    BOOLEAN         fakeSuccess = FALSE;

    ClRtlLogPrint(LOG_NOISE, 
        "[NMJOIN] Received update to begin join (2) of node %1!ws! with "
        "sponsor %2!ws!.\n",
        JoinerNodeId,
        SponsorNodeId
        );

    //
    // If running with -noquorum flag or if not online, don't sponsor
    // any node.
    //
    if (CsNoQuorum || !NmpEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to begin a join operation.\n"
            );
        return(ERROR_NODE_NOT_AVAILABLE);
    }

    //
    // Find the sponsor node
    //
    sponsorNode = OmReferenceObjectById(
                        ObjectTypeNode,
                        SponsorNodeId
                        );

    if (sponsorNode == NULL) {
        status = ERROR_CLUSTER_NODE_NOT_MEMBER;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] JoinBegin update for node %1!ws! failed because "
            "sponsor node %2!ws! is not a member of this cluster.\n",
            JoinerNodeId,
            SponsorNodeId
            );
        goto FnExit;
    }

    //
    // Find the joiner node
    //
    joinerNode = OmReferenceObjectById(
                    ObjectTypeNode,
                    JoinerNodeId
                    );

    if (joinerNode == NULL) {
        status = ERROR_CLUSTER_NODE_NOT_MEMBER;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] Node %1!ws! is not a member of this cluster. "
            "Cannot join.\n",
            JoinerNodeId
            );
        goto FnExit;
    }

    hXsaction = DmBeginLocalUpdate();

    if (hXsaction == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to start a transaction, status %1!u!\n",
            status
            );
        goto FnExit;
    }

    NmpAcquireLock(); lockAcquired = TRUE;

    if (!NM_NODE_UP(sponsorNode)) {
        //
        // [GorN 4/3/2000] See bug#98287
        // This hack is a kludgy solution to a problem that
        // a replay of this Gum update after the sponsor death
        // will fail on all the nodes that didn't see the update.
        //
        fakeSuccess = TRUE;
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] Sponsor node %1!ws! is not up. Join of node %2!ws! "
            "failed.\n",
            SponsorNodeId,
            JoinerNodeId
            );
        goto FnExit;
    }

    //
    // Check that the joiner is really who we think it is.
    //
    if (lstrcmpiW( OmObjectName(joinerNode), JoinerNodeName)) {
        status = ERROR_CLUSTER_NODE_NOT_MEMBER;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] Node %1!ws! is not a member of this cluster. "
            "Cannot join.\n",
            JoinerNodeName
            );
        goto FnExit;
    }

    //
    // Make sure the joiner is currently down.
    //
    if (joinerNode->State != ClusterNodeDown) {
        status = ERROR_CLUSTER_NODE_UP;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] Node %1!ws! is not down. Cannot begin join.\n",
            JoinerNodeId
            );
        goto FnExit;
    }

    //
    // Make sure we aren't already in a join.
    //
    if (NmpJoinerNodeId != ClusterInvalidNodeId) {
        status = ERROR_CLUSTER_JOIN_IN_PROGRESS;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] Node %1!ws! cannot begin join because a join is "
            "already in progress for node %2!u!.\n",
            JoinerNodeId,
            NmpJoinerNodeId
            );
        goto FnExit;
    }

    //
    // Perform the version compatibility check.
    //
    status = NmpIsNodeVersionAllowed(
             NmGetNodeId(joinerNode),
             *JoinerHighestVersion,
             *JoinerLowestVersion,
             TRUE
             );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] The version of the cluster prevents Node %1!ws! "
            "from joining the cluster\n",
            JoinerNodeId
            );
        goto FnExit;
    }

    // Fix up the joiner's version number if needed.
    //

    status = NmpValidateNodeVersion(
                 JoinerNodeId,
                 *JoinerHighestVersion,
                 *JoinerLowestVersion
                 );

    if (status == ERROR_REVISION_MISMATCH) {
        //
        // At this point, the registry contains the new
        // versions for the joining code.
        // The new node information should be reread
        // from the registry before resetting the cluster
        // version
        // make sure the joiner gets the database from the
        //          sponsor after the fixups have occured
        //
        status = NmpJoinFixupNodeVersion(
                     hXsaction,
                     JoinerNodeId,
                     *JoinerHighestVersion,
                     *JoinerLowestVersion
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NMJOIN] Node %1!ws! failed to fixup its node version\r\n",
                JoinerNodeId);
            goto FnExit;
        }
    }
    else if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] The verison of Node %1!ws! could not be validated\n",
            JoinerNodeId);
        goto FnExit;
    }

    //
    //at this point we ready to calculate the cluster version
    //all the node versions are in the registry, the fixups have
    //been made if neccessary
    //
    NmpResetClusterVersion(TRUE);

    //
    // Enable communication to the joiner.
    //
    // This must be the last test that can fail before the join is allowed
    // to proceed.
    //
    status = ClusnetOnlineNodeComm(NmClusnetHandle, joinerNode->NodeId);

    if (status != ERROR_SUCCESS) {
        if (status != ERROR_CLUSTER_NODE_ALREADY_UP) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NMJOIN] Failed to enable communication for node %1!u!, "
                "status %2!u!\n",
                JoinerNodeId,
                status
                );
            goto FnExit;
        }
        else {
            status = ERROR_SUCCESS;
        }
    }

    //
    // Officially begin the join process
    //
    CL_ASSERT(NmpJoinTimer == 0);
    CL_ASSERT(NmpJoinAbortPending == FALSE);
    CL_ASSERT(NmpJoinerUp == FALSE);
    CL_ASSERT(NmpSponsorNodeId == ClusterInvalidNodeId);

    NmpJoinerNodeId = joinerNode->NodeId;
    NmpSponsorNodeId = sponsorNode->NodeId;
    NmpJoinerOutOfSynch = FALSE;
    NmpJoinSequence = GumGetCurrentSequence(GumUpdateMembership);

    joinerNode->State = ClusterNodeJoining;

    ClusterEvent(
        CLUSTER_EVENT_NODE_JOIN,
        joinerNode
        );

    NmpCleanupIfJoinAborted = TRUE;

    ClRtlLogPrint(LOG_NOISE, 
        "[NMJOIN] Node %1!ws! join sequence = %2!u!\n",
        JoinerNodeId,
        NmpJoinSequence
        );

    CL_ASSERT(status == ERROR_SUCCESS);

FnExit:

    if (lockAcquired) {
        NmpLockedLeaveApi();
        NmpReleaseLock();
    }
    else {
        NmpLeaveApi();
    }

    if (hXsaction != NULL) {
        if (status == ERROR_SUCCESS) {
            DmCommitLocalUpdate(hXsaction);
        }
        else {
            DmAbortLocalUpdate(hXsaction);
        }
    }

    if (joinerNode != NULL) {
        OmDereferenceObject(joinerNode);
    }

    if (sponsorNode != NULL) {
        OmDereferenceObject(sponsorNode);
    }

    if (fakeSuccess) {
        status = ERROR_SUCCESS;
    }
    return(status);

} // NmpUpdateJoinBegin2


DWORD
NmpCreateRpcBindings(
    IN PNM_NODE  Node
    )
{
    DWORD  status;


    //
    // Create the default binding for the whole cluster service
    //
    status = ClMsgCreateDefaultRpcBinding(
                Node, &Node->DefaultRpcBindingGeneration);

    if (status != ERROR_SUCCESS) {
        return(status);
    }

    //
    // Create private bindings for the NM's use.
    // We create one for reporting network connectivity and one for
    // performing network failure isolation. The NM uses the
    // default binding for operations on behalf of joining nodes.
    //
    if (Node->ReportRpcBinding != NULL) {
        //
        // Reuse the old binding.
        //
        status = ClMsgVerifyRpcBinding(Node->ReportRpcBinding);

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Failed to verify RPC binding for node %1!u!, "
                "status %2!u!.\n",
                Node->NodeId,
                status
                );
            return(status);
        }
    }
    else {
        //
        // Create a new binding
        //
        status = ClMsgCreateRpcBinding(
                                Node,
                                &(Node->ReportRpcBinding),
                                0 );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Failed to create RPC binding for node %1!u!, "
                "status %2!u!.\n",
                Node->NodeId,
                status
                );
            return(status);
        }
    }

    if (Node->IsolateRpcBinding != NULL) {
        //
        // Reuse the old binding.
        //
        status = ClMsgVerifyRpcBinding(Node->IsolateRpcBinding);

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Failed to verify RPC binding for node %1!u!, "
                "status %2!u!.\n",
                Node->NodeId,
                status
                );
            return(status);
        }
    }
    else {
        //
        // Create a new binding
        //
        status = ClMsgCreateRpcBinding(
                                Node,
                                &(Node->IsolateRpcBinding),
                                0 );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] Failed to create RPC binding for node %1!u!, "
                "status %2!u!.\n",
                Node->NodeId,
                status
                );
            return(status);
        }
    }

    //
    // Call other components to create their private bindings
    //
    status = GumCreateRpcBindings(Node);

    if (status != ERROR_SUCCESS) {
        return(status);
    }

    status = EvCreateRpcBindings(Node);

    if (status != ERROR_SUCCESS) {
        return(status);
    }

    status = FmCreateRpcBindings(Node);

    if (status != ERROR_SUCCESS) {
        return(status);
    }

    return(ERROR_SUCCESS);

} // NmpCreateRpcBindings


error_status_t
s_NmRpcCreateBinding(
    IN handle_t  IDL_handle,
    IN DWORD     JoinSequence,
    IN LPWSTR    JoinerNodeId,
    IN LPWSTR    JoinerInterfaceId,
    IN LPWSTR    MemberNodeId
    )
{
    DWORD  status;


    NmpAcquireLock();

    ClRtlLogPrint(LOG_NOISE, 
        "[NMJOIN] Processing CreateBinding request from joining node %1!ws! for member node %2!ws!\n",
        JoinerNodeId,
        MemberNodeId
        );

    if (NmpLockedEnterApi(NmStateOnlinePending)) {

        PNM_NODE joinerNode = OmReferenceObjectById(
                                  ObjectTypeNode,
                                  JoinerNodeId
                                  );

        if (joinerNode != NULL) {
            if ( (JoinSequence == NmpJoinSequence) &&
                 (NmpJoinerNodeId == joinerNode->NodeId) &&
                 (NmpSponsorNodeId == NmLocalNodeId) &&
                 !NmpJoinAbortPending
               )
            {
                PNM_NODE memberNode;


                CL_ASSERT(joinerNode->State == ClusterNodeJoining);
                CL_ASSERT(NmpJoinerUp == FALSE);
                CL_ASSERT(NmpJoinTimer != 0);

                //
                // Suspend the join timer while we are working on
                // behalf of the joiner. This precludes an abort
                // from occuring as well.
                //
                NmpJoinTimer = 0;

                memberNode = OmReferenceObjectById(
                                 ObjectTypeNode,
                                 MemberNodeId
                                 );

                if (memberNode != NULL) {
                    PNM_INTERFACE  netInterface = OmReferenceObjectById(
                                                      ObjectTypeNetInterface,
                                                      JoinerInterfaceId
                                                      );

                    if (netInterface != NULL) {
                        if (memberNode == NmLocalNode) {
                            status = NmpCreateJoinerRpcBindings(
                                         joinerNode,
                                         netInterface
                                         );
                        }
                        else {
                            if (NM_NODE_UP(memberNode)) {
                                DWORD  joinSequence = NmpJoinSequence;
                                RPC_BINDING_HANDLE binding =
                                                   Session[memberNode->NodeId];

                                CL_ASSERT(binding != NULL);

                                NmpReleaseLock();

                                NmStartRpc(memberNode->NodeId);
                                status = NmRpcCreateJoinerBinding(
                                             binding,
                                             joinSequence,
                                             JoinerNodeId,
                                             JoinerInterfaceId
                                             );
                                NmEndRpc(memberNode->NodeId);
                                if(status != RPC_S_OK) {
                                    NmDumpRpcExtErrorInfo(status);
                                }

                                NmpAcquireLock();

                            }
                            else {
                                status = ERROR_CLUSTER_NODE_DOWN;
                                ClRtlLogPrint(LOG_UNUSUAL, 
                                    "[NMJOIN] CreateBinding call for joining node %1!ws! failed because member node %2!ws! is down.\n",
                                    JoinerNodeId,
                                    MemberNodeId
                                    );
                            }
                        }

                        OmDereferenceObject(netInterface);
                    }
                    else {
                        status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
                        ClRtlLogPrint(LOG_CRITICAL, 
                            "[NMJOIN] Can't create binding for joining node %1!ws! - interface %2!ws! doesn't exist.\n",
                            JoinerNodeId,
                            JoinerInterfaceId
                            );
                    }

                    OmDereferenceObject(memberNode);
                }
                else {
                    status = ERROR_CLUSTER_NODE_NOT_FOUND;
                    ClRtlLogPrint(LOG_UNUSUAL, 
                        "[NMJOIN] CreateBinding call for joining node %1!ws! failed because member node %2!ws! does not exist\n",
                        JoinerNodeId,
                        MemberNodeId
                        );
                }

                //
                // Verify that the join is still in progress
                //
                if ( (JoinSequence == NmpJoinSequence) &&
                     (NmpJoinerNodeId == joinerNode->NodeId)
                   )
                {
                    CL_ASSERT(joinerNode->State == ClusterNodeJoining);
                    CL_ASSERT(NmpJoinerUp == FALSE);
                    CL_ASSERT(NmpSponsorNodeId == NmLocalNodeId);
                    CL_ASSERT(NmpJoinTimer == 0);
                    CL_ASSERT(NmpJoinAbortPending == FALSE);

                    //
                    // Restart the join timer.
                    //
                    NmpJoinTimer = NM_JOIN_TIMEOUT;
                }
                else {
                    status = ERROR_CLUSTER_JOIN_ABORTED;
                    ClRtlLogPrint(LOG_UNUSUAL, 
                        "[NMJOIN] CreateBinding call for joining node %1!ws! failed because the join was aborted.\n",
                        JoinerNodeId
                        );
                }
            }
            else {
                status = ERROR_CLUSTER_JOIN_ABORTED;
                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[NMJOIN] CreateBinding call for joining node %1!ws! failed because the join was aborted.\n",
                    JoinerNodeId
                    );
            }

            OmDereferenceObject(joinerNode);
        }
        else {
            status = ERROR_CLUSTER_NODE_NOT_MEMBER;
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NMJOIN] CreateBinding call for joining node %1!ws! failed because the node is not a member of the cluster.\n",
                JoinerNodeId
                );
        }

        NmpLockedLeaveApi();
    }

    NmpReleaseLock();

    return(status);

} // s_NmRpcCreateBinding


error_status_t
s_NmRpcCreateJoinerBinding(
    IN handle_t  IDL_handle,
    IN DWORD     JoinSequence,
    IN LPWSTR    JoinerNodeId,
    IN LPWSTR    JoinerInterfaceId
    )
/*++

Notes:

   The sponsor is responsible for aborting the join on failure.

--*/
{
    DWORD   status;


    NmpAcquireLock();

    ClRtlLogPrint(LOG_NOISE, 
        "[NMJOIN] Processing CreateBinding request for joining node %1!ws!.\n",
        JoinerNodeId
        );

    if (NmpLockedEnterApi(NmStateOnline)) {
        PNM_NODE joinerNode = OmReferenceObjectById(
                                  ObjectTypeNode,
                                  JoinerNodeId
                                  );

        if (joinerNode != NULL) {
            PNM_INTERFACE  netInterface = OmReferenceObjectById(
                                              ObjectTypeNetInterface,
                                              JoinerInterfaceId
                                              );

            if (netInterface != NULL) {
                //
                // Verify that a join is still in progress.
                //
                if ( (JoinSequence == NmpJoinSequence) &&
                     (NmpJoinerNodeId == joinerNode->NodeId)
                   )
                {
                    status = NmpCreateJoinerRpcBindings(
                                 joinerNode,
                                 netInterface
                                 );

                    if (status != ERROR_SUCCESS) {
                        WCHAR errorString[12];

                        wsprintfW(&(errorString[0]), L"%u", status);
                        CsLogEvent3(
                            LOG_UNUSUAL,
                            NM_EVENT_JOINER_BIND_FAILED,
                            OmObjectName(joinerNode),
                            OmObjectName(netInterface->Network),
                            errorString
                            );
                    }
                }
                else {
                    status = ERROR_CLUSTER_JOIN_ABORTED;
                    ClRtlLogPrint(LOG_UNUSUAL, 
                        "[NMJOIN] Failing create bindings for joining node %1!ws! because the join was aborted\n",
                        JoinerNodeId
                        );
                }

                OmDereferenceObject(netInterface);
            }
            else {
                status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
                ClRtlLogPrint(LOG_CRITICAL, 
                    "[NMJOIN] Can't create binding for joining node %1!ws! - no corresponding interface for joiner interface %2!ws!.\n",
                    JoinerNodeId,
                    JoinerInterfaceId
                    );
            }

            OmDereferenceObject(joinerNode);
        }
        else {
            status = ERROR_CLUSTER_NODE_NOT_MEMBER;
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NMJOIN] CreateBinding call for joining node %1!ws! failed because the node is not a member of the cluster.\n",
                JoinerNodeId
                );
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE, 
            "[NMJOIN] Not in valid state to process the request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

}  // s_NmRpcCreateJoinerBinding


DWORD
NmpCreateJoinerRpcBindings(
    IN PNM_NODE       JoinerNode,
    IN PNM_INTERFACE  JoinerInterface
    )
/*++

Notes:

    Called with the NmpLock held.

--*/
{
    DWORD          status;
    PNM_NETWORK    network = JoinerInterface->Network;
    CL_NODE_ID     joinerNodeId = JoinerNode->NodeId;


    CL_ASSERT(JoinerNode->NodeId == NmpJoinerNodeId);
    CL_ASSERT(JoinerNode->State == ClusterNodeJoining);

    ClRtlLogPrint(LOG_NOISE, 
        "[NMJOIN] Creating bindings for joining node %1!u! using network %2!ws!\n",
        joinerNodeId,
        OmObjectName(JoinerInterface->Network)
        );

    //
    // Make sure that this node has an interface on the target network.
    //

    if (NmpIsNetworkForInternalUse(network)) {
        if (network->LocalInterface != NULL) {
            if ( NmpIsInterfaceRegistered(JoinerInterface) &&
                 NmpIsInterfaceRegistered(network->LocalInterface)

               )
            {
                status = NmpSetNodeInterfacePriority(
                             JoinerNode,
                             0xFFFFFFFF,
                             JoinerInterface,
                             1
                             );

                if (status == ERROR_SUCCESS) {
                    PNM_INTERFACE  localInterface = network->LocalInterface;

                    //
                    // Create intracluster RPC bindings for the petitioner.
                    // The MM relies on these to perform the join.
                    //

                    OmReferenceObject(localInterface);
                    OmReferenceObject(JoinerNode);

                    NmpReleaseLock();

                    status = NmpCreateRpcBindings(JoinerNode);

                    NmpAcquireLock();

                    if (status != ERROR_SUCCESS) {
                        ClRtlLogPrint(LOG_UNUSUAL, 
                            "[NMJOIN] Unable to create RPC binding for "
                            "joining node %1!u!, status %2!u!.\n",
                            joinerNodeId,
                            status
                            );
                    }

                    OmDereferenceObject(JoinerNode);
                    OmDereferenceObject(localInterface);
                }
                else {
                    ClRtlLogPrint(LOG_CRITICAL, 
                        "[NMJOIN] Failed to set interface priority for "
                        "network %1!ws! (%2!ws!), status %3!u!\n",
                        OmObjectId(network),
                        OmObjectName(network),
                        status
                        );
                }
            }
            else {
                status = ERROR_CLUSTER_NODE_UNREACHABLE;
            }
        }
        else {
            status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
        }
    }
    else {
        status = ERROR_CLUSTER_NODE_UNREACHABLE;
    }

    if (status !=ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NMJOIN] Failed to create binding for joining node %1!u! "
            "on network %2!ws! (%3!ws!), status %4!u!\n",
            joinerNodeId,
            OmObjectId(network),
            OmObjectName(network),
            status
            );
    }

    return(status);

} // NmpCreateJoinerRpcBinding



error_status_t
s_NmRpcPetitionForMembership(
    IN handle_t  IDL_handle,
    IN DWORD     JoinSequence,
    IN LPCWSTR   JoinerNodeId
    )
/*++

Routine Description:

    Server side of a join petition.

Arguments:

    IDL_handle - RPC binding handle, not used.

    JoinSequence - Supplies the sequence returned from NmRpcJoinBegin

    JoinerNodeId - Supplies the ID of the node attempting to join.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error otherwise.

--*/

{
    DWORD     status;
    PNM_NODE  joinerNode;


#ifdef CLUSTER_TESTPOINT
    TESTPT(TestpointJoinFailPetition) {
        return(999999);
    }
#endif

    NmpAcquireLock();

    ClRtlLogPrint(LOG_UNUSUAL, 
        "[NMJOIN] Processing petition to join from node %1!ws!.\n",
        JoinerNodeId
        );

    if (NmpLockedEnterApi(NmStateOnline)) {

        joinerNode = OmReferenceObjectById(ObjectTypeNode, JoinerNodeId);

        if (joinerNode != NULL) {
            //
            // Verify that the join is still in progress
            //
            //
            // DavidDio 6/13/2000
            // There is a small window where a begin join update can
            // succeed during a regroup, but the regroup ends before
            // the joining node petitions to join. In this case, the
            // node will be marked out of sync. Aborting the join
            // after MMJoin() is much more heavyweight than before,
            // so check for this condition now. (Bug 125778).
            //
            if ( (JoinSequence == NmpJoinSequence) &&
                 (NmpJoinerNodeId == joinerNode->NodeId) &&
                 (NmpSponsorNodeId == NmLocalNodeId) &&
                 (!NmpJoinAbortPending) &&
                 (!NmpJoinerOutOfSynch)
               )
            {
                ClRtlLogPrint(LOG_UNUSUAL, "[NMJOIN] Performing join.\n");

                CL_ASSERT(joinerNode->State == ClusterNodeJoining);
                CL_ASSERT(NmpJoinerUp == FALSE);
                CL_ASSERT(NmpJoinTimer != 0);

                //
                // Call the MM to join this node to the cluster membership.
                // Disable the join timer. Once the node becomes an active
                // member, we won't need it anymore.
                //
                NmpJoinTimer = 0;

                NmpReleaseLock();

                status = MMJoin(
                             joinerNode->NodeId,
                             NM_CLOCK_PERIOD,
                             NM_SEND_HB_RATE,
                             NM_RECV_HB_RATE,
                             NM_MM_JOIN_TIMEOUT
                             );

                NmpAcquireLock();

                //
                // Verify that the join is still in progress
                //
                if ( (JoinSequence == NmpJoinSequence) &&
                     (NmpJoinerNodeId == joinerNode->NodeId)
                   )
                {
                    CL_ASSERT(NmpSponsorNodeId == NmLocalNodeId);
                    CL_ASSERT(joinerNode->State == ClusterNodeJoining);
                    CL_ASSERT(NmpJoinTimer == 0);
                    CL_ASSERT(NmpJoinAbortPending == FALSE);

                    // GorN 3/22/2000
                    // We hit a case when MMJoin has succeeded after a regroup
                    // that killed one of the nodes (not joiner and not sponsor)
                    // thus leaving the joiner out of sync
                    // We need to abourt the join in this case too

                    if (status != MM_OK || NmpJoinerOutOfSynch) {
                        status = MMMapStatusToDosError(status);

                        if (NmpJoinerOutOfSynch) {
                            status = ERROR_CLUSTER_JOIN_ABORTED;
                        }
                        
                        //
                        // Abort the join
                        //
                        ClRtlLogPrint(LOG_UNUSUAL, 
                            "[NMJOIN] Petition to join by node %1!ws! failed, status %2!u!.\n",
                            JoinerNodeId,
                            status
                            );
                        //
                        // If MMJoin was unsuccessful it initiates a banishing
                        // regroup. This regroup will deliver node down events
                        // on all nodes that saw hb's from the joiner.
                        //
                        // Calling MMBlockIfRegroupIsInProgress here will guarantee that
                        // Phase2 cleanup is complete on all nodes, before we
                        // call NmpJoinAbort.
                        //
                        NmpReleaseLock();
                        MMBlockIfRegroupIsInProgress();
                        NmpAcquireLock();

                        NmpJoinAbort(status, joinerNode);
                    }
                    else {
                        NmpSuccessfulMMJoin = TRUE;
                        ClRtlLogPrint(LOG_UNUSUAL, 
                            "[NMJOIN] Petition to join by node %1!ws! succeeded.\n",
                            JoinerNodeId
                            );
                    }

#ifdef MM_IN_CLUSNET

                    if (status == MM_OK) {

                        status = NmJoinNodeToCluster(joinerNodeId);

                        if (status != ERROR_SUCCESS) {

                            DWORD clusnetStatus;

                            ClRtlLogPrint(LOG_UNUSUAL, 
                                "[NMJOIN] Join of node %1!ws! failed, status %2!u!.\n",
                                JoinerNodeId,
                                status
                                );

                            CL_LOGFAILURE( status );

                            NmpReleaseLock();

                            MMEject(joinerNodeId);

                            NmpAcquireLock();

                            clusnetStatus = ClusnetOfflineNodeComm(
                                                NmClusnetHandle,
                                                joinerNodeId
                                                );
                            CL_ASSERT(
                                (status == ERROR_SUCCESS) ||
                                (status == ERROR_CLUSTER_NODE_ALREADY_DOWN
                                );
                        }
                        else {
                            ClRtlLogPrint(LOG_UNUSUAL, 
                                "[NMJOIN] Join completed successfully.\n"
                                );
                        }
                    }

#endif // MM_IN_CLUSNET

                }
                else {
                    status = ERROR_CLUSTER_JOIN_ABORTED;
                    ClRtlLogPrint(LOG_UNUSUAL, 
                        "[NMJOIN] Petition to join by node %1!ws! failed because the join was aborted.\n",
                        JoinerNodeId
                        );
                }
            }
            else {
                status = ERROR_CLUSTER_JOIN_ABORTED;
                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[NMJOIN] Petition by node %1!ws! failed because the join was aborted\n",
                    JoinerNodeId
                    );
            }

            OmDereferenceObject(joinerNode);
        }
        else {
            status = ERROR_CLUSTER_NODE_NOT_MEMBER;
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NMJOIN] Petition to join by %1!ws! failed because the node is not a cluster member\n",
                JoinerNodeId
                );
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE, 
            "[NMJOIN] Not in valid state to process the request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

}  // s_NmRpcPetitionForMembership


error_status_t
s_NmRpcGetLeaderNodeId(
    IN  handle_t                    IDL_handle,
    IN  DWORD                       JoinSequence,   OPTIONAL
    IN  LPWSTR                      JoinerNodeId,   OPTIONAL
    OUT LPDWORD                     LeaderNodeId
    )
{
    DWORD          status = ERROR_SUCCESS;
    PNM_NODE       joinerNode = NULL;


    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)){
        joinerNode = OmReferenceObjectById(
                         ObjectTypeNode,
                         JoinerNodeId
                         );

        if (joinerNode != NULL) {
            if ( (JoinSequence == NmpJoinSequence) &&
                 (NmpJoinerNodeId == joinerNode->NodeId) &&
                 (NmpSponsorNodeId == NmLocalNodeId) &&
                 !NmpJoinAbortPending
               )
            {
                CL_ASSERT(joinerNode->State == ClusterNodeJoining);

                *LeaderNodeId = NmpLeaderNodeId;
            }
            else {
                status = ERROR_CLUSTER_JOIN_ABORTED;
                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[NMJOIN] GetLeaderNodeId call for joining node %1!ws! failed because the join was aborted.\n",
                    JoinerNodeId
                    );
            }

            OmDereferenceObject(joinerNode);
        }
        else {
            status = ERROR_CLUSTER_NODE_NOT_MEMBER;
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NMJOIN] GetLeaderNodeId call for joining node %1!ws! failed because the node is not a member of the cluster.\n",
                JoinerNodeId
                );
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE, 
            "[NMJOIN] Not in valid state to process GetLeaderNodeId request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

} // s_NmRpcGetLeaderNodeId


DWORD
NmpUpdateJoinComplete(
    IN PNM_JOIN_UPDATE  JoinUpdate
    )
{
    DWORD  status;


    NmpAcquireLock();

    ClRtlLogPrint(LOG_NOISE, 
        "[NMJOIN] Processing JoinComplete update from node %1!ws!\n",
        JoinUpdate->NodeId
        );

    if (NmpLockedEnterApi(NmStateOnline)) {
        PNM_NODE  joinerNode;
        LPWSTR    joinerIdString = JoinUpdate->NodeId;


        joinerNode = OmReferenceObjectById(ObjectTypeNode, joinerIdString);

        if (joinerNode != NULL) {

            CL_ASSERT(joinerNode != NmLocalNode);

            //
            // Verify that the join is still in progress and nothing has
            // changed.
            //
            if ( (JoinUpdate->JoinSequence == NmpJoinSequence) &&
                 (NmpJoinerNodeId == joinerNode->NodeId) &&
                 (joinerNode->State == ClusterNodeJoining) &&
                 NmpJoinerUp &&
                 !NmpJoinerOutOfSynch
               )
            {
                PNM_INTERFACE  netInterface;
                PNM_NETWORK    network;
                PLIST_ENTRY    ifEntry;


                NmpJoinerNodeId = ClusterInvalidNodeId;
                NmpSponsorNodeId = ClusterInvalidNodeId;
                NmpJoinTimer = 0;
                NmpJoinAbortPending = FALSE;
                NmpJoinSequence = 0;
                NmpJoinerUp = FALSE;

                if (JoinUpdate->IsPaused != 0) {
                    //
                    // This node is coming up in the paused state.
                    //
                    joinerNode->State = ClusterNodePaused;
                } else {
                    joinerNode->State = ClusterNodeUp;
                }

                joinerNode->ExtendedState = ClusterNodeJoining;

                ClusterEvent(CLUSTER_EVENT_NODE_UP, (PVOID)joinerNode);
                
                //
                // Reset the interface priorities for this node.
                //
                for (ifEntry = joinerNode->InterfaceList.Flink;
                     ifEntry != &joinerNode->InterfaceList;
                     ifEntry = ifEntry->Flink
                    )
                {
                    netInterface = CONTAINING_RECORD(
                                       ifEntry,
                                       NM_INTERFACE,
                                       NodeLinkage
                                       );

                    network = netInterface->Network;

                    if ( NmpIsNetworkForInternalUse(network) &&
                         NmpIsInterfaceRegistered(netInterface)
                       )
                    {
                        status = ClusnetSetInterfacePriority(
                                     NmClusnetHandle,
                                     joinerNode->NodeId,
                                     network->ShortId,
                                     0
                                     );

                        CL_ASSERT(status == ERROR_SUCCESS);
                    }
                }

                status = ERROR_SUCCESS;
            }
            else {
                status = ERROR_CLUSTER_JOIN_ABORTED;
                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[NMJOIN] Join of node %1!ws! cannot complete because the join was aborted\n",
                    joinerIdString
                    );
            }

            OmDereferenceObject(joinerNode);
        }
        else {
            status =ERROR_CLUSTER_NODE_NOT_MEMBER;
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NMJOIN] Join of node %1!ws! cannot complete because the node is not a cluster member.\n",
                joinerIdString
                );
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] Not in valid state to process JoinComplete update.\n"
            );
    }

    //
    // If the multicast shared key is based on the cluster service account
    // password, we may need to refresh, since the password might have
    // changed and the joiner will be running under the new password.
    //
    if (status == ERROR_SUCCESS) {
        status = NmpMulticastRegenerateKey(NULL);
        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to regenerate cluster network multicast "
                "keys, status %1!u!.\n",
                status
                );
            //
            // Not a de facto fatal error.
            //
            status = ERROR_SUCCESS;
        }
    }

    NmpReleaseLock();

    // DavidDio 10/27/2000
    // Bug 213781: NmpUpdateJoinComplete must always return ERROR_SUCCESS.
    // Otherwise, there is a small window whereby GUM sequence numbers on
    // remaining cluster nodes can fall out of sync. If the join should
    // be aborted, return ERROR_SUCCESS but poison the joiner out-of-band.
    if (status != ERROR_SUCCESS) {
        DWORD dwJoinerId;

        if (JoinUpdate->NodeId != NULL) {
            dwJoinerId = wcstoul(JoinUpdate->NodeId, NULL, 10);
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NMJOIN] Join of node %1!u! failed with status %2!u!. Initiating banishment.\n",
                dwJoinerId,
                status
                );
            NmAdviseNodeFailure(dwJoinerId, status);
        } else {
            dwJoinerId = ClusterInvalidNodeId;
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NMJOIN] Join of node %1!ws! failed with status %2!u!. Cannot initiate banishment as node id is unknown.\n",
                dwJoinerId,
                status
                );
        }
    }

    return(ERROR_SUCCESS);

} // NmpUpdateJoinComplete


DWORD
NmpUpdateJoinAbort(
    IN  BOOL    SourceNode,
    IN  LPDWORD JoinSequence,
    IN  LPWSTR  JoinerNodeId
    )
/*++

Notes:


--*/
{
    DWORD   status = ERROR_SUCCESS;


    NmpAcquireLock();

    ClRtlLogPrint(LOG_NOISE, 
        "[NMJOIN] Received update to abort join sequence %1!u! (joiner id %2!ws!).\n",
        *JoinSequence,
        JoinerNodeId
        );

    if (NmpLockedEnterApi(NmStateOnline)) {
        PNM_NODE  joinerNode = OmReferenceObjectById(
                                   ObjectTypeNode,
                                   JoinerNodeId
                                   );

        if (joinerNode != NULL) {
            //
            // Check if the specified join is still in progress.
            //
            if ( (*JoinSequence == NmpJoinSequence) &&
                 (NmpJoinerNodeId == joinerNode->NodeId)
               )
            {
                CL_ASSERT(NmpSponsorNodeId != ClusterInvalidNodeId);
                CL_ASSERT(joinerNode->State == ClusterNodeJoining);

                //
                // Assumption:
                //
                // An abort cannot occur during the MM join process.
                // If the joiner is not already up, it cannot come up
                // during the abort processing.
                //
                // Assert condition may not be true with the current MM join code.
                // Some nodes might have got monitor node and set
                // NmpJoinerUp state to TRUE by the time the sponsor issued
                // an abort update
                //
                //CL_ASSERT(NmpJoinerUp == FALSE);

                if (NmpCleanupIfJoinAborted) {

                    NmpCleanupIfJoinAborted = FALSE;

                    ClRtlLogPrint(LOG_UNUSUAL, 
                        "[NMJOIN] Issuing a node down event for %1!u!.\n",
                        joinerNode->NodeId
                        );

                    //
                    // This node is not yet active in the membership.
                    // Call the node down event handler to finish the abort.
                    //

                    //
                    // We will not call NmpMsgCleanup1 and NmpMsgCleanup2,
                    // because we cannot guarantee that they will get executed
                    // in a barrier style fashion
                    //
                    // !!! Lock will be acquired by NmpNodeDownEventHandler
                    // second time. Is it OK?
                    //
                    NmpNodeDownEventHandler(joinerNode);
                } else {
                    ClRtlLogPrint(LOG_UNUSUAL, 
                        "[NMJOIN] Node down was already issued for %1!u!.\n",
                        joinerNode->NodeId
                        );
                }
            }
            else {
                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[NMJOIN] Ignoring old join abort update with sequence %1!u!.\n",
                    *JoinSequence
                    );
            }

            OmDereferenceObject(joinerNode);
            status = ERROR_SUCCESS;
        }
        else {
            status = ERROR_CLUSTER_NODE_NOT_MEMBER;
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NMJOIN] Join of node %1!ws! cannot be aborted because the node is not a cluster member.\n",
                JoinerNodeId
                );
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] Not in valid state to process JoinAbort update.\n"
            );
    }

    NmpReleaseLock();

    return(status);

}  // NmpUpdateJoinAbort


VOID
NmpJoinAbort(
    DWORD      AbortStatus,
    PNM_NODE   JoinerNode
    )
/*++

Routine Description:

    Issues a JoinAbort update.

Notes:

    Called with the NmpLock held.

--*/
{
    DWORD    status;
    DWORD    joinSequence = NmpJoinSequence;
    WCHAR    errorString[12];


    CL_ASSERT(NmpJoinerNodeId != ClusterInvalidNodeId);
    CL_ASSERT(NmpSponsorNodeId == NmLocalNodeId);
    CL_ASSERT(JoinerNode->State == ClusterNodeJoining);

    if (AbortStatus == ERROR_TIMEOUT) {
        wsprintfW(&(errorString[0]), L"%u", AbortStatus);
        CsLogEvent1(
            LOG_CRITICAL,
            NM_EVENT_JOIN_TIMED_OUT,
            OmObjectName(JoinerNode)
            );
    }
    else {
        wsprintfW(&(errorString[0]), L"%u", AbortStatus);
        CsLogEvent2(
            LOG_CRITICAL,
            NM_EVENT_SPONSOR_JOIN_ABORTED,
            OmObjectName(JoinerNode),
            errorString
            );
    }

    //
    // Assumption:
    //
    // An abort cannot occur during the MM join process. If the joiner
    // is not already up, it cannot come up during the abort processing.
    //
    if (NmpSuccessfulMMJoin == FALSE) {
        //
        // The joining node has not become active yet. Issue
        // an abort update.
        //
        DWORD    joinSequence = NmpJoinSequence;


        ClRtlLogPrint(LOG_NOISE, 
            "[NMJOIN] Issuing update to abort join of node %1!u!.\n",
            NmpJoinerNodeId
            );

        NmpReleaseLock();

        status = GumSendUpdateEx(
                     GumUpdateMembership,
                     NmUpdateJoinAbort,
                     2,
                     sizeof(DWORD),
                     &joinSequence,
                     NM_WCSLEN(OmObjectId(JoinerNode)),
                     OmObjectId(JoinerNode)
                     );

        NmpAcquireLock();
    }
    else {
        //
        // The joining node is already active in the membership.
        // Ask the MM to kick it out. The node down event will
        // finish the abort process.
        //
        CL_NODE_ID joinerNodeId = NmpJoinerNodeId;

        ClRtlLogPrint(LOG_NOISE, 
            "[NMJOIN] Ejecting joining node %1!u! from the cluster membership.\n",
            NmpJoinerNodeId
            );

        NmpReleaseLock();

        status = MMEject(joinerNodeId);

        NmpAcquireLock();
    }

    if (status != MM_OK) {
        status = MMMapStatusToDosError(status);
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] Update to abort join of node %1!u! failed, status %2!u!\n",
            JoinerNode->NodeId,
            status
            );

        //
        // If the join is still pending, and this is the sponsor node,
        // force a timeout to retry the abort. If we aren't the sponsor,
        // there isn't much we can do.
        //
        if ( (joinSequence == NmpJoinSequence) &&
             (NmpJoinerNodeId == JoinerNode->NodeId) &&
             (NmpSponsorNodeId == NmLocalNodeId)
           )
        {
            NmpJoinTimer = 1;
            NmpJoinAbortPending = FALSE;
        }
    }

    return;

}  // NmpJoinAbort


VOID
NmpJoinAbortWorker(
    IN PCLRTL_WORK_ITEM   WorkItem,
    IN DWORD              Status,
    IN DWORD              BytesTransferred,
    IN ULONG_PTR          IoContext
    )
/*++

Routine Description:

    Worker thread for aborting a join.

--*/
{
    DWORD joinSequence = PtrToUlong(WorkItem->Context);


    NmpAcquireLock();

    //
    // The active thread count was bumped up when this item was scheduled.
    // No need to call NmpEnterApi().
    //

    //
    // If the join is still pending, begin the abort process.
    //
    if ( (joinSequence == NmpJoinSequence) &&
         (NmpJoinerNodeId != ClusterInvalidNodeId) &&
         NmpJoinAbortPending
       )
    {
        PNM_NODE  joinerNode = NmpIdArray[NmpJoinerNodeId];

        if (joinerNode != NULL) {
            ClRtlLogPrint(LOG_NOISE, 
                "[NMJOIN] Worker thread initiating abort of joining node %1!u!\n",
                NmpJoinerNodeId
                );

            NmpJoinAbort(ERROR_TIMEOUT, joinerNode);
        }
        else {
            CL_ASSERT(joinerNode != NULL);
        }
    }
    else {
        ClRtlLogPrint(LOG_NOISE, 
            "[NMJOIN] Skipping join abort, sequence to abort %1!u!, current join sequence %2!u!, "
            "joiner node: %3!u! sponsor node: %4!u!\n",
            joinSequence,
            NmpJoinSequence,
            NmpJoinerNodeId,
            NmpSponsorNodeId
            );
    }

    NmpLockedLeaveApi();

    NmpReleaseLock();

    LocalFree(WorkItem);

    return;

}  // NmpJoinAbortWorker


VOID
NmpJoinTimerTick(
    IN DWORD  MsTickInterval
    )
/*++

Notes:
    Called with NmpLock held.

--*/
{
    if (NmpLockedEnterApi(NmStateOnline)) {
        //
        // If we are sponsoring a join, update the timer.
        //
        if ( (NmpJoinerNodeId != ClusterInvalidNodeId) &&
             (NmpSponsorNodeId == NmLocalNodeId) &&
             !NmpJoinAbortPending &&
             (NmpJoinTimer != 0)
           )
        {        
            //ClRtlLogPrint(LOG_NOISE,
            //   "[NMJOIN] Timer tick (%1!u! ms)\n",
            //    Interval
            //    );

            if (NmpJoinTimer > MsTickInterval) {
                NmpJoinTimer -= MsTickInterval;
            }
            else {
                //
                // The join has timed out. Schedule a worker thread to
                // carry out the abort process.
                //
                PCLRTL_WORK_ITEM workItem;

                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[NMJOIN] Join of node %1!u! has timed out.\n",
                    NmpJoinerNodeId
                    );

                workItem = LocalAlloc(LMEM_FIXED, sizeof(CLRTL_WORK_ITEM));

                if (workItem != NULL) {
                    DWORD  status;

                    ClRtlInitializeWorkItem(
                        workItem,
                        NmpJoinAbortWorker,
                        ULongToPtr(NmpJoinSequence)
                        );

                    status = ClRtlPostItemWorkQueue(
                                 CsDelayedWorkQueue,
                                 workItem,
                                 0,
                                 0
                                 );

                    if (status == ERROR_SUCCESS) {
                        //
                        // Stop the timer, flag that an abort is in progress,
                        // and account for the thread we just scheduled.
                        //
                        NmpJoinTimer = 0;
                        NmpJoinAbortPending = TRUE;
                        NmpActiveThreadCount++;
                    }
                    else {
                        ClRtlLogPrint(LOG_UNUSUAL, 
                            "[NMJOIN] Failed to schedule abort of join, status %1!u!.\n",
                            status
                            );
                        LocalFree(workItem);
                    }
                }
                else {
                    ClRtlLogPrint(LOG_UNUSUAL, 
                        "[NMJOIN] Failed to allocate memory for join abort.\n"
                        );
                }
            }
        }
        NmpLockedLeaveApi();
    }

    return;

}  // NmpJoinTimerTick


VOID
NmTimerTick(
    IN DWORD  MsTickInterval
    )
/*++

Routine Description:

    Implements all of the NM timers. Called on every tick of
    the common NM/MM timer - currently every 300ms.

Arguments:

    MsTickInterval - The number of milliseconds that have passed
                     since the last tick.

ReturnValue:

    None.

--*/
{
    NmpAcquireLock();

    NmpNetworkTimerTick(MsTickInterval);

    NmpJoinTimerTick(MsTickInterval);

#if DBG

    // Addition for checking for hung RPC threads.
    NmpRpcTimerTick(MsTickInterval);

#endif // DBG

    NmpReleaseLock();

    return;

} // NmTimerTick


error_status_t
s_JoinAddNode3(
    IN handle_t IDL_handle,
    IN LPCWSTR  lpszNodeName,
    IN DWORD    dwNodeHighestVersion,
    IN DWORD    dwNodeLowestVersion,
    IN DWORD    dwNodeProductSuite
    )
/*++

Routine Description:

    Adds a new node to the cluster.

Arguments:

    IDL_handle - RPC binding handle, not used.

    lpszNodeName - Supplies the name of the new node.

    dwNodeHighestVersion - The highest cluster version number that the
                           new node can support.

    dwNodeLowestVersion - The lowest cluster version number that the
                          new node can support.

    dwNodeProductSuite - The product suite type identifier for the new node.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

Notes:

    This is a new routine in NT5. It performs the AddNode operation
    correctly. It will never be invoked by an NT4 system. It cannot
    be invoked if an NT4 node is in the cluster without violating
    the license agreement.

    The cluster registry APIs cannot be called while holding the NmpLock,
    or a deadlock may occur.

--*/
{
    DWORD     status;
    DWORD     registryNodeLimit;


    ClRtlLogPrint(LOG_NOISE, 
        "[NMJOIN] Received request to add node '%1!ws!' to the cluster.\n",
        lpszNodeName
        );

    //
    // Read the necessary registry parameters before acquiring
    // the NM lock.
    //
    status = DmQueryDword(
                 DmClusterParametersKey,
                 CLUSREG_NAME_MAX_NODES,
                 &registryNodeLimit,
                 NULL
                 );

    if (status != ERROR_SUCCESS) {
        registryNodeLimit = 0;
    }

    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)) {
        DWORD retryCount = 0;

        //if this is the last node and it has been evicted
        //but the cleanup hasnt completed and hence the
        //service is up, then it should not entertain
        //any new join requests
        if (NmpLastNodeEvicted)
        {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NMJOIN] This node was evicted and hence is not in a valid state to process a "
                "request to add a node to the cluster.\n"
                );
            status = ERROR_NODE_NOT_AVAILABLE;        
            NmpLockedLeaveApi();
            goto FnExit;
        }
        

        while (TRUE) {
            if (NmpLeaderNodeId == NmLocalNodeId) {
                //
                // This node is the leader, call the internal
                // handler directly.
                //
                status = NmpAddNode(
                            lpszNodeName,
                            dwNodeHighestVersion,
                            dwNodeLowestVersion,
                            dwNodeProductSuite,
                            registryNodeLimit
                            );
            }
            else {
                //
                // Forward the request to the leader.
                //
                RPC_BINDING_HANDLE binding = Session[NmpLeaderNodeId];

                    ClRtlLogPrint(LOG_NOISE, 
                        "[NMJOIN] Forwarding request to add node '%1!ws!' "
                        "to the cluster to the leader (node %!u!).\n",
                        lpszNodeName,
                        NmpLeaderNodeId
                        );

                CL_ASSERT(binding != NULL);

                NmpReleaseLock();

                status = NmRpcAddNode(
                             binding,
                             lpszNodeName,
                             dwNodeHighestVersion,
                             dwNodeLowestVersion,
                             dwNodeProductSuite
                             );

                 NmpAcquireLock();
             }

            //
            // Check for the error codes that indicate either that
            // another AddNode operation is in progress or that the
            // leadership is changing. We will retry in these cases.
            //
            if ( (status != ERROR_CLUSTER_JOIN_IN_PROGRESS) &&
                 (status != ERROR_NODE_NOT_AVAILABLE)
               ) {
                    break;
            }

            //
            // Sleep for 3 seconds and try again. We will give up and
            // return the error after retrying for 2 minutes.
            //
            if (++retryCount > 40) {
                break;
            }

            ClRtlLogPrint(LOG_NOISE, 
                "[NMJOIN] AddNode operation for node '%1!ws! delayed "
                "waiting for competing AddNode operation to complete.\n",
                lpszNodeName
                );

            NmpReleaseLock();

            Sleep(3000);

            NmpAcquireLock();

        } // end while(TRUE)

        NmpLockedLeaveApi();
    }
    else {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NMJOIN] This system is not in a valid state to process a "
            "request to add a node to the cluster.\n"
            );
        status = ERROR_NODE_NOT_AVAILABLE;
    }

FnExit:
    NmpReleaseLock();

    return(status);

} // s_NmJoinAddNode3


//  This is used by setup of all highest major versions post 1.0
error_status_t
s_JoinAddNode2(
    IN handle_t IDL_handle,
    IN LPCWSTR  lpszNodeName,
    IN DWORD    dwNodeHighestVersion,
    IN DWORD    dwNodeLowestVersion
    )
/*++

Routine Description:

    Adds a new node to the cluster database.

Arguments:

    IDL_handle - RPC binding handle, not used.

    lpszNodeName - Supplies the name of the new node.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

Notes:

    This routine was defined in NT4-SP4. JoinAddNode3 is used by NT5. Since
    it is impossible to install clustering using the NT4-SP4 software,
    this routine should never be invoked.

--*/

{
    CL_ASSERT(FALSE);

    return(ERROR_CLUSTER_INCOMPATIBLE_VERSIONS);
}

error_status_t
s_JoinAddNode(
    IN handle_t IDL_handle,
    IN LPCWSTR lpszNodeName
    )
/*++

Routine Description:

    Adds a new node to the cluster database.

Arguments:

    IDL_handle - RPC binding handle, not used.

    lpszNodeName - Supplies the name of the new node.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

Notes:

    This is the routine that NT4-SP3 setup invokes to add a new node to
    a cluster. The combination of NT4-SP3 and NT5 is not supported.

--*/

{
    return(ERROR_CLUSTER_INCOMPATIBLE_VERSIONS);
}

//
// The rest of the code is currently unused.
//
error_status_t
s_NmRpcDeliverJoinMessage(
    IN handle_t    IDL_handle,
    IN UCHAR *     Message,
    IN DWORD       MessageLength
    )
/*++

Routine Description:

    Server side of the RPC interface for delivering membership
    join messages.

Arguments:

    IDL_handle - RPC binding handle, not used.

    buffer - Supplies a pointer to the message data.

    length - Supplies the length of the message data.

Return Value:

    ERROR_SUCCESS

--*/

{
    DWORD  status = ERROR_SUCCESS;

#ifdef MM_IN_CLUSNET

    ClRtlLogPrint(LOG_NOISE, 
        "[NMJOIN] Delivering join message to Clusnet.\n"
        );

    status = ClusnetDeliverJoinMessage(
                 NmClusnetHandle,
                 Message,
                 MessageLength
                 );

#endif
    return(status);
}


#ifdef MM_IN_CLUSNET

DWORD
NmpSendJoinMessage(
    IN ULONG        DestNodeMask,
    IN PVOID        Message,
    IN ULONG        MessageLength
    )
{
    DWORD        status = ERROR_SUCCESS;
    CL_NODE_ID   node;


    CL_ASSERT(NmMaxNodeId != ClusterInvalidNodeId);

    for ( node = ClusterMinNodeId;
          node <= NmMaxNodeId;
          node++, (DestNodeMask >>= 1)
        )
    {

        if (DestNodeMask & 0x1) {
            if (node != NmLocalNodeId) {

                ClRtlLogPrint(LOG_NOISE, 
                    "[NMJOIN] Sending join message to node %1!u!.\n",
                    node
                    );

                status = NmRpcDeliverJoinMessage(
                             Session[node->NodeId],
                             Message,
                             MessageLength
                             );

                if (status == RPC_S_CALL_FAILED_DNE) {
                    //
                    // Try again since the first call to a restarted
                    // RPC server will fail.
                    //
                    status = NmRpcDeliverJoinMessage(
                                 Session[node->NodeId],
                                 Message,
                                 MessageLength
                                 );
                }
            }
            else {
                ClRtlLogPrint(LOG_NOISE, 
                    "[NMJOIN] Delivering join message to local node.\n"
                    );

                status = ClusnetDeliverJoinMessage(
                             NmClusnetHandle,
                             Message,
                             MessageLength
                             );
            }

            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_NOISE, 
                    "[NMJOIN] send of join message to node %1!u! failed, status %2!u!\n",
                    node,
                    status
                    );
                break;
            }
        }
    }

    return(status);

}  // NmpSendJoinMessage


DWORD
NmJoinNodeToCluster(
    CL_NODE_ID  joinerNodeId
    )
{
    DWORD                status;
    PVOID                message = NULL;
    ULONG                messageLength;
    ULONG                destMask;
    CLUSNET_JOIN_PHASE   phase;

    ClRtlLogPrint(LOG_NOISE, 
        "[NMJOIN] Joining node %1!u! to the cluster.\n",
        joinerNodeId
        );

    for (phase = ClusnetJoinPhase1; phase <= ClusnetJoinPhase4; phase++) {

        ClRtlLogPrint(LOG_NOISE, 
            "[NMJOIN] JoinNode phase %1!u!\n",
            phase
            );

        status = ClusnetJoinCluster(
                     NmClusnetHandle,
                     joinerNodeId,
                     phase,
                     NM_MM_JOIN_TIMEOUT,
                     &message,
                     &messageLength,
                     &destMask
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_NOISE, 
                "[NMJOIN] JoinNode phase %1!u! failed, status %2!u!\n",
                phase,
                status
                );

            break;
        }

        status = NmpSendJoinMessage(
                     destMask,
                     message,
                     messageLength
                     );

        if (status != ERROR_SUCCESS) {
            DWORD abortStatus;

            ClRtlLogPrint(LOG_NOISE, 
                "[NMJOIN] send join message failed %1!u!, aborting join of node %2!u!.\n",
                status,
                joinerNodeId
                );

            abortStatus = ClusnetJoinCluster(
                              NmClusnetHandle,
                              joinerNodeId,
                              ClusnetJoinPhaseAbort,
                              NM_MM_JOIN_TIMEOUT,
                              &message,
                              &messageLength,
                              &destMask
                              );

            if (abortStatus == ERROR_SUCCESS) {
                (VOID) NmpSendJoinMessage(
                           destMask,
                           message,
                           messageLength
                           );
            }

            break;
        }
    }

    if (message != NULL) {
        ClusnetEndJoinCluster(NmClusnetHandle, message);
    }

    return(status);

}  // NmJoinNodeToCluster


#endif  // MM_IN_CLUSNET
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\nm\nmp.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    nmp.h

Abstract:

    Private interface definitions for the Node Manager component.

Author:

    Mike Massa (mikemas) 12-Mar-1996


Revision History:

--*/


#ifndef _NMP_INCLUDED
#define _NMP_INCLUDED

#define UNICODE 1

#include "service.h"
#include <winsock2.h>
#include <clnetcfg.h>
#include <bitset.h>
#include <madcapcl.h>
#include <time.h>


//
// Constants
//
#define LOG_CURRENT_MODULE LOG_MODULE_NM

#define NM_JOIN_TIMEOUT     60000       // 60 seconds
#define NM_MM_JOIN_TIMEOUT   3000       // 3 seconds
#define NM_CLOCK_PERIOD       300       // 300 milliseconds
#define NM_SEND_HB_RATE         4
#define NM_RECV_HB_RATE         3       // Changed 2=>3 to prolong min_stage_1 ticks from 8 to 12


//
// Common Object Flags
//
#define NM_FLAG_OM_INSERTED               0x10000000
#define NM_FLAG_DELETE_PENDING            0x80000000

//
// Miscellaneous Macros
//
#define NM_WCSLEN(_string)    ((lstrlenW(_string) + 1) * sizeof(WCHAR))


//
// Common Object Management Macros
//
#define NM_OM_INSERTED(obj)         ((obj)->Flags & NM_FLAG_OM_INSERTED)
#define NM_DELETE_PENDING(obj)      ((obj)->Flags & NM_FLAG_DELETE_PENDING)

#define NM_FREE_OBJECT_FIELD(_object, _field)  \
            if ( (_object)->_field != NULL ) \
                LocalFree( (_object)->_field )

#define NM_MIDL_FREE_OBJECT_FIELD(_object, _field)    \
            if ( (_object)->_field != NULL )   {      \
                MIDL_user_free( (_object)->_field );  \
                (_object)->_field = NULL;             \
            }


//
// State of the NM component
//
// Note that the order is important. See NmpEnterApi().
//
typedef enum {
    NmStateOffline = 0,
    NmStateOfflinePending = 1,
    NmStateOnlinePending = 2,
    NmStateOnline = 3,
} NM_STATE, *PNM_STATE;


//
// Node definitions
//
typedef struct {
    DWORD  Status;
    DWORD  LocalOnly;
} NM_NODE_CREATE_CONTEXT, *PNM_NODE_CREATE_CONTEXT;

typedef struct _NM_NODE {
    LIST_ENTRY           Linkage;
    DWORD                NodeId;
    CLUSTER_NODE_STATE   State;
    CLUSTER_NODE_STATE   ExtendedState;
    DWORD                Flags;
    DWORD                InterfaceCount;
    LIST_ENTRY           InterfaceList;
    DWORD                HighestVersion;
    DWORD                LowestVersion;
    RPC_BINDING_HANDLE   ReportRpcBinding;  // for net connectivity reports
    RPC_BINDING_HANDLE   IsolateRpcBinding; // for net failure isolation
    SUITE_TYPE           ProductSuite;
    DWORD                DefaultRpcBindingGeneration;
} NM_NODE;

#define NM_NODE_SIG  'edon'

typedef struct _NM_NODE_AUX_INFO{
    DWORD       dwSize;
    DWORD       dwVer;
    SUITE_TYPE  ProductSuite;
}NM_NODE_AUX_INFO, *PNM_NODE_AUX_INFO;

typedef struct {
    LPCWSTR          NodeId;
    HLOCALXSACTION   Xaction;
    DWORD            Status;
} NM_EVICTION_CONTEXT, *PNM_EVICTION_CONTEXT;


#define NM_NODE_UP(node)  \
            ( ( (node)->State == ClusterNodeUp ) ||  \
              ( (node)->State == ClusterNodePaused ) )


//
// Network definitions
//
typedef struct _NM_STATE_WORK_ENTRY {
    NM_STATE_ENTRY    State;
    DWORD             ReachableCount;
} NM_STATE_WORK_ENTRY, *PNM_STATE_WORK_ENTRY;

typedef PNM_STATE_WORK_ENTRY  PNM_STATE_WORK_VECTOR;

typedef PNM_STATE_ENTRY  PNM_CONNECTIVITY_MATRIX;

#define NM_SIZEOF_CONNECTIVITY_MATRIX(_VectorSize) \
          (sizeof(NM_STATE_ENTRY) * _VectorSize *_VectorSize)

#define NM_NEXT_CONNECTIVITY_MATRIX_ROW(_CurrentRowPtr, _VectorSize) \
          (_CurrentRowPtr + (_VectorSize * sizeof(NM_STATE_ENTRY)))

#define NM_GET_CONNECTIVITY_MATRIX_ROW(_MatrixPtr, _RowNumber, _VectorSize) \
          (_MatrixPtr + (_RowNumber * (_VectorSize * sizeof(NM_STATE_ENTRY))))

#define NM_GET_CONNECTIVITY_MATRIX_ENTRY( \
            _MatrixPtr, \
            _RowNumber, \
            _ColNumber, \
            _VectorSize \
            ) \
            ( _MatrixPtr + \
              (_RowNumber * (_VectorSize * sizeof(NM_STATE_ENTRY))) + \
              (_ColNumber * sizeof(NM_STATE_ENTRY)) \
            )


typedef struct _NM_NETWORK {
    LIST_ENTRY                  Linkage;
    CL_NETWORK_ID               ShortId;
    CLUSTER_NETWORK_STATE       State;
    DWORD                       Flags;
    CLUSTER_NETWORK_ROLE        Role;
    DWORD                       Priority;
    LPWSTR                      Transport;
    LPWSTR                      Address;
    LPWSTR                      AddressMask;
    LPWSTR                      Description;
    LPWSTR                      MulticastAddress;
    PVOID                       MulticastKey;
    DWORD                       MulticastKeyLength;
    PVOID                       MulticastKeySalt;
    DWORD                       MulticastKeySaltLength;
    time_t                      MulticastLeaseObtained;
    time_t                      MulticastLeaseExpires;
    MCAST_CLIENT_UID            MulticastLeaseRequestId;
    LPWSTR                      MulticastLeaseServer;
    DWORD                       InterfaceCount;
    PNM_INTERFACE               LocalInterface;
    PNM_CONNECTIVITY_VECTOR     ConnectivityVector;
    PNM_CONNECTIVITY_MATRIX     ConnectivityMatrix;
    PNM_STATE_WORK_VECTOR       StateWorkVector;
    DWORD                       ConnectivityReportTimer;
    DWORD                       StateRecalcTimer;
    DWORD                       FailureIsolationTimer;
    DWORD                       RegistrationRetryTimer;
    DWORD                       RegistrationRetryTimeout;
    DWORD                       McastAddressRenewTimer;
    DWORD                       McastAddressReleaseRetryTimer;
    DWORD                       McastAddressReconfigureRetryTimer;
    DWORD                       ConnectivityReportRetryCount;
    CLRTL_WORK_ITEM             WorkItem;
    CLRTL_WORK_ITEM             MadcapWorkItem;
    LIST_ENTRY                  McastAddressReleaseList;
    LIST_ENTRY                  InterfaceList;
    LIST_ENTRY                  InternalLinkage;
} NM_NETWORK;

#define NM_NETWORK_SIG  'ten'

//
// State flags
//
#define NM_FLAG_NET_WORKER_RUNNING            0x00000001
#define NM_FLAG_NET_REGISTERED                0x00000002
#define NM_FLAG_NET_MULTICAST_ENABLED         0x00000004
#define NM_FLAG_NET_MADCAP_WORKER_RUNNING     0x00000008
//
// Work Flags
//
#define NM_FLAG_NET_REPORT_LOCAL_IF_UP        0x00000100
#define NM_FLAG_NET_REPORT_CONNECTIVITY       0x00000200
#define NM_FLAG_NET_RECALC_STATE              0x00000400
#define NM_FLAG_NET_ISOLATE_FAILURE           0x00000800
#define NM_FLAG_NET_NEED_TO_REGISTER          0x00002000
#define NM_FLAG_NET_REPORT_LOCAL_IF_FAILED    0x00004000
#define NM_FLAG_NET_RENEW_MCAST_ADDRESS       0x00008000
#define NM_FLAG_NET_RELEASE_MCAST_ADDRESS     0x00010000
#define NM_FLAG_NET_RECONFIGURE_MCAST         0x00020000

#define NM_NET_WORK_FLAGS \
            (NM_FLAG_NET_ISOLATE_FAILURE | \
             NM_FLAG_NET_RECALC_STATE | \
             NM_FLAG_NET_NEED_TO_REGISTER)

#define NM_NET_IF_WORK_FLAGS \
            (NM_FLAG_NET_REPORT_LOCAL_IF_UP | \
             NM_FLAG_NET_REPORT_LOCAL_IF_FAILED)
             
#define NM_NET_MADCAP_WORK_FLAGS \
            (NM_FLAG_NET_RENEW_MCAST_ADDRESS | \
             NM_FLAG_NET_RELEASE_MCAST_ADDRESS | \
             NM_FLAG_NET_RECONFIGURE_MCAST)

#define NmpIsNetworkRegistered(_network) \
            ((_network)->Flags & NM_FLAG_NET_REGISTERED)

#define NmpIsNetworkForInternalUse(_network) \
            ((_network)->Role & ClusterNetworkRoleInternalUse)

#define NmpIsNetworkForClientAccess(_network) \
            ((_network)->Role & ClusterNetworkRoleClientAccess)

#define NmpIsNetworkForInternalAndClientUse(_network) \
            ((_network)->Role == ClusterNetworkRoleInternalAndClient)

#define NmpIsNetworkDisabledForUse(_network) \
            ((_network)->Role == ClusterNetworkRoleNone)

#define NmpIsNetworkEnabledForUse(_network) \
            ((_network)->Role != ClusterNetworkRoleNone)
            
#define NmpIsNetworkMulticastEnabled(_network) \
            ((_network)->Flags & NM_FLAG_NET_MULTICAST_ENABLED)

//
// Network deferred-work timers.
//
// The timer fires every 300ms. One heartbeat (HB) period is 1200ms.
//
// An interface is declared unreachable by ClusNet after two missed HBs.
// On average, an interface will fail in the middle of a ClusNet HB period.
// So, the avg time for ClusNet to detect and report an interface failure
// is 600 + 2400 = 3000ms. The worst case is 1200 + 2400 = 3600ms.
// The best case is 2400ms.
//
// If there are >2 nodes active on a network, it is desirable to
// aggregate interface failure reports when an entire network fails;
// however, we do not know how long it took for ClusNet to make the first
// report. Thus, we assume that the first interface failure was detected
// in the avg time and wait the for the worst case time before reporting.
//
// In the 2 node case, there is no aggregation to be performed so we report
// failures immediately. We always report InterfaceUp and InterfaceFailed
// events immediately. We also report immediately after a NodeDown event.
//
// State recalculation should be performed only after all nodes have reported
// their connectivity changes after a failure. There is spread of 1200ms
// between the best and worst case reporting times. Arbitrary scheduling and
// communication delays can widen the spread even more in the worst case.
// The best we can do is make a good guess. Once in a while, we will
// recalculate too soon. This isn't a disaster since the state calculation
// algorithm will abort if it has partial information. Further, we wait an
// additional period before trying to isolate any connectivity failures that
// were detected. We do this in order to avoid inducing unnecessary
// cluster resource failures.
//
// Note that since we invalidate the connectivity vectors for dead nodes
// after regroup, we only need to delay long enough for each of the nodes
// to process the node down event and fire off a connectivity report.
//
#define NM_NET_CONNECTIVITY_REPORT_TIMEOUT        600  // 3600 - 3000
#define NM_NET_STATE_RECALC_TIMEOUT               2400 // 3600 - 2400 + 1200
#define NM_NET_STATE_RECALC_TIMEOUT_AFTER_REGROUP 900
#define NM_NET_STATE_FAILURE_ISOLATION_TIMEOUT    3600
#define NM_NET_STATE_FAILURE_ISOLATION_POLL       60000 // Change Default to 1 min after testing
#define NM_NET_STATE_INTERFACE_FAILURE_TIMEOUT    3600

#define NmpIsNetworkWorkerRunning(_network) \
            ((_network)->Flags & NM_FLAG_NET_WORKER_RUNNING)

#define NmpIsNetworkMadcapWorkerRunning(_network) \
            ((_network)->Flags & NM_FLAG_NET_MADCAP_WORKER_RUNNING)

#define NM_CONNECTIVITY_REPORT_RETRY_LIMIT  20    // 10 seconds

#define NM_NET_MIN_REGISTRATION_RETRY_TIMEOUT   500          // half a second
#define NM_NET_MAX_REGISTRATION_RETRY_TIMEOUT   (10*60*1000) // 10 minutes

//
// Network interface definitions
//
typedef struct _NM_INTERFACE {
    LIST_ENTRY                        Linkage;
    DWORD                             NetIndex;
    DWORD                             Flags;
    CLUSTER_NETINTERFACE_STATE        State;
    PNM_NODE                          Node;
    PNM_NETWORK                       Network;
    LPWSTR                            AdapterName;
    LPWSTR                            AdapterId;
    LPWSTR                            Address;
    ULONG                             BinaryAddress;
    LPWSTR                            ClusnetEndpoint;
    LPWSTR                            Description;
    LIST_ENTRY                        NetworkLinkage;
    LIST_ENTRY                        NodeLinkage;
} NM_INTERFACE;

#define NM_INTERFACE_SIG  '  fi'

#define NM_FLAG_IF_REGISTERED         0x00000002

#define NmpIsInterfaceRegistered(_interface) \
            ((_interface)->Flags & NM_FLAG_IF_REGISTERED)


//
// This structure is used to hook changes in the node leadership.
//
typedef struct _NM_LEADER_CHANGE_WAIT_ENTRY {
    LIST_ENTRY  Linkage;
    HANDLE      LeaderChangeEvent;
} NM_LEADER_CHANGE_WAIT_ENTRY, *PNM_LEADER_CHANGE_WAIT_ENTRY;

//
// This structure is used for asynchronous network connectivity reports.
//
typedef struct _NM_CONNECTIVITY_REPORT_CONTEXT {
    NM_LEADER_CHANGE_WAIT_ENTRY   LeaderChangeWaitEntry;
    HANDLE                        ConnectivityReportEvent;
} NM_CONNECTIVITY_REPORT_CONTEXT, *PNM_CONNECTIVITY_REPORT_CONTEXT;


// the fixup callback record stored by nm on behalf of other components to perform
//form or join fixups.
typedef struct _NM_FIXUP_CB_RECORD{
    NM_FIXUP_NOTIFYCB       pfnFixupNotifyCb;
    DWORD                   dwFixupMask;
}NM_FIXUP_CB_RECORD,*PNM_FIXUP_CB_RECORD;

//the fixup callback functions for updating in-memory structure after
//updatinbg the registry

typedef DWORD (WINAPI *NM_POST_FIXUP_CB)(VOID);


// fixup callback record used to pass argumnets to NmUpdatePerformFixups2
// update type handler
typedef struct _NM_FIXUP_CB_RECORD2{
    NM_FIXUP_NOTIFYCB       pfnFixupNotifyCb; // pointer to fn that builds up the fixup property list
    DWORD                   dwFixupMask;
    PRESUTIL_PROPERTY_ITEM  pPropertyTable;  // Property table for this key
} NM_FIXUP_CB_RECORD2,*PNM_FIXUP_CB_RECORD2;



//
// Global Data
//
extern CRITICAL_SECTION       NmpLock;
extern HANDLE                 NmpMutex;
extern NM_STATE               NmpState;
extern DWORD                  NmpActiveThreadCount;
extern HANDLE                 NmpShutdownEvent;
extern LIST_ENTRY             NmpNodeList;
extern PNM_NODE *             NmpIdArray;
extern BOOLEAN                NmpNodeCleanupOk;
extern LIST_ENTRY             NmpNetworkList;
extern LIST_ENTRY             NmpInternalNetworkList;
extern LIST_ENTRY             NmpDeletedNetworkList;
extern DWORD                  NmpNetworkCount;
extern DWORD                  NmpInternalNetworkCount;
extern DWORD                  NmpClientNetworkCount;
extern LIST_ENTRY             NmpInterfaceList;
extern LIST_ENTRY             NmpDeletedInterfaceList;
extern RESUTIL_PROPERTY_ITEM  NmpNetworkProperties[];
extern RESUTIL_PROPERTY_ITEM  NmpInterfaceProperties[];
extern CL_NODE_ID             NmpJoinerNodeId;
extern CL_NODE_ID             NmpSponsorNodeId;
extern DWORD                  NmpJoinTimer;
extern BOOLEAN                NmpJoinAbortPending;
extern DWORD                  NmpJoinSequence;
extern BOOLEAN                NmpJoinerUp;
extern BOOLEAN                NmpJoinBeginInProgress;
extern BOOLEAN                NmpJoinerOutOfSynch;
extern WCHAR                  NmpInvalidJoinerIdString[];
extern WCHAR                  NmpUnknownString[];
extern LPWSTR                 NmpClusnetEndpoint;
extern NM_STATE               NmpState;
extern CL_NODE_ID             NmpLeaderNodeId;
extern BITSET                 NmpUpNodeSet;
extern WCHAR                  NmpNullString[];
extern CLUSTER_NETWORK_ROLE   NmpDefaultNetworkRole;
extern BOOL                   NmpCleanupIfJoinAborted;
extern DWORD                  NmpAddNodeId;
extern LIST_ENTRY             NmpLeaderChangeWaitList;
extern LIST_ENTRY *           NmpIntraClusterRpcArr;
extern CRITICAL_SECTION       NmpRPCLock;
extern BOOL                   NmpLastNodeEvicted;
extern DWORD                  NmpNodeCount;
extern BOOLEAN                NmpIsNT5NodeInCluster;
extern LPWSTR                 NmpClusterInstanceId;

#if DBG

extern DWORD                  NmpRpcTimer;

#endif //DBG


//
// Synchronization macros
//
#define NmpAcquireLock()  EnterCriticalSection(&NmpLock)
#define NmpReleaseLock()  LeaveCriticalSection(&NmpLock)

#define NmpAcquireMutex() \
            {  \
                DWORD _status = WaitForSingleObject(NmpMutex, INFINITE);  \
                CL_ASSERT(_status == WAIT_OBJECT_0);  \
            }  \

#define NmpReleaseMutex()    ReleaseMutex(NmpMutex);



//
// Node Intracluster RPC record/cancellation routines.
// Useful to terminate outstanding RPCs to failed nodes.
//

#define NM_RPC_TIMEOUT 45000  // 45 secs

typedef struct _NM_INTRACLUSTER_RPC_THREAD {
    LIST_ENTRY Linkage;
    BOOLEAN    Cancelled;
    HANDLE     Thread;
    DWORD      ThreadId;
}NM_INTRACLUSTER_RPC_THREAD, *PNM_INTRACLUSTER_RPC_THREAD;

#define NmpAcquireRPCLock() EnterCriticalSection(&NmpRPCLock);
#define NmpReleaseRPCLock() LeaveCriticalSection(&NmpRPCLock); 

VOID 
NmpTerminateRpcsToNode(
    DWORD NodeId
    );

VOID
NmpRpcTimerTick(
    DWORD MsTickInterval
    );

//
// IsolationPollTimerValue read routine
//
DWORD
NmpGetIsolationPollTimerValue(
    VOID
    );

//
// Miscellaneous Routines
//
BOOLEAN
NmpLockedEnterApi(
    NM_STATE  RequiredState
    );

BOOLEAN
NmpEnterApi(
    NM_STATE  RequiredState
    );

VOID
NmpLeaveApi(
    VOID
    );

VOID
NmpLockedLeaveApi(
    VOID
    );

LPWSTR
NmpLoadString(
    IN UINT        StringId
    );

VOID
NmpDbgPrint(
    IN ULONG  LogLevel,
    IN PCHAR  FormatString,
    ...
    );

DWORD
NmpCleanseRegistry(
    IN LPCWSTR          NodeId,
    IN HLOCALXSACTION   Xaction
    );

DWORD
NmpQueryString(
    IN     HDMKEY   Key,
    IN     LPCWSTR  ValueName,
    IN     DWORD    ValueType,
    IN     LPWSTR  *StringBuffer,
    IN OUT LPDWORD  StringBufferSize,
    OUT    LPDWORD  StringSize
    );

BOOL
NmpCleanseResTypeCallback(
    IN PNM_EVICTION_CONTEXT Context,
    IN PVOID Context2,
    IN PFM_RESTYPE pResType,
    IN LPCWSTR pszResTypeName
    );

BOOL
NmpCleanseResourceCallback(
    IN PNM_EVICTION_CONTEXT Context,
    IN PVOID Context2,
    IN PFM_RESOURCE Resource,
    IN LPCWSTR ResourceName
    );

BOOL
NmpCleanseGroupCallback(
    IN PNM_EVICTION_CONTEXT Context,
    IN PVOID Context2,
    IN PFM_GROUP Group,
    IN LPCWSTR GroupName
    );

VOID
NmpIssueClusterPropertyChangeEvent(
    VOID
    );

DWORD
NmpMarshallObjectInfo(
    IN  const PRESUTIL_PROPERTY_ITEM PropertyTable,
    IN  PVOID                        ObjectInfo,
    OUT PVOID *                      PropertyList,
    OUT LPDWORD                      PropertyListSize
    );

BOOLEAN
NmpVerifyNodeConnectivity(
    PNM_NODE      Node1,
    PNM_NODE      Node2,
    PNM_NETWORK   ExcludedNetwork
    );

BOOLEAN
NmpVerifyConnectivity(
    PNM_NETWORK   ExcludedNetwork
    );

BOOLEAN
NmpVerifyJoinerConnectivity(
    IN  PNM_NODE    JoiningNode,
    OUT PNM_NODE *  UnreachableNode
    );

//
// Node Management Routines
//
DWORD
NmpInitNodes(
    VOID
    );

VOID
NmpCleanupNodes(
    VOID
    );

DWORD
NmpGetNodeDefinition(
    IN OUT PNM_NODE_INFO2   NodeInfo
    );

DWORD
NmpEnumNodeDefinitions(
    PNM_NODE_ENUM2 *  NodeEnum
    );

DWORD
NmpCreateNodeObjects(
    IN PNM_NODE_ENUM2  NodeEnum2
    );

DWORD NmpRefreshNodeObjects(
);

DWORD
NmpCreateLocalNodeObject(
    IN PNM_NODE_INFO2  NodeInfo2
    );

PNM_NODE
NmpCreateNodeObject(
    IN PNM_NODE_INFO2  NodeInfo
    );

DWORD
NmpGetNodeObjectInfo(
    IN     PNM_NODE         Node,
    IN OUT PNM_NODE_INFO2   NodeInfo
    );

VOID
NmpDeleteNodeObject(
    IN PNM_NODE   Node,
    IN BOOLEAN    IssueEvent
    );

BOOL
NmpDestroyNodeObject(
    PNM_NODE  Node
    );

DWORD
NmpEnumNodeObjects(
    PNM_NODE_ENUM2 *  NodeEnum
    );

VOID
NmpNodeFailureHandler(
    CL_NODE_ID    NodeId,
    LPVOID        NodeFailureContext
    );

DWORD
NmpSetNodeInterfacePriority(
    IN  PNM_NODE Node,
    IN  DWORD Priority,
    IN  PNM_INTERFACE TargetInterface OPTIONAL,
    IN  DWORD TargetInterfacePriority OPTIONAL
    );

DWORD
NmpEnumNodeObjects(
    PNM_NODE_ENUM2 *  NodeEnum2
    );

DWORD
NmpAddNode(
    IN LPCWSTR  NewNodeName,
    IN DWORD    NewNodeHighestVersion,
    IN DWORD    NewNodeLowestVersion,
    IN DWORD    NewNodeProductSuite,
    IN DWORD    RegistryNodeLimit
);

BOOLEAN
NmpIsAddNodeAllowed(
    IN  DWORD    NewNodeProductSuite,
    IN  DWORD    RegistryNodeLimit,
    OUT LPDWORD  EffectiveNodeLimit   OPTIONAL
    );

VOID
NmpAdviseNodeFailure(
    IN PNM_NODE  Node,
    IN DWORD     ErrorCode
    );


//
// PnP Management Routines
//
DWORD
NmpInitializePnp(
    VOID
    );

VOID
NmpShutdownPnp(
    VOID
    );

VOID
NmpCleanupPnp(
    VOID
    );

VOID
NmpWatchForPnpEvents(
    VOID
    );

DWORD
NmpEnablePnpEvents(
    VOID
    );

DWORD
NmpPostPnpNotification(
    BOOLEAN    IsPnpLockHeld
    );

DWORD
NmpConfigureNetworks(
    IN     RPC_BINDING_HANDLE     JoinSponsorBinding,
    IN     LPWSTR                 LocalNodeId,
    IN     LPWSTR                 LocalNodeName,
    IN     PNM_NETWORK_ENUM *     NetworkEnum,
    IN     PNM_INTERFACE_ENUM2 *  InterfaceEnum,
    IN     LPWSTR                 DefaultEndpoint,
    IN OUT LPDWORD                MatchedNetworkCount,
    IN OUT LPDWORD                NewNetworkCount,
    IN     BOOL                   RenameConnectoids
    );

//
// Network Management Routines
//
DWORD
NmpInitializeNetworks(
    VOID
    );

VOID
NmpCleanupNetworks(
    VOID
    );

DWORD
NmpSetNetworkRole(
    PNM_NETWORK            Network,
    CLUSTER_NETWORK_ROLE   NewRole,
    HLOCALXSACTION         Xaction,
    HDMKEY                 NetworkKey
    );

DWORD
NmpCreateNetwork(
    IN RPC_BINDING_HANDLE    JoinSponsorBinding,
    IN PNM_NETWORK_INFO      NetworkInfo,
    IN PNM_INTERFACE_INFO2   InterfaceInfo
    );

DWORD
NmpGlobalCreateNetwork(
    IN PNM_NETWORK_INFO      NetworkInfo,
    IN PNM_INTERFACE_INFO2   InterfaceInfo
    );

DWORD
NmpCreateNetworkDefinition(
    IN PNM_NETWORK_INFO     NetworkInfo,
    IN HLOCALXSACTION       Xaction
    );

DWORD
NmpSetNetworkNameDefinition(
    IN PNM_NETWORK_INFO     NetworkInfo,
    IN HLOCALXSACTION       Xaction
    );

DWORD
NmpGetNetworkDefinition(
    IN  LPWSTR            NetworkId,
    OUT PNM_NETWORK_INFO  NetworkInfo
    );

DWORD
NmpEnumNetworkDefinitions(
    OUT PNM_NETWORK_ENUM *  NetworkEnum
    );

DWORD
NmpCreateNetworkObjects(
    IN  PNM_NETWORK_ENUM    NetworkEnum
    );

PNM_NETWORK
NmpCreateNetworkObject(
    IN  PNM_NETWORK_INFO   NetworkInfo
    );

DWORD
NmpGetNetworkObjectInfo(
    IN  PNM_NETWORK        Network,
    OUT PNM_NETWORK_INFO   NetworkInfo
    );

VOID
NmpDeleteNetworkObject(
    IN PNM_NETWORK  Network,
    IN BOOLEAN      IssueEvent
    );

BOOL
NmpDestroyNetworkObject(
    PNM_NETWORK  Network
    );

DWORD
NmpEnumNetworkObjects(
    OUT PNM_NETWORK_ENUM *   NetworkEnum
    );

DWORD
NmpRegisterNetwork(
    IN PNM_NETWORK   Network,
    IN BOOLEAN       RetryOnFailure
);

VOID
NmpDeregisterNetwork(
    IN  PNM_NETWORK   Network
    );

VOID
NmpInsertInternalNetwork(
    PNM_NETWORK   Network
    );

DWORD
NmpValidateNetworkRoleChange(
    PNM_NETWORK            Network,
    CLUSTER_NETWORK_ROLE   NewRole
    );

DWORD
NmpNetworkValidateCommonProperties(
    IN  PNM_NETWORK               Network,
    IN  PVOID                     InBuffer,
    IN  DWORD                     InBufferSize,
    OUT PNM_NETWORK_INFO          NetworkInfo  OPTIONAL
    );

DWORD
NmpSetNetworkName(
    IN PNM_NETWORK_INFO     NetworkInfo
    );

DWORD
NmpGlobalSetNetworkName(
    IN PNM_NETWORK_INFO NetworkInfo
    );

VOID
NmpRecomputeNT5NetworkAndInterfaceStates(
    VOID
    );

BOOLEAN
NmpComputeNetworkAndInterfaceStates(
    PNM_NETWORK               Network,
    BOOLEAN                   IsolateFailure,
    CLUSTER_NETWORK_STATE *   NewNetworkState
    );

VOID
NmpStartNetworkConnectivityReportTimer(
    PNM_NETWORK Network
    );

VOID
NmpStartNetworkStateRecalcTimer(
    PNM_NETWORK  Network,
    DWORD        Timeout
    );

VOID
NmpStartNetworkFailureIsolationTimer(
    PNM_NETWORK Network,
    DWORD       Timeout
    );

VOID
NmpStartNetworkRegistrationRetryTimer(
    PNM_NETWORK Network
    );

VOID
NmpScheduleNetworkConnectivityReport(
    PNM_NETWORK   Network
    );

VOID
NmpScheduleNetworkStateRecalc(
    PNM_NETWORK   Network
    );

VOID
NmpScheduleNetworkRegistration(
    PNM_NETWORK   Network
    );

DWORD
NmpScheduleConnectivityReportWorker(
    VOID
    );

DWORD
NmpScheduleNetworkWorker(
    PNM_NETWORK   Network
    );

VOID
NmpConnectivityReportWorker(
    IN PCLRTL_WORK_ITEM   WorkItem,
    IN DWORD              Status,
    IN DWORD              BytesTransferred,
    IN ULONG_PTR          IoContext
    );

VOID
NmpNetworkWorker(
    IN PCLRTL_WORK_ITEM   WorkItem,
    IN DWORD              Status,
    IN DWORD              BytesTransferred,
    IN ULONG_PTR          IoContext
    );

VOID
NmpNetworkTimerTick(
    IN DWORD  MsTickInterval
    );

VOID
NmpSetNetworkAndInterfaceStates(
    IN PNM_NETWORK                 Network,
    IN CLUSTER_NETWORK_STATE       NewNetworkState,
    IN PNM_STATE_ENTRY             InterfaceStateVector,
    IN DWORD                       VectorSize
    );

VOID
NmpUpdateNetworkConnectivityForDownNode(
    PNM_NODE  Node
    );

DWORD
NmpEnumNetworkObjectStates(
    OUT PNM_NETWORK_STATE_ENUM *  NetworkStateEnum
    );

VOID
NmpFreeNetworkStateEnum(
    PNM_NETWORK_STATE_ENUM   NetworkStateEnum
    );

DWORD
NmpReportNetworkConnectivity(
    IN PNM_NETWORK    Network
    );

DWORD
NmpGlobalSetNetworkAndInterfaceStates(
    PNM_NETWORK             Network,
    CLUSTER_NETWORK_STATE   NewNetworkState
    );

VOID
NmpReferenceNetwork(
    PNM_NETWORK  Network
    );

VOID
NmpDereferenceNetwork(
    PNM_NETWORK  Network
    );

PNM_NETWORK
NmpReferenceNetworkByAddress(
    LPWSTR  NetworkAddress
    );

DWORD
NmpEnumInternalNetworks(
    OUT LPDWORD         NetworkCount,
    OUT PNM_NETWORK *   NetworkList[]
    );

DWORD
NmpSetNetworkPriorityOrder(
    IN DWORD           NetworkCount,
    IN PNM_NETWORK *   NetworkList,
    IN HLOCALXSACTION  Xaction
    );

DWORD
NmpGetNetworkInterfaceFailureTimerValue(
    IN LPCWSTR  NetworkId
    );

BOOLEAN
NmpCheckForNetwork(
    VOID
    );

//
// Network Multicast Management Routines
//
DWORD
NmpCleanupMulticast(
    VOID
    );

DWORD
NmpRefreshMulticastConfiguration(
    IN PNM_NETWORK  Network
    );

DWORD
NmpRefreshClusterMulticastConfiguration(
    VOID
    );

DWORD
NmpMulticastRegenerateKey(
    IN PNM_NETWORK        Network
    );

DWORD
NmpMulticastValidatePrivateProperties(
    IN  PNM_NETWORK Network,
    IN  HDMKEY      RegistryKey,
    IN  PVOID       InBuffer,
    IN  DWORD       InBufferSize
    );

VOID
NmpScheduleMulticastAddressRenewal(
    PNM_NETWORK   Network
    );

VOID
NmpScheduleMulticastAddressRelease(
    PNM_NETWORK   Network
    );

VOID
NmpFreeMulticastAddressReleaseList(
    IN     PNM_NETWORK       Network
    );

DWORD
NmpMulticastManualConfigChange(
    IN     PNM_NETWORK          Network,
    IN     HDMKEY               NetworkKey,
    IN     HDMKEY               NetworkParametersKey,
    IN     PVOID                InBuffer,
    IN     DWORD                InBufferSize,
       OUT BOOLEAN            * SetProperties
    );

DWORD
NmpUpdateSetNetworkMulticastConfiguration(
    IN    BOOL                          SourceNode,
    IN    LPWSTR                        NetworkId,
    IN    PVOID                         UpdateBuffer,
    IN    PVOID                         PropBuffer,
    IN    LPDWORD                       PropBufferSize
    );

DWORD
NmpStartMulticast(
    IN PNM_NETWORK         Network         OPTIONAL
    );

DWORD
NmpStopMulticast(
    IN PNM_NETWORK   Network           OPTIONAL
    );

VOID
NmpMulticastInitialize(
    VOID
    );

BOOLEAN
NmpIsClusterMulticastReady(
    IN BOOLEAN       CheckNodeCount
    );

VOID
NmpMulticastProcessClusterVersionChange(
    VOID
    );

//
// Interface Management Routines
//
DWORD
NmpInitializeInterfaces(
    VOID
    );

VOID
NmpCleanupInterfaces(
    VOID
    );

DWORD
NmpCreateInterface(
    IN RPC_BINDING_HANDLE    JoinSponsorBinding,
    IN PNM_INTERFACE_INFO2   InterfaceInfo
    );

DWORD
NmpGlobalCreateInterface(
    IN PNM_INTERFACE_INFO2  InterfaceInfo
    );

DWORD
NmpSetInterfaceInfo(
    IN RPC_BINDING_HANDLE    JoinSponsorBinding,
    IN PNM_INTERFACE_INFO2   InterfaceInfo
    );

DWORD
NmpLocalSetInterfaceInfo(
    IN  PNM_INTERFACE         Interface,
    IN  PNM_INTERFACE_INFO2   InterfaceInfo,
    IN  HLOCALXSACTION        Xaction
    );

DWORD
NmpGlobalSetInterfaceInfo(
    IN PNM_INTERFACE_INFO2  InterfaceInfo
    );

DWORD
NmpDeleteInterface(
    IN     RPC_BINDING_HANDLE   JoinSponsorBinding,
    IN     LPWSTR               InterfaceId,
    IN     LPWSTR               NetworkId,
    IN OUT PBOOLEAN             NetworkDeleted
    );

DWORD
NmpGlobalDeleteInterface(
    IN     LPWSTR    InterfaceId,
    IN OUT PBOOLEAN  NetworkDeleted
    );

DWORD
NmpInterfaceValidateCommonProperties(
    IN PNM_INTERFACE         Interface,
    IN PVOID                 InBuffer,
    IN DWORD                 InBufferSize,
    OUT PNM_INTERFACE_INFO2  InterfaceInfo  OPTIONAL
    );

DWORD
NmpCreateInterfaceDefinition(
    IN PNM_INTERFACE_INFO2  InterfaceInfo,
    IN HLOCALXSACTION       Xaction
    );

DWORD
NmpGetInterfaceDefinition(
    IN  LPWSTR                InterfaceId,
    OUT PNM_INTERFACE_INFO2   InterfaceInfo
    );

DWORD
NmpSetInterfaceDefinition(
    IN PNM_INTERFACE_INFO2  InterfaceInfo,
    IN HLOCALXSACTION       Xaction
    );

DWORD
NmpEnumInterfaceDefinitions(
    OUT PNM_INTERFACE_ENUM2 *  InterfaceEnum
    );

DWORD
NmpCreateInterfaceObjects(
    IN  PNM_INTERFACE_ENUM2    InterfaceEnum
    );

PNM_INTERFACE
NmpCreateInterfaceObject(
    IN PNM_INTERFACE_INFO2   InterfaceInfo,
    IN BOOLEAN               RetryOnFailure

    );

DWORD
NmpGetInterfaceObjectInfo1(
    IN     PNM_INTERFACE        Interface,
    IN OUT PNM_INTERFACE_INFO   InterfaceInfo1
    );

DWORD
NmpGetInterfaceObjectInfo(
    IN     PNM_INTERFACE        Interface,
    IN OUT PNM_INTERFACE_INFO2  InterfaceInfo
    );

VOID
NmpDeleteInterfaceObject(
    IN PNM_INTERFACE  Interface,
    IN BOOLEAN        IssueEvent
    );

BOOL
NmpDestroyInterfaceObject(
    PNM_INTERFACE  Interface
    );

DWORD
NmpEnumInterfaceObjects1(
    OUT PNM_INTERFACE_ENUM *  InterfaceEnum1
    );

DWORD
NmpEnumInterfaceObjects(
    OUT PNM_INTERFACE_ENUM2 *  InterfaceEnum
    );

DWORD
NmpRegisterInterface(
    IN PNM_INTERFACE  Interface,
    IN BOOLEAN        RetryOnFailure
    );

VOID
NmpDeregisterInterface(
    IN  PNM_INTERFACE   Interface
    );

DWORD
NmpPrepareToCreateInterface(
    IN  PNM_INTERFACE_INFO2   InterfaceInfo,
    OUT PNM_NETWORK *         Network,
    OUT PNM_NODE *            Node
    );

PNM_INTERFACE
NmpGetInterfaceForNodeAndNetworkById(
    IN  CL_NODE_ID     NodeId,
    IN  CL_NETWORK_ID  NetworkId
    );

VOID
NmpFreeInterfaceStateEnum(
    PNM_INTERFACE_STATE_ENUM   InterfaceStateEnum
    );

DWORD
NmpEnumInterfaceObjectStates(
    OUT PNM_INTERFACE_STATE_ENUM *  InterfaceStateEnum
    );

VOID
NmpProcessLocalInterfaceStateEvent(
    IN PNM_INTERFACE                Interface,
    IN CLUSTER_NETINTERFACE_STATE   NewState
    );

DWORD
NmpReportInterfaceConnectivity(
    IN RPC_BINDING_HANDLE       RpcBinding,
    IN LPWSTR                   InterfaceId,
    IN PNM_CONNECTIVITY_VECTOR  ConnectivityVector,
    IN LPWSTR                   NetworkId
    );

VOID
NmpProcessInterfaceConnectivityReport(
    IN PNM_INTERFACE               SourceInterface,
    IN PNM_CONNECTIVITY_VECTOR     ConnectivityVector
    );

DWORD
NmpInterfaceCheckThread(
    LPDWORD   Context
    );

VOID
NmpReportLocalInterfaceStateEvent(
    IN CL_NODE_ID     NodeId,
    IN CL_NETWORK_ID  NetworkId,
    IN DWORD          NewState
    );

DWORD
NmpConvertPropertyListToInterfaceInfo(
    IN PVOID              InterfacePropertyList,
    IN DWORD              InterfacePropertyListSize,
    PNM_INTERFACE_INFO2   InterfaceInfo
    );

VOID
NmpSetInterfaceConnectivityData(
    PNM_NETWORK                  Network,
    DWORD                        InterfaceNetIndex,
    CLUSTER_NETINTERFACE_STATE   State
    );

DWORD
NmpTestInterfaceConnectivity(
    PNM_INTERFACE  Interface1,
    PBOOLEAN       Interface1HasConnectivity,
    PNM_INTERFACE  Interface2,
    PBOOLEAN       Interfacet2HasConnectivity
    );

DWORD
NmpBuildInterfaceOnlineAddressEnum(
    PNM_INTERFACE       Interface,
    PNM_ADDRESS_ENUM *  OnlineAddressEnum
    );

DWORD
NmpBuildInterfacePingAddressEnum(
    PNM_INTERFACE       Interface,
    PNM_ADDRESS_ENUM    OnlineAddressEnum,
    PNM_ADDRESS_ENUM *  PingAddressEnum
    );

BOOLEAN
NmpVerifyLocalInterfaceConnected(
    IN  PNM_INTERFACE   Interface
    );

//
// Membership Management Routines
//

DWORD
NmpMembershipInit(
    VOID
    );

VOID
NmpMembershipShutdown(
    VOID
    );

VOID
NmpMarkNodeUp(
    CL_NODE_ID  NodeId
    );

VOID
NmpNodeUpEventHandler(
    IN PNM_NODE   Node
    );

VOID
NmpNodeDownEventHandler(
    IN PNM_NODE   Node
    );

DWORD
NmpMultiNodeDownEventHandler(
    IN BITSET DownedNodeSet
    );

DWORD
NmpNodeChange(
    DWORD NodeId,
    NODESTATUS newstatus
    );

BOOL
NmpCheckQuorumEventHandler(
    VOID
    );

VOID
NmpHoldIoEventHandler(
    VOID
    );

VOID
NmpResumeIoEventHandler(
    VOID
    );

VOID
NmpHaltEventHandler(
    IN DWORD HaltCode
    );

VOID
NmpJoinAbort(
    DWORD      AbortStatus,
    PNM_NODE   JoinerNode
    );


//
// Routines for joining nodes to a cluster
//
DWORD
NmpCreateJoinerRpcBindings(
    IN PNM_NODE       JoinerNode,
    IN PNM_INTERFACE  JoinerInterface
    );

//
// Gum update message types.
//
// The first entries in this list are auto-marshalled through Gum...Ex.
// Any updates that are not auto-marshalled must come after NmUpdateMaxAuto
//
typedef enum {
    NmUpdateCreateNode = 0,
    NmUpdatePauseNode,
    NmUpdateResumeNode,
    NmUpdateEvictNode,
    NmUpdateCreateNetwork,
    NmUpdateSetNetworkName,
    NmUpdateSetNetworkPriorityOrder,
    NmUpdateSetNetworkCommonProperties,
    NmUpdateCreateInterface,
    NmUpdateSetInterfaceInfo,
    NmUpdateSetInterfaceCommonProperties,
    NmUpdateDeleteInterface,
    NmUpdateJoinBegin,
    NmUpdateJoinAbort,
    //
    // Version 2 (NT 5.0) extensions that are understood by
    // NT4 SP4 4.
    //
    NmUpdateJoinBegin2,
    NmUpdateSetNetworkAndInterfaceStates,
    NmUpdatePerformFixups,
    NmUpdatePerformFixups2,
    //
    // Version 2 (NT 5.0) extensions that are not understood
    // by NT4 SP4. These may not be issued in a mixed NT4/NT5 cluster.
    //
    NmUpdateAddNode,
    NmUpdateExtendedNodeState,
    //
    // NT 5.1 extensions that are not understood by NT5 and
    // earlier. NT5 nodes will ignore these updates without
    // error.
    //
    NmUpdateSetNetworkMulticastConfiguration,
    //
    // Max handled automatically by GUM
    //
    NmUpdateMaxAuto = 0x10000,

    NmUpdateJoinComplete,

    NmUpdateMaximum
} NM_GUM_MESSAGE_TYPES;

#pragma warning( disable: 4200 )
typedef struct _NM_JOIN_UPDATE {
    DWORD JoinSequence;
    DWORD IsPaused;
    WCHAR NodeId[0];
} NM_JOIN_UPDATE, *PNM_JOIN_UPDATE;
#pragma warning( default: 4200 )

DWORD
NmpGumUpdateHandler(
    IN DWORD Context,
    IN BOOL SourceNode,
    IN DWORD BufferLength,
    IN PVOID Buffer
    );

DWORD
NmpUpdateAddNode(
    IN BOOL       SourceNode,
    IN LPDWORD    NewNodeId,
    IN LPCWSTR    NewNodeName,
    IN LPDWORD    NewNodeHighestVersion,
    IN LPDWORD    NewNodeLowestVersion,
    IN LPDWORD    NewNodeProductSuite
    );

DWORD
NmpUpdateCreateNode(
    IN BOOL SourceNode,
    IN LPDWORD NodeId
    );

DWORD
NmpUpdatePauseNode(
    IN BOOL SourceNode,
    IN LPWSTR NodeName
    );

DWORD
NmpUpdateResumeNode(
    IN BOOL SourceNode,
    IN LPWSTR NodeName
    );

DWORD
NmpUpdateEvictNode(
    IN BOOL SourceNode,
    IN LPWSTR NodeName
    );

DWORD
NmpUpdateCreateNetwork(
    IN BOOL     IsSourceNode,
    IN PVOID    NetworkPropertyList,
    IN LPDWORD  NetworkPropertyListSize,
    IN PVOID    InterfacePropertyList,
    IN LPDWORD  InterfacePropertyListSize
    );

DWORD
NmpUpdateSetNetworkName(
    IN BOOL     IsSourceNode,
    IN LPWSTR   NetworkId,
    IN LPWSTR   Name
    );

DWORD
NmpUpdateSetNetworkPriorityOrder(
    IN BOOL      IsSourceNode,
    IN LPCWSTR   NetworkIdList
    );

DWORD
NmpUpdateSetNetworkCommonProperties(
    IN BOOL     IsSourceNode,
    IN LPWSTR   NetworkId,
    IN UCHAR *  PropertyList,
    IN LPDWORD  PropertyListLength
    );

DWORD
NmpUpdateCreateInterface(
    IN BOOL     IsSourceNode,
    IN PVOID    InterfacePropertyList,
    IN LPDWORD  InterfacePropertyListSize
    );

DWORD
NmpUpdateSetInterfaceInfo(
    IN BOOL     SourceNode,
    IN PVOID    InterfacePropertyList,
    IN LPDWORD  InterfacePropertyListSize
    );

DWORD
NmpUpdateSetInterfaceCommonProperties(
    IN BOOL     IsSourceNode,
    IN LPWSTR   InterfaceId,
    IN UCHAR *  PropertyList,
    IN LPDWORD  PropertyListLength
    );

DWORD
NmpUpdateDeleteInterface(
    IN BOOL     IsSourceNode,
    IN LPWSTR   InterfaceId
    );

DWORD
NmpUpdateJoinBegin(
    IN  BOOL    SourceNode,
    IN  LPWSTR  JoinerNodeId,
    IN  LPWSTR  JoinerNodeName,
    IN  LPWSTR  SponsorNodeId
    );

DWORD
NmpUpdateJoinComplete(
    IN PNM_JOIN_UPDATE  JoinUpdate
    );

DWORD
NmpUpdateJoinAbort(
    IN  BOOL    SourceNode,
    IN  LPDWORD JoinSequence,
    IN  LPWSTR  JoinerNodeId
    );

DWORD
NmpUpdateJoinBegin2(
    IN  BOOL      SourceNode,
    IN  LPWSTR    JoinerNodeId,
    IN  LPWSTR    JoinerNodeName,
    IN  LPWSTR    SponsorNodeId,
    IN  LPDWORD   JoinerHighestVersion,
    IN  LPDWORD   JoinerLowestVersion
    );

DWORD
NmpUpdateSetNetworkAndInterfaceStates(
    IN BOOL                        IsSourceNode,
    IN LPWSTR                      NetworkId,
    IN CLUSTER_NETWORK_STATE *     NewNetworkState,
    IN PNM_STATE_ENTRY             InterfaceStateVector,
    IN LPDWORD                     InterfaceStateVectorSize
    );



DWORD
NmpDoInterfacePing(
    IN  PNM_INTERFACE        Interface,
    IN  PNM_ADDRESS_ENUM     PingAddressEnum,
    OUT BOOLEAN *            PingSucceeded
    );

//versioning functions
VOID
NmpResetClusterVersion(
    BOOL ProcessChanges
    );

DWORD NmpValidateNodeVersion(
    IN LPCWSTR  NodeId,
    IN DWORD    dwHighestVersion,
    IN DWORD    dwLowestVersion
    );

DWORD NmpFormFixupNodeVersion(
    IN LPCWSTR      NodeId,
    IN DWORD        dwHighestVersion,
    IN DWORD        dwLowestVersion
    );

DWORD NmpJoinFixupNodeVersion(
    IN HLOCALXSACTION   hXsaction,
    IN LPCWSTR          NodeId,
    IN DWORD            dwHighestVersion,
    IN DWORD            dwLowestVersion
    );

DWORD NmpIsNodeVersionAllowed(
    IN DWORD    dwExcludeNodeId,
    IN DWORD    NodeHighestVersion,
    IN DWORD    NodeLowestVersion,
    IN BOOL     bJoin
    );

DWORD NmpCalcClusterVersion(
    IN  DWORD       dwExcludeNodeId,
    OUT LPDWORD     pdwClusterHighestVersion,
    OUT LPDWORD     pdwClusterLowestVersion
    );


DWORD NmpUpdatePerformFixups(
    IN BOOL     IsSourceNode,
    IN PVOID    PropertyList,
    IN LPDWORD  PropertyListSize
    );

DWORD NmpUpdatePerformFixups2(
    IN BOOL     IsSourceNode,
    IN PVOID    PropertyList,
    IN LPDWORD  PropertyListSize,
    IN LPDWORD  lpdwFixupNum,
    IN PVOID    lpKeyName,
    IN PVOID    pPropertyBuffer
    );

DWORD NmpUpdateExtendedNodeState(
    IN BOOL SourceNode,
    IN LPWSTR NodeId,
    IN CLUSTER_NODE_STATE* ExtendedState
    );

VOID
NmpProcessClusterVersionChange(
    VOID
    );

VOID
NmpResetClusterNodeLimit(
    );

// Fixup routine for updating the node version info, used by nmperformfixups

DWORD
NmpBuildVersionInfo(
    IN  DWORD    dwFixUpType,
    OUT PVOID  * ppPropertyList,
    OUT LPDWORD  pdwPropertyListSize,
    OUT LPWSTR * lpszKeyName
    );

//
// connectoid advise sink functions
//

HRESULT
NmpInitializeConnectoidAdviseSink(
    VOID
    );

//
// Routines that must be supplied by users of the ClNet package.
//
VOID
ClNetPrint(
    IN ULONG LogLevel,
    IN PCHAR FormatString,
    ...
    );

VOID
ClNetLogEvent(
    IN DWORD    LogLevel,
    IN DWORD    MessageId
    );

VOID
ClNetLogEvent1(
    IN DWORD    LogLevel,
    IN DWORD    MessageId,
    IN LPCWSTR  Arg1
    );

VOID
ClNetLogEvent2(
    IN DWORD    LogLevel,
    IN DWORD    MessageId,
    IN LPCWSTR  Arg1,
    IN LPCWSTR  Arg2
    );

VOID
ClNetLogEvent3(
    IN DWORD    LogLevel,
    IN DWORD    MessageId,
    IN LPCWSTR  Arg1,
    IN LPCWSTR  Arg2,
    IN LPCWSTR  Arg3
    );

//
// Shared key management routines.
//
DWORD
NmpGetClusterKey(
    OUT    PVOID    KeyBuffer,
    IN OUT DWORD  * KeyBufferLength
    );

DWORD
NmpRegenerateClusterKey(
    VOID
    );

VOID
NmpFreeClusterKey(
    VOID
    );

#endif  // _NMP_INCLUDED



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\nm\nmfixup.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    node.c

Abstract:

    Fix up Routines for Upgrade and Rolling Upgrades

Author:

    Sunita Shrivastava(sunitas) 18-Mar-1998


Revision History:

--*/
/****
@doc    EXTERNAL INTERFACES CLUSSVC DM
****/

#define UNICODE 1

#include "nmp.h"

//
// Cluster registry API function pointers.
//
CLUSTER_REG_APIS
NmpFixupRegApis = {
    (PFNCLRTLCREATEKEY) DmRtlCreateKey,
    (PFNCLRTLOPENKEY) DmRtlOpenKey,
    (PFNCLRTLCLOSEKEY) DmCloseKey,
    (PFNCLRTLSETVALUE) DmSetValue,
    (PFNCLRTLQUERYVALUE) DmQueryValue,
    (PFNCLRTLENUMVALUE) DmEnumValue,
    (PFNCLRTLDELETEVALUE) DmDeleteValue,
    (PFNCLRTLLOCALCREATEKEY) DmRtlLocalCreateKey,
    (PFNCLRTLLOCALSETVALUE) DmLocalSetValue,
    (PFNCLRTLLOCALDELETEVALUE) DmLocalDeleteValue,
};

//
// Data
//
RESUTIL_PROPERTY_ITEM
NmJoinFixupSDProperties[]=
{
    {
        CLUSREG_NAME_CLUS_SD, NULL, CLUSPROP_FORMAT_BINARY,
        0, 0, 0,
        0,
        0
    },
    {
        0
    }
};

// Fixup Table for WINS
RESUTIL_PROPERTY_ITEM
NmJoinFixupWINSProperties[]=
{
            {
                CLUSREG_NAME_RESTYPE_IS_ALIVE, CLUS_RESTYPE_NAME_WINS , CLUSPROP_FORMAT_DWORD,
                0,CLUSTER_RESTYPE_MINIMUM_IS_ALIVE ,CLUSTER_RESTYPE_MAXIMUM_IS_ALIVE ,
                0,
                0
            },

            {
                CLUSREG_NAME_RESTYPE_LOOKS_ALIVE,CLUS_RESTYPE_NAME_WINS ,CLUSPROP_FORMAT_DWORD,
                0,CLUSTER_RESTYPE_MINIMUM_LOOKS_ALIVE ,CLUSTER_RESTYPE_MAXIMUM_LOOKS_ALIVE ,
                0,
                sizeof(DWORD)
            },

            {
                CLUSREG_NAME_RESTYPE_DLL_NAME,CLUS_RESTYPE_NAME_WINS ,CLUSPROP_FORMAT_SZ,
                0,0,0,
                0,
                2*sizeof(DWORD)
            },

            {
                CLUSREG_NAME_RESTYPE_NAME,CLUS_RESTYPE_NAME_WINS ,CLUSPROP_FORMAT_SZ,
                0,0,0,
                0,
                2*sizeof(DWORD)+sizeof(LPWSTR*)
            },

            {
                CLUSREG_NAME_RESTYPE_ADMIN_EXTENSIONS,CLUS_RESTYPE_NAME_WINS,CLUSPROP_FORMAT_MULTI_SZ,
                0,0,0,
                0,
                2*sizeof(DWORD)+2*sizeof(LPWSTR*)
            },

            {
                0
            }
}; //NmJoinFixupWINSProperties

//Fixup Table for DHCP
RESUTIL_PROPERTY_ITEM
NmJoinFixupDHCPProperties[]=
{
            {
                CLUSREG_NAME_RESTYPE_IS_ALIVE, CLUS_RESTYPE_NAME_DHCP , CLUSPROP_FORMAT_DWORD,
                0,CLUSTER_RESTYPE_MINIMUM_IS_ALIVE ,CLUSTER_RESTYPE_MAXIMUM_IS_ALIVE ,
                0,
                0
            },

            {
                CLUSREG_NAME_RESTYPE_LOOKS_ALIVE,CLUS_RESTYPE_NAME_DHCP ,CLUSPROP_FORMAT_DWORD,
                0,CLUSTER_RESTYPE_MINIMUM_LOOKS_ALIVE ,CLUSTER_RESTYPE_MAXIMUM_LOOKS_ALIVE ,
                0,
                sizeof(DWORD)
            },

            {
                CLUSREG_NAME_RESTYPE_DLL_NAME,CLUS_RESTYPE_NAME_DHCP ,CLUSPROP_FORMAT_SZ,
                0,0,0,
                0,
                2*sizeof(DWORD)
            },

            {
                CLUSREG_NAME_RESTYPE_NAME,CLUS_RESTYPE_NAME_DHCP ,CLUSPROP_FORMAT_SZ,
                0,0,0,
                0,
                2*sizeof(DWORD)+sizeof(LPWSTR*)
            },

            {
                CLUSREG_NAME_RESTYPE_ADMIN_EXTENSIONS,CLUS_RESTYPE_NAME_DHCP,CLUSPROP_FORMAT_MULTI_SZ,
                0,0,0,
                0,
                2*sizeof(DWORD)+2*sizeof(LPWSTR*)
            },

            {
                0
            }
};//NmJoinFixupDHCPProperties


RESUTIL_PROPERTY_ITEM
NmJoinFixupNewMSMQProperties[]=
{
            {
                CLUSREG_NAME_RESTYPE_IS_ALIVE, CLUS_RESTYPE_NAME_NEW_MSMQ,CLUSPROP_FORMAT_DWORD,
                0,CLUSTER_RESTYPE_MINIMUM_IS_ALIVE ,CLUSTER_RESTYPE_MAXIMUM_IS_ALIVE ,
                0,
                0
            },

            {
                CLUSREG_NAME_RESTYPE_LOOKS_ALIVE,CLUS_RESTYPE_NAME_NEW_MSMQ,CLUSPROP_FORMAT_DWORD,
                0,CLUSTER_RESTYPE_MINIMUM_LOOKS_ALIVE ,CLUSTER_RESTYPE_MAXIMUM_LOOKS_ALIVE ,
                0,
                sizeof(DWORD)
            },

            {
                CLUSREG_NAME_RESTYPE_DLL_NAME,CLUS_RESTYPE_NAME_NEW_MSMQ,CLUSPROP_FORMAT_SZ,
                0,0,0,
                0,
                2*sizeof(DWORD)
            },

            {
                CLUSREG_NAME_RESTYPE_NAME,CLUS_RESTYPE_NAME_NEW_MSMQ,CLUSPROP_FORMAT_SZ,
                0,0,0,
                0,
                2*sizeof(DWORD)+sizeof(LPWSTR*)
            },

            {
                0
            }
};//NmJoinFixupNewMSMQProperties


//Fixup Table for changing thr dl name of MSDTC resource type
RESUTIL_PROPERTY_ITEM
NmJoinFixupMSDTCProperties[]=
{
            {
                CLUSREG_NAME_RESTYPE_DLL_NAME,CLUS_RESTYPE_NAME_MSDTC,CLUSPROP_FORMAT_SZ,
                0,0,0,
                0,
                0
            },

            {
                0
            }

};//NmJoinFixupMSDTCProperties


//Fixup table for node version info

RESUTIL_PROPERTY_ITEM
NmFixupVersionInfo[]=
{
            {
                CLUSREG_NAME_NODE_MAJOR_VERSION,NULL,CLUSPROP_FORMAT_DWORD,
                0,0,((DWORD)-1),
                0,
                0
            },

            {
                CLUSREG_NAME_NODE_MINOR_VERSION,NULL,CLUSPROP_FORMAT_DWORD,
                0,0,((DWORD)-1),
                0,
                sizeof(DWORD)
            },

            {
                CLUSREG_NAME_NODE_BUILD_NUMBER,NULL,CLUSPROP_FORMAT_DWORD,
                0,0,((DWORD)-1),
                0,
                2*sizeof(DWORD)
            },

            {
                CLUSREG_NAME_NODE_CSDVERSION,NULL,CLUSPROP_FORMAT_SZ,
                0,0,0,
                0,
                3*sizeof(DWORD)
            },

            {
                CLUSREG_NAME_NODE_PRODUCT_SUITE,NULL,CLUSPROP_FORMAT_DWORD,
                0,0,((DWORD)-1),
                0,
                3*sizeof(DWORD) + sizeof(LPWSTR*)
            },

            {
                0
            }

}; //NmFixupVersionInfo

RESUTIL_PROPERTY_ITEM
NmFixupClusterProperties[] =
    {
        {
            CLUSREG_NAME_ADMIN_EXT, NULL, CLUSPROP_FORMAT_MULTI_SZ,
            0, 0, 0,
            0,
            0
        },
        {
            0
        }
    };







//Used by NmUpdatePerformFixups update
RESUTIL_PROPERTY_ITEM
NmpJoinFixupProperties[] =
    {
        {
            CLUSREG_NAME_CLUS_SD, NULL, CLUSPROP_FORMAT_BINARY,
            0, 0, 0,
            0,
            0
        },
        {
            0
        }
    };


RESUTIL_PROPERTY_ITEM
NmpFormFixupProperties[] =
    {
        {
            CLUSREG_NAME_CLUS_SD, NULL, CLUSPROP_FORMAT_BINARY,
            0, 0, 0,
            0,
            0
        },
        {
            0
        }
    };

NM_FIXUP_CB_RECORD FixupTable[]=
{
   { ApiFixupNotifyCb, NM_FORM_FIXUP|NM_JOIN_FIXUP}
};

// Fixup Table used for NmUpdatePerformFixups2 update type
NM_FIXUP_CB_RECORD2 FixupTable2[]=
{
   { ApiFixupNotifyCb, NM_FORM_FIXUP|NM_JOIN_FIXUP, NmpJoinFixupProperties},
   { FmBuildWINS, NM_FORM_FIXUP|NM_JOIN_FIXUP, NmJoinFixupWINSProperties,},
   { FmBuildDHCP, NM_FORM_FIXUP|NM_JOIN_FIXUP, NmJoinFixupDHCPProperties},
   { FmBuildNewMSMQ, NM_FORM_FIXUP|NM_JOIN_FIXUP, NmJoinFixupNewMSMQProperties},
   { FmBuildMSDTC, NM_FORM_FIXUP|NM_JOIN_FIXUP, NmJoinFixupMSDTCProperties},
   { NmpBuildVersionInfo, NM_JOIN_FIXUP|NM_FORM_FIXUP, NmFixupVersionInfo},
   { FmBuildClusterProp, NM_FORM_FIXUP|NM_JOIN_FIXUP,NmFixupClusterProperties}
};


NM_POST_FIXUP_CB PostFixupCbTable[]=
{
    NULL,
    FmFixupNotifyCb,
    FmFixupNotifyCb,
    FmFixupNotifyCb,
    FmFixupNotifyCb,
    NmFixupNotifyCb,
    NULL
};




/****
@func       DWORD | NmPerformFixups| This is called when a cluster is being
            formed/or joining. Issues NmUpdateperforfixups GUM update
            for registry fixups of SECURITY_DESCRIPTOR  when NT5 node joins
            NT4 node.Also issues NmUpdateperforfixups2 GUM update for
            WINS and DHCP fixups when NT5 joins NT4. This update type can
            be extended in future to do more fixups for postNT5 and NT5 scenario.
            If later it is guaranteed that there is no NT4 node in cluster,
            NmUpdatePerformFixups update type won't be needed and hence can
            be taken out.

@comm       The first time the cluster service forms a cluster after an
            upgrade, it might have registry fixups it wants to make to the
            existing cluster registry.  Also, when an uplevel node
            joins a downlevel node, join fixups can be performed.
            Note that this is called on every form/join

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f NmpUpdatePerformFixups> <f NmpUpdatePerformFixups2>
****/

DWORD NmPerformFixups(
    IN DWORD dwFixupType)
{

    DWORD               dwCount = sizeof(FixupTable)/sizeof(NM_FIXUP_CB_RECORD);
    DWORD               dwStatus = ERROR_SUCCESS;
    PNM_FIXUP_CB_RECORD pFixupCbRec;
    PNM_FIXUP_CB_RECORD2 pFixupCbRec2;
    PVOID               pPropertyList = NULL;
    DWORD               dwPropertyListSize;
    DWORD               i,j;
    DWORD               dwSize;
    DWORD               Required;
    LPWSTR              szKeyName=NULL;
    LPBYTE              pBuffer=NULL;
    PRESUTIL_PROPERTY_ITEM pPropertyItem;

    ClRtlLogPrint(LOG_NOISE,"[NM] NmPerformFixups Entry, dwFixupType=%1!u!\r\n",
        dwFixupType);

    // using old gum update handler - this is needed to maintain compataility
    // with NT4, can be discarded later. See comments above.
    //

    for (i=0; i < dwCount ; i++)
    {

        pFixupCbRec = &FixupTable[i];

        //if this fixup doesnt need to be applied, skip it
        if (!(pFixupCbRec->dwFixupMask & dwFixupType))
            continue;

        dwStatus = (pFixupCbRec->pfnFixupNotifyCb)(dwFixupType, &pPropertyList,
                                         &dwPropertyListSize,&szKeyName);

        if (dwStatus != ERROR_SUCCESS)
        {
            goto FnExit;
        }
        if (pPropertyList && dwPropertyListSize)
        {
            //
            // Issue a global update
            //
            dwStatus = GumSendUpdateEx(
                         GumUpdateMembership,
                         NmUpdatePerformFixups,
                         2,
                         dwPropertyListSize,
                         pPropertyList,
                         sizeof(DWORD),
                         &dwPropertyListSize
                         );

            LocalFree(pPropertyList);
            pPropertyList = NULL;
            if(szKeyName)
            {
                LocalFree(szKeyName);
                szKeyName=NULL;
            }
        }

       if (dwStatus != ERROR_SUCCESS)
            goto FnExit;
    }


// Rohit (rjain): introduced new update type to fix the registry and
// in-memory structures after a node with a higher version of clustering
// service joins a node with a lower version. To make it extensible in future
// all the information needed for a fixup is passed as arguments to the fixup
// function. Any new fix can be added by adding suitable record to FixupTable2 and
// a postfixup function callback to PostfixupCbTable.

    dwCount= sizeof(FixupTable2)/sizeof(NM_FIXUP_CB_RECORD2);
    for (i=0; i < dwCount ; i++)
    {

        pFixupCbRec2 = &FixupTable2[i];

        //if this fixup doesnt need to be applied, skip it
        if (!(pFixupCbRec2->dwFixupMask & dwFixupType))
            continue;

        dwStatus = (pFixupCbRec2->pfnFixupNotifyCb)(dwFixupType, &pPropertyList,
                                         &dwPropertyListSize,&szKeyName);

        if (dwStatus != ERROR_SUCCESS)
        {
            goto FnExit;
        }
        if (pPropertyList && dwPropertyListSize)
        {
            // Marshall PropertyTable into byte array
            Required=sizeof(DWORD);
        AllocMem:
            pBuffer=(LPBYTE)LocalAlloc(LMEM_FIXED,Required);
            if (pBuffer==NULL)
            {
                dwStatus=GetLastError();
                goto FnExit;
            }
            dwSize=Required;
            dwStatus=ClRtlMarshallPropertyTable(pFixupCbRec2->pPropertyTable,dwSize,pBuffer,&Required);
            if(dwStatus!= ERROR_SUCCESS)
            {
                LocalFree(pBuffer);
                pBuffer=NULL;
              //  ClRtlLogPrint(LOG_NOISE,"[NM] NmPerformFixups - Memory Required=%1!u!\r\n",
              //          Required);
                goto AllocMem;
            }
            //
            // Issue a global update
            //
            dwStatus = GumSendUpdateEx(
                         GumUpdateMembership,
                         NmUpdatePerformFixups2,
                         5,
                         dwPropertyListSize,
                         pPropertyList,
                         sizeof(DWORD),
                         &dwPropertyListSize,
                         sizeof(DWORD),
                         &i,
                         (lstrlenW(szKeyName)+1)*sizeof(WCHAR),
                         szKeyName,
                         Required,
                         pBuffer
                         );

            LocalFree(pPropertyList);
            pPropertyList = NULL;
            LocalFree(pBuffer);
            pBuffer= NULL;
            if(szKeyName)
            {
                LocalFree(szKeyName);
                szKeyName= NULL;
            }
        }

       if (dwStatus != ERROR_SUCCESS)
            break;
    }


FnExit:
    if(szKeyName)
    {
        LocalFree(szKeyName);
        szKeyName=NULL;
    }
     ClRtlLogPrint(LOG_NOISE,"[NM] NmPerformFixups Exit, dwStatus=%1!u!\r\n",
        dwStatus);

    return(dwStatus);

} //NmPerformFixups



/****
@func       DWORD | NmpUpdatePerformFixups| The gum update handler for
            doing the registry fixups.

@parm       IN DWORD | IsSourceNode| If the gum request originated at this
node.

@parm       IN PVOID| pPropertyList| Pointer to a property list structure.

@parm       IN DWORD | pdwPropertyListSize | A pointer to a DWORD containing
            the size of the property list structure.

@comm       The gum update handler commits this fixup to the cluster registry
            as a transaction.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f NmJoinFixup> <f NmFormFixup>
****/
DWORD NmpUpdatePerformFixups(
    IN BOOL     IsSourceNode,
    IN PVOID    pPropertyList,
    IN LPDWORD  pdwPropertyListSize
    )
{
    DWORD           dwStatus = ERROR_SUCCESS;
    HLOCALXSACTION  hXaction;


    if (!NmpEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process PerformFixups update. "
            "update.\n"
            );
        return(ERROR_NODE_NOT_AVAILABLE);
    }

    //
    // Begin a transaction
    //
    hXaction = DmBeginLocalUpdate();

    if (hXaction != NULL) {
        dwStatus = ClRtlSetPropertyTable(
                       hXaction,
                       DmClusterParametersKey,
                       &NmpFixupRegApis,
                       NmpJoinFixupProperties,
                       NULL,
                       FALSE,
                       pPropertyList,
                       *pdwPropertyListSize,
                       FALSE /*bForceWrite*/,
                       NULL
                       );

        if (dwStatus == ERROR_SUCCESS) {
            DmCommitLocalUpdate(hXaction);
        }
        else {
            DmAbortLocalUpdate(hXaction);
        }
    }
    else {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, "[NM] Failed to begin a transaction "
            "to perform fixups, status %1!u!\n",
            dwStatus
            );
    }

    NmpLeaveApi();

    return(dwStatus);

} // NmpUpdatePerformFixups


/****
@func       DWORD | NmpUpdatePerformFixups2| The gum update handler for
            doing the registry fixups and updating in-memory fixups.New fixups
            can be added by adding suitable record to FixupTable2. However,
            for these new fixups only registry fixup will be carried out.

@parm       IN DWORD | IsSourceNode| If the gum request originated at this node.

@parm       IN PVOID| pPropertyList| Pointer to a property list structure.

@parm       IN DWORD | pdwPropertyListSize | Pointer to a DWORD containing
            the size of the property list structure.

@parm       IN LPDWORD | lpdeFixupNum | Pointer to DWORD which specifies the
            the index in NmpJoinFixupProperties table.
@parm       IN PVOID | lpKeyName | Registry Key which needs to be updated

@parm       IN PVOID  | pPropertyBuffer| Registry update table in marshalled form

@comm       The gum update handler commits this fixup to the cluster registry
            as a transaction.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f NmJoinFixup> <f NmFormFixup> <f PostFixupCbTable>
****/

DWORD NmpUpdatePerformFixups2(
    IN BOOL     IsSourceNode,
    IN PVOID    pPropertyList,
    IN LPDWORD  pdwPropertyListSize,
    IN LPDWORD  lpdwFixupNum,
    IN PVOID    lpKeyName,
    IN PVOID    pPropertyBuffer
    )
{
    DWORD           dwStatus = ERROR_SUCCESS;
    HLOCALXSACTION  hXaction = NULL;
    HDMKEY          hdmKey;
    PRESUTIL_PROPERTY_ITEM  pPropertyTable=NULL;
    PRESUTIL_PROPERTY_ITEM  propertyItem;


    if (!NmpEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process PerformFixups2 update. "
            "update.\n"
            );
        return(ERROR_NODE_NOT_AVAILABLE);
    }

    if(pPropertyBuffer == NULL)
    {
       ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] NmpUpdatePerformJoinFixups2: Bad Arguments\n"
                );
        dwStatus = ERROR_BAD_ARGUMENTS;
        goto FnExit;
     }

    // Begin a transaction
    //
    hXaction = DmBeginLocalUpdate();

    if (hXaction == NULL) {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] NmpUpdatePerformJoinFixups2: Failed to begin a transaction, "
            "status %1!u!\n",
            dwStatus
            );
        goto FnExit;
    }

    // special case - if fixup is for the property of key "Cluster"
    if(!lstrcmpW((LPCWSTR)lpKeyName,CLUSREG_KEYNAME_CLUSTER))
    {
        hdmKey=DmClusterParametersKey;
    }
    else
    {
        hdmKey=DmOpenKey(DmClusterParametersKey,
                         (LPCWSTR)lpKeyName,
                         KEY_ALL_ACCESS
                         );
        if (hdmKey == NULL)
        {
            dwStatus = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] NmpUpdatePerformJoinFixups2: DmOpenKey failed to "
                "open key %1!ws! : error %2!u!\n",
                lpKeyName,dwStatus);
            goto FnExit;
        }
    }

    //unmarshall pPropertyBuffer into a RESUTIL_PROPERTY_ITEM table
    //
    dwStatus=ClRtlUnmarshallPropertyTable(&pPropertyTable,pPropertyBuffer);

    if(dwStatus != ERROR_SUCCESS)
        goto FnExit;

    dwStatus=ClRtlSetPropertyTable(
                            hXaction,
                            hdmKey,
                            &NmpFixupRegApis,
                            pPropertyTable,
                            NULL,
                            FALSE,
                            pPropertyList,
                            *pdwPropertyListSize,
                            FALSE, // bForceWrite
                            NULL
                            );

   if (dwStatus != ERROR_SUCCESS) {
       goto FnExit;
   }

   // callback function to update in-memory structures
   // for any new fixup introduced in later version,
   // the in-memory fixups will not be applied.
   if (*lpdwFixupNum < (sizeof(PostFixupCbTable)/sizeof(NM_POST_FIXUP_CB)))
   {
       if (PostFixupCbTable[*lpdwFixupNum] !=NULL){
           dwStatus=(PostFixupCbTable[*lpdwFixupNum])();
           ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] NmpUpdatePerformJoinFixups2: called postfixup "
                "notifycb function with  status %1!u!\n",
                dwStatus
                );
       }
   }

FnExit:
    if (hXaction != NULL)
    {
        if (dwStatus == ERROR_SUCCESS){
            DmCommitLocalUpdate(hXaction);
        }
        else {
            DmAbortLocalUpdate(hXaction);
        }
    }

    if((hdmKey!= DmClusterParametersKey) && (hdmKey!= NULL)) {
        DmCloseKey(hdmKey);
    }

    if (pPropertyTable != NULL) {
        // Free pPropertyTable structure
        propertyItem=pPropertyTable;

        if(propertyItem!=NULL){
            while(propertyItem->Name != NULL)
            {
                LocalFree(propertyItem->Name);
                if(propertyItem->KeyName!=NULL)
                    LocalFree(propertyItem->KeyName);
                propertyItem++;
            }

            LocalFree(pPropertyTable);
        }
    }

    NmpLeaveApi();

    return(dwStatus);

} // NmpUpdatePerformFixups2



DWORD NmFixupNotifyCb(VOID)
{

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] NmFixupNotifyCb: Calculating Cluster Node Limit\r\n");
    //update the product suite information
    //when the node objects are created we assume that the suite
    //type is Enterprise.
    //Here after a node has joined and informed us about its suite
    //type by making fixups to the registry, we read the registry
    //and update the node structure
    NmpRefreshNodeObjects();
    //recalc the cluster node limit
    NmpResetClusterNodeLimit();

    //SS: This is ugly---we should pass in the product suits early on
    //also the fixup interface needs to to be richer so that the postcallback
    //function nodes whether it is a form fixup or a join fixup and if it 
    //is a join fixup, which node is joining.  This could certainly optimize
    //some of the fixup processing

    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\service\nm\nmpnp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    nmpnp.c

Abstract:

    Network Plug 'N Play and interface state event handling for
    the Node Manager.

Author:

    Mike Massa (mikemas)

Revision History:

    2/23/98   Created.

--*/

#include "nmp.h"


//
// Private Types
//
typedef struct {
    LIST_ENTRY           Linkage;
    CLUSNET_EVENT_TYPE   Type;
    DWORD                Context1;
    DWORD                Context2;
} NM_PNP_EVENT, *PNM_PNP_EVENT;


//
// Private Data
//
PCRITICAL_SECTION       NmpPnpLock = NULL;
BOOLEAN                 NmpPnpEnabled = FALSE;
BOOLEAN                 NmpPnpChangeOccurred = FALSE;
BOOLEAN                 NmpPnpInitialized = FALSE;
PCLRTL_BUFFER_POOL      NmpPnpEventPool = NULL;
PNM_PNP_EVENT           NmpPnpShutdownEvent = NULL;
PCL_QUEUE               NmpPnpEventQueue = NULL;
HANDLE                  NmpPnpWorkerThreadHandle = NULL;
LPWSTR                  NmpPnpAddressString = NULL;


//
// Private Prototypes
//
DWORD
NmpPnpWorkerThread(
    LPVOID Context
    );


//
// Routines
//
DWORD
NmpInitializePnp(
    VOID
    )
{
    DWORD      status;
    HANDLE     handle;
    DWORD      threadId;
    DWORD      maxAddressStringLength;


    //
    // Create the PnP lock
    //
    NmpPnpLock = LocalAlloc(LMEM_FIXED, sizeof(CRITICAL_SECTION));

    if (NmpPnpLock == NULL) {
        ClRtlLogPrint(LOG_CRITICAL, "[NM] Unable to allocate PnP lock.\n");
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    InitializeCriticalSection(NmpPnpLock);

    NmpPnpInitialized = TRUE;

    //
    // Allocate a buffer pool for PnP event contexts
    //
    NmpPnpEventPool = ClRtlCreateBufferPool(
                             sizeof(NM_PNP_EVENT),
                             5,
                             CLRTL_MAX_POOL_BUFFERS,
                             NULL,
                             NULL
                             );

    if (NmpPnpEventPool == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to allocate PnP event pool.\n"
            );
        goto error_exit;
    }

    //
    // Pre-allocate the shutdown event
    //
    NmpPnpShutdownEvent = ClRtlAllocateBuffer(NmpPnpEventPool);

    if (NmpPnpShutdownEvent == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to allocate PnP shutdown event.\n"
            );
        goto error_exit;
    }

    NmpPnpShutdownEvent->Type = ClusnetEventNone;

    //
    // Allocate the PnP event queue
    //
    NmpPnpEventQueue = LocalAlloc(LMEM_FIXED, sizeof(CL_QUEUE));

    if (NmpPnpEventQueue == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to allocate PnP event queue.\n"
            );
        goto error_exit;
    }

    ClRtlInitializeQueue(NmpPnpEventQueue);



    ClRtlQueryTcpipInformation(&maxAddressStringLength, NULL, NULL);

    NmpPnpAddressString = LocalAlloc(
                              LMEM_FIXED,
                              (maxAddressStringLength + 1) * sizeof(WCHAR)
                              );

    if (NmpPnpAddressString == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to allocate PnP address buffer.\n"
            );
        goto error_exit;
    }

    //
    // Create PnP worker thread
    //
    NmpPnpWorkerThreadHandle = CreateThread(
                                   NULL,
                                   0,
                                   NmpPnpWorkerThread,
                                   NULL,
                                   0,
                                   &threadId
                                   );

    if (NmpPnpWorkerThreadHandle == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Failed to create PnP worker thread, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    status = ERROR_SUCCESS;

error_exit:

    return(status);

} // NmpInitializePnp


VOID
NmpShutdownPnp(
    VOID
    )
{
    if (!NmpPnpInitialized) {
        return;
    }

    if (NmpPnpWorkerThreadHandle != NULL) {
        //
        // Post shutdown event to queue
        //
        ClRtlInsertTailQueue(
            NmpPnpEventQueue,
            &(NmpPnpShutdownEvent->Linkage)
            );

        //
        // Wait for the worker thread to terminate
        //
        WaitForSingleObject(NmpPnpWorkerThreadHandle, INFINITE);

        CloseHandle(NmpPnpWorkerThreadHandle);
        NmpPnpWorkerThreadHandle = NULL;
    }

    return;

} // NmpShutdownPnp


VOID
NmpCleanupPnp(
    VOID
    )
{
    if (!NmpPnpInitialized) {
        return;
    }

    if (NmpPnpEventQueue != NULL) {
        LIST_ENTRY      eventList;
        PLIST_ENTRY     entry;
        PNM_PNP_EVENT   event;


        ClRtlRundownQueue(NmpPnpEventQueue, &eventList);

        for ( entry = eventList.Flink;
              entry != &eventList;
            )
        {
            event = CONTAINING_RECORD(entry, NM_PNP_EVENT, Linkage);

            if (event == NmpPnpShutdownEvent) {
                NmpPnpShutdownEvent = NULL;
            }

            entry = entry->Flink;
            ClRtlFreeBuffer(event);
        }

        LocalFree(NmpPnpEventQueue);
        NmpPnpEventQueue = NULL;
    }

    if (NmpPnpEventPool != NULL) {
        if (NmpPnpShutdownEvent != NULL) {
            ClRtlFreeBuffer(NmpPnpShutdownEvent);
            NmpPnpShutdownEvent = NULL;

        }

        ClRtlDestroyBufferPool(NmpPnpEventPool);
        NmpPnpEventPool = NULL;
    }

    if (NmpPnpAddressString != NULL) {
        LocalFree(NmpPnpAddressString);
        NmpPnpAddressString = NULL;
    }

    DeleteCriticalSection(NmpPnpLock);
    NmpPnpLock = NULL;

    NmpPnpInitialized = FALSE;

    return;

} // NmpCleanupPnp


VOID
NmpWatchForPnpEvents(
    VOID
    )
{
    EnterCriticalSection(NmpPnpLock);

    NmpPnpChangeOccurred = FALSE;

