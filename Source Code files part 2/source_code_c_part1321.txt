ilure.
    // Will fail if the cookie is single-valued.
    // If the named value is already present in the cookie, calling this function
    // will modify the current value, otherwise a new name-value pair is added to the cookie.
    // Call RemoveValue or RemoveAllValues to remove the name-value pairs
    // added by this function.
    BOOL AddValue(LPCSTR szName, LPCSTR szValue) throw()
    {
        if (m_strValue.GetLength())
            return FALSE;
        _ATLTRY
		{
        return m_Values.SetAt(szName, szValue) != NULL;
		}
		_ATLCATCHALL()
		{
		}
		return FALSE;
    }
    
    // Call this function to modify a name-value pair associated with the cookie.
    // Returns TRUE on success, FALSE on failure.
    // Will fail if the cookie is single-valued.
    // This function just calls AddValue so the name-value pair will be added if not already present.
    // Use this function instead of AddValue to document the intentions of your call. 
    BOOL ModifyValue(LPCSTR szName, LPCSTR szValue) throw()
    {
        return AddValue(szName, szValue);
    }

    // Call this function to remove a name-value pair from the collection managed by this cookie.
    // Returns TRUE on success, FALSE on failure.
    BOOL RemoveValue(LPCSTR szName) throw()
    {
        return m_Values.RemoveKey(szName);
    }

    // Call this function to remove all the name-value pairs from the collection managed by this cookie.
    void RemoveAllValues() throw()
    {
        m_Values.RemoveAll();
    }

    // Call this function to add an attribute-value pair to the collection of attributes for this cookie.
    // Returns TRUE on success, FALSE on failure.
    // This function is equivalent to calling ModifyAttribute.
    // Both functions will add the attribute if not already present or
    // change its value if it has already been applied to the cookie.
    BOOL AddAttribute(LPCSTR szName, LPCSTR szValue) throw()
    {
        if (!szName || !*szName || !szValue)
            return FALSE;

		_ATLTRY
		{
        return (m_Attributes.SetAt(szName, szValue) != NULL);
		}
		_ATLCATCHALL()
		{
		}
		return FALSE;
        
    }

    // Call this function to modify an attribute-value pair associated with the cookie.
    // Returns TRUE on success, FALSE on failure.
    // This function is equivalent to calling AddAttribute.
    // Both functions will add the attribute if not already present or
    // change its value if it has already been applied to the cookie.
    BOOL ModifyAttribute(LPCSTR szName, LPCSTR szValue) throw()
    {
        return AddAttribute(szName, szValue);
    }

    // Call this function to remove an attribute-value pair from the collection of attributes managed by this cookie.
    // Returns TRUE on success, FALSE on failure.
    BOOL RemoveAttribute(LPCSTR szName) throw()
    {
        return m_Attributes.RemoveKey(szName);
    }

    // Call this function to remove all the attribute-value pairs from the collection of attributes managed by this cookie.
    void RemoveAllAttributes() throw()
    {
        m_Attributes.RemoveAll();
    }


    // Call this function to set the Comment attribute of the cookie.
    // Returns TRUE on success, FALSE on failure.
    // The Comment attribute allows a web server to document its
    // intended use of a cookie. This information may be displayed
    // by supporting browsers so that the user of the web site can
    // decide whether to initiate or continue a session with this cookie.
    // This attribute is optional.
    // Version 1 attribute.
    BOOL SetComment(LPCSTR szComment) throw()
    {
        BOOL bRet = SetVersion(1);
        if (bRet)
            bRet = AddAttribute("comment", szComment);
        return bRet;
    }

    // Call this function to set the CommentUrl attribute of the cookie.
    // Returns TRUE on success, FALSE on failure.
    // The CommentUrl attribute allows a web server to document its intended 
    // use of a cookie via a URL that the user of the web site can navigate to.
    // The URL specified here should not send further cookies to the client to
    // avoid frustrating the user.
    // This attribute is optional.
    // Version 1 attribute.
    BOOL SetCommentUrl(LPCSTR szUrl) throw()
    {
        BOOL bRet = SetVersion(1);
        if (bRet)
            bRet = AddAttribute("commenturl", szUrl);
        return bRet;
    }

    // Call this function to add or remove the Discard attribute of the cookie.
    // Returns TRUE on success, FALSE on failure.
    // The Discard attribute does not have a value.
    // Call SetDiscard(TRUE) to add the Discard attribute
    // or SetDiscard(FALSE) to remove the Discard attribute.
    // Setting the Discard attribute tells a web browser that it should
    // discard this cookie when the browser exits regardless of the 
    // value of the Max-Age attribute.
    // This attribute is optional.
    // When omitted, the default behavior is that the Max-Age attribute
    // controls the lifetime of the cookie.
    // Version 1 attribute.
    BOOL SetDiscard(BOOL bDiscard) throw()
    {
        BOOL bRet = FALSE;
        LPCSTR szKey = "Discard";
        bRet = SetVersion(1);
        if (bRet)
        {
            if (bDiscard == 0)
            {
                bRet = m_Attributes.RemoveKey(szKey);
            }
            else
            {
				_ATLTRY
				{
					bRet = m_Attributes.SetAt(szKey, " ") != 0;
				}
				_ATLCATCHALL()
				{
					bRet = FALSE;
				}
            }
        }
        return bRet;
    }

    // Call this function to set the Domain attribute of the cookie.
    // Returns TRUE on success, FALSE on failure.
    // The Domain attribute is used to indicate the domain to which the current 
    // cookie applies. Browsers should only send cookies back to the relevant domains.
    // This attribute is optional.
    // When omitted, the default behavior is for
    // browsers to use the full domain of the server originating the cookie. You can
    // set this attribute value explicitly if you want to share cookies among several servers.
    // Version 0 & Version 1 attribute.
    BOOL SetDomain(LPCSTR szDomain) throw()
    {
        BOOL bRet = SetVersion(1);
        if (bRet)
            bRet = AddAttribute("domain", szDomain);
        return bRet;
    }

    // Call this function to set the Max-Age attribute of the cookie.
    // Returns TRUE on success, FALSE on failure.
    // The value of the Max-Age attribute is a lifetime in seconds for the cookie.
    // When the time has expired, compliant browsers will discard this cookie
    // (if they haven't already done so as a result of the Discard attribute).
    // If Max-Age is set to zero, the browser discards the cookie immediately.
    // This attribute is the Version 1 replacement for the Expires attribute.
    // This attribute is optional.
    // When omitted, the default behavior is for browsers to discard cookies
    // when the user closes the browser.
    // Version 1 attribute.
    BOOL SetMaxAge(UINT nMaxAge) throw()
    {
        BOOL bRet = FALSE;
        bRet = SetVersion(1);
        if (bRet)
        {
            CHAR buff[20];
            if (_itoa(nMaxAge, buff, 10))
            {
                bRet = AddAttribute("max-age", buff);
            }
        }
        return bRet;
    }

    // Call this function to set the Path attribute of the cookie.
    // Returns TRUE on success, FALSE on failure.
    // The Path attribute specifies the subset of URLs to which this cookie applies.
    // Only URLs that contain that path are allowed to read or modify the cookie. 
    // This attribute is optional.
    // When omitted the default behavior is for browsers to treat the path of a cookie
    // as the path of the request URL that generated the Set-Cookie response, up to,
    // but not including, the right-most /.
    // Version 0 & Version 1 attribute.
    BOOL SetPath(LPCSTR szPath) throw()
    {   
        BOOL bRet = SetVersion(1);
        if (bRet)
            bRet = AddAttribute("path", szPath);
        return bRet;
    }

    // Call this function to set the Port attribute of the cookie.
    // Returns TRUE on success, FALSE on failure.
    // The Port attribute specifies the port to which this cookie applies.
    // Only URLs accessed via that port are allowed to read or modify the cookie. 
    // This attribute is optional.
    // When omitted the default behavior is for browsers to return the cookie via any port.
    // Version 1 attribute.
    BOOL SetPort(LPCSTR szPort) throw()
    {
        BOOL bRet = SetVersion(1);
        if (bRet)
            bRet = AddAttribute("port", szPort);
        return bRet;
    }

    // Call this function to add or remove the Secure attribute of the cookie.
    // Returns TRUE on success, FALSE on failure.
    // The Secure attribute does not have a value.
    // Call SetSecure(TRUE) to add the Secure attribute
    // or SetSecure(FALSE) to remove the Secure attribute.
    // Setting the Secure attribute tells a browser that it should
    // transmit the cookie to the web server only via secure means such as HTTPS.
    // This attribute is optional.
    // When omitted, the default behavior is that the cookie
    // will be sent via unsecured protocols.
    // Version 0 & Version 1 attribute.
    BOOL SetSecure(BOOL bSecure) throw()
    {
        BOOL bRet = FALSE;
        LPCSTR szKey = "secure";
        bRet = SetVersion(1);
        if (bRet)
        {
            if (bSecure == 0)
            {
                bRet = m_Attributes.RemoveKey(szKey);
            }
            else
            {
				_ATLTRY
				{
					bRet = m_Attributes.SetAt(szKey, " ") != 0;
				}
				_ATLCATCHALL()
				{
					bRet = FALSE;
				}
            }
        }
        return bRet;
    }

    // Call this function to set the Version attribute of the cookie.
    // Returns TRUE on success, FALSE on failure.
    // This attribute is required for Version 1 cookies by RFC 2109 and must have a value of 1.
    // However, you do not need to call SetVersion explicitly from your own code unless you need to
    // force RFC 2109 compliance. CCookie will automatically set this attribute whenever
    // you use a Version 1 attribute in your cookie.
    // Version 1 attribute.
    BOOL SetVersion(UINT nVersion) throw()
    {
        BOOL bRet = FALSE;      
        CHAR buff[20];
        if (_itoa(nVersion, buff, 10))
        {
            bRet = AddAttribute("version", buff);
        }
        return bRet;
    }

    // Call this function to set the Expires attribute of the cookie.
    // Returns TRUE on success, FALSE on failure.
    // The Expires attribute specifies an absolute date and time at which this cookie
    // should be discarded by web browsers. Pass a SYSTEMTIME holding a Greenwich Mean Time (GMT)
    // value or a string in the following format:
    //      Wdy, DD-Mon-YY HH:MM:SS GMT
    // This attribute is optional.
    // When omitted, the default behavior is for browsers to discard cookies
    // when the user closes the browser.
    // This attribute has been superceded in Version 1 by the Max-Age attribute,
    // but you should continue to use this attribute for Version 0 clients.
    // Version 0 attribute.
    BOOL SetExpires(LPCSTR szExpires) throw()
    {
        return AddAttribute("expires", szExpires);
    }

    BOOL SetExpires(const SYSTEMTIME &st) throw()
    {
		_ATLTRY
		{
			CFixedStringT<CStringA, ATLS_MAX_HTTP_DATE> strTime;
			SystemTimeToHttpDate(st, strTime);
			return SetExpires(strTime);
		}
		_ATLCATCHALL()
		{
		}
		return FALSE;
    }

    // Call this function to look up the value of a name-value pair applied to this cookie.
    // Returns the requested value if present or NULL if the name was not found.
    LPCSTR Lookup(LPCSTR szName=NULL) const throw()
    {
        if (IsEmpty())
            return NULL;

		if (!szName && m_strValue.GetLength())
			return m_strValue;

        if (m_Values.GetCount())
        {
            const mapType::CPair *pPair = m_Values.Lookup(szName);
            if (pPair)
                return (LPCSTR)pPair->m_value;
        }

        return NULL;
    }

    // Call this function to clear the cookie of all content
    // including name, value, name-value pairs, and attributes.
    void Empty() throw()
    {
        m_strName = "";
        m_strValue = "";
        m_Attributes.RemoveAll();
        m_Values.RemoveAll();
    }

     // Call this function to create a CCookie from a buffer.
     // The passed in buffer contains a cookie header retrieved
     // from the HTTP_COOKIE request variable
     //
     // review: support MBCS cookie values?
     ATL_NOINLINE bool Parse(LPSTR pstart) throw()
     {
        //pStart points to the beginning of the cookie
        //pEnd points to the character just past the end of the cookie.
        //cookie is in the form name=value
        LPSTR pEnd = pstart;
        LPSTR pStart = pstart;
        int index = 0;
        LPSTR pTokens[16];
        CStringA strName, name, value;

        while (*pEnd != '&' && *pEnd != ';' && *pEnd != '\0')
            pEnd++;

        int nCount = CountOf('=', pStart, pEnd);
        
        if (nCount == 2)
        {
            //first token is name, next tokens are first name/value in
            //the Values collection
            pEnd = pStart;
            index = 1;
            pTokens[0]=pStart;
            while (*pEnd != '&' && *pEnd != ';' && *pEnd != '\0')
            {
                if (*pEnd == '=')
                {
                    pTokens[index++] = pEnd;
                }                   
                pEnd++;
            }

            CopyToCString(strName, pTokens[0], pTokens[1]-1);
            CopyToCString(name, pTokens[1]+1, pTokens[2]-1);
            CopyToCString(value, pTokens[2]+1, pEnd-1);
			_ATLTRY
			{
				m_strName = strName;
				AddValue(name, value);
			}
			_ATLCATCHALL()
			{
				return false;
			}
        }
        else if (nCount == 1)
        {
            LPSTR pCurr = pStart;
            index = 1;
            pTokens[0] = pStart;
            while (pCurr != pEnd)
            {
                if (*pCurr == '=')
                {
                    pTokens[index] = pCurr;
                }                   
                pCurr++;
            }
            CopyToCString(name, pTokens[0], pTokens[1]-1);
            CopyToCString(value, pTokens[1]+1, pEnd-1);
			_ATLTRY
			{
				m_strName = name;
				m_strValue = value;
			}
			_ATLCATCHALL()
			{
				return false;
			}
		
        }
        else if (nCount == 0)
        {
            // no value
            if (pEnd > pStart)
            {
                CopyToCString(name, pStart, pEnd-1);
				_ATLTRY
				{
					m_strName = name;
					m_strValue = "";
				}
				_ATLCATCHALL()
				{
					return false;
				}
            }
        }
        else
            return false; //error in cookie

        if (*pEnd == '&')
        {
            //still have name/values to parse
            pStart = pEnd+1;
            pEnd = pStart;
            while(1)
            {
                if (*pEnd == '=') //separates the name from the value
                    pTokens[0] = pEnd;
                //Marks either the end of the name/values or    
                //the end of the name/value statement
                if (*pEnd == '&' || *pEnd == ';' || *pEnd == '\0')
                {
                    CopyToCString(name, pStart, pTokens[0]-1);
                    CopyToCString(value, pTokens[0]+1, pEnd-1);
                    AddValue(name, value);
                    pStart = pEnd+1;
                }

                if (*pEnd == ';' || *pEnd =='\0')
                    break;

                pEnd++;
            }
        }
         
        m_strName.TrimRight();
        m_strName.TrimLeft();
        m_strValue.TrimRight();
        m_strValue.TrimLeft();
        return true;
     }

    // Call this function to render this cookie
    // into a buffer. Returns TRUE on success, FALSE on failure.
    // On entry, pdwLen should point to a DWORD that indicates 
    // the size of the buffer in bytes. On exit, the DWORD contains
    // the number of bytes transferred or available to be transferred
    // into the buffer (including the nul-terminating byte). On
    // success, the buffer will contain the correct HTTP 
    // representation of the current cookie suitable for sending to 
    // a client as the body of a Set-Cookie header.
    ATL_NOINLINE BOOL Render(LPSTR szCookieBuffer, DWORD *pdwLen) const throw()
    {
        CStringA strCookie;
        CStringA name, value;
        DWORD nLenBuff = *pdwLen;
        *pdwLen = 0;

        // A cookie must have a name!
        if (!m_strName.GetLength())
        {
            *pdwLen = 0;
            return FALSE;
        }
		_ATLTRY
		{
			strCookie = m_strName;
			int nValSize = (int) m_Values.GetCount();

			//add value or name/value pairs.
			if (m_strValue.GetLength())
			{
				strCookie += '=';
				strCookie += m_strValue;
			}
			else if (nValSize)
			{
				strCookie += '=';
				POSITION pos = m_Values.GetStartPosition();
				for (int i=0; pos; i++)
				{
					m_Values.GetNextAssoc(pos, name, value);
					strCookie += name;
					if (value.GetLength())
					{
						strCookie += '=';
						strCookie += value;
					}
					if (i <= nValSize-2)
						strCookie += '&';
				}
			}

			CStringA strAttributes;
			if (!RenderAttributes(strAttributes))
				return FALSE;
			if (strAttributes.GetLength() > 0)
			{
				strCookie += "; ";
				strCookie += strAttributes;
			}
	        
			DWORD dwLenCookie = strCookie.GetLength() + 1;
			if (dwLenCookie > nLenBuff)
			{
				*pdwLen = dwLenCookie;
				return FALSE; //buffer wasn't big enough
			}

			*pdwLen = dwLenCookie - 1;
			strcpy(szCookieBuffer, strCookie);
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}

        return TRUE;
    }

    POSITION GetFirstAttributePos() const throw()
    {
        return m_Attributes.GetStartPosition();
    }

    const elemType& GetNextAttributeName(POSITION& pos) const throw()
    {
        return m_Attributes.GetNextKey(pos);
    }

	const elemType& GetAttributeValueAt(POSITION pos) const throw()
	{
		return m_Attributes.GetValueAt(pos);
	}

    BOOL GetNextAttrAssoc(POSITION& pos, elemType& key,
        elemType& val) const throw()
    {
		_ATLTRY
		{
			m_Attributes.GetNextAssoc(pos, key, val);
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
		return TRUE;
    }

    POSITION GetFirstValuePos() const throw()
    {
        return m_Values.GetStartPosition();
    }

    const elemType& GetNextValueName(POSITION& pos) const throw()
    {
        return m_Values.GetNextKey(pos);
    }

    const elemType& GetValueAt(POSITION pos) const throw()
    {
        return m_Values.GetValueAt(pos);
    }
	
	BOOL GetNextValueAssoc(POSITION& pos, elemType& key,
        elemType& val) const throw()
    {
		_ATLTRY
		{
			m_Values.GetNextAssoc(pos, key, val);
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
		return TRUE;
    }

protected:
// Implementation
    BOOL RenderAttributes(CStringA& strAttributes) const throw()
    {
		_ATLTRY
		{
			strAttributes = "";

			POSITION pos = m_Attributes.GetStartPosition();
			CStringA key, val;
			for (int i=0; pos; i++)
			{
				if (i)
					strAttributes += ";";
				m_Attributes.GetNextAssoc(pos, key, val);
				strAttributes += key;
				strAttributes += '=';
				strAttributes += val;
			}
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
		return TRUE;
    }
private:
    CCookie& Copy(const CCookie& thatCookie) throw(...)
    {
        m_strName = thatCookie.m_strName;
        m_strValue = thatCookie.m_strValue;
        POSITION pos = NULL;
        CStringA strName, strValue;
        if (!thatCookie.m_Attributes.IsEmpty())
        {
            pos = thatCookie.m_Attributes.GetStartPosition();
            while (pos)
            {
                thatCookie.m_Attributes.GetNextAssoc(pos, strName, strValue);
                m_Attributes.SetAt(strName, strValue);
            }
        }
        if (!thatCookie.m_Values.IsEmpty())
        {
            strName.Empty();
            strValue.Empty();
            pos = thatCookie.m_Values.GetStartPosition();
            while (pos)
            {
                thatCookie.m_Values.GetNextAssoc(pos, strName, strValue);
                m_Values.SetAt(strName, strValue);
            }
        }
        return *this;
    }

public:
    // These are implementation only, use at your own risk!
    // Map of attribute-value pairs applied to this cookie.
    mapType m_Attributes;

    // Map of name-value pairs applied to this cookie.
    mapType m_Values;

    // The name of this cookie.
    CStringA m_strName;

    // The value of this cookie.
    CStringA m_strValue;

};  // class CCookie

class CSessionCookie : public CCookie
{
public:
    CSessionCookie() throw(...)
    {
        if (!SetName(SESSION_COOKIE_NAME) &&
			!SetPath("/"))
			AtlThrow(E_OUTOFMEMORY);
    }

    CSessionCookie(LPCSTR szSessionID) throw(...)
    {
        if (!SetName(SESSION_COOKIE_NAME) &&
			!SetPath("/") &&
			!SetSessionID(szSessionID) )
			AtlThrow(E_OUTOFMEMORY);
    }

    BOOL SetSessionID(LPCSTR szSessionID) throw()
    {
        ATLASSERT(szSessionID && szSessionID[0]);
        return SetValue(szSessionID);
    }
}; // class CSessionCookie

template<>
class CElementTraits< CCookie > :
    public CElementTraitsBase< CCookie >
{
public:
    typedef const CCookie& INARGTYPE;
    typedef CCookie& OUTARGTYPE;
    
    static ULONG Hash( INARGTYPE cookie )
    {
        return CStringElementTraits<CStringA>::Hash( cookie.m_strName );
    }

    static bool CompareElements( INARGTYPE cookie1, INARGTYPE cookie2 )
    {
        return( cookie1.m_strName == cookie2.m_strName );
    }

    static int CompareElementsOrdered( INARGTYPE cookie1, INARGTYPE cookie2 )
    {
        return( cookie1.m_strName.Compare( cookie2.m_strName ) );
    }
};

///////////////////////////////////////////////////////////////////////////////
// Request and response classes and support functions


// This class is a wrapper for CAtlMap that allows maps to be chained.
// It simply adds a bool that tells whether or not a map shares values
template <typename K, typename V, typename KTraits=CElementTraits<K>, typename VTraits=CElementTraits<V> >
class CHttpMap
{
private:

#ifdef ATL_HTTP_PARAM_MULTIMAP
	typedef CRBMultiMap<K, V, KTraits, VTraits> MAPTYPE;
#else
	typedef CAtlMap<K, V, KTraits, VTraits> MAPTYPE;
#endif // ATL_HTTP_PARAM_MULTIMAP

public:

	typedef KTraits::INARGTYPE KINARGTYPE;
	typedef KTraits::OUTARGTYPE KOUTARGTYPE;
	typedef VTraits::INARGTYPE VINARGTYPE;
	typedef VTraits::OUTARGTYPE VOUTARGTYPE;

	typedef MAPTYPE::CPair CPair;

private:

	bool m_bShared;
	
	MAPTYPE m_map;
	
public:

	CHttpMap() throw()
		: m_bShared(false)
	{
	}

	virtual ~CHttpMap()
	{
	}

	inline bool IsShared() const throw()
	{
		return m_bShared;
	}

	inline void SetShared(bool bShared) throw()
	{
		m_bShared = bShared;
	}

	//
	// exposed lookup and iteration functionality
	//

	inline size_t GetCount() const throw()
	{
		return m_map.GetCount();
	}

	inline bool IsEmpty() const throw()
	{
		return m_map.IsEmpty();
	}

	inline POSITION GetStartPosition() const throw()
	{
#ifdef ATL_HTTP_PARAM_MULTIMAP
		return m_map.GetHeadPosition();
#else
		return m_map.GetStartPosition();
#endif // ATL_HTTP_PARAM_MULTIMAP
	}

	// Lookup wrappers
	bool Lookup( KINARGTYPE key, VOUTARGTYPE value ) const throw()
	{
		_ATLTRY
		{
#ifdef ATL_HTTP_PARAM_MULTIMAP
		CPair *p = Lookup(key);
		if (p != NULL)
		{
			value = p->m_value;
			return true;
		}
		return false;
#else
		return m_map.Lookup(key, value);
#endif // ATL_HTTP_PARAM_MULTIMAP
		}
		_ATLCATCHALL()
		{
			return false;
		}
	}

	const CPair* Lookup( KINARGTYPE key ) const throw()
	{
#ifdef ATL_HTTP_PARAM_MULTIMAP
		POSITION pos = m_map.FindFirstWithKey(key);
		if (pos != NULL)
		{
			return m_map.GetAt(pos);
		}
		return NULL;
#else
		return m_map.Lookup(key);
#endif // ATL_HTTP_PARAM_MULTIMAP
	}

	CPair* Lookup( KINARGTYPE key ) throw()
	{
#ifdef ATL_HTTP_PARAM_MULTIMAP
		POSITION pos = m_map.FindFirstWithKey(key);
		if (pos != NULL)
		{
			return m_map.GetAt(pos);
		}
		return NULL;
#else
		return m_map.Lookup(key);
#endif // ATL_HTTP_PARAM_MULTIMAP
	}

	// iteration wrappers
	void GetNextAssoc( POSITION& pos, KOUTARGTYPE key, VOUTARGTYPE value ) const throw(...)
	{
		m_map.GetNextAssoc(pos, key, value);
	}

	const CPair* GetNext( POSITION& pos ) const throw()
	{
		return m_map.GetNext(pos);
	}

	CPair* GetNext( POSITION& pos ) throw()
	{
		return m_map.GetNext(pos);
	}

	const K& GetNextKey( POSITION& pos ) const throw()
	{
		return m_map.GetNextKey(pos);
	}

	const V& GetNextValue( POSITION& pos ) const throw()
	{
		return m_map.GetNextValue(pos);
	}

	V& GetNextValue( POSITION& pos ) throw()
	{
		return m_map.GetNextValue(pos);
	}

	void GetAt( POSITION pos, KOUTARGTYPE key, VOUTARGTYPE value ) const throw(...)
	{
		return m_map.GetAt(pos, key, value);
	}

	CPair* GetAt( POSITION pos ) throw()
	{
		return m_map.GetAt(pos);
	}

	const CPair* GetAt( POSITION pos ) const throw()
	{
		return m_map.GetAt(pos);
	}

	const K& GetKeyAt( POSITION pos ) const throw()
	{
		return m_map.GetKeyAt(pos);
	}

	const V& GetValueAt( POSITION pos ) const throw()
	{
		return m_map.GetValueAt(pos);
	}

	V& GetValueAt( POSITION pos ) throw()
	{
		return m_map.GetValueAt(pos);
	}

	// modification wrappers
	POSITION SetAt( KINARGTYPE key, VINARGTYPE value ) throw(...)
	{
#ifdef ATL_HTTP_PARAM_MULTIMAP
		return m_map.Insert(key, value);
#else
		return m_map.SetAt(key, value);
#endif // ATL_HTTP_PARAM_MULTIMAP
	}

	virtual void RemoveAll() throw()
	{
		m_map.RemoveAll();
	}
};

// This class is a wrapper for CHttpMap that assumes it's values are pointers that
// should be deleted on RemoveAll
template <typename K, typename V, typename KTraits=CElementTraits<K>, typename VTraits=CElementTraits<V> >
class CHttpPtrMap : public CHttpMap<K, V, KTraits, VTraits>
{
public:
	typedef CHttpMap<K, V, KTraits, VTraits> Base;

	void RemoveAll() throw()
	{
		if (!IsShared())
		{
			POSITION pos = GetStartPosition();
			while (pos)
			{
				GetNextValue(pos)->Release();
			}
		}
		Base::RemoveAll();
	}

	~CHttpPtrMap() throw()
	{
		RemoveAll();
	}
};

// This class represents a collection of request parameters - the name-value pairs
// found, for example, in a query string or in the data provided when a form is submitted to the server.
// Call Parse to build the collection from a string of URL-encoded data.
// Use the standard collection methods of the CSimpleMap base class to retrieve the
// decoded names and values.
// Use the methods of the CValidateObject base class to validate the parameters.
class CHttpRequestParams : 
#if (defined(ATL_HTTP_PARAM_MAP_CASEINSENSITIVE))
    public CHttpMap<CStringA, CStringA, CStringElementTraitsI<CStringA>, CStringElementTraitsI<CStringA> >, 
#else
    public CHttpMap<CStringA, CStringA, CStringElementTraits<CStringA>, CStringElementTraits<CStringA> >, 
#endif
    public CValidateObject<CHttpRequestParams>
{
public:
#if (defined(ATL_HTTP_PARAM_MAP_CASEINSENSITIVE))
    typedef CHttpMap<CStringA, CStringA, CStringElementTraitsI<CStringA>, CStringElementTraitsI<CStringA> > BaseMap;
#else
	typedef CHttpMap<CStringA, CStringA, CStringElementTraits<CStringA>, CStringElementTraits<CStringA> > BaseMap;
#endif

    LPCSTR Lookup(LPCSTR szName) const throw()
    {
        if (!szName)
            return NULL;

        const CPair *p = BaseMap::Lookup(szName);
        if (p)
        {
            return p->m_value;
        }
        return NULL;
    }

    // Call this function to build a collection of name-value pairs from a string of URL-encoded data.
    // Returns TRUE on success, FALSE on failure.
    // URL-encoded data:
    //      Each name-value pair is separated from the next by an ampersand (&)
    //      Each name is separated from its corresponding value by an equals signs (=)
    //      The end of the data to be parsed is indicated by a nul character (\0) or a pound symbol (#)
    //      A plus sign (+) in the input will be decoded as a space
    //      A percent sign (%) in the input signifies the start of an escaped octet.
    //          The next two digits represent the hexadecimal code of the character.
    //          For example, %21 is the escaped encoding for the US-ASCII exclamation mark and will be decoded as !.
    // Common sources of URL-encoded data are query strings and the bodies of POST requests with content type of application/x-www-form-urlencoded.
    //
    // Parse and Render are complementary operations.
    // Parse creates a collection from a string.
    // Render creates a string from a collection.
    ATL_NOINLINE BOOL Parse(LPSTR szQueryString) throw()
    {
        while (szQueryString && *szQueryString)
        {
            LPSTR szUrlCurrent = szQueryString;
            LPSTR szName = szUrlCurrent;
            LPSTR szPropValue;

            while (*szQueryString)
            {
                if (*szQueryString == '=')
                {
                    szQueryString++;
                    break;
                }
                if (*szQueryString == '&')
                {
                    break;
                }
                if (*szQueryString == '+')
                    *szUrlCurrent = ' ';
                else if (*szQueryString == '%')
                {
                    // if there is a % without two characters
                    // at the end of the url we skip it
                    if (*(szQueryString+1) && *(szQueryString+2))
                    {
                        CHAR szCharCode[3];
                        szCharCode[0] = *(szQueryString+1);
                        szCharCode[1] = *(szQueryString+2);
                        szCharCode[2] = '\0';
                        LPSTR szEnd;
                        *szUrlCurrent = (CHAR) strtoul(szCharCode, &szEnd, 16);
                        szQueryString += 2;
                    }
                    else
                        *szUrlCurrent = '\0';
                }
                else
                    *szUrlCurrent = *szQueryString;

                szQueryString++;
                szUrlCurrent++;
            }

            if (*szUrlCurrent)
                *szUrlCurrent++ = '\0';

            // we have the property name
            szPropValue = szUrlCurrent;
            while (*szQueryString && *szQueryString != '#')
            {
                if (*szQueryString == '&')
                {
                    szQueryString++;
                    break;
                }
                if (*szQueryString == '+')
                    *szUrlCurrent = ' ';
                else if (*szQueryString == '%')
                {
                    // if there is a % without two characters
                    // at the end of the url we skip it
                    if (*(szQueryString+1) && *(szQueryString+2))
                    {
                        CHAR szCharCode[3];
                        szCharCode[0] = *(szQueryString+1);
                        szCharCode[1] = *(szQueryString+2);
                        szCharCode[2] = '\0';
                        LPSTR szEnd;
                        *szUrlCurrent = (CHAR) strtoul(szCharCode, &szEnd, 16);
                        szQueryString += 2;
                    }
                    else
                        *szUrlCurrent = '\0';
                }
                else
                    *szUrlCurrent = *szQueryString;
                szQueryString++;
                szUrlCurrent++;
            }
            // we have the value
            *szUrlCurrent = '\0';
            szUrlCurrent++;
			_ATLTRY
			{
				SetAt(szName, szPropValue);
			}
			_ATLCATCHALL()
			{
				return FALSE;
			}
        }
        return TRUE;
    }

    // Call this function to render the map of names and values into a buffer as a URL-encoded string.
    // Returns TRUE on success, FALSE on failure.
    // On entry, pdwLen should point to a DWORD that indicates the size of the buffer in bytes.
    // On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
    // On success, the buffer will contain the correct URL-encoded representation of the current object
    // suitable for sending to a server as a query string or in the body of a form.
    // URL-encoding:
    //      Each name-value pair is separated from the next by an ampersand (&)
    //      Each name is separated from its corresponding value by an equals signs (=)
    //      A space is encoded as a plus sign (+).
    //      Other unsafe characters (as determined by AtlIsUnsafeUrlChar) are encoded as escaped octets.
    //      An escaped octet is a percent sign (%) followed by two digits representing the hexadecimal code of the character.
    //
    // Parse and Render are complementary operations.
    // Parse creates a collection from a string.
    // Render creates a string from a collection.
    ATL_NOINLINE BOOL Render(LPSTR szParameters, LPDWORD pdwLen) throw()
    {
        ATLASSERT(szParameters);
        ATLASSERT(pdwLen);
		_ATLTRY
		{
			if (GetCount() == 0)
			{
				*szParameters = '\0';
				*pdwLen = 0;
				return TRUE;
			}

			CStringA strParams;
			POSITION pos = GetStartPosition();
			while (pos != NULL)
			{
				LPCSTR szBuf = GetKeyAt(pos);
				EscapeToCString(strParams, szBuf);
				szBuf = GetValueAt(pos);
				if (*szBuf)
				{
					strParams+= '=';
					EscapeToCString(strParams, szBuf);
				}
				strParams+= '&';
				GetNext(pos);
			}

			DWORD dwLen = strParams.GetLength();
			strParams.Delete(dwLen-1);
			BOOL bRet = TRUE;
			if (dwLen >= *pdwLen)
			{
				bRet = FALSE;
			}
			else
			{
				dwLen--;
				memcpy(szParameters, static_cast<LPCSTR>(strParams), dwLen);
				szParameters[dwLen] = '\0';
			}

			*pdwLen = dwLen;
			return bRet;
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}	
    }

}; // class CHttpRequestParams

#define MAX_TOKEN_LENGTH (MAX_PATH)

// This class represents the information about a file that has been uploaded to the web server.
class CHttpRequestFile : public IHttpFile
{
protected:

    // The name of the form field used to upload the file.
    CHAR m_szParamName[MAX_TOKEN_LENGTH];

    // The original file name of the uploaded file as set by the client.
    CHAR m_szFileName[MAX_PATH];

    // The original path and file name of the uploaded file as set by the client.
    CHAR m_szFullFileName[MAX_PATH];

    // The MIME type of the uploaded file.
    CHAR m_szContentType[MAX_TOKEN_LENGTH];

    // The name of the uploaded file on the server.
    CHAR m_szTempFileName[MAX_PATH];

    // The size of the file in bytes.
    ULONGLONG m_nFileSize;

public:

    // The constructor.
    CHttpRequestFile(
        LPCSTR pParamName,
        LPCSTR pFileName,
        LPCSTR pTempFileName,
        LPCSTR pContentType, 
        const ULONGLONG& nFileSize) throw()
    {
        ATLASSERT(pFileName);

        m_szParamName[0] = 0;
        m_szFileName[0] = 0;
        m_szTempFileName[0] = 0;
        m_szFullFileName[0] = 0;
        m_szContentType[0] = 0;
        m_nFileSize = nFileSize;

        strcpy(m_szParamName, pParamName);
        strcpy(m_szFullFileName, pFileName);
        strcpy(m_szTempFileName, pTempFileName);

        if (pContentType && *pContentType)
        {
            strcpy(m_szContentType, pContentType);
        }

        // Set m_szFileName to be the file name without the path.
        // This is likely to be the most meaningful part of the 
        // original file name once the file reaches the server.

        LPSTR szTmp = m_szFullFileName;
        LPSTR szFile = m_szFileName;

        while (*szTmp)
        {
            if (*szTmp == '\\')
            {
                szFile = m_szFileName;
            }
            else
            {
                *szFile++ = *szTmp;
            }
            szTmp++;
        }
        *szFile = 0;
    }

    //=======================================
    // IHttpFile interface
    //=======================================
    LPCSTR GetParamName() throw()
    {
        return m_szParamName;
    }

    LPCSTR GetFileName() throw()
    {
        return m_szFileName;
    }

    LPCSTR GetFullFileName() throw()
    {
        return m_szFullFileName;
    }

    LPCSTR GetContentType() throw()
    {
        return m_szContentType;
    }

    LPCSTR GetTempFileName() throw()
    {
        return m_szTempFileName;
    }

    ULONGLONG GetFileSize() throw()
    {
        return m_nFileSize;
    }

    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppv) throw()
    {
        if (!ppv)
        {
            return E_POINTER;
        }

        if (InlineIsEqualGUID(riid, __uuidof(IUnknown)) ||
            InlineIsEqualGUID(riid, __uuidof(IHttpFile)))
        {
            *ppv = static_cast<IUnknown*>(static_cast<IHttpFile*>(this));
            AddRef();
            return S_OK;
        }

        return E_NOINTERFACE;
    }
    
    ULONG STDMETHODCALLTYPE AddRef() throw()
    {
        ATLASSERT( FALSE );
        return 1;
    }
    
    ULONG STDMETHODCALLTYPE Release() throw()
    {
        delete this;

        return 1;
    }

}; // class CHttpRequestFile


// utility function to ReadData from a ServerContext
ATL_NOINLINE inline 
BOOL ReadClientData(IHttpServerContext *pServerContext, LPSTR pbDest, LPDWORD pdwLen, DWORD dwBytesRead) throw()
{
    ATLASSERT(pServerContext != NULL);
    ATLASSERT(pbDest != NULL);
    ATLASSERT(pdwLen != NULL);

    DWORD dwToRead = *pdwLen;
    DWORD dwAvailableBytes = pServerContext->GetAvailableBytes();
    DWORD dwRead(0);

    // Read from available data first
    if (dwBytesRead < dwAvailableBytes)
    {
        LPBYTE pbAvailableData = pServerContext->GetAvailableData();
        pbAvailableData+= dwBytesRead;
        DWORD dwAvailableToRead = min(dwToRead, dwAvailableBytes-dwBytesRead);
        memcpy(pbDest, pbAvailableData, dwAvailableToRead);
        dwBytesRead+= dwAvailableToRead;
        dwToRead-= dwAvailableToRead;
        pbDest+= dwAvailableToRead;
        dwRead+= dwAvailableToRead;
    }

    DWORD dwTotalBytes = pServerContext->GetTotalBytes();

    // If there is still more to read after the available data is exhausted
    if (dwToRead && dwBytesRead < dwTotalBytes)
    {
        DWORD dwClientBytesToRead = min(pServerContext->GetTotalBytes()-dwBytesRead, dwToRead);
        DWORD dwClientBytesRead = 0;

        // keep on reading until we've read the amount requested
        do
        {
            dwClientBytesRead = dwClientBytesToRead;
            if (!pServerContext->ReadClient(pbDest, &dwClientBytesRead))
            {
                return FALSE;
            }
            dwClientBytesToRead-= dwClientBytesRead;
            pbDest+= dwClientBytesRead;

        } while (dwClientBytesToRead != 0 && dwClientBytesRead != 0);

        dwRead+= dwToRead-dwClientBytesToRead;
    }

    *pdwLen = dwRead;

    return TRUE;
}

#define FORM_BUFFER_SIZE      2048
#define MAX_MIME_LINE_LEN     1024
#define MAX_MIME_BOUNDARY_LEN 128
#define MAX_PARAM_LEN         _MAX_PATH
#define MAX_CONTENT_TYPE_LEN  512

enum ATL_FORM_FLAGS
{
    ATL_FORM_FLAG_NONE = 0,
    ATL_FORM_FLAG_IGNORE_FILES = 1,
    ATL_FORM_FLAG_REFUSE_FILES = 2,
    ATL_FORM_FLAG_IGNORE_EMPTY_FILES = 4,
    ATL_FORM_FLAG_IGNORE_EMPTY_FIELDS = 8,
};

// Use this class to read multipart/form-data from the associated server context
// and generate files as necessary from the data in the body of the request.
class CMultiPartFormParser
{
protected:

    LPSTR                       m_pCurrent;
    LPSTR                       m_pEnd;
    LPSTR                       m_pStart;
    CHAR                        m_szBoundary[MAX_MIME_BOUNDARY_LEN+2];
    CHAR                        m_szSearchBoundary[MAX_MIME_BOUNDARY_LEN+4];
    DWORD                       m_dwBoundaryLen;
    BOOL                        m_bFinished;
    CComPtr<IHttpServerContext> m_spServerContext;

public:
    // The constructor.
    CMultiPartFormParser(IHttpServerContext* pServerContext) throw() :
        m_pCurrent(NULL),
        m_pEnd(NULL),
        m_pStart(NULL),
        m_dwBoundaryLen(0),
        m_bFinished(FALSE),
        m_spServerContext(pServerContext)
    {
        *m_szBoundary = '\0';
    }
    
    ~CMultiPartFormParser() throw()
    {
        // free memory if necessary
        if (m_spServerContext->GetTotalBytes() > m_spServerContext->GetAvailableBytes())
        {
            free(m_pStart);
        }
    }

    // Call this function to read multipart/form-data from the current HTTP request,
    // allowing files to be uploaded to the web server.
    //
    // Returns TRUE on success, FALSE on failure.
    //
    // Forms can be sent to a web server using one of two encodings: application/x-www-form-urlencoded or multipart/form-data.
    // In addition to the simple name-value pairs typically associated with
    // application/x-www-form-urlencoded form data, multipart/form-data (as 
    // described in RFC 2388) can also contain files to be uploaded
    // to the web server.
    //
    // This function will generate a physical file for each file contained in the multipart/form-data request body.
    // The generated files are stored in the server's temporary directory as returned by the 
    // GetTempPath API and are named using the GetTempFileName API.
    // The information about each file can be obtained from the elements of the Files array.
    // You can retrieve the original name of the file on the client, the name of the generated file on the server,
    // the MIME content type of the uploaded file, the name of the form field associated with that file, and the size in
    // bytes of the file. All this information is exposed by the CHttpRequestFile objects in the array.
    //
    // In addition to generating files and populating the Files array with information about them,
    // this function also populates the pQueryParams array with the names and values of the other form fields
    // contained in the current request. The file fields are also added to this array. The value of these fields
    // is the full name of the generated file on the server.
    //
    //      Note that files can be generated even if this function returns FALSE unless you specify either the
    //      ATL_FORM_FLAG_IGNORE_FILES or the ATL_FORM_FLAG_REFUSE_FILES flag. If you don't specify one of these
    //      flags, you should always check the Files array for generated files and delete any that are no longer
    //      needed to prevent your web server from running out of disk space.
    //
    // dwFlags can be a combination of one or more of the following values:
    //      ATL_FORM_FLAG_NONE                  Default behavior.
    //      ATL_FORM_FLAG_IGNORE_FILES          Any attempt to upload files is ignored.
    //      ATL_FORM_FLAG_REFUSE_FILES          Any attempt to upload files is treated as a failure. The function will return FALSE.
    //      ATL_FORM_FLAG_IGNORE_EMPTY_FILES    Files with a size of zero bytes are ignored.
    //      ATL_FORM_FLAG_IGNORE_EMPTY_FIELDS   Fields with no content are ignored.
    ATL_NOINLINE BOOL GetMultiPartData(CHttpMap<CStringA, IHttpFile*, CStringElementTraits<CStringA> >& Files,
        CHttpRequestParams* pQueryParams, 
        DWORD dwFlags=ATL_FORM_FLAG_NONE) throw()
    {
        _ATLTRY
        {
            if (!InitializeParser())
            {
                return FALSE;
            }

            //Get to the first boundary
            if (!ReadUntilBoundary())
            {
                return FALSE;
            }
            
            CStringA strParamName;
            CStringA strFileName;
            CStringA strContentType;
            CStringA strData;
            BOOL bFound;

            while (!m_bFinished)
            {
                // look for "name" field
                if (!GetMimeData(strParamName, "name=", sizeof("name=")-1, &bFound) || !bFound)
                {
                    ATLTRACE(atlTraceISAPI, 0, _T("Malformed Form-Data"));
                    return FALSE;
                }
                
                // see if it's a file
                if (!GetMimeData(strFileName, "filename=", sizeof("filename=")-1, &bFound))
                {
                    ATLTRACE(atlTraceISAPI, 0, _T("Malformed Form-Data"));
                    return FALSE;
                }
                
                if (bFound)
                {
                    if (dwFlags & ATL_FORM_FLAG_REFUSE_FILES)
                    {
                        return FALSE;
                    }

                    if (!strFileName.GetLength())
                    {
                        ReadUntilBoundary();
                        continue;
                    }
                    
                    if (!GetMimeData(strContentType, "Content-Type:", sizeof("Content-Type:")-1, &bFound, TRUE))
                    {
                        ATLTRACE(atlTraceISAPI, 0, _T("Malformed Form-Data"));
                        return FALSE;
                    }
                    
                    // move to the actual uploaded data
                    if (!MoveToData())
                    {
                        ATLTRACE(atlTraceISAPI, 0, _T("Malformed Form-Data"));
                        return FALSE;
                    }

                    // if the user doesn't want files, don't save the file
                    if (dwFlags & ATL_FORM_FLAG_IGNORE_FILES)
                    {
                        if (!ReadUntilBoundary(NULL, NULL))
                        {
                            return FALSE;
                        }
                        continue;
                    }

                    CAtlTemporaryFile ctf;
                    HRESULT hr = ctf.Create();
                    if (hr != S_OK)
                        return FALSE;

                    if (!ReadUntilBoundary(NULL, &ctf))
                    {
                        ctf.Close();
                        return FALSE;
                    }
                    ULONGLONG nFileSize = 0;
                    if (ctf.GetSize(nFileSize) != S_OK)
                        return FALSE;

                    if ((dwFlags & ATL_FORM_FLAG_IGNORE_EMPTY_FILES) && nFileSize == 0)
                    {
                        ctf.Close();
                        continue;
                    }

                    //REVIEW: if exceptions are thrown, the temp file created by ctf is never removed
                    ctf.HandsOff();

                    //REVIEW: pFile always leaks
                    CHttpRequestFile* pFile = NULL;

                    CT2AEX<MAX_PATH+1> szTempFileNameA(ctf.TempFileName());

                    ATLTRY(pFile = new CHttpRequestFile(strParamName, strFileName, szTempFileNameA, strContentType, nFileSize));
                    if (!pFile)
                        return FALSE;

                    Files.SetAt(szTempFileNameA, pFile);
                    pQueryParams->SetAt(strParamName, szTempFileNameA);
                    continue;
                }
                
                // move to the actual uploaded data
                if (!MoveToData())
                {
                    ATLTRACE(atlTraceISAPI, 0, _T("Malformed Form-Data"));
                    return FALSE;
                }

                if (!ReadUntilBoundary(&strData))
                {
                    return FALSE;
                }

                if ((dwFlags & ATL_FORM_FLAG_IGNORE_EMPTY_FIELDS) && strData.GetLength() == 0)
                    continue;

                pQueryParams->SetAt(strParamName, strData);
            }

            return TRUE;
        }
        _ATLCATCHALL()
        {
            return FALSE;
        }
    }

protected:

    // case insensitive substring search -- does not handle multibyte characters
    // allows searching up to a maximum point in a string
    inline char AtlCharLower(char ch) throw()
    {
        if (ch > 64 && ch < 91)
        {
            return ch+32;
        }

        return ch;
    }

    inline char * _stristrex (const char * str1, const char * str2, const char * str1End) throw()
    {
        char *cp = (char *) str1;
        char *s1, *s2;

        if ( !*str2 )
            return((char *)str1);

        while (cp != str1End)
        {
            s1 = cp;
            s2 = (char *) str2;

            while ( s1 != str1End && *s2 && !(AtlCharLower(*s1)-AtlCharLower(*s2)) )
            {
                s1++, s2++;
            }

            if (s1 == str1End)
            {
                return (NULL);
            }

            if (!*s2)
            {
                return (cp);
            }

            cp++;
        }

        return(NULL);
    }

    inline char * _strstrex (const char * str1, const char * str2, const char * str1End) throw()
    {
        char *cp = (char *) str1;
        char *s1, *s2;

        if ( !*str2 )
            return((char *)str1);

        while (cp != str1End)
        {
            s1 = cp;
            s2 = (char *) str2;

            while ( s1 != str1End && *s2 && !((*s1)-(*s2)) )
            {
                s1++, s2++;
            }
            
            if (s1 == str1End)
            {
                return (NULL);
            }

            if (!*s2)
            {
                return (cp);
            }

            cp++;
        }

        return(NULL);
    }

    ATL_NOINLINE BOOL InitializeParser() throw()
    {
        DWORD dwBytesTotal = m_spServerContext->GetTotalBytes();
        
        // if greater than bytes available, allocate necessary space
        if (dwBytesTotal > m_spServerContext->GetAvailableBytes())
        {
			ATLTRYALLOC(m_pStart = (LPSTR) malloc(dwBytesTotal));
            if (!m_pStart)
            {
                return FALSE;
            }
            m_pCurrent = m_pStart;
            DWORD dwLen = dwBytesTotal;
            if (!ReadClientData(m_spServerContext, m_pStart, &dwLen, 0) || dwLen != dwBytesTotal)
            {
                return FALSE;
            }
        }
        else
        {
            m_pStart = (LPSTR) m_spServerContext->GetAvailableData();
        }
        
        m_pCurrent = m_pStart;
        m_pEnd = m_pCurrent + dwBytesTotal;
        
        //get the boundary
        LPCSTR pszContentType = m_spServerContext ? m_spServerContext->GetContentType() : NULL;
        ATLASSERT(pszContentType != NULL);

        LPCSTR pszTmp = strstr(pszContentType, "boundary=");
        if (!pszTmp)
        {
            ATLTRACE(atlTraceISAPI, 0, _T("Malformed Form-Data"));
            return FALSE;
        }

        pszTmp += sizeof("boundary=")-1;
        BOOL bInQuote = FALSE;
        if (*pszTmp == '\"')
        {
            bInQuote = TRUE;
            pszTmp++;
        }

        LPSTR pszMimeBoundary = m_szBoundary;
        *pszMimeBoundary++ = '-';
        *pszMimeBoundary++ = '-';
        m_dwBoundaryLen = 2;
        while (*pszTmp && (bInQuote || IsStandardBoundaryChar(*pszTmp)))
        {
            if (m_dwBoundaryLen >= MAX_MIME_BOUNDARY_LEN)
            {
                ATLTRACE(atlTraceISAPI, 0, _T("Malformed MIME boundary"));
                return FALSE;
            }
            
            if (*pszTmp == '\r' || *pszTmp == '\n')
            {
                if (bInQuote)
                {
                    pszTmp++;
                    continue;
                }
                break;
            }
            if (bInQuote && *pszTmp == '"')
            {
                break;
            }

            *pszMimeBoundary++ = *pszTmp++;
            m_dwBoundaryLen++;
        }
        
        *pszMimeBoundary = '\0';
        m_szSearchBoundary[0] = '\r';
        m_szSearchBoundary[1] = '\n';
        strcpy(m_szSearchBoundary+2, m_szBoundary);
        return TRUE;
    }

    inline BOOL MoveToData() throw()
    {
        LPSTR szEnd = _strstrex(m_pCurrent, "\r\n\r\n", m_pEnd);
        if (!szEnd)
        {
            return FALSE;
        }

        m_pCurrent = szEnd+4;
        if (m_pCurrent >= m_pEnd)
        {
            return FALSE;
        }

        return TRUE;
    }

    inline BOOL GetMimeData(CStringA &str, LPCSTR szField, DWORD dwFieldLen, LPBOOL pbFound, BOOL bIgnoreCase = FALSE) throw()
    {
        _ATLTRY
        {
            ATLASSERT( szField != NULL );
            ATLASSERT( pbFound != NULL );
            
            *pbFound = FALSE;
            
            LPSTR szEnd = _strstrex(m_pCurrent, "\r\n\r\n", m_pEnd);
            if (!szEnd)
            {
                return FALSE;
            }
            
            LPSTR szDataStart = NULL;
            
            if (!bIgnoreCase)
            {
                szDataStart = _strstrex(m_pCurrent, szField, szEnd);
            }
            else
            {
                szDataStart = _stristrex(m_pCurrent, szField, szEnd);
            }

            if (szDataStart)
            {
                szDataStart+= dwFieldLen;
                if (szDataStart >= m_pEnd)
                {
                    return FALSE;
                }
                
                BOOL bInQuote = FALSE;
                if (*szDataStart == '\"')
                {
                    bInQuote = TRUE;
                    szDataStart++;
                }
                
                LPSTR szDataEnd = szDataStart;
                while (!bInQuote && (szDataEnd < m_pEnd) && (*szDataEnd == ' ' || *szDataEnd == '\t'))
                {
                    szDataEnd++;
                }
                
                if (szDataEnd >= m_pEnd)
                {
                    return FALSE;
                }
                
                while (szDataEnd < m_pEnd)
                {
                    if (!IsValidTokenChar(*szDataEnd))
                    {
                        if (*szDataEnd == '\"' || !bInQuote)
                        {
                            break;
                        }
                    }
                    szDataEnd++;
                }
                
                if (szDataEnd >= m_pEnd)
                {
                    return FALSE;
                }
                
                LPSTR szOut = str.GetBuffer((int)(szDataEnd-szDataStart)+1);
                if (!szOut)
                {
                    str.ReleaseBuffer();
                    return FALSE;
                }
                memcpy(szOut, szDataStart, szDataEnd-szDataStart);
                szOut[szDataEnd-szDataStart] = '\0';
                str.ReleaseBuffer((int)(szDataEnd-szDataStart));
                *pbFound = TRUE;
            }
            
            return TRUE;
        }
        _ATLCATCHALL()
        {
            return FALSE;
        }
    }
    
    ATL_NOINLINE BOOL ReadUntilBoundary(CStringA* pStrData=NULL, CAtlTemporaryFile* pCtf=NULL) throw()
    {
        _ATLTRY
        {
            LPSTR szBoundaryStart = m_pCurrent;
            LPSTR szBoundaryEnd = NULL;
            
            do 
            {
                szBoundaryStart = _strstrex(szBoundaryStart, m_szBoundary, m_pEnd);
                if (szBoundaryStart != m_pStart)
                {
                    if ((szBoundaryStart-m_pStart) >= 2)
                    {
                        if (*(szBoundaryStart-1) != 0x0a && *(szBoundaryStart-2) != 0x0d)
                            continue;
                    }
                    else
                    {
                        return FALSE;
                    }
                }
                szBoundaryEnd = szBoundaryStart+m_dwBoundaryLen;
                if (szBoundaryEnd+2 >= m_pEnd)
                {
                    return FALSE;
                }
                if (szBoundaryEnd[0] == '\r' && szBoundaryEnd[1] == '\n')
                {
                    break;
                }
                if (szBoundaryEnd[0] == '-' && szBoundaryEnd[1] == '-')
                {
                    m_bFinished = TRUE;
                    break;
                }
            } while (szBoundaryStart);
            
            if (!szBoundaryStart)
            {
                return FALSE;
            }
            
            szBoundaryStart-= 2;
            if (pStrData)
            {
                LPSTR szData = pStrData->GetBuffer((int)(szBoundaryStart-m_pCurrent)+1);
                if (!szData)
                {
                    pStrData->ReleaseBuffer();
                    return FALSE;
                }
                memcpy(szData, m_pCurrent, (int)(szBoundaryStart-m_pCurrent));
                szData[szBoundaryStart-m_pCurrent] = '\0';
                pStrData->ReleaseBuffer((int)(szBoundaryStart-m_pCurrent));
            }
            if (pCtf)
            {
                if (FAILED(pCtf->Write(m_pCurrent, (DWORD)(szBoundaryStart-m_pCurrent))))
                {
                    return FALSE;
                }
            }
            
            if (!m_bFinished)
            {
                m_pCurrent = szBoundaryEnd+2;
                if (m_pCurrent >= m_pEnd)
                {
                    return FALSE;
                }
            }
            
            return TRUE;
        }
        _ATLCATCHALL()
        {
            return FALSE;
        }
    }

    static inline BOOL IsStandardBoundaryChar(CHAR ch) throw()
    {
        if ( (ch >= 'A' && ch <= 'Z') ||
             (ch >= 'a' && ch <= 'z') ||
             (ch >= '0' && ch <= '9') ||
             (ch == '\'') ||
             (ch == '+')  ||
             (ch == '_')  ||
             (ch == '-')  ||
             (ch == '=')  ||
             (ch == '?') )
        {
            return TRUE;
        }

        return FALSE;
    }

    inline IsValidTokenChar(CHAR ch) throw()
    {
        return ( (ch != 0) && (ch != 0xd) && (ch != 0xa) && (ch != ' ') && (ch != '\"') );
    }

private:
    // Prevents copying.
    CMultiPartFormParser(const CMultiPartFormParser& /*that*/) throw()
    {
        ATLASSERT(FALSE);
    }

    const CMultiPartFormParser& operator=(const CMultiPartFormParser& /*that*/) throw()
    {
        ATLASSERT(FALSE);
        return (*this);
    }
}; // class CMultiPartFormParser


// 48K max form size
#ifndef DEFAULT_MAX_FORM_SIZE
#define DEFAULT_MAX_FORM_SIZE 49152
#endif

// This class provides access to the information contained in an HTTP request submitted to a web server.
//
// CHttpRequest provides access to the query string parameters, form fields, cookies, and files
// that make up an HTTP request, as well as many other important properties of the request.
class CHttpRequest : public IHttpRequestLookup
{
protected:
    // Implementation: Array used to map an HTTP request method (for example, "GET" or "POST")
    // from a string to a numeric constant from the HTTP_METHOD enum (HTTP_METHOD_GET or HTTP_METHOD_HEAD).
    static LPCSTR m_szMethodStrings[];

    // Implementation: The server context.
    CComPtr<IHttpServerContext> m_spServerContext;

    // Implementation: The number of bytes read from the body of the request.
    DWORD m_dwBytesRead;

    // Implementation: TRUE if the request method was POST and the encoding was
    // multipart/form-data, FALSE otherwise.
    BOOL m_bMultiPart;

    // Implementation: Constructor function used to reinitialize all data members.
    void Construct() throw()
    {
        m_spServerContext.Release();
        m_bMultiPart = FALSE;
        m_dwBytesRead = 0;
        if (m_pFormVars != &m_QueryParams)
            delete m_pFormVars;

        m_pFormVars = NULL;
        m_pFormVars = &m_QueryParams;
        m_QueryParams.RemoveAll();
        m_QueryParams.SetShared(false);

        ClearFilesAndCookies();
    }

    void ClearFilesAndCookies() throw()
    {
        m_Files.RemoveAll();
        m_Files.SetShared(false);
        m_requestCookies.RemoveAll();
        m_requestCookies.SetShared(false);
    }

public:

	// Implementation: The collection of query parameters (name-value pairs) obtained from the query string.
    CHttpRequestParams m_QueryParams;

    // Implementation: The collection of form fields (name-value pairs).
    // The elements of this collection are obtained from the query string for a GET request,
    // or from the body of the request for a POST request.
    CHttpRequestParams *m_pFormVars;

    // The array of CHttpRequestFiles obtained from the current request.
    // See CHttpRequest::Initialize and CMultiPartFormParser::GetMultiPartData for more information.
    typedef CHttpPtrMap<CStringA, IHttpFile*, CStringElementTraits<CStringA> > FileMap;
    FileMap m_Files;

    // Implementation: The array of cookies obtained from the current request.
    typedef CHttpMap<CStringA, CCookie, CStringElementTraits<CStringA> > CookieMap;
    CookieMap m_requestCookies;

    // Numeric constants for the HTTP request methods (such as GET and POST).
    enum HTTP_METHOD 
    {
        HTTP_METHOD_UNKNOWN=-1,
        HTTP_METHOD_GET,
        HTTP_METHOD_POST,
        HTTP_METHOD_HEAD,
        HTTP_METHOD_DELETE,
        HTTP_METHOD_LINK,
        HTTP_METHOD_UNLINK,
        HTTP_METHOD_DEBUG  // Debugging support for VS7
    };

    // The collection of query parameters (name-value pairs) obtained from the query string.
    // A read-only property.
    __declspec(property(get=GetQueryParams)) const CHttpRequestParams& QueryParams;

    // Returns a reference to the collection of query parameters(name-value pairs) 
    // obtained from the query string.
    const CHttpRequestParams& GetQueryParams() const throw()
    {
        return m_QueryParams;
    }

    // The collection of form fields (name-value pairs).
    // The elements of this collection are obtained from the query string for a GET request,
    // or from the body of the request for a POST request.
    // A read-only property.
    __declspec(property(get=GetFormVars)) const CHttpRequestParams& FormVars;

    // Returns a reference to the collection of form fields (name-value pairs)
    // obtained from the query string for a GET request,
    // or from the body of the request for a POST request.
    const CHttpRequestParams& GetFormVars() const throw()
    {
        return *m_pFormVars;
    }

    // The default constructor.
    CHttpRequest() throw()
        :m_pFormVars(NULL)
    {
        Construct();
    }

    // Implementation: The destructor.
    ~CHttpRequest() throw()
    {
        DeleteFiles();
        ClearFilesAndCookies();

        if (m_pFormVars != &m_QueryParams)
        {
            delete m_pFormVars;
            m_pFormVars = NULL;
        }
    }

    // Constructs and initializes the object.
    CHttpRequest(
        IHttpServerContext *pServerContext,
        DWORD dwMaxFormSize=DEFAULT_MAX_FORM_SIZE,
        DWORD dwFlags=ATL_FORM_FLAG_NONE) throw(...)
        :m_pFormVars(NULL)
    {
        Construct();
        if (!Initialize(pServerContext, dwMaxFormSize, dwFlags))
			AtlThrow(E_FAIL);
    }

    CHttpRequest(IHttpRequestLookup *pRequestLookup) throw(...)
        :m_pFormVars(NULL)
    {
        if (!Initialize(pRequestLookup)) // Calls Construct for you
			AtlThrow(E_FAIL);
    }

    //=========================================================================================
    // BEGIN IHttpRequestLoookup interface
    //=========================================================================================
    POSITION GetFirstQueryParam(LPCSTR *ppszName, LPCSTR *ppszValue) const throw()
    {
        ATLASSERT(ppszName != NULL);
        ATLASSERT(ppszValue != NULL);

        POSITION pos = m_QueryParams.GetStartPosition();
        if (pos != NULL)
        {
            *ppszName = m_QueryParams.GetKeyAt(pos);
            *ppszValue = m_QueryParams.GetValueAt(pos);
        }

        return pos;
    }

    POSITION GetNextQueryParam(POSITION pos, LPCSTR *ppszName, LPCSTR *ppszValue) const throw()
    {
        ATLASSERT(pos != NULL);
        ATLASSERT(ppszName != NULL);
        ATLASSERT(ppszValue != NULL);

        POSITION posNext(pos);
        m_QueryParams.GetNext(posNext);
        if (posNext != NULL)
        {
            *ppszName = m_QueryParams.GetKeyAt(posNext);
            *ppszValue = m_QueryParams.GetValueAt(posNext);
        }

        return posNext;
    }

    POSITION GetFirstFormVar(LPCSTR *ppszName, LPCSTR *ppszValue) const throw()
    {
        ATLASSERT(ppszName != NULL);
        ATLASSERT(ppszValue != NULL);

        // if no form vars and just pointing to the query params,
        // then return NULL
        if (m_pFormVars == &m_QueryParams)
            return NULL;
        
        POSITION pos = m_pFormVars->GetStartPosition();
        if (pos != NULL)
        {
            *ppszName = m_pFormVars->GetKeyAt(pos);
            *ppszValue = m_pFormVars->GetValueAt(pos);
        }

        return pos;
    }

    POSITION GetNextFormVar(POSITION pos, LPCSTR *ppszName, LPCSTR *ppszValue) const throw()
    {
        ATLASSERT(pos != NULL);
        ATLASSERT(ppszName != NULL);
        ATLASSERT(ppszValue != NULL);

        POSITION posNext(pos);
        m_pFormVars->GetNext(posNext);
        if (posNext != NULL)
        {
            *ppszName = m_pFormVars->GetKeyAt(posNext);
            *ppszValue = m_pFormVars->GetValueAt(posNext);
        }

        return posNext;
    }

    POSITION GetFirstFile(LPCSTR *ppszName, IHttpFile **ppFile) const throw()
    {
        ATLASSERT(ppszName != NULL);
        ATLASSERT(ppFile != NULL);

        POSITION pos = m_Files.GetStartPosition();
        if (pos != NULL)
        {
            *ppszName = m_Files.GetKeyAt(pos);
            *ppFile = m_Files.GetValueAt(pos);
        }

        return pos;
    }

    POSITION GetNextFile(POSITION pos, LPCSTR *ppszName, IHttpFile **ppFile) const throw()
    {
        ATLASSERT(pos != NULL);
        ATLASSERT(ppszName != NULL);
        ATLASSERT(ppFile != NULL);

        POSITION posNext(pos);
        m_Files.GetNext(posNext);
        if (posNext != NULL)
        {
            *ppszName = m_Files.GetKeyAt(posNext);
            *ppFile = m_Files.GetValueAt(posNext);
        }

        return posNext;
    }

    POSITION GetFirstCookie(LPCSTR *ppszName, const CCookie **ppCookie) throw()
    {
        ATLASSERT(ppszName != NULL);
        ATLASSERT(ppCookie != NULL);
        POSITION pos = NULL;
        if (GetRequestCookies())
        {
            pos = m_requestCookies.GetStartPosition();
            if (pos != NULL)
            {
                *ppszName = m_requestCookies.GetKeyAt(pos);
                *ppCookie = &(m_requestCookies.GetValueAt(pos));
            }
        }
        return pos;
    }

    POSITION GetNextCookie(POSITION pos, LPCSTR *ppszName, const CCookie **ppCookie) throw()
    {
        ATLASSERT(pos != NULL);
        ATLASSERT(ppszName != NULL);
        ATLASSERT(ppCookie != NULL);

        POSITION posNext(pos);
        m_requestCookies.GetNext(posNext);
        if (posNext != NULL)
        {
            *ppszName = m_requestCookies.GetKeyAt(posNext);
            *ppCookie = &(m_requestCookies.GetValueAt(posNext));
        }
        return posNext;
    }

    // Returns a pointer to the IHttpServerContext interface for the current request.
    HRESULT GetServerContext(IHttpServerContext ** ppOut) throw()
    {
        return m_spServerContext.CopyTo(ppOut);
    }
    //=========================================================================================
    // END IHttpRequestLookup interface
    //=========================================================================================

    void SetServerContext(IHttpServerContext *pServerContext) throw()
    {
        m_spServerContext = pServerContext;
    }

    BOOL Initialize(IHttpRequestLookup *pRequestLookup) throw()
    {
		_ATLTRY
		{	
			ATLASSERT(pRequestLookup != NULL);
			// if there's no pRequestLookup, just return
			if (!pRequestLookup)
				return TRUE;

			Construct();
			HRESULT hr = pRequestLookup->GetServerContext(&m_spServerContext);
			if (FAILED(hr))
				return FALSE;

			LPCSTR szName(NULL);
			LPCSTR szValue(NULL);

			// Initialize query params from the IHttpRequestLookup*
			POSITION pos(pRequestLookup->GetFirstQueryParam(&szName, &szValue));
			while (pos != NULL)
			{
				m_QueryParams.SetAt(szName, szValue);
				pos = pRequestLookup->GetNextQueryParam(pos, &szName, &szValue);
			}
			m_QueryParams.SetShared(true);

			// Initialize the form vars from the IHttpRequestLookup*
			pos = pRequestLookup->GetFirstFormVar(&szName, &szValue);
			if (pos)
			{
				m_pFormVars = NULL;
				ATLTRY(m_pFormVars = new CHttpRequestParams);
				if (!m_pFormVars)
					return FALSE;

				while (pos != NULL)
				{
					m_pFormVars->SetAt(szName, szValue);
					pos = pRequestLookup->GetNextFormVar(pos, &szName, &szValue);
				}
				m_pFormVars->SetShared(true);
			}
			else
			{
				m_pFormVars = &m_QueryParams;
			}

			// Initialize the files from the IHttpRequestLookup*
			IHttpFile *pFile(NULL);
			pos = pRequestLookup->GetFirstFile(&szName, &pFile);
			while (pos != NULL)
			{
				m_Files.SetAt(szName, pFile);
				pos = pRequestLookup->GetNextFile(pos, &szName, &pFile);
			}
			m_Files.SetShared(true);

			// Initialzie the cookies form the IHttpRequestLookup*
			BOOL bRet = FALSE;
			CStringA strCookies;
			bRet = GetCookies(strCookies);
			if (bRet)
			{
				bRet = Parse((LPSTR)(LPCSTR)strCookies);
			}
			m_requestCookies.SetShared(false);
			return bRet;
		} // _ATLTRY
		_ATLCATCHALL()
		{
		}
		return FALSE;
    }

    // Call this function to initialize the object with information about the current request.
    //
    // Returns TRUE on success, FALSE on failure.
    //
    // Call Initialize directly or via the appropriate constructor before using the methods and
    // properties of the request object.
    //
    // Initialize does the following:
    //
    //      Parses and decodes the query string into a collection of name-value pairs.
    //      This collection is accessible via the GetQueryParams method or the QueryParams property.
    //
    //      Sets m_bMultiPart to TRUE if the request is a POST request with multipart/form-data encoding.
    //
    //      Parses the body of a POST request if the size of the request data is less than or equal to dwMaxFormSize.
    //      The body of the request will consist of simple form fields and may also contain files if the request is encoded as multipart/form-data.
    //      In that case, the dwFlags parameter is passed to CMultiPartFormParser::GetMultiPartData to control the creation of the files.
    //      The collection of form fields is accessible via the GetFormVars method or the FormVars property.
    //      The collection of files is accessible via the m_Files member.
    //
    // Note that Initialize does not parse the cookies associated with a request.
    // Cookies are not processed until an attempt is made to access a cookie in the collection.
    BOOL Initialize(
        IHttpServerContext *pServerContext,
        DWORD dwMaxFormSize=DEFAULT_MAX_FORM_SIZE,
        DWORD dwFlags=ATL_FORM_FLAG_NONE) throw()
    {
		_ATLTRY
		{
			ATLASSERT(pServerContext != NULL);
			if (!pServerContext)
				return FALSE;

			m_spServerContext = pServerContext;

			HTTP_METHOD httpMethod = GetMethod();

			// Parse the query string.
			CHAR szQueryString[ATL_URL_MAX_URL_LENGTH];
			strcpy(szQueryString, GetQueryString());
			if (!m_QueryParams.Parse(szQueryString))
				return FALSE;

			if (m_QueryParams.IsShared())
				return TRUE;

			// If this is a GET request, the collection of form fields
			// is the same as the collection of query parameters.
			if (httpMethod == HTTP_METHOD_GET)
				m_pFormVars = &m_QueryParams;
			else if (httpMethod == HTTP_METHOD_POST)
			{
				LPCSTR szContentType = GetContentType();
				if (!szContentType)
					return FALSE;

				// Don't parse the form data if the size is bigger than the maximum specified.
				if (m_spServerContext->GetTotalBytes() > dwMaxFormSize)
				{
					if (memcmp(szContentType, "multipart/form-data", 19) == 0)
						m_bMultiPart = TRUE;

					m_dwBytesRead = 0;

					// REVIEW : We have to assume the developer knows what they're doing to
					// some extent here.
					return TRUE;
				}

				// If POSTed data is urlencoded, call InitFromPost.
				if (memcmp(szContentType, "application/x-www-form-urlencoded", 33) == 0 && !m_pFormVars->IsShared())
					return InitFromPost();

				// If POSTed data is encoded as multipart/form-data, use CMultiPartFormParser.
				if (memcmp(szContentType, "multipart/form-data", 19) == 0 && !m_pFormVars->IsShared())
				{
					if (m_pFormVars != &m_QueryParams)
						delete m_pFormVars;
					m_pFormVars = NULL;

					CMultiPartFormParser FormParser(m_spServerContext);
					ATLTRY(m_pFormVars = new CHttpRequestParams);
					if (!m_pFormVars)
						return FALSE;

					BOOL bRet = FormParser.GetMultiPartData(m_Files, m_pFormVars, dwFlags);
					return bRet;
				}

				// else initialize m_dwBytesRead for ReadData
				m_dwBytesRead = 0;
			}

			return TRUE;
		}
		_ATLCATCHALL()
		{
		}
		return FALSE;

    }

    // Implementation: Call this function to initialize the collection of form fields
    // from the body of an application/x-www-form-urlencoded POST request.
    ATL_NOINLINE BOOL InitFromPost() throw()
    {
		_ATLTRY
		{
			ATLASSERT(m_spServerContext != NULL);

			// create our m_pFormVars
			if (m_pFormVars == NULL || m_pFormVars == &m_QueryParams)
			{
				ATLTRY(m_pFormVars = new CHttpRequestParams);
				if (m_pFormVars == NULL)
				{
					return FALSE;
				}
			}   

			// read the form data into a buffer
			DWORD dwBytesTotal = m_spServerContext->GetTotalBytes();
			CAutoVectorPtr<CHAR> szBuff;
			if (!szBuff.Allocate(dwBytesTotal+1))
			{
				return FALSE;
			}
			// first copy the available
			BOOL bRet = ReadClientData(m_spServerContext, szBuff, &dwBytesTotal, 0);
			if (bRet)
			{
				szBuff[dwBytesTotal] = '\0';
				bRet = m_pFormVars->Parse(szBuff);
			}

			return bRet;
		}
		_ATLCATCHALL()
		{
		}
		return FALSE;
    }

    // Call this function to remove the files listed in m_Files from the web server's hard disk.
    // Returns the number of files deleted.
    int DeleteFiles() throw()
    {
        int nDeleted = 0;
        POSITION pos = m_Files.GetStartPosition();
        while (pos != NULL)
        {
            LPCSTR szTempFile = m_Files.GetKeyAt(pos);
            if (szTempFile && DeleteFileA(szTempFile))
            {
                nDeleted++;
            }
            m_Files.GetNext(pos);
        }

        return nDeleted;
    }

    // Read a specified amount of data into pbDest and return the bytes read in pdwLen.
    // Returns TRUE on success, FALSE on failure.
    BOOL ReadData(LPSTR pDest, LPDWORD pdwLen) throw()
    {
        ATLASSERT(pDest);
        ATLASSERT(pdwLen);

        BOOL bRet = ReadClientData(m_spServerContext, pDest, pdwLen, m_dwBytesRead);
        if (bRet)
            m_dwBytesRead+= *pdwLen;
        return bRet;
    }

    // Returns the number of bytes available in the request buffer accessible via GetAvailableData.
    // If GetAvailableBytes returns the same value as GetTotalBytes, the request buffer contains the whole request.
    // Otherwise, the remaining data should be read from the client using ReadData.
    // Equivalent to EXTENSION_CONTROL_BLOCK::cbAvailable.
    DWORD GetAvailableBytes() throw()
    {
        return m_spServerContext ? m_spServerContext->GetAvailableBytes() : 0;
    }

    // Returns the total number of bytes to be received from the client.
    // If this value is 0xffffffff, then there are four gigabytes or more of available data.
    // In this case, ReadData should be called until no more data is returned.
    // Equivalent to the CONTENT_LENGTH server variable or EXTENSION_CONTROL_BLOCK::cbTotalBytes. 
    DWORD GetTotalBytes() throw()
    {
        return m_spServerContext ? m_spServerContext->GetTotalBytes() : 0;
    }

    // Returns a pointer to the request buffer containing the data sent by the client.
    // The size of the buffer can be determined by calling GetAvailableBytes.
    // Equivalent to EXTENSION_CONTROL_BLOCK::lpbData
    LPBYTE GetAvailableData() throw()
    {
        return m_spServerContext ? m_spServerContext->GetAvailableData() : NULL;
    }


    // Returns a nul-terminated string that contains the query information.
    // This is the part of the URL that appears after the question mark (?). 
    // Equivalent to the QUERY_STRING server variable or EXTENSION_CONTROL_BLOCK::lpszQueryString.
    LPCSTR GetQueryString() throw()
    {
        return m_spServerContext ? m_spServerContext->GetQueryString() : NULL;
    }

    // Returns a nul-terminated string that contains the HTTP method of the current request.
    // Examples of common HTTP methods include "GET" and "POST".
    // Equivalent to the REQUEST_METHOD server variable or EXTENSION_CONTROL_BLOCK::lpszMethod.
    LPCSTR GetMethodString() throw()
    {
        return m_spServerContext ? m_spServerContext->GetRequestMethod() : NULL;
    }

    // Returns an HTTP_METHOD enum value corresponding to the HTTP method of the current request.
    // Returns HTTP_METHOD_UNKNOWN if the request method is not one of the following methods:
    //      GET
    //      POST
    //      HEAD
    //      DELETE
    //      LINK
    //      UNLINK
    HTTP_METHOD GetMethod() throw()
    {
        LPCSTR szMethod = GetMethodString();
        if (!szMethod)
            return HTTP_METHOD_UNKNOWN;
        for (int i=0; m_szMethodStrings[i]; i++)
        {
            if (strcmp(szMethod, m_szMethodStrings[i]) == 0)
                return (HTTP_METHOD) i;
        }
        return HTTP_METHOD_UNKNOWN;
    }

    // Returns a nul-terminated string that contains the content type of the data sent by the client.
    // Equivalent to the CONTENT_TYPE server variable or EXTENSION_CONTROL_BLOCK::lpszContentType.
    LPCSTR GetContentType() throw()
    {
        return m_spServerContext ? m_spServerContext->GetContentType() : NULL;
    }


    // Call this function to retrieve a nul-terminated string containing the value of the "AUTH_USER" server variable.
    //
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    //
    // On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
    // On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
    BOOL GetAuthUserName(LPSTR szBuff, DWORD *pdwSize) throw()
    {
        return m_spServerContext ? m_spServerContext->GetServerVariable("AUTH_USER", szBuff, pdwSize) :
            FALSE;
    }
    
    // Call this function to retrieve a nul-terminated string containing the value of the "APPL_PHYSICAL_PATH" server variable.
    //
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    //
    // On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
    // On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
    BOOL GetPhysicalPath(LPSTR szBuff, DWORD *pdwSize) throw()
    {
        return m_spServerContext ? m_spServerContext->GetServerVariable("APPL_PHYSICAL_PATH", szBuff, pdwSize) :
            FALSE;
    }

    // Call this function to retrieve a nul-terminated string containing the value of the "AUTH_PASSWORD" server variable.
    //
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    //
    // On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
    // On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
    BOOL GetAuthUserPassword(LPSTR szBuff, DWORD *pdwSize) throw()
    {
        return m_spServerContext ? m_spServerContext->GetServerVariable("AUTH_PASSWORD", szBuff, pdwSize) :
            FALSE;
    }

    // Call this function to retrieve a nul-terminated string containing the value of the "URL" server variable.
    //
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    //
    // On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
    // On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
    BOOL GetUrl(LPSTR szBuff, DWORD *pdwSize) throw()
    {
        return m_spServerContext ? m_spServerContext->GetServerVariable("URL", szBuff, pdwSize) :
            FALSE;
    }

    // Call this function to retrieve a nul-terminated string containing the value of the "REMOTE_HOST" server variable.
    //
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    //
    // On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
    // On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
    BOOL GetUserHostName(LPSTR szBuff, DWORD *pdwSize) throw()
    {
        return m_spServerContext ? m_spServerContext->GetServerVariable("REMOTE_HOST", szBuff, pdwSize) :
            FALSE;
    }

    // Call this function to retrieve a nul-terminated string containing the value of the "REMOTE_ADDR" server variable.
    //
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    //
    // On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
    // On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
    BOOL GetUserHostAddress(LPSTR szBuff, DWORD *pdwSize) throw()
    {
        return m_spServerContext ? m_spServerContext->GetServerVariable("REMOTE_ADDR", szBuff, pdwSize) :
            FALSE;
    }

    // Call this function to retrieve a nul-terminated string containing the physical path of the script.
    //
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    //
    // On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
    // On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
    // The script path is the same as GetPathTranslated up to the first .srf or .dll.
    // For example, if GetPathTranslated returns "c:\inetpub\vcisapi\hello.srf\goodmorning",
    // then this function returns "c:\inetpub\vcisapi\hello.srf".
    LPCSTR GetScriptPathTranslated() throw()
    {
        return m_spServerContext ? m_spServerContext->GetScriptPathTranslated() : NULL;
    }

    // Returns a nul-terminated string that contains the physical path of the requested resource on the local server.
    // Equivalent to the PATH_TRANSLATED server variable or EXTENSION_CONTROL_BLOCK::lpszPathTranslated.
    LPCSTR GetPathTranslated() throw()
    {
        return m_spServerContext ? m_spServerContext->GetPathTranslated() : NULL;
    }

    // Returns a nul-terminated string that contains the path of the current request.
    // This is the part of the URL that appears after the server name, but before the query string.
    // Equivalent to the PATH_INFO server variable or EXTENSION_CONTROL_BLOCK::lpszPathInfo.
    LPCSTR GetPathInfo() throw()
    {
        return m_spServerContext ? m_spServerContext->GetPathInfo() : NULL;
    }

    // Call this function to determine whether the current request was authenticated.
    // Returns TRUE if the authentication type is one of the following:
    //      BASIC
    //      NTLM
    //      Negotiate
    // Returns FALSE otherwise.
    BOOL GetAuthenticated() throw(...)
    {
		// check for basic or NTLM authentication
		CStringA strAuthType;
		if (GetAuthenticationType(strAuthType) &&
				(strAuthType == "BASIC" ||
				strAuthType == "NTLM" ||
				strAuthType == "Negotiate"))
			return TRUE;

		return FALSE;
    }

    // Call this function to retrieve a nul-terminated string containing the value of the "AUTH_TYPE" server variable.
    //
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    //
    // On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
    // On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
    BOOL GetAuthenticationType(LPSTR szBuff, DWORD *pdwSize) throw()
    {
        return m_spServerContext ? m_spServerContext->GetServerVariable("AUTH_TYPE", szBuff, pdwSize) :
            FALSE;
    }

    // Call this function to retrieve a nul-terminated string containing the value of the "REMOTE_USER" server variable.
    //
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    //
    // On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
    // On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
    BOOL GetUserName(LPSTR szBuff, DWORD *pdwSize) throw()
    {
        return m_spServerContext ? m_spServerContext->GetServerVariable("REMOTE_USER", szBuff, pdwSize) :
            FALSE;
    }

    // Call this function to retrieve a nul-terminated string containing the value of the "HTTP_USER_AGENT" server variable.
    //
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    //
    // On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
    // On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
     BOOL GetUserAgent(LPSTR szBuff, DWORD *pdwSize) throw()
     {
        return m_spServerContext ? m_spServerContext->GetServerVariable("HTTP_USER_AGENT", szBuff, pdwSize) :
            FALSE;
     }

    // Call this function to retrieve a nul-terminated string containing the value of the "HTTP_ACCEPT_LANGUAGE" server variable.
    //
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    //
    // On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
    // On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
     BOOL GetUserLanguages(LPSTR szBuff, DWORD *pdwSize) throw()
     {
        return m_spServerContext ? m_spServerContext->GetServerVariable("HTTP_ACCEPT_LANGUAGE", szBuff, pdwSize) :
            FALSE;
     }

    // Call this function to retrieve a nul-terminated string containing the value of the "HTTP_ACCEPT" server variable.
    //
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    //
    // On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
    // On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
    BOOL GetAcceptTypes(LPSTR szBuff, DWORD *pdwSize) throw()
    {
        return m_spServerContext ? m_spServerContext->GetServerVariable("HTTP_ACCEPT", szBuff, pdwSize) :
            FALSE;
    }

    // Call this function to retrieve a nul-terminated string containing the value of the "HTTP_ACCEPT_ENCODING" server variable.
    //
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    //
    // On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
    // On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
    BOOL GetAcceptEncodings(LPSTR szBuff, DWORD *pdwSize) throw()
    {
        return m_spServerContext ? m_spServerContext->GetServerVariable("HTTP_ACCEPT_ENCODING", szBuff, pdwSize) :
            FALSE;
    }


    // Call this function to retrieve a nul-terminated string containing the value of the "HTTP_REFERER" server variable.
    //
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    //
    // On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
    // On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
    BOOL GetUrlReferer(LPSTR szBuff, DWORD *pdwSize) throw()
    {
        return m_spServerContext ? m_spServerContext->GetServerVariable("HTTP_REFERER", szBuff, pdwSize) :
            FALSE;
    }

    // Call this function to retrieve a nul-terminated string containing the value of the "SCRIPT_NAME" server variable.
    //
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    //
    // On entry, pdwSize should point to a DWORD that indicates the size of the buffer in bytes.
    // On exit, the DWORD contains the number of bytes transferred or available to be transferred into the buffer (including the nul-terminating byte).
    BOOL GetScriptName(LPSTR szBuff, DWORD *pdwSize) throw()
    {
        return m_spServerContext ? m_spServerContext->GetServerVariable("SCRIPT_NAME", szBuff, pdwSize) :
            FALSE;
    }

    // Fills a buffer with the contents of the HTTP_COOKIE headers sent
    // from the browser.
    BOOL GetCookies(LPSTR szBuf, LPDWORD pdwSize) const throw()
    {
        ATLASSERT(pdwSize != NULL);
        ATLASSERT(szBuf != NULL);

        CStringA strCookie;
        if (GetCookies(strCookie))
        {
            if (pdwSize && *pdwSize > (DWORD)strCookie.GetLength())
            {
                strcpy(szBuf, strCookie);
                *pdwSize = strCookie.GetLength();
                return true;
            }
        }
        return false;
    }

    // Fills a CStringA with the contents of the HTTP_COOKIE headers sent
    // from the browser.
    BOOL GetCookies(CStringA& strBuff) const throw()
    {
        return GetServerVariable("HTTP_COOKIE", strBuff);
    }

    // Call this function to retrieve a reference to the specified cookie.
    // Returns a CCookie reference to the specified cookie or a
    // reference to an empty cookie if the name can not be found.
    ATL_NOINLINE const CCookie& Cookies(LPCSTR szName) throw()
    {
        static CCookie m_EmptyCookie;
        if (GetRequestCookies())
        {
            // p->m_value is a const CCookie&
            CookieMap::CPair *p = m_requestCookies.Lookup(szName);
            if (p)
            {
                return p->m_value;
            }
        }
        return m_EmptyCookie;
    }


    // Call this function to retrieve the session cookie.
    const CCookie& GetSessionCookie() throw()
    {
        return Cookies(SESSION_COOKIE_NAME);
    }

    // Call this function to retrieve the value of the requested server variable in a CStringA object.
    // Returns TRUE on success, and FALSE on failure. Call GetLastError to get extended error information.
    // Equivalent to EXTENSION_CONTROL_BLOCK::GetServerVariable.
    BOOL GetServerVariable(LPCSTR szVariable, CStringA &str) const throw()
    {
        if (!m_spServerContext)
            return FALSE;

        DWORD dwSize = 0;
		BOOL bRet = FALSE;
		_ATLTRY
		{
			m_spServerContext->GetServerVariable(szVariable, NULL, &dwSize);
			bRet = m_spServerContext->GetServerVariable(szVariable, str.GetBuffer(dwSize), &dwSize);
			if (dwSize > 0)
				dwSize--;
			str.ReleaseBuffer(dwSize);
		}
		_ATLCATCHALL()
		{
			bRet = FALSE;
		}
        return bRet;
    }

    // Call this function to retrieve the value of the "APPL_PHYSICAL_PATH" server variable.
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    BOOL GetPhysicalPath(CStringA &str) throw()
    {
        return GetServerVariable("APPL_PHYSICAL_PATH", str);
    }

    // Call this function to retrieve the value of the "REMOTE_HOST" server variable.
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    BOOL GetUserHostName(CStringA &str) throw()
    {
        return GetServerVariable("REMOTE_HOST", str);
    }

    // Call this function to retrieve the value of the "REMOTE_ADDR" server variable.
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    BOOL GetUserHostAddress(CStringA &str) throw()
    {
        return GetServerVariable("REMOTE_ADDR", str);
    }

    // Call this function to retrieve the value of the "AUTH_TYPE" server variable.
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    BOOL GetAuthenticationType(CStringA &str) throw()
    {
        return GetServerVariable("AUTH_TYPE", str);
    }

    // Call this function to retrieve the value of the "REMOTE_USER" server variable.
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    BOOL GetUserName(CStringA &str) throw()
    {
        return GetServerVariable("REMOTE_USER", str);
    }

    // Call this function to retrieve the value of the "HTTP_USER_AGENT" server variable.
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    BOOL GetUserAgent(CStringA &str) throw()
    {
        return GetServerVariable("HTTP_USER_AGENT", str);
    }

    // Call this function to retrieve the value of the "HTTP_ACCEPT_LANGUAGE" server variable.
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    BOOL GetUserLanguages(CStringA &str) throw()
    {
        return GetServerVariable("HTTP_ACCEPT_LANGUAGE", str);
    }

    // Call this function to retrieve the value of the "AUTH_USER" server variable.
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    BOOL GetAuthUserName(CStringA &str) throw()
    {
        return GetServerVariable("AUTH_USER", str);
    }

    // Call this function to retrieve the value of the "AUTH_PASSWORD" server variable.
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    BOOL GetAuthUserPassword(CStringA &str) throw()
    {
        return GetServerVariable("AUTH_PASSWORD", str);
    }

    // Call this function to retrieve the value of the "URL" server variable.
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    BOOL GetUrl(CStringA &str) throw()
    {
        return GetServerVariable("URL", str);
    }

    // Call this function to retrieve the value of the "HTTP_ACCEPT" server variable.
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    BOOL GetAcceptTypes(CStringA &str) throw()
    {
        return GetServerVariable("HTTP_ACCEPT", str);
    }

    // Call this function to retrieve the value of the "HTTP_ACCEPT_ENCODING" server variable.
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    BOOL GetAcceptEncodings(CStringA& str) throw()
    {
        return GetServerVariable("HTTP_ACCEPT_ENCODING", str);
    }

    // Call this function to retrieve the value of the "HTTP_REFERER" server variable.
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    BOOL GetUrlReferer(CStringA &str) throw()
    {
        return GetServerVariable("HTTP_REFERER", str);
    }

    // Call this function to retrieve the value of the "SCRIPT_NAME" server variable.
    // Returns TRUE on success, FALSE on failure. Call GetLastError to get extended error information.
    BOOL GetScriptName(CStringA &str) throw()
    {
        return GetServerVariable("SCRIPT_NAME", str);
    }

    // Implementation: Call this function to populate the collection 
    // of CCookie objects with the cookies in the current request.
    // Returns TRUE on success, FALSE on failure.
    BOOL GetRequestCookies() throw()
    {
        BOOL bRet = FALSE;

        if (m_requestCookies.GetCount())
            return TRUE; // we already got the cookies!

        CStringA strCookies;
        if (GetCookies(strCookies))
        {
            bRet = Parse((LPSTR)(LPCSTR)strCookies);
        }
        return bRet;
    }

    // Implementation: Call this function to populate m_requestCookies
    // with a collection of CCookie objects which represents the
    // cookies contained in szCookie header sent from the browser.
    BOOL Parse(LPSTR szCookieIn) throw()
    {
        // The browser only sends back the data for the
        // cookie, separated by ';'. Parse out all of the cookies
        // in the cookie string and create CCookie's out of them which
        // we add to our array of CCookies
        // example 1: Param1=Value1; hello=world&right=wrong&the+direction=west;
        // example 2: hello=world

        if (!szCookieIn)
            return FALSE;
        LPSTR pEnd = szCookieIn;
        LPSTR pStart = szCookieIn;
        CStringA strCookieName;
		_ATLTRY
		{
			while (1)
			{
				if (*pEnd == '\0' || *pEnd == ';')
				{
					CCookie c;
					if (c.Parse(pStart))
					{
						if (c.GetName(strCookieName))
							m_requestCookies.SetAt(strCookieName, c);
					}

					if (*pEnd)
						pStart = pEnd+1;
				}
				if (*pEnd == '\0')
					break;
				pEnd++;
			}
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
        return TRUE;
    }

    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppv) throw()
    {
        if (!ppv)
            return E_POINTER;
        if (InlineIsEqualGUID(riid, __uuidof(IHttpRequestLookup)))
        {
            *ppv = static_cast<IUnknown*>(static_cast<IHttpRequestLookup*>(this));
            AddRef();
            return S_OK;
        }
        if (InlineIsEqualGUID(riid, __uuidof(IUnknown)))
        {
            *ppv = static_cast<IUnknown*>(this);
            AddRef();
            return S_OK;
        }
        return E_NOINTERFACE;
    }
    
    ULONG STDMETHODCALLTYPE AddRef() throw()
    {
        return 1;
    }
    
    ULONG STDMETHODCALLTYPE Release() throw()
    {
        return 1;
    }
}; // class CHttpRequest

LPCSTR __declspec(selectany) CHttpRequest::m_szMethodStrings[] = {
    "GET",
    "POST",
    "HEAD",
    "DELETE",
    "LINK",
    "UNLINK",
    "DEBUG",  // Debugging support for VS7
    NULL
};

// This class provides type conversions via the Write method
// and overloaded left shift << operator for writing
// data to the IWriteStream interface. The IWriteStream interface
// only accepts strings, but this helper class allows you to transparently
// pass many different types by providing automatic type conversions.
//
// Notes on Type Conversions:
//      Numeric types are converted to their decimal representations.
//      Floating point values are output with a precision of 6 decimal places.
//      Currency values are converted according to the locale settings of the current thread.
class CWriteStreamHelper
{
protected:
    // Implementation: The IWriteStream interface.
    IWriteStream *m_pStream;

public:
    // The default constructor.
    CWriteStreamHelper() throw()
        :m_pStream(NULL)
    {
    }

    // The constructor.
    CWriteStreamHelper(IWriteStream *pStream) throw()
    {
        m_pStream = pStream;
    }

    // Attach a IWriteStream
    IWriteStream *Attach(IWriteStream *pStream) throw()
    {
        IWriteStream *pRetStream = m_pStream;
        m_pStream = pStream;
        return pRetStream;
    }

    // Call this function to write data to the IWriteStream interface managed by this object.
    // Returns TRUE on success, FALSE on failure.
    BOOL Write(LPCSTR szOut) throw()
    {
        if (!szOut)
            return FALSE;

        DWORD dwWritten;
        return SUCCEEDED(m_pStream->WriteStream(szOut, (int) strlen(szOut), &dwWritten));
    }

    // Call this function to write data to the IWriteStream interface managed by this object.
    // Returns TRUE on success, FALSE on failure.
    BOOL Write(int n) throw()
    {
        CHAR szTmp[21];
        _itoa(n, szTmp, 10);
        return Write(szTmp);
    }

    // Call this function to write data to the IWriteStream interface managed by this object.
    // Returns TRUE on success, FALSE on failure.
    BOOL Write(unsigned int u) throw()
    {
        CHAR szTmp[21];
        _itoa((int)u, szTmp, 10);
        return Write(szTmp);
    }

    // Call this function to write data to the IWriteStream interface managed by this object.
    // Returns TRUE on success, FALSE on failure.
    BOOL Write(short int w) throw()
    {
        return Write((int) w);
    }

    // Call this function to write data to the IWriteStream interface managed by this object.
    // Returns TRUE on success, FALSE on failure.
    BOOL Write(long int dw) throw()
    {
        CHAR szTmp[21];
        _ltoa(dw, szTmp, 10);
        return Write(szTmp);
    }

    // Call this function to write data to the IWriteStream interface managed by this object.
    // Returns TRUE on success, FALSE on failure.
    BOOL Write(unsigned long int dw) throw()
    {
        CHAR szTmp[21];
        _ultoa(dw, szTmp, 10);
        return Write(szTmp);
    }

    // Call this function to write data to the IWriteStream interface managed by this object.
    // Returns TRUE on success, FALSE on failure.
    BOOL Write(double d, int nDigitCount=ATL_DEFAULT_PRECISION) throw()
    {
        CHAR szTmp[512];
        int nDec = 0;
        int nSign = 0;
        bool fWriteDec=true;
        strcpy(szTmp, _fcvt(d, nDigitCount, &nDec, &nSign));
        if (nSign != 0)
            m_pStream->WriteStream("-", 1, NULL);
        if (nDec < 0)
        {
            nDec *= -1;
            m_pStream->WriteStream("0.", 2, NULL);
            for (int i=0;i<nDec;i++)
            {
                m_pStream->WriteStream("0", 1, NULL);
            }
            nDec = 0;
            fWriteDec=false;
        }

        char *p = szTmp;
        while (*p)
        {
            // if the decimal lies at the end of the number
            // (no digits to the right of the decimal, we don't
            // print it.
            if (nDec == 0 && fWriteDec)
                m_pStream->WriteStream(".", 1, NULL);
            m_pStream->WriteStream(p, 1, NULL);
            nDec--;
            p++;
        }
        return TRUE;
    }

    // Call this function to write data to the IWriteStream interface managed by this object.
    // Returns TRUE on success, FALSE on failure.
    BOOL Write(__int64 i) throw()
    {
        CHAR szTmp[21];
        _i64toa(i, szTmp, 10);
        return Write(szTmp);
    }       

    // Call this function to write data to the IWriteStream interface managed by this object.
    // Returns TRUE on success, FALSE on failure.
    BOOL Write(unsigned __int64 i) throw()
    {
        CHAR szTmp[21];
        _ui64toa(i, szTmp, 10);
        return Write(szTmp);
    }       

    // Call this function to write data to the IWriteStream interface managed by this object.
    // Returns TRUE on success, FALSE on failure.
    BOOL Write(CURRENCY c) throw()
    {
        CHAR szDest[256];
        CHAR szNumber[32];
        
#if 0
        sprintf(szNumber, "%05I64d", c.int64);
        int nLen = (int) strlen(szNumber);
#else
        _i64toa(c.int64, szNumber, 10);
        int nLen = (int) strlen(szNumber);
        if (nLen < 5)
        {
            // prepend ascii zeros
            memmove(szNumber+5-nLen, szNumber, nLen+1);
            memset(szNumber, '0', 5-nLen);
            nLen = 5;
        }
#endif
        memmove(szNumber+nLen-3, szNumber+nLen-4, 5);
        szNumber[nLen-4] = '.';

        int nRet = GetCurrencyFormatA(GetThreadLocale(), 0, szNumber, NULL, szDest, sizeof(szDest));
        if (nRet > 0)
            return Write(szDest);

        ATLASSERT(GetLastError()==ERROR_INSUFFICIENT_BUFFER);

        nRet = GetCurrencyFormatA(GetThreadLocale(), 0, szNumber, NULL, NULL, 0);
        ATLASSERT(nRet > 0);
        
        if (nRet <= 0)
            return FALSE;

        CAutoVectorPtr<CHAR> szBuffer;
        if (!szBuffer.Allocate(nRet))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        nRet = GetCurrencyFormatA(GetThreadLocale(), 0, szNumber, NULL, szBuffer, nRet);

        ATLASSERT(nRet > 0);
        BOOL bRet = FALSE;
        if (nRet > 0)
            bRet = Write(szBuffer);

        return bRet;
    }

    // Call this function to write data to the IWriteStream interface managed by this object.
    // Returns TRUE on success, FALSE on failure.
    BOOL Write(LPCWSTR wsz) throw()
    {
		BOOL bRet;

        _ATLTRY
        {
            CW2A sz(wsz);

            if (!sz)
			{
                bRet = FALSE;
			}

            DWORD dwWritten;
            bRet = SUCCEEDED(m_pStream->WriteStream(sz, (int) strlen(sz), &dwWritten));
        }
        _ATLCATCHALL()
        {
            bRet = FALSE;
        }

		return bRet;
    }

    // Use this operator to write data to the IWriteStream interface managed by this object.
    CWriteStreamHelper& operator<<(LPCSTR szStr) throw(...)
    {
        if (!Write(szStr))
            AtlThrow(E_FAIL);
        return *this;
    }

    // Use this operator to write data to the IWriteStream interface managed by this object.
    CWriteStreamHelper& operator<<(LPCWSTR wszStr) throw(...)
    {
        if (!Write(wszStr))
            AtlThrow(E_FAIL);
        return *this;
    }

    // Use this operator to write data to the IWriteStream interface managed by this object.
    CWriteStreamHelper& operator<<(int n) throw(...)
    {
        if (!Write(n))
            AtlThrow(E_FAIL);
        return *this;
    }

    // Use this operator to write data to the IWriteStream interface managed by this object.
    CWriteStreamHelper& operator<<(short int w) throw(...)
    {
        if (!Write(w))
            AtlThrow(E_FAIL);
        return *this;
    }

    // Use this operator to write data to the IWriteStream interface managed by this object.
    CWriteStreamHelper& operator<<(unsigned int u) throw(...)
    {
        if (!Write(u))
            AtlThrow(E_FAIL);
        return *this;
    }

    // Use this operator to write data to the IWriteStream interface managed by this object.
    CWriteStreamHelper& operator<<(long int dw) throw(...)
    {
        if (!Write(dw))
            AtlThrow(E_FAIL);
        return *this;
    }

    // Use this operator to write data to the IWriteStream interface managed by this object.
    CWriteStreamHelper& operator<<(unsigned long int dw) throw(...)
    {
        if (!Write(dw))
            AtlThrow(E_FAIL);
        return *this;
    }

    // Use this operator to write data to the IWriteStream interface managed by this object.
    CWriteStreamHelper& operator<<(double d) throw(...)
    {
        if (!Write(d))
            AtlThrow(E_FAIL);
        return *this;
    }

    // Use this operator to write data to the IWriteStream interface managed by this object.
    CWriteStreamHelper& operator<<(__int64 i) throw(...)
    {
        if (!Write(i))
            AtlThrow(E_FAIL);
        return *this;
    }

    // Use this operator to write data to the IWriteStream interface managed by this object.
    CWriteStreamHelper& operator<<(unsigned __int64 i) throw(...)
    {
        if (!Write(i))
            AtlThrow(E_FAIL);
        return *this;
    }

    // Use this operator to write data to the IWriteStream interface managed by this object.
    CWriteStreamHelper& operator<<(CURRENCY c) throw(...)
    {
        if (!Write(c))
            AtlThrow(E_FAIL);
        return *this;
    }
};


// This class represents the response that the web server will send back to the client.
//
// CHttpResponse provides friendly functions for building up the headers, cookies, and body of an HTTP response.
// The class derives from IWriteStream and CWriteStreamHelper, allowing you to call those classes' methods
// to build up the body of the response. By default, the class improves performance by buffering the response until it is complete before sending it back to the client.
class CHttpResponse : public IWriteStream, public CWriteStreamHelper
{
protected:
    // Implementation: A map of HTTP response headers.
    // The key is the name of the response header.
    // The value is the data for the response header.
    CSimpleMap<CStringA, CStringA> m_headers;

    // Implementation: Determines whether the response is currently being buffered.
    BOOL m_bBufferOutput;
    
    // Implementation: Determines whether any output should be sent to the client.
    // Intended mainly for HEAD requests, where the client should get the same headers
    // (i.e. Content-Length) as for a GET request
    BOOL m_bSendOutput;

    // Implementation: The limit in bytes of the response buffer.
    // When the limit is reached, the buffer is automatically flushed
    // and data is sent to the client. You can set this to ULONG_MAX
    // to enable full buffering (this is the default, and is required
    // for enabling keep alive connections).
    DWORD m_dwBufferLimit;

    // Implementation: The server context.
    CComPtr<IHttpServerContext> m_spServerContext;

    // Implementation: The HTTP status code for the response.
    int m_nStatusCode;

    // Implementation: Determines whether the response headers have already been sent to the client.
    BOOL m_bHeadersSent;

    // Implementation: Handle of the file being transmitted so it can be closed
    // when the async I/O completes
    HANDLE m_hFile;
public:
    // Implementation: The buffer used to store the response before
    // the data is sent to the client.
    CAtlIsapiBuffer<> m_strContent;

    // Numeric constants for the HTTP status codes used for redirecting client requests.
    enum HTTP_REDIRECT
    { 
        HTTP_REDIRECT_MULTIPLE=300,
        HTTP_REDIRECT_MOVED=301,
        HTTP_REDIRECT_FOUND=302,
        HTTP_REDIRECT_SEE_OTHER=303,
        HTTP_REDIRECT_NOT_MODIFIED=304,
        HTTP_REDIRECT_USE_PROXY=305,
        HTTP_REDIRECT_TEMPORARY_REDIRECT=307
    };

    // The default constructor. 
    CHttpResponse() throw()
    {
        m_bBufferOutput = TRUE;
        m_dwBufferLimit = ULONG_MAX;
        m_nStatusCode = 200;
        m_pStream = this;
        m_bHeadersSent = FALSE;
        m_bSendOutput = TRUE;
        m_hFile = INVALID_HANDLE_VALUE;
    }

    // The constructor.
    CHttpResponse(IHttpServerContext *pServerContext) throw()
    {
        m_bBufferOutput = TRUE;
        m_dwBufferLimit = ULONG_MAX;
        m_nStatusCode = 200;
        m_pStream = this;
        m_bHeadersSent = FALSE;
        Initialize(pServerContext);
        m_bSendOutput = TRUE;
        m_hFile = INVALID_HANDLE_VALUE;
    }

    // The destructor flushes the buffer if there is content that
    // hasn't yet been sent to the client.
    ~CHttpResponse() throw()
    {
//      if (m_strContent.GetLength())
            Flush(TRUE);
        if (m_hFile && m_hFile != INVALID_HANDLE_VALUE)
            CloseHandle(m_hFile);
    }

    // Call this function to initialize the response object with a pointer to the server context.
    // Returns TRUE on success, FALSE on failure.
    BOOL Initialize(IHttpServerContext *pServerContext) throw()
    {
        ATLASSERT(pServerContext != NULL);
        if (!pServerContext)
            return FALSE;

        m_spServerContext = pServerContext;

        return TRUE;
    }

    // This is called to initialize the CHttpResponse for a child handler.  By default, it
    // assumes the parent will be responsible for sending the headers.
    BOOL Initialize(IHttpRequestLookup *pLookup) throw()
    {
        ATLASSERT(pLookup);
        if (!pLookup)
            return FALSE;

        CComPtr<IHttpServerContext> spContext;
        HRESULT hr = pLookup->GetServerContext(&spContext);
        if (FAILED(hr))
            return FALSE;

        if (!Initialize(spContext))
            return FALSE;

        m_bHeadersSent = TRUE;

        return TRUE;
    }

    // Returns a pointer to the IHttpServerContext interface for the current request.
    HRESULT GetServerContext(IHttpServerContext ** ppOut) throw()
    {
        return m_spServerContext.CopyTo(ppOut);
    }

    // Call this function to set buffering options for the response.
    //
    // This function allows you to turn buffering on or off, and to set a size limit
    // on the amount of data that will be buffered before being sent to the client.
    // 
    // When you turn off buffering, the current contents of the buffer will be sent to the client.
    // If you need to clear the buffer without sending the contents to the client, call ClearContent instead.
    //
    // When the size of the buffer is reduced below the current size of the buffered content,
    // the entire buffer is flushed.
    void SetBufferOutput(BOOL bBufferOutput, DWORD dwBufferLimit=ATL_ISAPI_BUFFER_SIZE) throw()
    {
        if (m_bBufferOutput && !bBufferOutput)
        {
            // before turning off buffering, flush
            // the current contents
            Flush();
        }
        SetBufferLimit(dwBufferLimit);

        m_bBufferOutput = bBufferOutput;
    }

    // Call this function to determine whether data written to the response object is being buffered or not.
    // Returns TRUE if output is being buffered, FALSE otherwise.
    BOOL GetBufferOutput() throw()
    {
        return m_bBufferOutput;
    }

    // Call this function to determine whether the response headers have been sent
    // Returns TRUE if headers have been sent, FALSE otherwise.
    BOOL HaveSentHeaders() throw()
    {
        return m_bHeadersSent;
    }

    // Call this function to override the m_bHeadersSent state.  This is useful
    // when you want child handlers (e.g. from an include or subhandler) to send the headers
    void HaveSentHeaders(BOOL bSent) throw()
    {
        m_bHeadersSent = bSent;
    }

    // Call this function to set a size limit on the amount of data buffered by the reponse object.
    // When the size of the buffer is reduced below the current size of the buffered content,
    // the entire buffer is flushed.
    // See GetBufferLimit.
    void SetBufferLimit(DWORD dwBufferLimit) throw()
    {
        if (m_bBufferOutput)
        {
            if (m_strContent.GetLength() >= dwBufferLimit)
            {
                // new buffer limit is less than the
                // size currently buffered.  So flush
                // the current buffer
                Flush();
            }
        }
        m_dwBufferLimit = dwBufferLimit;
    }

    // Returns the current size limit of the buffer in bytes.
    // See SetBufferLimit.
    DWORD GetBufferLimit() throw()
    {
        return m_dwBufferLimit;
    }

    // Returns the current value of the Content-Type header if present, otherwise returns NULL.
    LPCSTR GetContentType() throw()
    {
        // return the content type from the
        // header collection if any
		_ATLTRY
		{
        CStringA strKey("Content-Type");

        int nIndex = m_headers.FindKey(strKey);
        if (nIndex >= 0)
            return m_headers.GetValueAt(nIndex);
		}
		_ATLCATCHALL()
		{
		}
        return NULL;
    }

    // Call this function to set the Content-Type of the HTTP response.
    // Examples of common MIME content types include text/html and text/plain.
    BOOL SetContentType(LPCSTR szContentType) throw()
    {
		_ATLTRY
		{
			if (!m_headers.SetAt("Content-Type", szContentType))
				return m_headers.Add("Content-Type", szContentType);
		}
		_ATLCATCHALL()
		{
		}
        return TRUE;
    }

    // Call this function to set the HTTP status code of the response.
    // If not set explicitly, the default status code is 200 (OK).
    // See GetStatusCode.
    void SetStatusCode(int nCode) throw()
    {
        m_nStatusCode = nCode;
    }

    // Returns the current HTTP status code of the response.
    // See SetStatusCode.
    int GetStatusCode() throw()
    {
        return m_nStatusCode;
    }

    // Call this function to set the Cache-Control http header of the response.
    // Examples of common Cache-Control header values: public, private, max-age=delta-seconds
    BOOL SetCacheControl(LPCSTR szCacheControl) throw()
    {
		_ATLTRY
		{
			if (!m_headers.SetAt("Cache-Control", szCacheControl))
				return m_headers.Add("Cache-Control", szCacheControl);
		}
		_ATLCATCHALL()
		{
		}
        return FALSE;
    }

    // Call this function to set the Expires HTTP header to the absolute date/time
    // specified in the stExpires parameter
    BOOL SetExpiresAbsolute(const SYSTEMTIME& stExpires) throw()
    {
		_ATLTRY
		{
			CStringA strExpires;
			SystemTimeToHttpDate(stExpires, strExpires);

			if (!m_headers.SetAt("Expires", strExpires))
				return m_headers.Add("Expires", strExpires);
		}
		_ATLCATCHALL()
		{
		}
        return FALSE;
    }

    // Call this function to set the Expires HTTP header to a relative date/time
    // value specified in minutes;
    BOOL SetExpires(long lMinutes) throw()
    {
        CFileTime ft;
        GetSystemTimeAsFileTime(&ft);

        // add the specified number of minutes
        ft += CFileTimeSpan(((ULONGLONG)lMinutes)*60*10000000);

        SYSTEMTIME st;
        FileTimeToSystemTime(&ft, &st);
        return SetExpiresAbsolute(st);
    }

    // Call this function to set whether or not to output to client.
    // Intended primarily for HEAD requests
    BOOL SetWriteToClient(BOOL bSendOutput) throw()
    {
        m_bSendOutput = bSendOutput;
        return TRUE;
    }

    // Call this function to determine whether or not the data is
    // sent to the client.  Intended primarily for HEAD requests
    BOOL GetWriteToClient() throw()
    {
        return m_bSendOutput;
    }

    // Call this function to write data to the response object.
    //
    // Returns S_OK on success, E_INVALIDARG or E_FAIL on failure.
    //
    // See WriteClient for comments on buffering.
    //
    // szOut    A pointer to the first byte of the data to be written.
    //
    // nLen     The number of bytes to write. If this parameter is -1,
    //          szOut is assumed to be a nul-terminated string and the
    //          whole string will be written.
    //
    // pdwWritten   A DWORD pointer that can be used to get the number of bytes written.
    //              This parameter can be NULL.
    HRESULT WriteStream(LPCSTR szOut, int nLen, DWORD *pdwWritten) throw()
    {
        ATLASSERT(m_spServerContext != NULL);

        if (pdwWritten)
            *pdwWritten = 0;
        if (nLen == -1)
        {
            if (!szOut)
                return E_INVALIDARG;
            nLen = (int) strlen(szOut);
        }
        BOOL bRet = WriteLen(szOut, nLen);
        if (!bRet)
        {
            return AtlHresultFromLastError();
        }
        if (pdwWritten)
            *pdwWritten = nLen;
        return S_OK;
    }

    // Call this function to write data to the response object.
    //
    // Returns TRUE on success. FALSE on failure.
    //
    // If buffering is disabled, data is written directly to the client.
    // If buffering is enabled, this function attempts to write to the buffer.
    // If the buffer is too small to contain its existing data and the new data,
    // the current contents of the buffer are flushed.
    // If the buffer is still too small to contain the new data, that data is written
    // directly to the client. Otherwise the new data is written to the buffer.
    //
    // Any headers that have been set in the response will be sent just before the 
    // data is written to the client if no headers have been sent up to that point.
    //
    // szOut    A pointer to the first byte of the data to be written.
    //
    // nLen     The number of bytes to write.
    BOOL WriteLen(LPCSTR szOut, DWORD dwLen) throw()
    {
        ATLASSERT(m_spServerContext != NULL);
        if (!szOut)
            return FALSE;

        if (m_bBufferOutput)
        {
            if (m_strContent.GetLength()+dwLen >= m_dwBufferLimit)
            {
                if (!Flush())
                    return FALSE;
            }
            if (dwLen <= m_dwBufferLimit)
                return m_strContent.Append(szOut, dwLen);
        }
        BOOL bRet = SendHeadersInternal();

        if (bRet && m_bSendOutput)
            bRet = m_spServerContext->WriteClient((void *) szOut, &dwLen);
        
        return bRet;
    }

    // Call this function to redirect the client to a different resource.
    //
    // Returns TRUE on success, FALSE on failure.
    //
    // szURL        A nul-terminated string specifying the resource the client should navigate to. 
    //
    // statusCode   An HTTP status code from the HTTP_REDIRECT enumeration describing the reason
    //              for the redirection.
    //
    // bSendBody    Specifies whether to generate and send a response body with the headers.
    //
    //  This function allows (and RFC 2616 encourages) a response body to be sent
    //  with the following redirect types:
    //      HTTP_REDIRECT_MOVED
    //      HTTP_REDIRECT_FOUND
    //      HTTP_REDIRECT_SEE_OTHER
    //      HTTP_REDIRECT_TEMPORARY_REDIRECT
    // No body will be sent with other redirect types.
    //
    // The response body contains a short hypertext note with a hyperlink to the new resource.
    // A meta refresh tag is also included to allow browsers to automatically redirect
    // the user to the resource even if they don't understand the redirect header.
    //
    // See RFC 2616 section 10.3 for more information on redirection.
    BOOL Redirect(LPCSTR szUrl, HTTP_REDIRECT statusCode=HTTP_REDIRECT_MOVED, BOOL bSendBody=TRUE) throw(...)
    {
        CStringA strBody;
        LPCSTR szBody = NULL;
        if (bSendBody &&
            (HTTP_REDIRECT_MOVED == statusCode  || HTTP_REDIRECT_FOUND == statusCode ||
            HTTP_REDIRECT_SEE_OTHER == statusCode || HTTP_REDIRECT_TEMPORARY_REDIRECT == statusCode))
        {
			_ATLTRY
			{
            strBody.Format(
                "<html>\r\n"
                "<head>\r\n"
                "<meta http-equiv=\"refresh\" content=\"0; url=%s\">\r\n"
                "</head>\r\n"
                "<body>Please use the following link to access this resource:"
                " <a href=\"%s\">%s</a>\r\n"
                "</body>\r\n"
                "</html>\r\n",
                szUrl, szUrl, szUrl);
			}
			_ATLCATCHALL()
			{
				return FALSE;
			}
            szBody = (LPCSTR) strBody;
        }
        return Redirect(szUrl, szBody, statusCode);
    }

    // Call this function to redirect the client to a different resource.
    //
    // Returns TRUE on success, FALSE on failure.
    //
    // szURL        A nul-terminated string specifying the resource the client should navigate to.
    //
    // szBody       A nul-terminated string containing the body of the response to be sent to the client.
    //
    // statusCode   An HTTP status code from the HTTP_REDIRECT enumeration describing the reason
    //              for the redirection.
    //
    //  This function allows (and RFC 2616 encourages) a response body to be sent
    //  with the following redirect types:
    //      HTTP_REDIRECT_MOVED
    //      HTTP_REDIRECT_FOUND
    //      HTTP_REDIRECT_SEE_OTHER
    //      HTTP_REDIRECT_TEMPORARY_REDIRECT
    // No body will be sent with other redirect types.
    //
    // The response body should contain a short hypertext note with a hyperlink to the new resource.
    // You can include a meta refresh tag to allow browsers to automatically redirect
    // the user to the resource even if they don't understand the redirect header.
    //
    // See RFC 2616 section 10.3 for more information on redirection.
    BOOL Redirect(LPCSTR szUrl, LPCSTR szBody, HTTP_REDIRECT statusCode=HTTP_REDIRECT_MOVED) throw()
    {
        // todo: handle multiple
        SetStatusCode(statusCode);
        AppendHeader("Location", szUrl);

		_ATLTRY
		{
			if (!SendHeadersInternal())
				return FALSE;
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}

        if (szBody &&
            (HTTP_REDIRECT_MOVED == statusCode  || HTTP_REDIRECT_FOUND == statusCode ||
            HTTP_REDIRECT_SEE_OTHER == statusCode || HTTP_REDIRECT_TEMPORARY_REDIRECT == statusCode))
        {
            Write(szBody);
            return Flush();
        }
        return TRUE;
    }

    // Call this function to append a header to the collection of HTTP headers managed by this object.
    //
    // szName   A nul-teminated string containing the name of the HTTP header.
    //
    // szValue  A nul-teminated string containing the value of the HTTP header.
    BOOL AppendHeader(LPCSTR szName, LPCSTR szValue) throw()
    {
		BOOL bRet = FALSE;
        _ATLTRY
		{
			bRet = m_headers.Add(szName, szValue);
		}
		_ATLCATCHALL()
		{
			bRet = FALSE;
		}
		return bRet;
    }

    // Call this function to add a Set-Cookie header to the collection of HTTP headers managed by this object.
    // 
    // pCookie      A pointer to a CCookie object describing the cookie to be sent to the client.
    BOOL AppendCookie(const CCookie *pCookie) throw()
    {
        ATLASSERT(pCookie);
        return AppendCookie((const CCookie&)*pCookie);
    }

    // Call this function to add a Set-Cookie header to the collection of HTTP headers managed by this object.
    // 
    // cookie       A reference to a CCookie object describing the cookie to be sent to the client.
    BOOL AppendCookie(const CCookie& cookie) throw()
    {
        CHAR szCookie[ATL_MAX_COOKIE_LEN];
        DWORD dwBuffSize = ATL_MAX_COOKIE_LEN;
        BOOL bRet = FALSE;
        bRet = cookie.Render(szCookie, &dwBuffSize);
        if (bRet)
        {
            bRet = m_headers.Add("Set-Cookie", szCookie);
        }

        if (!bRet && dwBuffSize > 0)    //static buffer wasn't big enough.
        {   
            //We'll have to try dynamically allocating it
            //allocate a buffer
            CAutoVectorPtr<CHAR> sz;
            if (sz.Allocate(dwBuffSize+1))
            {
                DWORD dwSizeNew = dwBuffSize + 1;
                if (cookie.Render(sz, &dwSizeNew))
                {
                    bRet = m_headers.Add("Set-Cookie", (const char *) sz);
                }
            }
        }
        return bRet;
    }

    // Call this function to add a Set-Cookie header to the collection of HTTP headers managed by this object.
    // 
    // szName       A nul-terminated string containing the name of the cookie to be sent to the client.
    //
    // szValue      A nul-terminated string containing the value of the cookie to be sent to the client.
    BOOL AppendCookie(LPCSTR szName, LPCSTR szValue) throw()
    {
		BOOL bRet = FALSE;
		_ATLTRY
		{
			CCookie c(szName, szValue);
			bRet = AppendCookie(c);
		}
		_ATLCATCHALL()
		{
			bRet = FALSE;
		}
		return bRet;
    }

    // Call this function to add a Set-Cookie header that removes a cookie value
    // to the collection of HTTP headers managed by this object.
    // 
    // szName       A nul-terminated string containing the name of the cookie to be deleted
    BOOL DeleteCookie(LPCSTR szName) throw()
    {
		BOOL bRet = FALSE;
		_ATLTRY
		{
        CCookie cookie(szName, "");
        cookie.SetMaxAge(0);
        bRet = AppendCookie(cookie);
		}
		_ATLCATCHALL()
		{
			bRet = FALSE;
		}
		return bRet;

    }

    // Call this function to clear the collection of HTTP response headers maintained by this object.
    //
    // Note that clearing the headers includes removing all cookies associated with the response
    // object. Cookies are sent to the client as Set-Cookie HTTP headers.
    void ClearHeaders() throw()
    {
        m_headers.RemoveAll();
    }

    // Call this function to clear theresponse buffer without sending the contents to the client.
    // If you need to empty the buffer but you do want the current contents sent to the client, call Flush instead. 
    void ClearContent() throw()
    {
        m_strContent.Empty();
    }

    // Call this function to send the current headers associated with this object to the client.
    // 
    // Returns TRUE on success, FALSE on failure.
    //
    // The response headers are sent to the client using the current status code for the
    // response object. See SetStatusCode and GetStatusCode.
    BOOL SendHeadersInternal(BOOL fKeepConn=FALSE) throw()
    {
        if (m_bHeadersSent)
            return TRUE;

        ATLASSERT(m_spServerContext != NULL);

        CStringA strHeaders;

        RenderHeaders(strHeaders);

        // REVIEW: should fix this to use the user's custom error provider
        CDefaultErrorProvider prov;

		BOOL bRet = FALSE;
		_ATLTRY
		{
        CStringA strStatus = GetStatusHeader(m_nStatusCode, SUBERR_NONE, &prov);
        bRet = m_spServerContext->SendResponseHeader(strHeaders, strStatus, fKeepConn);
        if (bRet)
            m_bHeadersSent = TRUE;
		}
		_ATLCATCHALL()
		{
			bRet = FALSE;
		}
        return bRet;
    }

    // Call this function to get a string containing all the HTTP headers associated with
    // this object in a format suitable for sending to a client.
    //
    // strHeaders   A CStringA reference to which will be appended the HTTP headers.
    void RenderHeaders(CStringA& strHeaders) throw()
    {
		_ATLTRY
		{
			for (int i=0; i<m_headers.GetSize(); i++)
			{
				strHeaders += m_headers.GetKeyAt(i);
				strHeaders += ": ";
				strHeaders += m_headers.GetValueAt(i);
				strHeaders += "\r\n";
			}
			strHeaders += "\r\n";
		}
		_ATLCATCHALL()
		{
		}
    }

    // Call this function to empty the response buffer and send its current
    // contents to the client.
    //
    // Returns S_OK on success, or an error HRESULT on failure.
    HRESULT FlushStream() throw()
    {
        if (!Flush())
            return AtlHresultFromLastError();
        return S_OK;
    }

    // Call this function to empty the response buffer and send its current
    // contents to the client.
    //
    // Returns TRUE on success, or FALSE on failure.
    //
    // Any headers that have been set in the response will be sent just before the 
    // data is written to the client if no headers have been sent up to that point.
    BOOL Flush(BOOL bFinal=FALSE) throw()
    {
        if (!m_spServerContext)
            return FALSE;

        BOOL bRet = TRUE;

		_ATLTRY
		{
			// if the headers haven't been sent,
			// send them now

			if (!m_bHeadersSent)
			{
				char szProtocol[ATL_URL_MAX_URL_LENGTH];
				DWORD dwProtocolLen = sizeof(szProtocol);

				if (bFinal && m_bBufferOutput && m_dwBufferLimit==ULONG_MAX)
				{
					if (m_spServerContext->GetServerVariable("SERVER_PROTOCOL", szProtocol, &dwProtocolLen) &&
						!strcmp(szProtocol, "HTTP/1.0"))
						AppendHeader("Connection", "Keep-Alive");
					_itoa(m_strContent.GetLength(), szProtocol, 10);
					AppendHeader("Content-Length", szProtocol);
					bRet = SendHeadersInternal(TRUE);
				}
				else
					bRet = SendHeadersInternal();
			}
			if (m_bBufferOutput)
			{
				DWORD dwLen = 0;

				dwLen = m_strContent.GetLength();
				if (dwLen)
				{
					if (m_bSendOutput && 
						m_spServerContext->WriteClient((void *) (LPCSTR) m_strContent, &dwLen) != TRUE)
					{
						m_strContent.Empty();
						return FALSE;
					}
					m_strContent.Empty();
				}
			}
		} // _ATLTRY
		_ATLCATCHALL()
		{
			bRet = FALSE;
		}
        return bRet;
    }

    // Call this function to clear the response object of any headers
    // and the contents of the buffer.
    void ClearResponse() throw()
    {
        m_strContent.Empty();
        m_headers.RemoveAll();
        
    }

    BOOL AsyncPrep(BOOL fKeepConn=FALSE) throw()
    {
        ATLASSERT(m_spServerContext != NULL);

        return SendHeadersInternal(fKeepConn);
    }
    
    BOOL AsyncFlush() throw()
    {
        ATLASSERT(m_spServerContext != NULL);

        BOOL bRet = SendHeadersInternal();

        if (bRet && m_bBufferOutput)
        {
            DWORD dwLen = 0;

            dwLen = m_strContent.GetLength();
            if (dwLen)
            {
                if (m_spServerContext->AsyncWriteClient((void *) (LPCSTR) m_strContent, &dwLen) != TRUE)
                    return FALSE;
            }
        }
        return bRet;
    }

    BOOL TransmitFile(HANDLE hFile, LPCSTR szContentType="text/plain") throw()
    {
        ATLASSERT(m_spServerContext != NULL);
        ATLASSERT(hFile != NULL && hFile != INVALID_HANDLE_VALUE);

        SetContentType(szContentType);

        if (m_strContent.GetLength())
            if (!Flush())
                return FALSE;

        BOOL bRet = SendHeadersInternal();
        if (bRet)
        {
            bRet = m_spServerContext->TransmitFile(hFile, NULL, NULL, NULL, 
                0, 0, NULL, 0, NULL, 0, HSE_IO_ASYNC);
        }
    
        return bRet;
    }
}; // class CHttpResponse



#define ATLS_FLAG_NONE      0
#define ATLS_FLAG_ASYNC     1   // handler might do some async handling

//REVIEW: push_macro/pop_macro don't work in a template definition.
//these have been moved out of IRequestHandlerImpl temporarily because
//of placement new usage
#pragma push_macro("new")
#undef new
template <class T>
class PerThreadWrapper : public CComObjectNoLock<T>
{
public:
    void *operator new(size_t /*size*/, void *p) throw()
    {
        return p;
    }
    
    void operator delete(void * /*p*/) throw()
    {
    }

    STDMETHOD_(ULONG, Release)() throw()
    {
        ULONG l = InternalRelease();
        if (l == 0)
        {
            T *pT = static_cast<T*>(this);
            ATLASSERT(pT->m_spExtension != NULL);
            CIsapiWorker *pWorker = pT->m_spExtension->GetThreadWorker();
            ATLASSERT(pWorker);

            delete this;
            HeapFree(pWorker->m_hHeap, HEAP_NO_SERIALIZE, this);
        }
        return l;
    }
};

template <typename THandler>
inline BOOL CreateRequestHandlerSync(IIsapiExtension *pExtension, IUnknown **ppOut) throw()
{
    CIsapiWorker *pWorker = pExtension->GetThreadWorker();
    ATLASSERT(pWorker);
    void *pv = HeapAlloc(pWorker->m_hHeap, HEAP_NO_SERIALIZE, sizeof(PerThreadWrapper<THandler>));
    if (!pv)
        return FALSE;

    PerThreadWrapper<THandler> *pHandler = new(pv) PerThreadWrapper<THandler>;
    *ppOut = static_cast<IRequestHandler *>(pHandler);
    pHandler->m_spExtension = pExtension;

    (*ppOut)->AddRef();

    return TRUE;
}
#pragma pop_macro("new")

#define DECLARE_ASYNC_HANDLER() \
    static DWORD GetHandlerFlags() throw() \
    { \
        return ATLS_FLAG_ASYNC; \
    } \
    DWORD GetAsyncFlags() throw() \
    { \
        return ATLSRV_INIT_USEASYNC; \
    }

#define DECLARE_ASYNC_HANDLER_EX() \
    static DWORD GetHandlerFlags() throw() \
    { \
        return ATLS_FLAG_ASYNC; \
    } \
    DWORD GetAsyncFlags() throw() \
    { \
        return (ATLSRV_INIT_USEASYNC|ATLSRV_INIT_USEASYNC_EX); \
    }


template <typename THandler>
class IRequestHandlerImpl : public IRequestHandler
{
public:
    HINSTANCE m_hInstHandler;
    CComPtr<IServiceProvider> m_spServiceProvider;
    CComPtr<IHttpServerContext> m_spServerContext;
    CComPtr<IIsapiExtension> m_spExtension;
    DWORD m_dwAsyncFlags;

    IRequestHandlerImpl() throw()
        :m_hInstHandler(NULL)
    {
        m_dwAsyncFlags = 0;
    }

    HTTP_CODE GetFlags(DWORD *pdwStatus) throw(...)
    {
        THandler *pT = static_cast<THandler *>(this);
        if (pdwStatus)
        {
            *pdwStatus = pT->GetAsyncFlags();
            if (pT->CachePage())
                *pdwStatus |= ATLSRV_INIT_USECACHE;

#ifdef _DEBUG
            if (*pdwStatus & (ATLSRV_INIT_USEASYNC|ATLSRV_INIT_USEASYNC_EX))
                ATLASSERT(pT->GetHandlerFlags() & ATLS_FLAG_ASYNC);
#endif
        }

        return HTTP_SUCCESS;
    }

    HTTP_CODE InitializeHandler(AtlServerRequest *pRequestInfo, IServiceProvider *pProvider) throw()
    {
        ATLASSERT(pRequestInfo != NULL);
        ATLASSERT(pProvider != NULL);
        ATLASSERT(pRequestInfo->hInstDll != NULL);
        ATLASSERT(pRequestInfo->pServerContext != NULL);

        // Initialize our internal references to required services
        m_hInstHandler = pRequestInfo->hInstDll;
        m_spServiceProvider = pProvider;
        m_spServerContext = pRequestInfo->pServerContext;

        return HTTP_SUCCESS;
    }

    HTTP_CODE InitializeChild(AtlServerRequest *pRequestInfo, IServiceProvider *pProvider, IHttpRequestLookup * /*pLookup*/) throw()
    {
        return InitializeHandler(pRequestInfo, pProvider);
    }

    void UninitializeHandler() throw()
    {
    }

    HTTP_CODE HandleRequest(
        AtlServerRequest* /*pRequestInfo*/,
        IServiceProvider* /*pServiceProvider*/) throw()
    {
        return HTTP_SUCCESS;
    }

    DWORD GetAsyncFlags() throw()
    {
        return m_dwAsyncFlags;
    }

    void SetAsyncFlags(DWORD dwAsyncFlags) throw()
    {
        ATLASSERT((dwAsyncFlags & ~(ATLSRV_INIT_USEASYNC|ATLSRV_INIT_USEASYNC_EX)) == 0);
        m_dwAsyncFlags = dwAsyncFlags;
    }

    BOOL CachePage() throw()
    {
        return FALSE;
    }

    static DWORD GetHandlerFlags() throw()
    {
        return ATLS_FLAG_NONE;
    }

    // Used to create new instance of this object. A pointer to this
    // function is stored in the handler map in user's code.
    static BOOL CreateRequestHandler(IIsapiExtension *pExtension, IUnknown **ppOut) throw()
    {
        ATLASSERT(ppOut != NULL);
        if (ppOut == NULL)
            return false;

        *ppOut = NULL;

        if (THandler::GetHandlerFlags() & ATLS_FLAG_ASYNC)
        {
            THandler *pHandler = NULL;
            ATLTRY(pHandler = new CComObjectNoLock<THandler>);
            if (!pHandler)
                return FALSE;
            *ppOut = static_cast<IRequestHandler *>(pHandler);
            pHandler->m_spExtension = pExtension;
            (*ppOut)->AddRef();
        }
        else
        {
            if (!CreateRequestHandlerSync<THandler>(pExtension, ppOut))
                return FALSE;
        }

        return TRUE;
    }

    // Used to initialize the class
    // function is stored in the handler map in user's code.
    static BOOL InitRequestHandlerClass(IHttpServerContext *pContext, IIsapiExtension *pExt) throw()
    {
        pContext; // unused
        pExt; // unused
        return TRUE;
    }

    // Used to uninitialize the class
    // function is stored in the handler map in user's code.
    static void UninitRequestHandlerClass() throw()
    {
        return;
    }
};

struct CRequestStats
{
    long m_lTotalRequests;
    long m_lFailedRequests;
    __int64 m_liTotalResponseTime;
    long m_lAvgResponseTime;
    long m_lCurrWaiting;
    long m_lMaxWaiting;
    long m_lActiveThreads;

    CRequestStats() throw()
    {
        m_lTotalRequests = 0;
        m_lFailedRequests = 0;
        m_liTotalResponseTime = 0;
        m_lAvgResponseTime = 0;
        m_lCurrWaiting = 0;
        m_lMaxWaiting = 0;
        m_lActiveThreads = 0;
    }

    void RequestHandled(AtlServerRequest *pRequestInfo, BOOL bSuccess) throw()
    {
        InterlockedIncrement(&m_lTotalRequests);
        if (!bSuccess)
            InterlockedIncrement(&m_lFailedRequests);

        long lTicks;

#ifndef ATL_NO_MMSYS
        lTicks = (long) (timeGetTime() - pRequestInfo->dwStartTicks);
#else
        lTicks = GetTickCount();
#endif
		m_liTotalResponseTime += lTicks;
		long lAv = (long) (m_liTotalResponseTime / m_lTotalRequests);
        InterlockedExchange(&m_lAvgResponseTime, lAv);

        InterlockedDecrement(&m_lActiveThreads);
    }

    long GetTotalRequests() throw()
    {
        return m_lTotalRequests;
    }

    long GetFailedRequests() throw()
    {
        return m_lFailedRequests;
    }

    long GetAvgResponseTime() throw()
    {
        return m_lAvgResponseTime;
    }

    void OnRequestReceived() throw()
    {
        InterlockedIncrement(&m_lCurrWaiting);
        if (m_lCurrWaiting > m_lMaxWaiting)
            InterlockedExchange(&m_lMaxWaiting, m_lCurrWaiting);
    }

    void OnRequestDequeued() throw()
    {
        InterlockedDecrement(&m_lCurrWaiting);
        InterlockedIncrement(&m_lActiveThreads);
    }

    long GetCurrWaiting() throw()
    {
        return m_lCurrWaiting;
    }

    long GetMaxWaiting() throw()
    {
        return m_lCurrWaiting;
    }

    long GetActiveThreads() throw()
    {
        return m_lActiveThreads;
    }
};

class CStdRequestStats : public CRequestStats
{

public:
    HRESULT Initialize() throw()
    {
        return S_OK;
    }

    void Uninitialize() throw()
    {
    }
};

#define PERF_REQUEST_OBJECT 100

struct CPerfRequestStatObject : public CPerfObject,
    public CRequestStats
{
    DECLARE_PERF_OBJECT_EX(PERF_REQUEST_OBJECT, IDS_PERFMON_REQUEST, IDS_PERFMON_REQUEST_HELP, PERF_DETAIL_NOVICE, 0, sizeof(CPerfRequestStatObject), MAX_PATH, -1);
	BEGIN_COUNTER_MAP(CPerfRequestStatObject)
		DEFINE_COUNTER(m_lTotalRequests, IDS_PERFMON_REQUEST_TOTAL, IDS_PERFMON_REQUEST_TOTAL_HELP, PERF_COUNTER_RAWCOUNT, -1)
		DEFINE_COUNTER(m_lFailedRequests, IDS_PERFMON_REQUEST_FAILED, IDS_PERFMON_REQUEST_FAILED_HELP, PERF_COUNTER_RAWCOUNT, -1)
		DEFINE_COUNTER(m_lTotalRequests, IDS_PERFMON_REQUEST_RATE, IDS_PERFMON_REQUEST_RATE_HELP, PERF_COUNTER_COUNTER, -1)
		DEFINE_COUNTER(m_lAvgResponseTime, IDS_PERFMON_REQUEST_AVG_RESPONSE_TIME, IDS_PERFMON_REQUEST_AVG_RESPONSE_TIME_HELP, PERF_COUNTER_RAWCOUNT, -1)
		DEFINE_COUNTER(m_lCurrWaiting, IDS_PERFMON_REQUEST_CURR_WAITING, IDS_PERFMON_REQUEST_CURR_WAITING_HELP, PERF_COUNTER_RAWCOUNT, -1)
		DEFINE_COUNTER(m_lMaxWaiting, IDS_PERFMON_REQUEST_MAX_WAITING, IDS_PERFMON_REQUEST_MAX_WAITING_HELP, PERF_COUNTER_RAWCOUNT, -1)
		DEFINE_COUNTER(m_lActiveThreads, IDS_PERFMON_REQUEST_ACTIVE_THREADS, IDS_PERFMON_REQUEST_ACTIVE_THREADS, PERF_COUNTER_RAWCOUNT, -1)
	END_COUNTER_MAP()
};

class CRequestPerfMon : public CPerfMon
{
public:
    BEGIN_PERF_MAP(_T("ATL Server:Request"))
		CHAIN_PERF_OBJECT(CPerfRequestStatObject)
    END_PERF_MAP()
};

class CPerfMonRequestStats
{
    CRequestPerfMon m_PerfMon;
    CPerfRequestStatObject * m_pPerfObjectInstance;
    CPerfRequestStatObject * m_pPerfObjectTotal;

public:
    CPerfMonRequestStats() throw()
    {
        m_pPerfObjectInstance = NULL;
        m_pPerfObjectTotal = NULL;
    }

    HRESULT Initialize() throw()
    {
        HRESULT hr;

        m_pPerfObjectInstance = NULL;
        m_pPerfObjectTotal = NULL;

        hr = m_PerfMon.Initialize();
        if (SUCCEEDED(hr))
        {
            CPerfLock lock(&m_PerfMon);
            if (FAILED(hr = lock.GetStatus()))
            {
                return hr;
            }

            HINSTANCE hInst = _AtlBaseModule.GetModuleInstance();
            WCHAR szName[MAX_PATH];
            if (GetModuleFileNameW(hInst, szName, MAX_PATH) == 0)
            {
                return E_FAIL;
            }
            szName[MAX_PATH-1] = 0;

            hr = m_PerfMon.CreateInstanceByName(PERF_REQUEST_OBJECT, L"_Total", reinterpret_cast<CPerfObject**>(&m_pPerfObjectTotal));
            if (FAILED(hr))
            {
                return hr;
            }

            hr = m_PerfMon.CreateInstanceByName(PERF_REQUEST_OBJECT, szName, reinterpret_cast<CPerfObject**>(&m_pPerfObjectInstance));
            if (FAILED(hr))
            {
                m_PerfMon.ReleaseInstance(m_pPerfObjectTotal);
                m_pPerfObjectTotal = NULL;
                return hr;
            }

            return S_OK;
        }

        return hr;
    }

    void Uninitialize() throw()
    {
        if (m_pPerfObjectInstance)
            m_PerfMon.ReleaseInstance(m_pPerfObjectInstance);
        if (m_pPerfObjectTotal)
            m_PerfMon.ReleaseInstance(m_pPerfObjectTotal);

        m_pPerfObjectInstance = NULL;
        m_pPerfObjectTotal = NULL;

        m_PerfMon.UnInitialize();
    }

    void RequestHandled(AtlServerRequest *pRequestInfo, BOOL bSuccess) throw()
    {
        CPerfLock lock(&m_PerfMon);
        if (m_pPerfObjectInstance != NULL)
            m_pPerfObjectInstance->RequestHandled(pRequestInfo, bSuccess);
        if (m_pPerfObjectTotal != NULL)
            m_pPerfObjectTotal->RequestHandled(pRequestInfo, bSuccess);
    }

    long GetTotalRequests() throw()
    {
        if (m_pPerfObjectInstance != NULL)
            return m_pPerfObjectInstance->GetTotalRequests();

        return 0;
    }

    long GetFailedRequests() throw()
    {
        if (m_pPerfObjectInstance != NULL)
            return m_pPerfObjectInstance->GetFailedRequests();

        return 0;
    }

    long GetAvgResponseTime() throw()
    {
        if (m_pPerfObjectInstance != NULL)
            return m_pPerfObjectInstance->GetAvgResponseTime();

        return 0;
    }

    void OnRequestReceived() throw()
    {
        if (m_pPerfObjectInstance != NULL)
            m_pPerfObjectInstance->OnRequestReceived();
        if (m_pPerfObjectTotal != NULL)
            m_pPerfObjectTotal->OnRequestReceived();
    }

    void OnRequestDequeued() throw()
    {
        if (m_pPerfObjectInstance != NULL)
            m_pPerfObjectInstance->OnRequestDequeued();
        if (m_pPerfObjectTotal != NULL)
            m_pPerfObjectTotal->OnRequestDequeued();
    }

    long GetCurrWaiting() throw()
    {
        if (m_pPerfObjectInstance != NULL)
            return m_pPerfObjectInstance->GetCurrWaiting();

        return 0;
    }

    long GetMaxWaiting() throw()
    {
        if (m_pPerfObjectInstance != NULL)
            return m_pPerfObjectInstance->GetMaxWaiting();

        return 0;
    }

    long GetActiveThreads() throw()
    {
        if (m_pPerfObjectInstance != NULL)
            return m_pPerfObjectInstance->GetActiveThreads();

        return 0;
    }
};

class CNoRequestStats
{
protected:

public:

    HRESULT Initialize() throw()
    {
        return S_OK;
    }

    void Uninitialize() throw()
    {
    }

    void RequestHandled(AtlServerRequest * /*pRequestInfo*/, BOOL /*bSuccess*/) throw()
    {
    }

    long GetTotalRequests() throw()
    {
        return 0;
    }

    long GetFailedRequests() throw()
    {
        return 0;
    }

    long GetAvgResponseTime() throw()
    {
        return 0;
    }

    void OnRequestReceived() throw()
    {
    }

    void OnRequestDequeued() throw()
    {
    }

    long GetCurrWaiting() throw()
    {
        return 0;
    }

    long GetMaxWaiting() throw()
    {
        return 0;
    }

    long GetActiveThreads() throw()
    {
        return 0;
    }
};


inline LPSTR StripHandlerComment(LPSTR szLine) throw()
{
    if (!memcmp(szLine, "<!--", 4))
    {
        szLine += 4;
        while (_istspace(*szLine))
            szLine++;
        LPSTR szEndComment = strstr(szLine, "-->");
        if (szEndComment)
            *szEndComment = '\0';
        return szLine;
    }
    return NULL;
}

struct ATLServerDllInfo
{
    GETATLHANDLERBYNAME     pfnGetHandler;
    UNINITIALIZEATLHANDLERS pfnUninitHandlers;
    INITIALIZEATLHANDLERS pfnInitHandlers;
    IIsapiExtension *pExtension;
    IHttpServerContext *pContext;
};

class CDllCachePeer
{
public:
    struct DllInfo : public ATLServerDllInfo
    {
        operator=(const DllInfo& right) throw()
        {
            pfnGetHandler = right.pfnGetHandler;
            pfnUninitHandlers = right.pfnUninitHandlers;
            pfnInitHandlers = right.pfnInitHandlers;
            pExtension = right.pExtension;
            pContext = right.pContext;
        }
    };

    BOOL Add(HINSTANCE hInst, DllInfo *pInfo) throw(...)
    {
        pInfo->pfnInitHandlers = (INITIALIZEATLHANDLERS) GetProcAddress(hInst, ATLS_FUNCID_INITIALIZEHANDLERS);

        pInfo->pfnGetHandler = (GETATLHANDLERBYNAME) GetProcAddress(hInst, ATLS_FUNCID_GETATLHANDLERBYNAME);
        if (!pInfo->pfnGetHandler)
            return FALSE;

        pInfo->pfnUninitHandlers = (UNINITIALIZEATLHANDLERS) GetProcAddress(hInst, ATLS_FUNCID_UNINITIALIZEHANDLERS);

        if (pInfo->pfnInitHandlers)
        {
			pInfo->pfnInitHandlers(pInfo->pContext, pInfo->pExtension);
            pInfo->pContext = NULL; // won't be valid after this call
        }

        return TRUE;
    }

    void Remove(HINSTANCE /*hInst*/, DllInfo *pInfo) throw(...)
    {
		if (pInfo->pfnUninitHandlers)
			(*pInfo->pfnUninitHandlers)();
    }

};

inline bool operator==(const CDllCachePeer::DllInfo& left, const CDllCachePeer::DllInfo& right) throw()
{
    return ( (left.pfnGetHandler == right.pfnGetHandler) &&
             (left.pfnUninitHandlers == right.pfnUninitHandlers) &&
             (left.pfnInitHandlers == right.pfnInitHandlers) &&
             (left.pExtension == right.pExtension) &&
             (left.pContext == right.pContext)
           );
}



// Helper function to impersonate the client
// on the current thread
inline BOOL AtlImpersonateClient(IHttpServerContext *pServerContext) throw()
{
    // impersonate the calling client on the current thread
    HANDLE hToken;
    if (!pServerContext->GetImpersonationToken(&hToken))
        return FALSE;
    
    if (!SetThreadToken(NULL, hToken))
        return FALSE;
    return TRUE;    
}

// Helper class to set the thread impersonation token
// This is mainly used internally to ensure that we
// don't forget to revert to the process impersonation
// level
class CSetThreadToken
{
public:
    BOOL Initialize(AtlServerRequest *pRequestInfo) throw()
    {
        return AtlImpersonateClient(pRequestInfo->pServerContext);
    }

    ~CSetThreadToken() throw()
    {
        RevertToSelf();         
    }
};


//REVIEW: push_macro/pop_macro don't work in a template definition.
//this has been moved out of  temporarily because
//of placement new usage
#pragma push_macro("new")
#undef new
template <class Base>
class _CComObjectHeap : public Base
{
public:
    typedef Base _BaseClass;
    HANDLE m_hHeap;
    _CComObjectHeap(HANDLE hHeap) throw()
    {
        m_hHeap = hHeap;
    }
    // Set refcount to 1 to protect destruction
    ~_CComObjectHeap() throw()
    {
        m_dwRef = 1L;
        FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
        _AtlDebugInterfacesModule.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
    }

    //If InternalAddRef or InternalRelease is undefined then your class
    //doesn't derive from CComObjectRoot
    STDMETHOD_(ULONG, AddRef)()throw() {return InternalAddRef();}
    STDMETHOD_(ULONG, Release)()throw()
    {
        ULONG l = InternalRelease();
        if (l == 0)
        {
            HANDLE hHeap = m_hHeap;;
            this->~_CComObjectHeap();
            HeapFree(hHeap, 0, this);
        }
        return l;
    }
    //if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) throw()
    {return _InternalQueryInterface(iid, ppvObject);}
};

inline CServerContext* CreateServerContext(HANDLE hRequestHeap) throw()
{
    // Allocate a fixed block size to avoid fragmentation
    void *pv = HeapAlloc(hRequestHeap, HEAP_ZERO_MEMORY,
        max(sizeof(AtlServerRequest), sizeof(_CComObjectHeap<CServerContext>)));
    if (!pv)
        return FALSE;

    _CComObjectHeap<CServerContext>* pContext = new(pv) _CComObjectHeap<CServerContext>(hRequestHeap);

    return pContext;
}
#pragma pop_macro("new")

// _AtlGetHandlerName
// get handler name from stencil file. Ignore all server side comments
//  szFileName - the file from which to extract the handler name
//  szHandlerName - buffer into which handler name will be copied,
//       it is assumed to be of size MAX_PATH+ATL_MAX_HANDLER_NAME+2
inline HTTP_CODE _AtlGetHandlerName(LPCSTR szFileName, LPSTR szHandlerName) throw()
{
    szHandlerName[0] = '\0';
    CAtlFile cfFile;
    HRESULT hr;

	_ATLTRY
	{
    hr = cfFile.Create(CA2TEX<MAX_PATH+1>(szFileName), GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING);
	if (FAILED(hr))
		return HTTP_ERROR(500, ISE_SUBERR_LOADFILEFAIL);
	}
	_ATLCATCHALL()
	{
		return ISE_SUBERR_OUTOFMEM; // CA2TEX threw
	}

    if (cfFile.m_h == NULL || GetFileType(cfFile.m_h) != FILE_TYPE_DISK)
    {
        if (hr == AtlHresultFromWin32(ERROR_FILE_NOT_FOUND))
            return HTTP_ERROR(404, SUBERR_NONE);
        else            
            return HTTP_ERROR(500, IDS_ATLSRV_SERVER_ERROR_STENCILLOADFAIL);
    }

    HTTP_CODE hcErr = HTTP_SUCCESS;
    DWORD dwRead=0;
    LPSTR szHandler = "handler";
    LPSTR pszHandlerPos = NULL;
    LPSTR pszHandlerName = szHandlerName;
    char szBuf[4097];
    LPSTR szCurly = NULL;
    LPSTR pszBuf = NULL;
    bool bInQuote = false;

    // state:
    //  0 = default/unknown
    //  1 = have "{"
	//  2 = have "{{" -- skip spaces
    //  3 = have "{{" -- check "handler"
    //  4 = have "handler" -- skip spaces
    //  5 = have "handler" -- get name
    //  6 = scan until first '}'
    //  7 = better be '}'
    //  8 = done
    int nState = 0;

    do
    {
        hr = cfFile.Read(szBuf, sizeof(szBuf)-1, dwRead);
        if (hr != S_OK)
        {
            return HTTP_ERROR(500, ISE_SUBERR_READFILEFAIL); // failed reading
        }

        szBuf[dwRead] = '\0';
        pszBuf = szBuf;

        while (*pszBuf && nState != 8)
        {
            switch (nState)
            {
            case 0: 
                //  0 = default/unknown

                // look for the first curly
                szCurly = strchr(pszBuf, '{');
                if (!szCurly)
                {
                    // skip to the end of the buffer
                    pszBuf = szBuf+dwRead-1;
                }
                else
                {
                    pszBuf = szCurly;
                    nState = 1;
                }
                break;
            case 1:
                //  1 = have "{"
                if (*pszBuf == '{') 
                {
                    nState = 2;
                }
                else
                {
                    nState = 0; // if the next character is not a '{', start over
                }
                break;
			case 2:
				if (!isspace(*pszBuf))
				{
					pszHandlerPos = szHandler;
					pszBuf--;
					nState = 3;
				}
				break;
            case 3:
                //  3 = partial handler "h..." 
                if (*pszBuf != *pszHandlerPos)
                {
                    // not a handler, skip tag
                    nState = 6;
                }
                else
                {
                    pszHandlerPos++;
                    if (!*pszHandlerPos) // at the end of the "handler" part
                        nState = 4;
                }
                break;
            case 4:
                //  4 = have "handler" -- skip spaces
                if (!isspace(*pszBuf))
                {
                    if (*pszBuf == '\"')
                    {
                        bInQuote = true;
                    }
                    else
                    {
                        pszBuf--;
                    }
                    nState = 5;
                }
                break;
            case 5:
                //  5 = have "handler" -- get name
                if (isspace(*pszBuf) && !bInQuote)
                {
                    if (*(pszHandlerName-1) != '/')
                    {
                        // end of the name -- jump to getting the first '}'
                        nState = 6;
                    }
                    else
                    {
                        nState = 4;
                    }
                }
                else if (*pszBuf == '}')
                {
                    // end of the name -- jump to getting the second '}'
                    nState = 7;
                }
                else if (*pszBuf == '\"')
                {
                    if (bInQuote)
                    {
                        bInQuote = false;
                    }
                    else
                    {
                        hcErr = HTTP_FAIL;
                        nState = 8;
                    }
                }
                else
                {
                    // ensure we don't overwrite the buffer
                    if (pszHandlerName-szHandlerName >= MAX_PATH+ATL_MAX_HANDLER_NAME_LEN+1)
                    {
                        hcErr =  HTTP_FAIL;
                        nState = 8;
                    }
                    else
                    {
                        *pszHandlerName++ = *pszBuf;
                    }
                }
                break;
            case 6:
                //  6 = scan until first '}'
                if (*pszBuf == '}')
                    nState = 7;
                break;
            case 7:
                //  7 = better be '}'
                if (*pszBuf != '}')
                {
                    hcErr = HTTP_ERROR(500, ISE_SUBERR_BAD_HANDLER_TAG);
                    nState = 8;
                }
                if (*szHandlerName)
                    nState = 8;
                else
                    nState = 0;
                break;
            default:
                __assume( 0 ); // the optimizer will not generate code for this branch
            }

            pszBuf++;
        }
    } while (dwRead != 0 && nState != 8);
    
    *pszHandlerName = '\0';

    return hcErr;
}

// _AtlCrackHandler cracks a request path of the form dll_path/handler_name into its
// consituent parts
// szHandlerDllName - the full handler path of the form "dll_path/handler_name"
// szDllPath - the DLL path (should be of length MAX_PATH+1)
// szHandlerName - the handler name (should be of length ATL_MAX_HANDLER_NAME_LEN+1)
//
inline BOOL _AtlCrackHandler(
    LPCSTR szHandlerDllName,
    LPSTR szDllPath,
    LPDWORD pdwDllPathLen,
    LPSTR szHandlerName,
    LPDWORD pdwHandlerNameLen) throw()
{
    ATLASSERT( szHandlerDllName != NULL );
    ATLASSERT( szDllPath != NULL );
    ATLASSERT( pdwDllPathLen != NULL );
    ATLASSERT( szHandlerName != NULL );
    ATLASSERT( pdwHandlerNameLen != NULL );
    
    BOOL bRet = TRUE;
    
    // skip leading spaces
    while (*szHandlerDllName && isspace(*szHandlerDllName))
        ++szHandlerDllName;

    // get the handler name
    LPSTR szSlash = strchr(szHandlerDllName, '/');
    LPSTR szEnd = NULL;
    LPSTR szSlashEnd = NULL;
    
    // if it is of the form <dll_name>/<handler_name>
    if (szSlash)
    {
        szEnd = szSlash;
        
        // skip trailing spaces on <dll_name>
        while (szEnd>szHandlerDllName && isspace(*(szEnd-1)))
            --szEnd;

        szSlash++;
        // skip leading whitespace
        while (*szSlash && isspace(*szSlash))
            szSlash++;
        
        // right trim szSlash;
        szSlashEnd = szSlash;
        while (*szSlashEnd && !isspace(*szSlashEnd))
            szSlashEnd++;       
    }
    else // only the <dll_name>
    {
        szSlash = "Default";
        szSlashEnd = szSlash+sizeof("Default")-1;

        // do it this way to handle paths with spaces
        // (e.g. "some path\subdirectory one\subdirectory two\dll_name.dll")
        szEnd = (LPSTR) (szHandlerDllName+strlen(szHandlerDllName));
        
        // skip trailing spaces
        while (szEnd>szHandlerDllName && isspace(*(szEnd-1)))
            --szEnd;
    }

    // if the dll path is quoted, strip the quotes
    if (*szHandlerDllName == '\"' && *(szEnd-1) == '\"' && szEnd > szHandlerDllName+2)
    {
        szHandlerDllName++;
        szEnd--;
    }

    if (*pdwDllPathLen > (DWORD)(szEnd-szHandlerDllName))
    {
        memcpy(szDllPath, szHandlerDllName, szEnd-szHandlerDllName);
        szDllPath[szEnd-szHandlerDllName] = '\0';
        *pdwDllPathLen = (DWORD)(szEnd-szHandlerDllName);
    }
    else
    {
        *pdwDllPathLen = (DWORD)(szEnd-szHandlerDllName)+1;
        bRet = FALSE;
    }

    if (*pdwHandlerNameLen > (DWORD)(szSlashEnd-szSlash))
    {
        memcpy(szHandlerName, szSlash, (szSlashEnd-szSlash));
        szHandlerName[szSlashEnd-szSlash] = '\0';
        *pdwHandlerNameLen = (DWORD)(szSlashEnd-szSlash);
    }
    else
    {
        *pdwHandlerNameLen = (DWORD)(szSlashEnd-szSlash)+1;
        bRet = FALSE;
    }
    
    return bRet;
}

inline HTTP_CODE _AtlLoadRequestHandler(
            LPCSTR szDllPath, 
            LPCSTR szHandlerName,
            IHttpServerContext *pServerContext, 
            HINSTANCE *phInstance, 
            IRequestHandler **ppHandler,
            IIsapiExtension *pExtension,
            IDllCache *pDllCache) throw(...)
{
    *phInstance = NULL;
    *ppHandler = NULL;

    ATLServerDllInfo DllInfo;
    DllInfo.pExtension = pExtension;
    DllInfo.pContext = pServerContext;
    if (!IsFullPathA(szDllPath))
    {
        CHAR szFileName[MAX_PATH];
        if (!GetScriptFullFileName(szDllPath, szFileName, pServerContext))
        {
            return HTTP_FAIL;
        }
        *phInstance = pDllCache->Load(szFileName, (void *)&DllInfo);
    }
    else
    {
        *phInstance = pDllCache->Load(szDllPath, (void *)&DllInfo);
    }
    if (!*phInstance)
    {
        ATLTRACE( "LoadLibrary failed: '%s' with error: %d\r\n", szDllPath, GetLastError() );
        return HTTP_ERROR(500, ISE_SUBERR_LOADLIB);
    }
    
    CComPtr<IUnknown> spUnk;

    if (!DllInfo.pfnGetHandler || 
        !DllInfo.pfnGetHandler(szHandlerName, pExtension, &spUnk) ||
        spUnk->QueryInterface(__uuidof(IRequestHandler), (void **)ppHandler))
    {
        pDllCache->Free(*phInstance);
        *phInstance = NULL;
        return HTTP_ERROR(500, ISE_SUBERR_HANDLER_NOT_FOUND);
    }

    return HTTP_SUCCESS;
} // _AtlLoadRequestHandler


class CTransferServerContext : public CComObjectRootEx<CComMultiThreadModel>,
    public CWrappedServerContext
{
public:
    char m_szFileName[MAX_PATH+1];
    char m_szQueryString[ATL_URL_MAX_PATH_LENGTH+1];
    IWriteStream *m_pStream;

    BEGIN_COM_MAP(CTransferServerContext)
        COM_INTERFACE_ENTRY(IHttpServerContext)
    END_COM_MAP()

    CTransferServerContext() throw()
    {
        m_pStream = NULL;
    }

    BOOL Initialize(LPCSTR szUrl, IWriteStream *pStream, IHttpServerContext *pParent) throw()
    {
        m_pStream = pStream;
        m_spParent = pParent;
		m_szFileName[0] = '\0';
		long nUrlLen = (long)strlen(szUrl);

        if (!IsFullPathA(szUrl))
        {
            DWORD dwLen = MAX_PATH;
            BOOL bRet = m_spParent->GetServerVariable(
                                        "APPL_PHYSICAL_PATH",
                                        m_szFileName,
                                        &dwLen);
            if (!bRet)
                return FALSE;
        }

		// check for query params
        LPCSTR szMark = strchr(szUrl, '?');
        if (szMark)
        {
			long nPathLen = (long) (szMark - szUrl);
			if (strlen(m_szFileName) + nPathLen < MAX_PATH)
			{
				if (m_szFileName[0])
					strncat(m_szFileName, szUrl, nPathLen);
				else
				{
					memcpy(m_szFileName, szUrl, nPathLen);
					m_szFileName[nPathLen] = '\0';
				}
			}
			else
				return FALSE; // path would overwrite buffer

			// save query params
			if (strlen(szMark + 1) < ATL_URL_MAX_PATH_LENGTH)
				strcpy(m_szQueryString, szMark+1);
			else
				return FALSE; // url would overwrite buffer
        }
        else
        {
			// no query string
			if (strlen(m_szFileName) + nUrlLen < MAX_PATH)
			{
				if (m_szFileName[0])
					strcat(m_szFileName, szUrl);
				else
					strcpy(m_szFileName, szUrl);
			}
			else
				return FALSE; // path would be too long
            m_szQueryString[0] = '\0';
        }

        return TRUE;
    }

    BOOL WriteClient(void *pvBuffer, DWORD *pdwBytes) throw()
    {
        HRESULT hr = m_pStream->WriteStream((LPCSTR) pvBuffer, *pdwBytes, pdwBytes);
        return SUCCEEDED(hr);
    }


    LPCSTR GetQueryString() throw()
    {
        ATLASSERT(m_spParent);
        return m_szQueryString;
    }

    LPCSTR GetScriptPathTranslated() throw()
    {
        ATLASSERT(m_spParent);
        return m_szFileName;
    }

    LPCSTR GetPathTranslated() throw()
    {
        ATLASSERT(m_spParent);
        return m_szFileName;
    }

    // Asynchronous writes will not work properly in a child handler
    BOOL AsyncWriteClient(void * /*pvBuffer*/, DWORD * /*pdwBytes*/) throw()
    {
        ATLASSERT(FALSE);
        return FALSE;
    }

    // These next few methods are to protect against attempting to parse form data twice
    // We tell the new handler that it was a GET request
    LPCSTR GetRequestMethod() throw()
    {
        ATLASSERT(m_spParent);
        return "GET";
    }

    // The handler should not query these methods -- they are only useful if attempting to
    // parse form data, which is not allowed in child handlers.
    BOOL ReadClient(void * /*pvBuffer*/, DWORD * /*pdwSize*/) throw()
    {
        return FALSE;
    }

    BOOL AsyncReadClient(void * /*pvBuffer*/, DWORD * /*pdwSize*/) throw()
    {
        return FALSE;
    }

    DWORD GetTotalBytes() throw()
    {       
        ATLASSERT(FALSE);
        return 0;
    }

    DWORD GetAvailableBytes() throw()
    {
        ATLASSERT(FALSE);
        return 0;
    }

    BYTE *GetAvailableData() throw()
    {
        ATLASSERT(FALSE);
        return NULL;
    }

    LPCSTR GetContentType() throw()
    {
        ATLASSERT(FALSE);
        return 0;
    }
};

inline HTTP_CODE _AtlTransferRequest(
    AtlServerRequest *pRequest, 
    IServiceProvider *pServiceProvider,
    IWriteStream *pWriteStream,
    IHttpRequestLookup *pLookup,
    LPCSTR szNewUrl,
    WORD nCodePage,
    bool bContinueAfterProcess = false,
    void *pState = NULL) throw(...)
{
    ATLASSERT(pRequest != NULL);
    AtlServerRequest* pRequestInfo = NULL;
    HTTP_CODE dwErr = HTTP_SUCCESS;

    CComPtr<IStencilCache> spStencilCache;

    if (pRequest->pServerContext == NULL)
        return HTTP_ERROR(500, 0);

    pServiceProvider->QueryService(
                                    __uuidof(IStencilCache),
                                    __uuidof(IStencilCache),
                                    (void**)&spStencilCache
                                    );
    if (!spStencilCache)
        return HTTP_ERROR(500, 0);

    CComObjectStackEx<CTransferServerContext> serverContext;
    serverContext.Initialize(szNewUrl, pWriteStream, pRequest->pServerContext);

    CStencilState* _pState = reinterpret_cast<CStencilState*>(pState);
    if (_pState && _pState->pIncludeInfo)
    {
        pRequestInfo = _pState->pIncludeInfo;
        _pState->pIncludeInfo = NULL;
    }
    else
    {
        ATLASSERT(spStencilCache != NULL);
        ATLASSERT(pRequest->pDllCache != NULL);
        ATLASSERT(pRequest->pExtension != NULL);

        pRequestInfo = pRequest->pExtension->CreateRequest();
        if (pRequestInfo == NULL)
            return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM);

        pRequestInfo->dwRequestState = ATLSRV_STATE_BEGIN;
        pRequestInfo->dwRequestType = ATLSRV_REQUEST_STENCIL;
        pRequestInfo->pDllCache = pRequest->pDllCache;
        pRequestInfo->pExtension = pRequest->pExtension;
        pRequestInfo->pServerContext = &serverContext;
        if (_pState)
            pRequestInfo->pUserData = _pState->pParentInfo->pUserData;
        else
            pRequestInfo->pUserData = pRequest->pUserData;

        // Extract the file extension of the included file by searching
        // for the first '.' from the right.
        // Can't use _tcsrchr because we have to use the stencil's codepage
        LPSTR szDot = NULL;
        LPSTR szMark = serverContext.m_szFileName;
        while (*szMark)
        {
            if (*szMark == '.')
                szDot = szMark;

            szMark = CharNextExA(nCodePage, szMark, 0);
        }

        if (szDot && _stricmp(szDot, c_AtlSRFExtension) == 0)
        {
            dwErr = pRequest->pExtension->LoadDispatchFile(
                            serverContext.m_szFileName,
                            pRequestInfo
                            );
            if (dwErr)
                return dwErr;

            CComPtr<IHttpRequestLookup> spLookup;
            DWORD dwStatus;
            if (pLookup)

            {
                dwErr = pRequestInfo->pHandler->GetFlags(&dwStatus);
                if (dwErr)
                    return dwErr;

                if (dwStatus & (ATLSRV_INIT_USEASYNC | ATLSRV_INIT_USEASYNC_EX))
                {
                    CComObjectNoLock<CTransferServerContext>* pServerContext = NULL;
                    ATLTRY(pServerContext = new CComObjectNoLock<CTransferServerContext>);
                    if (pServerContext == NULL)
                        return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM);
                    pServerContext->Initialize(szNewUrl, pWriteStream, pRequest->pServerContext);

                    pServerContext->AddRef();
                    pRequestInfo->pServerContext = pServerContext;
                }

                dwErr = pRequestInfo->pHandler->InitializeChild(
                                    pRequestInfo,
                                    pServiceProvider,
                                    pLookup);
                if (dwErr)
                    return dwErr;

            }
        }
        else if (szDot && _stricmp(szDot, ".dll") == 0)
        {
            // Get the handler name if they used the asdf.dll?Handler=Default notation
            // REVIEW : case sensitivity on the "Handler"?
            char szHandlerName[ATL_MAX_HANDLER_NAME_LEN+1] = { '\0' };

            LPSTR szStart = strstr(serverContext.m_szQueryString, "Handler");
            if (szStart)
            {
                szStart += 8;  // Skip past "Handler" and the "="
                LPSTR szEnd = strchr(szStart, '&');
                if (szEnd)
                {
                    memcpy(szHandlerName, szStart, min((szEnd-szStart), ATL_MAX_HANDLER_NAME_LEN));
                    szHandlerName[min((szEnd-szStart), ATL_MAX_HANDLER_NAME_LEN)] = '\0';
                }
                else
                {
                    strcpy(szHandlerName, szStart);
                }
            }
            else
            {
                memcpy(szHandlerName, "Default", sizeof("Default"));
            }

            pRequestInfo->dwRequestType = ATLSRV_REQUEST_DLL;

            dwErr = pRequest->pExtension->LoadRequestHandler(
                                            serverContext.m_szFileName,
                                            szHandlerName,
                                            pRequestInfo->pServerContext,
                                            &pRequestInfo->hInstDll,
                                            &pRequestInfo->pHandler
                                            );
			if (dwErr != HTTP_SUCCESS)
				return dwErr;

            ATLASSERT(pLookup);
            dwErr = pRequestInfo->pHandler->InitializeChild(
                                            pRequestInfo,
                                            pServiceProvider,
                                            pLookup
                                            );
        }

        pRequestInfo->pfnHandleRequest = &IRequestHandler::HandleRequest;
    }

    if (pRequestInfo)
    {
        if (!dwErr)
        {
            if (pRequestInfo->pServerContext == NULL)
                pRequestInfo->pServerContext = &serverContext;

            ATLASSERT(pRequestInfo->pfnHandleRequest != NULL);
            dwErr = (pRequestInfo->pHandler->*pRequestInfo->pfnHandleRequest)(pRequestInfo, pServiceProvider);

            if (pRequestInfo->pServerContext == &serverContext)
                pRequestInfo->pServerContext = NULL;

            if (IsAsyncStatus(dwErr))
            {
                ATLASSERT(pState); // state is required for async
                if (IsAsyncContinueStatus(dwErr))
                {
                    _pState->pIncludeInfo = pRequestInfo;
                    pRequestInfo->dwRequestState = ATLSRV_STATE_CONTINUE;
                }
                else if (IsAsyncDoneStatus(dwErr))
                    pRequest->pExtension->FreeRequest(pRequestInfo);
            }
            else
                pRequest->pExtension->FreeRequest(pRequestInfo);
        }
    }
    else
        dwErr = HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);

    if (dwErr == HTTP_SUCCESS && bContinueAfterProcess)
        return dwErr;
    return HTTP_SUCCESS_NO_PROCESS;
}

//
// Used to terminate process when buffer security check fails
//
inline void __cdecl AtlsSecErrHandlerFunc(int nCode, void * /* pv */)
{
    nCode;

#if defined(_M_IX86)
    //
    // only valid code
    //
    ATLASSERT( nCode == _SECERR_BUFFER_OVERRUN );
#endif

    //
    // a buffer overflow has occurred in your code
    //
    ATLASSERT( FALSE );

    //
    // terminate process (safest thing to do)
    //
    TerminateProcess( GetCurrentProcess(), 1 );
}

//
// Class CIsapiExtension
// The main ISAPI Extension implementation.
// Template parameters
// ThreadPoolClass: Specifies the thread pool that will be used by the 
//		extension to queue incoming requests. CThreadPool is the
//		default and is declared and implemented in ATLUTIL.H. This class
//		templatizes on a worker thread class. The worker thread class
//		represents an abstraction of a thread that will be used to
//		process requests as they are dequeued from the pool's work queue.
//		You would change this parameter if you wanted to use a completely
//		different thread pool, or, more commonly, if you wanted to use 
//		a different worker thread class. Request processing code can
//		access a pointer to the worker thread class, which allows the
//		request handling code to easily access per-thread data.
// CRequestStatClass:	Specifies the class to be used to track request statistics
//		CNoRequestStats is the default which is a noop class.
//		You would change this parameter to provide a class that will
//		track request statistics for you. ATL provides CStdRequestStats
//		and CPerfRequestStatObject but these classes should be used
//		with caution because they require interlocked operations to
//		keep track of request statistics which can affect server performance.
// HttpUserErrorTextProvider: This class provides error text messages
//		and headers, including  resource IDs of error messages to the
//		isapi extension's error handling functions. You would change this
//		parameter if you wanted to provide your own error headers and/or
//		messages in response to error encountered during request processing.
// WorkerThreadClass: The worker thread that will be used for this extension.
//		The worker thread will be used to sweep any caches used by the extension
//		and perform other periodic maintanence work while the extension is 
//		loaded. You would provide your own worker thread class to customize
//		when the worker thread times out.
// CPageCacheStats, CStencilCacheStats: These two classes are used to keep
//		statistics about the page and stencil caches. You could change these
//		paramters if you wanted to track statistics for these caches. ATL
//		provides CPerfStatClass and CStdStatClass to store the stat data but
//		using these classes can affect server performance because they use
//		interlocked operations internally to store the data.
template <  class ThreadPoolClass=CThreadPool<CIsapiWorker>, 
            class CRequestStatClass=CNoRequestStats,
            class HttpUserErrorTextProvider=CDefaultErrorProvider,
            class WorkerThreadTraits=DefaultThreadTraits,
            class CPageCacheStats=CNoStatClass,
            class CStencilCacheStats=CNoStatClass>
class CIsapiExtension :
    public IServiceProvider, public IIsapiExtension, public IRequestStats
{
#ifndef ATL_NO_CRITICAL_ISAPI_ERROR

	DWORD m_dwCriticalIsapiError;

#endif // ATL_NO_CRITICAL_ISAPI_ERROR

protected:
    typedef CWorkerThread<WorkerThreadTraits> extWorkerType;

    extWorkerType m_WorkerThread;
    ThreadPoolClass m_ThreadPool;
    
    CDllCache<extWorkerType, CDllCachePeer> m_DllCache;
    CFileCache<extWorkerType, CPageCacheStats, CPageCachePeer> m_PageCache;
    CComObjectGlobal<CStencilCache<extWorkerType, CStencilCacheStats > > m_StencilCache;
    HttpUserErrorTextProvider m_UserErrorProvider;
    HANDLE m_hRequestHeap;
    CComCriticalSection m_critSec;

    // Dynamic services stuff
    struct ServiceNode
    {
        HINSTANCE hInst;
        IUnknown *punk;
        GUID guidService;
        IID riid;

        ServiceNode() throw()
        {
        }

        ServiceNode(const ServiceNode& that) throw()
            :hInst(that.hInst), punk(that.punk), guidService(that.guidService), riid(that.riid)
        {
        }
    };

    class CServiceEqualHelper
    {
    public:
        static bool IsEqual(const ServiceNode& t1, const ServiceNode& t2) throw()
        {
            return (InlineIsEqualGUID(t1.guidService, t2.guidService) != 0 &&
                    InlineIsEqualGUID(t1.riid, t2.riid) != 0);
        }
    };

    CSimpleArray<ServiceNode, CServiceEqualHelper> m_serviceMap;

public:
    DWORD m_dwTlsIndex;
    CWin32Heap m_heap;

    CRequestStatClass m_reqStats;

    AtlServerRequest *CreateRequest() throw()
    {
        // Allocate a fixed block size to avoid fragmentation
        AtlServerRequest *pRequest = (AtlServerRequest *) HeapAlloc(m_hRequestHeap, 
                HEAP_ZERO_MEMORY, max(sizeof(AtlServerRequest), sizeof(_CComObjectHeap<CServerContext>)));
        if (!pRequest)
            return NULL;
        pRequest->cbSize = sizeof(AtlServerRequest);
        return pRequest;
    }

    void FreeRequest(AtlServerRequest *pRequest) throw()
    {
        _ReleaseAtlServerRequest(pRequest);
        HeapFree(m_hRequestHeap, 0, pRequest);
    }

    CIsapiExtension() throw()
    {
        m_hRequestHeap = NULL;
#ifdef _DEBUG
        m_bDebug = FALSE;
#endif
#ifndef ATL_NO_CRITICAL_ISAPI_ERROR
		
		m_dwCriticalIsapiError = 0;

#endif // ATL_NO_CRITICAL_ISAPI_ERROR

    }

    HTTP_CODE TransferRequest(
                        AtlServerRequest *pRequest, 
                        IServiceProvider *pServiceProvider,
                        IWriteStream *pWriteStream,
                        IHttpRequestLookup *pLookup,
                        LPCSTR szNewUrl,
                        WORD nCodePage,
                        bool bContinueAfterProcess = false,
                        void *pState = NULL
                        ) throw(...)
    {
        return _AtlTransferRequest(pRequest, pServiceProvider, pWriteStream,
            pLookup, szNewUrl, nCodePage, bContinueAfterProcess, pState);
    }

#ifndef ATL_NO_CRITICAL_ISAPI_ERROR
	DWORD ReturnCriticalError(EXTENSION_CONTROL_BLOCK *pECB) throw()
	{
        UINT uResId = 0;
		LPCSTR szHeader = NULL;

		m_UserErrorProvider.GetErrorText(500,
										 ISE_SUBERR_ISAPISTARTUPFAILED,
										 &szHeader,
										 &uResId);
		_ATLTRY
		{
			CStringA strStatus, strBody;
			strStatus.Format("500 %s", szHeader);
			if (uResId)
			{
				// load the body string from a resource
				if (!strBody.LoadString(uResId))
				{
					strBody = "<html><body>A critical error has occurred initializing this ISAPI extension.</body></html>";
				}
			}


			HSE_SEND_HEADER_EX_INFO hex;
			hex.pszStatus = (LPCSTR)strStatus;
			hex.pszHeader = NULL;
			hex.cchStatus = (DWORD)strStatus.GetLength();
			hex.cchHeader = 0;
			hex.fKeepConn = FALSE;

			pECB->ServerSupportFunction(pECB->ConnID,
										HSE_REQ_SEND_RESPONSE_HEADER_EX,
										&hex,
										NULL,
										NULL);

			DWORD dwBodyLen = strBody.GetLength();
			pECB->WriteClient(pECB->ConnID, 
							 (void *) (LPCSTR) strBody,
							 &dwBodyLen,
							 NULL);
		}
		_ATLCATCHALL()
		{
			//REALLY BAD!
			return HSE_STATUS_ERROR;
		}
		return HSE_STATUS_SUCCESS;
	}
#endif // ATL_NO_CRITICAL_ISAPI_ERROR

    DWORD HttpExtensionProc(LPEXTENSION_CONTROL_BLOCK lpECB) throw()
    {
#ifndef ATL_NO_CRITICAL_ISAPI_ERROR
		if (GetCriticalIsapiError() != 0)
		{
			return ReturnCriticalError(lpECB);
		}
#endif // ATL_NO_CRITICAL_ISAPI_ERROR

        AtlServerRequest *pRequestInfo = NULL;
        pRequestInfo = CreateRequest();
        if (pRequestInfo == NULL)
            return HSE_STATUS_ERROR;

        CServerContext *pServerContext = NULL;
        ATLTRY(pServerContext = CreateServerContext(m_hRequestHeap));
        if (pServerContext == NULL)
        {
            FreeRequest(pRequestInfo);
            return HSE_STATUS_ERROR;
        }
        pServerContext->Initialize(lpECB);
        pServerContext->AddRef();

        pRequestInfo->pServerContext = pServerContext;
        pRequestInfo->dwRequestType = ATLSRV_REQUEST_UNKNOWN;
        pRequestInfo->dwRequestState = ATLSRV_STATE_BEGIN;
        pRequestInfo->pExtension = static_cast<IIsapiExtension *>(this);
        pRequestInfo->pDllCache = static_cast<IDllCache *>(&m_DllCache);
#ifndef ATL_NO_MMSYS
        pRequestInfo->dwStartTicks = timeGetTime();
#else
        pRequestInfo->dwStartTicks = GetTickCount();
#endif
        pRequestInfo->pECB = lpECB;

        m_reqStats.OnRequestReceived();

        if (m_ThreadPool.QueueRequest(pRequestInfo))
            return HSE_STATUS_PENDING;

        // QueueRequest failed
        FreeRequest(pRequestInfo);
        return HSE_STATUS_ERROR;
    }


    BOOL QueueRequest(AtlServerRequest * pRequestInfo) throw()
    {
        return m_ThreadPool.QueueRequest(pRequestInfo);
    }

    CIsapiWorker *GetThreadWorker() throw()
    {
        return (CIsapiWorker *) TlsGetValue(m_dwTlsIndex);
    }

    BOOL SetThreadWorker(CIsapiWorker *pWorker) throw()
    {
        return TlsSetValue(m_dwTlsIndex, (void*)pWorker);
    }


    // Configuration functions -- override in base class if another value is desired
    virtual LPCSTR GetExtensionDesc() throw() { return "VC Server Classes"; }
    virtual int GetNumPoolThreads() throw() { return 0; }
    virtual int GetPoolStackSize() throw() { return 0; }
    virtual HANDLE GetIOCompletionHandle() throw() { return INVALID_HANDLE_VALUE; }
    virtual DWORD GetDllCacheTimeout() throw() { return ATL_DLL_CACHE_TIMEOUT; }
    virtual DWORD GetStencilCacheTimeout() throw() { return ATL_STENCIL_CACHE_TIMEOUT; }
    virtual LONGLONG GetStencilLifespan() throw() { return ATL_STENCIL_LIFESPAN; }

    BOOL OnThreadAttach() throw()
    {
        return SUCCEEDED(CoInitializeEx(NULL, COINIT_APARTMENTTHREADED));
    }

    void OnThreadTerminate() throw()
    {
        CoUninitialize();
    }


#ifndef ATL_NO_CRITICAL_ISAPI_ERROR
	BOOL SetCriticalIsapiError(DWORD dwErr = 1) throw()
	{
		m_dwCriticalIsapiError = dwErr;
		return TRUE;
	}


	DWORD GetCriticalIsapiError() throw()
	{
		return m_dwCriticalIsapiError;
	}

#else
	BOOL SetCriticalIsapiError(DWORD dwErr = 1) throw()
	{
		return FALSE;
	}

	DWORD GetCriticalIsapiError() throw()
	{
		return 0;
	}

#endif // ATL_NO_CRITICAL_ISAPI_ERROR


    BOOL GetExtensionVersion(HSE_VERSION_INFO* pVer) throw()
    {
        // allocate a Tls slot for storing per thread data
        m_dwTlsIndex = TlsAlloc();

        // create a private heap for request data
        // this heap has to be thread safe to allow for
        // async processing of requests
        m_hRequestHeap = HeapCreate(0, 0, 0);
        if (!m_hRequestHeap)
        {
            ATLTRACE(atlTraceISAPI, 0, _T("Failed creating request heap.  Using process heap\n"));
            m_hRequestHeap = GetProcessHeap();
			if (!m_hRequestHeap)
			{
				return SetCriticalIsapiError();
			}

        }

        // create a private heap (synchronized) for
        // allocations.  This reduces fragmentation overhead
        // as opposed to the process heap
        HANDLE hHeap = HeapCreate(0, 0, 0);
        if (!hHeap)
        {
            ATLTRACE(atlTraceISAPI, 0, _T("Failed creating extension heap.  Using process heap\n"));
            hHeap = GetProcessHeap();
            m_heap.Attach(hHeap, false);
        }
        else
        {
            m_heap.Attach(hHeap, true);
        }
        hHeap = NULL;

        if (S_OK != m_reqStats.Initialize())
        {
			ATLTRACE(atlTraceISAPI,
				     0,
					 _T("Initialization failed for request statistics perfmon support.\n")
					 _T("Check request statistics perfmon dll registration\n") );

			return SetCriticalIsapiError();
        }

        if (S_OK != m_WorkerThread.Initialize())
        {
            return SetCriticalIsapiError();
        }

        if (m_critSec.Init() != S_OK)
        {
            m_WorkerThread.Shutdown();
            return SetCriticalIsapiError();
        }

        if (S_OK != m_ThreadPool.Initialize(static_cast<IIsapiExtension*>(this), GetNumPoolThreads(), GetPoolStackSize(), GetIOCompletionHandle()))
        {
            m_WorkerThread.Shutdown();
            m_critSec.Term();
            return SetCriticalIsapiError();
        }


        if (FAILED(m_DllCache.Initialize(&m_WorkerThread, GetDllCacheTimeout())))
        {
            m_WorkerThread.Shutdown();
            m_ThreadPool.Shutdown();
            m_critSec.Term();
            return SetCriticalIsapiError();
        }

        if (FAILED(m_PageCache.Initialize(&m_WorkerThread)))
        {
            m_WorkerThread.Shutdown();
            m_ThreadPool.Shutdown();
            m_DllCache.Uninitialize();
            m_critSec.Term();
            return SetCriticalIsapiError();
        }

		if (S_OK != m_StencilCache.Initialize(static_cast<IServiceProvider*>(this),
										  &m_WorkerThread, 
										  GetStencilCacheTimeout(),
										  GetStencilLifespan()))
		{
			m_WorkerThread.Shutdown();
			m_ThreadPool.Shutdown();
			m_DllCache.Uninitialize();
            m_PageCache.Uninitialize();
            m_critSec.Term();
			return SetCriticalIsapiError();
        }

        pVer->dwExtensionVersion = HSE_VERSION;
        strcpy(pVer->lpszExtensionDesc, GetExtensionDesc());

        return TRUE;
    }

    BOOL TerminateExtension(DWORD /*dwFlags*/) throw()
    {
        m_critSec.Lock();
        for (int i=0; i < m_serviceMap.GetSize(); i++)
        {
            ATLASSERT(m_serviceMap[i].punk != NULL);
            m_serviceMap[i].punk->Release();
            m_DllCache.ReleaseModule(m_serviceMap[i].hInst);
        }
        m_critSec.Unlock();

		m_ThreadPool.Shutdown();
		m_StencilCache.Uninitialize();
		m_DllCache.Uninitialize();
        m_PageCache.Uninitialize();
        m_WorkerThread.Shutdown();
        m_reqStats.Uninitialize();
        m_critSec.Term();
        
        // free the request heap
        if (m_hRequestHeap != GetProcessHeap())
            HeapDestroy(m_hRequestHeap);

        // free the Tls slot that we allocated
        TlsFree(m_dwTlsIndex);

        return TRUE;
    }

    static void WINAPI AsyncCallback(LPEXTENSION_CONTROL_BLOCK /*lpECB*/,
                                     PVOID pContext,
                                     DWORD cbIO,
                                     DWORD dwError) throw(...)
    {
        ATLASSERT(pContext);

        AtlServerRequest *pRequestInfo = reinterpret_cast<AtlServerRequest*>(pContext);
        ATLASSERT(pRequestInfo);
        if (pRequestInfo->m_hMutex)
        {
            // synchronize in case the previous async_noflush call isn't finished
            // setting up state for the next call.
            DWORD dwStatus = WaitForSingleObject(pRequestInfo->m_hMutex, ATLS_ASYNC_MUTEX_TIMEOUT);
            if (dwStatus != WAIT_OBJECT_0 && dwStatus != WAIT_ABANDONED)
            {
				_ATLTRY
				{
					pRequestInfo->pExtension->RequestComplete(pRequestInfo, 500, ISE_SUBERR_UNEXPECTED);
				}
				_ATLCATCHALL()
				{
					ATLTRACE(_T("Warning: Uncaught user exception thrown and caught in AsyncCallback.\n"));
					_ATLRETHROW;
				}
                return;
            }
        }

        if (pRequestInfo->pfnAsyncComplete != NULL)
            ATLTRY((*pRequestInfo->pfnAsyncComplete)(pRequestInfo, cbIO, dwError));

        if (pRequestInfo->dwRequestState == ATLSRV_STATE_DONE)
        {
			pRequestInfo->pExtension->RequestComplete(pRequestInfo, HTTP_ERROR_CODE(HTTP_SUCCESS), 0);
        }
        else if (pRequestInfo->dwRequestState == ATLSRV_STATE_CACHE_DONE)
        {
            CloseHandle(pRequestInfo->hFile);
            pRequestInfo->pFileCache->ReleaseFile(pRequestInfo->hEntry);
            pRequestInfo->pExtension->RequestComplete(pRequestInfo, HTTP_ERROR_CODE(HTTP_SUCCESS), 0);
        }
        else 
        {
            HANDLE hMutex = pRequestInfo->m_hMutex;
            pRequestInfo->pExtension->QueueRequest(pRequestInfo);
            if (hMutex)
                ReleaseMutex(hMutex);
        }
    }

    void HandleError(IHttpServerContext *pServerContext, DWORD dwStatus, DWORD dwSubStatus) throw()
    {
        RenderError(pServerContext, dwStatus, dwSubStatus, &m_UserErrorProvider);
    }

    void RequestComplete(AtlServerRequest *pRequestInfo, DWORD dwStatus, DWORD dwSubStatus) throw(...)
    {
        ATLASSERT(pRequestInfo);
        
        if (pRequestInfo->pHandler != NULL)
            pRequestInfo->pHandler->UninitializeHandler();

		DWORD dwReqStatus = dwStatus;
		if (!dwReqStatus)
			dwReqStatus = 200;

        if (dwStatus >= 400)
        {
            if (dwSubStatus != SUBERR_NO_PROCESS)
                HandleError(pRequestInfo->pServerContext, dwStatus, dwSubStatus);
            m_reqStats.RequestHandled(pRequestInfo, FALSE);
        }
        else
            m_reqStats.RequestHandled(pRequestInfo, TRUE);

        CComPtr<IHttpServerContext> spServerContext = pRequestInfo->pServerContext;

        FreeRequest(pRequestInfo);

        spServerContext->DoneWithSession(dwReqStatus);
    }

    HTTP_CODE GetHandlerName(LPCSTR szFileName, LPSTR szHandlerName) throw()
    {
        return _AtlGetHandlerName(szFileName, szHandlerName);
    }

    HTTP_CODE LoadDispatchFile(LPCSTR szFileName, AtlServerRequest *pRequestInfo) throw()
    {
        CStencil *pStencil = NULL;
        HCACHEITEM hStencil = NULL;
        
        // Must have space for the path to the handler + the maximum size
        // of the handler, plus the '/' plus the '\0'
        CHAR szDllPath[MAX_PATH+1];
        CHAR szHandlerName[ATL_MAX_HANDLER_NAME_LEN+1];

        pRequestInfo->pHandler = NULL;
        pRequestInfo->hInstDll = NULL;

        m_StencilCache.LookupStencil(szFileName, &hStencil);

        // Stencil was found, check to see if it needs to be refreshed
        if (hStencil)
        {
            m_StencilCache.GetStencil(hStencil, (void **) &pStencil);
            pStencil->GetHandlerName(szDllPath, szHandlerName);

            CFileTime cftCurr;
            CFileTime cftLastChecked;
            cftCurr = CFileTime::GetCurrentTime();

            pStencil->GetLastChecked(&cftLastChecked);

            CFileTimeSpan d(ATL_STENCIL_CHECK_TIMEOUT * CFileTime::Millisecond);

            if (cftLastChecked + d < cftCurr)
            {
                CComPtr<IStencilCacheControl> spCacheCtrl;
                m_StencilCache.QueryInterface(__uuidof(IStencilCacheControl), (void **)&spCacheCtrl);
                if (spCacheCtrl)
                {
                    CFileTime cftLastModified;
                    pStencil->GetLastModified(&cftLastModified);

                    // Resource based stencils have a last modified filetime of 0
                    if (cftLastModified != 0)
                    {
                        // for file base stencils, we check whether the file
                        // has been modified since being put in the cache
                        WIN32_FILE_ATTRIBUTE_DATA fad;
                        pStencil->SetLastChecked(&cftCurr);
                        BOOL bRet = GetFileAttributesExA(szFileName, GetFileExInfoStandard, &fad);

                        if ((bRet && cftLastModified < fad.ftLastWriteTime) ||
                            !bRet)
                        {
                            // the file has changed or an error has occurred trying to read the file, 
                            // so remove it from the cache and force a reload
                            spCacheCtrl->RemoveStencil(hStencil);
                            pStencil = NULL;
                            hStencil = NULL;
                        }
                    }
                }   
            }
        }


        if (!hStencil)
        {
            CHAR szHandlerDllName[MAX_PATH+ATL_MAX_HANDLER_NAME_LEN+2] = { '\0' };
            
            // not in the cache, so open the file
            HTTP_CODE hcErr = GetHandlerName(szFileName, szHandlerDllName);
            if (hcErr)
                return hcErr;
            DWORD dwDllPathLen = MAX_PATH+1;
            DWORD dwHandlerNameLen = ATL_MAX_HANDLER_NAME_LEN+1;
            if (!_AtlCrackHandler(szHandlerDllName, szDllPath, &dwDllPathLen, szHandlerName, &dwHandlerNameLen))
            {
                HTTP_ERROR(500, ISE_SUBERR_HANDLER_NOT_FOUND);
            }
            ATLASSERT(*szHandlerName);
            ATLASSERT(*szDllPath);
            if (!*szHandlerName)
                return HTTP_ERROR(500, ISE_SUBERR_HANDLER_NOT_FOUND);
        }
        else
            m_StencilCache.ReleaseStencil(hStencil);


        return LoadRequestHandler(szDllPath, szHandlerName, pRequestInfo->pServerContext, 
            &pRequestInfo->hInstDll, &pRequestInfo->pHandler);
    }

    HTTP_CODE LoadDllHandler(LPCSTR szFileName, AtlServerRequest *pRequestInfo) throw()
    {
        _ATLTRY
        {
            HTTP_CODE hcErr = HTTP_SUCCESS;
			CHAR szHandler[ATL_MAX_HANDLER_NAME_LEN+1] = { 'D', 'e', 'f', 'a', 'u', 'l', 't', '\0' };
			LPCSTR szQueryString = pRequestInfo->pServerContext->GetQueryString();
			if (szQueryString != NULL)
			{
				LPCSTR szHdlr = strstr(szQueryString, "Handler=");
				if (szHdlr != NULL)
				{
					if ((szHdlr == szQueryString) ||
						((szHdlr > szQueryString) && (*(szHdlr-1) == '&')))
					{
						int nCnt = 0;
						LPSTR pszHandler = szHandler;
						szHdlr += sizeof("Handler=")-1;
						while (*szHdlr && *szHdlr != '&')
						{
							if (nCnt < ATL_MAX_HANDLER_NAME_LEN)
							{
								*pszHandler++ = *szHdlr++;
								nCnt++;
							}
							else
							{
								hcErr = HTTP_ERROR(500, ISE_SUBERR_HANDLER_NOT_FOUND);
								break;
							}
						}
						if (hcErr == HTTP_SUCCESS)
						{
							*pszHandler = '\0';
						}
					}
				}
			}

			if (hcErr == HTTP_SUCCESS)
			{
				CHAR szFile[_MAX_PATH+ATL_MAX_HANDLER_NAME_LEN+1];
				strcpy(szFile, szFileName);

				hcErr = LoadRequestHandler(szFile, szHandler, pRequestInfo->pServerContext, &pRequestInfo->hInstDll, &pRequestInfo->pHandler);
			}

            return hcErr;
        }
        _ATLCATCHALL()
        {
            return HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);
        }
    }

    BOOL TransmitFromCache(AtlServerRequest* pRequestInfo) throw()
    {
        if (strcmp(pRequestInfo->pServerContext->GetRequestMethod(), "GET"))
            return FALSE;

        char szUrl[ATL_URL_MAX_URL_LENGTH + 1];
        LPCSTR szPathInfo = pRequestInfo->pServerContext->GetPathInfo();
        LPCSTR szQueryString = pRequestInfo->pServerContext->GetQueryString();

        LPSTR szTo = szUrl;
        while (*szPathInfo)
        {
            *szTo++ = *szPathInfo++;
        }
        *szTo++ = '?';
        while (*szQueryString)
        {
            *szTo++ = *szQueryString++;
        }
        *szTo = '\0';

        HCACHEITEM hEntry;

        if (S_OK == m_PageCache.LookupFile(szUrl, &hEntry))
        { 
            LPSTR szFileName;
			CPageCachePeer::PeerInfo *pInfo;
            m_PageCache.GetFile(hEntry, &szFileName, (void **)&pInfo);
            CAtlFile file;
			HRESULT hr = E_FAIL;

			_ATLTRY
			{
				CA2CTEX<MAX_PATH+1> strFile(szFileName);
				hr = file.Create(strFile,
								GENERIC_READ,
								FILE_SHARE_READ,
								OPEN_EXISTING,
								FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_OVERLAPPED);
			}
			_ATLCATCHALL()
			{
				return FALSE;
			}
            
            if (FAILED(hr) || GetFileType(file) != FILE_TYPE_DISK)
                return FALSE;

            pRequestInfo->pServerContext->SendResponseHeader(
				(LPCSTR)pInfo->strHeader, (LPCSTR)pInfo->strStatus, FALSE);
            HANDLE hFile = file.Detach();
            BOOL bRet = FALSE;

            pRequestInfo->dwRequestState = ATLSRV_STATE_CACHE_DONE;
            pRequestInfo->hFile = hFile;
            pRequestInfo->hEntry = hEntry;
            pRequestInfo->pFileCache = &m_PageCache;

            bRet = pRequestInfo->pServerContext->TransmitFile(
                hFile,                          // The file to transmit
                AsyncCallback, pRequestInfo,    // The async callback and context
                pInfo->strStatus,               // HTTP status code
                0,                              // Send entire file
                0,                              // Start at the beginning of the file
                NULL, 0,                        // Head and length
                NULL, 0,                        // Tail and length
                HSE_IO_ASYNC | HSE_IO_DISCONNECT_AFTER_SEND // Send asynchronously
                );
            if (!bRet)
            {
                m_PageCache.ReleaseFile(hEntry);
                CloseHandle(hFile);
            }
            return TRUE;
        }
        else
            return FALSE;
    }

#ifdef _DEBUG
    BOOL m_bDebug;
    // F5 debugging support for VS7
    BOOL ProcessDebug(AtlServerRequest *pRequestInfo) throw()
    {
        _ATLTRY
        {
            if (!_stricmp(pRequestInfo->pServerContext->GetRequestMethod(), "debug"))
            {
                DWORD dwHeadersLen = 0;
                CStringA strHeaders;
                pRequestInfo->pServerContext->GetServerVariable("ALL_HTTP", NULL, &dwHeadersLen);
                BOOL bRet = pRequestInfo->pServerContext->GetServerVariable("ALL_HTTP", strHeaders.GetBuffer(dwHeadersLen), &dwHeadersLen);
                if (!bRet)
                {
                    RequestComplete(pRequestInfo, 501, 0);
                    return FALSE;
                }
                strHeaders.ReleaseBuffer(dwHeadersLen - 1);
                LPCSTR szCur = (LPCSTR)strHeaders;

                while(*szCur)
                {
                    if (!strncmp(szCur, "HTTP_COMMAND:", 13))
                    {
                        szCur += 13;
                        break;
                    }
                    
                    szCur = strchr(szCur, '\n');
                    if (!szCur)
                    {
                        RequestComplete(pRequestInfo, 501, 0);
                        return FALSE;
                    }

                    szCur++;
                }


                if (!_strnicmp(szCur, "start-debug", sizeof("start-debug")-sizeof('\0')))
                {
                    CCritSecLock Lock(m_critSec.m_sec);
                    if (m_bDebug)
                    {            
                        HandleError(pRequestInfo->pServerContext, 204, DBG_SUBERR_ALREADY_DEBUGGING);
                        RequestComplete(pRequestInfo, 204, DBG_SUBERR_ALREADY_DEBUGGING);   // Already being debugged by another process
                        return FALSE;
                    }
                    CHttpRequest HttpRequest;
                    HttpRequest.Initialize(pRequestInfo->pServerContext);
                    HttpRequest.InitFromPost();
                    LPCSTR szString;
                    szString = HttpRequest.FormVars.Lookup("DebugSessionID");
                    if (!szString || !*szString)
                    {
                        HandleError(pRequestInfo->pServerContext, 204, DBG_SUBERR_INVALID_SESSION);
                        RequestComplete(pRequestInfo, 204, DBG_SUBERR_INVALID_SESSION);
                        return FALSE;
                    }
                    CA2W szSessionID(szString);
                    if (!szSessionID)
                    {
                        HandleError(pRequestInfo->pServerContext, 500, ISE_SUBERR_OUTOFMEM);
                        RequestComplete(pRequestInfo, 500, ISE_SUBERR_OUTOFMEM);
                        return FALSE;
                    }
                    DWORD dwPid = GetCurrentProcessId();
                    LPWSTR szPoint = szSessionID;
                    while (szPoint && *szPoint && wcsncmp(szPoint, L"autoattachclsid=", 16))
                    {
                        szPoint = wcschr(szPoint, ';');
                        if (szPoint)
                            szPoint++;
                    }
                    
                    if (!szPoint || !*szPoint)
                    {
                        HandleError(pRequestInfo->pServerContext, 204, DBG_SUBERR_BAD_ID);
                        RequestComplete(pRequestInfo, 204, DBG_SUBERR_BAD_ID);
                        return FALSE;
                    }

                    szPoint += (sizeof("autoattachclsid=") - 1);
                    WCHAR szClsid[39];
                    wcsncpy(szClsid, szPoint, 38);
                    szClsid[38] = '\0';

                    CLSID clsidDebugAutoAttach = CLSID_NULL;
                    HRESULT hr = CLSIDFromString(szClsid, &clsidDebugAutoAttach);
                    
                    if (hr != S_OK)
                    {
                        HandleError(pRequestInfo->pServerContext, 204, DBG_SUBERR_BAD_ID);
                        RequestComplete(pRequestInfo, 204, DBG_SUBERR_BAD_ID);
                        return FALSE;
                    }

                    CComPtr<IDebugAutoAttach> spDebugAutoAttach;
                    hr = CoCreateInstance(clsidDebugAutoAttach, NULL, CLSCTX_LOCAL_SERVER, __uuidof(IDebugAutoAttach), (void**)&spDebugAutoAttach);
                    if (FAILED(hr))
                    {
                        if (hr == E_ACCESSDENIED)
                            RequestComplete(pRequestInfo, 401, 0);
                        else
                        {
                            HandleError(pRequestInfo->pServerContext, 204, DBG_SUBERR_COCREATE);
                            RequestComplete(pRequestInfo, 204, DBG_SUBERR_COCREATE);
                        }
                        return FALSE;
                    }
                    hr = spDebugAutoAttach->AutoAttach(GUID_NULL, dwPid, AUTOATTACH_PROGRAM_WIN32, 0, szSessionID);
                    if (FAILED(hr))
                    {
//                        HandleError(pRequestInfo->pServerContext, 204, DBG_SUBERR_ATTACH);
						char szRetBuf[256];
						DWORD dwLen = wsprintfA(szRetBuf, "204 HRESULT=0x%.08X;ErrorString=Unable to attach to worker process", hr);
						pRequestInfo->pServerContext->SendResponseHeader(NULL, szRetBuf, FALSE);
						pRequestInfo->pServerContext->WriteClient(szRetBuf, &dwLen);
                        RequestComplete(pRequestInfo, 204, DBG_SUBERR_ATTACH);
                        return FALSE;
                    }
                    m_bDebug = TRUE;
                    HandleError(pRequestInfo->pServerContext, 200, SUBERR_NONE);
                    RequestComplete(pRequestInfo, 200, SUBERR_NONE);
                    return FALSE;
                }
                else if (!_strnicmp(szCur, "stop-debug", sizeof("stop-debug")-sizeof('\0')))
                {
                    m_bDebug = FALSE;
                    HandleError(pRequestInfo->pServerContext, 200, SUBERR_NONE);
                    RequestComplete(pRequestInfo, 200, SUBERR_NONE);
                    return FALSE;
                }
                else
                {
                    RequestComplete(pRequestInfo, 501, SUBERR_NONE);   // Not Implemented
                    return FALSE;
                }            
            }
            return TRUE;
        }
        _ATLCATCHALL()
        {
            return FALSE;
        }
    }
#endif

    BOOL DispatchStencilCall(AtlServerRequest *pRequestInfo) throw(...)
    {
        CSetThreadToken sec;

        m_reqStats.OnRequestDequeued();

        if (!sec.Initialize(pRequestInfo))
        {
            RequestComplete(pRequestInfo, 500, ISE_SUBERR_IMPERSONATIONFAILED);
            return FALSE;
        }

#ifdef _DEBUG
        if (!ProcessDebug(pRequestInfo))
            return TRUE;
#endif
        if (pRequestInfo->m_hMutex)
        {
            // synchronize in case the previous async_noflush call isn't finished
            // setting up state for the next call.
            DWORD dwStatus = WaitForSingleObject(pRequestInfo->m_hMutex, ATLS_ASYNC_MUTEX_TIMEOUT);
            if (dwStatus != WAIT_OBJECT_0 && dwStatus != WAIT_ABANDONED)
            {
                RequestComplete(pRequestInfo, 500, ISE_SUBERR_UNEXPECTED);
                return FALSE;
            }
        }

#ifdef _DEBUG
        bool bAsyncAllowed = false;
#endif
        HTTP_CODE hcErr = HTTP_SUCCESS;
        if (pRequestInfo->dwRequestState == ATLSRV_STATE_BEGIN)
        {
            if (TransmitFromCache(pRequestInfo))    // Page is in the cache, send it and bail
            {                                       // Async Callback will handle freeing pRequestInfo
                return TRUE;
            }

            // get the srf filename
            LPCSTR szFileName = pRequestInfo->pServerContext->GetScriptPathTranslated();

            if (!szFileName)
            {
                RequestComplete(pRequestInfo, 500, ISE_SUBERR_UNEXPECTED);
                return FALSE;
            }

            LPCSTR szDot = szFileName + strlen(szFileName) - 1;

            // load a handler
            if (_stricmp(szDot - ATLS_EXTENSION_LEN, c_AtlSRFExtension) == 0)
            {
                pRequestInfo->dwRequestType = ATLSRV_REQUEST_STENCIL;
                hcErr = LoadDispatchFile(szFileName, pRequestInfo);
            }
            else if (_stricmp(szDot - 3, ".dll") == 0)
            {
                pRequestInfo->dwRequestType = ATLSRV_REQUEST_DLL;
                hcErr = LoadDllHandler(szFileName, pRequestInfo);
            }
            else
            {
                hcErr = HTTP_FAIL;
            }

            if (hcErr)
            {
                RequestComplete(pRequestInfo, HTTP_ERROR_CODE(hcErr), HTTP_SUBERROR_CODE(hcErr));
                return TRUE;
            }

            pRequestInfo->pfnHandleRequest = &IRequestHandler::HandleRequest;

            // initialize the handler
            DWORD dwStatus = 0;

            hcErr = pRequestInfo->pHandler->GetFlags(&dwStatus);

            if (dwStatus & ATLSRV_INIT_USECACHE &&
                !strcmp(pRequestInfo->pServerContext->GetRequestMethod(), "GET"))
            {
                CComObjectNoLock<CCacheServerContext> *pCacheServerContext = NULL;
                ATLTRY(pCacheServerContext = new CComObjectNoLock<CCacheServerContext>);
                if (pCacheServerContext == NULL)
                {
                    RequestComplete(pRequestInfo, 500, ISE_SUBERR_OUTOFMEM);
                    return FALSE;
                }

                pCacheServerContext->Initialize(pRequestInfo->pServerContext, &m_PageCache);
                pCacheServerContext->AddRef();
                pRequestInfo->pServerContext = pCacheServerContext;
            }

            if (dwStatus & (ATLSRV_INIT_USEASYNC | ATLSRV_INIT_USEASYNC_EX))
            {
#ifdef _DEBUG
                bAsyncAllowed = true;
#endif
                if (!pRequestInfo->pServerContext->RequestIOCompletion(AsyncCallback, (DWORD *)pRequestInfo))
                {
                    RequestComplete(pRequestInfo, 500, SUBERR_NONE);
                    return FALSE;
                }
            }

            if (dwStatus & ATLSRV_INIT_USEASYNC_EX)
            {
                pRequestInfo->m_hMutex = CreateMutex(NULL, FALSE, NULL);
                if (pRequestInfo->m_hMutex == NULL)
                {
                    RequestComplete(pRequestInfo, 500, ISE_SUBERR_SYSOBJFAIL);
                    return FALSE;
                }

                DWORD dwStatus = WaitForSingleObject(pRequestInfo->m_hMutex, 10000);
                if (dwStatus != WAIT_OBJECT_0 && dwStatus != WAIT_ABANDONED)
                {
                    RequestComplete(pRequestInfo, 500, ISE_SUBERR_UNEXPECTED);
                    return FALSE;
                }
            }
            hcErr = pRequestInfo->pHandler->InitializeHandler(pRequestInfo, static_cast<IServiceProvider*>(this));
        }
#ifdef _DEBUG
        else // pRequestInfo->dwRequestState != ATLSRV_STATE_BEGIN
        {
            bAsyncAllowed = true;
        }
#endif

        ATLASSERT(pRequestInfo->pfnHandleRequest != NULL);

	    if (hcErr == HTTP_SUCCESS)
           hcErr = (pRequestInfo->pHandler->*pRequestInfo->pfnHandleRequest)(pRequestInfo, static_cast<IServiceProvider*>(this));
 
       if (hcErr == HTTP_SUCCESS_NO_CACHE)
        {
            CComPtr<IPageCacheControl> spControl;
            HRESULT hr = pRequestInfo->pServerContext->QueryInterface(__uuidof(IPageCacheControl), (void **)&spControl);
            if (hr == S_OK)
                spControl->Cache(FALSE);
        }

#ifdef _DEBUG
        // must use ATLSRV_INIT_USEASYNC to use ASYNC returns
        if (IsAsyncStatus(hcErr))
            ATLASSERT(bAsyncAllowed);

        // must use ATLSRV_INIT_USEASYNC_EX to use NOFLUSH returns
        if (IsAsyncNoFlushStatus(hcErr))
            ATLASSERT(pRequestInfo->m_hMutex);
#endif

        // save hMutex in case pRequestInfo is deleted by AsyncCallback after
        // we call StartAsyncFlush but before we check to see if we need to
        // call ReleaseMutex
        HANDLE hMutex = pRequestInfo->m_hMutex;

        if (IsAsyncStatus(hcErr))
        {
            if (IsAsyncDoneStatus(hcErr))
                pRequestInfo->dwRequestState = ATLSRV_STATE_DONE;
            else
                pRequestInfo->dwRequestState = ATLSRV_STATE_CONTINUE;

            if (IsAsyncFlushStatus(hcErr) && !StartAsyncFlush(pRequestInfo))
            {
                RequestComplete(pRequestInfo, 500, SUBERR_NONE);
                pRequestInfo = NULL;
            }
        }
        else
        {
            RequestComplete(pRequestInfo, HTTP_ERROR_CODE(hcErr), HTTP_SUBERROR_CODE(hcErr));
            pRequestInfo = NULL;
        }

        if (hMutex)
            ReleaseMutex(hMutex);

        return TRUE;
    }

    BOOL StartAsyncFlush(AtlServerRequest *pRequestInfo) throw()
    {
        if (pRequestInfo->pszBuffer == NULL || pRequestInfo->dwBufferLen == 0)
        {
            ATLASSERT(FALSE);
            return FALSE;
        }

        return pRequestInfo->pServerContext->AsyncWriteClient(
            LPVOID(pRequestInfo->pszBuffer),
            &pRequestInfo->dwBufferLen);
    }

    long GetTotalRequests() throw()
    {
        return m_reqStats.GetTotalRequests();
    }

    long GetFailedRequests() throw()
    {
        return m_reqStats.GetFailedRequests();
    }

    long GetAvgResponseTime() throw()
    {
        return m_reqStats.GetAvgResponseTime();
    }

    long GetCurrWaiting() throw()
    {
        return m_reqStats.GetCurrWaiting();
    }

    long GetMaxWaiting() throw()
    {
        return m_reqStats.GetMaxWaiting();
    }

    long GetActiveThreads() throw()
    {
        return m_reqStats.GetActiveThreads();
    }

    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppv) throw()
    {
        if (!ppv)
            return E_POINTER;
        if (InlineIsEqualGUID(riid, __uuidof(IRequestStats)))
        {
            *ppv = static_cast<IUnknown*>(static_cast<IRequestStats*>(this));
            AddRef();
            return S_OK;
        }
        if (InlineIsEqualGUID(riid, __uuidof(IUnknown)) ||
            InlineIsEqualGUID(riid, __uuidof(IServiceProvider)))
        {
            *ppv = static_cast<IUnknown*>(static_cast<IServiceProvider*>(this));
            AddRef();
            return S_OK;
        }
        if (InlineIsEqualGUID(riid, __uuidof(IIsapiExtension)))
        {
            *ppv = static_cast<IUnknown*>(static_cast<IIsapiExtension*>(this));
            AddRef();
            return S_OK;
        }
        return E_NOINTERFACE;
    }
    
    ULONG STDMETHODCALLTYPE AddRef() throw()
    {
        return 1;
    }
    
    ULONG STDMETHODCALLTYPE Release() throw()
    {
        return 1;
    }

    virtual HRESULT STDMETHODCALLTYPE QueryService(
        REFGUID guidService,
        REFIID riid,
        void **ppvObject) throw()
    {
        if (!ppvObject)
            return E_POINTER;

        if (InlineIsEqualGUID(guidService, __uuidof(IDllCache)))
            return m_DllCache.QueryInterface(riid, ppvObject);
        else if (InlineIsEqualGUID(guidService, __uuidof(IStencilCache)))
            return m_StencilCache.QueryInterface(riid, ppvObject);
        else if (InlineIsEqualGUID(guidService, __uuidof(IThreadPoolConfig)))
            return m_ThreadPool.QueryInterface(riid, ppvObject);
        else if (InlineIsEqualGUID(guidService, __uuidof(IAtlMemMgr)))
        {
            *ppvObject = static_cast<IAtlMemMgr *>(&m_heap);
            return S_OK;
        }
#ifndef ATL_NO_SOAP
		else if (InlineIsEqualGUID(guidService, __uuidof(ISAXXMLReader)))
		{
			CIsapiWorker *p = GetThreadWorker();
			ATLASSERT( p != NULL );
			return p->m_spReader->QueryInterface(riid, ppvObject);
		}
#endif

        // otherwise look it up in the servicemap
        return GetService(guidService, riid, ppvObject);
    }

    virtual HRESULT AddService(REFGUID guidService, REFIID riid, IUnknown *punkService, HINSTANCE hInstance) throw()
    {
        if (!m_DllCache.AddRefModule(hInstance))
            return E_FAIL;

		if (!punkService)
			return E_INVALIDARG;
        
        CCritSecLock Lock(m_critSec.m_sec);
        
        ServiceNode srvNode;
        srvNode.hInst = hInstance;
        srvNode.punk = punkService;
        memcpy(&srvNode.guidService, &guidService, sizeof(guidService));
        memcpy(&srvNode.riid, &riid, sizeof(riid));
        
        // if the service is already there, return S_FALSE
        int nIndex = m_serviceMap.Find(srvNode);
        if (nIndex >= 0)
            return S_FALSE;

        if (!m_serviceMap.Add(srvNode))
            return E_OUTOFMEMORY;

        punkService->AddRef();
        return S_OK;
    }

    virtual HRESULT RemoveService(REFGUID guidService, REFIID riid) throw()
    {
        CCritSecLock Lock(m_critSec.m_sec);
        
        ServiceNode srvNode;
        memcpy(&srvNode.guidService, &guidService, sizeof(guidService));
        memcpy(&srvNode.riid, &riid, sizeof(riid));
        int nIndex = m_serviceMap.Find(srvNode);
        if (nIndex < 0)
            return S_FALSE;

        ATLASSERT(m_serviceMap[nIndex].punk != NULL);
        m_serviceMap[nIndex].punk->Release();

        HINSTANCE hInstRemove = m_serviceMap[nIndex].hInst;

        m_serviceMap.RemoveAt(nIndex);

        if (!m_DllCache.ReleaseModule(hInstRemove))
            return S_FALSE;

        return S_OK;
    }

    HRESULT GetService(REFGUID guidService, REFIID riid, void **ppvObject) throw()
    {
        if (!ppvObject)
            return E_POINTER;

        *ppvObject = NULL;
        if (!m_serviceMap.GetSize())
            return E_NOINTERFACE;

        ServiceNode srvNode;
        memcpy(&srvNode.guidService, &guidService, sizeof(guidService));
        memcpy(&srvNode.riid, &riid, sizeof(riid));

        CCritSecLock Lock(m_critSec.m_sec);
        
        int nIndex = m_serviceMap.Find(srvNode);
        if (nIndex < 0)
            return E_NOINTERFACE;

        ATLASSERT(m_serviceMap[nIndex].punk != NULL);
        return m_serviceMap[nIndex].punk->QueryInterface(riid, ppvObject);
    }

    HTTP_CODE LoadRequestHandler(LPCSTR szDllPath, LPCSTR szHandlerName, IHttpServerContext *pServerContext,
        HINSTANCE *phInstance, IRequestHandler **ppHandler) throw()
    {
        return _AtlLoadRequestHandler(szDllPath, szHandlerName, pServerContext, 
            phInstance, ppHandler, this, static_cast<IDllCache*>(&m_DllCache));
    } // LoadRequestHandler

}; // class CIsapiExtension

//===========================================================================================
// IMPORTANT NOTE TO USERS: 
// DO NOT ASSUME *ANYTHING* ABOUT THE STRUCTURE OF THESE MAPS/ENTRIES/FUNCTIONS--THEY CAN 
// AND *WILL* CHANGE IN THE FUTURE. CORRECT USAGE MANDATES THAT YOU USE THE MACROS PROVIDED.
// ABSOLUTELY NO GUARANTEES ABOUT BACKWARD COMPATABILITY ARE MADE FOR MANUALLY DEFINED 
// HANDLERS OR FUNCTIONS.
//===========================================================================================

typedef BOOL (*CREATEHANDLERFUNC)(IIsapiExtension *pExtension, IUnknown **ppOut);
typedef BOOL (*INITHANDLERFUNC)(IHttpServerContext*, IIsapiExtension*);
typedef void (*UNINITHANDLERFUNC)();

struct _HANDLER_ENTRY
{
    LPCSTR szName;
    CREATEHANDLERFUNC pfnCreate;
    INITHANDLERFUNC pfnInit;
    UNINITHANDLERFUNC pfnUninit;
};
// definitions of data segments and _HANDLER_ENTRY delimiters
#pragma data_seg(push)
#pragma data_seg("ATLS$A")
__declspec(selectany) ATL::_HANDLER_ENTRY * __phdlrA = NULL;
#pragma data_seg("ATLS$Z") 
__declspec(selectany) ATL::_HANDLER_ENTRY * __phdlrZ = NULL;
#pragma data_seg("ATLS$C")
#pragma data_seg(pop)

#ifndef HANDLER_ENTRY_PRAGMA

#if defined(_M_IX86)
#define HANDLER_ENTRY_PRAGMA(class, line) __pragma(comment(linker, "/include:___phdlrEntry_" #class "_" #line))
#elif defined(_M_AMD64) || defined(_M_IA64)
#define HANDLER_ENTRY_PRAGMA(class, line) __pragma(comment(linker, "/include:__phdlrEntry_" #class "_" #line))
#else
#error Unknown Platform. define HANDLER_ENTRY_PRAGMA
#endif

#endif // HANDLER_ENTRY_PRAGMA

// DECLARE_REQUEST_HANDLER macro
#define __DECLARE_REQUEST_HANDLER_INTERNAL(handlerName, className, lineNum) \
__declspec(selectany) ATL::_HANDLER_ENTRY __hdlrEntry_ ## className ## _ ## lineNum = { handlerName, className::CreateRequestHandler, className::InitRequestHandlerClass, className::UninitRequestHandlerClass }; \
extern "C" __declspec(allocate("ATLS$C")) __declspec(selectany) \
ATL::_HANDLER_ENTRY * __phdlrEntry_ ## className ## _ ## lineNum = &__hdlrEntry_ ## className ## _ ## lineNum; \
HANDLER_ENTRY_PRAGMA(className, lineNum) \
__if_not_exists(GetAtlHandlerByName) \
{ \
extern "C" ATL_NOINLINE inline BOOL __declspec(dllexport) __stdcall GetAtlHandlerByName(LPCSTR szHandlerName, IIsapiExtension *pExtension, IUnknown **ppHandler) throw() \
{ \
    *ppHandler = NULL; \
    ATL::_HANDLER_ENTRY **pEntry = &__phdlrA; \
    while (pEntry != &__phdlrZ) \
    { \
        if (*pEntry && (*pEntry)->szName) \
        { \
            if (strcmp((*pEntry)->szName, szHandlerName)==0) \
            { \
                return (*(*pEntry)->pfnCreate)(pExtension, ppHandler); \
            } \
        } \
        pEntry++; \
    } \
    return FALSE; \
} \
extern "C" ATL_NOINLINE inline  BOOL __declspec(dllexport) __stdcall InitializeAtlHandlers(IHttpServerContext *pContext, IIsapiExtension *pExt) throw() \
{ \
    ATL::_HANDLER_ENTRY **pEntry = &__phdlrA; \
    BOOL bRet = TRUE; \
    while (pEntry != &__phdlrZ) \
    { \
        if (*pEntry && (*pEntry)->szName && (*pEntry)->pfnInit) \
        { \
            bRet = (*(*pEntry)->pfnInit)(pContext, pExt); \
            if (!bRet) \
                break; \
        } \
        pEntry++; \
    } \
    if (!bRet) \
    { \
        if (pEntry == &__phdlrA) \
            return FALSE; \
        do \
        { \
            pEntry--; \
            (*(*pEntry)->pfnUninit)(); \
        } \
        while (pEntry != &__phdlrA); \
    } \
    return bRet; \
} \
extern "C" ATL_NOINLINE inline void __declspec(dllexport) __stdcall UninitializeAtlHandlers() throw() \
{\
    ATL::_HANDLER_ENTRY **pEntry = &__phdlrA; \
    while (pEntry != &__phdlrZ) \
    { \
        if (*pEntry && (*pEntry)->szName && (*pEntry)->pfnUninit) \
        { \
            (*(*pEntry)->pfnUninit)(); \
        } \
        pEntry++; \
    } \
} \
}

// TODO (jasjitg): When __COUNTER__ becomes available, replace __LINE__ with that
#define __DECLARE_REQUEST_HANDLER(handlerName, className, lineNum) __DECLARE_REQUEST_HANDLER_INTERNAL(handlerName, className, lineNum)
#define DECLARE_REQUEST_HANDLER(handlerName, className) __DECLARE_REQUEST_HANDLER(handlerName, className, __COUNTER__)

#define BEGIN_HANDLER_MAP()
#define HANDLER_ENTRY(handlerName, className) DECLARE_REQUEST_HANDLER(handlerName, className)
#define END_HANDLER_MAP()

#define HANDLER_ENTRY_SDL(handlerString, handlerClass, sdlClassName)\
__declspec(selectany) LPCSTR s_szClassName##handlerClass=handlerString;\
typedef CSDLGenerator<handlerClass, s_szClassName##handlerClass> sdlClassName; \
HANDLER_ENTRY(handlerString, handlerClass)\
HANDLER_ENTRY(#sdlClassName, sdlClassName)

// 
// Use this class to check the authorization level of a client who is making
// a request to this application. This class checks for the stronger authentication
// levels (NTLM and Negotiate). You can call it directly from an implementation
// of HandleRequest to check authorization before handling a request.
#define MAX_AUTH_TYPE 50
#define MAX_NAME_LEN 255

template <class T>
class CVerifyAuth
{
public:
    HTTP_CODE IsAuthorized(AtlServerRequest *pInfo, const SID* psidAuthGroup) throw()
    {
        HTTP_CODE hcErr = HTTP_UNAUTHORIZED;
        char szAuthType[MAX_AUTH_TYPE];
        DWORD dwSize = MAX_AUTH_TYPE;
        if (pInfo->pServerContext->GetServerVariable("AUTH_TYPE", 
            szAuthType, &dwSize))
        {
            if (szAuthType[0] && (!_stricmp(szAuthType, "NTLM") 
                || !_stricmp(szAuthType, "Negotiate")))
            {
                // if we were passed a group name
                // we check to see that the logged on user is part
                // of that group, else we just return success.
                if (psidAuthGroup)
                {
                    T* pT = static_cast<T*>(this);
                    if (pT->CheckAccount(pInfo->pServerContext, psidAuthGroup))
                        hcErr = HTTP_SUCCESS;
                    else
                        hcErr = pT->HandleError(pInfo);
                }
                else
                    hcErr = HTTP_SUCCESS;
            }
        }
        return hcErr;       
    }

    bool CheckAccount(IHttpServerContext *pContext, const SID *psidAuthGroup) throw()
    {
        pContext; // unused
        psidAuthGroup; // unused
        return true;
    }

    HTTP_CODE HandleError(AtlServerRequest *pRequestInfo) throw()
    {
        pRequestInfo; // unused
        return HTTP_FAIL;
    }
    
    bool CheckAuthAccount(IHttpServerContext *pContext, const SID* psidAuthGroup) throw()
    {
        ATLASSERT(pContext);
        ATLASSERT(psidAuthGroup);
        if (!pContext || !psidAuthGroup)
            return false;

        HANDLE hToken = INVALID_HANDLE_VALUE;
        if (!pContext->GetImpersonationToken(&hToken) ||
                            hToken == INVALID_HANDLE_VALUE)
            return false;

        CAccessToken tok;
		tok.Attach(hToken, true);

        bool bIsMember;
        bool bRet = tok.CheckTokenMembership(CSid(psidAuthGroup), &bIsMember);

        if (!bRet)
            return false;

        return bIsMember;
    }
};

// Checks that the user that is logging on is in the required group
class CDefaultAuth :
    public CVerifyAuth<CDefaultAuth>
{
public:
    bool CheckAccount(IHttpServerContext *pContext, const SID* psidAuthGroup) throw()
    {
        return CheckAuthAccount(pContext, psidAuthGroup);
    }

    HTTP_CODE HandleError(AtlServerRequest *pRequestInfo) throw()
    {
        ATLASSERT(pRequestInfo); // should always be valid
        
        CHttpResponse response(pRequestInfo->pServerContext);
        response.Write(GetErrorResponse());
        response.Flush();
        return HTTP_SUCCESS_NO_PROCESS;
    }

    virtual LPCSTR GetErrorResponse() throw()
    {
        static const char *szResponse = "<html><body>"
            "<H1 align=center>NOT AUTHORIZED</H1><p>"
            "</body></html>";
        return szResponse;
    }

};

} // namespace ATL

#pragma warning(pop)

#endif // __ATLISAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atlmfc\atlsiface.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLSIFACE_H__
#define __ATLSIFACE_H__

#pragma once
#include <atlcoll.h>
#include <httpext.h>
#include <atlserr.h>

namespace ATL{

// Forward declarations of custom data types used in 
// interfaces declared in this file.
struct AtlServerRequest;
class CIsapiWorker;
__interface IAtlMemMgr;
class CCookie;

// Forward declarations of all interfaces declared in this file.
__interface IWriteStream;
__interface IHttpFile;
__interface IHttpServerContext;
__interface IHttpRequestLookup;
__interface IRequestHandler;
__interface ITagReplacer;
__interface IIsapiExtension;
__interface IPageCacheControl;
__interface IRequestStats;
__interface IBrowserCaps;
__interface IBrowserCapsSvc;


// ATLS Interface declarations.

// Interface for writing to a stream.
__interface IWriteStream
{
	HRESULT WriteStream(LPCSTR szOut, int nLen, DWORD *pdwWritten);
	HRESULT FlushStream();
};

// This is an interface that provides for basic accessor
// functionality for files (see CHttpRequestFile).
__interface __declspec(uuid("84a2e035-d9e5-4e60-a61b-bcd960897056"))
	IHttpFile : public IUnknown
{
	LPCSTR GetParamName();
	LPCSTR GetFileName();
	LPCSTR GetFullFileName();
	LPCSTR GetContentType();
	LPCSTR GetTempFileName();
	ULONGLONG GetFileSize();
};

// This interface encapsulates the capabilities of the web server and provides information about
// the current request being handled. See CServerContext for implementation.
__interface ATL_NO_VTABLE __declspec(uuid("813F3F00-3881-11d3-977B-00C04F8EE25E")) 
	IHttpServerContext : public IUnknown
{
	HRESULT  STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppv);
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

	LPCSTR GetRequestMethod();
	LPCSTR GetQueryString();
	LPCSTR GetPathInfo();
	LPCSTR GetPathTranslated();
	LPCSTR GetScriptPathTranslated();
	DWORD GetTotalBytes();
	DWORD GetAvailableBytes();
	BYTE *GetAvailableData();
	LPCSTR GetContentType();
	BOOL GetServerVariable(LPCSTR pszVariableName,
									LPSTR pvBuffer, DWORD *pdwSize);
	BOOL GetImpersonationToken(HANDLE * pToken);
	BOOL WriteClient(void *pvBuffer, DWORD *pdwBytes);
	BOOL AsyncWriteClient(void *pvBuffer, DWORD *pdwBytes);
	BOOL ReadClient(void *pvBuffer, DWORD *pdwSize);
	BOOL AsyncReadClient(void *pvBuffer, DWORD *pdwSize);
	BOOL SendRedirectResponse(LPCSTR pszRedirectUrl);
	BOOL SendResponseHeader(LPCSTR pszHeader, LPCSTR pszStatusCode,
							BOOL fKeepConn);
	BOOL DoneWithSession(DWORD dwHttpStatusCode);
	BOOL RequestIOCompletion(PFN_HSE_IO_COMPLETION pfn, DWORD *pdwContext);
	BOOL TransmitFile(HANDLE hFile, PFN_HSE_IO_COMPLETION pfn, void *pContext, 
		LPCSTR szStatusCode, DWORD dwBytesToWrite, DWORD dwOffset,
		void *pvHead, DWORD dwHeadLen, void *pvTail,
		DWORD dwTailLen, DWORD dwFlags);
    BOOL AppendToLog(LPCSTR szMessage, DWORD* pdwLen);
	BOOL MapUrlToPathEx(LPCSTR szLogicalPath, DWORD dwLen, HSE_URL_MAPEX_INFO *pumInfo);
};

// This interface is designed to allow one map to chain to another map.
// The interface is implemented by the CHttpThunkMap and CHttpRequest classes.
// Pointers to this interface are passed around by CRequestHandlerT and CHtmlTagReplacer.
// dwType - the type of item being requested
__interface ATL_NO_VTABLE __declspec(uuid("A5990B44-FF74-4bfe-B66D-F9E7E9F42D42")) 
	IHttpRequestLookup : public IUnknown
//interface IHttpRequestLookup
{
	POSITION GetFirstQueryParam(LPCSTR *ppszName, LPCSTR *ppszValue) const;
	POSITION GetNextQueryParam(POSITION pos, LPCSTR *ppszName, LPCSTR *ppszValue) const;

	POSITION GetFirstFormVar(LPCSTR *ppszName, LPCSTR *ppszValue) const;
	POSITION GetNextFormVar(POSITION pos, LPCSTR *ppszName, LPCSTR *ppszValue) const;

	POSITION GetFirstFile(LPCSTR *ppszName, IHttpFile **ppFile) const;
	POSITION GetNextFile(POSITION pos, LPCSTR *ppszName, IHttpFile **ppFile) const;

	HRESULT GetServerContext(IHttpServerContext **ppOut);
};


__interface ATL_NO_VTABLE __declspec(uuid("D57F8D0C-751A-4223-92BC-0B29F65D2453")) 
IRequestHandler : public IUnknown
{
	HTTP_CODE GetFlags(DWORD *pdwStatus);
	HTTP_CODE InitializeHandler(AtlServerRequest *pRequestInfo, IServiceProvider *pProvider);
	HTTP_CODE InitializeChild(AtlServerRequest *pRequestInfo, IServiceProvider *pProvider, IHttpRequestLookup *pLookup);
	HTTP_CODE HandleRequest(AtlServerRequest *pRequestInfo, IServiceProvider *pProvider);
	void UninitializeHandler();
};

// This interface defines the methods necessary for server response file processing.
__interface ATL_NO_VTABLE __declspec(uuid("8FF5E90C-8CE0-43aa-96C4-3BF930837512")) 
	ITagReplacer : public IUnknown
{
public:
	HTTP_CODE FindReplacementOffset(LPCSTR szMethodName, DWORD *pdwMethodOffset, 
						LPCSTR szObjectName, DWORD *pdwObjOffset, DWORD *pdwMap, void **ppvParam, IAtlMemMgr *pMemMgr);
	HTTP_CODE RenderReplacement(DWORD dwFnOffset, DWORD dwObjOffset, DWORD dwMap, void *pvParam);
	HRESULT GetContext(REFIID riid, void** ppv);
	HTTP_CODE FreeParam(void *pvParam);
	IWriteStream *SetStream(IWriteStream *pStream);
};

__interface __declspec(uuid("79DD4A27-D820-4fa6-954D-E1DFC2C05978"))
	IIsapiExtension : public IUnknown
{
public:
	BOOL DispatchStencilCall(AtlServerRequest *pRequestInfo);
	void RequestComplete(AtlServerRequest *pRequestInfo, DWORD hStatus, DWORD dwSubStatus);
	BOOL OnThreadAttach();
	void OnThreadTerminate();
    BOOL QueueRequest(AtlServerRequest *pRequestInfo);
	CIsapiWorker *GetThreadWorker();
	BOOL SetThreadWorker(CIsapiWorker *pWorker);
	HTTP_CODE LoadRequestHandler(LPCSTR szDllPath, LPCSTR szHandlerName, IHttpServerContext *pServerContext,
		HINSTANCE *phInstance, IRequestHandler **ppHandler);
	HRESULT AddService(REFGUID guidService, REFIID riid, IUnknown *punk, HINSTANCE hInstance);
	HRESULT RemoveService(REFGUID guidService, REFIID riid);
	HTTP_CODE LoadDispatchFile(LPCSTR szFileName, AtlServerRequest *pRequestInfo);

	AtlServerRequest* CreateRequest();
	void FreeRequest(AtlServerRequest* pRequest);
	HTTP_CODE TransferRequest(
				AtlServerRequest *pRequest, 
				IServiceProvider *pServiceProvider,
				IWriteStream *pWriteStream,
				IHttpRequestLookup *pLookup,
				LPCSTR szNewUrl,
				WORD nCodePage,
				bool bContinueAfterProcess = false,
				void *pState = NULL
			);
};

// This interface controls the cacheability of the current page
__interface ATL_NO_VTABLE __declspec(uuid("9868BFC0-D44D-4154-931C-D186EC0C45D5")) 
	IPageCacheControl : public IUnknown
{
    HRESULT GetExpiration(FILETIME *pftExpiration);
    HRESULT SetExpiration(FILETIME ftExpiration);
    BOOL IsCached();
    BOOL Cache(BOOL bCache);
};

__interface ATL_NO_VTABLE __declspec(uuid("2B75C68D-0DDF-48d6-B58A-CC7C2387A6F2"))
	IRequestStats : public IUnknown
{
	long GetTotalRequests();
	long GetFailedRequests();
	long GetAvgResponseTime();
	long GetCurrWaiting();
	long GetMaxWaiting();
	long GetActiveThreads();
};

__interface __declspec(uuid("3339FCE2-99BC-4985-A702-4ABC8304A995"))
	IBrowserCaps : public IUnknown
{
public:
    HRESULT GetPropertyString(BSTR bstrProperty, BSTR * pbstrOut);
    HRESULT GetBooleanPropertyValue(BSTR bstrProperty, BOOL* pbOut);
    HRESULT GetBrowserName(BSTR * pbstrName);
    HRESULT GetPlatform(BSTR * pbstrPlatform);
	HRESULT GetVersion(BSTR * pbstrVersion);
	HRESULT GetMajorVer(BSTR * pbstrMajorVer);
	HRESULT GetMinorVer(BSTR * pbstrMinorVer);
    HRESULT SupportsFrames(BOOL* pbFrames);
    HRESULT SupportsTables(BOOL* pbTables);
    HRESULT SupportsCookies(BOOL* pbCookies);
    HRESULT SupportsBackgroundSounds(BOOL* pbBackgroundSounds);
    HRESULT SupportsVBScript(BOOL* pbVBScript);
    HRESULT SupportsJavaScript(BOOL* pbJavaScript);
    HRESULT SupportsJavaApplets(BOOL* pbJavaApplets);
    HRESULT SupportsActiveXControls(BOOL* pbActiveXControls);
    HRESULT SupportsCDF(BOOL* pbCDF);
    HRESULT SupportsAuthenticodeUpdate(BOOL* pbAuthenticodeUpdate);
    HRESULT IsBeta(BOOL* pbIsBeta);
    HRESULT IsCrawler(BOOL* pbIsCrawler);
    HRESULT IsAOL(BOOL* pbIsAOL);
    HRESULT IsWin16(BOOL* pbIsWin16);
    HRESULT IsAK(BOOL* pbIsAK);
    HRESULT IsSK(BOOL* pbIsSK);
    HRESULT IsUpdate(BOOL* pbIsUpdate);
};

__interface __declspec(uuid("391E7418-863B-430e-81BB-1312ED2FF3E9"))
	IBrowserCapsSvc : public IUnknown
{
public:
    HRESULT GetCaps(IHttpServerContext * pContext, IBrowserCaps ** ppOut);
    HRESULT GetCapsUserAgent(BSTR bstrAgent, IBrowserCaps ** ppOut);
};

__interface __declspec(uuid("B1F64757-6E88-4fa2-8886-7848B0D7E660")) 
    IThreadPoolConfig : public IUnknown
{
    HRESULT STDMETHODCALLTYPE SetSize(int nNumThreads);
    HRESULT STDMETHODCALLTYPE GetSize(int *pnNumThreads);
    HRESULT STDMETHODCALLTYPE SetTimeout(DWORD dwMaxWait);
    HRESULT STDMETHODCALLTYPE GetTimeout(DWORD *pdwMaxWait);
};


typedef DWORD_PTR HSESSIONENUM;
__interface ATL_NO_VTABLE __declspec(uuid("DEB69BE3-7AC9-4a13-9519-266C1EA3AB39")) 
ISession : public IUnknown
{
	STDMETHOD(SetVariable)(LPCSTR szName, VARIANT NewVal);
	STDMETHOD(GetVariable)(LPCSTR szName, VARIANT *pVal);
	STDMETHOD(GetCount)(long *pnCount);
	STDMETHOD(RemoveVariable)(LPCSTR szName);
	STDMETHOD(RemoveAllVariables)();
	STDMETHOD(BeginVariableEnum)(HSESSIONENUM *phEnumHandle, POSITION *pPOS);
	STDMETHOD(GetNextVariable)(HSESSIONENUM hEnum, POSITION *pPOS, LPSTR szName, DWORD dwLen, VARIANT *pVal);
	STDMETHOD(CloseEnum)(HSESSIONENUM hEnumHandle);
	STDMETHOD(IsExpired)();
	STDMETHOD(SetTimeout)(unsigned __int64 dwNewTimeout);
}; //ISession

__interface ATL_NO_VTABLE __declspec(uuid("C5740C4F-0C6D-4b43-92C4-2AF778F35DDE"))
ISessionStateService : public IUnknown
{
	STDMETHOD(CreateNewSession)(LPSTR szNewID, DWORD *pdwSize, ISession** ppSession);
	STDMETHOD(GetSession)(LPCSTR szID, ISession **ppSession);
	STDMETHOD(CloseSession)(LPCSTR szID);
};

__interface ATL_NO_VTABLE __declspec(uuid("6C7F5F56-6CBD-49ee-9797-4C837D4C527A"))
ISessionStateControl : public IUnknown
{
	STDMETHOD(SetSessionTimeout)(unsigned __int64 nTimeout);
	STDMETHOD(GetSessionTimeout)(unsigned __int64 *pnTimeout);
	STDMETHOD(GetSessionCount)(DWORD *pnSessionCount);
}; 

//
// IWorkerThreadClient
// Interface to be used with CWorkerThread

__interface IWorkerThreadClient
{
	HRESULT Execute(DWORD_PTR dwParam, HANDLE hObject);
	HRESULT CloseHandle(HANDLE hHandle);
};

}; // namespace ATL

#endif // __ATLSIFACE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atlmfc\atlserr.h ===
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLSERR_H__
#define __ATLSERR_H__

#pragma once

namespace ATL{

#define VALIDATION_S_OK				0x00000000
#define VALIDATION_S_EMPTY			0x00000001
#define VALIDATION_E_PARAMNOTFOUND	0x00000002
#define VALIDATION_E_LENGTHMIN		0x80000083
#define VALIDATION_E_LENGTHMAX		0x80000084
#define VALIDATION_E_INVALIDLENGTH  0x80000080
#define VALIDATION_E_INVALIDPARAM	0x80000005
#define VALIDATION_E_FAIL			0x80000006

#define VALIDATION_SUCCEEDED(x) (((x == VALIDATION_S_OK) || (x == VALIDATION_S_EMPTY )))

typedef DWORD HTTP_CODE;

#define HTTP_ERROR(err, sub)			((HTTP_CODE)(DWORD_PTR)MAKELONG((WORD)err, (WORD)sub))
#define HTTP_ERROR_CODE(err)			((DWORD)LOWORD(err))
#define HTTP_SUBERROR_CODE(err)			((DWORD)HIWORD(err))
#define HTTP_SUCCESS					HTTP_ERROR(0, 0)

#define SUBERR_NONE								0
#define ISE_SUBERR_BADSRF						1
#define ISE_SUBERR_HNDLFAIL						2
#define ISE_SUBERR_SYSOBJFAIL					3
#define ISE_SUBERR_READFILEFAIL					4
#define ISE_SUBERR_LOADFILEFAIL                 6
#define ISE_SUBERR_LOADLIB						7
#define ISE_SUBERR_HANDLERIF					8
#define ISE_SUBERR_OUTOFMEM						9
#define ISE_SUBERR_UNEXPECTED					10
#define ISE_SUBERR_STENCIL_INVALIDFUNCOFFSET	11
#define ISE_SUBERR_STENCIL_MISMATCHWHILE		12
#define ISE_SUBERR_STENCIL_MISMATCHIF			13
#define ISE_SUBERR_STENCIL_UNEXPECTEDTYPE		14
#define ISE_SUBERR_STENCIL_INVALIDINDEX			15
#define ISE_SUBERR_STENCIL_INDEXOUTOFRANGE		16
#define ISE_SUBERR_STENCIL_PARSE_FAIL			17
#define ISE_SUBERR_STENCIL_LOAD_FAIL			18
#define ISE_SUBERR_HANDLER_NOT_FOUND			19
#define ISE_SUBERR_BAD_HANDLER_TAG				20
#define ISE_SUBERR_NO_HANDLER_TAG				21
#define ISE_SUBERR_LONGMETHODNAME				22
#define ISE_SUBERR_LONGHANDLERNAME				23
#define ISE_SUBERR_IMPERSONATIONFAILED			24
#define ISE_SUBERR_ISAPISTARTUPFAILED			25
#define SUBERR_NO_PROCESS						26
#define SUBERR_S_FALSE							27
#define SUBERR_ASYNC							28
#define SUBERR_ASYNC_DONE						29
#define SUBERR_ASYNC_NOFLUSH					20
#define SUBERR_ASYNC_NOFLUSH_DONE				31
#define SUBERR_NO_CACHE							32
#define DBG_SUBERR_ALREADY_DEBUGGING            33
#define DBG_SUBERR_NOT_DEBUGGING                34
#define DBG_SUBERR_INVALID_SESSION              35
#define DBG_SUBERR_BAD_ID                       36
#define DBG_SUBERR_COCREATE                     37
#define DBG_SUBERR_ATTACH                       38


#define HTTP_FAIL						HTTP_ERROR(500, SUBERR_NONE)
#define HTTP_SUCCESS_NO_PROCESS			HTTP_ERROR(200, SUBERR_NO_PROCESS)
#define HTTP_S_FALSE					HTTP_ERROR(HTTP_ERROR_CODE(HTTP_SUCCESS), SUBERR_S_FALSE)
#define HTTP_SUCCESS_ASYNC				HTTP_ERROR(200, SUBERR_ASYNC)
#define HTTP_SUCCESS_ASYNC_DONE         HTTP_ERROR(200, SUBERR_ASYNC_DONE)
#define HTTP_SUCCESS_ASYNC_NOFLUSH		HTTP_ERROR(200, SUBERR_ASYNC_NOFLUSH)
#define HTTP_SUCCESS_ASYNC_NOFLUSH_DONE HTTP_ERROR(200, SUBERR_ASYNC_NOFLUSH_DONE)
#define HTTP_SUCCESS_NO_CACHE           HTTP_ERROR(200, SUBERR_NO_CACHE)
#define HTTP_OK							HTTP_ERROR(200, SUBERR_NONE)
#define HTTP_CONTINUE					HTTP_ERROR(100, SUBERR_NONE)

#define HTTP_CREATED					HTTP_ERROR(201, SUBERR_NONE)
#define HTTP_ACCEPTED					HTTP_ERROR(202, SUBERR_NONE)
#define HTTP_NON_AUTHORITATIVE			HTTP_ERROR(203, SUBERR_NONE)
#define HTTP_NO_CONTENT					HTTP_ERROR(204, SUBERR_NONE)
#define HTTP_RESET_CONTENT				HTTP_ERROR(205, SUBERR_NONE)
#define HTTP_PARTIAL_CONTENT			HTTP_ERROR(206, SUBERR_NONE)

#define HTTP_MULTIPLE_CHOICES			HTTP_ERROR(300, SUBERR_NONE)
#define HTTP_MOVED_PERMANENTLY			HTTP_ERROR(301, SUBERR_NONE)
#define HTTP_FOUND						HTTP_ERROR(302, SUBERR_NONE)
#define HTTP_SEE_OTHER					HTTP_ERROR(303, SUBERR_NONE)
#define HTTP_NOT_MODIFIED				HTTP_ERROR(304, SUBERR_NONE)
#define HTTP_USE_PROXY					HTTP_ERROR(305, SUBERR_NONE)
#define HTTP_TEMPORARY_REDIRECT			HTTP_ERROR(307, SUBERR_NONE)

#define HTTP_BAD_REQUEST				HTTP_ERROR(400, SUBERR_NONE)
#define HTTP_UNAUTHORIZED				HTTP_ERROR(401, SUBERR_NONE)
#define HTTP_PAYMENT_REQUIRED			HTTP_ERROR(402, SUBERR_NONE)
#define HTTP_FORBIDDEN					HTTP_ERROR(403, SUBERR_NONE)
#define HTTP_NOT_FOUND					HTTP_ERROR(404, SUBERR_NONE)
#define HTTP_METHOD_NOT_ALLOWED			HTTP_ERROR(405, SUBERR_NONE)
#define HTTP_NOT_ACCEPTABLE				HTTP_ERROR(406, SUBERR_NONE)
#define HTTP_PROXY_AUTHENTICATION_REQUIRED	HTTP_ERROR(407, SUBERR_NONE)
#define HTTP_REQUEST_TIMEOUT			HTTP_ERROR(408, SUBERR_NONE)
#define HTTP_CONFLICT					HTTP_ERROR(409, SUBERR_NONE)
#define HTTP_GONE						HTTP_ERROR(410, SUBERR_NONE)
#define HTTP_LENGTH_REQUIRED			HTTP_ERROR(411, SUBERR_NONE)
#define HTTP_PRECONDITION_FAILED		HTTP_ERROR(412, SUBERR_NONE)
#define HTTP_REQUEST_ENTITY_TOO_LONG	HTTP_ERROR(413, SUBERR_NONE)
#define HTTP_REQUEST_URI_TOO_LONG		HTTP_ERROR(414, SUBERR_NONE)
#define HTTP_UNSUPPORTED_MEDIA_TYPE		HTTP_ERROR(415, SUBERR_NONE)
#define HTTP_RANGE_NOT_SATISFIABLE		HTTP_ERROR(416, SUBERR_NONE)
#define HTTP_EXPECTATION_FAILED			HTTP_ERROR(417, SUBERR_NONE)

#define HTTP_INTERNAL_SERVER_ERROR		HTTP_ERROR(500, SUBERR_NONE)
#define HTTP_NOT_IMPLEMENTED			HTTP_ERROR(501, SUBERR_NONE)
#define HTTP_BAD_GATEWAY				HTTP_ERROR(502, SUBERR_NONE)
#define HTTP_SERVICE_UNAVAILABLE		HTTP_ERROR(503, SUBERR_NONE)
#define HTTP_GATEWAY_TIMEOUT			HTTP_ERROR(504, SUBERR_NONE)
#define HTTP_VERSION_NOT_SUPPORTED		HTTP_ERROR(505, SUBERR_NONE)

inline bool IsAsyncStatus(HTTP_CODE hcStatus)
{
	return 
		hcStatus == HTTP_SUCCESS_ASYNC ||
		hcStatus == HTTP_SUCCESS_ASYNC_DONE ||
		hcStatus == HTTP_SUCCESS_ASYNC_NOFLUSH ||
		hcStatus == HTTP_SUCCESS_ASYNC_NOFLUSH_DONE;
}

inline bool IsAsyncContinueStatus(HTTP_CODE hcStatus)
{
	return 
		hcStatus == HTTP_SUCCESS_ASYNC ||
		hcStatus == HTTP_SUCCESS_ASYNC_NOFLUSH;
}

inline bool IsAsyncDoneStatus(HTTP_CODE hcStatus)
{
	return 
		hcStatus == HTTP_SUCCESS_ASYNC_DONE ||
		hcStatus == HTTP_SUCCESS_ASYNC_NOFLUSH_DONE;
}

inline bool IsAsyncFlushStatus(HTTP_CODE hcStatus)
{
	return 
		hcStatus == HTTP_SUCCESS_ASYNC ||
		hcStatus == HTTP_SUCCESS_ASYNC_DONE;
}

inline bool IsAsyncNoFlushStatus(HTTP_CODE hcStatus)
{
	return 
		hcStatus == HTTP_SUCCESS_ASYNC_NOFLUSH ||
		hcStatus == HTTP_SUCCESS_ASYNC_NOFLUSH_DONE;
}

}; // namespace ATL

#endif // __ATLSERR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atlmfc\atlspriv.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLSPRIV_H__
#define __ATLSPRIV_H__

#pragma once
#ifndef _WINSOCKAPI_
#include <winsock2.h>
#endif

#ifndef	_WINSOCK2API_
#error Winsock2.h has to be included before including windows.h or use atlbase.h instead of windows.h
#endif

#ifndef _ATL_NO_DEFAULT_LIBS
#pragma comment(lib, "ws2_32.lib")
#endif  // !_ATL_NO_DEFAULT_LIBS

#include <svcguid.h>
#include <atlcoll.h>
#include <mlang.h>
#include <atlutil.h>

// ATL_SOCK_TIMEOUT defines the amount of time
// this socket will block the calling thread waiting
// for the socket before the call times out.
#ifndef ATL_SOCK_TIMEOUT
	#define ATL_SOCK_TIMEOUT 10000
#endif

#define ATL_WINSOCK_VER MAKELONG(2,0)

// This file contains unsupported code used in ATL implementation files. Most of 
// this code is support code for various ATL Server functions.

namespace ATL{

	// One of these objects can be created globally to turn
// on the socket stuff at CRT startup and shut it down
// on CRT term.
class _AtlWSAInit
{
public:
	_AtlWSAInit() throw()
	{
		m_dwErr = WSAEFAULT;
	}

	bool Init()
	{
		if (!IsStarted())
			m_dwErr = WSAStartup(ATL_WINSOCK_VER, &m_stData);

		return m_dwErr == 0;
	}

	bool IsStarted(){ return m_dwErr == 0; }

	~_AtlWSAInit() throw()
	{
		if (!m_dwErr)
			WSACleanup();
	}

	WSADATA  m_stData;
	DWORD m_dwErr;
};

#ifndef _ATL_NO_GLOBAL_SOCKET_STARTUP
	__declspec(selectany)_AtlWSAInit g_HttpInit;
#endif


class ZEvtSyncSocket
{
public:
	ZEvtSyncSocket() throw();
	~ZEvtSyncSocket() throw();
	operator SOCKET() throw();
	void Close() throw();
	void Term() throw();
	bool Create(WORD wFlags=0) throw();
	bool Create(short af, short st, short proto, WORD wFlags=0) throw();
	bool Connect(LPCTSTR szAddr, unsigned short nPort) throw();
	bool Connect(const SOCKADDR* psa) throw();
	bool Write(WSABUF *pBuffers, int nCount, DWORD *pdwSize) throw();
	bool Write(const unsigned char *pBuffIn, DWORD *pdwSize) throw();
	bool Read(const unsigned char *pBuff, DWORD *pdwSize) throw();
	bool Init(SOCKET hSocket, void * /*pData=NULL*/) throw();
	DWORD GetSocketTimeout();
	DWORD SetSocketTimeout(DWORD dwNewTimeout);
	bool SupportsScheme(ATL_URL_SCHEME scheme);

protected:
	DWORD m_dwCreateFlags;
	WSAEVENT m_hEventRead;
	WSAEVENT m_hEventWrite;
	WSAEVENT m_hEventConnect;

	CComAutoCriticalSection m_csRead;
	CComAutoCriticalSection m_csWrite;
	SOCKET m_socket;
	bool m_bConnected;
	DWORD m_dwLastError;
	DWORD m_dwSocketTimeout;
};


#define ATL_MAX_QUERYSET (sizeof(WSAQUERYSET) + 4096)

class CTCPAddrLookup
{
public:
	CTCPAddrLookup() throw();
	~CTCPAddrLookup() throw();

	// properties for this class
	__declspec(property(get=GetSockAddr)) const SOCKADDR* Addr;
	__declspec(property(get=GetSockAddrSize)) int AddrSize;
	
	// Takes a string that identifies a TCP service
	// to look up. The szName parameter is either the name
	// of a server (eg microsoft.com) or the dotted IP address
	// of a server (eg 157.24.34.205). This function must succeed
	// before accessing the Addr and AddrSize parameters.
	// This function returns normal socket errors on failure
	int GetRemoteAddr(LPCTSTR szName, short nPort) throw();
	const SOCKADDR* GetSockAddr();
	int GetSockAddrSize();
protected:
	SOCKADDR *m_pAddr;
	int m_nAddrSize;
	sockaddr_in m_saIn;
	WSAQUERYSET *m_pQuerySet;
};

// MIME helper functions

extern __declspec(selectany) const DWORD ATL_MIME_DEFAULT_CP = 28591;

// This function is used to create an CSMTPConnection-compatible recipient string 
// from a recipient string that is in a CMimeMessage object.
inline BOOL AtlMimeMakeRecipientsString(LPCSTR szNames, LPSTR szRecipients, LPDWORD pdwLen = NULL) throw()
{
	ATLASSERT(szNames != NULL);
	ATLASSERT(szRecipients != NULL);

	char ch;
	DWORD dwLen = 0;
	while ((ch = *szNames++) != '\0')
	{
		// Skip everything that is in double quotes
		if (ch == '"')
		{
			while (*szNames && *szNames++ != '"');
		}
		if (ch == '<')
		{
			// Extract the address from within the <>
			while (*szNames && *szNames != '>')
			{
				*szRecipients++ = *szNames++;
				dwLen++;
			}
			// End it with a comma
			*szRecipients++ = ',';
			dwLen++;
		}
		if (ch == '=')
		{
			// Skip any BEncoded or QEncoded parts
			while (*szNames)
			{
				if (*szNames == '?' && *(szNames+1) == '=')
				{
					szNames+=2;
					break;
				}
				szNames++;
			}
		}
		szNames++;
	}
	if (dwLen != 0)
	{
		szRecipients--;
		dwLen--;
	}
	*szRecipients = '\0';

	if (pdwLen)
		*pdwLen = dwLen;

	return TRUE;
}

// AtlMimeCharsetFromCodePage, AtlMimeConvertString
// are MIME multilanguage support functions.

// Get the MIME character set of the of the code page.  The character set is copied
// into szCharset.

#ifndef ATLSMTP_DEFAULT_CSET
	#define ATLSMTP_DEFAULT_CSET "iso-8859-1"
#endif

inline BOOL AtlMimeCharsetFromCodePage(LPSTR szCharset, UINT uiCodePage, IMultiLanguage* pMultiLanguage) throw()
{
	ATLASSERT(szCharset != NULL);

	if (!pMultiLanguage)
	{
		if ((uiCodePage == 0) || (uiCodePage == ATL_MIME_DEFAULT_CP))
		{
			strcpy(szCharset, ATLSMTP_DEFAULT_CSET);
		}
		else
		{
			return FALSE;
		}
	}
	else
	{
		if (uiCodePage == 0)
			uiCodePage = GetACP();

		HRESULT hr;
		MIMECPINFO cpInfo;
		memset(&cpInfo, 0x00, sizeof(cpInfo));

#ifdef __IMultiLanguage2_INTERFACE_DEFINED__

		// if IMultiLanguage2 is available, use it
		CComPtr<IMultiLanguage2> spMultiLanguage2;
		hr = pMultiLanguage->QueryInterface(__uuidof(IMultiLanguage2), (void **)&spMultiLanguage2);
		if (FAILED(hr) || !spMultiLanguage2.p)
			hr = pMultiLanguage->GetCodePageInfo(uiCodePage, &cpInfo);
		else
			hr = spMultiLanguage2->GetCodePageInfo(uiCodePage, 
				LANGIDFROMLCID(GetThreadLocale()), &cpInfo);

#else // __IMultiLanguage2_INTERFACE_DEFINED__

		hr = pMultiLanguage->GetCodePageInfo(uiCodePage, &cpInfo);

#endif // __IMultiLanguage2_INTERFACE_DEFINED__

		if (hr != S_OK)
			return FALSE;

		_ATLTRY
		{
			strcpy(szCharset, CW2A(cpInfo.wszWebCharset));
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
	}

	return TRUE;
}

inline BOOL AtlMimeConvertStringW(
	IMultiLanguage *pMultiLanguage,
	UINT uiCodePage,
	LPCWSTR wszIn, 
	LPSTR *ppszOut, 
	UINT *pnLen) throw()
{
	ATLASSERT( pMultiLanguage != NULL );
	ATLASSERT( wszIn != NULL );
	ATLASSERT( ppszOut != NULL );
	ATLASSERT( pnLen != NULL );

	*ppszOut = NULL;
	*pnLen = 0;

	if (uiCodePage == 0)
	{
		uiCodePage = GetACP();
	}

	DWORD dwMode = 0;
	CHeapPtr<char> pszOut;

	// get the length
	HRESULT hr = pMultiLanguage->ConvertStringFromUnicode(&dwMode, uiCodePage, const_cast<LPWSTR>(wszIn), NULL, NULL, pnLen);
	if (SUCCEEDED(hr))
	{
		// allocate the buffer
		if (pszOut.Allocate(*pnLen))
		{
			dwMode = 0;
			// do the conversion
			hr = pMultiLanguage->ConvertStringFromUnicode(&dwMode, uiCodePage, const_cast<LPWSTR>(wszIn), NULL, pszOut, pnLen);
			if (SUCCEEDED(hr))
			{
				*ppszOut = pszOut.Detach();
				return TRUE;
			}
		}
	}

	return FALSE;
}

inline BOOL AtlMimeConvertStringA(
	IMultiLanguage *pMultiLanguage,
	UINT uiCodePage,
	LPCSTR szIn, 
	LPSTR *ppszOut, 
	UINT *pnLen) throw()
{
	_ATLTRY
	{
		return AtlMimeConvertStringW(pMultiLanguage, uiCodePage, CA2W(szIn), ppszOut, pnLen);
	}
	_ATLCATCHALL()
	{
		return FALSE;
	}
}

#ifdef _UNICODE
	#define AtlMimeConvertString AtlMimeConvertStringW
#else
	#define AtlMimeConvertString AtlMimeConvertStringA
#endif



// SOAP helpers

extern __declspec(selectany) const char * s_szAtlsWSDLSrf =
"<?xml version=\"1.0\"?>\r\n"
"<!-- ATL Server generated Web Service Description -->\r\n"
"<definitions \r\n"
"	xmlns:s=\"http://www.w3.org/2000/10/XMLSchema\" \r\n"
"	xmlns:http=\"http://schemas.xmlsoap.org/wsdl/http/\" \r\n"
"	xmlns:mime=\"http://schemas.xmlsoap.org/wsdl/mime/\" \r\n"
"	xmlns:soap=\"http://schemas.xmlsoap.org/wsdl/soap/\" \r\n"
"	xmlns:soapenc=\"http://schemas.xmlsoap.org/soap/encoding/\" \r\n"
"	xmlns:s0=\"{{GetNamespace}}\" \r\n"
"	xmlns:wsdl=\"http://schemas.xmlsoap.org/wsdl/\"\r\n"
"	targetNamespace=\"{{GetNamespace}}\" \r\n"
"	xmlns=\"http://schemas.xmlsoap.org/wsdl/\"\r\n"
">\r\n"
"	<types>\r\n"
"		<s:schema targetNamespace=\"{{GetNamespace}}\" attributeFormDefault=\"qualified\" elementFormDefault=\"qualified\">\r\n"
"{{while GetNextFunction}}\r\n"
"			<s:element name=\"{{GetFunctionName}}\">\r\n"
"				<s:complexType derivedBy=\"restriction\">\r\n"
"					<s:all>\r\n"
"{{while GetNextParameter}}\r\n"
"{{if IsInParameter}}\r\n"
"						<s:element name=\"{{GetParameterName}}\" {{if NotIsArrayParameter}}type=\"{{if IsParameterUDT}}s0:{{else}}s:{{endif}}{{GetParameterSoapType}}\"/{{else}}nullable=\"{{if IsParameterDynamicArray}}true{{else}}false{{endif}}\"{{endif}}>\r\n"
"{{if IsArrayParameter}}\r\n"
"							<s:complexType derivedBy=\"restriction\">\r\n"
"								<s:all>\r\n"
"									<s:element name=\"{{GetParameterSoapType}}\" type=\"{{if IsParameterUDT}}s0:{{else}}s:{{endif}}{{GetParameterSoapType}}\" {{if IsParameterDynamicArray}}minOccurs=\"0\" maxOccurs=\"unbounded\"{{else}}{{if IsParameterOneDimensional}}minOccurs=\"{{GetParameterArraySize}}\" maxOccurs=\"{{GetParameterArraySize}}\"{{else}}soap:arrayType=\"{{GetParameterArraySoapDims}}\"{{endif}}{{endif}}/>\r\n"
"								</s:all>\r\n"
"							</s:complexType>\r\n"
"						</s:element>\r\n"
"{{endif}}\r\n"
"{{endif}}\r\n"
"{{endwhile}}\r\n"
"					</s:all>\r\n"
"				</s:complexType>\r\n"
"			</s:element>\r\n"
"			<s:element name=\"{{GetFunctionName}}Response\">\r\n"
"				<s:complexType derivedBy=\"restriction\">\r\n"
"					<s:all>\r\n"
"{{while GetNextParameter}}\r\n"
"{{if IsOutParameter}}\r\n"
"						<s:element name=\"{{GetParameterName}}\" {{if NotIsArrayParameter}}type=\"{{if IsParameterUDT}}s0:{{else}}s:{{endif}}{{GetParameterSoapType}}\"/{{else}}nullable=\"{{if IsParameterDynamicArray}}true{{else}}false{{endif}}\"{{endif}}>\r\n"
"{{if IsArrayParameter}}\r\n"
"							<s:complexType derivedBy=\"restriction\">\r\n"
"								<s:all>\r\n"
"									<s:element name=\"{{GetParameterSoapType}}\" type=\"{{if IsParameterUDT}}s0:{{else}}s:{{endif}}{{GetParameterSoapType}}\" {{if IsParameterDynamicArray}}minOccurs=\"0\" maxOccurs=\"unbounded\"{{else}}{{if IsParameterOneDimensional}}minOccurs=\"{{GetParameterArraySize}}\" maxOccurs=\"{{GetParameterArraySize}}\"{{else}}soap:arrayType=\"{{GetParameterArraySoapDims}}\"{{endif}}{{endif}}/>\r\n"
"								</s:all>\r\n"
"							</s:complexType>\r\n"
"						</s:element>\r\n"
"{{endif}}\r\n"
"{{endif}}\r\n"
"{{endwhile}}\r\n"
"					</s:all>\r\n"
"				</s:complexType>\r\n"
"			</s:element>\r\n"
"{{endwhile}}\r\n"
"{{while GetNextEnum}}\r\n"
"			<s:simpleType name=\"{{GetEnumName}}\">\r\n"
"				<s:restriction base=\"s:string\">\r\n"
"{{while GetNextEnumElement}}\r\n"
"					<s:enumeration value=\"{{GetEnumElementName}}\"/>\r\n"
"{{endwhile}}\r\n"
"				</s:restriction>\r\n"
"			</s:simpleType>\r\n"
"{{endwhile}}\r\n"
"			<s:complexType name=\"ATLSOAP_BLOB\">\r\n"
"				<s:all>\r\n"
"					<s:element name=\"size\" type=\"unsignedLong\"/>\r\n"
"					<s:element name=\"data\" nullable=\"false\">\r\n"
"						<s:simpleType xmlns:q3=\"http://www.w3.org/2000/10/XMLSchema\" base=\"q3:binary\">\r\n"
"							<s:encoding value=\"base64\"/>\r\n"
"						</s:simpleType>\r\n"
"					</s:element>\r\n"
"				</s:all>\r\n"
"			</s:complexType>\r\n"
"{{while GetNextStruct}}\r\n"
"			<s:complexType name=\"{{GetStructName}}\" derivedBy=\"restriction\">\r\n"
"				<s:all>\r\n"
"{{while GetNextStructField}}\r\n"
"					<s:element name=\"{{GetStructFieldName}}\" {{if NotIsArrayField}}type=\"{{if IsFieldUDT}}s0:{{else}}s:{{endif}}{{GetStructFieldSoapType}}\"/{{else}}nullable=\"false\"{{endif}}>\r\n"
"{{if IsArrayField}}\r\n"
"						<s:complexType derivedBy=\"restriction\">\r\n"
"							<s:all>\r\n"
"								<s:element name=\"{{GetStructFieldSoapType}}\" type=\"{{if IsFieldUDT}}s0:{{else}}s:{{endif}}{{GetStructFieldSoapType}}\" {{if IsFieldOneDimensional}}minOccurs=\"{{GetFieldArraySize}}\" maxOccurs=\"{{GetFieldArraySize}}\"{{else}}soap:arrayType=\"{{GetFieldArraySoapDims}}\"{{endif}}/>\r\n"
"							</s:all>\r\n"
"						</s:complexType>\r\n"
"					</s:element>\r\n"
"{{endif}}\r\n"
"{{endwhile}}\r\n"
"				</s:all>\r\n"
"			</s:complexType>\r\n"
"{{endwhile}}\r\n"
"{{while GetNextHeader}}\r\n"
"			<s:element name=\"{{GetHeaderName}}\" {{if NotIsArrayHeader}}type=\"{{if IsHeaderUDT}}s0:{{else}}s:{{endif}}{{GetHeaderSoapType}}\"/{{else}}nullable=\"false\"{{endif}}>\r\n"
"{{if IsArrayHeader}}\r\n"
"				<s:complexType derivedBy=\"restriction\">\r\n"
"					<s:all>\r\n"
"						<s:element name=\"{{GetHeaderSoapType}}\" type=\"{{if IsHeaderUDT}}s0:{{else}}s:{{endif}}{{GetHeaderSoapType}}\" {{if IsHeaderOneDimensional}}minOccurs=\"{{GetHeaderArraySize}}\" maxOccurs=\"{{GetHeaderArraySize}}\"{{else}}soap:arrayType=\"{{GetHeaderArraySoapDims}}\"{{endif}}/>\r\n"
"					</s:all>\r\n"
"				</s:complexType>\r\n"
"			</s:element>\r\n"
"{{endif}}\r\n"
"{{endwhile}}\r\n"
"		</s:schema>\r\n"
"	</types>\r\n"
"{{while GetNextFunction}}\r\n"
"	<message name=\"{{GetFunctionName}}In\">\r\n"
"		<part name=\"parameters\" element=\"s0:{{GetFunctionName}}\"/>\r\n"
"	</message>\r\n"
"	<message name=\"{{GetFunctionName}}Out\">\r\n"
"		<part name=\"parameters\" element=\"s0:{{GetFunctionName}}Response\"/>\r\n"
"	</message>\r\n"
"{{endwhile}}\r\n"
"{{while GetNextHeader}}\r\n"
"	<message name=\"{{GetHeaderName}}\">\r\n"
"		<part name=\"{{GetHeaderName}}\" element=\"s0:{{GetHeaderName}}\"/>\r\n"
"	</message>\r\n"
"{{endwhile}}\r\n"
"	<portType name=\"{{GetServiceName}}Soap\">\r\n"
"{{while GetNextFunction}}\r\n"
"		<operation name=\"{{GetFunctionName}}\">\r\n"
"			<input message=\"s0:{{GetFunctionName}}In\"/>\r\n"
"			<output message=\"s0:{{GetFunctionName}}Out\"/>\r\n"
"		</operation>\r\n"
"{{endwhile}}\r\n"
"	</portType>\r\n"
"	<binding name=\"{{GetServiceName}}Soap\" type=\"s0:{{GetServiceName}}Soap\">\r\n"
"		<soap:binding transport=\"http://schemas.xmlsoap.org/soap/http\" style=\"document\"/>\r\n"
"{{while GetNextFunction}}\r\n"
"		<operation name=\"{{GetFunctionName}}\">\r\n"
"			<soap:operation soapAction=\"#{{GetFunctionName}}\" style=\"document\"/>\r\n"
"			<input>\r\n"
"				<soap:body use=\"literal\"/>\r\n"
"{{while GetNextFunctionHeader}}\r\n"
"{{if IsInHeader}}\r\n"
"				<soap:header message=\"s0:{{GetFunctionHeaderName}}\" part=\"{{GetFunctionHeaderName}}\" use=\"literal\"{{if IsRequiredHeader}} wsdl:required=\"true\"{{endif}}/>\r\n"
"{{endif}}\r\n"
"{{endwhile}}\r\n"
"			</input>\r\n"
"			<output>\r\n"
"				<soap:body use=\"literal\"/>\r\n"
"{{while GetNextFunctionHeader}}\r\n"
"{{if IsOutHeader}}\r\n"
"				<soap:header message=\"s0:{{GetFunctionHeaderName}}\" part=\"{{GetFunctionHeaderName}}\" use=\"literal\"{{if IsRequiredHeader}} wsdl:required=\"true\"{{endif}}/>\r\n"
"{{endif}}\r\n"
"{{endwhile}}\r\n"
"			</output>\r\n"
"		</operation>\r\n"
"{{endwhile}}\r\n"
"	</binding>\r\n"
"	<service name=\"{{GetServiceName}}\">\r\n"
"		<port name=\"{{GetServiceName}}Soap\" binding=\"s0:{{GetServiceName}}Soap\">\r\n"
"			<soap:address location=\"{{GetURL}}\"/>\r\n"
"		</port>\r\n"
"	</service>\r\n"
"</definitions>"
"";

extern __declspec(selectany) const size_t s_nAtlsWSDLSrfLen = strlen(s_szAtlsWSDLSrf);

class CStreamOnSequentialStream : 
	public IStream
{
	CComPtr<ISequentialStream> m_spStream;
public:
	CStreamOnSequentialStream(ISequentialStream *pStream) throw()
	{
		ATLASSERT(pStream);
		m_spStream = pStream;
	}

    STDMETHOD(Read)(void *pv, ULONG cb, ULONG *pcbRead) throw()
	{
		if (!m_spStream)
			return E_UNEXPECTED;
		return m_spStream->Read(pv, cb, pcbRead);
	}

    STDMETHOD(Write)(const void *pv, ULONG cb, ULONG *pcbWritten) throw()
	{
		if (!m_spStream)
			return E_UNEXPECTED;
		return m_spStream->Write(pv, cb, pcbWritten);
	}

    STDMETHOD(Seek)(LARGE_INTEGER , DWORD , ULARGE_INTEGER *) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(SetSize)(ULARGE_INTEGER ) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(CopyTo)(IStream *, ULARGE_INTEGER , ULARGE_INTEGER *,
        ULARGE_INTEGER *) throw()
	{
		return E_NOTIMPL;
	}

	STDMETHOD(Commit)(DWORD ) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(Revert)( void) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(LockRegion)(ULARGE_INTEGER , ULARGE_INTEGER , DWORD ) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(UnlockRegion)(ULARGE_INTEGER , ULARGE_INTEGER ,
		DWORD ) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(Stat)(STATSTG *, DWORD ) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(Clone)(IStream **) throw()
	{
		return E_NOTIMPL;
	}

	STDMETHOD(QueryInterface)(REFIID iid, void **ppUnk) throw()
	{
		*ppUnk = NULL;
		if (::InlineIsEqualGUID(iid, IID_IUnknown) ||
            ::InlineIsEqualGUID(iid, IID_ISequentialStream) ||
			::InlineIsEqualGUID(iid, IID_IStream))
		{
			*ppUnk = (void*)(IStream*)this;
			AddRef();
			return S_OK;
		}
		return E_NOINTERFACE;
	}

	ULONG STDMETHODCALLTYPE AddRef( void) throw() 
	{
		return (ULONG)1;
	}

	ULONG STDMETHODCALLTYPE Release( void) throw() 
	{
		return (ULONG)1;
	}
};

class CStreamOnByteArray : 
	public IStream
{
public:
	BYTE *m_pArray;
	DWORD m_dwRead;

	CStreamOnByteArray(BYTE *pBytes) throw()
	{
		ATLASSERT(pBytes);
		m_pArray = pBytes;
		m_dwRead = 0;
	}

    STDMETHOD(Read)(void *pv, ULONG cb, ULONG *pcbRead) throw()
	{
		if (!pv)
			return E_INVALIDARG;

		if (cb == 0)
			return S_OK;

		if (!m_pArray)
			return E_UNEXPECTED;

		BYTE *pCurr  = m_pArray;
		pCurr += m_dwRead;
		memcpy(pv, pCurr, cb);
		if (pcbRead)
			*pcbRead = cb;
		m_dwRead += cb;
		return S_OK;
	}

    STDMETHOD(Write)(const void* , ULONG , ULONG* ) throw()
	{
		return E_UNEXPECTED;
	}

    STDMETHOD(Seek)(LARGE_INTEGER , DWORD , ULARGE_INTEGER *) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(SetSize)(ULARGE_INTEGER ) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(CopyTo)(IStream *, ULARGE_INTEGER , ULARGE_INTEGER *,
        ULARGE_INTEGER *) throw()
	{
		return E_NOTIMPL;
	}

	STDMETHOD(Commit)(DWORD ) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(Revert)( void) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(LockRegion)(ULARGE_INTEGER , ULARGE_INTEGER , DWORD ) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(UnlockRegion)(ULARGE_INTEGER , ULARGE_INTEGER ,
		DWORD ) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(Stat)(STATSTG *, DWORD ) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(Clone)(IStream **) throw()
	{
		return E_NOTIMPL;
	}

	STDMETHOD(QueryInterface)(REFIID iid, void **ppUnk) throw()
	{
		*ppUnk = NULL;
		if (::InlineIsEqualGUID(iid, IID_IUnknown) ||
            ::InlineIsEqualGUID(iid, IID_ISequentialStream) ||
			::InlineIsEqualGUID(iid, IID_IStream))
		{
			*ppUnk = (void*)(IStream*)this;
			AddRef();
			return S_OK;
		}
		return E_NOINTERFACE;
	}

	ULONG STDMETHODCALLTYPE AddRef( void)  throw()
	{
		return (ULONG)1;
	}

	ULONG STDMETHODCALLTYPE Release( void)  throw()
	{
		return (ULONG)1;
	}
};

class CVariantStream : 
	public IStream
{
public:
	CVariantStream() throw()
	{
		m_nCurrRead = 0;
		m_nVariantSize = 0;
		m_nRef = 1;
	}
	
	// input variant is put into contained BYTE array.
	HRESULT InsertVariant(const VARIANT *pVarIn) throw()
	{
		CComVariant vIn;
        HRESULT hr = E_FAIL;
		m_nCurrRead = 0;
		m_nVariantSize = 0;
		hr = vIn.Copy(pVarIn);
		if (hr == S_OK)
			hr = vIn.WriteToStream(static_cast<IStream*>(this));

		return hr;
	}

	// variant is read from contained byte array into
	// out variant.
	HRESULT RetrieveVariant(VARIANT *pVarOut) throw()
	{
		CComVariant vOut;
		HRESULT hr = vOut.ReadFromStream(static_cast<IStream*>(this));
		if (hr == S_OK)
			hr = VariantCopy(pVarOut, &vOut);
		
		m_nCurrRead = 0;
		return hr;
	}

	HRESULT LoadFromStream(ISequentialStream *stream) throw()
	{
		m_nCurrRead = 0;
		CStreamOnSequentialStream stm(stream);
		CComVariant v;
		HRESULT hr = v.ReadFromStream(&stm);
		if (hr == S_OK)
			hr = v.WriteToStream(static_cast<IStream*>(this));
		return hr;
	}

	ISequentialStream* GetStream() throw()
	{
		return static_cast<ISequentialStream*>(this);
	}

	size_t GetVariantSize() throw()
	{
		return m_nVariantSize;
	}

// Implementation
	// IStream implementation;
    STDMETHOD(Read)(void *pv, ULONG cb, ULONG *pcbRead) throw()
	{
		if (!pv)
			return E_INVALIDARG;

		if  (cb == 0)
			return S_OK;

		if (pcbRead)
			*pcbRead = 0;

		if (!m_nVariantSize)
			return S_OK; // nothing to do.

		size_t nLeft = m_nVariantSize - m_nCurrRead;
		if (nLeft > 0)
		{
			size_t nRead = min(nLeft, cb);
			BYTE *pCurr = m_stream;
			pCurr += m_nCurrRead;
			memcpy(pv,
				   pCurr,
				   nRead);
			m_nCurrRead += nRead;
			if (pcbRead)
				*pcbRead = (ULONG)nRead;
		}

		return S_OK;
	}

    STDMETHOD(Write)(const void *pv, ULONG cb, ULONG *pcbWritten) throw()
	{
		HRESULT hr = E_OUTOFMEMORY;
		if (!pv)
			return E_INVALIDARG;

		if (cb == 0)
			return S_OK;

		if (pcbWritten)
			*pcbWritten = 0;

		BYTE *pBytes = m_stream.Reallocate(cb);
		if (pBytes)
		{
			pBytes += m_nVariantSize;
			memcpy(pBytes, pv, cb);
			if (pcbWritten)
				*pcbWritten = cb;
			m_nVariantSize += cb;
			hr = S_OK;
		}
		return hr;
	}

    STDMETHOD(Seek)(LARGE_INTEGER , DWORD , ULARGE_INTEGER *) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(SetSize)(ULARGE_INTEGER ) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(CopyTo)(IStream *, ULARGE_INTEGER , ULARGE_INTEGER *,
        ULARGE_INTEGER *) throw()
	{
		return E_NOTIMPL;
	}

	STDMETHOD(Commit)(DWORD ) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(Revert)( void) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(LockRegion)(ULARGE_INTEGER , ULARGE_INTEGER , DWORD ) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(UnlockRegion)(ULARGE_INTEGER , ULARGE_INTEGER ,
		DWORD ) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(Stat)(STATSTG *, DWORD ) throw()
	{
		return E_NOTIMPL;
	}

    STDMETHOD(Clone)(IStream **) throw()
	{
		return E_NOTIMPL;
	}

	STDMETHOD(QueryInterface)(REFIID iid, void **ppUnk) throw()
	{
		*ppUnk = NULL;
		if (::InlineIsEqualGUID(iid, IID_IUnknown))
		{
			*ppUnk = (void*)(IUnknown*)this;
		}
		else if (::InlineIsEqualGUID(iid, IID_ISequentialStream))
		{
			*ppUnk = (void*)(ISequentialStream*)this;
		}
		else if (::InlineIsEqualGUID(iid, IID_IStream))
		{
			*ppUnk = (void*)(IStream*)this;
		}

		if (*ppUnk)
		{
			AddRef();
			return S_OK;
		}
		return E_NOINTERFACE;
	}

	ULONG STDMETHODCALLTYPE AddRef( void) throw()
	{
		return (ULONG)1;
	}

	ULONG STDMETHODCALLTYPE Release( void) throw()
	{
		return (ULONG)1;
	}

	CTempBuffer<BYTE> m_stream;
	size_t m_nVariantSize;
	size_t m_nCurrRead;
	long m_nRef;
};

#include <atlspriv.inl>
}; // namespace ATL

#endif // __ATLSPRIV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atlmfc\atlstencilres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by atlstencil.rc
//
#define IDS_ATLSTENCIL_ERROR            101
#define ATLSTENCIL_RESID_BASE           0x6200

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atlmfc\atlstr.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLSTR_H__
#define __ATLSTR_H__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#include <atlbase.h>

#include <winnls.h>
#include <limits.h>

#include <cstringt.h>

namespace ATL
{

extern CAtlStringMgr g_strmgr;

template< typename _BaseType = char, class StringIterator = ChTraitsOS< _BaseType > >
class StrTraitATL : public StringIterator
{
public:
	static HINSTANCE FindStringResourceInstance(UINT /* nID */) throw()
	{
		return( _AtlBaseModule.GetResourceInstance() );
	}

	static IAtlStringMgr* GetDefaultManager() throw()
	{
		return( &g_strmgr );
	}
};

#if !defined(_ATL_CSTRING_NO_CRT) && defined(_ATL_MIN_CRT)
#define _ATL_CSTRING_NO_CRT
#endif

#ifndef _ATL_CSTRING_NO_CRT
typedef CStringT< wchar_t, StrTraitATL< wchar_t, ChTraitsCRT< wchar_t > > > CAtlStringW;
typedef CStringT< char, StrTraitATL< char, ChTraitsCRT< char > > > CAtlStringA;
typedef CStringT< TCHAR, StrTraitATL< TCHAR, ChTraitsCRT< TCHAR > > > CAtlString;
#else  // _ATL_CSTRING_NO_CRT
typedef CStringT< wchar_t, StrTraitATL< wchar_t > > CAtlStringW;
typedef CStringT< char, StrTraitATL< char > > CAtlStringA;
typedef CStringT< TCHAR, StrTraitATL< TCHAR > > CAtlString;
#endif  // _ATL_CSTRING_NO_CRT

#ifndef _AFX
typedef CAtlStringW CStringW;
typedef CAtlStringA CStringA;
typedef CAtlString CString;
#endif

#ifdef __ATLCOLL_H__

template<>
class CElementTraits< ATL::CAtlStringA > :
	public CStringElementTraits< ATL::CAtlStringA >
{
};

template<>
class CElementTraits< ATL::CAtlStringW > :
	public CStringElementTraits< ATL::CAtlStringW >
{
};

#endif  // __ATLCOLL_H__

}; //namespace ATL

#endif // __ATLSTR_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atlmfc\atlsrvres.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

// Used by atlsrv.rc
//
#ifndef ATLSRV_RESID_BASE
#define ATLSRV_RESID_BASE 	0x6000
#endif

#ifndef PERFMON_RESID_BASE
#define PERFMON_RESID_BASE   0x6100
#endif

#define IDS_ATLSRV_BAD_REQUEST          (ATLSRV_RESID_BASE+1)
#define IDS_ATLSRV_AUTH_REQUIRED        (ATLSRV_RESID_BASE+2)
#define IDS_ATLSRV_FORBIDDEN            (ATLSRV_RESID_BASE+3)
#define IDS_ATLSRV_NOT_FOUND            (ATLSRV_RESID_BASE+4)
#define IDS_ATLSRV_SERVER_ERROR         (ATLSRV_RESID_BASE+5)
#define IDS_ATLSRV_NOT_IMPLEMENTED      (ATLSRV_RESID_BASE+6)
#define IDS_ATLSRV_BAD_GATEWAY          (ATLSRV_RESID_BASE+7)
#define IDS_ATLSRV_SERVICE_NOT_AVAILABLE (ATLSRV_RESID_BASE+8)
#define IDS_ATLSRV_SERVER_ERROR_BADSRF (ATLSRV_RESID_BASE+9)
#define IDS_ATLSRV_SERVER_ERROR_HNDLFAIL (ATLSRV_RESID_BASE+10)
#define IDS_ATLSRV_SERVER_ERROR_SYSOBJFAIL (ATLSRV_RESID_BASE+11)
#define IDS_ATLSRV_SERVER_ERROR_READFILEFAIL (ATLSRV_RESID_BASE+12)
#define IDS_ATLSRV_SERVER_ERROR_LOADLIB (ATLSRV_RESID_BASE+13)
#define IDS_ATLSRV_SERVER_ERROR_HANDLERIF (ATLSRV_RESID_BASE+14)
#define IDS_ATLSRV_SERVER_ERROR_OUTOFMEM (ATLSRV_RESID_BASE+15)
#define IDS_ATLSRV_SERVER_ERROR_UNEXPECTED	(ATLSRV_RESID_BASE+16)
#define IDS_ATLSRV_SERVER_ERROR_STENCILPARSEFAIL (ATLSRV_RESID_BASE+17)
#define IDS_ATLSRV_SERVER_ERROR_STENCILLOADFAIL (ATLSRV_RESID_BASE+18)
#define IDS_ATLSRV_SERVER_ERROR_HANDLERNOTFOUND (ATLSRV_RESID_BASE+19)
#define IDS_ATLSRV_SERVER_ERROR_BADHANDLERTAG (ATLSRV_RESID_BASE+20)
#define IDS_ATLSRV_SERVER_ERROR_NOHANDLERTAG (ATLSRV_RESID_BASE+21)
#define IDS_ATLSRV_SERVER_ERROR_LONGMETHODNAME (ATLSRV_RESID_BASE+22)
#define IDS_ATLSRV_SERVER_ERROR_LONGHANDLERNAME (ATLSRV_RESID_BASE+23)
#define IDS_ATLSRV_SERVER_ERROR_IMPERSONATIONFAILED (ATLSRV_RESID_BASE+24)
#define IDS_ATLSRV_SERVER_ERROR_ISAPISTARTUPFAILED (ATLSRV_RESID_BASE+25)
#define IDS_ATLSRV_SERVER_ERROR_LOADFILEFAIL (ATLSRV_RESID_BASE+26)
#define IDS_PERFMON_CACHE                       (PERFMON_RESID_BASE+1)
#define IDS_PERFMON_CACHE_HELP                  (PERFMON_RESID_BASE+2)
#define IDS_PERFMON_HITCOUNT                    (PERFMON_RESID_BASE+3)
#define IDS_PERFMON_HITCOUNT_HELP               (PERFMON_RESID_BASE+4)
#define IDS_PERFMON_MISSCOUNT                   (PERFMON_RESID_BASE+5)
#define IDS_PERFMON_MISSCOUNT_HELP              (PERFMON_RESID_BASE+6)
#define IDS_PERFMON_CURRENTALLOCATIONS          (PERFMON_RESID_BASE+7)
#define IDS_PERFMON_CURRENTALLOCATIONS_HELP     (PERFMON_RESID_BASE+8)
#define IDS_PERFMON_MAXALLOCATIONS              (PERFMON_RESID_BASE+9)
#define IDS_PERFMON_MAXALLOCATIONS_HELP         (PERFMON_RESID_BASE+10)
#define IDS_PERFMON_CURRENTENTRIES              (PERFMON_RESID_BASE+11)
#define IDS_PERFMON_CURRENTENTRIES_HELP         (PERFMON_RESID_BASE+12)
#define IDS_PERFMON_MAXENTRIES                  (PERFMON_RESID_BASE+13)
#define IDS_PERFMON_MAXENTRIES_HELP             (PERFMON_RESID_BASE+14)
#define IDS_PERFMON_HITCOUNTRATE                (PERFMON_RESID_BASE+15)
#define IDS_PERFMON_HITCOUNTRATE_HELP           (PERFMON_RESID_BASE+16)

#define IDS_PERFMON_REQUEST						(PERFMON_RESID_BASE+17)
#define IDS_PERFMON_REQUEST_HELP				(PERFMON_RESID_BASE+18)
#define IDS_PERFMON_REQUEST_TOTAL				(PERFMON_RESID_BASE+19)
#define IDS_PERFMON_REQUEST_TOTAL_HELP			(PERFMON_RESID_BASE+20)
#define IDS_PERFMON_REQUEST_FAILED				(PERFMON_RESID_BASE+21)
#define IDS_PERFMON_REQUEST_FAILED_HELP			(PERFMON_RESID_BASE+22)
#define IDS_PERFMON_REQUEST_RATE				(PERFMON_RESID_BASE+23)
#define IDS_PERFMON_REQUEST_RATE_HELP			(PERFMON_RESID_BASE+24)
#define IDS_PERFMON_REQUEST_AVG_RESPONSE_TIME		(PERFMON_RESID_BASE+25)
#define IDS_PERFMON_REQUEST_AVG_RESPONSE_TIME_HELP	(PERFMON_RESID_BASE+26)
#define IDS_PERFMON_REQUEST_CURR_WAITING (PERFMON_RESID_BASE+27)
#define IDS_PERFMON_REQUEST_CURR_WAITING_HELP	(PERFMON_RESID_BASE+28)
#define IDS_PERFMON_REQUEST_MAX_WAITING (PERFMON_RESID_BASE+29)
#define IDS_PERFMON_REQUEST_MAX_WAITING_HELP	(PERFMON_RESID_BASE+30)
#define IDS_PERFMON_REQUEST_ACTIVE_THREADS		(PERFMON_RESID_BASE+31)
#define IDS_PERFMON_REQUEST_ACTIVE_THREADS_HELP	(PERFMON_RESID_BASE+32)

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atlmfc\atlsync.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.


#ifndef __ATLSYNC_H__
#define __ATLSYNC_H__

#pragma once

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning(push)
#pragma warning(disable: 4512)  // assignment operator could not be generated
#endif  // !_ATL_NO_PRAGMA_WARNINGS

#include <atlbase.h>

namespace ATL
{

class CCriticalSection :
	public CRITICAL_SECTION
{
public:
	CCriticalSection();
#if (_WIN32_WINNT >= 0x0403)
	explicit CCriticalSection( ULONG nSpinCount );
#endif
	~CCriticalSection() throw();

	// Acquire the critical section
	void Enter();
	// Release the critical section
	void Leave() throw();
#if (_WIN32_WINNT >= 0x0403)
	// Set the spin count for the critical section
	ULONG SetSpinCount( ULONG nSpinCount ) throw();
#endif
#if (_WIN32_WINNT >= 0x0400)
	// Attempt to acquire the critical section
	BOOL TryEnter() throw();
#endif
};

class CEvent :
	public CHandle
{
public:
	CEvent() throw();
	CEvent( CEvent& h ) throw();
	CEvent( BOOL bManualReset, BOOL bInitialState );
	CEvent( LPSECURITY_ATTRIBUTES pSecurity, BOOL bManualReset, BOOL bInitialState, LPCTSTR pszName );
	explicit CEvent( HANDLE h ) throw();

	// Create a new event
	BOOL Create( LPSECURITY_ATTRIBUTES pSecurity, BOOL bManualReset, BOOL bInitialState, LPCTSTR pszName ) throw();
	// Open an existing named event
	BOOL Open( DWORD dwAccess, BOOL bInheritHandle, LPCTSTR pszName ) throw();
	// Pulse the event (signals waiting objects, then resets)
	BOOL Pulse() throw();
	// Set the event to the non-signaled state
	BOOL Reset() throw();
	// Set the event to the signaled state
	BOOL Set() throw();
};

class CMutex :
	public CHandle
{
public:
	CMutex() throw();
	CMutex( CMutex& h ) throw();
	explicit CMutex( BOOL bInitialOwner );
	CMutex( LPSECURITY_ATTRIBUTES pSecurity, BOOL bInitialOwner, LPCTSTR pszName );
	explicit CMutex( HANDLE h ) throw();

	// Create a new mutex
	BOOL Create( LPSECURITY_ATTRIBUTES pSecurity, BOOL bInitialOwner, LPCTSTR pszName ) throw();
	// Open an existing named mutex
	BOOL Open( DWORD dwAccess, BOOL bInheritHandle, LPCTSTR pszName ) throw();
	// Release ownership of the mutex
	BOOL Release() throw();
};

class CSemaphore :
	public CHandle
{
public:
	CSemaphore() throw();
	CSemaphore( CSemaphore& h ) throw();
	CSemaphore( LONG nInitialCount, LONG nMaxCount );
	CSemaphore( LPSECURITY_ATTRIBUTES pSecurity, LONG nInitialCount, LONG nMaxCount, LPCTSTR pszName );
	explicit CSemaphore( HANDLE h ) throw();

	// Create a new semaphore
	BOOL Create( LPSECURITY_ATTRIBUTES pSecurity, LONG nInitialCount, LONG nMaxCount, LPCTSTR pszName ) throw();
	// Open an existing named semaphore
	BOOL Open( DWORD dwAccess, BOOL bInheritHandle, LPCTSTR pszName ) throw();
	// Increase the count of the semaphore
	BOOL Release( LONG nReleaseCount = 1, LONG* pnOldCount = NULL ) throw();
};

class CMutexLock
{
public:
	CMutexLock( CMutex& mtx, bool bInitialLock = true );
	~CMutexLock() throw();

	void Lock();
	void Unlock() throw();

// Implementation
private:
	CMutex& m_mtx;
	bool m_bLocked;

// Private to prevent accidental use
	CMutexLock( const CMutexLock& ) throw();
	CMutexLock& operator=( const CMutexLock& ) throw();
};

};  // namespace ATL

#include <atlsync.inl>

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning(pop)
#endif  // !_ATL_NO_PRAGMA_WARNINGS

#endif  // __ATLSYNC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atlmfc\atlspriv.inl ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

/////////////////////////////////////////////////////////////////////////////////
//
// ZEvtSyncSocket
// ************ This is an implementation only class ************
// Class ZEvtSyncSocket is a non-supported, implementation only 
// class used by the ATL HTTP client class CAtlHttpClient. Do not
// use this class in your code. Use of this class is not supported by Microsoft.
//
/////////////////////////////////////////////////////////////////////////////////

#ifndef __ATLSPRIV_INL__
#define __ATLSPRIV_INL__

#pragma once

inline ZEvtSyncSocket::ZEvtSyncSocket() 
{
	m_dwCreateFlags = WSA_FLAG_OVERLAPPED;
	m_hEventRead = m_hEventWrite = m_hEventConnect = NULL;
	m_socket = INVALID_SOCKET;
	m_bConnected = false;
	m_dwLastError = 0;
	m_dwSocketTimeout = ATL_SOCK_TIMEOUT;
	g_HttpInit.Init();
}

inline ZEvtSyncSocket::~ZEvtSyncSocket() 
{
	Close();
}

inline ZEvtSyncSocket::operator SOCKET() 
{
	return m_socket;
}

inline void ZEvtSyncSocket::Close()
{
	if (m_socket != INVALID_SOCKET)
	{
		m_bConnected = false;
		closesocket(m_socket);
		m_socket = INVALID_SOCKET;
		Term();
	}
}

inline void ZEvtSyncSocket::Term() 
{
	if (m_hEventRead)
	{
		WSACloseEvent(m_hEventRead);
		m_hEventRead = NULL;
	}
	if (m_hEventWrite)
	{
		WSACloseEvent(m_hEventWrite);
		m_hEventWrite = NULL;
	}
	if (m_hEventConnect)
	{
		WSACloseEvent(m_hEventConnect);
		m_hEventConnect = NULL;
	}
	m_socket = INVALID_SOCKET;
}

inline bool ZEvtSyncSocket::Create(WORD wFlags)
{
	return Create(PF_INET, SOCK_STREAM, IPPROTO_TCP, wFlags);
}

inline bool ZEvtSyncSocket::Create(short af, short st, short proto, WORD wFlags) 
{
	bool bRet = true;
	if (m_socket != INVALID_SOCKET)
	{
		m_dwLastError = WSAEALREADY;
		return false; // Must close this socket first
	}

	m_socket = WSASocket(af, st, proto, NULL, 0,
		wFlags | m_dwCreateFlags);
	if (m_socket == INVALID_SOCKET)
	{
		m_dwLastError = ::WSAGetLastError();
		bRet = false;
	}
	else
		bRet = Init(m_socket, NULL);
	return bRet;
}

inline bool ZEvtSyncSocket::Connect(LPCTSTR szAddr, unsigned short nPort) 
{
	if (m_bConnected)
		return true;

	bool bRet = true;
	CTCPAddrLookup address;
	if (SOCKET_ERROR == address.GetRemoteAddr(szAddr, nPort))
	{
		m_dwLastError = WSAGetLastError();
		bRet = false;
	}
	else
	{
		bRet = Connect(address.Addr);
	}
	return bRet;
}

inline bool ZEvtSyncSocket::Connect(const SOCKADDR* psa) 
{
	if (m_bConnected)
		return true; // already connected

	DWORD dwLastError;
	bool bRet = true;

	// if you try to connect the socket without
	// creating it first it's reasonable to automatically
	// try the create for you.
	if (m_socket == INVALID_SOCKET &&
		!Create())
		return false;

	if (WSAConnect(m_socket, 
		psa, sizeof(SOCKADDR),
		NULL, NULL, NULL, NULL))
	{
		dwLastError = WSAGetLastError();
		if (dwLastError != WSAEWOULDBLOCK)
		{
			m_dwLastError = dwLastError;
			bRet = false;
		}
		else
		{
			dwLastError = WaitForSingleObject((HANDLE)m_hEventConnect, 10000);
			if (dwLastError == WAIT_OBJECT_0)
			{
				// make sure there were no connection errors.
				WSANETWORKEVENTS wse;
				ZeroMemory(&wse, sizeof(wse));
				WSAEnumNetworkEvents(m_socket, NULL, &wse);
				if (wse.iErrorCode[FD_CONNECT_BIT]!=0)
				{
					m_dwLastError = (DWORD)(wse.iErrorCode[FD_CONNECT_BIT]);
					return false;
				}
			}
		}

	}

	m_bConnected = bRet;
	return bRet;
}

inline bool ZEvtSyncSocket::Write(WSABUF *pBuffers, int nCount, DWORD *pdwSize) 
{
	// if we aren't already connected we'll wait to see if the connect
	// event happens
	if (WAIT_OBJECT_0 != WaitForSingleObject((HANDLE)m_hEventConnect , m_dwSocketTimeout))
	{
		m_dwLastError = WSAENOTCONN;
		return false; // not connected
	}

	// make sure we aren't already writing
	if (WAIT_TIMEOUT == WaitForSingleObject((HANDLE)m_hEventWrite, 0))
	{
		m_dwLastError = WSAEINPROGRESS;
		return false; // another write on is blocking this socket
	}

	bool bRet = true;
	*pdwSize = 0;
	WSAOVERLAPPED o;
	m_csWrite.Lock();
	o.hEvent = m_hEventWrite;
	WSAResetEvent(o.hEvent);
	if (WSASend(m_socket, pBuffers, nCount, pdwSize, 0, &o, 0))
	{	
		DWORD dwLastError = WSAGetLastError();
		if (dwLastError != WSA_IO_PENDING)
		{
			m_dwLastError = dwLastError;
			bRet = false;
		}
	}
	
	// wait for write to complete
	if (bRet && WAIT_OBJECT_0 == WaitForSingleObject((HANDLE)m_hEventWrite, m_dwSocketTimeout))
	{
		DWORD dwFlags = 0;
		if (WSAGetOverlappedResult(m_socket, &o, pdwSize, FALSE, &dwFlags))
			bRet = true;
		else
		{
			m_dwLastError = ::GetLastError();
			bRet = false;
		}
	}
	
	m_csWrite.Unlock();
	return bRet;

}

inline bool ZEvtSyncSocket::Write(const unsigned char *pBuffIn, DWORD *pdwSize) 
{
	WSABUF buff;
	buff.buf = (char*)pBuffIn;
	buff.len = *pdwSize;
	return Write(&buff, 1, pdwSize);
}

inline bool ZEvtSyncSocket::Read(const unsigned char *pBuff, DWORD *pdwSize) 
{
	// if we aren't already connected we'll wait to see if the connect
	// event happens
	if (WAIT_OBJECT_0 != WaitForSingleObject((HANDLE)m_hEventConnect , m_dwSocketTimeout))
	{
		m_dwLastError = WSAENOTCONN;
		return false; // not connected
	}

	if (WAIT_ABANDONED == WaitForSingleObject((HANDLE)m_hEventRead, 0))
	{
		m_dwLastError = WSAEINPROGRESS;
		return false; // another write on is blocking this socket
	}

	bool bRet = true;
	WSABUF buff;
	buff.buf = (char*)pBuff;
	buff.len = *pdwSize;
	*pdwSize = 0;
	DWORD dwFlags = 0;
	WSAOVERLAPPED o;
	ZeroMemory(&o, sizeof(o));

	// protect against re-entrency
	m_csRead.Lock();
	o.hEvent = m_hEventRead;
	WSAResetEvent(o.hEvent);
	if (WSARecv(m_socket, &buff, 1, pdwSize, &dwFlags, &o, 0))
	{
		DWORD dwLastError = WSAGetLastError();
		if (dwLastError != WSA_IO_PENDING)
		{
			m_dwLastError = dwLastError;
			bRet = false;
		}
	}

	// wait for the read to complete
	if (bRet && WAIT_OBJECT_0 == WaitForSingleObject((HANDLE)o.hEvent, m_dwSocketTimeout))
	{
		dwFlags = 0;
		if (WSAGetOverlappedResult(m_socket, &o, pdwSize, FALSE, &dwFlags))
			bRet = true;
		else
		{
			m_dwLastError = ::GetLastError();
			bRet = false;
		}

	}

	m_csRead.Unlock();
	return bRet;
}

inline bool ZEvtSyncSocket::Init(SOCKET hSocket, void * /*pData=NULL*/) 
{
	ATLASSERT(hSocket != INVALID_SOCKET);

	if (hSocket == INVALID_SOCKET)
	{
		m_dwLastError = WSAENOTSOCK;
		return false;
	}

	m_socket = hSocket;
	
	// Allocate Events. On error, any open event handles will be closed
	// in the destructor
	if (NULL != (m_hEventRead = WSACreateEvent()))
		if (NULL != (m_hEventWrite = WSACreateEvent()))
			if (NULL != (m_hEventConnect = WSACreateEvent()))
	{
		if (!WSASetEvent(m_hEventWrite) || !WSASetEvent(m_hEventRead))
		{
			m_dwLastError = ::GetLastError();
			return false;
		}

		if (SOCKET_ERROR != WSAEventSelect(m_socket, m_hEventRead, FD_READ))
			if (SOCKET_ERROR != WSAEventSelect(m_socket, m_hEventWrite, FD_WRITE))
				if (SOCKET_ERROR != WSAEventSelect(m_socket, m_hEventConnect, FD_CONNECT))
					return true;
	}
	m_dwLastError = ::GetLastError();
	return false;
}

inline DWORD ZEvtSyncSocket::GetSocketTimeout()
{
	return m_dwSocketTimeout;
}

inline DWORD ZEvtSyncSocket::SetSocketTimeout(DWORD dwNewTimeout)
{
	DWORD dwOldTimeout = m_dwSocketTimeout;
	m_dwSocketTimeout = dwNewTimeout;
	return dwOldTimeout;
}

inline bool ZEvtSyncSocket::SupportsScheme(ATL_URL_SCHEME scheme)
{
	// default only supports HTTP
	return scheme == ATL_URL_SCHEME_HTTP ? true : false;
}

inline CTCPAddrLookup::CTCPAddrLookup() 
{
	m_pQuerySet = NULL;
	m_pAddr = NULL;
	ZeroMemory(&m_saIn, sizeof(m_saIn));
	m_saIn.sin_family = PF_INET;
	m_saIn.sin_zero[0] = 0;
	m_saIn.sin_addr.s_addr = INADDR_NONE;
	m_nAddrSize = sizeof(m_saIn);
}

inline CTCPAddrLookup::~CTCPAddrLookup() 
{
	if (m_pQuerySet)
		free ((void*)m_pQuerySet);
}

inline int CTCPAddrLookup::GetRemoteAddr(LPCTSTR szName, short nPort) 
{
	int nErr = WSAEFAULT;

	m_nAddrSize = sizeof(m_saIn);
	// first try for the dotted IP address
	if (SOCKET_ERROR != WSAStringToAddress(	(LPTSTR)szName,
											AF_INET,
											NULL,
											(SOCKADDR*)&m_saIn,
											&m_nAddrSize))
	{
		// Address was a dotted IP address
		m_saIn.sin_port = htons(nPort);
		m_pAddr = (SOCKADDR*)&m_saIn;
		return 0;
	}

	// else, try to lookup the service
	m_nAddrSize = 0;
	ATLTRY(m_pQuerySet = (WSAQUERYSET*)malloc(ATL_MAX_QUERYSET));
	if (m_pQuerySet)
	{
		ZeroMemory(m_pQuerySet, sizeof(WSAQUERYSET));
		GUID guidsvc = SVCID_TCP(nPort);
		AFPROTOCOLS afinet = {PF_INET, IPPROTO_TCP};
		m_pQuerySet->dwSize = sizeof(WSAQUERYSET);
		m_pQuerySet->dwNameSpace = NS_ALL;
		m_pQuerySet->lpafpProtocols = &afinet;
		m_pQuerySet->dwNumberOfProtocols = 1;
		m_pQuerySet->lpServiceClassId = &guidsvc;
		m_pQuerySet->lpszServiceInstanceName = (LPTSTR)szName;
		DWORD dwSize = ATL_MAX_QUERYSET;
		HANDLE hLookup = NULL;

		if (SOCKET_ERROR != WSALookupServiceBegin(m_pQuerySet, LUP_RETURN_ADDR, &hLookup))
		{
			ATLASSERT(hLookup != NULL);

			if (SOCKET_ERROR != WSALookupServiceNext(hLookup, 0, (DWORD*)&dwSize, m_pQuerySet))
			{
				m_pAddr = m_pQuerySet->lpcsaBuffer[0].RemoteAddr.lpSockaddr;
				m_nAddrSize = m_pQuerySet->lpcsaBuffer[0].RemoteAddr.iSockaddrLength;
				nErr = 0;
			}
			else
				nErr = (int)GetLastError();
			WSALookupServiceEnd(hLookup);
		}
	}

	if (nErr != 0)
	{
		if (m_pQuerySet)
		{
			free(m_pQuerySet);
			m_pQuerySet = NULL;
		}
	
		m_pAddr = NULL;
		m_nAddrSize = 0;
	}
	return nErr;
}


inline const SOCKADDR* CTCPAddrLookup::GetSockAddr()
{
	return const_cast<const SOCKADDR*>(m_pAddr);
}

inline int CTCPAddrLookup::GetSockAddrSize()
{
	return m_nAddrSize;
}

#endif // __ATLSPRIV_INL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atlmfc\atltime.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLTIME_H__
#define __ATLTIME_H__

#pragma once

#include <atldef.h>

#ifndef _ATL_MIN_CRT
#include <time.h>

#ifdef _AFX
#include <afxstr.h>
#else
#include <atlstr.h>
#endif
#endif

namespace ATL
{
class CTimeSpan
{
public:
	CTimeSpan() throw();
	CTimeSpan( __time64_t time ) throw();
	CTimeSpan( LONG lDays, int nHours, int nMins, int nSecs ) throw();

	LONGLONG GetDays() const throw();
	LONGLONG GetTotalHours() const throw();
	LONG GetHours() const throw();
	LONGLONG GetTotalMinutes() const throw();
	LONG GetMinutes() const throw();
	LONGLONG GetTotalSeconds() const throw();
	LONG GetSeconds() const throw();

	__time64_t GetTimeSpan() const throw();

	CTimeSpan operator+( CTimeSpan span ) const throw();
	CTimeSpan operator-( CTimeSpan span ) const throw();
	CTimeSpan& operator+=( CTimeSpan span ) throw();
	CTimeSpan& operator-=( CTimeSpan span ) throw();
	bool operator==( CTimeSpan span ) const throw();
	bool operator!=( CTimeSpan span ) const throw();
	bool operator<( CTimeSpan span ) const throw();
	bool operator>( CTimeSpan span ) const throw();
	bool operator<=( CTimeSpan span ) const throw();
	bool operator>=( CTimeSpan span ) const throw();

#ifndef _ATL_MIN_CRT
public:
	CString Format( LPCTSTR pszFormat ) const;
	CString Format( UINT nID ) const;
#endif
#if defined(_AFX) && defined(_UNICODE)
	// REVIEW
	// for compatibility with MFC 3.x
	CString Format(LPCSTR pFormat) const;
#endif

#ifdef _AFX
	CArchive& Serialize64(CArchive& ar);
#endif

private:
	__time64_t m_timeSpan;
};

class CTime
{
public:
	static CTime GetCurrentTime() throw();

	CTime() throw();
	CTime( __time64_t time ) throw();
	CTime( int nYear, int nMonth, int nDay, int nHour, int nMin, int nSec,
		int nDST = -1 ) throw();
	CTime( WORD wDosDate, WORD wDosTime, int nDST = -1 ) throw();
	CTime( const SYSTEMTIME& st, int nDST = -1 ) throw();
	CTime( const FILETIME& ft, int nDST = -1 ) throw();
#ifdef __oledb_h__
	CTime( const DBTIMESTAMP& dbts, int nDST = -1 ) throw();
#endif

	CTime& operator=( __time64_t time ) throw();

	CTime& operator+=( CTimeSpan span ) throw();
	CTime& operator-=( CTimeSpan span ) throw();

	CTimeSpan operator-( CTime time ) const throw();
	CTime operator-( CTimeSpan span ) const throw();
	CTime operator+( CTimeSpan span ) const throw();

	bool operator==( CTime time ) const throw();
	bool operator!=( CTime time ) const throw();
	bool operator<( CTime time ) const throw();
	bool operator>( CTime time ) const throw();
	bool operator<=( CTime time ) const throw();
	bool operator>=( CTime time ) const throw();

	struct tm* GetGmtTm( struct tm* ptm = NULL ) const throw();
	struct tm* GetLocalTm( struct tm* ptm = NULL ) const throw();
	bool GetAsSystemTime( SYSTEMTIME& st ) const throw();
#ifdef __oledb_h__
	bool GetAsDBTIMESTAMP( DBTIMESTAMP& dbts ) const throw();
#endif

	__time64_t GetTime() const throw();

	int GetYear() const throw();
	int GetMonth() const throw();
	int GetDay() const throw();
	int GetHour() const throw();
	int GetMinute() const throw();
	int GetSecond() const throw();
	int GetDayOfWeek() const throw();

#ifndef _ATL_MIN_CRT
	// formatting using "C" strftime
	CString Format( LPCTSTR pszFormat ) const;
	CString FormatGmt( LPCTSTR pszFormat ) const;
	CString Format( UINT nFormatID ) const;
	CString FormatGmt( UINT nFormatID ) const;
#endif

#if defined(_AFX) && defined(_UNICODE)
	// REVIEW
	// for compatibility with MFC 3.x
	CString Format(LPCSTR pFormat) const;
	CString FormatGmt(LPCSTR pFormat) const;
#endif

#ifdef _AFX
	CArchive& Serialize64(CArchive& ar);
#endif

private:
	__time64_t m_time;
};

class COleDateTimeSpan
{
// Constructors
public:
	COleDateTimeSpan() throw();

	COleDateTimeSpan(double dblSpanSrc) throw();
	COleDateTimeSpan(LONG lDays, int nHours, int nMins, int nSecs) throw();

// Attributes
	enum DateTimeSpanStatus
	{
		valid = 0,
		invalid = 1,    // Invalid span (out of range, etc.)
		null = 2,       // Literally has no value
	};

	double m_span;
	DateTimeSpanStatus m_status;

	void SetStatus(DateTimeSpanStatus status) throw();
	DateTimeSpanStatus GetStatus() const throw();

	double GetTotalDays() const throw();    // span in days (about -3.65e6 to 3.65e6)
	double GetTotalHours() const throw();   // span in hours (about -8.77e7 to 8.77e6)
	double GetTotalMinutes() const throw(); // span in minutes (about -5.26e9 to 5.26e9)
	double GetTotalSeconds() const throw(); // span in seconds (about -3.16e11 to 3.16e11)

	LONG GetDays() const throw();       // component days in span
	LONG GetHours() const throw();      // component hours in span (-23 to 23)
	LONG GetMinutes() const throw();    // component minutes in span (-59 to 59)
	LONG GetSeconds() const throw();    // component seconds in span (-59 to 59)

// Operations
	COleDateTimeSpan& operator=(double dblSpanSrc) throw();

	bool operator==(const COleDateTimeSpan& dateSpan) const throw();
	bool operator!=(const COleDateTimeSpan& dateSpan) const throw();
	bool operator<(const COleDateTimeSpan& dateSpan) const throw();
	bool operator>(const COleDateTimeSpan& dateSpan) const throw();
	bool operator<=(const COleDateTimeSpan& dateSpan) const throw();
	bool operator>=(const COleDateTimeSpan& dateSpan) const throw();

	// DateTimeSpan math
	COleDateTimeSpan operator+(const COleDateTimeSpan& dateSpan) const throw();
	COleDateTimeSpan operator-(const COleDateTimeSpan& dateSpan) const throw();
	COleDateTimeSpan& operator+=(const COleDateTimeSpan dateSpan) throw();
	COleDateTimeSpan& operator-=(const COleDateTimeSpan dateSpan) throw();
	COleDateTimeSpan operator-() const throw();

	operator double() const throw();

	void SetDateTimeSpan(LONG lDays, int nHours, int nMins, int nSecs) throw();

#ifndef _ATL_MIN_CRT
	// formatting
	CString Format(LPCTSTR pFormat) const;
	CString Format(UINT nID) const;
#endif

// Implementation
	void CheckRange();

private:
	static const double OLE_DATETIME_HALFSECOND;
};

class COleDateTime
{
// Constructors
public:
	static COleDateTime GetCurrentTime() throw();

	COleDateTime() throw();

	COleDateTime(const VARIANT& varSrc) throw();
	COleDateTime(DATE dtSrc) throw();

#ifndef  _WIN64

	COleDateTime(time_t timeSrc) throw();

#endif // _WIN64

	COleDateTime(__time64_t timeSrc) throw();

	COleDateTime(const SYSTEMTIME& systimeSrc) throw();
	COleDateTime(const FILETIME& filetimeSrc) throw();

	COleDateTime(int nYear, int nMonth, int nDay,
		int nHour, int nMin, int nSec) throw();
	COleDateTime(WORD wDosDate, WORD wDosTime) throw();

// Attributes
	enum DateTimeStatus
	{
		error = -1,
		valid = 0,
		invalid = 1,    // Invalid date (out of range, etc.)
		null = 2,       // Literally has no value
	};

	DATE m_dt;
	DateTimeStatus m_status;

	void SetStatus(DateTimeStatus status) throw();
	DateTimeStatus GetStatus() const throw();

	bool GetAsSystemTime(SYSTEMTIME& sysTime) const throw();
	bool GetAsUDATE( UDATE& udate ) const throw();

	int GetYear() const throw();
	// Month of year (1 = January)
	int GetMonth() const throw();
	// Day of month (1-31)
	int GetDay() const throw();
	// Hour in day (0-23)
	int GetHour() const throw();
	// Minute in hour (0-59)
	int GetMinute() const throw();
	// Second in minute (0-59)
	int GetSecond() const throw();
	// Day of week (1 = Sunday, 2 = Monday, ..., 7 = Saturday)
	int GetDayOfWeek() const throw();
	// Days since start of year (1 = January 1)
	int GetDayOfYear() const throw();

// Operations
	COleDateTime& operator=(const VARIANT& varSrc) throw();
	COleDateTime& operator=(DATE dtSrc) throw();

#ifndef  _WIN64

	COleDateTime& operator=(const time_t& timeSrc) throw();
	
#endif // _WIN64

	COleDateTime& operator=(const __time64_t& timeSrc) throw();

	COleDateTime& operator=(const SYSTEMTIME& systimeSrc) throw();
	COleDateTime& operator=(const FILETIME& filetimeSrc) throw();
	COleDateTime& operator=(const UDATE& udate) throw();

	bool operator==(const COleDateTime& date) const throw();
	bool operator!=(const COleDateTime& date) const throw();
	bool operator<(const COleDateTime& date) const throw();
	bool operator>(const COleDateTime& date) const throw();
	bool operator<=(const COleDateTime& date) const throw();
	bool operator>=(const COleDateTime& date) const throw();

	// DateTime math
	COleDateTime operator+(COleDateTimeSpan dateSpan) const throw();
	COleDateTime operator-(COleDateTimeSpan dateSpan) const throw();
	COleDateTime& operator+=(COleDateTimeSpan dateSpan) throw();
	COleDateTime& operator-=(COleDateTimeSpan dateSpan) throw();

	// DateTimeSpan math
	COleDateTimeSpan operator-(const COleDateTime& date) const throw();

	operator DATE() const throw();

	int SetDateTime(int nYear, int nMonth, int nDay,
		int nHour, int nMin, int nSec) throw();
	int SetDate(int nYear, int nMonth, int nDay) throw();
	int SetTime(int nHour, int nMin, int nSec) throw();
	bool ParseDateTime(LPCTSTR lpszDate, DWORD dwFlags = 0,
		LCID lcid = LANG_USER_DEFAULT) throw();

#ifndef _ATL_MIN_CRT
	// formatting
	CString Format(DWORD dwFlags = 0, LCID lcid = LANG_USER_DEFAULT) const;
	CString Format(LPCTSTR lpszFormat) const;
	CString Format(UINT nFormatID) const;
#endif

protected:
	static double DoubleFromDate( DATE date ) throw();
	static DATE DateFromDouble( double f ) throw();

	void CheckRange();
};

class CFileTimeSpan
{
public:
	CFileTimeSpan() throw();
	CFileTimeSpan( const CFileTimeSpan& span ) throw();
	CFileTimeSpan( LONGLONG nSpan ) throw();

	CFileTimeSpan& operator=( const CFileTimeSpan& span ) throw();

	CFileTimeSpan& operator+=( CFileTimeSpan span ) throw();
	CFileTimeSpan& operator-=( CFileTimeSpan span ) throw();

	CFileTimeSpan operator+( CFileTimeSpan span ) const throw();
	CFileTimeSpan operator-( CFileTimeSpan span ) const throw();

	bool operator==( CFileTimeSpan span ) const throw();
	bool operator!=( CFileTimeSpan span ) const throw();
	bool operator<( CFileTimeSpan span ) const throw();
	bool operator>( CFileTimeSpan span ) const throw();
	bool operator<=( CFileTimeSpan span ) const throw();
	bool operator>=( CFileTimeSpan span ) const throw();

	LONGLONG GetTimeSpan() const throw();
	void SetTimeSpan( LONGLONG nSpan ) throw();

protected:
	LONGLONG m_nSpan;
};

class CFileTime :
	public FILETIME
{
public:
	CFileTime() throw();
	CFileTime( const FILETIME& ft ) throw();
	CFileTime( ULONGLONG nTime ) throw();

	static CFileTime GetCurrentTime() throw();

	CFileTime& operator=( const FILETIME& ft ) throw();

	CFileTime& operator+=( CFileTimeSpan span ) throw();
	CFileTime& operator-=( CFileTimeSpan span ) throw();

	CFileTime operator+( CFileTimeSpan span ) const throw();
	CFileTime operator-( CFileTimeSpan span ) const throw();
	CFileTimeSpan operator-( CFileTime ft ) const throw();

	bool operator==( CFileTime ft ) const throw();
	bool operator!=( CFileTime ft ) const throw();
	bool operator<( CFileTime ft ) const throw();
	bool operator>( CFileTime ft ) const throw();
	bool operator<=( CFileTime ft ) const throw();
	bool operator>=( CFileTime ft ) const throw();

	ULONGLONG GetTime() const throw();
	void SetTime( ULONGLONG nTime ) throw();

	CFileTime UTCToLocal() const throw();
	CFileTime LocalToUTC() const throw();

	static const ULONGLONG Millisecond = 10000;
	static const ULONGLONG Second = Millisecond * 1000;
	static const ULONGLONG Minute = Second * 60;
	static const ULONGLONG Hour = Minute * 60;
	static const ULONGLONG Day = Hour * 24;
	static const ULONGLONG Week = Day * 7;
};

}

#include <atltime.inl>

#endif  // __ATLTIME_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atlmfc\atlsync.inl ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#ifndef __ATLSYNC_INL__
#define __ATLSYNC_INL__

#pragma once

#ifndef __ATLSYNC_H__
	#error atlsync.inl requires atlsync.h to be included first
#endif

namespace ATL
{

inline CCriticalSection::CCriticalSection()
{
	__try
	{
		::InitializeCriticalSection( this );
	}
	__except( EXCEPTION_EXECUTE_HANDLER )
	{
		AtlThrow( E_OUTOFMEMORY );
	}
}

#if (_WIN32_WINNT >= 0x0403)
inline CCriticalSection::CCriticalSection( ULONG nSpinCount )
{
	__try
	{
		::InitializeCriticalSectionAndSpinCount( this, nSpinCount );
	}
	__except( EXCEPTION_EXECUTE_HANDLER )
	{
		AtlThrow( E_OUTOFMEMORY );
	}
}
#endif

inline CCriticalSection::~CCriticalSection()
{
	::DeleteCriticalSection( this );
}

inline void CCriticalSection::Enter()
{
	__try
	{
		::EnterCriticalSection( this );
	}
	__except( EXCEPTION_EXECUTE_HANDLER )
	{
		AtlThrow( E_OUTOFMEMORY );
	}
}

inline void CCriticalSection::Leave()
{
	::LeaveCriticalSection( this );
}

#if (_WIN32_WINNT >= 0x0403)
inline ULONG CCriticalSection::SetSpinCount( ULONG nSpinCount )
{
	return( ::SetCriticalSectionSpinCount( this, nSpinCount ) );
}
#endif

#if(_WIN32_WINNT >= 0x0400)
inline BOOL CCriticalSection::TryEnter()
{
	return( ::TryEnterCriticalSection( this ) );
}
#endif

inline CEvent::CEvent()
{
}

inline CEvent::CEvent( CEvent& hEvent ) :
	CHandle( hEvent )
{
}

inline CEvent::CEvent( BOOL bManualReset, BOOL bInitialState )
{
	BOOL bSuccess;
	
	bSuccess = Create( NULL, bManualReset, bInitialState, NULL );
	if( !bSuccess )
	{
		AtlThrowLastWin32();
	}
}

inline CEvent::CEvent( LPSECURITY_ATTRIBUTES pAttributes, BOOL bManualReset, BOOL bInitialState, LPCTSTR pszName )
{
	BOOL bSuccess;

	bSuccess = Create( pAttributes, bManualReset, bInitialState, pszName );
	if( !bSuccess )
	{
		AtlThrowLastWin32();
	}
}


inline CEvent::CEvent( HANDLE h ) :
	CHandle( h )
{
}

inline BOOL CEvent::Create( LPSECURITY_ATTRIBUTES pSecurity, BOOL bManualReset, BOOL bInitialState, LPCTSTR pszName )
{
	ATLASSERT( m_h == NULL );

	m_h = ::CreateEvent( pSecurity, bManualReset, bInitialState, pszName );

	return( m_h != NULL );
}

inline BOOL CEvent::Open( DWORD dwAccess, BOOL bInheritHandle, LPCTSTR pszName )
{
	ATLASSERT( m_h == NULL );

	m_h = ::OpenEvent( dwAccess, bInheritHandle, pszName );
	return( m_h != NULL );
}

inline BOOL CEvent::Pulse()
{
	ATLASSERT( m_h != NULL );

	return( ::PulseEvent( m_h ) );
}

inline BOOL CEvent::Reset()
{
	ATLASSERT( m_h != NULL );

	return( ::ResetEvent( m_h ) );
}

inline BOOL CEvent::Set()
{
	ATLASSERT( m_h != NULL );

	return( ::SetEvent( m_h ) );
}


inline CMutex::CMutex()
{
}

inline CMutex::CMutex( CMutex& hMutex ) :
	CHandle( hMutex )
{
}

inline CMutex::CMutex( BOOL bInitialOwner )
{
	BOOL bSuccess;

	bSuccess = Create( NULL, bInitialOwner, NULL );
	if( !bSuccess )
	{
		AtlThrowLastWin32();
	}
}

inline CMutex::CMutex( LPSECURITY_ATTRIBUTES pSecurity, BOOL bInitialOwner, LPCTSTR pszName )
{
	BOOL bSuccess;

	bSuccess = Create( pSecurity, bInitialOwner, pszName );
	if( !bSuccess )
	{
		AtlThrowLastWin32();
	}
}

inline CMutex::CMutex( HANDLE h ) :
	CHandle( h )
{
}

inline BOOL CMutex::Create( LPSECURITY_ATTRIBUTES pSecurity, BOOL bInitialOwner, LPCTSTR pszName )
{
	ATLASSERT( m_h == NULL );

	m_h = ::CreateMutex( pSecurity, bInitialOwner, pszName );
	return( m_h != NULL );
}

inline BOOL CMutex::Open( DWORD dwAccess, BOOL bInheritHandle, LPCTSTR pszName )
{
	ATLASSERT( m_h == NULL );

	m_h = ::OpenMutex( dwAccess, bInheritHandle, pszName );
	return( m_h != NULL );
}

inline BOOL CMutex::Release()
{
	ATLASSERT( m_h != NULL );

	return( ::ReleaseMutex( m_h ) );
}


inline CSemaphore::CSemaphore()
{
}

inline CSemaphore::CSemaphore( CSemaphore& hSemaphore ) :
	CHandle( hSemaphore )
{
}

inline CSemaphore::CSemaphore( LONG nInitialCount, LONG nMaxCount )
{
	BOOL bSuccess;

	bSuccess = Create( NULL, nInitialCount, nMaxCount, NULL );
	if( !bSuccess )
	{
		AtlThrowLastWin32();
	}
}

inline CSemaphore::CSemaphore( LPSECURITY_ATTRIBUTES pSecurity, LONG nInitialCount, LONG nMaxCount, LPCTSTR pszName )
{
	BOOL bSuccess;
	
	bSuccess = Create( pSecurity, nInitialCount, nMaxCount, pszName );
	if( !bSuccess )
	{
		AtlThrowLastWin32();
	}
}


inline CSemaphore::CSemaphore( HANDLE h ) :
	CHandle( h )
{
}

inline BOOL CSemaphore::Create( LPSECURITY_ATTRIBUTES pSecurity, LONG nInitialCount, LONG nMaxCount, LPCTSTR pszName )
{
	ATLASSERT( m_h == NULL );

	m_h = ::CreateSemaphore( pSecurity, nInitialCount, nMaxCount, pszName );
	return( m_h != NULL );
}

inline BOOL CSemaphore::Open( DWORD dwAccess, BOOL bInheritHandle, LPCTSTR pszName )
{
	ATLASSERT( m_h == NULL );

	m_h = ::OpenSemaphore( dwAccess, bInheritHandle, pszName );
	return( m_h != NULL );
}

inline BOOL CSemaphore::Release( LONG nReleaseCount, LONG* pnOldCount )
{
	ATLASSERT( m_h != NULL );

	return( ::ReleaseSemaphore( m_h, nReleaseCount, pnOldCount ) );
}


inline CMutexLock::CMutexLock( CMutex& mtx, bool bInitialLock ) :
	m_mtx( mtx ),
	m_bLocked( false )
{
	if( bInitialLock )
	{
		Lock();
	}
}

inline CMutexLock::~CMutexLock()
{
	if( m_bLocked )
	{
		Unlock();
	}
}

inline void CMutexLock::Lock()
{
	DWORD dwResult;

	ATLASSERT( !m_bLocked );
	dwResult = ::WaitForSingleObject( m_mtx, INFINITE );
	if( dwResult == WAIT_ABANDONED )
	{
		ATLTRACE(atlTraceSync, 0, _T("Warning: abandoned mutex 0x%x\n"), (HANDLE)m_mtx);
	}
	m_bLocked = true;
}

inline void CMutexLock::Unlock()
{
	ATLASSERT( m_bLocked );

	m_mtx.Release();
}

};  // namespace ATL

#endif  // __ATLSYNC_INL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atlmfc\atlstencil.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLSTENCIL_H__
#define __ATLSTENCIL_H__

#pragma once

#ifdef _ATL_MIN_CRT
#error "_ATL_MIN_CRT cannot be used with atlstencil.h"
#endif

#include <atlisapi.h>
#include <atlfile.h>
#include <atlutil.h>

#ifndef ATL_NO_MLANG
#include <mlang.h>
#endif

#ifndef _ATL_NO_DEFAULT_LIBS
#pragma comment(lib, "shlwapi.lib")
#endif // !_ATL_NO_DEFAULT_LIBS

#pragma warning( push )
#pragma warning( disable: 4127 )
#pragma warning(disable: 4511) // copy constructor could not be generated
#pragma warning(disable: 4512) // assignment operator could not be generated
#pragma warning(disable: 4702) // assignment operator could not be generated

namespace ATL {

// Token types
// These tags are token tags for the standard tag replacer implementation
extern __declspec(selectany) const DWORD STENCIL_TEXTTAG             = 0x00000000;
extern __declspec(selectany) const DWORD STENCIL_REPLACEMENT         = 0x00000001;
extern __declspec(selectany) const DWORD STENCIL_ITERATORSTART       = 0x00000002;
extern __declspec(selectany) const DWORD STENCIL_ITERATOREND         = 0x00000003;
extern __declspec(selectany) const DWORD STENCIL_CONDITIONALSTART    = 0x00000004;
extern __declspec(selectany) const DWORD STENCIL_CONDITIONALELSE     = 0x00000005;
extern __declspec(selectany) const DWORD STENCIL_CONDITIONALEND      = 0x00000006;
extern __declspec(selectany) const DWORD STENCIL_STENCILINCLUDE      = 0x00000007;
extern __declspec(selectany) const DWORD STENCIL_STATICINCLUDE       = 0x00000008;
extern __declspec(selectany) const DWORD STENCIL_LOCALE              = 0x00000009;
extern __declspec(selectany) const DWORD STENCIL_CODEPAGE            = 0x0000000a;

// The base for user defined token types
extern __declspec(selectany) const DWORD STENCIL_USER_TOKEN_BASE     = 0x00001000;
   
// Symbols to use in error handling in the stencil processor
#define STENCIL_INVALIDINDEX            0xFFFFFFFF
#define STENCIL_INVALIDOFFSET           0xFFFFFFFF

// error codes
#define STENCIL_SUCCESS     HTTP_SUCCESS
#define STENCL_FAIL         HTTP_FAIL

#define STENCIL_BASIC_MAP 0
#define STENCIL_ATTR_MAP 1

#ifndef ATL_MAX_METHOD_NAME_LEN
    #define ATL_MAX_METHOD_NAME_LEN 64
#endif

#ifndef ATL_MAX_BLOCK_STACK
    #define ATL_MAX_BLOCK_STACK 128
#endif

template <class TBase, typename T>
struct CTagReplacerMethodsEx
{
    typedef HTTP_CODE (TBase::*REPLACE_FUNC)();
    typedef HTTP_CODE (TBase::*REPLACE_FUNC_EX)(T*);
    typedef HTTP_CODE (TBase::*PARSE_FUNC)(IAtlMemMgr *, LPCSTR, T**);
    typedef HTTP_CODE (TBase::*REPLACE_FUNC_EX_V)(void *);
    typedef HTTP_CODE (TBase::*PARSE_FUNC_V)(IAtlMemMgr *, LPCSTR, void**);

    static REPLACE_FUNC_EX_V CheckRepl(REPLACE_FUNC p) throw()
    {
        return (REPLACE_FUNC_EX_V) p;
    }

    static REPLACE_FUNC_EX_V CheckReplEx(REPLACE_FUNC_EX p) throw()
    {
        return (REPLACE_FUNC_EX_V) p;
    }

    static PARSE_FUNC_V CheckParse(PARSE_FUNC p) throw()
    {
        return (PARSE_FUNC_V) p;
    }
};

template <class TBase>
struct CTagReplacerMethods
{
    union
    {
    HTTP_CODE (TBase::*pfnMethodEx)(void *);
    HTTP_CODE (TBase::*pfnMethod)();
    };
    HTTP_CODE (TBase::*pfnParse)(IAtlMemMgr *pMemMgr, LPCSTR, void **);
};

#define REPLACEMENT_ENTRY_DEFAULT   0
#define REPLACEMENT_ENTRY_ARGS      1

template <class TBase>
struct CTagReplacerMethodEntry
{
    int nType;  // REPLACEMENT_ENTRY_*
    LPCSTR szMethodName;
    CTagReplacerMethods<TBase> Methods;
};


#define BEGIN_REPLACEMENT_METHOD_MAP(className)\
public:\
    void GetReplacementMethodMap(const ATL::CTagReplacerMethodEntry<className> ** ppOut) const throw()\
    {\
        typedef className __className;\
        static const ATL::CTagReplacerMethodEntry<className> methods[] = {

#define REPLACEMENT_METHOD_ENTRY(methodName, methodFunc)\
    { 0, methodName,  {  ATL::CTagReplacerMethodsEx<__className, void>::CheckRepl(methodFunc), NULL }   },

#define REPLACEMENT_METHOD_ENTRY_EX(methodName, methodFunc, paramType, parseFunc)\
    { 1, methodName,  { ATL::CTagReplacerMethodsEx<__className, paramType>::CheckReplEx(methodFunc), ATL::CTagReplacerMethodsEx<__className, paramType>::CheckParse(parseFunc) } },

#define REPLACEMENT_METHOD_ENTRY_EX_STR(methodName, methodFunc) \
    { 1, methodName,  { ATL::CTagReplacerMethodsEx<__className, char>::CheckReplEx(methodFunc), ATL::CTagReplacerMethodsEx<__className, char>::CheckParse(DefaultParseString) } },

#define END_REPLACEMENT_METHOD_MAP()\
        { 0, NULL, NULL } };\
        *ppOut = methods;\
    }

#define BEGIN_ATTR_REPLACEMENT_METHOD_MAP(className)\
public:\
    void GetAttrReplacementMethodMap(const CTagReplacerMethodEntry<className> ** ppOut) const throw()\
    {\
        typedef className __className;\
        static const ATL::CTagReplacerMethodEntry<className> methods[] = {

#define END_ATTR_REPLACEMENT_METHOD_MAP()\
        { NULL, NULL, NULL } };\
        *ppOut = methods;\
    }

template <class T>
class ITagReplacerImpl : public ITagReplacer
{
protected:
    IWriteStream *m_pStream;

public:
    typedef HTTP_CODE (T::*REPLACEMENT_METHOD)();
    typedef HTTP_CODE (T::*REPLACEMENT_METHOD_EX)(void *pvParam);

    ITagReplacerImpl() throw()
        :m_pStream(NULL)
    {
    }

    IWriteStream *SetStream(IWriteStream *pStream) throw()
    {
        IWriteStream *pRetStream = m_pStream;
        m_pStream = pStream;
        return pRetStream;
    }

    // Looks up the replacement method offset. Optionally, it will 
    // look up the replacement method and object offset of an alternate
    // tag replacer.
    HTTP_CODE FindReplacementOffset(
        LPCSTR szMethodName,
        DWORD *pdwMethodOffset,
        LPCSTR szHandlerName,
        DWORD *pdwHandlerOffset,
        DWORD *pdwMap, void **ppvParam, IAtlMemMgr *pMemMgr) throw(...)
    {
        // we at least have to be looking up a method offset
        if (!pdwMethodOffset || !szMethodName)
            return HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);

        *pdwMethodOffset = STENCIL_INVALIDOFFSET;
        HTTP_CODE hcErr = HTTP_FAIL;
        T *pT = static_cast<T *>(this);

        char szName[ATL_MAX_METHOD_NAME_LEN];

        // if a handler name was supplied, we will try to
        // find a different object to handle the method
        if (szHandlerName && *szHandlerName)
        {
            if (!pdwHandlerOffset)
                return HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);

            hcErr = pT->GetHandlerOffset(szHandlerName, pdwHandlerOffset);
            // got the alternate handler, now look up the method offset on 
            // the handler.
            if (!hcErr)
            {
                CComPtr<ITagReplacer> spAltTagReplacer;
                hcErr = pT->GetReplacementObject(*pdwHandlerOffset, &spAltTagReplacer);
                if (!hcErr)
                    hcErr = spAltTagReplacer->FindReplacementOffset(szMethodName, pdwMethodOffset,
                        NULL, NULL, pdwMap, ppvParam, pMemMgr);
                return hcErr;
            }
            else
                return hcErr;
        }
        strcpy(szName, szMethodName);

        // check for params
        char *szLeftPar = strchr(szName, '(');
        if (szLeftPar)
        {
            *szLeftPar = '\0';
            szLeftPar++;

            char *szRightPar = strchr(szLeftPar, ')');
            if (!szRightPar)
                return HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);

            *szRightPar = '\0';

            szMethodName = szName;

        }

        // No handler name is specified, so we look up the method name in
        // T's replacement method map
        const CTagReplacerMethodEntry<T> *pEntry;
        pT->GetReplacementMethodMap(&pEntry);

        hcErr = FindReplacementOffsetInMap(szMethodName, pdwMethodOffset, pEntry);
        if (hcErr != HTTP_SUCCESS)
        {
            pT->GetAttrReplacementMethodMap(&pEntry);
            hcErr = FindReplacementOffsetInMap(szMethodName, pdwMethodOffset, pEntry);
            if (hcErr == HTTP_SUCCESS)
                *pdwMap = STENCIL_ATTR_MAP;
        }
        else
        {
            *pdwMap = STENCIL_BASIC_MAP;
        }

        // This assert will be triggered if arguments are passed to a replacement method that doesn't handle them
        ATLASSERT( szLeftPar == NULL || (szLeftPar != NULL && (pEntry != NULL && pEntry[*pdwMethodOffset].Methods.pfnParse) != NULL) );

        if (hcErr == HTTP_SUCCESS && pEntry && pEntry[*pdwMethodOffset].Methods.pfnParse)
            hcErr = (pT->*pEntry[*pdwMethodOffset].Methods.pfnParse)(pMemMgr, szLeftPar, ppvParam);
        return hcErr;

    }

    HTTP_CODE FindReplacementOffsetInMap(
        LPCSTR szMethodName,
        LPDWORD pdwMethodOffset,
        const CTagReplacerMethodEntry<T> *pEntry) throw()
    {
        if (pEntry == NULL)
            return HTTP_FAIL;

        const CTagReplacerMethodEntry<T> *pEntryHead = pEntry;

        while (pEntry->szMethodName)
        {
            if (strcmp(pEntry->szMethodName, szMethodName) == 0)
            {
                if (pEntry->Methods.pfnMethod)
                {
                    *pdwMethodOffset = (DWORD)(pEntry-pEntryHead);
                    return HTTP_SUCCESS;
                }
            }
            pEntry++;
        }

        return HTTP_FAIL;
    }


    // Used to render a single replacement tag into a stream.
    // Looks up a pointer to a member function in user code by offseting into the users
    // replacement map. Much faster than the other overload of this function since
    // no string compares are performed.
    HTTP_CODE RenderReplacement(DWORD dwFnOffset, DWORD dwObjOffset, DWORD dwMap, void *pvParam) throw(...)
    {
        HTTP_CODE hcErr = HTTP_FAIL;
        T *pT = static_cast<T *>(this);

        // if we were not passed an object offset, then we assume
        // that the function at dwFnOffset is in T's replacement
        // map
        if (dwObjOffset == STENCIL_INVALIDOFFSET)
        {
            // call a function in T's replacement map
            ATLASSERT(dwFnOffset != STENCIL_INVALIDOFFSET);
            const CTagReplacerMethodEntry<T> *pEntry;
            if (dwMap == STENCIL_BASIC_MAP)
                pT->GetReplacementMethodMap(&pEntry);
            else
                pT->GetAttrReplacementMethodMap(&pEntry);
            if (pEntry)
            {
                if (pEntry[dwFnOffset].nType == REPLACEMENT_ENTRY_DEFAULT)
                {
                    REPLACEMENT_METHOD pfn = NULL;
                    pfn = pEntry[dwFnOffset].Methods.pfnMethod;
                    ATLASSERT(pfn);
                    if (pfn)
                    {
                        hcErr = (pT->*pfn)();
                    }
                }
                else if (pEntry[dwFnOffset].nType == REPLACEMENT_ENTRY_ARGS)
                {
                    REPLACEMENT_METHOD_EX pfn = NULL;
                    pfn = pEntry[dwFnOffset].Methods.pfnMethodEx;
                    ATLASSERT(pfn);
                    if (pfn)
                    {
                        hcErr = (pT->*pfn)(pvParam);
                    }
                }
                else
                {
                    // unknown entry type
                    ATLASSERT(FALSE);
                }
            }
        }
        else
        {
            // otherwise, we were passed an object offset. The object
            // offset is a dword ID that T can use to look up the
            // ITagReplacer* of a tag replacer that will render this
            // replacement.
            CComPtr<ITagReplacer> spAltReplacer = NULL;
            if (!pT->GetReplacementObject(dwObjOffset, &spAltReplacer))
            {
                spAltReplacer->SetStream(m_pStream);
                hcErr = spAltReplacer->RenderReplacement(dwFnOffset, STENCIL_INVALIDOFFSET, dwMap, pvParam);
            }
        }
        return hcErr;
    }

    // Default GetHandlerOffset, does nothing
    HTTP_CODE GetHandlerOffset(LPCSTR /*szHandlerName*/, DWORD* pdwOffset) throw()
    {
        if (pdwOffset)
            *pdwOffset = 0;
        return HTTP_FAIL;
    }

    // Default GetReplacementObject, does nothing
    HTTP_CODE GetReplacementObject(DWORD /*dwObjOffset*/, ITagReplacer **ppReplacer) throw()
    {
        if (ppReplacer)
            *ppReplacer = NULL;
        return HTTP_FAIL;
    }

    void GetReplacementMethodMap(const CTagReplacerMethodEntry<T> ** ppOut) const throw()
    {
        static const CTagReplacerMethodEntry<T> methods[] = { { NULL, NULL } };
        *ppOut = methods;
    }

    void GetAttrReplacementMethodMap(const CTagReplacerMethodEntry<T> **ppOut) const throw()
    {
        static const CTagReplacerMethodEntry<T> methods[] = { { NULL, NULL } };
        *ppOut = methods;
    }

    HRESULT GetContext(REFIID, void**) throw()
    {
        return E_NOINTERFACE;
    }

    HTTP_CODE FreeParam(void * /*pvParam*/) throw()
    {
        return HTTP_SUCCESS;
    }

    HTTP_CODE DefaultParseString(IAtlMemMgr *pMemMgr, LPCSTR szParams, char **ppParam) throw(...)
    {
        ATLASSERT(szParams);

        size_t nLen = strlen(szParams);
        if (nLen)
        {
            nLen++;
            *ppParam = (char *) pMemMgr->Allocate(nLen);
            if (*ppParam)
                memcpy(*ppParam, szParams, nLen);
            else
                return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM);
        }

        return HTTP_SUCCESS;
    }

    HTTP_CODE DefaultParseUChar(IAtlMemMgr *pMemMgr, LPCSTR szParams, unsigned char **ppParam) throw(...)
    {
        ATLASSERT(szParams);

        *ppParam = (unsigned char *) pMemMgr->Allocate(sizeof(unsigned char));
        if (*ppParam)
        {
            char *szEnd;
            **ppParam = (unsigned char) strtoul(szParams, &szEnd, 10);
        }
        else
        {
            return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM);
        }
        return HTTP_SUCCESS;
    }

    HTTP_CODE DefaultParseShort(IAtlMemMgr *pMemMgr, LPCSTR szParams, short **ppParam) throw(...)
    {
        ATLASSERT(szParams);

        *ppParam = (short *) pMemMgr->Allocate(sizeof(short));
        if (*ppParam)
        {
            **ppParam = (short)atoi(szParams);
        }
        else
        {
            return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM);
        }
        return HTTP_SUCCESS;
    }

    HTTP_CODE DefaultParseUShort(IAtlMemMgr *pMemMgr, LPCSTR szParams, unsigned short **ppParam) throw(...)
    {
        ATLASSERT(szParams);

        *ppParam = (unsigned short *) pMemMgr->Allocate(sizeof(short));
        if (*ppParam)
        {
            char *szEnd;
            **ppParam = (unsigned short) strtoul(szParams, &szEnd, 10);
        }
        else
        {
            return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM);
        }
        return HTTP_SUCCESS;
    }

    HTTP_CODE DefaultParseInt(IAtlMemMgr *pMemMgr, LPCSTR szParams, int **ppParam) throw(...)
    {
        ATLASSERT(szParams);

        *ppParam = (int *) pMemMgr->Allocate(sizeof(int));
        if (*ppParam)
        {
            **ppParam = atoi(szParams);
        }
        else
        {
            return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM);
        }
        return HTTP_SUCCESS;
    }

    HTTP_CODE DefaultParseUInt(IAtlMemMgr *pMemMgr, LPCSTR szParams, unsigned int **ppParam) throw(...)
    {
        ATLASSERT(szParams);

        *ppParam = (unsigned int *) pMemMgr->Allocate(sizeof(unsigned int));
        if (*ppParam)
        {
            char *szEnd;
            **ppParam = strtoul(szParams, &szEnd, 10);
        }
        else
        {
            return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM);
        }
        return HTTP_SUCCESS;
    }

    HTTP_CODE DefaultParseInt64(IAtlMemMgr *pMemMgr, LPCSTR szParams, __int64 **ppParam) throw(...)
    {
        ATLASSERT(szParams);

        *ppParam = (__int64 *) pMemMgr->Allocate(sizeof(__int64));
        if (*ppParam)
        {
            **ppParam = _atoi64(szParams);
        }
        else
        {
            return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM);
        }
        return HTTP_SUCCESS;
    }

    HTTP_CODE DefaultParseUInt64(IAtlMemMgr *pMemMgr, LPCSTR szParams, unsigned __int64 **ppParam) throw(...)
    {
        ATLASSERT(szParams);

        *ppParam = (unsigned __int64 *) pMemMgr->Allocate(sizeof(unsigned __int64));
        if (*ppParam)
        {
            char *szEnd;
            **ppParam = _strtoui64(szParams, &szEnd, 10);
        }
        else
        {
            return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM);
        }
        return HTTP_SUCCESS;
    }

    HTTP_CODE DefaultParseBool(IAtlMemMgr *pMemMgr, LPCSTR szParams, bool **ppParam) throw(...)
    {
        ATLASSERT(szParams);
        
        *ppParam = (bool *) pMemMgr->Allocate(sizeof(bool));
        if (*ppParam)
        {
            if (!_strnicmp(szParams, "true", sizeof("true")-sizeof('\0')))
                **ppParam = true;
            else
                **ppParam = false;
        }
        else
        {
            return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM);
        }

        return HTTP_SUCCESS;
    }

    HTTP_CODE DefaultParseDouble(IAtlMemMgr *pMemMgr, LPCSTR szParams, double **ppParam) throw(...)
    {
        ATLASSERT(szParams);

        *ppParam = (double *) pMemMgr->Allocate(sizeof(double));
        if (*ppParam)
        {
            **ppParam = atof(szParams);
        }
        else
        {
            return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM);
        }
        return HTTP_SUCCESS;
    }

    HTTP_CODE DefaultParseFloat(IAtlMemMgr *pMemMgr, LPCSTR szParams, float **ppParam) throw(...)
    {
        ATLASSERT(szParams);

        *ppParam = (float *) pMemMgr->Allocate(sizeof(float));
        if (*ppParam)
        {
            **ppParam = (float) atof(szParams);
        }
        else
        {
            return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM);
        }
        return HTTP_SUCCESS;
    }
};

inline LPSTR SkipSpace(LPSTR sz, WORD nCodePage)
{
    while (_istspace(*sz))
        sz = CharNextExA(nCodePage, sz, 0);
    return sz;
}

inline LPSTR RSkipSpace(LPSTR pStart, LPSTR sz, WORD nCodePage) throw()
{
    while (_istspace(*sz))
        sz = CharPrevExA(nCodePage, pStart, sz, 0);
    return sz;
}

//
// StencilToken
// The stencil class will create an array of these tokens during the parse
// phase and use them during rendering to render the stencil
struct StencilToken
{
    LPSTR pStart; // Start of fragment to be rendered
    LPSTR pEnd; // End of fragment to be rendered
    DWORD type; // Type of token
    DWORD dwFnOffset; // Offset into the replacement map for the handler function.
    DWORD dwMap;
    DWORD dwObjOffset; // An identifier for the caller to use in identifiying the
                       // object that will render this token.
    CHAR szHandlerName[ATL_MAX_HANDLER_NAME_LEN + 1]; // Name of handler object. 
    CHAR szMethodName[ATL_MAX_METHOD_NAME_LEN + 1]; // Name of handler method.
    DWORD dwLoopIndex; // Offset into array of StencilTokens of the other loop tag
	DWORD_PTR dwData;
    BOOL bDynamicAlloc;
};


// Specialization of CElementTraitsBase so you can put a StencilToken safely in
// a collection object.
template<>
class CElementTraits< StencilToken > :
    public CElementTraitsBase< StencilToken >
{
public:
	static ULONG Hash( INARGTYPE t ) throw()
    {
        return( ULONG( ULONG_PTR( &t ) ) );
    }

    static bool CompareElements( INARGTYPE element1, INARGTYPE element2 ) throw()
    {
        return( (element1.pStart == element2.pStart) && (element1.pEnd == element2.pEnd) );
    }

    static int CompareElementsOrdered( INARGTYPE element1, INARGTYPE element2 ) throw()
    {
        if( element1.pStart < element2.pStart )
        {
            return( -1 );
        }
        else if( CompareElements(element1,element2) )
        {
            return( 0 );
        }
        else
        {
            ATLASSERT( element1.pStart > element2.pStart );
            return( 1 );
        }
    }
};

//
// Class CStencil
// The CStencil class is used to map in a stencil from a file or resource
// and parse the stencil into an array of StencilTokens. We then render
// the stencil from the array of tokens. This class's parse and render
// functions depend on an IReplacementHandlerLookup interface pointer to be
// passed so it can retrieve the IReplacementHandler interface pointer of the
// handler object that will be called to render replacement tags
class CStencil :
    public IMemoryCacheClient
{
private:
    LPSTR m_pBufferStart; // Beginning of CHAR buffer that holds the stencil.
                          // For mapped files this is the beginning of the mapping.
    LPSTR m_pBufferEnd; // End of CHAR buffer that holds the stencil.
    CAtlArray<StencilToken> m_arrTokens; //An array of tokens.
    FILETIME m_ftLastModified;  // Last modified time (0 for resource)
    FILETIME m_ftLastChecked;   // Last time we retrieved last modified time (0 for resource)
    HCACHEITEM m_hCacheItem;
    WORD m_nCodePage;
    BOOL m_bUseLocaleACP;
    char m_szDllPath[MAX_PATH+1];
    char m_szHandlerName[ATL_MAX_HANDLER_NAME_LEN+1];  // Room for the path, the handler
                                                                  // the '/' and the '\0'
#ifdef ATL_DEBUG_STENCILS
    struct ParseError
    {
        char m_szError[256];
        LPCSTR m_szPosition;
        LPCSTR m_szStartLine;
        LPCSTR m_szEndLine;
        int m_nLineNumber;

        bool operator==(const ParseError& that) const throw()
        {
            return (m_nLineNumber == that.m_nLineNumber);
        }
    };

    CSimpleArray<ParseError> m_Errors;

	class CParseErrorProvider : public ITagReplacerImpl<CParseErrorProvider>,
        public CComObjectRootEx<CComSingleThreadModel>           
    {
    public:
        BEGIN_COM_MAP(CParseErrorProvider)
            COM_INTERFACE_ENTRY(ITagReplacer)
        END_COM_MAP()
        CSimpleArray<ParseError> *m_pErrors;
        int m_nCurrentError;

        CParseErrorProvider() throw() :
            m_pErrors(NULL),
            m_nCurrentError(-1)
        {
        }

        void Initialize(CSimpleArray<ParseError> *pErrors) throw()
        {
            m_pErrors = pErrors;
        }

        HTTP_CODE OnGetNextError() throw()
        {
            m_nCurrentError++;
            if (m_nCurrentError >= m_pErrors->GetSize() ||
                m_nCurrentError < 0 )
            {
                m_nCurrentError = -1;
                return HTTP_S_FALSE;
            }
            else
                return HTTP_SUCCESS;
        }

        HTTP_CODE OnGetErrorLineNumber() throw(...)
        {
            if (m_pErrors->GetSize() == 0)
                return HTTP_SUCCESS;
            if (m_nCurrentError > m_pErrors->GetSize() ||
                m_nCurrentError < 0)
                m_nCurrentError = 0;

            CWriteStreamHelper c(m_pStream);
            if (!c.Write((*m_pErrors)[m_nCurrentError].m_nLineNumber))
				return HTTP_FAIL;

            return HTTP_SUCCESS;
        }

        HTTP_CODE OnGetErrorText() throw(...)
        {
            if (m_pErrors->GetSize() == 0)
                return HTTP_SUCCESS;
            if (m_nCurrentError > m_pErrors->GetSize() ||
                m_nCurrentError < 0)
                m_nCurrentError = 0;

            CWriteStreamHelper c(m_pStream);

            if (!c.Write((*m_pErrors)[m_nCurrentError].m_szError))
				return HTTP_FAIL;

            return HTTP_SUCCESS;
        }

        HTTP_CODE OnGetErrorLine() throw(...)
        {
            if (m_pErrors->GetSize() == 0)
                return HTTP_SUCCESS;
            if (m_nCurrentError > m_pErrors->GetSize() ||
                m_nCurrentError < 0)
                m_nCurrentError = 0;

            m_pStream->WriteStream((*m_pErrors)[m_nCurrentError].m_szStartLine, 
                (int)((*m_pErrors)[m_nCurrentError].m_szEndLine - (*m_pErrors)[m_nCurrentError].m_szStartLine), NULL);

            return HTTP_SUCCESS;
        }

        BEGIN_REPLACEMENT_METHOD_MAP(CParseErrorProvider)
            REPLACEMENT_METHOD_ENTRY("GetNextError", OnGetNextError)
            REPLACEMENT_METHOD_ENTRY("GetErrorText", OnGetErrorText)
            REPLACEMENT_METHOD_ENTRY("GetErrorLine", OnGetErrorLine)
            REPLACEMENT_METHOD_ENTRY("GetErrorLineNumber", OnGetErrorLineNumber)
        END_REPLACEMENT_METHOD_MAP()
    };

#else
	bool m_bErrorsOccurred;
#endif

    class CSaveThreadLocale
    {
        LCID m_locale;
    public:
        CSaveThreadLocale() throw()
        {
            m_locale = GetThreadLocale();
        }
        ~CSaveThreadLocale() throw()
        {
            SetThreadLocale(m_locale);
        }
    };

protected:
    ITagReplacer *m_pReplacer;
    IAtlMemMgr *m_pMemMgr;
    static CCRTHeap m_crtHeap;

public:

    enum PARSE_TOKEN_RESULT { INVALID_TOKEN, NORMAL_TOKEN, RESERVED_TOKEN };

    CStencil(IAtlMemMgr *pMemMgr=NULL) throw()
    {
        m_pBufferStart = NULL;
        m_pBufferEnd = NULL;
        m_hCacheItem = NULL;
        m_ftLastModified.dwLowDateTime = 0;
        m_ftLastModified.dwHighDateTime = 0;
        m_ftLastChecked.dwLowDateTime = 0;
        m_ftLastChecked.dwHighDateTime = 0;
        m_arrTokens.SetCount(0, 128);
        m_nCodePage = CP_ACP;
        m_bUseLocaleACP = TRUE;
        m_szHandlerName[0] = '\0';
        m_szDllPath[0] = '\0';
        m_pMemMgr = pMemMgr;
        if (!pMemMgr)
            m_pMemMgr = &m_crtHeap;
#ifdef ATL_DEBUG_STENCILS
//        m_pErrorStencil = NULL;
#else
        m_bErrorsOccurred = false;
#endif

    }

#ifdef ATL_DEBUG_STENCILS

	virtual LPCSTR GetErrorStencil() throw()
	{
		static LPCSTR s_szString = 
			"<h1><font color=#ff0000> While trying to parse a stencil file, "
			"the following errors occurred:</font></h1>\r\n"
			"{{while GetNextError}}"
			"<table border=1 width=50%>\r\n"
			"<tr><td width=25%>Error type</td><td>{{GetErrorText}}</td></tr>\r\n"
			"<tr><td>Line number</td><td>{{GetErrorLineNumber}}</td></tr>\r\n"
			"<tr><td>Error text</td><td><pre>{{GetErrorLine}}</pre></td></tr>\r\n"
			"</table>\r\n"
			"{{endwhile}}"
			"<br>Stencil output follows:\r\n"
			"<hr>";

		return s_szString;
	}

    bool RenderErrors(IWriteStream *pStream) throw(...)
    {
        if (!pStream)
            return false;

		LPCSTR szString = GetErrorStencil();
		if (szString == NULL)
		{
			// assume user doesn't want errors rendered
			return true;
		}

        CComObjectStackEx<CParseErrorProvider> Errors;

        Errors.Initialize(&m_Errors);
		CStencil ErrorStencil;

		HTTP_CODE hcRet = ErrorStencil.LoadFromString(szString, (DWORD)strlen(szString));
        
		if (hcRet != HTTP_SUCCESS)
        {
            return false;
        }

        if (!ErrorStencil.ParseReplacements(static_cast<ITagReplacer *>(&Errors)))
        {
            return false;
        }

        ErrorStencil.FinishParseReplacements();

        HTTP_CODE hcErrorCode = ErrorStencil.Render(static_cast<ITagReplacer *>(&Errors), pStream);
        
        if (HTTP_ERROR_CODE(hcErrorCode) >= 400)
            return false;

        return true;
    }

    bool ParseSuccessful() throw()
    {
        return (m_Errors.GetSize() == 0);
    }

    bool AddError(LPCSTR szErrorText, LPCSTR szPosition) throw()
    {
        int nLineNum = 0;
        LPCSTR szStartLine = NULL;
        LPCSTR szPtr = m_pBufferStart;
        while (szPtr < szPosition)
        {
            if (*szPtr == '\n')
            {
                szStartLine = szPtr + 1;
                nLineNum++;
            }

            LPSTR szNext = CharNextExA(m_nCodePage, szPtr, 0);
            if (szNext == szPtr)
            {
                break;
            }
            szPtr = szNext;
        }
        LPCSTR szEndLine = szPtr;
        while (*szPtr)
        {
            if (*szPtr == '\n')
                break;
            szEndLine = szPtr;
            LPSTR szNext = CharNextExA(m_nCodePage, szPtr, 0);
            if (szNext == szPtr)
            {
                break;
            }
            szPtr = szNext;
        }

        ParseError p;
        strcpy(p.m_szError, szErrorText);
        p.m_szPosition = szPosition;
        p.m_nLineNumber = nLineNum;
        p.m_szStartLine = szStartLine;
        p.m_szEndLine = szEndLine;

        return (m_Errors.Add(p) == TRUE);
    }
#else

    bool ParseSuccessful() throw()
    {
        return m_bErrorsOccurred;
    }

    void AddError(LPCSTR /*szErrorText*/, LPCSTR /*szPosition*/) throw()
    {
        m_bErrorsOccurred = true;
    }
#endif

    // Call Uninitialize if you want to re-use an already initialized CStencil
    void Uninitialize() throw(...)
    {
        int nSize = (int) m_arrTokens.GetCount();
        for (int nIndex = 0; nIndex < nSize; nIndex++)
        {
            if (m_arrTokens[nIndex].bDynamicAlloc)
                delete [] m_arrTokens[nIndex].pStart;
            if (m_arrTokens[nIndex].dwData != 0 && m_arrTokens[nIndex].type != STENCIL_LOCALE)
                m_pMemMgr->Free((void *) m_arrTokens[nIndex].dwData);
        }

        m_arrTokens.RemoveAll();
        if ((m_ftLastModified.dwLowDateTime || m_ftLastModified.dwHighDateTime) && m_pBufferStart)
            delete [] m_pBufferStart;
        m_pBufferStart = NULL;
        m_pBufferEnd = NULL;
    }

    void GetLastModified(FILETIME *pftLastModified) throw()
    {
        ATLASSERT(pftLastModified);
        *pftLastModified = m_ftLastModified;
    }

    void GetLastChecked(FILETIME *pftLastChecked) throw()
    {
        ATLASSERT(pftLastChecked);
        *pftLastChecked = m_ftLastChecked;
    }

    void SetLastChecked(FILETIME *pftLastChecked) throw()
    {
        ATLASSERT(pftLastChecked);
        m_ftLastChecked = *pftLastChecked;
    }

    HCACHEITEM GetCacheItem() throw()
    {
        return m_hCacheItem;
    }

    void SetCacheItem(HCACHEITEM hCacheItem) throw()
    {
        ATLASSERT(m_hCacheItem == NULL);
        m_hCacheItem = hCacheItem;
    }

    void GetHandlerName(LPSTR szDllPath, LPSTR szHandlerName) throw()
    {
        strcpy(szDllPath, m_szDllPath);
        strcpy(szHandlerName, m_szHandlerName);
    }

    // Adds a token to the token array, handler name, method name
    // and handler function offset are optional
    ATL_NOINLINE DWORD AddToken(
        LPSTR pStart,
        LPSTR pEnd,
        DWORD dwType,
        LPCSTR szHandlerName = NULL,
        LPCSTR szMethodName = NULL,
        DWORD dwFnOffset = STENCIL_INVALIDOFFSET,
        DWORD dwObjOffset = STENCIL_INVALIDOFFSET,
        DWORD_PTR dwData = 0,
        DWORD dwMap = 0,
        BOOL bDynamicAlloc = 0) throw()
    {
        StencilToken t;

        memset(&t, 0x00, sizeof(t));

        t.pStart = pStart;
        t.pEnd = pEnd;
        t.type = dwType;
        t.dwLoopIndex = STENCIL_INVALIDINDEX;
        t.dwFnOffset = dwFnOffset;
        t.dwObjOffset = dwObjOffset;
        t.dwData = dwData;
        t.dwMap = dwMap;
        t.bDynamicAlloc = bDynamicAlloc;

        if (szHandlerName && (sizeof(t.szHandlerName) > strlen(szHandlerName)))
            strcpy(t.szHandlerName, szHandlerName);
        else
            t.szHandlerName[0] = '\0';

        if (szMethodName && (sizeof(t.szMethodName) > strlen(szMethodName)))
            strcpy(t.szMethodName, szMethodName);
        else
            t.szMethodName[0] = '\0';

		_ATLTRY
		{
			return (DWORD) m_arrTokens.Add(t);
		}
		_ATLCATCHALL()
		{
			return STENCIL_INVALIDINDEX;
		}
    }

    // maps a stencil file into memory
    HTTP_CODE LoadFile(LPCSTR szFileName) throw()
    {
        HRESULT hr = E_FAIL;
        ULONGLONG dwLen = 0;
        CAtlFile file;

        hr = file.Create(CA2CTEX<MAX_PATH+1>(szFileName), GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING);
        if (FAILED(hr) || GetFileType(file) != FILE_TYPE_DISK)
            return HTTP_ERROR(500, ISE_SUBERR_STENCIL_LOAD_FAIL); // couldn't load SRF!

        if (GetFileTime(file, NULL, NULL, &m_ftLastModified))
        {
            if (SUCCEEDED(file.GetSize(dwLen)))
            {
                ATLASSERT(!m_pBufferStart);
            
                GetSystemTimeAsFileTime(&m_ftLastChecked);

                m_pBufferStart = NULL;
                ATLTRY(m_pBufferStart = new CHAR[(UINT) dwLen]);
                if (m_pBufferStart == NULL)
                    return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM); // out of memory

                DWORD dwRead;
                hr = file.Read(m_pBufferStart, (DWORD) dwLen, dwRead);
                if (FAILED(hr))
                {
                    delete [] m_pBufferStart;
                    m_pBufferStart = NULL;
                    return HTTP_ERROR(500, ISE_SUBERR_READFILEFAIL); // ReadFile failed
                }

                m_pBufferEnd = m_pBufferStart + dwRead;
            }
        }
        return HTTP_SUCCESS;
    }

    // loads a stencil from the specified resource.
    HTTP_CODE LoadFromResource(HINSTANCE hInstRes, LPCSTR szID, LPCSTR szType = NULL) throw()
    {
        if (!szType)
            szType = (LPCSTR) RT_HTML;

        HRSRC hRsrc = FindResourceA(hInstRes, szID, szType);
        HGLOBAL hgResource = NULL;
        if (hRsrc)
        {
            hgResource = LoadResource(hInstRes, hRsrc);
            if (!hgResource)
                return HTTP_FAIL;
        }
        else
            return HTTP_FAIL;

        DWORD dwSize = SizeofResource(hInstRes, hRsrc);
        m_pBufferStart = (LPSTR)LockResource(hgResource);
        m_pBufferEnd = m_pBufferStart+dwSize;       
        return HTTP_SUCCESS;
    }

    // loads a stencil from the specified resource
    HTTP_CODE LoadFromResource(HINSTANCE hInstRes, UINT nId, LPCSTR szType = NULL) throw()
    {
        return LoadFromResource(hInstRes, MAKEINTRESOURCEA(nId), szType);
    }

    // loads a stencil from a string
    HTTP_CODE LoadFromString(LPCSTR szString, DWORD dwSize) throw()
    {
        m_pBufferStart = (LPSTR) szString;
        m_pBufferEnd = m_pBufferStart+dwSize;
        return HTTP_SUCCESS;
    }

    inline BOOL CheckTag(LPCSTR szTag, DWORD dwTagLen, LPSTR szStart, DWORD dwLen) throw()
    {
        if (dwLen < dwTagLen)
            return FALSE;

        if (memcmp(szStart, szTag, dwTagLen))
            return FALSE;

        if (_istspace(szStart[dwTagLen]) || szStart[dwTagLen] == '}')
            return TRUE;

        return FALSE;
    }

    inline void FindTagArgs(LPSTR& szstart, LPSTR& szend, int nKeywordChars) throw()
    {
        if (*szstart == '{')
            szstart += 2; // move past {{
        szstart = SkipSpace(szstart, m_nCodePage); // move past whitespace
        szstart += nKeywordChars; // move past keyword
        szstart = SkipSpace(szstart, m_nCodePage); // move past whitespace after keyword
        if (*szend == '}')
            szend -=2; // chop off }}
        szend = RSkipSpace(szstart, szend, m_nCodePage); // chop of trailing whitespace
    }

    // Cracks the loaded stencil into an array of StencilTokens in preparation for
    // rendering. LoadStencil must be called prior to calling this function.
    virtual bool ParseReplacements(ITagReplacer* pReplacer) throw(...)
    {
        return ParseReplacements(pReplacer, GetBufferStart(), GetBufferEnd());
    }

    virtual void FinishParseReplacements() throw(...)
    {
        DWORD dwSize = (DWORD) m_arrTokens.GetCount();
        for (DWORD dwIndex = 0; dwIndex < dwSize; dwIndex++)
        {
            StencilToken& token = m_arrTokens[dwIndex];
            bool bUnclosedBlock = ((token.type == STENCIL_CONDITIONALSTART || 
									token.type == STENCIL_CONDITIONALELSE ||
                                    token.type == STENCIL_ITERATORSTART) && 
                                    token.dwLoopIndex == STENCIL_INVALIDINDEX);
            if (token.szMethodName[0] && 
                (token.dwFnOffset == STENCIL_INVALIDOFFSET || bUnclosedBlock))
            {
                if (bUnclosedBlock || 
                    m_pReplacer->FindReplacementOffset(
                        token.szMethodName, &token.dwFnOffset, 
                        token.szHandlerName, &token.dwObjOffset, 
                        &token.dwMap, (void **)(&token.dwData), m_pMemMgr) != HTTP_SUCCESS)
                {
                    if (bUnclosedBlock && token.type == STENCIL_CONDITIONALSTART)
                        AddError("{{if}} without {{endif}}", token.pStart);
					else if (bUnclosedBlock && token.type == STENCIL_CONDITIONALELSE)
                        AddError("{{else}} without {{endif}}", token.pStart);
                    else if (bUnclosedBlock && token.type == STENCIL_ITERATORSTART)
                        AddError("{{while}} without {{endwhile}}", token.pStart);
                    else          
                    {
                        char szBuf[ATL_MAX_METHOD_NAME_LEN+sizeof("Unresolved replacement : ''")];
                        _snprintf(szBuf, 
							ATL_MAX_METHOD_NAME_LEN+sizeof("Unresolved replacement : ''")-1,
							"Unresolved replacement : '%s'", token.szMethodName);

                        AddError(szBuf, token.pStart);
                    }

                    // unresolved replacement, convert it to a text token
                    token.type = STENCIL_TEXTTAG;

                    // convert all linked tokens to text tokens as well
                    // this includes: endif, else, endwhile
                    DWORD dwLoopIndex = token.dwLoopIndex;
                    while (dwLoopIndex != dwIndex && dwLoopIndex != STENCIL_INVALIDINDEX)
                    {
                        m_arrTokens[dwLoopIndex].type = STENCIL_TEXTTAG;
                        dwLoopIndex = m_arrTokens[dwLoopIndex].dwLoopIndex;
                    }
                }
            }
        }
    }

	virtual bool Parse(ITagReplacer *pReplacer) throw( ... )
	{
		if (ParseReplacements(pReplacer))
		{
			FinishParseReplacements();
			return true;
		}
		return false;
	}
    
    DWORD CheckTopAndPop(DWORD *pBlockStack, DWORD *pdwTop, DWORD dwToken) throw()
    {
        if (*pdwTop == 0)
            return STENCIL_INVALIDINDEX;
        if (m_arrTokens[pBlockStack[*pdwTop]].type == dwToken)
        {
            *pdwTop = (*pdwTop) - 1;
            return pBlockStack[(*pdwTop)+1];
        }
        return STENCIL_INVALIDINDEX;
    }

    DWORD ParseReplacement( LPSTR szTokenStart, 
							LPSTR szTokenEnd, 
							DWORD * /*pBlockStack*/,
							DWORD * /*pdwTop*/,
							DWORD dwTokenType = STENCIL_REPLACEMENT,
							DWORD dwKeywordLen = 0) throw()
    {
        // hold on to the start and end pointers (before removing curlies and whitespace)
        // this is needed so that we can convert the token to a text token if the method
        // is not resolved (in FinishParseReplacements)
        LPSTR szStart = szTokenStart;
        LPSTR szEnd = szTokenEnd;

        FindTagArgs(szTokenStart, szTokenEnd, dwKeywordLen);

        char szMethodName[ATL_MAX_METHOD_NAME_LEN+1];
        char szHandlerName[ATL_MAX_HANDLER_NAME_LEN+1];

        DWORD dwIndex;
        //look up the handler name, method name and handler interface
        if (HTTP_SUCCESS == GetHandlerAndMethodNames(szTokenStart, szTokenEnd,
                                            szMethodName, 
                                            szHandlerName))
            dwIndex = AddToken(szStart, szEnd, dwTokenType, 
                               szHandlerName, szMethodName, 
                               STENCIL_INVALIDINDEX, STENCIL_INVALIDINDEX, 
                               0, STENCIL_BASIC_MAP);
        else
            dwIndex = STENCIL_INVALIDINDEX;
        return dwIndex;
    }

    DWORD PushToken(DWORD *pBlockStack, DWORD *pdwTop, DWORD dwIndex) throw()
    {
        if (*pdwTop < (ATL_MAX_BLOCK_STACK-1))
        {
            *pdwTop = (*pdwTop) + 1;
            pBlockStack[*pdwTop] = dwIndex;
        }
        else
        {
            dwIndex = STENCIL_INVALIDINDEX;
        }

        return dwIndex;
    }

    DWORD ParseWhile(LPSTR szTokenStart, LPSTR szTokenEnd, DWORD *pBlockStack, DWORD *pdwTop) throw()
    {
        DWORD dwIndex = ParseReplacement(szTokenStart, szTokenEnd, pBlockStack, pdwTop, STENCIL_ITERATORSTART, 5);
        if (dwIndex == STENCIL_INVALIDINDEX)
            return dwIndex;
        return PushToken(pBlockStack, pdwTop, dwIndex);
    }

    DWORD ParseEndWhile(LPSTR szTokenStart, LPSTR szTokenEnd, DWORD *pBlockStack, DWORD *pdwTop) throw()
    {
        DWORD dwTopIndex = CheckTopAndPop(pBlockStack, pdwTop, STENCIL_ITERATORSTART);
        if (dwTopIndex == STENCIL_INVALIDINDEX)
        {
            AddError("{{endwhile}} without {{while}}", szTokenStart);
            return dwTopIndex;
        }

        DWORD dwIndex = AddToken(szTokenStart, szTokenEnd, STENCIL_ITERATOREND);
        m_arrTokens[dwTopIndex].dwLoopIndex = dwIndex;
        m_arrTokens[dwIndex].dwLoopIndex = dwTopIndex;
        return dwIndex;
    }

    DWORD ParseIf(LPSTR szTokenStart, LPSTR szTokenEnd, DWORD *pBlockStack, DWORD *pdwTop) throw()
    {
        DWORD dwIndex = ParseReplacement(szTokenStart, szTokenEnd, pBlockStack, pdwTop, STENCIL_CONDITIONALSTART, 2);
        if (dwIndex == STENCIL_INVALIDINDEX)
            return dwIndex;
        return PushToken(pBlockStack, pdwTop, dwIndex);
    }

    DWORD ParseElse(LPSTR szTokenStart, LPSTR szTokenEnd, DWORD *pBlockStack, DWORD *pdwTop) throw()
    {
        DWORD dwTopIndex = CheckTopAndPop(pBlockStack, pdwTop, STENCIL_CONDITIONALSTART);
        if (dwTopIndex == STENCIL_INVALIDINDEX)
        {
            AddError("{{else}} without {{if}}", szTokenStart);
            return dwTopIndex;
        }

        DWORD dwIndex = AddToken(szTokenStart, szTokenEnd, STENCIL_CONDITIONALELSE);
        m_arrTokens[dwTopIndex].dwLoopIndex = dwIndex;


        return PushToken(pBlockStack, pdwTop, dwIndex);
    }

    DWORD ParseEndIf(LPSTR szTokenStart, LPSTR szTokenEnd, DWORD *pBlockStack, DWORD *pdwTop) throw()
    {
        DWORD dwTopIndex = CheckTopAndPop(pBlockStack, pdwTop, STENCIL_CONDITIONALSTART);
        if (dwTopIndex == STENCIL_INVALIDINDEX)
        {
            dwTopIndex = CheckTopAndPop(pBlockStack, pdwTop, STENCIL_CONDITIONALELSE);
            if (dwTopIndex == STENCIL_INVALIDINDEX)
            {
                AddError("{{endif}} without {{if}}", szTokenStart);
                return dwTopIndex;
            }
        }
        DWORD dwIndex = AddToken(szTokenStart, szTokenEnd, STENCIL_CONDITIONALEND);
        m_arrTokens[dwTopIndex].dwLoopIndex = dwIndex;
        return dwIndex;
    }

    DWORD ParseLocale(LPSTR szTokenStart, LPSTR szTokenEnd, DWORD * /*pBlockStack*/, DWORD * /*pdwTop*/) throw()
    {
        LPSTR szstart = szTokenStart;
        LPSTR szend = szTokenEnd;
        LCID locale = 0xFFFFFFFF;
        FindTagArgs(szstart, szend, 6);
#ifndef ATL_NO_MLANG
        if (isdigit(szstart[0]))
        {
            locale = (LCID) atoi(szstart);
        }
        else
        {
            HRESULT hr;

            CComPtr<IMultiLanguage> pML;
            hr = pML.CoCreateInstance(__uuidof(CMultiLanguage));
            if (FAILED(hr))
            {
                ATLTRACE(atlTraceStencil, 0, _T("Couldn't create CMultiLanguage object. check MLANG installation."));
                AddError("Couldn't create CMultiLanguage", szTokenStart);
            }
            else
            {
                CStringW str(szstart, (int)((szend-szstart)+1));

#ifdef __IMultiLanguage2_INTERFACE_DEFINED__

                // use IMultiLanguage2 if possible
                CComPtr<IMultiLanguage2> spML2;
                hr = pML.QueryInterface(&spML2);
                if (FAILED(hr) || !spML2.p)
                    hr = pML->GetLcidFromRfc1766(&locale, CComBSTR(str));
                else
                    hr = spML2->GetLcidFromRfc1766(&locale, CComBSTR(str));

#else // __IMultiLanguage2_INTERFACE_DEFINED__

                hr = pML->GetLcidFromRfc1766(&locale, CComBSTR(str));

#endif // __IMultiLanguage2_INTERFACE_DEFINED__

                if (FAILED(hr))
                    AddError("Error getting lcid", szTokenStart);
            }
            if (FAILED(hr))
                locale = 0xFFFFFFFF;
        }
#else
        locale = (LCID) atoi(szstart);
#endif

        if (m_bUseLocaleACP)
        {
            TCHAR szACP[7];
            if (GetLocaleInfo(locale, LOCALE_IDEFAULTANSICODEPAGE, szACP, 7) != 0)
            {
                m_nCodePage = (WORD) _ttoi(szACP);
            }
            else
            {
                AddError("GetLocaleInfo failed", szTokenStart);
            }
        }
        DWORD dwCurrentTokenIndex = STENCIL_INVALIDINDEX;
        if (locale != 0xFFFFFFFF)
            dwCurrentTokenIndex = AddToken(NULL, NULL, STENCIL_LOCALE, 
                NULL, NULL, STENCIL_INVALIDOFFSET, STENCIL_INVALIDOFFSET, locale);
        else
            return STENCIL_INVALIDINDEX;
        return dwCurrentTokenIndex;
    }

    DWORD ParseCodepage(LPSTR szTokenStart, LPSTR szTokenEnd, DWORD * /*pBlockStack*/, DWORD * /*pdwTop*/) throw()
    {
        LPSTR szstart = szTokenStart;
        LPSTR szend = szTokenEnd;
        WORD nCodePage = 0xFFFF;

        FindTagArgs(szstart, szend, 8);
#ifndef ATL_NO_MLANG
        if (isdigit(szstart[0]))
        {
            nCodePage = (WORD) atoi(szstart);
        }
        else
        {
            HRESULT hr;

            CComPtr<IMultiLanguage> pML;
            hr = pML.CoCreateInstance(__uuidof(CMultiLanguage));
            if (FAILED(hr))
            {
                ATLTRACE(atlTraceStencil, 0, _T("Couldn't create CMultiLanguage object. check MLANG installation."));
                AddError("Couldn't CoCreate CMultiLanguage object", szTokenStart);
            }
            else
            {
                CStringW str(szstart, (int)((szend-szstart)+1));
                MIMECSETINFO info;

#ifdef __IMultiLanguage2_INTERFACE_DEFINED__

                // use IMultiLanguage2 if possible
                CComPtr<IMultiLanguage2> spML2;
                hr = pML.QueryInterface(&spML2);
                if (FAILED(hr) || !spML2.p)
                    hr = pML->GetCharsetInfo(CComBSTR(str), &info);
                else
                    hr = spML2->GetCharsetInfo(CComBSTR(str), &info);

#else // __IMultiLanguage2_INTERFACE_DEFINED__

                hr = pML->GetCharsetInfo(CComBSTR(str), &info);

#endif // __IMultiLanguage2_INTERFACE_DEFINED__

                // for most character sets, uiCodePage and uiInternetEncoding
                // are the same. UTF-8 is the exception that we're concerned about.
                // for that character set, we want uiInternetEncoding (65001 - UTF-8)
                // instead of uiCodePage (1200 - UCS-2)
                if (SUCCEEDED(hr))
                    nCodePage = (WORD) info.uiInternetEncoding;
                else
                    AddError("GetCharsetInfo failed", szTokenStart);
            }
            if (FAILED(hr))
                nCodePage = 0xFFFF;
        }
#else
        nCodePage = (WORD) atoi(szstart);
#endif
        if (nCodePage != 0xFFFF)
            m_nCodePage = nCodePage;
        m_bUseLocaleACP = FALSE;

        return STENCIL_INVALIDINDEX;
    }

    PARSE_TOKEN_RESULT ParseHandler(LPSTR szTokenStart, LPSTR szTokenEnd, DWORD * /*pBlockStack*/, DWORD * /*pdwTop*/) throw()
    {
        LPSTR szstart = szTokenStart;
        LPSTR szend = szTokenEnd;

        if (m_szHandlerName[0] && m_szDllPath[0])
            return RESERVED_TOKEN; // already found the handler and path dll names

        FindTagArgs(szstart, szend, 7);
        size_t nlen = (szend-szstart)+1;
        char szHandlerDllName[MAX_PATH + ATL_MAX_HANDLER_NAME_LEN + 2];
        if (nlen < MAX_PATH + ATL_MAX_HANDLER_NAME_LEN + 2)
        {
            memcpy(szHandlerDllName, szstart, szend-szstart+1);
            szHandlerDllName[szend-szstart+1] = '\0';

            DWORD dwDllPathLen = MAX_PATH+1;
            DWORD dwHandlerNameLen = ATL_MAX_HANDLER_NAME_LEN+1;

            if (!_AtlCrackHandler(szHandlerDllName, m_szDllPath, &dwDllPathLen, m_szHandlerName, &dwHandlerNameLen))
            {
                return INVALID_TOKEN;
            }
        }
        
        return RESERVED_TOKEN;
    }

    virtual PARSE_TOKEN_RESULT ParseToken(LPSTR szTokenStart, LPSTR szTokenEnd, DWORD *pBlockStack, DWORD *pdwTop) throw()
    {
        LPSTR pStart = szTokenStart;
        pStart += 2; //skip curlies
        pStart = SkipSpace(pStart, m_nCodePage);
        DWORD dwLen = (DWORD)(szTokenEnd - szTokenStart);

        DWORD dwIndex = STENCIL_INVALIDINDEX;
        PARSE_TOKEN_RESULT ret = RESERVED_TOKEN;
    

        if (CheckTag("endwhile", 8, pStart, dwLen))
            dwIndex = ParseEndWhile(szTokenStart, szTokenEnd, pBlockStack, pdwTop);
        else if (CheckTag("while", 5, pStart, dwLen))
            dwIndex = ParseWhile(szTokenStart, szTokenEnd, pBlockStack, pdwTop);
        else if (CheckTag("endif", 5, pStart, dwLen))
            dwIndex = ParseEndIf(szTokenStart, szTokenEnd, pBlockStack, pdwTop);
        else if (CheckTag("else", 4, pStart, dwLen))
            dwIndex = ParseElse(szTokenStart, szTokenEnd, pBlockStack, pdwTop);
        else if (CheckTag("if", 2, pStart, dwLen))
            dwIndex = ParseIf(szTokenStart, szTokenEnd, pBlockStack, pdwTop);
        else if (CheckTag("locale", 6, pStart, dwLen))
            dwIndex = ParseLocale(szTokenStart, szTokenEnd, pBlockStack, pdwTop);
        else if (CheckTag("handler", 7, pStart, dwLen))
        {
            return ParseHandler(szTokenStart, szTokenEnd, pBlockStack, pdwTop);
        }
        else if (CheckTag("codepage", 8, pStart, dwLen))
        {
            ParseCodepage(szTokenStart, szTokenEnd, pBlockStack, pdwTop);
            return RESERVED_TOKEN;
        }
        else
        {
            dwIndex = ParseReplacement(szTokenStart, szTokenEnd, pBlockStack, pdwTop, STENCIL_REPLACEMENT);
            if (dwIndex == STENCIL_INVALIDINDEX)
                return INVALID_TOKEN;
            ret = NORMAL_TOKEN;
        }
        if (dwIndex == STENCIL_INVALIDINDEX)
            return INVALID_TOKEN;
        return ret;
    }

    virtual bool ParseReplacements(ITagReplacer* pReplacer, LPSTR pStart, LPSTR pEnd) throw()
    {
        LPSTR szCurr = pStart;
        DWORD BlockStack[ATL_MAX_BLOCK_STACK];
        DWORD dwTop = 0;

        m_pReplacer = pReplacer;

        DWORD dwCurrentTokenIndex = 0;

        if (!szCurr)
        {
            ATLASSERT(FALSE);
            AddError("NULL parameter to ParseReplacements", NULL);
            return false;  
        }

        LPSTR szEnd = pEnd;
        if (szEnd <= szCurr)
        {
            ATLASSERT(FALSE);
            AddError("Empty or negative string passed to ParseReplacements", NULL);
            return true;
        }

        while(szCurr < szEnd)
        {
            //mark the start of this block, then find the end of the block
            //the end is denoted by an opening curly
            LPSTR szStart = szCurr;
            while (szCurr < szEnd && (*szCurr != '{' || szCurr[1] != '{'))
            {
                LPSTR szNext = CharNextExA(m_nCodePage, szCurr, 0);
                if (szNext == szCurr)
                {
                    // embedded null
                    AddError("Embedded null character in stencil", NULL);
                    return true;
                }
                szCurr = szNext;
            }

            //special case for the last text block, if there is one
            if (szCurr >= szEnd)
            {
                // add the last token. This is everything after the last
                // double curly block, which is text.
                dwCurrentTokenIndex = AddToken(szStart, szEnd-1, STENCIL_TEXTTAG);
                break;
            }

            //if there are any characters between szStart and szCurr inclusive,
            //copy them to a text token.
            if (szCurr-1 >= szStart)
                dwCurrentTokenIndex = AddToken(szStart, szCurr-1, STENCIL_TEXTTAG);

            //find the end of the tag
            LPSTR szEndTag;
            szStart = szCurr;
            szCurr += 2; // Skip over the two '{' s
            while (szCurr < szEnd)
            {
                if (szCurr[0] == '}' && szCurr[1] == '}')
                    break;
				else if (szCurr[0] == '{')
                    break;

                LPSTR szNext = CharNextExA(m_nCodePage, szCurr, 0);
                if (szNext == szCurr)
                {
                    // embedded null
                    AddError("Embedded null character in stencil", NULL);
                    return true;
                }
                szCurr = szNext;
            }

            if (szCurr >= szEnd)
            {
                AddError("Unmatched {{", szStart);
                AddToken(szStart, szCurr-1, STENCIL_TEXTTAG);
                break;
            }

            if (szCurr[0] == '{')
            {
				if (szCurr[1] != '{')
				{
					szCurr--;
				}
                AddError("Mismatched {{", szStart);
                AddToken(szStart, szCurr-1, STENCIL_TEXTTAG);
                continue;
            }

            szEndTag = CharNextExA(m_nCodePage, szCurr, 0);
            if (szEndTag == szCurr)
            {
                // embedded null
                AddError("Embedded null character in stencil", NULL);
                return true;
            }

            PARSE_TOKEN_RESULT ret = ParseToken(szStart, szEndTag, BlockStack, &dwTop);
            if (ret == INVALID_TOKEN)
            {
                dwCurrentTokenIndex = AddToken(szStart, szEndTag, STENCIL_TEXTTAG); 
                szCurr = CharNextExA(m_nCodePage, szEndTag, 0);
                continue;
            }

            szCurr = CharNextExA(m_nCodePage, szEndTag, 0);
            if (szEndTag == szCurr)
            {
                // embedded null
                AddError("Embedded null character in stencil", NULL);
                return true;
            }

            if (ret == RESERVED_TOKEN)
            {
                // REVIEW: should these be using CharNextExA
                if (szCurr < szEnd  && *szCurr == '\n')
                    szCurr++;
                else if ((szCurr+1 < szEnd && *szCurr == '\r' && *(szCurr+1) == '\n'))
                    szCurr += 2;
            }
        }

        return true;
    }

    HTTP_CODE GetHandlerAndMethodNames(
        LPSTR pStart,
        LPSTR pEnd,
        LPSTR pszMethodName,
        LPSTR pszHandlerName) throw()
    {
        if (!pszMethodName || !pszHandlerName)
        {
            ATLASSERT(FALSE);
            AddError("Bad parameter", pStart);
            return HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);
        }

        *pszMethodName = '\0';
        *pszHandlerName = '\0';
        CHAR szMethodString[ATL_MAX_METHOD_NAME_LEN + ATL_MAX_HANDLER_NAME_LEN+1]; //*2 in case the tag is an id.tag and +1 for the dot
        HTTP_CODE hcErr = HTTP_SUCCESS;
        //
        // copy the method string
        //
        size_t nMethodLen = (pEnd-pStart)+1;
        if (nMethodLen >= (ATL_MAX_METHOD_NAME_LEN + ATL_MAX_HANDLER_NAME_LEN+1))
        {
            AddError("Method name too long", pStart);
            return HTTP_ERROR(500, ISE_SUBERR_LONGMETHODNAME);
        }

        memcpy(szMethodString, pStart, nMethodLen);
        szMethodString[nMethodLen] = '\0';

        //
        // now crack the method string and get the handler
        // id and function name
        //
        LPSTR szParen = strchr(szMethodString, '(');
        LPSTR szDot = strchr(szMethodString, '.');
        if (szDot && (!szParen || (szDot < szParen)))
        {
            *szDot = '\0';
            szDot++;

            // copy method name
            if (strlen(szDot)<ATL_MAX_METHOD_NAME_LEN)
                strcpy(pszMethodName, szDot);
            else
            {
                AddError("Method name too long", pStart + (szDot - szMethodString));
                hcErr = HTTP_ERROR(500, ISE_SUBERR_LONGMETHODNAME);
            }
            // copy handler name
            if (!hcErr)
            {
                if (strlen(szMethodString) < ATL_MAX_METHOD_NAME_LEN)
                    strcpy(pszHandlerName, szMethodString);
                else
                {
                    AddError("Handler name too long", pStart); 
                    hcErr = HTTP_ERROR(500, ISE_SUBERR_LONGHANDLERNAME);
                }
            }
        }
        else
        {
            // only a method name so just copy it.
            if (strlen(szMethodString) < ATL_MAX_METHOD_NAME_LEN)
                strcpy(pszMethodName, szMethodString);
            else
            {
                AddError("Method name too long", pStart);
                hcErr = HTTP_ERROR(500, ISE_SUBERR_LONGMETHODNAME);
            }
        }
        return hcErr;
    }

    virtual HTTP_CODE Render(
        ITagReplacer *pReplacer,
        IWriteStream *pWriteStream,
        void* pState = NULL) const throw(...)
    {
        HTTP_CODE hcErrorCode = HTTP_SUCCESS;
        DWORD dwIndex = 0;
        DWORD dwArraySize = GetTokenCount();
        CStencilState* _pState = reinterpret_cast<CStencilState*>(pState);

        // set up locale info
        CSaveThreadLocale lcidSave;

        if (_pState)
        {
            dwIndex = _pState->dwIndex;

            // restore the locale if we're restarting rendering
            if (_pState->locale != CP_ACP)
                SetThreadLocale(_pState->locale);
        }

        pReplacer->SetStream(pWriteStream);
        while (dwIndex < dwArraySize)
        {
            // RenderToken advances dwIndex appropriately for us.
            dwIndex = RenderToken(dwIndex, pReplacer, pWriteStream, &hcErrorCode, pState);

            if (dwIndex == STENCIL_INVALIDINDEX ||
                hcErrorCode != HTTP_SUCCESS)
                break;
        }

        if (IsAsyncStatus(hcErrorCode))
        {
            ATLASSERT(_pState); // state is required for async
            _pState->dwIndex = dwIndex;
        }
        // lcidSave destructor will restore the locale info in case it was changed

        return hcErrorCode;
    }

    inline BOOL IsValidIndex(DWORD dwIndex) const throw()
    {
        if (dwIndex == STENCIL_INVALIDINDEX)
            return FALSE;
        if (dwIndex < GetTokenCount())
            return TRUE;
        else
            return FALSE;
    }

    virtual DWORD RenderToken(
        DWORD dwIndex,
        ITagReplacer *pReplacer,
        IWriteStream *pWriteStream,
        HTTP_CODE *phcErrorCode,
        void* pState = NULL) const throw(...)
    {
        const StencilToken* pToken = GetToken(dwIndex);
        DWORD dwNextToken = 0;
        HTTP_CODE hcErrorCode = HTTP_SUCCESS;

        if (!pToken)
            return STENCIL_INVALIDINDEX;

        switch (pToken->type)
        {
        case STENCIL_ITERATORSTART:
            {
                HTTP_CODE hcErr = STENCIL_SUCCESS;  

                // A 'while' token has to at least be followed by an endwhile!
                if (!IsValidIndex(dwIndex+1))
                {
                    // This should have been caught at parse time
                    dwNextToken = STENCIL_INVALIDINDEX;
                    hcErrorCode = HTTP_ERROR(500, ISE_SUBERR_STENCIL_INVALIDINDEX);
                    ATLASSERT(FALSE);
                    break;
                }
                    
                // End of loop should be valid
                if (!IsValidIndex(pToken->dwLoopIndex))
                {
                    // This should have been caught at parse time
                    dwNextToken = STENCIL_INVALIDINDEX;
                    hcErrorCode = HTTP_ERROR(500, ISE_SUBERR_STENCIL_MISMATCHWHILE);
                    ATLASSERT(FALSE);
                    break;
                }

                if (pToken->dwFnOffset == STENCIL_INVALIDOFFSET)
                {
                    // This should have been caught at parse time
                    dwNextToken = STENCIL_INVALIDINDEX;
                    hcErrorCode = HTTP_ERROR(500, ISE_SUBERR_STENCIL_INVALIDFUNCOFFSET);
                    ATLASSERT(FALSE);
                    break;
                }
            
                DWORD dwLoopIndex = pToken->dwLoopIndex; // points to the end of the loop

                // Call the replacement method
                // if it returns HTTP_SUCCESS, enter the loop
                // if it returns HTTP_S_FALSE, terminate the loop
                hcErr = pReplacer->RenderReplacement(pToken->dwFnOffset,
                    pToken->dwObjOffset, pToken->dwMap, (void *) pToken->dwData);

                if (hcErr == HTTP_SUCCESS)
                {
                    dwNextToken = dwIndex+1;
                    hcErrorCode = HTTP_SUCCESS;
                }
                else if (hcErr == HTTP_S_FALSE)
                {
                    dwNextToken = dwLoopIndex+1;
                    hcErrorCode = HTTP_SUCCESS;
                }
                else
                {
                    dwNextToken = STENCIL_INVALIDINDEX;
                    hcErrorCode = hcErr;
                    break;
                }
            }
            break;
        case STENCIL_ITERATOREND:
            {
                dwNextToken = pToken->dwLoopIndex;
                hcErrorCode = HTTP_SUCCESS;
                ATLASSERT(GetToken(dwNextToken)->type == STENCIL_ITERATORSTART);
            }
            break;
        case STENCIL_CONDITIONALSTART:
            {
                if (pToken->type == STENCIL_CONDITIONALSTART && pToken->dwFnOffset == STENCIL_INVALIDOFFSET)
                {
                    // This should have been caught at parse time
                    ATLASSERT(FALSE);
                    dwNextToken = STENCIL_INVALIDINDEX;
                    hcErrorCode = HTTP_ERROR(500, ISE_SUBERR_STENCIL_INVALIDFUNCOFFSET);
                    break;
                }
            
                if (pToken->dwLoopIndex == STENCIL_INVALIDINDEX)
                {
                    // This should have been caught at parse time
                    ATLASSERT(FALSE);
                    dwNextToken = STENCIL_INVALIDINDEX;
                    hcErrorCode = HTTP_ERROR(500, ISE_SUBERR_STENCIL_MISMATCHIF);
                    break;
                }

                DWORD dwLoopIndex = pToken->dwLoopIndex; // points to the end of the loop

                HTTP_CODE hcErr;
                // Call the replacement method.
                // If it returns HTTP_SUCCESS, we render everything up to
                //  the end of the conditional. 
                // if it returns HTTP_S_FALSE, the condition is not met and we
                //  render the else part if it exists or jump past the endif otherwise
                hcErr = pReplacer->RenderReplacement(pToken->dwFnOffset, 
                    pToken->dwObjOffset, pToken->dwMap, (void *)pToken->dwData);

                if (hcErr == HTTP_SUCCESS)
                {
                    dwNextToken = dwIndex+1;
                    hcErrorCode = HTTP_SUCCESS;
                }
                else if (hcErr == HTTP_S_FALSE)
                {
                    dwNextToken = dwLoopIndex+1;
                    hcErrorCode = HTTP_SUCCESS;
                }
                else
                {
                    dwNextToken = STENCIL_INVALIDINDEX;
                    hcErrorCode = hcErr;
                    break;
                }
            }
            break;
        case STENCIL_CONDITIONALELSE:
            {
                if (pToken->dwLoopIndex == STENCIL_INVALIDINDEX)
                {
                    // This should have been caught at parse time
                    ATLASSERT(FALSE);
                    dwNextToken = STENCIL_INVALIDINDEX;
                    hcErrorCode = HTTP_ERROR(500, ISE_SUBERR_STENCIL_MISMATCHIF);
                    break;
                }
                dwNextToken = pToken->dwLoopIndex+1;
                hcErrorCode = HTTP_SUCCESS;
            }
            break;
        case STENCIL_CONDITIONALEND:
            {
                dwNextToken = dwIndex+1;
                hcErrorCode = HTTP_SUCCESS;
            }
            break;
        case STENCIL_TEXTTAG:
            {
                pWriteStream->WriteStream(pToken->pStart,
                                        (int)((pToken->pEnd-pToken->pStart)+1), NULL);
                dwNextToken = dwIndex+1;
            }
            break;
        case STENCIL_REPLACEMENT:
            {
                if (pToken->dwFnOffset == STENCIL_INVALIDOFFSET)
                {
                    // This should have been caught at parse time
                    ATLASSERT(FALSE);
                    dwNextToken = STENCIL_INVALIDINDEX;
                    hcErrorCode = HTTP_ERROR(500, ISE_SUBERR_STENCIL_INVALIDFUNCOFFSET);
                    break;
                }

                hcErrorCode = pReplacer->RenderReplacement(pToken->dwFnOffset, 
                            pToken->dwObjOffset, pToken->dwMap, (void *)pToken->dwData);

                if (IsAsyncContinueStatus(hcErrorCode))
                    dwNextToken = dwIndex; // call the tag again after we get back
                else
                {
                    dwNextToken = dwIndex + 1;

                    // when returned from a handler, these indicate that the handler is done
                    // and that we should move on to the next handler when called back
                    if (hcErrorCode == HTTP_SUCCESS_ASYNC_DONE)
                        hcErrorCode = HTTP_SUCCESS_ASYNC;
                    else if (hcErrorCode == HTTP_SUCCESS_ASYNC_NOFLUSH_DONE)
                        hcErrorCode = HTTP_SUCCESS_ASYNC_NOFLUSH;
                }
            }
            break;
        case STENCIL_LOCALE:
            {
                if (pState)
                {
                    CStencilState* _pState = reinterpret_cast<CStencilState*>(pState);
                    _pState->locale = (LCID) pToken->dwData;
                }
                SetThreadLocale((LCID) pToken->dwData);
                dwNextToken = dwIndex + 1;
            }
            break;
        default:
            {
                ATLASSERT(FALSE);
                dwNextToken = STENCIL_INVALIDINDEX;
                hcErrorCode = HTTP_ERROR(500, ISE_SUBERR_STENCIL_UNEXPECTEDTYPE);
                break;
            }
        }
        ATLASSERT(dwNextToken != dwIndex || IsAsyncContinueStatus(hcErrorCode));

        if (phcErrorCode)
            *phcErrorCode = hcErrorCode;

        return dwNextToken;
    }

    DWORD GetTokenCount() const throw()
    {
        return (DWORD) m_arrTokens.GetCount();
    }

    const StencilToken* GetToken(DWORD dwIndex) const throw()
    {
        return &(m_arrTokens[dwIndex]);
    }

	StencilToken* GetToken(DWORD dwIndex) throw()
    {
        return &(m_arrTokens[dwIndex]);
    }

    LPSTR GetBufferStart() const throw()
    {
        return m_pBufferStart;
    }

    LPSTR GetBufferEnd() const throw()
    {
        return m_pBufferEnd;
    }

    WORD GetCodePage() const throw()
    {
        return m_nCodePage;
    }

    // IMemoryCacheClient
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv) throw()
    {
        if (!ppv)
            return E_POINTER;

        if (InlineIsEqualGUID(riid, __uuidof(IUnknown)) ||
            InlineIsEqualGUID(riid, __uuidof(IMemoryCacheClient)))
        {
            *ppv = static_cast<void*>(this);
            return S_OK;
        }
        return E_NOINTERFACE;
    }

    STDMETHOD_(ULONG, AddRef)() throw()
    {
        return 1;
    }

    STDMETHOD_(ULONG, Release)() throw()
    {
        return 1;
    }

    STDMETHOD(Free)(const void *pData) throw()
    {
        if (!pData)
            return E_UNEXPECTED;

        ATLASSERT(*((void **) pData) == static_cast<void*>(this));
        
        Uninitialize();

        delete this;
        return S_OK;
    }
}; // class CStencil

struct StencilIncludeInfo
{
public:
    CHAR m_szQueryString[2048];
    CHAR m_szFileName[MAX_PATH];
};


class CIncludeServerContext :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CWrappedServerContext
{
public:
    BEGIN_COM_MAP(CIncludeServerContext)
        COM_INTERFACE_ENTRY(IHttpServerContext)
    END_COM_MAP()

    IWriteStream * m_pStream;
    const StencilIncludeInfo * m_pIncludeInfo;

    CIncludeServerContext() throw()
    {
        m_pStream = NULL;
        m_pIncludeInfo = NULL;
    }

    void Initialize(
        IWriteStream *pStream,
        IHttpServerContext* pServerContext,
        const StencilIncludeInfo * pIncludeInfo) throw()
    {
        m_pStream = pStream;
        m_spParent = pServerContext;
        m_pIncludeInfo = pIncludeInfo;
    }

    LPCSTR GetRequestMethod() throw()
    {
        return "GET";
    }

    LPCSTR GetQueryString() throw()
    {
        return m_pIncludeInfo->m_szQueryString;
    }

    LPCSTR GetPathTranslated() throw()
    {
        return m_pIncludeInfo->m_szFileName;
    }

    LPCSTR GetScriptPathTranslated() throw()
    {
        return m_pIncludeInfo->m_szFileName;
    }

    DWORD GetTotalBytes() throw()
    {
        return 0;
    }

    DWORD GetAvailableBytes() throw()
    {
        return 0;
    }

    BYTE *GetAvailableData() throw()
    {
        return NULL;
    }

    LPCSTR GetContentType() throw()
    {
        return 0;
    }

    BOOL WriteClient(void *pvBuffer, DWORD *pdwBytes) throw(...)
    {
        HRESULT hr = m_pStream->WriteStream((LPCSTR) pvBuffer, *pdwBytes, pdwBytes);
        return SUCCEEDED(hr);
    }

    BOOL ReadClient(void * /*pvBuffer*/, DWORD * /*pdwSize*/) throw()
    {
        return FALSE;
    }

    BOOL AsyncReadClient(void * /*pvBuffer*/, DWORD * /*pdwSize*/) throw()
    {
        return FALSE;
    }
    
    BOOL SendRedirectResponse(LPCSTR /*pszRedirectURL*/) throw()
    {
        return FALSE;
    }

    BOOL SendResponseHeader(
        LPCSTR /*pszHeader*/,
        LPCSTR /*pszStatusCode*/,
        BOOL /*fKeepConn*/) throw()
    {
        return TRUE;
    }

    BOOL DoneWithSession(DWORD /*dwHttpStatusCode*/) throw()
    {
        return TRUE;
    }

    BOOL RequestIOCompletion(PFN_HSE_IO_COMPLETION /*pfn*/, DWORD * /*pdwContext*/) throw()
    {
        return FALSE;
    }
}; // class CIncludeServerContext

class CIDServerContext :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CWrappedServerContext
{
public:
    CHttpResponse *m_pResponse;
    CHttpRequest *m_pRequest;

    BEGIN_COM_MAP(CIDServerContext)
        COM_INTERFACE_ENTRY(IHttpServerContext)
    END_COM_MAP()

    CIDServerContext() throw()
        : m_pResponse(NULL), m_pRequest(NULL)
    {
    }

    BOOL Initialize(
        CHttpResponse *pResponse,
        CHttpRequest *pRequest) throw()
    {
        m_pResponse = pResponse;
        m_pRequest = pRequest;
        HRESULT hr = m_pRequest->GetServerContext(&m_spParent);
        return (SUCCEEDED(hr));
    }

    LPCSTR GetRequestMethod() throw()
    {
        ATLASSERT(m_pRequest != NULL);
        return m_pRequest->GetMethodString();
    }

    LPCSTR GetQueryString() throw()
    {
        ATLASSERT(m_pRequest != NULL);
        return m_pRequest->GetQueryString();
    }

    LPCSTR GetPathInfo() throw()
    {
        ATLASSERT(m_pRequest != NULL);
        return m_pRequest->GetPathInfo();
    }

    LPCSTR GetPathTranslated() throw()
    {
        ATLASSERT(m_pRequest != NULL);
        return m_pRequest->GetPathTranslated();
    }

    DWORD GetTotalBytes() throw()
    {
        ATLASSERT(m_pRequest != NULL);
        return m_pRequest->GetTotalBytes();
    }

    DWORD GetAvailableBytes() throw()
    {
        ATLASSERT(m_pRequest != NULL);
        return m_pRequest->GetAvailableBytes();
    }

    BYTE *GetAvailableData() throw()
    {
        ATLASSERT(m_pRequest != NULL);
        return m_pRequest->GetAvailableData();
    }

    LPCSTR GetContentType() throw()
    {
        ATLASSERT(m_pRequest != NULL);
        return m_pRequest->GetContentType();
    }

    LPCSTR GetScriptPathTranslated() throw()
    {
        ATLASSERT(m_pRequest != NULL);
        return m_pRequest->GetScriptPathTranslated();
    }

    BOOL WriteClient(void *pvBuffer, DWORD *pdwBytes) throw()
    {
        ATLASSERT(m_pResponse != NULL);
        return m_pResponse->WriteLen((LPCSTR)pvBuffer, *pdwBytes);
    }

    BOOL ReadClient(void *pvBuffer, DWORD *pdwSize) throw()
    {
        ATLASSERT(m_pRequest != NULL);
        return m_pRequest->ReadData((LPSTR)pvBuffer, pdwSize);
    }

    BOOL SendRedirectResponse(LPCSTR pszRedirectURL) throw()
    {
        ATLASSERT(m_pResponse != NULL);
        return m_pResponse->Redirect(pszRedirectURL);
    }

    BOOL TransmitFile(
        HANDLE hFile,
        PFN_HSE_IO_COMPLETION pfn,
        void *pContext,
        LPCSTR szStatusCode,
        DWORD dwBytesToWrite,
        DWORD dwOffset,
        void *pvHead,
        DWORD dwHeadLen,
        void *pvTail,
        DWORD dwTailLen,
        DWORD dwFlags) throw(...)
    {
        ATLASSERT(m_pResponse != NULL);
        ATLASSERT(m_spParent != NULL);

        m_pResponse->Flush();
        return m_spParent->TransmitFile(hFile, pfn, pContext, szStatusCode, 
            dwBytesToWrite, dwOffset, pvHead, dwHeadLen, pvTail, dwTailLen, dwFlags);
    }

}; // class CIDServerContext

//
// CHtmlStencil
// CHtmlStencil is a specialization of CStencil. CHtmlStencil adds the following
// capabilities to CStencil:
// 
// Support for rendering {{include }} tags
// The {{include }}  tags specify another stencil to be included in-place during
// stencil rendering. The {{include }} tag takes a single parameter which is the 
// URL of the stencil to include. That URL can optionally include parameters. 
// An example:
// {{include mystencil.srf?param1=value1}}
//
// We also grab the handler name and the name of any subhandlers.  A handler must be
// the first tag in the .srf file.  The syntax for the handler specification is:
// {{handler MyDynamicHandler.dll/Default}}
// which would cause the MyDynamicHandler.dll to be loaded. Once loaded, the stencil 
// processor will ask for the IReplacementHandler interface of the object named "Default".
//
// Additional handlers can be specified after the default handler.  An example of an 
// additional handler would be:
// {{subhandler OtherHandler MyOtherHandler.dll/Default}}
// would cause the MyOtherHandler.dll to be loaded. Once loaded, the stencil processor will
// ask for the IReplacementHandler interface of the object named "Default" and use it in
// processing the stencil anywhere it sees a stencil tag of the form 
// {{OtherHandler.RenderReplacement}}

struct CStringPair
{
    CStringA strDllPath;
    CStringA strHandlerName;

    CStringPair()throw()
	{
	}

    CStringPair(CStringA &strDllPath_, CStringA &strHandlerName_) throw(...)
        :strDllPath(strDllPath_), strHandlerName(strHandlerName_)
    {
    }
};

class CStringPairElementTraits :
    public CElementTraitsBase< CStringPair >
{
public:
    static ULONG Hash( INARGTYPE pair ) throw()
    {
        return CStringElementTraits<CStringA>::Hash( pair.strDllPath );
    }

    static bool CompareElements( INARGTYPE pair1, INARGTYPE pair2 ) throw()
    {
        return( (pair1.strDllPath == pair2.strDllPath) && (pair1.strHandlerName == pair2.strHandlerName) );
    }

    static int CompareElementsOrdered( INARGTYPE pair1, INARGTYPE pair2 ) throw()
    {
        return( pair1.strDllPath.Compare( pair2.strDllPath ) );
    }
};

class CHtmlStencil : public CStencil
{
protected:
    CAtlMap<CStringA, CStringPair, 
        CStringElementTraits<CStringA>, CStringPairElementTraits > m_arrExtraHandlers;
    CHAR m_szBaseDir[MAX_PATH];
    CComPtr<IServiceProvider> m_spServiceProvider;
    CComPtr<IIsapiExtension> m_spExtension;
    CComPtr<IStencilCache> m_spStencilCache;
    CComPtr<IDllCache> m_spDllCache;

public:
    typedef CAtlMap<CStringA, CStringPair, 
        CStringElementTraits<CStringA>, CStringPairElementTraits > mapType;
    typedef CStencil baseType;

    CHtmlStencil(IAtlMemMgr *pMemMgr=NULL) throw() :
        CStencil(pMemMgr)
    {

    }
    
    void Initialize(IServiceProvider *pProvider) throw(...)
    {
        ATLASSERT(pProvider);
        if (m_spServiceProvider)
            m_spServiceProvider.Release();

        m_spServiceProvider = pProvider;
        if (!m_spDllCache)
            pProvider->QueryService(__uuidof(IDllCache), __uuidof(IDllCache), (void **) &m_spDllCache);

        if (!m_spExtension)
            pProvider->QueryInterface(__uuidof(IIsapiExtension), (void **) &m_spExtension);
    }

    BOOL GetIncludeInfo(LPCSTR szParamBegin, LPCSTR szParamEnd, StencilIncludeInfo *pInfo) const throw()
    {
        LPCSTR szQueryBegin = szParamBegin;

        while (*szQueryBegin && *szQueryBegin != '?' && *szQueryBegin != '}')
        {
            LPSTR szNext = CharNextExA(GetCodePage(), szQueryBegin, 0);
            if (szNext == szQueryBegin)
            {
                return FALSE;
            }

            szQueryBegin = szNext;
        }

        char szPath[MAX_PATH];
		szPath[0] = '\0';
        DWORD dwPrefixLen = 0;
		if (*szParamBegin == '"')
		{
			szParamBegin++;
		}
        if (!IsFullPathA(szParamBegin))
		{	
			if (*szParamBegin != '\\')
			{
				strcpy(szPath, m_szBaseDir);
			}
			else
			{
				LPCSTR szBackslash = strchr(m_szBaseDir, '\\');
				if (szBackslash)
				{
					strncpy(szPath, m_szBaseDir, szBackslash-m_szBaseDir);
					szPath[szBackslash-m_szBaseDir] = '\0';
				}
				else
				{
					strcpy(szPath, m_szBaseDir);
				}
			}
            dwPrefixLen = (DWORD)strlen(szPath);
        }

        if (*szQueryBegin=='?')
        {
			size_t nMinus = (*(szQueryBegin-1) == '"') ? 1 : 0;
            strncat(szPath, szParamBegin, szQueryBegin-szParamBegin-nMinus);
            szPath[dwPrefixLen + szQueryBegin - szParamBegin] = '\0';
            memcpy(pInfo->m_szQueryString, szQueryBegin + 1, szParamEnd - szQueryBegin);
            pInfo->m_szQueryString[szParamEnd - szQueryBegin] = '\0';
        }
        else
        {
            pInfo->m_szQueryString[0] = '\0';
			size_t nAdd = (*szParamEnd == '"') ? 0 : 1;
            strncat(szPath, szParamBegin, szParamEnd - szParamBegin + nAdd);
            szPath[dwPrefixLen + szParamEnd - szParamBegin + 1] = '\0';
        }
        
        PathCanonicalizeA(pInfo->m_szFileName, szPath);

        return HTTP_SUCCESS;
    }

    int ParseInclude(LPSTR szTokenStart, LPSTR szTokenEnd, DWORD * /*pBlockStack*/, DWORD * /*pdwTop*/) throw(...)
    {
        LPSTR szStart = szTokenStart;
        LPSTR szEnd = szTokenEnd;

        FindTagArgs(szStart, szEnd, 7);
        
		CHeapPtr<char> szFileNameRelative;
		CHeapPtr<TCHAR> szFileName;

		ATLTRY(szFileNameRelative.AllocateBytes(max(MAX_PATH, szEnd-szStart+3)))
		ATLTRY(szFileName.AllocateBytes(((szEnd-szStart)+MAX_PATH+3)*sizeof(TCHAR)))

		if ((char*)szFileNameRelative == NULL ||
			(TCHAR*)szFileName == NULL)
		{
			AddError("Out of memory", szTokenStart);
            return AddToken(szTokenStart, szTokenEnd, STENCIL_TEXTTAG);
		}


        memcpy(szFileNameRelative, szStart, szEnd-szStart + 1);
        szFileNameRelative[szEnd-szStart + 1] = '\0';

        if (!IsFullPathA(szFileNameRelative))
        {
			CHeapPtr<CHAR> szTemp;
			ATLTRY(szTemp.AllocateBytes((szEnd-szStart)+MAX_PATH+3));
			if ((CHAR*)szTemp == NULL)
			{
				AddError("Out of memory", szTokenStart);
				return AddToken(szTokenStart, szTokenEnd, STENCIL_TEXTTAG);
			}
			if (*szFileNameRelative != '\\')
			{
				strcpy(szTemp, m_szBaseDir);
			}
			else
			{
				LPCSTR szBackslash = strchr(m_szBaseDir, '\\');
				if (szBackslash)
				{
					strncpy(szTemp, m_szBaseDir, szBackslash-m_szBaseDir);
					szTemp[szBackslash-m_szBaseDir] = '\0';
				}
				else
				{
					strcpy(szTemp, m_szBaseDir);
				}
			}

            strcat(szTemp, szFileNameRelative);
            PathCanonicalize(szFileName, CA2CT(szTemp));
        }
        else
        {
            _tcscpy(szFileName, CA2CTEX<MAX_PATH>(szFileNameRelative));
        }

		LPTSTR szDot = NULL;
		LPTSTR szExtra = _tcschr(szFileName, '?');
		if (!szExtra)
		{
			szExtra = _tcschr(szFileName, '#');
			if (!szExtra)
			{
				szDot = _tcsrchr(szFileName, '.');
			}
		}

		if (szExtra != NULL)
		{
			// there is some extra information
			LPTSTR szDotTmp = szFileName;
			do
			{
				szDot = szDotTmp;
				szDotTmp = _tcschr(szDotTmp+1, '.');
			} while (szDotTmp && szDotTmp < szExtra);
		}

		if (!szDot || *szDot != '.')
		{
			AddError("Unexpected error", szTokenStart);
            return AddToken(szTokenStart, szTokenEnd, STENCIL_TEXTTAG);
		}

		LPTSTR szExtEnd = szDot;

        while (true)
        {
            szExtEnd++;
            if (!*szExtEnd || *szExtEnd == '/' || *szExtEnd == '\\' || *szExtEnd == '?' || *szExtEnd == '#' || *szExtEnd == '"')
                break;
        }

        if (szDot && szExtEnd-szDot == sizeof(".dll")-sizeof('\0') &&
            !_tcsnicmp(szDot, _T(".dll"), sizeof(".dll")-sizeof('\0')))
        {
            // Do .dll stuff
            DWORD dwIndex = AddToken(szStart, szEnd, STENCIL_STENCILINCLUDE);
            StencilIncludeInfo *pInfo = (StencilIncludeInfo *)m_pMemMgr->Allocate(sizeof(StencilIncludeInfo));
            if (!pInfo)
                return -1;

            GetIncludeInfo(szStart, szEnd, pInfo);
//            m_arrTokens[dwIndex].pvParam = pInfo;
			GetToken(dwIndex)->dwData = (DWORD_PTR) pInfo;
            return dwIndex;
        }
        else if (szDot && (size_t)(szExtEnd-szDot) == _tcslen(c_tAtlSRFExtension) &&
            !_tcsnicmp(szDot, c_tAtlSRFExtension, _tcslen(c_tAtlSRFExtension)))
        {
            // Do .srf stuff
            DWORD dwIndex = AddToken(szStart, szEnd, STENCIL_STENCILINCLUDE);
            StencilIncludeInfo *pInfo = (StencilIncludeInfo *)m_pMemMgr->Allocate(sizeof(StencilIncludeInfo));
            if (!pInfo)
                return -1;

            GetIncludeInfo(szStart, szEnd, pInfo);
//            m_arrTokens[dwIndex].pvParam = pInfo;
			GetToken(dwIndex)->dwData = (DWORD_PTR) pInfo;
            return dwIndex;
        }
        else
        {
            // Assume static content
            CAtlFile file;

            HRESULT hr = file.Create(szFileName, GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING);
            if (FAILED(hr) || GetFileType(file) != FILE_TYPE_DISK)
			{
				if (FAILED(hr))
					AddError("Could not open included file", szTokenStart);
				else
					AddError("Included file is not a disk file", szTokenStart);
                return AddToken(szTokenStart, szTokenEnd, STENCIL_TEXTTAG);
			}

            CAutoVectorPtr<CHAR> szBufferStart;
            LPSTR szBufferEnd = NULL;
            ULONGLONG dwLen = 0;
            if (FAILED(file.GetSize(dwLen)))
                return AddToken(szTokenStart, szTokenEnd, STENCIL_TEXTTAG);

            if (!szBufferStart.Allocate((size_t) dwLen))
				AtlThrow(E_OUTOFMEMORY);

            DWORD dwRead;
            if (FAILED(file.Read(szBufferStart, (DWORD) dwLen, dwRead)))
                return AddToken(szTokenStart, szTokenEnd, STENCIL_TEXTTAG);

            szBufferEnd = szBufferStart + dwRead-1;

			DWORD dwIndex = AddToken(szBufferStart, szBufferEnd, STENCIL_STATICINCLUDE);
//            m_arrTokens[dwIndex].bDynamicAlloc = TRUE;
			GetToken(dwIndex)->bDynamicAlloc = TRUE;
			szBufferStart.Detach();
            return dwIndex;
        }
    }

    PARSE_TOKEN_RESULT ParseSubhandler(LPSTR szTokenStart, LPSTR szTokenEnd, DWORD * /*pBlockStack*/, DWORD * /*pdwTop*/) throw()
    {
        LPSTR szStart = szTokenStart;
        LPSTR szEnd = szTokenEnd;

        // move to the start of the arguments
        // (the first char past 'subhandler'
        FindTagArgs(szStart, szEnd, 10);

        // skip any space to bring us to the start
        // of the id for the subhandler.
        szStart = SkipSpace(szStart, GetCodePage());

        // id names cannot contain spaces. Mark the
        // beginning and end if the subhandler id
        LPCSTR szIdStart = szStart;
        while (!isspace(*szStart) && *szStart != '}')
        {
            LPSTR szNext = CharNextExA(GetCodePage(), szStart, 0);
            if (szNext == szStart)
            {
                // embedded null
                AddError("Embedded null character in stencil", NULL);
                return INVALID_TOKEN;
            }
            szStart = szNext;
        }
        LPCSTR szIdEnd = szStart;

        // skip space to bring us to the beginning of the
        // the dllpath/handlername
        szStart = SkipSpace(szStart, GetCodePage());

        // everything up to the end if the tag is
        // part of the dllpath/handlername
        LPSTR szHandlerStart = szStart;
        while (*szStart != '}')
        {
            LPSTR szNext = CharNextExA(GetCodePage(), szStart, 0);
            if (szNext == szStart)
            {
                // embedded null
                AddError("Embedded null character in stencil", NULL);
                return INVALID_TOKEN;
            }
            szStart = szNext;
        }
        LPCSTR szHandlerEnd = szStart;

		_ATLTRY
		{
        CStringA strName(szIdStart, (int)(szIdEnd-szIdStart));
        CStringA strPath(szHandlerStart, (int)(szHandlerEnd-szHandlerStart));

        CStringA strDllPath;
        CStringA strHandlerName;
        DWORD dwDllPathLen = MAX_PATH+1;
        DWORD dwHandlerNameLen = ATL_MAX_HANDLER_NAME_LEN+1;

        LPSTR szDllPath = strDllPath.GetBuffer(dwDllPathLen);
        LPSTR szHandlerName = strHandlerName.GetBuffer(dwHandlerNameLen);

        if (!_AtlCrackHandler(strPath, szDllPath, &dwDllPathLen, szHandlerName, &dwHandlerNameLen))
        {
            strDllPath.ReleaseBuffer();
            strHandlerName.ReleaseBuffer();
            return INVALID_TOKEN;
        }
        
        strDllPath.ReleaseBuffer(dwDllPathLen);
        strHandlerName.ReleaseBuffer(dwHandlerNameLen);

        m_arrExtraHandlers.SetAt(strName, CStringPair(strDllPath, strHandlerName));
		}
		_ATLCATCHALL()
		{
			return INVALID_TOKEN;
		}
        return RESERVED_TOKEN;
    }

    virtual PARSE_TOKEN_RESULT ParseToken(LPSTR szTokenStart, LPSTR szTokenEnd, DWORD *pBlockStack, DWORD *pdwTop) throw()
    {
        LPSTR pStart = szTokenStart;
        pStart += 2; //skip curlies
        pStart = SkipSpace(pStart, GetCodePage());
        DWORD dwLen = (DWORD)(szTokenEnd - szTokenStart);

        int nIndex = -1;

        if (CheckTag("include", 7, pStart, dwLen))
            nIndex = ParseInclude(szTokenStart, szTokenEnd, pBlockStack, pdwTop);
        else if (dwLen > 3 && !memcmp("!--", pStart, 3))
            return RESERVED_TOKEN;
        else if (dwLen > 2 && !memcmp("//", pStart, 2))
            return RESERVED_TOKEN;
        else if (CheckTag("subhandler", 10, pStart, dwLen))
        {
            return ParseSubhandler(szTokenStart, szTokenEnd, pBlockStack, pdwTop);
        }
        else
        {
            return CStencil::ParseToken(szTokenStart, szTokenEnd, pBlockStack, pdwTop);
        }
        if (nIndex < 0)
            return INVALID_TOKEN;
        return RESERVED_TOKEN;
    }

    mapType* GetExtraHandlers() throw()
    {
        return &m_arrExtraHandlers;
    }

    void SetBaseDirFromFile(LPCSTR szBaseDir) throw()
    {
        strcpy(m_szBaseDir, szBaseDir);
        LPSTR szSlash = strrchr(m_szBaseDir, '\\');
        if (szSlash)
        {
            szSlash++;
            *szSlash = '\0';
        }
        else
        {
            *m_szBaseDir = '\0';
        }
    }

    LPCSTR GetBaseDir() throw()
    {
        return m_szBaseDir;
    }


    // Any value returned from a replacement method other than HTTP_SUCCESS
    // will stop the rendering of the stencil.
    DWORD RenderToken(
        DWORD dwIndex,
        ITagReplacer* pReplacer,
        IWriteStream *pWriteStream,
        HTTP_CODE *phcErrorCode,
        void* pState = NULL) const throw(...)
    {
        DWORD dwNextToken = STENCIL_INVALIDINDEX;
        HTTP_CODE hcErrorCode = HTTP_SUCCESS;
        const StencilToken* pToken = GetToken(dwIndex);
        if (pToken)
        {
            if (pToken->type == STENCIL_STENCILINCLUDE)
            {
                ATLASSERT(m_spServiceProvider);
                CComPtr<IHttpServerContext> spServerContext;
                CComPtr<IHttpRequestLookup> spLookup;
                if (FAILED(pReplacer->GetContext(__uuidof(IHttpServerContext), (VOID**) &spServerContext)))
                    return HTTP_ERROR(500, 0);
                if (FAILED(pReplacer->GetContext(__uuidof(IHttpRequestLookup), (VOID**) &spLookup)))
                    return HTTP_ERROR(500, 0);
                hcErrorCode = RenderInclude(m_spServiceProvider, pWriteStream, 
                    (StencilIncludeInfo *)pToken->dwData, spServerContext, spLookup,
                    pState);
                if (hcErrorCode == HTTP_SUCCESS || IsAsyncDoneStatus(hcErrorCode))
                    dwNextToken = dwIndex+1;
                else if (IsAsyncContinueStatus(hcErrorCode))
                    dwNextToken = dwIndex;
            }
            else if (pToken->type == STENCIL_STATICINCLUDE)
            {
                pWriteStream->WriteStream(pToken->pStart,
                    (int)((pToken->pEnd-pToken->pStart)+1), NULL);
                dwNextToken = dwIndex+1;
            }
            else
                dwNextToken = baseType::RenderToken(dwIndex, pReplacer,
                        pWriteStream, &hcErrorCode, pState);
        }

        if (hcErrorCode == HTTP_SUCCESS_NO_CACHE)
        {
            hcErrorCode = HTTP_SUCCESS;
            CComPtr<IHttpServerContext> spContext;
            HRESULT hr = pReplacer->GetContext(__uuidof(IHttpServerContext), (void **)&spContext);
            if (hr == S_OK && spContext)
            {
                CComQIPtr<IPageCacheControl> spControl;
                spControl = spContext;
                if (spControl)
                    spControl->Cache(FALSE);
            }
        }

        if (phcErrorCode)
            *phcErrorCode = hcErrorCode;
        return dwNextToken;
    }

    ATL_NOINLINE HTTP_CODE RenderInclude(
        IServiceProvider *pServiceProvider,
        IWriteStream *pWriteStream,
        const StencilIncludeInfo *pIncludeInfo,
        IHttpServerContext *pServerContext,
        IHttpRequestLookup *pLookup,
        void* pState = NULL) const throw(...)
    {
        AtlServerRequest* pRequestInfo = NULL;
        HTTP_CODE hcErr = HTTP_SUCCESS;


        CComObjectStackEx<CIncludeServerContext> serverContext;
        serverContext.Initialize(pWriteStream, pServerContext, pIncludeInfo);

#ifdef _DEBUG
        bool bAsyncAllowed = false;
#endif

        CStencilState* _pState = reinterpret_cast<CStencilState*>(pState);
        if (_pState && _pState->pIncludeInfo)
        {
            pRequestInfo = _pState->pIncludeInfo;
            _pState->pIncludeInfo = NULL;
#ifdef _DEBUG
            bAsyncAllowed = true;
#endif
        }
        else
        {
            if (!m_spStencilCache)
                m_spServiceProvider->QueryService(__uuidof(IStencilCache), __uuidof(IStencilCache), (void **) &m_spStencilCache);
            ATLASSERT(m_spStencilCache);

            if (!m_spDllCache)
                pServiceProvider->QueryService(__uuidof(IDllCache), __uuidof(IDllCache), (void **) &m_spDllCache);
            ATLASSERT(m_spDllCache);

            pRequestInfo = m_spExtension->CreateRequest();
            if (pRequestInfo == NULL)
                return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM);

            pRequestInfo->dwRequestState = ATLSRV_STATE_BEGIN;
            pRequestInfo->dwRequestType = ATLSRV_REQUEST_STENCIL;
            pRequestInfo->pDllCache = m_spDllCache;
            pRequestInfo->pExtension = m_spExtension;
            pRequestInfo->pServerContext = &serverContext;
            if (_pState && _pState->pParentInfo)
                pRequestInfo->pUserData = _pState->pParentInfo->pUserData;

            // Extract the file extension of the included file by searching
            // for the first '.' from the right.
            // Can't use _tcsrchr because we have to use the stencil's codepage
            LPCSTR szDot = NULL;
            LPCSTR szMark = pIncludeInfo->m_szFileName;
            while (*szMark)
            {
                if (*szMark == '.')
                    szDot = szMark;

                LPCSTR szNext = CharNextExA(GetCodePage(), szMark, 0);
                if (szNext == szMark)
                {
                    // embedded null
                    return HTTP_FAIL;
                }
                szMark = szNext;
            }

            if (szDot && _stricmp(szDot, c_AtlSRFExtension) == 0)
            {
                hcErr = m_spExtension->LoadDispatchFile(pIncludeInfo->m_szFileName, pRequestInfo);
                if (hcErr)
                    return hcErr;
            }
            else if (szDot && _stricmp(szDot, ".dll") == 0)
            {
                // Get the handler name if they used the asdf.dll?Handler=Default notation
                // REVIEW : case sensitivity on the "Handler"?
                char szHandlerName[ATL_MAX_HANDLER_NAME_LEN+1] = { '\0' };

                LPSTR szStart = strstr(pIncludeInfo->m_szQueryString, "Handler=");
                if (szStart && 
					((szStart == pIncludeInfo->m_szQueryString) || 
					 ((szStart > pIncludeInfo->m_szQueryString) && (*(szStart-1) == '&'))))
                {
                    szStart += 8;  // Skip past "Handler" and the "="
                    LPSTR szEnd = strchr(szStart, '&');
                    if (szEnd)
                    {
                        memcpy(szHandlerName, szStart, min((szEnd-szStart), ATL_MAX_HANDLER_NAME_LEN));
                        szHandlerName[min((szEnd-szStart), ATL_MAX_HANDLER_NAME_LEN)] = '\0';
                    }
                    else
                    {
                        strcpy(szHandlerName, szStart);
                    }
                }
                else
                {
                    memcpy(szHandlerName, "Default", sizeof("Default"));
                }

                pRequestInfo->dwRequestType = ATLSRV_REQUEST_DLL;

                hcErr = m_spExtension->LoadRequestHandler(pIncludeInfo->m_szFileName, szHandlerName, pRequestInfo->pServerContext, 
                    &pRequestInfo->hInstDll, &pRequestInfo->pHandler);
                if (hcErr)
                    return hcErr;
            }

            DWORD dwStatus;
            hcErr = pRequestInfo->pHandler->GetFlags(&dwStatus);

            if (hcErr)
                return hcErr;

            if (dwStatus & (ATLSRV_INIT_USEASYNC | ATLSRV_INIT_USEASYNC_EX))
            {
#ifdef _DEBUG
                bAsyncAllowed = true;
#endif
                CComObjectNoLock<CIncludeServerContext>* pNewServerContext = NULL;
                ATLTRY(pNewServerContext = new CComObjectNoLock<CIncludeServerContext>);
                if (pNewServerContext == NULL)
                    return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM);
                pNewServerContext->Initialize(pWriteStream, pServerContext, pIncludeInfo);
                pNewServerContext->AddRef();
                pRequestInfo->pServerContext = pNewServerContext;
            }

            _ATLTRY
            {
                hcErr = pRequestInfo->pHandler->InitializeChild(pRequestInfo, m_spServiceProvider, pLookup);
                if (hcErr)
                    return hcErr;
            }
            _ATLCATCHALL()
            {
                return HTTP_FAIL;
            }

            pRequestInfo->pfnHandleRequest = &IRequestHandler::HandleRequest;
        }

        if (pRequestInfo)
        {
            if (!hcErr)
            {
                if (pRequestInfo->pServerContext == NULL)
                    pRequestInfo->pServerContext = &serverContext;

                _ATLTRY
                {
                    ATLASSERT(pRequestInfo->pfnHandleRequest != NULL);
                    hcErr = (pRequestInfo->pHandler->*pRequestInfo->pfnHandleRequest)(pRequestInfo, pServiceProvider);
                }
                _ATLCATCHALL()
                {
                    hcErr = HTTP_FAIL;
                }

                if (pRequestInfo->pServerContext == &serverContext)
                    pRequestInfo->pServerContext = NULL;

#ifdef _DEBUG
                // must use ATLSRV_INIT_USEASYNC to use ASYNC returns
                if (IsAsyncStatus(hcErr))
                    ATLASSERT(bAsyncAllowed);
#endif

                if (IsAsyncStatus(hcErr))
                {
                    ATLASSERT(pState); // state is required for async
                    if (IsAsyncContinueStatus(hcErr))
                    {
                        _pState->pIncludeInfo = pRequestInfo;
                        pRequestInfo->dwRequestState = ATLSRV_STATE_CONTINUE;
                    }
                    else if (IsAsyncDoneStatus(hcErr))
                        m_spExtension->FreeRequest(pRequestInfo);
                }
                else
                    m_spExtension->FreeRequest(pRequestInfo);
            }
        }
        else
            hcErr = HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);

        return hcErr;
    }
}; // class CHtmlStencil


__declspec(selectany) CCRTHeap CStencil::m_crtHeap;

// 
// CHtmlTagReplacer
// This class manages CStencil based objects for HTTP requests. This class will retrieve
// CStencil based objects from the stencil cache, store CStencil based objects in the
// stencil cache and allocate and initialize CStencil based objects on a per reqeust
// basis. Typically, one instance of this class is created for each HTTP request. The
// instance is destroyed once the request has been completed.
template <class THandler, class StencilType=CHtmlStencil>
class CHtmlTagReplacer : 
    public ITagReplacerImpl<THandler>
{
protected:
    typedef StencilType StencilType;

    CSimpleArray<HINSTANCE> m_hInstHandlers;
    typedef CAtlMap<CStringA, IRequestHandler*, CStringElementTraits<CStringA> > mapType;
    mapType m_Handlers;
    StencilType *m_pLoadedStencil;
    WORD m_nCodePage;
    CComPtr<IStencilCache> m_spStencilCache;

    AtlServerRequest m_RequestInfo;

public:
    // public members

    CHtmlTagReplacer() throw() :
      m_pLoadedStencil(NULL)
    {
        memset(&m_RequestInfo, 0x00, sizeof(m_RequestInfo));
        m_nCodePage = CP_THREAD_ACP;
    }

    ~CHtmlTagReplacer() throw()
    {
        // you should call FreeHandlers before
        // the object is destructed
        ATLASSERT(m_hInstHandlers.GetSize() == 0);
    }

    HTTP_CODE Initialize(AtlServerRequest *pRequestInfo, IHttpServerContext *pSafeSrvCtx=NULL) throw(...)
    {
        CComPtr<IServiceProvider> spServiceProvider;
        THandler *pT = static_cast<THandler*>(this);
        HRESULT hr = pT->GetContext(__uuidof(IServiceProvider), (void **)&spServiceProvider);
        if (FAILED(hr))
            return HTTP_FAIL;

        spServiceProvider->QueryService(__uuidof(IStencilCache), __uuidof(IStencilCache), (void **) &m_spStencilCache);
        if (!m_spStencilCache)
        {
            ATLASSERT(FALSE);
            return HTTP_FAIL;
        }

        m_RequestInfo.cbSize = sizeof(m_RequestInfo);
        m_RequestInfo.pServerContext = pSafeSrvCtx;
        m_RequestInfo.pUserData = pRequestInfo->pUserData;

        return HTTP_SUCCESS;
    }

    HTTP_CODE LoadStencilResource(
        HINSTANCE hInstResource,
        LPCSTR szResourceID,
        LPCSTR szResourceType = NULL, LPCSTR szStencilName=NULL) throw(...)
    {
        if (!szResourceType)
            szResourceType = (LPCSTR) (RT_HTML);
        // look up stencil in cache
        HTTP_CODE hcErr = HTTP_SUCCESS;

        // check the cache first
        StencilType *pStencil = FindCacheStencil(szStencilName ? szStencilName : szResourceID);
        if (!pStencil)
        {
            // create a new stencil
            pStencil = GetNewCacheStencil();
            THandler *pT = static_cast<THandler*>(this);
            LPCSTR szFileName = pT->m_spServerContext->GetScriptPathTranslated();

            if (!szFileName)
                return HTTP_FAIL;

            pStencil->SetBaseDirFromFile(szFileName);
            if (!pStencil)
                return HTTP_ERROR(500,ISE_SUBERR_OUTOFMEM);
        
            // load the stencil and parse its replacements
            if (HTTP_SUCCESS == pStencil->LoadFromResource(hInstResource, 
                                            szResourceID, szResourceType))
            {
                _ATLTRY
                {
                    if (!pStencil->ParseReplacements(static_cast<ITagReplacer*>(this),
                                pStencil->GetBufferStart(), pStencil->GetBufferEnd()))
                            return HTTP_ERROR(500, ISE_SUBERR_BADSRF);

                    hcErr = FinishLoadStencil(pStencil, NULL);
                    if (!hcErr)
                    {
                        pStencil->FinishParseReplacements();
                    }
                }
                _ATLCATCHALL()
                {
                    return HTTP_FAIL;
                }
            }
            else
            {
                hcErr = HTTP_FAIL;
            }

            // if everything went OK, put the stencil in the stencil cache.
            if (!hcErr)
            {
                hcErr = CacheStencil(szStencilName ? szStencilName : szResourceID, pStencil);
            }
                
            if (pStencil && hcErr) // something went wrong, free the stencil data
                FreeCacheStencil(pStencil);
        }
        else
        {
            hcErr = FinishLoadStencil(pStencil);
        }

        return hcErr;
    }

    HTTP_CODE LoadStencilResource(HINSTANCE hInstResource, UINT nID, LPCSTR szResourceType = NULL) throw(...)
    {
        if (!szResourceType)
            szResourceType = (LPCSTR) RT_HTML;
        char szName[80];
        sprintf(szName, "%p/%u", hInstResource, nID);
        return LoadStencilResource(hInstResource, MAKEINTRESOURCEA(nID), szResourceType, szName);
    }

    HTTP_CODE LoadStencil(LPCSTR szFileName, IHttpRequestLookup * pLookup = NULL) throw(...)
    {
        if (!szFileName)
        {
            return HTTP_FAIL;
        }

        HTTP_CODE hcErr = HTTP_FAIL;
        // try to find the stencil in the cache
        StencilType *pStencil = FindCacheStencil(szFileName);

        if (!pStencil)
        {
            // not in cache. Create a new one
            pStencil = GetNewCacheStencil();
            if (!pStencil)
            {
                return HTTP_ERROR(500, ISE_SUBERR_OUTOFMEM); // out of memory!
            }

            pStencil->SetBaseDirFromFile(szFileName);

            // finish loading
            hcErr = pStencil->LoadFile(szFileName);
            if ( !hcErr )
            {
                _ATLTRY
                {
                    if (!pStencil->ParseReplacements(static_cast<ITagReplacer*>(this),
                                pStencil->GetBufferStart(), pStencil->GetBufferEnd()))
                            return HTTP_ERROR(500, ISE_SUBERR_BADSRF);

                    hcErr = FinishLoadStencil(pStencil, pLookup);
                    if (!hcErr)
                    {
                        pStencil->FinishParseReplacements();
                    }
                }
                _ATLCATCHALL()
                {
                    return HTTP_FAIL;
                }
            }

            // if everything is OK, cache the stencil
            if (!hcErr)
            {
                hcErr = CacheStencil(szFileName, pStencil);
            }
        
            if (pStencil && hcErr) // something went wrong, free stencil data
                FreeCacheStencil(pStencil);
        }
        else
        {
            hcErr = FinishLoadStencil(pStencil, pLookup);
        }
        return hcErr;
    }

    HTTP_CODE RenderStencil(IWriteStream* pStream, void* pState = NULL) throw(...)
    {
        if (!m_pLoadedStencil)
            return HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);

        WORD nCodePage = m_pLoadedStencil->GetCodePage();
        if (nCodePage != CP_ACP)
            m_nCodePage = nCodePage;

        HTTP_CODE hcErr = HTTP_FAIL;
        
        hcErr = m_pLoadedStencil->Render(static_cast<ITagReplacer*>(this),
                    pStream, pState);

        if (!IsAsyncStatus(hcErr) && m_pLoadedStencil->GetCacheItem())
            m_spStencilCache->ReleaseStencil(m_pLoadedStencil->GetCacheItem());

        return hcErr;
    }


    HTTP_CODE AddHandler(LPCSTR szName, IRequestHandler *pHandler, HINSTANCE hInstHandler) throw()
    {
        _ATLTRY
        {
            ATLASSERT(szName);
            ATLASSERT(pHandler);
            ATLASSERT(hInstHandler);
            HTTP_CODE hcErr = HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED);
            if (szName && *szName && pHandler)
            {
                if (m_Handlers.SetAt(szName, pHandler))
                {
                    if (hInstHandler && m_hInstHandlers.Add(hInstHandler))
                        hcErr = HTTP_SUCCESS;
                }
            }
            return hcErr;
        }
        _ATLCATCHALL()
        {
            return HTTP_FAIL;
        }
    }

    void SendHandlerError(LPCSTR szHandlerName) throw()
    {
#ifndef _ATL_STENCIL_SLIENT_ERRORS
            m_pStream->WriteStream("Handler ");
            m_pStream->WriteStream(szHandlerName);
            m_pStream->WriteStream(" was not found");
#endif
    }

//Implementation

    void FreeHandlers() throw(...)
    {
        POSITION pos = m_Handlers.GetStartPosition();
        while (pos)
        {
            m_Handlers.GetNextValue(pos)->Release();
        }
        m_Handlers.RemoveAll();
        
        int nLen = m_hInstHandlers.GetSize();
        THandler *pT = static_cast<THandler *>(this);
        CComPtr<IDllCache> spDllCache;
        pT->m_spServiceProvider->QueryService(__uuidof(IDllCache), __uuidof(IDllCache),
            (void **)&spDllCache);
        for (int i=0; i<nLen; i++)
        {
            spDllCache->Free(m_hInstHandlers[i]);
        }
        m_hInstHandlers.RemoveAll();
    }

    StencilType* GetNewCacheStencil() throw(...)
    {
        StencilType *pStencil = NULL;
        THandler *pT = static_cast<THandler *>(this);
        IAtlMemMgr *pMemMgr;
        if (FAILED(pT->m_spServiceProvider->QueryService(__uuidof(IAtlMemMgr), __uuidof(IAtlMemMgr), (void **)&pMemMgr)))
            pMemMgr = NULL;
        
        ATLTRY(pStencil = new StencilType(pMemMgr));
        if (pStencil != NULL)
            pStencil->Initialize(pT->m_spServiceProvider);
        return pStencil;
    }

    HTTP_CODE CacheStencil(
        LPCSTR szName, 
        StencilType* pStencilData) throw()
    {
        THandler *pT = static_cast<THandler *>(this);
        HRESULT hr = E_FAIL;

        HCACHEITEM hCacheItem = NULL;

        hr = m_spStencilCache->CacheStencil(szName,
                        pStencilData,
                        sizeof(StencilType*),
                        &hCacheItem,
                        pT->m_hInstHandler,
                        static_cast<IMemoryCacheClient*>(pStencilData));

        if (hr == S_OK && hCacheItem)
            pStencilData->SetCacheItem(hCacheItem);

        return  (hr == S_OK) ? HTTP_SUCCESS : HTTP_FAIL;
    }

    StencilType *FindCacheStencil(LPCSTR szName) throw()
    {
        if (!szName || !m_spStencilCache)
            return NULL;

        StencilType *pStencilData = NULL;

        HCACHEITEM hStencil;

        if (m_spStencilCache->LookupStencil(szName, &hStencil) != S_OK)
            return NULL;

        m_spStencilCache->GetStencil(hStencil, reinterpret_cast<void **>(&pStencilData));

        return pStencilData;
    }

    void FreeCacheStencil(StencilType* pStencilData) throw()
    {
        CComPtr<IMemoryCacheClient> spCacheClient;

        if (m_spStencilCache->QueryInterface(__uuidof(IMemoryCacheClient), (void **) &spCacheClient) == S_OK)
            spCacheClient->Free(pStencilData);
    }

    HTTP_CODE GetHandlerOffset(LPCSTR szHandlerName, DWORD* pdwOffset) throw()
    {
        if (!pdwOffset)
            return HTTP_FAIL;

        mapType::CPair *p = m_Handlers.Lookup(szHandlerName);
        if (p)
        {
            DWORD dwIndex = 0;
            POSITION pos = m_Handlers.GetStartPosition();
            while (pos)
            {
                const mapType::CPair *p1 = m_Handlers.GetNext(pos);
                if (p1 == p)
                {
                    *pdwOffset = dwIndex;
                    return HTTP_SUCCESS;
                }
                dwIndex++;
            }
            ATLASSERT(FALSE);
            return HTTP_SUCCESS;
        }
        *pdwOffset = 0;
        return HTTP_FAIL;
    }

    HTTP_CODE GetReplacementObject(DWORD dwObjOffset, ITagReplacer **ppReplacer) throw(...)
    {
        HRESULT hr = E_FAIL;

        POSITION pos = m_Handlers.GetStartPosition();
        for (DWORD dwIndex=0; dwIndex < dwObjOffset; dwIndex++)
            m_Handlers.GetNext(pos);

        ATLASSERT(pos != NULL);

        IRequestHandler *pHandler = NULL;
        pHandler = m_Handlers.GetValueAt(pos);

        ATLASSERT(pHandler != NULL);
 
        hr = pHandler->QueryInterface(__uuidof(ITagReplacer), (void**)ppReplacer);

        if (hr != S_OK)
            return HTTP_FAIL;

        return HTTP_SUCCESS;
    }

    // This is where we would actually load any extra request
    // handlers the HTML stencil might have parsed for us.
    HTTP_CODE FinishLoadStencil(StencilType *pStencil, IHttpRequestLookup * pLookup = NULL) throw(...)
    {
        THandler *pT = static_cast<THandler *>(this);
        ATLASSERT(pStencil);
        if (!pStencil)
            return HTTP_ERROR(500, ISE_SUBERR_UNEXPECTED); // unexpected condition
        m_pLoadedStencil = pStencil;
        //load extra handlers if there are any
        StencilType::mapType *pExtraHandlersMap = 
            pStencil->GetExtraHandlers();
        
        if (pExtraHandlersMap)
        {
            POSITION pos = pExtraHandlersMap->GetStartPosition();
            CStringA name;
            CStringPair path;
            IRequestHandler *pHandler;
            HINSTANCE hInstHandler;
            while(pos)
            {
                pExtraHandlersMap->GetNextAssoc(pos, name, path);
                pHandler = NULL;
                hInstHandler = NULL;
                HTTP_CODE hcErr = pT->m_spExtension->LoadRequestHandler(path.strDllPath, path.strHandlerName,
                    pT->m_spServerContext,
                    &hInstHandler,
                    &pHandler);
                if (!hcErr)
                {
                    _ATLTRY
                    {
                        //map the name to the pointer to request handler
                        m_Handlers.SetAt(name, pHandler);
                        //store HINSTANCE of handler
                        m_hInstHandlers.Add(hInstHandler);
					}
                    _ATLCATCHALL()
                    {
                        return HTTP_FAIL;
                    }

                    if (pLookup)
                    {
						hcErr = pHandler->InitializeChild(&m_RequestInfo, pT->m_spServiceProvider, pLookup);
                        if (hcErr != HTTP_SUCCESS)
                            return hcErr;
                    }
    
                }
                else
                    return hcErr;
            }
        }
        return HTTP_SUCCESS;
    }
}; // class CHtmlTagReplacer


// CRequestHandlerT
// This is the base class for all user request handlers. This class implements
// the IReplacementHandler interface whose methods will be called to render HTML 
// into a stream. The stream will be returned as the HTTP response upon completion
// of the HTTP request.
template <	class THandler,
			class ThreadModel=CComSingleThreadModel,
			class TagReplacerType=CHtmlTagReplacer<THandler>
         >
class CRequestHandlerT : 
    public TagReplacerType,
    public CComObjectRootEx<ThreadModel>,
    public IRequestHandlerImpl<THandler>
{
protected:
    CStencilState m_state;
    CComObjectStackEx<CIDServerContext> m_SafeSrvCtx;
	typedef CRequestHandlerT<THandler, ThreadModel, TagReplacerType> _requestHandler;
   
public:
    BEGIN_COM_MAP(_requestHandler)
        COM_INTERFACE_ENTRY(IRequestHandler)
        COM_INTERFACE_ENTRY(ITagReplacer)
    END_COM_MAP()

    // public CRequestHandlerT members
    CHttpResponse m_HttpResponse;
    CHttpRequest m_HttpRequest;
    ATLSRV_REQUESTTYPE m_dwRequestType;
    AtlServerRequest* m_pRequestInfo;

    CRequestHandlerT() throw()
    {
        m_hInstHandler = NULL;
        m_dwAsyncFlags = 0;
        m_pRequestInfo = NULL;
    }

    ~CRequestHandlerT() throw()
    {
        FreeHandlers(); // free handlers held by CTagReplacer
    }

    void ClearResponse() throw()
    {
        m_HttpResponse.ClearResponse();
    }
    // Where user initialization should take place
    HTTP_CODE ValidateAndExchange() throw()
    {
        return HTTP_SUCCESS; // continue processing request
    }

    // Where user Uninitialization should take place
    HTTP_CODE Uninitialize(HTTP_CODE hcError) throw()
    {
        return hcError;
    }

    HTTP_CODE InitializeInternal(AtlServerRequest *pRequestInfo, IServiceProvider *pProvider) throw()
    {
		// Initialize our internal references to required services
        m_pRequestInfo = pRequestInfo;
        m_state.pParentInfo = pRequestInfo;
        m_hInstHandler = pRequestInfo->hInstDll;
        m_spServerContext = pRequestInfo->pServerContext;
        m_spServiceProvider = pProvider;
        return HTTP_SUCCESS;
    }

    HTTP_CODE InitializeHandler(
        AtlServerRequest *pRequestInfo, 
        IServiceProvider *pProvider) throw(...)
    {
		HTTP_CODE hcErr = HTTP_FAIL;
        ATLASSERT(pRequestInfo);
        ATLASSERT(pProvider);

        THandler* pT = static_cast<THandler*>(this);
        hcErr = pT->InitializeInternal(pRequestInfo, pProvider);
        if (!hcErr)
		{
			m_HttpResponse.Initialize(m_spServerContext);
			hcErr = pT->CheckValidRequest();
			if (!hcErr)
			{
				hcErr = HTTP_FAIL;
				if (m_HttpRequest.Initialize(m_spServerContext, 
											 pT->MaxFormSize(),
											 pT->FormFlags()))
				{
					if (m_SafeSrvCtx.Initialize(&m_HttpResponse, &m_HttpRequest))
					{
						hcErr = TagReplacerType::Initialize(pRequestInfo, &m_SafeSrvCtx);
						if (!hcErr)
						{
							hcErr = pT->ValidateAndExchange();
						}
					}
				}
			}
		}
        return hcErr;
    }

    HTTP_CODE InitializeChild(
        AtlServerRequest *pRequestInfo, 
        IServiceProvider *pProvider, 
        IHttpRequestLookup *pRequestLookup) throw(...)
    {
        ATLASSERT(pRequestInfo);
        ATLASSERT(pProvider);

        THandler *pT = static_cast<THandler*>(this);
        HTTP_CODE hcErr = pT->InitializeInternal(pRequestInfo, pProvider);
        if (hcErr)
            return hcErr;

        if (pRequestLookup)
        {
            // initialize with the pRequestLookup
            m_HttpResponse.Initialize(pRequestLookup);

            // REVIEW: Initialize with the IHttpServerContext if it exists
            // the only time this is different than the previous call to 
            // initialize is if the user passes a different IHttpServerContext
            // in pRequestInfo than the one extracted from pRequestLookup.
            if (m_spServerContext)
                m_HttpResponse.Initialize(m_spServerContext);
            hcErr = pT->CheckValidRequest();
            if (hcErr)
                return hcErr;

            // initialize with the pRequestLookup to chain query parameters
            m_HttpRequest.Initialize(pRequestLookup);

            // initialize with the m_spServerContext to get additional query params
            // if they exist.
            if (m_spServerContext)
                m_HttpRequest.Initialize(m_spServerContext);
        }

        m_HttpResponse.SetBufferOutput(false); // child cannot buffer

        // initialize the safe server context
        // REVIEW: necessary?
        if (!m_SafeSrvCtx.Initialize(&m_HttpResponse, &m_HttpRequest))
            return HTTP_FAIL;
        hcErr = TagReplacerType::Initialize(pRequestInfo, &m_SafeSrvCtx);
        if (hcErr)
            return hcErr;

        return pT->ValidateAndExchange();
    }

    // HandleRequest is called to perform default processing of HTTP requests. Users
    // can override this function in their derived classes if they need to perform
    // specific initialization prior to processing this request or want to change the
    // way the request is processed.
    HTTP_CODE HandleRequest(
        AtlServerRequest *pRequestInfo,
        IServiceProvider* /*pServiceProvider*/) throw(...)
    {
        ATLASSERT(pRequestInfo);

        THandler *pT = static_cast<THandler *>(this);
        HTTP_CODE hcErr = HTTP_SUCCESS;

        if (pRequestInfo->dwRequestState == ATLSRV_STATE_BEGIN)
        {
            m_dwRequestType = pRequestInfo->dwRequestType;

            if (pRequestInfo->dwRequestType==ATLSRV_REQUEST_STENCIL)
            {
                LPCSTR szFileName = pRequestInfo->pServerContext->GetScriptPathTranslated();
                hcErr = HTTP_FAIL;
                if (szFileName)
                    hcErr = pT->LoadStencil(szFileName, static_cast<IHttpRequestLookup *>(&m_HttpRequest));
            }
        }
        else if (pRequestInfo->dwRequestState == ATLSRV_STATE_CONTINUE)
            m_HttpResponse.ClearContent();

#ifdef ATL_DEBUG_STENCILS
        if (m_pLoadedStencil && !m_pLoadedStencil->ParseSuccessful())
        {
            // An error or series of errors occurred in parsing the stencil
            m_pLoadedStencil->RenderErrors(static_cast<IWriteStream*>(&m_HttpResponse));
        }
#endif

        if (hcErr == HTTP_SUCCESS && m_pLoadedStencil)
        {
            // if anything other than HTTP_SUCCESS is returned during
            // the rendering of replacement tags, we return that value
            // here.
            hcErr = pT->RenderStencil(static_cast<IWriteStream*>(&m_HttpResponse), &m_state);

            if (hcErr == HTTP_SUCCESS && !m_HttpResponse.Flush(TRUE))
                hcErr = HTTP_FAIL;
        }

        if (IsAsyncFlushStatus(hcErr))
        {
            pRequestInfo->pszBuffer = LPCSTR(m_HttpResponse.m_strContent);
            pRequestInfo->dwBufferLen = m_HttpResponse.m_strContent.GetLength();
        }

        if (pRequestInfo->dwRequestState == ATLSRV_STATE_BEGIN || IsAsyncDoneStatus(hcErr))
            return pT->Uninitialize(hcErr);

        else if (!IsAsyncStatus(hcErr))
            m_HttpResponse.ClearContent();

        return hcErr;
    }

    HTTP_CODE ServerTransferRequest(LPCSTR szRequest, bool bContinueAfterTransfer=false,
        int nCodePage = 0, void *pState = NULL) throw(...)
    {
        return m_spExtension->TransferRequest(
                m_pRequestInfo,
                m_spServiceProvider,
                static_cast<IWriteStream*>(&m_HttpResponse),
                static_cast<IHttpRequestLookup*>(&m_HttpRequest),
                szRequest,
                nCodePage == 0 ? m_nCodePage : nCodePage,
                bContinueAfterTransfer,
                pState);
    }

    inline DWORD MaxFormSize() throw()
    {
        return DEFAULT_MAX_FORM_SIZE;
    }

    inline DWORD FormFlags() throw()
    {
        return ATL_FORM_FLAG_IGNORE_FILES;
    }

    // Override this function to check if the request
    // is valid. This function is called after m_HttpResponse
    // has been initialized, so you can use it if you need
    // to return an error to the client. This is also a
    // good place to initialize any internal class data needed
    // to handle the request. CRequestHandlerT::CheckValidRequest
    // is called after CRequestHandlerT::InitializeInternal is 
    // called, so your override of this method will have access to
    // m_pRequestInfo (this request's AtlServerRequest structure),
    // m_hInstHandler (the HINSTANCE of this handler dll),
    // m_spServerContext (the IHttpServerContext interface for this request),
    // m_spServiceProvider (the IServiceProvider interface for this request).
    // You should call CRequestHandlerT::CheckValidRequest in your override
    // if you override this function.
    // 
    // Note that m_HttpRequest has not been initialized, so
    // you cannot use it.  This function is intended to
    // do simple checking throught IHttpServerContext to avoid
    // expensive initialization of m_HttpRequest. 
    HTTP_CODE CheckValidRequest() throw()
    {
        LPCSTR szMethod = NULL;
        ATLASSERT(m_pRequestInfo);
        szMethod = m_pRequestInfo->pServerContext->GetRequestMethod();
        if (strcmp(szMethod, "GET") && strcmp(szMethod, "POST") && strcmp(szMethod, "HEAD"))
            return HTTP_NOT_IMPLEMENTED;

        return HTTP_SUCCESS;
    }

    HRESULT GetContext(REFIID riid, void** ppv) throw()
    {
        if (!ppv)
            return E_POINTER;
        if (InlineIsEqualGUID(riid, __uuidof(IHttpServerContext)))
        {
            return m_spServerContext.CopyTo((IHttpServerContext **)ppv);
        }
        if (InlineIsEqualGUID(riid, __uuidof(IHttpRequestLookup)))
        {
            *ppv = static_cast<IHttpRequestLookup*>(&m_HttpRequest);
            m_HttpRequest.AddRef();
            return S_OK;
        }
        if (InlineIsEqualGUID(riid, __uuidof(IServiceProvider)))
        {
            *ppv = m_spServiceProvider;
            m_spServiceProvider.p->AddRef();
            return S_OK;
        }
        return E_NOINTERFACE;
    }

    template <typename Interface>
    HRESULT GetContext(Interface** ppInterface) throw()
    {
        return GetContext(__uuidof(Interface), reinterpret_cast<void**>(ppInterface));
    }
}; // class CRequestHandlerT

} // namespace ATL

#pragma warning( pop )

#endif // __ATLSTENCIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atlmfc\atlwin.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLWIN_H__
#define __ATLWIN_H__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLBASE_H__
	#error atlwin.h requires atlbase.h to be included first
#endif

#include <atlbase.inl>

#include <commctrl.h>
#include <atlsimpstr.h>

// protect template members from windowsx.h macros
#ifdef _INC_WINDOWSX
#undef SubclassWindow
#endif //_INC_WINDOWSX

#ifdef SetWindowLongPtrA
#undef SetWindowLongPtrA
inline LONG_PTR SetWindowLongPtrA( HWND hWnd, int nIndex, LONG_PTR dwNewLong )
{
	return( ::SetWindowLongA( hWnd, nIndex, LONG( dwNewLong ) ) );
}
#endif

#ifdef SetWindowLongPtrW
#undef SetWindowLongPtrW
inline LONG_PTR SetWindowLongPtrW( HWND hWnd, int nIndex, LONG_PTR dwNewLong )
{
	return( ::SetWindowLongW( hWnd, nIndex, LONG( dwNewLong ) ) );
}
#endif

#ifdef GetWindowLongPtrA
#undef GetWindowLongPtrA
inline LONG_PTR GetWindowLongPtrA( HWND hWnd, int nIndex )
{
	return( ::GetWindowLongA( hWnd, nIndex ) );
}
#endif

#ifdef GetWindowLongPtrW
#undef GetWindowLongPtrW
inline LONG_PTR GetWindowLongPtrW( HWND hWnd, int nIndex )
{
	return( ::GetWindowLongW( hWnd, nIndex ) );
}
#endif

//REVIEW: Just to fix VSEE
#pragma push_macro("min")
#pragma push_macro("max")
#undef min
#undef max
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#define max(a,b)            (((a) > (b)) ? (a) : (b))

//#ifndef _ATL_DLL_IMPL
namespace ATL
{
//#endif

struct _ATL_WNDCLASSINFOA;
struct _ATL_WNDCLASSINFOW;

ATLAPI_(ATOM) AtlWinModuleRegisterWndClassInfoA(_ATL_WIN_MODULE* pWinModule, _ATL_BASE_MODULE* pBaseModule, _ATL_WNDCLASSINFOA* p, WNDPROC* pProc);
inline ATOM AtlModuleRegisterWndClassInfoA(_ATL_MODULE* /*pM*/, _ATL_WNDCLASSINFOA* p, WNDPROC* pProc)
{
	return AtlWinModuleRegisterWndClassInfoA(&_AtlWinModule, &_AtlBaseModule, p, pProc);
}

ATLAPI_(ATOM) AtlWinModuleRegisterWndClassInfoW(_ATL_WIN_MODULE* pWinModule, _ATL_BASE_MODULE* pBaseModule, _ATL_WNDCLASSINFOW* p, WNDPROC* pProc);
inline ATOM AtlModuleRegisterWndClassInfoW(_ATL_MODULE* /*pM*/, _ATL_WNDCLASSINFOW* p, WNDPROC* pProc)
{
	return AtlWinModuleRegisterWndClassInfoW(&_AtlWinModule, &_AtlBaseModule, p, pProc);
}

ATLINLINE ATLAPI_(ATOM) AtlWinModuleRegisterClassExA(_ATL_WIN_MODULE* pWinModule, const WNDCLASSEXA *lpwc);
inline ATOM AtlModuleRegisterClassExA(_ATL_MODULE* /*pM*/, const WNDCLASSEXA *lpwc)
{
	return AtlWinModuleRegisterClassExA(&_AtlWinModule, lpwc);
}

ATLAPI_(ATOM) AtlWinModuleRegisterClassExW(_ATL_WIN_MODULE* pWinModule, const WNDCLASSEXW *lpwc);
inline ATOM AtlModuleRegisterClassExW(_ATL_MODULE* /*pM*/, const WNDCLASSEXW *lpwc)
{
	return AtlWinModuleRegisterClassExW(&_AtlWinModule, lpwc);
}


#ifdef UNICODE
#define AtlWinModuleRegisterWndClassInfo AtlWinModuleRegisterWndClassInfoW
#define AtlWinModuleRegisterClassEx AtlWinModuleRegisterClassExW
#define AtlModuleRegisterWndClassInfo AtlModuleRegisterWndClassInfoW
#define AtlModuleRegisterClassEx AtlModuleRegisterClassExW
#else
#define AtlWinModuleRegisterWndClassInfo AtlWinModuleRegisterWndClassInfoA
#define AtlWinModuleRegisterClassEx AtlWinModuleRegisterClassExA
#define AtlModuleRegisterWndClassInfo AtlModuleRegisterWndClassInfoA
#define AtlModuleRegisterClassEx AtlModuleRegisterClassExA
#endif


#define HIMETRIC_PER_INCH   2540
#define MAP_PIX_TO_LOGHIM(x,ppli)   MulDiv(HIMETRIC_PER_INCH, (x), (ppli))
#define MAP_LOGHIM_TO_PIX(x,ppli)   MulDiv((ppli), (x), HIMETRIC_PER_INCH)

ATLAPI_(HDC) AtlCreateTargetDC(HDC hdc, DVTARGETDEVICE* ptd);
ATLAPI_(void) AtlHiMetricToPixel(const SIZEL * lpSizeInHiMetric, LPSIZEL lpSizeInPix);
ATLAPI_(void) AtlPixelToHiMetric(const SIZEL * lpSizeInPix, LPSIZEL lpSizeInHiMetric);

#ifndef GET_X_LPARAM
#define GET_X_LPARAM(lParam)	((int)(short)LOWORD(lParam))
#endif
#ifndef GET_Y_LPARAM
#define GET_Y_LPARAM(lParam)	((int)(short)HIWORD(lParam))
#endif


//#ifndef _ATL_DLL_IMPL
}; //namespace ATL
//#endif

namespace ATL
{

struct _ATL_WNDCLASSINFOA
{
	WNDCLASSEXA m_wc;
	LPCSTR m_lpszOrigName;
	WNDPROC pWndProc;
	LPCSTR m_lpszCursorID;
	BOOL m_bSystemCursor;
	ATOM m_atom;
	CHAR m_szAutoName[5+sizeof(void*)*CHAR_BIT];
	ATOM Register(WNDPROC* p)
	{
		return AtlWinModuleRegisterWndClassInfoA(&_AtlWinModule, &_AtlBaseModule, this, p);
	}
};

struct _ATL_WNDCLASSINFOW
{
	WNDCLASSEXW m_wc;
	LPCWSTR m_lpszOrigName;
	WNDPROC pWndProc;
	LPCWSTR m_lpszCursorID;
	BOOL m_bSystemCursor;
	ATOM m_atom;
	WCHAR m_szAutoName[5+sizeof(void*)*CHAR_BIT];
	ATOM Register(WNDPROC* p)
	{
		return AtlWinModuleRegisterWndClassInfoW(&_AtlWinModule, &_AtlBaseModule, this, p);
	}
};

};  // namespace ATL

namespace ATL
{

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

class CWindow;
#ifndef _ATL_NO_HOSTING
template <class TBase = CWindow> class CAxWindowT;
template <class TBase = CWindow> class CAxWindow2T;
#endif //!_ATL_NO_HOSTING
class CMessageMap;
class CDynamicChain;
typedef _ATL_WNDCLASSINFOA CWndClassInfoA;
typedef _ATL_WNDCLASSINFOW CWndClassInfoW;
#ifdef UNICODE
#define CWndClassInfo CWndClassInfoW
#else
#define CWndClassInfo CWndClassInfoA
#endif
template <class T, class TBase = CWindow, class TWinTraits = CControlWinTraits> class CWindowImpl;
template <class T, class TBase = CWindow, class TWinTraits = CControlWinTraits> class CWindowWithReflectorImpl;
template <class T, class TBase = CWindow> class CDialogImpl;
#ifndef _ATL_NO_HOSTING
template <class T, class TBase = CWindow> class CAxDialogImpl;
#endif //!_ATL_NO_HOSTING
template <WORD t_wDlgTemplateID, BOOL t_bCenter = TRUE> class CSimpleDialog;
template <class TBase = CWindow, class TWinTraits = CControlWinTraits> class CContainedWindowT;

/////////////////////////////////////////////////////////////////////////////
// Helper functions for cracking dialog templates

class _DialogSplitHelper
{
public:
	// Constants used in DLGINIT resources for OLE control containers
	// NOTE: These are NOT real Windows messages they are simply tags
	// used in the control resource and are never used as 'messages'
	enum
	{
		ATL_WM_OCC_LOADFROMSTREAM = 0x0376,
		ATL_WM_OCC_LOADFROMSTORAGE = 0x0377,
		ATL_WM_OCC_INITNEW = 0x0378,
		ATL_WM_OCC_LOADFROMSTREAM_EX = 0x037A,
		ATL_WM_OCC_LOADFROMSTORAGE_EX = 0x037B,
		ATL_DISPID_DATASOURCE = 0x80010001,
		ATL_DISPID_DATAFIELD = 0x80010002,
	};

//local struct used for implementation
#pragma pack(push, 1)
	struct DLGINITSTRUCT
	{
		WORD nIDC;
		WORD message;
		DWORD dwSize;
	};
	struct DLGTEMPLATEEX
	{
		WORD dlgVer;
		WORD signature;
		DWORD helpID;
		DWORD exStyle;
		DWORD style;
		WORD cDlgItems;
		short x;
		short y;
		short cx;
		short cy;

		// Everything else in this structure is variable length,
		// and therefore must be determined dynamically

		// sz_Or_Ord menu;			// name or ordinal of a menu resource
		// sz_Or_Ord windowClass;	// name or ordinal of a window class
		// WCHAR title[titleLen];	// title string of the dialog box
		// short pointsize;			// only if DS_SETFONT is set
		// short weight;			// only if DS_SETFONT is set
		// short bItalic;			// only if DS_SETFONT is set
		// WCHAR font[fontLen];		// typeface name, if DS_SETFONT is set
	};
	struct DLGITEMTEMPLATEEX
	{
		DWORD helpID;
		DWORD exStyle;
		DWORD style;
		short x;
		short y;
		short cx;
		short cy;
		DWORD id;

		// Everything else in this structure is variable length,
		// and therefore must be determined dynamically

		// sz_Or_Ord windowClass;	// name or ordinal of a window class
		// sz_Or_Ord title;			// title string or ordinal of a resource
		// WORD extraCount;			// bytes following creation data
	};
#pragma pack(pop)

	static BOOL IsDialogEx(const DLGTEMPLATE* pTemplate)
	{
		return ((DLGTEMPLATEEX*)pTemplate)->signature == 0xFFFF;
	}

	inline static WORD& DlgTemplateItemCount(DLGTEMPLATE* pTemplate)
	{
		if (IsDialogEx(pTemplate))
			return reinterpret_cast<DLGTEMPLATEEX*>(pTemplate)->cDlgItems;
		else
			return pTemplate->cdit;
	}

	inline static const WORD& DlgTemplateItemCount(const DLGTEMPLATE* pTemplate)
	{
		if (IsDialogEx(pTemplate))
			return reinterpret_cast<const DLGTEMPLATEEX*>(pTemplate)->cDlgItems;
		else
			return pTemplate->cdit;
	}

	static DLGITEMTEMPLATE* FindFirstDlgItem(const DLGTEMPLATE* pTemplate)
	{
		BOOL bDialogEx = IsDialogEx(pTemplate);

		WORD* pw;
		DWORD dwStyle;
		if (bDialogEx)
		{
			pw = (WORD*)((DLGTEMPLATEEX*)pTemplate + 1);
			dwStyle = ((DLGTEMPLATEEX*)pTemplate)->style;
		}
		else
		{
			pw = (WORD*)(pTemplate + 1);
			dwStyle = pTemplate->style;
		}

		// Check for presence of menu and skip it if there is one
		// 0x0000 means there is no menu
		// 0xFFFF means there is a menu ID following
		// Everything else means that this is a NULL terminated Unicode string
		// which identifies the menu resource
		if (*pw == 0xFFFF)
			pw += 2;				// Has menu ID, so skip 2 words
		else
			while (*pw++);			// Either No menu, or string, skip past terminating NULL

		// Check for presence of class name string
		// 0x0000 means "Use system dialog class name"
		// 0xFFFF means there is a window class (atom) specified
		// Everything else means that this is a NULL terminated Unicode string
		// which identifies the menu resource
		if (*pw == 0xFFFF)
			pw += 2;				// Has class atom, so skip 2 words
		else
			while (*pw++);			// Either No class, or string, skip past terminating NULL

		// Skip caption string
		while (*pw++);

		// If we have DS_SETFONT, there is extra font information which we must now skip
		if (dwStyle & DS_SETFONT)
		{
			// If it is a regular DLGTEMPLATE there is only a short for the point size
			// and a string specifying the font (typefacename).  If this is a DLGTEMPLATEEX
			// then there is also the font weight, and bItalic which must be skipped
			if (bDialogEx)
				pw += 3;			// Skip font size, weight, (italic, charset)
			else
				pw += 1;			// Skip font size
			while (*pw++);			// Skip typeface name
		}

		// Dword-align and return
		return (DLGITEMTEMPLATE*)(((DWORD_PTR)pw + 3) & ~3);
	}

	// Given the current dialog item and whether this is an extended dialog
	// return a pointer to the next DLGITEMTEMPLATE*
	static DLGITEMTEMPLATE* FindNextDlgItem(DLGITEMTEMPLATE* pItem, BOOL bDialogEx)
	{
		WORD* pw;

		// First skip fixed size header information, size of which depends
		// if this is a DLGITEMTEMPLATE or DLGITEMTEMPLATEEX
		if (bDialogEx)
			pw = (WORD*)((DLGITEMTEMPLATEEX*)pItem + 1);
		else
			pw = (WORD*)(pItem + 1);

		if (*pw == 0xFFFF)			// Skip class name ordinal or string
			pw += 2; // (WORDs)
		else
			while (*pw++);

		if (*pw == 0xFFFF)			// Skip title ordinal or string
			pw += 2; // (WORDs)
		else
			while (*pw++);

		WORD cbExtra = *pw++;		// Skip extra data

		// cbExtra includes the size WORD in DIALOG resource.
		if (cbExtra != 0 && !bDialogEx)
			cbExtra -= 2;

		// Dword-align and return
		return (DLGITEMTEMPLATE*)(((DWORD_PTR)pw + cbExtra + 3) & ~3);
	}

	// Find the initialization data (Stream) for the control specified by the ID
	// If found, return the pointer into the data and the length of the data
	static DWORD FindCreateData(DWORD dwID, BYTE* pInitData, BYTE** pData)
	{
		while (pInitData)
		{
			// Read the DLGINIT header
			WORD nIDC = *((UNALIGNED WORD*)pInitData);
			pInitData += sizeof(WORD);
			BYTE* pTemp = pInitData;
			WORD nMsg = *((UNALIGNED WORD*)pInitData);
			pInitData += sizeof(WORD);
			DWORD dwLen = *((UNALIGNED DWORD*)pInitData);
			pInitData += sizeof(DWORD);

			// If the header is for the control specified get the other info
			if (nIDC == dwID)
			{
				if (nMsg == (WORD)ATL_WM_OCC_INITNEW)
				{
					ATLASSERT(dwLen == 0);
					return 0;
				}
				*pData = pTemp;
				return dwLen + sizeof(WORD) + sizeof(DWORD);
			}

			// It's not the right control, skip past data
			pInitData += dwLen;
		}
		return 0;
	}

	static bool IsActiveXControl(DLGITEMTEMPLATE* pItem, BOOL bDialogEx)
	{
		LPWSTR pszClassName;
		pszClassName = bDialogEx ?
			(LPWSTR)(((DLGITEMTEMPLATEEX*)pItem) + 1) :
			(LPWSTR)(pItem + 1);
		if (pszClassName[0] == L'{')
			return true;
		return false;
	}

	// Convert MSDEV (MFC) style DLGTEMPLATE with controls to regular DLGTEMPLATE
	// Changing all ActiveX Controls to use ATL AxWin hosting code
	static DLGTEMPLATE* SplitDialogTemplate(DLGTEMPLATE* pTemplate, BYTE* /*pInitData*/)
	{
		// Calculate the size of the DLGTEMPLATE for allocating the new one
		DLGITEMTEMPLATE* pFirstItem = FindFirstDlgItem(pTemplate);
		ULONG_PTR cbHeader = (BYTE*)pFirstItem - (BYTE*)pTemplate;
		ULONG_PTR cbNewTemplate = cbHeader;

		BOOL bDialogEx = IsDialogEx(pTemplate);

		int iItem;
		int nItems = (int)DlgTemplateItemCount(pTemplate);
		LPWSTR pszClassName;
		BOOL bHasOleControls = FALSE;

		// Make first pass through the dialog template.  On this pass, we're
		// interested in determining:
		//    1. Does this template contain any ActiveX Controls?
		//    2. If so, how large a buffer is needed for a template containing
		//       only the non-OLE controls?

		DLGITEMTEMPLATE* pItem = pFirstItem;
		DLGITEMTEMPLATE* pNextItem = pItem;
		for (iItem = 0; iItem < nItems; iItem++)
		{
			pNextItem = FindNextDlgItem(pItem, bDialogEx);

			pszClassName = bDialogEx ?
				(LPWSTR)(((DLGITEMTEMPLATEEX*)pItem) + 1) :
				(LPWSTR)(pItem + 1);

			// Check if the class name begins with a '{'
			// If it does, that means it is an ActiveX Control in MSDEV (MFC) format
			if (pszClassName[0] == L'{')
			{
				// Item is an ActiveX control.
				bHasOleControls = TRUE;
			}
			else
			{
				// Item is not an ActiveX Control: make room for it in new template.
				cbNewTemplate += (BYTE*)pNextItem - (BYTE*)pItem;
			}

			pItem = pNextItem;
		}

		// No OLE controls were found, so there's no reason to go any further.
		if (!bHasOleControls)
			return pTemplate;

		// Copy entire header into new template.
		BYTE* pNew = (BYTE*)GlobalAlloc(GMEM_FIXED, cbNewTemplate);
		DLGTEMPLATE* pNewTemplate = (DLGTEMPLATE*)pNew;
		memcpy(pNew, pTemplate, cbHeader);
		pNew += cbHeader;

		// Initialize item count in new header to zero.
		DlgTemplateItemCount(pNewTemplate) = 0;

		pItem = pFirstItem;
		pNextItem = pItem;

		// Second pass through the dialog template.  On this pass, we want to:
		//    1. Copy all the non-OLE controls into the new template.
		for (iItem = 0; iItem < nItems; iItem++)
		{
			pNextItem = FindNextDlgItem(pItem, bDialogEx);

			pszClassName = bDialogEx ?
				(LPWSTR)(((DLGITEMTEMPLATEEX*)pItem) + 1) :
				(LPWSTR)(pItem + 1);

			if (pszClassName[0] != L'{')
			{
				// Item is not an OLE control: copy it to the new template.
				ULONG_PTR cbItem = (BYTE*)pNextItem - (BYTE*)pItem;
				ATLASSERT(cbItem >= (bDialogEx ?
					sizeof(DLGITEMTEMPLATEEX) :
					sizeof(DLGITEMTEMPLATE)));
				memcpy(pNew, pItem, cbItem);
				pNew += cbItem;

				// Incrememt item count in new header.
				++DlgTemplateItemCount(pNewTemplate);
			}

			pItem = pNextItem;
		}
		return pNewTemplate;
	}

	static HRESULT ParseInitData(IStream* pStream, BSTR* pLicKey)
	{
		*pLicKey = NULL;
		if(pStream == NULL)
			return S_OK;	// nothing to do

		ULONG uRead;
		HRESULT hr;

		WORD nMsg;
		hr = pStream->Read(&nMsg, sizeof(WORD), &uRead);
		if (FAILED(hr))
			return hr;

		DWORD dwLen;
		hr = pStream->Read(&dwLen, sizeof(DWORD), &uRead);
		if (FAILED(hr))
			return hr;
		
		DWORD cchLicKey;
		hr = pStream->Read(&cchLicKey, sizeof(DWORD), &uRead);
		if (FAILED(hr))
			return hr;
		
		if (cchLicKey > 0)
		{
			CComBSTR bstr(cchLicKey);
			if (bstr.Length() == 0)
				return E_OUTOFMEMORY;
			memset(bstr.m_str, 0, (cchLicKey + 1) * sizeof(OLECHAR));
			hr = pStream->Read(bstr.m_str, cchLicKey * sizeof(OLECHAR), &uRead);
			if (FAILED(hr))
				return hr;
			*pLicKey = bstr.Detach();
		}

		// Extended (DATABINDING) stream format is not supported,
		// we reject databinding info but preserve other information
		if (nMsg == (WORD)ATL_WM_OCC_LOADFROMSTREAM_EX ||
			nMsg == (WORD)ATL_WM_OCC_LOADFROMSTORAGE_EX)
		{
			// Read the size of the section
			ULONG cbOffset;
			hr = pStream->Read(&cbOffset, sizeof(ULONG), &uRead);
			if (FAILED(hr))
				return hr;
			BYTE pTemp[1000];
			cbOffset -= sizeof(ULONG);
			
			while (cbOffset > 0)
			{
				pStream->Read(pTemp, min(cbOffset, 1000), &uRead);
				cbOffset -= uRead;
			}
			return S_OK;
		}
		if (nMsg == (WORD)ATL_WM_OCC_LOADFROMSTREAM)
		{
			return S_OK;
		}
		return E_FAIL;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CWindow - client side for a Windows window

class CWindow
{
public:
	static RECT rcDefault;
	HWND m_hWnd;

	CWindow(HWND hWnd = NULL) throw() :
		m_hWnd(hWnd)
	{
	}

	CWindow& operator=(HWND hWnd) throw()
	{
		m_hWnd = hWnd;
		return *this;
	}

	static LPCTSTR GetWndClassName() throw()
	{
		return NULL;
	}

	void Attach(HWND hWndNew) throw()
	{
		ATLASSERT(m_hWnd == NULL);
		ATLASSERT((hWndNew == NULL) || ::IsWindow(hWndNew));
		m_hWnd = hWndNew;
	}

	HWND Detach() throw()
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		return hWnd;
	}

	HWND Create(LPCTSTR lpstrWndClass, HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL) throw()
	{
		ATLASSERT(m_hWnd == NULL);
		if(rect.m_lpRect == NULL)
			rect.m_lpRect = &rcDefault;
		m_hWnd = ::CreateWindowEx(dwExStyle, lpstrWndClass, szWindowName,
			dwStyle, rect.m_lpRect->left, rect.m_lpRect->top, rect.m_lpRect->right - rect.m_lpRect->left,
			rect.m_lpRect->bottom - rect.m_lpRect->top, hWndParent, MenuOrID.m_hMenu,
			_AtlBaseModule.GetModuleInstance(), lpCreateParam);
		return m_hWnd;
	}

	BOOL DestroyWindow() throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));

		if(!::DestroyWindow(m_hWnd))
			return FALSE;

		m_hWnd = NULL;
		return TRUE;
	}

// Attributes

	operator HWND() const throw()
	{ 
		return m_hWnd; 
	}

	DWORD GetStyle() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::GetWindowLong(m_hWnd, GWL_STYLE);
	}

	DWORD GetExStyle() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::GetWindowLong(m_hWnd, GWL_EXSTYLE);
	}

	LONG GetWindowLong(int nIndex) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetWindowLong(m_hWnd, nIndex);
	}
	
	LONG_PTR GetWindowLongPtr(int nIndex) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetWindowLongPtr(m_hWnd, nIndex);
	}

	LONG SetWindowLong(int nIndex, LONG dwNewLong) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetWindowLong(m_hWnd, nIndex, dwNewLong);
	}

	LONG_PTR SetWindowLongPtr(int nIndex, LONG_PTR dwNewLong) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetWindowLongPtr(m_hWnd, nIndex, dwNewLong);
	}

	WORD GetWindowWord(int nIndex) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetWindowWord(m_hWnd, nIndex);
	}

	WORD SetWindowWord(int nIndex, WORD wNewWord) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetWindowWord(m_hWnd, nIndex, wNewWord);
	}

// Message Functions

	LRESULT SendMessage(UINT message, WPARAM wParam = 0, LPARAM lParam = 0) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SendMessage(m_hWnd,message,wParam,lParam);
	}

	BOOL PostMessage(UINT message, WPARAM wParam = 0, LPARAM lParam = 0) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::PostMessage(m_hWnd,message,wParam,lParam);
	}

	BOOL SendNotifyMessage(UINT message, WPARAM wParam = 0, LPARAM lParam = 0) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SendNotifyMessage(m_hWnd, message, wParam, lParam);
	}

	// support for C style macros
	static LRESULT SendMessage(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) throw()
	{
		ATLASSERT(::IsWindow(hWnd));
		return ::SendMessage(hWnd, message, wParam, lParam);
	}

// Window Text Functions

	BOOL SetWindowText(LPCTSTR lpszString) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetWindowText(m_hWnd, lpszString);
	}

	int GetWindowText(LPTSTR lpszStringBuf, int nMaxCount) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetWindowText(m_hWnd, lpszStringBuf, nMaxCount);
	}
	int GetWindowText(CSimpleString& strText) const
	{
		int nLength;
		LPTSTR pszText;

		nLength = GetWindowTextLength();
		pszText = strText.GetBuffer(nLength+1);
		nLength = GetWindowText(pszText, nLength+1);
		strText.ReleaseBuffer(nLength);

		return nLength;
	}
	int GetWindowTextLength() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetWindowTextLength(m_hWnd);
	}

// Font Functions

	void SetFont(HFONT hFont, BOOL bRedraw = TRUE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(bRedraw, 0));
	}

	HFONT GetFont() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HFONT)::SendMessage(m_hWnd, WM_GETFONT, 0, 0);
	}

// Menu Functions (non-child windows only)

	HMENU GetMenu() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HMENU)::GetMenu(m_hWnd);
	}

	BOOL SetMenu(HMENU hMenu) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetMenu(m_hWnd, hMenu);
	}

	BOOL DrawMenuBar() throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::DrawMenuBar(m_hWnd);
	}

	HMENU GetSystemMenu(BOOL bRevert) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HMENU)::GetSystemMenu(m_hWnd, bRevert);
	}

	BOOL HiliteMenuItem(HMENU hMenu, UINT uItemHilite, UINT uHilite) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::HiliteMenuItem(m_hWnd, hMenu, uItemHilite, uHilite);
	}

// Window Size and Position Functions

	BOOL IsIconic() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::IsIconic(m_hWnd);
	}

	BOOL IsZoomed() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::IsZoomed(m_hWnd);
	}

	BOOL MoveWindow(int x, int y, int nWidth, int nHeight, BOOL bRepaint = TRUE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::MoveWindow(m_hWnd, x, y, nWidth, nHeight, bRepaint);
	}

	BOOL MoveWindow(LPCRECT lpRect, BOOL bRepaint = TRUE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::MoveWindow(m_hWnd, lpRect->left, lpRect->top, lpRect->right - lpRect->left, lpRect->bottom - lpRect->top, bRepaint);
	}

	BOOL SetWindowPos(HWND hWndInsertAfter, int x, int y, int cx, int cy, UINT nFlags) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetWindowPos(m_hWnd, hWndInsertAfter, x, y, cx, cy, nFlags);
	}

	BOOL SetWindowPos(HWND hWndInsertAfter, LPCRECT lpRect, UINT nFlags) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetWindowPos(m_hWnd, hWndInsertAfter, lpRect->left, lpRect->top, lpRect->right - lpRect->left, lpRect->bottom - lpRect->top, nFlags);
	}

	UINT ArrangeIconicWindows() throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ArrangeIconicWindows(m_hWnd);
	}

	BOOL BringWindowToTop() throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::BringWindowToTop(m_hWnd);
	}

	BOOL GetWindowRect(LPRECT lpRect) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetWindowRect(m_hWnd, lpRect);
	}

	BOOL GetClientRect(LPRECT lpRect) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetClientRect(m_hWnd, lpRect);
	}

	BOOL GetWindowPlacement(WINDOWPLACEMENT FAR* lpwndpl) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetWindowPlacement(m_hWnd, lpwndpl);
	}

	BOOL SetWindowPlacement(const WINDOWPLACEMENT FAR* lpwndpl) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetWindowPlacement(m_hWnd, lpwndpl);
	}

// Coordinate Mapping Functions

	BOOL ClientToScreen(LPPOINT lpPoint) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ClientToScreen(m_hWnd, lpPoint);
	}

	BOOL ClientToScreen(LPRECT lpRect) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		if(!::ClientToScreen(m_hWnd, (LPPOINT)lpRect))
			return FALSE;
		return ::ClientToScreen(m_hWnd, ((LPPOINT)lpRect)+1);
	}

	BOOL ScreenToClient(LPPOINT lpPoint) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ScreenToClient(m_hWnd, lpPoint);
	}

	BOOL ScreenToClient(LPRECT lpRect) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		if(!::ScreenToClient(m_hWnd, (LPPOINT)lpRect))
			return FALSE;
		return ::ScreenToClient(m_hWnd, ((LPPOINT)lpRect)+1);
	}

	int MapWindowPoints(HWND hWndTo, LPPOINT lpPoint, UINT nCount) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::MapWindowPoints(m_hWnd, hWndTo, lpPoint, nCount);
	}

	int MapWindowPoints(HWND hWndTo, LPRECT lpRect) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::MapWindowPoints(m_hWnd, hWndTo, (LPPOINT)lpRect, 2);
	}

// Update and Painting Functions

	HDC BeginPaint(LPPAINTSTRUCT lpPaint) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::BeginPaint(m_hWnd, lpPaint);
	}

	void EndPaint(LPPAINTSTRUCT lpPaint) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::EndPaint(m_hWnd, lpPaint);
	}

	HDC GetDC() throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetDC(m_hWnd);
	}

	HDC GetWindowDC() throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetWindowDC(m_hWnd);
	}

	int ReleaseDC(HDC hDC) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ReleaseDC(m_hWnd, hDC);
	}

	void Print(HDC hDC, DWORD dwFlags) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_PRINT, (WPARAM)hDC, dwFlags);
	}

	void PrintClient(HDC hDC, DWORD dwFlags) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_PRINTCLIENT, (WPARAM)hDC, dwFlags);
	}

	BOOL UpdateWindow() throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::UpdateWindow(m_hWnd);
	}

	void SetRedraw(BOOL bRedraw = TRUE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_SETREDRAW, (WPARAM)bRedraw, 0);
	}

	BOOL GetUpdateRect(LPRECT lpRect, BOOL bErase = FALSE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetUpdateRect(m_hWnd, lpRect, bErase);
	}

	int GetUpdateRgn(HRGN hRgn, BOOL bErase = FALSE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetUpdateRgn(m_hWnd, hRgn, bErase);
	}

	BOOL Invalidate(BOOL bErase = TRUE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::InvalidateRect(m_hWnd, NULL, bErase);
	}

	BOOL InvalidateRect(LPCRECT lpRect, BOOL bErase = TRUE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::InvalidateRect(m_hWnd, lpRect, bErase);
	}

	BOOL ValidateRect(LPCRECT lpRect) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ValidateRect(m_hWnd, lpRect);
	}

	void InvalidateRgn(HRGN hRgn, BOOL bErase = TRUE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::InvalidateRgn(m_hWnd, hRgn, bErase);
	}

	BOOL ValidateRgn(HRGN hRgn) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ValidateRgn(m_hWnd, hRgn);
	}

	BOOL ShowWindow(int nCmdShow) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ShowWindow(m_hWnd, nCmdShow);
	}

	BOOL IsWindowVisible() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::IsWindowVisible(m_hWnd);
	}

	BOOL ShowOwnedPopups(BOOL bShow = TRUE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ShowOwnedPopups(m_hWnd, bShow);
	}

	HDC GetDCEx(HRGN hRgnClip, DWORD flags) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetDCEx(m_hWnd, hRgnClip, flags);
	}

	BOOL LockWindowUpdate(BOOL bLock = TRUE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::LockWindowUpdate(bLock ? m_hWnd : NULL);
	}

	BOOL RedrawWindow(LPCRECT lpRectUpdate = NULL, HRGN hRgnUpdate = NULL, UINT flags = RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::RedrawWindow(m_hWnd, lpRectUpdate, hRgnUpdate, flags);
	}

// Timer Functions

	UINT_PTR SetTimer(UINT_PTR nIDEvent, UINT nElapse, void (CALLBACK* lpfnTimer)(HWND, UINT, UINT_PTR, DWORD) = NULL) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetTimer(m_hWnd, nIDEvent, nElapse, (TIMERPROC)lpfnTimer);
	}

	BOOL KillTimer(UINT_PTR nIDEvent) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::KillTimer(m_hWnd, nIDEvent);
	}

// Window State Functions

	BOOL IsWindowEnabled() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::IsWindowEnabled(m_hWnd);
	}

	BOOL EnableWindow(BOOL bEnable = TRUE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::EnableWindow(m_hWnd, bEnable);
	}

	HWND SetActiveWindow() throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetActiveWindow(m_hWnd);
	}

	HWND SetCapture() throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetCapture(m_hWnd);
	}

	HWND SetFocus() throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetFocus(m_hWnd);
	}

// Dialog-Box Item Functions

	BOOL CheckDlgButton(int nIDButton, UINT nCheck) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::CheckDlgButton(m_hWnd, nIDButton, nCheck);
	}

	BOOL CheckRadioButton(int nIDFirstButton, int nIDLastButton, int nIDCheckButton) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::CheckRadioButton(m_hWnd, nIDFirstButton, nIDLastButton, nIDCheckButton);
	}

	int DlgDirList(LPTSTR lpPathSpec, int nIDListBox, int nIDStaticPath, UINT nFileType) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::DlgDirList(m_hWnd, lpPathSpec, nIDListBox, nIDStaticPath, nFileType);
	}

	int DlgDirListComboBox(LPTSTR lpPathSpec, int nIDComboBox, int nIDStaticPath, UINT nFileType) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::DlgDirListComboBox(m_hWnd, lpPathSpec, nIDComboBox, nIDStaticPath, nFileType);
	}

	BOOL DlgDirSelect(LPTSTR lpString, int nCount, int nIDListBox) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::DlgDirSelectEx(m_hWnd, lpString, nCount, nIDListBox);
	}

	BOOL DlgDirSelectComboBox(LPTSTR lpString, int nCount, int nIDComboBox) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::DlgDirSelectComboBoxEx(m_hWnd, lpString, nCount, nIDComboBox);
	}

	UINT GetDlgItemInt(int nID, BOOL* lpTrans = NULL, BOOL bSigned = TRUE) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetDlgItemInt(m_hWnd, nID, lpTrans, bSigned);
	}

	UINT GetDlgItemText(int nID, LPTSTR lpStr, int nMaxCount) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetDlgItemText(m_hWnd, nID, lpStr, nMaxCount);
	}

	UINT GetDlgItemText(int nID, CSimpleString& strText) const
	{
		HWND hItem;

		ATLASSERT(::IsWindow(m_hWnd));
		hItem = GetDlgItem(nID);
		if (hItem != NULL)
		{
			int nLength;
			LPTSTR pszText;

			nLength = ::GetWindowTextLength(hItem);
			pszText = strText.GetBuffer(nLength+1);
			nLength = ::GetWindowText(hItem, pszText, nLength+1);
			strText.ReleaseBuffer(nLength);

			return nLength;
		}
		else
		{
			strText.Empty();

			return 0;
		}
	}
#ifdef _OLEAUTO_H_
	BOOL GetDlgItemText(int nID, BSTR& bstrText) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));

		HWND hWndCtl = GetDlgItem(nID);
		if(hWndCtl == NULL)
			return FALSE;

		return CWindow(hWndCtl).GetWindowText(bstrText);
	}
#endif // _OLEAUTO_H_
	CWindow GetNextDlgGroupItem(HWND hWndCtl, BOOL bPrevious = FALSE) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CWindow(::GetNextDlgGroupItem(m_hWnd, hWndCtl, bPrevious));
	}

	CWindow GetNextDlgTabItem(HWND hWndCtl, BOOL bPrevious = FALSE) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CWindow(::GetNextDlgTabItem(m_hWnd, hWndCtl, bPrevious));
	}

	UINT IsDlgButtonChecked(int nIDButton) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::IsDlgButtonChecked(m_hWnd, nIDButton);
	}

	LRESULT SendDlgItemMessage(int nID, UINT message, WPARAM wParam = 0, LPARAM lParam = 0) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SendDlgItemMessage(m_hWnd, nID, message, wParam, lParam);
	}

	BOOL SetDlgItemInt(int nID, UINT nValue, BOOL bSigned = TRUE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetDlgItemInt(m_hWnd, nID, nValue, bSigned);
	}

	BOOL SetDlgItemText(int nID, LPCTSTR lpszString) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetDlgItemText(m_hWnd, nID, lpszString);
	}

#ifndef _ATL_NO_HOSTING
	HRESULT GetDlgControl(int nID, REFIID iid, void** ppCtrl) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(ppCtrl != NULL);
		if (ppCtrl == NULL)
			return E_POINTER;
		*ppCtrl = NULL;
		HRESULT hr = HRESULT_FROM_WIN32(ERROR_CONTROL_ID_NOT_FOUND);
		HWND hWndCtrl = GetDlgItem(nID);
		if (hWndCtrl != NULL)
		{
			*ppCtrl = NULL;
			CComPtr<IUnknown> spUnk;
			hr = AtlAxGetControl(hWndCtrl, &spUnk);
			if (SUCCEEDED(hr))
				hr = spUnk->QueryInterface(iid, ppCtrl);
		}
		return hr;
	}
	HRESULT GetDlgHost(int nID, REFIID iid, void** ppHost) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(ppHost != NULL);
		if (ppHost == NULL)
			return E_POINTER;
		*ppHost = NULL;
		HRESULT hr = HRESULT_FROM_WIN32(ERROR_CONTROL_ID_NOT_FOUND);
		HWND hWndCtrl = GetDlgItem(nID);
		if (hWndCtrl != NULL)
		{
			CComPtr<IUnknown> spUnk;
			hr = AtlAxGetHost(hWndCtrl, &spUnk);
			if (SUCCEEDED(hr))
				hr = spUnk->QueryInterface(iid, ppHost);
		}
		return hr;
	}
#endif //!_ATL_NO_HOSTING

// Scrolling Functions

	int GetScrollPos(int nBar) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetScrollPos(m_hWnd, nBar);
	}

	BOOL GetScrollRange(int nBar, LPINT lpMinPos, LPINT lpMaxPos) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetScrollRange(m_hWnd, nBar, lpMinPos, lpMaxPos);
	}

	BOOL ScrollWindow(int xAmount, int yAmount, LPCRECT lpRect = NULL, LPCRECT lpClipRect = NULL) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ScrollWindow(m_hWnd, xAmount, yAmount, lpRect, lpClipRect);
	}

	int ScrollWindowEx(int dx, int dy, LPCRECT lpRectScroll, LPCRECT lpRectClip, HRGN hRgnUpdate, LPRECT lpRectUpdate, UINT uFlags) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ScrollWindowEx(m_hWnd, dx, dy, lpRectScroll, lpRectClip, hRgnUpdate, lpRectUpdate, uFlags);
	}

	int ScrollWindowEx(int dx, int dy, UINT uFlags, LPCRECT lpRectScroll = NULL, LPCRECT lpRectClip = NULL, HRGN hRgnUpdate = NULL, LPRECT lpRectUpdate = NULL) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ScrollWindowEx(m_hWnd, dx, dy, lpRectScroll, lpRectClip, hRgnUpdate, lpRectUpdate, uFlags);
	}

	int SetScrollPos(int nBar, int nPos, BOOL bRedraw = TRUE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetScrollPos(m_hWnd, nBar, nPos, bRedraw);
	}

	BOOL SetScrollRange(int nBar, int nMinPos, int nMaxPos, BOOL bRedraw = TRUE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetScrollRange(m_hWnd, nBar, nMinPos, nMaxPos, bRedraw);
	}

	BOOL ShowScrollBar(UINT nBar, BOOL bShow = TRUE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ShowScrollBar(m_hWnd, nBar, bShow);
	}

	BOOL EnableScrollBar(UINT uSBFlags, UINT uArrowFlags = ESB_ENABLE_BOTH) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::EnableScrollBar(m_hWnd, uSBFlags, uArrowFlags);
	}

// Window Access Functions

	CWindow ChildWindowFromPoint(POINT point) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CWindow(::ChildWindowFromPoint(m_hWnd, point));
	}

	CWindow ChildWindowFromPointEx(POINT point, UINT uFlags) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CWindow(::ChildWindowFromPointEx(m_hWnd, point, uFlags));
	}

	CWindow GetTopWindow() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CWindow(::GetTopWindow(m_hWnd));
	}

	CWindow GetWindow(UINT nCmd) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CWindow(::GetWindow(m_hWnd, nCmd));
	}

	CWindow GetLastActivePopup() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CWindow(::GetLastActivePopup(m_hWnd));
	}

	BOOL IsChild(HWND hWnd) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::IsChild(m_hWnd, hWnd);
	}

	CWindow GetParent() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CWindow(::GetParent(m_hWnd));
	}

	CWindow SetParent(HWND hWndNewParent) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CWindow(::SetParent(m_hWnd, hWndNewParent));
	}

// Window Tree Access

	int GetDlgCtrlID() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetDlgCtrlID(m_hWnd);
	}

	int SetDlgCtrlID(int nID) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SetWindowLong(m_hWnd, GWL_ID, nID);
	}

	CWindow GetDlgItem(int nID) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CWindow(::GetDlgItem(m_hWnd, nID));
	}

// Alert Functions

	BOOL FlashWindow(BOOL bInvert) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::FlashWindow(m_hWnd, bInvert);
	}

	int MessageBox(LPCTSTR lpszText, LPCTSTR lpszCaption = _T(""), UINT nType = MB_OK) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::MessageBox(m_hWnd, lpszText, lpszCaption, nType);
	}

// Clipboard Functions

	BOOL ChangeClipboardChain(HWND hWndNewNext) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ChangeClipboardChain(m_hWnd, hWndNewNext);
	}

	HWND SetClipboardViewer() throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetClipboardViewer(m_hWnd);
	}

	BOOL OpenClipboard() throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::OpenClipboard(m_hWnd);
	}

// Caret Functions

	BOOL CreateCaret(HBITMAP hBitmap) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::CreateCaret(m_hWnd, hBitmap, 0, 0);
	}

	BOOL CreateSolidCaret(int nWidth, int nHeight) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::CreateCaret(m_hWnd, (HBITMAP)0, nWidth, nHeight);
	}

	BOOL CreateGrayCaret(int nWidth, int nHeight) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::CreateCaret(m_hWnd, (HBITMAP)1, nWidth, nHeight);
	}

	BOOL HideCaret() throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::HideCaret(m_hWnd);
	}

	BOOL ShowCaret() throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ShowCaret(m_hWnd);
	}

#ifdef _INC_SHELLAPI
// Drag-Drop Functions
	void DragAcceptFiles(BOOL bAccept = TRUE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd)); ::DragAcceptFiles(m_hWnd, bAccept);
	}
#endif

// Icon Functions

	HICON SetIcon(HICON hIcon, BOOL bBigIcon = TRUE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HICON)::SendMessage(m_hWnd, WM_SETICON, bBigIcon, (LPARAM)hIcon);
	}

	HICON GetIcon(BOOL bBigIcon = TRUE) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HICON)::SendMessage(m_hWnd, WM_GETICON, bBigIcon, 0);
	}

// Help Functions

	BOOL WinHelp(LPCTSTR lpszHelp, UINT nCmd = HELP_CONTEXT, DWORD dwData = 0) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::WinHelp(m_hWnd, lpszHelp, nCmd, dwData);
	}

	BOOL SetWindowContextHelpId(DWORD dwContextHelpId) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetWindowContextHelpId(m_hWnd, dwContextHelpId);
	}

	DWORD GetWindowContextHelpId() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetWindowContextHelpId(m_hWnd);
	}

// Hot Key Functions

	int SetHotKey(WORD wVirtualKeyCode, WORD wModifiers) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, WM_SETHOTKEY, MAKEWORD(wVirtualKeyCode, wModifiers), 0);
	}

	DWORD GetHotKey() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, WM_GETHOTKEY, 0, 0);
	}

// Misc. Operations

//N new
	BOOL GetScrollInfo(int nBar, LPSCROLLINFO lpScrollInfo) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetScrollInfo(m_hWnd, nBar, lpScrollInfo);
	}
	int SetScrollInfo(int nBar, LPSCROLLINFO lpScrollInfo, BOOL bRedraw = TRUE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetScrollInfo(m_hWnd, nBar, lpScrollInfo, bRedraw);
	}
	BOOL IsDialogMessage(LPMSG lpMsg) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::IsDialogMessage(m_hWnd, lpMsg);
	}

	void NextDlgCtrl() const throw()
        {
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_NEXTDLGCTL, 0, 0L);
	}
	void PrevDlgCtrl() const throw()
        {
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_NEXTDLGCTL, 1, 0L);
	}
	void GotoDlgCtrl(HWND hWndCtrl) const throw()
        {
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_NEXTDLGCTL, (WPARAM)hWndCtrl, 1L);
	}

	BOOL ResizeClient(int nWidth, int nHeight, BOOL bRedraw = TRUE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));

		RECT rcWnd;
		if(!GetClientRect(&rcWnd))
			return FALSE;

		if(nWidth != -1)
			rcWnd.right = nWidth;
		if(nHeight != -1)
			rcWnd.bottom = nHeight;

		if(!::AdjustWindowRectEx(&rcWnd, GetStyle(), (!(GetStyle() & WS_CHILD) && (GetMenu() != NULL)), GetExStyle()))
			return FALSE;

		UINT uFlags = SWP_NOZORDER | SWP_NOMOVE;
		if(!bRedraw)
			uFlags |= SWP_NOREDRAW;

		return SetWindowPos(NULL, 0, 0, rcWnd.right - rcWnd.left, rcWnd.bottom - rcWnd.top, uFlags);
	}

	int GetWindowRgn(HRGN hRgn) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetWindowRgn(m_hWnd, hRgn);
	}
	int SetWindowRgn(HRGN hRgn, BOOL bRedraw = FALSE) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetWindowRgn(m_hWnd, hRgn, bRedraw);
	}
	HDWP DeferWindowPos(HDWP hWinPosInfo, HWND hWndInsertAfter, int x, int y, int cx, int cy, UINT uFlags) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::DeferWindowPos(hWinPosInfo, m_hWnd, hWndInsertAfter, x, y, cx, cy, uFlags);
	}
	DWORD GetWindowThreadID() throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetWindowThreadProcessId(m_hWnd, NULL);
	}
	DWORD GetWindowProcessID() throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		DWORD dwProcessID;
		::GetWindowThreadProcessId(m_hWnd, &dwProcessID);
		return dwProcessID;
	}
	BOOL IsWindow() const throw()
	{
		return ::IsWindow(m_hWnd);
	}
	BOOL IsWindowUnicode() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::IsWindowUnicode(m_hWnd);
	}
	BOOL IsParentDialog() throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		TCHAR szBuf[8]; // "#32770" + NUL character
		if (GetClassName(GetParent(), szBuf, sizeof(szBuf)/sizeof(TCHAR)) == 0)
			return FALSE;
		return lstrcmp(szBuf, _T("#32770")) == 0;
	}
	BOOL ShowWindowAsync(int nCmdShow) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ShowWindowAsync(m_hWnd, nCmdShow);
	}

	CWindow GetDescendantWindow(int nID) const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));

		// GetDlgItem recursive (return first found)
		// breadth-first for 1 level, then depth-first for next level

		// use GetDlgItem since it is a fast USER function
		HWND hWndChild, hWndTmp;
		if((hWndChild = ::GetDlgItem(m_hWnd, nID)) != NULL)
		{
			if(::GetTopWindow(hWndChild) != NULL)
			{
				// children with the same ID as their parent have priority
				CWindow wnd(hWndChild);
				hWndTmp = wnd.GetDescendantWindow(nID);
				if(hWndTmp != NULL)
					return CWindow(hWndTmp);
			}
			return CWindow(hWndChild);
		}

		// walk each child
		for(hWndChild = ::GetTopWindow(m_hWnd); hWndChild != NULL;
			hWndChild = ::GetNextWindow(hWndChild, GW_HWNDNEXT))
		{
			CWindow wnd(hWndChild);
			hWndTmp = wnd.GetDescendantWindow(nID);
			if(hWndTmp != NULL)
				return CWindow(hWndTmp);
		}

		return CWindow(NULL);    // not found
	}

	void SendMessageToDescendants(UINT message, WPARAM wParam = 0, LPARAM lParam = 0, BOOL bDeep = TRUE) throw()
	{
		for(HWND hWndChild = ::GetTopWindow(m_hWnd); hWndChild != NULL;
			hWndChild = ::GetNextWindow(hWndChild, GW_HWNDNEXT))
		{
			::SendMessage(hWndChild, message, wParam, lParam);

			if(bDeep && ::GetTopWindow(hWndChild) != NULL)
			{
				// send to child windows after parent
				CWindow wnd(hWndChild);
				wnd.SendMessageToDescendants(message, wParam, lParam, bDeep);
			}
		}
	}

	BOOL CenterWindow(HWND hWndCenter = NULL) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));

		// determine owner window to center against
		DWORD dwStyle = GetStyle();
		if(hWndCenter == NULL)
		{
			if(dwStyle & WS_CHILD)
				hWndCenter = ::GetParent(m_hWnd);
			else
				hWndCenter = ::GetWindow(m_hWnd, GW_OWNER);
		}

		// get coordinates of the window relative to its parent
		RECT rcDlg;
		::GetWindowRect(m_hWnd, &rcDlg);
		RECT rcArea;
		RECT rcCenter;
		HWND hWndParent;
		if(!(dwStyle & WS_CHILD))
		{
			// don't center against invisible or minimized windows
			if(hWndCenter != NULL)
			{
				DWORD dwStyleCenter = ::GetWindowLong(hWndCenter, GWL_STYLE);
				if(!(dwStyleCenter & WS_VISIBLE) || (dwStyleCenter & WS_MINIMIZE))
					hWndCenter = NULL;
			}

			// center within screen coordinates
			::SystemParametersInfo(SPI_GETWORKAREA, NULL, &rcArea, NULL);
			if(hWndCenter == NULL)
				rcCenter = rcArea;
			else
				::GetWindowRect(hWndCenter, &rcCenter);
		}
		else
		{
			// center within parent client coordinates
			hWndParent = ::GetParent(m_hWnd);
			ATLASSERT(::IsWindow(hWndParent));

			::GetClientRect(hWndParent, &rcArea);
			ATLASSERT(::IsWindow(hWndCenter));
			::GetClientRect(hWndCenter, &rcCenter);
			::MapWindowPoints(hWndCenter, hWndParent, (POINT*)&rcCenter, 2);
		}

		int DlgWidth = rcDlg.right - rcDlg.left;
		int DlgHeight = rcDlg.bottom - rcDlg.top;

		// find dialog's upper left based on rcCenter
		int xLeft = (rcCenter.left + rcCenter.right) / 2 - DlgWidth / 2;
		int yTop = (rcCenter.top + rcCenter.bottom) / 2 - DlgHeight / 2;

		// if the dialog is outside the screen, move it inside
		if(xLeft < rcArea.left)
			xLeft = rcArea.left;
		else if(xLeft + DlgWidth > rcArea.right)
			xLeft = rcArea.right - DlgWidth;

		if(yTop < rcArea.top)
			yTop = rcArea.top;
		else if(yTop + DlgHeight > rcArea.bottom)
			yTop = rcArea.bottom - DlgHeight;

		// map screen coordinates to child coordinates
		return ::SetWindowPos(m_hWnd, NULL, xLeft, yTop, -1, -1,
			SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
	}

	BOOL ModifyStyle(DWORD dwRemove, DWORD dwAdd, UINT nFlags = 0) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));

		DWORD dwStyle = ::GetWindowLong(m_hWnd, GWL_STYLE);
		DWORD dwNewStyle = (dwStyle & ~dwRemove) | dwAdd;
		if(dwStyle == dwNewStyle)
			return FALSE;

		::SetWindowLong(m_hWnd, GWL_STYLE, dwNewStyle);
		if(nFlags != 0)
		{
			::SetWindowPos(m_hWnd, NULL, 0, 0, 0, 0,
				SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | nFlags);
		}

		return TRUE;
	}

	BOOL ModifyStyleEx(DWORD dwRemove, DWORD dwAdd, UINT nFlags = 0) throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));

		DWORD dwStyle = ::GetWindowLong(m_hWnd, GWL_EXSTYLE);
		DWORD dwNewStyle = (dwStyle & ~dwRemove) | dwAdd;
		if(dwStyle == dwNewStyle)
			return FALSE;

		::SetWindowLong(m_hWnd, GWL_EXSTYLE, dwNewStyle);
		if(nFlags != 0)
		{
			::SetWindowPos(m_hWnd, NULL, 0, 0, 0, 0,
				SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | nFlags);
		}

		return TRUE;
	}

#ifdef _OLEAUTO_H_
	BOOL GetWindowText(BSTR* pbstrText) throw()
	{
		return GetWindowText(*pbstrText);
	}
	BOOL GetWindowText(BSTR& bstrText) throw()
	{
		USES_CONVERSION;
		ATLASSERT(::IsWindow(m_hWnd));
		if (bstrText != NULL)
		{
			SysFreeString(bstrText);
			bstrText = NULL;
		}

		int nLen = ::GetWindowTextLength(m_hWnd);
		if(nLen == 0)
		{
			bstrText = ::SysAllocString(OLESTR(""));
			return (bstrText != NULL) ? TRUE : FALSE;
		}

		LPTSTR lpszText = (LPTSTR)_alloca((nLen+1)*sizeof(TCHAR));

		if(!::GetWindowText(m_hWnd, lpszText, nLen+1))
			return FALSE;

		bstrText = ::SysAllocString(T2OLE(lpszText));
		return (bstrText != NULL) ? TRUE : FALSE;
	}
#endif // _OLEAUTO_H_
	CWindow GetTopLevelParent() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));

		HWND hWndParent = m_hWnd;
		HWND hWndTmp;
		while((hWndTmp = ::GetParent(hWndParent)) != NULL)
			hWndParent = hWndTmp;

		return CWindow(hWndParent);
	}

	CWindow GetTopLevelWindow() const throw()
	{
		ATLASSERT(::IsWindow(m_hWnd));

		HWND hWndParent;
		HWND hWndTmp = m_hWnd;

		do
		{
			hWndParent = hWndTmp;
			hWndTmp = (::GetWindowLong(hWndParent, GWL_STYLE) & WS_CHILD) ? ::GetParent(hWndParent) : ::GetWindow(hWndParent, GW_OWNER);
		}
		while(hWndTmp != NULL);

		return CWindow(hWndParent);
	}
};

_declspec(selectany) RECT CWindow::rcDefault = { CW_USEDEFAULT, CW_USEDEFAULT, 0, 0 };

/////////////////////////////////////////////////////////////////////////////
// CAxWindow - client side for an ActiveX host window

#ifndef _ATL_NO_HOSTING

template <class TBase = CWindow>
class CAxWindowT : public TBase
{
public:
// Constructors
	CAxWindowT(HWND hWnd = NULL) : TBase(hWnd)
	{
		AtlAxWinInit();
	}

	CAxWindowT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return _T(ATLAXWIN_CLASS);
	}

// Operations
	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect, szWindowName, dwStyle, dwExStyle, MenuOrID, lpCreateParam);
	}

	HRESULT CreateControl(LPCOLESTR lpszName, IStream* pStream = NULL, IUnknown** ppUnkContainer = NULL)
	{
		return CreateControlEx(lpszName, pStream, ppUnkContainer);
	}

	HRESULT CreateControl(DWORD dwResID, IStream* pStream = NULL, IUnknown** ppUnkContainer = NULL)
	{
		return CreateControlEx(dwResID, pStream, ppUnkContainer);
	}

	HRESULT CreateControlEx(LPCOLESTR lpszName, IStream* pStream = NULL, 
			IUnknown** ppUnkContainer = NULL, IUnknown** ppUnkControl = NULL,
			REFIID iidSink = IID_NULL, IUnknown* punkSink = NULL)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		// We must have a valid window!

		// Get a pointer to the container object connected to this window
		CComPtr<IAxWinHostWindow> spWinHost;
		HRESULT hr = QueryHost(&spWinHost);
		
		// If QueryHost failed, there is no host attached to this window
		// We assume that the user wants to create a new host and subclass the current window
		if (FAILED(hr))
			return AtlAxCreateControlEx(lpszName, m_hWnd, pStream, ppUnkContainer, ppUnkControl, iidSink, punkSink);

		// Create the control requested by the caller
		CComPtr<IUnknown> pControl;
		if (SUCCEEDED(hr))
			hr = spWinHost->CreateControlEx(lpszName, m_hWnd, pStream, &pControl, iidSink, punkSink);

		// Send back the necessary interface pointers
		if (SUCCEEDED(hr))
		{
			if (ppUnkControl)
				*ppUnkControl = pControl.Detach();

			if (ppUnkContainer)
			{
				hr = spWinHost.QueryInterface(ppUnkContainer);
				ATLASSERT(SUCCEEDED(hr)); // This should not fail!
			}
		}

		return hr;
	}

	HRESULT CreateControlEx(DWORD dwResID,  IStream* pStream = NULL, 
			IUnknown** ppUnkContainer = NULL, IUnknown** ppUnkControl = NULL,
			REFIID iidSink = IID_NULL, IUnknown* punkSink = NULL)
	{
		TCHAR szModule[_MAX_PATH];
		GetModuleFileName(_AtlBaseModule.GetModuleInstance(), szModule, _MAX_PATH);

		CComBSTR bstrURL(OLESTR("res://"));
		bstrURL.Append(szModule);
		bstrURL.Append(OLESTR("/"));
		TCHAR szResID[11];
		wsprintf(szResID, _T("%0d"), dwResID);
		bstrURL.Append(szResID);

		ATLASSERT(::IsWindow(m_hWnd));
		return CreateControlEx(bstrURL, pStream, ppUnkContainer, ppUnkControl, iidSink, punkSink);
	}

	HRESULT AttachControl(IUnknown* pControl, IUnknown** ppUnkContainer)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		// We must have a valid window!

		// Get a pointer to the container object connected to this window
		CComPtr<IAxWinHostWindow> spWinHost;
		HRESULT hr = QueryHost(&spWinHost);
		
		// If QueryHost failed, there is no host attached to this window
		// We assume that the user wants to create a new host and subclass the current window
		if (FAILED(hr))
			return AtlAxAttachControl(pControl, m_hWnd, ppUnkContainer);

		// Attach the control specified by the caller
		if (SUCCEEDED(hr))
			hr = spWinHost->AttachControl(pControl, m_hWnd);

		// Get the IUnknown interface of the container
		if (SUCCEEDED(hr) && ppUnkContainer)
		{
			hr = spWinHost.QueryInterface(ppUnkContainer);
			ATLASSERT(SUCCEEDED(hr)); // This should not fail!
		}

		return hr;
	}

	HRESULT QueryHost(REFIID iid, void** ppUnk)
	{
		ATLASSERT(ppUnk != NULL);
		if (ppUnk == NULL)
			return E_POINTER;
		HRESULT hr;
		*ppUnk = NULL;
		CComPtr<IUnknown> spUnk;
		hr = AtlAxGetHost(m_hWnd, &spUnk);
		if (SUCCEEDED(hr))
			hr = spUnk->QueryInterface(iid, ppUnk);
		return hr;
	}
	template <class Q>
	HRESULT QueryHost(Q** ppUnk)
	{
		return QueryHost(__uuidof(Q), (void**)ppUnk);
	}
	HRESULT QueryControl(REFIID iid, void** ppUnk)
	{
		ATLASSERT(ppUnk != NULL);
		if (ppUnk == NULL)
			return E_POINTER;
		HRESULT hr;
		*ppUnk = NULL;
		CComPtr<IUnknown> spUnk;
		hr = AtlAxGetControl(m_hWnd, &spUnk);
		if (SUCCEEDED(hr))
			hr = spUnk->QueryInterface(iid, ppUnk);
		return hr;
	}
	template <class Q>
	HRESULT QueryControl(Q** ppUnk)
	{
		return QueryControl(__uuidof(Q), (void**)ppUnk);
	}
	HRESULT SetExternalDispatch(IDispatch* pDisp)
	{
		HRESULT hr;
		CComPtr<IAxWinHostWindow> spHost;
		hr = QueryHost(__uuidof(IAxWinHostWindow), (void**)&spHost);
		if (SUCCEEDED(hr))
			hr = spHost->SetExternalDispatch(pDisp);
		return hr;
	}
	HRESULT SetExternalUIHandler(IDocHostUIHandlerDispatch* pUIHandler)
	{
		HRESULT hr;
		CComPtr<IAxWinHostWindow> spHost;
		hr = QueryHost(__uuidof(IAxWinHostWindow), (void**)&spHost);
		if (SUCCEEDED(hr))
			hr = spHost->SetExternalUIHandler(pUIHandler);
		return hr;
	}
};

typedef CAxWindowT<CWindow> CAxWindow;

template <class TBase = CWindow>
class CAxWindow2T : public CAxWindowT<TBase>
{
public:
// Constructors
	CAxWindow2T(HWND hWnd = NULL) : CAxWindowT<TBase>(hWnd)
	{
	}

	CAxWindow2T< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return _T(ATLAXWINLIC_CLASS);
	}

// Operations
	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect, szWindowName, dwStyle, dwExStyle, MenuOrID, lpCreateParam);
	}

	HRESULT CreateControlLic(LPCOLESTR lpszName, IStream* pStream = NULL, IUnknown** ppUnkContainer = NULL, BSTR bstrLicKey = NULL)
	{
		return CreateControlLicEx(lpszName, pStream, ppUnkContainer, NULL, IID_NULL, NULL, bstrLicKey);
	}

	HRESULT CreateControlLic(DWORD dwResID, IStream* pStream = NULL, IUnknown** ppUnkContainer = NULL, BSTR bstrLicKey = NULL)
	{
		return CreateControlLicEx(dwResID, pStream, ppUnkContainer, NULL, IID_NULL, NULL, bstrLicKey);
	}

	HRESULT CreateControlLicEx(LPCOLESTR lpszName, IStream* pStream = NULL, 
			IUnknown** ppUnkContainer = NULL, IUnknown** ppUnkControl = NULL,
			REFIID iidSink = IID_NULL, IUnknown* punkSink = NULL, BSTR bstrLicKey = NULL)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		// We must have a valid window!

		// Get a pointer to the container object connected to this window
		CComPtr<IAxWinHostWindowLic> spWinHost;
		HRESULT hr = QueryHost(&spWinHost);
		
		// If QueryHost failed, there is no host attached to this window
		// We assume that the user wants to create a new host and subclass the current window
		if (FAILED(hr))
			return AtlAxCreateControlLicEx(lpszName, m_hWnd, pStream, ppUnkContainer, ppUnkControl, iidSink, punkSink, bstrLicKey);

		// Create the control requested by the caller
		CComPtr<IUnknown> pControl;
		if (SUCCEEDED(hr))
			hr = spWinHost->CreateControlLicEx(lpszName, m_hWnd, pStream, &pControl, iidSink, punkSink, bstrLicKey);

		// Send back the necessary interface pointers
		if (SUCCEEDED(hr))
		{
			if (ppUnkControl)
				*ppUnkControl = pControl.Detach();

			if (ppUnkContainer)
			{
				hr = spWinHost.QueryInterface(ppUnkContainer);
				ATLASSERT(SUCCEEDED(hr)); // This should not fail!
			}
		}

		return hr;
	}

	HRESULT CreateControlLicEx(DWORD dwResID,  IStream* pStream = NULL, 
			IUnknown** ppUnkContainer = NULL, IUnknown** ppUnkControl = NULL,
			REFIID iidSink = IID_NULL, IUnknown* punkSink = NULL, BSTR bstrLickey = NULL)
	{
		TCHAR szModule[_MAX_PATH];
		GetModuleFileName(_AtlBaseModule.GetModuleInstance(), szModule, _MAX_PATH);

		CComBSTR bstrURL(OLESTR("res://"));
		bstrURL.Append(szModule);
		bstrURL.Append(OLESTR("/"));
		TCHAR szResID[11];
		wsprintf(szResID, _T("%0d"), dwResID);
		bstrURL.Append(szResID);

		ATLASSERT(::IsWindow(m_hWnd));
		return CreateControlLicEx(bstrURL, pStream, ppUnkContainer, ppUnkControl, iidSink, punkSink, bstrLickey);
	}
};

typedef CAxWindow2T<CWindow> CAxWindow2;


#endif //_ATL_NO_HOSTING

/////////////////////////////////////////////////////////////////////////////
// WindowProc thunks

class CWndProcThunk
{
public:
	_AtlCreateWndData cd;
	CStdCallThunk thunk;

	void Init(WNDPROC proc, void* pThis)
	{
		thunk.Init((DWORD_PTR)proc, pThis);
	}
	WNDPROC GetWNDPROC()
	{
		return (WNDPROC)thunk.GetCodeAddress();
	}
};

/////////////////////////////////////////////////////////////////////////////
// CMessageMap - abstract class that provides an interface for message maps

class ATL_NO_VTABLE CMessageMap
{ 
public:
	virtual BOOL ProcessWindowMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam,
		LRESULT& lResult, DWORD dwMsgMapID) = 0;
};

/////////////////////////////////////////////////////////////////////////////
// Message map

#define BEGIN_MSG_MAP(theClass) \
public: \
	BOOL ProcessWindowMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult, DWORD dwMsgMapID = 0) \
	{ \
		BOOL bHandled = TRUE; \
		hWnd; \
		uMsg; \
		wParam; \
		lParam; \
		lResult; \
		bHandled; \
		switch(dwMsgMapID) \
		{ \
		case 0:

#define ALT_MSG_MAP(msgMapID) \
		break; \
		case msgMapID:

#define MESSAGE_HANDLER(msg, func) \
	if(uMsg == msg) \
	{ \
		bHandled = TRUE; \
		lResult = func(uMsg, wParam, lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define MESSAGE_RANGE_HANDLER(msgFirst, msgLast, func) \
	if(uMsg >= msgFirst && uMsg <= msgLast) \
	{ \
		bHandled = TRUE; \
		lResult = func(uMsg, wParam, lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define COMMAND_HANDLER(id, code, func) \
	if(uMsg == WM_COMMAND && id == LOWORD(wParam) && code == HIWORD(wParam)) \
	{ \
		bHandled = TRUE; \
		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define COMMAND_ID_HANDLER(id, func) \
	if(uMsg == WM_COMMAND && id == LOWORD(wParam)) \
	{ \
		bHandled = TRUE; \
		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define COMMAND_CODE_HANDLER(code, func) \
	if(uMsg == WM_COMMAND && code == HIWORD(wParam)) \
	{ \
		bHandled = TRUE; \
		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define COMMAND_RANGE_HANDLER(idFirst, idLast, func) \
	if(uMsg == WM_COMMAND && LOWORD(wParam) >= idFirst  && LOWORD(wParam) <= idLast) \
	{ \
		bHandled = TRUE; \
		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define COMMAND_RANGE_CODE_HANDLER(idFirst, idLast, code, func) \
	if(uMsg == WM_COMMAND && code == HIWORD(wParam) && LOWORD(wParam) >= idFirst  && LOWORD(wParam) <= idLast) \
	{ \
		bHandled = TRUE; \
		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define NOTIFY_HANDLER(id, cd, func) \
	if(uMsg == WM_NOTIFY && id == ((LPNMHDR)lParam)->idFrom && cd == ((LPNMHDR)lParam)->code) \
	{ \
		bHandled = TRUE; \
		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define NOTIFY_ID_HANDLER(id, func) \
	if(uMsg == WM_NOTIFY && id == ((LPNMHDR)lParam)->idFrom) \
	{ \
		bHandled = TRUE; \
		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define NOTIFY_CODE_HANDLER(cd, func) \
	if(uMsg == WM_NOTIFY && cd == ((LPNMHDR)lParam)->code) \
	{ \
		bHandled = TRUE; \
		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define NOTIFY_RANGE_HANDLER(idFirst, idLast, func) \
	if(uMsg == WM_NOTIFY && ((LPNMHDR)lParam)->idFrom >= idFirst && ((LPNMHDR)lParam)->idFrom <= idLast) \
	{ \
		bHandled = TRUE; \
		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define NOTIFY_RANGE_CODE_HANDLER(idFirst, idLast, cd, func) \
	if(uMsg == WM_NOTIFY && cd == ((LPNMHDR)lParam)->code && ((LPNMHDR)lParam)->idFrom >= idFirst && ((LPNMHDR)lParam)->idFrom <= idLast) \
	{ \
		bHandled = TRUE; \
		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define CHAIN_MSG_MAP(theChainClass) \
	{ \
		if(theChainClass::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) \
			return TRUE; \
	}

#define CHAIN_MSG_MAP_MEMBER(theChainMember) \
	{ \
		if(theChainMember.ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) \
			return TRUE; \
	}

#define CHAIN_MSG_MAP_ALT(theChainClass, msgMapID) \
	{ \
		if(theChainClass::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult, msgMapID)) \
			return TRUE; \
	}

#define CHAIN_MSG_MAP_ALT_MEMBER(theChainMember, msgMapID) \
	{ \
		if(theChainMember.ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult, msgMapID)) \
			return TRUE; \
	}

#define CHAIN_MSG_MAP_DYNAMIC(dynaChainID) \
	{ \
		if(CDynamicChain::CallChain(dynaChainID, hWnd, uMsg, wParam, lParam, lResult)) \
			return TRUE; \
	}

#define END_MSG_MAP() \
			break; \
		default: \
			ATLTRACE(ATL::atlTraceWindowing, 0, _T("Invalid message map ID (%i)\n"), dwMsgMapID); \
			ATLASSERT(FALSE); \
			break; \
		} \
		return FALSE; \
	}


// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);


// Empty message map macro

#define DECLARE_EMPTY_MSG_MAP() \
public: \
	BOOL ProcessWindowMessage(HWND, UINT, WPARAM, LPARAM, LRESULT&, DWORD = 0) \
	{ \
		return FALSE; \
	}

// Message forwarding and reflection macros

#define FORWARD_NOTIFICATIONS() \
	{ \
		bHandled = TRUE; \
		lResult = ForwardNotifications(uMsg, wParam, lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECT_NOTIFICATIONS() \
	{ \
		bHandled = TRUE; \
		lResult = ReflectNotifications(uMsg, wParam, lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define DEFAULT_REFLECTION_HANDLER() \
	if(DefaultReflectionHandler(hWnd, uMsg, wParam, lParam, lResult)) \
		return TRUE;

#define REFLECTED_COMMAND_HANDLER(id, code, func) \
	if(uMsg == OCM_COMMAND && id == LOWORD(wParam) && code == HIWORD(wParam)) \
	{ \
		bHandled = TRUE; \
		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECTED_COMMAND_ID_HANDLER(id, func) \
	if(uMsg == OCM_COMMAND && id == LOWORD(wParam)) \
	{ \
		bHandled = TRUE; \
		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECTED_COMMAND_CODE_HANDLER(code, func) \
	if(uMsg == OCM_COMMAND && code == HIWORD(wParam)) \
	{ \
		bHandled = TRUE; \
		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECTED_COMMAND_RANGE_HANDLER(idFirst, idLast, func) \
	if(uMsg == OCM_COMMAND && LOWORD(wParam) >= idFirst  && LOWORD(wParam) <= idLast) \
	{ \
		bHandled = TRUE; \
		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECTED_COMMAND_RANGE_CODE_HANDLER(idFirst, idLast, code, func) \
	if(uMsg == OCM_COMMAND && code == HIWORD(wParam) && LOWORD(wParam) >= idFirst  && LOWORD(wParam) <= idLast) \
	{ \
		bHandled = TRUE; \
		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECTED_NOTIFY_HANDLER(id, cd, func) \
	if(uMsg == OCM_NOTIFY && id == ((LPNMHDR)lParam)->idFrom && cd == ((LPNMHDR)lParam)->code) \
	{ \
		bHandled = TRUE; \
		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECTED_NOTIFY_ID_HANDLER(id, func) \
	if(uMsg == OCM_NOTIFY && id == ((LPNMHDR)lParam)->idFrom) \
	{ \
		bHandled = TRUE; \
		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECTED_NOTIFY_CODE_HANDLER(cd, func) \
	if(uMsg == OCM_NOTIFY && cd == ((LPNMHDR)lParam)->code) \
	{ \
		bHandled = TRUE; \
		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECTED_NOTIFY_RANGE_HANDLER(idFirst, idLast, func) \
	if(uMsg == OCM_NOTIFY && ((LPNMHDR)lParam)->idFrom >= idFirst && ((LPNMHDR)lParam)->idFrom <= idLast) \
	{ \
		bHandled = TRUE; \
		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECTED_NOTIFY_RANGE_CODE_HANDLER(idFirst, idLast, cd, func) \
	if(uMsg == OCM_NOTIFY && cd == ((LPNMHDR)lParam)->code && ((LPNMHDR)lParam)->idFrom >= idFirst && ((LPNMHDR)lParam)->idFrom <= idLast) \
	{ \
		bHandled = TRUE; \
		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

/////////////////////////////////////////////////////////////////////////////
// CDynamicChain - provides support for dynamic chaining

class CDynamicChain
{
public:
	struct ATL_CHAIN_ENTRY
	{
		DWORD m_dwChainID;
		CMessageMap* m_pObject;
		DWORD m_dwMsgMapID;
	};

	CSimpleArray<ATL_CHAIN_ENTRY*> m_aChainEntry;

	CDynamicChain()
	{ }

	~CDynamicChain()
	{
		for(int i = 0; i < m_aChainEntry.GetSize(); i++)
		{
			if(m_aChainEntry[i] != NULL)
				delete m_aChainEntry[i];
		}
	}

	BOOL SetChainEntry(DWORD dwChainID, CMessageMap* pObject, DWORD dwMsgMapID = 0)
	{
	// first search for an existing entry

		int i;
		for(i = 0; i < m_aChainEntry.GetSize(); i++)
		{
			if(m_aChainEntry[i] != NULL && m_aChainEntry[i]->m_dwChainID == dwChainID)
			{
				m_aChainEntry[i]->m_pObject = pObject;
				m_aChainEntry[i]->m_dwMsgMapID = dwMsgMapID;
				return TRUE;
			}
		}

	// create a new one

		ATL_CHAIN_ENTRY* pEntry = NULL;
		ATLTRY(pEntry = new ATL_CHAIN_ENTRY);

		if(pEntry == NULL)
			return FALSE;

		pEntry->m_dwChainID = dwChainID;
		pEntry->m_pObject = pObject;
		pEntry->m_dwMsgMapID = dwMsgMapID;

	// search for an empty one

		for(i = 0; i < m_aChainEntry.GetSize(); i++)
		{
			if(m_aChainEntry[i] == NULL)
			{
				m_aChainEntry[i] = pEntry;
				return TRUE;
			}
		}

	// add a new one

		BOOL bRet = m_aChainEntry.Add(pEntry);

		if(!bRet)
		{
			delete pEntry;
			return FALSE;
		}

		return TRUE;
	}

	BOOL RemoveChainEntry(DWORD dwChainID)
	{
		for(int i = 0; i < m_aChainEntry.GetSize(); i++)
		{
			if(m_aChainEntry[i] != NULL && m_aChainEntry[i]->m_dwChainID == dwChainID)
			{
				delete m_aChainEntry[i];
				m_aChainEntry[i] = NULL;
				return TRUE;
			}
		}

		return FALSE;
	}

	BOOL CallChain(DWORD dwChainID, HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult)
	{
		for(int i = 0; i < m_aChainEntry.GetSize(); i++)
		{
			if(m_aChainEntry[i] != NULL && m_aChainEntry[i]->m_dwChainID == dwChainID)
				return (m_aChainEntry[i]->m_pObject)->ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult, m_aChainEntry[i]->m_dwMsgMapID);
		}

		return FALSE;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CWndClassInfo - Manages Windows class information

#define DECLARE_WND_CLASS(WndClassName) \
static ATL::CWndClassInfo& GetWndClassInfo() \
{ \
	static ATL::CWndClassInfo wc = \
	{ \
		{ sizeof(WNDCLASSEX), CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS, StartWindowProc, \
		  0, 0, NULL, NULL, NULL, (HBRUSH)(COLOR_WINDOW + 1), NULL, WndClassName, NULL }, \
		NULL, NULL, IDC_ARROW, TRUE, 0, _T("") \
	}; \
	return wc; \
}

#define DECLARE_WND_CLASS_EX(WndClassName, style, bkgnd) \
static ATL::CWndClassInfo& GetWndClassInfo() \
{ \
	static ATL::CWndClassInfo wc = \
	{ \
		{ sizeof(WNDCLASSEX), style, StartWindowProc, \
		  0, 0, NULL, NULL, NULL, (HBRUSH)(bkgnd + 1), NULL, WndClassName, NULL }, \
		NULL, NULL, IDC_ARROW, TRUE, 0, _T("") \
	}; \
	return wc; \
}

#define DECLARE_WND_SUPERCLASS(WndClassName, OrigWndClassName) \
static ATL::CWndClassInfo& GetWndClassInfo() \
{ \
	static ATL::CWndClassInfo wc = \
	{ \
		{ sizeof(WNDCLASSEX), 0, StartWindowProc, \
		  0, 0, NULL, NULL, NULL, NULL, NULL, WndClassName, NULL }, \
		OrigWndClassName, NULL, NULL, TRUE, 0, _T("") \
	}; \
	return wc; \
}

/////////////////////////////////////////////////////////////////////////////
// CWinTraits - Defines various default values for a window

template <DWORD t_dwStyle = 0, DWORD t_dwExStyle = 0>
class CWinTraits
{
public:
	static DWORD GetWndStyle(DWORD dwStyle)
	{
		return dwStyle == 0 ? t_dwStyle : dwStyle;
	}
	static DWORD GetWndExStyle(DWORD dwExStyle)
	{
		return dwExStyle == 0 ? t_dwExStyle : dwExStyle;
	}
};

typedef CWinTraits<WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, 0>					CControlWinTraits;
typedef CWinTraits<WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, WS_EX_APPWINDOW | WS_EX_WINDOWEDGE>		CFrameWinTraits;
typedef CWinTraits<WS_OVERLAPPEDWINDOW | WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, WS_EX_MDICHILD>	CMDIChildWinTraits;

typedef CWinTraits<0, 0> CNullTraits;

template <DWORD t_dwStyle = 0, DWORD t_dwExStyle = 0, class TWinTraits = CControlWinTraits>
class CWinTraitsOR
{
public:
	static DWORD GetWndStyle(DWORD dwStyle)
	{
		return dwStyle | t_dwStyle | TWinTraits::GetWndStyle(dwStyle);
	}
	static DWORD GetWndExStyle(DWORD dwExStyle)
	{
		return dwExStyle | t_dwExStyle | TWinTraits::GetWndExStyle(dwExStyle);
	}
};

/////////////////////////////////////////////////////////////////////////////
// CWindowImpl - Implements a window

template <class TBase = CWindow>
class ATL_NO_VTABLE CWindowImplRoot : public TBase, public CMessageMap
{
public:
	CWndProcThunk m_thunk;
	const _ATL_MSG* m_pCurrentMsg;
	DWORD m_dwState;

	enum { WINSTATE_DESTROYED = 0x00000001 };

// Constructor/destructor
	CWindowImplRoot() : m_pCurrentMsg(NULL), m_dwState(0)
	{ }

	~CWindowImplRoot()
	{
#ifdef _DEBUG
		if(m_hWnd != NULL)	// should be cleared in WindowProc
		{
			ATLTRACE(atlTraceWindowing, 0, _T("ERROR - Object deleted before window was destroyed\n"));
			ATLASSERT(FALSE);
		}
#endif //_DEBUG
	}

// Current message
	const _ATL_MSG* GetCurrentMessage() const
	{
		return m_pCurrentMsg;
	}

	// "handled" management for cracked handlers
	BOOL IsMsgHandled() const
	{
		const _ATL_MSG* pMsg = GetCurrentMessage();
		ATLASSERT(pMsg != NULL);
		ATLASSERT(pMsg->cbSize >= sizeof(_ATL_MSG));
		return pMsg->bHandled;
	}
	void SetMsgHandled(BOOL bHandled)
	{
		_ATL_MSG* pMsg = (_ATL_MSG*)GetCurrentMessage();	// override const
		ATLASSERT(pMsg != NULL);
		ATLASSERT(pMsg->cbSize >= sizeof(_ATL_MSG));
		pMsg->bHandled = bHandled;
	}

// Message forwarding and reflection support
	LRESULT ForwardNotifications(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT ReflectNotifications(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	static BOOL DefaultReflectionHandler(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult);
};

template <class TBase>
LRESULT CWindowImplRoot< TBase >::ForwardNotifications(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	LRESULT lResult = 0;
	switch(uMsg)
	{
	case WM_COMMAND:
	case WM_NOTIFY:
	case WM_PARENTNOTIFY:
	case WM_DRAWITEM:
	case WM_MEASUREITEM:
	case WM_COMPAREITEM:
	case WM_DELETEITEM:
	case WM_VKEYTOITEM:
	case WM_CHARTOITEM:
	case WM_HSCROLL:
	case WM_VSCROLL:
	case WM_CTLCOLORBTN:
	case WM_CTLCOLORDLG:
	case WM_CTLCOLOREDIT:
	case WM_CTLCOLORLISTBOX:
	case WM_CTLCOLORMSGBOX:
	case WM_CTLCOLORSCROLLBAR:
	case WM_CTLCOLORSTATIC:
		lResult = GetParent().SendMessage(uMsg, wParam, lParam);
		break;
	default:
		bHandled = FALSE;
		break;
	}
	return lResult;
}

template <class TBase>
LRESULT CWindowImplRoot< TBase >::ReflectNotifications(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	HWND hWndChild = NULL;

	switch(uMsg)
	{
	case WM_COMMAND:
		if(lParam != NULL)	// not from a menu
			hWndChild = (HWND)lParam;
		break;
	case WM_NOTIFY:
		hWndChild = ((LPNMHDR)lParam)->hwndFrom;
		break;
	case WM_PARENTNOTIFY:
		switch(LOWORD(wParam))
		{
		case WM_CREATE:
		case WM_DESTROY:
			hWndChild = (HWND)lParam;
			break;
		default:
			hWndChild = GetDlgItem(HIWORD(wParam));
			break;
		}
		break;
	case WM_DRAWITEM:
		if(wParam)	// not from a menu
			hWndChild = ((LPDRAWITEMSTRUCT)lParam)->hwndItem;
		break;
	case WM_MEASUREITEM:
		if(wParam)	// not from a menu
			hWndChild = GetDlgItem(((LPMEASUREITEMSTRUCT)lParam)->CtlID);
		break;
	case WM_COMPAREITEM:
		if(wParam)	// not from a menu
			hWndChild = GetDlgItem(((LPCOMPAREITEMSTRUCT)lParam)->CtlID);
		break;
	case WM_DELETEITEM:
		if(wParam)	// not from a menu
			hWndChild = GetDlgItem(((LPDELETEITEMSTRUCT)lParam)->CtlID);
		break;
	case WM_VKEYTOITEM:
	case WM_CHARTOITEM:
	case WM_HSCROLL:
	case WM_VSCROLL:
		hWndChild = (HWND)lParam;
		break;
	case WM_CTLCOLORBTN:
	case WM_CTLCOLORDLG:
	case WM_CTLCOLOREDIT:
	case WM_CTLCOLORLISTBOX:
	case WM_CTLCOLORMSGBOX:
	case WM_CTLCOLORSCROLLBAR:
	case WM_CTLCOLORSTATIC:
		hWndChild = (HWND)lParam;
		break;
	default:
		break;
	}

	if(hWndChild == NULL)
	{
		bHandled = FALSE;
		return 1;
	}

	ATLASSERT(::IsWindow(hWndChild));
	return ::SendMessage(hWndChild, OCM__BASE + uMsg, wParam, lParam);
}

template <class TBase>
BOOL CWindowImplRoot< TBase >::DefaultReflectionHandler(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult)
{
	switch(uMsg)
	{
	case OCM_COMMAND:
	case OCM_NOTIFY:
	case OCM_PARENTNOTIFY:
	case OCM_DRAWITEM:
	case OCM_MEASUREITEM:
	case OCM_COMPAREITEM:
	case OCM_DELETEITEM:
	case OCM_VKEYTOITEM:
	case OCM_CHARTOITEM:
	case OCM_HSCROLL:
	case OCM_VSCROLL:
	case OCM_CTLCOLORBTN:
	case OCM_CTLCOLORDLG:
	case OCM_CTLCOLOREDIT:
	case OCM_CTLCOLORLISTBOX:
	case OCM_CTLCOLORMSGBOX:
	case OCM_CTLCOLORSCROLLBAR:
	case OCM_CTLCOLORSTATIC:
		lResult = ::DefWindowProc(hWnd, uMsg - OCM__BASE, wParam, lParam);
		return TRUE;
	default:
		break;
	}
	return FALSE;
}

template <class TBase = CWindow, class TWinTraits = CControlWinTraits>
class ATL_NO_VTABLE CWindowImplBaseT : public CWindowImplRoot< TBase >
{
public:
	WNDPROC m_pfnSuperWindowProc;

	CWindowImplBaseT() : m_pfnSuperWindowProc(::DefWindowProc)
	{}

	static DWORD GetWndStyle(DWORD dwStyle)
	{
		return TWinTraits::GetWndStyle(dwStyle);
	}
	static DWORD GetWndExStyle(DWORD dwExStyle)
	{
		return TWinTraits::GetWndExStyle(dwExStyle);
	}

	virtual WNDPROC GetWindowProc()
	{
		return WindowProc;
	}
	static LRESULT CALLBACK StartWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	static LRESULT CALLBACK WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	HWND Create(HWND hWndParent, _U_RECT rect, LPCTSTR szWindowName,
			DWORD dwStyle, DWORD dwExStyle, _U_MENUorID MenuOrID, ATOM atom, LPVOID lpCreateParam = NULL);
	BOOL DestroyWindow()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::DestroyWindow(m_hWnd);
	}
	BOOL SubclassWindow(HWND hWnd);
	HWND UnsubclassWindow(BOOL bForce = FALSE);

	LRESULT DefWindowProc()
	{
		const _ATL_MSG* pMsg = m_pCurrentMsg;
		LRESULT lRes = 0;
		if (pMsg != NULL)
			lRes = DefWindowProc(pMsg->message, pMsg->wParam, pMsg->lParam);
		return lRes;
	}

	LRESULT DefWindowProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
#ifdef STRICT
		return ::CallWindowProc(m_pfnSuperWindowProc, m_hWnd, uMsg, wParam, lParam);
#else
		return ::CallWindowProc((FARPROC)m_pfnSuperWindowProc, m_hWnd, uMsg, wParam, lParam);
#endif
	}

	virtual void OnFinalMessage(HWND /*hWnd*/)
	{
		// override to do something, if needed
	}
};

typedef CWindowImplBaseT<CWindow>	CWindowImplBase;

template <class TBase, class TWinTraits>
LRESULT CALLBACK CWindowImplBaseT< TBase, TWinTraits >::StartWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	CWindowImplBaseT< TBase, TWinTraits >* pThis = (CWindowImplBaseT< TBase, TWinTraits >*)_AtlWinModule.ExtractCreateWndData();
	ATLASSERT(pThis != NULL);
	pThis->m_hWnd = hWnd;
	pThis->m_thunk.Init(pThis->GetWindowProc(), pThis);
	WNDPROC pProc = pThis->m_thunk.GetWNDPROC();
	WNDPROC pOldProc = (WNDPROC)::SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)pProc);
#ifdef _DEBUG
	// check if somebody has subclassed us already since we discard it
	if(pOldProc != StartWindowProc)
		ATLTRACE(atlTraceWindowing, 0, _T("Subclassing through a hook discarded.\n"));
#else
	pOldProc;	// avoid unused warning
#endif
	return pProc(hWnd, uMsg, wParam, lParam);
}

template <class TBase, class TWinTraits>
LRESULT CALLBACK CWindowImplBaseT< TBase, TWinTraits >::WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	CWindowImplBaseT< TBase, TWinTraits >* pThis = (CWindowImplBaseT< TBase, TWinTraits >*)hWnd;
	// set a ptr to this message and save the old value
	_ATL_MSG msg(pThis->m_hWnd, uMsg, wParam, lParam);
	const _ATL_MSG* pOldMsg = pThis->m_pCurrentMsg;
	pThis->m_pCurrentMsg = &msg;
	// pass to the message map to process
	LRESULT lRes;
	BOOL bRet = pThis->ProcessWindowMessage(pThis->m_hWnd, uMsg, wParam, lParam, lRes, 0);
	// restore saved value for the current message
	ATLASSERT(pThis->m_pCurrentMsg == &msg);
	pThis->m_pCurrentMsg = pOldMsg;
	// do the default processing if message was not handled
	if(!bRet)
	{
		if(uMsg != WM_NCDESTROY)
			lRes = pThis->DefWindowProc(uMsg, wParam, lParam);
		else
		{
			// unsubclass, if needed
			LONG_PTR pfnWndProc = ::GetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC);
			lRes = pThis->DefWindowProc(uMsg, wParam, lParam);
			if(pThis->m_pfnSuperWindowProc != ::DefWindowProc && ::GetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC) == pfnWndProc)
				::SetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC, (LONG_PTR)pThis->m_pfnSuperWindowProc);
			// mark window as destryed
			pThis->m_dwState |= WINSTATE_DESTROYED;
		}
	}
	if((pThis->m_dwState & WINSTATE_DESTROYED) && pThis->m_pCurrentMsg == NULL)
	{
		// clear out window handle
		HWND hWnd = pThis->m_hWnd;
		pThis->m_hWnd = NULL;
		pThis->m_dwState &= ~WINSTATE_DESTROYED;
		// clean up after window is destroyed
		pThis->OnFinalMessage(hWnd);
	}
	return lRes;
}

template <class TBase, class TWinTraits>
HWND CWindowImplBaseT< TBase, TWinTraits >::Create(HWND hWndParent, _U_RECT rect, LPCTSTR szWindowName,
		DWORD dwStyle, DWORD dwExStyle, _U_MENUorID MenuOrID, ATOM atom, LPVOID lpCreateParam)
{
	ATLASSERT(m_hWnd == NULL);

	if(atom == 0)
		return NULL;

	_AtlWinModule.AddCreateWndData(&m_thunk.cd, this);

	if(MenuOrID.m_hMenu == NULL && (dwStyle & WS_CHILD))
		MenuOrID.m_hMenu = (HMENU)(UINT_PTR)this;
	if(rect.m_lpRect == NULL)
		rect.m_lpRect = &TBase::rcDefault;

	HWND hWnd = ::CreateWindowEx(dwExStyle, MAKEINTATOM(atom), szWindowName,
		dwStyle, rect.m_lpRect->left, rect.m_lpRect->top, rect.m_lpRect->right - rect.m_lpRect->left,
		rect.m_lpRect->bottom - rect.m_lpRect->top, hWndParent, MenuOrID.m_hMenu,
		_AtlBaseModule.GetModuleInstance(), lpCreateParam);

	ATLASSERT(m_hWnd == hWnd);

	return hWnd;
}

template <class TBase, class TWinTraits>
BOOL CWindowImplBaseT< TBase, TWinTraits >::SubclassWindow(HWND hWnd)
{
	ATLASSERT(m_hWnd == NULL);
	ATLASSERT(::IsWindow(hWnd));
	m_thunk.Init(GetWindowProc(), this);
	WNDPROC pProc = m_thunk.GetWNDPROC();
	WNDPROC pfnWndProc = (WNDPROC)::SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)pProc);
	if(pfnWndProc == NULL)
		return FALSE;
	m_pfnSuperWindowProc = pfnWndProc;
	m_hWnd = hWnd;
	return TRUE;
}

// Use only if you want to subclass before window is destroyed,
// WindowProc will automatically subclass when  window goes away
template <class TBase, class TWinTraits>
HWND CWindowImplBaseT< TBase, TWinTraits >::UnsubclassWindow(BOOL bForce /*= FALSE*/)
{
	ATLASSERT(m_hWnd != NULL);

	WNDPROC pOurProc = m_thunk.GetWNDPROC();
	WNDPROC pActiveProc = (WNDPROC)::GetWindowLongPtr(m_hWnd, GWLP_WNDPROC);

	HWND hWnd = NULL;
	if (bForce || pOurProc == pActiveProc)
	{
		if(!::SetWindowLongPtr(m_hWnd, GWLP_WNDPROC, (LONG_PTR)m_pfnSuperWindowProc))
			return NULL;

		m_pfnSuperWindowProc = ::DefWindowProc;
		hWnd = m_hWnd;
		m_hWnd = NULL;
	}
	return hWnd;
}

template <class T, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class ATL_NO_VTABLE CWindowImpl : public CWindowImplBaseT< TBase, TWinTraits >
{
public:
	DECLARE_WND_CLASS(NULL)

	static LPCTSTR GetWndCaption()
	{
		return NULL;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		if (T::GetWndClassInfo().m_lpszOrigName == NULL)
			T::GetWndClassInfo().m_lpszOrigName = GetWndClassName();
		ATOM atom = T::GetWndClassInfo().Register(&m_pfnSuperWindowProc);

		dwStyle = T::GetWndStyle(dwStyle);
		dwExStyle = T::GetWndExStyle(dwExStyle);

		// set caption
		if (szWindowName == NULL)
			szWindowName = T::GetWndCaption();

		return CWindowImplBaseT< TBase, TWinTraits >::Create(hWndParent, rect, szWindowName,
			dwStyle, dwExStyle, MenuOrID, atom, lpCreateParam);
	}
};

template <class T, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class ATL_NO_VTABLE CWindowWithReflectorImpl : public CWindowImpl< T, TBase, TWinTraits >
{
public:
	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		m_wndReflector.Create(hWndParent, rect, NULL, WS_VISIBLE | WS_CHILD | WS_CLIPSIBLINGS | WS_CLIPCHILDREN, 0, Reflector::REFLECTOR_MAP_ID);
		RECT rcPos = { 0, 0, rect.m_lpRect->right, rect.m_lpRect->bottom };
		return CWindowImpl< T, TBase, TWinTraits >::Create(m_wndReflector, rcPos, szWindowName, dwStyle, dwExStyle, MenuOrID, lpCreateParam);
	}

// message map and handlers
	typedef CWindowWithReflectorImpl< T, TBase, TWinTraits >	thisClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_NCDESTROY, OnNcDestroy)
		MESSAGE_HANDLER(WM_WINDOWPOSCHANGING, OnWindowPosChanging)
	END_MSG_MAP()

	LRESULT OnNcDestroy(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		m_wndReflector.DestroyWindow();
		bHandled = FALSE;
		return 1;
	}
	LRESULT OnWindowPosChanging(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
	{
		WINDOWPOS* pWP = (WINDOWPOS*)lParam;
		m_wndReflector.SetWindowPos(m_wndReflector.GetParent(), pWP->x, pWP->y, pWP->cx, pWP->cy, pWP->flags);
		pWP->flags |= SWP_NOMOVE;
		pWP->x = 0;
		pWP->y = 0;
		return DefWindowProc(uMsg, wParam, lParam);
	}

	// reflector window stuff
	class Reflector : public CWindowImpl<Reflector>
	{
	public:
		enum { REFLECTOR_MAP_ID = 69 };
		DECLARE_WND_CLASS_EX(_T("ATLReflectorWindow"), 0, -1)
		BEGIN_MSG_MAP(Reflector)
			REFLECT_NOTIFICATIONS()
		END_MSG_MAP()
	} m_wndReflector;
};

/////////////////////////////////////////////////////////////////////////////
// CDialogImpl - Implements a dialog box

#define _ATL_RT_DLGINIT  MAKEINTRESOURCE(240)

template <class TBase = CWindow>
class ATL_NO_VTABLE CDialogImplBaseT : public CWindowImplRoot< TBase >
{
public:
	virtual DLGPROC GetDialogProc()
	{
		return DialogProc;
	}
	static INT_PTR CALLBACK StartDialogProc(HWND hWnd, UINT uMsg,
		WPARAM wParam, LPARAM lParam);
	static INT_PTR CALLBACK DialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	BOOL MapDialogRect(LPRECT lpRect)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::MapDialogRect(m_hWnd, lpRect);
	}
	virtual void OnFinalMessage(HWND /*hWnd*/)
	{
		// override to do something, if needed
	}
	// has no meaning for a dialog, but needed for handlers that use it
	LRESULT DefWindowProc()
	{
		return 0;
	}
	// initialize combobox and comboboxex from RT_DLGINIT resource if any
	BOOL ExecuteDlgInit(int iDlgID)
	{
		BOOL bSuccess = TRUE;
		HINSTANCE hInst = _AtlBaseModule.GetResourceInstance();
		HRSRC hrsrc = ::FindResource(hInst, MAKEINTRESOURCE(iDlgID), _ATL_RT_DLGINIT);
		if (hrsrc)
		{
			HGLOBAL hResData = ::LoadResource(hInst, hrsrc);
			if (hResData)
			{
				UNALIGNED WORD* pDlgInit = (UNALIGNED WORD*)::LockResource(hResData);
				if (pDlgInit)
				{
					USES_CONVERSION;
					while (bSuccess && NULL != *pDlgInit)
					{
						WORD wID = *pDlgInit++;
						WORD wMsg = *pDlgInit++;
						DWORD dwSize = *((UNALIGNED DWORD*&)pDlgInit)++;

						// CB_ADDSTRING is stored as 0x403
						if (0x403 == wMsg)
						{
							if (-1 == SendDlgItemMessage(wID, CB_ADDSTRING, 0, (LPARAM)(A2T((LPSTR)pDlgInit))))
								bSuccess = FALSE;
						}
						// CBEM_INSERTITEM is stored as 0x1234
						else if (0x1234 == wMsg)
						{
							COMBOBOXEXITEM item;
							item.mask = CBEIF_TEXT;
							item.iItem = -1;
							item.pszText = A2T(LPSTR(pDlgInit));
							if (-1 == SendDlgItemMessage(wID, CBEM_INSERTITEM, 0, (LPARAM)&item))
								bSuccess = FALSE;
						}
						pDlgInit = (LPWORD)((LPBYTE)pDlgInit + dwSize);
					}
				}
			}
		}
		return bSuccess;
	}
};

template <class TBase>
INT_PTR CALLBACK CDialogImplBaseT< TBase >::StartDialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	CDialogImplBaseT< TBase >* pThis = (CDialogImplBaseT< TBase >*)_AtlWinModule.ExtractCreateWndData();
	ATLASSERT(pThis != NULL);
	pThis->m_hWnd = hWnd;
	pThis->m_thunk.Init((WNDPROC)pThis->GetDialogProc(), pThis);
	DLGPROC pProc = (DLGPROC)pThis->m_thunk.GetWNDPROC();
	DLGPROC pOldProc = (DLGPROC)::SetWindowLongPtr(hWnd, DWLP_DLGPROC, (LONG_PTR)pProc);
#ifdef _DEBUG
	// check if somebody has subclassed us already since we discard it
	if(pOldProc != StartDialogProc)
		ATLTRACE(atlTraceWindowing, 0, _T("Subclassing through a hook discarded.\n"));
#else
	pOldProc;	// avoid unused warning
#endif
	return pProc(hWnd, uMsg, wParam, lParam);
}

template <class TBase>
INT_PTR CALLBACK CDialogImplBaseT< TBase >::DialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	CDialogImplBaseT< TBase >* pThis = (CDialogImplBaseT< TBase >*)hWnd;
	// set a ptr to this message and save the old value
	_ATL_MSG msg(pThis->m_hWnd, uMsg, wParam, lParam);
	const _ATL_MSG* pOldMsg = pThis->m_pCurrentMsg;
	pThis->m_pCurrentMsg = &msg;
	// pass to the message map to process
	LRESULT lRes;
	BOOL bRet = pThis->ProcessWindowMessage(pThis->m_hWnd, uMsg, wParam, lParam, lRes, 0);
	// restore saved value for the current message
	ATLASSERT(pThis->m_pCurrentMsg == &msg);
	pThis->m_pCurrentMsg = pOldMsg;
	// set result if message was handled
	if(bRet)
	{
		switch (uMsg)
		{
		case WM_COMPAREITEM:
		case WM_VKEYTOITEM:
		case WM_CHARTOITEM:
		case WM_INITDIALOG:
		case WM_QUERYDRAGICON:
		case WM_CTLCOLORMSGBOX:
		case WM_CTLCOLOREDIT:
		case WM_CTLCOLORLISTBOX:
		case WM_CTLCOLORBTN:
		case WM_CTLCOLORDLG:
		case WM_CTLCOLORSCROLLBAR:
		case WM_CTLCOLORSTATIC:
			// return directly
			bRet = (BOOL)lRes;
			break;
		default:
			// return in DWL_MSGRESULT
			::SetWindowLongPtr(pThis->m_hWnd, DWLP_MSGRESULT, lRes);
			break;
		}
	}
	else if(uMsg == WM_NCDESTROY)
	{
		// mark dialog as destryed
		pThis->m_dwState |= WINSTATE_DESTROYED;
	}

	if((pThis->m_dwState & WINSTATE_DESTROYED) && pThis->m_pCurrentMsg == NULL)
	{
		// clear out window handle
		HWND hWnd = pThis->m_hWnd;
		pThis->m_hWnd = NULL;
		pThis->m_dwState &= ~WINSTATE_DESTROYED;
		// clean up after dialog is destroyed
		pThis->OnFinalMessage(hWnd);
	}
	return bRet;
}

typedef CDialogImplBaseT<CWindow>	CDialogImplBase;

template <class T, class TBase = CWindow>
class ATL_NO_VTABLE CDialogImpl : public CDialogImplBaseT< TBase >
{
public:
#ifdef _DEBUG
	bool m_bModal;
	CDialogImpl() : m_bModal(false) { }
#endif //_DEBUG
	// modal dialogs
	INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow(), LPARAM dwInitParam = NULL)
	{
		ATLASSERT(m_hWnd == NULL);
		_AtlWinModule.AddCreateWndData(&m_thunk.cd, (CDialogImplBaseT< TBase >*)this);
#ifdef _DEBUG
		m_bModal = true;
#endif //_DEBUG
		T* pT;
		pT = static_cast<T*>(this);
		return ::DialogBoxParam(_AtlBaseModule.GetResourceInstance(), MAKEINTRESOURCE(pT->IDD),
					hWndParent, T::StartDialogProc, dwInitParam);
	}
	BOOL EndDialog(int nRetCode)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(m_bModal);	// must be a modal dialog
		return ::EndDialog(m_hWnd, nRetCode);
	}
	// modeless dialogs
	HWND Create(HWND hWndParent, LPARAM dwInitParam = NULL)
	{
		ATLASSERT(m_hWnd == NULL);
		_AtlWinModule.AddCreateWndData(&m_thunk.cd, (CDialogImplBaseT< TBase >*)this);
#ifdef _DEBUG
		m_bModal = false;
#endif //_DEBUG
		T* pT;
		pT = static_cast<T*>(this);
		HWND hWnd = ::CreateDialogParam(_AtlBaseModule.GetResourceInstance(), MAKEINTRESOURCE(pT->IDD),
					hWndParent, T::StartDialogProc, dwInitParam);
		ATLASSERT(m_hWnd == hWnd);
		return hWnd;
	}
	// for CComControl
	HWND Create(HWND hWndParent, RECT&, LPARAM dwInitParam = NULL)
	{
		return Create(hWndParent, dwInitParam);
	}
	BOOL DestroyWindow()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(!m_bModal);	// must not be a modal dialog
		return ::DestroyWindow(m_hWnd);
	}
};

/////////////////////////////////////////////////////////////////////////////
// CAxDialogImpl - Implements a dialog box that hosts ActiveX controls

#ifndef _ATL_NO_HOSTING


template <class T, class TBase = CWindow>
class ATL_NO_VTABLE CAxDialogImpl : public CDialogImplBaseT< TBase >
{
public:
#ifdef _DEBUG
	bool m_bModal;
	CAxDialogImpl() : m_bModal(false) { }
#endif //_DEBUG
	int GetIDD()
	{
		return( static_cast<T*>(this)->IDD );
	}
	virtual DLGPROC GetDialogProc()
	{
		return DialogProc;
	}
	static INT_PTR CALLBACK DialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	// modal dialogs
	INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow(), LPARAM dwInitParam = NULL)
	{
		ATLASSERT(m_hWnd == NULL);
		_AtlWinModule.AddCreateWndData(&m_thunk.cd, (CDialogImplBaseT< TBase >*)this);
#ifdef _DEBUG
		m_bModal = true;
#endif //_DEBUG
		T* pT;
		pT = static_cast<T*>(this);
		return AtlAxDialogBox(_AtlBaseModule.GetResourceInstance(), MAKEINTRESOURCE(pT->IDD),
					hWndParent, T::StartDialogProc, dwInitParam);
	}
	BOOL EndDialog(int nRetCode)
	{
		ATLASSERT(::IsWindow(m_hWnd));
#ifdef _DEBUG
		ATLASSERT(m_bModal);	// must be a modal dialog
#endif //_DEBUG
		return ::EndDialog(m_hWnd, nRetCode);
	}
	// modeless dialogs
	HWND Create(HWND hWndParent, LPARAM dwInitParam = NULL)
	{
		ATLASSERT(m_hWnd == NULL);
		_AtlWinModule.AddCreateWndData(&m_thunk.cd, (CDialogImplBaseT< TBase >*)this);
#ifdef _DEBUG
		m_bModal = false;
#endif //_DEBUG
		T* pT;
		pT = static_cast<T*>(this);
		HWND hWnd = AtlAxCreateDialog(_AtlBaseModule.GetResourceInstance(), MAKEINTRESOURCE(pT->IDD),
					hWndParent, T::StartDialogProc, dwInitParam);
		ATLASSERT(m_hWnd == hWnd);
		return hWnd;
	}
	// for CComControl
	HWND Create(HWND hWndParent, RECT&, LPARAM dwInitParam = NULL)
	{
		return Create(hWndParent, dwInitParam);
	}
	BOOL DestroyWindow()
	{
		ATLASSERT(::IsWindow(m_hWnd));
#ifdef _DEBUG
		ATLASSERT(!m_bModal);	// must not be a modal dialog
#endif //_DEBUG
		return ::DestroyWindow(m_hWnd);
	}

// Event handling support and Message map
	HRESULT AdviseSinkMap(bool bAdvise)
	{
		if(!bAdvise && m_hWnd == NULL)
		{
			// window is gone, controls are already unadvised
			ATLTRACE(atlTraceControls, 1, _T("CAxDialogImpl::AdviseSinkMap called after the window was destroyed\n"));
			return S_OK;
		}
		HRESULT hRet = E_NOTIMPL;
		__if_exists(T::_GetSinkMapFinder)
		{
			T* pT = static_cast<T*>(this);
			hRet = AtlAdviseSinkMap(pT, bAdvise);
		}
		return hRet;
	}

	typedef CAxDialogImpl< T, TBase >	thisClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
	END_MSG_MAP()

	virtual HRESULT CreateActiveXControls(UINT nID)
	{
		// Load dialog template and InitData
		HRSRC hDlgInit = ::FindResource(_AtlBaseModule.GetResourceInstance(), MAKEINTRESOURCE(nID), (LPTSTR)_ATL_RT_DLGINIT);
		BYTE* pInitData = NULL;
		HGLOBAL hData = NULL;
		HRESULT hr = S_OK;
		if (hDlgInit != NULL)
		{
			hData = ::LoadResource(_AtlBaseModule.GetResourceInstance(), hDlgInit);
			if (hData != NULL)
				pInitData = (BYTE*) ::LockResource(hData);
		}

		HRSRC hDlg = ::FindResource(_AtlBaseModule.GetResourceInstance(), MAKEINTRESOURCE(nID), (LPTSTR)RT_DIALOG);
		if (hDlg != NULL)
		{
			HGLOBAL hResource = ::LoadResource(_AtlBaseModule.GetResourceInstance(), hDlg);
			DLGTEMPLATE* pDlg = NULL;
			if (hResource != NULL)
			{
				pDlg = (DLGTEMPLATE*) ::LockResource(hResource);
				if (pDlg != NULL)
				{
					// Get first control on the template
					BOOL bDialogEx = _DialogSplitHelper::IsDialogEx(pDlg);
					WORD nItems = _DialogSplitHelper::DlgTemplateItemCount(pDlg);

					// Get first control on the dialog
					DLGITEMTEMPLATE* pItem = _DialogSplitHelper::FindFirstDlgItem(pDlg);
					HWND hWndPrev = GetWindow(GW_CHILD);

					// Create all ActiveX cotnrols in the dialog template and place them in the correct tab order (z-order)
					for (WORD nItem = 0; nItem < nItems; nItem++)
					{
						DWORD wID = bDialogEx ? ((_DialogSplitHelper::DLGITEMTEMPLATEEX*)pItem)->id : pItem->id;
						if (_DialogSplitHelper::IsActiveXControl(pItem, bDialogEx))
						{
							BYTE* pData = NULL;
							DWORD dwLen = _DialogSplitHelper::FindCreateData(wID, pInitData, &pData);
							CComPtr<IStream> spStream;
							if (dwLen != 0)
							{
								HGLOBAL h = GlobalAlloc(GHND, dwLen);
								if (h != NULL)
								{
									BYTE* pBytes = (BYTE*) GlobalLock(h);
									BYTE* pSource = pData; 
									memcpy(pBytes, pSource, dwLen);
									GlobalUnlock(h);
									CreateStreamOnHGlobal(h, TRUE, &spStream);
								}
								else
								{
									hr = E_OUTOFMEMORY;
									break;
								}
							}
							
							CComBSTR bstrLicKey;
							hr = _DialogSplitHelper::ParseInitData(spStream, &bstrLicKey.m_str);
							if (SUCCEEDED(hr))
							{
								CAxWindow2 wnd;
								// Get control caption.
								LPWSTR pszClassName = 
									bDialogEx ? 
										(LPWSTR)(((_DialogSplitHelper::DLGITEMTEMPLATEEX*)pItem) + 1) :
										(LPWSTR)(pItem + 1);
								// Get control rect.
								RECT rect;
								rect.left = 
									bDialogEx ? 
										((_DialogSplitHelper::DLGITEMTEMPLATEEX*)pItem)->x : 
										pItem->x;
								rect.top = 
									bDialogEx ? 
										((_DialogSplitHelper::DLGITEMTEMPLATEEX*)pItem)->y : 
										pItem->y;
								rect.right = rect.left + 
									(bDialogEx ? 
										((_DialogSplitHelper::DLGITEMTEMPLATEEX*)pItem)->cx : 
										pItem->cx);
								rect.bottom = rect.top + 
									(bDialogEx ? 
										((_DialogSplitHelper::DLGITEMTEMPLATEEX*)pItem)->cy : 
										pItem->cy);

								// Convert from dialog units to screen units
								MapDialogRect(&rect);

								// Create AxWindow with a NULL caption.
								wnd.Create(m_hWnd, 
									&rect, 
									NULL, 
									(bDialogEx ? 
										((_DialogSplitHelper::DLGITEMTEMPLATEEX*)pItem)->style : 
										pItem->style) | WS_TABSTOP, 
									bDialogEx ? 
										((_DialogSplitHelper::DLGITEMTEMPLATEEX*)pItem)->exStyle : 
										0,
									bDialogEx ? 
										((_DialogSplitHelper::DLGITEMTEMPLATEEX*)pItem)->id : 
										pItem->id,
									NULL);

								if (wnd != NULL)
								{
									// Set the Help ID
									if (bDialogEx && ((_DialogSplitHelper::DLGITEMTEMPLATEEX*)pItem)->helpID != 0)
										wnd.SetWindowContextHelpId(((_DialogSplitHelper::DLGITEMTEMPLATEEX*)pItem)->helpID);
									// Try to create the ActiveX control.
									hr = wnd.CreateControlLic(pszClassName, spStream, NULL, bstrLicKey);
									if (FAILED(hr))
										break;
									// Set the correct tab position.
									if (nItem == 0)
										hWndPrev = HWND_TOP;
									wnd.SetWindowPos(hWndPrev, 0,0,0,0,SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);
									hWndPrev = wnd;
								}
								else
								{
									hr = AtlHresultFromLastError();
								}
							}
						}
						else
						{
							if (nItem != 0)
								hWndPrev = ::GetWindow(hWndPrev, GW_HWNDNEXT);
						}
						pItem = _DialogSplitHelper::FindNextDlgItem(pItem, bDialogEx);
					}
				}
				else
					hr = AtlHresultFromLastError();
			}
			else
				hr = AtlHresultFromLastError();
		}
		return hr;
	}
		
	LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		// initialize controls in dialog with DLGINIT resource section
		T* pT = static_cast<T*>(this);
		(void)pT;  // Avoid 'initialized but not referenced' warning if T::IDD is static
		ExecuteDlgInit(pT->IDD);
		AdviseSinkMap(true);
		bHandled = FALSE;
		return 1;
	}

	LRESULT OnDestroy(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		AdviseSinkMap(false);
		bHandled = FALSE;
		return 1;
	}

// Accelerators handling - needs to be called from a message loop
	BOOL IsDialogMessage(LPMSG pMsg)
	{
		if((pMsg->message < WM_KEYFIRST || pMsg->message > WM_KEYLAST) &&
		   (pMsg->message < WM_MOUSEFIRST || pMsg->message > WM_MOUSELAST))
			return FALSE;

		// find a direct child of the dialog from the window that has focus
		HWND hWndCtl = ::GetFocus();
		if(IsChild(hWndCtl) && ::GetParent(hWndCtl) != m_hWnd)
		{
			do
			{
				hWndCtl = ::GetParent(hWndCtl);
			}
			while (::GetParent(hWndCtl) != m_hWnd);
		}
		// give controls a chance to translate this message
		if (::SendMessage(hWndCtl, WM_FORWARDMSG, 0, (LPARAM)pMsg) == 1)
			return TRUE;

		// do the Windows default thing
		return CDialogImplBaseT< TBase >::IsDialogMessage(pMsg);
	}
};

template <class T, class TBase>
INT_PTR CALLBACK CAxDialogImpl< T, TBase >::DialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	CAxDialogImpl< T, TBase >* pThis = (CAxDialogImpl< T, TBase >*)hWnd;
	if (uMsg == WM_INITDIALOG)
	{
		HRESULT hr;
		if (FAILED(hr = pThis->CreateActiveXControls(pThis->GetIDD())))
		{
			pThis->DestroyWindow();
			SetLastError(hr & 0x0000FFFF);
			return FALSE;
		}
	}
	return CDialogImplBaseT< TBase >::DialogProc(hWnd, uMsg, wParam, lParam);
}
#endif //_ATL_NO_HOSTING

/////////////////////////////////////////////////////////////////////////////
// CSimpleDialog - Prebuilt modal dialog that uses standard buttons

template <WORD t_wDlgTemplateID, BOOL t_bCenter = TRUE>
class CSimpleDialog : public CDialogImplBase
{
public:
	INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow())
	{
		ATLASSERT(m_hWnd == NULL);
		_AtlWinModule.AddCreateWndData(&m_thunk.cd, (CDialogImplBase*)this);
		int nRet = ::DialogBox(_AtlBaseModule.GetResourceInstance(),
			MAKEINTRESOURCE(t_wDlgTemplateID), hWndParent, StartDialogProc);
		m_hWnd = NULL;
		return nRet;
	}

	typedef CSimpleDialog<t_wDlgTemplateID, t_bCenter>	thisClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		COMMAND_RANGE_HANDLER(IDOK, IDNO, OnCloseCmd)
	END_MSG_MAP()

	LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		// initialize controls in dialog with DLGINIT resource section
		ExecuteDlgInit(t_wDlgTemplateID);
		if(t_bCenter)
			CenterWindow(GetParent());
		return TRUE;
	}

	LRESULT OnCloseCmd(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		::EndDialog(m_hWnd, wID);
		return 0;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CContainedWindow - Implements a contained window

template <class TBase = CWindow, class TWinTraits = CControlWinTraits>
class CContainedWindowT : public TBase
{
public:
	CWndProcThunk m_thunk;
	LPCTSTR m_lpszClassName;
	WNDPROC m_pfnSuperWindowProc;
	CMessageMap* m_pObject;
	DWORD m_dwMsgMapID;
	const _ATL_MSG* m_pCurrentMsg;

	// If you use this constructor you must supply
	// the Window Class Name, Object* and Message Map ID
	// Later to the Create call
	CContainedWindowT() : m_pCurrentMsg(NULL)
	{ }

	CContainedWindowT(LPTSTR lpszClassName, CMessageMap* pObject, DWORD dwMsgMapID = 0)
		: m_lpszClassName(lpszClassName),
		m_pfnSuperWindowProc(::DefWindowProc),
		m_pObject(pObject), m_dwMsgMapID(dwMsgMapID),
		m_pCurrentMsg(NULL)
	{ }

	CContainedWindowT(CMessageMap* pObject, DWORD dwMsgMapID = 0)
		: m_lpszClassName(TBase::GetWndClassName()),
		m_pfnSuperWindowProc(::DefWindowProc),
		m_pObject(pObject), m_dwMsgMapID(dwMsgMapID),
		m_pCurrentMsg(NULL)
	{ }

	void SwitchMessageMap(DWORD dwMsgMapID)
	{
		m_dwMsgMapID = dwMsgMapID;
	}

	const _ATL_MSG* GetCurrentMessage() const
	{
		return m_pCurrentMsg;
	}

	LRESULT DefWindowProc()
	{
		const _ATL_MSG* pMsg = m_pCurrentMsg;
		LRESULT lRes = 0;
		if (pMsg != NULL)
			lRes = DefWindowProc(pMsg->message, pMsg->wParam, pMsg->lParam);
		return lRes;
	}

	LRESULT DefWindowProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
#ifdef STRICT
		return ::CallWindowProc(m_pfnSuperWindowProc, m_hWnd, uMsg, wParam, lParam);
#else
		return ::CallWindowProc((FARPROC)m_pfnSuperWindowProc, m_hWnd, uMsg, wParam, lParam);
#endif
	}
	static LRESULT CALLBACK StartWindowProc(HWND hWnd, UINT uMsg,
		WPARAM wParam, LPARAM lParam)
	{
		CContainedWindowT< TBase >* pThis = (CContainedWindowT< TBase >*)_AtlWinModule.ExtractCreateWndData();
		ATLASSERT(pThis != NULL);
		pThis->m_hWnd = hWnd;
		pThis->m_thunk.Init(WindowProc, pThis);
		WNDPROC pProc = pThis->m_thunk.GetWNDPROC();
		WNDPROC pOldProc = (WNDPROC)::SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)pProc);
#ifdef _DEBUG
		// check if somebody has subclassed us already since we discard it
		if(pOldProc != StartWindowProc)
			ATLTRACE(atlTraceWindowing, 0, _T("Subclassing through a hook discarded.\n"));
#else
		pOldProc;	// avoid unused warning
#endif
		return pProc(hWnd, uMsg, wParam, lParam);
	}

	static LRESULT CALLBACK WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		CContainedWindowT< TBase >* pThis = (CContainedWindowT< TBase >*)hWnd;
		ATLASSERT(pThis->m_hWnd != NULL);
		ATLASSERT(pThis->m_pObject != NULL);
		// set a ptr to this message and save the old value
		_ATL_MSG msg(pThis->m_hWnd, uMsg, wParam, lParam);
		const _ATL_MSG* pOldMsg = pThis->m_pCurrentMsg;
		pThis->m_pCurrentMsg = &msg;
		// pass to the message map to process
		LRESULT lRes;
		BOOL bRet = pThis->m_pObject->ProcessWindowMessage(pThis->m_hWnd, uMsg, wParam, lParam, lRes, pThis->m_dwMsgMapID);
		// restore saved value for the current message
		ATLASSERT(pThis->m_pCurrentMsg == &msg);
		pThis->m_pCurrentMsg = pOldMsg;
		// do the default processing if message was not handled
		if(!bRet)
		{
			if(uMsg != WM_NCDESTROY)
				lRes = pThis->DefWindowProc(uMsg, wParam, lParam);
			else
			{
				// unsubclass, if needed
				LONG_PTR pfnWndProc = ::GetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC);
				lRes = pThis->DefWindowProc(uMsg, wParam, lParam);
				if(pThis->m_pfnSuperWindowProc != ::DefWindowProc && ::GetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC) == pfnWndProc)
					::SetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC, (LONG_PTR)pThis->m_pfnSuperWindowProc);
				// clear out window handle
				pThis->m_hWnd = NULL;
			}
		}
		return lRes;
	}

	ATOM RegisterWndSuperclass()
	{
		ATOM atom = 0;
		LPTSTR szBuff = (LPTSTR)_alloca((lstrlen(m_lpszClassName) + 14) * sizeof(TCHAR));

		WNDCLASSEX wc;
		wc.cbSize = sizeof(WNDCLASSEX);

		// Try global class
		if(!::GetClassInfoEx(NULL, m_lpszClassName, &wc))
		{
			// try local class
			if(!::GetClassInfoEx(_AtlBaseModule.GetModuleInstance(), m_lpszClassName, &wc))
				return atom;
		}

		m_pfnSuperWindowProc = wc.lpfnWndProc;
		lstrcpy(szBuff, _T("ATL:"));
		lstrcat(szBuff, m_lpszClassName);

		WNDCLASSEX wc1;
		wc1.cbSize = sizeof(WNDCLASSEX);
		atom = (ATOM)::GetClassInfoEx(_AtlBaseModule.GetModuleInstance(), szBuff, &wc1);

		if(atom == 0)   // register class
		{
			wc.lpszClassName = szBuff;
			wc.lpfnWndProc = StartWindowProc;
			wc.hInstance = _AtlBaseModule.GetModuleInstance();
			wc.style &= ~CS_GLOBALCLASS;	// we don't register global classes

			atom = AtlWinModuleRegisterClassEx(&_AtlWinModule, &wc);
		}
		return atom;
	}

	HWND Create(HWND hWndParent, _U_RECT rect, LPCTSTR szWindowName = NULL,
		DWORD dwStyle = 0, DWORD dwExStyle = 0,
		_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		ATLASSERT(m_hWnd == NULL);

		ATOM atom = RegisterWndSuperclass();
		if(atom == 0)
			return NULL;

		_AtlWinModule.AddCreateWndData(&m_thunk.cd, this);

		if(MenuOrID.m_hMenu == NULL && (dwStyle & WS_CHILD))
			MenuOrID.m_hMenu = (HMENU)(UINT_PTR)this;
		if(rect.m_lpRect == NULL)
			rect.m_lpRect = &TBase::rcDefault;

		dwStyle = TWinTraits::GetWndStyle(dwStyle);
		dwExStyle = TWinTraits::GetWndExStyle(dwExStyle);

		HWND hWnd = ::CreateWindowEx(dwExStyle, MAKEINTATOM(atom), szWindowName,
								dwStyle,
								rect.m_lpRect->left, rect.m_lpRect->top,
								rect.m_lpRect->right - rect.m_lpRect->left,
								rect.m_lpRect->bottom - rect.m_lpRect->top,
								hWndParent, MenuOrID.m_hMenu,
								_AtlBaseModule.GetModuleInstance(), lpCreateParam);
		ATLASSERT(m_hWnd == hWnd);
		return hWnd;
	}

	HWND Create(CMessageMap* pObject, DWORD dwMsgMapID, HWND hWndParent, _U_RECT rect,
		LPCTSTR szWindowName = NULL, DWORD dwStyle = 0, DWORD dwExStyle = 0,
		_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		m_lpszClassName = TBase::GetWndClassName();
		m_pfnSuperWindowProc = ::DefWindowProc;
		m_pObject = pObject;
		m_dwMsgMapID = dwMsgMapID;
		return Create(hWndParent, rect, szWindowName, dwStyle, dwExStyle, MenuOrID, lpCreateParam);
	}

	HWND Create(LPCTSTR lpszClassName, CMessageMap* pObject, DWORD dwMsgMapID, HWND hWndParent, _U_RECT rect, LPCTSTR szWindowName = NULL,
		DWORD dwStyle = 0, DWORD dwExStyle = 0, _U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		m_lpszClassName = lpszClassName;
		m_pfnSuperWindowProc = ::DefWindowProc;
		m_pObject = pObject;
		m_dwMsgMapID = dwMsgMapID;
		return Create(hWndParent, rect, szWindowName, dwStyle, dwExStyle, MenuOrID, lpCreateParam);
	}

	BOOL SubclassWindow(HWND hWnd)
	{
		ATLASSERT(m_hWnd == NULL);
		ATLASSERT(::IsWindow(hWnd));

		m_thunk.Init(WindowProc, this);
		WNDPROC pProc = m_thunk.GetWNDPROC();
		WNDPROC pfnWndProc = (WNDPROC)::SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)pProc);
		if(pfnWndProc == NULL)
			return FALSE;
		m_pfnSuperWindowProc = pfnWndProc;
		m_hWnd = hWnd;
		return TRUE;
	}

	// Use only if you want to subclass before window is destroyed,
	// WindowProc will automatically subclass when  window goes away
	HWND UnsubclassWindow(BOOL bForce = FALSE)
	{
		ATLASSERT(m_hWnd != NULL);

		WNDPROC pOurProc = m_thunk.GetWNDPROC();
		WNDPROC pActiveProc = (WNDPROC)::GetWindowLongPtr(m_hWnd, GWLP_WNDPROC);

		HWND hWnd = NULL;
		if (bForce || pOurProc == pActiveProc)
		{
			if(!::SetWindowLongPtr(m_hWnd, GWLP_WNDPROC, (LONG_PTR)m_pfnSuperWindowProc))
				return NULL;

			m_pfnSuperWindowProc = ::DefWindowProc;
			hWnd = m_hWnd;
			m_hWnd = NULL;
		}
		return hWnd;
	}
	LRESULT ReflectNotifications(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		HWND hWndChild = NULL;

		switch(uMsg)
		{
		case WM_COMMAND:
			if(lParam != NULL)	// not from a menu
				hWndChild = (HWND)lParam;
			break;
		case WM_NOTIFY:
			hWndChild = ((LPNMHDR)lParam)->hwndFrom;
			break;
		case WM_PARENTNOTIFY:
			switch(LOWORD(wParam))
			{
			case WM_CREATE:
			case WM_DESTROY:
				hWndChild = (HWND)lParam;
				break;
			default:
				hWndChild = GetDlgItem(HIWORD(wParam));
				break;
			}
			break;
		case WM_DRAWITEM:
			if(wParam)	// not from a menu
				hWndChild = ((LPDRAWITEMSTRUCT)lParam)->hwndItem;
			break;
		case WM_MEASUREITEM:
			if(wParam)	// not from a menu
				hWndChild = GetDlgItem(((LPMEASUREITEMSTRUCT)lParam)->CtlID);
			break;
		case WM_COMPAREITEM:
			if(wParam)	// not from a menu
				hWndChild = GetDlgItem(((LPCOMPAREITEMSTRUCT)lParam)->CtlID);
			break;
		case WM_DELETEITEM:
			if(wParam)	// not from a menu
				hWndChild = GetDlgItem(((LPDELETEITEMSTRUCT)lParam)->CtlID);
			break;
		case WM_VKEYTOITEM:
		case WM_CHARTOITEM:
		case WM_HSCROLL:
		case WM_VSCROLL:
			hWndChild = (HWND)lParam;
			break;
		case WM_CTLCOLORBTN:
		case WM_CTLCOLORDLG:
		case WM_CTLCOLOREDIT:
		case WM_CTLCOLORLISTBOX:
		case WM_CTLCOLORMSGBOX:
		case WM_CTLCOLORSCROLLBAR:
		case WM_CTLCOLORSTATIC:
			hWndChild = (HWND)lParam;
			break;
		default:
			break;
		}

		if(hWndChild == NULL)
		{
			bHandled = FALSE;
			return 1;
		}

		ATLASSERT(::IsWindow(hWndChild));
		return ::SendMessage(hWndChild, OCM__BASE + uMsg, wParam, lParam);
	}
};

typedef CContainedWindowT<CWindow>	CContainedWindow;

/////////////////////////////////////////////////////////////////////////////
// _DialogSizeHelper - helpers for calculating the size of a dialog template

class _DialogSizeHelper
{
public:
//local struct used for implementation
#pragma pack(push, 1)
	struct _ATL_DLGTEMPLATEEX
	{
		WORD dlgVer;
		WORD signature;
		DWORD helpID;
		DWORD exStyle;
		DWORD style;
		WORD cDlgItems;
		short x;
		short y;
		short cx;
		short cy;
	};
#pragma pack(pop)

	static void GetDialogSize(const DLGTEMPLATE* pTemplate, SIZE* pSize, bool bPropertyPage = false)
	{
		// If the dialog has a font we use it otherwise we default
		// to the system font.
		TCHAR szFace[LF_FACESIZE];
		WORD  wFontSize = 0;
		GetSizeInDialogUnits(pTemplate, pSize);
		BOOL bFont = GetFont(pTemplate, szFace, &wFontSize);
		if (bFont)
		{
			ConvertDialogUnitsToPixels(szFace, wFontSize, pSize, bPropertyPage);
		}
		else
		{
			ConvertDialogUnitsToPixels(NULL, 0, pSize, bPropertyPage);
		}
	}

	static void GetFontDimensions(LPCTSTR pszFontFace, WORD wFontSize, SIZE* pSizeChar, LONG *ptmHeight)
	{
		if (pszFontFace != NULL)
		{
			// Attempt to create the font to be used in the dialog box
			HDC hDC = ::GetDC(NULL);
			if (hDC != NULL)
			{
				LOGFONT lf;
				memset(&lf, 0, sizeof(LOGFONT));
				lf.lfHeight = -MulDiv(wFontSize, GetDeviceCaps(hDC, LOGPIXELSY), 72);
				lf.lfWeight = FW_NORMAL;
				lf.lfCharSet = DEFAULT_CHARSET;
				lstrcpy(lf.lfFaceName, pszFontFace);

				HFONT hNewFont = CreateFontIndirect(&lf);
				if (hNewFont != NULL)
				{
					TEXTMETRIC  tm;
					SIZE        size;
					HFONT       hFontOld = (HFONT)SelectObject(hDC, hNewFont);
					GetTextMetrics(hDC, &tm);
					::GetTextExtentPoint(hDC,
						_T("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"), 52,
						&size);
					SelectObject(hDC, hFontOld);
					DeleteObject(hNewFont);
					*ptmHeight = tm.tmHeight;
					pSizeChar->cy = tm.tmHeight + tm.tmExternalLeading;
					pSizeChar->cx = (size.cx + 26) / 52;
					::ReleaseDC(NULL, hDC);
					return;
				}
				::ReleaseDC(NULL, hDC);
			}
		}
		// Could not create font or no font name was not specified
		LONG nDlgBaseUnits = GetDialogBaseUnits();
		pSizeChar->cx = LOWORD(nDlgBaseUnits);
		*ptmHeight = pSizeChar->cy = HIWORD(nDlgBaseUnits);
	}

// ID of the dialog template used for property sheet in comctl32.dll
#define IDD_PROPSHEET_ID   1006

	static void ConvertDialogUnitsToPixels(LPCTSTR pszFontFace, WORD wFontSize, SIZE* pSizePixel, bool bPropertyPage = false)
	{
		LONG tmHeight;
		SIZE sizeFontChar;
		GetFontDimensions(pszFontFace, wFontSize, &sizeFontChar, &tmHeight);
		if (bPropertyPage)
		{
			// Get the font used by the property sheet
			HINSTANCE hInst = LoadLibrary(_T("COMCTL32.DLL"));
			if (hInst != NULL)
			{
				HRSRC hResource = ::FindResource(hInst,
					MAKEINTRESOURCE(IDD_PROPSHEET_ID),
					RT_DIALOG);
				if (hResource != NULL)
				{
					HGLOBAL hTemplate = LoadResource(hInst, hResource);
					if (hTemplate != NULL)
					{
						TCHAR szFace[LF_FACESIZE];
						WORD wSize;
						BOOL bFont;
						bFont = _DialogSizeHelper::GetFont((DLGTEMPLATE*)hTemplate, szFace,	&wSize);
						FreeLibrary(hInst);
						if (bFont)
						{
							SIZE sizeSheetFontChar;
							LONG tmHeightSheetFont;
							GetFontDimensions(szFace, wSize, &sizeSheetFontChar, &tmHeightSheetFont);
							// Now translate to pixels compensating for the calculations made by OLEAUT32 and Dialog manager

							// Calculate the size of pixels using property sheet font.
							pSizePixel->cx = MulDiv(pSizePixel->cx, sizeFontChar.cx, 4);
							pSizePixel->cy = MulDiv(pSizePixel->cy, sizeSheetFontChar.cy, 8);

							// Inflate/Deflate the height to compensate for the correct font.
							pSizePixel->cy = MulDiv(pSizePixel->cy, tmHeight, tmHeightSheetFont);
							return ;
						}
					}
				}
			}
		}
		// Not property page or could not load Property sheet resource.
		// Translate dialog units to pixels
		pSizePixel->cx = MulDiv(pSizePixel->cx, sizeFontChar.cx, 4);
		pSizePixel->cy = MulDiv(pSizePixel->cy, sizeFontChar.cy, 8);
	}

	static BOOL IsDialogEx(const DLGTEMPLATE* pTemplate)
	{
		return ((_ATL_DLGTEMPLATEEX*)pTemplate)->signature == 0xFFFF;
	}

	static BOOL HasFont(const DLGTEMPLATE* pTemplate)
	{
		return (DS_SETFONT &
			(IsDialogEx(pTemplate) ?
				((_ATL_DLGTEMPLATEEX*)pTemplate)->style : pTemplate->style));
	}

	static BYTE* GetFontSizeField(const DLGTEMPLATE* pTemplate)
	{
		BOOL bDialogEx = IsDialogEx(pTemplate);
		WORD* pw;

		if (bDialogEx)
			pw = (WORD*)((_ATL_DLGTEMPLATEEX*)pTemplate + 1);
		else
			pw = (WORD*)(pTemplate + 1);

		if (*pw == (WORD)-1)        // Skip menu name string or ordinal
			pw += 2; // WORDs
		else
			while(*pw++);

		if (*pw == (WORD)-1)        // Skip class name string or ordinal
			pw += 2; // WORDs
		else
			while(*pw++);

		while (*pw++);          // Skip caption string

		return (BYTE*)pw;
	}

	static BOOL GetFont(const DLGTEMPLATE* pTemplate, TCHAR* pszFace, WORD* pFontSize)
	{
		USES_CONVERSION;
		if (!HasFont(pTemplate))
			return FALSE;

		BYTE* pb = GetFontSizeField(pTemplate);
		*pFontSize = *(WORD*)pb;
		// Skip over font attributes to get to the font name
		pb += sizeof(WORD) * (IsDialogEx(pTemplate) ? 3 : 1);

		_tcscpy(pszFace, W2T((WCHAR*)pb));
		return TRUE;
	}

	static void GetSizeInDialogUnits(const DLGTEMPLATE* pTemplate, SIZE* pSize)
	{
		if (IsDialogEx(pTemplate))
		{
			pSize->cx = ((_ATL_DLGTEMPLATEEX*)pTemplate)->cx;
			pSize->cy = ((_ATL_DLGTEMPLATEEX*)pTemplate)->cy;
		}
		else
		{
			pSize->cx = pTemplate->cx;
			pSize->cy = pTemplate->cy;
		}
	}
};

inline void AtlGetDialogSize(const DLGTEMPLATE* pTemplate, SIZE* pSize, bool bPropertyPage = false)
{
	ATLASSERT(pTemplate != NULL);
	ATLASSERT(pSize != NULL);
	_DialogSizeHelper::GetDialogSize(pTemplate, pSize, bPropertyPage);
}

}; //namespace ATL

#ifndef _ATL_NO_HOSTING
#include <atlhost.h>
#endif

#ifndef _ATL_DLL_IMPL
#ifndef _ATL_DLL
#define _ATLWIN_IMPL
#endif
#endif

//REVIEW: Just to fix VSEE
#pragma pop_macro("min")
#pragma pop_macro("max")

#endif // __ATLWIN_H__

//All exports go here
#ifdef _ATLWIN_IMPL


//#ifndef _ATL_DLL_IMPL
namespace ATL
{
//#endif

class AtlModuleRegisterWndClassInfoParamA
{
public:
	typedef LPSTR				PXSTR;
	typedef LPCSTR				PCXSTR;
	typedef _ATL_WNDCLASSINFOA	_ATL_WNDCLASSINFO;
	typedef WNDCLASSEXA			WNDCLASSEX;

	static BOOL GetClassInfoEx(HINSTANCE hinst, PCXSTR lpszClass, WNDCLASSEX* lpwcx)
	{
		return ::GetClassInfoExA(hinst, lpszClass, lpwcx);
	}

	static void FormatWindowClassName(PXSTR szBuffer, void* unique)
	{
#if defined(_WIN64) // || or Windows 2000
		::wsprintfA(szBuffer, "ATL:%p", unique);
#else
		::wsprintfA(szBuffer, "ATL:%8.8X", reinterpret_cast<DWORD_PTR>(unique));
#endif
	}
	
	static HCURSOR LoadCursor(HINSTANCE hInstance, PCXSTR lpCursorName)
	{
		return ::LoadCursorA(hInstance, lpCursorName);
	}

	static ATOM RegisterClassEx(_ATL_WIN_MODULE* pWinModule, const WNDCLASSEX* lpwcx)
	{
		return AtlWinModuleRegisterClassExA(pWinModule, lpwcx);
	}
};

class AtlModuleRegisterWndClassInfoParamW
{
public:
	typedef LPWSTR				PXSTR;
	typedef LPCWSTR				PCXSTR;
	typedef _ATL_WNDCLASSINFOW	_ATL_WNDCLASSINFO;
	typedef WNDCLASSEXW			WNDCLASSEX;

	static BOOL GetClassInfoEx(HINSTANCE hinst, PCXSTR lpszClass, WNDCLASSEX* lpwcx)
	{
		return ::GetClassInfoExW(hinst, lpszClass, lpwcx);
	}

	static void FormatWindowClassName(PXSTR szBuffer, void* unique)
	{
#if defined(_WIN64) // || or Windows 2000
		::wsprintfW(szBuffer, L"ATL:%p", unique);
#else
		::wsprintfW(szBuffer, L"ATL:%8.8X", reinterpret_cast<DWORD_PTR>(unique));
#endif
	}
	
	static HCURSOR LoadCursor(HINSTANCE hInstance, PCXSTR lpCursorName)
	{
		return ::LoadCursorW(hInstance, lpCursorName);
	}

	static ATOM RegisterClassEx(_ATL_WIN_MODULE* pWinModule, const WNDCLASSEX* lpwcx)
	{
		return AtlWinModuleRegisterClassExW(pWinModule, lpwcx);
	}
};

ATLINLINE ATLAPI_(ATOM) AtlWinModuleRegisterClassExA(_ATL_WIN_MODULE* pWinModule, const WNDCLASSEXA *lpwc)
{
	ATOM atom = ::RegisterClassExA(lpwc);
	pWinModule->m_rgWindowClassAtoms[pWinModule->m_nAtomIndex++] = atom;
	return atom;
}

ATLINLINE ATLAPI_(ATOM) AtlWinModuleRegisterClassExW(_ATL_WIN_MODULE* pWinModule, const WNDCLASSEXW *lpwc)
{
	ATOM atom = ::RegisterClassExW(lpwc);
	pWinModule->m_rgWindowClassAtoms[pWinModule->m_nAtomIndex++] = atom;
	return atom;
}


template <class T>
ATLINLINE ATOM AtlModuleRegisterWndClassInfoT(_ATL_BASE_MODULE* pBaseModule, _ATL_WIN_MODULE* pWinModule, T::_ATL_WNDCLASSINFO* p, WNDPROC* pProc, T)
{
	if (p->m_atom == 0)
	{
		CComCritSecLock<CComCriticalSection> lock(pWinModule->m_csWindowCreate, false);
		if (FAILED(lock.Lock()))
		{
			ATLTRACE(atlTraceWindowing, 0, _T("ERROR : Unable to lock critical section in AtlModuleRegisterWndClassInfoT\n"));
			ATLASSERT(0);
			return 0;
		}
		if(p->m_atom == 0)
		{
			if (p->m_lpszOrigName != NULL)
			{
				ATLASSERT(pProc != NULL);
				T::PCXSTR lpsz = p->m_wc.lpszClassName;
				WNDPROC proc = p->m_wc.lpfnWndProc;

				T::WNDCLASSEX wc;
				wc.cbSize = sizeof(T::WNDCLASSEX);
				// Try global class
				if(!T::GetClassInfoEx(NULL, p->m_lpszOrigName, &wc))
				{
					// try process local
					if(!T::GetClassInfoEx(pBaseModule->m_hInst, p->m_lpszOrigName, &wc))
					{
						ATLTRACE(atlTraceWindowing, 0, "ERROR : Could not obtain Window Class information for %s\n", p->m_lpszOrigName);
						return 0;
					}
				}
				p->m_wc = wc;
				p->pWndProc = p->m_wc.lpfnWndProc;
				p->m_wc.lpszClassName = lpsz;
				p->m_wc.lpfnWndProc = proc;
			}
			else
			{
				p->m_wc.hCursor = T::LoadCursor(p->m_bSystemCursor ? NULL : pBaseModule->m_hInstResource,
					p->m_lpszCursorID);
			}

			p->m_wc.hInstance = pBaseModule->m_hInst;
			p->m_wc.style &= ~CS_GLOBALCLASS;	// we don't register global classes
			if (p->m_wc.lpszClassName == NULL)
			{
				T::FormatWindowClassName(p->m_szAutoName, &p->m_wc);
				p->m_wc.lpszClassName = p->m_szAutoName;
			}
			T::WNDCLASSEX wcTemp;
			wcTemp = p->m_wc;
			p->m_atom = static_cast<ATOM>(T::GetClassInfoEx(p->m_wc.hInstance, p->m_wc.lpszClassName, &wcTemp));
			if (p->m_atom == 0)
			{
				p->m_atom = T::RegisterClassEx(pWinModule, &p->m_wc);
			}
		}
	}

	if (p->m_lpszOrigName != NULL)
	{
		ATLASSERT(pProc != NULL);
		ATLASSERT(p->pWndProc != NULL);
		*pProc = p->pWndProc;
	}
	return p->m_atom;
}

ATLINLINE ATLAPI_(ATOM) AtlWinModuleRegisterWndClassInfoA(_ATL_WIN_MODULE* pWinModule, _ATL_BASE_MODULE* pBaseModule, _ATL_WNDCLASSINFOA* p, WNDPROC* pProc)
{
	AtlModuleRegisterWndClassInfoParamA templateParameter;
	return AtlModuleRegisterWndClassInfoT<AtlModuleRegisterWndClassInfoParamA>(pBaseModule, pWinModule, p, pProc, templateParameter);
}

ATLINLINE ATLAPI_(ATOM) AtlWinModuleRegisterWndClassInfoW(_ATL_WIN_MODULE* pWinModule, _ATL_BASE_MODULE* pBaseModule, _ATL_WNDCLASSINFOW* p, WNDPROC* pProc)
{
	AtlModuleRegisterWndClassInfoParamW templateParameter;
	return AtlModuleRegisterWndClassInfoT<AtlModuleRegisterWndClassInfoParamW>(pBaseModule, pWinModule, p, pProc, templateParameter);
}

ATLINLINE ATLAPI_(HDC) AtlCreateTargetDC(HDC hdc, DVTARGETDEVICE* ptd)
{
	USES_CONVERSION;

	// cases  hdc, ptd, hdc is metafile, hic
//  NULL,    NULL,  n/a,    Display
//  NULL,   !NULL,  n/a,    ptd
//  !NULL,   NULL,  FALSE,  hdc
//  !NULL,   NULL,  TRUE,   display
//  !NULL,  !NULL,  FALSE,  ptd
//  !NULL,  !NULL,  TRUE,   ptd

	if (ptd != NULL)
	{
		LPDEVMODEOLE lpDevMode;
		LPOLESTR lpszDriverName;
		LPOLESTR lpszDeviceName;
		LPOLESTR lpszPortName;

		if (ptd->tdExtDevmodeOffset == 0)
			lpDevMode = NULL;
		else
			lpDevMode  = (LPDEVMODEOLE) ((LPSTR)ptd + ptd->tdExtDevmodeOffset);

		lpszDriverName = (LPOLESTR)((BYTE*)ptd + ptd->tdDriverNameOffset);
		lpszDeviceName = (LPOLESTR)((BYTE*)ptd + ptd->tdDeviceNameOffset);
		lpszPortName   = (LPOLESTR)((BYTE*)ptd + ptd->tdPortNameOffset);

		return ::CreateDC(OLE2CT(lpszDriverName), OLE2CT(lpszDeviceName),
			OLE2CT(lpszPortName), DEVMODEOLE2T(lpDevMode));
	}
	else if (hdc == NULL || GetDeviceCaps(hdc, TECHNOLOGY) == DT_METAFILE)
		return ::CreateDC(_T("DISPLAY"), NULL, NULL, NULL);
	else
		return hdc;
}

ATLINLINE ATLAPI_(void) AtlHiMetricToPixel(const SIZEL * lpSizeInHiMetric, LPSIZEL lpSizeInPix)
{
	int nPixelsPerInchX;    // Pixels per logical inch along width
	int nPixelsPerInchY;    // Pixels per logical inch along height

	HDC hDCScreen = GetDC(NULL);
	ATLASSERT(hDCScreen != NULL);
	nPixelsPerInchX = GetDeviceCaps(hDCScreen, LOGPIXELSX);
	nPixelsPerInchY = GetDeviceCaps(hDCScreen, LOGPIXELSY);
	ReleaseDC(NULL, hDCScreen);

	lpSizeInPix->cx = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric->cx, nPixelsPerInchX);
	lpSizeInPix->cy = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric->cy, nPixelsPerInchY);
}

ATLINLINE ATLAPI_(void) AtlPixelToHiMetric(const SIZEL * lpSizeInPix, LPSIZEL lpSizeInHiMetric)
{
	int nPixelsPerInchX;    // Pixels per logical inch along width
	int nPixelsPerInchY;    // Pixels per logical inch along height

	HDC hDCScreen = GetDC(NULL);
	ATLASSERT(hDCScreen != NULL);
	nPixelsPerInchX = GetDeviceCaps(hDCScreen, LOGPIXELSX);
	nPixelsPerInchY = GetDeviceCaps(hDCScreen, LOGPIXELSY);
	ReleaseDC(NULL, hDCScreen);

	lpSizeInHiMetric->cx = MAP_PIX_TO_LOGHIM(lpSizeInPix->cx, nPixelsPerInchX);
	lpSizeInHiMetric->cy = MAP_PIX_TO_LOGHIM(lpSizeInPix->cy, nPixelsPerInchY);
}


//#ifndef _ATL_DLL_IMPL
}; //namespace ATL
//#endif

//Prevent pulling in second time 
#undef _ATLWIN_IMPL

#endif // _ATLWIN_IMPL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atlmfc\atltrace.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#ifndef __ATLTRACE_H__
#define __ATLTRACE_H__

#pragma once

#include <atldef.h>
#include <atlconv.h>

#ifdef _DEBUG
#include <stdio.h>
#include <stdarg.h>
#endif

#ifndef _ATL_NO_DEBUG_CRT
// Warning: if you define the above symbol, you will have
// to provide your own definition of the ATLASSERT(x) macro
// in order to compile ATL
	#include <crtdbg.h>
#endif

#ifdef _DEBUG
#include <atldebugapi.h>

extern "C" IMAGE_DOS_HEADER __ImageBase;
#endif  // _DEBUG

namespace ATL
{

// Declare a global instance of this class to automatically register a custom trace category at startup
class CTraceCategory
{
public:
	explicit CTraceCategory( LPCTSTR pszCategoryName, UINT nStartingLevel = 0 ) throw();

	operator DWORD_PTR() const throw();

public:
#ifdef _DEBUG
	DWORD_PTR m_dwCategory;
#endif
};

#ifdef _DEBUG

class CTrace
{
public:
	typedef int (__cdecl *fnCrtDbgReport_t)(int,const char *,int,const char *,const char *,...);

	CTrace(
#ifdef _ATL_NO_DEBUG_CRT
		fnCrtDbgReport_t pfnCrtDbgReport = NULL)
#else
		fnCrtDbgReport_t pfnCrtDbgReport = _CrtDbgReport)
#endif
		: m_hInst(reinterpret_cast<HINSTANCE>(&__ImageBase)),
			m_dwModule( 0 )
	{
		m_dwModule = AtlTraceRegister(m_hInst, pfnCrtDbgReport);
//		LoadSettings();
	}

	~CTrace()
	{
		AtlTraceUnregister(m_dwModule);
	}
	bool ChangeCategory(DWORD_PTR dwCategory, UINT nLevel, ATLTRACESTATUS eStatus)
	{
		return 0 !=
			AtlTraceModifyCategory(0, dwCategory, nLevel, eStatus);
	}

	bool GetCategory(DWORD_PTR dwCategory, UINT *pnLevel, ATLTRACESTATUS *peStatus)
	{
		ATLASSERT(pnLevel && peStatus);
		return 0 != AtlTraceGetCategory(0, dwCategory, pnLevel, peStatus);
	}

	void __cdecl TraceV(const char *pszFileName, int nLine,
		DWORD_PTR dwCategory, UINT nLevel, LPCSTR pszFmt, va_list args) const
	{
		AtlTraceVA(m_dwModule, pszFileName, nLine, dwCategory, nLevel, pszFmt, args);
	}
	void __cdecl TraceV(const char *pszFileName, int nLine,
		DWORD_PTR dwCategory, UINT nLevel, LPCWSTR pszFmt, va_list args) const
	{
		AtlTraceVU(m_dwModule, pszFileName, nLine, dwCategory, nLevel, pszFmt, args);
	}

	DWORD_PTR RegisterCategory(LPCSTR pszCategory)
		{return(AtlTraceRegisterCategoryA(m_dwModule, pszCategory));}
#ifdef _UNICODE
	DWORD_PTR RegisterCategory(LPCWSTR pszCategory)
		{return(AtlTraceRegisterCategoryU(m_dwModule, pszCategory));}
#endif

	bool LoadSettings(LPCTSTR pszFileName = NULL) const
		{return 0 != AtlTraceLoadSettings(pszFileName, FALSE);}
	void SaveSettings(LPCTSTR pszFileName = NULL) const
		{AtlTraceSaveSettings(pszFileName);}

protected:
	HINSTANCE m_hInst;
	DWORD_PTR m_dwModule;
};

extern CTrace g_AtlTrace;

extern CTraceCategory atlTraceGeneral;

class CTraceFileAndLineInfo
{
public:
	CTraceFileAndLineInfo(const char *pszFileName, int nLineNo)
		: m_pszFileName(pszFileName), m_nLineNo(nLineNo)
	{}

	void __cdecl operator()(DWORD_PTR dwCategory, UINT nLevel, const char *pszFmt, ...) const
	{
		va_list ptr; va_start(ptr, pszFmt);
		g_AtlTrace.TraceV(m_pszFileName, m_nLineNo, dwCategory, nLevel, pszFmt, ptr);
		va_end(ptr);
	}
	void __cdecl operator()(DWORD_PTR dwCategory, UINT nLevel, const wchar_t *pszFmt, ...) const
	{
		va_list ptr; va_start(ptr, pszFmt);
		g_AtlTrace.TraceV(m_pszFileName, m_nLineNo, dwCategory, nLevel, pszFmt, ptr);
		va_end(ptr);
	}
	void __cdecl operator()(const char *pszFmt, ...) const
	{
		va_list ptr; va_start(ptr, pszFmt);
		g_AtlTrace.TraceV(m_pszFileName, m_nLineNo, atlTraceGeneral, 0, pszFmt, ptr);
		va_end(ptr);
	}
	void __cdecl operator()(const wchar_t *pszFmt, ...) const
	{
		va_list ptr; va_start(ptr, pszFmt);
		g_AtlTrace.TraceV(m_pszFileName, m_nLineNo, atlTraceGeneral, 0, pszFmt, ptr);
		va_end(ptr);
	}

private:
	const char *const m_pszFileName;
	const int m_nLineNo;
};

#endif  // _DEBUG

#ifdef _DEBUG

inline CTraceCategory::CTraceCategory( LPCTSTR pszCategoryName, UINT nStartingLevel ) throw() :
	m_dwCategory( 0 )
{
	m_dwCategory = g_AtlTrace.RegisterCategory( pszCategoryName );
	g_AtlTrace.ChangeCategory( m_dwCategory, nStartingLevel, ATLTRACESTATUS_INHERIT);
}

inline CTraceCategory::operator DWORD_PTR() const throw()
{
	return( m_dwCategory );
}

#else  // !_DEBUG

inline CTraceCategory::CTraceCategory( LPCTSTR pszCategoryName, UINT nStartingLevel ) throw()
{
	(void)pszCategoryName;
	(void)nStartingLevel;
}

inline CTraceCategory::operator DWORD_PTR() const throw()
{
	return( 0 );
}

#endif  // _DEBUG

}  // namespace ATL

namespace ATL
{

#ifdef _DEBUG
#define DECLARE_TRACE_CATEGORY( name ) extern ATL::CTraceCategory name;
#else
#define DECLARE_TRACE_CATEGORY( name ) const DWORD_PTR name = 0;
#endif

DECLARE_TRACE_CATEGORY( atlTraceGeneral )
DECLARE_TRACE_CATEGORY( atlTraceCOM )  
DECLARE_TRACE_CATEGORY( atlTraceQI )	
DECLARE_TRACE_CATEGORY( atlTraceRegistrar )
DECLARE_TRACE_CATEGORY( atlTraceRefcount )
DECLARE_TRACE_CATEGORY( atlTraceWindowing )
DECLARE_TRACE_CATEGORY( atlTraceControls )
DECLARE_TRACE_CATEGORY( atlTraceHosting ) 
DECLARE_TRACE_CATEGORY( atlTraceDBClient )  
DECLARE_TRACE_CATEGORY( atlTraceDBProvider )
DECLARE_TRACE_CATEGORY( atlTraceSnapin )
DECLARE_TRACE_CATEGORY( atlTraceNotImpl )   
DECLARE_TRACE_CATEGORY( atlTraceAllocation )
DECLARE_TRACE_CATEGORY( atlTraceException )
DECLARE_TRACE_CATEGORY( atlTraceTime )
DECLARE_TRACE_CATEGORY( atlTraceCache )		
DECLARE_TRACE_CATEGORY( atlTraceStencil )
DECLARE_TRACE_CATEGORY( atlTraceString )
DECLARE_TRACE_CATEGORY( atlTraceMap )	
DECLARE_TRACE_CATEGORY( atlTraceUtil )		
DECLARE_TRACE_CATEGORY( atlTraceSecurity )
DECLARE_TRACE_CATEGORY( atlTraceSync )
DECLARE_TRACE_CATEGORY( atlTraceISAPI )		

// atlTraceUser categories are no longer needed.  Just declare your own trace category using CTraceCategory.
DECLARE_TRACE_CATEGORY( atlTraceUser )
DECLARE_TRACE_CATEGORY( atlTraceUser2 )
DECLARE_TRACE_CATEGORY( atlTraceUser3 )
DECLARE_TRACE_CATEGORY( atlTraceUser4 )

#pragma deprecated( atlTraceUser )
#pragma deprecated( atlTraceUser2 )
#pragma deprecated( atlTraceUser3 )
#pragma deprecated( atlTraceUser4 )

#ifdef _DEBUG

#ifndef _ATL_NO_DEBUG_CRT
class CNoUIAssertHook
{
public:
	CNoUIAssertHook()
	{
		ATLASSERT( s_pfnPrevHook == NULL );
		s_pfnPrevHook = _CrtSetReportHook(CrtHookProc);
	}
	~CNoUIAssertHook()
	{
		_CrtSetReportHook(s_pfnPrevHook);
		s_pfnPrevHook = NULL;
	}

private:
	static int __cdecl CrtHookProc(int eReportType, char* pszMessage, int* pnRetVal)
	{
		if (eReportType == _CRT_ASSERT)
		{
			::OutputDebugStringA( "ASSERTION FAILED\n" );
			::OutputDebugStringA( pszMessage );
			*pnRetVal = 1;
			return TRUE;
		}

		if (s_pfnPrevHook != NULL)
		{
			return s_pfnPrevHook(eReportType, pszMessage, pnRetVal);
		}
		else
		{
			return FALSE;
		}
	}

private:
	static _CRT_REPORT_HOOK s_pfnPrevHook;
};

__declspec( selectany ) _CRT_REPORT_HOOK CNoUIAssertHook::s_pfnPrevHook = NULL;

#define DECLARE_NOUIASSERT() ATL::CNoUIAssertHook _g_NoUIAssertHook;

#endif  // _ATL_NO_DEBUG_CRT

#ifndef ATLTRACE
#define ATLTRACE ATL::CTraceFileAndLineInfo(__FILE__, __LINE__)
#define ATLTRACE2 ATLTRACE
#endif

inline void _cdecl AtlTrace(LPCSTR pszFormat, ...)
{
	va_list ptr;
	va_start(ptr, pszFormat);
	g_AtlTrace.TraceV(NULL, -1, atlTraceGeneral, 0, pszFormat, ptr);
	va_end(ptr);
}

inline void _cdecl AtlTrace(LPCWSTR pszFormat, ...)
{
	va_list ptr;
	va_start(ptr, pszFormat);
	g_AtlTrace.TraceV(NULL, -1, atlTraceGeneral, 0, pszFormat, ptr);
	va_end(ptr);
}

inline void _cdecl AtlTrace2(DWORD_PTR dwCategory, UINT nLevel, LPCSTR pszFormat, ...)
{
	va_list ptr;
	va_start(ptr, pszFormat);
	g_AtlTrace.TraceV(NULL, -1, dwCategory, nLevel, pszFormat, ptr);
	va_end(ptr);
}

inline void _cdecl AtlTrace2(DWORD_PTR dwCategory, UINT nLevel, LPCWSTR pszFormat, ...)
{
	va_list ptr;
	va_start(ptr, pszFormat);
	g_AtlTrace.TraceV(NULL, -1, dwCategory, nLevel, pszFormat, ptr);
	va_end(ptr);
}

#define ATLTRACENOTIMPL(funcname)   ATLTRACE(ATL::atlTraceNotImpl, 0, _T("ATL: %s not implemented.\n"), funcname); return E_NOTIMPL

#else // !DEBUG

inline void _cdecl AtlTraceNull(...){}
inline void _cdecl AtlTrace(LPCSTR , ...){}
inline void _cdecl AtlTrace2(DWORD_PTR, UINT, LPCSTR , ...){}
inline void _cdecl AtlTrace(LPCWSTR , ...){}
inline void _cdecl AtlTrace2(DWORD_PTR, UINT, LPCWSTR , ...){}
#ifndef ATLTRACE

// BUG BUG BUG  ATLTRACE != AtlTrace2!!!
#define ATLTRACE            __noop
#define ATLTRACE2           __noop
#endif //ATLTRACE
#define ATLTRACENOTIMPL(funcname)   return E_NOTIMPL
#define DECLARE_NOUIASSERT()

#endif //!_DEBUG

};  // namespace ATL

#endif  // __ATLTRACE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atlmfc\atltypes.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __ATLTYPES_H__
#define __ATLTYPES_H__

#pragma once

/////////////////////////////////////////////////////////////////////////////
// Classes declared in this file

class CSize;
class CPoint;
class CRect;

/////////////////////////////////////////////////////////////////////////////
// CSize - An extent, similar to Windows SIZE structure.

class CSize : public tagSIZE
{
public:

// Constructors
	// construct an uninitialized size
	CSize() throw();
	// create from two integers
	CSize(int initCX, int initCY) throw();
	// create from another size
	CSize(SIZE initSize) throw();
	// create from a point
	CSize(POINT initPt) throw();
	// create from a DWORD: cx = LOWORD(dw) cy = HIWORD(dw)
	CSize(DWORD dwSize) throw();

// Operations
	BOOL operator==(SIZE size) const throw();
	BOOL operator!=(SIZE size) const throw();
	void operator+=(SIZE size) throw();
	void operator-=(SIZE size) throw();
	void SetSize(int CX, int CY) throw();

// Operators returning CSize values
	CSize operator+(SIZE size) const throw();
	CSize operator-(SIZE size) const throw();
	CSize operator-() const throw();

// Operators returning CPoint values
	CPoint operator+(POINT point) const throw();
	CPoint operator-(POINT point) const throw();

// Operators returning CRect values
	CRect operator+(const RECT* lpRect) const throw();
	CRect operator-(const RECT* lpRect) const throw();
};

/////////////////////////////////////////////////////////////////////////////
// CPoint - A 2-D point, similar to Windows POINT structure.

class CPoint : public tagPOINT
{
public:
// Constructors

	// create an uninitialized point
	CPoint() throw();
	// create from two integers
	CPoint(int initX, int initY) throw();
	// create from another point
	CPoint(POINT initPt) throw();
	// create from a size
	CPoint(SIZE initSize) throw();
	// create from an LPARAM: x = LOWORD(dw) y = HIWORD(dw)
	CPoint(LPARAM dwPoint) throw();


// Operations

// translate the point
	void Offset(int xOffset, int yOffset) throw();
	void Offset(POINT point) throw();
	void Offset(SIZE size) throw();
	void SetPoint(int X, int Y) throw();

	BOOL operator==(POINT point) const throw();
	BOOL operator!=(POINT point) const throw();
	void operator+=(SIZE size) throw();
	void operator-=(SIZE size) throw();
	void operator+=(POINT point) throw();
	void operator-=(POINT point) throw();

// Operators returning CPoint values
	CPoint operator+(SIZE size) const throw();
	CPoint operator-(SIZE size) const throw();
	CPoint operator-() const throw();
	CPoint operator+(POINT point) const throw();

// Operators returning CSize values
	CSize operator-(POINT point) const throw();

// Operators returning CRect values
	CRect operator+(const RECT* lpRect) const throw();
	CRect operator-(const RECT* lpRect) const throw();
};

/////////////////////////////////////////////////////////////////////////////
// CRect - A 2-D rectangle, similar to Windows RECT structure.

class CRect : public tagRECT
{
// Constructors
public:
	// uninitialized rectangle
	CRect() throw();
	// from left, top, right, and bottom
	CRect(int l, int t, int r, int b) throw();
	// copy constructor
	CRect(const RECT& srcRect) throw();
	// from a pointer to another rect
	CRect(LPCRECT lpSrcRect) throw();
	// from a point and size
	CRect(POINT point, SIZE size) throw();
	// from two points
	CRect(POINT topLeft, POINT bottomRight) throw();

// Attributes (in addition to RECT members)

	// retrieves the width
	int Width() const throw();
	// returns the height
	int Height() const throw();
	// returns the size
	CSize Size() const throw();
	// reference to the top-left point
	CPoint& TopLeft() throw();
	// reference to the bottom-right point
	CPoint& BottomRight() throw();
	// const reference to the top-left point
	const CPoint& TopLeft() const throw();
	// const reference to the bottom-right point
	const CPoint& BottomRight() const throw();
	// the geometric center point of the rectangle
	CPoint CenterPoint() const throw();
	// swap the left and right
	void SwapLeftRight() throw();
	static void SwapLeftRight(LPRECT lpRect) throw();

	// convert between CRect and LPRECT/LPCRECT (no need for &)
	operator LPRECT() throw();
	operator LPCRECT() const throw();

	// returns TRUE if rectangle has no area
	BOOL IsRectEmpty() const throw();
	// returns TRUE if rectangle is at (0,0) and has no area
	BOOL IsRectNull() const throw();
	// returns TRUE if point is within rectangle
	BOOL PtInRect(POINT point) const throw();

// Operations

	// set rectangle from left, top, right, and bottom
	void SetRect(int x1, int y1, int x2, int y2) throw();
	void SetRect(POINT topLeft, POINT bottomRight) throw();
	// empty the rectangle
	void SetRectEmpty() throw();
	// copy from another rectangle
	void CopyRect(LPCRECT lpSrcRect) throw();
	// TRUE if exactly the same as another rectangle
	BOOL EqualRect(LPCRECT lpRect) const throw();

	// Inflate rectangle's width and height by
	// x units to the left and right ends of the rectangle
	// and y units to the top and bottom.
	void InflateRect(int x, int y) throw();
	// Inflate rectangle's width and height by
	// size.cx units to the left and right ends of the rectangle
	// and size.cy units to the top and bottom.
	void InflateRect(SIZE size) throw();
	// Inflate rectangle's width and height by moving individual sides.
	// Left side is moved to the left, right side is moved to the right,
	// top is moved up and bottom is moved down.
	void InflateRect(LPCRECT lpRect) throw();
	void InflateRect(int l, int t, int r, int b) throw();

	// deflate the rectangle's width and height without
	// moving its top or left
	void DeflateRect(int x, int y) throw();
	void DeflateRect(SIZE size) throw();
	void DeflateRect(LPCRECT lpRect) throw();
	void DeflateRect(int l, int t, int r, int b) throw();

	// translate the rectangle by moving its top and left
	void OffsetRect(int x, int y) throw();
	void OffsetRect(SIZE size) throw();
	void OffsetRect(POINT point) throw();
	void NormalizeRect() throw();

	// absolute position of rectangle
	void MoveToY(int y) throw();
	void MoveToX(int x) throw();
	void MoveToXY(int x, int y) throw();
	void MoveToXY(POINT point) throw();

	// set this rectangle to intersection of two others
	BOOL IntersectRect(LPCRECT lpRect1, LPCRECT lpRect2) throw();

	// set this rectangle to bounding union of two others
	BOOL UnionRect(LPCRECT lpRect1, LPCRECT lpRect2) throw();

	// set this rectangle to minimum of two others
	BOOL SubtractRect(LPCRECT lpRectSrc1, LPCRECT lpRectSrc2) throw();

// Additional Operations
	void operator=(const RECT& srcRect) throw();
	BOOL operator==(const RECT& rect) const throw();
	BOOL operator!=(const RECT& rect) const throw();
	void operator+=(POINT point) throw();
	void operator+=(SIZE size) throw();
	void operator+=(LPCRECT lpRect) throw();
	void operator-=(POINT point) throw();
	void operator-=(SIZE size) throw();
	void operator-=(LPCRECT lpRect) throw();
	void operator&=(const RECT& rect) throw();
	void operator|=(const RECT& rect) throw();

// Operators returning CRect values
	CRect operator+(POINT point) const throw();
	CRect operator-(POINT point) const throw();
	CRect operator+(LPCRECT lpRect) const throw();
	CRect operator+(SIZE size) const throw();
	CRect operator-(SIZE size) const throw();
	CRect operator-(LPCRECT lpRect) const throw();
	CRect operator&(const RECT& rect2) const throw();
	CRect operator|(const RECT& rect2) const throw();
	CRect MulDiv(int nMultiplier, int nDivisor) const throw();
};


// CSize
inline CSize::CSize()
	{ /* random filled */ }
inline CSize::CSize(int initCX, int initCY)
	{ cx = initCX; cy = initCY; }
inline CSize::CSize(SIZE initSize)
	{ *(SIZE*)this = initSize; }
inline CSize::CSize(POINT initPt)
	{ *(POINT*)this = initPt; }
inline CSize::CSize(DWORD dwSize)
	{
		cx = (short)LOWORD(dwSize);
		cy = (short)HIWORD(dwSize);
	}
inline BOOL CSize::operator==(SIZE size) const
	{ return (cx == size.cx && cy == size.cy); }
inline BOOL CSize::operator!=(SIZE size) const
	{ return (cx != size.cx || cy != size.cy); }
inline void CSize::operator+=(SIZE size)
	{ cx += size.cx; cy += size.cy; }
inline void CSize::operator-=(SIZE size)
	{ cx -= size.cx; cy -= size.cy; }
inline void CSize::SetSize(int CX, int CY)
	{ cx = CX; cy = CY; }	
inline CSize CSize::operator+(SIZE size) const
	{ return CSize(cx + size.cx, cy + size.cy); }
inline CSize CSize::operator-(SIZE size) const
	{ return CSize(cx - size.cx, cy - size.cy); }
inline CSize CSize::operator-() const
	{ return CSize(-cx, -cy); }
inline CPoint CSize::operator+(POINT point) const
	{ return CPoint(cx + point.x, cy + point.y); }
inline CPoint CSize::operator-(POINT point) const
	{ return CPoint(cx - point.x, cy - point.y); }
inline CRect CSize::operator+(const RECT* lpRect) const
	{ return CRect(lpRect) + *this; }
inline CRect CSize::operator-(const RECT* lpRect) const
	{ return CRect(lpRect) - *this; }

// CPoint
inline CPoint::CPoint()
	{ /* random filled */ }
inline CPoint::CPoint(int initX, int initY)
	{ x = initX; y = initY; }
inline CPoint::CPoint(POINT initPt)
	{ *(POINT*)this = initPt; }
inline CPoint::CPoint(SIZE initSize)
	{ *(SIZE*)this = initSize; }
inline CPoint::CPoint(LPARAM dwPoint)
	{
		x = (short)LOWORD(dwPoint);
		y = (short)HIWORD(dwPoint);
	}
inline void CPoint::Offset(int xOffset, int yOffset)
	{ x += xOffset; y += yOffset; }
inline void CPoint::Offset(POINT point)
	{ x += point.x; y += point.y; }
inline void CPoint::Offset(SIZE size)
	{ x += size.cx; y += size.cy; }
inline void CPoint::SetPoint(int X, int Y)
	{ x = X; y = Y; }
inline BOOL CPoint::operator==(POINT point) const
	{ return (x == point.x && y == point.y); }
inline BOOL CPoint::operator!=(POINT point) const
	{ return (x != point.x || y != point.y); }
inline void CPoint::operator+=(SIZE size)
	{ x += size.cx; y += size.cy; }
inline void CPoint::operator-=(SIZE size)
	{ x -= size.cx; y -= size.cy; }
inline void CPoint::operator+=(POINT point)
	{ x += point.x; y += point.y; }
inline void CPoint::operator-=(POINT point)
	{ x -= point.x; y -= point.y; }
inline CPoint CPoint::operator+(SIZE size) const
	{ return CPoint(x + size.cx, y + size.cy); }
inline CPoint CPoint::operator-(SIZE size) const
	{ return CPoint(x - size.cx, y - size.cy); }
inline CPoint CPoint::operator-() const
	{ return CPoint(-x, -y); }
inline CPoint CPoint::operator+(POINT point) const
	{ return CPoint(x + point.x, y + point.y); }
inline CSize CPoint::operator-(POINT point) const
	{ return CSize(x - point.x, y - point.y); }
inline CRect CPoint::operator+(const RECT* lpRect) const
	{ return CRect(lpRect) + *this; }
inline CRect CPoint::operator-(const RECT* lpRect) const
	{ return CRect(lpRect) - *this; }

// CRect
inline CRect::CRect()
	{ /* random filled */ }
inline CRect::CRect(int l, int t, int r, int b)
	{ left = l; top = t; right = r; bottom = b; }
inline CRect::CRect(const RECT& srcRect)
	{ ::CopyRect(this, &srcRect); }
inline CRect::CRect(LPCRECT lpSrcRect)
	{ ::CopyRect(this, lpSrcRect); }
inline CRect::CRect(POINT point, SIZE size)
	{ right = (left = point.x) + size.cx; bottom = (top = point.y) + size.cy; }
inline CRect::CRect(POINT topLeft, POINT bottomRight)
	{ left = topLeft.x; top = topLeft.y;
		right = bottomRight.x; bottom = bottomRight.y; }
inline int CRect::Width() const
	{ return right - left; }
inline int CRect::Height() const
	{ return bottom - top; }
inline CSize CRect::Size() const
	{ return CSize(right - left, bottom - top); }
inline CPoint& CRect::TopLeft()
	{ return *((CPoint*)this); }
inline CPoint& CRect::BottomRight()
	{ return *((CPoint*)this+1); }
inline const CPoint& CRect::TopLeft() const
	{ return *((CPoint*)this); }
inline const CPoint& CRect::BottomRight() const
	{ return *((CPoint*)this+1); }
inline CPoint CRect::CenterPoint() const
	{ return CPoint((left+right)/2, (top+bottom)/2); }
inline void CRect::SwapLeftRight()
	{ SwapLeftRight(LPRECT(this)); }
inline void CRect::SwapLeftRight(LPRECT lpRect)
	{ LONG temp = lpRect->left; lpRect->left = lpRect->right; lpRect->right = temp; }
inline CRect::operator LPRECT()
	{ return this; }
inline CRect::operator LPCRECT() const
	{ return this; }
inline BOOL CRect::IsRectEmpty() const
	{ return ::IsRectEmpty(this); }
inline BOOL CRect::IsRectNull() const
	{ return (left == 0 && right == 0 && top == 0 && bottom == 0); }
inline BOOL CRect::PtInRect(POINT point) const
	{ return ::PtInRect(this, point); }
inline void CRect::SetRect(int x1, int y1, int x2, int y2)
	{ ::SetRect(this, x1, y1, x2, y2); }
inline void CRect::SetRect(POINT topLeft, POINT bottomRight)
	{ ::SetRect(this, topLeft.x, topLeft.y, bottomRight.x, bottomRight.y); }
inline void CRect::SetRectEmpty()
	{ ::SetRectEmpty(this); }
inline void CRect::CopyRect(LPCRECT lpSrcRect)
	{ ::CopyRect(this, lpSrcRect); }
inline BOOL CRect::EqualRect(LPCRECT lpRect) const
	{ return ::EqualRect(this, lpRect); }
inline void CRect::InflateRect(int x, int y)
	{ ::InflateRect(this, x, y); }
inline void CRect::InflateRect(SIZE size)
	{ ::InflateRect(this, size.cx, size.cy); }
inline void CRect::DeflateRect(int x, int y)
	{ ::InflateRect(this, -x, -y); }
inline void CRect::DeflateRect(SIZE size)
	{ ::InflateRect(this, -size.cx, -size.cy); }
inline void CRect::OffsetRect(int x, int y)
	{ ::OffsetRect(this, x, y); }
inline void CRect::OffsetRect(POINT point)
	{ ::OffsetRect(this, point.x, point.y); }
inline void CRect::OffsetRect(SIZE size)
	{ ::OffsetRect(this, size.cx, size.cy); }
inline void CRect::MoveToY(int y)
	{ bottom = Height() + y; top = y; }
inline void CRect::MoveToX(int x)
	{ right = Width() + x; left = x; }
inline void CRect::MoveToXY(int x, int y)
	{ MoveToX(x); MoveToY(y); }
inline void CRect::MoveToXY(POINT pt)
	{ MoveToX(pt.x); MoveToY(pt.y); }
inline BOOL CRect::IntersectRect(LPCRECT lpRect1, LPCRECT lpRect2)
	{ return ::IntersectRect(this, lpRect1, lpRect2);}
inline BOOL CRect::UnionRect(LPCRECT lpRect1, LPCRECT lpRect2)
	{ return ::UnionRect(this, lpRect1, lpRect2); }
inline void CRect::operator=(const RECT& srcRect)
	{ ::CopyRect(this, &srcRect); }
inline BOOL CRect::operator==(const RECT& rect) const
	{ return ::EqualRect(this, &rect); }
inline BOOL CRect::operator!=(const RECT& rect) const
	{ return !::EqualRect(this, &rect); }
inline void CRect::operator+=(POINT point)
	{ ::OffsetRect(this, point.x, point.y); }
inline void CRect::operator+=(SIZE size)
	{ ::OffsetRect(this, size.cx, size.cy); }
inline void CRect::operator+=(LPCRECT lpRect)
	{ InflateRect(lpRect); }
inline void CRect::operator-=(POINT point)
	{ ::OffsetRect(this, -point.x, -point.y); }
inline void CRect::operator-=(SIZE size)
	{ ::OffsetRect(this, -size.cx, -size.cy); }
inline void CRect::operator-=(LPCRECT lpRect)
	{ DeflateRect(lpRect); }
inline void CRect::operator&=(const RECT& rect)
	{ ::IntersectRect(this, this, &rect); }
inline void CRect::operator|=(const RECT& rect)
	{ ::UnionRect(this, this, &rect); }
inline CRect CRect::operator+(POINT pt) const
	{ CRect rect(*this); ::OffsetRect(&rect, pt.x, pt.y); return rect; }
inline CRect CRect::operator-(POINT pt) const
	{ CRect rect(*this); ::OffsetRect(&rect, -pt.x, -pt.y); return rect; }
inline CRect CRect::operator+(SIZE size) const
	{ CRect rect(*this); ::OffsetRect(&rect, size.cx, size.cy); return rect; }
inline CRect CRect::operator-(SIZE size) const
	{ CRect rect(*this); ::OffsetRect(&rect, -size.cx, -size.cy); return rect; }
inline CRect CRect::operator+(LPCRECT lpRect) const
	{ CRect rect(this); rect.InflateRect(lpRect); return rect; }
inline CRect CRect::operator-(LPCRECT lpRect) const
	{ CRect rect(this); rect.DeflateRect(lpRect); return rect; }
inline CRect CRect::operator&(const RECT& rect2) const
	{ CRect rect; ::IntersectRect(&rect, this, &rect2);
		return rect; }
inline CRect CRect::operator|(const RECT& rect2) const
	{ CRect rect; ::UnionRect(&rect, this, &rect2);
		return rect; }
inline BOOL CRect::SubtractRect(LPCRECT lpRectSrc1, LPCRECT lpRectSrc2)
	{ return ::SubtractRect(this, lpRectSrc1, lpRectSrc2); }

inline void CRect::NormalizeRect()
	{
		int nTemp;
		if (left > right)
		{
			nTemp = left;
			left = right;
			right = nTemp;
		}
		if (top > bottom)
		{
			nTemp = top;
			top = bottom;
			bottom = nTemp;
		}
	}

inline void CRect::InflateRect(LPCRECT lpRect)
	{
		left -= lpRect->left;		top -= lpRect->top;
		right += lpRect->right;		bottom += lpRect->bottom;
	}

inline void CRect::InflateRect(int l, int t, int r, int b)
	{
		left -= l;			top -= t;
		right += r;			bottom += b;
	}

inline void CRect::DeflateRect(LPCRECT lpRect)
	{
		left += lpRect->left;	top += lpRect->top;
		right -= lpRect->right;	bottom -= lpRect->bottom;
	}

inline void CRect::DeflateRect(int l, int t, int r, int b)
	{
		left += l;		top += t;
		right -= r;		bottom -= b;
	}

inline CRect CRect::MulDiv(int nMultiplier, int nDivisor) const
	{
		return CRect(
			::MulDiv(left, nMultiplier, nDivisor),
			::MulDiv(top, nMultiplier, nDivisor),
			::MulDiv(right, nMultiplier, nDivisor),
			::MulDiv(bottom, nMultiplier, nDivisor));
	}

#endif // __ATLTYPES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atlmfc\atltime.inl ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLTIME_INL__
#define __ATLTIME_INL__

#pragma once

#ifndef __ATLTIME_H__
	#error atltime.inl requires atltime.h to be included first
#endif

#include <math.h>

namespace ATL
{
// Used only if these strings could not be found in resources.
__declspec(selectany) const TCHAR *szInvalidDateTime = _T("Invalid DateTime");
__declspec(selectany) const TCHAR *szInvalidDateTimeSpan = _T("Invalid DateTimeSpan");

const int maxTimeBufferSize = 128;
const long maxDaysInSpan  =	3615897L;

/////////////////////////////////////////////////////////////////////////////
// CTimeSpan
/////////////////////////////////////////////////////////////////////////////

inline CTimeSpan::CTimeSpan() :
	m_timeSpan(0)
{
}

inline CTimeSpan::CTimeSpan( __time64_t time ) :
	m_timeSpan( time )
{
}

inline CTimeSpan::CTimeSpan(LONG lDays, int nHours, int nMins, int nSecs)
{
 	m_timeSpan = nSecs + 60* (nMins + 60* (nHours + __int64(24) * lDays));
}

inline LONGLONG CTimeSpan::GetDays() const
{
	return( m_timeSpan/(24*3600) );
}

inline LONGLONG CTimeSpan::GetTotalHours() const
{
	return( m_timeSpan/3600 );
}

inline LONG CTimeSpan::GetHours() const
{
	return( LONG( GetTotalHours()-(GetDays()*24) ) );
}

inline LONGLONG CTimeSpan::GetTotalMinutes() const
{
	return( m_timeSpan/60 );
}

inline LONG CTimeSpan::GetMinutes() const
{
	return( LONG( GetTotalMinutes()-(GetTotalHours()*60) ) );
}

inline LONGLONG CTimeSpan::GetTotalSeconds() const
{
	return( m_timeSpan );
}

inline LONG CTimeSpan::GetSeconds() const
{
	return( LONG( GetTotalSeconds()-(GetTotalMinutes()*60) ) );
}

inline __time64_t CTimeSpan::GetTimeSpan() const
{
	return( m_timeSpan );
}

inline CTimeSpan CTimeSpan::operator+( CTimeSpan span ) const
{
	return( CTimeSpan( m_timeSpan+span.m_timeSpan ) );
}

inline CTimeSpan CTimeSpan::operator-( CTimeSpan span ) const
{
	return( CTimeSpan( m_timeSpan-span.m_timeSpan ) );
}

inline CTimeSpan& CTimeSpan::operator+=( CTimeSpan span )
{
	m_timeSpan += span.m_timeSpan;
	return( *this );
}

inline CTimeSpan& CTimeSpan::operator-=( CTimeSpan span )
{
	m_timeSpan -= span.m_timeSpan;
	return( *this );
}

inline bool CTimeSpan::operator==( CTimeSpan span ) const
{
	return( m_timeSpan == span.m_timeSpan );
}

inline bool CTimeSpan::operator!=( CTimeSpan span ) const
{
	return( m_timeSpan != span.m_timeSpan );
}

inline bool CTimeSpan::operator<( CTimeSpan span ) const
{
	return( m_timeSpan < span.m_timeSpan );
}

inline bool CTimeSpan::operator>( CTimeSpan span ) const
{
	return( m_timeSpan > span.m_timeSpan );
}

inline bool CTimeSpan::operator<=( CTimeSpan span ) const
{
	return( m_timeSpan <= span.m_timeSpan );
}

inline bool CTimeSpan::operator>=( CTimeSpan span ) const
{
	return( m_timeSpan >= span.m_timeSpan );
}

#ifndef _ATL_MIN_CRT
inline CString CTimeSpan::Format(LPCTSTR pFormat) const
// formatting timespans is a little trickier than formatting CTimes
//  * we are only interested in relative time formats, ie. it is illegal
//      to format anything dealing with absolute time (i.e. years, months,
//         day of week, day of year, timezones, ...)
//  * the only valid formats:
//      %D - # of days
//      %H - hour in 24 hour format
//      %M - minute (0-59)
//      %S - seconds (0-59)
//      %% - percent sign
{
	TCHAR szBuffer[maxTimeBufferSize];
	TCHAR ch;
	LPTSTR pch = szBuffer;

	while ((ch = *pFormat++) != _T('\0'))
	{
		ATLASSERT(pch < &szBuffer[maxTimeBufferSize-1]);
		if (ch == _T('%'))
		{
			switch (ch = *pFormat++)
			{
			default:
				ATLASSERT(FALSE);      // probably a bad format character
				break;
			case '%':
				*pch++ = ch;
				break;
			case 'D':
				pch += _stprintf(pch, _T("%I64d"), GetDays());
				break;
			case 'H':
				pch += _stprintf(pch, _T("%02ld"), GetHours());
				break;
			case 'M':
				pch += _stprintf(pch, _T("%02ld"), GetMinutes());
				break;
			case 'S':
				pch += _stprintf(pch, _T("%02ld"), GetSeconds());
				break;
			}
		}
		else
		{
			*pch++ = ch;
			if (_istlead(ch))
			{
				ATLASSERT(pch < &szBuffer[maxTimeBufferSize]);
				*pch++ = *pFormat++;
			}
		}
	}

	*pch = '\0';
	return szBuffer;
}

inline CString CTimeSpan::Format(UINT nFormatID) const
{
	CString strFormat;
	ATLVERIFY(strFormat.LoadString(nFormatID));
	return Format(strFormat);
}
#endif // !_ATL_MIN_CRT

#if defined(_AFX) && defined(_UNICODE)
inline CString CTimeSpan::Format(LPCSTR pFormat) const
{
	return Format(CString(pFormat));
}
#endif

/////////////////////////////////////////////////////////////////////////////
// CTime
/////////////////////////////////////////////////////////////////////////////

inline CTime CTime::GetCurrentTime()
{
	return( CTime( ::_time64( NULL ) ) );
}

inline CTime::CTime() :
	m_time(0)
{
}

inline CTime::CTime( __time64_t time ) :
	m_time( time )
{
}

inline CTime::CTime(int nYear, int nMonth, int nDay, int nHour, int nMin, int nSec,
	int nDST)
{
	struct tm atm;
	atm.tm_sec = nSec;
	atm.tm_min = nMin;
	atm.tm_hour = nHour;
	ATLASSERT(nDay >= 1 && nDay <= 31);
	atm.tm_mday = nDay;
	ATLASSERT(nMonth >= 1 && nMonth <= 12);
	atm.tm_mon = nMonth - 1;        // tm_mon is 0 based
	ATLASSERT(nYear >= 1900);
	atm.tm_year = nYear - 1900;     // tm_year is 1900 based
	atm.tm_isdst = nDST;
	m_time = _mktime64(&atm);
	ATLASSERT(m_time != -1);       // indicates an illegal input time
}

inline CTime::CTime(WORD wDosDate, WORD wDosTime, int nDST)
{
	struct tm atm;
	atm.tm_sec = (wDosTime & ~0xFFE0) << 1;
	atm.tm_min = (wDosTime & ~0xF800) >> 5;
	atm.tm_hour = wDosTime >> 11;

	atm.tm_mday = wDosDate & ~0xFFE0;
	atm.tm_mon = ((wDosDate & ~0xFE00) >> 5) - 1;
	atm.tm_year = (wDosDate >> 9) + 80;
	atm.tm_isdst = nDST;
	m_time = _mktime64(&atm);
	ATLASSERT(m_time != -1);       // indicates an illegal input time
}

inline CTime::CTime(const SYSTEMTIME& sysTime, int nDST)
{
	if (sysTime.wYear < 1900)
	{
		__time64_t time0 = 0L;
		CTime timeT(time0);
		*this = timeT;
	}
	else
	{
		CTime timeT(
			(int)sysTime.wYear, (int)sysTime.wMonth, (int)sysTime.wDay,
			(int)sysTime.wHour, (int)sysTime.wMinute, (int)sysTime.wSecond,
			nDST);
		*this = timeT;
	}
}

inline CTime::CTime(const FILETIME& fileTime, int nDST)
{
	// first convert file time (UTC time) to local time
	FILETIME localTime;
	if (!FileTimeToLocalFileTime(&fileTime, &localTime))
	{
		m_time = 0;
		return;
	}

	// then convert that time to system time
	SYSTEMTIME sysTime;
	if (!FileTimeToSystemTime(&localTime, &sysTime))
	{
		m_time = 0;
		return;
	}

	// then convert the system time to a time_t (C-runtime local time)
	CTime timeT(sysTime, nDST);
	*this = timeT;
}

#ifdef __oledb_h__
inline CTime::CTime( const DBTIMESTAMP& dbts, int nDST )
{
	struct tm atm;
	atm.tm_sec = dbts.second;
	atm.tm_min = dbts.minute;
	atm.tm_hour = dbts.hour;
	atm.tm_mday = dbts.day;
	atm.tm_mon = dbts.month - 1;        // tm_mon is 0 based
	ATLASSERT(dbts.year >= 1900);
	atm.tm_year = dbts.year - 1900;     // tm_year is 1900 based
	atm.tm_isdst = nDST;
	m_time = _mktime64(&atm);
	ATLASSERT(m_time != -1);       // indicates an illegal input time
}
#endif

inline CTime& CTime::operator=( __time64_t time )
{
	m_time = time;

	return( *this );
}

inline CTime& CTime::operator+=( CTimeSpan span )
{
	m_time += span.GetTimeSpan();

	return( *this );
}

inline CTime& CTime::operator-=( CTimeSpan span )
{
	m_time -= span.GetTimeSpan();

	return( *this );
}

inline CTimeSpan CTime::operator-( CTime time ) const
{
	return( CTimeSpan( m_time-time.m_time ) );
}

inline CTime CTime::operator-( CTimeSpan span ) const
{
	return( CTime( m_time-span.GetTimeSpan() ) );
}

inline CTime CTime::operator+( CTimeSpan span ) const
{
	return( CTime( m_time+span.GetTimeSpan() ) );
}

inline bool CTime::operator==( CTime time ) const
{
	return( m_time == time.m_time );
}

inline bool CTime::operator!=( CTime time ) const
{
	return( m_time != time.m_time );
}

inline bool CTime::operator<( CTime time ) const
{
	return( m_time < time.m_time );
}

inline bool CTime::operator>( CTime time ) const
{
	return( m_time > time.m_time );
}

inline bool CTime::operator<=( CTime time ) const
{
	return( m_time <= time.m_time );
}

inline bool CTime::operator>=( CTime time ) const
{
	return( m_time >= time.m_time );
}

inline struct tm* CTime::GetGmtTm(struct tm* ptm) const
{
	if (ptm != NULL)
	{
		*ptm = *_gmtime64(&m_time);
		return ptm;
	}
	else
		return _gmtime64(&m_time);
}

inline struct tm* CTime::GetLocalTm(struct tm* ptm) const
{
	if (ptm != NULL)
	{
		struct tm* ptmTemp = _localtime64(&m_time);
		if (ptmTemp == NULL)
			return NULL;    // indicates the m_time was not initialized!

		*ptm = *ptmTemp;
		return ptm;
	}
	else
		return _localtime64(&m_time);
}

inline bool CTime::GetAsSystemTime(SYSTEMTIME& timeDest) const
{
	struct tm* ptm = GetLocalTm(NULL);
	if (!ptm)
		return false;

	timeDest.wYear = (WORD) (1900 + ptm->tm_year);
	timeDest.wMonth = (WORD) (1 + ptm->tm_mon);
	timeDest.wDayOfWeek = (WORD) ptm->tm_wday;
	timeDest.wDay = (WORD) ptm->tm_mday;
	timeDest.wHour = (WORD) ptm->tm_hour;
	timeDest.wMinute = (WORD) ptm->tm_min;
	timeDest.wSecond = (WORD) ptm->tm_sec;
	timeDest.wMilliseconds = 0;

	return true;
}

#ifdef __oledb_h__
inline bool CTime::GetAsDBTIMESTAMP( DBTIMESTAMP& dbts ) const
{
	struct tm* ptm = GetLocalTm(NULL);
	if (!ptm)
		return false;

	dbts.year = (SHORT) (1900 + ptm->tm_year);
	dbts.month = (USHORT) (1 + ptm->tm_mon);
	dbts.day = (USHORT) ptm->tm_mday;
	dbts.hour = (USHORT) ptm->tm_hour;
	dbts.minute = (USHORT) ptm->tm_min;
	dbts.second = (USHORT) ptm->tm_sec;
	dbts.fraction = 0;

	return true;
}
#endif

inline __time64_t CTime::GetTime() const
{
	return( m_time );
}

inline int CTime::GetYear() const
{ 
	return( GetLocalTm()->tm_year+1900 ); 
}

inline int CTime::GetMonth() const
{ 
	return( GetLocalTm()->tm_mon+1 ); 
}

inline int CTime::GetDay() const
{ 
	return( GetLocalTm()->tm_mday ); 
}

inline int CTime::GetHour() const
{ 
	return( GetLocalTm()->tm_hour ); 
}

inline int CTime::GetMinute() const
{ 
	return( GetLocalTm()->tm_min ); 
}

inline int CTime::GetSecond() const
{ 
	return( GetLocalTm()->tm_sec ); 
}

inline int CTime::GetDayOfWeek() const
{ 
	return( GetLocalTm()->tm_wday+1 ); 
}

#ifndef _ATL_MIN_CRT
inline CString CTime::Format(LPCTSTR pFormat) const
{
	TCHAR szBuffer[maxTimeBufferSize];

	struct tm* ptmTemp = _localtime64(&m_time);
	if (ptmTemp == NULL ||
		!_tcsftime(szBuffer, maxTimeBufferSize, pFormat, ptmTemp))
		szBuffer[0] = '\0';
	return szBuffer;
}

inline CString CTime::FormatGmt(LPCTSTR pFormat) const
{
	TCHAR szBuffer[maxTimeBufferSize];

	struct tm* ptmTemp = _gmtime64(&m_time);
	if (ptmTemp == NULL ||
		!_tcsftime(szBuffer, maxTimeBufferSize, pFormat, ptmTemp))
		szBuffer[0] = '\0';
	return szBuffer;
}

inline CString CTime::Format(UINT nFormatID) const
{
	CString strFormat;
	ATLVERIFY(strFormat.LoadString(nFormatID));
	return Format(strFormat);
}

inline CString CTime::FormatGmt(UINT nFormatID) const
{
	CString strFormat;
	ATLVERIFY(strFormat.LoadString(nFormatID));
	return FormatGmt(strFormat);
}
#endif // !_ATL_MIN_CRT

#if defined (_AFX) && defined(_UNICODE)
inline CString CTime::Format(LPCSTR pFormat) const
{
	return Format(CString(pFormat));
}

inline CString CTime::FormatGmt(LPCSTR pFormat) const
{
	return FormatGmt(CString(pFormat));
}
#endif // _AFX && _UNICODE

/////////////////////////////////////////////////////////////////////////////
// COleDateTimeSpan
/////////////////////////////////////////////////////////////////////////////

inline COleDateTimeSpan::COleDateTimeSpan() : m_span(0), m_status(valid)
{
}

inline COleDateTimeSpan::COleDateTimeSpan(double dblSpanSrc) : m_span(dblSpanSrc), m_status(valid)
{
	CheckRange();
}

inline COleDateTimeSpan::COleDateTimeSpan(LONG lDays, int nHours, int nMins, int nSecs)
{
	SetDateTimeSpan(lDays, nHours, nMins, nSecs);
}

inline void COleDateTimeSpan::SetStatus(DateTimeSpanStatus status)
{
	m_status = status;
}

inline COleDateTimeSpan::DateTimeSpanStatus COleDateTimeSpan::GetStatus() const
{
	return m_status;
}

__declspec(selectany) const double
	COleDateTimeSpan::OLE_DATETIME_HALFSECOND =
	1.0 / (2.0 * (60.0 * 60.0 * 24.0));

inline double COleDateTimeSpan::GetTotalDays() const
{
	ATLASSERT(GetStatus() == valid);

	return LONG(m_span + (m_span < 0 ?
		-OLE_DATETIME_HALFSECOND : OLE_DATETIME_HALFSECOND));
}

inline double COleDateTimeSpan::GetTotalHours() const
{
	ATLASSERT(GetStatus() == valid);

	return LONG((m_span + (m_span < 0 ? 
		-OLE_DATETIME_HALFSECOND : OLE_DATETIME_HALFSECOND)) * 24);
}

inline double COleDateTimeSpan::GetTotalMinutes() const
{
	ATLASSERT(GetStatus() == valid);

	return LONG((m_span + (m_span < 0 ?
		-OLE_DATETIME_HALFSECOND : OLE_DATETIME_HALFSECOND)) * (24 * 60));
}

inline double COleDateTimeSpan::GetTotalSeconds() const
{
	ATLASSERT(GetStatus() == valid);
	
	return LONG((m_span + (m_span < 0 ?
		-OLE_DATETIME_HALFSECOND : OLE_DATETIME_HALFSECOND)) * (24 * 60 * 60));
}

inline LONG COleDateTimeSpan::GetDays() const
{
	ATLASSERT(GetStatus() == valid);
	return LONG(m_span);
}

inline LONG COleDateTimeSpan::GetHours() const
{
	return LONG(GetTotalHours()) % 24;
}

inline LONG COleDateTimeSpan::GetMinutes() const
{
	return LONG(GetTotalMinutes()) % 60;
}

inline LONG COleDateTimeSpan::GetSeconds() const
{
	return LONG(GetTotalSeconds()) % 60;
}

inline COleDateTimeSpan& COleDateTimeSpan::operator=(double dblSpanSrc)
{
	m_span = dblSpanSrc;
	m_status = valid;
	CheckRange();
	return *this;
}

inline bool COleDateTimeSpan::operator==(const COleDateTimeSpan& dateSpan) const
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(dateSpan.GetStatus() == valid);
	return (m_status == dateSpan.m_status &&
		m_span == dateSpan.m_span);
}

inline bool COleDateTimeSpan::operator!=(const COleDateTimeSpan& dateSpan) const
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(dateSpan.GetStatus() == valid);
	return (m_status != dateSpan.m_status ||
		m_span != dateSpan.m_span);
}

inline bool COleDateTimeSpan::operator<(const COleDateTimeSpan& dateSpan) const
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(dateSpan.GetStatus() == valid);
	return m_span < dateSpan.m_span;
}

inline bool COleDateTimeSpan::operator>(const COleDateTimeSpan& dateSpan) const
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(dateSpan.GetStatus() == valid);
	return m_span > dateSpan.m_span;
}

inline bool COleDateTimeSpan::operator<=(const COleDateTimeSpan& dateSpan) const
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(dateSpan.GetStatus() == valid);
	return m_span <= dateSpan.m_span;
}

inline bool COleDateTimeSpan::operator>=(const COleDateTimeSpan& dateSpan) const
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(dateSpan.GetStatus() == valid);
	return m_span >= dateSpan.m_span;
}

inline COleDateTimeSpan COleDateTimeSpan::operator+(const COleDateTimeSpan& dateSpan) const
{
	COleDateTimeSpan dateSpanTemp;

	// If either operand Null, result Null
	if (GetStatus() == null || dateSpan.GetStatus() == null)
	{
		dateSpanTemp.SetStatus(null);
		return dateSpanTemp;
	}

	// If either operand Invalid, result Invalid
	if (GetStatus() == invalid || dateSpan.GetStatus() == invalid)
	{
		dateSpanTemp.SetStatus(invalid);
		return dateSpanTemp;
	}

	// Add spans and validate within legal range
	dateSpanTemp.m_span = m_span + dateSpan.m_span;
	dateSpanTemp.CheckRange();

	return dateSpanTemp;
}

inline COleDateTimeSpan COleDateTimeSpan::operator-(const COleDateTimeSpan& dateSpan) const
{
	COleDateTimeSpan dateSpanTemp;

	// If either operand Null, result Null
	if (GetStatus() == null || dateSpan.GetStatus() == null)
	{
		dateSpanTemp.SetStatus(null);
		return dateSpanTemp;
	}

	// If either operand Invalid, result Invalid
	if (GetStatus() == invalid || dateSpan.GetStatus() == invalid)
	{
		dateSpanTemp.SetStatus(invalid);
		return dateSpanTemp;
	}

	// Subtract spans and validate within legal range
	dateSpanTemp.m_span = m_span - dateSpan.m_span;
	dateSpanTemp.CheckRange();

	return dateSpanTemp;
}

inline COleDateTimeSpan& COleDateTimeSpan::operator+=(const COleDateTimeSpan dateSpan)
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(dateSpan.GetStatus() == valid);
	*this = *this + dateSpan;
	CheckRange();
	return *this;
}

inline COleDateTimeSpan& COleDateTimeSpan::operator-=(const COleDateTimeSpan dateSpan)
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(dateSpan.GetStatus() == valid);
	*this = *this - dateSpan;
	CheckRange();
	return *this;
}

inline COleDateTimeSpan COleDateTimeSpan::operator-() const
{
	return -this->m_span;
}

inline COleDateTimeSpan::operator double() const
{
	return m_span;
}

inline void COleDateTimeSpan::SetDateTimeSpan(LONG lDays, int nHours, int nMins, int nSecs)
{
	// Set date span by breaking into fractional days (all input ranges valid)
	m_span = lDays + ((double)nHours)/24 + ((double)nMins)/(24*60) +
		((double)nSecs)/(24*60*60);
	m_status = valid;
	CheckRange();
}

#ifndef _ATL_MIN_CRT
inline CString COleDateTimeSpan::Format(LPCTSTR pFormat) const
{
	// If null, return empty string
	if (GetStatus() == null)
		return _T("");

	CTimeSpan tmp(GetDays(), GetHours(), GetMinutes(), GetSeconds());
	return tmp.Format(pFormat);
}

inline CString COleDateTimeSpan::Format(UINT nFormatID) const
{
	CString strFormat;
	ATLVERIFY(strFormat.LoadString(nFormatID));
	return Format(strFormat);
}
#endif // !_ATL_MIN_CRT

inline void COleDateTimeSpan::CheckRange()
{
	if(m_span < -maxDaysInSpan || m_span > maxDaysInSpan)
		m_status = invalid;
}

/////////////////////////////////////////////////////////////////////////////
// COleDateTime
/////////////////////////////////////////////////////////////////////////////

inline COleDateTime COleDateTime::GetCurrentTime()
{
	return COleDateTime(::_time64(NULL));
}

inline COleDateTime::COleDateTime() :
	m_dt( 0 ), m_status(valid)
{
}

inline COleDateTime::COleDateTime( const VARIANT& varSrc ) :
	m_dt( 0 ), m_status(valid)
{
	*this = varSrc;
}

inline COleDateTime::COleDateTime( DATE dtSrc ) :
	m_dt( dtSrc ), m_status(valid)
{
}

#ifndef  _WIN64

inline COleDateTime::COleDateTime( time_t timeSrc) :
	m_dt( 0 ), m_status(valid)
{
	*this = timeSrc;
}

#endif

inline COleDateTime::COleDateTime( __time64_t timeSrc ) :
	m_dt( 0 ), m_status(valid)
{
	*this = timeSrc;
}

inline COleDateTime::COleDateTime( const SYSTEMTIME& systimeSrc ) :
	m_dt( 0 ), m_status(valid)
{
	*this = systimeSrc;
}

inline COleDateTime::COleDateTime( const FILETIME& filetimeSrc ) :
	m_dt( 0 ), m_status(valid)
{
	*this = filetimeSrc;
}

inline COleDateTime::COleDateTime(int nYear, int nMonth, int nDay,
	int nHour, int nMin, int nSec)
{
	SetDateTime(nYear, nMonth, nDay, nHour, nMin, nSec);
}

inline COleDateTime::COleDateTime(WORD wDosDate, WORD wDosTime)
{
	m_status = ::DosDateTimeToVariantTime(wDosDate, wDosTime, &m_dt) ?
		valid : invalid;
}

inline void COleDateTime::SetStatus(DateTimeStatus status)
{
	m_status = status;
}

inline COleDateTime::DateTimeStatus COleDateTime::GetStatus() const
{
	return m_status;
}

inline bool COleDateTime::GetAsSystemTime(SYSTEMTIME& sysTime) const
{
	return GetStatus() == valid && ::VariantTimeToSystemTime(m_dt, &sysTime);
}

inline bool COleDateTime::GetAsUDATE(UDATE &udate) const
{
	return SUCCEEDED(::VarUdateFromDate(m_dt, 0, &udate));
}

inline int COleDateTime::GetYear() const
{
	SYSTEMTIME st;
	return GetAsSystemTime(st) ? st.wYear : error;
}

inline int COleDateTime::GetMonth() const
{
	SYSTEMTIME st;
	return GetAsSystemTime(st) ? st.wMonth : error;
}

inline int COleDateTime::GetDay() const
{
	SYSTEMTIME st;
	return GetAsSystemTime(st) ? st.wDay : error;
}

inline int COleDateTime::GetHour() const
{
	SYSTEMTIME st;
	return GetAsSystemTime(st) ? st.wHour : error;
}

inline int COleDateTime::GetMinute() const
{
	SYSTEMTIME st;
	return GetAsSystemTime(st) ? st.wMinute : error;
}

inline int COleDateTime::GetSecond() const
{ 
	SYSTEMTIME st;
	return GetAsSystemTime(st) ? st.wSecond : error;
}

inline int COleDateTime::GetDayOfWeek() const
{
	SYSTEMTIME st;
	return GetAsSystemTime(st) ? st.wDayOfWeek + 1 : error;
}

inline int COleDateTime::GetDayOfYear() const
{
	UDATE udate;
	return GetAsUDATE(udate) ? udate.wDayOfYear : error;
}

inline COleDateTime& COleDateTime::operator=(const VARIANT& varSrc)
{
	if (varSrc.vt != VT_DATE)
	{
		VARIANT varDest;
		varDest.vt = VT_EMPTY;
		if(SUCCEEDED(::VariantChangeType(&varDest, const_cast<VARIANT *>(&varSrc), 0, VT_DATE)))
		{
			m_dt = varDest.date;
			m_status = valid;
		}
		else
			m_status = invalid;
	}
	else
	{
		m_dt = varSrc.date;
		m_status = valid;
	}

	return *this;
}

inline COleDateTime& COleDateTime::operator=(DATE dtSrc)
{
	m_dt = dtSrc;
	m_status = valid;
	return *this;
}

#ifndef  _WIN64

inline COleDateTime& COleDateTime::operator=(const time_t& timeSrc)
{
	return operator=(static_cast<__time64_t>(timeSrc));
}

#endif // _WIN64

inline COleDateTime& COleDateTime::operator=(const __time64_t& timeSrc)
{
	SYSTEMTIME st;
	CTime tmp(timeSrc);
	
	m_status = tmp.GetAsSystemTime(st) &&
		::SystemTimeToVariantTime(&st, &m_dt) ? valid : invalid;

	return *this;
}

inline COleDateTime &COleDateTime::operator=(const SYSTEMTIME &systimeSrc)
{
	m_status = ::SystemTimeToVariantTime(const_cast<SYSTEMTIME *>(&systimeSrc), &m_dt) ?
		valid : invalid;
	return *this;
}

inline COleDateTime &COleDateTime::operator=(const FILETIME &filetimeSrc)
{
	SYSTEMTIME st;
	m_status = ::FileTimeToSystemTime(&filetimeSrc, &st) &&
				::SystemTimeToVariantTime(&st, &m_dt) ?
		valid : invalid;

	return *this;
}

inline COleDateTime &COleDateTime::operator=(const UDATE &udate)
{
	m_status = (S_OK == VarDateFromUdate((UDATE*)&udate, 0, &m_dt)) ? valid : invalid;

	return *this;
}

inline bool COleDateTime::operator==( const COleDateTime& date ) const
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(date.GetStatus() == valid);
	return( m_dt == date.m_dt );
}

inline bool COleDateTime::operator!=( const COleDateTime& date ) const
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(date.GetStatus() == valid);
	return( m_dt != date.m_dt );
}

inline bool COleDateTime::operator<( const COleDateTime& date ) const
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(date.GetStatus() == valid);
	return( DoubleFromDate( m_dt ) < DoubleFromDate( date.m_dt ) );
}

inline bool COleDateTime::operator>( const COleDateTime& date ) const
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(date.GetStatus() == valid);
	return( DoubleFromDate( m_dt ) > DoubleFromDate( date.m_dt ) );
}

inline bool COleDateTime::operator<=( const COleDateTime& date ) const
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(date.GetStatus() == valid);
	return( DoubleFromDate( m_dt ) <= DoubleFromDate( date.m_dt ) );
}

inline bool COleDateTime::operator>=( const COleDateTime& date ) const
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(date.GetStatus() == valid);
	return( DoubleFromDate( m_dt ) >= DoubleFromDate( date.m_dt ) );
}

inline COleDateTime COleDateTime::operator+( COleDateTimeSpan dateSpan ) const
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(dateSpan.GetStatus() == valid);
	return( COleDateTime( DateFromDouble( DoubleFromDate( m_dt )+(double)dateSpan ) ) );
}

inline COleDateTime COleDateTime::operator-( COleDateTimeSpan dateSpan ) const
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(dateSpan.GetStatus() == valid);
	return( COleDateTime( DateFromDouble( DoubleFromDate( m_dt )-(double)dateSpan ) ) );
}
	
inline COleDateTime& COleDateTime::operator+=( COleDateTimeSpan dateSpan )
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(dateSpan.GetStatus() == valid);
	m_dt = DateFromDouble( DoubleFromDate( m_dt )+(double)dateSpan );
	return( *this );
}

inline COleDateTime& COleDateTime::operator-=( COleDateTimeSpan dateSpan )
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(dateSpan.GetStatus() == valid);
	m_dt = DateFromDouble( DoubleFromDate( m_dt )-(double)dateSpan );
	return( *this );
}

inline COleDateTimeSpan COleDateTime::operator-(const COleDateTime& date) const
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(date.GetStatus() == valid);
	return DoubleFromDate(m_dt) - DoubleFromDate(date.m_dt);
}

inline COleDateTime::operator DATE() const
{
	ATLASSERT(GetStatus() == valid);
	return( m_dt );
}

inline int COleDateTime::SetDateTime(int nYear, int nMonth, int nDay,
	int nHour, int nMin, int nSec)
{
	SYSTEMTIME st;
	::ZeroMemory(&st, sizeof(SYSTEMTIME));

	st.wYear = WORD(nYear);
	st.wMonth = WORD(nMonth);
	st.wDay = WORD(nDay);
	st.wHour = WORD(nHour);
	st.wMinute = WORD(nMin);
	st.wSecond = WORD(nSec);

	return m_status = ::SystemTimeToVariantTime(&st, &m_dt) ? valid : invalid;
}

inline int COleDateTime::SetDate(int nYear, int nMonth, int nDay)
{
	return SetDateTime(nYear, nMonth, nDay, 0, 0, 0);
}

inline int COleDateTime::SetTime(int nHour, int nMin, int nSec)
{
	// Set date to zero date - 12/30/1899
	return SetDateTime(1899, 12, 30, nHour, nMin, nSec);
}

inline bool COleDateTime::ParseDateTime(LPCTSTR lpszDate, DWORD dwFlags, LCID lcid)
{
	USES_CONVERSION;
	CString strDate = lpszDate;

	HRESULT hr;
	if (FAILED(hr = VarDateFromStr((LPOLESTR)T2COLE(strDate), lcid,
		dwFlags, &m_dt)))
	{
		if (hr == DISP_E_TYPEMISMATCH)
		{
			// Can't convert string to date, set 0 and invalidate
			m_dt = 0;
			m_status = invalid;
			return false;
		}
		else if (hr == DISP_E_OVERFLOW)
		{
			// Can't convert string to date, set -1 and invalidate
			m_dt = -1;
			m_status = invalid;
			return false;
		}
		else
		{
			ATLTRACE(atlTraceTime, 0, _T("\nCOleDateTime VarDateFromStr call failed.\n\t"));
			// Can't convert string to date, set -1 and invalidate
			m_dt = -1;
			m_status = invalid;
			return false;
		}
	}

	m_status = valid;
	return true;
}

#ifndef _ATL_MIN_CRT
inline CString COleDateTime::Format(DWORD dwFlags, LCID lcid) const
{
	// If null, return empty string
	if (GetStatus() == null)
		return _T("");

	// If invalid, return DateTime global string
	if (GetStatus() == invalid)
	{
		CString str;
		if(str.LoadString(ATL_IDS_DATETIME_INVALID))
			return str;
		return szInvalidDateTime;
	}

	CComBSTR bstr;
	if (FAILED(::VarBstrFromDate(m_dt, lcid, dwFlags, &bstr)))
	{
		CString str;
		if(str.LoadString(ATL_IDS_DATETIME_INVALID))
			return str;
		return szInvalidDateTime;
	}

	CString tmp = CString(bstr);
	return tmp;
}

inline CString COleDateTime::Format(LPCTSTR pFormat) const
{
	// If null, return empty string
	if(GetStatus() == null)
		return _T("");

	// If invalid, return DateTime global string
	if(GetStatus() == invalid)
	{
		CString str;
		if(str.LoadString(ATL_IDS_DATETIME_INVALID))
			return str;
		return szInvalidDateTime;
	}

	UDATE ud;
	if (S_OK != VarUdateFromDate(m_dt, 0, &ud))
	{
		CString str;
		if(str.LoadString(ATL_IDS_DATETIME_INVALID))
			return str;
		return szInvalidDateTime;
	}

	struct tm tmTemp;
	tmTemp.tm_sec	= ud.st.wSecond;
	tmTemp.tm_min	= ud.st.wMinute;
	tmTemp.tm_hour	= ud.st.wHour;
	tmTemp.tm_mday	= ud.st.wDay;
	tmTemp.tm_mon	= ud.st.wMonth - 1;
	tmTemp.tm_year	= ud.st.wYear - 1900;
	tmTemp.tm_wday	= ud.st.wDayOfWeek;
	tmTemp.tm_yday	= ud.wDayOfYear - 1;
	tmTemp.tm_isdst	= 0;

	CString strDate;
	LPTSTR lpszTemp = strDate.GetBufferSetLength(256);
	_tcsftime(lpszTemp, strDate.GetLength(), pFormat, &tmTemp);
	strDate.ReleaseBuffer();

	return strDate;
}

inline CString COleDateTime::Format(UINT nFormatID) const
{
	CString strFormat;
	ATLVERIFY(strFormat.LoadString(nFormatID));
	return Format(strFormat);
}
#endif // !_ATL_MIN_CRT

inline double COleDateTime::DoubleFromDate( DATE date )
{
	double fTemp;

	// No problem if positive
	if( date >= 0 )
	{
		return( date );
	}

	// If negative, must convert since negative dates not continuous
	// (examples: -1.25 to -.75, -1.50 to -.50, -1.75 to -.25)
	fTemp = ceil( date );

	return( fTemp-(date-fTemp) );
}

inline DATE COleDateTime::DateFromDouble( double f )
{
	double fTemp;

	// No problem if positive
	if( f >= 0 )
	{
		return( f );
	}

	// If negative, must convert since negative dates not continuous
	// (examples: -.75 to -1.25, -.50 to -1.50, -.25 to -1.75)
	fTemp = floor( f ); // fTemp is now whole part
	
	return( fTemp+(fTemp-f) );
}

/////////////////////////////////////////////////////////////////////////////
// CFileTimeSpan
/////////////////////////////////////////////////////////////////////////////

inline CFileTimeSpan::CFileTimeSpan() :
	m_nSpan( 0 )
{
}

// REVIEW
inline CFileTimeSpan::CFileTimeSpan( const CFileTimeSpan& span ) :
	m_nSpan( span.m_nSpan )
{
}

inline CFileTimeSpan::CFileTimeSpan( LONGLONG nSpan ) :
	m_nSpan( nSpan )
{
}

inline CFileTimeSpan& CFileTimeSpan::operator=( const CFileTimeSpan& span )
{
	m_nSpan = span.m_nSpan;

	return( *this );
}

inline CFileTimeSpan& CFileTimeSpan::operator+=( CFileTimeSpan span )
{
	m_nSpan += span.m_nSpan;

	return( *this );
}

inline CFileTimeSpan& CFileTimeSpan::operator-=( CFileTimeSpan span )
{
	m_nSpan -= span.m_nSpan;

	return( *this );
}

inline CFileTimeSpan CFileTimeSpan::operator+( CFileTimeSpan span ) const
{
	return( CFileTimeSpan( m_nSpan+span.m_nSpan ) );
}

inline CFileTimeSpan CFileTimeSpan::operator-( CFileTimeSpan span ) const
{
	return( CFileTimeSpan( m_nSpan-span.m_nSpan ) );
}

inline bool CFileTimeSpan::operator==( CFileTimeSpan span ) const
{
	return( m_nSpan == span.m_nSpan );
}

inline bool CFileTimeSpan::operator!=( CFileTimeSpan span ) const
{
	return( m_nSpan != span.m_nSpan );
}

inline bool CFileTimeSpan::operator<( CFileTimeSpan span ) const
{
	return( m_nSpan < span.m_nSpan );
}

inline bool CFileTimeSpan::operator>( CFileTimeSpan span ) const
{
	return( m_nSpan > span.m_nSpan );
}

inline bool CFileTimeSpan::operator<=( CFileTimeSpan span ) const
{
	return( m_nSpan <= span.m_nSpan );
}

inline bool CFileTimeSpan::operator>=( CFileTimeSpan span ) const
{
	return( m_nSpan >= span.m_nSpan );
}

inline LONGLONG CFileTimeSpan::GetTimeSpan() const
{
	return( m_nSpan );
}

inline void CFileTimeSpan::SetTimeSpan( LONGLONG nSpan )
{
	m_nSpan = nSpan;
}


/////////////////////////////////////////////////////////////////////////////
// CFileTime
/////////////////////////////////////////////////////////////////////////////

inline CFileTime::CFileTime()
{
	dwLowDateTime = 0;
	dwHighDateTime = 0;
}

inline CFileTime::CFileTime( const FILETIME& ft )
{
	dwLowDateTime = ft.dwLowDateTime;
	dwHighDateTime = ft.dwHighDateTime;
}

inline CFileTime::CFileTime( ULONGLONG nTime )
{
	dwLowDateTime = DWORD( nTime );
	dwHighDateTime = DWORD( nTime>>32 );
}

inline CFileTime& CFileTime::operator=( const FILETIME& ft )
{
	dwLowDateTime = ft.dwLowDateTime;
	dwHighDateTime = ft.dwHighDateTime;

	return( *this );
}

inline CFileTime CFileTime::GetCurrentTime()
{
	CFileTime ft;
	GetSystemTimeAsFileTime(&ft);
	return ft;
}

inline CFileTime& CFileTime::operator+=( CFileTimeSpan span )
{
	SetTime( GetTime()+span.GetTimeSpan() );

	return( *this );
}

inline CFileTime& CFileTime::operator-=( CFileTimeSpan span )
{
	SetTime( GetTime()-span.GetTimeSpan() );

	return( *this );
}

inline CFileTime CFileTime::operator+( CFileTimeSpan span ) const
{
	return( CFileTime( GetTime()+span.GetTimeSpan() ) );
}

inline CFileTime CFileTime::operator-( CFileTimeSpan span ) const
{
	return( CFileTime( GetTime()-span.GetTimeSpan() ) );
}

inline CFileTimeSpan CFileTime::operator-( CFileTime ft ) const
{
	return( CFileTimeSpan( GetTime()-ft.GetTime() ) );
}

inline bool CFileTime::operator==( CFileTime ft ) const
{
	return( GetTime() == ft.GetTime() );
}

inline bool CFileTime::operator!=( CFileTime ft ) const
{
	return( GetTime() != ft.GetTime() );
}

inline bool CFileTime::operator<( CFileTime ft ) const
{
	return( GetTime() < ft.GetTime() );
}

inline bool CFileTime::operator>( CFileTime ft ) const
{
	return( GetTime() > ft.GetTime() );
}

inline bool CFileTime::operator<=( CFileTime ft ) const
{
	return( GetTime() <= ft.GetTime() );
}

inline bool CFileTime::operator>=( CFileTime ft ) const
{
	return( GetTime() >= ft.GetTime() );
}

inline ULONGLONG CFileTime::GetTime() const
{
	return( (ULONGLONG( dwHighDateTime )<<32)|dwLowDateTime );
}

inline void CFileTime::SetTime( ULONGLONG nTime )
{
	dwLowDateTime = DWORD( nTime );
	dwHighDateTime = DWORD( nTime>>32 );
}

inline CFileTime CFileTime::UTCToLocal() const
{
	CFileTime ftLocal;

	::FileTimeToLocalFileTime( this, &ftLocal );

	return( ftLocal );
}

inline CFileTime CFileTime::LocalToUTC() const
{
	CFileTime ftUTC;

	::LocalFileTimeToFileTime( this, &ftUTC );

	return( ftUTC );
}

}  // namespace ATL
#endif //__ATLTIME_INL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atlmfc\atlutil.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLUTIL_H__
#define __ATLUTIL_H__

#pragma once
#include <stdio.h>
#include <string.h>
#include <crtdbg.h>
#include <stdlib.h>
#include <mbstring.h>
#include <atldef.h>
#include <imagehlp.h>
#include <atlbase.h>
#include <atlstr.h>
#include <atlcoll.h>
#include <atlsiface.h>
#include <atlenc.h>
#include <atlcom.h>

#ifndef _ATL_NO_DEFAULT_LIBS

#pragma comment(lib, "imagehlp.lib")

#endif  // !_ATL_NO_DEFAULT_LIBS

#pragma warning( push )
#pragma warning( disable: 4127 )

namespace ATL {


inline BOOL IsFullPath(LPCTSTR szPath)
{
	size_t nLen = _tcslen(szPath);
	if (nLen <= 1)
		return FALSE;
	if (*szPath == _T('"'))
	{
		szPath++;
	}
	if (szPath[1]==_T(':'))		// drive: case
		return TRUE;
	if (nLen > 2 && szPath[0]==_T('\\') &&
		szPath[1]==_T('\\'))	// unc path name
		return TRUE;
	return FALSE;
}

inline BOOL IsFullPathA(LPCSTR szPath)
{
	DWORD nLen = (DWORD) strlen(szPath);
	if (nLen <= 1)
		return FALSE;
	if (*szPath == '"')
	{
		szPath++;
	}
	if (szPath[1]==':')		// drive: case
		return TRUE;
	if (nLen > 2 && szPath[0]=='\\' &&
		szPath[1]=='\\')	// unc path name
		return TRUE;
	return FALSE;
}

#if(_WIN32_WINNT >= 0x0400)
// Helper class for reverting the thread impersonation token
// and then restoring it back to what it was
class CRevertThreadToken
{
public:
	HANDLE m_hThreadToken;

	CRevertThreadToken()
	{
		m_hThreadToken = INVALID_HANDLE_VALUE;
	}

	~CRevertThreadToken()
	{
		Restore();
	}
	// When called, this function
	// makes a copy of the thread's impersonation token
	// and then calls RevertToSelf() to revert the impersonation
	// level to the process
	// call Restore() to restore the impersonation
	// token
	// Restore is automatically called by the destructor
	BOOL Initialize()
	{
		if (OpenThreadToken(GetCurrentThread(), TOKEN_DUPLICATE, FALSE, &m_hThreadToken))
		{
			if (!RevertToSelf())
			{
				CloseHandle(m_hThreadToken);
				m_hThreadToken = INVALID_HANDLE_VALUE;
				return FALSE;
			}
			return TRUE;
		}
		return FALSE;
	}

	void Restore()
	{
		if (m_hThreadToken != INVALID_HANDLE_VALUE)
		{
			SetThreadToken(NULL, m_hThreadToken);
			CloseHandle(m_hThreadToken);
			m_hThreadToken = INVALID_HANDLE_VALUE;
		}
	}
};
#else
// Dummy version for downlevel support
class CRevertThreadToken
{
public:
	BOOL Initialize()
	{
		return FALSE;
	}
	void Restore()
	{
	}
};
#endif // _WIN32_WINNT >= 0x0400)

#ifndef ATL_ISAPI_BUFFER_SIZE
#define ATL_ISAPI_BUFFER_SIZE 4096
#endif

//typedefs and defines for CUrl (essentially the same as the ones from wininet, but with an ATL_ prepended)
typedef WORD ATL_URL_PORT;

typedef enum {
	ATL_URL_SCHEME_UNKNOWN = -1, 
    ATL_URL_SCHEME_FTP     = 0,
    ATL_URL_SCHEME_GOPHER  = 1,
    ATL_URL_SCHEME_HTTP    = 2,
    ATL_URL_SCHEME_HTTPS   = 3,
    ATL_URL_SCHEME_FILE    = 4,
    ATL_URL_SCHEME_NEWS    = 5,
    ATL_URL_SCHEME_MAILTO  = 6,
    ATL_URL_SCHEME_SOCKS   = 7,
} ATL_URL_SCHEME;


#define ATL_URL_MAX_HOST_NAME_LENGTH   256
#define ATL_URL_MAX_USER_NAME_LENGTH   128
#define ATL_URL_MAX_PASSWORD_LENGTH    128
#define ATL_URL_MAX_PORT_NUMBER_LENGTH 5           // ATL_URL_PORT is unsigned short
#define ATL_URL_MAX_PORT_NUMBER_VALUE  65535       // maximum unsigned short value
#define ATL_URL_MAX_PATH_LENGTH        2048
#define ATL_URL_MAX_SCHEME_LENGTH      32          // longest protocol name length
#define ATL_URL_MAX_URL_LENGTH         (ATL_URL_MAX_SCHEME_LENGTH \
                                       + sizeof("://") \
                                       + ATL_URL_MAX_PATH_LENGTH)

#define ATL_URL_INVALID_PORT_NUMBER    0           // use the protocol-specific default

#define ATL_URL_DEFAULT_FTP_PORT       21          // default for FTP servers
#define ATL_URL_DEFAULT_GOPHER_PORT    70          //    "     "  gopher "
#define ATL_URL_DEFAULT_HTTP_PORT      80          //    "     "  HTTP   "
#define ATL_URL_DEFAULT_HTTPS_PORT     443         //    "     "  HTTPS  "
#define ATL_URL_DEFAULT_SOCKS_PORT     1080        // default for SOCKS firewall servers.


template <DWORD dwSizeT=ATL_ISAPI_BUFFER_SIZE>
class CAtlIsapiBuffer
{
protected:
	char m_szBuffer[dwSizeT];
	LPSTR m_pBuffer;
	DWORD m_dwLen;
	DWORD m_dwAlloc;
    HANDLE m_hProcHeap;

public:
	CAtlIsapiBuffer() throw()
	{
		if (dwSizeT > 0)
			m_szBuffer[0] = 0;

		m_pBuffer = m_szBuffer;
		m_dwLen = 0;
		m_dwAlloc = dwSizeT;
        m_hProcHeap = GetProcessHeap();
	}

	CAtlIsapiBuffer(LPCSTR sz)
	{
		m_pBuffer = m_szBuffer;
		m_dwLen = 0;
		m_dwAlloc = dwSizeT;
        m_hProcHeap = GetProcessHeap();

		if (!Append(sz))
			AtlThrow(E_OUTOFMEMORY);
	}

	~CAtlIsapiBuffer() throw()
	{
		Free();
	}

	BOOL Alloc(DWORD dwSize) throw()
	{
		if (m_dwAlloc >= dwSize)
		{
			return TRUE;
		}
		if (m_pBuffer != m_szBuffer)
		{
			HeapFree(m_hProcHeap, 0, m_pBuffer);
			m_dwLen = 0;
			m_dwAlloc = 0;
		}
		m_pBuffer = (LPSTR)HeapAlloc(m_hProcHeap, 0, dwSize);
		if (m_pBuffer)
		{
			m_dwAlloc = dwSize;
			return TRUE;
		}
		return FALSE;
	}

	BOOL ReAlloc(DWORD dwNewSize) throw()
	{
		if (dwNewSize <= m_dwAlloc)
			return TRUE;

		if (m_pBuffer == m_szBuffer)
		{
			BOOL bRet = Alloc(dwNewSize);
			if (bRet)
				memcpy(m_pBuffer, m_szBuffer, m_dwLen);
			return bRet;
		}

		LPSTR pvNew = (LPSTR )HeapReAlloc(m_hProcHeap, 0, m_pBuffer, dwNewSize);
		if (pvNew)
		{
			m_pBuffer = pvNew;
			m_dwAlloc = dwNewSize;
			return TRUE;
		}
		return FALSE;
	}

	void Free() throw()
	{
		if (m_pBuffer != m_szBuffer)
		{
			HeapFree(m_hProcHeap,0 , m_pBuffer);
			m_dwAlloc = dwSizeT;
			m_pBuffer = m_szBuffer;
		}
		Empty();
	}

	void Empty() throw()
	{
		if (m_pBuffer)
		{
			m_pBuffer[0]=0;
			m_dwLen  = 0;
		}
	}

	DWORD GetLength() throw()
	{
		return m_dwLen;
	}

	BOOL Append(LPCSTR sz, int nLen = -1) throw()
	{
		if (nLen == -1)
			nLen = (int) strlen(sz);

		if (m_dwLen + nLen + 1 > m_dwAlloc)
		{
			if (!ReAlloc(m_dwAlloc + (nLen+1 > ATL_ISAPI_BUFFER_SIZE ? nLen+1 : ATL_ISAPI_BUFFER_SIZE)))
				return FALSE;
		}
		memcpy(m_pBuffer + m_dwLen, sz, nLen);
		m_dwLen += nLen;
		m_pBuffer[m_dwLen]=0;
		return TRUE;
	}

	operator LPCSTR() throw()
	{
		return m_pBuffer;
	}

	CAtlIsapiBuffer& operator+=(LPCSTR sz)
	{
		if (!Append(sz))
			AtlThrow(E_OUTOFMEMORY);
		return *this;
	}
}; // class CAtlIsapiBuffer


__interface IStackDumpHandler
{
public:
	void __stdcall OnBegin();
	void __stdcall OnEntry(void *pvAddress, LPCSTR szModule, LPCSTR szSymbol);
	void __stdcall OnError(LPCSTR szError);
	void __stdcall OnEnd();
};

#define ATL_MODULE_NAME_LEN _MAX_PATH
#define ATL_SYMBOL_NAME_LEN 1024

// Helper class for generating a stack dump
// This is used internally by AtlDumpStack
class CStackDumper
{
public:
	struct _ATL_SYMBOL_INFO
	{
		ULONG_PTR dwAddress;
		ULONG_PTR dwOffset;
		CHAR	szModule[ATL_MODULE_NAME_LEN];
		CHAR	szSymbol[ATL_SYMBOL_NAME_LEN];
	};

	static LPVOID __stdcall FunctionTableAccess(HANDLE hProcess, ULONG_PTR dwPCAddress)
	{
#ifdef _WIN64
		return SymFunctionTableAccess(hProcess, dwPCAddress);
#else
		return SymFunctionTableAccess(hProcess, (ULONG)dwPCAddress);
#endif
	}

	static ULONG_PTR __stdcall GetModuleBase(HANDLE hProcess, ULONG_PTR dwReturnAddress)
	{
		IMAGEHLP_MODULE moduleInfo;

#ifdef _WIN64
		if (SymGetModuleInfo(hProcess, dwReturnAddress, &moduleInfo))
#else
		if (SymGetModuleInfo(hProcess, (ULONG)dwReturnAddress, &moduleInfo))
#endif
	   		return moduleInfo.BaseOfImage;
		else
		{
			MEMORY_BASIC_INFORMATION memoryBasicInfo;

			if (::VirtualQueryEx(hProcess, (LPVOID) dwReturnAddress,
				&memoryBasicInfo, sizeof(memoryBasicInfo)))
			{
				DWORD cch = 0;
				char szFile[MAX_PATH] = { 0 };

				cch = GetModuleFileNameA((HINSTANCE)memoryBasicInfo.AllocationBase,
											 szFile, MAX_PATH);

				// Ignore the return code since we can't do anything with it.
				SymLoadModule(hProcess,
					NULL, ((cch) ? szFile : NULL),
#ifdef _WIN64
					NULL, (DWORD_PTR) memoryBasicInfo.AllocationBase, 0);
#else
					NULL, (DWORD)(DWORD_PTR)memoryBasicInfo.AllocationBase, 0);
#endif
				return (DWORD_PTR) memoryBasicInfo.AllocationBase;
			}
		}

		return 0;
	}

	static BOOL ResolveSymbol(HANDLE hProcess, UINT_PTR dwAddress,
		_ATL_SYMBOL_INFO &siSymbol)
	{
		BOOL fRetval = TRUE;

		siSymbol.dwAddress = dwAddress;

		CHAR szUndec[ATL_SYMBOL_NAME_LEN];
		CHAR szWithOffset[ATL_SYMBOL_NAME_LEN];
		LPSTR pszSymbol = NULL;
		IMAGEHLP_MODULE mi;

		memset(&siSymbol, 0, sizeof(_ATL_SYMBOL_INFO));
		mi.SizeOfStruct = sizeof(IMAGEHLP_MODULE);

#ifdef _WIN64
		if (!SymGetModuleInfo(hProcess, dwAddress, &mi))
#else
		if (!SymGetModuleInfo(hProcess, (UINT)dwAddress, &mi))
#endif
	   		lstrcpyA(siSymbol.szModule, "<no module>");
		else
		{
			LPSTR pszModule = strchr(mi.ImageName, '\\');
			if (pszModule == NULL)
				pszModule = mi.ImageName;
			else
				pszModule++;

			lstrcpynA(siSymbol.szModule, pszModule, sizeof(siSymbol.szModule)/sizeof(siSymbol.szModule[0]));
		}

		__try
		{
			union 
			{
				CHAR rgchSymbol[sizeof(IMAGEHLP_SYMBOL) + ATL_SYMBOL_NAME_LEN];
				IMAGEHLP_SYMBOL  sym;
			} sym;
			memset(&sym.sym, 0x00, sizeof(sym.sym));
			sym.sym.SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
#ifdef _WIN64
			sym.sym.Address = dwAddress;
#else
			sym.sym.Address = (DWORD)dwAddress;
#endif
			sym.sym.MaxNameLength = ATL_SYMBOL_NAME_LEN;

#ifdef _WIN64
			if (SymGetSymFromAddr(hProcess, dwAddress, &(siSymbol.dwOffset), &sym.sym))
#else
			if (SymGetSymFromAddr(hProcess, (DWORD)dwAddress, &(siSymbol.dwOffset), &sym.sym))
#endif
			{
				pszSymbol = sym.sym.Name;
				
				if (UnDecorateSymbolName(sym.sym.Name, szUndec, sizeof(szUndec)/sizeof(szUndec[0]), 
					UNDNAME_NO_MS_KEYWORDS | UNDNAME_NO_ACCESS_SPECIFIERS))
				{
					pszSymbol = szUndec;
				}
				else if (SymUnDName(&sym.sym, szUndec, sizeof(szUndec)/sizeof(szUndec[0])))
				{
					pszSymbol = szUndec;
				}
				if (siSymbol.dwOffset != 0)
				{
					wsprintfA(szWithOffset, "%s + %d bytes", pszSymbol, siSymbol.dwOffset);
					pszSymbol = szWithOffset;
				}
		  }
		  else
			  pszSymbol = "<no symbol>";
		}
		__except (EXCEPTION_EXECUTE_HANDLER)
		{
			pszSymbol = "<EX: no symbol>";
			siSymbol.dwOffset = dwAddress - mi.BaseOfImage;
		}

		lstrcpynA(siSymbol.szSymbol, pszSymbol, sizeof(siSymbol.szSymbol)/sizeof(siSymbol.szSymbol[0]));
		return fRetval;
	}
};

// Helper function to produce a stack dump
ATL_NOINLINE inline void AtlDumpStack(IStackDumpHandler *pHandler)
{
	ATLASSERT(pHandler);

	pHandler->OnBegin();

	CAtlArray<void *> adwAddress;
	HANDLE hProcess = ::GetCurrentProcess();
	if (SymInitialize(hProcess, NULL, FALSE))
	{
		// force undecorated names to get params
		DWORD dw = SymGetOptions();
		dw &= ~SYMOPT_UNDNAME;
		SymSetOptions(dw);

		HANDLE hThread = ::GetCurrentThread();
		CONTEXT threadContext;

		threadContext.ContextFlags = CONTEXT_FULL;

		if (::GetThreadContext(hThread, &threadContext))
		{
			//DumpContext(&threadContext);
			STACKFRAME stackFrame;
			memset(&stackFrame, 0, sizeof(stackFrame));
			stackFrame.AddrPC.Mode = AddrModeFlat;

			DWORD dwMachType;

#if defined(_M_IX86)
			dwMachType                  = IMAGE_FILE_MACHINE_I386;
			
			// program counter, stack pointer, and frame pointer
			stackFrame.AddrPC.Offset    = threadContext.Eip;
			stackFrame.AddrStack.Offset = threadContext.Esp;
			stackFrame.AddrStack.Mode   = AddrModeFlat;
			stackFrame.AddrFrame.Offset = threadContext.Ebp;
			stackFrame.AddrFrame.Mode   = AddrModeFlat;
#elif defined(_M_AMD64)
			// only program counter
			dwMachType                  = IMAGE_FILE_MACHINE_AMD64;
			stackFrame.AddrPC.Offset    = threadContext.Rip;
#elif defined(_M_IA64)
            //IA64: What do we need to do here?
            dwMachType                  = IMAGE_FILE_MACHINE_IA64;
#if 0
            stackFrame.AddrPC.Offset =  threadContext.StIIP;
            stackFrame.AddrPC.Mode   = AddrModeFlat;
            stackFrame.AddrStack.Offset = threadContext.IntSp;
            stackFrame.AddrStack.Mode   = AddrModeFlat;
            stackFrame.AddrFrame.Offset = threadContext.IntSp;
            stackFrame.AddrFrame.Mode   = AddrModeFlat;
            stackFrame.AddrBStore.Offset = threadContext.RsBSP;
            stackFrame.AddrBStore.Mode   = AddrModeFlat;
            stackFrame.AddrReturn.Offset = threadContext.BrRp;
            stackFrame.AddrReturn.Mode   = AddrModeFlat;
#endif
		
#else
#error("Unknown Target Machine");
#endif

			adwAddress.SetCount(0, 16);

			int nFrame;
			for (nFrame = 0; nFrame < 5; nFrame++)
			{
				if (!StackWalk(dwMachType, hProcess, hProcess,
					&stackFrame, &threadContext, NULL,
					CStackDumper::FunctionTableAccess, CStackDumper::GetModuleBase, NULL))
				{
					break;
				}
				adwAddress.SetAtGrow(nFrame, (void*)(DWORD_PTR)stackFrame.AddrPC.Offset);
			}
		}
	}
	else
	{
		DWORD dw = GetLastError();
		char sz[100];
		wsprintfA(sz,
			"AtlDumpStack Error: IMAGEHLP.DLL wasn't found. "
			"GetLastError() returned 0x%8.8X\r\n", dw);
		pHandler->OnError(sz);
	}

	// dump it out now
	INT_PTR nAddress;
	INT_PTR cAddresses = adwAddress.GetCount();
	for (nAddress = 0; nAddress < cAddresses; nAddress++)
	{
		CStackDumper::_ATL_SYMBOL_INFO info;
		UINT_PTR dwAddress = (UINT_PTR)adwAddress[nAddress];

		LPCSTR szModule = NULL;
		LPCSTR szSymbol = NULL;

		if (CStackDumper::ResolveSymbol(hProcess, dwAddress, info))
		{
			szModule = info.szModule;
			szSymbol = info.szSymbol;
		}
		pHandler->OnEntry((void *) dwAddress, szModule, szSymbol);
	}
	pHandler->OnEnd();
}

#define STACK_TRACE_PART_DELIMITER ';'
#define STACK_TRACE_LINE_DELIMITER '~'

// CReportHookDumpHandler is a stack dump handler
// that gathers the stack dump into the format
// used by CDebugReportHook
class CReportHookDumpHandler : public IStackDumpHandler
{
public:
	CReportHookDumpHandler()
	{
		m_pstr = NULL;
	}

	void GetStackDump(CStringA *pstr)
	{
		ATLASSERT(pstr);
		SetString(pstr);
		AtlDumpStack(this);
		SetString(NULL);
	}

	void SetString(CStringA *pstr)
	{
		m_pstr = pstr;
	}

	// implementation
	// IStackDumpHandler methods
	void __stdcall OnBegin()
	{
	}
	
	void __stdcall OnEntry(void *pvAddress, LPCSTR szModule, LPCSTR szSymbol)
	{
		// make sure SetString was called before
		// trying to get a stack dump
		ATLASSERT(m_pstr);
		if (!m_pstr)
			return;

		char szBuf[100];
		sprintf(szBuf, "0x%p;", pvAddress);
		*m_pstr += szBuf;
		if (!szModule)
			szModule = "Unknown";
		if (!szSymbol)
			szSymbol = "<No Info>";

		*m_pstr += szModule;
		*m_pstr += STACK_TRACE_PART_DELIMITER;
		ATLASSERT(szSymbol);
		*m_pstr += szSymbol;
		*m_pstr += STACK_TRACE_PART_DELIMITER;
		*m_pstr += STACK_TRACE_LINE_DELIMITER;
	}
	
	void __stdcall OnError(LPCSTR /*szError*/)
	{
	}
	void __stdcall OnEnd()
	{
	}

protected:
	CStringA *m_pstr;

};

#define PIPE_INPUT_BUFFER_SIZE  4096
#define PIPE_OUTPUT_BUFFER_SIZE 2048

enum { DEBUG_SERVER_MESSAGE_TRACE, DEBUG_SERVER_MESSAGE_ASSERT, DEBUG_SERVER_MESSAGE_QUIT };

struct DEBUG_SERVER_MESSAGE
{
	DWORD dwType;		// one of DEBUG_SERVER_MESSAGE_*
	DWORD dwProcessId;	// process id of client
	DWORD dwClientNameLen;	// length of client name
	size_t dwTextLen;	// length of text message including null terminator
	BOOL bIsDebuggerAttached;	// TRUE if the debugger is already attached
};

#ifdef _DEBUG

extern "C" WINBASEAPI
BOOL
WINAPI
IsDebuggerPresent(
    VOID
    );

class CDebugReportHook
{
protected:
	_CRT_REPORT_HOOK m_pfnOldHook;
	static char m_szPipeName[MAX_PATH+1];
	static DWORD m_dwTimeout;
	static DWORD m_dwClientNameLen;
	static char m_szClientName[MAX_COMPUTERNAME_LENGTH+1];
	
public:
	CDebugReportHook(LPCSTR szMachineName = ".", LPCSTR szPipeName = "AtlsDbgPipe", DWORD dwTimeout = 20000) throw()
	{
		if (SetPipeName(szMachineName, szPipeName))
		{
			SetTimeout(dwTimeout);
			SetHook();
		}
		m_dwClientNameLen = sizeof(m_szClientName);
		GetComputerNameA(m_szClientName, &m_dwClientNameLen);
	}

	~CDebugReportHook() throw()
	{
		RemoveHook();
	}

	BOOL SetPipeName(LPCSTR szMachineName = ".", LPCSTR szPipeName = "AtlsDbgPipe") throw()
	{
		size_t nLen1 = strlen(szMachineName);
		size_t nLen2 = strlen(szPipeName);
		if (nLen1 + nLen2 + 8 <= MAX_PATH)
		{
			_snprintf(m_szPipeName, MAX_PATH, "\\\\%s\\pipe\\%s", szMachineName, szPipeName);
			return TRUE;
		}
		return FALSE;
	}

	void SetTimeout(DWORD dwTimeout)
	{
		m_dwTimeout = dwTimeout;
	}

	void SetHook() throw()
	{
		m_pfnOldHook = _CrtSetReportHook(CDebugReportHookProc);
	}

	void RemoveHook() throw()
	{
		_CrtSetReportHook(m_pfnOldHook);
	}

	static int __cdecl CDebugReportHookProc(int reportType, char *message, int *returnValue) throw()
	{
		DWORD dwWritten;
		
		*returnValue = 0;

		CRevertThreadToken revert;
		revert.Initialize();

		CHandle hdlPipe;
		while (1)
		{
			HANDLE hPipe = CreateFileA(m_szPipeName, GENERIC_WRITE | GENERIC_READ,
				FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
			
			if (hPipe != INVALID_HANDLE_VALUE )
			{
				hdlPipe.Attach(hPipe);
				break;
			}

			if (GetLastError() != ERROR_PIPE_BUSY)
			{
				if (reportType == _CRT_ASSERT)
					return TRUE;
				return FALSE;
			}

			//If the pipe is busy, we wait for up to m_dwTimeout
			if (!WaitNamedPipeA(m_szPipeName, m_dwTimeout)) 
			{
				if (reportType == _CRT_ASSERT)
					return TRUE;
				return FALSE;
			}
		}

		DEBUG_SERVER_MESSAGE Message;

		Message.bIsDebuggerAttached = IsDebuggerPresent();

		if (reportType == _CRT_ASSERT)
		{
			Message.dwType = DEBUG_SERVER_MESSAGE_ASSERT;
		}
		else
		{
			Message.dwType = DEBUG_SERVER_MESSAGE_TRACE;
		}

		Message.dwProcessId = GetCurrentProcessId();
		Message.dwClientNameLen = m_dwClientNameLen+1;	// add 1 for the null terminator
		Message.dwTextLen = strlen(message)+1;

		int nRet = 1;

		WriteFile(hdlPipe, &Message, sizeof(DEBUG_SERVER_MESSAGE), &dwWritten, NULL);

		WriteFile(hdlPipe, m_szClientName, Message.dwClientNameLen, &dwWritten, NULL);

		WriteFile(hdlPipe, message, (DWORD)Message.dwTextLen, &dwWritten, NULL);

		//Check to see whether or not to send stack trace
		BOOL bRet = ReadFile(hdlPipe, &nRet, sizeof(nRet), &dwWritten, NULL);

		//if nRet == 1, the user wants stack trace info
		if (bRet && nRet)
		{
			_ATLTRY
			{
				CStringA str;
				CReportHookDumpHandler stackDumper;
				stackDumper.GetStackDump(&str);
				if (!WriteFile(hdlPipe, (LPCSTR)str, str.GetLength(), &dwWritten, NULL))
					return (reportType == _CRT_ASSERT ? TRUE : FALSE);
			}
			_ATLCATCHALL()
			{
				return (reportType == _CRT_ASSERT ? TRUE : FALSE);
			}
		}

		if (bRet)
			bRet = ReadFile(hdlPipe, &nRet, sizeof(nRet), &dwWritten, NULL);
		if (!bRet)
			nRet = 0;

		revert.Restore();

		// possible return values
		// 0 -> Ignore or cancel
		// 1 -> Retry
		// 2 -> Abort
		if (nRet == 0)
		{
			return (reportType == _CRT_ASSERT ? TRUE : FALSE);
		}
		if (nRet == 1)
		{
			if (IsDebuggerPresent())
			{
				DebugBreak();
			}
		}

		if (nRet == 2)
			abort();

		return (reportType == _CRT_ASSERT ? TRUE : FALSE);
	}
}; // class CDebugReportHook


__declspec(selectany) char CDebugReportHook::m_szPipeName[MAX_PATH+1];
__declspec(selectany) DWORD CDebugReportHook::m_dwTimeout;
__declspec(selectany) DWORD CDebugReportHook::m_dwClientNameLen;
__declspec(selectany) char CDebugReportHook::m_szClientName[MAX_COMPUTERNAME_LENGTH+1];
#endif

#ifndef ATL_POOL_NUM_THREADS
	#define ATL_POOL_NUM_THREADS 0
#endif

#ifndef ATL_POOL_STACK_SIZE
	#define ATL_POOL_STACK_SIZE 0
#endif

#ifndef ATLS_DEFAULT_THREADSPERPROC
    #define ATLS_DEFAULT_THREADSPERPROC 2
#endif

#ifndef ATLS_DEFAULT_THREADPOOLSHUTDOWNTIMEOUT
    #define ATLS_DEFAULT_THREADPOOLSHUTDOWNTIMEOUT 36000
#endif

//
// CThreadPool
// This class is a simple IO completion port based thread pool
//	Worker:
//		is a class that is responsible for handling requests
//		queued on the thread pool.
//		It must have a typedef for RequestType, where request type
//		is the datatype to be queued on the pool
//		RequestType must be castable to (DWORD)
//		The value -1 is reserved for shutdown
//		of the pool
//		Worker must also have a void Execute(RequestType request, void *pvParam, OVERLAPPED *pOverlapped) function
//	ThreadTraits:
//		is a class that implements a static CreateThread function
//		This allows for overriding how the threads are created
#define ATLS_POOL_SHUTDOWN ((OVERLAPPED*) ((__int64) -1))
template <class Worker, class ThreadTraits=DefaultThreadTraits>
class CThreadPool : public IThreadPoolConfig
{
protected:

    CSimpleMap<DWORD, HANDLE> m_threadMap;

    DWORD m_dwThreadEventId;
    
    CComCriticalSection m_critSec;
    DWORD m_dwStackSize;
    DWORD m_dwMaxWait;
	
	void *m_pvWorkerParam;
	LONG m_bShutdown;

	HANDLE m_hThreadEvent;
	HANDLE m_hRequestQueue;

public:
	
	CThreadPool() throw() :
		m_hRequestQueue(NULL),
		m_pvWorkerParam(NULL),
        m_dwMaxWait(ATLS_DEFAULT_THREADPOOLSHUTDOWNTIMEOUT),
		m_bShutdown(FALSE),
		m_dwThreadEventId(0),
		m_dwStackSize(0)
	{
	}

	~CThreadPool() throw()
	{
		Shutdown();
	}
	
	// Initialize the thread pool
    // if nNumThreads > 0, then it specifies the number of threads
    // if nNumThreads < 0, then it specifies the number of threads per proc (-)
    // if nNumThreads == 0, then it defaults to two threads per proc
	// hCompletion is a handle of a file to associate with the completion port
	// pvWorkerParam is a parameter that will be passed to Worker::Execute
	//	dwStackSize:
	//		The stack size to use when creating the threads
	HRESULT Initialize(void *pvWorkerParam=NULL, int nNumThreads=0, DWORD dwStackSize=0, HANDLE hCompletion=INVALID_HANDLE_VALUE) throw()
	{
		ATLASSERT( m_hRequestQueue == NULL );

        if (m_hRequestQueue)   // Already initialized
            return AtlHresultFromWin32(ERROR_ALREADY_INITIALIZED);

        if (S_OK != m_critSec.Init())
            return E_FAIL;

        m_hThreadEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (!m_hThreadEvent)
        {
            m_critSec.Term();
            return AtlHresultFromLastError();
        }

		// Create IO completion port to queue the requests
		m_hRequestQueue = CreateIoCompletionPort(hCompletion, NULL, 0, nNumThreads);
		if (m_hRequestQueue == NULL)
		{
			// failed creating the Io completion port
            m_critSec.Term();
            CloseHandle(m_hThreadEvent);
			return AtlHresultFromLastError();		
		}
        m_pvWorkerParam = pvWorkerParam;
        m_dwStackSize = dwStackSize;

        HRESULT hr = SetSize(nNumThreads);
        if (hr != S_OK)
        {
		    // Close the request queue handle
		    CloseHandle(m_hRequestQueue);
		    
		    // Clear the queue handle
		    m_hRequestQueue = NULL;

            // Uninitialize the critical sections
            m_critSec.Term();
            CloseHandle(m_hThreadEvent);


            return hr;
        }

		return S_OK;
	}

	// Shutdown the thread pool
	// This function posts the shutdown request to all the threads in the pool
	// It will wait for the threads to shutdown a maximum of dwMaxWait MS.
	// If the timeout expires it just returns without terminating the threads.
	void Shutdown(DWORD dwMaxWait=0) throw()
	{
        if (!m_hRequestQueue)   // Not initialized
            return;

		CComCritSecLock<CComCriticalSection> lock(m_critSec, false);
		if (FAILED(lock.Lock()))
		{
			// out of memory
			ATLASSERT( FALSE );
			return;
		}


		if (dwMaxWait == 0)
			dwMaxWait = m_dwMaxWait;

        HRESULT hr = InternalResizePool(0, dwMaxWait);

        if (hr != S_OK)
            ATLTRACE(atlTraceUtil, 0, _T("Thread pool not shutting down cleanly : %08x"), hr);
            // If the threads have not returned, then something is wrong

        for (int i = m_threadMap.GetSize() - 1; i >= 0; i--)
        {
            HANDLE hThread = m_threadMap.GetValueAt(i);
            DWORD dwExitCode;
            GetExitCodeThread(hThread, &dwExitCode);
            if (dwExitCode == STILL_ACTIVE)
            {
                ATLTRACE(atlTraceUtil, 0, _T("Terminating thread"));
                TerminateThread(hThread, 0);
            }
            CloseHandle(hThread);
        }

		// Close the request queue handle
		CloseHandle(m_hRequestQueue);
		
		// Clear the queue handle
		m_hRequestQueue = NULL;

        ATLASSERT(m_threadMap.GetSize() == 0);

        // Uninitialize the critical sections
		lock.Unlock();
        m_critSec.Term();
        CloseHandle(m_hThreadEvent);

	}

    // IThreadPoolConfig methods
    HRESULT STDMETHODCALLTYPE SetSize(int nNumThreads) throw()
    {
        if (nNumThreads == 0)
            nNumThreads = -ATLS_DEFAULT_THREADSPERPROC;

		if (nNumThreads < 0)
		{
			SYSTEM_INFO si;
			GetSystemInfo(&si);
			nNumThreads = (int) (-nNumThreads) * si.dwNumberOfProcessors;
		}

        return InternalResizePool(nNumThreads, m_dwMaxWait);
    }

    HRESULT STDMETHODCALLTYPE GetSize(int *pnNumThreads) throw()
    {
		if (!pnNumThreads)
			return E_POINTER;

        *pnNumThreads = GetNumThreads();
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE SetTimeout(DWORD dwMaxWait) throw()
    {
        m_dwMaxWait = dwMaxWait;

        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE GetTimeout(DWORD *pdwMaxWait) throw()
    {
        if (!pdwMaxWait)
            return E_POINTER;

        *pdwMaxWait = m_dwMaxWait;

        return S_OK;
    }

    // IUnknown methods
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppv) throw()
	{
		if (!ppv)
			return E_POINTER;

		*ppv = NULL;

		if (InlineIsEqualGUID(riid, __uuidof(IUnknown)) ||
			InlineIsEqualGUID(riid, __uuidof(IThreadPoolConfig)))
		{
			*ppv = static_cast<IThreadPoolConfig*>(this);
			AddRef();
			return S_OK;
		}
		return E_NOINTERFACE;
	}

	ULONG STDMETHODCALLTYPE AddRef() throw()
	{
		return 1;
	}
	
	ULONG STDMETHODCALLTYPE Release() throw()
	{
		return 1;
	}


	HANDLE GetQueueHandle() throw()
	{
		return m_hRequestQueue;
	}

	int GetNumThreads() throw()
	{
		return m_threadMap.GetSize();
	}

	// QueueRequest adds a request to the thread pool
	// it will be picked up by one of the threads and dispatched to the worker
	// in WorkerThreadProc
	BOOL QueueRequest(Worker::RequestType request) throw()
	{
		if (!PostQueuedCompletionStatus(m_hRequestQueue, 0, (ULONG_PTR) request, NULL))
			return FALSE;
		return TRUE;
	}
	

protected:

    DWORD ThreadProc() throw()
    {
		DWORD dwBytesTransfered;
		ULONG_PTR dwCompletionKey;

		OVERLAPPED* pOverlapped;

		// We instantiate an instance of the worker class on the stack
		// for the life time of the thread.
		Worker theWorker;

		if (theWorker.Initialize(m_pvWorkerParam) == FALSE)
		{
			return 1;
		}

        SetEvent(m_hThreadEvent);
		// Get the request from the IO completion port
		while (GetQueuedCompletionStatus(m_hRequestQueue, &dwBytesTransfered, &dwCompletionKey, &pOverlapped, INFINITE))
		{
			if (pOverlapped == ATLS_POOL_SHUTDOWN) // Shut down
			{
		        m_dwThreadEventId = GetCurrentThreadId();
				LONG bResult = InterlockedExchange(&m_bShutdown, FALSE);
				if (bResult) // Shutdown has not been cancelled
					break;
				m_dwThreadEventId = 0;
				// else, shutdown has been cancelled -- continue as before
			}
			else										// Do work
			{
				Worker::RequestType request = (Worker::RequestType) dwCompletionKey;

				// Process the request.  Notice the following:
				// (1) It is the worker's responsibility to free any memory associated
				// with the request if the request is complete
				// (2) If the request still requires some more processing
				// the worker should queue the request again for dispatching
				theWorker.Execute(request, m_pvWorkerParam, pOverlapped);
			}
		}
        SetEvent(m_hThreadEvent);
    	theWorker.Terminate(m_pvWorkerParam);
		return 0; 
    }

	static DWORD WINAPI WorkerThreadProc(LPVOID pv) throw()
	{
		CThreadPool* pThis = 
			reinterpret_cast< CThreadPool* >(pv); 

        return pThis->ThreadProc();
	} 

    HRESULT InternalResizePool(int nNumThreads, int dwMaxWait) throw()
    {
        if (!m_hRequestQueue)   // Not initialized
            return E_FAIL;

		CComCritSecLock<CComCriticalSection> lock(m_critSec, false);
		if (FAILED(lock.Lock()))
		{
			// out of memory
			ATLASSERT( FALSE );
			return E_FAIL;
		}

        int nCurThreads = m_threadMap.GetSize();
        if (nNumThreads == nCurThreads)
        {
            return S_OK;
        }
        else if (nNumThreads < nCurThreads)
        {
            int nNumShutdownThreads = nCurThreads - nNumThreads;
            for (int nThreadIndex = 0; nThreadIndex < nNumShutdownThreads; nThreadIndex++)
            {    
				ResetEvent(m_hThreadEvent);

				m_bShutdown = TRUE;
                PostQueuedCompletionStatus(m_hRequestQueue, 0, 0, ATLS_POOL_SHUTDOWN);
                DWORD dwRet = WaitForSingleObject(m_hThreadEvent, dwMaxWait);

                if (dwRet == WAIT_TIMEOUT)
                {
					LONG bResult = InterlockedExchange(&m_bShutdown, FALSE);
					if (bResult) // Nobody picked up the shutdown message
					{
//						m_critSec.Unlock();
						return HRESULT_FROM_WIN32(WAIT_TIMEOUT);
					}
                }
                else if (dwRet != WAIT_OBJECT_0)
                {
//                    m_critSec.Unlock();
                    return AtlHresultFromLastError();
                }

                int nIndex = m_threadMap.FindKey(m_dwThreadEventId);
                if (nIndex != -1)
                {
                    HANDLE hThread = m_threadMap.GetValueAt(nIndex);
                    CloseHandle(hThread);
                    m_threadMap.RemoveAt(nIndex);
                }
            }
        }
        else
        {
            int nNumNewThreads = nNumThreads - nCurThreads;
		    // Create and initialize worker threads

		    for (int nThreadIndex = 0; nThreadIndex < nNumNewThreads; nThreadIndex++)
		    {
    		    DWORD dwThreadID;
                ResetEvent(m_hThreadEvent);
//                HANDLE hThread = ThreadTraits::CreateThread(NULL, m_dwStackSize, WorkerThreadProc, (LPVOID)this, 0, &dwThreadID);
				CHandle hdlThread( ThreadTraits::CreateThread(NULL, m_dwStackSize, WorkerThreadProc, (LPVOID)this, 0, &dwThreadID) );
            
			    if (!hdlThread)
                {
					HRESULT hr = AtlHresultFromLastError();
					ATLASSERT(hr != S_OK);
//                    m_critSec.Unlock();
				    return hr;
                }

                DWORD dwRet = WaitForSingleObject(m_hThreadEvent, dwMaxWait);
                if (dwRet != WAIT_OBJECT_0)
                {
                    if (dwRet == WAIT_TIMEOUT)
                    {
//                        m_critSec.Unlock();
                        return HRESULT_FROM_WIN32(WAIT_TIMEOUT);
                    }
                    else
                    {
//                        m_critSec.Unlock();
                        return AtlHresultFromLastError();
                    }
                }
                
                if (m_threadMap.Add(dwThreadID, hdlThread) != FALSE)
				{
					hdlThread.Detach();
				}
            }
        }
//        m_critSec.Unlock();
        return S_OK;
    }

}; // class CThreadPool

//
// CNonStatelessWorker
// This class is a simple wrapper for use with CThreadPool.
//	It instantiates one instance of Worker per request
//	this allows Worker to hold state for each request
//	and depend on the destructor being called
//	Worker:
//		is a class that is responsible for handling requests
//		queued on the thread pool (See CThreadPool)
template <class Worker>
class CNonStatelessWorker
{
public:
	typedef Worker::RequestType RequestType;

	BOOL Initialize(void * /*pvParam*/) throw()
	{
		return TRUE;
	}
	
	void Execute(Worker::RequestType request, void *pvWorkerParam, OVERLAPPED *pOverlapped)
	{
		Worker worker;
		worker.Execute(request, pvWorkerParam, pOverlapped);
	}
	void Terminate(void* /*pvParam*/) throw()
	{
	}
}; // class CNonStatelessWorker


//Flags
#define ATL_URL_ESCAPE             1   // (un)escape URL characters
#define ATL_URL_NO_ENCODE          2   // Don't convert unsafe characters to escape sequence
#define ATL_URL_DECODE             4   // Convert %XX escape sequences to characters
#define ATL_URL_NO_META            8   // Don't convert .. etc. meta path sequences
#define ATL_URL_ENCODE_SPACES_ONLY 16  // Encode spaces only
#define ATL_URL_BROWSER_MODE       32  // Special encode/decode rules for browser
#define ATL_URL_ENCODE_PERCENT     64  // Encode percent (by default, not encoded)
#define ATL_URL_CANONICALIZE       128 // Internal: used by Canonicalize for AtlEscapeUrl: Cannot be set via SetFlags
#define ATL_URL_COMBINE            256 // Internal: Cannot be set via SetFlags


//Get the decimal value of a hexadecimal character
inline short AtlHexValue(char chIn)
{
	unsigned char ch = (unsigned char)chIn;
	if (ch >= '0' && ch <= '9')
		return (short)(ch - '0');
	if (ch >= 'A' && ch <= 'F')
		return (short)(ch - 'A' + 10);
	if (ch >= 'a' && ch <= 'f')
		return (short)(ch - 'a' + 10);
	return -1;
}


//Determine if the character is unsafe under the URI RFC document
inline BOOL AtlIsUnsafeUrlChar(char chIn) throw()
{
	unsigned char ch = (unsigned char)chIn;
	switch(ch)
	{
		case ';': case '\\': case '?': case '@': case '&':
		case '=': case '+': case '$': case ',': case ' ':
		case '<': case '>': case '#': case '%': case '\"':
		case '{': case '}': case '|':
		case '^': case '[': case ']': case '`':
			return TRUE;
		default:
		{
			if (ch < 32 || ch > 126)
				return TRUE;
			return FALSE;
		}
	}
}

//Get the default internet port for a particular scheme
inline ATL_URL_PORT AtlGetDefaultUrlPort(ATL_URL_SCHEME m_nScheme) throw()
{
	switch (m_nScheme)
	{
		case ATL_URL_SCHEME_FTP:
			return ATL_URL_DEFAULT_FTP_PORT;
		case ATL_URL_SCHEME_GOPHER:
			return ATL_URL_DEFAULT_GOPHER_PORT;
		case ATL_URL_SCHEME_HTTP:
			return ATL_URL_DEFAULT_HTTP_PORT;
		case ATL_URL_SCHEME_HTTPS:
			return ATL_URL_DEFAULT_HTTPS_PORT;
		case ATL_URL_SCHEME_SOCKS:
			return ATL_URL_DEFAULT_SOCKS_PORT;
		default:
			return ATL_URL_INVALID_PORT_NUMBER;
	}
}

//Escape a meta sequence with lpszOutUrl as the base url and lpszInUrl as the relative url
//i.e. lpszInUrl = ./* or ../*
ATL_NOINLINE inline BOOL AtlEscapeUrlMetaHelper(
	LPSTR* ppszOutUrl,
	DWORD dwOutLen,
	LPSTR* ppszInUrl,
	DWORD* pdwLen, 
	DWORD dwFlags = 0,
	DWORD dwColonPos = ATL_URL_MAX_URL_LENGTH) throw()
{
	ATLASSERT( ppszOutUrl != NULL );
	ATLASSERT( ppszInUrl != NULL );
	ATLASSERT( pdwLen != NULL);

	LPSTR szOut = *ppszOutUrl;
	LPSTR szIn = *ppszInUrl;
	DWORD dwUrlLen = dwOutLen;
	char chPrev = *(szOut-1);
	BOOL bRet = FALSE;

	//if the previous character is a directory delimiter
	if (chPrev == '/' || chPrev == '\\')
	{
		char chNext = *szIn;

		//if the next character is a directory delimiter
		if (chNext == '/' || chNext == '\\')
		{
			//the meta sequence is of the form /./*
			szIn++;
			bRet = TRUE;
		}
		else if (chNext == '.' && ((chNext = *(szIn+1)) == '/' || 
			chNext == '\\' || chNext == '\0'))
		{
			//otherwise if the meta sequence is of the form "/../"
			//skip the preceding "/"
			szOut--;

			//skip the ".." of the meta sequence
			szIn+= 2;
			DWORD dwOutPos = dwUrlLen-1;
			LPSTR szTmp = szOut;

			//while we are not at the beginning of the base url
			while (dwOutPos)
			{
				szTmp--;
				dwOutPos--;

				//if it is a directory delimiter
				if (*szTmp == '/' || *szTmp == '\\')
				{
					//if we are canonicalizing the url and NOT combining it
					//and if we have encountered the ':' or we are at a position before the ':'
					if ((dwFlags & ATL_URL_CANONICALIZE) && ((dwFlags & ATL_URL_COMBINE) == 0) &&
						(dwColonPos && (dwOutPos <= dwColonPos+1)))
					{
						//NOTE: this is to match the way that InternetCanonicalizeUrl and 
						//      InternetCombineUrl handle this case
						break;
					}

					//otherwise, set the current output string position to right after the '/'
					szOut = szTmp+1;

					//update the length to match
					dwUrlLen = dwOutPos+1;
					bRet = TRUE;
					break;
				}
			}

			//if we could not properly escape the meta sequence
			if (dwUrlLen != dwOutPos+1)
			{
				//restore everything to its original value
				szIn-= 2;
				szOut++;
			}
			else
			{
				bRet = TRUE;
			}
		}
	}
	//update the strings
	*ppszOutUrl = szOut;
	*ppszInUrl = szIn;
	*pdwLen = dwUrlLen;
	return bRet;
}

//Convert all unsafe characters in szStringIn to escape sequences
//lpszStringIn and lpszStringOut should be different strings
inline BOOL AtlEscapeUrlA(
	LPCSTR szStringIn,
	LPSTR szStringOut,
	DWORD* pdwStrLen,
	DWORD dwMaxLength,
	DWORD dwFlags = 0) throw()
{
	ATLASSERT( szStringIn != NULL );
	ATLASSERT( szStringOut != NULL );
	ATLASSERT( szStringIn != szStringOut );

	char ch;
	DWORD dwLen = 0;
	BOOL bRet = TRUE;
	BOOL bSchemeFile = FALSE;
	DWORD dwColonPos = 0;
	DWORD dwFlagsInternal = dwFlags;
	while((ch = *szStringIn++) != '\0')
	{
		//if we are at the maximum length, set bRet to FALSE
		//this ensures no more data is written to szStringOut, but
		//the length of the string is still updated, so the user
		//knows how much space to allocate
		if (dwLen == dwMaxLength)
		{
			bRet = FALSE;
		}
		
		//Keep track of the first ':' position to match the weird way
		//InternetCanonicalizeUrl handles it
		if (ch == ':' && (dwFlagsInternal & ATL_URL_CANONICALIZE) && !dwColonPos)
		{
			if (bRet)
			{
				*szStringOut = '\0';
				_strlwr(szStringOut-dwLen);

				if (dwLen == 4 && !strncmp("file", (szStringOut-4), 4))
				{
					bSchemeFile = TRUE;
				}
			}

			dwColonPos = dwLen+1;
		}
		else if (ch == '%' && (dwFlagsInternal & ATL_URL_DECODE))
		{
			//decode the escaped sequence
			ch = (char)(16*AtlHexValue(*szStringIn++));
			ch = (char)(ch+AtlHexValue(*szStringIn++));
		}
		else if ((ch == '?' || ch == '#') && (dwFlagsInternal & ATL_URL_BROWSER_MODE))
		{
			//ATL_URL_BROWSER mode does not encode after a '?' or a '#'
			dwFlagsInternal |= ATL_URL_NO_ENCODE;
		}

		if ((dwFlagsInternal & ATL_URL_CANONICALIZE) && (dwFlagsInternal & ATL_URL_NO_ENCODE)==0)
		{
			//canonicalize the '\' to '/'
			if (ch == '\\' && (dwColonPos || (dwFlagsInternal & ATL_URL_COMBINE)) && bRet)
			{
				//if the scheme is not file or it is file and the '\' is in "file:\\"
				//NOTE: This is to match the way InternetCanonicalizeUrl handles this case
				if (!bSchemeFile || (dwLen < 7))
				{
					ch = '/';
				}
			}
			else if (ch == '.' && dwLen > 0 && (dwFlagsInternal & ATL_URL_NO_META)==0)
			{
				//if we are escaping meta sequences, attempt to do so
				if (AtlEscapeUrlMetaHelper(&szStringOut, dwLen, (char**)(&szStringIn), &dwLen, dwFlagsInternal, dwColonPos))
					continue;
			}
		}

		//if we are encoding and it is an unsafe character
		if (AtlIsUnsafeUrlChar(ch) && (dwFlagsInternal & ATL_URL_NO_ENCODE)==0)
		{
			//if we are only encoding spaces, and ch is not a space or
			//if we are not encoding meta sequences and it is a dot or
			//if we not encoding percents and it is a percent
			if (((dwFlagsInternal & ATL_URL_ENCODE_SPACES_ONLY) && ch != ' ') ||
				((dwFlagsInternal & ATL_URL_NO_META) && ch == '.') ||
				(((dwFlagsInternal & ATL_URL_ENCODE_PERCENT) == 0) && ch == '%'))
			{
				//just output it without encoding
				if (bRet)
					*szStringOut++ = ch;
			}
			else 
			{
				//if there is not enough space for the escape sequence
				if (dwLen >= (dwMaxLength-3))
				{
					bRet = FALSE;
				}
				if (bRet)
				{
					//output the percent, followed by the hex value of the character
					*szStringOut++ = '%';
//					sprintf(szStringOut, "%.2X", (unsigned char)(ch));
					_itoa((int)ch, szStringOut, 16);
					szStringOut+= 2;
				}
				dwLen += 2;
			}
		}
		else //safe character
		{
			if (bRet)
				*szStringOut++ = ch;
		}
		dwLen++;
	}

	if ((dwFlags & ATL_URL_BROWSER_MODE)==0)
	{
		//trim trailing whitespace
		szStringOut--;
		while (1)
		{
			if (*szStringOut == ' ')
			{
				--szStringOut;
				continue;
			}
			if (!strncmp(szStringOut-2, "%20", 3))
			{
				szStringOut -= 3;
				continue;
			}
			break;
		}
		szStringOut++;
	}

	if (bRet)
		*szStringOut = '\0';

	if (pdwStrLen)
		*pdwStrLen = dwLen;
	return bRet;
}

inline BOOL AtlEscapeUrlW(
	LPCWSTR szStringIn,
	LPWSTR szStringOut,
	DWORD* pdwStrLen,
	DWORD dwMaxLength,
	DWORD dwFlags = 0) throw()
{
	// convert to UTF8
	BOOL bRet = FALSE;

	int nSrcLen = (int) wcslen(szStringIn);
	int nCnt = AtlUnicodeToUTF8(szStringIn, nSrcLen, NULL, 0);
	if (nCnt != 0)
	{
		nCnt++;
		CHeapPtr<char> szIn;

		char szInBuf[ATL_URL_MAX_URL_LENGTH];
		char *pszIn = szInBuf;

		// try to avoid allocation
		if (nCnt > ATL_URL_MAX_URL_LENGTH)
		{
			if (!szIn.AllocateBytes(nCnt))
			{
				// out of memory
				return FALSE;
			}
			pszIn = szIn;
		}

		nCnt = AtlUnicodeToUTF8(szStringIn, nSrcLen, pszIn, nCnt);
		ATLASSERT( nCnt != 0 );

		pszIn[nCnt] = '\0';
		
		char szOutBuf[ATL_URL_MAX_URL_LENGTH];
		char *pszOut = szOutBuf;
		CHeapPtr<char> szTmp;

		// try to avoid allocation
		if (dwMaxLength > ATL_URL_MAX_URL_LENGTH)
		{
			if (!szTmp.AllocateBytes(dwMaxLength))
			{
				// out of memory
				return FALSE;
			}
			pszOut = szTmp;
		}

		DWORD dwStrLen = 0;
		bRet = AtlEscapeUrlA(pszIn, pszOut, &dwStrLen, dwMaxLength, dwFlags);
		if (bRet != FALSE)
		{
			// it is now safe to convert using any codepage, since there
			// are no non-ASCII characters
			pszOut[dwStrLen] = '\0';
			_ATLTRY
			{
				memcpy(szStringOut, CA2W( pszOut ), dwStrLen*sizeof(wchar_t));
				szStringOut[dwStrLen] = '\0';
			}
			_ATLCATCHALL()
			{
				bRet = FALSE;
			}
		}
		if (pdwStrLen)
		{
			*pdwStrLen = dwStrLen;
		}
	}

	return bRet;
}

//Convert all escaped characters in szString to their real values
//lpszStringIn and lpszStringOut can be the same string	
inline BOOL AtlUnescapeUrlA(
	LPCSTR szStringIn,
	LPSTR szStringOut,
	LPDWORD pdwStrLen,
	DWORD dwMaxLength) throw()
{
	ATLASSERT(szStringIn != NULL);
	ATLASSERT(szStringOut != NULL);

	int nValue = 0;
	char ch;
	DWORD dwLen = 0;
	BOOL bRet = TRUE;
	while ((ch = *szStringIn) != 0)
	{
		if (dwLen == dwMaxLength)
			bRet = FALSE;

		if (bRet)
		{
			if (ch == '%')
			{
				if ((*(szStringIn+1) == '\0') || (*(szStringIn+2) == '\0'))
				{
					bRet = FALSE;
					break;
				}
				ch = *(++szStringIn);
				//currently assuming 2 hex values after '%'
				//as per the RFC 2396 document
				nValue = 16*AtlHexValue(ch);
				nValue+= AtlHexValue(*(++szStringIn));
				*szStringOut++ = (char) nValue;
			}
			else //non-escape character
			{
				if (bRet)
					*szStringOut++ = ch;
			}
		}
		dwLen++;
		szStringIn++;
	}

	if (bRet)
		*szStringOut = '\0';

	if (pdwStrLen)
		*pdwStrLen = dwLen;
	return TRUE;
}

inline BOOL AtlUnescapeUrlW(
	LPCWSTR szStringIn,
	LPWSTR szStringOut,
	LPDWORD pdwStrLen,
	DWORD dwMaxLength) throw()
{
	/// convert to UTF8
	BOOL bRet = FALSE;

	int nSrcLen = (int) wcslen(szStringIn);
	int nCnt = AtlUnicodeToUTF8(szStringIn, nSrcLen, NULL, 0);
	if (nCnt != 0)
	{
		nCnt++;
		CHeapPtr<char> szIn;

		char szInBuf[ATL_URL_MAX_URL_LENGTH];
		char *pszIn = szInBuf;

		// try to avoid allocation
		if (nCnt > ATL_URL_MAX_URL_LENGTH)
		{
			if (!szIn.AllocateBytes(nCnt))
			{
				// out of memory
				return FALSE;
			}
			pszIn = szIn;
		}

		nCnt = AtlUnicodeToUTF8(szStringIn, nSrcLen, pszIn, nCnt);
		ATLASSERT( nCnt != 0 );

		pszIn[nCnt] = '\0';
		
		char szOutBuf[ATL_URL_MAX_URL_LENGTH];
		char *pszOut = szOutBuf;
		CHeapPtr<char> szTmp;

		// try to avoid allocation
		if (dwMaxLength > ATL_URL_MAX_URL_LENGTH)
		{
			if (!szTmp.AllocateBytes(dwMaxLength))
			{
				// out of memory
				return FALSE;
			}
			pszOut = szTmp;
		}

		DWORD dwStrLen = 0;
		bRet = AtlUnescapeUrlA(pszIn, pszOut, &dwStrLen, dwMaxLength);
		if (bRet != FALSE)
		{
			// it is now safe to convert using any codepage, since there
			// are no non-ASCII characters
			pszOut[dwStrLen] = '\0';
			_ATLTRY
			{
				memcpy(szStringOut, CA2W( pszOut ), dwStrLen*sizeof(wchar_t));
				szStringOut[dwStrLen] = '\0';
			}
			_ATLCATCHALL()
			{
				bRet = FALSE;
			}
		}
		if (pdwStrLen)
		{
			*pdwStrLen = dwStrLen;
		}
	}

	return bRet;
}

#ifdef UNICODE
	#define AtlEscapeUrl AtlEscapeUrlW
	#define AtlUnescapeUrl AtlUnescapeUrlW
#else
	#define AtlEscapeUrl AtlEscapeUrlA
	#define AtlUnescapeUrl AtlUnescapeUrlA
#endif

//Canonicalize a URL (same as InternetCanonicalizeUrl)
inline BOOL AtlCanonicalizeUrl(
	LPCTSTR szUrl,
	LPTSTR szCanonicalized,
	DWORD* pdwMaxLength,
	DWORD dwFlags = 0) throw()
{
	ATLASSERT( szUrl != NULL );
	ATLASSERT( szCanonicalized != NULL );
	ATLASSERT( pdwMaxLength != NULL);

	return AtlEscapeUrl(szUrl, szCanonicalized, pdwMaxLength, *pdwMaxLength, dwFlags | ATL_URL_CANONICALIZE);
}

//Combine a base and relative URL (same as InternetCombineUrl)
inline BOOL AtlCombineUrl(
	LPCTSTR szBaseUrl,
	LPCTSTR szRelativeUrl,
	LPTSTR szBuffer,
	DWORD* pdwMaxLength,
	DWORD dwFlags = 0) throw()
{
	ATLASSERT(szBaseUrl != NULL);
	ATLASSERT(szRelativeUrl != NULL);
	ATLASSERT(szBuffer != NULL);
	ATLASSERT(pdwMaxLength != NULL);

	size_t nLen1 = _tcslen(szBaseUrl);
	TCHAR szCombined[2*ATL_URL_MAX_URL_LENGTH];
	if (nLen1 >= 2*ATL_URL_MAX_URL_LENGTH)
	{
		return FALSE;
	}

	_tcscpy(szCombined, szBaseUrl);

	// if last char of szBaseUrl is not a slash, add it.
	if (nLen1 > 0 && szCombined[nLen1-1] != _T('/'))
	{
		szCombined[nLen1] = _T('/');
		nLen1++;
		szCombined[nLen1] = _T('\0');
	}

	size_t nLen2 = _tcslen(szRelativeUrl);
	
	if (nLen2+nLen1+1 >= 2*ATL_URL_MAX_URL_LENGTH)
	{
		return FALSE;
	}

	_tcsncpy(szCombined+nLen1, szRelativeUrl, nLen2+1);
	DWORD dwLen = (DWORD) (nLen1+nLen2);
	if (dwLen >= *pdwMaxLength)
	{
		*pdwMaxLength = dwLen;
		return FALSE;
	}
	return AtlEscapeUrl(szCombined, szBuffer, pdwMaxLength, *pdwMaxLength, dwFlags | ATL_URL_COMBINE | ATL_URL_CANONICALIZE);
}

class CUrl
{
private:
	//scheme names cannot contain escape/unsafe characters
	TCHAR m_szScheme[ATL_URL_MAX_SCHEME_LENGTH+1];

	//host names cannot contain escape/unsafe characters
	TCHAR m_szHostName[ATL_URL_MAX_HOST_NAME_LENGTH+1];

	TCHAR m_szUserName[ATL_URL_MAX_USER_NAME_LENGTH+1];
	TCHAR m_szPassword[ATL_URL_MAX_PASSWORD_LENGTH+1];
	TCHAR m_szUrlPath[ATL_URL_MAX_PATH_LENGTH+1];
	TCHAR m_szExtraInfo[ATL_URL_MAX_PATH_LENGTH+1];

	ATL_URL_PORT m_nPortNumber;
	ATL_URL_SCHEME m_nScheme;

	DWORD m_dwSchemeNameLength;
	DWORD m_dwHostNameLength;
	DWORD m_dwUserNameLength;
	DWORD m_dwPasswordLength;
	DWORD m_dwUrlPathLength;
	DWORD m_dwExtraInfoLength;

public:
	//Empty constructor
	CUrl() throw()
	{
		InitFields();
		SetScheme(ATL_URL_SCHEME_HTTP);
	}

	//Copy constructor--maybe make private
	CUrl(const CUrl& urlThat) throw()
	{
		CopyFields(urlThat);
	}

	//Destructor (empty)
	~CUrl() throw()
	{
	}

	CUrl& operator=(const CUrl& urlThat)  throw()
	{
		CopyFields(urlThat);
		return (*this);
	}

	//Set the url
	BOOL CrackUrl(LPCTSTR lpszUrl, DWORD dwFlags = 0) throw()
	{
		ATLASSERT(lpszUrl != NULL);

		InitFields();
		BOOL bRet = FALSE;
		if (dwFlags & ATL_URL_DECODE)
		{
			//decode the url before parsing it
			TCHAR szDecodedUrl[ATL_URL_MAX_URL_LENGTH];
			DWORD dwLen;
			if (!AtlUnescapeUrl(lpszUrl, szDecodedUrl, &dwLen, ATL_URL_MAX_URL_LENGTH))
				return FALSE;
			bRet = Parse(szDecodedUrl);
		}
		else
		{
			bRet = Parse(lpszUrl);
		}
		if (bRet && (dwFlags & ATL_URL_ESCAPE))
		{
			bRet = AtlUnescapeUrl(m_szUserName, m_szUserName, 
				&m_dwUserNameLength, ATL_URL_MAX_USER_NAME_LENGTH);
			if (bRet)
			{
				bRet = AtlUnescapeUrl(m_szPassword, m_szPassword, 
					&m_dwPasswordLength, ATL_URL_MAX_PASSWORD_LENGTH);
				if (bRet)
				{
					bRet = AtlUnescapeUrl(m_szUrlPath, m_szUrlPath, 
						&m_dwUrlPathLength, ATL_URL_MAX_PATH_LENGTH);
					if (bRet)
					{
						bRet = AtlUnescapeUrl(m_szExtraInfo, m_szExtraInfo, 
							&m_dwExtraInfoLength, ATL_URL_MAX_PATH_LENGTH);
					}
				}
			}
		}
		return bRet;
	}

	inline BOOL CreateUrl(LPTSTR lpszUrl, DWORD* pdwMaxLength, DWORD dwFlags = 0) const throw()
	{
		ATLASSERT(lpszUrl != NULL);
		ATLASSERT(pdwMaxLength != NULL);

		//build URL: <scheme>://<user>:<pass>@<domain>:<port><path><extra>
		TCHAR szPortNumber[ATL_URL_MAX_PORT_NUMBER_LENGTH+2];
		DWORD dwLength = *pdwMaxLength;
		*pdwMaxLength = GetUrlLength()+1;
		if (*pdwMaxLength > dwLength)
			return FALSE;
		_stprintf(szPortNumber, _T(":%d"), m_nPortNumber);
		LPTSTR lpszOutUrl = lpszUrl;
		*lpszUrl = '\0';

		if (*m_szScheme)
		{
			_tcsncpy(lpszUrl, m_szScheme, m_dwSchemeNameLength);
			lpszUrl += m_dwSchemeNameLength;
			*lpszUrl++ = ':';
			if (m_nScheme != ATL_URL_SCHEME_MAILTO)
			{
				*lpszUrl++ = '/';
				*lpszUrl++ = '/';
			}
		}
		
		if (*m_szUserName)
		{
			_tcsncpy(lpszUrl, m_szUserName, m_dwUserNameLength);
			lpszUrl += m_dwUserNameLength;
			if (*m_szPassword)
			{
				*lpszUrl++ = ':';
				_tcsncpy(lpszUrl, m_szPassword, m_dwPasswordLength);
				lpszUrl += m_dwPasswordLength;
			}
			*lpszUrl++ = '@';
		}

		if (*m_szHostName)
		{
			_tcsncpy(lpszUrl, m_szHostName, m_dwHostNameLength);
			lpszUrl += m_dwHostNameLength;
			if (m_nPortNumber != AtlGetDefaultUrlPort(m_nScheme))
			{
				DWORD dwPortLen = (DWORD) _tcslen(szPortNumber);
				_tcsncpy(lpszUrl, szPortNumber, dwPortLen);
				lpszUrl += dwPortLen;
			}
			if (*m_szUrlPath && *m_szUrlPath != '/' && *m_szUrlPath != '\\')
				*lpszUrl++ = '/';
		}

		if (*m_szUrlPath)
		{
			_tcsncpy(lpszUrl, m_szUrlPath, m_dwUrlPathLength);
			lpszUrl+= m_dwUrlPathLength;
		}

		if (*m_szExtraInfo)
		{
			_tcsncpy(lpszUrl, m_szExtraInfo, m_dwExtraInfoLength);
			lpszUrl += m_dwExtraInfoLength;
		}
		*lpszUrl = '\0';

		(*pdwMaxLength)--;
		
		if (dwFlags & ATL_URL_ESCAPE)
		{
			TCHAR szUrl[ATL_URL_MAX_URL_LENGTH];
			_tcsncpy(szUrl, lpszOutUrl, *pdwMaxLength+1);
			return AtlUnescapeUrl(szUrl, lpszOutUrl, pdwMaxLength, dwLength);
		}

		return TRUE;
	}

	inline void Clear() throw()
	{
		InitFields();
	}

	inline DWORD GetUrlLength() const throw()
	{
		//The conditionals in this method are related to the conditionals in the CreateUrl method
		//scheme + ':'
		DWORD dwUrlLength = m_dwSchemeNameLength+1;

		//i.e. "//"
		if (m_nScheme != ATL_URL_SCHEME_MAILTO)
			dwUrlLength += 2;  

		dwUrlLength += m_dwUserNameLength;

		//i.e. "username@"
		if (m_dwUserNameLength > 0)
			dwUrlLength += m_dwUserNameLength+1;

		//i.e. ":password"
		if (m_dwPasswordLength > 0)
			dwUrlLength += m_dwPasswordLength+1;
	
		dwUrlLength += m_dwHostNameLength;

		// will need to add an extra '/' in this case
		if (m_dwHostNameLength && m_dwUrlPathLength && *m_szUrlPath != '/' && *m_szUrlPath != '\\')
			dwUrlLength++;

		//i.e. ":xx" where "xx" is the port number
		if (m_nPortNumber != AtlGetDefaultUrlPort(m_nScheme))
		{
			TCHAR szPortTmp[6];
			dwUrlLength += _stprintf(szPortTmp, _T(":%d"), m_nPortNumber);
		}

		dwUrlLength += m_dwUrlPathLength + m_dwExtraInfoLength;

		return dwUrlLength;
	}

	//Get the Scheme Name (i.e. http, ftp, etc.)
	inline LPCTSTR GetSchemeName() const throw()
	{
		return m_szScheme;
	}

	//Get the Scheme Name length
	inline DWORD GetSchemeNameLength() const throw()
	{
		return m_dwSchemeNameLength;
	}

	//This method will incur the cost of 
	//validating the scheme and updating the scheme name
	inline BOOL SetSchemeName(LPCTSTR lpszSchm) throw()
	{
		ATLASSERT(lpszSchm != NULL);

		const _schemeinfo *pSchemes = GetSchemes();

		ATLASSERT( pSchemes != NULL );

		int nScheme = -1;

		for (int i=0; i<s_nSchemes; i++)
		{
			if (_tcsicmp(lpszSchm, pSchemes[i].szSchemeName) == 0)
			{
				nScheme = i;
				break;
			}
		}

		if (nScheme != -1)
		{
			m_nScheme = (ATL_URL_SCHEME) nScheme;
			m_dwSchemeNameLength = pSchemes[nScheme].dwSchemeLength;
			m_nPortNumber = (ATL_URL_PORT) pSchemes[nScheme].nUrlPort;
		}
		else
		{
			// unknown scheme
			m_nScheme = ATL_URL_SCHEME_UNKNOWN;
			m_dwSchemeNameLength = (DWORD) _tcslen(lpszSchm);
			m_nPortNumber = ATL_URL_INVALID_PORT_NUMBER;
		}

		_tcsncpy(m_szScheme, lpszSchm, m_dwSchemeNameLength);
		m_szScheme[m_dwSchemeNameLength] = '\0';

		return TRUE;
	}

	inline BOOL SetScheme(ATL_URL_SCHEME nScheme) throw()
	{
		if ((nScheme < 0) || (nScheme >= s_nSchemes))
		{
			// invalid scheme
			return FALSE;
		}

		const _schemeinfo *pSchemes = GetSchemes();

		ATLASSERT( pSchemes != NULL );

		m_nScheme = (ATL_URL_SCHEME) nScheme;
		m_dwSchemeNameLength = pSchemes[nScheme].dwSchemeLength;
		m_nPortNumber = (ATL_URL_PORT) pSchemes[nScheme].nUrlPort;
		_tcsncpy(m_szScheme, pSchemes[nScheme].szSchemeName, m_dwSchemeNameLength);

		return TRUE;
	}

	inline ATL_URL_SCHEME GetScheme() const throw()
	{
		return m_nScheme;
	}

	//Get the host name
	inline LPCTSTR GetHostName() const throw()
	{
		return m_szHostName;
	}

	//Get the host name's length
	inline DWORD GetHostNameLength() const throw()
	{
		return m_dwHostNameLength;
	}

	//Set the Host name
	inline BOOL SetHostName(LPCTSTR lpszHost) throw()
	{
		ATLASSERT(lpszHost != NULL);

		DWORD dwLen = (DWORD) _tcslen(lpszHost);
		if (dwLen > ATL_URL_MAX_HOST_NAME_LENGTH)
			return FALSE;

		_tcsncpy(m_szHostName, lpszHost, dwLen+1);
		m_dwHostNameLength = dwLen;
		
		return TRUE;
	}

	//Get the port number in terms of ATL_URL_PORT
	inline ATL_URL_PORT GetPortNumber() const throw()
	{
		return m_nPortNumber;
	}

	//Set the port number in terms of ATL_URL_PORT
	inline BOOL SetPortNumber(ATL_URL_PORT nPrt) throw()
	{
		m_nPortNumber = nPrt;
		return TRUE;
	}

	//Get the user name
	inline LPCTSTR GetUserName() const throw()
	{
		return m_szUserName;
	}

	//Get the user name's length
	inline DWORD GetUserNameLength() const throw()
	{
		return m_dwUserNameLength;
	}

	//Set the user name
	inline BOOL SetUserName(LPCTSTR lpszUser) throw()
	{
		ATLASSERT(lpszUser != NULL);
		
		DWORD dwLen = (DWORD) _tcslen(lpszUser);
		if (dwLen > ATL_URL_MAX_USER_NAME_LENGTH)
			return FALSE;

		_tcsncpy(m_szUserName, lpszUser, dwLen+1);
		m_dwUserNameLength = dwLen;

		return TRUE;
	}

	//Get the password
	inline LPCTSTR GetPassword() const throw()
	{
		return m_szPassword;
	}

	//Get the password's length
	inline DWORD GetPasswordLength() const throw()
	{
		return m_dwPasswordLength;
	}

	//Set the password
	inline BOOL SetPassword(LPCTSTR lpszPass) throw()
	{
		ATLASSERT(lpszPass != NULL);

		if (*lpszPass && !*m_szUserName)
			return FALSE;

		DWORD dwLen = (DWORD) _tcslen(lpszPass);
		if (dwLen > ATL_URL_MAX_PASSWORD_LENGTH)
			return FALSE;

		_tcsncpy(m_szPassword, lpszPass, dwLen+1);
		m_dwPasswordLength = dwLen;

		return TRUE;
	}

	//Get the url path (everything after scheme and
	//before extra info)
	inline LPCTSTR GetUrlPath() const throw()
	{
		return m_szUrlPath;
	}

	//Get the url path's length
	inline DWORD GetUrlPathLength() const throw()
	{
		return m_dwUrlPathLength;
	}

	//Set the url path
	inline BOOL SetUrlPath(LPCTSTR lpszPath) throw()
	{
		ATLASSERT(lpszPath != NULL);

		DWORD dwLen = (DWORD) _tcslen(lpszPath);
		if (dwLen > ATL_URL_MAX_PATH_LENGTH)
			return FALSE;

		_tcsncpy(m_szUrlPath, lpszPath, dwLen+1);
		m_dwUrlPathLength = dwLen;
		
		return TRUE;
	}

	//Get extra info (i.e. ?something or #something)
	inline LPCTSTR GetExtraInfo() const throw()
	{
		return m_szExtraInfo;
	}

	//Get extra info's length
	inline DWORD GetExtraInfoLength() const throw()
	{
		return m_dwExtraInfoLength;
	}

	//Set extra info
	inline BOOL SetExtraInfo(LPCTSTR lpszInfo) throw()
	{
		ATLASSERT(lpszInfo != NULL);

		DWORD dwLen = (DWORD) _tcslen(lpszInfo);
		if (dwLen > ATL_URL_MAX_PATH_LENGTH)
			return FALSE;

		_tcsncpy(m_szExtraInfo, lpszInfo, dwLen+1);
		m_dwExtraInfoLength = dwLen;
		
		return TRUE;
	}
	
	//Insert Escape characters into URL
	inline BOOL Canonicalize(DWORD dwFlags = 0) throw()
	{
		_tcslwr(m_szScheme);
		TCHAR szTmp[ATL_URL_MAX_URL_LENGTH];
		_tcscpy(szTmp, m_szUserName);
		BOOL bRet = AtlEscapeUrl(szTmp, m_szUserName, &m_dwUserNameLength, ATL_URL_MAX_USER_NAME_LENGTH, dwFlags);
		if (bRet)
		{
			_tcscpy(szTmp, m_szPassword);
			bRet = AtlEscapeUrl(szTmp, m_szPassword, &m_dwPasswordLength, ATL_URL_MAX_PASSWORD_LENGTH, dwFlags);
		}
		if (bRet)
		{
			_tcscpy(szTmp, m_szHostName);
			bRet = AtlEscapeUrl(szTmp, m_szHostName, &m_dwHostNameLength, ATL_URL_MAX_HOST_NAME_LENGTH, dwFlags);
		}
		if (bRet)
		{
			_tcscpy(szTmp, m_szUrlPath);
			bRet = AtlEscapeUrl(szTmp, m_szUrlPath, &m_dwUrlPathLength, ATL_URL_MAX_PATH_LENGTH, dwFlags);
		}

		//in ATL_URL_BROWSER mode, the portion of the URL following the '?' or '#' is not encoded
		if (bRet && (dwFlags & ATL_URL_BROWSER_MODE) == 0)
		{
			_tcscpy(szTmp, m_szExtraInfo);
			bRet = AtlEscapeUrl(szTmp+1, m_szExtraInfo+1, &m_dwExtraInfoLength, ATL_URL_MAX_PATH_LENGTH-1, dwFlags);
			if (bRet)
				m_dwExtraInfoLength++;
		}

		return bRet;
	}

private:

	const static DWORD s_nSchemes = 8;

	struct _schemeinfo
	{
		LPCTSTR szSchemeName;
		DWORD dwSchemeLength;
		ATL_URL_PORT nUrlPort;
	};

	const _schemeinfo * GetSchemes() throw()
	{
		const static _schemeinfo s_schemes[] =
		{
			{ _T("ftp"), sizeof("ftp")-1, ATL_URL_DEFAULT_FTP_PORT },
			{ _T("gopher"), sizeof("gopher")-1, ATL_URL_DEFAULT_GOPHER_PORT },
			{ _T("http"), sizeof("http")-1, ATL_URL_DEFAULT_HTTP_PORT },
			{ _T("https"), sizeof("https")-1, ATL_URL_DEFAULT_HTTPS_PORT },
			{ _T("file"), sizeof("file")-1, ATL_URL_INVALID_PORT_NUMBER },
			{ _T("news"), sizeof("news")-1, ATL_URL_INVALID_PORT_NUMBER },
			{ _T("mailto"), sizeof("mailto")-1, ATL_URL_INVALID_PORT_NUMBER },
			{ _T("socks"), sizeof("socks")-1, ATL_URL_DEFAULT_SOCKS_PORT }
		};

		return s_schemes;
	}

	inline BOOL Parse(LPCTSTR lpszUrl) throw()
	{
		ATLASSERT(lpszUrl != NULL);

		TCHAR ch;
		BOOL bGotScheme = FALSE;
		BOOL bGotUserName = FALSE;
		BOOL bGotHostName = FALSE;
		BOOL bGotPortNumber = FALSE;
		TCHAR szCurrentUrl[ATL_URL_MAX_URL_LENGTH+6];
		TCHAR* pszCurrentUrl = szCurrentUrl;

		//parse lpszUrl using szCurrentUrl to store temporary data
		
		//this loop will get the following if it exists:
		//<protocol>://user:pass@server:port
		while ((ch = *lpszUrl) != '\0')
		{
			if (ch == ':')
			{
				//3 cases:
				//(1) Just encountered a scheme
				//(2) Port number follows
				//(3) Form of username:password@

				// Check to see if we've just encountered a scheme
				*pszCurrentUrl = '\0';
				if (!bGotScheme)
				{
					if (!SetSchemeName(szCurrentUrl))
						goto error;

					//Set a flag to avoid checking for
					//schemes everytime we encounter a :
					bGotScheme = TRUE;

					if (*(lpszUrl+1) == '/')
					{
						if (*(lpszUrl+2) == '/')
						{
							//the mailto scheme cannot have a '/' following the "mailto:" portion
							if (bGotScheme && m_nScheme == ATL_URL_SCHEME_MAILTO)
								goto error;

							//Skip these characters and continue
							lpszUrl+= 2;
						}
						else 
						{
							//it is an absolute path
							//no domain name, port, username, or password is allowed in this case
							//break to loop that gets path
							lpszUrl++;
							pszCurrentUrl = szCurrentUrl;
							break;
						}
					}

					//reset pszCurrentUrl
					pszCurrentUrl = szCurrentUrl;
					lpszUrl++;

					//if the scheme is file, skip to getting the path information
					if (m_nScheme == ATL_URL_SCHEME_FILE)
						break;
					continue;
				}
				else if (!bGotUserName || !bGotPortNumber)
				{
					//It must be a username:password or a port number
					*pszCurrentUrl = '\0';

					pszCurrentUrl = szCurrentUrl;
					TCHAR tmpBuf[ATL_URL_MAX_PASSWORD_LENGTH];
					TCHAR* pTmpBuf = tmpBuf;
					int nCnt = 0;

					//get the user or portnumber (break on either '/', '@', or '\0'
					while (((ch = *(++lpszUrl)) != '/') && (ch != '@') && (ch != '\0'))
					{
						if (nCnt >= ATL_URL_MAX_PASSWORD_LENGTH)
							goto error;
 
						*pTmpBuf++ = ch;
						nCnt++;
					}
					*pTmpBuf = '\0';

					//if we broke on a '/' or a '\0', it must be a port number
					if (!bGotPortNumber && (ch == '/' || ch == '\0'))
					{
						//the host name must immediately preced the port number
						if (!SetHostName(szCurrentUrl))
							goto error;

						//get the port number
						m_nPortNumber = (ATL_URL_PORT) _ttoi(tmpBuf);
						if (m_nPortNumber < 0)
							goto error;

						bGotPortNumber = bGotHostName = TRUE;
					}
					else if (!bGotUserName && ch=='@')
					{
						//otherwise it must be a username:password
						if (!SetUserName(szCurrentUrl) || !SetPassword(tmpBuf))
							goto error;

						bGotUserName = TRUE;
						lpszUrl++;
					}
					else
					{
						goto error;
					}
				}
			}
			else if (ch == '@')
			{
				if (bGotUserName)
					goto error;
				
				//type is userinfo@
				*pszCurrentUrl = '\0';
				if (!SetUserName(szCurrentUrl))
					goto error;

				bGotUserName = TRUE;
				lpszUrl++;
				pszCurrentUrl = szCurrentUrl;
			}
			else if (ch == '/' || ch == '?' || (!*(lpszUrl+1)))
			{
				//we're at the end of this loop
				//set the domain name and break
				if (!*(lpszUrl+1) && ch != '/' && ch != '?')
				{
					*pszCurrentUrl++ = ch;
					lpszUrl++;
				}
				*pszCurrentUrl = '\0';
				if (!bGotHostName)
				{
					if (!SetHostName(szCurrentUrl))
						goto error;
				}
				pszCurrentUrl = szCurrentUrl;
				break;
			}
			else
			{
				*pszCurrentUrl++ = ch;
				lpszUrl++;
			}
		}

		if (!bGotScheme)
			goto error;

		//Now build the path
		while ((ch = *lpszUrl) != '\0')
		{
			//break on a '#' or a '?', which delimit "extra information"
			if (m_nScheme != ATL_URL_SCHEME_FILE && (ch == '#' || ch == '?'))
			{
				break;
			}
			*pszCurrentUrl++ = ch;
			lpszUrl++;
		}
		*pszCurrentUrl = '\0';
		
		if (*szCurrentUrl != '\0' && !SetUrlPath(szCurrentUrl))
			goto error;

		pszCurrentUrl = szCurrentUrl;

		while ((ch = *lpszUrl++) != '\0')
		{
			*pszCurrentUrl++ = ch;
		}

		*pszCurrentUrl = '\0';
		if (*szCurrentUrl != '\0' && !SetExtraInfo(szCurrentUrl))
			goto error;

		switch(m_nScheme)
		{
			case ATL_URL_SCHEME_FILE:
				m_nPortNumber = ATL_URL_INVALID_PORT_NUMBER;
				break;
			case ATL_URL_SCHEME_NEWS:
				m_nPortNumber = ATL_URL_INVALID_PORT_NUMBER;
				break;
			case ATL_URL_SCHEME_MAILTO:
				m_nPortNumber = ATL_URL_INVALID_PORT_NUMBER;
				break;
			default:
				if (!bGotPortNumber)
					m_nPortNumber = (unsigned short)AtlGetDefaultUrlPort(m_nScheme);
		}

		return TRUE;

error:
		InitFields();
		return FALSE;

	}

	ATL_NOINLINE void InitFields() throw()
	{
		m_nPortNumber = ATL_URL_INVALID_PORT_NUMBER;
		m_nScheme = ATL_URL_SCHEME_UNKNOWN;

		m_dwSchemeNameLength = 0;
		m_dwHostNameLength   = 0;
		m_dwUserNameLength   = 0;
		m_dwUrlPathLength    = 0;
		m_dwPasswordLength   = 0;
		m_dwExtraInfoLength  = 0;

		m_szScheme[0]        = '\0';
		m_szHostName[0]      = '\0';
		m_szUserName[0]      = '\0';
		m_szPassword[0]      = '\0';
		m_szUrlPath[0]       = '\0';
		m_szExtraInfo[0]     = '\0';
	}

	//copy all fields from urlThat
	inline void CopyFields(const CUrl& urlThat) throw()
	{
		_tcsncpy(m_szScheme, urlThat.m_szScheme, urlThat.m_dwSchemeNameLength+1);
		_tcsncpy(m_szHostName, urlThat.m_szHostName, urlThat.m_dwHostNameLength+1);
		_tcsncpy(m_szUserName, urlThat.m_szUserName, urlThat.m_dwUserNameLength+1);
		_tcsncpy(m_szPassword, urlThat.m_szPassword, urlThat.m_dwPasswordLength+1);
		_tcsncpy(m_szUrlPath, urlThat.m_szUrlPath, urlThat.m_dwUrlPathLength+1);
		_tcsncpy(m_szExtraInfo, urlThat.m_szExtraInfo, urlThat.m_dwExtraInfoLength+1);

		m_nPortNumber        = urlThat.m_nPortNumber;
		m_nScheme            = urlThat.m_nScheme;
		m_dwSchemeNameLength = urlThat.m_dwSchemeNameLength;
		m_dwHostNameLength   = urlThat.m_dwHostNameLength;
		m_dwUserNameLength   = urlThat.m_dwUserNameLength;
		m_dwPasswordLength   = urlThat.m_dwPasswordLength;
		m_dwUrlPathLength    = urlThat.m_dwUrlPathLength;
		m_dwExtraInfoLength  = urlThat.m_dwExtraInfoLength;
	}

}; // class CUrl

typedef CUrl* LPURL;
typedef const CUrl * LPCURL;


#ifndef ATL_WORKER_THREAD_WAIT
#define ATL_WORKER_THREAD_WAIT 10000	// time to wait when shutting down
#endif

//
// CWorkerThread
// This class creates a worker thread that waits on kernel
// object handles and executes a specified client
// function when the handle is signaled
// To use it, construct an instance, call Initialize
// then call add AddHandle with the handle of a kernel
// object and pass a pointer to your implementation
// of IWorkerThreadClient.  Execute on your IWorkerThreadClient
// implementation will be called when the handle is signaled
// You can also use AddTimer() to add a waitable timer
// to the worker thread.
// If the thread is still active when your object is destroyed
// you must call RemoveHandle() on each handle that your object
// owns.
// To terminate the thread, call Shutdown
//
template <class ThreadTraits=DefaultThreadTraits>
class CWorkerThread
{
protected:
	HANDLE m_hThread;
	DWORD m_dwThreadId;
	CWorkerThread<ThreadTraits> *m_pThread;
	struct WorkerClientEntry
	{
		IWorkerThreadClient *pClient;
		DWORD_PTR dwParam;
	};

	CSimpleArray<HANDLE> m_hWaitHandles;
	CSimpleArray<WorkerClientEntry, CSimpleArrayEqualHelperFalse<WorkerClientEntry> > m_ClientEntries;
	CComCriticalSection m_critSec;
	HANDLE m_hRefreshComplete;

	void Refresh() throw()
	{
		ATLASSERT(m_hRefreshComplete);
		BOOL bRet = SetEvent(m_hWaitHandles[1]);
		ATLASSERT(bRet);
		bRet; // unused
		WaitForSingleObject(m_hRefreshComplete, INFINITE);
	}

public:
	CWorkerThread() throw() :
	  m_hThread(NULL),
	  m_dwThreadId(0),
	  m_hRefreshComplete(NULL),
	  m_pThread(NULL)
	{

	}

	~CWorkerThread() throw()
	{
		Shutdown();
	}

	DWORD GetThreadId() throw()
	{
		if (m_pThread)
			return m_pThread->GetThreadId();

		return m_dwThreadId;
	}

	HANDLE GetThreadHandle() throw()
	{
		if (m_pThread)
			return m_pThread->GetThreadHandle();

		return m_hThread;
	}

	HRESULT Initialize() throw()
	{
		if (m_pThread)
			return E_UNEXPECTED; // already initialized!

		// the object should be initialized first
		ATLASSERT(m_hWaitHandles.GetSize() == 0);

		m_critSec.Init();

		// create the refresh complete event
		m_hRefreshComplete = CreateEvent(NULL, FALSE, FALSE, NULL);
		if (!m_hRefreshComplete)
		{
			m_critSec.Term();
			return AtlHresultFromLastError();
		}

		// add the shutdown event
		HRESULT hr;

		HANDLE hEventShutdown = CreateEvent(NULL, FALSE, FALSE, NULL);
		if (!hEventShutdown)
		{
			hr = AtlHresultFromLastError();
			Shutdown();
			return hr;
		}

		hr = AddHandle(hEventShutdown, NULL, 0);
		if (FAILED(hr))
		{
			CloseHandle(hEventShutdown);
			Shutdown();
			return hr;
		}

		// create the refresh event
		HANDLE hEventRefresh = CreateEvent(NULL, FALSE, FALSE, NULL);
		if (!hEventRefresh)
		{
			hr = AtlHresultFromLastError();
			Shutdown();
			return hr;
		}

		hr = AddHandle(hEventRefresh, NULL, 0);
		if (FAILED(hr))
		{
			CloseHandle(hEventRefresh);
			Shutdown();
			return hr;
		}

		m_hThread = ThreadTraits::CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) _WorkerThreadProc, 
			this, 0, &m_dwThreadId);
		if (!m_hThread)
		{
			hr = AtlHresultFromLastError();
			Shutdown();
			return hr;
		}

		WaitForSingleObject(m_hRefreshComplete, INFINITE);

		return S_OK;
	}

	HRESULT Initialize(CWorkerThread<ThreadTraits> *pThread)
	{
		if (!pThread)
			return E_INVALIDARG;

		if (m_hThread)
			return E_UNEXPECTED; // already initialized

		if (!m_pThread)
		{
			m_pThread = pThread;
		}
		return S_OK;
	}

	HRESULT AddHandle(HANDLE hObject, IWorkerThreadClient *pClient, DWORD_PTR dwParam) throw()
	{
		if (m_pThread)
			return m_pThread->AddHandle(hObject, pClient, dwParam);
		// Make sure the object has been initialized
		ATLASSERT(m_hRefreshComplete != NULL);

		CComCritSecLock<CComCriticalSection> lock(m_critSec, false);
		HRESULT hr = lock.Lock();
		if (FAILED(hr))
			return hr;

		if (m_hWaitHandles.GetSize() == MAXIMUM_WAIT_OBJECTS)
		{
			return AtlHresultFromWin32(ERROR_INVALID_PARAMETER);
		}
		BOOL bRet = m_hWaitHandles.Add(hObject);
		if (!bRet)
		{
			return E_OUTOFMEMORY;
		}

		WorkerClientEntry entry;
		entry.pClient = pClient;
		entry.dwParam = dwParam;
		bRet = m_ClientEntries.Add(entry);
		if (!bRet)
		{
			m_hWaitHandles.RemoveAt(m_hWaitHandles.GetSize()-1);
			return E_OUTOFMEMORY;
		}
		if (m_hWaitHandles.GetSize() > 2)
		{
			// tell the worker thread to refresh
			Refresh();
		}
		return S_OK;
	}

#if (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)
	HRESULT AddTimer(DWORD dwInterval, IWorkerThreadClient *pClient, DWORD_PTR dwParam, HANDLE *phTimer) throw()
	{
		if (m_pThread)
			return m_pThread->AddTimer(dwInterval, pClient, dwParam, phTimer);
		// Make sure the object has been initialized
		ATLASSERT(m_hRefreshComplete != NULL);

		ATLASSERT(phTimer);
		*phTimer = NULL;

		HANDLE hTimer = CreateWaitableTimer(NULL, FALSE, NULL);
		if (!hTimer)
		{
			return AtlHresultFromLastError();
		}

		HRESULT hr;
		LARGE_INTEGER liDueTime;

		liDueTime.QuadPart = -10000 * (__int64) dwInterval;

		BOOL bRet = SetWaitableTimer(hTimer, &liDueTime, dwInterval,  NULL, NULL, FALSE);
		if (!bRet)
		{
			hr = AtlHresultFromLastError();
			CloseHandle(hTimer);
			return hr;
		}

		hr = AddHandle(hTimer, pClient, dwParam);
		if (FAILED(hr))
		{
			CloseHandle(hTimer);
			return hr;
		}
		if (phTimer)
			*phTimer = hTimer;
		return S_OK;
	}
#endif

	HRESULT RemoveHandle(HANDLE hObject) throw()
	{
		if (m_pThread)
			return m_pThread->RemoveHandle(hObject);

		// Make sure the object has been initialized
		ATLASSERT(m_hRefreshComplete != NULL);

		CComCritSecLock<CComCriticalSection> lock(m_critSec, false);
		HRESULT hr = lock.Lock();
		if (FAILED(hr))
			return hr;

		int nIndex = m_hWaitHandles.Find(hObject);
		if (nIndex >= 0)
		{
			ATLASSERT(nIndex < m_ClientEntries.GetSize());

			IWorkerThreadClient *pClient = m_ClientEntries[nIndex].pClient;

			m_hWaitHandles.RemoveAt(nIndex);
			m_ClientEntries.RemoveAt(nIndex);

			Refresh();
			
			// now it is safe to close the handle
			if (!pClient || FAILED(pClient->CloseHandle(hObject)))
				CloseHandle(hObject);
		}
		return S_OK;
	}


	HRESULT Shutdown(DWORD dwWait=ATL_WORKER_THREAD_WAIT) throw()
	{
		if (m_pThread)
			return S_OK;

		if (!m_hThread)
		{
			RemoveAllClients();
			m_critSec.Term();
			if (m_hRefreshComplete)
			{
				CloseHandle(m_hRefreshComplete);
				m_hRefreshComplete = NULL;
			}
			return S_OK;
		}

		ATLASSERT(m_hWaitHandles.GetSize() > 0);

		SetEvent(m_hWaitHandles[0]);

		DWORD dwRet = WaitForSingleObject(m_hThread, dwWait);

		RemoveAllClients();

		CloseHandle(m_hThread);
		m_hThread = NULL;
		if (m_hRefreshComplete)
		{
			CloseHandle(m_hRefreshComplete);
			m_hRefreshComplete = NULL;
		}
		m_critSec.Term();
		return (dwRet == WAIT_OBJECT_0) ? S_OK : AtlHresultFromWin32(dwRet);
	}

protected:
	void RemoveAllClients() throw()
	{
		ATLASSERT(m_hWaitHandles.GetSize() == m_ClientEntries.GetSize());

		int nLen = m_hWaitHandles.GetSize();
		for (int i = 0; i < nLen; i++)
		{
			WorkerClientEntry& entry = m_ClientEntries[i];
			if (!entry.pClient || FAILED(entry.pClient->CloseHandle(m_hWaitHandles[i])))
				CloseHandle(m_hWaitHandles[i]);
		}
		m_hWaitHandles.RemoveAll();

		m_ClientEntries.RemoveAll();
	}

	DWORD WorkerThreadProc() throw()
	{
		// Make sure the object has been initialized
		ATLASSERT(m_hRefreshComplete != NULL);

		CSimpleArray<HANDLE> handles(m_hWaitHandles);
		CSimpleArray<WorkerClientEntry, CSimpleArrayEqualHelperFalse<WorkerClientEntry> > clientEntries(m_ClientEntries);

		// tell the main thread we're done copying
		SetEvent(m_hRefreshComplete);

		while (TRUE)
		{
			DWORD dwRet = WaitForMultipleObjects(handles.GetSize(), handles.GetData(),
					FALSE, INFINITE);
			// check for shutdown
			if (dwRet == WAIT_OBJECT_0)
				return 0;
			else if (dwRet == WAIT_OBJECT_0+1)	// check for refresh
			{
				handles = m_hWaitHandles;
				clientEntries = m_ClientEntries;

				// tell the main thread we're done copying
				SetEvent(m_hRefreshComplete);
				continue;
			}
			else if (dwRet > WAIT_OBJECT_0 && dwRet < WAIT_OBJECT_0 + handles.GetSize())
			{
				// execute the approriate client
				WorkerClientEntry& entry = clientEntries[dwRet - WAIT_OBJECT_0];

				// We ignore the error code because nothing useful can be done with it in this
				// implementation
				entry.pClient->Execute(entry.dwParam, handles[dwRet - WAIT_OBJECT_0]);
			}
			else
			{
				// this probably means an invalid handle was added
				ATLASSERT(FALSE);
				return 1;
			}
		}
		return 0;		
	}

	static DWORD WINAPI _WorkerThreadProc(CWorkerThread *pThis) throw()
	{
		return pThis->WorkerThreadProc();
	}
}; // class CWorkerThread

// Use CNoWorkerThread as a template argument for classes
// that need a worker thread type as a template argument but
// don't require the services of a worker thread. An example
// would be CDllCache (atlutil.h) when you want to create a
// CDllCache with no sweeper thread.
class CNoWorkerThread
{
public:
	DWORD GetThreadId() throw()
	{
		return 0;
	}

	HANDLE GetThreadHandle() throw()
	{
		return NULL;
	}

	HRESULT Initialize() throw()
	{
		return S_OK;
	}

	HRESULT AddHandle(HANDLE /*hObject*/, IWorkerThreadClient * /*pClient*/, DWORD_PTR /*dwParam*/) throw()
	{
		return S_OK;
	}


	HRESULT AddTimer(DWORD /*dwInterval*/, IWorkerThreadClient * /*pClient*/, DWORD_PTR /*dwParam*/, HANDLE * /*phTimer*/) throw()
	{
		return S_OK;
	}

	HRESULT RemoveHandle(HANDLE /*hObject*/) throw()
	{
		return S_OK;
	}

	HRESULT Shutdown(DWORD dwWait=ATL_WORKER_THREAD_WAIT) throw()
	{
		dwWait;
		return S_OK;
	}
}; // CNoWorkerThread

class CBrowserCaps : public IBrowserCaps, public CComObjectRootEx<CComSingleThreadModel>
{
public:

    BEGIN_COM_MAP(CBrowserCaps)
        COM_INTERFACE_ENTRY(IBrowserCaps)
    END_COM_MAP()

    CBrowserCaps()
    {
    }

    void FinalRelease()
    {
        if (m_pParent)
            m_pParent->Release();
    }

    HRESULT Initialize(IXMLDOMNode * pNode, IBrowserCapsSvc * pSvc)
    {
        if (!pNode)
            return E_POINTER;

		HRESULT hr = pNode->QueryInterface(__uuidof(IXMLDOMElement), (void **)&m_spElement);
        if (FAILED(hr))
            return hr;

        CComPtr<IXMLDOMNamedNodeMap> spList;
        hr = pNode->get_attributes(&spList);
        if (FAILED(hr))
            return hr;

        CComPtr<IXMLDOMNode> spItem;
        hr = spList->getNamedItem((BSTR)L"parent", &spItem);
        if (FAILED(hr))
            return hr;

        if (hr == S_FALSE)
            m_pParent = NULL;
        else
        {
            if (!spItem)
                return E_FAIL;

            CComVariant varVal;
            hr = spItem->get_nodeValue(&varVal);
            if (FAILED(hr))
                return hr;

            varVal.ChangeType(VT_BSTR);
            hr = pSvc->GetCapsUserAgent(varVal.bstrVal, (IBrowserCaps **)&m_pParent);
            if (FAILED(hr))
                return hr;
        }

        return S_OK;
    }

    HRESULT GetPropertyString(BSTR bstrProperty, BSTR * pbstrOut)
    {
        ATLASSERT(m_spElement);
        if (!m_spElement)
            return E_FAIL;

        if (!pbstrOut)
            return E_POINTER;

        *pbstrOut = NULL;

        CComPtr<IXMLDOMNodeList> spList;
        HRESULT hr = m_spElement->getElementsByTagName(bstrProperty, &spList);
        if (FAILED(hr))
            return hr;

        long nLength;
        hr = spList->get_length(&nLength);
        if (FAILED(hr))
            return hr;

        if (nLength == 0)
        {
            if (m_pParent)
                return m_pParent->GetPropertyString(bstrProperty, pbstrOut);
            else
                return E_FAIL;
        }

        // Assume the first one is the correct node
        CComPtr<IXMLDOMNode> spNode;
        hr = spList->get_item(0, &spNode);
        if (FAILED(hr))
            return hr;

        CComBSTR bstrValue;

        hr = spNode->get_text(&bstrValue);
        if (FAILED(hr))
            return hr;

        *pbstrOut = bstrValue.Detach();
        
        return hr;
    }

    HRESULT GetBooleanPropertyValue(BSTR bstrProperty, BOOL* pbOut)
    {
		if (!pbOut)
			return E_POINTER;

        CComBSTR bstrOut;
        HRESULT hr = GetPropertyString(bstrProperty, &bstrOut);
		if (FAILED(hr))
			return hr;

        if (bstrOut[0] == L'1' && bstrOut.Length() == 1)
            *pbOut = TRUE;
		else
			*pbOut = FALSE;

		return S_OK;
    }

    HRESULT GetBrowserName(BSTR * pbstrName)
    {
        return GetPropertyString(L"name", pbstrName);
    }

    HRESULT GetPlatform(BSTR * pbstrPlatform)
    {
        return GetPropertyString(L"platform", pbstrPlatform);
    }

    HRESULT GetVersion(BSTR * pbstrVersion)
    {
        return GetPropertyString(L"version", pbstrVersion);
    }

    HRESULT GetMajorVer(BSTR * pbstrMajorVer)
    {
        return GetPropertyString(L"majorver", pbstrMajorVer);
    }

    HRESULT GetMinorVer(BSTR * pbstrMinorVer)
    {
        return GetPropertyString(L"minorver", pbstrMinorVer);
    }

    HRESULT SupportsFrames(BOOL* pbFrames)
    {
        return GetBooleanPropertyValue(L"frames", pbFrames);
    }

    HRESULT SupportsTables(BOOL* pbTables)
    {
        return GetBooleanPropertyValue(L"tables", pbTables);
    }
    HRESULT SupportsCookies(BOOL* pbCookies)
    {
        return GetBooleanPropertyValue(L"cookies", pbCookies);
    }
    HRESULT SupportsBackgroundSounds(BOOL* pbBackgroundSounds)
    {
        return GetBooleanPropertyValue(L"backgroundsounds", pbBackgroundSounds);
    }
    HRESULT SupportsVBScript(BOOL* pbVBScript)
    {
        return GetBooleanPropertyValue(L"vbscript", pbVBScript);
    }
    HRESULT SupportsJavaScript(BOOL* pbJavaScript)
    {
        return GetBooleanPropertyValue(L"javascript", pbJavaScript);
    }
    HRESULT SupportsJavaApplets(BOOL* pbJavaApplets)
    {
        return GetBooleanPropertyValue(L"javaapplets", pbJavaApplets);
    }
    HRESULT SupportsActiveXControls(BOOL* pbActiveXControls)
    {
        return GetBooleanPropertyValue(L"ActiveXControls", pbActiveXControls);
    }
    HRESULT SupportsCDF(BOOL* pbCDF)
    {
        return GetBooleanPropertyValue(L"CDF", pbCDF);
    }
    HRESULT SupportsAuthenticodeUpdate(BOOL* pbAuthenticodeUpdate)
    {
        return GetBooleanPropertyValue(L"AuthenticodeUpdate", pbAuthenticodeUpdate);
    }
    HRESULT IsBeta(BOOL* pbIsBeta)
    {
        return GetBooleanPropertyValue(L"beta", pbIsBeta);
    }
    HRESULT IsCrawler(BOOL* pbIsCrawler)
    {
        return GetBooleanPropertyValue(L"Crawler", pbIsCrawler);
    }
    HRESULT IsAOL(BOOL* pbIsAOL)
    {
        return GetBooleanPropertyValue(L"AOL", pbIsAOL);
    }
    HRESULT IsWin16(BOOL* pbIsWin16)
    {
        return GetBooleanPropertyValue(L"Win16", pbIsWin16);
    }
    HRESULT IsAK(BOOL* pbIsAK)
    {
        return GetBooleanPropertyValue(L"AK", pbIsAK);
    }
    HRESULT IsSK(BOOL* pbIsSK)
    {
        return GetBooleanPropertyValue(L"SK", pbIsSK);
    }
    HRESULT IsUpdate(BOOL* pbIsUpdate) 
    {
        return GetBooleanPropertyValue(L"Update", pbIsUpdate);
    }

private:
    CComPtr<IXMLDOMElement> m_spElement;
    CComObjectNoLock<CBrowserCaps> * m_pParent;
};

template <class TVal>
class CWildCardEqualHelper
{
public:
    static bool IsEqualKey(LPCWSTR szPattern, LPCWSTR szInput)
    {
        while (*szPattern && *szInput && *szPattern == *szInput)
        {
            szPattern++;
            szInput++;
        }

        if (*szPattern == *szInput)
            return TRUE;

        if (*szPattern == '*')
        {
            szPattern++;
            if (!*szPattern)
                return true;
            while(*szInput)
            {
                if (IsEqualKey(szPattern, szInput))
                    return TRUE;
            
                szInput++;
            }
        }
        return FALSE;

    }

    static bool IsEqualValue(TVal& v1, const TVal& v2)
    {
        return (v1 == v2);
    }

};


class CBrowserCapsSvc : public IBrowserCapsSvc, 
                        public CComObjectRootEx<CComSingleThreadModel>
{
public:
    BEGIN_COM_MAP(CBrowserCapsSvc)
        COM_INTERFACE_ENTRY(IBrowserCapsSvc)
    END_COM_MAP()

    HRESULT GetCaps(IHttpServerContext * pContext, IBrowserCaps ** ppOut)
    {
        if (!pContext)
            return E_POINTER;

        if (!ppOut)
            return E_POINTER;

        *ppOut = NULL;

        char szUserAgent[256];
        DWORD dwSize = sizeof(szUserAgent);
		if (!pContext->GetServerVariable("HTTP_USER_AGENT", szUserAgent, &dwSize))
            return E_FAIL;

        CComBSTR bstrAgent = szUserAgent;

        return GetCapsUserAgent(bstrAgent, ppOut);
    }

    HRESULT GetCapsUserAgent(BSTR bstrAgent, IBrowserCaps ** ppOut)
    {
        if (!bstrAgent)
            return E_POINTER;

        if (!ppOut)
            return E_POINTER;

        *ppOut = NULL;

        CComPtr<IXMLDOMNode> spNode;
        spNode = m_Map.Lookup((LPCWSTR)bstrAgent);
        if (spNode != NULL)
        {
			CComObjectNoLock<CBrowserCaps> *pRet = NULL;
            ATLTRY(pRet = new CComObjectNoLock<CBrowserCaps>);
			if (!pRet)
				return E_OUTOFMEMORY;

            HRESULT hr = pRet->Initialize(spNode, this);
			if (FAILED(hr))
			{
				delete pRet;
				return hr;
			}
            pRet->AddRef();
            *ppOut = pRet;
            return S_OK;
        }
        return E_FAIL;
    }

    HRESULT Initialize(HINSTANCE hInstance)
	{
		HRESULT hr = _Initialize(hInstance);
		if (FAILED(hr))
			Clear();

		return hr;
	}

    HRESULT Uninitialize()
    {
		Clear();
        return S_OK;
    }

private:
    HRESULT _Initialize(HINSTANCE hInstance)
    {
        if (m_spDoc)  // Already initialized
            return S_OK;

		HRESULT hr;
		
        hr = m_spDoc.CoCreateInstance(__uuidof(DOMDocument), NULL, CLSCTX_INPROC);
        if (FAILED(hr))
            return hr;

        if (!m_spDoc)
            return E_FAIL;

        hr = m_spDoc->put_async(VARIANT_FALSE);
        if (FAILED(hr))
            return hr;

        char szPath[MAX_PATH];

        int nRet = GetModuleFileNameA(hInstance, szPath, MAX_PATH);
        if (!nRet)
			return AtlHresultFromLastError();

        LPSTR szMark = strrchr(szPath, '\\');

        ATLASSERT(szMark);

        if (szMark)
            *szMark = '\0';

        CComBSTR bstrFile;
        bstrFile += "file://";
        bstrFile += szPath ;
        bstrFile += "\\browscap.xml";

        CComVariant varFile(bstrFile);
        VARIANT_BOOL varBool;
        hr = m_spDoc->load(varFile, &varBool);
        if (FAILED(hr))
            return hr;

        if (!varBool)
            return E_FAIL;

        hr = m_spDoc->get_documentElement(&m_spRoot);
        if (FAILED(hr))
            return hr;

        if (!m_spRoot)
            return E_FAIL;

        CComPtr<IXMLDOMElement> spElement;
        hr = m_spRoot->QueryInterface(&spElement);
        if (FAILED(hr))
            return hr;

        if (!spElement)
            return E_FAIL;

        CComPtr<IXMLDOMNodeList> spList;
        hr = spElement->getElementsByTagName(L"browser", &spList);
        if (FAILED(hr))
            return hr;
        
        if (!spList)
            return E_FAIL;

        CComPtr<IXMLDOMNode> spCurrent;
        hr = spList->nextNode(&spCurrent);
        if (FAILED(hr))
            return hr;

        while (spCurrent)
        {
            CComPtr<IXMLDOMNamedNodeMap> spAttrs;
            CComPtr<IXMLDOMNode> spItem;

            DOMNodeType nodeType;
            hr = spCurrent->get_nodeType(&nodeType);
            if (FAILED(hr))
                return hr;

            if (nodeType == NODE_ELEMENT)
            {
                hr = spCurrent->get_attributes(&spAttrs);
                if (FAILED(hr))
                    return hr;

                hr = spAttrs->getNamedItem((BSTR)L"user-agent", &spItem);
                if (FAILED(hr))
                    return hr;

                CComVariant varVal;
                hr = spItem->get_nodeValue(&varVal);
                if (FAILED(hr))
                    return hr;

                hr = varVal.ChangeType(VT_BSTR);
                if (FAILED(hr))
                    return hr;

                CComBSTR bstrValue = varVal.bstrVal;
                m_Map.Add((LPCWSTR)bstrValue, spCurrent);
                bstrValue.Detach();
            }

            CComPtr<IXMLDOMNode> spNext;
            spList->nextNode(&spNext);
            spCurrent = spNext;
        }

        return S_OK;
    }

	void Clear()
	{
		if (!m_spDoc)
			return;

		m_Map.RemoveAll();
		m_spRoot.Release();
		m_spDoc.Release();
	}

    CSimpleMap<LPCWSTR, CComPtr<IXMLDOMNode>, CWildCardEqualHelper< CComPtr<IXMLDOMNode> > > m_Map;
    CComCriticalSection m_critSec;
    CComPtr<IXMLDOMDocument> m_spDoc;
    CComPtr<IXMLDOMElement> m_spRoot;
};

// Copies a CString into a null-terminated string.
// pdwDestLen on input is the size of the buffer in characters (including the null)
// On success, pdwDestLen contains the length of the string in characters (not including the null)
// On failure, pdwDestLen contains the length of the string including the null.
template <class StringType>
inline BOOL CopyCString(const StringType& str, StringType::PXSTR szDest, DWORD *pdwDestLen) throw()
{
	if (!pdwDestLen)
		return FALSE;

	DWORD dwLen = str.GetLength();
	if (!szDest || *pdwDestLen < (dwLen + 1))
	{
		*pdwDestLen = dwLen + 1;
		return FALSE;
	}

	StringType::PCXSTR szBuffer = str;
	if (szBuffer)
	{
		memcpy(szDest, szBuffer, (dwLen+1) * sizeof(StringType::XCHAR));
		*pdwDestLen = dwLen;
		return TRUE;
	}

	return FALSE;
}

// Call this function to convert from a SYSTEMTIME
// structure to an Http-date as defined in rfc2616
inline void SystemTimeToHttpDate(const SYSTEMTIME& st, CStringA &strTime)
{
	static LPCSTR szDays[] = { "Sun", "Mon", "Tue",
		"Wed", "Thu", "Fri", "Sat" };
	static LPCSTR szMonth[] = { "Jan", "Feb", "Mar", "Apr",
		"May", "Jun", "Jul", "Aug", "Sep", 
		"Oct", "Nov", "Dec" };

	strTime.Format("%s, %02d %s %d %02d:%02d:%02d GMT",
		szDays[st.wDayOfWeek], st.wDay, szMonth[st.wMonth-1], st.wYear,
		st.wHour, st.wMinute, st.wSecond);
}

// RGBToHtml - Converts a COLORREF to a color that can be used in HTML.
//             Eg. RGB(11,22,33) would be converted to #112233
// color:    The color to convert.
// pbOut:    The output buffer that will hold the the resulting color.
// nBuffer:	 Specifies the number of bytes in pbOut.
bool inline RGBToHtml(COLORREF color, LPTSTR pbOut, long nBuffer)
{
	// make sure the buffer is big enough
	if (nBuffer < (7 * sizeof(TCHAR)))
		return false;

	wsprintf(pbOut, _T("#%0.2x%0.2x%0.2x"),
		GetRValue(color), GetGValue(color), GetBValue(color));
	return true;
}

} // namespace ATL

#pragma warning( pop )

#endif // __ATLUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atlmfc\bmio.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0280 */
/* at Thu Jul 13 20:04:56 2000
 */
/* Compiler settings for bmio.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __bmio_h__
#define __bmio_h__

/* Forward Declarations */ 

#ifndef __IIRGBTarget_FWD_DEFINED__
#define __IIRGBTarget_FWD_DEFINED__
typedef interface IIRGBTarget IIRGBTarget;
#endif 	/* __IIRGBTarget_FWD_DEFINED__ */


#ifndef __IBitmapTarget_FWD_DEFINED__
#define __IBitmapTarget_FWD_DEFINED__
typedef interface IBitmapTarget IBitmapTarget;
#endif 	/* __IBitmapTarget_FWD_DEFINED__ */


#ifndef __IAnimatedBitmapTarget_FWD_DEFINED__
#define __IAnimatedBitmapTarget_FWD_DEFINED__
typedef interface IAnimatedBitmapTarget IAnimatedBitmapTarget;
#endif 	/* __IAnimatedBitmapTarget_FWD_DEFINED__ */


#ifndef __IBitmapSource_FWD_DEFINED__
#define __IBitmapSource_FWD_DEFINED__
typedef interface IBitmapSource IBitmapSource;
#endif 	/* __IBitmapSource_FWD_DEFINED__ */


#ifndef __IBitmapFormatConverter_FWD_DEFINED__
#define __IBitmapFormatConverter_FWD_DEFINED__
typedef interface IBitmapFormatConverter IBitmapFormatConverter;
#endif 	/* __IBitmapFormatConverter_FWD_DEFINED__ */


#ifndef __IColorSpaceConverter_FWD_DEFINED__
#define __IColorSpaceConverter_FWD_DEFINED__
typedef interface IColorSpaceConverter IColorSpaceConverter;
#endif 	/* __IColorSpaceConverter_FWD_DEFINED__ */


#ifndef __IBitmapImport_FWD_DEFINED__
#define __IBitmapImport_FWD_DEFINED__
typedef interface IBitmapImport IBitmapImport;
#endif 	/* __IBitmapImport_FWD_DEFINED__ */


#ifndef __IBitmapExport_FWD_DEFINED__
#define __IBitmapExport_FWD_DEFINED__
typedef interface IBitmapExport IBitmapExport;
#endif 	/* __IBitmapExport_FWD_DEFINED__ */


#ifndef __IPNGExport_FWD_DEFINED__
#define __IPNGExport_FWD_DEFINED__
typedef interface IPNGExport IPNGExport;
#endif 	/* __IPNGExport_FWD_DEFINED__ */


#ifndef __IJPEGExport_FWD_DEFINED__
#define __IJPEGExport_FWD_DEFINED__
typedef interface IJPEGExport IJPEGExport;
#endif 	/* __IJPEGExport_FWD_DEFINED__ */


#ifndef __IGIFExport_FWD_DEFINED__
#define __IGIFExport_FWD_DEFINED__
typedef interface IGIFExport IGIFExport;
#endif 	/* __IGIFExport_FWD_DEFINED__ */


#ifndef __IBMPExport_FWD_DEFINED__
#define __IBMPExport_FWD_DEFINED__
typedef interface IBMPExport IBMPExport;
#endif 	/* __IBMPExport_FWD_DEFINED__ */


#ifndef __IEnumBMExporterInfo_FWD_DEFINED__
#define __IEnumBMExporterInfo_FWD_DEFINED__
typedef interface IEnumBMExporterInfo IEnumBMExporterInfo;
#endif 	/* __IEnumBMExporterInfo_FWD_DEFINED__ */


#ifndef __IEnumBMImporterInfo_FWD_DEFINED__
#define __IEnumBMImporterInfo_FWD_DEFINED__
typedef interface IEnumBMImporterInfo IEnumBMImporterInfo;
#endif 	/* __IEnumBMImporterInfo_FWD_DEFINED__ */


#ifndef __IBMFileTypeInfo_FWD_DEFINED__
#define __IBMFileTypeInfo_FWD_DEFINED__
typedef interface IBMFileTypeInfo IBMFileTypeInfo;
#endif 	/* __IBMFileTypeInfo_FWD_DEFINED__ */


#ifndef __IEnumBMFileTypeInfo_FWD_DEFINED__
#define __IEnumBMFileTypeInfo_FWD_DEFINED__
typedef interface IEnumBMFileTypeInfo IEnumBMFileTypeInfo;
#endif 	/* __IEnumBMFileTypeInfo_FWD_DEFINED__ */


#ifndef __IBMExporterInfo_FWD_DEFINED__
#define __IBMExporterInfo_FWD_DEFINED__
typedef interface IBMExporterInfo IBMExporterInfo;
#endif 	/* __IBMExporterInfo_FWD_DEFINED__ */


#ifndef __IBMImporterInfo_FWD_DEFINED__
#define __IBMImporterInfo_FWD_DEFINED__
typedef interface IBMImporterInfo IBMImporterInfo;
#endif 	/* __IBMImporterInfo_FWD_DEFINED__ */


#ifndef __IDitherer_FWD_DEFINED__
#define __IDitherer_FWD_DEFINED__
typedef interface IDitherer IDitherer;
#endif 	/* __IDitherer_FWD_DEFINED__ */


#ifndef __IColorQuantizer_FWD_DEFINED__
#define __IColorQuantizer_FWD_DEFINED__
typedef interface IColorQuantizer IColorQuantizer;
#endif 	/* __IColorQuantizer_FWD_DEFINED__ */


#ifndef __IAlphaAdd_FWD_DEFINED__
#define __IAlphaAdd_FWD_DEFINED__
typedef interface IAlphaAdd IAlphaAdd;
#endif 	/* __IAlphaAdd_FWD_DEFINED__ */


#ifndef __IAlphaRemove_FWD_DEFINED__
#define __IAlphaRemove_FWD_DEFINED__
typedef interface IAlphaRemove IAlphaRemove;
#endif 	/* __IAlphaRemove_FWD_DEFINED__ */


#ifndef __IBitmapNotify_FWD_DEFINED__
#define __IBitmapNotify_FWD_DEFINED__
typedef interface IBitmapNotify IBitmapNotify;
#endif 	/* __IBitmapNotify_FWD_DEFINED__ */


#ifndef __IStdBitmapNotify_FWD_DEFINED__
#define __IStdBitmapNotify_FWD_DEFINED__
typedef interface IStdBitmapNotify IStdBitmapNotify;
#endif 	/* __IStdBitmapNotify_FWD_DEFINED__ */


#ifndef __IBMGraphManager_FWD_DEFINED__
#define __IBMGraphManager_FWD_DEFINED__
typedef interface IBMGraphManager IBMGraphManager;
#endif 	/* __IBMGraphManager_FWD_DEFINED__ */


#ifndef __IDIBTarget_FWD_DEFINED__
#define __IDIBTarget_FWD_DEFINED__
typedef interface IDIBTarget IDIBTarget;
#endif 	/* __IDIBTarget_FWD_DEFINED__ */


#ifndef __IDDSurfaceTarget_FWD_DEFINED__
#define __IDDSurfaceTarget_FWD_DEFINED__
typedef interface IDDSurfaceTarget IDDSurfaceTarget;
#endif 	/* __IDDSurfaceTarget_FWD_DEFINED__ */


#ifndef __IDIBSource_FWD_DEFINED__
#define __IDIBSource_FWD_DEFINED__
typedef interface IDIBSource IDIBSource;
#endif 	/* __IDIBSource_FWD_DEFINED__ */


#ifndef __IBMPImport_FWD_DEFINED__
#define __IBMPImport_FWD_DEFINED__
typedef interface IBMPImport IBMPImport;
#endif 	/* __IBMPImport_FWD_DEFINED__ */


#ifndef __IBMExporterInfo_FWD_DEFINED__
#define __IBMExporterInfo_FWD_DEFINED__
typedef interface IBMExporterInfo IBMExporterInfo;
#endif 	/* __IBMExporterInfo_FWD_DEFINED__ */


#ifndef __IBMImporterInfo_FWD_DEFINED__
#define __IBMImporterInfo_FWD_DEFINED__
typedef interface IBMImporterInfo IBMImporterInfo;
#endif 	/* __IBMImporterInfo_FWD_DEFINED__ */


#ifndef __IBitmapImport_FWD_DEFINED__
#define __IBitmapImport_FWD_DEFINED__
typedef interface IBitmapImport IBitmapImport;
#endif 	/* __IBitmapImport_FWD_DEFINED__ */


#ifndef __IBitmapExport_FWD_DEFINED__
#define __IBitmapExport_FWD_DEFINED__
typedef interface IBitmapExport IBitmapExport;
#endif 	/* __IBitmapExport_FWD_DEFINED__ */


#ifndef __IPNGExport_FWD_DEFINED__
#define __IPNGExport_FWD_DEFINED__
typedef interface IPNGExport IPNGExport;
#endif 	/* __IPNGExport_FWD_DEFINED__ */


#ifndef __IJPEGExport_FWD_DEFINED__
#define __IJPEGExport_FWD_DEFINED__
typedef interface IJPEGExport IJPEGExport;
#endif 	/* __IJPEGExport_FWD_DEFINED__ */


#ifndef __PNGPage_FWD_DEFINED__
#define __PNGPage_FWD_DEFINED__

#ifdef __cplusplus
typedef class PNGPage PNGPage;
#else
typedef struct PNGPage PNGPage;
#endif /* __cplusplus */

#endif 	/* __PNGPage_FWD_DEFINED__ */


#ifndef __PNGExport_FWD_DEFINED__
#define __PNGExport_FWD_DEFINED__

#ifdef __cplusplus
typedef class PNGExport PNGExport;
#else
typedef struct PNGExport PNGExport;
#endif /* __cplusplus */

#endif 	/* __PNGExport_FWD_DEFINED__ */


#ifndef __JPEGPage_FWD_DEFINED__
#define __JPEGPage_FWD_DEFINED__

#ifdef __cplusplus
typedef class JPEGPage JPEGPage;
#else
typedef struct JPEGPage JPEGPage;
#endif /* __cplusplus */

#endif 	/* __JPEGPage_FWD_DEFINED__ */


#ifndef __JPEGExport_FWD_DEFINED__
#define __JPEGExport_FWD_DEFINED__

#ifdef __cplusplus
typedef class JPEGExport JPEGExport;
#else
typedef struct JPEGExport JPEGExport;
#endif /* __cplusplus */

#endif 	/* __JPEGExport_FWD_DEFINED__ */


#ifndef __GIFImport_FWD_DEFINED__
#define __GIFImport_FWD_DEFINED__

#ifdef __cplusplus
typedef class GIFImport GIFImport;
#else
typedef struct GIFImport GIFImport;
#endif /* __cplusplus */

#endif 	/* __GIFImport_FWD_DEFINED__ */


#ifndef __GIFExport_FWD_DEFINED__
#define __GIFExport_FWD_DEFINED__

#ifdef __cplusplus
typedef class GIFExport GIFExport;
#else
typedef struct GIFExport GIFExport;
#endif /* __cplusplus */

#endif 	/* __GIFExport_FWD_DEFINED__ */


#ifndef __BMPExport_FWD_DEFINED__
#define __BMPExport_FWD_DEFINED__

#ifdef __cplusplus
typedef class BMPExport BMPExport;
#else
typedef struct BMPExport BMPExport;
#endif /* __cplusplus */

#endif 	/* __BMPExport_FWD_DEFINED__ */


#ifndef __Ditherer_FWD_DEFINED__
#define __Ditherer_FWD_DEFINED__

#ifdef __cplusplus
typedef class Ditherer Ditherer;
#else
typedef struct Ditherer Ditherer;
#endif /* __cplusplus */

#endif 	/* __Ditherer_FWD_DEFINED__ */


#ifndef __JPEGImport_FWD_DEFINED__
#define __JPEGImport_FWD_DEFINED__

#ifdef __cplusplus
typedef class JPEGImport JPEGImport;
#else
typedef struct JPEGImport JPEGImport;
#endif /* __cplusplus */

#endif 	/* __JPEGImport_FWD_DEFINED__ */


#ifndef __PNGImport_FWD_DEFINED__
#define __PNGImport_FWD_DEFINED__

#ifdef __cplusplus
typedef class PNGImport PNGImport;
#else
typedef struct PNGImport PNGImport;
#endif /* __cplusplus */

#endif 	/* __PNGImport_FWD_DEFINED__ */


#ifndef __BMGraphManager_FWD_DEFINED__
#define __BMGraphManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class BMGraphManager BMGraphManager;
#else
typedef struct BMGraphManager BMGraphManager;
#endif /* __cplusplus */

#endif 	/* __BMGraphManager_FWD_DEFINED__ */


#ifndef __GSToRGB_FWD_DEFINED__
#define __GSToRGB_FWD_DEFINED__

#ifdef __cplusplus
typedef class GSToRGB GSToRGB;
#else
typedef struct GSToRGB GSToRGB;
#endif /* __cplusplus */

#endif 	/* __GSToRGB_FWD_DEFINED__ */


#ifndef __GSConverter_FWD_DEFINED__
#define __GSConverter_FWD_DEFINED__

#ifdef __cplusplus
typedef class GSConverter GSConverter;
#else
typedef struct GSConverter GSConverter;
#endif /* __cplusplus */

#endif 	/* __GSConverter_FWD_DEFINED__ */


#ifndef __RGBConverter_FWD_DEFINED__
#define __RGBConverter_FWD_DEFINED__

#ifdef __cplusplus
typedef class RGBConverter RGBConverter;
#else
typedef struct RGBConverter RGBConverter;
#endif /* __cplusplus */

#endif 	/* __RGBConverter_FWD_DEFINED__ */


#ifndef __DIBTarget_FWD_DEFINED__
#define __DIBTarget_FWD_DEFINED__

#ifdef __cplusplus
typedef class DIBTarget DIBTarget;
#else
typedef struct DIBTarget DIBTarget;
#endif /* __cplusplus */

#endif 	/* __DIBTarget_FWD_DEFINED__ */


#ifndef __DDSurfaceTarget_FWD_DEFINED__
#define __DDSurfaceTarget_FWD_DEFINED__

#ifdef __cplusplus
typedef class DDSurfaceTarget DDSurfaceTarget;
#else
typedef struct DDSurfaceTarget DDSurfaceTarget;
#endif /* __cplusplus */

#endif 	/* __DDSurfaceTarget_FWD_DEFINED__ */


#ifndef __IRGBToRGB_FWD_DEFINED__
#define __IRGBToRGB_FWD_DEFINED__

#ifdef __cplusplus
typedef class IRGBToRGB IRGBToRGB;
#else
typedef struct IRGBToRGB IRGBToRGB;
#endif /* __cplusplus */

#endif 	/* __IRGBToRGB_FWD_DEFINED__ */


#ifndef __RGBToGS_FWD_DEFINED__
#define __RGBToGS_FWD_DEFINED__

#ifdef __cplusplus
typedef class RGBToGS RGBToGS;
#else
typedef struct RGBToGS RGBToGS;
#endif /* __cplusplus */

#endif 	/* __RGBToGS_FWD_DEFINED__ */


#ifndef __RGBAToRGB_FWD_DEFINED__
#define __RGBAToRGB_FWD_DEFINED__

#ifdef __cplusplus
typedef class RGBAToRGB RGBAToRGB;
#else
typedef struct RGBAToRGB RGBAToRGB;
#endif /* __cplusplus */

#endif 	/* __RGBAToRGB_FWD_DEFINED__ */


#ifndef __RGBToRGBA_FWD_DEFINED__
#define __RGBToRGBA_FWD_DEFINED__

#ifdef __cplusplus
typedef class RGBToRGBA RGBToRGBA;
#else
typedef struct RGBToRGBA RGBToRGBA;
#endif /* __cplusplus */

#endif 	/* __RGBToRGBA_FWD_DEFINED__ */


#ifndef __DXT1ToRGBA_FWD_DEFINED__
#define __DXT1ToRGBA_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXT1ToRGBA DXT1ToRGBA;
#else
typedef struct DXT1ToRGBA DXT1ToRGBA;
#endif /* __cplusplus */

#endif 	/* __DXT1ToRGBA_FWD_DEFINED__ */


#ifndef __IRGBConverter_FWD_DEFINED__
#define __IRGBConverter_FWD_DEFINED__

#ifdef __cplusplus
typedef class IRGBConverter IRGBConverter;
#else
typedef struct IRGBConverter IRGBConverter;
#endif /* __cplusplus */

#endif 	/* __IRGBConverter_FWD_DEFINED__ */


#ifndef __DIBSource_FWD_DEFINED__
#define __DIBSource_FWD_DEFINED__

#ifdef __cplusplus
typedef class DIBSource DIBSource;
#else
typedef struct DIBSource DIBSource;
#endif /* __cplusplus */

#endif 	/* __DIBSource_FWD_DEFINED__ */


#ifndef __StdBitmapNotify_FWD_DEFINED__
#define __StdBitmapNotify_FWD_DEFINED__

#ifdef __cplusplus
typedef class StdBitmapNotify StdBitmapNotify;
#else
typedef struct StdBitmapNotify StdBitmapNotify;
#endif /* __cplusplus */

#endif 	/* __StdBitmapNotify_FWD_DEFINED__ */


#ifndef __BMPImport_FWD_DEFINED__
#define __BMPImport_FWD_DEFINED__

#ifdef __cplusplus
typedef class BMPImport BMPImport;
#else
typedef struct BMPImport BMPImport;
#endif /* __cplusplus */

#endif 	/* __BMPImport_FWD_DEFINED__ */


#ifndef __DXT2ToRGBA_FWD_DEFINED__
#define __DXT2ToRGBA_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXT2ToRGBA DXT2ToRGBA;
#else
typedef struct DXT2ToRGBA DXT2ToRGBA;
#endif /* __cplusplus */

#endif 	/* __DXT2ToRGBA_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_bmio_0000 */
/* [local] */ 

#include <ddraw.h>
#if 0
typedef void BITMAPINFO;

typedef struct _DDSURFACEDESC2 DDSURFACEDESC2;

typedef DWORD RGBQUAD;

#endif

typedef struct _BMFORMAT
    {
    ULONG nSize;
    GUID guidColorSpace;
    }	BMFORMAT;

typedef struct _BMFORMAT __RPC_FAR *PBMFORMAT;

typedef const BMFORMAT __RPC_FAR *PCBMFORMAT;

typedef struct _BMFORMAT_RGB
    {
    ULONG nSize;
    GUID guidColorSpace;
    ULONG nBPP;
    ULONGLONG dwRBitMask;
    ULONGLONG dwGBitMask;
    ULONGLONG dwBBitMask;
    }	BMFORMAT_RGB;

typedef struct _BMFORMAT_RGB __RPC_FAR *PBMFORMAT_RGB;

typedef const BMFORMAT_RGB __RPC_FAR *PCBMFORMAT_RGB;

typedef struct _BMFORMAT_RGBA
    {
    ULONG nSize;
    GUID guidColorSpace;
    USHORT nBPP;
    WORD wFlags;
    ULONGLONG dwRBitMask;
    ULONGLONG dwGBitMask;
    ULONGLONG dwBBitMask;
    ULONGLONG dwABitMask;
    }	BMFORMAT_RGBA;

typedef struct _BMFORMAT_RGBA __RPC_FAR *PBMFORMAT_RGBA;

typedef const BMFORMAT_RGBA __RPC_FAR *PCBMFORMAT_RGBA;

typedef struct _BMFORMAT_IRGB
    {
    ULONG nSize;
    GUID guidColorSpace;
    ULONG nBPP;
    }	BMFORMAT_IRGB;

typedef struct _BMFORMAT_IRGB __RPC_FAR *PBMFORMAT_IRGB;

typedef const BMFORMAT_IRGB __RPC_FAR *PCBMFORMAT_IRGB;

typedef struct _IRGBPALETTEUSAGE
    {
    ULONG iFirstAvailableColor;
    ULONG nAvailableColors;
    ULONG iFirstWritableColor;
    ULONG nWritableColors;
    }	IRGBPALETTEUSAGE;

typedef struct _BMFORMAT_GRAYSCALE
    {
    ULONG nSize;
    GUID guidColorSpace;
    USHORT nBPP;
    WORD wBitMask;
    }	BMFORMAT_GRAYSCALE;

typedef struct _BMFORMAT_GRAYSCALE __RPC_FAR *PBMFORMAT_GRAYSCALE;

typedef const BMFORMAT_GRAYSCALE __RPC_FAR *PCBMFORMAT_GRAYSCALE;

typedef struct _BMFORMAT_GRAYALPHA
    {
    ULONG nSize;
    GUID guidColorSpace;
    USHORT nBPP;
    DWORD dwGBitMask;
    DWORD dwABitMask;
    }	BMFORMAT_GRAYALPHA;

typedef struct _BMFORMAT_GRAYALPHA __RPC_FAR *PBMFORMAT_GRAYALPHA;

typedef const BMFORMAT_GRAYALPHA __RPC_FAR *PCBMFORMAT_GRAYALPHA;

typedef struct _BMFORMAT_YUV
    {
    ULONG nSize;
    GUID guidColorSpace;
    ULONG nBPP;
    DWORD dwYBitMask;
    DWORD dwUBitMask;
    DWORD dwVBitMask;
    }	BMFORMAT_YUV;

typedef struct _BMFORMAT_YUV __RPC_FAR *PBMFORMAT_YUV;

typedef const BMFORMAT_YUV __RPC_FAR *PCBMFORMAT_YUV;

typedef struct _BMFORMAT_DXT1
    {
    ULONG nSize;
    GUID guidColorSpace;
    }	BMFORMAT_DXT1;

typedef struct _BMFORMAT_DXT1 __RPC_FAR *PBMFORMAT_DXT1;

typedef const BMFORMAT_DXT1 __RPC_FAR *PCBMFORMAT_DXT1;

typedef struct _BMFORMAT_DXT2
    {
    ULONG nSize;
    GUID guidColorSpace;
    }	BMFORMAT_DXT2;

typedef struct _BMFORMAT_DXT2 __RPC_FAR *PBMFORMAT_DXT2;

typedef const BMFORMAT_DXT2 __RPC_FAR *PCBMFORMAT_DXT2;

typedef struct _BMFORMAT_DXT3
    {
    ULONG nSize;
    GUID guidColorSpace;
    }	BMFORMAT_DXT3;

typedef struct _BMFORMAT_DXT3 __RPC_FAR *PBMFORMAT_DXT3;

typedef const BMFORMAT_DXT3 __RPC_FAR *PCBMFORMAT_DXT3;

typedef struct _BMFORMAT_DXT4
    {
    ULONG nSize;
    GUID guidColorSpace;
    }	BMFORMAT_DXT4;

typedef struct _BMFORMAT_DXT4 __RPC_FAR *PBMFORMAT_DXT4;

typedef const BMFORMAT_DXT4 __RPC_FAR *PCBMFORMAT_DXT4;

typedef struct _BMFORMAT_DXT5
    {
    ULONG nSize;
    GUID guidColorSpace;
    }	BMFORMAT_DXT5;

typedef struct _BMFORMAT_DXT5 __RPC_FAR *PBMFORMAT_DXT5;

typedef const BMFORMAT_DXT5 __RPC_FAR *PCBMFORMAT_DXT5;

typedef struct _COLORSPACEINFO
    {
    GUID guidColorSpace;
    CLSID clsidConverter;
    DWORD dwFourCC;
    DWORD dwFlags;
    LPCOLESTR pszDescription;
    }	COLORSPACEINFO;

typedef struct _COLORSPACEINFO __RPC_FAR *PCOLORSPACEINFO;

typedef const COLORSPACEINFO __RPC_FAR *PCCOLORSPACEINFO;



extern RPC_IF_HANDLE __MIDL_itf_bmio_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_bmio_0000_v0_0_s_ifspec;

#ifndef __IIRGBTarget_INTERFACE_DEFINED__
#define __IIRGBTarget_INTERFACE_DEFINED__

/* interface IIRGBTarget */
/* [object][unique][helpstring][uuid][local] */ 


EXTERN_C const IID IID_IIRGBTarget;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3721E998-D851-11d1-8EC1-00C04FB68D60")
    IIRGBTarget : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPalette( 
            /* [in] */ ULONG iFirstColor,
            /* [in] */ ULONG nColors,
            /* [out] */ RGBQUAD __RPC_FAR *prgbColors) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPaletteUsage( 
            /* [out] */ ULONG __RPC_FAR *piFirstAvailableColor,
            /* [out] */ ULONG __RPC_FAR *pnAvailableColors,
            /* [out] */ ULONG __RPC_FAR *piFirstWritableColor,
            /* [out] */ ULONG __RPC_FAR *pnWritableColors,
            int __MIDL_0011) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPalette( 
            /* [in] */ ULONG iFirstColor,
            /* [in] */ ULONG nColors,
            /* [in] */ const RGBQUAD __RPC_FAR *prgbColors) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPaletteUsage( 
            /* [in] */ ULONG iFirstColor,
            /* [in] */ ULONG nColors) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTransparentColor( 
            /* [in] */ LONG iTransparentColor) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIRGBTargetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IIRGBTarget __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IIRGBTarget __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IIRGBTarget __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPalette )( 
            IIRGBTarget __RPC_FAR * This,
            /* [in] */ ULONG iFirstColor,
            /* [in] */ ULONG nColors,
            /* [out] */ RGBQUAD __RPC_FAR *prgbColors);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPaletteUsage )( 
            IIRGBTarget __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *piFirstAvailableColor,
            /* [out] */ ULONG __RPC_FAR *pnAvailableColors,
            /* [out] */ ULONG __RPC_FAR *piFirstWritableColor,
            /* [out] */ ULONG __RPC_FAR *pnWritableColors,
            int __MIDL_0011);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPalette )( 
            IIRGBTarget __RPC_FAR * This,
            /* [in] */ ULONG iFirstColor,
            /* [in] */ ULONG nColors,
            /* [in] */ const RGBQUAD __RPC_FAR *prgbColors);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPaletteUsage )( 
            IIRGBTarget __RPC_FAR * This,
            /* [in] */ ULONG iFirstColor,
            /* [in] */ ULONG nColors);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTransparentColor )( 
            IIRGBTarget __RPC_FAR * This,
            /* [in] */ LONG iTransparentColor);
        
        END_INTERFACE
    } IIRGBTargetVtbl;

    interface IIRGBTarget
    {
        CONST_VTBL struct IIRGBTargetVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIRGBTarget_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IIRGBTarget_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IIRGBTarget_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IIRGBTarget_GetPalette(This,iFirstColor,nColors,prgbColors)	\
    (This)->lpVtbl -> GetPalette(This,iFirstColor,nColors,prgbColors)

#define IIRGBTarget_GetPaletteUsage(This,piFirstAvailableColor,pnAvailableColors,piFirstWritableColor,pnWritableColors,__MIDL_0011)	\
    (This)->lpVtbl -> GetPaletteUsage(This,piFirstAvailableColor,pnAvailableColors,piFirstWritableColor,pnWritableColors,__MIDL_0011)

#define IIRGBTarget_SetPalette(This,iFirstColor,nColors,prgbColors)	\
    (This)->lpVtbl -> SetPalette(This,iFirstColor,nColors,prgbColors)

#define IIRGBTarget_SetPaletteUsage(This,iFirstColor,nColors)	\
    (This)->lpVtbl -> SetPaletteUsage(This,iFirstColor,nColors)

#define IIRGBTarget_SetTransparentColor(This,iTransparentColor)	\
    (This)->lpVtbl -> SetTransparentColor(This,iTransparentColor)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IIRGBTarget_GetPalette_Proxy( 
    IIRGBTarget __RPC_FAR * This,
    /* [in] */ ULONG iFirstColor,
    /* [in] */ ULONG nColors,
    /* [out] */ RGBQUAD __RPC_FAR *prgbColors);


void __RPC_STUB IIRGBTarget_GetPalette_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIRGBTarget_GetPaletteUsage_Proxy( 
    IIRGBTarget __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *piFirstAvailableColor,
    /* [out] */ ULONG __RPC_FAR *pnAvailableColors,
    /* [out] */ ULONG __RPC_FAR *piFirstWritableColor,
    /* [out] */ ULONG __RPC_FAR *pnWritableColors,
    int __MIDL_0011);


void __RPC_STUB IIRGBTarget_GetPaletteUsage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIRGBTarget_SetPalette_Proxy( 
    IIRGBTarget __RPC_FAR * This,
    /* [in] */ ULONG iFirstColor,
    /* [in] */ ULONG nColors,
    /* [in] */ const RGBQUAD __RPC_FAR *prgbColors);


void __RPC_STUB IIRGBTarget_SetPalette_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIRGBTarget_SetPaletteUsage_Proxy( 
    IIRGBTarget __RPC_FAR * This,
    /* [in] */ ULONG iFirstColor,
    /* [in] */ ULONG nColors);


void __RPC_STUB IIRGBTarget_SetPaletteUsage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIRGBTarget_SetTransparentColor_Proxy( 
    IIRGBTarget __RPC_FAR * This,
    /* [in] */ LONG iTransparentColor);


void __RPC_STUB IIRGBTarget_SetTransparentColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IIRGBTarget_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_bmio_0246 */
/* [local] */ 

typedef struct _BMTHINTS
    {
    ULONG nSize;
    DWORD dwFlags;
    ULONG nBlockXAlign;
    ULONG nBlockYAlign;
    ULONG nPasses;
    }	BMTHINTS;

typedef struct _BMTHINTS __RPC_FAR *PBMTHINTS;

typedef const BMTHINTS __RPC_FAR *PCBMTHINTS;



extern RPC_IF_HANDLE __MIDL_itf_bmio_0246_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_bmio_0246_v0_0_s_ifspec;

#ifndef __IBitmapTarget_INTERFACE_DEFINED__
#define __IBitmapTarget_INTERFACE_DEFINED__

/* interface IBitmapTarget */
/* [object][unique][helpstring][uuid][local] */ 


EXTERN_C const IID IID_IBitmapTarget;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D85EBB1F-7337-11D1-8E73-00C04FB68D60")
    IBitmapTarget : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ChooseInputFormat( 
            /* [in] */ PCBMFORMAT pSuggestedFormat,
            /* [out] */ PBMFORMAT __RPC_FAR *ppFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Finish( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputColorSpaces( 
            /* [out] */ CAUUID __RPC_FAR *pColorSpaces) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSurface( 
            /* [in] */ LONG nWidth,
            /* [in] */ LONG nHeight,
            /* [in] */ PCBMTHINTS pHints,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppBits,
            /* [out] */ LONG __RPC_FAR *pnPitch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnBitsComplete( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnProgress( 
            /* [in] */ const void __RPC_FAR *pBits,
            /* [in] */ LONG nPitch,
            /* [in] */ LPCRECT prcBounds,
            /* [in] */ BOOL bComplete) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBackgroundColor( 
            /* [in] */ const void __RPC_FAR *pColor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInputFormat( 
            /* [in] */ PCBMFORMAT pFormat) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBitmapTargetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBitmapTarget __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBitmapTarget __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBitmapTarget __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ChooseInputFormat )( 
            IBitmapTarget __RPC_FAR * This,
            /* [in] */ PCBMFORMAT pSuggestedFormat,
            /* [out] */ PBMFORMAT __RPC_FAR *ppFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Finish )( 
            IBitmapTarget __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInputColorSpaces )( 
            IBitmapTarget __RPC_FAR * This,
            /* [out] */ CAUUID __RPC_FAR *pColorSpaces);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSurface )( 
            IBitmapTarget __RPC_FAR * This,
            /* [in] */ LONG nWidth,
            /* [in] */ LONG nHeight,
            /* [in] */ PCBMTHINTS pHints,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppBits,
            /* [out] */ LONG __RPC_FAR *pnPitch);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnBitsComplete )( 
            IBitmapTarget __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnProgress )( 
            IBitmapTarget __RPC_FAR * This,
            /* [in] */ const void __RPC_FAR *pBits,
            /* [in] */ LONG nPitch,
            /* [in] */ LPCRECT prcBounds,
            /* [in] */ BOOL bComplete);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBackgroundColor )( 
            IBitmapTarget __RPC_FAR * This,
            /* [in] */ const void __RPC_FAR *pColor);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInputFormat )( 
            IBitmapTarget __RPC_FAR * This,
            /* [in] */ PCBMFORMAT pFormat);
        
        END_INTERFACE
    } IBitmapTargetVtbl;

    interface IBitmapTarget
    {
        CONST_VTBL struct IBitmapTargetVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBitmapTarget_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBitmapTarget_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBitmapTarget_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBitmapTarget_ChooseInputFormat(This,pSuggestedFormat,ppFormat)	\
    (This)->lpVtbl -> ChooseInputFormat(This,pSuggestedFormat,ppFormat)

#define IBitmapTarget_Finish(This)	\
    (This)->lpVtbl -> Finish(This)

#define IBitmapTarget_GetInputColorSpaces(This,pColorSpaces)	\
    (This)->lpVtbl -> GetInputColorSpaces(This,pColorSpaces)

#define IBitmapTarget_GetSurface(This,nWidth,nHeight,pHints,ppBits,pnPitch)	\
    (This)->lpVtbl -> GetSurface(This,nWidth,nHeight,pHints,ppBits,pnPitch)

#define IBitmapTarget_OnBitsComplete(This)	\
    (This)->lpVtbl -> OnBitsComplete(This)

#define IBitmapTarget_OnProgress(This,pBits,nPitch,prcBounds,bComplete)	\
    (This)->lpVtbl -> OnProgress(This,pBits,nPitch,prcBounds,bComplete)

#define IBitmapTarget_SetBackgroundColor(This,pColor)	\
    (This)->lpVtbl -> SetBackgroundColor(This,pColor)

#define IBitmapTarget_SetInputFormat(This,pFormat)	\
    (This)->lpVtbl -> SetInputFormat(This,pFormat)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBitmapTarget_ChooseInputFormat_Proxy( 
    IBitmapTarget __RPC_FAR * This,
    /* [in] */ PCBMFORMAT pSuggestedFormat,
    /* [out] */ PBMFORMAT __RPC_FAR *ppFormat);


void __RPC_STUB IBitmapTarget_ChooseInputFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBitmapTarget_Finish_Proxy( 
    IBitmapTarget __RPC_FAR * This);


void __RPC_STUB IBitmapTarget_Finish_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBitmapTarget_GetInputColorSpaces_Proxy( 
    IBitmapTarget __RPC_FAR * This,
    /* [out] */ CAUUID __RPC_FAR *pColorSpaces);


void __RPC_STUB IBitmapTarget_GetInputColorSpaces_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBitmapTarget_GetSurface_Proxy( 
    IBitmapTarget __RPC_FAR * This,
    /* [in] */ LONG nWidth,
    /* [in] */ LONG nHeight,
    /* [in] */ PCBMTHINTS pHints,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppBits,
    /* [out] */ LONG __RPC_FAR *pnPitch);


void __RPC_STUB IBitmapTarget_GetSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBitmapTarget_OnBitsComplete_Proxy( 
    IBitmapTarget __RPC_FAR * This);


void __RPC_STUB IBitmapTarget_OnBitsComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBitmapTarget_OnProgress_Proxy( 
    IBitmapTarget __RPC_FAR * This,
    /* [in] */ const void __RPC_FAR *pBits,
    /* [in] */ LONG nPitch,
    /* [in] */ LPCRECT prcBounds,
    /* [in] */ BOOL bComplete);


void __RPC_STUB IBitmapTarget_OnProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBitmapTarget_SetBackgroundColor_Proxy( 
    IBitmapTarget __RPC_FAR * This,
    /* [in] */ const void __RPC_FAR *pColor);


void __RPC_STUB IBitmapTarget_SetBackgroundColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBitmapTarget_SetInputFormat_Proxy( 
    IBitmapTarget __RPC_FAR * This,
    /* [in] */ PCBMFORMAT pFormat);


void __RPC_STUB IBitmapTarget_SetInputFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBitmapTarget_INTERFACE_DEFINED__ */


#ifndef __IAnimatedBitmapTarget_INTERFACE_DEFINED__
#define __IAnimatedBitmapTarget_INTERFACE_DEFINED__

/* interface IAnimatedBitmapTarget */
/* [object][unique][helpstring][uuid][local] */ 


EXTERN_C const IID IID_IAnimatedBitmapTarget;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("304f4b52-70bc-11d2-8f06-00c04fb68d60")
    IAnimatedBitmapTarget : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddFrames( 
            /* [in] */ ULONG nFrames) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginFrame( 
            /* [in] */ ULONG iFrame,
            /* [in] */ PCBMTHINTS pHints,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppBits,
            /* [out] */ LONG __RPC_FAR *pnPitch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChooseInputFormat( 
            /* [in] */ PCBMFORMAT pSuggestedFormat,
            /* [out] */ PBMFORMAT __RPC_FAR *ppFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndFrame( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Finish( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputColorSpaces( 
            /* [out] */ CAUUID __RPC_FAR *pColorSpaces) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnProgress( 
            /* [in] */ const void __RPC_FAR *pBits,
            /* [in] */ LONG nPitch,
            /* [in] */ LPCRECT prcBounds,
            /* [in] */ BOOL bComplete) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetImageSize( 
            /* [in] */ LONG nWidth,
            /* [in] */ LONG nHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInputFormat( 
            /* [in] */ PCBMFORMAT pFormat) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAnimatedBitmapTargetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAnimatedBitmapTarget __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAnimatedBitmapTarget __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAnimatedBitmapTarget __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddFrames )( 
            IAnimatedBitmapTarget __RPC_FAR * This,
            /* [in] */ ULONG nFrames);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginFrame )( 
            IAnimatedBitmapTarget __RPC_FAR * This,
            /* [in] */ ULONG iFrame,
            /* [in] */ PCBMTHINTS pHints,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppBits,
            /* [out] */ LONG __RPC_FAR *pnPitch);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ChooseInputFormat )( 
            IAnimatedBitmapTarget __RPC_FAR * This,
            /* [in] */ PCBMFORMAT pSuggestedFormat,
            /* [out] */ PBMFORMAT __RPC_FAR *ppFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndFrame )( 
            IAnimatedBitmapTarget __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Finish )( 
            IAnimatedBitmapTarget __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInputColorSpaces )( 
            IAnimatedBitmapTarget __RPC_FAR * This,
            /* [out] */ CAUUID __RPC_FAR *pColorSpaces);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnProgress )( 
            IAnimatedBitmapTarget __RPC_FAR * This,
            /* [in] */ const void __RPC_FAR *pBits,
            /* [in] */ LONG nPitch,
            /* [in] */ LPCRECT prcBounds,
            /* [in] */ BOOL bComplete);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetImageSize )( 
            IAnimatedBitmapTarget __RPC_FAR * This,
            /* [in] */ LONG nWidth,
            /* [in] */ LONG nHeight);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInputFormat )( 
            IAnimatedBitmapTarget __RPC_FAR * This,
            /* [in] */ PCBMFORMAT pFormat);
        
        END_INTERFACE
    } IAnimatedBitmapTargetVtbl;

    interface IAnimatedBitmapTarget
    {
        CONST_VTBL struct IAnimatedBitmapTargetVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAnimatedBitmapTarget_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAnimatedBitmapTarget_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAnimatedBitmapTarget_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAnimatedBitmapTarget_AddFrames(This,nFrames)	\
    (This)->lpVtbl -> AddFrames(This,nFrames)

#define IAnimatedBitmapTarget_BeginFrame(This,iFrame,pHints,ppBits,pnPitch)	\
    (This)->lpVtbl -> BeginFrame(This,iFrame,pHints,ppBits,pnPitch)

#define IAnimatedBitmapTarget_ChooseInputFormat(This,pSuggestedFormat,ppFormat)	\
    (This)->lpVtbl -> ChooseInputFormat(This,pSuggestedFormat,ppFormat)

#define IAnimatedBitmapTarget_EndFrame(This)	\
    (This)->lpVtbl -> EndFrame(This)

#define IAnimatedBitmapTarget_Finish(This)	\
    (This)->lpVtbl -> Finish(This)

#define IAnimatedBitmapTarget_GetInputColorSpaces(This,pColorSpaces)	\
    (This)->lpVtbl -> GetInputColorSpaces(This,pColorSpaces)

#define IAnimatedBitmapTarget_OnProgress(This,pBits,nPitch,prcBounds,bComplete)	\
    (This)->lpVtbl -> OnProgress(This,pBits,nPitch,prcBounds,bComplete)

#define IAnimatedBitmapTarget_SetImageSize(This,nWidth,nHeight)	\
    (This)->lpVtbl -> SetImageSize(This,nWidth,nHeight)

#define IAnimatedBitmapTarget_SetInputFormat(This,pFormat)	\
    (This)->lpVtbl -> SetInputFormat(This,pFormat)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAnimatedBitmapTarget_AddFrames_Proxy( 
    IAnimatedBitmapTarget __RPC_FAR * This,
    /* [in] */ ULONG nFrames);


void __RPC_STUB IAnimatedBitmapTarget_AddFrames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAnimatedBitmapTarget_BeginFrame_Proxy( 
    IAnimatedBitmapTarget __RPC_FAR * This,
    /* [in] */ ULONG iFrame,
    /* [in] */ PCBMTHINTS pHints,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppBits,
    /* [out] */ LONG __RPC_FAR *pnPitch);


void __RPC_STUB IAnimatedBitmapTarget_BeginFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAnimatedBitmapTarget_ChooseInputFormat_Proxy( 
    IAnimatedBitmapTarget __RPC_FAR * This,
    /* [in] */ PCBMFORMAT pSuggestedFormat,
    /* [out] */ PBMFORMAT __RPC_FAR *ppFormat);


void __RPC_STUB IAnimatedBitmapTarget_ChooseInputFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAnimatedBitmapTarget_EndFrame_Proxy( 
    IAnimatedBitmapTarget __RPC_FAR * This);


void __RPC_STUB IAnimatedBitmapTarget_EndFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAnimatedBitmapTarget_Finish_Proxy( 
    IAnimatedBitmapTarget __RPC_FAR * This);


void __RPC_STUB IAnimatedBitmapTarget_Finish_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAnimatedBitmapTarget_GetInputColorSpaces_Proxy( 
    IAnimatedBitmapTarget __RPC_FAR * This,
    /* [out] */ CAUUID __RPC_FAR *pColorSpaces);


void __RPC_STUB IAnimatedBitmapTarget_GetInputColorSpaces_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAnimatedBitmapTarget_OnProgress_Proxy( 
    IAnimatedBitmapTarget __RPC_FAR * This,
    /* [in] */ const void __RPC_FAR *pBits,
    /* [in] */ LONG nPitch,
    /* [in] */ LPCRECT prcBounds,
    /* [in] */ BOOL bComplete);


void __RPC_STUB IAnimatedBitmapTarget_OnProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAnimatedBitmapTarget_SetImageSize_Proxy( 
    IAnimatedBitmapTarget __RPC_FAR * This,
    /* [in] */ LONG nWidth,
    /* [in] */ LONG nHeight);


void __RPC_STUB IAnimatedBitmapTarget_SetImageSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAnimatedBitmapTarget_SetInputFormat_Proxy( 
    IAnimatedBitmapTarget __RPC_FAR * This,
    /* [in] */ PCBMFORMAT pFormat);


void __RPC_STUB IAnimatedBitmapTarget_SetInputFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAnimatedBitmapTarget_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_bmio_0248 */
/* [local] */ 





extern RPC_IF_HANDLE __MIDL_itf_bmio_0248_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_bmio_0248_v0_0_s_ifspec;

#ifndef __IBitmapSource_INTERFACE_DEFINED__
#define __IBitmapSource_INTERFACE_DEFINED__

/* interface IBitmapSource */
/* [object][unique][helpstring][uuid][local] */ 


EXTERN_C const IID IID_IBitmapSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D85EBB22-7337-11D1-8E73-00C04FB68D60")
    IBitmapSource : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOutputFormat( 
            /* [retval][out] */ PBMFORMAT __RPC_FAR *ppFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTarget( 
            /* [retval][out] */ IBitmapTarget __RPC_FAR *__RPC_FAR *ppTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE JoinGraph( 
            /* [in] */ IBMGraphManager __RPC_FAR *pGraph,
            /* [in] */ IBitmapNotify __RPC_FAR *pNotify) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTarget( 
            /* [in] */ IBitmapTarget __RPC_FAR *pTarget) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBitmapSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBitmapSource __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBitmapSource __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBitmapSource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputFormat )( 
            IBitmapSource __RPC_FAR * This,
            /* [retval][out] */ PBMFORMAT __RPC_FAR *ppFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTarget )( 
            IBitmapSource __RPC_FAR * This,
            /* [retval][out] */ IBitmapTarget __RPC_FAR *__RPC_FAR *ppTarget);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *JoinGraph )( 
            IBitmapSource __RPC_FAR * This,
            /* [in] */ IBMGraphManager __RPC_FAR *pGraph,
            /* [in] */ IBitmapNotify __RPC_FAR *pNotify);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTarget )( 
            IBitmapSource __RPC_FAR * This,
            /* [in] */ IBitmapTarget __RPC_FAR *pTarget);
        
        END_INTERFACE
    } IBitmapSourceVtbl;

    interface IBitmapSource
    {
        CONST_VTBL struct IBitmapSourceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBitmapSource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBitmapSource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBitmapSource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBitmapSource_GetOutputFormat(This,ppFormat)	\
    (This)->lpVtbl -> GetOutputFormat(This,ppFormat)

#define IBitmapSource_GetTarget(This,ppTarget)	\
    (This)->lpVtbl -> GetTarget(This,ppTarget)

#define IBitmapSource_JoinGraph(This,pGraph,pNotify)	\
    (This)->lpVtbl -> JoinGraph(This,pGraph,pNotify)

#define IBitmapSource_SetTarget(This,pTarget)	\
    (This)->lpVtbl -> SetTarget(This,pTarget)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBitmapSource_GetOutputFormat_Proxy( 
    IBitmapSource __RPC_FAR * This,
    /* [retval][out] */ PBMFORMAT __RPC_FAR *ppFormat);


void __RPC_STUB IBitmapSource_GetOutputFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBitmapSource_GetTarget_Proxy( 
    IBitmapSource __RPC_FAR * This,
    /* [retval][out] */ IBitmapTarget __RPC_FAR *__RPC_FAR *ppTarget);


void __RPC_STUB IBitmapSource_GetTarget_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBitmapSource_JoinGraph_Proxy( 
    IBitmapSource __RPC_FAR * This,
    /* [in] */ IBMGraphManager __RPC_FAR *pGraph,
    /* [in] */ IBitmapNotify __RPC_FAR *pNotify);


void __RPC_STUB IBitmapSource_JoinGraph_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBitmapSource_SetTarget_Proxy( 
    IBitmapSource __RPC_FAR * This,
    /* [in] */ IBitmapTarget __RPC_FAR *pTarget);


void __RPC_STUB IBitmapSource_SetTarget_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBitmapSource_INTERFACE_DEFINED__ */


#ifndef __IBitmapFormatConverter_INTERFACE_DEFINED__
#define __IBitmapFormatConverter_INTERFACE_DEFINED__

/* interface IBitmapFormatConverter */
/* [object][unique][helpstring][uuid][local] */ 


EXTERN_C const IID IID_IBitmapFormatConverter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D85EBB20-7337-11D1-8E73-00C04FB68D60")
    IBitmapFormatConverter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetOutputFormat( 
            /* [in] */ PCBMFORMAT pFormat) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBitmapFormatConverterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBitmapFormatConverter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBitmapFormatConverter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBitmapFormatConverter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutputFormat )( 
            IBitmapFormatConverter __RPC_FAR * This,
            /* [in] */ PCBMFORMAT pFormat);
        
        END_INTERFACE
    } IBitmapFormatConverterVtbl;

    interface IBitmapFormatConverter
    {
        CONST_VTBL struct IBitmapFormatConverterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBitmapFormatConverter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBitmapFormatConverter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBitmapFormatConverter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBitmapFormatConverter_SetOutputFormat(This,pFormat)	\
    (This)->lpVtbl -> SetOutputFormat(This,pFormat)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBitmapFormatConverter_SetOutputFormat_Proxy( 
    IBitmapFormatConverter __RPC_FAR * This,
    /* [in] */ PCBMFORMAT pFormat);


void __RPC_STUB IBitmapFormatConverter_SetOutputFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBitmapFormatConverter_INTERFACE_DEFINED__ */


#ifndef __IColorSpaceConverter_INTERFACE_DEFINED__
#define __IColorSpaceConverter_INTERFACE_DEFINED__

/* interface IColorSpaceConverter */
/* [object][unique][helpstring][uuid][local] */ 


EXTERN_C const IID IID_IColorSpaceConverter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9A8307E4-C9B3-11d1-8EBB-00C04FB68D60")
    IColorSpaceConverter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetOutputColorSpace( 
            /* [in] */ REFGUID guidColorSpace) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IColorSpaceConverterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IColorSpaceConverter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IColorSpaceConverter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IColorSpaceConverter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutputColorSpace )( 
            IColorSpaceConverter __RPC_FAR * This,
            /* [in] */ REFGUID guidColorSpace);
        
        END_INTERFACE
    } IColorSpaceConverterVtbl;

    interface IColorSpaceConverter
    {
        CONST_VTBL struct IColorSpaceConverterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IColorSpaceConverter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IColorSpaceConverter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IColorSpaceConverter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IColorSpaceConverter_SetOutputColorSpace(This,guidColorSpace)	\
    (This)->lpVtbl -> SetOutputColorSpace(This,guidColorSpace)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IColorSpaceConverter_SetOutputColorSpace_Proxy( 
    IColorSpaceConverter __RPC_FAR * This,
    /* [in] */ REFGUID guidColorSpace);


void __RPC_STUB IColorSpaceConverter_SetOutputColorSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IColorSpaceConverter_INTERFACE_DEFINED__ */


#ifndef __IBitmapImport_INTERFACE_DEFINED__
#define __IBitmapImport_INTERFACE_DEFINED__

/* interface IBitmapImport */
/* [object][unique][helpstring][uuid][local] */ 


EXTERN_C const IID IID_IBitmapImport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B69C56E1-7588-11D1-8E73-00C04FB68D60")
    IBitmapImport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Import( 
            /* [in] */ ISequentialStream __RPC_FAR *pStream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBitmapImportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBitmapImport __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBitmapImport __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBitmapImport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Import )( 
            IBitmapImport __RPC_FAR * This,
            /* [in] */ ISequentialStream __RPC_FAR *pStream);
        
        END_INTERFACE
    } IBitmapImportVtbl;

    interface IBitmapImport
    {
        CONST_VTBL struct IBitmapImportVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBitmapImport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBitmapImport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBitmapImport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBitmapImport_Import(This,pStream)	\
    (This)->lpVtbl -> Import(This,pStream)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBitmapImport_Import_Proxy( 
    IBitmapImport __RPC_FAR * This,
    /* [in] */ ISequentialStream __RPC_FAR *pStream);


void __RPC_STUB IBitmapImport_Import_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBitmapImport_INTERFACE_DEFINED__ */


#ifndef __IBitmapExport_INTERFACE_DEFINED__
#define __IBitmapExport_INTERFACE_DEFINED__

/* interface IBitmapExport */
/* [object][unique][helpstring][uuid][local] */ 


EXTERN_C const IID IID_IBitmapExport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("244FB8EA-23C6-11D1-8E31-00C04FB68D60")
    IBitmapExport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDestination( 
            /* [in] */ ISequentialStream __RPC_FAR *pStream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBitmapExportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBitmapExport __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBitmapExport __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBitmapExport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDestination )( 
            IBitmapExport __RPC_FAR * This,
            /* [in] */ ISequentialStream __RPC_FAR *pStream);
        
        END_INTERFACE
    } IBitmapExportVtbl;

    interface IBitmapExport
    {
        CONST_VTBL struct IBitmapExportVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBitmapExport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBitmapExport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBitmapExport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBitmapExport_SetDestination(This,pStream)	\
    (This)->lpVtbl -> SetDestination(This,pStream)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBitmapExport_SetDestination_Proxy( 
    IBitmapExport __RPC_FAR * This,
    /* [in] */ ISequentialStream __RPC_FAR *pStream);


void __RPC_STUB IBitmapExport_SetDestination_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBitmapExport_INTERFACE_DEFINED__ */


#ifndef __IPNGExport_INTERFACE_DEFINED__
#define __IPNGExport_INTERFACE_DEFINED__

/* interface IPNGExport */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IPNGExport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43AFD2E6-2493-11d1-8E32-00C04FB68D60")
    IPNGExport : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BitsPerChannel( 
            /* [retval][out] */ long __RPC_FAR *pnBitsPerChannel) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_BitsPerChannel( 
            /* [in] */ long nBitsPerChannel) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ColorSpace( 
            /* [retval][out] */ long __RPC_FAR *peColorSpace) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ColorSpace( 
            /* [in] */ long eColorSpace) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CompressionLevel( 
            /* [retval][out] */ long __RPC_FAR *pnCompressionLevel) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CompressionLevel( 
            /* [in] */ long nCompressionLevel) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Interlacing( 
            /* [retval][out] */ long __RPC_FAR *peInterlacing) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Interlacing( 
            /* [in] */ long eInterlacing) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPNGExportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPNGExport __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPNGExport __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPNGExport __RPC_FAR * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BitsPerChannel )( 
            IPNGExport __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pnBitsPerChannel);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BitsPerChannel )( 
            IPNGExport __RPC_FAR * This,
            /* [in] */ long nBitsPerChannel);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ColorSpace )( 
            IPNGExport __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *peColorSpace);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ColorSpace )( 
            IPNGExport __RPC_FAR * This,
            /* [in] */ long eColorSpace);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CompressionLevel )( 
            IPNGExport __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pnCompressionLevel);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CompressionLevel )( 
            IPNGExport __RPC_FAR * This,
            /* [in] */ long nCompressionLevel);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Interlacing )( 
            IPNGExport __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *peInterlacing);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Interlacing )( 
            IPNGExport __RPC_FAR * This,
            /* [in] */ long eInterlacing);
        
        END_INTERFACE
    } IPNGExportVtbl;

    interface IPNGExport
    {
        CONST_VTBL struct IPNGExportVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPNGExport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPNGExport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPNGExport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPNGExport_get_BitsPerChannel(This,pnBitsPerChannel)	\
    (This)->lpVtbl -> get_BitsPerChannel(This,pnBitsPerChannel)

#define IPNGExport_put_BitsPerChannel(This,nBitsPerChannel)	\
    (This)->lpVtbl -> put_BitsPerChannel(This,nBitsPerChannel)

#define IPNGExport_get_ColorSpace(This,peColorSpace)	\
    (This)->lpVtbl -> get_ColorSpace(This,peColorSpace)

#define IPNGExport_put_ColorSpace(This,eColorSpace)	\
    (This)->lpVtbl -> put_ColorSpace(This,eColorSpace)

#define IPNGExport_get_CompressionLevel(This,pnCompressionLevel)	\
    (This)->lpVtbl -> get_CompressionLevel(This,pnCompressionLevel)

#define IPNGExport_put_CompressionLevel(This,nCompressionLevel)	\
    (This)->lpVtbl -> put_CompressionLevel(This,nCompressionLevel)

#define IPNGExport_get_Interlacing(This,peInterlacing)	\
    (This)->lpVtbl -> get_Interlacing(This,peInterlacing)

#define IPNGExport_put_Interlacing(This,eInterlacing)	\
    (This)->lpVtbl -> put_Interlacing(This,eInterlacing)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IPNGExport_get_BitsPerChannel_Proxy( 
    IPNGExport __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pnBitsPerChannel);


void __RPC_STUB IPNGExport_get_BitsPerChannel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IPNGExport_put_BitsPerChannel_Proxy( 
    IPNGExport __RPC_FAR * This,
    /* [in] */ long nBitsPerChannel);


void __RPC_STUB IPNGExport_put_BitsPerChannel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IPNGExport_get_ColorSpace_Proxy( 
    IPNGExport __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *peColorSpace);


void __RPC_STUB IPNGExport_get_ColorSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IPNGExport_put_ColorSpace_Proxy( 
    IPNGExport __RPC_FAR * This,
    /* [in] */ long eColorSpace);


void __RPC_STUB IPNGExport_put_ColorSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IPNGExport_get_CompressionLevel_Proxy( 
    IPNGExport __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pnCompressionLevel);


void __RPC_STUB IPNGExport_get_CompressionLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IPNGExport_put_CompressionLevel_Proxy( 
    IPNGExport __RPC_FAR * This,
    /* [in] */ long nCompressionLevel);


void __RPC_STUB IPNGExport_put_CompressionLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IPNGExport_get_Interlacing_Proxy( 
    IPNGExport __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *peInterlacing);


void __RPC_STUB IPNGExport_get_Interlacing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IPNGExport_put_Interlacing_Proxy( 
    IPNGExport __RPC_FAR * This,
    /* [in] */ long eInterlacing);


void __RPC_STUB IPNGExport_put_Interlacing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPNGExport_INTERFACE_DEFINED__ */


#ifndef __IJPEGExport_INTERFACE_DEFINED__
#define __IJPEGExport_INTERFACE_DEFINED__

/* interface IJPEGExport */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IJPEGExport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2D86768A-2643-11d1-8E33-00C04FB68D60")
    IJPEGExport : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_GrayScale( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbGrayScale) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_GrayScale( 
            /* [in] */ VARIANT_BOOL bGrayScale) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Quality( 
            /* [retval][out] */ long __RPC_FAR *pnQuality) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Quality( 
            /* [in] */ long nQuality) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Progressive( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbProgressive) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Progressive( 
            /* [in] */ VARIANT_BOOL bProgressive) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJPEGExportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJPEGExport __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJPEGExport __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJPEGExport __RPC_FAR * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GrayScale )( 
            IJPEGExport __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbGrayScale);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_GrayScale )( 
            IJPEGExport __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bGrayScale);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Quality )( 
            IJPEGExport __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pnQuality);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Quality )( 
            IJPEGExport __RPC_FAR * This,
            /* [in] */ long nQuality);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progressive )( 
            IJPEGExport __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbProgressive);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progressive )( 
            IJPEGExport __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bProgressive);
        
        END_INTERFACE
    } IJPEGExportVtbl;

    interface IJPEGExport
    {
        CONST_VTBL struct IJPEGExportVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJPEGExport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJPEGExport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJPEGExport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJPEGExport_get_GrayScale(This,pbGrayScale)	\
    (This)->lpVtbl -> get_GrayScale(This,pbGrayScale)

#define IJPEGExport_put_GrayScale(This,bGrayScale)	\
    (This)->lpVtbl -> put_GrayScale(This,bGrayScale)

#define IJPEGExport_get_Quality(This,pnQuality)	\
    (This)->lpVtbl -> get_Quality(This,pnQuality)

#define IJPEGExport_put_Quality(This,nQuality)	\
    (This)->lpVtbl -> put_Quality(This,nQuality)

#define IJPEGExport_get_Progressive(This,pbProgressive)	\
    (This)->lpVtbl -> get_Progressive(This,pbProgressive)

#define IJPEGExport_put_Progressive(This,bProgressive)	\
    (This)->lpVtbl -> put_Progressive(This,bProgressive)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IJPEGExport_get_GrayScale_Proxy( 
    IJPEGExport __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbGrayScale);


void __RPC_STUB IJPEGExport_get_GrayScale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IJPEGExport_put_GrayScale_Proxy( 
    IJPEGExport __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bGrayScale);


void __RPC_STUB IJPEGExport_put_GrayScale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IJPEGExport_get_Quality_Proxy( 
    IJPEGExport __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pnQuality);


void __RPC_STUB IJPEGExport_get_Quality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IJPEGExport_put_Quality_Proxy( 
    IJPEGExport __RPC_FAR * This,
    /* [in] */ long nQuality);


void __RPC_STUB IJPEGExport_put_Quality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IJPEGExport_get_Progressive_Proxy( 
    IJPEGExport __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbProgressive);


void __RPC_STUB IJPEGExport_get_Progressive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IJPEGExport_put_Progressive_Proxy( 
    IJPEGExport __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bProgressive);


void __RPC_STUB IJPEGExport_put_Progressive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJPEGExport_INTERFACE_DEFINED__ */


#ifndef __IGIFExport_INTERFACE_DEFINED__
#define __IGIFExport_INTERFACE_DEFINED__

/* interface IGIFExport */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IGIFExport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("30d5522c-a4e9-11d2-8f10-00c04fb68d60")
    IGIFExport : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Interlace( 
            /* [retval][out] */ BOOL __RPC_FAR *pbInterlace) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Interlace( 
            /* [in] */ BOOL bInterlace) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGIFExportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IGIFExport __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IGIFExport __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IGIFExport __RPC_FAR * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Interlace )( 
            IGIFExport __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pbInterlace);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Interlace )( 
            IGIFExport __RPC_FAR * This,
            /* [in] */ BOOL bInterlace);
        
        END_INTERFACE
    } IGIFExportVtbl;

    interface IGIFExport
    {
        CONST_VTBL struct IGIFExportVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGIFExport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGIFExport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGIFExport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGIFExport_get_Interlace(This,pbInterlace)	\
    (This)->lpVtbl -> get_Interlace(This,pbInterlace)

#define IGIFExport_put_Interlace(This,bInterlace)	\
    (This)->lpVtbl -> put_Interlace(This,bInterlace)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IGIFExport_get_Interlace_Proxy( 
    IGIFExport __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pbInterlace);


void __RPC_STUB IGIFExport_get_Interlace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IGIFExport_put_Interlace_Proxy( 
    IGIFExport __RPC_FAR * This,
    /* [in] */ BOOL bInterlace);


void __RPC_STUB IGIFExport_put_Interlace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGIFExport_INTERFACE_DEFINED__ */


#ifndef __IBMPExport_INTERFACE_DEFINED__
#define __IBMPExport_INTERFACE_DEFINED__

/* interface IBMPExport */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IBMPExport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("53B727A2-36BC-11D1-8E43-00C04FB68D60")
    IBMPExport : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BottomUp( 
            /* [retval][out] */ BOOL __RPC_FAR *pbBottomUp) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_BottomUp( 
            BOOL bBottomUp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBMPExportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBMPExport __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBMPExport __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBMPExport __RPC_FAR * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BottomUp )( 
            IBMPExport __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pbBottomUp);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BottomUp )( 
            IBMPExport __RPC_FAR * This,
            BOOL bBottomUp);
        
        END_INTERFACE
    } IBMPExportVtbl;

    interface IBMPExport
    {
        CONST_VTBL struct IBMPExportVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBMPExport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBMPExport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBMPExport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBMPExport_get_BottomUp(This,pbBottomUp)	\
    (This)->lpVtbl -> get_BottomUp(This,pbBottomUp)

#define IBMPExport_put_BottomUp(This,bBottomUp)	\
    (This)->lpVtbl -> put_BottomUp(This,bBottomUp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IBMPExport_get_BottomUp_Proxy( 
    IBMPExport __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pbBottomUp);


void __RPC_STUB IBMPExport_get_BottomUp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IBMPExport_put_BottomUp_Proxy( 
    IBMPExport __RPC_FAR * This,
    BOOL bBottomUp);


void __RPC_STUB IBMPExport_put_BottomUp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBMPExport_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_bmio_0257 */
/* [local] */ 

typedef struct _BMIMPORTERSNIFFDATA
    {
    ULONG nBytes;
    ULONG iOffset;
    const BYTE __RPC_FAR *pbMask;
    const BYTE __RPC_FAR *pbData;
    }	BMIMPORTERSNIFFDATA;

typedef struct _BMIMPORTERSNIFFDATA __RPC_FAR *PBMIMPORTERSNIFFDATA;

typedef struct _BMIMPORTERSNIFFDATA BMSNIFFDATA;

typedef struct _BMIMPORTERSNIFFDATA __RPC_FAR *PBMSNIFFDATA;

typedef const BMIMPORTERSNIFFDATA __RPC_FAR *PCBMIMPORTERSNIFFDATA;

typedef const BMSNIFFDATA __RPC_FAR *PCBMSNIFFDATA;

typedef struct _BMFILETYPEINFO
    {
    GUID guid;
    ULONG nMIMETypes;
    const LPCOLESTR __RPC_FAR *ppszMIMETypes;
    ULONG nExtensions;
    const LPCOLESTR __RPC_FAR *ppszExtensions;
    LPCOLESTR pszDescription;
    ULONG nSniffData;
    const PCBMSNIFFDATA __RPC_FAR *ppSniffData;
    }	BMFILETYPEINFO;

typedef struct _BMFILETYPEINFO __RPC_FAR *PBMFILETYPEINFO;

typedef const BMFILETYPEINFO __RPC_FAR *PCBMFILETYPEINFO;

typedef struct _BMIMPORTERINFO
    {
    CLSID clsid;
    ULONG nMIMETypes;
    const LPCOLESTR __RPC_FAR *ppszMIMETypes;
    ULONG nExtensions;
    const LPCOLESTR __RPC_FAR *ppszExtensions;
    LPCOLESTR pszDescription;
    ULONG nSniffData;
    const PCBMIMPORTERSNIFFDATA __RPC_FAR *ppSniffData;
    }	BMIMPORTERINFO;

typedef struct _BMIMPORTERINFO __RPC_FAR *PBMIMPORTERINFO;

typedef const BMIMPORTERINFO __RPC_FAR *PCBMIMPORTERINFO;

typedef struct _BMEXPORTERINFO
    {
    CLSID clsid;
    LPCOLESTR pszMIMEType;
    LPCOLESTR pszDefaultExtension;
    LPCOLESTR pszDescription;
    LPCOLESTR pszFilterString;
    }	BMEXPORTERINFO;

typedef struct _BMEXPORTERINFO __RPC_FAR *PBMEXPORTERINFO;

typedef const BMEXPORTERINFO __RPC_FAR *PCBMEXPORTERINFO;




extern RPC_IF_HANDLE __MIDL_itf_bmio_0257_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_bmio_0257_v0_0_s_ifspec;

#ifndef __IEnumBMExporterInfo_INTERFACE_DEFINED__
#define __IEnumBMExporterInfo_INTERFACE_DEFINED__

/* interface IEnumBMExporterInfo */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IEnumBMExporterInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("83C41A78-BD3A-11d1-8EB2-00C04FB68D60")
    IEnumBMExporterInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG nElements,
            /* [out] */ IBMExporterInfo __RPC_FAR *__RPC_FAR *ppElements,
            /* [out] */ ULONG __RPC_FAR *pnFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG nElements) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumBMExporterInfo __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumBMExporterInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumBMExporterInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumBMExporterInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumBMExporterInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumBMExporterInfo __RPC_FAR * This,
            /* [in] */ ULONG nElements,
            /* [out] */ IBMExporterInfo __RPC_FAR *__RPC_FAR *ppElements,
            /* [out] */ ULONG __RPC_FAR *pnFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumBMExporterInfo __RPC_FAR * This,
            /* [in] */ ULONG nElements);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumBMExporterInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumBMExporterInfo __RPC_FAR * This,
            /* [out] */ IEnumBMExporterInfo __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumBMExporterInfoVtbl;

    interface IEnumBMExporterInfo
    {
        CONST_VTBL struct IEnumBMExporterInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumBMExporterInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumBMExporterInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumBMExporterInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumBMExporterInfo_Next(This,nElements,ppElements,pnFetched)	\
    (This)->lpVtbl -> Next(This,nElements,ppElements,pnFetched)

#define IEnumBMExporterInfo_Skip(This,nElements)	\
    (This)->lpVtbl -> Skip(This,nElements)

#define IEnumBMExporterInfo_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumBMExporterInfo_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumBMExporterInfo_Next_Proxy( 
    IEnumBMExporterInfo __RPC_FAR * This,
    /* [in] */ ULONG nElements,
    /* [out] */ IBMExporterInfo __RPC_FAR *__RPC_FAR *ppElements,
    /* [out] */ ULONG __RPC_FAR *pnFetched);


void __RPC_STUB IEnumBMExporterInfo_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumBMExporterInfo_Skip_Proxy( 
    IEnumBMExporterInfo __RPC_FAR * This,
    /* [in] */ ULONG nElements);


void __RPC_STUB IEnumBMExporterInfo_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumBMExporterInfo_Reset_Proxy( 
    IEnumBMExporterInfo __RPC_FAR * This);


void __RPC_STUB IEnumBMExporterInfo_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumBMExporterInfo_Clone_Proxy( 
    IEnumBMExporterInfo __RPC_FAR * This,
    /* [out] */ IEnumBMExporterInfo __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumBMExporterInfo_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumBMExporterInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_bmio_0258 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_bmio_0258_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_bmio_0258_v0_0_s_ifspec;

#ifndef __IEnumBMImporterInfo_INTERFACE_DEFINED__
#define __IEnumBMImporterInfo_INTERFACE_DEFINED__

/* interface IEnumBMImporterInfo */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IEnumBMImporterInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5C7F0A68-D699-11d1-8EC1-00C04FB68D60")
    IEnumBMImporterInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG nElements,
            /* [out] */ IBMImporterInfo __RPC_FAR *__RPC_FAR *ppElements,
            /* [out] */ ULONG __RPC_FAR *pnFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG nElements) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumBMImporterInfo __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumBMImporterInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumBMImporterInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumBMImporterInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumBMImporterInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumBMImporterInfo __RPC_FAR * This,
            /* [in] */ ULONG nElements,
            /* [out] */ IBMImporterInfo __RPC_FAR *__RPC_FAR *ppElements,
            /* [out] */ ULONG __RPC_FAR *pnFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumBMImporterInfo __RPC_FAR * This,
            /* [in] */ ULONG nElements);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumBMImporterInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumBMImporterInfo __RPC_FAR * This,
            /* [out] */ IEnumBMImporterInfo __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumBMImporterInfoVtbl;

    interface IEnumBMImporterInfo
    {
        CONST_VTBL struct IEnumBMImporterInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumBMImporterInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumBMImporterInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumBMImporterInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumBMImporterInfo_Next(This,nElements,ppElements,pnFetched)	\
    (This)->lpVtbl -> Next(This,nElements,ppElements,pnFetched)

#define IEnumBMImporterInfo_Skip(This,nElements)	\
    (This)->lpVtbl -> Skip(This,nElements)

#define IEnumBMImporterInfo_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumBMImporterInfo_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumBMImporterInfo_Next_Proxy( 
    IEnumBMImporterInfo __RPC_FAR * This,
    /* [in] */ ULONG nElements,
    /* [out] */ IBMImporterInfo __RPC_FAR *__RPC_FAR *ppElements,
    /* [out] */ ULONG __RPC_FAR *pnFetched);


void __RPC_STUB IEnumBMImporterInfo_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumBMImporterInfo_Skip_Proxy( 
    IEnumBMImporterInfo __RPC_FAR * This,
    /* [in] */ ULONG nElements);


void __RPC_STUB IEnumBMImporterInfo_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumBMImporterInfo_Reset_Proxy( 
    IEnumBMImporterInfo __RPC_FAR * This);


void __RPC_STUB IEnumBMImporterInfo_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumBMImporterInfo_Clone_Proxy( 
    IEnumBMImporterInfo __RPC_FAR * This,
    /* [out] */ IEnumBMImporterInfo __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumBMImporterInfo_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumBMImporterInfo_INTERFACE_DEFINED__ */


#ifndef __IBMFileTypeInfo_INTERFACE_DEFINED__
#define __IBMFileTypeInfo_INTERFACE_DEFINED__

/* interface IBMFileTypeInfo */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IBMFileTypeInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EBACCCA7-0574-11D2-8EE4-00C04FB68D60")
    IBMFileTypeInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDefaultExtension( 
            /* [retval][out] */ LPOLESTR __RPC_FAR *ppszExtension) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultMIMEType( 
            /* [retval][out] */ LPOLESTR __RPC_FAR *ppszMIMEType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [in] */ LCID lcid,
            /* [retval][out] */ LPOLESTR __RPC_FAR *ppszDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExporterClassID( 
            /* [retval][out] */ CLSID __RPC_FAR *pclsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExtension( 
            /* [in] */ ULONG iExtension,
            /* [retval][out] */ LPOLESTR __RPC_FAR *ppszExtension) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGUID( 
            /* [retval][out] */ GUID __RPC_FAR *pguid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImporterClassID( 
            /* [retval][out] */ CLSID __RPC_FAR *pclsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMIMEType( 
            /* [in] */ ULONG iMIMEType,
            /* [retval][out] */ LPOLESTR __RPC_FAR *ppszMIMEType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumExtensions( 
            /* [retval][out] */ ULONG __RPC_FAR *pnExtensions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumMIMETypes( 
            /* [retval][out] */ ULONG __RPC_FAR *pnMIMETypes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBMFileTypeInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBMFileTypeInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBMFileTypeInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBMFileTypeInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultExtension )( 
            IBMFileTypeInfo __RPC_FAR * This,
            /* [retval][out] */ LPOLESTR __RPC_FAR *ppszExtension);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultMIMEType )( 
            IBMFileTypeInfo __RPC_FAR * This,
            /* [retval][out] */ LPOLESTR __RPC_FAR *ppszMIMEType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDescription )( 
            IBMFileTypeInfo __RPC_FAR * This,
            /* [in] */ LCID lcid,
            /* [retval][out] */ LPOLESTR __RPC_FAR *ppszDescription);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExporterClassID )( 
            IBMFileTypeInfo __RPC_FAR * This,
            /* [retval][out] */ CLSID __RPC_FAR *pclsid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExtension )( 
            IBMFileTypeInfo __RPC_FAR * This,
            /* [in] */ ULONG iExtension,
            /* [retval][out] */ LPOLESTR __RPC_FAR *ppszExtension);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGUID )( 
            IBMFileTypeInfo __RPC_FAR * This,
            /* [retval][out] */ GUID __RPC_FAR *pguid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetImporterClassID )( 
            IBMFileTypeInfo __RPC_FAR * This,
            /* [retval][out] */ CLSID __RPC_FAR *pclsid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMIMEType )( 
            IBMFileTypeInfo __RPC_FAR * This,
            /* [in] */ ULONG iMIMEType,
            /* [retval][out] */ LPOLESTR __RPC_FAR *ppszMIMEType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNumExtensions )( 
            IBMFileTypeInfo __RPC_FAR * This,
            /* [retval][out] */ ULONG __RPC_FAR *pnExtensions);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNumMIMETypes )( 
            IBMFileTypeInfo __RPC_FAR * This,
            /* [retval][out] */ ULONG __RPC_FAR *pnMIMETypes);
        
        END_INTERFACE
    } IBMFileTypeInfoVtbl;

    interface IBMFileTypeInfo
    {
        CONST_VTBL struct IBMFileTypeInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBMFileTypeInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBMFileTypeInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBMFileTypeInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBMFileTypeInfo_GetDefaultExtension(This,ppszExtension)	\
    (This)->lpVtbl -> GetDefaultExtension(This,ppszExtension)

#define IBMFileTypeInfo_GetDefaultMIMEType(This,ppszMIMEType)	\
    (This)->lpVtbl -> GetDefaultMIMEType(This,ppszMIMEType)

#define IBMFileTypeInfo_GetDescription(This,lcid,ppszDescription)	\
    (This)->lpVtbl -> GetDescription(This,lcid,ppszDescription)

#define IBMFileTypeInfo_GetExporterClassID(This,pclsid)	\
    (This)->lpVtbl -> GetExporterClassID(This,pclsid)

#define IBMFileTypeInfo_GetExtension(This,iExtension,ppszExtension)	\
    (This)->lpVtbl -> GetExtension(This,iExtension,ppszExtension)

#define IBMFileTypeInfo_GetGUID(This,pguid)	\
    (This)->lpVtbl -> GetGUID(This,pguid)

#define IBMFileTypeInfo_GetImporterClassID(This,pclsid)	\
    (This)->lpVtbl -> GetImporterClassID(This,pclsid)

#define IBMFileTypeInfo_GetMIMEType(This,iMIMEType,ppszMIMEType)	\
    (This)->lpVtbl -> GetMIMEType(This,iMIMEType,ppszMIMEType)

#define IBMFileTypeInfo_GetNumExtensions(This,pnExtensions)	\
    (This)->lpVtbl -> GetNumExtensions(This,pnExtensions)

#define IBMFileTypeInfo_GetNumMIMETypes(This,pnMIMETypes)	\
    (This)->lpVtbl -> GetNumMIMETypes(This,pnMIMETypes)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBMFileTypeInfo_GetDefaultExtension_Proxy( 
    IBMFileTypeInfo __RPC_FAR * This,
    /* [retval][out] */ LPOLESTR __RPC_FAR *ppszExtension);


void __RPC_STUB IBMFileTypeInfo_GetDefaultExtension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBMFileTypeInfo_GetDefaultMIMEType_Proxy( 
    IBMFileTypeInfo __RPC_FAR * This,
    /* [retval][out] */ LPOLESTR __RPC_FAR *ppszMIMEType);


void __RPC_STUB IBMFileTypeInfo_GetDefaultMIMEType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBMFileTypeInfo_GetDescription_Proxy( 
    IBMFileTypeInfo __RPC_FAR * This,
    /* [in] */ LCID lcid,
    /* [retval][out] */ LPOLESTR __RPC_FAR *ppszDescription);


void __RPC_STUB IBMFileTypeInfo_GetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBMFileTypeInfo_GetExporterClassID_Proxy( 
    IBMFileTypeInfo __RPC_FAR * This,
    /* [retval][out] */ CLSID __RPC_FAR *pclsid);


void __RPC_STUB IBMFileTypeInfo_GetExporterClassID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBMFileTypeInfo_GetExtension_Proxy( 
    IBMFileTypeInfo __RPC_FAR * This,
    /* [in] */ ULONG iExtension,
    /* [retval][out] */ LPOLESTR __RPC_FAR *ppszExtension);


void __RPC_STUB IBMFileTypeInfo_GetExtension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBMFileTypeInfo_GetGUID_Proxy( 
    IBMFileTypeInfo __RPC_FAR * This,
    /* [retval][out] */ GUID __RPC_FAR *pguid);


void __RPC_STUB IBMFileTypeInfo_GetGUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBMFileTypeInfo_GetImporterClassID_Proxy( 
    IBMFileTypeInfo __RPC_FAR * This,
    /* [retval][out] */ CLSID __RPC_FAR *pclsid);


void __RPC_STUB IBMFileTypeInfo_GetImporterClassID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBMFileTypeInfo_GetMIMEType_Proxy( 
    IBMFileTypeInfo __RPC_FAR * This,
    /* [in] */ ULONG iMIMEType,
    /* [retval][out] */ LPOLESTR __RPC_FAR *ppszMIMEType);


void __RPC_STUB IBMFileTypeInfo_GetMIMEType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBMFileTypeInfo_GetNumExtensions_Proxy( 
    IBMFileTypeInfo __RPC_FAR * This,
    /* [retval][out] */ ULONG __RPC_FAR *pnExtensions);


void __RPC_STUB IBMFileTypeInfo_GetNumExtensions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBMFileTypeInfo_GetNumMIMETypes_Proxy( 
    IBMFileTypeInfo __RPC_FAR * This,
    /* [retval][out] */ ULONG __RPC_FAR *pnMIMETypes);


void __RPC_STUB IBMFileTypeInfo_GetNumMIMETypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBMFileTypeInfo_INTERFACE_DEFINED__ */


#ifndef __IEnumBMFileTypeInfo_INTERFACE_DEFINED__
#define __IEnumBMFileTypeInfo_INTERFACE_DEFINED__

/* interface IEnumBMFileTypeInfo */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IEnumBMFileTypeInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EBACCCA8-0574-11D2-8EE4-00C04FB68D60")
    IEnumBMFileTypeInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG nElements,
            /* [out] */ IBMFileTypeInfo __RPC_FAR *__RPC_FAR *ppElements,
            /* [out] */ ULONG __RPC_FAR *pnFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG nElements) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumBMFileTypeInfo __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumBMFileTypeInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumBMFileTypeInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumBMFileTypeInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumBMFileTypeInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumBMFileTypeInfo __RPC_FAR * This,
            /* [in] */ ULONG nElements,
            /* [out] */ IBMFileTypeInfo __RPC_FAR *__RPC_FAR *ppElements,
            /* [out] */ ULONG __RPC_FAR *pnFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumBMFileTypeInfo __RPC_FAR * This,
            /* [in] */ ULONG nElements);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumBMFileTypeInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumBMFileTypeInfo __RPC_FAR * This,
            /* [out] */ IEnumBMFileTypeInfo __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumBMFileTypeInfoVtbl;

    interface IEnumBMFileTypeInfo
    {
        CONST_VTBL struct IEnumBMFileTypeInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumBMFileTypeInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumBMFileTypeInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumBMFileTypeInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumBMFileTypeInfo_Next(This,nElements,ppElements,pnFetched)	\
    (This)->lpVtbl -> Next(This,nElements,ppElements,pnFetched)

#define IEnumBMFileTypeInfo_Skip(This,nElements)	\
    (This)->lpVtbl -> Skip(This,nElements)

#define IEnumBMFileTypeInfo_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumBMFileTypeInfo_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumBMFileTypeInfo_Next_Proxy( 
    IEnumBMFileTypeInfo __RPC_FAR * This,
    /* [in] */ ULONG nElements,
    /* [out] */ IBMFileTypeInfo __RPC_FAR *__RPC_FAR *ppElements,
    /* [out] */ ULONG __RPC_FAR *pnFetched);


void __RPC_STUB IEnumBMFileTypeInfo_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumBMFileTypeInfo_Skip_Proxy( 
    IEnumBMFileTypeInfo __RPC_FAR * This,
    /* [in] */ ULONG nElements);


void __RPC_STUB IEnumBMFileTypeInfo_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumBMFileTypeInfo_Reset_Proxy( 
    IEnumBMFileTypeInfo __RPC_FAR * This);


void __RPC_STUB IEnumBMFileTypeInfo_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumBMFileTypeInfo_Clone_Proxy( 
    IEnumBMFileTypeInfo __RPC_FAR * This,
    /* [out] */ IEnumBMFileTypeInfo __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumBMFileTypeInfo_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumBMFileTypeInfo_INTERFACE_DEFINED__ */


#ifndef __IBMExporterInfo_INTERFACE_DEFINED__
#define __IBMExporterInfo_INTERFACE_DEFINED__

/* interface IBMExporterInfo */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IBMExporterInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("20C58D30-7024-11D1-8E73-00C04FB68D60")
    IBMExporterInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClassID( 
            /* [retval][out] */ CLSID __RPC_FAR *pclsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [in] */ LCID lcid,
            /* [retval][out] */ LPOLESTR __RPC_FAR *ppszDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultExtension( 
            /* [retval][out] */ LPOLESTR __RPC_FAR *ppszExtension) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFilterString( 
            /* [in] */ LCID lcid,
            /* [retval][out] */ LPOLESTR __RPC_FAR *ppszFilterString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMIMEType( 
            /* [retval][out] */ LPOLESTR __RPC_FAR *ppszMIMEType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBMExporterInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBMExporterInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBMExporterInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBMExporterInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClassID )( 
            IBMExporterInfo __RPC_FAR * This,
            /* [retval][out] */ CLSID __RPC_FAR *pclsid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDescription )( 
            IBMExporterInfo __RPC_FAR * This,
            /* [in] */ LCID lcid,
            /* [retval][out] */ LPOLESTR __RPC_FAR *ppszDescription);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultExtension )( 
            IBMExporterInfo __RPC_FAR * This,
            /* [retval][out] */ LPOLESTR __RPC_FAR *ppszExtension);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFilterString )( 
            IBMExporterInfo __RPC_FAR * This,
            /* [in] */ LCID lcid,
            /* [retval][out] */ LPOLESTR __RPC_FAR *ppszFilterString);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMIMEType )( 
            IBMExporterInfo __RPC_FAR * This,
            /* [retval][out] */ LPOLESTR __RPC_FAR *ppszMIMEType);
        
        END_INTERFACE
    } IBMExporterInfoVtbl;

    interface IBMExporterInfo
    {
        CONST_VTBL struct IBMExporterInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBMExporterInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBMExporterInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBMExporterInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBMExporterInfo_GetClassID(This,pclsid)	\
    (This)->lpVtbl -> GetClassID(This,pclsid)

#define IBMExporterInfo_GetDescription(This,lcid,ppszDescription)	\
    (This)->lpVtbl -> GetDescription(This,lcid,ppszDescription)

#define IBMExporterInfo_GetDefaultExtension(This,ppszExtension)	\
    (This)->lpVtbl -> GetDefaultExtension(This,ppszExtension)

#define IBMExporterInfo_GetFilterString(This,lcid,ppszFilterString)	\
    (This)->lpVtbl -> GetFilterString(This,lcid,ppszFilterString)

#define IBMExporterInfo_GetMIMEType(This,ppszMIMEType)	\
    (This)->lpVtbl -> GetMIMEType(This,ppszMIMEType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBMExporterInfo_GetClassID_Proxy( 
    IBMExporterInfo __RPC_FAR * This,
    /* [retval][out] */ CLSID __RPC_FAR *pclsid);


void __RPC_STUB IBMExporterInfo_GetClassID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBMExporterInfo_GetDescription_Proxy( 
    IBMExporterInfo __RPC_FAR * This,
    /* [in] */ LCID lcid,
    /* [retval][out] */ LPOLESTR __RPC_FAR *ppszDescription);


void __RPC_STUB IBMExporterInfo_GetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBMExporterInfo_GetDefaultExtension_Proxy( 
    IBMExporterInfo __RPC_FAR * This,
    /* [retval][out] */ LPOLESTR __RPC_FAR *ppszExtension);


void __RPC_STUB IBMExporterInfo_GetDefaultExtension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBMExporterInfo_GetFilterString_Proxy( 
    IBMExporterInfo __RPC_FAR * This,
    /* [in] */ LCID lcid,
    /* [retval][out] */ LPOLESTR __RPC_FAR *ppszFilterString);


void __RPC_STUB IBMExporterInfo_GetFilterString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBMExporterInfo_GetMIMEType_Proxy( 
    IBMExporterInfo __RPC_FAR * This,
    /* [retval][out] */ LPOLESTR __RPC_FAR *ppszMIMEType);


void __RPC_STUB IBMExporterInfo_GetMIMEType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBMExporterInfo_INTERFACE_DEFINED__ */


#ifndef __IBMImporterInfo_INTERFACE_DEFINED__
#define __IBMImporterInfo_INTERFACE_DEFINED__

/* interface IBMImporterInfo */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IBMImporterInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9A76B128-D68E-11d1-8EC1-00C04FB68D60")
    IBMImporterInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClassID( 
            /* [retval][out] */ CLSID __RPC_FAR *pclsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [in] */ LCID lcid,
            /* [retval][out] */ LPOLESTR __RPC_FAR *ppszDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExtension( 
            /* [in] */ ULONG iExtension,
            /* [retval][out] */ LPOLESTR __RPC_FAR *ppszExtension) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMIMEType( 
            /* [in] */ ULONG iMIMEType,
            /* [retval][out] */ LPOLESTR __RPC_FAR *ppszMIMEType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumExtensions( 
            /* [retval][out] */ ULONG __RPC_FAR *pnExtensions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumMIMETypes( 
            /* [retval][out] */ ULONG __RPC_FAR *pnMIMETypes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBMImporterInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBMImporterInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBMImporterInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBMImporterInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClassID )( 
            IBMImporterInfo __RPC_FAR * This,
            /* [retval][out] */ CLSID __RPC_FAR *pclsid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDescription )( 
            IBMImporterInfo __RPC_FAR * This,
            /* [in] */ LCID lcid,
            /* [retval][out] */ LPOLESTR __RPC_FAR *ppszDescription);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExtension )( 
            IBMImporterInfo __RPC_FAR * This,
            /* [in] */ ULONG iExtension,
            /* [retval][out] */ LPOLESTR __RPC_FAR *ppszExtension);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMIMEType )( 
            IBMImporterInfo __RPC_FAR * This,
            /* [in] */ ULONG iMIMEType,
            /* [retval][out] */ LPOLESTR __RPC_FAR *ppszMIMEType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNumExtensions )( 
            IBMImporterInfo __RPC_FAR * This,
            /* [retval][out] */ ULONG __RPC_FAR *pnExtensions);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNumMIMETypes )( 
            IBMImporterInfo __RPC_FAR * This,
            /* [retval][out] */ ULONG __RPC_FAR *pnMIMETypes);
        
        END_INTERFACE
    } IBMImporterInfoVtbl;

    interface IBMImporterInfo
    {
        CONST_VTBL struct IBMImporterInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBMImporterInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBMImporterInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBMImporterInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBMImporterInfo_GetClassID(This,pclsid)	\
    (This)->lpVtbl -> GetClassID(This,pclsid)

#define IBMImporterInfo_GetDescription(This,lcid,ppszDescription)	\
    (This)->lpVtbl -> GetDescription(This,lcid,ppszDescription)

#define IBMImporterInfo_GetExtension(This,iExtension,ppszExtension)	\
    (This)->lpVtbl -> GetExtension(This,iExtension,ppszExtension)

#define IBMImporterInfo_GetMIMEType(This,iMIMEType,ppszMIMEType)	\
    (This)->lpVtbl -> GetMIMEType(This,iMIMEType,ppszMIMEType)

#define IBMImporterInfo_GetNumExtensions(This,pnExtensions)	\
    (This)->lpVtbl -> GetNumExtensions(This,pnExtensions)

#define IBMImporterInfo_GetNumMIMETypes(This,pnMIMETypes)	\
    (This)->lpVtbl -> GetNumMIMETypes(This,pnMIMETypes)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBMImporterInfo_GetClassID_Proxy( 
    IBMImporterInfo __RPC_FAR * This,
    /* [retval][out] */ CLSID __RPC_FAR *pclsid);


void __RPC_STUB IBMImporterInfo_GetClassID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBMImporterInfo_GetDescription_Proxy( 
    IBMImporterInfo __RPC_FAR * This,
    /* [in] */ LCID lcid,
    /* [retval][out] */ LPOLESTR __RPC_FAR *ppszDescription);


void __RPC_STUB IBMImporterInfo_GetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBMImporterInfo_GetExtension_Proxy( 
    IBMImporterInfo __RPC_FAR * This,
    /* [in] */ ULONG iExtension,
    /* [retval][out] */ LPOLESTR __RPC_FAR *ppszExtension);


void __RPC_STUB IBMImporterInfo_GetExtension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBMImporterInfo_GetMIMEType_Proxy( 
    IBMImporterInfo __RPC_FAR * This,
    /* [in] */ ULONG iMIMEType,
    /* [retval][out] */ LPOLESTR __RPC_FAR *ppszMIMEType);


void __RPC_STUB IBMImporterInfo_GetMIMEType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBMImporterInfo_GetNumExtensions_Proxy( 
    IBMImporterInfo __RPC_FAR * This,
    /* [retval][out] */ ULONG __RPC_FAR *pnExtensions);


void __RPC_STUB IBMImporterInfo_GetNumExtensions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBMImporterInfo_GetNumMIMETypes_Proxy( 
    IBMImporterInfo __RPC_FAR * This,
    /* [retval][out] */ ULONG __RPC_FAR *pnMIMETypes);


void __RPC_STUB IBMImporterInfo_GetNumMIMETypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBMImporterInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_bmio_0263 */
/* [local] */ 

typedef 
enum _BMDITHERMODE
    {	BMDITHER_NONE	= 0,
	BMDITHER_ERRORDIFFUSION	= 1
    }	BMDITHERMODE;



extern RPC_IF_HANDLE __MIDL_itf_bmio_0263_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_bmio_0263_v0_0_s_ifspec;

#ifndef __IDitherer_INTERFACE_DEFINED__
#define __IDitherer_INTERFACE_DEFINED__

/* interface IDitherer */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IDitherer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B69C56DD-7588-11D1-8E73-00C04FB68D60")
    IDitherer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDitherMode( 
            /* [in] */ BMDITHERMODE eMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDithererVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDitherer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDitherer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDitherer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDitherMode )( 
            IDitherer __RPC_FAR * This,
            /* [in] */ BMDITHERMODE eMode);
        
        END_INTERFACE
    } IDithererVtbl;

    interface IDitherer
    {
        CONST_VTBL struct IDithererVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDitherer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDitherer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDitherer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDitherer_SetDitherMode(This,eMode)	\
    (This)->lpVtbl -> SetDitherMode(This,eMode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDitherer_SetDitherMode_Proxy( 
    IDitherer __RPC_FAR * This,
    /* [in] */ BMDITHERMODE eMode);


void __RPC_STUB IDitherer_SetDitherMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDitherer_INTERFACE_DEFINED__ */


#ifndef __IColorQuantizer_INTERFACE_DEFINED__
#define __IColorQuantizer_INTERFACE_DEFINED__

/* interface IColorQuantizer */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IColorQuantizer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("591BBC11-968D-11D1-8E87-00C04FB68D60")
    IColorQuantizer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMaxPaletteEntries( 
            /* [retval][out] */ ULONG __RPC_FAR *pnEntries) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCustomPalette( 
            /* [in] */ const PALETTEENTRY __RPC_FAR *ppePalette,
            /* [in] */ LONG iFirstEntry,
            /* [in] */ LONG nEntries) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPaletteGenerationMode( 
            /* [in] */ LONG ePaletteMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IColorQuantizerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IColorQuantizer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IColorQuantizer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IColorQuantizer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxPaletteEntries )( 
            IColorQuantizer __RPC_FAR * This,
            /* [retval][out] */ ULONG __RPC_FAR *pnEntries);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCustomPalette )( 
            IColorQuantizer __RPC_FAR * This,
            /* [in] */ const PALETTEENTRY __RPC_FAR *ppePalette,
            /* [in] */ LONG iFirstEntry,
            /* [in] */ LONG nEntries);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPaletteGenerationMode )( 
            IColorQuantizer __RPC_FAR * This,
            /* [in] */ LONG ePaletteMode);
        
        END_INTERFACE
    } IColorQuantizerVtbl;

    interface IColorQuantizer
    {
        CONST_VTBL struct IColorQuantizerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IColorQuantizer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IColorQuantizer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IColorQuantizer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IColorQuantizer_GetMaxPaletteEntries(This,pnEntries)	\
    (This)->lpVtbl -> GetMaxPaletteEntries(This,pnEntries)

#define IColorQuantizer_SetCustomPalette(This,ppePalette,iFirstEntry,nEntries)	\
    (This)->lpVtbl -> SetCustomPalette(This,ppePalette,iFirstEntry,nEntries)

#define IColorQuantizer_SetPaletteGenerationMode(This,ePaletteMode)	\
    (This)->lpVtbl -> SetPaletteGenerationMode(This,ePaletteMode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IColorQuantizer_GetMaxPaletteEntries_Proxy( 
    IColorQuantizer __RPC_FAR * This,
    /* [retval][out] */ ULONG __RPC_FAR *pnEntries);


void __RPC_STUB IColorQuantizer_GetMaxPaletteEntries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IColorQuantizer_SetCustomPalette_Proxy( 
    IColorQuantizer __RPC_FAR * This,
    /* [in] */ const PALETTEENTRY __RPC_FAR *ppePalette,
    /* [in] */ LONG iFirstEntry,
    /* [in] */ LONG nEntries);


void __RPC_STUB IColorQuantizer_SetCustomPalette_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IColorQuantizer_SetPaletteGenerationMode_Proxy( 
    IColorQuantizer __RPC_FAR * This,
    /* [in] */ LONG ePaletteMode);


void __RPC_STUB IColorQuantizer_SetPaletteGenerationMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IColorQuantizer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_bmio_0265 */
/* [local] */ 

typedef 
enum _BMALPHAADDMODE
    {	BMALPHAADD_OPAQUE	= 0,
	BMALPHAADD_CONSTANT	= 1
    }	BMALPHAADDMODE;



extern RPC_IF_HANDLE __MIDL_itf_bmio_0265_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_bmio_0265_v0_0_s_ifspec;

#ifndef __IAlphaAdd_INTERFACE_DEFINED__
#define __IAlphaAdd_INTERFACE_DEFINED__

/* interface IAlphaAdd */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IAlphaAdd;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3B01E55B-F65E-11D1-8EE0-00C04FB68D60")
    IAlphaAdd : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAlphaAddMode( 
            /* [in] */ BMALPHAADDMODE eMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConstantAlpha( 
            /* [in] */ BYTE bAlpha) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAlphaAddVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAlphaAdd __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAlphaAdd __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAlphaAdd __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAlphaAddMode )( 
            IAlphaAdd __RPC_FAR * This,
            /* [in] */ BMALPHAADDMODE eMode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetConstantAlpha )( 
            IAlphaAdd __RPC_FAR * This,
            /* [in] */ BYTE bAlpha);
        
        END_INTERFACE
    } IAlphaAddVtbl;

    interface IAlphaAdd
    {
        CONST_VTBL struct IAlphaAddVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAlphaAdd_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAlphaAdd_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAlphaAdd_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAlphaAdd_SetAlphaAddMode(This,eMode)	\
    (This)->lpVtbl -> SetAlphaAddMode(This,eMode)

#define IAlphaAdd_SetConstantAlpha(This,bAlpha)	\
    (This)->lpVtbl -> SetConstantAlpha(This,bAlpha)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAlphaAdd_SetAlphaAddMode_Proxy( 
    IAlphaAdd __RPC_FAR * This,
    /* [in] */ BMALPHAADDMODE eMode);


void __RPC_STUB IAlphaAdd_SetAlphaAddMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAlphaAdd_SetConstantAlpha_Proxy( 
    IAlphaAdd __RPC_FAR * This,
    /* [in] */ BYTE bAlpha);


void __RPC_STUB IAlphaAdd_SetConstantAlpha_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAlphaAdd_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_bmio_0266 */
/* [local] */ 

typedef 
enum _BMALPHAREMOVEMODE
    {	BMALPHAREMOVE_DROP	= 0,
	BMALPHAREMOVE_BLEND	= 1
    }	BMALPHAREMOVEMODE;



extern RPC_IF_HANDLE __MIDL_itf_bmio_0266_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_bmio_0266_v0_0_s_ifspec;

#ifndef __IAlphaRemove_INTERFACE_DEFINED__
#define __IAlphaRemove_INTERFACE_DEFINED__

/* interface IAlphaRemove */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IAlphaRemove;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4038C2CF-F110-11D1-8EDD-00C04FB68D60")
    IAlphaRemove : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAlphaRemoveMode( 
            /* [in] */ BMALPHAREMOVEMODE eMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBlendColor( 
            /* [in] */ RGBQUAD rgbColor) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAlphaRemoveVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAlphaRemove __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAlphaRemove __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAlphaRemove __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAlphaRemoveMode )( 
            IAlphaRemove __RPC_FAR * This,
            /* [in] */ BMALPHAREMOVEMODE eMode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBlendColor )( 
            IAlphaRemove __RPC_FAR * This,
            /* [in] */ RGBQUAD rgbColor);
        
        END_INTERFACE
    } IAlphaRemoveVtbl;

    interface IAlphaRemove
    {
        CONST_VTBL struct IAlphaRemoveVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAlphaRemove_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAlphaRemove_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAlphaRemove_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAlphaRemove_SetAlphaRemoveMode(This,eMode)	\
    (This)->lpVtbl -> SetAlphaRemoveMode(This,eMode)

#define IAlphaRemove_SetBlendColor(This,rgbColor)	\
    (This)->lpVtbl -> SetBlendColor(This,rgbColor)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAlphaRemove_SetAlphaRemoveMode_Proxy( 
    IAlphaRemove __RPC_FAR * This,
    /* [in] */ BMALPHAREMOVEMODE eMode);


void __RPC_STUB IAlphaRemove_SetAlphaRemoveMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAlphaRemove_SetBlendColor_Proxy( 
    IAlphaRemove __RPC_FAR * This,
    /* [in] */ RGBQUAD rgbColor);


void __RPC_STUB IAlphaRemove_SetBlendColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAlphaRemove_INTERFACE_DEFINED__ */


#ifndef __IBitmapNotify_INTERFACE_DEFINED__
#define __IBitmapNotify_INTERFACE_DEFINED__

/* interface IBitmapNotify */
/* [object][unique][helpstring][uuid][local] */ 


EXTERN_C const IID IID_IBitmapNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B6E7DA76-E074-11D1-8ECA-00C04FB68D60")
    IBitmapNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnNewColorSpaceConverter( 
            /* [in] */ IColorSpaceConverter __RPC_FAR *pConverter,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnNewFormatConverter( 
            /* [in] */ IBitmapFormatConverter __RPC_FAR *pConverter) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBitmapNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBitmapNotify __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBitmapNotify __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBitmapNotify __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnNewColorSpaceConverter )( 
            IBitmapNotify __RPC_FAR * This,
            /* [in] */ IColorSpaceConverter __RPC_FAR *pConverter,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnNewFormatConverter )( 
            IBitmapNotify __RPC_FAR * This,
            /* [in] */ IBitmapFormatConverter __RPC_FAR *pConverter);
        
        END_INTERFACE
    } IBitmapNotifyVtbl;

    interface IBitmapNotify
    {
        CONST_VTBL struct IBitmapNotifyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBitmapNotify_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBitmapNotify_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBitmapNotify_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBitmapNotify_OnNewColorSpaceConverter(This,pConverter,dwFlags)	\
    (This)->lpVtbl -> OnNewColorSpaceConverter(This,pConverter,dwFlags)

#define IBitmapNotify_OnNewFormatConverter(This,pConverter)	\
    (This)->lpVtbl -> OnNewFormatConverter(This,pConverter)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBitmapNotify_OnNewColorSpaceConverter_Proxy( 
    IBitmapNotify __RPC_FAR * This,
    /* [in] */ IColorSpaceConverter __RPC_FAR *pConverter,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IBitmapNotify_OnNewColorSpaceConverter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBitmapNotify_OnNewFormatConverter_Proxy( 
    IBitmapNotify __RPC_FAR * This,
    /* [in] */ IBitmapFormatConverter __RPC_FAR *pConverter);


void __RPC_STUB IBitmapNotify_OnNewFormatConverter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBitmapNotify_INTERFACE_DEFINED__ */


#ifndef __IStdBitmapNotify_INTERFACE_DEFINED__
#define __IStdBitmapNotify_INTERFACE_DEFINED__

/* interface IStdBitmapNotify */
/* [object][unique][helpstring][uuid][local] */ 


EXTERN_C const IID IID_IStdBitmapNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3B01E55C-F65E-11D1-8EE0-00C04FB68D60")
    IStdBitmapNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAlphaAddConstantAlpha( 
            /* [in] */ BYTE bAlpha) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAlphaAddMode( 
            /* [in] */ BMALPHAADDMODE eMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAlphaRemoveBlendColor( 
            /* [in] */ RGBQUAD rgbColor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAlphaRemoveMode( 
            /* [in] */ BMALPHAREMOVEMODE eMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDitherMode( 
            /* [in] */ BMDITHERMODE eMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStdBitmapNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IStdBitmapNotify __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IStdBitmapNotify __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IStdBitmapNotify __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAlphaAddConstantAlpha )( 
            IStdBitmapNotify __RPC_FAR * This,
            /* [in] */ BYTE bAlpha);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAlphaAddMode )( 
            IStdBitmapNotify __RPC_FAR * This,
            /* [in] */ BMALPHAADDMODE eMode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAlphaRemoveBlendColor )( 
            IStdBitmapNotify __RPC_FAR * This,
            /* [in] */ RGBQUAD rgbColor);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAlphaRemoveMode )( 
            IStdBitmapNotify __RPC_FAR * This,
            /* [in] */ BMALPHAREMOVEMODE eMode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDitherMode )( 
            IStdBitmapNotify __RPC_FAR * This,
            /* [in] */ BMDITHERMODE eMode);
        
        END_INTERFACE
    } IStdBitmapNotifyVtbl;

    interface IStdBitmapNotify
    {
        CONST_VTBL struct IStdBitmapNotifyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStdBitmapNotify_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStdBitmapNotify_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStdBitmapNotify_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStdBitmapNotify_SetAlphaAddConstantAlpha(This,bAlpha)	\
    (This)->lpVtbl -> SetAlphaAddConstantAlpha(This,bAlpha)

#define IStdBitmapNotify_SetAlphaAddMode(This,eMode)	\
    (This)->lpVtbl -> SetAlphaAddMode(This,eMode)

#define IStdBitmapNotify_SetAlphaRemoveBlendColor(This,rgbColor)	\
    (This)->lpVtbl -> SetAlphaRemoveBlendColor(This,rgbColor)

#define IStdBitmapNotify_SetAlphaRemoveMode(This,eMode)	\
    (This)->lpVtbl -> SetAlphaRemoveMode(This,eMode)

#define IStdBitmapNotify_SetDitherMode(This,eMode)	\
    (This)->lpVtbl -> SetDitherMode(This,eMode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IStdBitmapNotify_SetAlphaAddConstantAlpha_Proxy( 
    IStdBitmapNotify __RPC_FAR * This,
    /* [in] */ BYTE bAlpha);


void __RPC_STUB IStdBitmapNotify_SetAlphaAddConstantAlpha_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStdBitmapNotify_SetAlphaAddMode_Proxy( 
    IStdBitmapNotify __RPC_FAR * This,
    /* [in] */ BMALPHAADDMODE eMode);


void __RPC_STUB IStdBitmapNotify_SetAlphaAddMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStdBitmapNotify_SetAlphaRemoveBlendColor_Proxy( 
    IStdBitmapNotify __RPC_FAR * This,
    /* [in] */ RGBQUAD rgbColor);


void __RPC_STUB IStdBitmapNotify_SetAlphaRemoveBlendColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStdBitmapNotify_SetAlphaRemoveMode_Proxy( 
    IStdBitmapNotify __RPC_FAR * This,
    /* [in] */ BMALPHAREMOVEMODE eMode);


void __RPC_STUB IStdBitmapNotify_SetAlphaRemoveMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStdBitmapNotify_SetDitherMode_Proxy( 
    IStdBitmapNotify __RPC_FAR * This,
    /* [in] */ BMDITHERMODE eMode);


void __RPC_STUB IStdBitmapNotify_SetDitherMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStdBitmapNotify_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_bmio_0269 */
/* [local] */ 

typedef 
enum _BMCOLORSPACECONVERTERQUALITY
    {	BMCSCQ_PERFECT	= 0,
	BMCSCQ_HIGH	= 1,
	BMCSCQ_MEDIUM	= 2,
	BMCSCQ_LOW	= 3
    }	BMCOLORSPACECONVERTERQUALITY;



extern RPC_IF_HANDLE __MIDL_itf_bmio_0269_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_bmio_0269_v0_0_s_ifspec;

#ifndef __IBMGraphManager_INTERFACE_DEFINED__
#define __IBMGraphManager_INTERFACE_DEFINED__

/* interface IBMGraphManager */
/* [object][unique][helpstring][uuid][local] */ 


EXTERN_C const IID IID_IBMGraphManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A1CD76BF-AFC6-11D1-8EAE-00C04FB68D60")
    IBMGraphManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ IBitmapSource __RPC_FAR *pSource,
            /* [in] */ PCBMFORMAT pSourceFormat,
            /* [in] */ IBitmapTarget __RPC_FAR *pTarget,
            /* [in] */ PCBMFORMAT pTargetFormat,
            /* [in] */ IBitmapNotify __RPC_FAR *pNotify) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateExporter( 
            /* [in] */ REFGUID guidFileType,
            /* [retval][out] */ IBitmapExport __RPC_FAR *__RPC_FAR *ppExporter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateImporter( 
            /* [in] */ LPCOLESTR pszMIMEType,
            /* [in] */ LPCOLESTR pszExtension,
            /* [in] */ ISequentialStream __RPC_FAR *pStream,
            /* [out] */ IBitmapImport __RPC_FAR *__RPC_FAR *ppImporter,
            /* [out] */ ISequentialStream __RPC_FAR *__RPC_FAR *ppStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumFileTypes( 
            /* [retval][out] */ IEnumBMFileTypeInfo __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FlushCache( 
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBMGraphManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBMGraphManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBMGraphManager __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBMGraphManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            IBMGraphManager __RPC_FAR * This,
            /* [in] */ IBitmapSource __RPC_FAR *pSource,
            /* [in] */ PCBMFORMAT pSourceFormat,
            /* [in] */ IBitmapTarget __RPC_FAR *pTarget,
            /* [in] */ PCBMFORMAT pTargetFormat,
            /* [in] */ IBitmapNotify __RPC_FAR *pNotify);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateExporter )( 
            IBMGraphManager __RPC_FAR * This,
            /* [in] */ REFGUID guidFileType,
            /* [retval][out] */ IBitmapExport __RPC_FAR *__RPC_FAR *ppExporter);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateImporter )( 
            IBMGraphManager __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszMIMEType,
            /* [in] */ LPCOLESTR pszExtension,
            /* [in] */ ISequentialStream __RPC_FAR *pStream,
            /* [out] */ IBitmapImport __RPC_FAR *__RPC_FAR *ppImporter,
            /* [out] */ ISequentialStream __RPC_FAR *__RPC_FAR *ppStream);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumFileTypes )( 
            IBMGraphManager __RPC_FAR * This,
            /* [retval][out] */ IEnumBMFileTypeInfo __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FlushCache )( 
            IBMGraphManager __RPC_FAR * This,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IBMGraphManagerVtbl;

    interface IBMGraphManager
    {
        CONST_VTBL struct IBMGraphManagerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBMGraphManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBMGraphManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBMGraphManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBMGraphManager_Connect(This,pSource,pSourceFormat,pTarget,pTargetFormat,pNotify)	\
    (This)->lpVtbl -> Connect(This,pSource,pSourceFormat,pTarget,pTargetFormat,pNotify)

#define IBMGraphManager_CreateExporter(This,guidFileType,ppExporter)	\
    (This)->lpVtbl -> CreateExporter(This,guidFileType,ppExporter)

#define IBMGraphManager_CreateImporter(This,pszMIMEType,pszExtension,pStream,ppImporter,ppStream)	\
    (This)->lpVtbl -> CreateImporter(This,pszMIMEType,pszExtension,pStream,ppImporter,ppStream)

#define IBMGraphManager_EnumFileTypes(This,ppEnum)	\
    (This)->lpVtbl -> EnumFileTypes(This,ppEnum)

#define IBMGraphManager_FlushCache(This,dwFlags)	\
    (This)->lpVtbl -> FlushCache(This,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBMGraphManager_Connect_Proxy( 
    IBMGraphManager __RPC_FAR * This,
    /* [in] */ IBitmapSource __RPC_FAR *pSource,
    /* [in] */ PCBMFORMAT pSourceFormat,
    /* [in] */ IBitmapTarget __RPC_FAR *pTarget,
    /* [in] */ PCBMFORMAT pTargetFormat,
    /* [in] */ IBitmapNotify __RPC_FAR *pNotify);


void __RPC_STUB IBMGraphManager_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBMGraphManager_CreateExporter_Proxy( 
    IBMGraphManager __RPC_FAR * This,
    /* [in] */ REFGUID guidFileType,
    /* [retval][out] */ IBitmapExport __RPC_FAR *__RPC_FAR *ppExporter);


void __RPC_STUB IBMGraphManager_CreateExporter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBMGraphManager_CreateImporter_Proxy( 
    IBMGraphManager __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszMIMEType,
    /* [in] */ LPCOLESTR pszExtension,
    /* [in] */ ISequentialStream __RPC_FAR *pStream,
    /* [out] */ IBitmapImport __RPC_FAR *__RPC_FAR *ppImporter,
    /* [out] */ ISequentialStream __RPC_FAR *__RPC_FAR *ppStream);


void __RPC_STUB IBMGraphManager_CreateImporter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBMGraphManager_EnumFileTypes_Proxy( 
    IBMGraphManager __RPC_FAR * This,
    /* [retval][out] */ IEnumBMFileTypeInfo __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IBMGraphManager_EnumFileTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBMGraphManager_FlushCache_Proxy( 
    IBMGraphManager __RPC_FAR * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IBMGraphManager_FlushCache_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBMGraphManager_INTERFACE_DEFINED__ */


#ifndef __IDIBTarget_INTERFACE_DEFINED__
#define __IDIBTarget_INTERFACE_DEFINED__

/* interface IDIBTarget */
/* [object][unique][helpstring][uuid][local] */ 


EXTERN_C const IID IID_IDIBTarget;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("27ECF887-B791-11D1-8EB0-00C04FB68D60")
    IDIBTarget : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDIB( 
            /* [retval][out] */ void __RPC_FAR *__RPC_FAR *phBitmap) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransparentColor( 
            /* [retval][out] */ LONG __RPC_FAR *piTransparentColor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HasAlphaChannel( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCustomPalette( 
            /* [in] */ ULONG iFirstColor,
            /* [in] */ ULONG nColors,
            /* [in] */ const RGBQUAD __RPC_FAR *ppeColors) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCustomPaletteUsage( 
            /* [in] */ DWORD dwFormat,
            /* [in] */ const IRGBPALETTEUSAGE __RPC_FAR *pUsage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseDIB( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSupportedFormats( 
            /* [in] */ DWORD dwFormats) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDIBTargetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDIBTarget __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDIBTarget __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDIBTarget __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDIB )( 
            IDIBTarget __RPC_FAR * This,
            /* [retval][out] */ void __RPC_FAR *__RPC_FAR *phBitmap);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTransparentColor )( 
            IDIBTarget __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *piTransparentColor);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HasAlphaChannel )( 
            IDIBTarget __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCustomPalette )( 
            IDIBTarget __RPC_FAR * This,
            /* [in] */ ULONG iFirstColor,
            /* [in] */ ULONG nColors,
            /* [in] */ const RGBQUAD __RPC_FAR *ppeColors);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCustomPaletteUsage )( 
            IDIBTarget __RPC_FAR * This,
            /* [in] */ DWORD dwFormat,
            /* [in] */ const IRGBPALETTEUSAGE __RPC_FAR *pUsage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseDIB )( 
            IDIBTarget __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSupportedFormats )( 
            IDIBTarget __RPC_FAR * This,
            /* [in] */ DWORD dwFormats);
        
        END_INTERFACE
    } IDIBTargetVtbl;

    interface IDIBTarget
    {
        CONST_VTBL struct IDIBTargetVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDIBTarget_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDIBTarget_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDIBTarget_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDIBTarget_GetDIB(This,phBitmap)	\
    (This)->lpVtbl -> GetDIB(This,phBitmap)

#define IDIBTarget_GetTransparentColor(This,piTransparentColor)	\
    (This)->lpVtbl -> GetTransparentColor(This,piTransparentColor)

#define IDIBTarget_HasAlphaChannel(This)	\
    (This)->lpVtbl -> HasAlphaChannel(This)

#define IDIBTarget_SetCustomPalette(This,iFirstColor,nColors,ppeColors)	\
    (This)->lpVtbl -> SetCustomPalette(This,iFirstColor,nColors,ppeColors)

#define IDIBTarget_SetCustomPaletteUsage(This,dwFormat,pUsage)	\
    (This)->lpVtbl -> SetCustomPaletteUsage(This,dwFormat,pUsage)

#define IDIBTarget_ReleaseDIB(This)	\
    (This)->lpVtbl -> ReleaseDIB(This)

#define IDIBTarget_SetSupportedFormats(This,dwFormats)	\
    (This)->lpVtbl -> SetSupportedFormats(This,dwFormats)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDIBTarget_GetDIB_Proxy( 
    IDIBTarget __RPC_FAR * This,
    /* [retval][out] */ void __RPC_FAR *__RPC_FAR *phBitmap);


void __RPC_STUB IDIBTarget_GetDIB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDIBTarget_GetTransparentColor_Proxy( 
    IDIBTarget __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *piTransparentColor);


void __RPC_STUB IDIBTarget_GetTransparentColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDIBTarget_HasAlphaChannel_Proxy( 
    IDIBTarget __RPC_FAR * This);


void __RPC_STUB IDIBTarget_HasAlphaChannel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDIBTarget_SetCustomPalette_Proxy( 
    IDIBTarget __RPC_FAR * This,
    /* [in] */ ULONG iFirstColor,
    /* [in] */ ULONG nColors,
    /* [in] */ const RGBQUAD __RPC_FAR *ppeColors);


void __RPC_STUB IDIBTarget_SetCustomPalette_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDIBTarget_SetCustomPaletteUsage_Proxy( 
    IDIBTarget __RPC_FAR * This,
    /* [in] */ DWORD dwFormat,
    /* [in] */ const IRGBPALETTEUSAGE __RPC_FAR *pUsage);


void __RPC_STUB IDIBTarget_SetCustomPaletteUsage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDIBTarget_ReleaseDIB_Proxy( 
    IDIBTarget __RPC_FAR * This);


void __RPC_STUB IDIBTarget_ReleaseDIB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDIBTarget_SetSupportedFormats_Proxy( 
    IDIBTarget __RPC_FAR * This,
    /* [in] */ DWORD dwFormats);


void __RPC_STUB IDIBTarget_SetSupportedFormats_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDIBTarget_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_bmio_0271 */
/* [local] */ 





extern RPC_IF_HANDLE __MIDL_itf_bmio_0271_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_bmio_0271_v0_0_s_ifspec;

#ifndef __IDDSurfaceTarget_INTERFACE_DEFINED__
#define __IDDSurfaceTarget_INTERFACE_DEFINED__

/* interface IDDSurfaceTarget */
/* [object][unique][helpstring][uuid][local] */ 


EXTERN_C const IID IID_IDDSurfaceTarget;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8B8A10C2-D848-11d1-8EC1-00C04FB68D60")
    IDDSurfaceTarget : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSurface( 
            /* [retval][out] */ IDirectDrawSurface7 __RPC_FAR *__RPC_FAR *ppSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDirectDraw( 
            /* [in] */ IDirectDraw7 __RPC_FAR *pDirectDraw,
            /* [in] */ const DDSURFACEDESC2 __RPC_FAR *pDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSurface( 
            /* [in] */ IDirectDrawSurface7 __RPC_FAR *pSurface) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDDSurfaceTargetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDDSurfaceTarget __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDDSurfaceTarget __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDDSurfaceTarget __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSurface )( 
            IDDSurfaceTarget __RPC_FAR * This,
            /* [retval][out] */ IDirectDrawSurface7 __RPC_FAR *__RPC_FAR *ppSurface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDirectDraw )( 
            IDDSurfaceTarget __RPC_FAR * This,
            /* [in] */ IDirectDraw7 __RPC_FAR *pDirectDraw,
            /* [in] */ const DDSURFACEDESC2 __RPC_FAR *pDesc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSurface )( 
            IDDSurfaceTarget __RPC_FAR * This,
            /* [in] */ IDirectDrawSurface7 __RPC_FAR *pSurface);
        
        END_INTERFACE
    } IDDSurfaceTargetVtbl;

    interface IDDSurfaceTarget
    {
        CONST_VTBL struct IDDSurfaceTargetVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDDSurfaceTarget_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDDSurfaceTarget_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDDSurfaceTarget_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDDSurfaceTarget_GetSurface(This,ppSurface)	\
    (This)->lpVtbl -> GetSurface(This,ppSurface)

#define IDDSurfaceTarget_SetDirectDraw(This,pDirectDraw,pDesc)	\
    (This)->lpVtbl -> SetDirectDraw(This,pDirectDraw,pDesc)

#define IDDSurfaceTarget_SetSurface(This,pSurface)	\
    (This)->lpVtbl -> SetSurface(This,pSurface)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDDSurfaceTarget_GetSurface_Proxy( 
    IDDSurfaceTarget __RPC_FAR * This,
    /* [retval][out] */ IDirectDrawSurface7 __RPC_FAR *__RPC_FAR *ppSurface);


void __RPC_STUB IDDSurfaceTarget_GetSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDDSurfaceTarget_SetDirectDraw_Proxy( 
    IDDSurfaceTarget __RPC_FAR * This,
    /* [in] */ IDirectDraw7 __RPC_FAR *pDirectDraw,
    /* [in] */ const DDSURFACEDESC2 __RPC_FAR *pDesc);


void __RPC_STUB IDDSurfaceTarget_SetDirectDraw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDDSurfaceTarget_SetSurface_Proxy( 
    IDDSurfaceTarget __RPC_FAR * This,
    /* [in] */ IDirectDrawSurface7 __RPC_FAR *pSurface);


void __RPC_STUB IDDSurfaceTarget_SetSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDDSurfaceTarget_INTERFACE_DEFINED__ */


#ifndef __IDIBSource_INTERFACE_DEFINED__
#define __IDIBSource_INTERFACE_DEFINED__

/* interface IDIBSource */
/* [object][unique][helpstring][uuid][local] */ 


EXTERN_C const IID IID_IDIBSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("81B3E6EF-CE76-11D1-8EBE-00C04FB68D60")
    IDIBSource : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Go( 
            /* [in] */ const BITMAPINFO __RPC_FAR *pInfo,
            /* [in] */ DWORD dwFlags,
            /* [in] */ const void __RPC_FAR *pBits) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDIBSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDIBSource __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDIBSource __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDIBSource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Go )( 
            IDIBSource __RPC_FAR * This,
            /* [in] */ const BITMAPINFO __RPC_FAR *pInfo,
            /* [in] */ DWORD dwFlags,
            /* [in] */ const void __RPC_FAR *pBits);
        
        END_INTERFACE
    } IDIBSourceVtbl;

    interface IDIBSource
    {
        CONST_VTBL struct IDIBSourceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDIBSource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDIBSource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDIBSource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDIBSource_Go(This,pInfo,dwFlags,pBits)	\
    (This)->lpVtbl -> Go(This,pInfo,dwFlags,pBits)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDIBSource_Go_Proxy( 
    IDIBSource __RPC_FAR * This,
    /* [in] */ const BITMAPINFO __RPC_FAR *pInfo,
    /* [in] */ DWORD dwFlags,
    /* [in] */ const void __RPC_FAR *pBits);


void __RPC_STUB IDIBSource_Go_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDIBSource_INTERFACE_DEFINED__ */


#ifndef __IBMPImport_INTERFACE_DEFINED__
#define __IBMPImport_INTERFACE_DEFINED__

/* interface IBMPImport */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IBMPImport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EE725DB7-F4AB-11D1-8EDF-00C04FB68D60")
    IBMPImport : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IBMPImportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBMPImport __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBMPImport __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBMPImport __RPC_FAR * This);
        
        END_INTERFACE
    } IBMPImportVtbl;

    interface IBMPImport
    {
        CONST_VTBL struct IBMPImportVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBMPImport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBMPImport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBMPImport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBMPImport_INTERFACE_DEFINED__ */



#ifndef __BMExportLib_LIBRARY_DEFINED__
#define __BMExportLib_LIBRARY_DEFINED__

/* library BMExportLib */
/* [helpstring][version][uuid] */ 








#define	RGBA_PREMULT	( 0x1 )

#define	CSCONV_ALPHAADD	( 0x1 )

#define	CSCONV_ALPHAREMOVE	( 0x2 )

#define	CSCONV_DITHER	( 0x4 )

#define	BMGFLUSH_IMPORTERS	( 0x1 )

#define	BMGFLUSH_EXPORTERS	( 0x2 )

#define	BMGFLUSH_CONVERTERS	( 0x4 )

#define	BMGFLUSH_ALL	( BMGFLUSH_IMPORTERS | BMGFLUSH_EXPORTERS | BMGFLUSH_CONVERTERS )

#define	BMTHINT_TOPDOWN	( 0x1 )

#define	BMTHINT_BOTTOMUP	( 0x2 )

#define	BMTHINT_FULLWIDTH	( 0x4 )

#define	BMTHINT_ENTIRESURFACE	( 0x8 | BMTHINT_FULLWIDTH | BMTHINT_TOPDOWN | BMTHINT_BOTTOMUP )

#define	BMTHINT_DIRECTACCESS	( 0x10 )

#define	BMTHINT_BLOCKXALIGN	( 0x20 )

#define	BMTHINT_BLOCKYALIGN	( 0x40 )

#define	BMTHINT_PASSES	( 0x80 )

#define	DIBTARGET_1BPP	( 0x1 )

#define	DIBTARGET_2BPP	( 0x2 )

#define	DIBTARGET_4BPP	( 0x4 )

#define	DIBTARGET_8BPP	( 0x8 )

#define	DIBTARGET_16BPP	( 0x10 )

#define	DIBTARGET_24BPP	( 0x20 )

#define	DIBTARGET_32BPP	( 0x40 )

#define	DIBTARGET_32BPP_ALPHA	( 0x80 )

#define	DIBTARGET_GS1	( 0x10000 )

#define	DIBTARGET_GS2	( 0x20000 )

#define	DIBTARGET_GS4	( 0x40000 )

#define	DIBTARGET_GS8	( 0x80000 )

#define	DIBTARGET_ANYGS	( DIBTARGET_GS1 | DIBTARGET_GS2 | DIBTARGET_GS4 | DIBTARGET_GS8 )

#define	DIBTARGET_ANYINDEXED	( DIBTARGET_1BPP | DIBTARGET_2BPP | DIBTARGET_4BPP | DIBTARGET_8BPP )

#define	DIBTARGET_ANYRGB	( DIBTARGET_16BPP | DIBTARGET_24BPP | DIBTARGET_32BPP )

#define	DIBTARGET_ANY	( DIBTARGET_ANYRGB | DIBTARGET_ANYINDEXED | DIBTARGET_32BPP_ALPHA )

#define	DIBSOURCE_ALPHA	( 0x1 )

typedef 
enum _PNGCOLORSPACE
    {	PNG_COLORSPACE_AUTO	= 0,
	PNG_COLORSPACE_RGB	= 1,
	PNG_COLORSPACE_RGBA	= 2,
	PNG_COLORSPACE_GRAYSCALE	= 3,
	PNG_COLORSPACE_GRAYSCALEA	= 4,
	PNG_COLORSPACE_INDEXED	= 5
    }	PNGCOLORSPACE;

typedef 
enum _PNG_COMPRESSIONLEVEL
    {	PNG_COMPRESSION_NORMAL	= 0,
	PNG_COMPRESSION_FASTEST	= 1,
	PNG_COMPRESSION_SMALLEST	= 2
    }	PNGCOMPRESSIONLEVEL;

typedef 
enum _PNG_INTERLACING
    {	PNG_INTERLACING_NONE	= 0,
	PNG_INTERLACING_ADAM7	= 1
    }	PNG_INTERLACING;

#define	COLORSPACEINFO_HASALPHA	( 0x1 )

typedef 
enum _BMPALGENMODE
    {	BMPALGEN_HALFTONE	= 0,
	BMPALGEN_CUSTOM	= 1,
	BMPALGEN_OPTIMAL	= 2
    }	BMPALGENMODE;


EXTERN_C const IID LIBID_BMExportLib;

EXTERN_C const CLSID CLSID_PNGPage;

#ifdef __cplusplus

class DECLSPEC_UUID("EBCB6E58-24AD-11d1-8E32-00C04FB68D60")
PNGPage;
#endif

EXTERN_C const CLSID CLSID_PNGExport;

#ifdef __cplusplus

class DECLSPEC_UUID("244FB8EB-23C6-11D1-8E31-00C04FB68D60")
PNGExport;
#endif

EXTERN_C const CLSID CLSID_JPEGPage;

#ifdef __cplusplus

class DECLSPEC_UUID("63DD5C2A-288D-11d1-8E33-00C04FB68D60")
JPEGPage;
#endif

EXTERN_C const CLSID CLSID_JPEGExport;

#ifdef __cplusplus

class DECLSPEC_UUID("3CD872DC-2643-11d1-8E33-00C04FB68D60")
JPEGExport;
#endif

EXTERN_C const CLSID CLSID_GIFImport;

#ifdef __cplusplus

class DECLSPEC_UUID("32D4F06D-1DDB-11D2-8EED-00C04FB68D60")
GIFImport;
#endif

EXTERN_C const CLSID CLSID_GIFExport;

#ifdef __cplusplus

class DECLSPEC_UUID("4ef1e486-a4ea-11d2-8f10-00c04fb68d60")
GIFExport;
#endif

EXTERN_C const CLSID CLSID_BMPExport;

#ifdef __cplusplus

class DECLSPEC_UUID("53B727A3-36BC-11D1-8E43-00C04FB68D60")
BMPExport;
#endif

EXTERN_C const CLSID CLSID_Ditherer;

#ifdef __cplusplus

class DECLSPEC_UUID("B69C56DE-7588-11D1-8E73-00C04FB68D60")
Ditherer;
#endif

EXTERN_C const CLSID CLSID_JPEGImport;

#ifdef __cplusplus

class DECLSPEC_UUID("B69C56E0-7588-11D1-8E73-00C04FB68D60")
JPEGImport;
#endif

EXTERN_C const CLSID CLSID_PNGImport;

#ifdef __cplusplus

class DECLSPEC_UUID("D25EB70E-7810-11D1-8E75-00C04FB68D60")
PNGImport;
#endif

EXTERN_C const CLSID CLSID_BMGraphManager;

#ifdef __cplusplus

class DECLSPEC_UUID("A1CD76C0-AFC6-11D1-8EAE-00C04FB68D60")
BMGraphManager;
#endif

EXTERN_C const CLSID CLSID_GSToRGB;

#ifdef __cplusplus

class DECLSPEC_UUID("A1CD76C2-AFC6-11D1-8EAE-00C04FB68D60")
GSToRGB;
#endif

EXTERN_C const CLSID CLSID_GSConverter;

#ifdef __cplusplus

class DECLSPEC_UUID("07CEAF1C-B483-11D1-8EB0-00C04FB68D60")
GSConverter;
#endif

EXTERN_C const CLSID CLSID_RGBConverter;

#ifdef __cplusplus

class DECLSPEC_UUID("27ECF886-B791-11D1-8EB0-00C04FB68D60")
RGBConverter;
#endif

EXTERN_C const CLSID CLSID_DIBTarget;

#ifdef __cplusplus

class DECLSPEC_UUID("27ECF888-B791-11D1-8EB0-00C04FB68D60")
DIBTarget;
#endif

EXTERN_C const CLSID CLSID_DDSurfaceTarget;

#ifdef __cplusplus

class DECLSPEC_UUID("CC0C1224-91E0-11D1-8E86-00C04FB68D60")
DDSurfaceTarget;
#endif

EXTERN_C const CLSID CLSID_IRGBToRGB;

#ifdef __cplusplus

class DECLSPEC_UUID("988CEECE-B93F-11D1-8EB0-00C04FB68D60")
IRGBToRGB;
#endif

EXTERN_C const CLSID CLSID_RGBToGS;

#ifdef __cplusplus

class DECLSPEC_UUID("929FC2B2-BA06-11D1-8EB0-00C04FB68D60")
RGBToGS;
#endif

EXTERN_C const CLSID CLSID_RGBAToRGB;

#ifdef __cplusplus

class DECLSPEC_UUID("885878C2-C455-11D1-8EB7-00C04FB68D60")
RGBAToRGB;
#endif

EXTERN_C const CLSID CLSID_RGBToRGBA;

#ifdef __cplusplus

class DECLSPEC_UUID("B2DDD5A3-C572-11D1-8EBB-00C04FB68D60")
RGBToRGBA;
#endif

EXTERN_C const CLSID CLSID_DXT1ToRGBA;

#ifdef __cplusplus

class DECLSPEC_UUID("79d1842e-6f14-11d2-8f06-00c04fb68d60")
DXT1ToRGBA;
#endif

EXTERN_C const CLSID CLSID_IRGBConverter;

#ifdef __cplusplus

class DECLSPEC_UUID("B2DDD5A6-C572-11D1-8EBB-00C04FB68D60")
IRGBConverter;
#endif

EXTERN_C const CLSID CLSID_DIBSource;

#ifdef __cplusplus

class DECLSPEC_UUID("81B3E6F0-CE76-11D1-8EBE-00C04FB68D60")
DIBSource;
#endif

EXTERN_C const CLSID CLSID_StdBitmapNotify;

#ifdef __cplusplus

class DECLSPEC_UUID("B6E7DA78-E074-11D1-8ECA-00C04FB68D60")
StdBitmapNotify;
#endif

EXTERN_C const CLSID CLSID_BMPImport;

#ifdef __cplusplus

class DECLSPEC_UUID("EE725DB8-F4AB-11D1-8EDF-00C04FB68D60")
BMPImport;
#endif

EXTERN_C const CLSID CLSID_DXT2ToRGBA;

#ifdef __cplusplus

class DECLSPEC_UUID("BB69F264-6F1A-11D2-8F06-00C04FB68D60")
DXT2ToRGBA;
#endif
#endif /* __BMExportLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atlmfc\cstringt.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CSTRINGT.H - Framework-independent, templateable string class

#ifndef __CSTRINGT_H__
#define __CSTRINGT_H__

#pragma once

#pragma warning(disable:4786)	// avoid 255-character limit warnings

#ifdef _MANAGED
#include <vcclr.h>  // For PtrToStringChars
#endif

#include <atlsimpstr.h>

#include <objbase.h>
#include <oleauto.h>

#include <stddef.h>
#ifndef _INC_NEW
#include <new.h>
#endif
#include <stdio.h>
#include <limits.h>
#ifndef _ATL_NO_DEBUG_CRT
#include <crtdbg.h>
#endif
#ifndef _ATL_MIN_CRT
#include <mbstring.h>
#endif

#ifdef _ATL_CSTRING_EXPLICIT_CONSTRUCTORS
#define CSTRING_EXPLICIT explicit
#else
#define CSTRING_EXPLICIT
#endif

#include <atlconv.h>
#include <atlmem.h>

#pragma push_macro("new")
#undef new

/////////////////////////////////////////////////////////////////////////////
// Naming conventions:
//    The term "length" can be confusing when dealing with ANSI, Unicode, and
//    MBCS character sets, so this file will use the following naming 
//    conventions to differentiate between the different meanings of 
//    "length":
//
//    'Byte Length' - Length of a buffer in bytes, regardless of character 
//       size
//    'Char Length' - Number of distinct characters in string.  For wide-
//       character strings, this is equivalent to half the 'Byte Length'.  
//       For ANSI strings, this is equivalent to the 'Byte Length'.  For MBCS
//       strings, 'Char Length' counts a lead-byte/trail-byte combination
//       as one character.
//    'Length' - When neither of the above terms is used, 'Length' refers to 
//       length in XCHARs, which is equal to 'Byte Length'/sizeof(XCHAR).
/////////////////////////////////////////////////////////////////////////////

namespace ATL
{

/////////////////////////////////////////////////////////////////////////////
// inline helpers

inline int _wcstombsz(char* mbstr, const wchar_t* wcstr, ULONG count) throw()
{
	// count is number of bytes
	if (count == 0 && mbstr != NULL)
		return 0;

	int result = ::WideCharToMultiByte(_AtlGetConversionACP(), 0, wcstr, -1,
		mbstr, count, NULL, NULL);
	ATLASSERT(mbstr == NULL || result <= (int)count);
	return result;
}

inline int _mbstowcsz(wchar_t* wcstr, const char* mbstr, ULONG count) throw()
{
	// count is number of wchar_t's
	if (count == 0 && wcstr != NULL)
		return 0;

	int result = ::MultiByteToWideChar(_AtlGetConversionACP(), 0, mbstr, -1,
		wcstr, count);
	ATLASSERT(wcstr == NULL || result <= (int)count);
	if ((result > 0) && (wcstr != NULL))
		wcstr[result-1] = 0;
	return result;
}

#if !defined(_UNICODE) || defined(_CSTRING_ALWAYS_THUNK)
// Win9x doesn't support Unicode versions of these useful string functions.
// If the app was built without _UNICODE defined, we thunk at runtime to
// either the real Unicode implementation (on NT), or a conversion helper
// (on Win9x).

inline void _AtlInstallStringThunk(void** ppThunk, void* pfnWin9x, void* pfnNT) throw()
{
	static bool s_bWin9x = (::GetVersion()&0x80000000) != 0;

	void* pfn;
	if (s_bWin9x)
		pfn = pfnWin9x;
	else
	{
#ifdef _CSTRING_ALWAYS_THUNK
		pfn = pfnWin9x;
		(void)pfnNT;
#else
		pfn = pfnNT;
#endif
	}
	InterlockedExchangePointer(ppThunk, pfn);
}

typedef int (WINAPI* ATLCOMPARESTRINGW)(LCID, DWORD, LPCWSTR, int, LPCWSTR, int);
typedef BOOL (WINAPI* ATLGETSTRINGTYPEEXW)(LCID, DWORD, LPCWSTR, int, LPWORD);
typedef int (WINAPI* ATLLSTRCMPIW)(LPCWSTR, LPCWSTR);
typedef LPWSTR (WINAPI* ATLCHARLOWERW)(LPWSTR);
typedef LPWSTR (WINAPI* ATLCHARUPPERW)(LPWSTR);
typedef DWORD (WINAPI* ATLGETENVIRONMENTVARIABLEW)(LPCWSTR, LPWSTR, DWORD);

struct _AtlStringThunks
{
	ATLCOMPARESTRINGW pfnCompareStringW;
	ATLGETSTRINGTYPEEXW pfnGetStringTypeExW;
	ATLLSTRCMPIW pfnlstrcmpiW;
	ATLCHARLOWERW pfnCharLowerW;
	ATLCHARUPPERW pfnCharUpperW;
	ATLGETENVIRONMENTVARIABLEW pfnGetEnvironmentVariableW;
};

extern _AtlStringThunks _strthunks;

inline DWORD WINAPI GetEnvironmentVariableWFake(LPCWSTR pszName, 
	LPWSTR pszBuffer, DWORD nSize)
{
	USES_CONVERSION;
	ULONG nSizeA;
	ULONG nSizeW;
	LPSTR pszNameA;
	LPSTR pszBufferA;

	pszNameA = W2A(pszName);
	nSizeA = ::GetEnvironmentVariableA(pszNameA, NULL, 0);
	if (nSizeA == 0)
		return 0;

	pszBufferA = LPSTR(_alloca(nSizeA*2));
	::GetEnvironmentVariableA(pszNameA, pszBufferA, nSizeA);

	nSizeW = ::MultiByteToWideChar(_AtlGetConversionACP(), 0, pszBufferA, -1, NULL, 0);
	if (nSize == 0)
		return nSizeW;
	ATLASSERT(nSize >= nSizeW);
	::MultiByteToWideChar(_AtlGetConversionACP(), 0, pszBufferA, -1, pszBuffer, nSizeW);

	return nSizeW;
}

inline DWORD WINAPI GetEnvironmentVariableWThunk(LPCWSTR pszName, 
	LPWSTR pszBuffer, DWORD nSize)
{
	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnGetEnvironmentVariableW), 
		GetEnvironmentVariableWFake, ::GetEnvironmentVariableW);

	return _strthunks.pfnGetEnvironmentVariableW(pszName, pszBuffer, nSize);
}

inline int WINAPI CompareStringWFake(LCID lcid, DWORD dwFlags, 
	LPCWSTR pszString1, int nLength1, LPCWSTR pszString2, int nLength2)
{
	USES_CONVERSION;

	return ::CompareStringA(lcid, dwFlags, W2A(pszString1), nLength1, W2A(pszString2), nLength2);
}

inline int WINAPI CompareStringWThunk(LCID lcid, DWORD dwFlags, 
	LPCWSTR pszString1, int nLength1, LPCWSTR pszString2, int nLength2)
{
	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnCompareStringW), CompareStringWFake, ::CompareStringW);

	return _strthunks.pfnCompareStringW(lcid, dwFlags, pszString1, nLength1, pszString2, nLength2);
}

inline BOOL WINAPI GetStringTypeExWFake(LCID lcid, DWORD dwInfoType, LPCWSTR pszSrc,
	int nLength, LPWORD pwCharType)
{
	int nLengthA;
	LPSTR pszA;

	nLengthA = ::WideCharToMultiByte(_AtlGetConversionACP(), 0, pszSrc, nLength, NULL, 0, NULL, NULL);
	pszA = LPSTR(_alloca(nLengthA*sizeof(char)));
	::WideCharToMultiByte(_AtlGetConversionACP(), 0, pszSrc, nLength, pszA, nLengthA, NULL, NULL);

	if (nLength == -1)
		nLengthA = -1;

	return ::GetStringTypeExA(lcid, dwInfoType, pszA, nLengthA, pwCharType);
}

inline BOOL WINAPI GetStringTypeExWThunk(LCID lcid, DWORD dwInfoType, LPCWSTR pszSrc,
	int nLength, LPWORD pwCharType)
{
	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnGetStringTypeExW), GetStringTypeExWFake, ::GetStringTypeExW);

	return _strthunks.pfnGetStringTypeExW(lcid, dwInfoType, pszSrc, nLength, pwCharType);
}

inline int WINAPI lstrcmpiWFake(LPCWSTR psz1, LPCWSTR psz2)
{
	USES_CONVERSION;

	return ::lstrcmpiA(W2A(psz1), W2A(psz2));
}

inline int WINAPI lstrcmpiWThunk(LPCWSTR psz1, LPCWSTR psz2)
{
	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnlstrcmpiW), lstrcmpiWFake, ::lstrcmpiW);

	return _strthunks.pfnlstrcmpiW(psz1, psz2);
}

inline LPWSTR WINAPI CharLowerWFake(LPWSTR psz)
{
	USES_CONVERSION;
	LPSTR pszA;

	pszA = W2A(psz);
	::CharLowerA(pszA);
	wcscpy(psz, A2W(pszA));

	return psz;
}

inline LPWSTR WINAPI CharLowerWThunk(LPWSTR psz)
{
	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnCharLowerW), CharLowerWFake, ::CharLowerW);

	return _strthunks.pfnCharLowerW(psz);
}

inline LPWSTR WINAPI CharUpperWFake(LPWSTR psz)
{
	USES_CONVERSION;
	LPSTR pszA;

	pszA = W2A(psz);
	::CharUpperA(pszA);
	wcscpy(psz, A2W(pszA));

	return psz;
}

inline LPWSTR WINAPI CharUpperWThunk(LPWSTR psz)
{
	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnCharUpperW), CharUpperWFake, ::CharUpperW);

	return _strthunks.pfnCharUpperW(psz);
}

__declspec(selectany) _AtlStringThunks _strthunks =
{
	CompareStringWThunk,
	GetStringTypeExWThunk,
	lstrcmpiWThunk,
	CharLowerWThunk,
	CharUpperWThunk,
	GetEnvironmentVariableWThunk
};

#endif  // !_UNICODE

/////////////////////////////////////////////////////////////////////////////
//

#ifndef _ATL_MIN_CRT
template< typename _CharType = char >
class ChTraitsCRT :
	public ChTraitsBase< _CharType >
{
public:
	static char* CharNext( const char* p ) throw()
	{
		return reinterpret_cast< char* >( _mbsinc( reinterpret_cast< const unsigned char* >( p ) ) );
	}

	static int IsDigit( char ch ) throw()
	{
		return _ismbcdigit( ch );
	}

	static int IsSpace( char ch ) throw()
	{
		return _ismbcspace( ch );
	}

	static int StringCompare( LPCSTR pszA, LPCSTR pszB ) throw()
	{
		return _mbscmp( reinterpret_cast< const unsigned char* >( pszA ), reinterpret_cast< const unsigned char* >( pszB ) );
	}

	static int StringCompareIgnore( LPCSTR pszA, LPCSTR pszB ) throw()
	{
		return _mbsicmp( reinterpret_cast< const unsigned char* >( pszA ), reinterpret_cast< const unsigned char* >( pszB ) );
	}

	static int StringCollate( LPCSTR pszA, LPCSTR pszB ) throw()
	{
		return _mbscoll( reinterpret_cast< const unsigned char* >( pszA ), reinterpret_cast< const unsigned char* >( pszB ) );
	}

	static int StringCollateIgnore( LPCSTR pszA, LPCSTR pszB ) throw()
	{
		return _mbsicoll( reinterpret_cast< const unsigned char* >( pszA ), reinterpret_cast< const unsigned char* >( pszB ) );
	}

	static LPSTR StringFindString( LPCSTR pszBlock, LPCSTR pszMatch ) throw()
	{
		return reinterpret_cast< LPSTR >( _mbsstr( reinterpret_cast< const unsigned char* >( pszBlock ),
			reinterpret_cast< const unsigned char* >( pszMatch ) ) );
	}

	static LPSTR StringFindChar( LPCSTR pszBlock, char chMatch ) throw()
	{
		return reinterpret_cast< LPSTR >( _mbschr( reinterpret_cast< const unsigned char* >( pszBlock ), chMatch ) );
	}

	static LPSTR StringFindCharRev( LPCSTR psz, char ch ) throw()
	{
		return reinterpret_cast< LPSTR >( _mbsrchr( reinterpret_cast< const unsigned char* >( psz ), ch ) );
	}

	static LPSTR StringScanSet( LPCSTR pszBlock, LPCSTR pszMatch ) throw()
	{
		return reinterpret_cast< LPSTR >( _mbspbrk( reinterpret_cast< const unsigned char* >( pszBlock ),
			reinterpret_cast< const unsigned char* >( pszMatch ) ) );
	}

	static int StringSpanIncluding( LPCSTR pszBlock, LPCSTR pszSet ) throw()
	{
		return (int)_mbsspn( reinterpret_cast< const unsigned char* >( pszBlock ), reinterpret_cast< const unsigned char* >( pszSet ) );
	}

	static int StringSpanExcluding( LPCSTR pszBlock, LPCSTR pszSet ) throw()
	{
		return (int)_mbscspn( reinterpret_cast< const unsigned char* >( pszBlock ), reinterpret_cast< const unsigned char* >( pszSet ) );
	}

	static LPSTR StringUppercase( LPSTR psz ) throw()
	{
		return reinterpret_cast< LPSTR >( _mbsupr( reinterpret_cast< unsigned char* >( psz ) ) );
	}

	static LPSTR StringLowercase( LPSTR psz ) throw()
	{
		return reinterpret_cast< LPSTR >( _mbslwr( reinterpret_cast< unsigned char* >( psz ) ) );
	}

	static LPSTR StringReverse( LPSTR psz ) throw()
	{
		return reinterpret_cast< LPSTR >( _mbsrev( reinterpret_cast< unsigned char* >( psz ) ) );
	}

	static int GetFormattedLength( LPCSTR pszFormat, va_list args ) throw()
	{
		return _vscprintf( pszFormat, args );
	}

	static int Format( LPSTR pszBuffer, LPCSTR pszFormat, va_list args ) throw()
	{
		return vsprintf( pszBuffer, pszFormat, args );
	}

	static int GetBaseTypeLength( LPCSTR pszSrc ) throw()
	{
		// Returns required buffer length in XCHARs
		return int( strlen( pszSrc ) );
	}

	static int GetBaseTypeLength( LPCSTR pszSrc, int nLength ) throw()
	{
		(void)pszSrc;
		// Returns required buffer length in XCHARs
		return nLength;
	}

	static int GetBaseTypeLength( LPCWSTR pszSource ) throw()
	{
		// Returns required buffer length in XCHARs
		return ::WideCharToMultiByte( _AtlGetConversionACP(), 0, pszSource, -1, NULL, 0, NULL, NULL )-1;
	}

	static int GetBaseTypeLength( LPCWSTR pszSource, int nLength ) throw()
	{
		// Returns required buffer length in XCHARs
		return ::WideCharToMultiByte( _AtlGetConversionACP(), 0, pszSource, nLength, NULL, 0, NULL, NULL );
	}

	static void ConvertToBaseType( LPSTR pszDest, int nDestLength,
		LPCSTR pszSrc, int nSrcLength = -1 ) throw()
	{
		(void)nSrcLength;
		// nLen is in XCHARs
		memcpy( pszDest, pszSrc, nDestLength*sizeof( char ) );
	}

	static void ConvertToBaseType( LPSTR pszDest, int nDestLength,
		LPCWSTR pszSrc, int nSrcLength = -1 ) throw()
	{
		// nLen is in XCHARs
		::WideCharToMultiByte( _AtlGetConversionACP(), 0, pszSrc, nSrcLength, pszDest, nDestLength, NULL, NULL );
	}

	static void ConvertToOem( LPSTR psz ) throw()
	{
		::AnsiToOem( psz, psz );
	}

	static void ConvertToAnsi( LPSTR psz ) throw()
	{
		::OemToAnsi( psz, psz );
	}

	static void FloodCharacters( char ch, int nLength, char* pch ) throw()
	{
		// nLength is in XCHARs
		memset( pch, ch, nLength );
	}

	static BSTR AllocSysString( const char* pchData, int nDataLength ) throw()
	{
		int nLen = ::MultiByteToWideChar( _AtlGetConversionACP(), 0, pchData, nDataLength,
			NULL, NULL );
		BSTR bstr = ::SysAllocStringLen( NULL, nLen );
		if( bstr != NULL )
		{
			::MultiByteToWideChar( _AtlGetConversionACP(), 0, pchData, nDataLength,
				bstr, nLen );
		}

		return bstr;
	}

	static BOOL ReAllocSysString( const char* pchData, BSTR* pbstr, int nDataLength ) throw()
	{
		int nLen = ::MultiByteToWideChar( _AtlGetConversionACP(), 0, pchData, nDataLength, NULL, NULL );
		BOOL bSuccess = ::SysReAllocStringLen( pbstr, NULL, nLen );
		if( bSuccess )
		{
			::MultiByteToWideChar( _AtlGetConversionACP(), 0, pchData, nDataLength, *pbstr, nLen );
		}

		return bSuccess;
	}

	static DWORD FormatMessage( DWORD dwFlags, LPCVOID pSource,
		DWORD dwMessageID, DWORD dwLanguageID, LPSTR pszBuffer,
		DWORD nSize, va_list* pArguments ) throw()
	{
		return ::FormatMessageA( dwFlags, pSource, dwMessageID, dwLanguageID,
				pszBuffer, nSize, pArguments );
	}

	static int SafeStringLen( LPCSTR psz ) throw()
	{
		// returns length in bytes
		return (psz != NULL) ? int( strlen( psz ) ) : 0;
	}

	static int SafeStringLen( LPCWSTR psz ) throw()
	{
		// returns length in wchar_ts
		return (psz != NULL) ? int( wcslen( psz ) ) : 0;
	}

	static int GetCharLen( const wchar_t* pch ) throw()
	{
		(void)pch;
		// returns char length
		return 1;
	}

	static int GetCharLen( const char* pch ) throw()
	{
		// returns char length
		return int( _mbclen( reinterpret_cast< const unsigned char* >( pch ) ) );
	}

	static DWORD GetEnvironmentVariable( LPCSTR pszVar,
		LPSTR pszBuffer, DWORD dwSize ) throw()
	{
		return ::GetEnvironmentVariableA( pszVar, pszBuffer, dwSize );
	}
};

// specialization for wchar_t
template<>
class ChTraitsCRT< wchar_t > :
	public ChTraitsBase< wchar_t >
{
#if defined(_UNICODE) && !defined(_CSTRING_ALWAYS_THUNK)
	static DWORD _GetEnvironmentVariableW( LPCWSTR pszName, LPWSTR pszBuffer, DWORD nSize ) throw()
	{
		return ::GetEnvironmentVariableW( pszName, pszBuffer, nSize );
	}
#else  // !_UNICODE
	static DWORD WINAPI _GetEnvironmentVariableW( LPCWSTR pszName, 
		LPWSTR pszBuffer, DWORD nSize ) throw()
	{
		return _strthunks.pfnGetEnvironmentVariableW( pszName, pszBuffer, nSize );
	}
#endif  // !_UNICODE

public:
	static LPWSTR CharNext( LPCWSTR psz ) throw()
	{
		return const_cast< LPWSTR >( psz+1 );
	}

	static int IsDigit( wchar_t ch ) throw()
	{
		return iswdigit( ch );
	}

	static int IsSpace( wchar_t ch ) throw()
	{
		return iswspace( ch );
	}

	static int StringCompare( LPCWSTR pszA, LPCWSTR pszB ) throw()
	{
		return wcscmp( pszA, pszB );
	}

	static int StringCompareIgnore( LPCWSTR pszA, LPCWSTR pszB ) throw()
	{
		return _wcsicmp( pszA, pszB );
	}

	static int StringCollate( LPCWSTR pszA, LPCWSTR pszB ) throw()
	{
		return wcscoll( pszA, pszB );
	}

	static int StringCollateIgnore( LPCWSTR pszA, LPCWSTR pszB ) throw()
	{
		return _wcsicoll( pszA, pszB );
	}

	static LPWSTR StringFindString( LPCWSTR pszBlock, LPCWSTR pszMatch ) throw()
	{
		return wcsstr( pszBlock, pszMatch );
	}

	static LPWSTR StringFindChar( LPCWSTR pszBlock, wchar_t chMatch ) throw()
	{
		return wcschr( pszBlock, chMatch );
	}

	static LPWSTR StringFindCharRev( LPCWSTR psz, wchar_t ch ) throw()
	{
		return wcsrchr( psz, ch );
	}

	static LPWSTR StringScanSet( LPCWSTR pszBlock, LPCWSTR pszMatch ) throw()
	{
		return wcspbrk( pszBlock, pszMatch );
	}

	static int StringSpanIncluding( LPCWSTR pszBlock, LPCWSTR pszSet ) throw()
	{
		return (int)wcsspn( pszBlock, pszSet );
	}

	static int StringSpanExcluding( LPCWSTR pszBlock, LPCWSTR pszSet ) throw()
	{
		return (int)wcscspn( pszBlock, pszSet );
	}

	static LPWSTR StringUppercase( LPWSTR psz ) throw()
	{
		return _wcsupr( psz );
	}

	static LPWSTR StringLowercase( LPWSTR psz ) throw()
	{
		return _wcslwr( psz );
	}

	static LPWSTR StringReverse( LPWSTR psz ) throw()
	{
		return _wcsrev( psz );
	}

	static int GetFormattedLength( LPCWSTR pszFormat, va_list args) throw()
	{
		return _vscwprintf( pszFormat, args );
	}

	static int Format( LPWSTR pszBuffer, LPCWSTR pszFormat, va_list args) throw()
	{
		return vswprintf( pszBuffer, pszFormat, args );
	}

	static int GetBaseTypeLength( LPCSTR pszSrc ) throw()
	{
		// Returns required buffer size in wchar_ts
		return ::MultiByteToWideChar( _AtlGetConversionACP(), 0, pszSrc, -1, NULL, 0 )-1;
	}

	static int GetBaseTypeLength( LPCSTR pszSrc, int nLength ) throw()
	{
		// Returns required buffer size in wchar_ts
		return ::MultiByteToWideChar( _AtlGetConversionACP(), 0, pszSrc, nLength, NULL, 0 );
	}

	static int GetBaseTypeLength( LPCWSTR pszSrc ) throw()
	{
		// Returns required buffer size in wchar_ts
		return (int)wcslen( pszSrc );
	}

	static int GetBaseTypeLength( LPCWSTR pszSrc, int nLength ) throw()
	{
		(void)pszSrc;
		// Returns required buffer size in wchar_ts
		return nLength;
	}

	static void ConvertToBaseType( LPWSTR pszDest, int nDestLength,
		LPCSTR pszSrc, int nSrcLength = -1) throw()
	{
		// nLen is in wchar_ts
		::MultiByteToWideChar( _AtlGetConversionACP(), 0, pszSrc, nSrcLength, pszDest, nDestLength );
	}

	static void ConvertToBaseType( LPWSTR pszDest, int nDestLength,
		LPCWSTR pszSrc, int nSrcLength = -1) throw()
	{
		(void)nSrcLength;
		// nLen is in wchar_ts
		memcpy( pszDest, pszSrc, nDestLength*sizeof( wchar_t ) );
	}

	static void FloodCharacters( wchar_t ch, int nLength, LPWSTR psz ) throw()
	{
		// nLength is in XCHARs
		for( int i = 0; i < nLength; i++ )
		{
			psz[i] = ch;
		}
	}

	static BSTR AllocSysString( const wchar_t* pchData, int nDataLength ) throw()
	{
		return ::SysAllocStringLen( pchData, nDataLength );
	}

	static BOOL ReAllocSysString( const wchar_t* pchData, BSTR* pbstr, int nDataLength ) throw()
	{
		return ::SysReAllocStringLen( pbstr, pchData, nDataLength );
	}
	
#ifdef _UNICODE
	static DWORD FormatMessage( DWORD dwFlags, LPCVOID pSource,
		DWORD dwMessageID, DWORD dwLanguageID, LPWSTR pszBuffer,
		DWORD nSize, va_list* pArguments ) throw()
	{
		return ::FormatMessageW( dwFlags, pSource, dwMessageID, dwLanguageID,
				pszBuffer, nSize, pArguments );
	}
#endif

	static int SafeStringLen( LPCSTR psz ) throw()
	{
		// returns length in bytes
		return (psz != NULL) ? (int)strlen( psz ) : 0;
	}

	static int SafeStringLen( LPCWSTR psz ) throw()
	{
		// returns length in wchar_ts
		return (psz != NULL) ? (int)wcslen( psz ) : 0;
	}

	static int GetCharLen( const wchar_t* pch ) throw()
	{
		(void)pch;
		// returns char length
		return 1;
	}

	static int GetCharLen( const char* pch ) throw()
	{
		// returns char length
		return (int)( _mbclen( reinterpret_cast< const unsigned char* >( pch ) ) );
	}

	static DWORD GetEnvironmentVariable( LPCWSTR pszVar, LPWSTR pszBuffer, DWORD dwSize ) throw()
	{
		return _GetEnvironmentVariableW( pszVar, pszBuffer, dwSize );
	}
};
#endif  // _ATL_MIN_CRT

template< typename _CharType = char >
class ChTraitsOS :
	public ChTraitsBase< _CharType >
{
public:
	static int tclen(const _CharType* p) throw()
	{
		ATLASSERT(p != NULL);
		_CharType* pnext = CharNext(p);
		return ((pnext-p)>1) ? 2 : 1;
	}
	static _CharType* strchr(const _CharType* p, _CharType ch) throw()
	{
		ATLASSERT(p != NULL);
		//strchr for '\0' should succeed
		do
		{
			if (*p == ch)
			{
				return const_cast< _CharType* >( p );
			}
			p = CharNext(p);
		} while( *p != 0 );

		return NULL;
	}
	static _CharType* strchr_db(const _CharType* p, char ch1, char ch2) throw()
	{
		ATLASSERT(p != NULL);
		while (*p != 0)
		{
			if (*p == ch1 && *(p+1) == ch2)
			{
				return const_cast< _CharType* >( p );
			}
			p = CharNext(p);
		}
		return NULL;
	}
	static _CharType* strrchr(const _CharType* p, _CharType ch) throw()
	{
		ATLASSERT(p != NULL);
		const _CharType* pch = NULL;
		while (*p != 0)
		{
			if (*p == ch)
				pch = p;
			p = CharNext(p);
		}
		return const_cast< _CharType* >( pch );
	}
	static _CharType* _strrev(_CharType* psz) throw()
	{
		// Optimize NULL, zero-length, and single-char case.
		if ((psz == NULL) || (psz[0] == '\0') || (psz[1] == '\0'))
			return psz;

		_CharType* p = psz;

		while (p[1] != 0) 
		{
			_CharType* pNext = CharNext(p);
			if(pNext > p + 1)
			{
				char p1 = *p;
				*p = *(p + 1);
				*(p + 1) = p1;
			}
			p = pNext;
		}

		_CharType* q = psz;

		while (q < p)
		{
			_CharType t = *q;
			*q = *p;
			*p = t;
			q++;
			p--;
		}
		return psz;
	}
	static _CharType* strstr(const _CharType* pStr, const _CharType* pCharSet) throw()
	{
		ATLASSERT(p != NULL);
		int nLen = lstrlenA(pCharSet);
		if (nLen == 0)
			return const_cast<_CharType*>(pStr);

		const _CharType* pMatch;
		const _CharType* pStart = pStr;
		while ((pMatch = strchr(pStart, *pCharSet)) != NULL)
		{
			if (memcmp(pMatch, pCharSet, nLen*sizeof(_CharType)) == 0)
				return const_cast<_CharType*>(pMatch);
			pStart = CharNextA(pMatch);
		}

		return NULL;
	}
	static int strspn(const _CharType* pStr, const _CharType* pCharSet) throw()
	{
		ATLASSERT(p != NULL);
		int nRet = 0;
		_CharType* p = pStr;
		while (*p != 0)
		{
			_CharType* pNext = CharNext(p);
			if(pNext > p + 1)
			{
				if(strchr_db(pCharSet, *p, *(p+1)) == NULL)
					break;
				nRet += 2;
			}
			else
			{
				if(strchr(pCharSet, *p) == NULL)
					break;
				nRet++;
			}
			p = pNext;
		}
		return nRet;
	}
	static int strcspn(const _CharType* pStr, const _CharType* pCharSet) throw()
	{
		ATLASSERT(p != NULL);
		int nRet = 0;
		_CharType* p = pStr;
		while (*p != 0)
		{
			_CharType* pNext = CharNext(p);
			if(pNext > p + 1)
			{
				if(strchr_db(pCharSet, *p, *(p+1)) != NULL)
					break;
				nRet += 2;
			}
			else
			{
				if(strchr(pCharSet, *p) != NULL)
					break;
				nRet++;
			}
			p = pNext;
		}
		return nRet;
	}
	static _CharType* strpbrk(const _CharType* p, const _CharType* lpszCharSet) throw()
	{
		ATLASSERT(p != NULL);
		while (*p != 0)
		{
			if (strchr(lpszCharSet, *p) != NULL)
			{
				return const_cast< _CharType* >( p );
			}
			p = CharNext(p);
		}
		return NULL;
	}

	static _CharType* CharNext(const _CharType* p) throw()
	{
		ATLASSERT(p != NULL);
		if (*p == '\0')  // ::CharNextA won't increment if we're at a \0 already
			return const_cast<_CharType*>(p+1);
		else
			return ::CharNextA(p);
	}

	static int IsDigit(_CharType ch) throw()
	{
		WORD type;
		GetStringTypeExA(GetThreadLocale(), CT_CTYPE1, &ch, 1, &type);
		return (type & C1_DIGIT) == C1_DIGIT;
	}

	static int IsSpace(_CharType ch) throw()
	{
		WORD type;
		GetStringTypeExA(GetThreadLocale(), CT_CTYPE1, &ch, 1, &type);
		return (type & C1_SPACE) == C1_SPACE;
	}

	static int StringCompare(const _CharType* pstrOne,
		const _CharType* pstrOther) throw()
	{
		return lstrcmpA((LPCSTR) pstrOne, (LPCSTR) pstrOther);
	}

	static int StringCompareIgnore(const _CharType* pstrOne,
		const _CharType* pstrOther) throw()
	{
		return lstrcmpiA((LPCSTR) pstrOne, (LPCSTR) pstrOther);
	}

	static int StringCollate(const _CharType* pstrOne,
		const _CharType* pstrOther) throw()
	{
		int nRet = CompareStringA(GetThreadLocale(), 0, (LPCSTR)pstrOne, -1, 
			(LPCSTR)pstrOther, -1);
		ATLASSERT(nRet != 0);
		return nRet-2;  // Convert to strcmp convention.  This really is documented.
	}

	static int StringCollateIgnore(const _CharType* pstrOne,
		const _CharType* pstrOther) throw()
	{
		int nRet = CompareStringA(GetThreadLocale(), NORM_IGNORECASE, (LPCSTR)pstrOne, -1, 
			(LPCSTR)pstrOther, -1);
		ATLASSERT(nRet != 0);
		return nRet-2;  // Convert to strcmp convention.  This really is documented.
	}

	static _CharType* StringFindString(const _CharType* pstrBlock,
		const _CharType* pstrMatch) throw()
	{
		return strstr(pstrBlock, pstrMatch);
	}

	static _CharType* StringFindChar(const _CharType* pstrBlock,
		_CharType pstrMatch) throw()
	{
		return strchr(pstrBlock, pstrMatch);
	}

	static _CharType* StringFindCharRev(const _CharType* pstr, _CharType ch) throw()
	{
		return strrchr(pstr, ch);
	}

	static _CharType* StringScanSet(const _CharType* pstrBlock,
		const _CharType* pstrMatch) throw()
	{
		return strpbrk(pstrBlock, pstrMatch);
	}

	static int StringSpanIncluding(const _CharType* pstrBlock,
		const _CharType* pstrSet) throw()
	{
		return strspn(pstrBlock, pstrSet);
	}

	static int StringSpanExcluding(const _CharType* pstrBlock,
		const _CharType* pstrSet) throw()
	{
		return strcspn(pstrBlock, pstrSet);
	}

	static _CharType* StringUppercase(_CharType* psz) throw()
	{
		return CharUpperA( psz );
	}

	static _CharType* StringLowercase(_CharType* psz) throw()
	{
		return CharLowerA( psz );
	}

	static _CharType* StringReverse(_CharType* psz) throw()
	{
		return _strrev( psz );
	}

	static int GetFormattedLength(const _CharType* pszFormat, va_list args) throw()
	{
		_CharType szBuffer[1028];

		// wvsprintf always truncates the output to 1024 character plus
		// the '\0'.
		int nLength = wvsprintfA(szBuffer, pszFormat, args);
		ATLASSERT(nLength >= 0);
		ATLASSERT(nLength <= 1024);

		return nLength;
	}

	static int Format(_CharType* pszBuffer, const _CharType* pszFormat,
		va_list args) throw()
	{
		return wvsprintfA(pszBuffer, pszFormat, args);
	}

	static int GetBaseTypeLength(const char* pszSrc) throw()
	{
		// Returns required buffer length in XCHARs
		return lstrlenA(pszSrc);
	}

	static int GetBaseTypeLength(const char* pszSrc, int nLength) throw()
	{
		(void)pszSrc;
		// Returns required buffer length in XCHARs
		return nLength;
	}

	static int GetBaseTypeLength(const wchar_t* pszSrc) throw()
	{
		// Returns required buffer length in XCHARs
		return ::WideCharToMultiByte(_AtlGetConversionACP(), 0, pszSrc, -1, NULL, 0, NULL, NULL)-1;
	}

	static int GetBaseTypeLength(const wchar_t* pszSrc, int nLength) throw()
	{
		// Returns required buffer length in XCHARs
		return ::WideCharToMultiByte(_AtlGetConversionACP(), 0, pszSrc, nLength, NULL, 0, NULL, NULL);
	}

	static void ConvertToBaseType(_CharType* pszDest, int nDestLength,
		const char* pszSrc, int nSrcLength = -1) throw()
	{
		(void)nSrcLength;
		// nLen is in chars
		memcpy(pszDest, pszSrc, nDestLength);
	}

	static void ConvertToBaseType(_CharType* pszDest, int nDestLength,
		const wchar_t* pszSrc, int nSrcLength = -1) throw()
	{
		// nLen is in XCHARs
		::WideCharToMultiByte(_AtlGetConversionACP(), 0, pszSrc, nSrcLength, pszDest, nDestLength, NULL, NULL);
	}

	static void ConvertToOem(_CharType* pstrString) throw()
	{
		::AnsiToOem(pstrString, pstrString);
	}

	static void ConvertToAnsi(_CharType* pstrString) throw()
	{
		::OemToAnsi(pstrString, pstrString);
	}

	static void FloodCharacters(_CharType ch, int nLength, _CharType* pstr) throw()
	{
		// nLength is in XCHARs
		memset(pstr, ch, nLength);
	}

	static BSTR AllocSysString(const _CharType* pchData, int nDataLength) throw()
	{
		int nLen = MultiByteToWideChar(_AtlGetConversionACP(), 0, pchData, nDataLength,
			NULL, NULL);
		BSTR bstr = ::SysAllocStringLen(NULL, nLen);
		if (bstr != NULL)
		{
			MultiByteToWideChar(_AtlGetConversionACP(), 0, pchData, nDataLength,
				bstr, nLen);
		}

		return bstr;
	}

	static BOOL ReAllocSysString(const _CharType* pchData, BSTR* pbstr,
		int nDataLength) throw()
	{
		int nLen = MultiByteToWideChar(_AtlGetConversionACP(), 0, pchData,
			nDataLength, NULL, NULL);
		BOOL bSuccess =::SysReAllocStringLen(pbstr, NULL, nLen);
		if (bSuccess)
		{
			MultiByteToWideChar(_AtlGetConversionACP(), 0, pchData, nDataLength,
				*pbstr, nLen);
		}

		return bSuccess;
	}

	static DWORD FormatMessage(DWORD dwFlags, LPCVOID lpSource,
		DWORD dwMessageID, DWORD dwLanguageID, char* pstrBuffer,
		DWORD nSize, va_list* pArguments) throw()
	{
		return ::FormatMessageA(dwFlags, lpSource, dwMessageID, dwLanguageID,
				pstrBuffer, nSize, pArguments);
	}

	static int SafeStringLen(const char* psz) throw()
	{
		// returns length in bytes
		return (psz != NULL) ? lstrlenA(psz) : 0;
	}

	static int SafeStringLen(const wchar_t* psz) throw()
	{
		// returns length in wchar_ts
		return (psz != NULL) ? lstrlenW(psz) : 0;
	}

	static int GetCharLen(const wchar_t*) throw()
	{
		// returns char length
		return 1;
	}
	static int GetCharLen(const char* psz) throw()
	{
		const char* p = ::CharNextA(psz);
		return (p - psz);
	}

	static DWORD GetEnvironmentVariable(const _CharType* pstrVar,
		_CharType* pstrBuffer, DWORD dwSize) throw()
	{
		return ::GetEnvironmentVariableA(pstrVar, pstrBuffer, dwSize);
	}
};

// specialization for wchar_t
template<>
class ChTraitsOS< wchar_t > :
	public ChTraitsBase< wchar_t >
{
protected:
#if defined(_UNICODE) && !defined(_CSTRING_ALWAYS_THUNK)
	static int CompareStringW(LCID lcid, DWORD dwFlags, 
		LPCWSTR pszString1, int nLength1, LPCWSTR pszString2, int nLength2)
	{
		return ::CompareStringW(lcid, dwFlags, pszString1, nLength1, 
			pszString2, nLength2);
	}
	static BOOL GetStringTypeExW(LCID lcid, DWORD dwInfoType, LPCWSTR pszSrc,
		int nLength, LPWORD pwCharType)
	{
		return ::GetStringTypeExW(lcid, dwInfoType, pszSrc, nLength, pwCharType);
	}
	static int lstrcmpiW(LPCWSTR psz1, LPCWSTR psz2)
	{
		return ::lstrcmpiW(psz1, psz2);
	}
	static LPWSTR CharLowerW(LPWSTR psz)
	{
		return ::CharLowerW(psz);
	}
	static LPWSTR CharUpperW(LPWSTR psz)
	{
		return ::CharUpperW(psz);
	}
	static DWORD _GetEnvironmentVariableW(LPCWSTR pszName, LPWSTR pszBuffer, DWORD nSize)
	{
		return ::GetEnvironmentVariableW(pszName, pszBuffer, nSize);
	}
#else  // !_UNICODE
	static int WINAPI CompareStringW(LCID lcid, DWORD dwFlags, 
		LPCWSTR pszString1, int nLength1, LPCWSTR pszString2, int nLength2)
	{
		return _strthunks.pfnCompareStringW(lcid, dwFlags, pszString1, nLength1, pszString2, nLength2);
	}
	static BOOL WINAPI GetStringTypeExW(LCID lcid, DWORD dwInfoType, LPCWSTR pszSrc,
		int nLength, LPWORD pwCharType)
	{
		return _strthunks.pfnGetStringTypeExW(lcid, dwInfoType, pszSrc, nLength, pwCharType);
	}
	static int WINAPI lstrcmpiW(LPCWSTR psz1, LPCWSTR psz2)
	{
		return _strthunks.pfnlstrcmpiW(psz1, psz2);
	}
	static LPWSTR WINAPI CharLowerW(LPWSTR psz)
	{
		ATLASSERT(HIWORD(psz) != 0);  // No single chars
		return _strthunks.pfnCharLowerW(psz);
	}
	static LPWSTR WINAPI CharUpperW(LPWSTR psz)
	{
		ATLASSERT(HIWORD(psz) != 0);  // No single chars
		return _strthunks.pfnCharUpperW(psz);
	}
	static DWORD _GetEnvironmentVariableW(LPCWSTR pszName, LPWSTR pszBuffer, DWORD nSize)
	{
		return _strthunks.pfnGetEnvironmentVariableW(pszName, pszBuffer, nSize);
	}
#endif  // !_UNICODE

public:
	static int tclen(const _CharType*) throw()
	{
		return 1;
	}
	static _CharType* strchr(const _CharType* p, _CharType ch) throw()
	{
		//strchr for '\0' should succeed
		while (*p != 0)
		{
			if (*p == ch)
			{
				return const_cast< _CharType* >( p );
			}
			p++;
		}
		return const_cast< _CharType* >((*p == ch) ? p : NULL);
	}
	static _CharType* strrchr(const _CharType* p, _CharType ch) throw()
	{
		const _CharType* pch = p+lstrlenW(p);
		while ((pch != p) && (*pch != ch))
		{
			pch--;
		}
		if (*pch == ch)
		{
			return const_cast<_CharType*>(pch);
		}
		else
		{
			return NULL;
		}
	}
	static _CharType* _strrev(_CharType* psz) throw()
	{
		// Optimize NULL, zero-length, and single-char case.
		if ((psz == NULL) || (psz[0] == L'\0') || (psz[1] == L'\0'))
			return psz;

		_CharType* p = psz+(lstrlenW( psz )-1);
		_CharType* q = psz;
		while(q < p)
		{
			_CharType t = *q;
			*q = *p;
			*p = t;
			q++;
			p--;
		}
		return psz;
	}
	static _CharType* strstr(const _CharType* pStr, const _CharType* pCharSet) throw()
	{
		int nLen = lstrlenW(pCharSet);
		if (nLen == 0)
			return const_cast<_CharType*>(pStr);

		const _CharType* pMatch;
		const _CharType* pStart = pStr;
		while ((pMatch = strchr(pStart, *pCharSet)) != NULL)
		{
			if (memcmp(pMatch, pCharSet, nLen*sizeof(_CharType)) == 0)
				return const_cast<_CharType*>(pMatch);
			pStart++;
		}

		return NULL;
	}
	static int strspn(const _CharType* psz, const _CharType* pszCharSet) throw()
	{
		int nRet = 0;
		const _CharType* p = psz;
		while (*p != 0)
		{
			if(strchr(pszCharSet, *p) == NULL)
				break;
			nRet++;
			p++;
		}
		return nRet;
	}
	static int strcspn(const _CharType* psz, const _CharType* pszCharSet) throw()
	{
		int nRet = 0;
		const _CharType* p = psz;
		while (*p != 0)
		{
			if(strchr(pszCharSet, *p) != NULL)
				break;
			nRet++;
			p++;
		}
		return nRet;
	}
	static _CharType* strpbrk(const _CharType* psz, const _CharType* pszCharSet) throw()
	{
		const wchar_t* p = psz;
		while (*p != 0)
		{
			if (strchr(pszCharSet, *p) != NULL)
				return const_cast< wchar_t* >( p );
			p++;
		}
		return NULL;
	}

	static wchar_t* CharNext(const wchar_t* p) throw()
	{
		return const_cast< wchar_t* >( p+1 );
	}

	static int IsDigit(_CharType ch) throw()
	{
		WORD type;
		GetStringTypeExW(0, CT_CTYPE1, &ch, 1, &type);
		return (type & C1_DIGIT) == C1_DIGIT;
	}

	static int IsSpace(_CharType ch) throw()
	{
		WORD type;
		GetStringTypeExW(0, CT_CTYPE1, &ch, 1, &type);
		return (type & C1_SPACE) == C1_SPACE;
	}


	static int StringCompare(const _CharType* pstrOne,
		const _CharType* pstrOther) throw()
	{
		return wcscmp(pstrOne, pstrOther);
	}

	static int StringCompareIgnore(const _CharType* pstrOne,
		const _CharType* pstrOther) throw()
	{
		return lstrcmpiW(pstrOne, pstrOther);
	}

	static int StringCollate(const _CharType* pstrOne,
		const _CharType* pstrOther) throw()
	{ 
		int nRet;

		nRet = CompareStringW(GetThreadLocale(), 0, pstrOne, -1, pstrOther, -1);
		ATLASSERT(nRet != 0);
		return nRet-2;  // Convert to strcmp convention.  This really is documented.
	}

	static int StringCollateIgnore(const _CharType* pstrOne,
		const _CharType* pstrOther) throw()
	{
		int nRet = CompareStringW(GetThreadLocale(), NORM_IGNORECASE, 
			pstrOne, -1, pstrOther, -1);
		ATLASSERT(nRet != 0);
		return nRet-2;  // Convert to strcmp convention.  This really is documented.
	}

	static _CharType* StringFindString(const _CharType* pstrBlock,
		const _CharType* pstrMatch) throw()
	{
		return strstr(pstrBlock, pstrMatch);
	}

	static _CharType* StringFindChar(const _CharType* pstrBlock,
		_CharType pstrMatch) throw()
	{
		return strchr(pstrBlock, pstrMatch);
	}

	static _CharType* StringFindCharRev(const _CharType* pstr, _CharType ch) throw()
	{
		return strrchr(pstr, ch);
	}

	static _CharType* StringScanSet(const _CharType* pszBlock,
		const _CharType* pszMatch) throw()
	{
		return strpbrk(pszBlock, pszMatch);
	}

	static int StringSpanIncluding(const _CharType* pszBlock,
		const _CharType* pszSet) throw()
	{
		return strspn(pszBlock, pszSet);
	}

	static int StringSpanExcluding(const _CharType* pszBlock,
		const _CharType* pszSet) throw()
	{
		return strcspn(pszBlock, pszSet);
	}

	static _CharType* StringUppercase(_CharType* psz) throw()
	{
		CharUpperW(psz);
		return psz;
	}

	static _CharType* StringLowercase(_CharType* psz) throw()
	{
		CharLowerW(psz);
		return psz;
	}

	static _CharType* StringReverse(_CharType* psz) throw()
	{
		return _strrev(psz);
	}

#ifdef _UNICODE
	static int GetFormattedLength(const _CharType* pszFormat, va_list args) throw()
	{
		_CharType szBuffer[1028];

		// wvsprintf always truncates the output to 1024 character plus
		// the '\0'.
		int nLength = wvsprintfW(szBuffer, pszFormat, args);
		ATLASSERT(nLength >= 0);
		ATLASSERT(nLength <= 1024);

		return nLength;
	}

	static int Format(_CharType* pszBuffer, const _CharType* pszFormat,
		va_list args) throw()
	{
		return wvsprintfW(pszBuffer, pszFormat, args);
	}
#endif

	static int GetBaseTypeLength(const char* pszSrc) throw()
	{
		// Returns required buffer size in wchar_ts
		return ::MultiByteToWideChar(_AtlGetConversionACP(), 0, pszSrc, -1, NULL, 0)-1;
	}

	static int GetBaseTypeLength(const char* pszSrc, int nLength) throw()
	{
		// Returns required buffer size in wchar_ts
		return ::MultiByteToWideChar(_AtlGetConversionACP(), 0, pszSrc, nLength, NULL, 0);
	}

	static int GetBaseTypeLength(const wchar_t* pszSrc) throw()
	{
		// Returns required buffer size in wchar_ts
		return lstrlenW(pszSrc);
	}

	static int GetBaseTypeLength(const wchar_t* pszSrc, int nLength) throw()
	{
		(void)pszSrc;
		// Returns required buffer size in wchar_ts
		return nLength;
	}

	static void ConvertToBaseType(_CharType* pszDest, int nDestLength,
		const char* pszSrc, int nSrcLength = -1) throw()
	{
		// nLen is in wchar_ts
		::MultiByteToWideChar(_AtlGetConversionACP(), 0, pszSrc, nSrcLength, pszDest, nDestLength);
	}

	static void ConvertToBaseType(_CharType* pszDest, int nDestLength,
		const wchar_t* pszSrc, int nSrcLength = -1) throw()
	{
		(void)nSrcLength;
		// nLen is in wchar_ts
		memcpy(pszDest, pszSrc, nDestLength*sizeof(wchar_t));
	}

	// this conversion on Unicode strings makes no sense
	/*
	static void ConvertToOem(_CharType*)
	{
		ATLASSERT(FALSE);
	}
	*/

	// this conversion on Unicode strings makes no sense
	/*
	static void ConvertToAnsi(_CharType*)
	{
		ATLASSERT(FALSE);
	}
	*/

	static void FloodCharacters(_CharType ch, int nLength, _CharType* pstr) throw()
	{
		// nLength is in XCHARs
		for (int i = 0; i < nLength; i++)
			pstr[i] = ch;
	}

	static BSTR AllocSysString(const _CharType* pchData, int nDataLength) throw()
	{
		BSTR bstr = ::SysAllocStringLen(pchData, nDataLength);
		return bstr;
	}

	static BOOL ReAllocSysString(const _CharType* pchData, BSTR* pbstr,
		int nDataLength) throw()
	{
		return ::SysReAllocStringLen(pbstr, pchData, nDataLength);
	}
	
#ifdef _UNICODE
	static DWORD FormatMessage(DWORD dwFlags, LPCVOID lpSource,
		DWORD dwMessageID, DWORD dwLanguageID, wchar_t* pstrBuffer,
		DWORD nSize, va_list* pArguments) throw()
	{
		return ::FormatMessageW(dwFlags, lpSource, dwMessageID, dwLanguageID,
				pstrBuffer, nSize, pArguments);
	}
#endif
	static int SafeStringLen(const char* psz) throw()
	{
		// returns length in bytes
		return (psz != NULL) ? lstrlenA(psz) : 0;
	}

	static int SafeStringLen(const wchar_t* psz) throw()
	{
		// returns length in wchar_ts
		return (psz != NULL) ? lstrlenW(psz) : 0;
	}

	static int GetCharLen(const wchar_t*) throw()
	{
		// returns char length
		return 1;
	}
	static int GetCharLen(const char* psz) throw()
	{
		LPCSTR p = ::CharNextA( psz );
		return int( p-psz );
	}

	static DWORD GetEnvironmentVariable(const _CharType* pstrVar,
		_CharType* pstrBuffer, DWORD dwSize) throw()
	{
		return ::GetEnvironmentVariableW(pstrVar, pstrBuffer, dwSize);
	}
};


template< typename BaseType, class StringTraits >
class CStringT :
	public CSimpleStringT< BaseType >
{
public:
	typedef CSimpleStringT< BaseType > CThisSimpleString;
	typedef StringTraits StrTraits;

public:
	CStringT() throw() :
		CThisSimpleString( StringTraits::GetDefaultManager() )
	{
	}
	explicit CStringT( IAtlStringMgr* pStringMgr ) throw() :
		CThisSimpleString( pStringMgr )
	{ 
	}

	CStringT( const VARIANT& varSrc ) :
		CThisSimpleString( StringTraits::GetDefaultManager() )
	{
		CComVariant varResult;
		HRESULT hr = ::VariantChangeType( &varResult, const_cast< VARIANT* >( &varSrc ), 0, VT_BSTR );
		if( FAILED( hr ) )
		{
			AtlThrow( hr );
		}

		*this = V_BSTR( &varResult );
	}

	CStringT( const VARIANT& varSrc, IAtlStringMgr* pStringMgr ) :
		CThisSimpleString( pStringMgr )
	{
		CComVariant varResult;
		HRESULT hr = ::VariantChangeType( &varResult, const_cast< VARIANT* >( &varSrc ), 0, VT_BSTR );
		if( FAILED( hr ) )
		{
			AtlThrow( hr );
		}

		*this = V_BSTR( &varResult );
	}

	static void Construct( CStringT* pString )
	{
		new( pString ) CStringT;
	}

	// Copy constructor
	CStringT( const CStringT& strSrc ) :
		CThisSimpleString( strSrc )
	{
	}

	// Construct from CSimpleStringT
	CStringT( const CThisSimpleString& strSrc ) :
		CThisSimpleString( strSrc )
	{
	}

	CStringT( const XCHAR* pszSrc ) :
		CThisSimpleString( StringTraits::GetDefaultManager() )
	{
		if( !CheckImplicitLoad( pszSrc ) )
		{
			// nDestLength is in XCHARs
			*this = pszSrc;
		}
	}

	CStringT( LPCSTR pszSrc, IAtlStringMgr* pStringMgr ) :
		CThisSimpleString( pStringMgr )
	{
		if( !CheckImplicitLoad( pszSrc ) )
		{
			// nDestLength is in XCHARs
			*this = pszSrc;
		}
	}

	CSTRING_EXPLICIT CStringT( const YCHAR* pszSrc ) :
		CThisSimpleString( StringTraits::GetDefaultManager() )
	{
		if( !CheckImplicitLoad( pszSrc ) )
		{
			*this = pszSrc;
		}
	}

	CStringT( LPCWSTR pszSrc, IAtlStringMgr* pStringMgr ) :
		CThisSimpleString( pStringMgr )
	{
		if( !CheckImplicitLoad( pszSrc ) )
		{
			*this = pszSrc;
		}
	}

#ifdef _MANAGED
	CStringT( System::String* pString ) :
		CThisSimpleString( StringTraits::GetDefaultManager() )
	{
		const wchar_t __pin* psz = PtrToStringChars( pString );
		*this = psz;
	}
#endif

	CSTRING_EXPLICIT CStringT( const unsigned char* pszSrc ) :
		CThisSimpleString( StringTraits::GetDefaultManager() )
	{
		*this = reinterpret_cast< const char* >( pszSrc );
	}

	CStringT( const unsigned char* pszSrc, IAtlStringMgr* pStringMgr ) :
		CThisSimpleString( pStringMgr )
	{
		*this = reinterpret_cast< const char* >( pszSrc );
	}

	CSTRING_EXPLICIT CStringT( wchar_t ch, int nLength = 1 ) :
		CThisSimpleString( StringTraits::GetDefaultManager() )
	{
		ATLASSERT( nLength >= 0 );
		if( nLength > 0 )
		{
			PXSTR pszBuffer = GetBuffer( nLength );
			StringTraits::FloodCharacters( XCHAR( ch ), nLength, pszBuffer );
			ReleaseBuffer( nLength );
		}
	}

	CStringT( const XCHAR* pch, int nLength ) :
		CThisSimpleString( pch, nLength, StringTraits::GetDefaultManager() )
	{
	}

	CStringT( const XCHAR* pch, int nLength, IAtlStringMgr* pStringMgr ) :
		CThisSimpleString( pch, nLength, pStringMgr )
	{
	}

	CStringT( const YCHAR* pch, int nLength ) :
		CThisSimpleString( StringTraits::GetDefaultManager() )
	{
		ATLASSERT( nLength >= 0 );
		if( nLength > 0 )
		{
			ATLASSERT( AtlIsValidAddress( pch, nLength*sizeof( YCHAR ), FALSE ) );
			int nDestLength = StringTraits::GetBaseTypeLength( pch, nLength );
			PXSTR pszBuffer = GetBuffer( nDestLength );
			StringTraits::ConvertToBaseType( pszBuffer, nDestLength, pch, nLength );
			ReleaseBuffer( nDestLength );
		}
	}

	CStringT( const YCHAR* pch, int nLength, IAtlStringMgr* pStringMgr ) :
		CThisSimpleString( pStringMgr )
	{
		ATLASSERT( nLength >= 0 );
		if( nLength > 0 )
		{
			ATLASSERT( AtlIsValidAddress( pch, nLength*sizeof( YCHAR ), FALSE ) );
			int nDestLength = StringTraits::GetBaseTypeLength( pch, nLength );
			PXSTR pszBuffer = GetBuffer( nDestLength );
			StringTraits::ConvertToBaseType( pszBuffer, nDestLength, pch, nLength );
			ReleaseBuffer( nDestLength );
		}
	}

	// Destructor
	~CStringT() throw()
	{
	}

	// Assignment operators
	CStringT& operator=( const CStringT& strSrc )
	{
		CThisSimpleString::operator=( strSrc );

		return( *this );
	}

	CStringT& operator=( const CThisSimpleString& strSrc )
	{
		CThisSimpleString::operator=( strSrc );

		return( *this );
	}

	CStringT& operator=( PCXSTR pszSrc )
	{
		CThisSimpleString::operator=( pszSrc );

		return( *this );
	}

	CStringT& operator=( PCYSTR pszSrc )
	{
		// nDestLength is in XCHARs
		int nDestLength = (pszSrc != NULL) ? StringTraits::GetBaseTypeLength( pszSrc ) : 0;
		if( nDestLength > 0 )
		{
			PXSTR pszBuffer = GetBuffer( nDestLength );
			StringTraits::ConvertToBaseType( pszBuffer, nDestLength, pszSrc );
			ReleaseBuffer( nDestLength );
		}
		else
		{
			Empty();
		}

		return( *this );
	}

	CStringT& operator=( const unsigned char* pszSrc )
	{
		return( operator=( reinterpret_cast< const char* >( pszSrc ) ) );
	}

	CStringT& operator=( char ch )
	{
		char ach[2] = { ch, 0 };

		return( operator=( ach ) );
	}

	CStringT& operator=( wchar_t ch )
	{
		wchar_t ach[2] = { ch, 0 };

		return( operator=( ach ) );
	}

	CStringT& operator=( const VARIANT& var )
	{
		CComVariant varResult;
		HRESULT hr = ::VariantChangeType( &varResult, const_cast< VARIANT* >( &var ), 0, VT_BSTR );
		if( FAILED( hr ) )
		{
			AtlThrow( hr );
		}

		*this = V_BSTR( &varResult );

		return( *this );
	}

	CStringT& operator+=( const CThisSimpleString& str )
	{
		CThisSimpleString::operator+=( str );

		return( *this );
	}
	CStringT& operator+=( PCXSTR pszSrc )
	{
		CThisSimpleString::operator+=( pszSrc );

		return( *this );
	}
	template< int t_nSize >
	CStringT& operator+=( const CStaticString< XCHAR, t_nSize >& strSrc )
	{
		CThisSimpleString::operator+=( strSrc );

		return( *this );
	}
	CStringT& operator+=( PCYSTR psz )
	{
		CStringT str( psz, GetManager() );

		return( operator+=( str ) );
	}

	CStringT& operator+=( char ch )
	{
		CThisSimpleString::operator+=( ch );

		return( *this );
	}

	CStringT& operator+=( unsigned char ch )
	{
		CThisSimpleString::operator+=( ch );

		return( *this );
	}

	CStringT& operator+=( wchar_t ch )
	{
		CThisSimpleString::operator+=( ch );

		return( *this );
	}

	CStringT& operator+=( const VARIANT& var )
	{
		CComVariant varResult;
		HRESULT hr = ::VariantChangeType( &varResult, const_cast< VARIANT* >( &var ), 0, VT_BSTR );
		if( FAILED( hr ) )
		{
			AtlThrow( hr );
		}

		*this += V_BSTR( &varResult );

		return( *this );
	}

	// Comparison

	int Compare( PCXSTR psz ) const throw()
	{
		ATLASSERT( AtlIsValidString( psz ) );
		return( StringTraits::StringCompare( GetString(), psz ) );
	}

	int CompareNoCase( PCXSTR psz ) const throw()
	{
		ATLASSERT( AtlIsValidString( psz ) );
		return( StringTraits::StringCompareIgnore( GetString(), psz ) );
	}

	int Collate( PCXSTR psz ) const throw()
	{
		ATLASSERT( AtlIsValidString( psz ) );
		return( StringTraits::StringCollate( GetString(), psz ) );
	}

	int CollateNoCase( PCXSTR psz ) const throw()
	{
		ATLASSERT( AtlIsValidString( psz ) );
		return( StringTraits::StringCollateIgnore( GetString(), psz ) );
	}

	// Advanced manipulation

	// Delete 'nCount' characters, starting at index 'iIndex'
	int Delete( int iIndex, int nCount = 1 )
	{
		ATLASSERT( iIndex >= 0 );
		ATLASSERT( nCount >= 0 );
		int nLength = GetLength();
		if( (nCount+iIndex) > nLength )
		{
			nCount = nLength-iIndex;
		}
		if( nCount > 0 )
		{
			int nNewLength = nLength-nCount;
			int nXCHARsToCopy = nLength-(iIndex+nCount)+1;
			PXSTR pszBuffer = GetBuffer();
			memmove( pszBuffer+iIndex, pszBuffer+iIndex+nCount, nXCHARsToCopy*sizeof( XCHAR ) );
			ReleaseBuffer( nNewLength );
		}

		return( GetLength() );
	}

	// Insert character 'ch' before index 'iIndex'
	int Insert( int iIndex, XCHAR ch )
	{
		ATLASSERT( iIndex >= 0 );
		if( iIndex > GetLength() )
		{
			iIndex = GetLength();
		}
		int nNewLength = GetLength()+1;

		PXSTR pszBuffer = GetBuffer( nNewLength );

		// move existing bytes down
		memmove( pszBuffer+iIndex+1, pszBuffer+iIndex, (nNewLength-iIndex)*sizeof( XCHAR ) );
		pszBuffer[iIndex] = ch;

		ReleaseBuffer( nNewLength );

		return( nNewLength );
	}

	// Insert string 'psz' before index 'iIndex'
	int Insert( int iIndex, PCXSTR psz )
	{
		ATLASSERT( iIndex >= 0 );
		if( iIndex > GetLength() )
		{
			iIndex = GetLength();
		}

		// nInsertLength and nNewLength are in XCHARs
		int nInsertLength = StringTraits::SafeStringLen( psz );
		int nNewLength = GetLength();
		if( nInsertLength > 0 )
		{
			nNewLength += nInsertLength;

			PXSTR pszBuffer = GetBuffer( nNewLength );
			// move existing bytes down
			memmove( pszBuffer+iIndex+nInsertLength,
				pszBuffer+iIndex, (nNewLength-iIndex-nInsertLength+1)*sizeof( XCHAR ) );
			memcpy( pszBuffer+iIndex, psz, nInsertLength*sizeof( XCHAR ) );
			ReleaseBuffer( nNewLength );
		}

		return( nNewLength );
	}

	// Replace all occurrences of character 'chOld' with character 'chNew'
	int Replace( XCHAR chOld, XCHAR chNew )
	{
		int nCount = 0;

		// short-circuit the nop case
		if( chOld != chNew )
		{
			// otherwise modify each character that matches in the string
			bool bCopied = false;
			PXSTR pszBuffer = const_cast< PXSTR >( GetString() );  // We don't actually write to pszBuffer until we've called GetBuffer().

			int nLength = GetLength();
			int iChar = 0;
			while( iChar < nLength )
			{
				// replace instances of the specified character only
				if( pszBuffer[iChar] == chOld )
				{
					if( !bCopied )
					{
						bCopied = true;
						pszBuffer = GetBuffer( nLength );
					}
					pszBuffer[iChar] = chNew;
					nCount++;
				}
				iChar = int( StringTraits::CharNext( pszBuffer+iChar )-pszBuffer );
			}
			if( bCopied )
			{
				ReleaseBuffer( nLength );
			}
		}

		return( nCount );
	}

	// Replace all occurrences of string 'pszOld' with string 'pszNew'
	int Replace( PCXSTR pszOld, PCXSTR pszNew )
	{
		// can't have empty or NULL lpszOld

		// nSourceLen is in XCHARs
		int nSourceLen = StringTraits::SafeStringLen( pszOld );
		if( nSourceLen == 0 )
			return( 0 );
		// nReplacementLen is in XCHARs
		int nReplacementLen = StringTraits::SafeStringLen( pszNew );

		// loop once to figure out the size of the result string
		int nCount = 0;
		{
			PCXSTR pszStart = GetString();
			PCXSTR pszEnd = pszStart+GetLength();
			while( pszStart < pszEnd )
			{
				PCXSTR pszTarget;
				while( (pszTarget = StringTraits::StringFindString( pszStart, pszOld ) ) != NULL)
				{
					nCount++;
					pszStart = pszTarget+nSourceLen;
				}
				pszStart += StringTraits::SafeStringLen( pszStart )+1;
			}
		}

		// if any changes were made, make them
		if( nCount > 0 )
		{
			// if the buffer is too small, just
			//   allocate a new buffer (slow but sure)
			int nOldLength = GetLength();
			int nNewLength = nOldLength+(nReplacementLen-nSourceLen)*nCount;

			PXSTR pszBuffer = GetBuffer( max( nNewLength, nOldLength ) );

			PXSTR pszStart = pszBuffer;
			PXSTR pszEnd = pszStart+nOldLength;

			// loop again to actually do the work
			while( pszStart < pszEnd )
			{
				PXSTR pszTarget;
				while( (pszTarget = StringTraits::StringFindString( pszStart, pszOld ) ) != NULL )
				{
					int nBalance = nOldLength-int(pszTarget-pszBuffer+nSourceLen);
					memmove( pszTarget+nReplacementLen, pszTarget+nSourceLen, nBalance*sizeof( XCHAR ) );
 	
					memcpy( pszTarget, pszNew, nReplacementLen*sizeof( XCHAR ) );
					pszStart = pszTarget+nReplacementLen;
					pszTarget[nReplacementLen+nBalance] = 0;
					nOldLength += (nReplacementLen-nSourceLen);
				}
				pszStart += StringTraits::SafeStringLen( pszStart )+1;
			}
			ATLASSERT( pszBuffer[nNewLength] == 0 );
			ReleaseBuffer( nNewLength );
		}

		return( nCount );
	}

	// Remove all occurrences of character 'chRemove'
	int Remove( XCHAR chRemove )
	{
		int nLength = GetLength();
		PXSTR pszBuffer = GetBuffer( nLength );

		PXSTR pszSource = pszBuffer;
		PXSTR pszDest = pszBuffer;
		PXSTR pszEnd = pszBuffer+nLength;

		while( pszSource < pszEnd )
		{
			if( *pszSource != chRemove )
			{
				*pszDest = *pszSource;
				pszDest = StringTraits::CharNext( pszDest );
			}
			pszSource = StringTraits::CharNext( pszSource );
		}
		*pszDest = 0;
		int nCount = int( pszSource-pszDest );
		ReleaseBuffer( nLength-nCount );

		return( nCount );
	}

	CStringT Tokenize( PCXSTR pszTokens, int& iStart ) const
	{
		ATLASSERT( iStart >= 0 );

		if( pszTokens == NULL )
		{
			return( *this );
		}

		PCXSTR pszPlace = GetString()+iStart;
		PCXSTR pszEnd = GetString()+GetLength();
		if( pszPlace < pszEnd )
		{
			int nIncluding = StringTraits::StringSpanIncluding( pszPlace,
				pszTokens );

			if( (pszPlace+nIncluding) < pszEnd )
			{
				pszPlace += nIncluding;
				int nExcluding = StringTraits::StringSpanExcluding( pszPlace, pszTokens );
				
				int iFrom = iStart+nIncluding;
				int nUntil = nExcluding;
				iStart = iFrom+nUntil+1;

				return( Mid( iFrom, nUntil ) );
			}
		}

		// return empty string, done tokenizing
		iStart = -1;

		return( CStringT( GetManager() ) );
	}

	// find routines

	// Find the first occurrence of character 'ch', starting at index 'iStart'
	int Find( XCHAR ch, int iStart = 0 ) const throw()
	{
		// iStart is in XCHARs
		ATLASSERT( iStart >= 0 );

		// nLength is in XCHARs
		int nLength = GetLength();
		if( iStart >= nLength)
		{
			return( -1 );
		}

		// find first single character
		PCXSTR psz = StringTraits::StringFindChar( GetString()+iStart, ch );

		// return -1 if not found and index otherwise
		return( (psz == NULL) ? -1 : int( psz-GetString() ) );
	}

	// look for a specific sub-string

	// Find the first occurrence of string 'pszSub', starting at index 'iStart'
	int Find( PCXSTR pszSub, int iStart = 0 ) const throw()
	{
		// iStart is in XCHARs
		ATLASSERT( iStart >= 0 );
		ATLASSERT( AtlIsValidString( pszSub ) );

		// nLength is in XCHARs
		int nLength = GetLength();
		if( iStart > nLength )
		{
			return( -1 );
		}

		// find first matching substring
		PCXSTR psz = StringTraits::StringFindString( GetString()+iStart, pszSub );

		// return -1 for not found, distance from beginning otherwise
		return( (psz == NULL) ? -1 : int( psz-GetString() ) );
	}

	// Find the first occurrence of any of the characters in string 'pszCharSet'
	int FindOneOf( PCXSTR pszCharSet ) const throw()
	{
		ATLASSERT( AtlIsValidString( pszCharSet ) );
		PCXSTR psz = StringTraits::StringScanSet( GetString(), pszCharSet );
		return( (psz == NULL) ? -1 : int( psz-GetString() ) );
	}

	// Find the last occurrence of character 'ch'
	int ReverseFind( XCHAR ch ) const throw()
	{
		// find last single character
		PCXSTR psz = StringTraits::StringFindCharRev( GetString(), ch );

		// return -1 if not found, distance from beginning otherwise
		return( (psz == NULL) ? -1 : int( psz-GetString() ) );
	}

	// manipulation

	// Convert the string to uppercase
	CStringT& MakeUpper()
	{
		int nLength = GetLength();
		PXSTR pszBuffer = GetBuffer( nLength );
		StringTraits::StringUppercase( pszBuffer );
		ReleaseBuffer( nLength );

		return( *this );
	}

	// Convert the string to lowercase
	CStringT& MakeLower()
	{
		int nLength = GetLength();
		PXSTR pszBuffer = GetBuffer( nLength );
		StringTraits::StringLowercase( pszBuffer );
		ReleaseBuffer( nLength );

		return( *this );
	}

	// Reverse the string
	CStringT& MakeReverse()
	{
		int nLength = GetLength();
		PXSTR pszBuffer = GetBuffer( nLength );
		StringTraits::StringReverse( pszBuffer );
		ReleaseBuffer( nLength );

		return( *this );
	}

	// trimming

	// Remove all trailing whitespace
	CStringT& TrimRight()
	{
		// find beginning of trailing spaces by starting
		// at beginning (DBCS aware)

		PCXSTR psz = GetString();
		PCXSTR pszLast = NULL;

		while( *psz != 0 )
		{
			if( StringTraits::IsSpace( *psz ) )
			{
				if( pszLast == NULL )
					pszLast = psz;
			}
			else
			{
				pszLast = NULL;
			}
			psz = StringTraits::CharNext( psz );
		}

		if( pszLast != NULL )
		{
			// truncate at trailing space start
			int iLast = int( pszLast-GetString() );

			Truncate( iLast );
		}

		return( *this );
	}

	// Remove all leading whitespace
	CStringT& TrimLeft()
	{
		// find first non-space character

		PCXSTR psz = GetString();

		while( StringTraits::IsSpace( *psz ) )
		{
			psz = StringTraits::CharNext( psz );
		}

		if( psz != GetString() )
		{
			// fix up data and length
			int iFirst = int( psz-GetString() );
			PXSTR pszBuffer = GetBuffer( GetLength() );
			psz = pszBuffer+iFirst;
			int nDataLength = GetLength()-iFirst;
			memmove( pszBuffer, psz, (nDataLength+1)*sizeof( XCHAR ) );
			ReleaseBuffer( nDataLength );
		}

		return( *this );
	}

	// Remove all leading and trailing whitespace
	CStringT& Trim()
	{
		return( TrimRight().TrimLeft() );
	}

	// Remove all leading and trailing occurrences of character 'chTarget'
	CStringT& Trim( XCHAR chTarget )
	{
		return( TrimRight( chTarget ).TrimLeft( chTarget ) );
	}

	// Remove all leading and trailing occurrences of any of the characters in the string 'pszTargets'
	CStringT& Trim( PCXSTR pszTargets )
	{
		return( TrimRight( pszTargets ).TrimLeft( pszTargets ) );
	}

	// trimming anything (either side)

	// Remove all trailing occurrences of character 'chTarget'
	CStringT& TrimRight( XCHAR chTarget )
	{
		// find beginning of trailing matches
		// by starting at beginning (DBCS aware)

		PCXSTR psz = GetString();
		PCXSTR pszLast = NULL;

		while( *psz != 0 )
		{
			if( *psz == chTarget )
			{
				if( pszLast == NULL )
				{
					pszLast = psz;
				}
			}
			else
			{
				pszLast = NULL;
			}
			psz = StringTraits::CharNext( psz );
		}

		if( pszLast != NULL )
		{
			// truncate at left-most matching character  
			int iLast = int( pszLast-GetString() );
			Truncate( iLast );
		}

		return( *this );
	}

	// Remove all trailing occurrences of any of the characters in string 'pszTargets'
	CStringT& TrimRight( PCXSTR pszTargets )
	{
		// if we're not trimming anything, we're not doing any work
		if( (pszTargets == NULL) || (*pszTargets == 0) )
		{
			return( *this );
		}

		// find beginning of trailing matches
		// by starting at beginning (DBCS aware)

		PCXSTR psz = GetString();
		PCXSTR pszLast = NULL;

		while( *psz != 0 )
		{
			if( StringTraits::StringFindChar( pszTargets, *psz ) != NULL )
			{
				if( pszLast == NULL )
				{
					pszLast = psz;
				}
			}
			else
			{
				pszLast = NULL;
			}
			psz = StringTraits::CharNext( psz );
		}

		if( pszLast != NULL )
		{
			// truncate at left-most matching character  
			int iLast = int( pszLast-GetString() );
			Truncate( iLast );
		}

		return( *this );
	}

	// Remove all leading occurrences of character 'chTarget'
	CStringT& TrimLeft( XCHAR chTarget )
	{
		// find first non-matching character
		PCXSTR psz = GetString();

		while( chTarget == *psz )
		{
			psz = StringTraits::CharNext( psz );
		}

		if( psz != GetString() )
		{
			// fix up data and length
			int iFirst = int( psz-GetString() );
			PXSTR pszBuffer = GetBuffer( GetLength() );
			psz = pszBuffer+iFirst;
			int nDataLength = GetLength()-iFirst;
			memmove( pszBuffer, psz, (nDataLength+1)*sizeof( XCHAR ) );
			ReleaseBuffer( nDataLength );
		}

		return( *this );
	}

	// Remove all leading occurrences of any of the characters in string 'pszTargets'
	CStringT& TrimLeft( PCXSTR pszTargets )
	{
		// if we're not trimming anything, we're not doing any work
		if( (pszTargets == NULL) || (*pszTargets == 0) )
		{
			return( *this );
		}

		PCXSTR psz = GetString();
		while( (*psz != 0) && (StringTraits::StringFindChar( pszTargets, *psz ) != NULL) )
		{
			psz = StringTraits::CharNext( psz );
		}

		if( psz != GetString() )
		{
			// fix up data and length
			int iFirst = int( psz-GetString() );
			PXSTR pszBuffer = GetBuffer( GetLength() );
			psz = pszBuffer+iFirst;
			int nDataLength = GetLength()-iFirst;
			memmove( pszBuffer, psz, (nDataLength+1)*sizeof( XCHAR ) );
			ReleaseBuffer( nDataLength );
		}

		return( *this );
	}

__if_exists( StringTraits::ConvertToOem )
{
	// Convert the string to the OEM character set
	void AnsiToOem()
	{
		int nLength = GetLength();
		PXSTR pszBuffer = GetBuffer( nLength );
		StringTraits::ConvertToOem( pszBuffer );
		ReleaseBuffer( nLength );
	}
}

__if_exists( StringTraits::ConvertToAnsi )
{
	// Convert the string to the ANSI character set
	void OemToAnsi()
	{
		int nLength = GetLength();
		PXSTR pszBuffer = GetBuffer( nLength );
		StringTraits::ConvertToAnsi( pszBuffer );
		ReleaseBuffer( nLength );
	}
}

	// Very simple sub-string extraction

	// Return the substring starting at index 'iFirst'
	CStringT Mid( int iFirst ) const
	{
		return( Mid( iFirst, GetLength()-iFirst ) );
	}

	// Return the substring starting at index 'iFirst', with length 'nCount'
	CStringT Mid( int iFirst, int nCount ) const
	{
		// nCount is in XCHARs

		// out-of-bounds requests return sensible things
		ATLASSERT( iFirst >= 0 );
		ATLASSERT( nCount >= 0 );

		if( (iFirst+nCount) > GetLength() )
		{
			nCount = GetLength()-iFirst;
		}
		if( iFirst > GetLength() )
		{
			nCount = 0;
		}

		ATLASSERT( (nCount == 0) || ((iFirst+nCount) <= GetLength()) );

		// optimize case of returning entire string
		if( (iFirst == 0) && ((iFirst+nCount) == GetLength()) )
		{
			return( *this );
		}

		CStringT strDest( GetManager() );  //GetString()+nFirst, nCount );

		PXSTR pszBuffer = strDest.GetBufferSetLength( nCount );
		memcpy( pszBuffer, GetString()+iFirst, nCount*sizeof( XCHAR ) );
		strDest.ReleaseBuffer( nCount );

		return( strDest );
	}

	// Return the substring consisting of the rightmost 'nCount' characters
	CStringT Right( int nCount ) const
	{
		// nCount is in XCHARs
		ATLASSERT( nCount >= 0 );
		if( nCount >= GetLength() )
		{
			return( *this );
		}

		CStringT strDest( GetManager() );

		PXSTR pszBuffer = strDest.GetBufferSetLength( nCount );
		memcpy( pszBuffer, GetString()+GetLength()-nCount, nCount*sizeof( XCHAR ) );
		strDest.ReleaseBuffer( nCount );

		return( strDest );
	}

	// Return the substring consisting of the leftmost 'nCount' characters
	CStringT Left( int nCount ) const
	{
		// nCount is in XCHARs
		ATLASSERT( nCount >= 0 );
		if( nCount >= GetLength() )
		{
			return( *this );
		}

		CStringT strDest( GetManager() );

		PXSTR pszBuffer = strDest.GetBufferSetLength( nCount );
		memcpy( pszBuffer, GetString(), nCount*sizeof( XCHAR ) );
		strDest.ReleaseBuffer( nCount );

		return( strDest );
	}

	// Return the substring consisting of the leftmost characters in the set 'pszCharSet'
	CStringT SpanIncluding( PCXSTR pszCharSet ) const
	{
		ATLASSERT( AtlIsValidString( pszCharSet ) );

		return( Left( StringTraits::StringSpanIncluding( GetString(), pszCharSet ) ) );
	}

	// Return the substring consisting of the leftmost characters not in the set 'pszCharSet'
	CStringT SpanExcluding( PCXSTR pszCharSet ) const
	{
		ATLASSERT( AtlIsValidString( pszCharSet ) );
		return( Left( StringTraits::StringSpanExcluding( GetString(), pszCharSet ) ) );
 	}

	// Format data using format string 'pszFormat'
	void __cdecl Format( PCXSTR pszFormat, ... )
	{
		ATLASSERT( AtlIsValidString( pszFormat ) );

		va_list argList;
		va_start( argList, pszFormat );
		FormatV( pszFormat, argList );
		va_end( argList );
	}

	// Format data using format string loaded from resource 'nFormatID'
	void __cdecl Format( UINT nFormatID, ... )
	{
		CStringT strFormat( GetManager() );
		ATLVERIFY( strFormat.LoadString( nFormatID ) );

		va_list argList;
		va_start( argList, nFormatID );
		FormatV( strFormat, argList );
		va_end( argList );
	}

	// Append formatted data using format string loaded from resource 'nFormatID'
	void __cdecl AppendFormat( UINT nFormatID, ... )
	{
		CStringT strTemp( GetManager() );
		va_list argList;
		va_start( argList, nFormatID );

		CStringT strFormat( GetManager() );
		ATLVERIFY( strFormat.LoadString( nFormatID ) ); 

		strTemp.FormatV( strFormat, argList );
		operator+=( strTemp );

		va_end( argList );
	}

	// Append formatted data using format string 'pszFormat'
	void __cdecl AppendFormat( PCXSTR pszFormat, ... )
	{
		ATLASSERT( AtlIsValidString( pszFormat ) );

		CStringT strTemp( GetManager() );
		va_list argList;
		va_start( argList, pszFormat );

		strTemp.FormatV( pszFormat, argList );
		operator+=( strTemp );

		va_end( argList );
	}

	void FormatV( PCXSTR pszFormat, va_list args )
	{
		ATLASSERT( AtlIsValidString( pszFormat ) );

		int nLength = StringTraits::GetFormattedLength( pszFormat, args );
		PXSTR pszBuffer = GetBuffer( nLength );
		StringTraits::Format( pszBuffer, pszFormat, args );
		ReleaseBuffer( nLength );
	}

__if_exists(StringTraits::FormatMessage)
{
	// Format a message using format string 'pszFormat'
	void __cdecl FormatMessage( PCXSTR pszFormat, ... )
	{
		va_list argList;
		va_start( argList, pszFormat );

		FormatMessageV( pszFormat, &argList );

		va_end( argList );
	}

	// Format a message using format string loaded from resource 'nFormatID'
	void __cdecl FormatMessage( UINT nFormatID, ... )
	{
		// get format string from string table
		CStringT strFormat( GetManager() );
		ATLVERIFY( strFormat.LoadString( nFormatID ) );

		va_list argList;
		va_start( argList, nFormatID );

		FormatMessageV( strFormat, &argList );

		va_end( argList );
	}
}

	// OLE BSTR support

	// Allocate a BSTR containing a copy of the string
	BSTR AllocSysString() const
	{
		BSTR bstrResult = StringTraits::AllocSysString( GetString(), 
			GetLength() );
		if( bstrResult == NULL )
		{
			ThrowMemoryException();
		}

		return( bstrResult );
	}

	BSTR SetSysString( BSTR* pbstr ) const
	{
		ATLASSERT( AtlIsValidAddress( pbstr, sizeof( BSTR ) ) );

		if( !StringTraits::ReAllocSysString( GetString(), pbstr,
			GetLength() ) )
		{
			ThrowMemoryException();
		}

		ATLASSERT( *pbstr != NULL );
		return( *pbstr );
	}

	// Set the string to the value of environment variable 'pszVar'
	BOOL GetEnvironmentVariable( PCXSTR pszVar )
	{
		ULONG nLength = StringTraits::GetEnvironmentVariable( pszVar, NULL, 0 );
		BOOL bRetVal = FALSE;

		if( nLength == 0 )
		{
			Empty();
		}
		else
		{
			PXSTR pszBuffer = GetBuffer( nLength );
			StringTraits::GetEnvironmentVariable( pszVar, pszBuffer, nLength );
			ReleaseBuffer();
			bRetVal = TRUE;
		}
		
		return( bRetVal );
	}

	// Load the string from resource 'nID'
	BOOL LoadString( UINT nID )
	{
		HINSTANCE hInst = StringTraits::FindStringResourceInstance( nID );
		if( hInst == NULL )
		{
			return( FALSE );
		}

		return( LoadString( hInst, nID ) );		
	}

	// Load the string from resource 'nID' in module 'hInstance'
	BOOL LoadString( HINSTANCE hInstance, UINT nID )
	{
		const ATLSTRINGRESOURCEIMAGE* pImage = AtlGetStringResourceImage( hInstance, nID );
		if( pImage == NULL )
		{
			return( FALSE );
		}

		int nLength = StringTraits::GetBaseTypeLength( pImage->achString, pImage->nLength );
		PXSTR pszBuffer = GetBuffer( nLength );
		StringTraits::ConvertToBaseType( pszBuffer, nLength, pImage->achString, pImage->nLength );
		ReleaseBuffer( nLength );

		return( TRUE );
	}

	// Load the string from resource 'nID' in module 'hInstance', using language 'wLanguageID'
	BOOL LoadString( HINSTANCE hInstance, UINT nID, WORD wLanguageID )
	{
		const ATLSTRINGRESOURCEIMAGE* pImage = AtlGetStringResourceImage( hInstance, nID, wLanguageID );
		if( pImage == NULL )
		{
			return( FALSE );
		}

		int nLength = StringTraits::GetBaseTypeLength( pImage->achString, pImage->nLength );
		PXSTR pszBuffer = GetBuffer( nLength );
		StringTraits::ConvertToBaseType( pszBuffer, nLength, pImage->achString, pImage->nLength );
		ReleaseBuffer( nLength );

		return( TRUE );
	}

	friend CStringT operator+( const CStringT& str1, const CStringT& str2 )
	{
		CStringT strResult( str1.GetManager() );

		Concatenate( strResult, str1, str1.GetLength(), str2, str2.GetLength() );

		return( strResult );
	}

	friend CStringT operator+( const CStringT& str1, PCXSTR psz2 )
	{
		CStringT strResult( str1.GetManager() );

		Concatenate( strResult, str1, str1.GetLength(), psz2, StringLength( psz2 ) );

		return( strResult );
	}

	friend CStringT operator+( PCXSTR psz1, const CStringT& str2 )
	{
		CStringT strResult( str2.GetManager() );

		Concatenate( strResult, psz1, StringLength( psz1 ), str2, str2.GetLength() );

		return( strResult );
	}

	friend CStringT operator+( const CStringT& str1, wchar_t ch2 )
	{
		CStringT strResult( str1.GetManager() );
		XCHAR chTemp = XCHAR( ch2 );

		Concatenate( strResult, str1, str1.GetLength(), &chTemp, 1 );

		return( strResult );
	}

	friend CStringT operator+( const CStringT& str1, char ch2 )
	{
		CStringT strResult( str1.GetManager() );
		XCHAR chTemp = XCHAR( ch2 );

		Concatenate( strResult, str1, str1.GetLength(), &chTemp, 1 );

		return( strResult );
	}

	friend CStringT operator+( wchar_t ch1, const CStringT& str2 )
	{
		CStringT strResult( str2.GetManager() );
		XCHAR chTemp = XCHAR( ch1 );

		Concatenate( strResult, &chTemp, 1, str2, str2.GetLength() );

		return( strResult );
	}

	friend CStringT operator+( char ch1, const CStringT& str2 )
	{
		CStringT strResult( str2.GetManager() );
		XCHAR chTemp = XCHAR( ch1 );

		Concatenate( strResult, &chTemp, 1, str2, str2.GetLength() );

		return( strResult );
	}

	friend bool operator==( const CStringT& str1, const CStringT& str2 ) throw()
	{
		return( str1.Compare( str2 ) == 0 );
	}

	friend bool operator==(
		const CStringT& str1, PCXSTR psz2 ) throw()
	{
		return( str1.Compare( psz2 ) == 0 );
	}

	friend bool operator==(
		PCXSTR psz1, const CStringT& str2 ) throw()
	{
		return( str2.Compare( psz1 ) == 0 );
	}

	friend bool operator==(
		const CStringT& str1, PCYSTR psz2 ) throw( ... )
	{
		CStringT str2( psz2, str1.GetManager() );

		return( str1 == str2 );
	}

	friend bool operator==(
		PCYSTR psz1, const CStringT& str2 ) throw( ... )
	{
		CStringT str1( psz1, str2.GetManager() );

		return( str1 == str2 );
	}

	friend bool operator!=(
		const CStringT& str1, const CStringT& str2 ) throw()
	{
		return( str1.Compare( str2 ) != 0 );
	}

	friend bool operator!=(
		const CStringT& str1, PCXSTR psz2 ) throw()
	{
		return( str1.Compare( psz2 ) != 0 );
	}

	friend bool operator!=(
		PCXSTR psz1, const CStringT& str2 ) throw()
	{
		return( str2.Compare( psz1 ) != 0 );
	}

	friend bool operator!=(
		const CStringT& str1, PCYSTR psz2 ) throw( ... )
	{
		CStringT str2( psz2, str1.GetManager() );

		return( str1 != str2 );
	}

	friend bool operator!=(
		PCYSTR psz1, const CStringT& str2 ) throw( ... )
	{
		CStringT str1( psz1, str2.GetManager() );

		return( str1 != str2 );
	}

	friend bool operator<( const CStringT& str1, const CStringT& str2 ) throw()
	{
		return( str1.Compare( str2 ) < 0 );
	}

	friend bool operator<( const CStringT& str1, PCXSTR psz2 ) throw()
	{
		return( str1.Compare( psz2 ) < 0 );
	}

	friend bool operator<( PCXSTR psz1, const CStringT& str2 ) throw()
	{
		return( str2.Compare( psz1 ) >= 0 );
	}

	friend bool operator>( const CStringT& str1, const CStringT& str2 ) throw()
	{
		return( str1.Compare( str2 ) > 0 );
	}

	friend bool operator>( const CStringT& str1, PCXSTR psz2 ) throw()
	{
		return( str1.Compare( psz2 ) > 0 );
	}

	friend bool operator>( PCXSTR psz1, const CStringT& str2 ) throw()
	{
		return( str2.Compare( psz1 ) <= 0 );
	}

	friend bool operator<=( const CStringT& str1, const CStringT& str2 ) throw()
	{
		return( str1.Compare( str2 ) <= 0 );
	}

	friend bool operator<=( const CStringT& str1, PCXSTR psz2 ) throw()
	{
		return( str1.Compare( psz2 ) <= 0 );
	}

	friend bool operator<=( PCXSTR psz1, const CStringT& str2 ) throw()
	{
		return( str2.Compare( psz1 ) > 0 );
	}

	friend bool operator>=( const CStringT& str1, const CStringT& str2 ) throw()
	{
		return( str1.Compare( str2 ) >= 0 );
	}

	friend bool operator>=( const CStringT& str1, PCXSTR psz2 ) throw()
	{
		return( str1.Compare( psz2 ) >= 0 );
	}

	friend bool operator>=( PCXSTR psz1, const CStringT& str2 ) throw()
	{
		return( str2.Compare( psz1 ) < 0 );
	}

	friend bool operator==( XCHAR ch1, const CStringT& str2 ) throw()
	{
		return( (str2.GetLength() == 1) && (str2[0] == ch1) );
	}

	friend bool operator==( const CStringT& str1, XCHAR ch2 ) throw()
	{
		return( (str1.GetLength() == 1) && (str1[0] == ch2) );
	}

	friend bool operator!=( XCHAR ch1, const CStringT& str2 ) throw()
	{
		return( (str2.GetLength() != 1) || (str2[0] != ch1) );
	}

	friend bool operator!=( const CStringT& str1, XCHAR ch2 ) throw()
	{
		return( (str1.GetLength() != 1) || (str1[0] != ch2) );
	}

private:
	bool CheckImplicitLoad( const void* pv )
	{
		bool bRet = false;

		if( (pv != NULL) && IS_INTRESOURCE( pv ) )
		{
			UINT nID = LOWORD( reinterpret_cast< DWORD_PTR >( pv ) );
			if( !LoadString( nID ) )
			{
				ATLTRACE( atlTraceString, 2, _T( "Warning: implicit LoadString(%u) failed\n" ), nID );
			}
			bRet = true;
		}

		return( bRet );
	}

__if_exists( StringTraits::FormatMessage )
{
	void FormatMessageV( PCXSTR pszFormat, va_list* pArgList )
	{
		// format message into temporary buffer pszTemp
		CHeapPtr< XCHAR, CLocalAllocator > pszTemp;
		DWORD dwResult = StringTraits::FormatMessage( FORMAT_MESSAGE_FROM_STRING|
			FORMAT_MESSAGE_ALLOCATE_BUFFER, pszFormat, 0, 0, reinterpret_cast< PXSTR >( &pszTemp ),
			0, pArgList );
		if( dwResult == 0 )
		{
			ThrowMemoryException();
		}

		*this = pszTemp;
	}
}
};

class IFixedStringLog
{
public:
	virtual void OnAllocateSpill( int nActualChars, int nFixedChars, const CStringData* pData ) throw() = 0;
	virtual void OnReallocateSpill( int nActualChars, int nFixedChars, const CStringData* pData ) throw() = 0;
};

class CFixedStringMgr :
	public IAtlStringMgr
{
public:
	CFixedStringMgr( CStringData* pData, int nChars, IAtlStringMgr* pMgr = NULL ) throw() :
		m_pData( pData ),
		m_pMgr( pMgr )
	{
		m_pData->nRefs = -1;
		m_pData->nDataLength = 0;
		m_pData->nAllocLength = nChars;
		m_pData->pStringMgr = this;
		*static_cast< wchar_t* >( m_pData->data() ) = 0;
	}
	~CFixedStringMgr() throw()
	{
	}

// IAtlStringMgr
public:
	virtual CStringData* Allocate( int nChars, int nCharSize ) throw()
	{
		ATLASSERT( m_pData->nRefs == -1 );
		ATLASSERT( m_pData->nDataLength == 0 );
		if( nChars > m_pData->nAllocLength )
		{
			if( s_pLog != NULL )
			{
				s_pLog->OnAllocateSpill( nChars, m_pData->nAllocLength, m_pData );
			}
			CStringData* pData = m_pMgr->Allocate( nChars, nCharSize );
			if( pData != NULL )
			{
				pData->pStringMgr = this;
				pData->nRefs = -1;  // Locked
			}

			return pData;
		}

		m_pData->nRefs = -1;  // Locked
		m_pData->nDataLength = 0;
		m_pData->pStringMgr = this;

		return m_pData;
	}
	virtual void Free( CStringData* pData ) throw()
	{
		ATLASSERT( pData->nRefs <= 0 );
		if( pData != m_pData )
		{
			// Must have been allocated from the backup manager
			pData->pStringMgr = m_pMgr;
			m_pMgr->Free( pData );
		}

		// Always make sure the fixed buffer is ready to be used as the nil string.
		m_pData->nRefs = -1;
		m_pData->nDataLength = 0;
		*static_cast< wchar_t* >( m_pData->data() ) = 0;
	}
	virtual CStringData* Reallocate( CStringData* pData, int nChars, int nCharSize ) throw()
	{
		CStringData* pNewData;

		ATLASSERT( pData->nRefs < 0 );
		if( pData != m_pData )
		{
			pData->pStringMgr = m_pMgr;
			pNewData = m_pMgr->Reallocate( pData, nChars, nCharSize );
			if( pNewData == NULL )
			{
				pData->pStringMgr = this;
			}
			else
			{
				pNewData->pStringMgr = this;
			}
		}
		else
		{
			if( nChars > pData->nAllocLength )
			{
				if( s_pLog != NULL )
				{
					s_pLog->OnReallocateSpill( nChars, pData->nAllocLength, pData );
				}
				pNewData = m_pMgr->Allocate( nChars, nCharSize );
				if( pNewData == NULL )
				{
					return NULL;
				}

				// Copy the string data
				memcpy( pNewData->data(), pData->data(), (pData->nAllocLength+1)*nCharSize );
				pNewData->nRefs = pData->nRefs;  // Locked
				pNewData->pStringMgr = this;
				pNewData->nDataLength = pData->nDataLength;
			}
			else
			{
				// Don't do anything if the buffer is already big enough.
				pNewData = pData;
			}
		}

		return pNewData;
	}
	virtual CStringData* GetNilString() throw()
	{
		ATLASSERT( m_pData->nRefs == -1 );
		ATLASSERT( m_pData->nDataLength == 0 );

		return m_pData;
	}
	virtual IAtlStringMgr* Clone() throw()
	{
		return m_pMgr;
	}

public:
	static IFixedStringLog* s_pLog;

	IAtlStringMgr* GetBackupManager() const throw()
	{
		return m_pMgr;
	}

protected:
	IAtlStringMgr* m_pMgr;
	CStringData* m_pData;
};

__declspec( selectany ) IFixedStringLog* CFixedStringMgr::s_pLog = NULL;

#pragma warning( push )
#pragma warning( disable: 4355 )  // 'this' used in base member initializer list

template< class StringType, int t_nChars >
class CFixedStringT :
	private CFixedStringMgr,  // This class must be first, since it needs to be initialized before StringType
	public StringType
{
public:
	CFixedStringT() throw() :
		CFixedStringMgr( &m_data, t_nChars, StrTraits::GetDefaultManager() ),
		StringType( static_cast< CFixedStringMgr* >( this ) )
	{
	}

	explicit CFixedStringT( IAtlStringMgr* pStringMgr ) throw() :
		CFixedStringMgr( &m_data, t_nChars, pStringMgr ),
		StringType( static_cast< CFixedStringMgr* >( this ) )
	{
	}

	CFixedStringT( const CFixedStringT< StringType, t_nChars >& str ) :
		CFixedStringMgr( &m_data, t_nChars, StrTraits::GetDefaultManager() ),
		StringType( str.GetString(), str.GetLength(), static_cast< CFixedStringMgr* >( this ) )
	{
	}

	CFixedStringT( const StringType& str ) :
		CFixedStringMgr( &m_data, t_nChars, StrTraits::GetDefaultManager() ),
		StringType( str.GetString(), str.GetLength(), static_cast< CFixedStringMgr* >( this ) )
	{
	}

	CFixedStringT( const StringType::XCHAR* psz ) :
		CFixedStringMgr( &m_data, t_nChars, StrTraits::GetDefaultManager() ),
		StringType( psz, static_cast< CFixedStringMgr* >( this ) )
	{
	}

	CFixedStringT( const StringType::XCHAR* psz, int nLength ) :
		CFixedStringMgr( &m_data, t_nChars, StrTraits::GetDefaultManager() ),
		StringType( psz, nLength, static_cast< CFixedStringMgr* >( this ) )
	{
	}

	explicit CFixedStringT( const StringType::YCHAR* psz ) :
		CFixedStringMgr( &m_data, t_nChars, StrTraits::GetDefaultManager() ),
		StringType( psz, static_cast< CFixedStringMgr* >( this ) )
	{
	}

	explicit CFixedStringT( const unsigned char* psz ) :
		CFixedStringMgr( &m_data, t_nChars, StrTraits::GetDefaultManager() ),
		StringType( psz, static_cast< CFixedStringMgr* >( this ) )
	{
	}

	~CFixedStringT() throw()
	{
		Empty();
	}

	CFixedStringT< StringType, t_nChars >& operator=( const CFixedStringT< StringType, t_nChars >& str )
	{
		StringType::operator=( str );
		return *this;
	}

	CFixedStringT< StringType, t_nChars >& operator=( const char* psz )
	{
		StringType::operator=( psz );
		return *this;
	}

	CFixedStringT< StringType, t_nChars >& operator=( const wchar_t* psz )
	{
		StringType::operator=( psz );
		return *this;
	}

	CFixedStringT< StringType, t_nChars >& operator=( const unsigned char* psz )
	{
		StringType::operator=( psz );
		return *this;
	}

	CFixedStringT< StringType, t_nChars >& operator=( const StringType& str )
	{
		StringType::operator=( str );
		return *this;
	}

// Implementation
protected:
	CStringData m_data;
	StringType::XCHAR m_achData[t_nChars+1];
};

#pragma warning( pop )
class CFixedStringLog :
	public IFixedStringLog
{
public:
	CFixedStringLog() throw()
	{
		CFixedStringMgr::s_pLog = this;
	}
	~CFixedStringLog() throw()
	{
		CFixedStringMgr::s_pLog = NULL;
	}

public:
	void OnAllocateSpill( int nActualChars, int nFixedChars, const CStringData* pData ) throw()
	{
		(void)nActualChars;
		(void)nFixedChars;
		(void)pData;
		ATLTRACE( atlTraceString, 0, _T( "CFixedStringMgr::Allocate() spilling to heap.  %d chars (fixed size = %d chars)\n" ), nActualChars, nFixedChars );
	}
	void OnReallocateSpill( int nActualChars, int nFixedChars, const CStringData* pData ) throw()
	{
		(void)nActualChars;
		(void)nFixedChars;
		(void)pData;
		ATLTRACE( atlTraceString, 0, _T( "CFixedStringMgr::Reallocate() spilling to heap.  %d chars (fixed size = %d chars)\n" ), nActualChars, nFixedChars );
	}
};

};  // namespace ATL

#pragma pop_macro("new")

#endif	// __CSTRINGT_H__ (whole file)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atlmfc\statreg.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#pragma message("statreg.cpp is obsolete. Please remove it from your project.")

///////////////////////////////////////
// No longer used
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atlmfc\dbgautoattach.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0280 */
/* at Wed Mar 08 12:46:13 2000
 */
/* Compiler settings for dbgautoattach.idl:
    Os (OptLev=s), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dbgautoattach_h__
#define __dbgautoattach_h__

/* Forward Declarations */ 

#ifndef __IDebugAutoAttach_FWD_DEFINED__
#define __IDebugAutoAttach_FWD_DEFINED__
typedef interface IDebugAutoAttach IDebugAutoAttach;
#endif 	/* __IDebugAutoAttach_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_dbgautoattach_0000 */
/* [local] */ 

DEFINE_GUID(CLSID_DebugAutoAttach, 0x70f65411, 0xfe8c, 0x4248, 0xbc, 0xff, 0x70, 0x1c, 0x8b, 0x2f, 0x45, 0x29);


extern RPC_IF_HANDLE __MIDL_itf_dbgautoattach_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dbgautoattach_0000_v0_0_s_ifspec;

#ifndef __IDebugAutoAttach_INTERFACE_DEFINED__
#define __IDebugAutoAttach_INTERFACE_DEFINED__

/* interface IDebugAutoAttach */
/* [unique][uuid][object] */ 


enum __MIDL_IDebugAutoAttach_0001
    {	AUTOATTACH_PROGRAM_WIN32	= 0x1,
	AUTOATTACH_PROGRAM_COMPLUS	= 0x2
    };
typedef DWORD AUTOATTACH_PROGRAM_TYPE;


EXTERN_C const IID IID_IDebugAutoAttach;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E9958F1F-0A56-424a-A300-530EBB2E9865")
    IDebugAutoAttach : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AutoAttach( 
            /* [in] */ REFGUID guidPort,
            /* [in] */ DWORD dwPid,
            /* [in] */ AUTOATTACH_PROGRAM_TYPE dwProgramType,
            /* [in] */ DWORD dwProgramId,
            /* [in] */ LPCWSTR pszSessionId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugAutoAttachVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugAutoAttach __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugAutoAttach __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugAutoAttach __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AutoAttach )( 
            IDebugAutoAttach __RPC_FAR * This,
            /* [in] */ REFGUID guidPort,
            /* [in] */ DWORD dwPid,
            /* [in] */ AUTOATTACH_PROGRAM_TYPE dwProgramType,
            /* [in] */ DWORD dwProgramId,
            /* [in] */ LPCWSTR pszSessionId);
        
        END_INTERFACE
    } IDebugAutoAttachVtbl;

    interface IDebugAutoAttach
    {
        CONST_VTBL struct IDebugAutoAttachVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugAutoAttach_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugAutoAttach_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugAutoAttach_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugAutoAttach_AutoAttach(This,guidPort,dwPid,dwProgramType,dwProgramId,pszSessionId)	\
    (This)->lpVtbl -> AutoAttach(This,guidPort,dwPid,dwProgramType,dwProgramId,pszSessionId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugAutoAttach_AutoAttach_Proxy( 
    IDebugAutoAttach __RPC_FAR * This,
    /* [in] */ REFGUID guidPort,
    /* [in] */ DWORD dwPid,
    /* [in] */ AUTOATTACH_PROGRAM_TYPE dwProgramType,
    /* [in] */ DWORD dwProgramId,
    /* [in] */ LPCWSTR pszSessionId);


void __RPC_STUB IDebugAutoAttach_AutoAttach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugAutoAttach_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atls\allocate.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#ifndef ATLDEBUG_SHAREDMEORY_ALLOCATOR_HEADER
#define ATLDEBUG_SHAREDMEORY_ALLOCATOR_HEADER

class CAtlTraceProcess;
class CAtlTraceModule;
class CAtlTraceCategory;

class CTraceSnapshot
{
public:
	struct CModuleInfo
	{
		DWORD_PTR m_dwModule;
		int m_nCategories;
		int m_iFirstCategory;
	};

public:
	CSimpleArray< CModuleInfo > m_aModules;
	CSimpleArray< DWORD_PTR > m_adwCategories;
};

class CAtlAllocator
{
public:
	CAtlAllocator() :
		m_dwPageSize(0), 
		m_hMap(NULL),
		m_bValid(false),
		m_pProcess(NULL),
		m_bSnapshot(false)
	{
	}

	~CAtlAllocator() 
	{
		Close();
	}

	bool Init(const CHAR *pszFileMappingName, DWORD dwMaxSize);
	bool Open(const CHAR *pszFileMappingName);
	void Close(bool bForceUnmap = false);
	bool IsValid() const {return m_bValid;}

	CAtlTraceProcess *GetProcess() const {return m_pProcess;}
	CAtlTraceModule *GetModule(int iModule) const;
//	CAtlTraceCategory *GetCategory(int iModule, unsigned nCategory) const;
	CAtlTraceCategory* GetCategory(int iCategory) const;

	/*
	bool Lock(DWORD dwTimeOut);
	void Unlock();
	*/

	bool LoadSettings(const CHAR *pszFileName);
	bool LoadSettings(const WCHAR *pszFileName);
	bool SaveSettings(const CHAR *pszFileName);
	bool SaveSettings(const WCHAR *pszFileName);

	int GetModuleCount() const;
	int GetCategoryCount(int iModule) const;
	int GetCategoryCount(const CAtlTraceModule& Module) const;

	int AddModule(HINSTANCE hInst);
	int AddCategory(int iModule, const WCHAR *szCategoryName);

	bool RemoveModule(int iModule);

	void CleanUp();

	void TakeSnapshot();
	void ReleaseSnapshot();

	CTraceSnapshot m_snapshot;
	bool m_bSnapshot;

private:
	CAtlTraceProcess *m_pProcess;
	DWORD m_dwPageSize;
	HANDLE m_hMap;
	bool m_bValid;
	BYTE *m_pBufferStart;
};

#endif // ATLDEBUG_SHAREDMEORY_ALLOCATOR_HEADER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atlmfc\statreg.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __STATREG_H__
#define __STATREG_H__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLBASE_H__
	#error statreg.h requires atlbase.h to be included first
#endif

#define E_ATL_REGISTRAR_DESC              0x0201
#define E_ATL_NOT_IN_MAP                  0x0202
#define E_ATL_UNEXPECTED_EOS              0x0203
#define E_ATL_VALUE_SET_FAILED            0x0204
#define E_ATL_RECURSE_DELETE_FAILED       0x0205
#define E_ATL_EXPECTING_EQUAL             0x0206
#define E_ATL_CREATE_KEY_FAILED           0x0207
#define E_ATL_DELETE_KEY_FAILED           0x0208
#define E_ATL_OPEN_KEY_FAILED             0x0209
#define E_ATL_CLOSE_KEY_FAILED            0x020A
#define E_ATL_UNABLE_TO_COERCE            0x020B
#define E_ATL_BAD_HKEY                    0x020C
#define E_ATL_MISSING_OPENKEY_TOKEN       0x020D
#define E_ATL_CONVERT_FAILED              0x020E
#define E_ATL_TYPE_NOT_SUPPORTED          0x020F
#define E_ATL_COULD_NOT_CONCAT            0x0210
#define E_ATL_COMPOUND_KEY                0x0211
#define E_ATL_INVALID_MAPKEY              0x0212
#define E_ATL_UNSUPPORTED_VT              0x0213
#define E_ATL_VALUE_GET_FAILED            0x0214
#define E_ATL_VALUE_TOO_LARGE             0x0215
#define E_ATL_MISSING_VALUE_DELIMETER     0x0216
#define E_ATL_DATA_NOT_BYTE_ALIGNED       0x0217

namespace ATL
{
const TCHAR  chDirSep            = _T('\\');
const TCHAR  chRightBracket      = _T('}');
const TCHAR  chLeftBracket       = _T('{');
const TCHAR  chQuote             = _T('\'');
const TCHAR  chEquals            = _T('=');
const LPCTSTR  szStringVal       = _T("S");
const LPCTSTR  multiszStringVal  = _T("M");
const LPCTSTR  szDwordVal        = _T("D");
const LPCTSTR  szBinaryVal       = _T("B");
const LPCTSTR  szValToken        = _T("Val");
const LPCTSTR  szForceRemove     = _T("ForceRemove");
const LPCTSTR  szNoRemove        = _T("NoRemove");
const LPCTSTR  szDelete          = _T("Delete");


// Implementation helper
class CExpansionVectorEqualHelper
{
public:
	static bool IsEqualKey(const LPTSTR k1, const LPTSTR k2)
	{
		if (lstrcmpi(k1, k2) == 0)
			return true;
		return false;
	}

	// Not used
	static bool IsEqualValue(const LPCOLESTR /*v1*/, const LPCOLESTR /*v2*/)
	{
		return false;
	}
};

// Implementation helper
class CExpansionVector : public CSimpleMap<LPTSTR, LPOLESTR, CExpansionVectorEqualHelper >
{
public:
	~CExpansionVector()
	{
		 ClearReplacements();
	}

	BOOL Add(LPCTSTR lpszKey, LPCOLESTR lpszValue)
	{
		ATLASSERT(lpszKey != NULL && lpszValue != NULL);
		if (lpszKey == NULL || lpszValue == NULL)
			return FALSE;

		HRESULT hRes = S_OK;

		size_t cbKey = (lstrlen(lpszKey)+1)*sizeof(TCHAR);
		TCHAR* szKey = NULL;
		
		ATLTRY(szKey = new TCHAR[cbKey];)

		size_t cbValue = (ocslen(lpszValue)+1)*sizeof(OLECHAR);
		LPOLESTR szValue = NULL;
		ATLTRY(szValue = new OLECHAR[cbValue];)
		
		if (szKey == NULL || szValue == NULL)
			hRes = E_OUTOFMEMORY;
		else
		{
			memcpy(szKey, lpszKey, cbKey);
			memcpy(szValue, lpszValue, cbValue);
			if (!CSimpleMap<LPTSTR, LPOLESTR, CExpansionVectorEqualHelper>::Add(szKey, szValue))
				hRes = E_OUTOFMEMORY;
		}
		if (FAILED(hRes))
		{
			delete []szKey;
			delete []szValue;
		}
		return SUCCEEDED(hRes);
	}
	HRESULT ClearReplacements()
	{
		for (int i = 0; i < GetSize(); i++)
		{
			delete []GetKeyAt(i);
			delete []GetValueAt(i);
		}
		RemoveAll();
		return S_OK;
	}
};

class CRegObject;

class CRegParser
{
public:
	CRegParser(CRegObject* pRegObj);

	HRESULT  PreProcessBuffer(LPTSTR lpszReg, LPTSTR* ppszReg);
	HRESULT  RegisterBuffer(LPTSTR szReg, BOOL bRegister);

protected:

	void    SkipWhiteSpace();
	HRESULT NextToken(LPTSTR szToken);
	HRESULT AddValue(CRegKey& rkParent,LPCTSTR szValueName, LPTSTR szToken);
	BOOL    CanForceRemoveKey(LPCTSTR szKey);
	BOOL    HasSubKeys(HKEY hkey);
	BOOL    HasValues(HKEY hkey);
	HRESULT RegisterSubkeys(LPTSTR szToken, HKEY hkParent, BOOL bRegister, BOOL bInRecovery = FALSE);
	BOOL    IsSpace(TCHAR ch);
	LPTSTR  m_pchCur;

	CRegObject*     m_pRegObj;

	HRESULT GenerateError(UINT) {return DISP_E_EXCEPTION;}
	HRESULT HandleReplacements(LPTSTR& szToken);
	HRESULT SkipAssignment(LPTSTR szToken);

	BOOL    EndOfVar() { return chQuote == *m_pchCur && chQuote != *CharNext(m_pchCur); }
	static LPTSTR StrChr(LPTSTR lpsz, TCHAR ch);
	static HKEY HKeyFromString(LPTSTR szToken);
	static BYTE ChToByte(const TCHAR ch);
	static BOOL VTFromRegType(LPCTSTR szValueType, VARTYPE& vt);
	static LPCTSTR rgszNeverDelete[];
	static const int cbNeverDelete;
	static const int MAX_VALUE = 4096;
	static const int MAX_TYPE = 4096;
	
	// Implementation Helper
	class CParseBuffer
	{
	public:
		int nPos;
		int nSize;
		LPTSTR p;
		CParseBuffer(int nInitial)
		{
			if (nInitial < 100)
				nInitial = 1000;
			nPos = 0;
			nSize = nInitial;
			p = (LPTSTR) CoTaskMemAlloc(nSize*sizeof(TCHAR));
			if (p != NULL)
				*p = NULL;
		}
		~CParseBuffer()
		{
			CoTaskMemFree(p);
		}
		BOOL Append(const TCHAR* pch, int nChars)
		{
			ATLASSERT(p != NULL);
			if ((nPos + nChars + 1) >= nSize)
			{
				while ((nPos + nChars + 1) >= nSize)
					nSize *=2;
				LPTSTR pTemp = (LPTSTR) CoTaskMemRealloc(p, nSize*sizeof(TCHAR));
				if (pTemp == NULL)
					return FALSE;
				p = pTemp;
			}
			memcpy(p + nPos, pch, int(nChars * sizeof(TCHAR)));
			nPos += nChars;
			*(p + nPos) = NULL;
			return TRUE;			
		}
		
		BOOL AddChar(const TCHAR* pch)
		{
#ifndef _UNICODE		
			int nChars = int(CharNext(pch) - pch);
#else
			int nChars = 1;
#endif
			return Append(pch, nChars);

		}
		BOOL AddString(LPCOLESTR lpsz)
		{
			if (lpsz == NULL)
				return FALSE;
			USES_CONVERSION;
			LPCTSTR lpszT = OLE2CT(lpsz);
			if (lpszT == NULL)
				return FALSE;
			return Append(lpszT, (int)lstrlen(lpszT));
		}
		LPTSTR Detach()
		{
			LPTSTR lp = p;
			p = NULL;
			nSize = nPos = 0;
			return lp;
		}

	};
};

#if defined(_ATL_DLL) | defined(_ATL_DLL_IMPL)
class ATL_NO_VTABLE CRegObject
 : public IRegistrar
#else
class CRegObject  : public IRegistrarBase
#endif
{
public:

#if defined(_ATL_DLL) | defined(_ATL_DLL_IMPL)

#else
	STDMETHOD(QueryInterface)(const IID &,void ** )
	{
		ATLASSERT(_T("statically linked in CRegObject is not a com object. Do not callthis function"));
		return E_NOTIMPL;
	}

	STDMETHOD_(ULONG, AddRef)(void)
	{
		ATLASSERT(_T("statically linked in CRegObject is not a com object. Do not callthis function"));
		return 1;
	}
	STDMETHOD_(ULONG, Release)(void)
	{
		ATLASSERT(_T("statically linked in CRegObject is not a com object. Do not callthis function"));
		return 0;
	}
#endif
	~CRegObject(){ClearReplacements();}
	HRESULT FinalConstruct() {return S_OK;}
	void FinalRelease() {}


	// Map based methods
	HRESULT STDMETHODCALLTYPE AddReplacement(LPCOLESTR lpszKey, LPCOLESTR lpszItem);
	HRESULT STDMETHODCALLTYPE ClearReplacements();
	LPCOLESTR StrFromMap(LPTSTR lpszKey);

	// Register via a given mechanism
	HRESULT STDMETHODCALLTYPE ResourceRegister(LPCOLESTR pszFileName, UINT nID, LPCOLESTR pszType);
	HRESULT STDMETHODCALLTYPE ResourceRegisterSz(LPCOLESTR pszFileName, LPCOLESTR pszID, LPCOLESTR pszType);
	HRESULT STDMETHODCALLTYPE ResourceUnregister(LPCOLESTR pszFileName, UINT nID, LPCOLESTR pszType);
	HRESULT STDMETHODCALLTYPE ResourceUnregisterSz(LPCOLESTR pszFileName, LPCOLESTR pszID, LPCOLESTR pszType);
	HRESULT STDMETHODCALLTYPE FileRegister(LPCOLESTR bstrFileName)
	{
		return CommonFileRegister(bstrFileName, TRUE);
	}

	HRESULT STDMETHODCALLTYPE FileUnregister(LPCOLESTR bstrFileName)
	{
		return CommonFileRegister(bstrFileName, FALSE);
	}

	HRESULT STDMETHODCALLTYPE StringRegister(LPCOLESTR bstrData)
	{
		return RegisterWithString(bstrData, TRUE);
	}

	HRESULT STDMETHODCALLTYPE StringUnregister(LPCOLESTR bstrData)
	{
		return RegisterWithString(bstrData, FALSE);
	}

protected:

	HRESULT CommonFileRegister(LPCOLESTR pszFileName, BOOL bRegister);
	HRESULT RegisterFromResource(LPCOLESTR pszFileName, LPCTSTR pszID, LPCTSTR pszType, BOOL bRegister);
	HRESULT RegisterWithString(LPCOLESTR pszData, BOOL bRegister);

	static HRESULT GenerateError(UINT) {return DISP_E_EXCEPTION;}

	CExpansionVector								m_RepMap;
	CComObjectThreadModel::AutoCriticalSection      m_csMap;
};

inline HRESULT STDMETHODCALLTYPE CRegObject::AddReplacement(LPCOLESTR lpszKey, LPCOLESTR lpszItem)
{
	if (lpszKey == NULL || lpszItem == NULL)
		return E_INVALIDARG;
	m_csMap.Lock();
	USES_CONVERSION;
	BOOL bRet = m_RepMap.Add(OLE2CT(lpszKey), lpszItem);
	m_csMap.Unlock();
	return bRet ? S_OK : E_OUTOFMEMORY;
}

inline HRESULT CRegObject::RegisterFromResource(LPCOLESTR bstrFileName, LPCTSTR szID,
										 LPCTSTR szType, BOOL bRegister)
{
	USES_CONVERSION;

	HRESULT     hr;
	CRegParser  parser(this);
	HINSTANCE   hInstResDll;
	HRSRC       hrscReg;
	HGLOBAL     hReg;
	DWORD       dwSize;
	LPSTR       szRegA;
	LPTSTR      szReg;

	hInstResDll = LoadLibraryEx(OLE2CT(bstrFileName), NULL, LOAD_LIBRARY_AS_DATAFILE);

	if (NULL == hInstResDll)
	{
		ATLTRACE(atlTraceRegistrar, 0, _T("Failed to LoadLibrary on %s\n"), bstrFileName);
		hr = AtlHresultFromLastError();
		goto ReturnHR;
	}

	hrscReg = FindResource((HMODULE)hInstResDll, szID, szType);

	if (NULL == hrscReg)
	{
		ATLTRACE(atlTraceRegistrar, 0, (HIWORD(szID) == NULL) ? 
			_T("Failed to FindResource on ID:%d TYPE:%s\n") : 
			_T("Failed to FindResource on ID:%s TYPE:%s\n"), 
			szID, szType);
		hr = AtlHresultFromLastError();
		goto ReturnHR;
	}

	hReg = LoadResource((HMODULE)hInstResDll, hrscReg);

	if (NULL == hReg)
	{
		ATLTRACE(atlTraceRegistrar, 0, _T("Failed to LoadResource\n"));
		hr = AtlHresultFromLastError();
		goto ReturnHR;
	}

	dwSize = SizeofResource((HMODULE)hInstResDll, hrscReg);
	szRegA = (LPSTR)hReg;
	if (szRegA[dwSize] != NULL)
	{
		szRegA = (LPSTR)_alloca(dwSize+1);
		memcpy(szRegA, (void*)hReg, dwSize+1);
		szRegA[dwSize] = NULL;
	}

	szReg = A2T(szRegA);

	hr = parser.RegisterBuffer(szReg, bRegister);

ReturnHR:

	if (NULL != hInstResDll)
		FreeLibrary((HMODULE)hInstResDll);
	return hr;
}

inline HRESULT STDMETHODCALLTYPE CRegObject::ResourceRegister(LPCOLESTR szFileName, UINT nID, LPCOLESTR szType)
{
	USES_CONVERSION;
	return RegisterFromResource(szFileName, MAKEINTRESOURCE(nID), OLE2CT(szType), TRUE);
}

inline HRESULT STDMETHODCALLTYPE CRegObject::ResourceRegisterSz(LPCOLESTR szFileName, LPCOLESTR szID, LPCOLESTR szType)
{
	USES_CONVERSION;
	if (szID == NULL || szType == NULL)
		return E_INVALIDARG;
	return RegisterFromResource(szFileName, OLE2CT(szID), OLE2CT(szType), TRUE);
}

inline HRESULT STDMETHODCALLTYPE CRegObject::ResourceUnregister(LPCOLESTR szFileName, UINT nID, LPCOLESTR szType)
{
	USES_CONVERSION;
	return RegisterFromResource(szFileName, MAKEINTRESOURCE(nID), OLE2CT(szType), FALSE);
}

inline HRESULT STDMETHODCALLTYPE CRegObject::ResourceUnregisterSz(LPCOLESTR szFileName, LPCOLESTR szID, LPCOLESTR szType)
{
	USES_CONVERSION;
	if (szID == NULL || szType == NULL)
		return E_INVALIDARG;

	return RegisterFromResource(szFileName, OLE2CT(szID), OLE2CT(szType), FALSE);
}

inline HRESULT CRegObject::RegisterWithString(LPCOLESTR bstrData, BOOL bRegister)
{
	USES_CONVERSION;
	CRegParser  parser(this);

	LPCTSTR szReg = OLE2CT(bstrData);
	if (szReg == NULL)
		return E_OUTOFMEMORY;

	HRESULT hr = parser.RegisterBuffer((LPTSTR)szReg, bRegister);

	return hr;
}

inline HRESULT CRegObject::ClearReplacements()
{
	m_csMap.Lock();
	HRESULT hr = m_RepMap.ClearReplacements();
	m_csMap.Unlock();
	return hr;
}


inline LPCOLESTR CRegObject::StrFromMap(LPTSTR lpszKey)
{
	USES_CONVERSION;
	m_csMap.Lock();
	LPCOLESTR lpsz = m_RepMap.Lookup(lpszKey);
	if (lpsz == NULL) // not found!!
		ATLTRACE(atlTraceRegistrar, 0, _T("Map Entry not found\n"));
	m_csMap.Unlock();
	return lpsz;
}

inline HRESULT CRegObject::CommonFileRegister(LPCOLESTR bstrFileName, BOOL bRegister)
{
	USES_CONVERSION;

	CRegParser  parser(this);

	HANDLE hFile = CreateFile(OLE2CT(bstrFileName), GENERIC_READ, 0, NULL,
							  OPEN_EXISTING,
							  FILE_ATTRIBUTE_READONLY,
							  NULL);
	if (INVALID_HANDLE_VALUE == hFile)
	{
		ATLTRACE(atlTraceRegistrar, 0, _T("Failed to CreateFile on %s\n"), OLE2CT(bstrFileName));
		return AtlHresultFromLastError();
	}

	HRESULT hRes = S_OK;
	DWORD cbRead;
	DWORD cbFile = GetFileSize(hFile, NULL); // No HiOrder DWORD required
	char* szReg = (char*)_alloca(cbFile + 1);
	if (ReadFile(hFile, szReg, cbFile, &cbRead, NULL) == 0)
	{
		ATLTRACE(atlTraceRegistrar, 0, _T("Read Failed on file%s\n"), OLE2CT(bstrFileName));
		hRes =  AtlHresultFromLastError();
	}
	if (SUCCEEDED(hRes))
	{
		szReg[cbRead] = NULL;
		LPTSTR szConverted = A2T(szReg);
		hRes = parser.RegisterBuffer(szConverted, bRegister);
	}
	CloseHandle(hFile);
	return hRes;
}

__declspec(selectany) LPCTSTR CRegParser::rgszNeverDelete[] =
{
	_T("AppID"),
	_T("CLSID"),
	_T("Component Categories"),
	_T("FileType"),
	_T("Interface"),
	_T("Hardware"),
	_T("Mime"),
	_T("SAM"),
	_T("SECURITY"),
	_T("SYSTEM"),
	_T("Software"),
	_T("TypeLib")
};

__declspec(selectany) const int CRegParser::cbNeverDelete = sizeof(rgszNeverDelete) / sizeof(LPCTSTR*);


inline BOOL CRegParser::VTFromRegType(LPCTSTR szValueType, VARTYPE& vt)
{
	struct typemap
	{
		LPCTSTR lpsz;
		VARTYPE vt;
	};
	static const typemap map[] = {
		{szStringVal, VT_BSTR},
		{multiszStringVal, VT_BSTR | VT_BYREF},
		{szDwordVal,  VT_UI4},
		{szBinaryVal, VT_UI1}
	};

	for (int i=0;i<sizeof(map)/sizeof(typemap);i++)
	{
		if (!lstrcmpi(szValueType, map[i].lpsz))
		{
			vt = map[i].vt;
			return TRUE;
		}
	}

	return FALSE;

}

inline BYTE CRegParser::ChToByte(const TCHAR ch)
{
	switch (ch)
	{
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
				return (BYTE) (ch - '0');
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
				return (BYTE) (10 + (ch - 'A'));
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
				return (BYTE) (10 + (ch - 'a'));
		default:
				ATLASSERT(FALSE);
				ATLTRACE(atlTraceRegistrar, 0, _T("Bogus value %c passed as binary Hex value\n"), ch);
				return 0;
	}
}

inline HKEY CRegParser::HKeyFromString(LPTSTR szToken)
{
	struct keymap
	{
		LPCTSTR lpsz;
		HKEY hkey;
	};
	static const keymap map[] = {
		{_T("HKCR"), HKEY_CLASSES_ROOT},
		{_T("HKCU"), HKEY_CURRENT_USER},
		{_T("HKLM"), HKEY_LOCAL_MACHINE},
		{_T("HKU"),  HKEY_USERS},
		{_T("HKPD"), HKEY_PERFORMANCE_DATA},
		{_T("HKDD"), HKEY_DYN_DATA},
		{_T("HKCC"), HKEY_CURRENT_CONFIG},
		{_T("HKEY_CLASSES_ROOT"), HKEY_CLASSES_ROOT},
		{_T("HKEY_CURRENT_USER"), HKEY_CURRENT_USER},
		{_T("HKEY_LOCAL_MACHINE"), HKEY_LOCAL_MACHINE},
		{_T("HKEY_USERS"), HKEY_USERS},
		{_T("HKEY_PERFORMANCE_DATA"), HKEY_PERFORMANCE_DATA},
		{_T("HKEY_DYN_DATA"), HKEY_DYN_DATA},
		{_T("HKEY_CURRENT_CONFIG"), HKEY_CURRENT_CONFIG}
	};

	for (int i=0;i<sizeof(map)/sizeof(keymap);i++)
	{
		if (!lstrcmpi(szToken, map[i].lpsz))
			return map[i].hkey;
	}
	return NULL;
}

inline LPTSTR CRegParser::StrChr(LPTSTR lpsz, TCHAR ch)
{
	LPTSTR p = NULL;
	while (*lpsz)
	{
		if (*lpsz == ch)
		{
			p = lpsz;
			break;
		}
		lpsz = CharNext(lpsz);
	}
	return p;
}

inline CRegParser::CRegParser(CRegObject* pRegObj)
{
	m_pRegObj           = pRegObj;
	m_pchCur            = NULL;
}

inline BOOL CRegParser::IsSpace(TCHAR ch)
{
	switch (ch)
	{
		case _T(' '):
		case _T('\t'):
		case _T('\r'):
		case _T('\n'):
				return TRUE;
	}

	return FALSE;
}

inline void CRegParser::SkipWhiteSpace()
{
	while(IsSpace(*m_pchCur))
		m_pchCur = CharNext(m_pchCur);
}

inline HRESULT CRegParser::NextToken(LPTSTR szToken)
{
	USES_CONVERSION;

	SkipWhiteSpace();

	// NextToken cannot be called at EOS
	if (NULL == *m_pchCur)
		return GenerateError(E_ATL_UNEXPECTED_EOS);

	// handle quoted value / key
	if (chQuote == *m_pchCur)
	{
		LPCTSTR szOrig = szToken;

		m_pchCur = CharNext(m_pchCur);

		while (NULL != *m_pchCur && !EndOfVar())
		{
			if (chQuote == *m_pchCur) // If it is a quote that means we must skip it
				m_pchCur = CharNext(m_pchCur);

			LPTSTR pchPrev = m_pchCur;
			m_pchCur = CharNext(m_pchCur);

			if (szToken + sizeof(WORD) >= MAX_VALUE + szOrig)
				return GenerateError(E_ATL_VALUE_TOO_LARGE);
			for (int i = 0; pchPrev+i < m_pchCur; i++, szToken++)
				*szToken = *(pchPrev+i);
		}

		if (NULL == *m_pchCur)
		{
			ATLTRACE(atlTraceRegistrar, 0, _T("NextToken : Unexpected End of File\n"));
			return GenerateError(E_ATL_UNEXPECTED_EOS);
		}

		*szToken = NULL;
		m_pchCur = CharNext(m_pchCur);
	}

	else
	{   // Handle non-quoted ie parse up till first "White Space"
		while (NULL != *m_pchCur && !IsSpace(*m_pchCur))
		{
			LPTSTR pchPrev = m_pchCur;
			m_pchCur = CharNext(m_pchCur);
			for (int i = 0; pchPrev+i < m_pchCur; i++, szToken++)
				*szToken = *(pchPrev+i);
		}

		*szToken = NULL;
	}
	return S_OK;
}

inline HRESULT CRegParser::AddValue(CRegKey& rkParent,LPCTSTR szValueName, LPTSTR szToken)
{
	USES_CONVERSION;
	HRESULT hr;

	TCHAR       szTypeToken[MAX_TYPE];
	VARTYPE     vt = VT_EMPTY;
	LONG        lRes = ERROR_SUCCESS;
	UINT        nIDRes = 0;

	if (FAILED(hr = NextToken(szTypeToken)))
		return hr;
	if (!VTFromRegType(szTypeToken, vt))
	{
		ATLTRACE(atlTraceRegistrar, 0, _T("%s Type not supported\n"), szTypeToken);
		return GenerateError(E_ATL_TYPE_NOT_SUPPORTED);
	}

	TCHAR szValue[MAX_VALUE];
	SkipWhiteSpace();
	if (FAILED(hr = NextToken(szValue)))
		return hr;
	ULONG ulVal;

	switch (vt)
	{
	case VT_BSTR:
		lRes = rkParent.SetStringValue(szValueName, szValue);
		ATLTRACE(atlTraceRegistrar, 2, _T("Setting Value %s at %s\n"), szValue, !szValueName ? _T("default") : szValueName);
		break;
	case VT_BSTR | VT_BYREF:
		{
			ATLTRACE(atlTraceRegistrar, 2, _T("Setting Value %s at %s\n"), szValue, !szValueName ? _T("default") : szValueName);
			int nLen = lstrlen(szValue);
			TCHAR* pszDestValue = (TCHAR*) _alloca(nLen * sizeof(TCHAR));
			if (pszDestValue != NULL)
			{
				TCHAR* p = pszDestValue;
				TCHAR* q = szValue;
				nLen = 0;
				while (*q != NULL)
				{
					TCHAR* r = CharNext(q);
					if (*q == '\\' && *r == '0')
					{
						*p++ = NULL;
						q = CharNext(r);
					}
					else
					{
						*p = *q;
#ifndef _UNICODE
						if (IsDBCSLeadByte(*q))
						{
							p++;
							q++;
							*p = *q;
						}
#endif
						p++;
						q++;
					}
					nLen ++;
				}
				*p = NULL;
				lRes = rkParent.SetMultiStringValue(szValueName, pszDestValue);
			}
			else
			{
				lRes = ERROR_OUTOFMEMORY;
			}
		}
		break;
	case VT_UI4:
		VarUI4FromStr(T2OLE(szValue), 0, 0, &ulVal);
		lRes = rkParent.SetDWORDValue(szValueName, ulVal);
		ATLTRACE(atlTraceRegistrar, 2, _T("Setting Value %d at %s\n"), ulVal, !szValueName ? _T("default") : szValueName);
		break;
	case VT_UI1:
		{
			int cbValue = lstrlen(szValue);
			if (cbValue & 0x00000001)
			{
				ATLTRACE(atlTraceRegistrar, 0, _T("Binary Data does not fall on BYTE boundries\n"));
				return E_FAIL;
			}
			int cbValDiv2 = cbValue/2;
			BYTE* rgBinary = (BYTE*)_alloca(cbValDiv2*sizeof(BYTE));
			memset(rgBinary, 0, cbValDiv2);
			if (rgBinary == NULL)
				return E_FAIL;
			for (int irg = 0; irg < cbValue; irg++)
				rgBinary[(irg/2)] |= (ChToByte(szValue[irg])) << (4*(1 - (irg & 0x00000001)));
			lRes = RegSetValueEx(rkParent, szValueName, 0, REG_BINARY, rgBinary, cbValDiv2);
			break;
		}
	}

	if (ERROR_SUCCESS != lRes)
	{
		nIDRes = E_ATL_VALUE_SET_FAILED;
		return AtlHresultFromWin32(lRes);
	}

	if (FAILED(hr = NextToken(szToken)))
		return hr;

	return S_OK;
}

inline BOOL CRegParser::CanForceRemoveKey(LPCTSTR szKey)
{
	for (int iNoDel = 0; iNoDel < cbNeverDelete; iNoDel++)
		if (!lstrcmpi(szKey, rgszNeverDelete[iNoDel]))
			 return FALSE;                       // We cannot delete it

	return TRUE;
}

inline BOOL CRegParser::HasSubKeys(HKEY hkey)
{
	DWORD       cbSubKeys = 0;

	if (RegQueryInfoKey(hkey, NULL, NULL, NULL,
							   &cbSubKeys, NULL, NULL,
							   NULL, NULL, NULL, NULL, NULL) != ERROR_SUCCESS)
	{
		ATLTRACE(atlTraceRegistrar, 0, _T("Should not be here!!\n"));
		ATLASSERT(FALSE);
		return FALSE;
	}

	return cbSubKeys > 0;
}

inline BOOL CRegParser::HasValues(HKEY hkey)
{
	DWORD       cbValues = 0;

	LONG lResult = RegQueryInfoKey(hkey, NULL, NULL, NULL,
								  NULL, NULL, NULL,
								  &cbValues, NULL, NULL, NULL, NULL);
	if (ERROR_SUCCESS != lResult)
	{
		ATLTRACE(atlTraceRegistrar, 0, _T("RegQueryInfoKey Failed "));
		ATLASSERT(FALSE);
		return FALSE;
	}

	if (1 == cbValues)
	{
		DWORD cbMaxName= MAX_VALUE;
		TCHAR szValueName[MAX_VALUE];
		// Check to see if the Value is default or named
		lResult = RegEnumValue(hkey, 0, szValueName, &cbMaxName, NULL, NULL, NULL, NULL);
		if (ERROR_SUCCESS == lResult && (szValueName[0] != NULL))
			return TRUE; // Named Value means we have a value
		return FALSE;
	}

	return cbValues > 0; // More than 1 means we have a non-default value
}

inline HRESULT CRegParser::SkipAssignment(LPTSTR szToken)
{
	HRESULT hr;
	TCHAR szValue[MAX_VALUE];

	if (*szToken == chEquals)
	{
		if (FAILED(hr = NextToken(szToken)))
			return hr;
		// Skip assignment
		SkipWhiteSpace();
		if (FAILED(hr = NextToken(szValue)))
			return hr;
		if (FAILED(hr = NextToken(szToken)))
			return hr;
	}

	return S_OK;
}

inline HRESULT CRegParser::PreProcessBuffer(LPTSTR lpszReg, LPTSTR* ppszReg)
{
	USES_CONVERSION;
	ATLASSERT(lpszReg != NULL);
	ATLASSERT(ppszReg != NULL);
	*ppszReg = NULL;
	int nSize = lstrlen(lpszReg)*2;
	CParseBuffer pb(nSize);
	if (pb.p == NULL)
		return E_OUTOFMEMORY;
	m_pchCur = lpszReg;
	HRESULT hr = S_OK;

	while (*m_pchCur != NULL) // look for end
	{
		if (*m_pchCur == _T('%'))
		{
			m_pchCur = CharNext(m_pchCur);
			if (*m_pchCur == _T('%'))
			{
				if (!pb.AddChar(m_pchCur))
				{
					hr = E_OUTOFMEMORY;
					break;
				}
			}
			else
			{
				LPTSTR lpszNext = StrChr(m_pchCur, _T('%'));
				if (lpszNext == NULL)
				{
					ATLTRACE(atlTraceRegistrar, 0, _T("Error no closing % found\n"));
					hr = GenerateError(E_ATL_UNEXPECTED_EOS);
					break;
				}
				if ((lpszNext-m_pchCur) > 31)
				{
					hr = E_FAIL;
					break;
				}
				int nLength = int(lpszNext - m_pchCur);
				TCHAR buf[32];
				lstrcpyn(buf, m_pchCur, nLength+1);
				LPCOLESTR lpszVar = m_pRegObj->StrFromMap(buf);
				if (lpszVar == NULL)
				{
					hr = GenerateError(E_ATL_NOT_IN_MAP);
					break;
				}
				if (!pb.AddString(lpszVar))
				{
					hr = E_OUTOFMEMORY;
					break;
				}

				while (m_pchCur != lpszNext)
					m_pchCur = CharNext(m_pchCur);
			}
		}
		else
		{
			if (!pb.AddChar(m_pchCur))
			{
				hr = E_OUTOFMEMORY;
				break;
			}
		}

		m_pchCur = CharNext(m_pchCur);
	}
	if (SUCCEEDED(hr))
		*ppszReg = pb.Detach();
	return hr;
}

inline HRESULT CRegParser::RegisterBuffer(LPTSTR szBuffer, BOOL bRegister)
{
	TCHAR   szToken[MAX_VALUE];
	HRESULT hr = S_OK;

	LPTSTR szReg;
	hr = PreProcessBuffer(szBuffer, &szReg);
	if (FAILED(hr))
		return hr;

	ATLTRACE(atlTraceRegistrar, 0, szReg);
	ATLTRACE(atlTraceRegistrar, 0, _T("\n"));

	m_pchCur = szReg;

	// Preprocess szReg

	while (NULL != *m_pchCur)
	{
		if (FAILED(hr = NextToken(szToken)))
			break;
		HKEY hkBase;
		if ((hkBase = HKeyFromString(szToken)) == NULL)
		{
			ATLTRACE(atlTraceRegistrar, 0, _T("HKeyFromString failed on %s\n"), szToken);
			hr = GenerateError(E_ATL_BAD_HKEY);
			break;
		}

		if (FAILED(hr = NextToken(szToken)))
			break;

		if (chLeftBracket != *szToken)
		{
			ATLTRACE(atlTraceRegistrar, 0, _T("Syntax error, expecting a {, found a %s\n"), szToken);
			hr = GenerateError(E_ATL_MISSING_OPENKEY_TOKEN);
			break;
		}
		if (bRegister)
		{
			LPTSTR szRegAtRegister = m_pchCur;
			hr = RegisterSubkeys(szToken, hkBase, bRegister);
			if (FAILED(hr))
			{
				ATLTRACE(atlTraceRegistrar, 0, _T("Failed to register, cleaning up!\n"));
				m_pchCur = szRegAtRegister;
				RegisterSubkeys(szToken, hkBase, FALSE);
				break;
			}
		}
		else
		{
			if (FAILED(hr = RegisterSubkeys(szToken, hkBase, bRegister)))
				break;
		}

		SkipWhiteSpace();
	}
	CoTaskMemFree(szReg);
	return hr;
}

inline HRESULT CRegParser::RegisterSubkeys(LPTSTR szToken, HKEY hkParent, BOOL bRegister, BOOL bRecover)
{
	CRegKey keyCur;
	LONG    lRes;
	LPTSTR  szKey = NULL;
	BOOL    bDelete = TRUE;
	BOOL    bInRecovery = bRecover;
	HRESULT hr = S_OK;

	ATLTRACE(atlTraceRegistrar, 2, _T("Num Els = %d\n"), cbNeverDelete);
	if (FAILED(hr = NextToken(szToken)))
		return hr;


	while (*szToken != chRightBracket) // Continue till we see a }
	{
		bDelete = TRUE;
		BOOL bTokenDelete = !lstrcmpi(szToken, szDelete);

		if (!lstrcmpi(szToken, szForceRemove) || bTokenDelete)
		{
			if (FAILED(hr = NextToken(szToken)))
				break;

			if (bRegister)
			{
				CRegKey rkForceRemove;

				if (StrChr(szToken, chDirSep) != NULL)
					return GenerateError(E_ATL_COMPOUND_KEY);

				if (CanForceRemoveKey(szToken))
				{
					rkForceRemove.Attach(hkParent);
					// Error not returned. We will overwrite the values any way.
					rkForceRemove.RecurseDeleteKey(szToken);
					rkForceRemove.Detach();
				}
				if (bTokenDelete)
				{
					if (FAILED(hr = NextToken(szToken)))
						break;
					if (FAILED(hr = SkipAssignment(szToken)))
						break;
					goto EndCheck;
				}
			}

		}

		if (!lstrcmpi(szToken, szNoRemove))
		{
			bDelete = FALSE;    // set even for register
			if (FAILED(hr = NextToken(szToken)))
				break;
		}

		if (!lstrcmpi(szToken, szValToken)) // need to add a value to hkParent
		{
			TCHAR  szValueName[_MAX_PATH];

			if (FAILED(hr = NextToken(szValueName)))
				break;
			if (FAILED(hr = NextToken(szToken)))
				break;


			if (*szToken != chEquals)
				return GenerateError(E_ATL_EXPECTING_EQUAL);

			if (bRegister)
			{
				CRegKey rk;

				rk.Attach(hkParent);
				hr = AddValue(rk, szValueName, szToken);
				rk.Detach();

				if (FAILED(hr))
					return hr;

				goto EndCheck;
			}
			else
			{
				if (!bRecover && bDelete)
				{
					ATLTRACE(atlTraceRegistrar, 1, _T("Deleting %s\n"), szValueName);
					// We have to open the key for write to be able to delete.
					CRegKey rkParent;
					lRes = rkParent.Open(hkParent, NULL, KEY_WRITE);
					if (lRes == ERROR_SUCCESS)
					{
						lRes = rkParent.DeleteValue(szValueName);
						if (lRes != ERROR_SUCCESS && lRes != ERROR_FILE_NOT_FOUND)
						{
							// Key not present is not an error
							hr = AtlHresultFromWin32(lRes);
							break;
						}
					}
					else
					{
						hr = AtlHresultFromWin32(lRes);
						break;
					}
				}
				if (FAILED(hr = SkipAssignment(szToken)))
					break;
				continue;  // can never have a subkey
			}
		}

		if (StrChr(szToken, chDirSep) != NULL)
			return GenerateError(E_ATL_COMPOUND_KEY);

		if (bRegister)
		{
			lRes = keyCur.Open(hkParent, szToken, KEY_READ | KEY_WRITE);
			if (ERROR_SUCCESS != lRes)
			{
				// Failed all access try read only
				lRes = keyCur.Open(hkParent, szToken, KEY_READ);
				if (ERROR_SUCCESS != lRes)
				{
					// Finally try creating it
					ATLTRACE(atlTraceRegistrar, 2, _T("Creating key %s\n"), szToken);
					lRes = keyCur.Create(hkParent, szToken, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE);
					if (lRes != ERROR_SUCCESS)
						return AtlHresultFromWin32(lRes);
				}
			}

			if (FAILED(hr = NextToken(szToken)))
				break;


			if (*szToken == chEquals)
			{
				if (FAILED(hr = AddValue(keyCur, NULL, szToken))) // NULL == default
					break;
			}
		}
		else
		{
			if (!bRecover)
				lRes = keyCur.Open(hkParent, szToken, KEY_READ);
			else
				lRes = ERROR_FILE_NOT_FOUND;


			// Open failed set recovery mode
			if (lRes != ERROR_SUCCESS)
				bRecover = true;

			// TRACE out Key open status and if in recovery mode
#ifdef _DEBUG
			if (!bRecover)
				ATLTRACE(atlTraceRegistrar, 1, _T("Opened Key %s\n"), szToken);
			else
				ATLTRACE(atlTraceRegistrar, 0, _T("Ignoring Open key on %s : In Recovery mode\n"), szToken);
#endif //_DEBUG

			// Remember Subkey
			if (szKey == NULL)
				szKey = (LPTSTR)_alloca(sizeof(TCHAR)*_MAX_PATH);
			lstrcpyn(szKey, szToken, _MAX_PATH);

			if (FAILED(hr = NextToken(szToken)))
				break;
			if (FAILED(hr = SkipAssignment(szToken)))
				break;

			if (*szToken == chLeftBracket)
			{
				hr = RegisterSubkeys(szToken, keyCur.m_hKey, bRegister, bRecover);
				// In recover mode ignore error
				if (FAILED(hr) && !bRecover)
					break;
				// Skip the }
				if (FAILED(hr = NextToken(szToken)))
					break;
			}

#ifdef _DEBUG
			if (bRecover != bInRecovery)
				ATLTRACE(atlTraceRegistrar, 0, _T("Ending Recovery Mode\n"));
#endif
			bRecover = bInRecovery;
			
			if (lRes == ERROR_FILE_NOT_FOUND)
				// Key already not present so not an error.
				continue;

			if (lRes != ERROR_SUCCESS)
			{
				// We are recovery mode continue on errors else break
				if (bRecover)
					continue;
				else
				{
					hr = AtlHresultFromWin32(lRes);
					break;
				}
			}

			// If in recovery mode
			if (bRecover && HasSubKeys(keyCur))
			{
				// See if the KEY is in the NeverDelete list and if so, don't
				if (CanForceRemoveKey(szKey) && bDelete)
				{
					ATLTRACE(atlTraceRegistrar, 0, _T("Deleting non-empty subkey %s by force\n"), szKey);
					// Error not returned since we are in recovery mode. The error that caused recovery mode is returned
					keyCur.RecurseDeleteKey(szKey);
				}
				continue;
			}

			lRes = keyCur.Close();
			if (lRes != ERROR_SUCCESS)
			   return AtlHresultFromWin32(lRes);

			if (bDelete)
			{
				ATLTRACE(atlTraceRegistrar, 0, _T("Deleting Key %s\n"), szKey);
				CRegKey rkParent;
				rkParent.Attach(hkParent);
				lRes = rkParent.DeleteSubKey(szKey);
				rkParent.Detach();
				if (lRes != ERROR_SUCCESS)
				{
					hr = AtlHresultFromWin32(lRes);
					break;
				}
			}
		}

EndCheck:

		if (bRegister)
		{
			if (*szToken == chLeftBracket && lstrlen(szToken) == 1)
			{
				if (FAILED(hr = RegisterSubkeys(szToken, keyCur.m_hKey, bRegister, FALSE)))
					break;
				if (FAILED(hr = NextToken(szToken)))
					break;
			}
		}
	}

	return hr;
}

}; //namespace ATL

#endif //__STATREG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atlmfc\msxml2.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0340 */
/* Compiler settings for msxml2.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __msxml2_h__
#define __msxml2_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IXMLDOMImplementation_FWD_DEFINED__
#define __IXMLDOMImplementation_FWD_DEFINED__
typedef interface IXMLDOMImplementation IXMLDOMImplementation;
#endif 	/* __IXMLDOMImplementation_FWD_DEFINED__ */


#ifndef __IXMLDOMNode_FWD_DEFINED__
#define __IXMLDOMNode_FWD_DEFINED__
typedef interface IXMLDOMNode IXMLDOMNode;
#endif 	/* __IXMLDOMNode_FWD_DEFINED__ */


#ifndef __IXMLDOMDocumentFragment_FWD_DEFINED__
#define __IXMLDOMDocumentFragment_FWD_DEFINED__
typedef interface IXMLDOMDocumentFragment IXMLDOMDocumentFragment;
#endif 	/* __IXMLDOMDocumentFragment_FWD_DEFINED__ */


#ifndef __IXMLDOMDocument_FWD_DEFINED__
#define __IXMLDOMDocument_FWD_DEFINED__
typedef interface IXMLDOMDocument IXMLDOMDocument;
#endif 	/* __IXMLDOMDocument_FWD_DEFINED__ */


#ifndef __IXMLDOMSchemaCollection_FWD_DEFINED__
#define __IXMLDOMSchemaCollection_FWD_DEFINED__
typedef interface IXMLDOMSchemaCollection IXMLDOMSchemaCollection;
#endif 	/* __IXMLDOMSchemaCollection_FWD_DEFINED__ */


#ifndef __IXMLDOMDocument2_FWD_DEFINED__
#define __IXMLDOMDocument2_FWD_DEFINED__
typedef interface IXMLDOMDocument2 IXMLDOMDocument2;
#endif 	/* __IXMLDOMDocument2_FWD_DEFINED__ */


#ifndef __IXMLDOMNodeList_FWD_DEFINED__
#define __IXMLDOMNodeList_FWD_DEFINED__
typedef interface IXMLDOMNodeList IXMLDOMNodeList;
#endif 	/* __IXMLDOMNodeList_FWD_DEFINED__ */


#ifndef __IXMLDOMNamedNodeMap_FWD_DEFINED__
#define __IXMLDOMNamedNodeMap_FWD_DEFINED__
typedef interface IXMLDOMNamedNodeMap IXMLDOMNamedNodeMap;
#endif 	/* __IXMLDOMNamedNodeMap_FWD_DEFINED__ */


#ifndef __IXMLDOMCharacterData_FWD_DEFINED__
#define __IXMLDOMCharacterData_FWD_DEFINED__
typedef interface IXMLDOMCharacterData IXMLDOMCharacterData;
#endif 	/* __IXMLDOMCharacterData_FWD_DEFINED__ */


#ifndef __IXMLDOMAttribute_FWD_DEFINED__
#define __IXMLDOMAttribute_FWD_DEFINED__
typedef interface IXMLDOMAttribute IXMLDOMAttribute;
#endif 	/* __IXMLDOMAttribute_FWD_DEFINED__ */


#ifndef __IXMLDOMElement_FWD_DEFINED__
#define __IXMLDOMElement_FWD_DEFINED__
typedef interface IXMLDOMElement IXMLDOMElement;
#endif 	/* __IXMLDOMElement_FWD_DEFINED__ */


#ifndef __IXMLDOMText_FWD_DEFINED__
#define __IXMLDOMText_FWD_DEFINED__
typedef interface IXMLDOMText IXMLDOMText;
#endif 	/* __IXMLDOMText_FWD_DEFINED__ */


#ifndef __IXMLDOMComment_FWD_DEFINED__
#define __IXMLDOMComment_FWD_DEFINED__
typedef interface IXMLDOMComment IXMLDOMComment;
#endif 	/* __IXMLDOMComment_FWD_DEFINED__ */


#ifndef __IXMLDOMProcessingInstruction_FWD_DEFINED__
#define __IXMLDOMProcessingInstruction_FWD_DEFINED__
typedef interface IXMLDOMProcessingInstruction IXMLDOMProcessingInstruction;
#endif 	/* __IXMLDOMProcessingInstruction_FWD_DEFINED__ */


#ifndef __IXMLDOMCDATASection_FWD_DEFINED__
#define __IXMLDOMCDATASection_FWD_DEFINED__
typedef interface IXMLDOMCDATASection IXMLDOMCDATASection;
#endif 	/* __IXMLDOMCDATASection_FWD_DEFINED__ */


#ifndef __IXMLDOMDocumentType_FWD_DEFINED__
#define __IXMLDOMDocumentType_FWD_DEFINED__
typedef interface IXMLDOMDocumentType IXMLDOMDocumentType;
#endif 	/* __IXMLDOMDocumentType_FWD_DEFINED__ */


#ifndef __IXMLDOMNotation_FWD_DEFINED__
#define __IXMLDOMNotation_FWD_DEFINED__
typedef interface IXMLDOMNotation IXMLDOMNotation;
#endif 	/* __IXMLDOMNotation_FWD_DEFINED__ */


#ifndef __IXMLDOMEntity_FWD_DEFINED__
#define __IXMLDOMEntity_FWD_DEFINED__
typedef interface IXMLDOMEntity IXMLDOMEntity;
#endif 	/* __IXMLDOMEntity_FWD_DEFINED__ */


#ifndef __IXMLDOMEntityReference_FWD_DEFINED__
#define __IXMLDOMEntityReference_FWD_DEFINED__
typedef interface IXMLDOMEntityReference IXMLDOMEntityReference;
#endif 	/* __IXMLDOMEntityReference_FWD_DEFINED__ */


#ifndef __IXMLDOMParseError_FWD_DEFINED__
#define __IXMLDOMParseError_FWD_DEFINED__
typedef interface IXMLDOMParseError IXMLDOMParseError;
#endif 	/* __IXMLDOMParseError_FWD_DEFINED__ */


#ifndef __IXTLRuntime_FWD_DEFINED__
#define __IXTLRuntime_FWD_DEFINED__
typedef interface IXTLRuntime IXTLRuntime;
#endif 	/* __IXTLRuntime_FWD_DEFINED__ */


#ifndef __IXSLTemplate_FWD_DEFINED__
#define __IXSLTemplate_FWD_DEFINED__
typedef interface IXSLTemplate IXSLTemplate;
#endif 	/* __IXSLTemplate_FWD_DEFINED__ */


#ifndef __IXSLProcessor_FWD_DEFINED__
#define __IXSLProcessor_FWD_DEFINED__
typedef interface IXSLProcessor IXSLProcessor;
#endif 	/* __IXSLProcessor_FWD_DEFINED__ */


#ifndef __ISAXXMLReader_FWD_DEFINED__
#define __ISAXXMLReader_FWD_DEFINED__
typedef interface ISAXXMLReader ISAXXMLReader;
#endif 	/* __ISAXXMLReader_FWD_DEFINED__ */


#ifndef __ISAXXMLFilter_FWD_DEFINED__
#define __ISAXXMLFilter_FWD_DEFINED__
typedef interface ISAXXMLFilter ISAXXMLFilter;
#endif 	/* __ISAXXMLFilter_FWD_DEFINED__ */


#ifndef __ISAXLocator_FWD_DEFINED__
#define __ISAXLocator_FWD_DEFINED__
typedef interface ISAXLocator ISAXLocator;
#endif 	/* __ISAXLocator_FWD_DEFINED__ */


#ifndef __ISAXEntityResolver_FWD_DEFINED__
#define __ISAXEntityResolver_FWD_DEFINED__
typedef interface ISAXEntityResolver ISAXEntityResolver;
#endif 	/* __ISAXEntityResolver_FWD_DEFINED__ */


#ifndef __ISAXContentHandler_FWD_DEFINED__
#define __ISAXContentHandler_FWD_DEFINED__
typedef interface ISAXContentHandler ISAXContentHandler;
#endif 	/* __ISAXContentHandler_FWD_DEFINED__ */


#ifndef __ISAXDTDHandler_FWD_DEFINED__
#define __ISAXDTDHandler_FWD_DEFINED__
typedef interface ISAXDTDHandler ISAXDTDHandler;
#endif 	/* __ISAXDTDHandler_FWD_DEFINED__ */


#ifndef __ISAXErrorHandler_FWD_DEFINED__
#define __ISAXErrorHandler_FWD_DEFINED__
typedef interface ISAXErrorHandler ISAXErrorHandler;
#endif 	/* __ISAXErrorHandler_FWD_DEFINED__ */


#ifndef __ISAXLexicalHandler_FWD_DEFINED__
#define __ISAXLexicalHandler_FWD_DEFINED__
typedef interface ISAXLexicalHandler ISAXLexicalHandler;
#endif 	/* __ISAXLexicalHandler_FWD_DEFINED__ */


#ifndef __ISAXDeclHandler_FWD_DEFINED__
#define __ISAXDeclHandler_FWD_DEFINED__
typedef interface ISAXDeclHandler ISAXDeclHandler;
#endif 	/* __ISAXDeclHandler_FWD_DEFINED__ */


#ifndef __ISAXAttributes_FWD_DEFINED__
#define __ISAXAttributes_FWD_DEFINED__
typedef interface ISAXAttributes ISAXAttributes;
#endif 	/* __ISAXAttributes_FWD_DEFINED__ */


#ifndef __IVBSAXXMLReader_FWD_DEFINED__
#define __IVBSAXXMLReader_FWD_DEFINED__
typedef interface IVBSAXXMLReader IVBSAXXMLReader;
#endif 	/* __IVBSAXXMLReader_FWD_DEFINED__ */


#ifndef __IVBSAXXMLFilter_FWD_DEFINED__
#define __IVBSAXXMLFilter_FWD_DEFINED__
typedef interface IVBSAXXMLFilter IVBSAXXMLFilter;
#endif 	/* __IVBSAXXMLFilter_FWD_DEFINED__ */


#ifndef __IVBSAXLocator_FWD_DEFINED__
#define __IVBSAXLocator_FWD_DEFINED__
typedef interface IVBSAXLocator IVBSAXLocator;
#endif 	/* __IVBSAXLocator_FWD_DEFINED__ */


#ifndef __IVBSAXEntityResolver_FWD_DEFINED__
#define __IVBSAXEntityResolver_FWD_DEFINED__
typedef interface IVBSAXEntityResolver IVBSAXEntityResolver;
#endif 	/* __IVBSAXEntityResolver_FWD_DEFINED__ */


#ifndef __IVBSAXContentHandler_FWD_DEFINED__
#define __IVBSAXContentHandler_FWD_DEFINED__
typedef interface IVBSAXContentHandler IVBSAXContentHandler;
#endif 	/* __IVBSAXContentHandler_FWD_DEFINED__ */


#ifndef __IVBSAXDTDHandler_FWD_DEFINED__
#define __IVBSAXDTDHandler_FWD_DEFINED__
typedef interface IVBSAXDTDHandler IVBSAXDTDHandler;
#endif 	/* __IVBSAXDTDHandler_FWD_DEFINED__ */


#ifndef __IVBSAXErrorHandler_FWD_DEFINED__
#define __IVBSAXErrorHandler_FWD_DEFINED__
typedef interface IVBSAXErrorHandler IVBSAXErrorHandler;
#endif 	/* __IVBSAXErrorHandler_FWD_DEFINED__ */


#ifndef __IVBSAXLexicalHandler_FWD_DEFINED__
#define __IVBSAXLexicalHandler_FWD_DEFINED__
typedef interface IVBSAXLexicalHandler IVBSAXLexicalHandler;
#endif 	/* __IVBSAXLexicalHandler_FWD_DEFINED__ */


#ifndef __IVBSAXDeclHandler_FWD_DEFINED__
#define __IVBSAXDeclHandler_FWD_DEFINED__
typedef interface IVBSAXDeclHandler IVBSAXDeclHandler;
#endif 	/* __IVBSAXDeclHandler_FWD_DEFINED__ */


#ifndef __IVBSAXAttributes_FWD_DEFINED__
#define __IVBSAXAttributes_FWD_DEFINED__
typedef interface IVBSAXAttributes IVBSAXAttributes;
#endif 	/* __IVBSAXAttributes_FWD_DEFINED__ */


#ifndef __IMXWriter_FWD_DEFINED__
#define __IMXWriter_FWD_DEFINED__
typedef interface IMXWriter IMXWriter;
#endif 	/* __IMXWriter_FWD_DEFINED__ */


#ifndef __IMXAttributes_FWD_DEFINED__
#define __IMXAttributes_FWD_DEFINED__
typedef interface IMXAttributes IMXAttributes;
#endif 	/* __IMXAttributes_FWD_DEFINED__ */


#ifndef __IMXReaderControl_FWD_DEFINED__
#define __IMXReaderControl_FWD_DEFINED__
typedef interface IMXReaderControl IMXReaderControl;
#endif 	/* __IMXReaderControl_FWD_DEFINED__ */


#ifndef __IXMLElementCollection_FWD_DEFINED__
#define __IXMLElementCollection_FWD_DEFINED__
typedef interface IXMLElementCollection IXMLElementCollection;
#endif 	/* __IXMLElementCollection_FWD_DEFINED__ */


#ifndef __IXMLDocument_FWD_DEFINED__
#define __IXMLDocument_FWD_DEFINED__
typedef interface IXMLDocument IXMLDocument;
#endif 	/* __IXMLDocument_FWD_DEFINED__ */


#ifndef __IXMLDocument2_FWD_DEFINED__
#define __IXMLDocument2_FWD_DEFINED__
typedef interface IXMLDocument2 IXMLDocument2;
#endif 	/* __IXMLDocument2_FWD_DEFINED__ */


#ifndef __IXMLElement_FWD_DEFINED__
#define __IXMLElement_FWD_DEFINED__
typedef interface IXMLElement IXMLElement;
#endif 	/* __IXMLElement_FWD_DEFINED__ */


#ifndef __IXMLElement2_FWD_DEFINED__
#define __IXMLElement2_FWD_DEFINED__
typedef interface IXMLElement2 IXMLElement2;
#endif 	/* __IXMLElement2_FWD_DEFINED__ */


#ifndef __IXMLAttribute_FWD_DEFINED__
#define __IXMLAttribute_FWD_DEFINED__
typedef interface IXMLAttribute IXMLAttribute;
#endif 	/* __IXMLAttribute_FWD_DEFINED__ */


#ifndef __IXMLError_FWD_DEFINED__
#define __IXMLError_FWD_DEFINED__
typedef interface IXMLError IXMLError;
#endif 	/* __IXMLError_FWD_DEFINED__ */


#ifndef __IXMLDOMSelection_FWD_DEFINED__
#define __IXMLDOMSelection_FWD_DEFINED__
typedef interface IXMLDOMSelection IXMLDOMSelection;
#endif 	/* __IXMLDOMSelection_FWD_DEFINED__ */


#ifndef __XMLDOMDocumentEvents_FWD_DEFINED__
#define __XMLDOMDocumentEvents_FWD_DEFINED__
typedef interface XMLDOMDocumentEvents XMLDOMDocumentEvents;
#endif 	/* __XMLDOMDocumentEvents_FWD_DEFINED__ */


#ifndef __IDSOControl_FWD_DEFINED__
#define __IDSOControl_FWD_DEFINED__
typedef interface IDSOControl IDSOControl;
#endif 	/* __IDSOControl_FWD_DEFINED__ */


#ifndef __IXMLHTTPRequest_FWD_DEFINED__
#define __IXMLHTTPRequest_FWD_DEFINED__
typedef interface IXMLHTTPRequest IXMLHTTPRequest;
#endif 	/* __IXMLHTTPRequest_FWD_DEFINED__ */


#ifndef __IServerXMLHTTPRequest_FWD_DEFINED__
#define __IServerXMLHTTPRequest_FWD_DEFINED__
typedef interface IServerXMLHTTPRequest IServerXMLHTTPRequest;
#endif 	/* __IServerXMLHTTPRequest_FWD_DEFINED__ */


#ifndef __DOMDocument_FWD_DEFINED__
#define __DOMDocument_FWD_DEFINED__

#ifdef __cplusplus
typedef class DOMDocument DOMDocument;
#else
typedef struct DOMDocument DOMDocument;
#endif /* __cplusplus */

#endif 	/* __DOMDocument_FWD_DEFINED__ */


#ifndef __DOMDocument26_FWD_DEFINED__
#define __DOMDocument26_FWD_DEFINED__

#ifdef __cplusplus
typedef class DOMDocument26 DOMDocument26;
#else
typedef struct DOMDocument26 DOMDocument26;
#endif /* __cplusplus */

#endif 	/* __DOMDocument26_FWD_DEFINED__ */


#ifndef __DOMDocument30_FWD_DEFINED__
#define __DOMDocument30_FWD_DEFINED__

#ifdef __cplusplus
typedef class DOMDocument30 DOMDocument30;
#else
typedef struct DOMDocument30 DOMDocument30;
#endif /* __cplusplus */

#endif 	/* __DOMDocument30_FWD_DEFINED__ */


#ifndef __FreeThreadedDOMDocument_FWD_DEFINED__
#define __FreeThreadedDOMDocument_FWD_DEFINED__

#ifdef __cplusplus
typedef class FreeThreadedDOMDocument FreeThreadedDOMDocument;
#else
typedef struct FreeThreadedDOMDocument FreeThreadedDOMDocument;
#endif /* __cplusplus */

#endif 	/* __FreeThreadedDOMDocument_FWD_DEFINED__ */


#ifndef __FreeThreadedDOMDocument26_FWD_DEFINED__
#define __FreeThreadedDOMDocument26_FWD_DEFINED__

#ifdef __cplusplus
typedef class FreeThreadedDOMDocument26 FreeThreadedDOMDocument26;
#else
typedef struct FreeThreadedDOMDocument26 FreeThreadedDOMDocument26;
#endif /* __cplusplus */

#endif 	/* __FreeThreadedDOMDocument26_FWD_DEFINED__ */


#ifndef __FreeThreadedDOMDocument30_FWD_DEFINED__
#define __FreeThreadedDOMDocument30_FWD_DEFINED__

#ifdef __cplusplus
typedef class FreeThreadedDOMDocument30 FreeThreadedDOMDocument30;
#else
typedef struct FreeThreadedDOMDocument30 FreeThreadedDOMDocument30;
#endif /* __cplusplus */

#endif 	/* __FreeThreadedDOMDocument30_FWD_DEFINED__ */


#ifndef __XMLSchemaCache_FWD_DEFINED__
#define __XMLSchemaCache_FWD_DEFINED__

#ifdef __cplusplus
typedef class XMLSchemaCache XMLSchemaCache;
#else
typedef struct XMLSchemaCache XMLSchemaCache;
#endif /* __cplusplus */

#endif 	/* __XMLSchemaCache_FWD_DEFINED__ */


#ifndef __XMLSchemaCache26_FWD_DEFINED__
#define __XMLSchemaCache26_FWD_DEFINED__

#ifdef __cplusplus
typedef class XMLSchemaCache26 XMLSchemaCache26;
#else
typedef struct XMLSchemaCache26 XMLSchemaCache26;
#endif /* __cplusplus */

#endif 	/* __XMLSchemaCache26_FWD_DEFINED__ */


#ifndef __XMLSchemaCache30_FWD_DEFINED__
#define __XMLSchemaCache30_FWD_DEFINED__

#ifdef __cplusplus
typedef class XMLSchemaCache30 XMLSchemaCache30;
#else
typedef struct XMLSchemaCache30 XMLSchemaCache30;
#endif /* __cplusplus */

#endif 	/* __XMLSchemaCache30_FWD_DEFINED__ */


#ifndef __XSLTemplate_FWD_DEFINED__
#define __XSLTemplate_FWD_DEFINED__

#ifdef __cplusplus
typedef class XSLTemplate XSLTemplate;
#else
typedef struct XSLTemplate XSLTemplate;
#endif /* __cplusplus */

#endif 	/* __XSLTemplate_FWD_DEFINED__ */


#ifndef __XSLTemplate26_FWD_DEFINED__
#define __XSLTemplate26_FWD_DEFINED__

#ifdef __cplusplus
typedef class XSLTemplate26 XSLTemplate26;
#else
typedef struct XSLTemplate26 XSLTemplate26;
#endif /* __cplusplus */

#endif 	/* __XSLTemplate26_FWD_DEFINED__ */


#ifndef __XSLTemplate30_FWD_DEFINED__
#define __XSLTemplate30_FWD_DEFINED__

#ifdef __cplusplus
typedef class XSLTemplate30 XSLTemplate30;
#else
typedef struct XSLTemplate30 XSLTemplate30;
#endif /* __cplusplus */

#endif 	/* __XSLTemplate30_FWD_DEFINED__ */


#ifndef __DSOControl_FWD_DEFINED__
#define __DSOControl_FWD_DEFINED__

#ifdef __cplusplus
typedef class DSOControl DSOControl;
#else
typedef struct DSOControl DSOControl;
#endif /* __cplusplus */

#endif 	/* __DSOControl_FWD_DEFINED__ */


#ifndef __DSOControl26_FWD_DEFINED__
#define __DSOControl26_FWD_DEFINED__

#ifdef __cplusplus
typedef class DSOControl26 DSOControl26;
#else
typedef struct DSOControl26 DSOControl26;
#endif /* __cplusplus */

#endif 	/* __DSOControl26_FWD_DEFINED__ */


#ifndef __DSOControl30_FWD_DEFINED__
#define __DSOControl30_FWD_DEFINED__

#ifdef __cplusplus
typedef class DSOControl30 DSOControl30;
#else
typedef struct DSOControl30 DSOControl30;
#endif /* __cplusplus */

#endif 	/* __DSOControl30_FWD_DEFINED__ */


#ifndef __XMLHTTP_FWD_DEFINED__
#define __XMLHTTP_FWD_DEFINED__

#ifdef __cplusplus
typedef class XMLHTTP XMLHTTP;
#else
typedef struct XMLHTTP XMLHTTP;
#endif /* __cplusplus */

#endif 	/* __XMLHTTP_FWD_DEFINED__ */


#ifndef __XMLHTTP26_FWD_DEFINED__
#define __XMLHTTP26_FWD_DEFINED__

#ifdef __cplusplus
typedef class XMLHTTP26 XMLHTTP26;
#else
typedef struct XMLHTTP26 XMLHTTP26;
#endif /* __cplusplus */

#endif 	/* __XMLHTTP26_FWD_DEFINED__ */


#ifndef __XMLHTTP30_FWD_DEFINED__
#define __XMLHTTP30_FWD_DEFINED__

#ifdef __cplusplus
typedef class XMLHTTP30 XMLHTTP30;
#else
typedef struct XMLHTTP30 XMLHTTP30;
#endif /* __cplusplus */

#endif 	/* __XMLHTTP30_FWD_DEFINED__ */


#ifndef __ServerXMLHTTP_FWD_DEFINED__
#define __ServerXMLHTTP_FWD_DEFINED__

#ifdef __cplusplus
typedef class ServerXMLHTTP ServerXMLHTTP;
#else
typedef struct ServerXMLHTTP ServerXMLHTTP;
#endif /* __cplusplus */

#endif 	/* __ServerXMLHTTP_FWD_DEFINED__ */


#ifndef __ServerXMLHTTP30_FWD_DEFINED__
#define __ServerXMLHTTP30_FWD_DEFINED__

#ifdef __cplusplus
typedef class ServerXMLHTTP30 ServerXMLHTTP30;
#else
typedef struct ServerXMLHTTP30 ServerXMLHTTP30;
#endif /* __cplusplus */

#endif 	/* __ServerXMLHTTP30_FWD_DEFINED__ */


#ifndef __SAXXMLReader_FWD_DEFINED__
#define __SAXXMLReader_FWD_DEFINED__

#ifdef __cplusplus
typedef class SAXXMLReader SAXXMLReader;
#else
typedef struct SAXXMLReader SAXXMLReader;
#endif /* __cplusplus */

#endif 	/* __SAXXMLReader_FWD_DEFINED__ */


#ifndef __SAXXMLReader30_FWD_DEFINED__
#define __SAXXMLReader30_FWD_DEFINED__

#ifdef __cplusplus
typedef class SAXXMLReader30 SAXXMLReader30;
#else
typedef struct SAXXMLReader30 SAXXMLReader30;
#endif /* __cplusplus */

#endif 	/* __SAXXMLReader30_FWD_DEFINED__ */


#ifndef __MXXMLWriter_FWD_DEFINED__
#define __MXXMLWriter_FWD_DEFINED__

#ifdef __cplusplus
typedef class MXXMLWriter MXXMLWriter;
#else
typedef struct MXXMLWriter MXXMLWriter;
#endif /* __cplusplus */

#endif 	/* __MXXMLWriter_FWD_DEFINED__ */


#ifndef __MXXMLWriter30_FWD_DEFINED__
#define __MXXMLWriter30_FWD_DEFINED__

#ifdef __cplusplus
typedef class MXXMLWriter30 MXXMLWriter30;
#else
typedef struct MXXMLWriter30 MXXMLWriter30;
#endif /* __cplusplus */

#endif 	/* __MXXMLWriter30_FWD_DEFINED__ */


#ifndef __SAXAttributes_FWD_DEFINED__
#define __SAXAttributes_FWD_DEFINED__

#ifdef __cplusplus
typedef class SAXAttributes SAXAttributes;
#else
typedef struct SAXAttributes SAXAttributes;
#endif /* __cplusplus */

#endif 	/* __SAXAttributes_FWD_DEFINED__ */


#ifndef __SAXAttributes30_FWD_DEFINED__
#define __SAXAttributes30_FWD_DEFINED__

#ifdef __cplusplus
typedef class SAXAttributes30 SAXAttributes30;
#else
typedef struct SAXAttributes30 SAXAttributes30;
#endif /* __cplusplus */

#endif 	/* __SAXAttributes30_FWD_DEFINED__ */


#ifndef __XMLDocument_FWD_DEFINED__
#define __XMLDocument_FWD_DEFINED__

#ifdef __cplusplus
typedef class XMLDocument XMLDocument;
#else
typedef struct XMLDocument XMLDocument;
#endif /* __cplusplus */

#endif 	/* __XMLDocument_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_msxml2_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1998.
//
//--------------------------------------------------------------------------
#define DOMDocument DOMDocument2
#define CLSID_DOMDocument CLSID_DOMDocument2

#ifdef __USE_MSXML2_NAMESPACE__
namespace MSXML2 {
#endif
#ifndef __msxml_h__
typedef struct _xml_error
    {
    unsigned int _nLine;
    BSTR _pchBuf;
    unsigned int _cchBuf;
    unsigned int _ich;
    BSTR _pszFound;
    BSTR _pszExpected;
    DWORD _reserved1;
    DWORD _reserved2;
    } 	XML_ERROR;

#endif
#ifndef __ISAXXMLReader_INTERFACE_DEFINED__
#undef __MSXML2_LIBRARY_DEFINED__
#endif


extern RPC_IF_HANDLE __MIDL_itf_msxml2_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msxml2_0000_v0_0_s_ifspec;


#ifndef __MSXML2_LIBRARY_DEFINED__
#define __MSXML2_LIBRARY_DEFINED__

/* library MSXML2 */
/* [lcid][helpstring][version][uuid] */ 























































#undef ParseURL
#if !defined(__msxml_h__)
typedef /* [helpstring] */ 
enum tagXMLEMEM_TYPE
    {	XMLELEMTYPE_ELEMENT	= 0,
	XMLELEMTYPE_TEXT	= XMLELEMTYPE_ELEMENT + 1,
	XMLELEMTYPE_COMMENT	= XMLELEMTYPE_TEXT + 1,
	XMLELEMTYPE_DOCUMENT	= XMLELEMTYPE_COMMENT + 1,
	XMLELEMTYPE_DTD	= XMLELEMTYPE_DOCUMENT + 1,
	XMLELEMTYPE_PI	= XMLELEMTYPE_DTD + 1,
	XMLELEMTYPE_OTHER	= XMLELEMTYPE_PI + 1
    } 	XMLELEM_TYPE;

#endif
#if !defined(__msxml_h__) || defined(__IXMLElementNotificationSink_INTERFACE_DEFINED__)
typedef /* [helpstring] */ 
enum tagDOMNodeType
    {	NODE_INVALID	= 0,
	NODE_ELEMENT	= NODE_INVALID + 1,
	NODE_ATTRIBUTE	= NODE_ELEMENT + 1,
	NODE_TEXT	= NODE_ATTRIBUTE + 1,
	NODE_CDATA_SECTION	= NODE_TEXT + 1,
	NODE_ENTITY_REFERENCE	= NODE_CDATA_SECTION + 1,
	NODE_ENTITY	= NODE_ENTITY_REFERENCE + 1,
	NODE_PROCESSING_INSTRUCTION	= NODE_ENTITY + 1,
	NODE_COMMENT	= NODE_PROCESSING_INSTRUCTION + 1,
	NODE_DOCUMENT	= NODE_COMMENT + 1,
	NODE_DOCUMENT_TYPE	= NODE_DOCUMENT + 1,
	NODE_DOCUMENT_FRAGMENT	= NODE_DOCUMENT_TYPE + 1,
	NODE_NOTATION	= NODE_DOCUMENT_FRAGMENT + 1
    } 	DOMNodeType;

#endif
typedef /* [helpstring] */ 
enum _SERVERXMLHTTP_OPTION
    {	SXH_OPTION_URL_CODEPAGE	= 0,
	SXH_OPTION_ESCAPE_PERCENT_IN_URL	= SXH_OPTION_URL_CODEPAGE + 1
    } 	SERVERXMLHTTP_OPTION;


EXTERN_C const IID LIBID_MSXML2;

#ifndef __IXMLDOMImplementation_INTERFACE_DEFINED__
#define __IXMLDOMImplementation_INTERFACE_DEFINED__

/* interface IXMLDOMImplementation */
/* [uuid][dual][oleautomation][unique][nonextensible][object][local] */ 


EXTERN_C const IID IID_IXMLDOMImplementation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF8F-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMImplementation : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE hasFeature( 
            /* [in] */ BSTR feature,
            /* [in] */ BSTR version,
            /* [retval][out] */ VARIANT_BOOL *hasFeature) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMImplementationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMImplementation * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMImplementation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMImplementation * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMImplementation * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMImplementation * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMImplementation * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMImplementation * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *hasFeature )( 
            IXMLDOMImplementation * This,
            /* [in] */ BSTR feature,
            /* [in] */ BSTR version,
            /* [retval][out] */ VARIANT_BOOL *hasFeature);
        
        END_INTERFACE
    } IXMLDOMImplementationVtbl;

    interface IXMLDOMImplementation
    {
        CONST_VTBL struct IXMLDOMImplementationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMImplementation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMImplementation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMImplementation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMImplementation_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMImplementation_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMImplementation_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMImplementation_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMImplementation_hasFeature(This,feature,version,hasFeature)	\
    (This)->lpVtbl -> hasFeature(This,feature,version,hasFeature)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IXMLDOMImplementation_hasFeature_Proxy( 
    IXMLDOMImplementation * This,
    /* [in] */ BSTR feature,
    /* [in] */ BSTR version,
    /* [retval][out] */ VARIANT_BOOL *hasFeature);


void __RPC_STUB IXMLDOMImplementation_hasFeature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMImplementation_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMNode_INTERFACE_DEFINED__
#define __IXMLDOMNode_INTERFACE_DEFINED__

/* interface IXMLDOMNode */
/* [unique][helpstring][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMNode;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF80-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMNode : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_nodeName( 
            /* [retval][out] */ BSTR *name) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_nodeValue( 
            /* [retval][out] */ VARIANT *value) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_nodeValue( 
            /* [in] */ VARIANT value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_nodeType( 
            /* [retval][out] */ DOMNodeType *type) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_parentNode( 
            /* [retval][out] */ IXMLDOMNode **parent) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_childNodes( 
            /* [retval][out] */ IXMLDOMNodeList **childList) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_firstChild( 
            /* [retval][out] */ IXMLDOMNode **firstChild) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_lastChild( 
            /* [retval][out] */ IXMLDOMNode **lastChild) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_previousSibling( 
            /* [retval][out] */ IXMLDOMNode **previousSibling) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_nextSibling( 
            /* [retval][out] */ IXMLDOMNode **nextSibling) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_attributes( 
            /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE insertBefore( 
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE replaceChild( 
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ IXMLDOMNode *oldChild,
            /* [retval][out] */ IXMLDOMNode **outOldChild) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeChild( 
            /* [in] */ IXMLDOMNode *childNode,
            /* [retval][out] */ IXMLDOMNode **oldChild) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE appendChild( 
            /* [in] */ IXMLDOMNode *newChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE hasChildNodes( 
            /* [retval][out] */ VARIANT_BOOL *hasChild) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ownerDocument( 
            /* [retval][out] */ IXMLDOMDocument **DOMDocument) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE cloneNode( 
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode **cloneRoot) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_nodeTypeString( 
            /* [out][retval] */ BSTR *nodeType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_text( 
            /* [out][retval] */ BSTR *text) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_text( 
            /* [in] */ BSTR text) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_specified( 
            /* [retval][out] */ VARIANT_BOOL *isSpecified) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_definition( 
            /* [out][retval] */ IXMLDOMNode **definitionNode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_nodeTypedValue( 
            /* [out][retval] */ VARIANT *typedValue) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_nodeTypedValue( 
            /* [in] */ VARIANT typedValue) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_dataType( 
            /* [out][retval] */ VARIANT *dataTypeName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_dataType( 
            /* [in] */ BSTR dataTypeName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_xml( 
            /* [out][retval] */ BSTR *xmlString) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE transformNode( 
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [out][retval] */ BSTR *xmlString) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE selectNodes( 
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList **resultList) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE selectSingleNode( 
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode **resultNode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_parsed( 
            /* [out][retval] */ VARIANT_BOOL *isParsed) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_namespaceURI( 
            /* [out][retval] */ BSTR *namespaceURI) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_prefix( 
            /* [out][retval] */ BSTR *prefixString) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_baseName( 
            /* [out][retval] */ BSTR *nameString) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE transformNodeToObject( 
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [in] */ VARIANT outputObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMNodeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMNode * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMNode * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMNode * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMNode * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMNode * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMNode * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMNode * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeName )( 
            IXMLDOMNode * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeValue )( 
            IXMLDOMNode * This,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeValue )( 
            IXMLDOMNode * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeType )( 
            IXMLDOMNode * This,
            /* [retval][out] */ DOMNodeType *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parentNode )( 
            IXMLDOMNode * This,
            /* [retval][out] */ IXMLDOMNode **parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_childNodes )( 
            IXMLDOMNode * This,
            /* [retval][out] */ IXMLDOMNodeList **childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_firstChild )( 
            IXMLDOMNode * This,
            /* [retval][out] */ IXMLDOMNode **firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastChild )( 
            IXMLDOMNode * This,
            /* [retval][out] */ IXMLDOMNode **lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_previousSibling )( 
            IXMLDOMNode * This,
            /* [retval][out] */ IXMLDOMNode **previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nextSibling )( 
            IXMLDOMNode * This,
            /* [retval][out] */ IXMLDOMNode **nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            IXMLDOMNode * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertBefore )( 
            IXMLDOMNode * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceChild )( 
            IXMLDOMNode * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ IXMLDOMNode *oldChild,
            /* [retval][out] */ IXMLDOMNode **outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IXMLDOMNode * This,
            /* [in] */ IXMLDOMNode *childNode,
            /* [retval][out] */ IXMLDOMNode **oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendChild )( 
            IXMLDOMNode * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *hasChildNodes )( 
            IXMLDOMNode * This,
            /* [retval][out] */ VARIANT_BOOL *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ownerDocument )( 
            IXMLDOMNode * This,
            /* [retval][out] */ IXMLDOMDocument **DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *cloneNode )( 
            IXMLDOMNode * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode **cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypeString )( 
            IXMLDOMNode * This,
            /* [out][retval] */ BSTR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IXMLDOMNode * This,
            /* [out][retval] */ BSTR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IXMLDOMNode * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_specified )( 
            IXMLDOMNode * This,
            /* [retval][out] */ VARIANT_BOOL *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_definition )( 
            IXMLDOMNode * This,
            /* [out][retval] */ IXMLDOMNode **definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypedValue )( 
            IXMLDOMNode * This,
            /* [out][retval] */ VARIANT *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeTypedValue )( 
            IXMLDOMNode * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataType )( 
            IXMLDOMNode * This,
            /* [out][retval] */ VARIANT *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dataType )( 
            IXMLDOMNode * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_xml )( 
            IXMLDOMNode * This,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNode )( 
            IXMLDOMNode * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectNodes )( 
            IXMLDOMNode * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectSingleNode )( 
            IXMLDOMNode * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode **resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parsed )( 
            IXMLDOMNode * This,
            /* [out][retval] */ VARIANT_BOOL *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            IXMLDOMNode * This,
            /* [out][retval] */ BSTR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_prefix )( 
            IXMLDOMNode * This,
            /* [out][retval] */ BSTR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseName )( 
            IXMLDOMNode * This,
            /* [out][retval] */ BSTR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNodeToObject )( 
            IXMLDOMNode * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        END_INTERFACE
    } IXMLDOMNodeVtbl;

    interface IXMLDOMNode
    {
        CONST_VTBL struct IXMLDOMNodeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMNode_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMNode_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMNode_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMNode_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMNode_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMNode_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMNode_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMNode_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMNode_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMNode_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMNode_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMNode_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMNode_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMNode_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMNode_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMNode_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMNode_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMNode_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMNode_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMNode_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMNode_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMNode_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMNode_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMNode_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMNode_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMNode_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMNode_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMNode_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMNode_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMNode_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMNode_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMNode_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMNode_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMNode_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMNode_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMNode_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMNode_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMNode_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMNode_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMNode_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMNode_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMNode_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMNode_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_nodeName_Proxy( 
    IXMLDOMNode * This,
    /* [retval][out] */ BSTR *name);


void __RPC_STUB IXMLDOMNode_get_nodeName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_nodeValue_Proxy( 
    IXMLDOMNode * This,
    /* [retval][out] */ VARIANT *value);


void __RPC_STUB IXMLDOMNode_get_nodeValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_put_nodeValue_Proxy( 
    IXMLDOMNode * This,
    /* [in] */ VARIANT value);


void __RPC_STUB IXMLDOMNode_put_nodeValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_nodeType_Proxy( 
    IXMLDOMNode * This,
    /* [retval][out] */ DOMNodeType *type);


void __RPC_STUB IXMLDOMNode_get_nodeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_parentNode_Proxy( 
    IXMLDOMNode * This,
    /* [retval][out] */ IXMLDOMNode **parent);


void __RPC_STUB IXMLDOMNode_get_parentNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_childNodes_Proxy( 
    IXMLDOMNode * This,
    /* [retval][out] */ IXMLDOMNodeList **childList);


void __RPC_STUB IXMLDOMNode_get_childNodes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_firstChild_Proxy( 
    IXMLDOMNode * This,
    /* [retval][out] */ IXMLDOMNode **firstChild);


void __RPC_STUB IXMLDOMNode_get_firstChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_lastChild_Proxy( 
    IXMLDOMNode * This,
    /* [retval][out] */ IXMLDOMNode **lastChild);


void __RPC_STUB IXMLDOMNode_get_lastChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_previousSibling_Proxy( 
    IXMLDOMNode * This,
    /* [retval][out] */ IXMLDOMNode **previousSibling);


void __RPC_STUB IXMLDOMNode_get_previousSibling_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_nextSibling_Proxy( 
    IXMLDOMNode * This,
    /* [retval][out] */ IXMLDOMNode **nextSibling);


void __RPC_STUB IXMLDOMNode_get_nextSibling_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_attributes_Proxy( 
    IXMLDOMNode * This,
    /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap);


void __RPC_STUB IXMLDOMNode_get_attributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_insertBefore_Proxy( 
    IXMLDOMNode * This,
    /* [in] */ IXMLDOMNode *newChild,
    /* [in] */ VARIANT refChild,
    /* [retval][out] */ IXMLDOMNode **outNewChild);


void __RPC_STUB IXMLDOMNode_insertBefore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_replaceChild_Proxy( 
    IXMLDOMNode * This,
    /* [in] */ IXMLDOMNode *newChild,
    /* [in] */ IXMLDOMNode *oldChild,
    /* [retval][out] */ IXMLDOMNode **outOldChild);


void __RPC_STUB IXMLDOMNode_replaceChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_removeChild_Proxy( 
    IXMLDOMNode * This,
    /* [in] */ IXMLDOMNode *childNode,
    /* [retval][out] */ IXMLDOMNode **oldChild);


void __RPC_STUB IXMLDOMNode_removeChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_appendChild_Proxy( 
    IXMLDOMNode * This,
    /* [in] */ IXMLDOMNode *newChild,
    /* [retval][out] */ IXMLDOMNode **outNewChild);


void __RPC_STUB IXMLDOMNode_appendChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_hasChildNodes_Proxy( 
    IXMLDOMNode * This,
    /* [retval][out] */ VARIANT_BOOL *hasChild);


void __RPC_STUB IXMLDOMNode_hasChildNodes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_ownerDocument_Proxy( 
    IXMLDOMNode * This,
    /* [retval][out] */ IXMLDOMDocument **DOMDocument);


void __RPC_STUB IXMLDOMNode_get_ownerDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_cloneNode_Proxy( 
    IXMLDOMNode * This,
    /* [in] */ VARIANT_BOOL deep,
    /* [retval][out] */ IXMLDOMNode **cloneRoot);


void __RPC_STUB IXMLDOMNode_cloneNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_nodeTypeString_Proxy( 
    IXMLDOMNode * This,
    /* [out][retval] */ BSTR *nodeType);


void __RPC_STUB IXMLDOMNode_get_nodeTypeString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_text_Proxy( 
    IXMLDOMNode * This,
    /* [out][retval] */ BSTR *text);


void __RPC_STUB IXMLDOMNode_get_text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_put_text_Proxy( 
    IXMLDOMNode * This,
    /* [in] */ BSTR text);


void __RPC_STUB IXMLDOMNode_put_text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_specified_Proxy( 
    IXMLDOMNode * This,
    /* [retval][out] */ VARIANT_BOOL *isSpecified);


void __RPC_STUB IXMLDOMNode_get_specified_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_definition_Proxy( 
    IXMLDOMNode * This,
    /* [out][retval] */ IXMLDOMNode **definitionNode);


void __RPC_STUB IXMLDOMNode_get_definition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_nodeTypedValue_Proxy( 
    IXMLDOMNode * This,
    /* [out][retval] */ VARIANT *typedValue);


void __RPC_STUB IXMLDOMNode_get_nodeTypedValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_put_nodeTypedValue_Proxy( 
    IXMLDOMNode * This,
    /* [in] */ VARIANT typedValue);


void __RPC_STUB IXMLDOMNode_put_nodeTypedValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_dataType_Proxy( 
    IXMLDOMNode * This,
    /* [out][retval] */ VARIANT *dataTypeName);


void __RPC_STUB IXMLDOMNode_get_dataType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_put_dataType_Proxy( 
    IXMLDOMNode * This,
    /* [in] */ BSTR dataTypeName);


void __RPC_STUB IXMLDOMNode_put_dataType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_xml_Proxy( 
    IXMLDOMNode * This,
    /* [out][retval] */ BSTR *xmlString);


void __RPC_STUB IXMLDOMNode_get_xml_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_transformNode_Proxy( 
    IXMLDOMNode * This,
    /* [in] */ IXMLDOMNode *stylesheet,
    /* [out][retval] */ BSTR *xmlString);


void __RPC_STUB IXMLDOMNode_transformNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_selectNodes_Proxy( 
    IXMLDOMNode * This,
    /* [in] */ BSTR queryString,
    /* [out][retval] */ IXMLDOMNodeList **resultList);


void __RPC_STUB IXMLDOMNode_selectNodes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_selectSingleNode_Proxy( 
    IXMLDOMNode * This,
    /* [in] */ BSTR queryString,
    /* [out][retval] */ IXMLDOMNode **resultNode);


void __RPC_STUB IXMLDOMNode_selectSingleNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_parsed_Proxy( 
    IXMLDOMNode * This,
    /* [out][retval] */ VARIANT_BOOL *isParsed);


void __RPC_STUB IXMLDOMNode_get_parsed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_namespaceURI_Proxy( 
    IXMLDOMNode * This,
    /* [out][retval] */ BSTR *namespaceURI);


void __RPC_STUB IXMLDOMNode_get_namespaceURI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_prefix_Proxy( 
    IXMLDOMNode * This,
    /* [out][retval] */ BSTR *prefixString);


void __RPC_STUB IXMLDOMNode_get_prefix_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_get_baseName_Proxy( 
    IXMLDOMNode * This,
    /* [out][retval] */ BSTR *nameString);


void __RPC_STUB IXMLDOMNode_get_baseName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNode_transformNodeToObject_Proxy( 
    IXMLDOMNode * This,
    /* [in] */ IXMLDOMNode *stylesheet,
    /* [in] */ VARIANT outputObject);


void __RPC_STUB IXMLDOMNode_transformNodeToObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMNode_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMDocumentFragment_INTERFACE_DEFINED__
#define __IXMLDOMDocumentFragment_INTERFACE_DEFINED__

/* interface IXMLDOMDocumentFragment */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMDocumentFragment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3efaa413-272f-11d2-836f-0000f87a7782")
    IXMLDOMDocumentFragment : public IXMLDOMNode
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMDocumentFragmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMDocumentFragment * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMDocumentFragment * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMDocumentFragment * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMDocumentFragment * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMDocumentFragment * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMDocumentFragment * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMDocumentFragment * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeName )( 
            IXMLDOMDocumentFragment * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeValue )( 
            IXMLDOMDocumentFragment * This,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeValue )( 
            IXMLDOMDocumentFragment * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeType )( 
            IXMLDOMDocumentFragment * This,
            /* [retval][out] */ DOMNodeType *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parentNode )( 
            IXMLDOMDocumentFragment * This,
            /* [retval][out] */ IXMLDOMNode **parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_childNodes )( 
            IXMLDOMDocumentFragment * This,
            /* [retval][out] */ IXMLDOMNodeList **childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_firstChild )( 
            IXMLDOMDocumentFragment * This,
            /* [retval][out] */ IXMLDOMNode **firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastChild )( 
            IXMLDOMDocumentFragment * This,
            /* [retval][out] */ IXMLDOMNode **lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_previousSibling )( 
            IXMLDOMDocumentFragment * This,
            /* [retval][out] */ IXMLDOMNode **previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nextSibling )( 
            IXMLDOMDocumentFragment * This,
            /* [retval][out] */ IXMLDOMNode **nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            IXMLDOMDocumentFragment * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertBefore )( 
            IXMLDOMDocumentFragment * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceChild )( 
            IXMLDOMDocumentFragment * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ IXMLDOMNode *oldChild,
            /* [retval][out] */ IXMLDOMNode **outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IXMLDOMDocumentFragment * This,
            /* [in] */ IXMLDOMNode *childNode,
            /* [retval][out] */ IXMLDOMNode **oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendChild )( 
            IXMLDOMDocumentFragment * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *hasChildNodes )( 
            IXMLDOMDocumentFragment * This,
            /* [retval][out] */ VARIANT_BOOL *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ownerDocument )( 
            IXMLDOMDocumentFragment * This,
            /* [retval][out] */ IXMLDOMDocument **DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *cloneNode )( 
            IXMLDOMDocumentFragment * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode **cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypeString )( 
            IXMLDOMDocumentFragment * This,
            /* [out][retval] */ BSTR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IXMLDOMDocumentFragment * This,
            /* [out][retval] */ BSTR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IXMLDOMDocumentFragment * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_specified )( 
            IXMLDOMDocumentFragment * This,
            /* [retval][out] */ VARIANT_BOOL *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_definition )( 
            IXMLDOMDocumentFragment * This,
            /* [out][retval] */ IXMLDOMNode **definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypedValue )( 
            IXMLDOMDocumentFragment * This,
            /* [out][retval] */ VARIANT *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeTypedValue )( 
            IXMLDOMDocumentFragment * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataType )( 
            IXMLDOMDocumentFragment * This,
            /* [out][retval] */ VARIANT *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dataType )( 
            IXMLDOMDocumentFragment * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_xml )( 
            IXMLDOMDocumentFragment * This,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNode )( 
            IXMLDOMDocumentFragment * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectNodes )( 
            IXMLDOMDocumentFragment * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectSingleNode )( 
            IXMLDOMDocumentFragment * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode **resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parsed )( 
            IXMLDOMDocumentFragment * This,
            /* [out][retval] */ VARIANT_BOOL *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            IXMLDOMDocumentFragment * This,
            /* [out][retval] */ BSTR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_prefix )( 
            IXMLDOMDocumentFragment * This,
            /* [out][retval] */ BSTR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseName )( 
            IXMLDOMDocumentFragment * This,
            /* [out][retval] */ BSTR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNodeToObject )( 
            IXMLDOMDocumentFragment * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        END_INTERFACE
    } IXMLDOMDocumentFragmentVtbl;

    interface IXMLDOMDocumentFragment
    {
        CONST_VTBL struct IXMLDOMDocumentFragmentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMDocumentFragment_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMDocumentFragment_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMDocumentFragment_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMDocumentFragment_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMDocumentFragment_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMDocumentFragment_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMDocumentFragment_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMDocumentFragment_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMDocumentFragment_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMDocumentFragment_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMDocumentFragment_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMDocumentFragment_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMDocumentFragment_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMDocumentFragment_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMDocumentFragment_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMDocumentFragment_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMDocumentFragment_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMDocumentFragment_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMDocumentFragment_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMDocumentFragment_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMDocumentFragment_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMDocumentFragment_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMDocumentFragment_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMDocumentFragment_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMDocumentFragment_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMDocumentFragment_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMDocumentFragment_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMDocumentFragment_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMDocumentFragment_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMDocumentFragment_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMDocumentFragment_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMDocumentFragment_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMDocumentFragment_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMDocumentFragment_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMDocumentFragment_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMDocumentFragment_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMDocumentFragment_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMDocumentFragment_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMDocumentFragment_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMDocumentFragment_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMDocumentFragment_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMDocumentFragment_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMDocumentFragment_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXMLDOMDocumentFragment_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMDocument_INTERFACE_DEFINED__
#define __IXMLDOMDocument_INTERFACE_DEFINED__

/* interface IXMLDOMDocument */
/* [hidden][unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF81-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMDocument : public IXMLDOMNode
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_doctype( 
            /* [retval][out] */ IXMLDOMDocumentType **documentType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_implementation( 
            /* [retval][out] */ IXMLDOMImplementation **impl) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_documentElement( 
            /* [retval][out] */ IXMLDOMElement **DOMElement) = 0;
        
        virtual /* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_documentElement( 
            /* [in] */ IXMLDOMElement *DOMElement) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE createElement( 
            /* [in] */ BSTR tagName,
            /* [retval][out] */ IXMLDOMElement **element) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE createDocumentFragment( 
            /* [retval][out] */ IXMLDOMDocumentFragment **docFrag) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE createTextNode( 
            /* [in] */ BSTR data,
            /* [retval][out] */ IXMLDOMText **text) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE createComment( 
            /* [in] */ BSTR data,
            /* [retval][out] */ IXMLDOMComment **comment) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE createCDATASection( 
            /* [in] */ BSTR data,
            /* [retval][out] */ IXMLDOMCDATASection **cdata) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE createProcessingInstruction( 
            /* [in] */ BSTR target,
            /* [in] */ BSTR data,
            /* [retval][out] */ IXMLDOMProcessingInstruction **pi) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE createAttribute( 
            /* [in] */ BSTR name,
            /* [retval][out] */ IXMLDOMAttribute **attribute) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE createEntityReference( 
            /* [in] */ BSTR name,
            /* [retval][out] */ IXMLDOMEntityReference **entityRef) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getElementsByTagName( 
            /* [in] */ BSTR tagName,
            /* [retval][out] */ IXMLDOMNodeList **resultList) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE createNode( 
            /* [in] */ VARIANT Type,
            /* [in] */ BSTR name,
            /* [in] */ BSTR namespaceURI,
            /* [out][retval] */ IXMLDOMNode **node) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE nodeFromID( 
            /* [in] */ BSTR idString,
            /* [out][retval] */ IXMLDOMNode **node) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE load( 
            /* [in] */ VARIANT xmlSource,
            /* [retval][out] */ VARIANT_BOOL *isSuccessful) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_readyState( 
            /* [out][retval] */ long *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_parseError( 
            /* [out][retval] */ IXMLDOMParseError **errorObj) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_url( 
            /* [out][retval] */ BSTR *urlString) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_async( 
            /* [out][retval] */ VARIANT_BOOL *isAsync) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_async( 
            /* [in] */ VARIANT_BOOL isAsync) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE abort( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE loadXML( 
            /* [in] */ BSTR bstrXML,
            /* [retval][out] */ VARIANT_BOOL *isSuccessful) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE save( 
            /* [in] */ VARIANT destination) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_validateOnParse( 
            /* [out][retval] */ VARIANT_BOOL *isValidating) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_validateOnParse( 
            /* [in] */ VARIANT_BOOL isValidating) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_resolveExternals( 
            /* [out][retval] */ VARIANT_BOOL *isResolving) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_resolveExternals( 
            /* [in] */ VARIANT_BOOL isResolving) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_preserveWhiteSpace( 
            /* [out][retval] */ VARIANT_BOOL *isPreserving) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_preserveWhiteSpace( 
            /* [in] */ VARIANT_BOOL isPreserving) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_onreadystatechange( 
            /* [in] */ VARIANT readystatechangeSink) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ondataavailable( 
            /* [in] */ VARIANT ondataavailableSink) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ontransformnode( 
            /* [in] */ VARIANT ontransformnodeSink) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMDocumentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMDocument * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMDocument * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMDocument * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMDocument * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMDocument * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMDocument * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMDocument * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeName )( 
            IXMLDOMDocument * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeValue )( 
            IXMLDOMDocument * This,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeValue )( 
            IXMLDOMDocument * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeType )( 
            IXMLDOMDocument * This,
            /* [retval][out] */ DOMNodeType *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parentNode )( 
            IXMLDOMDocument * This,
            /* [retval][out] */ IXMLDOMNode **parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_childNodes )( 
            IXMLDOMDocument * This,
            /* [retval][out] */ IXMLDOMNodeList **childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_firstChild )( 
            IXMLDOMDocument * This,
            /* [retval][out] */ IXMLDOMNode **firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastChild )( 
            IXMLDOMDocument * This,
            /* [retval][out] */ IXMLDOMNode **lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_previousSibling )( 
            IXMLDOMDocument * This,
            /* [retval][out] */ IXMLDOMNode **previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nextSibling )( 
            IXMLDOMDocument * This,
            /* [retval][out] */ IXMLDOMNode **nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            IXMLDOMDocument * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertBefore )( 
            IXMLDOMDocument * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceChild )( 
            IXMLDOMDocument * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ IXMLDOMNode *oldChild,
            /* [retval][out] */ IXMLDOMNode **outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IXMLDOMDocument * This,
            /* [in] */ IXMLDOMNode *childNode,
            /* [retval][out] */ IXMLDOMNode **oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendChild )( 
            IXMLDOMDocument * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *hasChildNodes )( 
            IXMLDOMDocument * This,
            /* [retval][out] */ VARIANT_BOOL *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ownerDocument )( 
            IXMLDOMDocument * This,
            /* [retval][out] */ IXMLDOMDocument **DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *cloneNode )( 
            IXMLDOMDocument * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode **cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypeString )( 
            IXMLDOMDocument * This,
            /* [out][retval] */ BSTR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IXMLDOMDocument * This,
            /* [out][retval] */ BSTR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IXMLDOMDocument * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_specified )( 
            IXMLDOMDocument * This,
            /* [retval][out] */ VARIANT_BOOL *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_definition )( 
            IXMLDOMDocument * This,
            /* [out][retval] */ IXMLDOMNode **definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypedValue )( 
            IXMLDOMDocument * This,
            /* [out][retval] */ VARIANT *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeTypedValue )( 
            IXMLDOMDocument * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataType )( 
            IXMLDOMDocument * This,
            /* [out][retval] */ VARIANT *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dataType )( 
            IXMLDOMDocument * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_xml )( 
            IXMLDOMDocument * This,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNode )( 
            IXMLDOMDocument * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectNodes )( 
            IXMLDOMDocument * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectSingleNode )( 
            IXMLDOMDocument * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode **resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parsed )( 
            IXMLDOMDocument * This,
            /* [out][retval] */ VARIANT_BOOL *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            IXMLDOMDocument * This,
            /* [out][retval] */ BSTR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_prefix )( 
            IXMLDOMDocument * This,
            /* [out][retval] */ BSTR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseName )( 
            IXMLDOMDocument * This,
            /* [out][retval] */ BSTR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNodeToObject )( 
            IXMLDOMDocument * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_doctype )( 
            IXMLDOMDocument * This,
            /* [retval][out] */ IXMLDOMDocumentType **documentType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_implementation )( 
            IXMLDOMDocument * This,
            /* [retval][out] */ IXMLDOMImplementation **impl);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_documentElement )( 
            IXMLDOMDocument * This,
            /* [retval][out] */ IXMLDOMElement **DOMElement);
        
        /* [helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE *putref_documentElement )( 
            IXMLDOMDocument * This,
            /* [in] */ IXMLDOMElement *DOMElement);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createElement )( 
            IXMLDOMDocument * This,
            /* [in] */ BSTR tagName,
            /* [retval][out] */ IXMLDOMElement **element);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createDocumentFragment )( 
            IXMLDOMDocument * This,
            /* [retval][out] */ IXMLDOMDocumentFragment **docFrag);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createTextNode )( 
            IXMLDOMDocument * This,
            /* [in] */ BSTR data,
            /* [retval][out] */ IXMLDOMText **text);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createComment )( 
            IXMLDOMDocument * This,
            /* [in] */ BSTR data,
            /* [retval][out] */ IXMLDOMComment **comment);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createCDATASection )( 
            IXMLDOMDocument * This,
            /* [in] */ BSTR data,
            /* [retval][out] */ IXMLDOMCDATASection **cdata);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createProcessingInstruction )( 
            IXMLDOMDocument * This,
            /* [in] */ BSTR target,
            /* [in] */ BSTR data,
            /* [retval][out] */ IXMLDOMProcessingInstruction **pi);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createAttribute )( 
            IXMLDOMDocument * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ IXMLDOMAttribute **attribute);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createEntityReference )( 
            IXMLDOMDocument * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ IXMLDOMEntityReference **entityRef);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getElementsByTagName )( 
            IXMLDOMDocument * This,
            /* [in] */ BSTR tagName,
            /* [retval][out] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createNode )( 
            IXMLDOMDocument * This,
            /* [in] */ VARIANT Type,
            /* [in] */ BSTR name,
            /* [in] */ BSTR namespaceURI,
            /* [out][retval] */ IXMLDOMNode **node);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *nodeFromID )( 
            IXMLDOMDocument * This,
            /* [in] */ BSTR idString,
            /* [out][retval] */ IXMLDOMNode **node);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *load )( 
            IXMLDOMDocument * This,
            /* [in] */ VARIANT xmlSource,
            /* [retval][out] */ VARIANT_BOOL *isSuccessful);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_readyState )( 
            IXMLDOMDocument * This,
            /* [out][retval] */ long *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parseError )( 
            IXMLDOMDocument * This,
            /* [out][retval] */ IXMLDOMParseError **errorObj);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_url )( 
            IXMLDOMDocument * This,
            /* [out][retval] */ BSTR *urlString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_async )( 
            IXMLDOMDocument * This,
            /* [out][retval] */ VARIANT_BOOL *isAsync);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_async )( 
            IXMLDOMDocument * This,
            /* [in] */ VARIANT_BOOL isAsync);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *abort )( 
            IXMLDOMDocument * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *loadXML )( 
            IXMLDOMDocument * This,
            /* [in] */ BSTR bstrXML,
            /* [retval][out] */ VARIANT_BOOL *isSuccessful);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *save )( 
            IXMLDOMDocument * This,
            /* [in] */ VARIANT destination);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_validateOnParse )( 
            IXMLDOMDocument * This,
            /* [out][retval] */ VARIANT_BOOL *isValidating);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_validateOnParse )( 
            IXMLDOMDocument * This,
            /* [in] */ VARIANT_BOOL isValidating);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_resolveExternals )( 
            IXMLDOMDocument * This,
            /* [out][retval] */ VARIANT_BOOL *isResolving);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_resolveExternals )( 
            IXMLDOMDocument * This,
            /* [in] */ VARIANT_BOOL isResolving);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_preserveWhiteSpace )( 
            IXMLDOMDocument * This,
            /* [out][retval] */ VARIANT_BOOL *isPreserving);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_preserveWhiteSpace )( 
            IXMLDOMDocument * This,
            /* [in] */ VARIANT_BOOL isPreserving);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_onreadystatechange )( 
            IXMLDOMDocument * This,
            /* [in] */ VARIANT readystatechangeSink);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ondataavailable )( 
            IXMLDOMDocument * This,
            /* [in] */ VARIANT ondataavailableSink);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ontransformnode )( 
            IXMLDOMDocument * This,
            /* [in] */ VARIANT ontransformnodeSink);
        
        END_INTERFACE
    } IXMLDOMDocumentVtbl;

    interface IXMLDOMDocument
    {
        CONST_VTBL struct IXMLDOMDocumentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMDocument_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMDocument_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMDocument_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMDocument_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMDocument_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMDocument_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMDocument_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMDocument_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMDocument_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMDocument_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMDocument_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMDocument_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMDocument_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMDocument_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMDocument_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMDocument_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMDocument_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMDocument_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMDocument_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMDocument_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMDocument_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMDocument_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMDocument_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMDocument_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMDocument_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMDocument_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMDocument_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMDocument_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMDocument_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMDocument_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMDocument_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMDocument_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMDocument_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMDocument_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMDocument_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMDocument_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMDocument_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMDocument_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMDocument_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMDocument_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMDocument_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMDocument_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMDocument_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMDocument_get_doctype(This,documentType)	\
    (This)->lpVtbl -> get_doctype(This,documentType)

#define IXMLDOMDocument_get_implementation(This,impl)	\
    (This)->lpVtbl -> get_implementation(This,impl)

#define IXMLDOMDocument_get_documentElement(This,DOMElement)	\
    (This)->lpVtbl -> get_documentElement(This,DOMElement)

#define IXMLDOMDocument_putref_documentElement(This,DOMElement)	\
    (This)->lpVtbl -> putref_documentElement(This,DOMElement)

#define IXMLDOMDocument_createElement(This,tagName,element)	\
    (This)->lpVtbl -> createElement(This,tagName,element)

#define IXMLDOMDocument_createDocumentFragment(This,docFrag)	\
    (This)->lpVtbl -> createDocumentFragment(This,docFrag)

#define IXMLDOMDocument_createTextNode(This,data,text)	\
    (This)->lpVtbl -> createTextNode(This,data,text)

#define IXMLDOMDocument_createComment(This,data,comment)	\
    (This)->lpVtbl -> createComment(This,data,comment)

#define IXMLDOMDocument_createCDATASection(This,data,cdata)	\
    (This)->lpVtbl -> createCDATASection(This,data,cdata)

#define IXMLDOMDocument_createProcessingInstruction(This,target,data,pi)	\
    (This)->lpVtbl -> createProcessingInstruction(This,target,data,pi)

#define IXMLDOMDocument_createAttribute(This,name,attribute)	\
    (This)->lpVtbl -> createAttribute(This,name,attribute)

#define IXMLDOMDocument_createEntityReference(This,name,entityRef)	\
    (This)->lpVtbl -> createEntityReference(This,name,entityRef)

#define IXMLDOMDocument_getElementsByTagName(This,tagName,resultList)	\
    (This)->lpVtbl -> getElementsByTagName(This,tagName,resultList)

#define IXMLDOMDocument_createNode(This,Type,name,namespaceURI,node)	\
    (This)->lpVtbl -> createNode(This,Type,name,namespaceURI,node)

#define IXMLDOMDocument_nodeFromID(This,idString,node)	\
    (This)->lpVtbl -> nodeFromID(This,idString,node)

#define IXMLDOMDocument_load(This,xmlSource,isSuccessful)	\
    (This)->lpVtbl -> load(This,xmlSource,isSuccessful)

#define IXMLDOMDocument_get_readyState(This,value)	\
    (This)->lpVtbl -> get_readyState(This,value)

#define IXMLDOMDocument_get_parseError(This,errorObj)	\
    (This)->lpVtbl -> get_parseError(This,errorObj)

#define IXMLDOMDocument_get_url(This,urlString)	\
    (This)->lpVtbl -> get_url(This,urlString)

#define IXMLDOMDocument_get_async(This,isAsync)	\
    (This)->lpVtbl -> get_async(This,isAsync)

#define IXMLDOMDocument_put_async(This,isAsync)	\
    (This)->lpVtbl -> put_async(This,isAsync)

#define IXMLDOMDocument_abort(This)	\
    (This)->lpVtbl -> abort(This)

#define IXMLDOMDocument_loadXML(This,bstrXML,isSuccessful)	\
    (This)->lpVtbl -> loadXML(This,bstrXML,isSuccessful)

#define IXMLDOMDocument_save(This,destination)	\
    (This)->lpVtbl -> save(This,destination)

#define IXMLDOMDocument_get_validateOnParse(This,isValidating)	\
    (This)->lpVtbl -> get_validateOnParse(This,isValidating)

#define IXMLDOMDocument_put_validateOnParse(This,isValidating)	\
    (This)->lpVtbl -> put_validateOnParse(This,isValidating)

#define IXMLDOMDocument_get_resolveExternals(This,isResolving)	\
    (This)->lpVtbl -> get_resolveExternals(This,isResolving)

#define IXMLDOMDocument_put_resolveExternals(This,isResolving)	\
    (This)->lpVtbl -> put_resolveExternals(This,isResolving)

#define IXMLDOMDocument_get_preserveWhiteSpace(This,isPreserving)	\
    (This)->lpVtbl -> get_preserveWhiteSpace(This,isPreserving)

#define IXMLDOMDocument_put_preserveWhiteSpace(This,isPreserving)	\
    (This)->lpVtbl -> put_preserveWhiteSpace(This,isPreserving)

#define IXMLDOMDocument_put_onreadystatechange(This,readystatechangeSink)	\
    (This)->lpVtbl -> put_onreadystatechange(This,readystatechangeSink)

#define IXMLDOMDocument_put_ondataavailable(This,ondataavailableSink)	\
    (This)->lpVtbl -> put_ondataavailable(This,ondataavailableSink)

#define IXMLDOMDocument_put_ontransformnode(This,ontransformnodeSink)	\
    (This)->lpVtbl -> put_ontransformnode(This,ontransformnodeSink)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_get_doctype_Proxy( 
    IXMLDOMDocument * This,
    /* [retval][out] */ IXMLDOMDocumentType **documentType);


void __RPC_STUB IXMLDOMDocument_get_doctype_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_get_implementation_Proxy( 
    IXMLDOMDocument * This,
    /* [retval][out] */ IXMLDOMImplementation **impl);


void __RPC_STUB IXMLDOMDocument_get_implementation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_get_documentElement_Proxy( 
    IXMLDOMDocument * This,
    /* [retval][out] */ IXMLDOMElement **DOMElement);


void __RPC_STUB IXMLDOMDocument_get_documentElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_putref_documentElement_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ IXMLDOMElement *DOMElement);


void __RPC_STUB IXMLDOMDocument_putref_documentElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_createElement_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ BSTR tagName,
    /* [retval][out] */ IXMLDOMElement **element);


void __RPC_STUB IXMLDOMDocument_createElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_createDocumentFragment_Proxy( 
    IXMLDOMDocument * This,
    /* [retval][out] */ IXMLDOMDocumentFragment **docFrag);


void __RPC_STUB IXMLDOMDocument_createDocumentFragment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_createTextNode_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ BSTR data,
    /* [retval][out] */ IXMLDOMText **text);


void __RPC_STUB IXMLDOMDocument_createTextNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_createComment_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ BSTR data,
    /* [retval][out] */ IXMLDOMComment **comment);


void __RPC_STUB IXMLDOMDocument_createComment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_createCDATASection_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ BSTR data,
    /* [retval][out] */ IXMLDOMCDATASection **cdata);


void __RPC_STUB IXMLDOMDocument_createCDATASection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_createProcessingInstruction_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ BSTR target,
    /* [in] */ BSTR data,
    /* [retval][out] */ IXMLDOMProcessingInstruction **pi);


void __RPC_STUB IXMLDOMDocument_createProcessingInstruction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_createAttribute_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ IXMLDOMAttribute **attribute);


void __RPC_STUB IXMLDOMDocument_createAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_createEntityReference_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ IXMLDOMEntityReference **entityRef);


void __RPC_STUB IXMLDOMDocument_createEntityReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_getElementsByTagName_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ BSTR tagName,
    /* [retval][out] */ IXMLDOMNodeList **resultList);


void __RPC_STUB IXMLDOMDocument_getElementsByTagName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_createNode_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ VARIANT Type,
    /* [in] */ BSTR name,
    /* [in] */ BSTR namespaceURI,
    /* [out][retval] */ IXMLDOMNode **node);


void __RPC_STUB IXMLDOMDocument_createNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_nodeFromID_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ BSTR idString,
    /* [out][retval] */ IXMLDOMNode **node);


void __RPC_STUB IXMLDOMDocument_nodeFromID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_load_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ VARIANT xmlSource,
    /* [retval][out] */ VARIANT_BOOL *isSuccessful);


void __RPC_STUB IXMLDOMDocument_load_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_get_readyState_Proxy( 
    IXMLDOMDocument * This,
    /* [out][retval] */ long *value);


void __RPC_STUB IXMLDOMDocument_get_readyState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_get_parseError_Proxy( 
    IXMLDOMDocument * This,
    /* [out][retval] */ IXMLDOMParseError **errorObj);


void __RPC_STUB IXMLDOMDocument_get_parseError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_get_url_Proxy( 
    IXMLDOMDocument * This,
    /* [out][retval] */ BSTR *urlString);


void __RPC_STUB IXMLDOMDocument_get_url_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_get_async_Proxy( 
    IXMLDOMDocument * This,
    /* [out][retval] */ VARIANT_BOOL *isAsync);


void __RPC_STUB IXMLDOMDocument_get_async_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_put_async_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ VARIANT_BOOL isAsync);


void __RPC_STUB IXMLDOMDocument_put_async_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_abort_Proxy( 
    IXMLDOMDocument * This);


void __RPC_STUB IXMLDOMDocument_abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_loadXML_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ BSTR bstrXML,
    /* [retval][out] */ VARIANT_BOOL *isSuccessful);


void __RPC_STUB IXMLDOMDocument_loadXML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_save_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ VARIANT destination);


void __RPC_STUB IXMLDOMDocument_save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_get_validateOnParse_Proxy( 
    IXMLDOMDocument * This,
    /* [out][retval] */ VARIANT_BOOL *isValidating);


void __RPC_STUB IXMLDOMDocument_get_validateOnParse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_put_validateOnParse_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ VARIANT_BOOL isValidating);


void __RPC_STUB IXMLDOMDocument_put_validateOnParse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_get_resolveExternals_Proxy( 
    IXMLDOMDocument * This,
    /* [out][retval] */ VARIANT_BOOL *isResolving);


void __RPC_STUB IXMLDOMDocument_get_resolveExternals_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_put_resolveExternals_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ VARIANT_BOOL isResolving);


void __RPC_STUB IXMLDOMDocument_put_resolveExternals_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_get_preserveWhiteSpace_Proxy( 
    IXMLDOMDocument * This,
    /* [out][retval] */ VARIANT_BOOL *isPreserving);


void __RPC_STUB IXMLDOMDocument_get_preserveWhiteSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_put_preserveWhiteSpace_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ VARIANT_BOOL isPreserving);


void __RPC_STUB IXMLDOMDocument_put_preserveWhiteSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_put_onreadystatechange_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ VARIANT readystatechangeSink);


void __RPC_STUB IXMLDOMDocument_put_onreadystatechange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_put_ondataavailable_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ VARIANT ondataavailableSink);


void __RPC_STUB IXMLDOMDocument_put_ondataavailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument_put_ontransformnode_Proxy( 
    IXMLDOMDocument * This,
    /* [in] */ VARIANT ontransformnodeSink);


void __RPC_STUB IXMLDOMDocument_put_ontransformnode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMDocument_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMSchemaCollection_INTERFACE_DEFINED__
#define __IXMLDOMSchemaCollection_INTERFACE_DEFINED__

/* interface IXMLDOMSchemaCollection */
/* [unique][helpstring][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMSchemaCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("373984c8-b845-449b-91e7-45ac83036ade")
    IXMLDOMSchemaCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE add( 
            /* [in] */ BSTR namespaceURI,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE get( 
            /* [in] */ BSTR namespaceURI,
            /* [retval][out] */ IXMLDOMNode **schemaNode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE remove( 
            /* [in] */ BSTR namespaceURI) = 0;
        
        virtual /* [propget][helpstring][id] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ long *length) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_namespaceURI( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR *length) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE addCollection( 
            /* [in] */ IXMLDOMSchemaCollection *otherCollection) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__newEnum( 
            /* [out][retval] */ IUnknown **ppUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMSchemaCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMSchemaCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMSchemaCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMSchemaCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMSchemaCollection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMSchemaCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMSchemaCollection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMSchemaCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *add )( 
            IXMLDOMSchemaCollection * This,
            /* [in] */ BSTR namespaceURI,
            /* [in] */ VARIANT var);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *get )( 
            IXMLDOMSchemaCollection * This,
            /* [in] */ BSTR namespaceURI,
            /* [retval][out] */ IXMLDOMNode **schemaNode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *remove )( 
            IXMLDOMSchemaCollection * This,
            /* [in] */ BSTR namespaceURI);
        
        /* [propget][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IXMLDOMSchemaCollection * This,
            /* [retval][out] */ long *length);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            IXMLDOMSchemaCollection * This,
            /* [in] */ long index,
            /* [retval][out] */ BSTR *length);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *addCollection )( 
            IXMLDOMSchemaCollection * This,
            /* [in] */ IXMLDOMSchemaCollection *otherCollection);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__newEnum )( 
            IXMLDOMSchemaCollection * This,
            /* [out][retval] */ IUnknown **ppUnk);
        
        END_INTERFACE
    } IXMLDOMSchemaCollectionVtbl;

    interface IXMLDOMSchemaCollection
    {
        CONST_VTBL struct IXMLDOMSchemaCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMSchemaCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMSchemaCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMSchemaCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMSchemaCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMSchemaCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMSchemaCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMSchemaCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMSchemaCollection_add(This,namespaceURI,var)	\
    (This)->lpVtbl -> add(This,namespaceURI,var)

#define IXMLDOMSchemaCollection_get(This,namespaceURI,schemaNode)	\
    (This)->lpVtbl -> get(This,namespaceURI,schemaNode)

#define IXMLDOMSchemaCollection_remove(This,namespaceURI)	\
    (This)->lpVtbl -> remove(This,namespaceURI)

#define IXMLDOMSchemaCollection_get_length(This,length)	\
    (This)->lpVtbl -> get_length(This,length)

#define IXMLDOMSchemaCollection_get_namespaceURI(This,index,length)	\
    (This)->lpVtbl -> get_namespaceURI(This,index,length)

#define IXMLDOMSchemaCollection_addCollection(This,otherCollection)	\
    (This)->lpVtbl -> addCollection(This,otherCollection)

#define IXMLDOMSchemaCollection_get__newEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__newEnum(This,ppUnk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMSchemaCollection_add_Proxy( 
    IXMLDOMSchemaCollection * This,
    /* [in] */ BSTR namespaceURI,
    /* [in] */ VARIANT var);


void __RPC_STUB IXMLDOMSchemaCollection_add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMSchemaCollection_get_Proxy( 
    IXMLDOMSchemaCollection * This,
    /* [in] */ BSTR namespaceURI,
    /* [retval][out] */ IXMLDOMNode **schemaNode);


void __RPC_STUB IXMLDOMSchemaCollection_get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMSchemaCollection_remove_Proxy( 
    IXMLDOMSchemaCollection * This,
    /* [in] */ BSTR namespaceURI);


void __RPC_STUB IXMLDOMSchemaCollection_remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMSchemaCollection_get_length_Proxy( 
    IXMLDOMSchemaCollection * This,
    /* [retval][out] */ long *length);


void __RPC_STUB IXMLDOMSchemaCollection_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMSchemaCollection_get_namespaceURI_Proxy( 
    IXMLDOMSchemaCollection * This,
    /* [in] */ long index,
    /* [retval][out] */ BSTR *length);


void __RPC_STUB IXMLDOMSchemaCollection_get_namespaceURI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMSchemaCollection_addCollection_Proxy( 
    IXMLDOMSchemaCollection * This,
    /* [in] */ IXMLDOMSchemaCollection *otherCollection);


void __RPC_STUB IXMLDOMSchemaCollection_addCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMSchemaCollection_get__newEnum_Proxy( 
    IXMLDOMSchemaCollection * This,
    /* [out][retval] */ IUnknown **ppUnk);


void __RPC_STUB IXMLDOMSchemaCollection_get__newEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMSchemaCollection_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMDocument2_INTERFACE_DEFINED__
#define __IXMLDOMDocument2_INTERFACE_DEFINED__

/* interface IXMLDOMDocument2 */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMDocument2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF95-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMDocument2 : public IXMLDOMDocument
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_namespaces( 
            /* [retval][out] */ IXMLDOMSchemaCollection **namespaceCollection) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_schemas( 
            /* [retval][out] */ VARIANT *otherCollection) = 0;
        
        virtual /* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_schemas( 
            /* [in] */ VARIANT otherCollection) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE validate( 
            /* [out][retval] */ IXMLDOMParseError **errorObj) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setProperty( 
            /* [in] */ BSTR name,
            /* [in] */ VARIANT value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getProperty( 
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT *value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMDocument2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMDocument2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMDocument2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMDocument2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMDocument2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMDocument2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMDocument2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMDocument2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeName )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeValue )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeValue )( 
            IXMLDOMDocument2 * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeType )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ DOMNodeType *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parentNode )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ IXMLDOMNode **parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_childNodes )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ IXMLDOMNodeList **childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_firstChild )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ IXMLDOMNode **firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastChild )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ IXMLDOMNode **lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_previousSibling )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ IXMLDOMNode **previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nextSibling )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ IXMLDOMNode **nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertBefore )( 
            IXMLDOMDocument2 * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceChild )( 
            IXMLDOMDocument2 * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ IXMLDOMNode *oldChild,
            /* [retval][out] */ IXMLDOMNode **outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IXMLDOMDocument2 * This,
            /* [in] */ IXMLDOMNode *childNode,
            /* [retval][out] */ IXMLDOMNode **oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendChild )( 
            IXMLDOMDocument2 * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *hasChildNodes )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ VARIANT_BOOL *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ownerDocument )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ IXMLDOMDocument **DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *cloneNode )( 
            IXMLDOMDocument2 * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode **cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypeString )( 
            IXMLDOMDocument2 * This,
            /* [out][retval] */ BSTR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IXMLDOMDocument2 * This,
            /* [out][retval] */ BSTR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IXMLDOMDocument2 * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_specified )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ VARIANT_BOOL *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_definition )( 
            IXMLDOMDocument2 * This,
            /* [out][retval] */ IXMLDOMNode **definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypedValue )( 
            IXMLDOMDocument2 * This,
            /* [out][retval] */ VARIANT *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeTypedValue )( 
            IXMLDOMDocument2 * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataType )( 
            IXMLDOMDocument2 * This,
            /* [out][retval] */ VARIANT *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dataType )( 
            IXMLDOMDocument2 * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_xml )( 
            IXMLDOMDocument2 * This,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNode )( 
            IXMLDOMDocument2 * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectNodes )( 
            IXMLDOMDocument2 * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectSingleNode )( 
            IXMLDOMDocument2 * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode **resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parsed )( 
            IXMLDOMDocument2 * This,
            /* [out][retval] */ VARIANT_BOOL *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            IXMLDOMDocument2 * This,
            /* [out][retval] */ BSTR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_prefix )( 
            IXMLDOMDocument2 * This,
            /* [out][retval] */ BSTR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseName )( 
            IXMLDOMDocument2 * This,
            /* [out][retval] */ BSTR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNodeToObject )( 
            IXMLDOMDocument2 * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_doctype )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ IXMLDOMDocumentType **documentType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_implementation )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ IXMLDOMImplementation **impl);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_documentElement )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ IXMLDOMElement **DOMElement);
        
        /* [helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE *putref_documentElement )( 
            IXMLDOMDocument2 * This,
            /* [in] */ IXMLDOMElement *DOMElement);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createElement )( 
            IXMLDOMDocument2 * This,
            /* [in] */ BSTR tagName,
            /* [retval][out] */ IXMLDOMElement **element);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createDocumentFragment )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ IXMLDOMDocumentFragment **docFrag);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createTextNode )( 
            IXMLDOMDocument2 * This,
            /* [in] */ BSTR data,
            /* [retval][out] */ IXMLDOMText **text);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createComment )( 
            IXMLDOMDocument2 * This,
            /* [in] */ BSTR data,
            /* [retval][out] */ IXMLDOMComment **comment);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createCDATASection )( 
            IXMLDOMDocument2 * This,
            /* [in] */ BSTR data,
            /* [retval][out] */ IXMLDOMCDATASection **cdata);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createProcessingInstruction )( 
            IXMLDOMDocument2 * This,
            /* [in] */ BSTR target,
            /* [in] */ BSTR data,
            /* [retval][out] */ IXMLDOMProcessingInstruction **pi);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createAttribute )( 
            IXMLDOMDocument2 * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ IXMLDOMAttribute **attribute);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createEntityReference )( 
            IXMLDOMDocument2 * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ IXMLDOMEntityReference **entityRef);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getElementsByTagName )( 
            IXMLDOMDocument2 * This,
            /* [in] */ BSTR tagName,
            /* [retval][out] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createNode )( 
            IXMLDOMDocument2 * This,
            /* [in] */ VARIANT Type,
            /* [in] */ BSTR name,
            /* [in] */ BSTR namespaceURI,
            /* [out][retval] */ IXMLDOMNode **node);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *nodeFromID )( 
            IXMLDOMDocument2 * This,
            /* [in] */ BSTR idString,
            /* [out][retval] */ IXMLDOMNode **node);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *load )( 
            IXMLDOMDocument2 * This,
            /* [in] */ VARIANT xmlSource,
            /* [retval][out] */ VARIANT_BOOL *isSuccessful);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_readyState )( 
            IXMLDOMDocument2 * This,
            /* [out][retval] */ long *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parseError )( 
            IXMLDOMDocument2 * This,
            /* [out][retval] */ IXMLDOMParseError **errorObj);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_url )( 
            IXMLDOMDocument2 * This,
            /* [out][retval] */ BSTR *urlString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_async )( 
            IXMLDOMDocument2 * This,
            /* [out][retval] */ VARIANT_BOOL *isAsync);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_async )( 
            IXMLDOMDocument2 * This,
            /* [in] */ VARIANT_BOOL isAsync);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *abort )( 
            IXMLDOMDocument2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *loadXML )( 
            IXMLDOMDocument2 * This,
            /* [in] */ BSTR bstrXML,
            /* [retval][out] */ VARIANT_BOOL *isSuccessful);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *save )( 
            IXMLDOMDocument2 * This,
            /* [in] */ VARIANT destination);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_validateOnParse )( 
            IXMLDOMDocument2 * This,
            /* [out][retval] */ VARIANT_BOOL *isValidating);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_validateOnParse )( 
            IXMLDOMDocument2 * This,
            /* [in] */ VARIANT_BOOL isValidating);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_resolveExternals )( 
            IXMLDOMDocument2 * This,
            /* [out][retval] */ VARIANT_BOOL *isResolving);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_resolveExternals )( 
            IXMLDOMDocument2 * This,
            /* [in] */ VARIANT_BOOL isResolving);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_preserveWhiteSpace )( 
            IXMLDOMDocument2 * This,
            /* [out][retval] */ VARIANT_BOOL *isPreserving);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_preserveWhiteSpace )( 
            IXMLDOMDocument2 * This,
            /* [in] */ VARIANT_BOOL isPreserving);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_onreadystatechange )( 
            IXMLDOMDocument2 * This,
            /* [in] */ VARIANT readystatechangeSink);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ondataavailable )( 
            IXMLDOMDocument2 * This,
            /* [in] */ VARIANT ondataavailableSink);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ontransformnode )( 
            IXMLDOMDocument2 * This,
            /* [in] */ VARIANT ontransformnodeSink);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaces )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ IXMLDOMSchemaCollection **namespaceCollection);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_schemas )( 
            IXMLDOMDocument2 * This,
            /* [retval][out] */ VARIANT *otherCollection);
        
        /* [helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE *putref_schemas )( 
            IXMLDOMDocument2 * This,
            /* [in] */ VARIANT otherCollection);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *validate )( 
            IXMLDOMDocument2 * This,
            /* [out][retval] */ IXMLDOMParseError **errorObj);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setProperty )( 
            IXMLDOMDocument2 * This,
            /* [in] */ BSTR name,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getProperty )( 
            IXMLDOMDocument2 * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT *value);
        
        END_INTERFACE
    } IXMLDOMDocument2Vtbl;

    interface IXMLDOMDocument2
    {
        CONST_VTBL struct IXMLDOMDocument2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMDocument2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMDocument2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMDocument2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMDocument2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMDocument2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMDocument2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMDocument2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMDocument2_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMDocument2_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMDocument2_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMDocument2_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMDocument2_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMDocument2_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMDocument2_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMDocument2_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMDocument2_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMDocument2_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMDocument2_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMDocument2_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMDocument2_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMDocument2_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMDocument2_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMDocument2_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMDocument2_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMDocument2_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMDocument2_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMDocument2_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMDocument2_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMDocument2_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMDocument2_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMDocument2_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMDocument2_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMDocument2_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMDocument2_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMDocument2_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMDocument2_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMDocument2_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMDocument2_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMDocument2_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMDocument2_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMDocument2_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMDocument2_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMDocument2_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMDocument2_get_doctype(This,documentType)	\
    (This)->lpVtbl -> get_doctype(This,documentType)

#define IXMLDOMDocument2_get_implementation(This,impl)	\
    (This)->lpVtbl -> get_implementation(This,impl)

#define IXMLDOMDocument2_get_documentElement(This,DOMElement)	\
    (This)->lpVtbl -> get_documentElement(This,DOMElement)

#define IXMLDOMDocument2_putref_documentElement(This,DOMElement)	\
    (This)->lpVtbl -> putref_documentElement(This,DOMElement)

#define IXMLDOMDocument2_createElement(This,tagName,element)	\
    (This)->lpVtbl -> createElement(This,tagName,element)

#define IXMLDOMDocument2_createDocumentFragment(This,docFrag)	\
    (This)->lpVtbl -> createDocumentFragment(This,docFrag)

#define IXMLDOMDocument2_createTextNode(This,data,text)	\
    (This)->lpVtbl -> createTextNode(This,data,text)

#define IXMLDOMDocument2_createComment(This,data,comment)	\
    (This)->lpVtbl -> createComment(This,data,comment)

#define IXMLDOMDocument2_createCDATASection(This,data,cdata)	\
    (This)->lpVtbl -> createCDATASection(This,data,cdata)

#define IXMLDOMDocument2_createProcessingInstruction(This,target,data,pi)	\
    (This)->lpVtbl -> createProcessingInstruction(This,target,data,pi)

#define IXMLDOMDocument2_createAttribute(This,name,attribute)	\
    (This)->lpVtbl -> createAttribute(This,name,attribute)

#define IXMLDOMDocument2_createEntityReference(This,name,entityRef)	\
    (This)->lpVtbl -> createEntityReference(This,name,entityRef)

#define IXMLDOMDocument2_getElementsByTagName(This,tagName,resultList)	\
    (This)->lpVtbl -> getElementsByTagName(This,tagName,resultList)

#define IXMLDOMDocument2_createNode(This,Type,name,namespaceURI,node)	\
    (This)->lpVtbl -> createNode(This,Type,name,namespaceURI,node)

#define IXMLDOMDocument2_nodeFromID(This,idString,node)	\
    (This)->lpVtbl -> nodeFromID(This,idString,node)

#define IXMLDOMDocument2_load(This,xmlSource,isSuccessful)	\
    (This)->lpVtbl -> load(This,xmlSource,isSuccessful)

#define IXMLDOMDocument2_get_readyState(This,value)	\
    (This)->lpVtbl -> get_readyState(This,value)

#define IXMLDOMDocument2_get_parseError(This,errorObj)	\
    (This)->lpVtbl -> get_parseError(This,errorObj)

#define IXMLDOMDocument2_get_url(This,urlString)	\
    (This)->lpVtbl -> get_url(This,urlString)

#define IXMLDOMDocument2_get_async(This,isAsync)	\
    (This)->lpVtbl -> get_async(This,isAsync)

#define IXMLDOMDocument2_put_async(This,isAsync)	\
    (This)->lpVtbl -> put_async(This,isAsync)

#define IXMLDOMDocument2_abort(This)	\
    (This)->lpVtbl -> abort(This)

#define IXMLDOMDocument2_loadXML(This,bstrXML,isSuccessful)	\
    (This)->lpVtbl -> loadXML(This,bstrXML,isSuccessful)

#define IXMLDOMDocument2_save(This,destination)	\
    (This)->lpVtbl -> save(This,destination)

#define IXMLDOMDocument2_get_validateOnParse(This,isValidating)	\
    (This)->lpVtbl -> get_validateOnParse(This,isValidating)

#define IXMLDOMDocument2_put_validateOnParse(This,isValidating)	\
    (This)->lpVtbl -> put_validateOnParse(This,isValidating)

#define IXMLDOMDocument2_get_resolveExternals(This,isResolving)	\
    (This)->lpVtbl -> get_resolveExternals(This,isResolving)

#define IXMLDOMDocument2_put_resolveExternals(This,isResolving)	\
    (This)->lpVtbl -> put_resolveExternals(This,isResolving)

#define IXMLDOMDocument2_get_preserveWhiteSpace(This,isPreserving)	\
    (This)->lpVtbl -> get_preserveWhiteSpace(This,isPreserving)

#define IXMLDOMDocument2_put_preserveWhiteSpace(This,isPreserving)	\
    (This)->lpVtbl -> put_preserveWhiteSpace(This,isPreserving)

#define IXMLDOMDocument2_put_onreadystatechange(This,readystatechangeSink)	\
    (This)->lpVtbl -> put_onreadystatechange(This,readystatechangeSink)

#define IXMLDOMDocument2_put_ondataavailable(This,ondataavailableSink)	\
    (This)->lpVtbl -> put_ondataavailable(This,ondataavailableSink)

#define IXMLDOMDocument2_put_ontransformnode(This,ontransformnodeSink)	\
    (This)->lpVtbl -> put_ontransformnode(This,ontransformnodeSink)


#define IXMLDOMDocument2_get_namespaces(This,namespaceCollection)	\
    (This)->lpVtbl -> get_namespaces(This,namespaceCollection)

#define IXMLDOMDocument2_get_schemas(This,otherCollection)	\
    (This)->lpVtbl -> get_schemas(This,otherCollection)

#define IXMLDOMDocument2_putref_schemas(This,otherCollection)	\
    (This)->lpVtbl -> putref_schemas(This,otherCollection)

#define IXMLDOMDocument2_validate(This,errorObj)	\
    (This)->lpVtbl -> validate(This,errorObj)

#define IXMLDOMDocument2_setProperty(This,name,value)	\
    (This)->lpVtbl -> setProperty(This,name,value)

#define IXMLDOMDocument2_getProperty(This,name,value)	\
    (This)->lpVtbl -> getProperty(This,name,value)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument2_get_namespaces_Proxy( 
    IXMLDOMDocument2 * This,
    /* [retval][out] */ IXMLDOMSchemaCollection **namespaceCollection);


void __RPC_STUB IXMLDOMDocument2_get_namespaces_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument2_get_schemas_Proxy( 
    IXMLDOMDocument2 * This,
    /* [retval][out] */ VARIANT *otherCollection);


void __RPC_STUB IXMLDOMDocument2_get_schemas_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument2_putref_schemas_Proxy( 
    IXMLDOMDocument2 * This,
    /* [in] */ VARIANT otherCollection);


void __RPC_STUB IXMLDOMDocument2_putref_schemas_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument2_validate_Proxy( 
    IXMLDOMDocument2 * This,
    /* [out][retval] */ IXMLDOMParseError **errorObj);


void __RPC_STUB IXMLDOMDocument2_validate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument2_setProperty_Proxy( 
    IXMLDOMDocument2 * This,
    /* [in] */ BSTR name,
    /* [in] */ VARIANT value);


void __RPC_STUB IXMLDOMDocument2_setProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocument2_getProperty_Proxy( 
    IXMLDOMDocument2 * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ VARIANT *value);


void __RPC_STUB IXMLDOMDocument2_getProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMDocument2_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMNodeList_INTERFACE_DEFINED__
#define __IXMLDOMNodeList_INTERFACE_DEFINED__

/* interface IXMLDOMNodeList */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMNodeList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF82-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMNodeList : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_item( 
            /* [in] */ long index,
            /* [retval][out] */ IXMLDOMNode **listItem) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ long *listLength) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE nextNode( 
            /* [retval][out] */ IXMLDOMNode **nextItem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE reset( void) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__newEnum( 
            /* [out][retval] */ IUnknown **ppUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMNodeListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMNodeList * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMNodeList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMNodeList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMNodeList * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMNodeList * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMNodeList * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMNodeList * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_item )( 
            IXMLDOMNodeList * This,
            /* [in] */ long index,
            /* [retval][out] */ IXMLDOMNode **listItem);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IXMLDOMNodeList * This,
            /* [retval][out] */ long *listLength);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *nextNode )( 
            IXMLDOMNodeList * This,
            /* [retval][out] */ IXMLDOMNode **nextItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *reset )( 
            IXMLDOMNodeList * This);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__newEnum )( 
            IXMLDOMNodeList * This,
            /* [out][retval] */ IUnknown **ppUnk);
        
        END_INTERFACE
    } IXMLDOMNodeListVtbl;

    interface IXMLDOMNodeList
    {
        CONST_VTBL struct IXMLDOMNodeListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMNodeList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMNodeList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMNodeList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMNodeList_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMNodeList_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMNodeList_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMNodeList_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMNodeList_get_item(This,index,listItem)	\
    (This)->lpVtbl -> get_item(This,index,listItem)

#define IXMLDOMNodeList_get_length(This,listLength)	\
    (This)->lpVtbl -> get_length(This,listLength)

#define IXMLDOMNodeList_nextNode(This,nextItem)	\
    (This)->lpVtbl -> nextNode(This,nextItem)

#define IXMLDOMNodeList_reset(This)	\
    (This)->lpVtbl -> reset(This)

#define IXMLDOMNodeList_get__newEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__newEnum(This,ppUnk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNodeList_get_item_Proxy( 
    IXMLDOMNodeList * This,
    /* [in] */ long index,
    /* [retval][out] */ IXMLDOMNode **listItem);


void __RPC_STUB IXMLDOMNodeList_get_item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNodeList_get_length_Proxy( 
    IXMLDOMNodeList * This,
    /* [retval][out] */ long *listLength);


void __RPC_STUB IXMLDOMNodeList_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNodeList_nextNode_Proxy( 
    IXMLDOMNodeList * This,
    /* [retval][out] */ IXMLDOMNode **nextItem);


void __RPC_STUB IXMLDOMNodeList_nextNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNodeList_reset_Proxy( 
    IXMLDOMNodeList * This);


void __RPC_STUB IXMLDOMNodeList_reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNodeList_get__newEnum_Proxy( 
    IXMLDOMNodeList * This,
    /* [out][retval] */ IUnknown **ppUnk);


void __RPC_STUB IXMLDOMNodeList_get__newEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMNodeList_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMNamedNodeMap_INTERFACE_DEFINED__
#define __IXMLDOMNamedNodeMap_INTERFACE_DEFINED__

/* interface IXMLDOMNamedNodeMap */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMNamedNodeMap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF83-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMNamedNodeMap : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getNamedItem( 
            /* [in] */ BSTR name,
            /* [retval][out] */ IXMLDOMNode **namedItem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setNamedItem( 
            /* [in] */ IXMLDOMNode *newItem,
            /* [retval][out] */ IXMLDOMNode **nameItem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeNamedItem( 
            /* [in] */ BSTR name,
            /* [retval][out] */ IXMLDOMNode **namedItem) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_item( 
            /* [in] */ long index,
            /* [retval][out] */ IXMLDOMNode **listItem) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ long *listLength) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getQualifiedItem( 
            /* [in] */ BSTR baseName,
            /* [in] */ BSTR namespaceURI,
            /* [retval][out] */ IXMLDOMNode **qualifiedItem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeQualifiedItem( 
            /* [in] */ BSTR baseName,
            /* [in] */ BSTR namespaceURI,
            /* [retval][out] */ IXMLDOMNode **qualifiedItem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE nextNode( 
            /* [retval][out] */ IXMLDOMNode **nextItem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE reset( void) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__newEnum( 
            /* [out][retval] */ IUnknown **ppUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMNamedNodeMapVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMNamedNodeMap * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMNamedNodeMap * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMNamedNodeMap * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMNamedNodeMap * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMNamedNodeMap * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMNamedNodeMap * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMNamedNodeMap * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getNamedItem )( 
            IXMLDOMNamedNodeMap * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ IXMLDOMNode **namedItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setNamedItem )( 
            IXMLDOMNamedNodeMap * This,
            /* [in] */ IXMLDOMNode *newItem,
            /* [retval][out] */ IXMLDOMNode **nameItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeNamedItem )( 
            IXMLDOMNamedNodeMap * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ IXMLDOMNode **namedItem);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_item )( 
            IXMLDOMNamedNodeMap * This,
            /* [in] */ long index,
            /* [retval][out] */ IXMLDOMNode **listItem);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IXMLDOMNamedNodeMap * This,
            /* [retval][out] */ long *listLength);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getQualifiedItem )( 
            IXMLDOMNamedNodeMap * This,
            /* [in] */ BSTR baseName,
            /* [in] */ BSTR namespaceURI,
            /* [retval][out] */ IXMLDOMNode **qualifiedItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeQualifiedItem )( 
            IXMLDOMNamedNodeMap * This,
            /* [in] */ BSTR baseName,
            /* [in] */ BSTR namespaceURI,
            /* [retval][out] */ IXMLDOMNode **qualifiedItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *nextNode )( 
            IXMLDOMNamedNodeMap * This,
            /* [retval][out] */ IXMLDOMNode **nextItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *reset )( 
            IXMLDOMNamedNodeMap * This);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__newEnum )( 
            IXMLDOMNamedNodeMap * This,
            /* [out][retval] */ IUnknown **ppUnk);
        
        END_INTERFACE
    } IXMLDOMNamedNodeMapVtbl;

    interface IXMLDOMNamedNodeMap
    {
        CONST_VTBL struct IXMLDOMNamedNodeMapVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMNamedNodeMap_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMNamedNodeMap_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMNamedNodeMap_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMNamedNodeMap_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMNamedNodeMap_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMNamedNodeMap_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMNamedNodeMap_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMNamedNodeMap_getNamedItem(This,name,namedItem)	\
    (This)->lpVtbl -> getNamedItem(This,name,namedItem)

#define IXMLDOMNamedNodeMap_setNamedItem(This,newItem,nameItem)	\
    (This)->lpVtbl -> setNamedItem(This,newItem,nameItem)

#define IXMLDOMNamedNodeMap_removeNamedItem(This,name,namedItem)	\
    (This)->lpVtbl -> removeNamedItem(This,name,namedItem)

#define IXMLDOMNamedNodeMap_get_item(This,index,listItem)	\
    (This)->lpVtbl -> get_item(This,index,listItem)

#define IXMLDOMNamedNodeMap_get_length(This,listLength)	\
    (This)->lpVtbl -> get_length(This,listLength)

#define IXMLDOMNamedNodeMap_getQualifiedItem(This,baseName,namespaceURI,qualifiedItem)	\
    (This)->lpVtbl -> getQualifiedItem(This,baseName,namespaceURI,qualifiedItem)

#define IXMLDOMNamedNodeMap_removeQualifiedItem(This,baseName,namespaceURI,qualifiedItem)	\
    (This)->lpVtbl -> removeQualifiedItem(This,baseName,namespaceURI,qualifiedItem)

#define IXMLDOMNamedNodeMap_nextNode(This,nextItem)	\
    (This)->lpVtbl -> nextNode(This,nextItem)

#define IXMLDOMNamedNodeMap_reset(This)	\
    (This)->lpVtbl -> reset(This)

#define IXMLDOMNamedNodeMap_get__newEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__newEnum(This,ppUnk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNamedNodeMap_getNamedItem_Proxy( 
    IXMLDOMNamedNodeMap * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ IXMLDOMNode **namedItem);


void __RPC_STUB IXMLDOMNamedNodeMap_getNamedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNamedNodeMap_setNamedItem_Proxy( 
    IXMLDOMNamedNodeMap * This,
    /* [in] */ IXMLDOMNode *newItem,
    /* [retval][out] */ IXMLDOMNode **nameItem);


void __RPC_STUB IXMLDOMNamedNodeMap_setNamedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNamedNodeMap_removeNamedItem_Proxy( 
    IXMLDOMNamedNodeMap * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ IXMLDOMNode **namedItem);


void __RPC_STUB IXMLDOMNamedNodeMap_removeNamedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNamedNodeMap_get_item_Proxy( 
    IXMLDOMNamedNodeMap * This,
    /* [in] */ long index,
    /* [retval][out] */ IXMLDOMNode **listItem);


void __RPC_STUB IXMLDOMNamedNodeMap_get_item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNamedNodeMap_get_length_Proxy( 
    IXMLDOMNamedNodeMap * This,
    /* [retval][out] */ long *listLength);


void __RPC_STUB IXMLDOMNamedNodeMap_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNamedNodeMap_getQualifiedItem_Proxy( 
    IXMLDOMNamedNodeMap * This,
    /* [in] */ BSTR baseName,
    /* [in] */ BSTR namespaceURI,
    /* [retval][out] */ IXMLDOMNode **qualifiedItem);


void __RPC_STUB IXMLDOMNamedNodeMap_getQualifiedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNamedNodeMap_removeQualifiedItem_Proxy( 
    IXMLDOMNamedNodeMap * This,
    /* [in] */ BSTR baseName,
    /* [in] */ BSTR namespaceURI,
    /* [retval][out] */ IXMLDOMNode **qualifiedItem);


void __RPC_STUB IXMLDOMNamedNodeMap_removeQualifiedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNamedNodeMap_nextNode_Proxy( 
    IXMLDOMNamedNodeMap * This,
    /* [retval][out] */ IXMLDOMNode **nextItem);


void __RPC_STUB IXMLDOMNamedNodeMap_nextNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMNamedNodeMap_reset_Proxy( 
    IXMLDOMNamedNodeMap * This);


void __RPC_STUB IXMLDOMNamedNodeMap_reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNamedNodeMap_get__newEnum_Proxy( 
    IXMLDOMNamedNodeMap * This,
    /* [out][retval] */ IUnknown **ppUnk);


void __RPC_STUB IXMLDOMNamedNodeMap_get__newEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMNamedNodeMap_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMCharacterData_INTERFACE_DEFINED__
#define __IXMLDOMCharacterData_INTERFACE_DEFINED__

/* interface IXMLDOMCharacterData */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMCharacterData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF84-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMCharacterData : public IXMLDOMNode
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_data( 
            /* [retval][out] */ BSTR *data) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_data( 
            /* [in] */ BSTR data) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ long *dataLength) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE substringData( 
            /* [in] */ long offset,
            /* [in] */ long count,
            /* [retval][out] */ BSTR *data) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE appendData( 
            /* [in] */ BSTR data) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE insertData( 
            /* [in] */ long offset,
            /* [in] */ BSTR data) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE deleteData( 
            /* [in] */ long offset,
            /* [in] */ long count) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE replaceData( 
            /* [in] */ long offset,
            /* [in] */ long count,
            /* [in] */ BSTR data) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMCharacterDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMCharacterData * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMCharacterData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMCharacterData * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMCharacterData * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMCharacterData * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMCharacterData * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMCharacterData * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeName )( 
            IXMLDOMCharacterData * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeValue )( 
            IXMLDOMCharacterData * This,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeValue )( 
            IXMLDOMCharacterData * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeType )( 
            IXMLDOMCharacterData * This,
            /* [retval][out] */ DOMNodeType *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parentNode )( 
            IXMLDOMCharacterData * This,
            /* [retval][out] */ IXMLDOMNode **parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_childNodes )( 
            IXMLDOMCharacterData * This,
            /* [retval][out] */ IXMLDOMNodeList **childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_firstChild )( 
            IXMLDOMCharacterData * This,
            /* [retval][out] */ IXMLDOMNode **firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastChild )( 
            IXMLDOMCharacterData * This,
            /* [retval][out] */ IXMLDOMNode **lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_previousSibling )( 
            IXMLDOMCharacterData * This,
            /* [retval][out] */ IXMLDOMNode **previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nextSibling )( 
            IXMLDOMCharacterData * This,
            /* [retval][out] */ IXMLDOMNode **nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            IXMLDOMCharacterData * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertBefore )( 
            IXMLDOMCharacterData * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceChild )( 
            IXMLDOMCharacterData * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ IXMLDOMNode *oldChild,
            /* [retval][out] */ IXMLDOMNode **outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IXMLDOMCharacterData * This,
            /* [in] */ IXMLDOMNode *childNode,
            /* [retval][out] */ IXMLDOMNode **oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendChild )( 
            IXMLDOMCharacterData * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *hasChildNodes )( 
            IXMLDOMCharacterData * This,
            /* [retval][out] */ VARIANT_BOOL *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ownerDocument )( 
            IXMLDOMCharacterData * This,
            /* [retval][out] */ IXMLDOMDocument **DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *cloneNode )( 
            IXMLDOMCharacterData * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode **cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypeString )( 
            IXMLDOMCharacterData * This,
            /* [out][retval] */ BSTR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IXMLDOMCharacterData * This,
            /* [out][retval] */ BSTR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IXMLDOMCharacterData * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_specified )( 
            IXMLDOMCharacterData * This,
            /* [retval][out] */ VARIANT_BOOL *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_definition )( 
            IXMLDOMCharacterData * This,
            /* [out][retval] */ IXMLDOMNode **definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypedValue )( 
            IXMLDOMCharacterData * This,
            /* [out][retval] */ VARIANT *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeTypedValue )( 
            IXMLDOMCharacterData * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataType )( 
            IXMLDOMCharacterData * This,
            /* [out][retval] */ VARIANT *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dataType )( 
            IXMLDOMCharacterData * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_xml )( 
            IXMLDOMCharacterData * This,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNode )( 
            IXMLDOMCharacterData * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectNodes )( 
            IXMLDOMCharacterData * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectSingleNode )( 
            IXMLDOMCharacterData * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode **resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parsed )( 
            IXMLDOMCharacterData * This,
            /* [out][retval] */ VARIANT_BOOL *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            IXMLDOMCharacterData * This,
            /* [out][retval] */ BSTR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_prefix )( 
            IXMLDOMCharacterData * This,
            /* [out][retval] */ BSTR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseName )( 
            IXMLDOMCharacterData * This,
            /* [out][retval] */ BSTR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNodeToObject )( 
            IXMLDOMCharacterData * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_data )( 
            IXMLDOMCharacterData * This,
            /* [retval][out] */ BSTR *data);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_data )( 
            IXMLDOMCharacterData * This,
            /* [in] */ BSTR data);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IXMLDOMCharacterData * This,
            /* [retval][out] */ long *dataLength);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *substringData )( 
            IXMLDOMCharacterData * This,
            /* [in] */ long offset,
            /* [in] */ long count,
            /* [retval][out] */ BSTR *data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendData )( 
            IXMLDOMCharacterData * This,
            /* [in] */ BSTR data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertData )( 
            IXMLDOMCharacterData * This,
            /* [in] */ long offset,
            /* [in] */ BSTR data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *deleteData )( 
            IXMLDOMCharacterData * This,
            /* [in] */ long offset,
            /* [in] */ long count);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceData )( 
            IXMLDOMCharacterData * This,
            /* [in] */ long offset,
            /* [in] */ long count,
            /* [in] */ BSTR data);
        
        END_INTERFACE
    } IXMLDOMCharacterDataVtbl;

    interface IXMLDOMCharacterData
    {
        CONST_VTBL struct IXMLDOMCharacterDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMCharacterData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMCharacterData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMCharacterData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMCharacterData_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMCharacterData_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMCharacterData_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMCharacterData_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMCharacterData_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMCharacterData_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMCharacterData_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMCharacterData_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMCharacterData_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMCharacterData_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMCharacterData_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMCharacterData_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMCharacterData_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMCharacterData_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMCharacterData_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMCharacterData_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMCharacterData_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMCharacterData_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMCharacterData_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMCharacterData_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMCharacterData_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMCharacterData_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMCharacterData_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMCharacterData_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMCharacterData_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMCharacterData_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMCharacterData_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMCharacterData_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMCharacterData_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMCharacterData_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMCharacterData_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMCharacterData_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMCharacterData_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMCharacterData_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMCharacterData_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMCharacterData_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMCharacterData_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMCharacterData_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMCharacterData_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMCharacterData_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMCharacterData_get_data(This,data)	\
    (This)->lpVtbl -> get_data(This,data)

#define IXMLDOMCharacterData_put_data(This,data)	\
    (This)->lpVtbl -> put_data(This,data)

#define IXMLDOMCharacterData_get_length(This,dataLength)	\
    (This)->lpVtbl -> get_length(This,dataLength)

#define IXMLDOMCharacterData_substringData(This,offset,count,data)	\
    (This)->lpVtbl -> substringData(This,offset,count,data)

#define IXMLDOMCharacterData_appendData(This,data)	\
    (This)->lpVtbl -> appendData(This,data)

#define IXMLDOMCharacterData_insertData(This,offset,data)	\
    (This)->lpVtbl -> insertData(This,offset,data)

#define IXMLDOMCharacterData_deleteData(This,offset,count)	\
    (This)->lpVtbl -> deleteData(This,offset,count)

#define IXMLDOMCharacterData_replaceData(This,offset,count,data)	\
    (This)->lpVtbl -> replaceData(This,offset,count,data)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMCharacterData_get_data_Proxy( 
    IXMLDOMCharacterData * This,
    /* [retval][out] */ BSTR *data);


void __RPC_STUB IXMLDOMCharacterData_get_data_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMCharacterData_put_data_Proxy( 
    IXMLDOMCharacterData * This,
    /* [in] */ BSTR data);


void __RPC_STUB IXMLDOMCharacterData_put_data_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMCharacterData_get_length_Proxy( 
    IXMLDOMCharacterData * This,
    /* [retval][out] */ long *dataLength);


void __RPC_STUB IXMLDOMCharacterData_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMCharacterData_substringData_Proxy( 
    IXMLDOMCharacterData * This,
    /* [in] */ long offset,
    /* [in] */ long count,
    /* [retval][out] */ BSTR *data);


void __RPC_STUB IXMLDOMCharacterData_substringData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMCharacterData_appendData_Proxy( 
    IXMLDOMCharacterData * This,
    /* [in] */ BSTR data);


void __RPC_STUB IXMLDOMCharacterData_appendData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMCharacterData_insertData_Proxy( 
    IXMLDOMCharacterData * This,
    /* [in] */ long offset,
    /* [in] */ BSTR data);


void __RPC_STUB IXMLDOMCharacterData_insertData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMCharacterData_deleteData_Proxy( 
    IXMLDOMCharacterData * This,
    /* [in] */ long offset,
    /* [in] */ long count);


void __RPC_STUB IXMLDOMCharacterData_deleteData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMCharacterData_replaceData_Proxy( 
    IXMLDOMCharacterData * This,
    /* [in] */ long offset,
    /* [in] */ long count,
    /* [in] */ BSTR data);


void __RPC_STUB IXMLDOMCharacterData_replaceData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMCharacterData_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMAttribute_INTERFACE_DEFINED__
#define __IXMLDOMAttribute_INTERFACE_DEFINED__

/* interface IXMLDOMAttribute */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMAttribute;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF85-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMAttribute : public IXMLDOMNode
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [retval][out] */ BSTR *attributeName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_value( 
            /* [retval][out] */ VARIANT *attributeValue) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_value( 
            /* [in] */ VARIANT attributeValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMAttributeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMAttribute * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMAttribute * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMAttribute * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMAttribute * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMAttribute * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMAttribute * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMAttribute * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeName )( 
            IXMLDOMAttribute * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeValue )( 
            IXMLDOMAttribute * This,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeValue )( 
            IXMLDOMAttribute * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeType )( 
            IXMLDOMAttribute * This,
            /* [retval][out] */ DOMNodeType *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parentNode )( 
            IXMLDOMAttribute * This,
            /* [retval][out] */ IXMLDOMNode **parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_childNodes )( 
            IXMLDOMAttribute * This,
            /* [retval][out] */ IXMLDOMNodeList **childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_firstChild )( 
            IXMLDOMAttribute * This,
            /* [retval][out] */ IXMLDOMNode **firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastChild )( 
            IXMLDOMAttribute * This,
            /* [retval][out] */ IXMLDOMNode **lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_previousSibling )( 
            IXMLDOMAttribute * This,
            /* [retval][out] */ IXMLDOMNode **previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nextSibling )( 
            IXMLDOMAttribute * This,
            /* [retval][out] */ IXMLDOMNode **nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            IXMLDOMAttribute * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertBefore )( 
            IXMLDOMAttribute * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceChild )( 
            IXMLDOMAttribute * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ IXMLDOMNode *oldChild,
            /* [retval][out] */ IXMLDOMNode **outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IXMLDOMAttribute * This,
            /* [in] */ IXMLDOMNode *childNode,
            /* [retval][out] */ IXMLDOMNode **oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendChild )( 
            IXMLDOMAttribute * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *hasChildNodes )( 
            IXMLDOMAttribute * This,
            /* [retval][out] */ VARIANT_BOOL *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ownerDocument )( 
            IXMLDOMAttribute * This,
            /* [retval][out] */ IXMLDOMDocument **DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *cloneNode )( 
            IXMLDOMAttribute * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode **cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypeString )( 
            IXMLDOMAttribute * This,
            /* [out][retval] */ BSTR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IXMLDOMAttribute * This,
            /* [out][retval] */ BSTR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IXMLDOMAttribute * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_specified )( 
            IXMLDOMAttribute * This,
            /* [retval][out] */ VARIANT_BOOL *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_definition )( 
            IXMLDOMAttribute * This,
            /* [out][retval] */ IXMLDOMNode **definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypedValue )( 
            IXMLDOMAttribute * This,
            /* [out][retval] */ VARIANT *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeTypedValue )( 
            IXMLDOMAttribute * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataType )( 
            IXMLDOMAttribute * This,
            /* [out][retval] */ VARIANT *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dataType )( 
            IXMLDOMAttribute * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_xml )( 
            IXMLDOMAttribute * This,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNode )( 
            IXMLDOMAttribute * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectNodes )( 
            IXMLDOMAttribute * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectSingleNode )( 
            IXMLDOMAttribute * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode **resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parsed )( 
            IXMLDOMAttribute * This,
            /* [out][retval] */ VARIANT_BOOL *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            IXMLDOMAttribute * This,
            /* [out][retval] */ BSTR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_prefix )( 
            IXMLDOMAttribute * This,
            /* [out][retval] */ BSTR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseName )( 
            IXMLDOMAttribute * This,
            /* [out][retval] */ BSTR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNodeToObject )( 
            IXMLDOMAttribute * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
            IXMLDOMAttribute * This,
            /* [retval][out] */ BSTR *attributeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_value )( 
            IXMLDOMAttribute * This,
            /* [retval][out] */ VARIANT *attributeValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_value )( 
            IXMLDOMAttribute * This,
            /* [in] */ VARIANT attributeValue);
        
        END_INTERFACE
    } IXMLDOMAttributeVtbl;

    interface IXMLDOMAttribute
    {
        CONST_VTBL struct IXMLDOMAttributeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMAttribute_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMAttribute_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMAttribute_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMAttribute_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMAttribute_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMAttribute_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMAttribute_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMAttribute_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMAttribute_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMAttribute_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMAttribute_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMAttribute_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMAttribute_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMAttribute_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMAttribute_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMAttribute_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMAttribute_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMAttribute_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMAttribute_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMAttribute_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMAttribute_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMAttribute_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMAttribute_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMAttribute_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMAttribute_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMAttribute_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMAttribute_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMAttribute_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMAttribute_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMAttribute_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMAttribute_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMAttribute_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMAttribute_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMAttribute_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMAttribute_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMAttribute_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMAttribute_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMAttribute_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMAttribute_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMAttribute_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMAttribute_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMAttribute_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMAttribute_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMAttribute_get_name(This,attributeName)	\
    (This)->lpVtbl -> get_name(This,attributeName)

#define IXMLDOMAttribute_get_value(This,attributeValue)	\
    (This)->lpVtbl -> get_value(This,attributeValue)

#define IXMLDOMAttribute_put_value(This,attributeValue)	\
    (This)->lpVtbl -> put_value(This,attributeValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMAttribute_get_name_Proxy( 
    IXMLDOMAttribute * This,
    /* [retval][out] */ BSTR *attributeName);


void __RPC_STUB IXMLDOMAttribute_get_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMAttribute_get_value_Proxy( 
    IXMLDOMAttribute * This,
    /* [retval][out] */ VARIANT *attributeValue);


void __RPC_STUB IXMLDOMAttribute_get_value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMAttribute_put_value_Proxy( 
    IXMLDOMAttribute * This,
    /* [in] */ VARIANT attributeValue);


void __RPC_STUB IXMLDOMAttribute_put_value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMAttribute_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMElement_INTERFACE_DEFINED__
#define __IXMLDOMElement_INTERFACE_DEFINED__

/* interface IXMLDOMElement */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF86-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMElement : public IXMLDOMNode
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_tagName( 
            /* [retval][out] */ BSTR *tagName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getAttribute( 
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT *value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setAttribute( 
            /* [in] */ BSTR name,
            /* [in] */ VARIANT value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeAttribute( 
            /* [in] */ BSTR name) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getAttributeNode( 
            /* [in] */ BSTR name,
            /* [retval][out] */ IXMLDOMAttribute **attributeNode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setAttributeNode( 
            /* [in] */ IXMLDOMAttribute *DOMAttribute,
            /* [retval][out] */ IXMLDOMAttribute **attributeNode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeAttributeNode( 
            /* [in] */ IXMLDOMAttribute *DOMAttribute,
            /* [retval][out] */ IXMLDOMAttribute **attributeNode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getElementsByTagName( 
            /* [in] */ BSTR tagName,
            /* [retval][out] */ IXMLDOMNodeList **resultList) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE normalize( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMElement * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMElement * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMElement * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMElement * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMElement * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMElement * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMElement * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeName )( 
            IXMLDOMElement * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeValue )( 
            IXMLDOMElement * This,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeValue )( 
            IXMLDOMElement * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeType )( 
            IXMLDOMElement * This,
            /* [retval][out] */ DOMNodeType *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parentNode )( 
            IXMLDOMElement * This,
            /* [retval][out] */ IXMLDOMNode **parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_childNodes )( 
            IXMLDOMElement * This,
            /* [retval][out] */ IXMLDOMNodeList **childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_firstChild )( 
            IXMLDOMElement * This,
            /* [retval][out] */ IXMLDOMNode **firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastChild )( 
            IXMLDOMElement * This,
            /* [retval][out] */ IXMLDOMNode **lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_previousSibling )( 
            IXMLDOMElement * This,
            /* [retval][out] */ IXMLDOMNode **previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nextSibling )( 
            IXMLDOMElement * This,
            /* [retval][out] */ IXMLDOMNode **nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            IXMLDOMElement * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertBefore )( 
            IXMLDOMElement * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceChild )( 
            IXMLDOMElement * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ IXMLDOMNode *oldChild,
            /* [retval][out] */ IXMLDOMNode **outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IXMLDOMElement * This,
            /* [in] */ IXMLDOMNode *childNode,
            /* [retval][out] */ IXMLDOMNode **oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendChild )( 
            IXMLDOMElement * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *hasChildNodes )( 
            IXMLDOMElement * This,
            /* [retval][out] */ VARIANT_BOOL *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ownerDocument )( 
            IXMLDOMElement * This,
            /* [retval][out] */ IXMLDOMDocument **DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *cloneNode )( 
            IXMLDOMElement * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode **cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypeString )( 
            IXMLDOMElement * This,
            /* [out][retval] */ BSTR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IXMLDOMElement * This,
            /* [out][retval] */ BSTR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IXMLDOMElement * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_specified )( 
            IXMLDOMElement * This,
            /* [retval][out] */ VARIANT_BOOL *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_definition )( 
            IXMLDOMElement * This,
            /* [out][retval] */ IXMLDOMNode **definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypedValue )( 
            IXMLDOMElement * This,
            /* [out][retval] */ VARIANT *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeTypedValue )( 
            IXMLDOMElement * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataType )( 
            IXMLDOMElement * This,
            /* [out][retval] */ VARIANT *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dataType )( 
            IXMLDOMElement * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_xml )( 
            IXMLDOMElement * This,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNode )( 
            IXMLDOMElement * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectNodes )( 
            IXMLDOMElement * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectSingleNode )( 
            IXMLDOMElement * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode **resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parsed )( 
            IXMLDOMElement * This,
            /* [out][retval] */ VARIANT_BOOL *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            IXMLDOMElement * This,
            /* [out][retval] */ BSTR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_prefix )( 
            IXMLDOMElement * This,
            /* [out][retval] */ BSTR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseName )( 
            IXMLDOMElement * This,
            /* [out][retval] */ BSTR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNodeToObject )( 
            IXMLDOMElement * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_tagName )( 
            IXMLDOMElement * This,
            /* [retval][out] */ BSTR *tagName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getAttribute )( 
            IXMLDOMElement * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setAttribute )( 
            IXMLDOMElement * This,
            /* [in] */ BSTR name,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeAttribute )( 
            IXMLDOMElement * This,
            /* [in] */ BSTR name);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getAttributeNode )( 
            IXMLDOMElement * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ IXMLDOMAttribute **attributeNode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setAttributeNode )( 
            IXMLDOMElement * This,
            /* [in] */ IXMLDOMAttribute *DOMAttribute,
            /* [retval][out] */ IXMLDOMAttribute **attributeNode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeAttributeNode )( 
            IXMLDOMElement * This,
            /* [in] */ IXMLDOMAttribute *DOMAttribute,
            /* [retval][out] */ IXMLDOMAttribute **attributeNode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getElementsByTagName )( 
            IXMLDOMElement * This,
            /* [in] */ BSTR tagName,
            /* [retval][out] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *normalize )( 
            IXMLDOMElement * This);
        
        END_INTERFACE
    } IXMLDOMElementVtbl;

    interface IXMLDOMElement
    {
        CONST_VTBL struct IXMLDOMElementVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMElement_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMElement_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMElement_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMElement_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMElement_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMElement_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMElement_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMElement_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMElement_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMElement_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMElement_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMElement_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMElement_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMElement_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMElement_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMElement_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMElement_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMElement_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMElement_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMElement_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMElement_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMElement_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMElement_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMElement_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMElement_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMElement_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMElement_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMElement_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMElement_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMElement_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMElement_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMElement_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMElement_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMElement_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMElement_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMElement_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMElement_get_tagName(This,tagName)	\
    (This)->lpVtbl -> get_tagName(This,tagName)

#define IXMLDOMElement_getAttribute(This,name,value)	\
    (This)->lpVtbl -> getAttribute(This,name,value)

#define IXMLDOMElement_setAttribute(This,name,value)	\
    (This)->lpVtbl -> setAttribute(This,name,value)

#define IXMLDOMElement_removeAttribute(This,name)	\
    (This)->lpVtbl -> removeAttribute(This,name)

#define IXMLDOMElement_getAttributeNode(This,name,attributeNode)	\
    (This)->lpVtbl -> getAttributeNode(This,name,attributeNode)

#define IXMLDOMElement_setAttributeNode(This,DOMAttribute,attributeNode)	\
    (This)->lpVtbl -> setAttributeNode(This,DOMAttribute,attributeNode)

#define IXMLDOMElement_removeAttributeNode(This,DOMAttribute,attributeNode)	\
    (This)->lpVtbl -> removeAttributeNode(This,DOMAttribute,attributeNode)

#define IXMLDOMElement_getElementsByTagName(This,tagName,resultList)	\
    (This)->lpVtbl -> getElementsByTagName(This,tagName,resultList)

#define IXMLDOMElement_normalize(This)	\
    (This)->lpVtbl -> normalize(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMElement_get_tagName_Proxy( 
    IXMLDOMElement * This,
    /* [retval][out] */ BSTR *tagName);


void __RPC_STUB IXMLDOMElement_get_tagName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMElement_getAttribute_Proxy( 
    IXMLDOMElement * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ VARIANT *value);


void __RPC_STUB IXMLDOMElement_getAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMElement_setAttribute_Proxy( 
    IXMLDOMElement * This,
    /* [in] */ BSTR name,
    /* [in] */ VARIANT value);


void __RPC_STUB IXMLDOMElement_setAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMElement_removeAttribute_Proxy( 
    IXMLDOMElement * This,
    /* [in] */ BSTR name);


void __RPC_STUB IXMLDOMElement_removeAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMElement_getAttributeNode_Proxy( 
    IXMLDOMElement * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ IXMLDOMAttribute **attributeNode);


void __RPC_STUB IXMLDOMElement_getAttributeNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMElement_setAttributeNode_Proxy( 
    IXMLDOMElement * This,
    /* [in] */ IXMLDOMAttribute *DOMAttribute,
    /* [retval][out] */ IXMLDOMAttribute **attributeNode);


void __RPC_STUB IXMLDOMElement_setAttributeNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMElement_removeAttributeNode_Proxy( 
    IXMLDOMElement * This,
    /* [in] */ IXMLDOMAttribute *DOMAttribute,
    /* [retval][out] */ IXMLDOMAttribute **attributeNode);


void __RPC_STUB IXMLDOMElement_removeAttributeNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMElement_getElementsByTagName_Proxy( 
    IXMLDOMElement * This,
    /* [in] */ BSTR tagName,
    /* [retval][out] */ IXMLDOMNodeList **resultList);


void __RPC_STUB IXMLDOMElement_getElementsByTagName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMElement_normalize_Proxy( 
    IXMLDOMElement * This);


void __RPC_STUB IXMLDOMElement_normalize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMElement_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMText_INTERFACE_DEFINED__
#define __IXMLDOMText_INTERFACE_DEFINED__

/* interface IXMLDOMText */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMText;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF87-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMText : public IXMLDOMCharacterData
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE splitText( 
            /* [in] */ long offset,
            /* [retval][out] */ IXMLDOMText **rightHandTextNode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMTextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMText * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMText * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMText * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMText * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMText * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMText * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMText * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeName )( 
            IXMLDOMText * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeValue )( 
            IXMLDOMText * This,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeValue )( 
            IXMLDOMText * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeType )( 
            IXMLDOMText * This,
            /* [retval][out] */ DOMNodeType *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parentNode )( 
            IXMLDOMText * This,
            /* [retval][out] */ IXMLDOMNode **parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_childNodes )( 
            IXMLDOMText * This,
            /* [retval][out] */ IXMLDOMNodeList **childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_firstChild )( 
            IXMLDOMText * This,
            /* [retval][out] */ IXMLDOMNode **firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastChild )( 
            IXMLDOMText * This,
            /* [retval][out] */ IXMLDOMNode **lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_previousSibling )( 
            IXMLDOMText * This,
            /* [retval][out] */ IXMLDOMNode **previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nextSibling )( 
            IXMLDOMText * This,
            /* [retval][out] */ IXMLDOMNode **nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            IXMLDOMText * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertBefore )( 
            IXMLDOMText * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceChild )( 
            IXMLDOMText * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ IXMLDOMNode *oldChild,
            /* [retval][out] */ IXMLDOMNode **outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IXMLDOMText * This,
            /* [in] */ IXMLDOMNode *childNode,
            /* [retval][out] */ IXMLDOMNode **oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendChild )( 
            IXMLDOMText * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *hasChildNodes )( 
            IXMLDOMText * This,
            /* [retval][out] */ VARIANT_BOOL *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ownerDocument )( 
            IXMLDOMText * This,
            /* [retval][out] */ IXMLDOMDocument **DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *cloneNode )( 
            IXMLDOMText * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode **cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypeString )( 
            IXMLDOMText * This,
            /* [out][retval] */ BSTR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IXMLDOMText * This,
            /* [out][retval] */ BSTR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IXMLDOMText * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_specified )( 
            IXMLDOMText * This,
            /* [retval][out] */ VARIANT_BOOL *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_definition )( 
            IXMLDOMText * This,
            /* [out][retval] */ IXMLDOMNode **definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypedValue )( 
            IXMLDOMText * This,
            /* [out][retval] */ VARIANT *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeTypedValue )( 
            IXMLDOMText * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataType )( 
            IXMLDOMText * This,
            /* [out][retval] */ VARIANT *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dataType )( 
            IXMLDOMText * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_xml )( 
            IXMLDOMText * This,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNode )( 
            IXMLDOMText * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectNodes )( 
            IXMLDOMText * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectSingleNode )( 
            IXMLDOMText * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode **resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parsed )( 
            IXMLDOMText * This,
            /* [out][retval] */ VARIANT_BOOL *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            IXMLDOMText * This,
            /* [out][retval] */ BSTR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_prefix )( 
            IXMLDOMText * This,
            /* [out][retval] */ BSTR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseName )( 
            IXMLDOMText * This,
            /* [out][retval] */ BSTR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNodeToObject )( 
            IXMLDOMText * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_data )( 
            IXMLDOMText * This,
            /* [retval][out] */ BSTR *data);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_data )( 
            IXMLDOMText * This,
            /* [in] */ BSTR data);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IXMLDOMText * This,
            /* [retval][out] */ long *dataLength);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *substringData )( 
            IXMLDOMText * This,
            /* [in] */ long offset,
            /* [in] */ long count,
            /* [retval][out] */ BSTR *data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendData )( 
            IXMLDOMText * This,
            /* [in] */ BSTR data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertData )( 
            IXMLDOMText * This,
            /* [in] */ long offset,
            /* [in] */ BSTR data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *deleteData )( 
            IXMLDOMText * This,
            /* [in] */ long offset,
            /* [in] */ long count);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceData )( 
            IXMLDOMText * This,
            /* [in] */ long offset,
            /* [in] */ long count,
            /* [in] */ BSTR data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *splitText )( 
            IXMLDOMText * This,
            /* [in] */ long offset,
            /* [retval][out] */ IXMLDOMText **rightHandTextNode);
        
        END_INTERFACE
    } IXMLDOMTextVtbl;

    interface IXMLDOMText
    {
        CONST_VTBL struct IXMLDOMTextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMText_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMText_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMText_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMText_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMText_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMText_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMText_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMText_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMText_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMText_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMText_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMText_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMText_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMText_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMText_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMText_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMText_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMText_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMText_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMText_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMText_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMText_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMText_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMText_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMText_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMText_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMText_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMText_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMText_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMText_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMText_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMText_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMText_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMText_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMText_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMText_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMText_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMText_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMText_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMText_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMText_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMText_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMText_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMText_get_data(This,data)	\
    (This)->lpVtbl -> get_data(This,data)

#define IXMLDOMText_put_data(This,data)	\
    (This)->lpVtbl -> put_data(This,data)

#define IXMLDOMText_get_length(This,dataLength)	\
    (This)->lpVtbl -> get_length(This,dataLength)

#define IXMLDOMText_substringData(This,offset,count,data)	\
    (This)->lpVtbl -> substringData(This,offset,count,data)

#define IXMLDOMText_appendData(This,data)	\
    (This)->lpVtbl -> appendData(This,data)

#define IXMLDOMText_insertData(This,offset,data)	\
    (This)->lpVtbl -> insertData(This,offset,data)

#define IXMLDOMText_deleteData(This,offset,count)	\
    (This)->lpVtbl -> deleteData(This,offset,count)

#define IXMLDOMText_replaceData(This,offset,count,data)	\
    (This)->lpVtbl -> replaceData(This,offset,count,data)


#define IXMLDOMText_splitText(This,offset,rightHandTextNode)	\
    (This)->lpVtbl -> splitText(This,offset,rightHandTextNode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMText_splitText_Proxy( 
    IXMLDOMText * This,
    /* [in] */ long offset,
    /* [retval][out] */ IXMLDOMText **rightHandTextNode);


void __RPC_STUB IXMLDOMText_splitText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMText_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMComment_INTERFACE_DEFINED__
#define __IXMLDOMComment_INTERFACE_DEFINED__

/* interface IXMLDOMComment */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMComment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF88-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMComment : public IXMLDOMCharacterData
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMCommentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMComment * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMComment * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMComment * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMComment * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMComment * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMComment * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMComment * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeName )( 
            IXMLDOMComment * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeValue )( 
            IXMLDOMComment * This,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeValue )( 
            IXMLDOMComment * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeType )( 
            IXMLDOMComment * This,
            /* [retval][out] */ DOMNodeType *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parentNode )( 
            IXMLDOMComment * This,
            /* [retval][out] */ IXMLDOMNode **parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_childNodes )( 
            IXMLDOMComment * This,
            /* [retval][out] */ IXMLDOMNodeList **childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_firstChild )( 
            IXMLDOMComment * This,
            /* [retval][out] */ IXMLDOMNode **firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastChild )( 
            IXMLDOMComment * This,
            /* [retval][out] */ IXMLDOMNode **lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_previousSibling )( 
            IXMLDOMComment * This,
            /* [retval][out] */ IXMLDOMNode **previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nextSibling )( 
            IXMLDOMComment * This,
            /* [retval][out] */ IXMLDOMNode **nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            IXMLDOMComment * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertBefore )( 
            IXMLDOMComment * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceChild )( 
            IXMLDOMComment * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ IXMLDOMNode *oldChild,
            /* [retval][out] */ IXMLDOMNode **outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IXMLDOMComment * This,
            /* [in] */ IXMLDOMNode *childNode,
            /* [retval][out] */ IXMLDOMNode **oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendChild )( 
            IXMLDOMComment * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *hasChildNodes )( 
            IXMLDOMComment * This,
            /* [retval][out] */ VARIANT_BOOL *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ownerDocument )( 
            IXMLDOMComment * This,
            /* [retval][out] */ IXMLDOMDocument **DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *cloneNode )( 
            IXMLDOMComment * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode **cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypeString )( 
            IXMLDOMComment * This,
            /* [out][retval] */ BSTR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IXMLDOMComment * This,
            /* [out][retval] */ BSTR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IXMLDOMComment * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_specified )( 
            IXMLDOMComment * This,
            /* [retval][out] */ VARIANT_BOOL *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_definition )( 
            IXMLDOMComment * This,
            /* [out][retval] */ IXMLDOMNode **definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypedValue )( 
            IXMLDOMComment * This,
            /* [out][retval] */ VARIANT *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeTypedValue )( 
            IXMLDOMComment * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataType )( 
            IXMLDOMComment * This,
            /* [out][retval] */ VARIANT *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dataType )( 
            IXMLDOMComment * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_xml )( 
            IXMLDOMComment * This,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNode )( 
            IXMLDOMComment * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectNodes )( 
            IXMLDOMComment * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectSingleNode )( 
            IXMLDOMComment * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode **resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parsed )( 
            IXMLDOMComment * This,
            /* [out][retval] */ VARIANT_BOOL *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            IXMLDOMComment * This,
            /* [out][retval] */ BSTR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_prefix )( 
            IXMLDOMComment * This,
            /* [out][retval] */ BSTR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseName )( 
            IXMLDOMComment * This,
            /* [out][retval] */ BSTR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNodeToObject )( 
            IXMLDOMComment * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_data )( 
            IXMLDOMComment * This,
            /* [retval][out] */ BSTR *data);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_data )( 
            IXMLDOMComment * This,
            /* [in] */ BSTR data);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IXMLDOMComment * This,
            /* [retval][out] */ long *dataLength);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *substringData )( 
            IXMLDOMComment * This,
            /* [in] */ long offset,
            /* [in] */ long count,
            /* [retval][out] */ BSTR *data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendData )( 
            IXMLDOMComment * This,
            /* [in] */ BSTR data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertData )( 
            IXMLDOMComment * This,
            /* [in] */ long offset,
            /* [in] */ BSTR data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *deleteData )( 
            IXMLDOMComment * This,
            /* [in] */ long offset,
            /* [in] */ long count);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceData )( 
            IXMLDOMComment * This,
            /* [in] */ long offset,
            /* [in] */ long count,
            /* [in] */ BSTR data);
        
        END_INTERFACE
    } IXMLDOMCommentVtbl;

    interface IXMLDOMComment
    {
        CONST_VTBL struct IXMLDOMCommentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMComment_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMComment_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMComment_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMComment_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMComment_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMComment_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMComment_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMComment_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMComment_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMComment_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMComment_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMComment_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMComment_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMComment_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMComment_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMComment_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMComment_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMComment_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMComment_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMComment_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMComment_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMComment_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMComment_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMComment_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMComment_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMComment_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMComment_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMComment_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMComment_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMComment_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMComment_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMComment_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMComment_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMComment_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMComment_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMComment_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMComment_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMComment_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMComment_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMComment_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMComment_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMComment_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMComment_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMComment_get_data(This,data)	\
    (This)->lpVtbl -> get_data(This,data)

#define IXMLDOMComment_put_data(This,data)	\
    (This)->lpVtbl -> put_data(This,data)

#define IXMLDOMComment_get_length(This,dataLength)	\
    (This)->lpVtbl -> get_length(This,dataLength)

#define IXMLDOMComment_substringData(This,offset,count,data)	\
    (This)->lpVtbl -> substringData(This,offset,count,data)

#define IXMLDOMComment_appendData(This,data)	\
    (This)->lpVtbl -> appendData(This,data)

#define IXMLDOMComment_insertData(This,offset,data)	\
    (This)->lpVtbl -> insertData(This,offset,data)

#define IXMLDOMComment_deleteData(This,offset,count)	\
    (This)->lpVtbl -> deleteData(This,offset,count)

#define IXMLDOMComment_replaceData(This,offset,count,data)	\
    (This)->lpVtbl -> replaceData(This,offset,count,data)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXMLDOMComment_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMProcessingInstruction_INTERFACE_DEFINED__
#define __IXMLDOMProcessingInstruction_INTERFACE_DEFINED__

/* interface IXMLDOMProcessingInstruction */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMProcessingInstruction;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF89-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMProcessingInstruction : public IXMLDOMNode
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_target( 
            /* [retval][out] */ BSTR *name) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_data( 
            /* [retval][out] */ BSTR *value) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_data( 
            /* [in] */ BSTR value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMProcessingInstructionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMProcessingInstruction * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMProcessingInstruction * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMProcessingInstruction * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMProcessingInstruction * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMProcessingInstruction * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMProcessingInstruction * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMProcessingInstruction * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeName )( 
            IXMLDOMProcessingInstruction * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeValue )( 
            IXMLDOMProcessingInstruction * This,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeValue )( 
            IXMLDOMProcessingInstruction * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeType )( 
            IXMLDOMProcessingInstruction * This,
            /* [retval][out] */ DOMNodeType *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parentNode )( 
            IXMLDOMProcessingInstruction * This,
            /* [retval][out] */ IXMLDOMNode **parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_childNodes )( 
            IXMLDOMProcessingInstruction * This,
            /* [retval][out] */ IXMLDOMNodeList **childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_firstChild )( 
            IXMLDOMProcessingInstruction * This,
            /* [retval][out] */ IXMLDOMNode **firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastChild )( 
            IXMLDOMProcessingInstruction * This,
            /* [retval][out] */ IXMLDOMNode **lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_previousSibling )( 
            IXMLDOMProcessingInstruction * This,
            /* [retval][out] */ IXMLDOMNode **previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nextSibling )( 
            IXMLDOMProcessingInstruction * This,
            /* [retval][out] */ IXMLDOMNode **nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            IXMLDOMProcessingInstruction * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertBefore )( 
            IXMLDOMProcessingInstruction * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceChild )( 
            IXMLDOMProcessingInstruction * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ IXMLDOMNode *oldChild,
            /* [retval][out] */ IXMLDOMNode **outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IXMLDOMProcessingInstruction * This,
            /* [in] */ IXMLDOMNode *childNode,
            /* [retval][out] */ IXMLDOMNode **oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendChild )( 
            IXMLDOMProcessingInstruction * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *hasChildNodes )( 
            IXMLDOMProcessingInstruction * This,
            /* [retval][out] */ VARIANT_BOOL *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ownerDocument )( 
            IXMLDOMProcessingInstruction * This,
            /* [retval][out] */ IXMLDOMDocument **DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *cloneNode )( 
            IXMLDOMProcessingInstruction * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode **cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypeString )( 
            IXMLDOMProcessingInstruction * This,
            /* [out][retval] */ BSTR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IXMLDOMProcessingInstruction * This,
            /* [out][retval] */ BSTR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IXMLDOMProcessingInstruction * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_specified )( 
            IXMLDOMProcessingInstruction * This,
            /* [retval][out] */ VARIANT_BOOL *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_definition )( 
            IXMLDOMProcessingInstruction * This,
            /* [out][retval] */ IXMLDOMNode **definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypedValue )( 
            IXMLDOMProcessingInstruction * This,
            /* [out][retval] */ VARIANT *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeTypedValue )( 
            IXMLDOMProcessingInstruction * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataType )( 
            IXMLDOMProcessingInstruction * This,
            /* [out][retval] */ VARIANT *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dataType )( 
            IXMLDOMProcessingInstruction * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_xml )( 
            IXMLDOMProcessingInstruction * This,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNode )( 
            IXMLDOMProcessingInstruction * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectNodes )( 
            IXMLDOMProcessingInstruction * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectSingleNode )( 
            IXMLDOMProcessingInstruction * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode **resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parsed )( 
            IXMLDOMProcessingInstruction * This,
            /* [out][retval] */ VARIANT_BOOL *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            IXMLDOMProcessingInstruction * This,
            /* [out][retval] */ BSTR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_prefix )( 
            IXMLDOMProcessingInstruction * This,
            /* [out][retval] */ BSTR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseName )( 
            IXMLDOMProcessingInstruction * This,
            /* [out][retval] */ BSTR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNodeToObject )( 
            IXMLDOMProcessingInstruction * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_target )( 
            IXMLDOMProcessingInstruction * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_data )( 
            IXMLDOMProcessingInstruction * This,
            /* [retval][out] */ BSTR *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_data )( 
            IXMLDOMProcessingInstruction * This,
            /* [in] */ BSTR value);
        
        END_INTERFACE
    } IXMLDOMProcessingInstructionVtbl;

    interface IXMLDOMProcessingInstruction
    {
        CONST_VTBL struct IXMLDOMProcessingInstructionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMProcessingInstruction_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMProcessingInstruction_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMProcessingInstruction_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMProcessingInstruction_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMProcessingInstruction_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMProcessingInstruction_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMProcessingInstruction_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMProcessingInstruction_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMProcessingInstruction_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMProcessingInstruction_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMProcessingInstruction_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMProcessingInstruction_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMProcessingInstruction_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMProcessingInstruction_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMProcessingInstruction_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMProcessingInstruction_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMProcessingInstruction_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMProcessingInstruction_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMProcessingInstruction_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMProcessingInstruction_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMProcessingInstruction_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMProcessingInstruction_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMProcessingInstruction_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMProcessingInstruction_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMProcessingInstruction_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMProcessingInstruction_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMProcessingInstruction_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMProcessingInstruction_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMProcessingInstruction_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMProcessingInstruction_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMProcessingInstruction_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMProcessingInstruction_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMProcessingInstruction_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMProcessingInstruction_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMProcessingInstruction_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMProcessingInstruction_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMProcessingInstruction_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMProcessingInstruction_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMProcessingInstruction_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMProcessingInstruction_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMProcessingInstruction_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMProcessingInstruction_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMProcessingInstruction_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMProcessingInstruction_get_target(This,name)	\
    (This)->lpVtbl -> get_target(This,name)

#define IXMLDOMProcessingInstruction_get_data(This,value)	\
    (This)->lpVtbl -> get_data(This,value)

#define IXMLDOMProcessingInstruction_put_data(This,value)	\
    (This)->lpVtbl -> put_data(This,value)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMProcessingInstruction_get_target_Proxy( 
    IXMLDOMProcessingInstruction * This,
    /* [retval][out] */ BSTR *name);


void __RPC_STUB IXMLDOMProcessingInstruction_get_target_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMProcessingInstruction_get_data_Proxy( 
    IXMLDOMProcessingInstruction * This,
    /* [retval][out] */ BSTR *value);


void __RPC_STUB IXMLDOMProcessingInstruction_get_data_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMProcessingInstruction_put_data_Proxy( 
    IXMLDOMProcessingInstruction * This,
    /* [in] */ BSTR value);


void __RPC_STUB IXMLDOMProcessingInstruction_put_data_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMProcessingInstruction_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMCDATASection_INTERFACE_DEFINED__
#define __IXMLDOMCDATASection_INTERFACE_DEFINED__

/* interface IXMLDOMCDATASection */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMCDATASection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF8A-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMCDATASection : public IXMLDOMText
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMCDATASectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMCDATASection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMCDATASection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMCDATASection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMCDATASection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMCDATASection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMCDATASection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMCDATASection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeName )( 
            IXMLDOMCDATASection * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeValue )( 
            IXMLDOMCDATASection * This,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeValue )( 
            IXMLDOMCDATASection * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeType )( 
            IXMLDOMCDATASection * This,
            /* [retval][out] */ DOMNodeType *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parentNode )( 
            IXMLDOMCDATASection * This,
            /* [retval][out] */ IXMLDOMNode **parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_childNodes )( 
            IXMLDOMCDATASection * This,
            /* [retval][out] */ IXMLDOMNodeList **childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_firstChild )( 
            IXMLDOMCDATASection * This,
            /* [retval][out] */ IXMLDOMNode **firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastChild )( 
            IXMLDOMCDATASection * This,
            /* [retval][out] */ IXMLDOMNode **lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_previousSibling )( 
            IXMLDOMCDATASection * This,
            /* [retval][out] */ IXMLDOMNode **previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nextSibling )( 
            IXMLDOMCDATASection * This,
            /* [retval][out] */ IXMLDOMNode **nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            IXMLDOMCDATASection * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertBefore )( 
            IXMLDOMCDATASection * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceChild )( 
            IXMLDOMCDATASection * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ IXMLDOMNode *oldChild,
            /* [retval][out] */ IXMLDOMNode **outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IXMLDOMCDATASection * This,
            /* [in] */ IXMLDOMNode *childNode,
            /* [retval][out] */ IXMLDOMNode **oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendChild )( 
            IXMLDOMCDATASection * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *hasChildNodes )( 
            IXMLDOMCDATASection * This,
            /* [retval][out] */ VARIANT_BOOL *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ownerDocument )( 
            IXMLDOMCDATASection * This,
            /* [retval][out] */ IXMLDOMDocument **DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *cloneNode )( 
            IXMLDOMCDATASection * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode **cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypeString )( 
            IXMLDOMCDATASection * This,
            /* [out][retval] */ BSTR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IXMLDOMCDATASection * This,
            /* [out][retval] */ BSTR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IXMLDOMCDATASection * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_specified )( 
            IXMLDOMCDATASection * This,
            /* [retval][out] */ VARIANT_BOOL *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_definition )( 
            IXMLDOMCDATASection * This,
            /* [out][retval] */ IXMLDOMNode **definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypedValue )( 
            IXMLDOMCDATASection * This,
            /* [out][retval] */ VARIANT *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeTypedValue )( 
            IXMLDOMCDATASection * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataType )( 
            IXMLDOMCDATASection * This,
            /* [out][retval] */ VARIANT *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dataType )( 
            IXMLDOMCDATASection * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_xml )( 
            IXMLDOMCDATASection * This,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNode )( 
            IXMLDOMCDATASection * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectNodes )( 
            IXMLDOMCDATASection * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectSingleNode )( 
            IXMLDOMCDATASection * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode **resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parsed )( 
            IXMLDOMCDATASection * This,
            /* [out][retval] */ VARIANT_BOOL *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            IXMLDOMCDATASection * This,
            /* [out][retval] */ BSTR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_prefix )( 
            IXMLDOMCDATASection * This,
            /* [out][retval] */ BSTR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseName )( 
            IXMLDOMCDATASection * This,
            /* [out][retval] */ BSTR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNodeToObject )( 
            IXMLDOMCDATASection * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_data )( 
            IXMLDOMCDATASection * This,
            /* [retval][out] */ BSTR *data);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_data )( 
            IXMLDOMCDATASection * This,
            /* [in] */ BSTR data);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IXMLDOMCDATASection * This,
            /* [retval][out] */ long *dataLength);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *substringData )( 
            IXMLDOMCDATASection * This,
            /* [in] */ long offset,
            /* [in] */ long count,
            /* [retval][out] */ BSTR *data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendData )( 
            IXMLDOMCDATASection * This,
            /* [in] */ BSTR data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertData )( 
            IXMLDOMCDATASection * This,
            /* [in] */ long offset,
            /* [in] */ BSTR data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *deleteData )( 
            IXMLDOMCDATASection * This,
            /* [in] */ long offset,
            /* [in] */ long count);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceData )( 
            IXMLDOMCDATASection * This,
            /* [in] */ long offset,
            /* [in] */ long count,
            /* [in] */ BSTR data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *splitText )( 
            IXMLDOMCDATASection * This,
            /* [in] */ long offset,
            /* [retval][out] */ IXMLDOMText **rightHandTextNode);
        
        END_INTERFACE
    } IXMLDOMCDATASectionVtbl;

    interface IXMLDOMCDATASection
    {
        CONST_VTBL struct IXMLDOMCDATASectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMCDATASection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMCDATASection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMCDATASection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMCDATASection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMCDATASection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMCDATASection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMCDATASection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMCDATASection_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMCDATASection_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMCDATASection_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMCDATASection_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMCDATASection_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMCDATASection_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMCDATASection_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMCDATASection_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMCDATASection_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMCDATASection_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMCDATASection_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMCDATASection_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMCDATASection_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMCDATASection_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMCDATASection_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMCDATASection_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMCDATASection_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMCDATASection_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMCDATASection_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMCDATASection_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMCDATASection_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMCDATASection_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMCDATASection_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMCDATASection_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMCDATASection_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMCDATASection_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMCDATASection_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMCDATASection_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMCDATASection_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMCDATASection_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMCDATASection_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMCDATASection_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMCDATASection_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMCDATASection_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMCDATASection_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMCDATASection_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMCDATASection_get_data(This,data)	\
    (This)->lpVtbl -> get_data(This,data)

#define IXMLDOMCDATASection_put_data(This,data)	\
    (This)->lpVtbl -> put_data(This,data)

#define IXMLDOMCDATASection_get_length(This,dataLength)	\
    (This)->lpVtbl -> get_length(This,dataLength)

#define IXMLDOMCDATASection_substringData(This,offset,count,data)	\
    (This)->lpVtbl -> substringData(This,offset,count,data)

#define IXMLDOMCDATASection_appendData(This,data)	\
    (This)->lpVtbl -> appendData(This,data)

#define IXMLDOMCDATASection_insertData(This,offset,data)	\
    (This)->lpVtbl -> insertData(This,offset,data)

#define IXMLDOMCDATASection_deleteData(This,offset,count)	\
    (This)->lpVtbl -> deleteData(This,offset,count)

#define IXMLDOMCDATASection_replaceData(This,offset,count,data)	\
    (This)->lpVtbl -> replaceData(This,offset,count,data)


#define IXMLDOMCDATASection_splitText(This,offset,rightHandTextNode)	\
    (This)->lpVtbl -> splitText(This,offset,rightHandTextNode)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXMLDOMCDATASection_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMDocumentType_INTERFACE_DEFINED__
#define __IXMLDOMDocumentType_INTERFACE_DEFINED__

/* interface IXMLDOMDocumentType */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMDocumentType;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF8B-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMDocumentType : public IXMLDOMNode
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [retval][out] */ BSTR *rootName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_entities( 
            /* [retval][out] */ IXMLDOMNamedNodeMap **entityMap) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_notations( 
            /* [retval][out] */ IXMLDOMNamedNodeMap **notationMap) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMDocumentTypeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMDocumentType * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMDocumentType * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMDocumentType * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMDocumentType * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMDocumentType * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMDocumentType * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMDocumentType * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeName )( 
            IXMLDOMDocumentType * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeValue )( 
            IXMLDOMDocumentType * This,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeValue )( 
            IXMLDOMDocumentType * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeType )( 
            IXMLDOMDocumentType * This,
            /* [retval][out] */ DOMNodeType *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parentNode )( 
            IXMLDOMDocumentType * This,
            /* [retval][out] */ IXMLDOMNode **parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_childNodes )( 
            IXMLDOMDocumentType * This,
            /* [retval][out] */ IXMLDOMNodeList **childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_firstChild )( 
            IXMLDOMDocumentType * This,
            /* [retval][out] */ IXMLDOMNode **firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastChild )( 
            IXMLDOMDocumentType * This,
            /* [retval][out] */ IXMLDOMNode **lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_previousSibling )( 
            IXMLDOMDocumentType * This,
            /* [retval][out] */ IXMLDOMNode **previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nextSibling )( 
            IXMLDOMDocumentType * This,
            /* [retval][out] */ IXMLDOMNode **nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            IXMLDOMDocumentType * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertBefore )( 
            IXMLDOMDocumentType * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceChild )( 
            IXMLDOMDocumentType * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ IXMLDOMNode *oldChild,
            /* [retval][out] */ IXMLDOMNode **outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IXMLDOMDocumentType * This,
            /* [in] */ IXMLDOMNode *childNode,
            /* [retval][out] */ IXMLDOMNode **oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendChild )( 
            IXMLDOMDocumentType * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *hasChildNodes )( 
            IXMLDOMDocumentType * This,
            /* [retval][out] */ VARIANT_BOOL *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ownerDocument )( 
            IXMLDOMDocumentType * This,
            /* [retval][out] */ IXMLDOMDocument **DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *cloneNode )( 
            IXMLDOMDocumentType * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode **cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypeString )( 
            IXMLDOMDocumentType * This,
            /* [out][retval] */ BSTR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IXMLDOMDocumentType * This,
            /* [out][retval] */ BSTR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IXMLDOMDocumentType * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_specified )( 
            IXMLDOMDocumentType * This,
            /* [retval][out] */ VARIANT_BOOL *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_definition )( 
            IXMLDOMDocumentType * This,
            /* [out][retval] */ IXMLDOMNode **definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypedValue )( 
            IXMLDOMDocumentType * This,
            /* [out][retval] */ VARIANT *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeTypedValue )( 
            IXMLDOMDocumentType * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataType )( 
            IXMLDOMDocumentType * This,
            /* [out][retval] */ VARIANT *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dataType )( 
            IXMLDOMDocumentType * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_xml )( 
            IXMLDOMDocumentType * This,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNode )( 
            IXMLDOMDocumentType * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectNodes )( 
            IXMLDOMDocumentType * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectSingleNode )( 
            IXMLDOMDocumentType * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode **resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parsed )( 
            IXMLDOMDocumentType * This,
            /* [out][retval] */ VARIANT_BOOL *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            IXMLDOMDocumentType * This,
            /* [out][retval] */ BSTR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_prefix )( 
            IXMLDOMDocumentType * This,
            /* [out][retval] */ BSTR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseName )( 
            IXMLDOMDocumentType * This,
            /* [out][retval] */ BSTR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNodeToObject )( 
            IXMLDOMDocumentType * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
            IXMLDOMDocumentType * This,
            /* [retval][out] */ BSTR *rootName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_entities )( 
            IXMLDOMDocumentType * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **entityMap);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_notations )( 
            IXMLDOMDocumentType * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **notationMap);
        
        END_INTERFACE
    } IXMLDOMDocumentTypeVtbl;

    interface IXMLDOMDocumentType
    {
        CONST_VTBL struct IXMLDOMDocumentTypeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMDocumentType_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMDocumentType_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMDocumentType_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMDocumentType_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMDocumentType_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMDocumentType_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMDocumentType_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMDocumentType_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMDocumentType_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMDocumentType_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMDocumentType_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMDocumentType_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMDocumentType_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMDocumentType_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMDocumentType_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMDocumentType_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMDocumentType_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMDocumentType_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMDocumentType_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMDocumentType_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMDocumentType_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMDocumentType_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMDocumentType_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMDocumentType_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMDocumentType_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMDocumentType_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMDocumentType_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMDocumentType_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMDocumentType_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMDocumentType_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMDocumentType_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMDocumentType_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMDocumentType_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMDocumentType_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMDocumentType_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMDocumentType_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMDocumentType_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMDocumentType_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMDocumentType_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMDocumentType_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMDocumentType_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMDocumentType_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMDocumentType_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMDocumentType_get_name(This,rootName)	\
    (This)->lpVtbl -> get_name(This,rootName)

#define IXMLDOMDocumentType_get_entities(This,entityMap)	\
    (This)->lpVtbl -> get_entities(This,entityMap)

#define IXMLDOMDocumentType_get_notations(This,notationMap)	\
    (This)->lpVtbl -> get_notations(This,notationMap)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocumentType_get_name_Proxy( 
    IXMLDOMDocumentType * This,
    /* [retval][out] */ BSTR *rootName);


void __RPC_STUB IXMLDOMDocumentType_get_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocumentType_get_entities_Proxy( 
    IXMLDOMDocumentType * This,
    /* [retval][out] */ IXMLDOMNamedNodeMap **entityMap);


void __RPC_STUB IXMLDOMDocumentType_get_entities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocumentType_get_notations_Proxy( 
    IXMLDOMDocumentType * This,
    /* [retval][out] */ IXMLDOMNamedNodeMap **notationMap);


void __RPC_STUB IXMLDOMDocumentType_get_notations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMDocumentType_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMNotation_INTERFACE_DEFINED__
#define __IXMLDOMNotation_INTERFACE_DEFINED__

/* interface IXMLDOMNotation */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMNotation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF8C-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMNotation : public IXMLDOMNode
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_publicId( 
            /* [retval][out] */ VARIANT *publicID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_systemId( 
            /* [retval][out] */ VARIANT *systemID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMNotationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMNotation * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMNotation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMNotation * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMNotation * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMNotation * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMNotation * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMNotation * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeName )( 
            IXMLDOMNotation * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeValue )( 
            IXMLDOMNotation * This,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeValue )( 
            IXMLDOMNotation * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeType )( 
            IXMLDOMNotation * This,
            /* [retval][out] */ DOMNodeType *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parentNode )( 
            IXMLDOMNotation * This,
            /* [retval][out] */ IXMLDOMNode **parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_childNodes )( 
            IXMLDOMNotation * This,
            /* [retval][out] */ IXMLDOMNodeList **childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_firstChild )( 
            IXMLDOMNotation * This,
            /* [retval][out] */ IXMLDOMNode **firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastChild )( 
            IXMLDOMNotation * This,
            /* [retval][out] */ IXMLDOMNode **lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_previousSibling )( 
            IXMLDOMNotation * This,
            /* [retval][out] */ IXMLDOMNode **previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nextSibling )( 
            IXMLDOMNotation * This,
            /* [retval][out] */ IXMLDOMNode **nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            IXMLDOMNotation * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertBefore )( 
            IXMLDOMNotation * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceChild )( 
            IXMLDOMNotation * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ IXMLDOMNode *oldChild,
            /* [retval][out] */ IXMLDOMNode **outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IXMLDOMNotation * This,
            /* [in] */ IXMLDOMNode *childNode,
            /* [retval][out] */ IXMLDOMNode **oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendChild )( 
            IXMLDOMNotation * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *hasChildNodes )( 
            IXMLDOMNotation * This,
            /* [retval][out] */ VARIANT_BOOL *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ownerDocument )( 
            IXMLDOMNotation * This,
            /* [retval][out] */ IXMLDOMDocument **DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *cloneNode )( 
            IXMLDOMNotation * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode **cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypeString )( 
            IXMLDOMNotation * This,
            /* [out][retval] */ BSTR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IXMLDOMNotation * This,
            /* [out][retval] */ BSTR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IXMLDOMNotation * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_specified )( 
            IXMLDOMNotation * This,
            /* [retval][out] */ VARIANT_BOOL *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_definition )( 
            IXMLDOMNotation * This,
            /* [out][retval] */ IXMLDOMNode **definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypedValue )( 
            IXMLDOMNotation * This,
            /* [out][retval] */ VARIANT *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeTypedValue )( 
            IXMLDOMNotation * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataType )( 
            IXMLDOMNotation * This,
            /* [out][retval] */ VARIANT *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dataType )( 
            IXMLDOMNotation * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_xml )( 
            IXMLDOMNotation * This,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNode )( 
            IXMLDOMNotation * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectNodes )( 
            IXMLDOMNotation * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectSingleNode )( 
            IXMLDOMNotation * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode **resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parsed )( 
            IXMLDOMNotation * This,
            /* [out][retval] */ VARIANT_BOOL *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            IXMLDOMNotation * This,
            /* [out][retval] */ BSTR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_prefix )( 
            IXMLDOMNotation * This,
            /* [out][retval] */ BSTR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseName )( 
            IXMLDOMNotation * This,
            /* [out][retval] */ BSTR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNodeToObject )( 
            IXMLDOMNotation * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_publicId )( 
            IXMLDOMNotation * This,
            /* [retval][out] */ VARIANT *publicID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_systemId )( 
            IXMLDOMNotation * This,
            /* [retval][out] */ VARIANT *systemID);
        
        END_INTERFACE
    } IXMLDOMNotationVtbl;

    interface IXMLDOMNotation
    {
        CONST_VTBL struct IXMLDOMNotationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMNotation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMNotation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMNotation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMNotation_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMNotation_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMNotation_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMNotation_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMNotation_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMNotation_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMNotation_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMNotation_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMNotation_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMNotation_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMNotation_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMNotation_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMNotation_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMNotation_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMNotation_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMNotation_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMNotation_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMNotation_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMNotation_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMNotation_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMNotation_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMNotation_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMNotation_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMNotation_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMNotation_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMNotation_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMNotation_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMNotation_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMNotation_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMNotation_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMNotation_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMNotation_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMNotation_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMNotation_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMNotation_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMNotation_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMNotation_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMNotation_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMNotation_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMNotation_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMNotation_get_publicId(This,publicID)	\
    (This)->lpVtbl -> get_publicId(This,publicID)

#define IXMLDOMNotation_get_systemId(This,systemID)	\
    (This)->lpVtbl -> get_systemId(This,systemID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNotation_get_publicId_Proxy( 
    IXMLDOMNotation * This,
    /* [retval][out] */ VARIANT *publicID);


void __RPC_STUB IXMLDOMNotation_get_publicId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNotation_get_systemId_Proxy( 
    IXMLDOMNotation * This,
    /* [retval][out] */ VARIANT *systemID);


void __RPC_STUB IXMLDOMNotation_get_systemId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMNotation_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMEntity_INTERFACE_DEFINED__
#define __IXMLDOMEntity_INTERFACE_DEFINED__

/* interface IXMLDOMEntity */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMEntity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF8D-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMEntity : public IXMLDOMNode
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_publicId( 
            /* [retval][out] */ VARIANT *publicID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_systemId( 
            /* [retval][out] */ VARIANT *systemID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_notationName( 
            /* [retval][out] */ BSTR *name) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMEntityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMEntity * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMEntity * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMEntity * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMEntity * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMEntity * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMEntity * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMEntity * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeName )( 
            IXMLDOMEntity * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeValue )( 
            IXMLDOMEntity * This,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeValue )( 
            IXMLDOMEntity * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeType )( 
            IXMLDOMEntity * This,
            /* [retval][out] */ DOMNodeType *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parentNode )( 
            IXMLDOMEntity * This,
            /* [retval][out] */ IXMLDOMNode **parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_childNodes )( 
            IXMLDOMEntity * This,
            /* [retval][out] */ IXMLDOMNodeList **childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_firstChild )( 
            IXMLDOMEntity * This,
            /* [retval][out] */ IXMLDOMNode **firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastChild )( 
            IXMLDOMEntity * This,
            /* [retval][out] */ IXMLDOMNode **lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_previousSibling )( 
            IXMLDOMEntity * This,
            /* [retval][out] */ IXMLDOMNode **previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nextSibling )( 
            IXMLDOMEntity * This,
            /* [retval][out] */ IXMLDOMNode **nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            IXMLDOMEntity * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertBefore )( 
            IXMLDOMEntity * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceChild )( 
            IXMLDOMEntity * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ IXMLDOMNode *oldChild,
            /* [retval][out] */ IXMLDOMNode **outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IXMLDOMEntity * This,
            /* [in] */ IXMLDOMNode *childNode,
            /* [retval][out] */ IXMLDOMNode **oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendChild )( 
            IXMLDOMEntity * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *hasChildNodes )( 
            IXMLDOMEntity * This,
            /* [retval][out] */ VARIANT_BOOL *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ownerDocument )( 
            IXMLDOMEntity * This,
            /* [retval][out] */ IXMLDOMDocument **DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *cloneNode )( 
            IXMLDOMEntity * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode **cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypeString )( 
            IXMLDOMEntity * This,
            /* [out][retval] */ BSTR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IXMLDOMEntity * This,
            /* [out][retval] */ BSTR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IXMLDOMEntity * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_specified )( 
            IXMLDOMEntity * This,
            /* [retval][out] */ VARIANT_BOOL *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_definition )( 
            IXMLDOMEntity * This,
            /* [out][retval] */ IXMLDOMNode **definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypedValue )( 
            IXMLDOMEntity * This,
            /* [out][retval] */ VARIANT *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeTypedValue )( 
            IXMLDOMEntity * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataType )( 
            IXMLDOMEntity * This,
            /* [out][retval] */ VARIANT *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dataType )( 
            IXMLDOMEntity * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_xml )( 
            IXMLDOMEntity * This,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNode )( 
            IXMLDOMEntity * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectNodes )( 
            IXMLDOMEntity * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectSingleNode )( 
            IXMLDOMEntity * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode **resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parsed )( 
            IXMLDOMEntity * This,
            /* [out][retval] */ VARIANT_BOOL *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            IXMLDOMEntity * This,
            /* [out][retval] */ BSTR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_prefix )( 
            IXMLDOMEntity * This,
            /* [out][retval] */ BSTR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseName )( 
            IXMLDOMEntity * This,
            /* [out][retval] */ BSTR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNodeToObject )( 
            IXMLDOMEntity * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_publicId )( 
            IXMLDOMEntity * This,
            /* [retval][out] */ VARIANT *publicID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_systemId )( 
            IXMLDOMEntity * This,
            /* [retval][out] */ VARIANT *systemID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_notationName )( 
            IXMLDOMEntity * This,
            /* [retval][out] */ BSTR *name);
        
        END_INTERFACE
    } IXMLDOMEntityVtbl;

    interface IXMLDOMEntity
    {
        CONST_VTBL struct IXMLDOMEntityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMEntity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMEntity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMEntity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMEntity_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMEntity_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMEntity_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMEntity_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMEntity_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMEntity_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMEntity_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMEntity_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMEntity_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMEntity_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMEntity_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMEntity_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMEntity_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMEntity_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMEntity_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMEntity_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMEntity_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMEntity_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMEntity_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMEntity_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMEntity_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMEntity_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMEntity_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMEntity_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMEntity_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMEntity_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMEntity_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMEntity_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMEntity_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMEntity_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMEntity_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMEntity_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMEntity_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMEntity_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMEntity_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMEntity_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMEntity_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMEntity_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMEntity_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMEntity_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMEntity_get_publicId(This,publicID)	\
    (This)->lpVtbl -> get_publicId(This,publicID)

#define IXMLDOMEntity_get_systemId(This,systemID)	\
    (This)->lpVtbl -> get_systemId(This,systemID)

#define IXMLDOMEntity_get_notationName(This,name)	\
    (This)->lpVtbl -> get_notationName(This,name)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMEntity_get_publicId_Proxy( 
    IXMLDOMEntity * This,
    /* [retval][out] */ VARIANT *publicID);


void __RPC_STUB IXMLDOMEntity_get_publicId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMEntity_get_systemId_Proxy( 
    IXMLDOMEntity * This,
    /* [retval][out] */ VARIANT *systemID);


void __RPC_STUB IXMLDOMEntity_get_systemId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMEntity_get_notationName_Proxy( 
    IXMLDOMEntity * This,
    /* [retval][out] */ BSTR *name);


void __RPC_STUB IXMLDOMEntity_get_notationName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMEntity_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMEntityReference_INTERFACE_DEFINED__
#define __IXMLDOMEntityReference_INTERFACE_DEFINED__

/* interface IXMLDOMEntityReference */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMEntityReference;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF8E-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMEntityReference : public IXMLDOMNode
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMEntityReferenceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMEntityReference * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMEntityReference * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMEntityReference * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMEntityReference * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMEntityReference * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMEntityReference * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMEntityReference * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeName )( 
            IXMLDOMEntityReference * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeValue )( 
            IXMLDOMEntityReference * This,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeValue )( 
            IXMLDOMEntityReference * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeType )( 
            IXMLDOMEntityReference * This,
            /* [retval][out] */ DOMNodeType *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parentNode )( 
            IXMLDOMEntityReference * This,
            /* [retval][out] */ IXMLDOMNode **parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_childNodes )( 
            IXMLDOMEntityReference * This,
            /* [retval][out] */ IXMLDOMNodeList **childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_firstChild )( 
            IXMLDOMEntityReference * This,
            /* [retval][out] */ IXMLDOMNode **firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastChild )( 
            IXMLDOMEntityReference * This,
            /* [retval][out] */ IXMLDOMNode **lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_previousSibling )( 
            IXMLDOMEntityReference * This,
            /* [retval][out] */ IXMLDOMNode **previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nextSibling )( 
            IXMLDOMEntityReference * This,
            /* [retval][out] */ IXMLDOMNode **nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            IXMLDOMEntityReference * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertBefore )( 
            IXMLDOMEntityReference * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceChild )( 
            IXMLDOMEntityReference * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ IXMLDOMNode *oldChild,
            /* [retval][out] */ IXMLDOMNode **outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IXMLDOMEntityReference * This,
            /* [in] */ IXMLDOMNode *childNode,
            /* [retval][out] */ IXMLDOMNode **oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendChild )( 
            IXMLDOMEntityReference * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *hasChildNodes )( 
            IXMLDOMEntityReference * This,
            /* [retval][out] */ VARIANT_BOOL *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ownerDocument )( 
            IXMLDOMEntityReference * This,
            /* [retval][out] */ IXMLDOMDocument **DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *cloneNode )( 
            IXMLDOMEntityReference * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode **cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypeString )( 
            IXMLDOMEntityReference * This,
            /* [out][retval] */ BSTR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IXMLDOMEntityReference * This,
            /* [out][retval] */ BSTR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IXMLDOMEntityReference * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_specified )( 
            IXMLDOMEntityReference * This,
            /* [retval][out] */ VARIANT_BOOL *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_definition )( 
            IXMLDOMEntityReference * This,
            /* [out][retval] */ IXMLDOMNode **definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypedValue )( 
            IXMLDOMEntityReference * This,
            /* [out][retval] */ VARIANT *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeTypedValue )( 
            IXMLDOMEntityReference * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataType )( 
            IXMLDOMEntityReference * This,
            /* [out][retval] */ VARIANT *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dataType )( 
            IXMLDOMEntityReference * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_xml )( 
            IXMLDOMEntityReference * This,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNode )( 
            IXMLDOMEntityReference * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectNodes )( 
            IXMLDOMEntityReference * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectSingleNode )( 
            IXMLDOMEntityReference * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode **resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parsed )( 
            IXMLDOMEntityReference * This,
            /* [out][retval] */ VARIANT_BOOL *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            IXMLDOMEntityReference * This,
            /* [out][retval] */ BSTR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_prefix )( 
            IXMLDOMEntityReference * This,
            /* [out][retval] */ BSTR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseName )( 
            IXMLDOMEntityReference * This,
            /* [out][retval] */ BSTR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNodeToObject )( 
            IXMLDOMEntityReference * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        END_INTERFACE
    } IXMLDOMEntityReferenceVtbl;

    interface IXMLDOMEntityReference
    {
        CONST_VTBL struct IXMLDOMEntityReferenceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMEntityReference_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMEntityReference_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMEntityReference_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMEntityReference_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMEntityReference_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMEntityReference_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMEntityReference_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMEntityReference_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMEntityReference_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMEntityReference_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMEntityReference_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMEntityReference_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMEntityReference_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMEntityReference_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMEntityReference_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMEntityReference_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMEntityReference_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMEntityReference_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMEntityReference_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMEntityReference_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMEntityReference_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMEntityReference_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMEntityReference_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMEntityReference_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMEntityReference_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMEntityReference_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMEntityReference_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMEntityReference_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMEntityReference_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMEntityReference_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMEntityReference_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMEntityReference_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMEntityReference_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMEntityReference_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMEntityReference_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMEntityReference_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMEntityReference_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMEntityReference_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMEntityReference_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMEntityReference_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMEntityReference_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMEntityReference_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMEntityReference_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXMLDOMEntityReference_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMParseError_INTERFACE_DEFINED__
#define __IXMLDOMParseError_INTERFACE_DEFINED__

/* interface IXMLDOMParseError */
/* [unique][helpstring][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMParseError;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3efaa426-272f-11d2-836f-0000f87a7782")
    IXMLDOMParseError : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_errorCode( 
            /* [out][retval] */ long *errorCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_url( 
            /* [out][retval] */ BSTR *urlString) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_reason( 
            /* [out][retval] */ BSTR *reasonString) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_srcText( 
            /* [out][retval] */ BSTR *sourceString) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_line( 
            /* [out][retval] */ long *lineNumber) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_linepos( 
            /* [out][retval] */ long *linePosition) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_filepos( 
            /* [out][retval] */ long *filePosition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMParseErrorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMParseError * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMParseError * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMParseError * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMParseError * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMParseError * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMParseError * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMParseError * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_errorCode )( 
            IXMLDOMParseError * This,
            /* [out][retval] */ long *errorCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_url )( 
            IXMLDOMParseError * This,
            /* [out][retval] */ BSTR *urlString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_reason )( 
            IXMLDOMParseError * This,
            /* [out][retval] */ BSTR *reasonString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_srcText )( 
            IXMLDOMParseError * This,
            /* [out][retval] */ BSTR *sourceString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_line )( 
            IXMLDOMParseError * This,
            /* [out][retval] */ long *lineNumber);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_linepos )( 
            IXMLDOMParseError * This,
            /* [out][retval] */ long *linePosition);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_filepos )( 
            IXMLDOMParseError * This,
            /* [out][retval] */ long *filePosition);
        
        END_INTERFACE
    } IXMLDOMParseErrorVtbl;

    interface IXMLDOMParseError
    {
        CONST_VTBL struct IXMLDOMParseErrorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMParseError_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMParseError_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMParseError_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMParseError_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMParseError_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMParseError_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMParseError_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMParseError_get_errorCode(This,errorCode)	\
    (This)->lpVtbl -> get_errorCode(This,errorCode)

#define IXMLDOMParseError_get_url(This,urlString)	\
    (This)->lpVtbl -> get_url(This,urlString)

#define IXMLDOMParseError_get_reason(This,reasonString)	\
    (This)->lpVtbl -> get_reason(This,reasonString)

#define IXMLDOMParseError_get_srcText(This,sourceString)	\
    (This)->lpVtbl -> get_srcText(This,sourceString)

#define IXMLDOMParseError_get_line(This,lineNumber)	\
    (This)->lpVtbl -> get_line(This,lineNumber)

#define IXMLDOMParseError_get_linepos(This,linePosition)	\
    (This)->lpVtbl -> get_linepos(This,linePosition)

#define IXMLDOMParseError_get_filepos(This,filePosition)	\
    (This)->lpVtbl -> get_filepos(This,filePosition)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMParseError_get_errorCode_Proxy( 
    IXMLDOMParseError * This,
    /* [out][retval] */ long *errorCode);


void __RPC_STUB IXMLDOMParseError_get_errorCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMParseError_get_url_Proxy( 
    IXMLDOMParseError * This,
    /* [out][retval] */ BSTR *urlString);


void __RPC_STUB IXMLDOMParseError_get_url_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMParseError_get_reason_Proxy( 
    IXMLDOMParseError * This,
    /* [out][retval] */ BSTR *reasonString);


void __RPC_STUB IXMLDOMParseError_get_reason_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMParseError_get_srcText_Proxy( 
    IXMLDOMParseError * This,
    /* [out][retval] */ BSTR *sourceString);


void __RPC_STUB IXMLDOMParseError_get_srcText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMParseError_get_line_Proxy( 
    IXMLDOMParseError * This,
    /* [out][retval] */ long *lineNumber);


void __RPC_STUB IXMLDOMParseError_get_line_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMParseError_get_linepos_Proxy( 
    IXMLDOMParseError * This,
    /* [out][retval] */ long *linePosition);


void __RPC_STUB IXMLDOMParseError_get_linepos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMParseError_get_filepos_Proxy( 
    IXMLDOMParseError * This,
    /* [out][retval] */ long *filePosition);


void __RPC_STUB IXMLDOMParseError_get_filepos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMParseError_INTERFACE_DEFINED__ */


#ifndef __IXTLRuntime_INTERFACE_DEFINED__
#define __IXTLRuntime_INTERFACE_DEFINED__

/* interface IXTLRuntime */
/* [unique][helpstring][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXTLRuntime;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3efaa425-272f-11d2-836f-0000f87a7782")
    IXTLRuntime : public IXMLDOMNode
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE uniqueID( 
            /* [in] */ IXMLDOMNode *pNode,
            /* [retval][out] */ long *pID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE depth( 
            /* [in] */ IXMLDOMNode *pNode,
            /* [retval][out] */ long *pDepth) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE childNumber( 
            /* [in] */ IXMLDOMNode *pNode,
            /* [retval][out] */ long *pNumber) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ancestorChildNumber( 
            /* [in] */ BSTR bstrNodeName,
            /* [in] */ IXMLDOMNode *pNode,
            /* [retval][out] */ long *pNumber) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE absoluteChildNumber( 
            /* [in] */ IXMLDOMNode *pNode,
            /* [retval][out] */ long *pNumber) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE formatIndex( 
            /* [in] */ long lIndex,
            /* [in] */ BSTR bstrFormat,
            /* [retval][out] */ BSTR *pbstrFormattedString) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE formatNumber( 
            /* [in] */ double dblNumber,
            /* [in] */ BSTR bstrFormat,
            /* [retval][out] */ BSTR *pbstrFormattedString) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE formatDate( 
            /* [in] */ VARIANT varDate,
            /* [in] */ BSTR bstrFormat,
            /* [optional][in] */ VARIANT varDestLocale,
            /* [retval][out] */ BSTR *pbstrFormattedString) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE formatTime( 
            /* [in] */ VARIANT varTime,
            /* [in] */ BSTR bstrFormat,
            /* [optional][in] */ VARIANT varDestLocale,
            /* [retval][out] */ BSTR *pbstrFormattedString) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXTLRuntimeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXTLRuntime * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXTLRuntime * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXTLRuntime * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXTLRuntime * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXTLRuntime * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXTLRuntime * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXTLRuntime * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeName )( 
            IXTLRuntime * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeValue )( 
            IXTLRuntime * This,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeValue )( 
            IXTLRuntime * This,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeType )( 
            IXTLRuntime * This,
            /* [retval][out] */ DOMNodeType *type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parentNode )( 
            IXTLRuntime * This,
            /* [retval][out] */ IXMLDOMNode **parent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_childNodes )( 
            IXTLRuntime * This,
            /* [retval][out] */ IXMLDOMNodeList **childList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_firstChild )( 
            IXTLRuntime * This,
            /* [retval][out] */ IXMLDOMNode **firstChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lastChild )( 
            IXTLRuntime * This,
            /* [retval][out] */ IXMLDOMNode **lastChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_previousSibling )( 
            IXTLRuntime * This,
            /* [retval][out] */ IXMLDOMNode **previousSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nextSibling )( 
            IXTLRuntime * This,
            /* [retval][out] */ IXMLDOMNode **nextSibling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            IXTLRuntime * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap **attributeMap);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *insertBefore )( 
            IXTLRuntime * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *replaceChild )( 
            IXTLRuntime * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [in] */ IXMLDOMNode *oldChild,
            /* [retval][out] */ IXMLDOMNode **outOldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IXTLRuntime * This,
            /* [in] */ IXMLDOMNode *childNode,
            /* [retval][out] */ IXMLDOMNode **oldChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *appendChild )( 
            IXTLRuntime * This,
            /* [in] */ IXMLDOMNode *newChild,
            /* [retval][out] */ IXMLDOMNode **outNewChild);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *hasChildNodes )( 
            IXTLRuntime * This,
            /* [retval][out] */ VARIANT_BOOL *hasChild);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ownerDocument )( 
            IXTLRuntime * This,
            /* [retval][out] */ IXMLDOMDocument **DOMDocument);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *cloneNode )( 
            IXTLRuntime * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode **cloneRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypeString )( 
            IXTLRuntime * This,
            /* [out][retval] */ BSTR *nodeType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IXTLRuntime * This,
            /* [out][retval] */ BSTR *text);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IXTLRuntime * This,
            /* [in] */ BSTR text);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_specified )( 
            IXTLRuntime * This,
            /* [retval][out] */ VARIANT_BOOL *isSpecified);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_definition )( 
            IXTLRuntime * This,
            /* [out][retval] */ IXMLDOMNode **definitionNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_nodeTypedValue )( 
            IXTLRuntime * This,
            /* [out][retval] */ VARIANT *typedValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_nodeTypedValue )( 
            IXTLRuntime * This,
            /* [in] */ VARIANT typedValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dataType )( 
            IXTLRuntime * This,
            /* [out][retval] */ VARIANT *dataTypeName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_dataType )( 
            IXTLRuntime * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_xml )( 
            IXTLRuntime * This,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNode )( 
            IXTLRuntime * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [out][retval] */ BSTR *xmlString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectNodes )( 
            IXTLRuntime * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList **resultList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *selectSingleNode )( 
            IXTLRuntime * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode **resultNode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parsed )( 
            IXTLRuntime * This,
            /* [out][retval] */ VARIANT_BOOL *isParsed);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            IXTLRuntime * This,
            /* [out][retval] */ BSTR *namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_prefix )( 
            IXTLRuntime * This,
            /* [out][retval] */ BSTR *prefixString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseName )( 
            IXTLRuntime * This,
            /* [out][retval] */ BSTR *nameString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transformNodeToObject )( 
            IXTLRuntime * This,
            /* [in] */ IXMLDOMNode *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *uniqueID )( 
            IXTLRuntime * This,
            /* [in] */ IXMLDOMNode *pNode,
            /* [retval][out] */ long *pID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *depth )( 
            IXTLRuntime * This,
            /* [in] */ IXMLDOMNode *pNode,
            /* [retval][out] */ long *pDepth);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *childNumber )( 
            IXTLRuntime * This,
            /* [in] */ IXMLDOMNode *pNode,
            /* [retval][out] */ long *pNumber);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ancestorChildNumber )( 
            IXTLRuntime * This,
            /* [in] */ BSTR bstrNodeName,
            /* [in] */ IXMLDOMNode *pNode,
            /* [retval][out] */ long *pNumber);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *absoluteChildNumber )( 
            IXTLRuntime * This,
            /* [in] */ IXMLDOMNode *pNode,
            /* [retval][out] */ long *pNumber);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *formatIndex )( 
            IXTLRuntime * This,
            /* [in] */ long lIndex,
            /* [in] */ BSTR bstrFormat,
            /* [retval][out] */ BSTR *pbstrFormattedString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *formatNumber )( 
            IXTLRuntime * This,
            /* [in] */ double dblNumber,
            /* [in] */ BSTR bstrFormat,
            /* [retval][out] */ BSTR *pbstrFormattedString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *formatDate )( 
            IXTLRuntime * This,
            /* [in] */ VARIANT varDate,
            /* [in] */ BSTR bstrFormat,
            /* [optional][in] */ VARIANT varDestLocale,
            /* [retval][out] */ BSTR *pbstrFormattedString);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *formatTime )( 
            IXTLRuntime * This,
            /* [in] */ VARIANT varTime,
            /* [in] */ BSTR bstrFormat,
            /* [optional][in] */ VARIANT varDestLocale,
            /* [retval][out] */ BSTR *pbstrFormattedString);
        
        END_INTERFACE
    } IXTLRuntimeVtbl;

    interface IXTLRuntime
    {
        CONST_VTBL struct IXTLRuntimeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXTLRuntime_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXTLRuntime_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXTLRuntime_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXTLRuntime_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXTLRuntime_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXTLRuntime_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXTLRuntime_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXTLRuntime_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXTLRuntime_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXTLRuntime_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXTLRuntime_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXTLRuntime_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXTLRuntime_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXTLRuntime_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXTLRuntime_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXTLRuntime_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXTLRuntime_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXTLRuntime_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXTLRuntime_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXTLRuntime_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXTLRuntime_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXTLRuntime_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXTLRuntime_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXTLRuntime_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXTLRuntime_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXTLRuntime_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXTLRuntime_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXTLRuntime_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXTLRuntime_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXTLRuntime_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXTLRuntime_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXTLRuntime_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXTLRuntime_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXTLRuntime_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXTLRuntime_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXTLRuntime_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXTLRuntime_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXTLRuntime_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXTLRuntime_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXTLRuntime_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXTLRuntime_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXTLRuntime_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXTLRuntime_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXTLRuntime_uniqueID(This,pNode,pID)	\
    (This)->lpVtbl -> uniqueID(This,pNode,pID)

#define IXTLRuntime_depth(This,pNode,pDepth)	\
    (This)->lpVtbl -> depth(This,pNode,pDepth)

#define IXTLRuntime_childNumber(This,pNode,pNumber)	\
    (This)->lpVtbl -> childNumber(This,pNode,pNumber)

#define IXTLRuntime_ancestorChildNumber(This,bstrNodeName,pNode,pNumber)	\
    (This)->lpVtbl -> ancestorChildNumber(This,bstrNodeName,pNode,pNumber)

#define IXTLRuntime_absoluteChildNumber(This,pNode,pNumber)	\
    (This)->lpVtbl -> absoluteChildNumber(This,pNode,pNumber)

#define IXTLRuntime_formatIndex(This,lIndex,bstrFormat,pbstrFormattedString)	\
    (This)->lpVtbl -> formatIndex(This,lIndex,bstrFormat,pbstrFormattedString)

#define IXTLRuntime_formatNumber(This,dblNumber,bstrFormat,pbstrFormattedString)	\
    (This)->lpVtbl -> formatNumber(This,dblNumber,bstrFormat,pbstrFormattedString)

#define IXTLRuntime_formatDate(This,varDate,bstrFormat,varDestLocale,pbstrFormattedString)	\
    (This)->lpVtbl -> formatDate(This,varDate,bstrFormat,varDestLocale,pbstrFormattedString)

#define IXTLRuntime_formatTime(This,varTime,bstrFormat,varDestLocale,pbstrFormattedString)	\
    (This)->lpVtbl -> formatTime(This,varTime,bstrFormat,varDestLocale,pbstrFormattedString)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXTLRuntime_uniqueID_Proxy( 
    IXTLRuntime * This,
    /* [in] */ IXMLDOMNode *pNode,
    /* [retval][out] */ long *pID);


void __RPC_STUB IXTLRuntime_uniqueID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXTLRuntime_depth_Proxy( 
    IXTLRuntime * This,
    /* [in] */ IXMLDOMNode *pNode,
    /* [retval][out] */ long *pDepth);


void __RPC_STUB IXTLRuntime_depth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXTLRuntime_childNumber_Proxy( 
    IXTLRuntime * This,
    /* [in] */ IXMLDOMNode *pNode,
    /* [retval][out] */ long *pNumber);


void __RPC_STUB IXTLRuntime_childNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXTLRuntime_ancestorChildNumber_Proxy( 
    IXTLRuntime * This,
    /* [in] */ BSTR bstrNodeName,
    /* [in] */ IXMLDOMNode *pNode,
    /* [retval][out] */ long *pNumber);


void __RPC_STUB IXTLRuntime_ancestorChildNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXTLRuntime_absoluteChildNumber_Proxy( 
    IXTLRuntime * This,
    /* [in] */ IXMLDOMNode *pNode,
    /* [retval][out] */ long *pNumber);


void __RPC_STUB IXTLRuntime_absoluteChildNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXTLRuntime_formatIndex_Proxy( 
    IXTLRuntime * This,
    /* [in] */ long lIndex,
    /* [in] */ BSTR bstrFormat,
    /* [retval][out] */ BSTR *pbstrFormattedString);


void __RPC_STUB IXTLRuntime_formatIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXTLRuntime_formatNumber_Proxy( 
    IXTLRuntime * This,
    /* [in] */ double dblNumber,
    /* [in] */ BSTR bstrFormat,
    /* [retval][out] */ BSTR *pbstrFormattedString);


void __RPC_STUB IXTLRuntime_formatNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXTLRuntime_formatDate_Proxy( 
    IXTLRuntime * This,
    /* [in] */ VARIANT varDate,
    /* [in] */ BSTR bstrFormat,
    /* [optional][in] */ VARIANT varDestLocale,
    /* [retval][out] */ BSTR *pbstrFormattedString);


void __RPC_STUB IXTLRuntime_formatDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXTLRuntime_formatTime_Proxy( 
    IXTLRuntime * This,
    /* [in] */ VARIANT varTime,
    /* [in] */ BSTR bstrFormat,
    /* [optional][in] */ VARIANT varDestLocale,
    /* [retval][out] */ BSTR *pbstrFormattedString);


void __RPC_STUB IXTLRuntime_formatTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXTLRuntime_INTERFACE_DEFINED__ */


#ifndef __IXSLTemplate_INTERFACE_DEFINED__
#define __IXSLTemplate_INTERFACE_DEFINED__

/* interface IXSLTemplate */
/* [unique][helpstring][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXSLTemplate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF93-7B36-11d2-B20E-00C04F983E60")
    IXSLTemplate : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_stylesheet( 
            /* [in] */ IXMLDOMNode *stylesheet) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_stylesheet( 
            /* [retval][out] */ IXMLDOMNode **stylesheet) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE createProcessor( 
            /* [retval][out] */ IXSLProcessor **ppProcessor) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXSLTemplateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXSLTemplate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXSLTemplate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXSLTemplate * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXSLTemplate * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXSLTemplate * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXSLTemplate * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXSLTemplate * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE *putref_stylesheet )( 
            IXSLTemplate * This,
            /* [in] */ IXMLDOMNode *stylesheet);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_stylesheet )( 
            IXSLTemplate * This,
            /* [retval][out] */ IXMLDOMNode **stylesheet);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createProcessor )( 
            IXSLTemplate * This,
            /* [retval][out] */ IXSLProcessor **ppProcessor);
        
        END_INTERFACE
    } IXSLTemplateVtbl;

    interface IXSLTemplate
    {
        CONST_VTBL struct IXSLTemplateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXSLTemplate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXSLTemplate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXSLTemplate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXSLTemplate_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXSLTemplate_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXSLTemplate_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXSLTemplate_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXSLTemplate_putref_stylesheet(This,stylesheet)	\
    (This)->lpVtbl -> putref_stylesheet(This,stylesheet)

#define IXSLTemplate_get_stylesheet(This,stylesheet)	\
    (This)->lpVtbl -> get_stylesheet(This,stylesheet)

#define IXSLTemplate_createProcessor(This,ppProcessor)	\
    (This)->lpVtbl -> createProcessor(This,ppProcessor)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IXSLTemplate_putref_stylesheet_Proxy( 
    IXSLTemplate * This,
    /* [in] */ IXMLDOMNode *stylesheet);


void __RPC_STUB IXSLTemplate_putref_stylesheet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXSLTemplate_get_stylesheet_Proxy( 
    IXSLTemplate * This,
    /* [retval][out] */ IXMLDOMNode **stylesheet);


void __RPC_STUB IXSLTemplate_get_stylesheet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXSLTemplate_createProcessor_Proxy( 
    IXSLTemplate * This,
    /* [retval][out] */ IXSLProcessor **ppProcessor);


void __RPC_STUB IXSLTemplate_createProcessor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXSLTemplate_INTERFACE_DEFINED__ */


#ifndef __IXSLProcessor_INTERFACE_DEFINED__
#define __IXSLProcessor_INTERFACE_DEFINED__

/* interface IXSLProcessor */
/* [unique][helpstring][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXSLProcessor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF92-7B36-11d2-B20E-00C04F983E60")
    IXSLProcessor : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_input( 
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_input( 
            /* [retval][out] */ VARIANT *pVar) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ownerTemplate( 
            /* [retval][out] */ IXSLTemplate **ppTemplate) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setStartMode( 
            /* [in] */ BSTR mode,
            /* [defaultvalue][in] */ BSTR namespaceURI = L"") = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_startMode( 
            /* [retval][out] */ BSTR *mode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_startModeURI( 
            /* [retval][out] */ BSTR *namespaceURI) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_output( 
            /* [in] */ VARIANT output) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_output( 
            /* [retval][out] */ VARIANT *pOutput) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE transform( 
            /* [retval][out] */ VARIANT_BOOL *pDone) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE reset( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_readyState( 
            /* [retval][out] */ long *pReadyState) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE addParameter( 
            /* [in] */ BSTR baseName,
            /* [in] */ VARIANT parameter,
            /* [defaultvalue][in] */ BSTR namespaceURI = L"") = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE addObject( 
            /* [in] */ IDispatch *obj,
            /* [in] */ BSTR namespaceURI) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_stylesheet( 
            /* [retval][out] */ IXMLDOMNode **stylesheet) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXSLProcessorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXSLProcessor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXSLProcessor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXSLProcessor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXSLProcessor * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXSLProcessor * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXSLProcessor * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXSLProcessor * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_input )( 
            IXSLProcessor * This,
            /* [in] */ VARIANT var);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_input )( 
            IXSLProcessor * This,
            /* [retval][out] */ VARIANT *pVar);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ownerTemplate )( 
            IXSLProcessor * This,
            /* [retval][out] */ IXSLTemplate **ppTemplate);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setStartMode )( 
            IXSLProcessor * This,
            /* [in] */ BSTR mode,
            /* [defaultvalue][in] */ BSTR namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_startMode )( 
            IXSLProcessor * This,
            /* [retval][out] */ BSTR *mode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_startModeURI )( 
            IXSLProcessor * This,
            /* [retval][out] */ BSTR *namespaceURI);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_output )( 
            IXSLProcessor * This,
            /* [in] */ VARIANT output);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_output )( 
            IXSLProcessor * This,
            /* [retval][out] */ VARIANT *pOutput);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *transform )( 
            IXSLProcessor * This,
            /* [retval][out] */ VARIANT_BOOL *pDone);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *reset )( 
            IXSLProcessor * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_readyState )( 
            IXSLProcessor * This,
            /* [retval][out] */ long *pReadyState);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *addParameter )( 
            IXSLProcessor * This,
            /* [in] */ BSTR baseName,
            /* [in] */ VARIANT parameter,
            /* [defaultvalue][in] */ BSTR namespaceURI);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *addObject )( 
            IXSLProcessor * This,
            /* [in] */ IDispatch *obj,
            /* [in] */ BSTR namespaceURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_stylesheet )( 
            IXSLProcessor * This,
            /* [retval][out] */ IXMLDOMNode **stylesheet);
        
        END_INTERFACE
    } IXSLProcessorVtbl;

    interface IXSLProcessor
    {
        CONST_VTBL struct IXSLProcessorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXSLProcessor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXSLProcessor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXSLProcessor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXSLProcessor_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXSLProcessor_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXSLProcessor_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXSLProcessor_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXSLProcessor_put_input(This,var)	\
    (This)->lpVtbl -> put_input(This,var)

#define IXSLProcessor_get_input(This,pVar)	\
    (This)->lpVtbl -> get_input(This,pVar)

#define IXSLProcessor_get_ownerTemplate(This,ppTemplate)	\
    (This)->lpVtbl -> get_ownerTemplate(This,ppTemplate)

#define IXSLProcessor_setStartMode(This,mode,namespaceURI)	\
    (This)->lpVtbl -> setStartMode(This,mode,namespaceURI)

#define IXSLProcessor_get_startMode(This,mode)	\
    (This)->lpVtbl -> get_startMode(This,mode)

#define IXSLProcessor_get_startModeURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_startModeURI(This,namespaceURI)

#define IXSLProcessor_put_output(This,output)	\
    (This)->lpVtbl -> put_output(This,output)

#define IXSLProcessor_get_output(This,pOutput)	\
    (This)->lpVtbl -> get_output(This,pOutput)

#define IXSLProcessor_transform(This,pDone)	\
    (This)->lpVtbl -> transform(This,pDone)

#define IXSLProcessor_reset(This)	\
    (This)->lpVtbl -> reset(This)

#define IXSLProcessor_get_readyState(This,pReadyState)	\
    (This)->lpVtbl -> get_readyState(This,pReadyState)

#define IXSLProcessor_addParameter(This,baseName,parameter,namespaceURI)	\
    (This)->lpVtbl -> addParameter(This,baseName,parameter,namespaceURI)

#define IXSLProcessor_addObject(This,obj,namespaceURI)	\
    (This)->lpVtbl -> addObject(This,obj,namespaceURI)

#define IXSLProcessor_get_stylesheet(This,stylesheet)	\
    (This)->lpVtbl -> get_stylesheet(This,stylesheet)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_put_input_Proxy( 
    IXSLProcessor * This,
    /* [in] */ VARIANT var);


void __RPC_STUB IXSLProcessor_put_input_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_get_input_Proxy( 
    IXSLProcessor * This,
    /* [retval][out] */ VARIANT *pVar);


void __RPC_STUB IXSLProcessor_get_input_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_get_ownerTemplate_Proxy( 
    IXSLProcessor * This,
    /* [retval][out] */ IXSLTemplate **ppTemplate);


void __RPC_STUB IXSLProcessor_get_ownerTemplate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_setStartMode_Proxy( 
    IXSLProcessor * This,
    /* [in] */ BSTR mode,
    /* [defaultvalue][in] */ BSTR namespaceURI);


void __RPC_STUB IXSLProcessor_setStartMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_get_startMode_Proxy( 
    IXSLProcessor * This,
    /* [retval][out] */ BSTR *mode);


void __RPC_STUB IXSLProcessor_get_startMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_get_startModeURI_Proxy( 
    IXSLProcessor * This,
    /* [retval][out] */ BSTR *namespaceURI);


void __RPC_STUB IXSLProcessor_get_startModeURI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_put_output_Proxy( 
    IXSLProcessor * This,
    /* [in] */ VARIANT output);


void __RPC_STUB IXSLProcessor_put_output_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_get_output_Proxy( 
    IXSLProcessor * This,
    /* [retval][out] */ VARIANT *pOutput);


void __RPC_STUB IXSLProcessor_get_output_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_transform_Proxy( 
    IXSLProcessor * This,
    /* [retval][out] */ VARIANT_BOOL *pDone);


void __RPC_STUB IXSLProcessor_transform_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_reset_Proxy( 
    IXSLProcessor * This);


void __RPC_STUB IXSLProcessor_reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_get_readyState_Proxy( 
    IXSLProcessor * This,
    /* [retval][out] */ long *pReadyState);


void __RPC_STUB IXSLProcessor_get_readyState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_addParameter_Proxy( 
    IXSLProcessor * This,
    /* [in] */ BSTR baseName,
    /* [in] */ VARIANT parameter,
    /* [defaultvalue][in] */ BSTR namespaceURI);


void __RPC_STUB IXSLProcessor_addParameter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_addObject_Proxy( 
    IXSLProcessor * This,
    /* [in] */ IDispatch *obj,
    /* [in] */ BSTR namespaceURI);


void __RPC_STUB IXSLProcessor_addObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_get_stylesheet_Proxy( 
    IXSLProcessor * This,
    /* [retval][out] */ IXMLDOMNode **stylesheet);


void __RPC_STUB IXSLProcessor_get_stylesheet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXSLProcessor_INTERFACE_DEFINED__ */


#ifndef __ISAXXMLReader_INTERFACE_DEFINED__
#define __ISAXXMLReader_INTERFACE_DEFINED__

/* interface ISAXXMLReader */
/* [unique][helpstring][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_ISAXXMLReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a4f96ed0-f829-476e-81c0-cdc7bd2a0802")
    ISAXXMLReader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE getFeature( 
            /* [in] */ const wchar_t *pwchName,
            /* [retval][out] */ VARIANT_BOOL *pvfValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE putFeature( 
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ VARIANT_BOOL vfValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getProperty( 
            /* [in] */ const wchar_t *pwchName,
            /* [retval][out] */ VARIANT *pvarValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE putProperty( 
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ VARIANT varValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getEntityResolver( 
            /* [retval][out] */ ISAXEntityResolver **ppResolver) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE putEntityResolver( 
            /* [in] */ ISAXEntityResolver *pResolver) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getContentHandler( 
            /* [retval][out] */ ISAXContentHandler **ppHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE putContentHandler( 
            /* [in] */ ISAXContentHandler *pHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getDTDHandler( 
            /* [retval][out] */ ISAXDTDHandler **ppHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE putDTDHandler( 
            /* [in] */ ISAXDTDHandler *pHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getErrorHandler( 
            /* [retval][out] */ ISAXErrorHandler **ppHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE putErrorHandler( 
            /* [in] */ ISAXErrorHandler *pHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getBaseURL( 
            /* [retval][out] */ const wchar_t **ppwchBaseUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE putBaseURL( 
            /* [in] */ const wchar_t *pwchBaseUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getSecureBaseURL( 
            /* [retval][out] */ const wchar_t **ppwchSecureBaseUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE putSecureBaseURL( 
            /* [in] */ const wchar_t *pwchSecureBaseUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE parse( 
            /* [in] */ VARIANT varInput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE parseURL( 
            /* [in] */ const wchar_t *pwchUrl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAXXMLReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISAXXMLReader * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISAXXMLReader * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISAXXMLReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *getFeature )( 
            ISAXXMLReader * This,
            /* [in] */ const wchar_t *pwchName,
            /* [retval][out] */ VARIANT_BOOL *pvfValue);
        
        HRESULT ( STDMETHODCALLTYPE *putFeature )( 
            ISAXXMLReader * This,
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ VARIANT_BOOL vfValue);
        
        HRESULT ( STDMETHODCALLTYPE *getProperty )( 
            ISAXXMLReader * This,
            /* [in] */ const wchar_t *pwchName,
            /* [retval][out] */ VARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *putProperty )( 
            ISAXXMLReader * This,
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ VARIANT varValue);
        
        HRESULT ( STDMETHODCALLTYPE *getEntityResolver )( 
            ISAXXMLReader * This,
            /* [retval][out] */ ISAXEntityResolver **ppResolver);
        
        HRESULT ( STDMETHODCALLTYPE *putEntityResolver )( 
            ISAXXMLReader * This,
            /* [in] */ ISAXEntityResolver *pResolver);
        
        HRESULT ( STDMETHODCALLTYPE *getContentHandler )( 
            ISAXXMLReader * This,
            /* [retval][out] */ ISAXContentHandler **ppHandler);
        
        HRESULT ( STDMETHODCALLTYPE *putContentHandler )( 
            ISAXXMLReader * This,
            /* [in] */ ISAXContentHandler *pHandler);
        
        HRESULT ( STDMETHODCALLTYPE *getDTDHandler )( 
            ISAXXMLReader * This,
            /* [retval][out] */ ISAXDTDHandler **ppHandler);
        
        HRESULT ( STDMETHODCALLTYPE *putDTDHandler )( 
            ISAXXMLReader * This,
            /* [in] */ ISAXDTDHandler *pHandler);
        
        HRESULT ( STDMETHODCALLTYPE *getErrorHandler )( 
            ISAXXMLReader * This,
            /* [retval][out] */ ISAXErrorHandler **ppHandler);
        
        HRESULT ( STDMETHODCALLTYPE *putErrorHandler )( 
            ISAXXMLReader * This,
            /* [in] */ ISAXErrorHandler *pHandler);
        
        HRESULT ( STDMETHODCALLTYPE *getBaseURL )( 
            ISAXXMLReader * This,
            /* [retval][out] */ const wchar_t **ppwchBaseUrl);
        
        HRESULT ( STDMETHODCALLTYPE *putBaseURL )( 
            ISAXXMLReader * This,
            /* [in] */ const wchar_t *pwchBaseUrl);
        
        HRESULT ( STDMETHODCALLTYPE *getSecureBaseURL )( 
            ISAXXMLReader * This,
            /* [retval][out] */ const wchar_t **ppwchSecureBaseUrl);
        
        HRESULT ( STDMETHODCALLTYPE *putSecureBaseURL )( 
            ISAXXMLReader * This,
            /* [in] */ const wchar_t *pwchSecureBaseUrl);
        
        HRESULT ( STDMETHODCALLTYPE *parse )( 
            ISAXXMLReader * This,
            /* [in] */ VARIANT varInput);
        
        HRESULT ( STDMETHODCALLTYPE *parseURL )( 
            ISAXXMLReader * This,
            /* [in] */ const wchar_t *pwchUrl);
        
        END_INTERFACE
    } ISAXXMLReaderVtbl;

    interface ISAXXMLReader
    {
        CONST_VTBL struct ISAXXMLReaderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAXXMLReader_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAXXMLReader_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAXXMLReader_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAXXMLReader_getFeature(This,pwchName,pvfValue)	\
    (This)->lpVtbl -> getFeature(This,pwchName,pvfValue)

#define ISAXXMLReader_putFeature(This,pwchName,vfValue)	\
    (This)->lpVtbl -> putFeature(This,pwchName,vfValue)

#define ISAXXMLReader_getProperty(This,pwchName,pvarValue)	\
    (This)->lpVtbl -> getProperty(This,pwchName,pvarValue)

#define ISAXXMLReader_putProperty(This,pwchName,varValue)	\
    (This)->lpVtbl -> putProperty(This,pwchName,varValue)

#define ISAXXMLReader_getEntityResolver(This,ppResolver)	\
    (This)->lpVtbl -> getEntityResolver(This,ppResolver)

#define ISAXXMLReader_putEntityResolver(This,pResolver)	\
    (This)->lpVtbl -> putEntityResolver(This,pResolver)

#define ISAXXMLReader_getContentHandler(This,ppHandler)	\
    (This)->lpVtbl -> getContentHandler(This,ppHandler)

#define ISAXXMLReader_putContentHandler(This,pHandler)	\
    (This)->lpVtbl -> putContentHandler(This,pHandler)

#define ISAXXMLReader_getDTDHandler(This,ppHandler)	\
    (This)->lpVtbl -> getDTDHandler(This,ppHandler)

#define ISAXXMLReader_putDTDHandler(This,pHandler)	\
    (This)->lpVtbl -> putDTDHandler(This,pHandler)

#define ISAXXMLReader_getErrorHandler(This,ppHandler)	\
    (This)->lpVtbl -> getErrorHandler(This,ppHandler)

#define ISAXXMLReader_putErrorHandler(This,pHandler)	\
    (This)->lpVtbl -> putErrorHandler(This,pHandler)

#define ISAXXMLReader_getBaseURL(This,ppwchBaseUrl)	\
    (This)->lpVtbl -> getBaseURL(This,ppwchBaseUrl)

#define ISAXXMLReader_putBaseURL(This,pwchBaseUrl)	\
    (This)->lpVtbl -> putBaseURL(This,pwchBaseUrl)

#define ISAXXMLReader_getSecureBaseURL(This,ppwchSecureBaseUrl)	\
    (This)->lpVtbl -> getSecureBaseURL(This,ppwchSecureBaseUrl)

#define ISAXXMLReader_putSecureBaseURL(This,pwchSecureBaseUrl)	\
    (This)->lpVtbl -> putSecureBaseURL(This,pwchSecureBaseUrl)

#define ISAXXMLReader_parse(This,varInput)	\
    (This)->lpVtbl -> parse(This,varInput)

#define ISAXXMLReader_parseURL(This,pwchUrl)	\
    (This)->lpVtbl -> parseURL(This,pwchUrl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISAXXMLReader_getFeature_Proxy( 
    ISAXXMLReader * This,
    /* [in] */ const wchar_t *pwchName,
    /* [retval][out] */ VARIANT_BOOL *pvfValue);


void __RPC_STUB ISAXXMLReader_getFeature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_putFeature_Proxy( 
    ISAXXMLReader * This,
    /* [in] */ const wchar_t *pwchName,
    /* [in] */ VARIANT_BOOL vfValue);


void __RPC_STUB ISAXXMLReader_putFeature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_getProperty_Proxy( 
    ISAXXMLReader * This,
    /* [in] */ const wchar_t *pwchName,
    /* [retval][out] */ VARIANT *pvarValue);


void __RPC_STUB ISAXXMLReader_getProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_putProperty_Proxy( 
    ISAXXMLReader * This,
    /* [in] */ const wchar_t *pwchName,
    /* [in] */ VARIANT varValue);


void __RPC_STUB ISAXXMLReader_putProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_getEntityResolver_Proxy( 
    ISAXXMLReader * This,
    /* [retval][out] */ ISAXEntityResolver **ppResolver);


void __RPC_STUB ISAXXMLReader_getEntityResolver_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_putEntityResolver_Proxy( 
    ISAXXMLReader * This,
    /* [in] */ ISAXEntityResolver *pResolver);


void __RPC_STUB ISAXXMLReader_putEntityResolver_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_getContentHandler_Proxy( 
    ISAXXMLReader * This,
    /* [retval][out] */ ISAXContentHandler **ppHandler);


void __RPC_STUB ISAXXMLReader_getContentHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_putContentHandler_Proxy( 
    ISAXXMLReader * This,
    /* [in] */ ISAXContentHandler *pHandler);


void __RPC_STUB ISAXXMLReader_putContentHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_getDTDHandler_Proxy( 
    ISAXXMLReader * This,
    /* [retval][out] */ ISAXDTDHandler **ppHandler);


void __RPC_STUB ISAXXMLReader_getDTDHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_putDTDHandler_Proxy( 
    ISAXXMLReader * This,
    /* [in] */ ISAXDTDHandler *pHandler);


void __RPC_STUB ISAXXMLReader_putDTDHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_getErrorHandler_Proxy( 
    ISAXXMLReader * This,
    /* [retval][out] */ ISAXErrorHandler **ppHandler);


void __RPC_STUB ISAXXMLReader_getErrorHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_putErrorHandler_Proxy( 
    ISAXXMLReader * This,
    /* [in] */ ISAXErrorHandler *pHandler);


void __RPC_STUB ISAXXMLReader_putErrorHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_getBaseURL_Proxy( 
    ISAXXMLReader * This,
    /* [retval][out] */ const wchar_t **ppwchBaseUrl);


void __RPC_STUB ISAXXMLReader_getBaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_putBaseURL_Proxy( 
    ISAXXMLReader * This,
    /* [in] */ const wchar_t *pwchBaseUrl);


void __RPC_STUB ISAXXMLReader_putBaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_getSecureBaseURL_Proxy( 
    ISAXXMLReader * This,
    /* [retval][out] */ const wchar_t **ppwchSecureBaseUrl);


void __RPC_STUB ISAXXMLReader_getSecureBaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_putSecureBaseURL_Proxy( 
    ISAXXMLReader * This,
    /* [in] */ const wchar_t *pwchSecureBaseUrl);


void __RPC_STUB ISAXXMLReader_putSecureBaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_parse_Proxy( 
    ISAXXMLReader * This,
    /* [in] */ VARIANT varInput);


void __RPC_STUB ISAXXMLReader_parse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_parseURL_Proxy( 
    ISAXXMLReader * This,
    /* [in] */ const wchar_t *pwchUrl);


void __RPC_STUB ISAXXMLReader_parseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAXXMLReader_INTERFACE_DEFINED__ */


#ifndef __ISAXXMLFilter_INTERFACE_DEFINED__
#define __ISAXXMLFilter_INTERFACE_DEFINED__

/* interface ISAXXMLFilter */
/* [unique][helpstring][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_ISAXXMLFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("70409222-ca09-4475-acb8-40312fe8d145")
    ISAXXMLFilter : public ISAXXMLReader
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE getParent( 
            /* [retval][out] */ ISAXXMLReader **ppReader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE putParent( 
            /* [in] */ ISAXXMLReader *pReader) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAXXMLFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISAXXMLFilter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISAXXMLFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISAXXMLFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *getFeature )( 
            ISAXXMLFilter * This,
            /* [in] */ const wchar_t *pwchName,
            /* [retval][out] */ VARIANT_BOOL *pvfValue);
        
        HRESULT ( STDMETHODCALLTYPE *putFeature )( 
            ISAXXMLFilter * This,
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ VARIANT_BOOL vfValue);
        
        HRESULT ( STDMETHODCALLTYPE *getProperty )( 
            ISAXXMLFilter * This,
            /* [in] */ const wchar_t *pwchName,
            /* [retval][out] */ VARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *putProperty )( 
            ISAXXMLFilter * This,
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ VARIANT varValue);
        
        HRESULT ( STDMETHODCALLTYPE *getEntityResolver )( 
            ISAXXMLFilter * This,
            /* [retval][out] */ ISAXEntityResolver **ppResolver);
        
        HRESULT ( STDMETHODCALLTYPE *putEntityResolver )( 
            ISAXXMLFilter * This,
            /* [in] */ ISAXEntityResolver *pResolver);
        
        HRESULT ( STDMETHODCALLTYPE *getContentHandler )( 
            ISAXXMLFilter * This,
            /* [retval][out] */ ISAXContentHandler **ppHandler);
        
        HRESULT ( STDMETHODCALLTYPE *putContentHandler )( 
            ISAXXMLFilter * This,
            /* [in] */ ISAXContentHandler *pHandler);
        
        HRESULT ( STDMETHODCALLTYPE *getDTDHandler )( 
            ISAXXMLFilter * This,
            /* [retval][out] */ ISAXDTDHandler **ppHandler);
        
        HRESULT ( STDMETHODCALLTYPE *putDTDHandler )( 
            ISAXXMLFilter * This,
            /* [in] */ ISAXDTDHandler *pHandler);
        
        HRESULT ( STDMETHODCALLTYPE *getErrorHandler )( 
            ISAXXMLFilter * This,
            /* [retval][out] */ ISAXErrorHandler **ppHandler);
        
        HRESULT ( STDMETHODCALLTYPE *putErrorHandler )( 
            ISAXXMLFilter * This,
            /* [in] */ ISAXErrorHandler *pHandler);
        
        HRESULT ( STDMETHODCALLTYPE *getBaseURL )( 
            ISAXXMLFilter * This,
            /* [retval][out] */ const wchar_t **ppwchBaseUrl);
        
        HRESULT ( STDMETHODCALLTYPE *putBaseURL )( 
            ISAXXMLFilter * This,
            /* [in] */ const wchar_t *pwchBaseUrl);
        
        HRESULT ( STDMETHODCALLTYPE *getSecureBaseURL )( 
            ISAXXMLFilter * This,
            /* [retval][out] */ const wchar_t **ppwchSecureBaseUrl);
        
        HRESULT ( STDMETHODCALLTYPE *putSecureBaseURL )( 
            ISAXXMLFilter * This,
            /* [in] */ const wchar_t *pwchSecureBaseUrl);
        
        HRESULT ( STDMETHODCALLTYPE *parse )( 
            ISAXXMLFilter * This,
            /* [in] */ VARIANT varInput);
        
        HRESULT ( STDMETHODCALLTYPE *parseURL )( 
            ISAXXMLFilter * This,
            /* [in] */ const wchar_t *pwchUrl);
        
        HRESULT ( STDMETHODCALLTYPE *getParent )( 
            ISAXXMLFilter * This,
            /* [retval][out] */ ISAXXMLReader **ppReader);
        
        HRESULT ( STDMETHODCALLTYPE *putParent )( 
            ISAXXMLFilter * This,
            /* [in] */ ISAXXMLReader *pReader);
        
        END_INTERFACE
    } ISAXXMLFilterVtbl;

    interface ISAXXMLFilter
    {
        CONST_VTBL struct ISAXXMLFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAXXMLFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAXXMLFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAXXMLFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAXXMLFilter_getFeature(This,pwchName,pvfValue)	\
    (This)->lpVtbl -> getFeature(This,pwchName,pvfValue)

#define ISAXXMLFilter_putFeature(This,pwchName,vfValue)	\
    (This)->lpVtbl -> putFeature(This,pwchName,vfValue)

#define ISAXXMLFilter_getProperty(This,pwchName,pvarValue)	\
    (This)->lpVtbl -> getProperty(This,pwchName,pvarValue)

#define ISAXXMLFilter_putProperty(This,pwchName,varValue)	\
    (This)->lpVtbl -> putProperty(This,pwchName,varValue)

#define ISAXXMLFilter_getEntityResolver(This,ppResolver)	\
    (This)->lpVtbl -> getEntityResolver(This,ppResolver)

#define ISAXXMLFilter_putEntityResolver(This,pResolver)	\
    (This)->lpVtbl -> putEntityResolver(This,pResolver)

#define ISAXXMLFilter_getContentHandler(This,ppHandler)	\
    (This)->lpVtbl -> getContentHandler(This,ppHandler)

#define ISAXXMLFilter_putContentHandler(This,pHandler)	\
    (This)->lpVtbl -> putContentHandler(This,pHandler)

#define ISAXXMLFilter_getDTDHandler(This,ppHandler)	\
    (This)->lpVtbl -> getDTDHandler(This,ppHandler)

#define ISAXXMLFilter_putDTDHandler(This,pHandler)	\
    (This)->lpVtbl -> putDTDHandler(This,pHandler)

#define ISAXXMLFilter_getErrorHandler(This,ppHandler)	\
    (This)->lpVtbl -> getErrorHandler(This,ppHandler)

#define ISAXXMLFilter_putErrorHandler(This,pHandler)	\
    (This)->lpVtbl -> putErrorHandler(This,pHandler)

#define ISAXXMLFilter_getBaseURL(This,ppwchBaseUrl)	\
    (This)->lpVtbl -> getBaseURL(This,ppwchBaseUrl)

#define ISAXXMLFilter_putBaseURL(This,pwchBaseUrl)	\
    (This)->lpVtbl -> putBaseURL(This,pwchBaseUrl)

#define ISAXXMLFilter_getSecureBaseURL(This,ppwchSecureBaseUrl)	\
    (This)->lpVtbl -> getSecureBaseURL(This,ppwchSecureBaseUrl)

#define ISAXXMLFilter_putSecureBaseURL(This,pwchSecureBaseUrl)	\
    (This)->lpVtbl -> putSecureBaseURL(This,pwchSecureBaseUrl)

#define ISAXXMLFilter_parse(This,varInput)	\
    (This)->lpVtbl -> parse(This,varInput)

#define ISAXXMLFilter_parseURL(This,pwchUrl)	\
    (This)->lpVtbl -> parseURL(This,pwchUrl)


#define ISAXXMLFilter_getParent(This,ppReader)	\
    (This)->lpVtbl -> getParent(This,ppReader)

#define ISAXXMLFilter_putParent(This,pReader)	\
    (This)->lpVtbl -> putParent(This,pReader)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISAXXMLFilter_getParent_Proxy( 
    ISAXXMLFilter * This,
    /* [retval][out] */ ISAXXMLReader **ppReader);


void __RPC_STUB ISAXXMLFilter_getParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLFilter_putParent_Proxy( 
    ISAXXMLFilter * This,
    /* [in] */ ISAXXMLReader *pReader);


void __RPC_STUB ISAXXMLFilter_putParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAXXMLFilter_INTERFACE_DEFINED__ */


#ifndef __ISAXLocator_INTERFACE_DEFINED__
#define __ISAXLocator_INTERFACE_DEFINED__

/* interface ISAXLocator */
/* [unique][helpstring][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_ISAXLocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9b7e472a-0de4-4640-bff3-84d38a051c31")
    ISAXLocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE getColumnNumber( 
            /* [retval][out] */ int *pnColumn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getLineNumber( 
            /* [retval][out] */ int *pnLine) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getPublicId( 
            /* [retval][out] */ const wchar_t **ppwchPublicId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getSystemId( 
            /* [retval][out] */ const wchar_t **ppwchSystemId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAXLocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISAXLocator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISAXLocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISAXLocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *getColumnNumber )( 
            ISAXLocator * This,
            /* [retval][out] */ int *pnColumn);
        
        HRESULT ( STDMETHODCALLTYPE *getLineNumber )( 
            ISAXLocator * This,
            /* [retval][out] */ int *pnLine);
        
        HRESULT ( STDMETHODCALLTYPE *getPublicId )( 
            ISAXLocator * This,
            /* [retval][out] */ const wchar_t **ppwchPublicId);
        
        HRESULT ( STDMETHODCALLTYPE *getSystemId )( 
            ISAXLocator * This,
            /* [retval][out] */ const wchar_t **ppwchSystemId);
        
        END_INTERFACE
    } ISAXLocatorVtbl;

    interface ISAXLocator
    {
        CONST_VTBL struct ISAXLocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAXLocator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAXLocator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAXLocator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAXLocator_getColumnNumber(This,pnColumn)	\
    (This)->lpVtbl -> getColumnNumber(This,pnColumn)

#define ISAXLocator_getLineNumber(This,pnLine)	\
    (This)->lpVtbl -> getLineNumber(This,pnLine)

#define ISAXLocator_getPublicId(This,ppwchPublicId)	\
    (This)->lpVtbl -> getPublicId(This,ppwchPublicId)

#define ISAXLocator_getSystemId(This,ppwchSystemId)	\
    (This)->lpVtbl -> getSystemId(This,ppwchSystemId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISAXLocator_getColumnNumber_Proxy( 
    ISAXLocator * This,
    /* [retval][out] */ int *pnColumn);


void __RPC_STUB ISAXLocator_getColumnNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXLocator_getLineNumber_Proxy( 
    ISAXLocator * This,
    /* [retval][out] */ int *pnLine);


void __RPC_STUB ISAXLocator_getLineNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXLocator_getPublicId_Proxy( 
    ISAXLocator * This,
    /* [retval][out] */ const wchar_t **ppwchPublicId);


void __RPC_STUB ISAXLocator_getPublicId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXLocator_getSystemId_Proxy( 
    ISAXLocator * This,
    /* [retval][out] */ const wchar_t **ppwchSystemId);


void __RPC_STUB ISAXLocator_getSystemId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAXLocator_INTERFACE_DEFINED__ */


#ifndef __ISAXEntityResolver_INTERFACE_DEFINED__
#define __ISAXEntityResolver_INTERFACE_DEFINED__

/* interface ISAXEntityResolver */
/* [unique][helpstring][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_ISAXEntityResolver;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("99bca7bd-e8c4-4d5f-a0cf-6d907901ff07")
    ISAXEntityResolver : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE resolveEntity( 
            /* [in] */ const wchar_t *pwchPublicId,
            /* [in] */ const wchar_t *pwchSystemId,
            /* [retval][out] */ VARIANT *pvarInput) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAXEntityResolverVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISAXEntityResolver * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISAXEntityResolver * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISAXEntityResolver * This);
        
        HRESULT ( STDMETHODCALLTYPE *resolveEntity )( 
            ISAXEntityResolver * This,
            /* [in] */ const wchar_t *pwchPublicId,
            /* [in] */ const wchar_t *pwchSystemId,
            /* [retval][out] */ VARIANT *pvarInput);
        
        END_INTERFACE
    } ISAXEntityResolverVtbl;

    interface ISAXEntityResolver
    {
        CONST_VTBL struct ISAXEntityResolverVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAXEntityResolver_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAXEntityResolver_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAXEntityResolver_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAXEntityResolver_resolveEntity(This,pwchPublicId,pwchSystemId,pvarInput)	\
    (This)->lpVtbl -> resolveEntity(This,pwchPublicId,pwchSystemId,pvarInput)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISAXEntityResolver_resolveEntity_Proxy( 
    ISAXEntityResolver * This,
    /* [in] */ const wchar_t *pwchPublicId,
    /* [in] */ const wchar_t *pwchSystemId,
    /* [retval][out] */ VARIANT *pvarInput);


void __RPC_STUB ISAXEntityResolver_resolveEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAXEntityResolver_INTERFACE_DEFINED__ */


#ifndef __ISAXContentHandler_INTERFACE_DEFINED__
#define __ISAXContentHandler_INTERFACE_DEFINED__

/* interface ISAXContentHandler */
/* [unique][helpstring][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_ISAXContentHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1545cdfa-9e4e-4497-a8a4-2bf7d0112c44")
    ISAXContentHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE putDocumentLocator( 
            /* [in] */ ISAXLocator *pLocator) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE startDocument( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE endDocument( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE startPrefixMapping( 
            /* [in] */ const wchar_t *pwchPrefix,
            /* [in] */ int cchPrefix,
            /* [in] */ const wchar_t *pwchUri,
            /* [in] */ int cchUri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE endPrefixMapping( 
            /* [in] */ const wchar_t *pwchPrefix,
            /* [in] */ int cchPrefix) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE startElement( 
            /* [in] */ const wchar_t *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ const wchar_t *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ const wchar_t *pwchQName,
            /* [in] */ int cchQName,
            /* [in] */ ISAXAttributes *pAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE endElement( 
            /* [in] */ const wchar_t *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ const wchar_t *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ const wchar_t *pwchQName,
            /* [in] */ int cchQName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE characters( 
            /* [in] */ const wchar_t *pwchChars,
            /* [in] */ int cchChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ignorableWhitespace( 
            /* [in] */ const wchar_t *pwchChars,
            /* [in] */ int cchChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE processingInstruction( 
            /* [in] */ const wchar_t *pwchTarget,
            /* [in] */ int cchTarget,
            /* [in] */ const wchar_t *pwchData,
            /* [in] */ int cchData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE skippedEntity( 
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ int cchName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAXContentHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISAXContentHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISAXContentHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISAXContentHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *putDocumentLocator )( 
            ISAXContentHandler * This,
            /* [in] */ ISAXLocator *pLocator);
        
        HRESULT ( STDMETHODCALLTYPE *startDocument )( 
            ISAXContentHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *endDocument )( 
            ISAXContentHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *startPrefixMapping )( 
            ISAXContentHandler * This,
            /* [in] */ const wchar_t *pwchPrefix,
            /* [in] */ int cchPrefix,
            /* [in] */ const wchar_t *pwchUri,
            /* [in] */ int cchUri);
        
        HRESULT ( STDMETHODCALLTYPE *endPrefixMapping )( 
            ISAXContentHandler * This,
            /* [in] */ const wchar_t *pwchPrefix,
            /* [in] */ int cchPrefix);
        
        HRESULT ( STDMETHODCALLTYPE *startElement )( 
            ISAXContentHandler * This,
            /* [in] */ const wchar_t *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ const wchar_t *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ const wchar_t *pwchQName,
            /* [in] */ int cchQName,
            /* [in] */ ISAXAttributes *pAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *endElement )( 
            ISAXContentHandler * This,
            /* [in] */ const wchar_t *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ const wchar_t *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ const wchar_t *pwchQName,
            /* [in] */ int cchQName);
        
        HRESULT ( STDMETHODCALLTYPE *characters )( 
            ISAXContentHandler * This,
            /* [in] */ const wchar_t *pwchChars,
            /* [in] */ int cchChars);
        
        HRESULT ( STDMETHODCALLTYPE *ignorableWhitespace )( 
            ISAXContentHandler * This,
            /* [in] */ const wchar_t *pwchChars,
            /* [in] */ int cchChars);
        
        HRESULT ( STDMETHODCALLTYPE *processingInstruction )( 
            ISAXContentHandler * This,
            /* [in] */ const wchar_t *pwchTarget,
            /* [in] */ int cchTarget,
            /* [in] */ const wchar_t *pwchData,
            /* [in] */ int cchData);
        
        HRESULT ( STDMETHODCALLTYPE *skippedEntity )( 
            ISAXContentHandler * This,
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ int cchName);
        
        END_INTERFACE
    } ISAXContentHandlerVtbl;

    interface ISAXContentHandler
    {
        CONST_VTBL struct ISAXContentHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAXContentHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAXContentHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAXContentHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAXContentHandler_putDocumentLocator(This,pLocator)	\
    (This)->lpVtbl -> putDocumentLocator(This,pLocator)

#define ISAXContentHandler_startDocument(This)	\
    (This)->lpVtbl -> startDocument(This)

#define ISAXContentHandler_endDocument(This)	\
    (This)->lpVtbl -> endDocument(This)

#define ISAXContentHandler_startPrefixMapping(This,pwchPrefix,cchPrefix,pwchUri,cchUri)	\
    (This)->lpVtbl -> startPrefixMapping(This,pwchPrefix,cchPrefix,pwchUri,cchUri)

#define ISAXContentHandler_endPrefixMapping(This,pwchPrefix,cchPrefix)	\
    (This)->lpVtbl -> endPrefixMapping(This,pwchPrefix,cchPrefix)

#define ISAXContentHandler_startElement(This,pwchNamespaceUri,cchNamespaceUri,pwchLocalName,cchLocalName,pwchQName,cchQName,pAttributes)	\
    (This)->lpVtbl -> startElement(This,pwchNamespaceUri,cchNamespaceUri,pwchLocalName,cchLocalName,pwchQName,cchQName,pAttributes)

#define ISAXContentHandler_endElement(This,pwchNamespaceUri,cchNamespaceUri,pwchLocalName,cchLocalName,pwchQName,cchQName)	\
    (This)->lpVtbl -> endElement(This,pwchNamespaceUri,cchNamespaceUri,pwchLocalName,cchLocalName,pwchQName,cchQName)

#define ISAXContentHandler_characters(This,pwchChars,cchChars)	\
    (This)->lpVtbl -> characters(This,pwchChars,cchChars)

#define ISAXContentHandler_ignorableWhitespace(This,pwchChars,cchChars)	\
    (This)->lpVtbl -> ignorableWhitespace(This,pwchChars,cchChars)

#define ISAXContentHandler_processingInstruction(This,pwchTarget,cchTarget,pwchData,cchData)	\
    (This)->lpVtbl -> processingInstruction(This,pwchTarget,cchTarget,pwchData,cchData)

#define ISAXContentHandler_skippedEntity(This,pwchName,cchName)	\
    (This)->lpVtbl -> skippedEntity(This,pwchName,cchName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISAXContentHandler_putDocumentLocator_Proxy( 
    ISAXContentHandler * This,
    /* [in] */ ISAXLocator *pLocator);


void __RPC_STUB ISAXContentHandler_putDocumentLocator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXContentHandler_startDocument_Proxy( 
    ISAXContentHandler * This);


void __RPC_STUB ISAXContentHandler_startDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXContentHandler_endDocument_Proxy( 
    ISAXContentHandler * This);


void __RPC_STUB ISAXContentHandler_endDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXContentHandler_startPrefixMapping_Proxy( 
    ISAXContentHandler * This,
    /* [in] */ const wchar_t *pwchPrefix,
    /* [in] */ int cchPrefix,
    /* [in] */ const wchar_t *pwchUri,
    /* [in] */ int cchUri);


void __RPC_STUB ISAXContentHandler_startPrefixMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXContentHandler_endPrefixMapping_Proxy( 
    ISAXContentHandler * This,
    /* [in] */ const wchar_t *pwchPrefix,
    /* [in] */ int cchPrefix);


void __RPC_STUB ISAXContentHandler_endPrefixMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXContentHandler_startElement_Proxy( 
    ISAXContentHandler * This,
    /* [in] */ const wchar_t *pwchNamespaceUri,
    /* [in] */ int cchNamespaceUri,
    /* [in] */ const wchar_t *pwchLocalName,
    /* [in] */ int cchLocalName,
    /* [in] */ const wchar_t *pwchQName,
    /* [in] */ int cchQName,
    /* [in] */ ISAXAttributes *pAttributes);


void __RPC_STUB ISAXContentHandler_startElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXContentHandler_endElement_Proxy( 
    ISAXContentHandler * This,
    /* [in] */ const wchar_t *pwchNamespaceUri,
    /* [in] */ int cchNamespaceUri,
    /* [in] */ const wchar_t *pwchLocalName,
    /* [in] */ int cchLocalName,
    /* [in] */ const wchar_t *pwchQName,
    /* [in] */ int cchQName);


void __RPC_STUB ISAXContentHandler_endElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXContentHandler_characters_Proxy( 
    ISAXContentHandler * This,
    /* [in] */ const wchar_t *pwchChars,
    /* [in] */ int cchChars);


void __RPC_STUB ISAXContentHandler_characters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXContentHandler_ignorableWhitespace_Proxy( 
    ISAXContentHandler * This,
    /* [in] */ const wchar_t *pwchChars,
    /* [in] */ int cchChars);


void __RPC_STUB ISAXContentHandler_ignorableWhitespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXContentHandler_processingInstruction_Proxy( 
    ISAXContentHandler * This,
    /* [in] */ const wchar_t *pwchTarget,
    /* [in] */ int cchTarget,
    /* [in] */ const wchar_t *pwchData,
    /* [in] */ int cchData);


void __RPC_STUB ISAXContentHandler_processingInstruction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXContentHandler_skippedEntity_Proxy( 
    ISAXContentHandler * This,
    /* [in] */ const wchar_t *pwchName,
    /* [in] */ int cchName);


void __RPC_STUB ISAXContentHandler_skippedEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAXContentHandler_INTERFACE_DEFINED__ */


#ifndef __ISAXDTDHandler_INTERFACE_DEFINED__
#define __ISAXDTDHandler_INTERFACE_DEFINED__

/* interface ISAXDTDHandler */
/* [unique][helpstring][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_ISAXDTDHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e15c1baf-afb3-4d60-8c36-19a8c45defed")
    ISAXDTDHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE notationDecl( 
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ int cchName,
            /* [in] */ const wchar_t *pwchPublicId,
            /* [in] */ int cchPublicId,
            /* [in] */ const wchar_t *pwchSystemId,
            /* [in] */ int cchSystemId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE unparsedEntityDecl( 
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ int cchName,
            /* [in] */ const wchar_t *pwchPublicId,
            /* [in] */ int cchPublicId,
            /* [in] */ const wchar_t *pwchSystemId,
            /* [in] */ int cchSystemId,
            /* [in] */ const wchar_t *pwchNotationName,
            /* [in] */ int cchNotationName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAXDTDHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISAXDTDHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISAXDTDHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISAXDTDHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *notationDecl )( 
            ISAXDTDHandler * This,
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ int cchName,
            /* [in] */ const wchar_t *pwchPublicId,
            /* [in] */ int cchPublicId,
            /* [in] */ const wchar_t *pwchSystemId,
            /* [in] */ int cchSystemId);
        
        HRESULT ( STDMETHODCALLTYPE *unparsedEntityDecl )( 
            ISAXDTDHandler * This,
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ int cchName,
            /* [in] */ const wchar_t *pwchPublicId,
            /* [in] */ int cchPublicId,
            /* [in] */ const wchar_t *pwchSystemId,
            /* [in] */ int cchSystemId,
            /* [in] */ const wchar_t *pwchNotationName,
            /* [in] */ int cchNotationName);
        
        END_INTERFACE
    } ISAXDTDHandlerVtbl;

    interface ISAXDTDHandler
    {
        CONST_VTBL struct ISAXDTDHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAXDTDHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAXDTDHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAXDTDHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAXDTDHandler_notationDecl(This,pwchName,cchName,pwchPublicId,cchPublicId,pwchSystemId,cchSystemId)	\
    (This)->lpVtbl -> notationDecl(This,pwchName,cchName,pwchPublicId,cchPublicId,pwchSystemId,cchSystemId)

#define ISAXDTDHandler_unparsedEntityDecl(This,pwchName,cchName,pwchPublicId,cchPublicId,pwchSystemId,cchSystemId,pwchNotationName,cchNotationName)	\
    (This)->lpVtbl -> unparsedEntityDecl(This,pwchName,cchName,pwchPublicId,cchPublicId,pwchSystemId,cchSystemId,pwchNotationName,cchNotationName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISAXDTDHandler_notationDecl_Proxy( 
    ISAXDTDHandler * This,
    /* [in] */ const wchar_t *pwchName,
    /* [in] */ int cchName,
    /* [in] */ const wchar_t *pwchPublicId,
    /* [in] */ int cchPublicId,
    /* [in] */ const wchar_t *pwchSystemId,
    /* [in] */ int cchSystemId);


void __RPC_STUB ISAXDTDHandler_notationDecl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXDTDHandler_unparsedEntityDecl_Proxy( 
    ISAXDTDHandler * This,
    /* [in] */ const wchar_t *pwchName,
    /* [in] */ int cchName,
    /* [in] */ const wchar_t *pwchPublicId,
    /* [in] */ int cchPublicId,
    /* [in] */ const wchar_t *pwchSystemId,
    /* [in] */ int cchSystemId,
    /* [in] */ const wchar_t *pwchNotationName,
    /* [in] */ int cchNotationName);


void __RPC_STUB ISAXDTDHandler_unparsedEntityDecl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAXDTDHandler_INTERFACE_DEFINED__ */


#ifndef __ISAXErrorHandler_INTERFACE_DEFINED__
#define __ISAXErrorHandler_INTERFACE_DEFINED__

/* interface ISAXErrorHandler */
/* [unique][helpstring][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_ISAXErrorHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a60511c4-ccf5-479e-98a3-dc8dc545b7d0")
    ISAXErrorHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE error( 
            /* [in] */ ISAXLocator *pLocator,
            /* [in] */ const wchar_t *pwchErrorMessage,
            /* [in] */ HRESULT hrErrorCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE fatalError( 
            /* [in] */ ISAXLocator *pLocator,
            /* [in] */ const wchar_t *pwchErrorMessage,
            /* [in] */ HRESULT hrErrorCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ignorableWarning( 
            /* [in] */ ISAXLocator *pLocator,
            /* [in] */ const wchar_t *pwchErrorMessage,
            /* [in] */ HRESULT hrErrorCode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAXErrorHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISAXErrorHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISAXErrorHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISAXErrorHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *error )( 
            ISAXErrorHandler * This,
            /* [in] */ ISAXLocator *pLocator,
            /* [in] */ const wchar_t *pwchErrorMessage,
            /* [in] */ HRESULT hrErrorCode);
        
        HRESULT ( STDMETHODCALLTYPE *fatalError )( 
            ISAXErrorHandler * This,
            /* [in] */ ISAXLocator *pLocator,
            /* [in] */ const wchar_t *pwchErrorMessage,
            /* [in] */ HRESULT hrErrorCode);
        
        HRESULT ( STDMETHODCALLTYPE *ignorableWarning )( 
            ISAXErrorHandler * This,
            /* [in] */ ISAXLocator *pLocator,
            /* [in] */ const wchar_t *pwchErrorMessage,
            /* [in] */ HRESULT hrErrorCode);
        
        END_INTERFACE
    } ISAXErrorHandlerVtbl;

    interface ISAXErrorHandler
    {
        CONST_VTBL struct ISAXErrorHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAXErrorHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAXErrorHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAXErrorHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAXErrorHandler_error(This,pLocator,pwchErrorMessage,hrErrorCode)	\
    (This)->lpVtbl -> error(This,pLocator,pwchErrorMessage,hrErrorCode)

#define ISAXErrorHandler_fatalError(This,pLocator,pwchErrorMessage,hrErrorCode)	\
    (This)->lpVtbl -> fatalError(This,pLocator,pwchErrorMessage,hrErrorCode)

#define ISAXErrorHandler_ignorableWarning(This,pLocator,pwchErrorMessage,hrErrorCode)	\
    (This)->lpVtbl -> ignorableWarning(This,pLocator,pwchErrorMessage,hrErrorCode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISAXErrorHandler_error_Proxy( 
    ISAXErrorHandler * This,
    /* [in] */ ISAXLocator *pLocator,
    /* [in] */ const wchar_t *pwchErrorMessage,
    /* [in] */ HRESULT hrErrorCode);


void __RPC_STUB ISAXErrorHandler_error_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXErrorHandler_fatalError_Proxy( 
    ISAXErrorHandler * This,
    /* [in] */ ISAXLocator *pLocator,
    /* [in] */ const wchar_t *pwchErrorMessage,
    /* [in] */ HRESULT hrErrorCode);


void __RPC_STUB ISAXErrorHandler_fatalError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXErrorHandler_ignorableWarning_Proxy( 
    ISAXErrorHandler * This,
    /* [in] */ ISAXLocator *pLocator,
    /* [in] */ const wchar_t *pwchErrorMessage,
    /* [in] */ HRESULT hrErrorCode);


void __RPC_STUB ISAXErrorHandler_ignorableWarning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAXErrorHandler_INTERFACE_DEFINED__ */


#ifndef __ISAXLexicalHandler_INTERFACE_DEFINED__
#define __ISAXLexicalHandler_INTERFACE_DEFINED__

/* interface ISAXLexicalHandler */
/* [unique][helpstring][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_ISAXLexicalHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7f85d5f5-47a8-4497-bda5-84ba04819ea6")
    ISAXLexicalHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE startDTD( 
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ int cchName,
            /* [in] */ const wchar_t *pwchPublicId,
            /* [in] */ int cchPublicId,
            /* [in] */ const wchar_t *pwchSystemId,
            /* [in] */ int cchSystemId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE endDTD( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE startEntity( 
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ int cchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE endEntity( 
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ int cchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE startCDATA( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE endCDATA( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE comment( 
            /* [in] */ const wchar_t *pwchChars,
            /* [in] */ int cchChars) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAXLexicalHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISAXLexicalHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISAXLexicalHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISAXLexicalHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *startDTD )( 
            ISAXLexicalHandler * This,
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ int cchName,
            /* [in] */ const wchar_t *pwchPublicId,
            /* [in] */ int cchPublicId,
            /* [in] */ const wchar_t *pwchSystemId,
            /* [in] */ int cchSystemId);
        
        HRESULT ( STDMETHODCALLTYPE *endDTD )( 
            ISAXLexicalHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *startEntity )( 
            ISAXLexicalHandler * This,
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ int cchName);
        
        HRESULT ( STDMETHODCALLTYPE *endEntity )( 
            ISAXLexicalHandler * This,
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ int cchName);
        
        HRESULT ( STDMETHODCALLTYPE *startCDATA )( 
            ISAXLexicalHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *endCDATA )( 
            ISAXLexicalHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *comment )( 
            ISAXLexicalHandler * This,
            /* [in] */ const wchar_t *pwchChars,
            /* [in] */ int cchChars);
        
        END_INTERFACE
    } ISAXLexicalHandlerVtbl;

    interface ISAXLexicalHandler
    {
        CONST_VTBL struct ISAXLexicalHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAXLexicalHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAXLexicalHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAXLexicalHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAXLexicalHandler_startDTD(This,pwchName,cchName,pwchPublicId,cchPublicId,pwchSystemId,cchSystemId)	\
    (This)->lpVtbl -> startDTD(This,pwchName,cchName,pwchPublicId,cchPublicId,pwchSystemId,cchSystemId)

#define ISAXLexicalHandler_endDTD(This)	\
    (This)->lpVtbl -> endDTD(This)

#define ISAXLexicalHandler_startEntity(This,pwchName,cchName)	\
    (This)->lpVtbl -> startEntity(This,pwchName,cchName)

#define ISAXLexicalHandler_endEntity(This,pwchName,cchName)	\
    (This)->lpVtbl -> endEntity(This,pwchName,cchName)

#define ISAXLexicalHandler_startCDATA(This)	\
    (This)->lpVtbl -> startCDATA(This)

#define ISAXLexicalHandler_endCDATA(This)	\
    (This)->lpVtbl -> endCDATA(This)

#define ISAXLexicalHandler_comment(This,pwchChars,cchChars)	\
    (This)->lpVtbl -> comment(This,pwchChars,cchChars)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISAXLexicalHandler_startDTD_Proxy( 
    ISAXLexicalHandler * This,
    /* [in] */ const wchar_t *pwchName,
    /* [in] */ int cchName,
    /* [in] */ const wchar_t *pwchPublicId,
    /* [in] */ int cchPublicId,
    /* [in] */ const wchar_t *pwchSystemId,
    /* [in] */ int cchSystemId);


void __RPC_STUB ISAXLexicalHandler_startDTD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXLexicalHandler_endDTD_Proxy( 
    ISAXLexicalHandler * This);


void __RPC_STUB ISAXLexicalHandler_endDTD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXLexicalHandler_startEntity_Proxy( 
    ISAXLexicalHandler * This,
    /* [in] */ const wchar_t *pwchName,
    /* [in] */ int cchName);


void __RPC_STUB ISAXLexicalHandler_startEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXLexicalHandler_endEntity_Proxy( 
    ISAXLexicalHandler * This,
    /* [in] */ const wchar_t *pwchName,
    /* [in] */ int cchName);


void __RPC_STUB ISAXLexicalHandler_endEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXLexicalHandler_startCDATA_Proxy( 
    ISAXLexicalHandler * This);


void __RPC_STUB ISAXLexicalHandler_startCDATA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXLexicalHandler_endCDATA_Proxy( 
    ISAXLexicalHandler * This);


void __RPC_STUB ISAXLexicalHandler_endCDATA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXLexicalHandler_comment_Proxy( 
    ISAXLexicalHandler * This,
    /* [in] */ const wchar_t *pwchChars,
    /* [in] */ int cchChars);


void __RPC_STUB ISAXLexicalHandler_comment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAXLexicalHandler_INTERFACE_DEFINED__ */


#ifndef __ISAXDeclHandler_INTERFACE_DEFINED__
#define __ISAXDeclHandler_INTERFACE_DEFINED__

/* interface ISAXDeclHandler */
/* [unique][helpstring][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_ISAXDeclHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("862629ac-771a-47b2-8337-4e6843c1be90")
    ISAXDeclHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE elementDecl( 
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ int cchName,
            /* [in] */ const wchar_t *pwchModel,
            /* [in] */ int cchModel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE attributeDecl( 
            /* [in] */ const wchar_t *pwchElementName,
            /* [in] */ int cchElementName,
            /* [in] */ const wchar_t *pwchAttributeName,
            /* [in] */ int cchAttributeName,
            /* [in] */ const wchar_t *pwchType,
            /* [in] */ int cchType,
            /* [in] */ const wchar_t *pwchValueDefault,
            /* [in] */ int cchValueDefault,
            /* [in] */ const wchar_t *pwchValue,
            /* [in] */ int cchValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE internalEntityDecl( 
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ int cchName,
            /* [in] */ const wchar_t *pwchValue,
            /* [in] */ int cchValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE externalEntityDecl( 
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ int cchName,
            /* [in] */ const wchar_t *pwchPublicId,
            /* [in] */ int cchPublicId,
            /* [in] */ const wchar_t *pwchSystemId,
            /* [in] */ int cchSystemId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAXDeclHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISAXDeclHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISAXDeclHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISAXDeclHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *elementDecl )( 
            ISAXDeclHandler * This,
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ int cchName,
            /* [in] */ const wchar_t *pwchModel,
            /* [in] */ int cchModel);
        
        HRESULT ( STDMETHODCALLTYPE *attributeDecl )( 
            ISAXDeclHandler * This,
            /* [in] */ const wchar_t *pwchElementName,
            /* [in] */ int cchElementName,
            /* [in] */ const wchar_t *pwchAttributeName,
            /* [in] */ int cchAttributeName,
            /* [in] */ const wchar_t *pwchType,
            /* [in] */ int cchType,
            /* [in] */ const wchar_t *pwchValueDefault,
            /* [in] */ int cchValueDefault,
            /* [in] */ const wchar_t *pwchValue,
            /* [in] */ int cchValue);
        
        HRESULT ( STDMETHODCALLTYPE *internalEntityDecl )( 
            ISAXDeclHandler * This,
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ int cchName,
            /* [in] */ const wchar_t *pwchValue,
            /* [in] */ int cchValue);
        
        HRESULT ( STDMETHODCALLTYPE *externalEntityDecl )( 
            ISAXDeclHandler * This,
            /* [in] */ const wchar_t *pwchName,
            /* [in] */ int cchName,
            /* [in] */ const wchar_t *pwchPublicId,
            /* [in] */ int cchPublicId,
            /* [in] */ const wchar_t *pwchSystemId,
            /* [in] */ int cchSystemId);
        
        END_INTERFACE
    } ISAXDeclHandlerVtbl;

    interface ISAXDeclHandler
    {
        CONST_VTBL struct ISAXDeclHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAXDeclHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAXDeclHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAXDeclHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAXDeclHandler_elementDecl(This,pwchName,cchName,pwchModel,cchModel)	\
    (This)->lpVtbl -> elementDecl(This,pwchName,cchName,pwchModel,cchModel)

#define ISAXDeclHandler_attributeDecl(This,pwchElementName,cchElementName,pwchAttributeName,cchAttributeName,pwchType,cchType,pwchValueDefault,cchValueDefault,pwchValue,cchValue)	\
    (This)->lpVtbl -> attributeDecl(This,pwchElementName,cchElementName,pwchAttributeName,cchAttributeName,pwchType,cchType,pwchValueDefault,cchValueDefault,pwchValue,cchValue)

#define ISAXDeclHandler_internalEntityDecl(This,pwchName,cchName,pwchValue,cchValue)	\
    (This)->lpVtbl -> internalEntityDecl(This,pwchName,cchName,pwchValue,cchValue)

#define ISAXDeclHandler_externalEntityDecl(This,pwchName,cchName,pwchPublicId,cchPublicId,pwchSystemId,cchSystemId)	\
    (This)->lpVtbl -> externalEntityDecl(This,pwchName,cchName,pwchPublicId,cchPublicId,pwchSystemId,cchSystemId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISAXDeclHandler_elementDecl_Proxy( 
    ISAXDeclHandler * This,
    /* [in] */ const wchar_t *pwchName,
    /* [in] */ int cchName,
    /* [in] */ const wchar_t *pwchModel,
    /* [in] */ int cchModel);


void __RPC_STUB ISAXDeclHandler_elementDecl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXDeclHandler_attributeDecl_Proxy( 
    ISAXDeclHandler * This,
    /* [in] */ const wchar_t *pwchElementName,
    /* [in] */ int cchElementName,
    /* [in] */ const wchar_t *pwchAttributeName,
    /* [in] */ int cchAttributeName,
    /* [in] */ const wchar_t *pwchType,
    /* [in] */ int cchType,
    /* [in] */ const wchar_t *pwchValueDefault,
    /* [in] */ int cchValueDefault,
    /* [in] */ const wchar_t *pwchValue,
    /* [in] */ int cchValue);


void __RPC_STUB ISAXDeclHandler_attributeDecl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXDeclHandler_internalEntityDecl_Proxy( 
    ISAXDeclHandler * This,
    /* [in] */ const wchar_t *pwchName,
    /* [in] */ int cchName,
    /* [in] */ const wchar_t *pwchValue,
    /* [in] */ int cchValue);


void __RPC_STUB ISAXDeclHandler_internalEntityDecl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXDeclHandler_externalEntityDecl_Proxy( 
    ISAXDeclHandler * This,
    /* [in] */ const wchar_t *pwchName,
    /* [in] */ int cchName,
    /* [in] */ const wchar_t *pwchPublicId,
    /* [in] */ int cchPublicId,
    /* [in] */ const wchar_t *pwchSystemId,
    /* [in] */ int cchSystemId);


void __RPC_STUB ISAXDeclHandler_externalEntityDecl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAXDeclHandler_INTERFACE_DEFINED__ */


#ifndef __ISAXAttributes_INTERFACE_DEFINED__
#define __ISAXAttributes_INTERFACE_DEFINED__

/* interface ISAXAttributes */
/* [unique][helpstring][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_ISAXAttributes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f078abe1-45d2-4832-91ea-4466ce2f25c9")
    ISAXAttributes : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE getLength( 
            /* [retval][out] */ int *pnLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getURI( 
            /* [in] */ int nIndex,
            /* [out] */ const wchar_t **ppwchUri,
            /* [out] */ int *pcchUri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getLocalName( 
            /* [in] */ int nIndex,
            /* [out] */ const wchar_t **ppwchLocalName,
            /* [out] */ int *pcchLocalName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getQName( 
            /* [in] */ int nIndex,
            /* [out] */ const wchar_t **ppwchQName,
            /* [out] */ int *pcchQName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getName( 
            /* [in] */ int nIndex,
            /* [out] */ const wchar_t **ppwchUri,
            /* [out] */ int *pcchUri,
            /* [out] */ const wchar_t **ppwchLocalName,
            /* [out] */ int *pcchLocalName,
            /* [out] */ const wchar_t **ppwchQName,
            /* [out] */ int *pcchQName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getIndexFromName( 
            /* [in] */ const wchar_t *pwchUri,
            /* [in] */ int cchUri,
            /* [in] */ const wchar_t *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [retval][out] */ int *pnIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getIndexFromQName( 
            /* [in] */ const wchar_t *pwchQName,
            /* [in] */ int cchQName,
            /* [retval][out] */ int *pnIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getType( 
            /* [in] */ int nIndex,
            /* [out] */ const wchar_t **ppwchType,
            /* [out] */ int *pcchType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getTypeFromName( 
            /* [in] */ const wchar_t *pwchUri,
            /* [in] */ int cchUri,
            /* [in] */ const wchar_t *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [out] */ const wchar_t **ppwchType,
            /* [out] */ int *pcchType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getTypeFromQName( 
            /* [in] */ const wchar_t *pwchQName,
            /* [in] */ int cchQName,
            /* [out] */ const wchar_t **ppwchType,
            /* [out] */ int *pcchType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getValue( 
            /* [in] */ int nIndex,
            /* [out] */ const wchar_t **ppwchValue,
            /* [out] */ int *pcchValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getValueFromName( 
            /* [in] */ const wchar_t *pwchUri,
            /* [in] */ int cchUri,
            /* [in] */ const wchar_t *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [out] */ const wchar_t **ppwchValue,
            /* [out] */ int *pcchValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getValueFromQName( 
            /* [in] */ const wchar_t *pwchQName,
            /* [in] */ int cchQName,
            /* [out] */ const wchar_t **ppwchValue,
            /* [out] */ int *pcchValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAXAttributesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISAXAttributes * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISAXAttributes * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISAXAttributes * This);
        
        HRESULT ( STDMETHODCALLTYPE *getLength )( 
            ISAXAttributes * This,
            /* [retval][out] */ int *pnLength);
        
        HRESULT ( STDMETHODCALLTYPE *getURI )( 
            ISAXAttributes * This,
            /* [in] */ int nIndex,
            /* [out] */ const wchar_t **ppwchUri,
            /* [out] */ int *pcchUri);
        
        HRESULT ( STDMETHODCALLTYPE *getLocalName )( 
            ISAXAttributes * This,
            /* [in] */ int nIndex,
            /* [out] */ const wchar_t **ppwchLocalName,
            /* [out] */ int *pcchLocalName);
        
        HRESULT ( STDMETHODCALLTYPE *getQName )( 
            ISAXAttributes * This,
            /* [in] */ int nIndex,
            /* [out] */ const wchar_t **ppwchQName,
            /* [out] */ int *pcchQName);
        
        HRESULT ( STDMETHODCALLTYPE *getName )( 
            ISAXAttributes * This,
            /* [in] */ int nIndex,
            /* [out] */ const wchar_t **ppwchUri,
            /* [out] */ int *pcchUri,
            /* [out] */ const wchar_t **ppwchLocalName,
            /* [out] */ int *pcchLocalName,
            /* [out] */ const wchar_t **ppwchQName,
            /* [out] */ int *pcchQName);
        
        HRESULT ( STDMETHODCALLTYPE *getIndexFromName )( 
            ISAXAttributes * This,
            /* [in] */ const wchar_t *pwchUri,
            /* [in] */ int cchUri,
            /* [in] */ const wchar_t *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [retval][out] */ int *pnIndex);
        
        HRESULT ( STDMETHODCALLTYPE *getIndexFromQName )( 
            ISAXAttributes * This,
            /* [in] */ const wchar_t *pwchQName,
            /* [in] */ int cchQName,
            /* [retval][out] */ int *pnIndex);
        
        HRESULT ( STDMETHODCALLTYPE *getType )( 
            ISAXAttributes * This,
            /* [in] */ int nIndex,
            /* [out] */ const wchar_t **ppwchType,
            /* [out] */ int *pcchType);
        
        HRESULT ( STDMETHODCALLTYPE *getTypeFromName )( 
            ISAXAttributes * This,
            /* [in] */ const wchar_t *pwchUri,
            /* [in] */ int cchUri,
            /* [in] */ const wchar_t *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [out] */ const wchar_t **ppwchType,
            /* [out] */ int *pcchType);
        
        HRESULT ( STDMETHODCALLTYPE *getTypeFromQName )( 
            ISAXAttributes * This,
            /* [in] */ const wchar_t *pwchQName,
            /* [in] */ int cchQName,
            /* [out] */ const wchar_t **ppwchType,
            /* [out] */ int *pcchType);
        
        HRESULT ( STDMETHODCALLTYPE *getValue )( 
            ISAXAttributes * This,
            /* [in] */ int nIndex,
            /* [out] */ const wchar_t **ppwchValue,
            /* [out] */ int *pcchValue);
        
        HRESULT ( STDMETHODCALLTYPE *getValueFromName )( 
            ISAXAttributes * This,
            /* [in] */ const wchar_t *pwchUri,
            /* [in] */ int cchUri,
            /* [in] */ const wchar_t *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [out] */ const wchar_t **ppwchValue,
            /* [out] */ int *pcchValue);
        
        HRESULT ( STDMETHODCALLTYPE *getValueFromQName )( 
            ISAXAttributes * This,
            /* [in] */ const wchar_t *pwchQName,
            /* [in] */ int cchQName,
            /* [out] */ const wchar_t **ppwchValue,
            /* [out] */ int *pcchValue);
        
        END_INTERFACE
    } ISAXAttributesVtbl;

    interface ISAXAttributes
    {
        CONST_VTBL struct ISAXAttributesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAXAttributes_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAXAttributes_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAXAttributes_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAXAttributes_getLength(This,pnLength)	\
    (This)->lpVtbl -> getLength(This,pnLength)

#define ISAXAttributes_getURI(This,nIndex,ppwchUri,pcchUri)	\
    (This)->lpVtbl -> getURI(This,nIndex,ppwchUri,pcchUri)

#define ISAXAttributes_getLocalName(This,nIndex,ppwchLocalName,pcchLocalName)	\
    (This)->lpVtbl -> getLocalName(This,nIndex,ppwchLocalName,pcchLocalName)

#define ISAXAttributes_getQName(This,nIndex,ppwchQName,pcchQName)	\
    (This)->lpVtbl -> getQName(This,nIndex,ppwchQName,pcchQName)

#define ISAXAttributes_getName(This,nIndex,ppwchUri,pcchUri,ppwchLocalName,pcchLocalName,ppwchQName,pcchQName)	\
    (This)->lpVtbl -> getName(This,nIndex,ppwchUri,pcchUri,ppwchLocalName,pcchLocalName,ppwchQName,pcchQName)

#define ISAXAttributes_getIndexFromName(This,pwchUri,cchUri,pwchLocalName,cchLocalName,pnIndex)	\
    (This)->lpVtbl -> getIndexFromName(This,pwchUri,cchUri,pwchLocalName,cchLocalName,pnIndex)

#define ISAXAttributes_getIndexFromQName(This,pwchQName,cchQName,pnIndex)	\
    (This)->lpVtbl -> getIndexFromQName(This,pwchQName,cchQName,pnIndex)

#define ISAXAttributes_getType(This,nIndex,ppwchType,pcchType)	\
    (This)->lpVtbl -> getType(This,nIndex,ppwchType,pcchType)

#define ISAXAttributes_getTypeFromName(This,pwchUri,cchUri,pwchLocalName,cchLocalName,ppwchType,pcchType)	\
    (This)->lpVtbl -> getTypeFromName(This,pwchUri,cchUri,pwchLocalName,cchLocalName,ppwchType,pcchType)

#define ISAXAttributes_getTypeFromQName(This,pwchQName,cchQName,ppwchType,pcchType)	\
    (This)->lpVtbl -> getTypeFromQName(This,pwchQName,cchQName,ppwchType,pcchType)

#define ISAXAttributes_getValue(This,nIndex,ppwchValue,pcchValue)	\
    (This)->lpVtbl -> getValue(This,nIndex,ppwchValue,pcchValue)

#define ISAXAttributes_getValueFromName(This,pwchUri,cchUri,pwchLocalName,cchLocalName,ppwchValue,pcchValue)	\
    (This)->lpVtbl -> getValueFromName(This,pwchUri,cchUri,pwchLocalName,cchLocalName,ppwchValue,pcchValue)

#define ISAXAttributes_getValueFromQName(This,pwchQName,cchQName,ppwchValue,pcchValue)	\
    (This)->lpVtbl -> getValueFromQName(This,pwchQName,cchQName,ppwchValue,pcchValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISAXAttributes_getLength_Proxy( 
    ISAXAttributes * This,
    /* [retval][out] */ int *pnLength);


void __RPC_STUB ISAXAttributes_getLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXAttributes_getURI_Proxy( 
    ISAXAttributes * This,
    /* [in] */ int nIndex,
    /* [out] */ const wchar_t **ppwchUri,
    /* [out] */ int *pcchUri);


void __RPC_STUB ISAXAttributes_getURI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXAttributes_getLocalName_Proxy( 
    ISAXAttributes * This,
    /* [in] */ int nIndex,
    /* [out] */ const wchar_t **ppwchLocalName,
    /* [out] */ int *pcchLocalName);


void __RPC_STUB ISAXAttributes_getLocalName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXAttributes_getQName_Proxy( 
    ISAXAttributes * This,
    /* [in] */ int nIndex,
    /* [out] */ const wchar_t **ppwchQName,
    /* [out] */ int *pcchQName);


void __RPC_STUB ISAXAttributes_getQName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXAttributes_getName_Proxy( 
    ISAXAttributes * This,
    /* [in] */ int nIndex,
    /* [out] */ const wchar_t **ppwchUri,
    /* [out] */ int *pcchUri,
    /* [out] */ const wchar_t **ppwchLocalName,
    /* [out] */ int *pcchLocalName,
    /* [out] */ const wchar_t **ppwchQName,
    /* [out] */ int *pcchQName);


void __RPC_STUB ISAXAttributes_getName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXAttributes_getIndexFromName_Proxy( 
    ISAXAttributes * This,
    /* [in] */ const wchar_t *pwchUri,
    /* [in] */ int cchUri,
    /* [in] */ const wchar_t *pwchLocalName,
    /* [in] */ int cchLocalName,
    /* [retval][out] */ int *pnIndex);


void __RPC_STUB ISAXAttributes_getIndexFromName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXAttributes_getIndexFromQName_Proxy( 
    ISAXAttributes * This,
    /* [in] */ const wchar_t *pwchQName,
    /* [in] */ int cchQName,
    /* [retval][out] */ int *pnIndex);


void __RPC_STUB ISAXAttributes_getIndexFromQName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXAttributes_getType_Proxy( 
    ISAXAttributes * This,
    /* [in] */ int nIndex,
    /* [out] */ const wchar_t **ppwchType,
    /* [out] */ int *pcchType);


void __RPC_STUB ISAXAttributes_getType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXAttributes_getTypeFromName_Proxy( 
    ISAXAttributes * This,
    /* [in] */ const wchar_t *pwchUri,
    /* [in] */ int cchUri,
    /* [in] */ const wchar_t *pwchLocalName,
    /* [in] */ int cchLocalName,
    /* [out] */ const wchar_t **ppwchType,
    /* [out] */ int *pcchType);


void __RPC_STUB ISAXAttributes_getTypeFromName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXAttributes_getTypeFromQName_Proxy( 
    ISAXAttributes * This,
    /* [in] */ const wchar_t *pwchQName,
    /* [in] */ int cchQName,
    /* [out] */ const wchar_t **ppwchType,
    /* [out] */ int *pcchType);


void __RPC_STUB ISAXAttributes_getTypeFromQName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXAttributes_getValue_Proxy( 
    ISAXAttributes * This,
    /* [in] */ int nIndex,
    /* [out] */ const wchar_t **ppwchValue,
    /* [out] */ int *pcchValue);


void __RPC_STUB ISAXAttributes_getValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXAttributes_getValueFromName_Proxy( 
    ISAXAttributes * This,
    /* [in] */ const wchar_t *pwchUri,
    /* [in] */ int cchUri,
    /* [in] */ const wchar_t *pwchLocalName,
    /* [in] */ int cchLocalName,
    /* [out] */ const wchar_t **ppwchValue,
    /* [out] */ int *pcchValue);


void __RPC_STUB ISAXAttributes_getValueFromName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXAttributes_getValueFromQName_Proxy( 
    ISAXAttributes * This,
    /* [in] */ const wchar_t *pwchQName,
    /* [in] */ int cchQName,
    /* [out] */ const wchar_t **ppwchValue,
    /* [out] */ int *pcchValue);


void __RPC_STUB ISAXAttributes_getValueFromQName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAXAttributes_INTERFACE_DEFINED__ */


#ifndef __IVBSAXXMLReader_INTERFACE_DEFINED__
#define __IVBSAXXMLReader_INTERFACE_DEFINED__

/* interface IVBSAXXMLReader */
/* [unique][helpstring][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IVBSAXXMLReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8c033caa-6cd6-4f73-b728-4531af74945f")
    IVBSAXXMLReader : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getFeature( 
            /* [in] */ BSTR strName,
            /* [retval][out] */ VARIANT_BOOL *fValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE putFeature( 
            /* [in] */ BSTR strName,
            /* [in] */ VARIANT_BOOL fValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getProperty( 
            /* [in] */ BSTR strName,
            /* [retval][out] */ VARIANT *varValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE putProperty( 
            /* [in] */ BSTR strName,
            /* [in] */ VARIANT varValue) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_entityResolver( 
            /* [retval][out] */ IVBSAXEntityResolver **oResolver) = 0;
        
        virtual /* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_entityResolver( 
            /* [in] */ IVBSAXEntityResolver *oResolver) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_contentHandler( 
            /* [retval][out] */ IVBSAXContentHandler **oHandler) = 0;
        
        virtual /* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_contentHandler( 
            /* [in] */ IVBSAXContentHandler *oHandler) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_dtdHandler( 
            /* [retval][out] */ IVBSAXDTDHandler **oHandler) = 0;
        
        virtual /* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_dtdHandler( 
            /* [in] */ IVBSAXDTDHandler *oHandler) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_errorHandler( 
            /* [retval][out] */ IVBSAXErrorHandler **oHandler) = 0;
        
        virtual /* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_errorHandler( 
            /* [in] */ IVBSAXErrorHandler *oHandler) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_baseURL( 
            /* [retval][out] */ BSTR *strBaseURL) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_baseURL( 
            /* [in] */ BSTR strBaseURL) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_secureBaseURL( 
            /* [retval][out] */ BSTR *strSecureBaseURL) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_secureBaseURL( 
            /* [in] */ BSTR strSecureBaseURL) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE parse( 
            /* [in] */ VARIANT varInput) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE parseURL( 
            /* [in] */ BSTR strURL) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVBSAXXMLReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVBSAXXMLReader * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVBSAXXMLReader * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVBSAXXMLReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IVBSAXXMLReader * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IVBSAXXMLReader * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IVBSAXXMLReader * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVBSAXXMLReader * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getFeature )( 
            IVBSAXXMLReader * This,
            /* [in] */ BSTR strName,
            /* [retval][out] */ VARIANT_BOOL *fValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *putFeature )( 
            IVBSAXXMLReader * This,
            /* [in] */ BSTR strName,
            /* [in] */ VARIANT_BOOL fValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getProperty )( 
            IVBSAXXMLReader * This,
            /* [in] */ BSTR strName,
            /* [retval][out] */ VARIANT *varValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *putProperty )( 
            IVBSAXXMLReader * This,
            /* [in] */ BSTR strName,
            /* [in] */ VARIANT varValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_entityResolver )( 
            IVBSAXXMLReader * This,
            /* [retval][out] */ IVBSAXEntityResolver **oResolver);
        
        /* [helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE *putref_entityResolver )( 
            IVBSAXXMLReader * This,
            /* [in] */ IVBSAXEntityResolver *oResolver);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_contentHandler )( 
            IVBSAXXMLReader * This,
            /* [retval][out] */ IVBSAXContentHandler **oHandler);
        
        /* [helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE *putref_contentHandler )( 
            IVBSAXXMLReader * This,
            /* [in] */ IVBSAXContentHandler *oHandler);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dtdHandler )( 
            IVBSAXXMLReader * This,
            /* [retval][out] */ IVBSAXDTDHandler **oHandler);
        
        /* [helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE *putref_dtdHandler )( 
            IVBSAXXMLReader * This,
            /* [in] */ IVBSAXDTDHandler *oHandler);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_errorHandler )( 
            IVBSAXXMLReader * This,
            /* [retval][out] */ IVBSAXErrorHandler **oHandler);
        
        /* [helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE *putref_errorHandler )( 
            IVBSAXXMLReader * This,
            /* [in] */ IVBSAXErrorHandler *oHandler);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_baseURL )( 
            IVBSAXXMLReader * This,
            /* [retval][out] */ BSTR *strBaseURL);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_baseURL )( 
            IVBSAXXMLReader * This,
            /* [in] */ BSTR strBaseURL);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_secureBaseURL )( 
            IVBSAXXMLReader * This,
            /* [retval][out] */ BSTR *strSecureBaseURL);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_secureBaseURL )( 
            IVBSAXXMLReader * This,
            /* [in] */ BSTR strSecureBaseURL);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *parse )( 
            IVBSAXXMLReader * This,
            /* [in] */ VARIANT varInput);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *parseURL )( 
            IVBSAXXMLReader * This,
            /* [in] */ BSTR strURL);
        
        END_INTERFACE
    } IVBSAXXMLReaderVtbl;

    interface IVBSAXXMLReader
    {
        CONST_VTBL struct IVBSAXXMLReaderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBSAXXMLReader_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVBSAXXMLReader_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVBSAXXMLReader_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVBSAXXMLReader_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVBSAXXMLReader_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVBSAXXMLReader_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVBSAXXMLReader_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVBSAXXMLReader_getFeature(This,strName,fValue)	\
    (This)->lpVtbl -> getFeature(This,strName,fValue)

#define IVBSAXXMLReader_putFeature(This,strName,fValue)	\
    (This)->lpVtbl -> putFeature(This,strName,fValue)

#define IVBSAXXMLReader_getProperty(This,strName,varValue)	\
    (This)->lpVtbl -> getProperty(This,strName,varValue)

#define IVBSAXXMLReader_putProperty(This,strName,varValue)	\
    (This)->lpVtbl -> putProperty(This,strName,varValue)

#define IVBSAXXMLReader_get_entityResolver(This,oResolver)	\
    (This)->lpVtbl -> get_entityResolver(This,oResolver)

#define IVBSAXXMLReader_putref_entityResolver(This,oResolver)	\
    (This)->lpVtbl -> putref_entityResolver(This,oResolver)

#define IVBSAXXMLReader_get_contentHandler(This,oHandler)	\
    (This)->lpVtbl -> get_contentHandler(This,oHandler)

#define IVBSAXXMLReader_putref_contentHandler(This,oHandler)	\
    (This)->lpVtbl -> putref_contentHandler(This,oHandler)

#define IVBSAXXMLReader_get_dtdHandler(This,oHandler)	\
    (This)->lpVtbl -> get_dtdHandler(This,oHandler)

#define IVBSAXXMLReader_putref_dtdHandler(This,oHandler)	\
    (This)->lpVtbl -> putref_dtdHandler(This,oHandler)

#define IVBSAXXMLReader_get_errorHandler(This,oHandler)	\
    (This)->lpVtbl -> get_errorHandler(This,oHandler)

#define IVBSAXXMLReader_putref_errorHandler(This,oHandler)	\
    (This)->lpVtbl -> putref_errorHandler(This,oHandler)

#define IVBSAXXMLReader_get_baseURL(This,strBaseURL)	\
    (This)->lpVtbl -> get_baseURL(This,strBaseURL)

#define IVBSAXXMLReader_put_baseURL(This,strBaseURL)	\
    (This)->lpVtbl -> put_baseURL(This,strBaseURL)

#define IVBSAXXMLReader_get_secureBaseURL(This,strSecureBaseURL)	\
    (This)->lpVtbl -> get_secureBaseURL(This,strSecureBaseURL)

#define IVBSAXXMLReader_put_secureBaseURL(This,strSecureBaseURL)	\
    (This)->lpVtbl -> put_secureBaseURL(This,strSecureBaseURL)

#define IVBSAXXMLReader_parse(This,varInput)	\
    (This)->lpVtbl -> parse(This,varInput)

#define IVBSAXXMLReader_parseURL(This,strURL)	\
    (This)->lpVtbl -> parseURL(This,strURL)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_getFeature_Proxy( 
    IVBSAXXMLReader * This,
    /* [in] */ BSTR strName,
    /* [retval][out] */ VARIANT_BOOL *fValue);


void __RPC_STUB IVBSAXXMLReader_getFeature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_putFeature_Proxy( 
    IVBSAXXMLReader * This,
    /* [in] */ BSTR strName,
    /* [in] */ VARIANT_BOOL fValue);


void __RPC_STUB IVBSAXXMLReader_putFeature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_getProperty_Proxy( 
    IVBSAXXMLReader * This,
    /* [in] */ BSTR strName,
    /* [retval][out] */ VARIANT *varValue);


void __RPC_STUB IVBSAXXMLReader_getProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_putProperty_Proxy( 
    IVBSAXXMLReader * This,
    /* [in] */ BSTR strName,
    /* [in] */ VARIANT varValue);


void __RPC_STUB IVBSAXXMLReader_putProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_get_entityResolver_Proxy( 
    IVBSAXXMLReader * This,
    /* [retval][out] */ IVBSAXEntityResolver **oResolver);


void __RPC_STUB IVBSAXXMLReader_get_entityResolver_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_putref_entityResolver_Proxy( 
    IVBSAXXMLReader * This,
    /* [in] */ IVBSAXEntityResolver *oResolver);


void __RPC_STUB IVBSAXXMLReader_putref_entityResolver_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_get_contentHandler_Proxy( 
    IVBSAXXMLReader * This,
    /* [retval][out] */ IVBSAXContentHandler **oHandler);


void __RPC_STUB IVBSAXXMLReader_get_contentHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_putref_contentHandler_Proxy( 
    IVBSAXXMLReader * This,
    /* [in] */ IVBSAXContentHandler *oHandler);


void __RPC_STUB IVBSAXXMLReader_putref_contentHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_get_dtdHandler_Proxy( 
    IVBSAXXMLReader * This,
    /* [retval][out] */ IVBSAXDTDHandler **oHandler);


void __RPC_STUB IVBSAXXMLReader_get_dtdHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_putref_dtdHandler_Proxy( 
    IVBSAXXMLReader * This,
    /* [in] */ IVBSAXDTDHandler *oHandler);


void __RPC_STUB IVBSAXXMLReader_putref_dtdHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_get_errorHandler_Proxy( 
    IVBSAXXMLReader * This,
    /* [retval][out] */ IVBSAXErrorHandler **oHandler);


void __RPC_STUB IVBSAXXMLReader_get_errorHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_putref_errorHandler_Proxy( 
    IVBSAXXMLReader * This,
    /* [in] */ IVBSAXErrorHandler *oHandler);


void __RPC_STUB IVBSAXXMLReader_putref_errorHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_get_baseURL_Proxy( 
    IVBSAXXMLReader * This,
    /* [retval][out] */ BSTR *strBaseURL);


void __RPC_STUB IVBSAXXMLReader_get_baseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_put_baseURL_Proxy( 
    IVBSAXXMLReader * This,
    /* [in] */ BSTR strBaseURL);


void __RPC_STUB IVBSAXXMLReader_put_baseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_get_secureBaseURL_Proxy( 
    IVBSAXXMLReader * This,
    /* [retval][out] */ BSTR *strSecureBaseURL);


void __RPC_STUB IVBSAXXMLReader_get_secureBaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_put_secureBaseURL_Proxy( 
    IVBSAXXMLReader * This,
    /* [in] */ BSTR strSecureBaseURL);


void __RPC_STUB IVBSAXXMLReader_put_secureBaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_parse_Proxy( 
    IVBSAXXMLReader * This,
    /* [in] */ VARIANT varInput);


void __RPC_STUB IVBSAXXMLReader_parse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_parseURL_Proxy( 
    IVBSAXXMLReader * This,
    /* [in] */ BSTR strURL);


void __RPC_STUB IVBSAXXMLReader_parseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVBSAXXMLReader_INTERFACE_DEFINED__ */


#ifndef __IVBSAXXMLFilter_INTERFACE_DEFINED__
#define __IVBSAXXMLFilter_INTERFACE_DEFINED__

/* interface IVBSAXXMLFilter */
/* [unique][helpstring][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IVBSAXXMLFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1299eb1b-5b88-433e-82de-82ca75ad4e04")
    IVBSAXXMLFilter : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_parent( 
            /* [retval][out] */ IVBSAXXMLReader **oReader) = 0;
        
        virtual /* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_parent( 
            /* [in] */ IVBSAXXMLReader *oReader) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVBSAXXMLFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVBSAXXMLFilter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVBSAXXMLFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVBSAXXMLFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IVBSAXXMLFilter * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IVBSAXXMLFilter * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IVBSAXXMLFilter * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVBSAXXMLFilter * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parent )( 
            IVBSAXXMLFilter * This,
            /* [retval][out] */ IVBSAXXMLReader **oReader);
        
        /* [helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE *putref_parent )( 
            IVBSAXXMLFilter * This,
            /* [in] */ IVBSAXXMLReader *oReader);
        
        END_INTERFACE
    } IVBSAXXMLFilterVtbl;

    interface IVBSAXXMLFilter
    {
        CONST_VTBL struct IVBSAXXMLFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBSAXXMLFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVBSAXXMLFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVBSAXXMLFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVBSAXXMLFilter_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVBSAXXMLFilter_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVBSAXXMLFilter_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVBSAXXMLFilter_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVBSAXXMLFilter_get_parent(This,oReader)	\
    (This)->lpVtbl -> get_parent(This,oReader)

#define IVBSAXXMLFilter_putref_parent(This,oReader)	\
    (This)->lpVtbl -> putref_parent(This,oReader)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLFilter_get_parent_Proxy( 
    IVBSAXXMLFilter * This,
    /* [retval][out] */ IVBSAXXMLReader **oReader);


void __RPC_STUB IVBSAXXMLFilter_get_parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLFilter_putref_parent_Proxy( 
    IVBSAXXMLFilter * This,
    /* [in] */ IVBSAXXMLReader *oReader);


void __RPC_STUB IVBSAXXMLFilter_putref_parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVBSAXXMLFilter_INTERFACE_DEFINED__ */


#ifndef __IVBSAXLocator_INTERFACE_DEFINED__
#define __IVBSAXLocator_INTERFACE_DEFINED__

/* interface IVBSAXLocator */
/* [unique][helpstring][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IVBSAXLocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("796e7ac5-5aa2-4eff-acad-3faaf01a3288")
    IVBSAXLocator : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_columnNumber( 
            /* [retval][out] */ int *nColumn) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_lineNumber( 
            /* [retval][out] */ int *nLine) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_publicId( 
            /* [retval][out] */ BSTR *strPublicId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_systemId( 
            /* [retval][out] */ BSTR *strSystemId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVBSAXLocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVBSAXLocator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVBSAXLocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVBSAXLocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IVBSAXLocator * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IVBSAXLocator * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IVBSAXLocator * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVBSAXLocator * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_columnNumber )( 
            IVBSAXLocator * This,
            /* [retval][out] */ int *nColumn);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lineNumber )( 
            IVBSAXLocator * This,
            /* [retval][out] */ int *nLine);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_publicId )( 
            IVBSAXLocator * This,
            /* [retval][out] */ BSTR *strPublicId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_systemId )( 
            IVBSAXLocator * This,
            /* [retval][out] */ BSTR *strSystemId);
        
        END_INTERFACE
    } IVBSAXLocatorVtbl;

    interface IVBSAXLocator
    {
        CONST_VTBL struct IVBSAXLocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBSAXLocator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVBSAXLocator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVBSAXLocator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVBSAXLocator_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVBSAXLocator_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVBSAXLocator_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVBSAXLocator_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVBSAXLocator_get_columnNumber(This,nColumn)	\
    (This)->lpVtbl -> get_columnNumber(This,nColumn)

#define IVBSAXLocator_get_lineNumber(This,nLine)	\
    (This)->lpVtbl -> get_lineNumber(This,nLine)

#define IVBSAXLocator_get_publicId(This,strPublicId)	\
    (This)->lpVtbl -> get_publicId(This,strPublicId)

#define IVBSAXLocator_get_systemId(This,strSystemId)	\
    (This)->lpVtbl -> get_systemId(This,strSystemId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IVBSAXLocator_get_columnNumber_Proxy( 
    IVBSAXLocator * This,
    /* [retval][out] */ int *nColumn);


void __RPC_STUB IVBSAXLocator_get_columnNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IVBSAXLocator_get_lineNumber_Proxy( 
    IVBSAXLocator * This,
    /* [retval][out] */ int *nLine);


void __RPC_STUB IVBSAXLocator_get_lineNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IVBSAXLocator_get_publicId_Proxy( 
    IVBSAXLocator * This,
    /* [retval][out] */ BSTR *strPublicId);


void __RPC_STUB IVBSAXLocator_get_publicId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IVBSAXLocator_get_systemId_Proxy( 
    IVBSAXLocator * This,
    /* [retval][out] */ BSTR *strSystemId);


void __RPC_STUB IVBSAXLocator_get_systemId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVBSAXLocator_INTERFACE_DEFINED__ */


#ifndef __IVBSAXEntityResolver_INTERFACE_DEFINED__
#define __IVBSAXEntityResolver_INTERFACE_DEFINED__

/* interface IVBSAXEntityResolver */
/* [unique][helpstring][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IVBSAXEntityResolver;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0c05d096-f45b-4aca-ad1a-aa0bc25518dc")
    IVBSAXEntityResolver : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE resolveEntity( 
            /* [out][in] */ BSTR *strPublicId,
            /* [out][in] */ BSTR *strSystemId,
            /* [retval][out] */ VARIANT *varInput) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVBSAXEntityResolverVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVBSAXEntityResolver * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVBSAXEntityResolver * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVBSAXEntityResolver * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IVBSAXEntityResolver * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IVBSAXEntityResolver * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IVBSAXEntityResolver * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVBSAXEntityResolver * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *resolveEntity )( 
            IVBSAXEntityResolver * This,
            /* [out][in] */ BSTR *strPublicId,
            /* [out][in] */ BSTR *strSystemId,
            /* [retval][out] */ VARIANT *varInput);
        
        END_INTERFACE
    } IVBSAXEntityResolverVtbl;

    interface IVBSAXEntityResolver
    {
        CONST_VTBL struct IVBSAXEntityResolverVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBSAXEntityResolver_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVBSAXEntityResolver_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVBSAXEntityResolver_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVBSAXEntityResolver_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVBSAXEntityResolver_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVBSAXEntityResolver_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVBSAXEntityResolver_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVBSAXEntityResolver_resolveEntity(This,strPublicId,strSystemId,varInput)	\
    (This)->lpVtbl -> resolveEntity(This,strPublicId,strSystemId,varInput)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXEntityResolver_resolveEntity_Proxy( 
    IVBSAXEntityResolver * This,
    /* [out][in] */ BSTR *strPublicId,
    /* [out][in] */ BSTR *strSystemId,
    /* [retval][out] */ VARIANT *varInput);


void __RPC_STUB IVBSAXEntityResolver_resolveEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVBSAXEntityResolver_INTERFACE_DEFINED__ */


#ifndef __IVBSAXContentHandler_INTERFACE_DEFINED__
#define __IVBSAXContentHandler_INTERFACE_DEFINED__

/* interface IVBSAXContentHandler */
/* [unique][helpstring][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IVBSAXContentHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2ed7290a-4dd5-4b46-bb26-4e4155e77faa")
    IVBSAXContentHandler : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_documentLocator( 
            /* [in] */ IVBSAXLocator *oLocator) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE startDocument( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE endDocument( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE startPrefixMapping( 
            /* [out][in] */ BSTR *strPrefix,
            /* [out][in] */ BSTR *strURI) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE endPrefixMapping( 
            /* [out][in] */ BSTR *strPrefix) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE startElement( 
            /* [out][in] */ BSTR *strNamespaceURI,
            /* [out][in] */ BSTR *strLocalName,
            /* [out][in] */ BSTR *strQName,
            /* [in] */ IVBSAXAttributes *oAttributes) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE endElement( 
            /* [out][in] */ BSTR *strNamespaceURI,
            /* [out][in] */ BSTR *strLocalName,
            /* [out][in] */ BSTR *strQName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE characters( 
            /* [out][in] */ BSTR *strChars) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ignorableWhitespace( 
            /* [out][in] */ BSTR *strChars) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE processingInstruction( 
            /* [out][in] */ BSTR *strTarget,
            /* [out][in] */ BSTR *strData) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE skippedEntity( 
            /* [out][in] */ BSTR *strName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVBSAXContentHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVBSAXContentHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVBSAXContentHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVBSAXContentHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IVBSAXContentHandler * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IVBSAXContentHandler * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IVBSAXContentHandler * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVBSAXContentHandler * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE *putref_documentLocator )( 
            IVBSAXContentHandler * This,
            /* [in] */ IVBSAXLocator *oLocator);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *startDocument )( 
            IVBSAXContentHandler * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *endDocument )( 
            IVBSAXContentHandler * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *startPrefixMapping )( 
            IVBSAXContentHandler * This,
            /* [out][in] */ BSTR *strPrefix,
            /* [out][in] */ BSTR *strURI);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *endPrefixMapping )( 
            IVBSAXContentHandler * This,
            /* [out][in] */ BSTR *strPrefix);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *startElement )( 
            IVBSAXContentHandler * This,
            /* [out][in] */ BSTR *strNamespaceURI,
            /* [out][in] */ BSTR *strLocalName,
            /* [out][in] */ BSTR *strQName,
            /* [in] */ IVBSAXAttributes *oAttributes);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *endElement )( 
            IVBSAXContentHandler * This,
            /* [out][in] */ BSTR *strNamespaceURI,
            /* [out][in] */ BSTR *strLocalName,
            /* [out][in] */ BSTR *strQName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *characters )( 
            IVBSAXContentHandler * This,
            /* [out][in] */ BSTR *strChars);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ignorableWhitespace )( 
            IVBSAXContentHandler * This,
            /* [out][in] */ BSTR *strChars);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *processingInstruction )( 
            IVBSAXContentHandler * This,
            /* [out][in] */ BSTR *strTarget,
            /* [out][in] */ BSTR *strData);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *skippedEntity )( 
            IVBSAXContentHandler * This,
            /* [out][in] */ BSTR *strName);
        
        END_INTERFACE
    } IVBSAXContentHandlerVtbl;

    interface IVBSAXContentHandler
    {
        CONST_VTBL struct IVBSAXContentHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBSAXContentHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVBSAXContentHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVBSAXContentHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVBSAXContentHandler_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVBSAXContentHandler_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVBSAXContentHandler_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVBSAXContentHandler_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVBSAXContentHandler_putref_documentLocator(This,oLocator)	\
    (This)->lpVtbl -> putref_documentLocator(This,oLocator)

#define IVBSAXContentHandler_startDocument(This)	\
    (This)->lpVtbl -> startDocument(This)

#define IVBSAXContentHandler_endDocument(This)	\
    (This)->lpVtbl -> endDocument(This)

#define IVBSAXContentHandler_startPrefixMapping(This,strPrefix,strURI)	\
    (This)->lpVtbl -> startPrefixMapping(This,strPrefix,strURI)

#define IVBSAXContentHandler_endPrefixMapping(This,strPrefix)	\
    (This)->lpVtbl -> endPrefixMapping(This,strPrefix)

#define IVBSAXContentHandler_startElement(This,strNamespaceURI,strLocalName,strQName,oAttributes)	\
    (This)->lpVtbl -> startElement(This,strNamespaceURI,strLocalName,strQName,oAttributes)

#define IVBSAXContentHandler_endElement(This,strNamespaceURI,strLocalName,strQName)	\
    (This)->lpVtbl -> endElement(This,strNamespaceURI,strLocalName,strQName)

#define IVBSAXContentHandler_characters(This,strChars)	\
    (This)->lpVtbl -> characters(This,strChars)

#define IVBSAXContentHandler_ignorableWhitespace(This,strChars)	\
    (This)->lpVtbl -> ignorableWhitespace(This,strChars)

#define IVBSAXContentHandler_processingInstruction(This,strTarget,strData)	\
    (This)->lpVtbl -> processingInstruction(This,strTarget,strData)

#define IVBSAXContentHandler_skippedEntity(This,strName)	\
    (This)->lpVtbl -> skippedEntity(This,strName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IVBSAXContentHandler_putref_documentLocator_Proxy( 
    IVBSAXContentHandler * This,
    /* [in] */ IVBSAXLocator *oLocator);


void __RPC_STUB IVBSAXContentHandler_putref_documentLocator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXContentHandler_startDocument_Proxy( 
    IVBSAXContentHandler * This);


void __RPC_STUB IVBSAXContentHandler_startDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXContentHandler_endDocument_Proxy( 
    IVBSAXContentHandler * This);


void __RPC_STUB IVBSAXContentHandler_endDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXContentHandler_startPrefixMapping_Proxy( 
    IVBSAXContentHandler * This,
    /* [out][in] */ BSTR *strPrefix,
    /* [out][in] */ BSTR *strURI);


void __RPC_STUB IVBSAXContentHandler_startPrefixMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXContentHandler_endPrefixMapping_Proxy( 
    IVBSAXContentHandler * This,
    /* [out][in] */ BSTR *strPrefix);


void __RPC_STUB IVBSAXContentHandler_endPrefixMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXContentHandler_startElement_Proxy( 
    IVBSAXContentHandler * This,
    /* [out][in] */ BSTR *strNamespaceURI,
    /* [out][in] */ BSTR *strLocalName,
    /* [out][in] */ BSTR *strQName,
    /* [in] */ IVBSAXAttributes *oAttributes);


void __RPC_STUB IVBSAXContentHandler_startElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXContentHandler_endElement_Proxy( 
    IVBSAXContentHandler * This,
    /* [out][in] */ BSTR *strNamespaceURI,
    /* [out][in] */ BSTR *strLocalName,
    /* [out][in] */ BSTR *strQName);


void __RPC_STUB IVBSAXContentHandler_endElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXContentHandler_characters_Proxy( 
    IVBSAXContentHandler * This,
    /* [out][in] */ BSTR *strChars);


void __RPC_STUB IVBSAXContentHandler_characters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXContentHandler_ignorableWhitespace_Proxy( 
    IVBSAXContentHandler * This,
    /* [out][in] */ BSTR *strChars);


void __RPC_STUB IVBSAXContentHandler_ignorableWhitespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXContentHandler_processingInstruction_Proxy( 
    IVBSAXContentHandler * This,
    /* [out][in] */ BSTR *strTarget,
    /* [out][in] */ BSTR *strData);


void __RPC_STUB IVBSAXContentHandler_processingInstruction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXContentHandler_skippedEntity_Proxy( 
    IVBSAXContentHandler * This,
    /* [out][in] */ BSTR *strName);


void __RPC_STUB IVBSAXContentHandler_skippedEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVBSAXContentHandler_INTERFACE_DEFINED__ */


#ifndef __IVBSAXDTDHandler_INTERFACE_DEFINED__
#define __IVBSAXDTDHandler_INTERFACE_DEFINED__

/* interface IVBSAXDTDHandler */
/* [unique][helpstring][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IVBSAXDTDHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("24fb3297-302d-4620-ba39-3a732d850558")
    IVBSAXDTDHandler : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE notationDecl( 
            /* [out][in] */ BSTR *strName,
            /* [out][in] */ BSTR *strPublicId,
            /* [out][in] */ BSTR *strSystemId) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE unparsedEntityDecl( 
            /* [out][in] */ BSTR *strName,
            /* [out][in] */ BSTR *strPublicId,
            /* [out][in] */ BSTR *strSystemId,
            /* [out][in] */ BSTR *strNotationName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVBSAXDTDHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVBSAXDTDHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVBSAXDTDHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVBSAXDTDHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IVBSAXDTDHandler * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IVBSAXDTDHandler * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IVBSAXDTDHandler * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVBSAXDTDHandler * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *notationDecl )( 
            IVBSAXDTDHandler * This,
            /* [out][in] */ BSTR *strName,
            /* [out][in] */ BSTR *strPublicId,
            /* [out][in] */ BSTR *strSystemId);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *unparsedEntityDecl )( 
            IVBSAXDTDHandler * This,
            /* [out][in] */ BSTR *strName,
            /* [out][in] */ BSTR *strPublicId,
            /* [out][in] */ BSTR *strSystemId,
            /* [out][in] */ BSTR *strNotationName);
        
        END_INTERFACE
    } IVBSAXDTDHandlerVtbl;

    interface IVBSAXDTDHandler
    {
        CONST_VTBL struct IVBSAXDTDHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBSAXDTDHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVBSAXDTDHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVBSAXDTDHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVBSAXDTDHandler_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVBSAXDTDHandler_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVBSAXDTDHandler_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVBSAXDTDHandler_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVBSAXDTDHandler_notationDecl(This,strName,strPublicId,strSystemId)	\
    (This)->lpVtbl -> notationDecl(This,strName,strPublicId,strSystemId)

#define IVBSAXDTDHandler_unparsedEntityDecl(This,strName,strPublicId,strSystemId,strNotationName)	\
    (This)->lpVtbl -> unparsedEntityDecl(This,strName,strPublicId,strSystemId,strNotationName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXDTDHandler_notationDecl_Proxy( 
    IVBSAXDTDHandler * This,
    /* [out][in] */ BSTR *strName,
    /* [out][in] */ BSTR *strPublicId,
    /* [out][in] */ BSTR *strSystemId);


void __RPC_STUB IVBSAXDTDHandler_notationDecl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXDTDHandler_unparsedEntityDecl_Proxy( 
    IVBSAXDTDHandler * This,
    /* [out][in] */ BSTR *strName,
    /* [out][in] */ BSTR *strPublicId,
    /* [out][in] */ BSTR *strSystemId,
    /* [out][in] */ BSTR *strNotationName);


void __RPC_STUB IVBSAXDTDHandler_unparsedEntityDecl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVBSAXDTDHandler_INTERFACE_DEFINED__ */


#ifndef __IVBSAXErrorHandler_INTERFACE_DEFINED__
#define __IVBSAXErrorHandler_INTERFACE_DEFINED__

/* interface IVBSAXErrorHandler */
/* [unique][helpstring][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IVBSAXErrorHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d963d3fe-173c-4862-9095-b92f66995f52")
    IVBSAXErrorHandler : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE error( 
            /* [in] */ IVBSAXLocator *oLocator,
            /* [out][in] */ BSTR *strErrorMessage,
            /* [in] */ long nErrorCode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE fatalError( 
            /* [in] */ IVBSAXLocator *oLocator,
            /* [out][in] */ BSTR *strErrorMessage,
            /* [in] */ long nErrorCode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ignorableWarning( 
            /* [in] */ IVBSAXLocator *oLocator,
            /* [out][in] */ BSTR *strErrorMessage,
            /* [in] */ long nErrorCode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVBSAXErrorHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVBSAXErrorHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVBSAXErrorHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVBSAXErrorHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IVBSAXErrorHandler * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IVBSAXErrorHandler * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IVBSAXErrorHandler * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVBSAXErrorHandler * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *error )( 
            IVBSAXErrorHandler * This,
            /* [in] */ IVBSAXLocator *oLocator,
            /* [out][in] */ BSTR *strErrorMessage,
            /* [in] */ long nErrorCode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *fatalError )( 
            IVBSAXErrorHandler * This,
            /* [in] */ IVBSAXLocator *oLocator,
            /* [out][in] */ BSTR *strErrorMessage,
            /* [in] */ long nErrorCode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ignorableWarning )( 
            IVBSAXErrorHandler * This,
            /* [in] */ IVBSAXLocator *oLocator,
            /* [out][in] */ BSTR *strErrorMessage,
            /* [in] */ long nErrorCode);
        
        END_INTERFACE
    } IVBSAXErrorHandlerVtbl;

    interface IVBSAXErrorHandler
    {
        CONST_VTBL struct IVBSAXErrorHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBSAXErrorHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVBSAXErrorHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVBSAXErrorHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVBSAXErrorHandler_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVBSAXErrorHandler_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVBSAXErrorHandler_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVBSAXErrorHandler_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVBSAXErrorHandler_error(This,oLocator,strErrorMessage,nErrorCode)	\
    (This)->lpVtbl -> error(This,oLocator,strErrorMessage,nErrorCode)

#define IVBSAXErrorHandler_fatalError(This,oLocator,strErrorMessage,nErrorCode)	\
    (This)->lpVtbl -> fatalError(This,oLocator,strErrorMessage,nErrorCode)

#define IVBSAXErrorHandler_ignorableWarning(This,oLocator,strErrorMessage,nErrorCode)	\
    (This)->lpVtbl -> ignorableWarning(This,oLocator,strErrorMessage,nErrorCode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXErrorHandler_error_Proxy( 
    IVBSAXErrorHandler * This,
    /* [in] */ IVBSAXLocator *oLocator,
    /* [out][in] */ BSTR *strErrorMessage,
    /* [in] */ long nErrorCode);


void __RPC_STUB IVBSAXErrorHandler_error_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXErrorHandler_fatalError_Proxy( 
    IVBSAXErrorHandler * This,
    /* [in] */ IVBSAXLocator *oLocator,
    /* [out][in] */ BSTR *strErrorMessage,
    /* [in] */ long nErrorCode);


void __RPC_STUB IVBSAXErrorHandler_fatalError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXErrorHandler_ignorableWarning_Proxy( 
    IVBSAXErrorHandler * This,
    /* [in] */ IVBSAXLocator *oLocator,
    /* [out][in] */ BSTR *strErrorMessage,
    /* [in] */ long nErrorCode);


void __RPC_STUB IVBSAXErrorHandler_ignorableWarning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVBSAXErrorHandler_INTERFACE_DEFINED__ */


#ifndef __IVBSAXLexicalHandler_INTERFACE_DEFINED__
#define __IVBSAXLexicalHandler_INTERFACE_DEFINED__

/* interface IVBSAXLexicalHandler */
/* [unique][helpstring][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IVBSAXLexicalHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("032aac35-8c0e-4d9d-979f-e3b702935576")
    IVBSAXLexicalHandler : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE startDTD( 
            /* [out][in] */ BSTR *strName,
            /* [out][in] */ BSTR *strPublicId,
            /* [out][in] */ BSTR *strSystemId) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE endDTD( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE startEntity( 
            /* [out][in] */ BSTR *strName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE endEntity( 
            /* [out][in] */ BSTR *strName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE startCDATA( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE endCDATA( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE comment( 
            /* [out][in] */ BSTR *strChars) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVBSAXLexicalHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVBSAXLexicalHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVBSAXLexicalHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVBSAXLexicalHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IVBSAXLexicalHandler * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IVBSAXLexicalHandler * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IVBSAXLexicalHandler * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVBSAXLexicalHandler * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *startDTD )( 
            IVBSAXLexicalHandler * This,
            /* [out][in] */ BSTR *strName,
            /* [out][in] */ BSTR *strPublicId,
            /* [out][in] */ BSTR *strSystemId);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *endDTD )( 
            IVBSAXLexicalHandler * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *startEntity )( 
            IVBSAXLexicalHandler * This,
            /* [out][in] */ BSTR *strName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *endEntity )( 
            IVBSAXLexicalHandler * This,
            /* [out][in] */ BSTR *strName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *startCDATA )( 
            IVBSAXLexicalHandler * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *endCDATA )( 
            IVBSAXLexicalHandler * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *comment )( 
            IVBSAXLexicalHandler * This,
            /* [out][in] */ BSTR *strChars);
        
        END_INTERFACE
    } IVBSAXLexicalHandlerVtbl;

    interface IVBSAXLexicalHandler
    {
        CONST_VTBL struct IVBSAXLexicalHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBSAXLexicalHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVBSAXLexicalHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVBSAXLexicalHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVBSAXLexicalHandler_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVBSAXLexicalHandler_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVBSAXLexicalHandler_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVBSAXLexicalHandler_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVBSAXLexicalHandler_startDTD(This,strName,strPublicId,strSystemId)	\
    (This)->lpVtbl -> startDTD(This,strName,strPublicId,strSystemId)

#define IVBSAXLexicalHandler_endDTD(This)	\
    (This)->lpVtbl -> endDTD(This)

#define IVBSAXLexicalHandler_startEntity(This,strName)	\
    (This)->lpVtbl -> startEntity(This,strName)

#define IVBSAXLexicalHandler_endEntity(This,strName)	\
    (This)->lpVtbl -> endEntity(This,strName)

#define IVBSAXLexicalHandler_startCDATA(This)	\
    (This)->lpVtbl -> startCDATA(This)

#define IVBSAXLexicalHandler_endCDATA(This)	\
    (This)->lpVtbl -> endCDATA(This)

#define IVBSAXLexicalHandler_comment(This,strChars)	\
    (This)->lpVtbl -> comment(This,strChars)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXLexicalHandler_startDTD_Proxy( 
    IVBSAXLexicalHandler * This,
    /* [out][in] */ BSTR *strName,
    /* [out][in] */ BSTR *strPublicId,
    /* [out][in] */ BSTR *strSystemId);


void __RPC_STUB IVBSAXLexicalHandler_startDTD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXLexicalHandler_endDTD_Proxy( 
    IVBSAXLexicalHandler * This);


void __RPC_STUB IVBSAXLexicalHandler_endDTD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXLexicalHandler_startEntity_Proxy( 
    IVBSAXLexicalHandler * This,
    /* [out][in] */ BSTR *strName);


void __RPC_STUB IVBSAXLexicalHandler_startEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXLexicalHandler_endEntity_Proxy( 
    IVBSAXLexicalHandler * This,
    /* [out][in] */ BSTR *strName);


void __RPC_STUB IVBSAXLexicalHandler_endEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXLexicalHandler_startCDATA_Proxy( 
    IVBSAXLexicalHandler * This);


void __RPC_STUB IVBSAXLexicalHandler_startCDATA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXLexicalHandler_endCDATA_Proxy( 
    IVBSAXLexicalHandler * This);


void __RPC_STUB IVBSAXLexicalHandler_endCDATA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXLexicalHandler_comment_Proxy( 
    IVBSAXLexicalHandler * This,
    /* [out][in] */ BSTR *strChars);


void __RPC_STUB IVBSAXLexicalHandler_comment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVBSAXLexicalHandler_INTERFACE_DEFINED__ */


#ifndef __IVBSAXDeclHandler_INTERFACE_DEFINED__
#define __IVBSAXDeclHandler_INTERFACE_DEFINED__

/* interface IVBSAXDeclHandler */
/* [unique][helpstring][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IVBSAXDeclHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e8917260-7579-4be1-b5dd-7afbfa6f077b")
    IVBSAXDeclHandler : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE elementDecl( 
            /* [out][in] */ BSTR *strName,
            /* [out][in] */ BSTR *strModel) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE attributeDecl( 
            /* [out][in] */ BSTR *strElementName,
            /* [out][in] */ BSTR *strAttributeName,
            /* [out][in] */ BSTR *strType,
            /* [out][in] */ BSTR *strValueDefault,
            /* [out][in] */ BSTR *strValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE internalEntityDecl( 
            /* [out][in] */ BSTR *strName,
            /* [out][in] */ BSTR *strValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE externalEntityDecl( 
            /* [out][in] */ BSTR *strName,
            /* [out][in] */ BSTR *strPublicId,
            /* [out][in] */ BSTR *strSystemId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVBSAXDeclHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVBSAXDeclHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVBSAXDeclHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVBSAXDeclHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IVBSAXDeclHandler * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IVBSAXDeclHandler * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IVBSAXDeclHandler * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVBSAXDeclHandler * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *elementDecl )( 
            IVBSAXDeclHandler * This,
            /* [out][in] */ BSTR *strName,
            /* [out][in] */ BSTR *strModel);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *attributeDecl )( 
            IVBSAXDeclHandler * This,
            /* [out][in] */ BSTR *strElementName,
            /* [out][in] */ BSTR *strAttributeName,
            /* [out][in] */ BSTR *strType,
            /* [out][in] */ BSTR *strValueDefault,
            /* [out][in] */ BSTR *strValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *internalEntityDecl )( 
            IVBSAXDeclHandler * This,
            /* [out][in] */ BSTR *strName,
            /* [out][in] */ BSTR *strValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *externalEntityDecl )( 
            IVBSAXDeclHandler * This,
            /* [out][in] */ BSTR *strName,
            /* [out][in] */ BSTR *strPublicId,
            /* [out][in] */ BSTR *strSystemId);
        
        END_INTERFACE
    } IVBSAXDeclHandlerVtbl;

    interface IVBSAXDeclHandler
    {
        CONST_VTBL struct IVBSAXDeclHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBSAXDeclHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVBSAXDeclHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVBSAXDeclHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVBSAXDeclHandler_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVBSAXDeclHandler_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVBSAXDeclHandler_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVBSAXDeclHandler_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVBSAXDeclHandler_elementDecl(This,strName,strModel)	\
    (This)->lpVtbl -> elementDecl(This,strName,strModel)

#define IVBSAXDeclHandler_attributeDecl(This,strElementName,strAttributeName,strType,strValueDefault,strValue)	\
    (This)->lpVtbl -> attributeDecl(This,strElementName,strAttributeName,strType,strValueDefault,strValue)

#define IVBSAXDeclHandler_internalEntityDecl(This,strName,strValue)	\
    (This)->lpVtbl -> internalEntityDecl(This,strName,strValue)

#define IVBSAXDeclHandler_externalEntityDecl(This,strName,strPublicId,strSystemId)	\
    (This)->lpVtbl -> externalEntityDecl(This,strName,strPublicId,strSystemId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXDeclHandler_elementDecl_Proxy( 
    IVBSAXDeclHandler * This,
    /* [out][in] */ BSTR *strName,
    /* [out][in] */ BSTR *strModel);


void __RPC_STUB IVBSAXDeclHandler_elementDecl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXDeclHandler_attributeDecl_Proxy( 
    IVBSAXDeclHandler * This,
    /* [out][in] */ BSTR *strElementName,
    /* [out][in] */ BSTR *strAttributeName,
    /* [out][in] */ BSTR *strType,
    /* [out][in] */ BSTR *strValueDefault,
    /* [out][in] */ BSTR *strValue);


void __RPC_STUB IVBSAXDeclHandler_attributeDecl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXDeclHandler_internalEntityDecl_Proxy( 
    IVBSAXDeclHandler * This,
    /* [out][in] */ BSTR *strName,
    /* [out][in] */ BSTR *strValue);


void __RPC_STUB IVBSAXDeclHandler_internalEntityDecl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXDeclHandler_externalEntityDecl_Proxy( 
    IVBSAXDeclHandler * This,
    /* [out][in] */ BSTR *strName,
    /* [out][in] */ BSTR *strPublicId,
    /* [out][in] */ BSTR *strSystemId);


void __RPC_STUB IVBSAXDeclHandler_externalEntityDecl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVBSAXDeclHandler_INTERFACE_DEFINED__ */


#ifndef __IVBSAXAttributes_INTERFACE_DEFINED__
#define __IVBSAXAttributes_INTERFACE_DEFINED__

/* interface IVBSAXAttributes */
/* [unique][helpstring][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IVBSAXAttributes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("10dc0586-132b-4cac-8bb3-db00ac8b7ee0")
    IVBSAXAttributes : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ int *nLength) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getURI( 
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR *strURI) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getLocalName( 
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR *strLocalName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getQName( 
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR *strQName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getIndexFromName( 
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [retval][out] */ int *nIndex) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getIndexFromQName( 
            /* [in] */ BSTR strQName,
            /* [retval][out] */ int *nIndex) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getType( 
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR *strType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getTypeFromName( 
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [retval][out] */ BSTR *strType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getTypeFromQName( 
            /* [in] */ BSTR strQName,
            /* [retval][out] */ BSTR *strType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getValue( 
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR *strValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getValueFromName( 
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [retval][out] */ BSTR *strValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getValueFromQName( 
            /* [in] */ BSTR strQName,
            /* [retval][out] */ BSTR *strValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVBSAXAttributesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVBSAXAttributes * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVBSAXAttributes * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVBSAXAttributes * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IVBSAXAttributes * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IVBSAXAttributes * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IVBSAXAttributes * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVBSAXAttributes * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IVBSAXAttributes * This,
            /* [retval][out] */ int *nLength);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getURI )( 
            IVBSAXAttributes * This,
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR *strURI);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getLocalName )( 
            IVBSAXAttributes * This,
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR *strLocalName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getQName )( 
            IVBSAXAttributes * This,
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR *strQName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getIndexFromName )( 
            IVBSAXAttributes * This,
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [retval][out] */ int *nIndex);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getIndexFromQName )( 
            IVBSAXAttributes * This,
            /* [in] */ BSTR strQName,
            /* [retval][out] */ int *nIndex);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getType )( 
            IVBSAXAttributes * This,
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR *strType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getTypeFromName )( 
            IVBSAXAttributes * This,
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [retval][out] */ BSTR *strType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getTypeFromQName )( 
            IVBSAXAttributes * This,
            /* [in] */ BSTR strQName,
            /* [retval][out] */ BSTR *strType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getValue )( 
            IVBSAXAttributes * This,
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR *strValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getValueFromName )( 
            IVBSAXAttributes * This,
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [retval][out] */ BSTR *strValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getValueFromQName )( 
            IVBSAXAttributes * This,
            /* [in] */ BSTR strQName,
            /* [retval][out] */ BSTR *strValue);
        
        END_INTERFACE
    } IVBSAXAttributesVtbl;

    interface IVBSAXAttributes
    {
        CONST_VTBL struct IVBSAXAttributesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBSAXAttributes_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVBSAXAttributes_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVBSAXAttributes_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVBSAXAttributes_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVBSAXAttributes_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVBSAXAttributes_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVBSAXAttributes_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVBSAXAttributes_get_length(This,nLength)	\
    (This)->lpVtbl -> get_length(This,nLength)

#define IVBSAXAttributes_getURI(This,nIndex,strURI)	\
    (This)->lpVtbl -> getURI(This,nIndex,strURI)

#define IVBSAXAttributes_getLocalName(This,nIndex,strLocalName)	\
    (This)->lpVtbl -> getLocalName(This,nIndex,strLocalName)

#define IVBSAXAttributes_getQName(This,nIndex,strQName)	\
    (This)->lpVtbl -> getQName(This,nIndex,strQName)

#define IVBSAXAttributes_getIndexFromName(This,strURI,strLocalName,nIndex)	\
    (This)->lpVtbl -> getIndexFromName(This,strURI,strLocalName,nIndex)

#define IVBSAXAttributes_getIndexFromQName(This,strQName,nIndex)	\
    (This)->lpVtbl -> getIndexFromQName(This,strQName,nIndex)

#define IVBSAXAttributes_getType(This,nIndex,strType)	\
    (This)->lpVtbl -> getType(This,nIndex,strType)

#define IVBSAXAttributes_getTypeFromName(This,strURI,strLocalName,strType)	\
    (This)->lpVtbl -> getTypeFromName(This,strURI,strLocalName,strType)

#define IVBSAXAttributes_getTypeFromQName(This,strQName,strType)	\
    (This)->lpVtbl -> getTypeFromQName(This,strQName,strType)

#define IVBSAXAttributes_getValue(This,nIndex,strValue)	\
    (This)->lpVtbl -> getValue(This,nIndex,strValue)

#define IVBSAXAttributes_getValueFromName(This,strURI,strLocalName,strValue)	\
    (This)->lpVtbl -> getValueFromName(This,strURI,strLocalName,strValue)

#define IVBSAXAttributes_getValueFromQName(This,strQName,strValue)	\
    (This)->lpVtbl -> getValueFromQName(This,strQName,strValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IVBSAXAttributes_get_length_Proxy( 
    IVBSAXAttributes * This,
    /* [retval][out] */ int *nLength);


void __RPC_STUB IVBSAXAttributes_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXAttributes_getURI_Proxy( 
    IVBSAXAttributes * This,
    /* [in] */ int nIndex,
    /* [retval][out] */ BSTR *strURI);


void __RPC_STUB IVBSAXAttributes_getURI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXAttributes_getLocalName_Proxy( 
    IVBSAXAttributes * This,
    /* [in] */ int nIndex,
    /* [retval][out] */ BSTR *strLocalName);


void __RPC_STUB IVBSAXAttributes_getLocalName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXAttributes_getQName_Proxy( 
    IVBSAXAttributes * This,
    /* [in] */ int nIndex,
    /* [retval][out] */ BSTR *strQName);


void __RPC_STUB IVBSAXAttributes_getQName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXAttributes_getIndexFromName_Proxy( 
    IVBSAXAttributes * This,
    /* [in] */ BSTR strURI,
    /* [in] */ BSTR strLocalName,
    /* [retval][out] */ int *nIndex);


void __RPC_STUB IVBSAXAttributes_getIndexFromName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXAttributes_getIndexFromQName_Proxy( 
    IVBSAXAttributes * This,
    /* [in] */ BSTR strQName,
    /* [retval][out] */ int *nIndex);


void __RPC_STUB IVBSAXAttributes_getIndexFromQName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXAttributes_getType_Proxy( 
    IVBSAXAttributes * This,
    /* [in] */ int nIndex,
    /* [retval][out] */ BSTR *strType);


void __RPC_STUB IVBSAXAttributes_getType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXAttributes_getTypeFromName_Proxy( 
    IVBSAXAttributes * This,
    /* [in] */ BSTR strURI,
    /* [in] */ BSTR strLocalName,
    /* [retval][out] */ BSTR *strType);


void __RPC_STUB IVBSAXAttributes_getTypeFromName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXAttributes_getTypeFromQName_Proxy( 
    IVBSAXAttributes * This,
    /* [in] */ BSTR strQName,
    /* [retval][out] */ BSTR *strType);


void __RPC_STUB IVBSAXAttributes_getTypeFromQName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXAttributes_getValue_Proxy( 
    IVBSAXAttributes * This,
    /* [in] */ int nIndex,
    /* [retval][out] */ BSTR *strValue);


void __RPC_STUB IVBSAXAttributes_getValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXAttributes_getValueFromName_Proxy( 
    IVBSAXAttributes * This,
    /* [in] */ BSTR strURI,
    /* [in] */ BSTR strLocalName,
    /* [retval][out] */ BSTR *strValue);


void __RPC_STUB IVBSAXAttributes_getValueFromName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVBSAXAttributes_getValueFromQName_Proxy( 
    IVBSAXAttributes * This,
    /* [in] */ BSTR strQName,
    /* [retval][out] */ BSTR *strValue);


void __RPC_STUB IVBSAXAttributes_getValueFromQName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVBSAXAttributes_INTERFACE_DEFINED__ */


#ifndef __IMXWriter_INTERFACE_DEFINED__
#define __IMXWriter_INTERFACE_DEFINED__

/* interface IMXWriter */
/* [unique][helpstring][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IMXWriter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4d7ff4ba-1565-4ea8-94e1-6e724a46f98d")
    IMXWriter : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_output( 
            /* [in] */ VARIANT varDestination) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_output( 
            /* [retval][out] */ VARIANT *varDestination) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_encoding( 
            /* [in] */ BSTR strEncoding) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_encoding( 
            /* [retval][out] */ BSTR *strEncoding) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_byteOrderMark( 
            /* [in] */ VARIANT_BOOL fWriteByteOrderMark) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_byteOrderMark( 
            /* [retval][out] */ VARIANT_BOOL *fWriteByteOrderMark) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_indent( 
            /* [in] */ VARIANT_BOOL fIndentMode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_indent( 
            /* [retval][out] */ VARIANT_BOOL *fIndentMode) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_standalone( 
            /* [in] */ VARIANT_BOOL fValue) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_standalone( 
            /* [retval][out] */ VARIANT_BOOL *fValue) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_omitXMLDeclaration( 
            /* [in] */ VARIANT_BOOL fValue) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_omitXMLDeclaration( 
            /* [retval][out] */ VARIANT_BOOL *fValue) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_version( 
            /* [in] */ BSTR strVersion) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_version( 
            /* [retval][out] */ BSTR *strVersion) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_disableOutputEscaping( 
            /* [in] */ VARIANT_BOOL fValue) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_disableOutputEscaping( 
            /* [retval][out] */ VARIANT_BOOL *fValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE flush( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMXWriterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMXWriter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMXWriter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMXWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMXWriter * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMXWriter * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMXWriter * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMXWriter * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_output )( 
            IMXWriter * This,
            /* [in] */ VARIANT varDestination);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_output )( 
            IMXWriter * This,
            /* [retval][out] */ VARIANT *varDestination);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_encoding )( 
            IMXWriter * This,
            /* [in] */ BSTR strEncoding);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_encoding )( 
            IMXWriter * This,
            /* [retval][out] */ BSTR *strEncoding);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_byteOrderMark )( 
            IMXWriter * This,
            /* [in] */ VARIANT_BOOL fWriteByteOrderMark);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_byteOrderMark )( 
            IMXWriter * This,
            /* [retval][out] */ VARIANT_BOOL *fWriteByteOrderMark);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_indent )( 
            IMXWriter * This,
            /* [in] */ VARIANT_BOOL fIndentMode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_indent )( 
            IMXWriter * This,
            /* [retval][out] */ VARIANT_BOOL *fIndentMode);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_standalone )( 
            IMXWriter * This,
            /* [in] */ VARIANT_BOOL fValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_standalone )( 
            IMXWriter * This,
            /* [retval][out] */ VARIANT_BOOL *fValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_omitXMLDeclaration )( 
            IMXWriter * This,
            /* [in] */ VARIANT_BOOL fValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_omitXMLDeclaration )( 
            IMXWriter * This,
            /* [retval][out] */ VARIANT_BOOL *fValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_version )( 
            IMXWriter * This,
            /* [in] */ BSTR strVersion);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_version )( 
            IMXWriter * This,
            /* [retval][out] */ BSTR *strVersion);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_disableOutputEscaping )( 
            IMXWriter * This,
            /* [in] */ VARIANT_BOOL fValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_disableOutputEscaping )( 
            IMXWriter * This,
            /* [retval][out] */ VARIANT_BOOL *fValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *flush )( 
            IMXWriter * This);
        
        END_INTERFACE
    } IMXWriterVtbl;

    interface IMXWriter
    {
        CONST_VTBL struct IMXWriterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMXWriter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMXWriter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMXWriter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMXWriter_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMXWriter_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMXWriter_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMXWriter_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMXWriter_put_output(This,varDestination)	\
    (This)->lpVtbl -> put_output(This,varDestination)

#define IMXWriter_get_output(This,varDestination)	\
    (This)->lpVtbl -> get_output(This,varDestination)

#define IMXWriter_put_encoding(This,strEncoding)	\
    (This)->lpVtbl -> put_encoding(This,strEncoding)

#define IMXWriter_get_encoding(This,strEncoding)	\
    (This)->lpVtbl -> get_encoding(This,strEncoding)

#define IMXWriter_put_byteOrderMark(This,fWriteByteOrderMark)	\
    (This)->lpVtbl -> put_byteOrderMark(This,fWriteByteOrderMark)

#define IMXWriter_get_byteOrderMark(This,fWriteByteOrderMark)	\
    (This)->lpVtbl -> get_byteOrderMark(This,fWriteByteOrderMark)

#define IMXWriter_put_indent(This,fIndentMode)	\
    (This)->lpVtbl -> put_indent(This,fIndentMode)

#define IMXWriter_get_indent(This,fIndentMode)	\
    (This)->lpVtbl -> get_indent(This,fIndentMode)

#define IMXWriter_put_standalone(This,fValue)	\
    (This)->lpVtbl -> put_standalone(This,fValue)

#define IMXWriter_get_standalone(This,fValue)	\
    (This)->lpVtbl -> get_standalone(This,fValue)

#define IMXWriter_put_omitXMLDeclaration(This,fValue)	\
    (This)->lpVtbl -> put_omitXMLDeclaration(This,fValue)

#define IMXWriter_get_omitXMLDeclaration(This,fValue)	\
    (This)->lpVtbl -> get_omitXMLDeclaration(This,fValue)

#define IMXWriter_put_version(This,strVersion)	\
    (This)->lpVtbl -> put_version(This,strVersion)

#define IMXWriter_get_version(This,strVersion)	\
    (This)->lpVtbl -> get_version(This,strVersion)

#define IMXWriter_put_disableOutputEscaping(This,fValue)	\
    (This)->lpVtbl -> put_disableOutputEscaping(This,fValue)

#define IMXWriter_get_disableOutputEscaping(This,fValue)	\
    (This)->lpVtbl -> get_disableOutputEscaping(This,fValue)

#define IMXWriter_flush(This)	\
    (This)->lpVtbl -> flush(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMXWriter_put_output_Proxy( 
    IMXWriter * This,
    /* [in] */ VARIANT varDestination);


void __RPC_STUB IMXWriter_put_output_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMXWriter_get_output_Proxy( 
    IMXWriter * This,
    /* [retval][out] */ VARIANT *varDestination);


void __RPC_STUB IMXWriter_get_output_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMXWriter_put_encoding_Proxy( 
    IMXWriter * This,
    /* [in] */ BSTR strEncoding);


void __RPC_STUB IMXWriter_put_encoding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMXWriter_get_encoding_Proxy( 
    IMXWriter * This,
    /* [retval][out] */ BSTR *strEncoding);


void __RPC_STUB IMXWriter_get_encoding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMXWriter_put_byteOrderMark_Proxy( 
    IMXWriter * This,
    /* [in] */ VARIANT_BOOL fWriteByteOrderMark);


void __RPC_STUB IMXWriter_put_byteOrderMark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMXWriter_get_byteOrderMark_Proxy( 
    IMXWriter * This,
    /* [retval][out] */ VARIANT_BOOL *fWriteByteOrderMark);


void __RPC_STUB IMXWriter_get_byteOrderMark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMXWriter_put_indent_Proxy( 
    IMXWriter * This,
    /* [in] */ VARIANT_BOOL fIndentMode);


void __RPC_STUB IMXWriter_put_indent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMXWriter_get_indent_Proxy( 
    IMXWriter * This,
    /* [retval][out] */ VARIANT_BOOL *fIndentMode);


void __RPC_STUB IMXWriter_get_indent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMXWriter_put_standalone_Proxy( 
    IMXWriter * This,
    /* [in] */ VARIANT_BOOL fValue);


void __RPC_STUB IMXWriter_put_standalone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMXWriter_get_standalone_Proxy( 
    IMXWriter * This,
    /* [retval][out] */ VARIANT_BOOL *fValue);


void __RPC_STUB IMXWriter_get_standalone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMXWriter_put_omitXMLDeclaration_Proxy( 
    IMXWriter * This,
    /* [in] */ VARIANT_BOOL fValue);


void __RPC_STUB IMXWriter_put_omitXMLDeclaration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMXWriter_get_omitXMLDeclaration_Proxy( 
    IMXWriter * This,
    /* [retval][out] */ VARIANT_BOOL *fValue);


void __RPC_STUB IMXWriter_get_omitXMLDeclaration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMXWriter_put_version_Proxy( 
    IMXWriter * This,
    /* [in] */ BSTR strVersion);


void __RPC_STUB IMXWriter_put_version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMXWriter_get_version_Proxy( 
    IMXWriter * This,
    /* [retval][out] */ BSTR *strVersion);


void __RPC_STUB IMXWriter_get_version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMXWriter_put_disableOutputEscaping_Proxy( 
    IMXWriter * This,
    /* [in] */ VARIANT_BOOL fValue);


void __RPC_STUB IMXWriter_put_disableOutputEscaping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMXWriter_get_disableOutputEscaping_Proxy( 
    IMXWriter * This,
    /* [retval][out] */ VARIANT_BOOL *fValue);


void __RPC_STUB IMXWriter_get_disableOutputEscaping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMXWriter_flush_Proxy( 
    IMXWriter * This);


void __RPC_STUB IMXWriter_flush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMXWriter_INTERFACE_DEFINED__ */


#ifndef __IMXAttributes_INTERFACE_DEFINED__
#define __IMXAttributes_INTERFACE_DEFINED__

/* interface IMXAttributes */
/* [unique][helpstring][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IMXAttributes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f10d27cc-3ec0-415c-8ed8-77ab1c5e7262")
    IMXAttributes : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE addAttribute( 
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [in] */ BSTR strQName,
            /* [in] */ BSTR strType,
            /* [in] */ BSTR strValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE addAttributeFromIndex( 
            /* [in] */ VARIANT varAtts,
            /* [in] */ int nIndex) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE clear( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeAttribute( 
            /* [in] */ int nIndex) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setAttribute( 
            /* [in] */ int nIndex,
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [in] */ BSTR strQName,
            /* [in] */ BSTR strType,
            /* [in] */ BSTR strValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setAttributes( 
            /* [in] */ VARIANT varAtts) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setLocalName( 
            /* [in] */ int nIndex,
            /* [in] */ BSTR strLocalName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setQName( 
            /* [in] */ int nIndex,
            /* [in] */ BSTR strQName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setType( 
            /* [in] */ int nIndex,
            /* [in] */ BSTR strType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setURI( 
            /* [in] */ int nIndex,
            /* [in] */ BSTR strURI) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setValue( 
            /* [in] */ int nIndex,
            /* [in] */ BSTR strValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMXAttributesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMXAttributes * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMXAttributes * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMXAttributes * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMXAttributes * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMXAttributes * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMXAttributes * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMXAttributes * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *addAttribute )( 
            IMXAttributes * This,
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [in] */ BSTR strQName,
            /* [in] */ BSTR strType,
            /* [in] */ BSTR strValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *addAttributeFromIndex )( 
            IMXAttributes * This,
            /* [in] */ VARIANT varAtts,
            /* [in] */ int nIndex);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *clear )( 
            IMXAttributes * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeAttribute )( 
            IMXAttributes * This,
            /* [in] */ int nIndex);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setAttribute )( 
            IMXAttributes * This,
            /* [in] */ int nIndex,
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [in] */ BSTR strQName,
            /* [in] */ BSTR strType,
            /* [in] */ BSTR strValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setAttributes )( 
            IMXAttributes * This,
            /* [in] */ VARIANT varAtts);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setLocalName )( 
            IMXAttributes * This,
            /* [in] */ int nIndex,
            /* [in] */ BSTR strLocalName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setQName )( 
            IMXAttributes * This,
            /* [in] */ int nIndex,
            /* [in] */ BSTR strQName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setType )( 
            IMXAttributes * This,
            /* [in] */ int nIndex,
            /* [in] */ BSTR strType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setURI )( 
            IMXAttributes * This,
            /* [in] */ int nIndex,
            /* [in] */ BSTR strURI);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setValue )( 
            IMXAttributes * This,
            /* [in] */ int nIndex,
            /* [in] */ BSTR strValue);
        
        END_INTERFACE
    } IMXAttributesVtbl;

    interface IMXAttributes
    {
        CONST_VTBL struct IMXAttributesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMXAttributes_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMXAttributes_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMXAttributes_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMXAttributes_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMXAttributes_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMXAttributes_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMXAttributes_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMXAttributes_addAttribute(This,strURI,strLocalName,strQName,strType,strValue)	\
    (This)->lpVtbl -> addAttribute(This,strURI,strLocalName,strQName,strType,strValue)

#define IMXAttributes_addAttributeFromIndex(This,varAtts,nIndex)	\
    (This)->lpVtbl -> addAttributeFromIndex(This,varAtts,nIndex)

#define IMXAttributes_clear(This)	\
    (This)->lpVtbl -> clear(This)

#define IMXAttributes_removeAttribute(This,nIndex)	\
    (This)->lpVtbl -> removeAttribute(This,nIndex)

#define IMXAttributes_setAttribute(This,nIndex,strURI,strLocalName,strQName,strType,strValue)	\
    (This)->lpVtbl -> setAttribute(This,nIndex,strURI,strLocalName,strQName,strType,strValue)

#define IMXAttributes_setAttributes(This,varAtts)	\
    (This)->lpVtbl -> setAttributes(This,varAtts)

#define IMXAttributes_setLocalName(This,nIndex,strLocalName)	\
    (This)->lpVtbl -> setLocalName(This,nIndex,strLocalName)

#define IMXAttributes_setQName(This,nIndex,strQName)	\
    (This)->lpVtbl -> setQName(This,nIndex,strQName)

#define IMXAttributes_setType(This,nIndex,strType)	\
    (This)->lpVtbl -> setType(This,nIndex,strType)

#define IMXAttributes_setURI(This,nIndex,strURI)	\
    (This)->lpVtbl -> setURI(This,nIndex,strURI)

#define IMXAttributes_setValue(This,nIndex,strValue)	\
    (This)->lpVtbl -> setValue(This,nIndex,strValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMXAttributes_addAttribute_Proxy( 
    IMXAttributes * This,
    /* [in] */ BSTR strURI,
    /* [in] */ BSTR strLocalName,
    /* [in] */ BSTR strQName,
    /* [in] */ BSTR strType,
    /* [in] */ BSTR strValue);


void __RPC_STUB IMXAttributes_addAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMXAttributes_addAttributeFromIndex_Proxy( 
    IMXAttributes * This,
    /* [in] */ VARIANT varAtts,
    /* [in] */ int nIndex);


void __RPC_STUB IMXAttributes_addAttributeFromIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMXAttributes_clear_Proxy( 
    IMXAttributes * This);


void __RPC_STUB IMXAttributes_clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMXAttributes_removeAttribute_Proxy( 
    IMXAttributes * This,
    /* [in] */ int nIndex);


void __RPC_STUB IMXAttributes_removeAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMXAttributes_setAttribute_Proxy( 
    IMXAttributes * This,
    /* [in] */ int nIndex,
    /* [in] */ BSTR strURI,
    /* [in] */ BSTR strLocalName,
    /* [in] */ BSTR strQName,
    /* [in] */ BSTR strType,
    /* [in] */ BSTR strValue);


void __RPC_STUB IMXAttributes_setAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMXAttributes_setAttributes_Proxy( 
    IMXAttributes * This,
    /* [in] */ VARIANT varAtts);


void __RPC_STUB IMXAttributes_setAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMXAttributes_setLocalName_Proxy( 
    IMXAttributes * This,
    /* [in] */ int nIndex,
    /* [in] */ BSTR strLocalName);


void __RPC_STUB IMXAttributes_setLocalName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMXAttributes_setQName_Proxy( 
    IMXAttributes * This,
    /* [in] */ int nIndex,
    /* [in] */ BSTR strQName);


void __RPC_STUB IMXAttributes_setQName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMXAttributes_setType_Proxy( 
    IMXAttributes * This,
    /* [in] */ int nIndex,
    /* [in] */ BSTR strType);


void __RPC_STUB IMXAttributes_setType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMXAttributes_setURI_Proxy( 
    IMXAttributes * This,
    /* [in] */ int nIndex,
    /* [in] */ BSTR strURI);


void __RPC_STUB IMXAttributes_setURI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMXAttributes_setValue_Proxy( 
    IMXAttributes * This,
    /* [in] */ int nIndex,
    /* [in] */ BSTR strValue);


void __RPC_STUB IMXAttributes_setValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMXAttributes_INTERFACE_DEFINED__ */


#ifndef __IMXReaderControl_INTERFACE_DEFINED__
#define __IMXReaderControl_INTERFACE_DEFINED__

/* interface IMXReaderControl */
/* [unique][helpstring][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IMXReaderControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("808f4e35-8d5a-4fbe-8466-33a41279ed30")
    IMXReaderControl : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE abort( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE resume( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE suspend( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMXReaderControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMXReaderControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMXReaderControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMXReaderControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMXReaderControl * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMXReaderControl * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMXReaderControl * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMXReaderControl * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *abort )( 
            IMXReaderControl * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *resume )( 
            IMXReaderControl * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *suspend )( 
            IMXReaderControl * This);
        
        END_INTERFACE
    } IMXReaderControlVtbl;

    interface IMXReaderControl
    {
        CONST_VTBL struct IMXReaderControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMXReaderControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMXReaderControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMXReaderControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMXReaderControl_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMXReaderControl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMXReaderControl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMXReaderControl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMXReaderControl_abort(This)	\
    (This)->lpVtbl -> abort(This)

#define IMXReaderControl_resume(This)	\
    (This)->lpVtbl -> resume(This)

#define IMXReaderControl_suspend(This)	\
    (This)->lpVtbl -> suspend(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMXReaderControl_abort_Proxy( 
    IMXReaderControl * This);


void __RPC_STUB IMXReaderControl_abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMXReaderControl_resume_Proxy( 
    IMXReaderControl * This);


void __RPC_STUB IMXReaderControl_resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMXReaderControl_suspend_Proxy( 
    IMXReaderControl * This);


void __RPC_STUB IMXReaderControl_suspend_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMXReaderControl_INTERFACE_DEFINED__ */


#ifndef __IXMLElementCollection_INTERFACE_DEFINED__
#define __IXMLElementCollection_INTERFACE_DEFINED__

/* interface IXMLElementCollection */
/* [helpstring][hidden][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLElementCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("65725580-9B5D-11d0-9BFE-00C04FC99C8E")
    IXMLElementCollection : public IDispatch
    {
    public:
        virtual /* [id][hidden][restricted][propput] */ HRESULT STDMETHODCALLTYPE put_length( 
            /* [in] */ long v) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [out][retval] */ long *p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__newEnum( 
            /* [out][retval] */ IUnknown **ppUnk) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE item( 
            /* [in][optional] */ VARIANT var1,
            /* [in][optional] */ VARIANT var2,
            /* [out][retval] */ IDispatch **ppDisp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLElementCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLElementCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLElementCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLElementCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLElementCollection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLElementCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLElementCollection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLElementCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][hidden][restricted][propput] */ HRESULT ( STDMETHODCALLTYPE *put_length )( 
            IXMLElementCollection * This,
            /* [in] */ long v);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IXMLElementCollection * This,
            /* [out][retval] */ long *p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__newEnum )( 
            IXMLElementCollection * This,
            /* [out][retval] */ IUnknown **ppUnk);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *item )( 
            IXMLElementCollection * This,
            /* [in][optional] */ VARIANT var1,
            /* [in][optional] */ VARIANT var2,
            /* [out][retval] */ IDispatch **ppDisp);
        
        END_INTERFACE
    } IXMLElementCollectionVtbl;

    interface IXMLElementCollection
    {
        CONST_VTBL struct IXMLElementCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLElementCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLElementCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLElementCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLElementCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLElementCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLElementCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLElementCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLElementCollection_put_length(This,v)	\
    (This)->lpVtbl -> put_length(This,v)

#define IXMLElementCollection_get_length(This,p)	\
    (This)->lpVtbl -> get_length(This,p)

#define IXMLElementCollection_get__newEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__newEnum(This,ppUnk)

#define IXMLElementCollection_item(This,var1,var2,ppDisp)	\
    (This)->lpVtbl -> item(This,var1,var2,ppDisp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][hidden][restricted][propput] */ HRESULT STDMETHODCALLTYPE IXMLElementCollection_put_length_Proxy( 
    IXMLElementCollection * This,
    /* [in] */ long v);


void __RPC_STUB IXMLElementCollection_put_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElementCollection_get_length_Proxy( 
    IXMLElementCollection * This,
    /* [out][retval] */ long *p);


void __RPC_STUB IXMLElementCollection_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLElementCollection_get__newEnum_Proxy( 
    IXMLElementCollection * This,
    /* [out][retval] */ IUnknown **ppUnk);


void __RPC_STUB IXMLElementCollection_get__newEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLElementCollection_item_Proxy( 
    IXMLElementCollection * This,
    /* [in][optional] */ VARIANT var1,
    /* [in][optional] */ VARIANT var2,
    /* [out][retval] */ IDispatch **ppDisp);


void __RPC_STUB IXMLElementCollection_item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLElementCollection_INTERFACE_DEFINED__ */


#ifndef __IXMLDocument_INTERFACE_DEFINED__
#define __IXMLDocument_INTERFACE_DEFINED__

/* interface IXMLDocument */
/* [helpstring][hidden][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F52E2B61-18A1-11d1-B105-00805F49916B")
    IXMLDocument : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_root( 
            /* [out][retval] */ IXMLElement **p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_fileSize( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_fileModifiedDate( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_fileUpdatedDate( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_URL( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_URL( 
            /* [in] */ BSTR p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_mimeType( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_readyState( 
            /* [out][retval] */ long *pl) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_charset( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_charset( 
            /* [in] */ BSTR p) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_version( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_doctype( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_dtdURL( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE createElement( 
            /* [in] */ VARIANT vType,
            /* [in][optional] */ VARIANT var1,
            /* [out][retval] */ IXMLElement **ppElem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDocumentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDocument * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDocument * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDocument * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDocument * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDocument * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDocument * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDocument * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_root )( 
            IXMLDocument * This,
            /* [out][retval] */ IXMLElement **p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get_fileSize )( 
            IXMLDocument * This,
            /* [out][retval] */ BSTR *p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get_fileModifiedDate )( 
            IXMLDocument * This,
            /* [out][retval] */ BSTR *p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get_fileUpdatedDate )( 
            IXMLDocument * This,
            /* [out][retval] */ BSTR *p);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_URL )( 
            IXMLDocument * This,
            /* [out][retval] */ BSTR *p);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_URL )( 
            IXMLDocument * This,
            /* [in] */ BSTR p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get_mimeType )( 
            IXMLDocument * This,
            /* [out][retval] */ BSTR *p);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_readyState )( 
            IXMLDocument * This,
            /* [out][retval] */ long *pl);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_charset )( 
            IXMLDocument * This,
            /* [out][retval] */ BSTR *p);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_charset )( 
            IXMLDocument * This,
            /* [in] */ BSTR p);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_version )( 
            IXMLDocument * This,
            /* [out][retval] */ BSTR *p);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_doctype )( 
            IXMLDocument * This,
            /* [out][retval] */ BSTR *p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dtdURL )( 
            IXMLDocument * This,
            /* [out][retval] */ BSTR *p);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createElement )( 
            IXMLDocument * This,
            /* [in] */ VARIANT vType,
            /* [in][optional] */ VARIANT var1,
            /* [out][retval] */ IXMLElement **ppElem);
        
        END_INTERFACE
    } IXMLDocumentVtbl;

    interface IXMLDocument
    {
        CONST_VTBL struct IXMLDocumentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDocument_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDocument_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDocument_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDocument_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDocument_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDocument_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDocument_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDocument_get_root(This,p)	\
    (This)->lpVtbl -> get_root(This,p)

#define IXMLDocument_get_fileSize(This,p)	\
    (This)->lpVtbl -> get_fileSize(This,p)

#define IXMLDocument_get_fileModifiedDate(This,p)	\
    (This)->lpVtbl -> get_fileModifiedDate(This,p)

#define IXMLDocument_get_fileUpdatedDate(This,p)	\
    (This)->lpVtbl -> get_fileUpdatedDate(This,p)

#define IXMLDocument_get_URL(This,p)	\
    (This)->lpVtbl -> get_URL(This,p)

#define IXMLDocument_put_URL(This,p)	\
    (This)->lpVtbl -> put_URL(This,p)

#define IXMLDocument_get_mimeType(This,p)	\
    (This)->lpVtbl -> get_mimeType(This,p)

#define IXMLDocument_get_readyState(This,pl)	\
    (This)->lpVtbl -> get_readyState(This,pl)

#define IXMLDocument_get_charset(This,p)	\
    (This)->lpVtbl -> get_charset(This,p)

#define IXMLDocument_put_charset(This,p)	\
    (This)->lpVtbl -> put_charset(This,p)

#define IXMLDocument_get_version(This,p)	\
    (This)->lpVtbl -> get_version(This,p)

#define IXMLDocument_get_doctype(This,p)	\
    (This)->lpVtbl -> get_doctype(This,p)

#define IXMLDocument_get_dtdURL(This,p)	\
    (This)->lpVtbl -> get_dtdURL(This,p)

#define IXMLDocument_createElement(This,vType,var1,ppElem)	\
    (This)->lpVtbl -> createElement(This,vType,var1,ppElem)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_root_Proxy( 
    IXMLDocument * This,
    /* [out][retval] */ IXMLElement **p);


void __RPC_STUB IXMLDocument_get_root_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_fileSize_Proxy( 
    IXMLDocument * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLDocument_get_fileSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_fileModifiedDate_Proxy( 
    IXMLDocument * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLDocument_get_fileModifiedDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_fileUpdatedDate_Proxy( 
    IXMLDocument * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLDocument_get_fileUpdatedDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_URL_Proxy( 
    IXMLDocument * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLDocument_get_URL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDocument_put_URL_Proxy( 
    IXMLDocument * This,
    /* [in] */ BSTR p);


void __RPC_STUB IXMLDocument_put_URL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_mimeType_Proxy( 
    IXMLDocument * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLDocument_get_mimeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_readyState_Proxy( 
    IXMLDocument * This,
    /* [out][retval] */ long *pl);


void __RPC_STUB IXMLDocument_get_readyState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_charset_Proxy( 
    IXMLDocument * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLDocument_get_charset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDocument_put_charset_Proxy( 
    IXMLDocument * This,
    /* [in] */ BSTR p);


void __RPC_STUB IXMLDocument_put_charset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_version_Proxy( 
    IXMLDocument * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLDocument_get_version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_doctype_Proxy( 
    IXMLDocument * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLDocument_get_doctype_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_dtdURL_Proxy( 
    IXMLDocument * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLDocument_get_dtdURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDocument_createElement_Proxy( 
    IXMLDocument * This,
    /* [in] */ VARIANT vType,
    /* [in][optional] */ VARIANT var1,
    /* [out][retval] */ IXMLElement **ppElem);


void __RPC_STUB IXMLDocument_createElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDocument_INTERFACE_DEFINED__ */


#ifndef __IXMLDocument2_INTERFACE_DEFINED__
#define __IXMLDocument2_INTERFACE_DEFINED__

/* interface IXMLDocument2 */
/* [hidden][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDocument2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2B8DE2FE-8D2D-11d1-B2FC-00C04FD915A9")
    IXMLDocument2 : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_root( 
            /* [out][retval] */ IXMLElement2 **p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_fileSize( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_fileModifiedDate( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_fileUpdatedDate( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_URL( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_URL( 
            /* [in] */ BSTR p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_mimeType( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_readyState( 
            /* [out][retval] */ long *pl) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_charset( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_charset( 
            /* [in] */ BSTR p) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_version( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_doctype( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_dtdURL( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE createElement( 
            /* [in] */ VARIANT vType,
            /* [in][optional] */ VARIANT var1,
            /* [out][retval] */ IXMLElement2 **ppElem) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_async( 
            /* [out][retval] */ VARIANT_BOOL *pf) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_async( 
            /* [in] */ VARIANT_BOOL f) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDocument2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDocument2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDocument2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDocument2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDocument2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDocument2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDocument2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDocument2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_root )( 
            IXMLDocument2 * This,
            /* [out][retval] */ IXMLElement2 **p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get_fileSize )( 
            IXMLDocument2 * This,
            /* [out][retval] */ BSTR *p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get_fileModifiedDate )( 
            IXMLDocument2 * This,
            /* [out][retval] */ BSTR *p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get_fileUpdatedDate )( 
            IXMLDocument2 * This,
            /* [out][retval] */ BSTR *p);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_URL )( 
            IXMLDocument2 * This,
            /* [out][retval] */ BSTR *p);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_URL )( 
            IXMLDocument2 * This,
            /* [in] */ BSTR p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get_mimeType )( 
            IXMLDocument2 * This,
            /* [out][retval] */ BSTR *p);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_readyState )( 
            IXMLDocument2 * This,
            /* [out][retval] */ long *pl);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_charset )( 
            IXMLDocument2 * This,
            /* [out][retval] */ BSTR *p);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_charset )( 
            IXMLDocument2 * This,
            /* [in] */ BSTR p);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_version )( 
            IXMLDocument2 * This,
            /* [out][retval] */ BSTR *p);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_doctype )( 
            IXMLDocument2 * This,
            /* [out][retval] */ BSTR *p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get_dtdURL )( 
            IXMLDocument2 * This,
            /* [out][retval] */ BSTR *p);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createElement )( 
            IXMLDocument2 * This,
            /* [in] */ VARIANT vType,
            /* [in][optional] */ VARIANT var1,
            /* [out][retval] */ IXMLElement2 **ppElem);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_async )( 
            IXMLDocument2 * This,
            /* [out][retval] */ VARIANT_BOOL *pf);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_async )( 
            IXMLDocument2 * This,
            /* [in] */ VARIANT_BOOL f);
        
        END_INTERFACE
    } IXMLDocument2Vtbl;

    interface IXMLDocument2
    {
        CONST_VTBL struct IXMLDocument2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDocument2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDocument2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDocument2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDocument2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDocument2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDocument2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDocument2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDocument2_get_root(This,p)	\
    (This)->lpVtbl -> get_root(This,p)

#define IXMLDocument2_get_fileSize(This,p)	\
    (This)->lpVtbl -> get_fileSize(This,p)

#define IXMLDocument2_get_fileModifiedDate(This,p)	\
    (This)->lpVtbl -> get_fileModifiedDate(This,p)

#define IXMLDocument2_get_fileUpdatedDate(This,p)	\
    (This)->lpVtbl -> get_fileUpdatedDate(This,p)

#define IXMLDocument2_get_URL(This,p)	\
    (This)->lpVtbl -> get_URL(This,p)

#define IXMLDocument2_put_URL(This,p)	\
    (This)->lpVtbl -> put_URL(This,p)

#define IXMLDocument2_get_mimeType(This,p)	\
    (This)->lpVtbl -> get_mimeType(This,p)

#define IXMLDocument2_get_readyState(This,pl)	\
    (This)->lpVtbl -> get_readyState(This,pl)

#define IXMLDocument2_get_charset(This,p)	\
    (This)->lpVtbl -> get_charset(This,p)

#define IXMLDocument2_put_charset(This,p)	\
    (This)->lpVtbl -> put_charset(This,p)

#define IXMLDocument2_get_version(This,p)	\
    (This)->lpVtbl -> get_version(This,p)

#define IXMLDocument2_get_doctype(This,p)	\
    (This)->lpVtbl -> get_doctype(This,p)

#define IXMLDocument2_get_dtdURL(This,p)	\
    (This)->lpVtbl -> get_dtdURL(This,p)

#define IXMLDocument2_createElement(This,vType,var1,ppElem)	\
    (This)->lpVtbl -> createElement(This,vType,var1,ppElem)

#define IXMLDocument2_get_async(This,pf)	\
    (This)->lpVtbl -> get_async(This,pf)

#define IXMLDocument2_put_async(This,f)	\
    (This)->lpVtbl -> put_async(This,f)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_root_Proxy( 
    IXMLDocument2 * This,
    /* [out][retval] */ IXMLElement2 **p);


void __RPC_STUB IXMLDocument2_get_root_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_fileSize_Proxy( 
    IXMLDocument2 * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLDocument2_get_fileSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_fileModifiedDate_Proxy( 
    IXMLDocument2 * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLDocument2_get_fileModifiedDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_fileUpdatedDate_Proxy( 
    IXMLDocument2 * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLDocument2_get_fileUpdatedDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_URL_Proxy( 
    IXMLDocument2 * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLDocument2_get_URL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_put_URL_Proxy( 
    IXMLDocument2 * This,
    /* [in] */ BSTR p);


void __RPC_STUB IXMLDocument2_put_URL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_mimeType_Proxy( 
    IXMLDocument2 * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLDocument2_get_mimeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_readyState_Proxy( 
    IXMLDocument2 * This,
    /* [out][retval] */ long *pl);


void __RPC_STUB IXMLDocument2_get_readyState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_charset_Proxy( 
    IXMLDocument2 * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLDocument2_get_charset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_put_charset_Proxy( 
    IXMLDocument2 * This,
    /* [in] */ BSTR p);


void __RPC_STUB IXMLDocument2_put_charset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_version_Proxy( 
    IXMLDocument2 * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLDocument2_get_version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_doctype_Proxy( 
    IXMLDocument2 * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLDocument2_get_doctype_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_dtdURL_Proxy( 
    IXMLDocument2 * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLDocument2_get_dtdURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_createElement_Proxy( 
    IXMLDocument2 * This,
    /* [in] */ VARIANT vType,
    /* [in][optional] */ VARIANT var1,
    /* [out][retval] */ IXMLElement2 **ppElem);


void __RPC_STUB IXMLDocument2_createElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_async_Proxy( 
    IXMLDocument2 * This,
    /* [out][retval] */ VARIANT_BOOL *pf);


void __RPC_STUB IXMLDocument2_get_async_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_put_async_Proxy( 
    IXMLDocument2 * This,
    /* [in] */ VARIANT_BOOL f);


void __RPC_STUB IXMLDocument2_put_async_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDocument2_INTERFACE_DEFINED__ */


#ifndef __IXMLElement_INTERFACE_DEFINED__
#define __IXMLElement_INTERFACE_DEFINED__

/* interface IXMLElement */
/* [helpstring][hidden][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3F7F31AC-E15F-11d0-9C25-00C04FC99C8E")
    IXMLElement : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_tagName( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_tagName( 
            /* [in] */ BSTR p) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_parent( 
            /* [out][retval] */ IXMLElement **ppParent) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setAttribute( 
            /* [in] */ BSTR strPropertyName,
            /* [in] */ VARIANT PropertyValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getAttribute( 
            /* [in] */ BSTR strPropertyName,
            /* [out][retval] */ VARIANT *PropertyValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeAttribute( 
            /* [in] */ BSTR strPropertyName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_children( 
            /* [out][retval] */ IXMLElementCollection **pp) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_type( 
            /* [out][retval] */ long *plType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_text( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_text( 
            /* [in] */ BSTR p) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE addChild( 
            /* [in] */ IXMLElement *pChildElem,
            long lIndex,
            long lReserved) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeChild( 
            /* [in] */ IXMLElement *pChildElem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLElement * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLElement * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLElement * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLElement * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLElement * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLElement * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLElement * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_tagName )( 
            IXMLElement * This,
            /* [out][retval] */ BSTR *p);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_tagName )( 
            IXMLElement * This,
            /* [in] */ BSTR p);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parent )( 
            IXMLElement * This,
            /* [out][retval] */ IXMLElement **ppParent);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setAttribute )( 
            IXMLElement * This,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ VARIANT PropertyValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getAttribute )( 
            IXMLElement * This,
            /* [in] */ BSTR strPropertyName,
            /* [out][retval] */ VARIANT *PropertyValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeAttribute )( 
            IXMLElement * This,
            /* [in] */ BSTR strPropertyName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_children )( 
            IXMLElement * This,
            /* [out][retval] */ IXMLElementCollection **pp);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_type )( 
            IXMLElement * This,
            /* [out][retval] */ long *plType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IXMLElement * This,
            /* [out][retval] */ BSTR *p);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IXMLElement * This,
            /* [in] */ BSTR p);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *addChild )( 
            IXMLElement * This,
            /* [in] */ IXMLElement *pChildElem,
            long lIndex,
            long lReserved);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IXMLElement * This,
            /* [in] */ IXMLElement *pChildElem);
        
        END_INTERFACE
    } IXMLElementVtbl;

    interface IXMLElement
    {
        CONST_VTBL struct IXMLElementVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IXMLElement_put_tagName(This,p)	\
    (This)->lpVtbl -> put_tagName(This,p)

#define IXMLElement_get_parent(This,ppParent)	\
    (This)->lpVtbl -> get_parent(This,ppParent)

#define IXMLElement_setAttribute(This,strPropertyName,PropertyValue)	\
    (This)->lpVtbl -> setAttribute(This,strPropertyName,PropertyValue)

#define IXMLElement_getAttribute(This,strPropertyName,PropertyValue)	\
    (This)->lpVtbl -> getAttribute(This,strPropertyName,PropertyValue)

#define IXMLElement_removeAttribute(This,strPropertyName)	\
    (This)->lpVtbl -> removeAttribute(This,strPropertyName)

#define IXMLElement_get_children(This,pp)	\
    (This)->lpVtbl -> get_children(This,pp)

#define IXMLElement_get_type(This,plType)	\
    (This)->lpVtbl -> get_type(This,plType)

#define IXMLElement_get_text(This,p)	\
    (This)->lpVtbl -> get_text(This,p)

#define IXMLElement_put_text(This,p)	\
    (This)->lpVtbl -> put_text(This,p)

#define IXMLElement_addChild(This,pChildElem,lIndex,lReserved)	\
    (This)->lpVtbl -> addChild(This,pChildElem,lIndex,lReserved)

#define IXMLElement_removeChild(This,pChildElem)	\
    (This)->lpVtbl -> removeChild(This,pChildElem)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement_get_tagName_Proxy( 
    IXMLElement * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLElement_get_tagName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLElement_put_tagName_Proxy( 
    IXMLElement * This,
    /* [in] */ BSTR p);


void __RPC_STUB IXMLElement_put_tagName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement_get_parent_Proxy( 
    IXMLElement * This,
    /* [out][retval] */ IXMLElement **ppParent);


void __RPC_STUB IXMLElement_get_parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLElement_setAttribute_Proxy( 
    IXMLElement * This,
    /* [in] */ BSTR strPropertyName,
    /* [in] */ VARIANT PropertyValue);


void __RPC_STUB IXMLElement_setAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLElement_getAttribute_Proxy( 
    IXMLElement * This,
    /* [in] */ BSTR strPropertyName,
    /* [out][retval] */ VARIANT *PropertyValue);


void __RPC_STUB IXMLElement_getAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLElement_removeAttribute_Proxy( 
    IXMLElement * This,
    /* [in] */ BSTR strPropertyName);


void __RPC_STUB IXMLElement_removeAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement_get_children_Proxy( 
    IXMLElement * This,
    /* [out][retval] */ IXMLElementCollection **pp);


void __RPC_STUB IXMLElement_get_children_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement_get_type_Proxy( 
    IXMLElement * This,
    /* [out][retval] */ long *plType);


void __RPC_STUB IXMLElement_get_type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement_get_text_Proxy( 
    IXMLElement * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLElement_get_text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLElement_put_text_Proxy( 
    IXMLElement * This,
    /* [in] */ BSTR p);


void __RPC_STUB IXMLElement_put_text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLElement_addChild_Proxy( 
    IXMLElement * This,
    /* [in] */ IXMLElement *pChildElem,
    long lIndex,
    long lReserved);


void __RPC_STUB IXMLElement_addChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLElement_removeChild_Proxy( 
    IXMLElement * This,
    /* [in] */ IXMLElement *pChildElem);


void __RPC_STUB IXMLElement_removeChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLElement_INTERFACE_DEFINED__ */


#ifndef __IXMLElement2_INTERFACE_DEFINED__
#define __IXMLElement2_INTERFACE_DEFINED__

/* interface IXMLElement2 */
/* [helpstring][hidden][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLElement2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2B8DE2FF-8D2D-11d1-B2FC-00C04FD915A9")
    IXMLElement2 : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_tagName( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_tagName( 
            /* [in] */ BSTR p) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_parent( 
            /* [out][retval] */ IXMLElement2 **ppParent) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setAttribute( 
            /* [in] */ BSTR strPropertyName,
            /* [in] */ VARIANT PropertyValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getAttribute( 
            /* [in] */ BSTR strPropertyName,
            /* [out][retval] */ VARIANT *PropertyValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeAttribute( 
            /* [in] */ BSTR strPropertyName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_children( 
            /* [out][retval] */ IXMLElementCollection **pp) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_type( 
            /* [out][retval] */ long *plType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_text( 
            /* [out][retval] */ BSTR *p) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_text( 
            /* [in] */ BSTR p) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE addChild( 
            /* [in] */ IXMLElement2 *pChildElem,
            long lIndex,
            long lReserved) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeChild( 
            /* [in] */ IXMLElement2 *pChildElem) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_attributes( 
            /* [out][retval] */ IXMLElementCollection **pp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLElement2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLElement2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLElement2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLElement2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLElement2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLElement2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLElement2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLElement2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_tagName )( 
            IXMLElement2 * This,
            /* [out][retval] */ BSTR *p);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_tagName )( 
            IXMLElement2 * This,
            /* [in] */ BSTR p);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_parent )( 
            IXMLElement2 * This,
            /* [out][retval] */ IXMLElement2 **ppParent);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setAttribute )( 
            IXMLElement2 * This,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ VARIANT PropertyValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getAttribute )( 
            IXMLElement2 * This,
            /* [in] */ BSTR strPropertyName,
            /* [out][retval] */ VARIANT *PropertyValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeAttribute )( 
            IXMLElement2 * This,
            /* [in] */ BSTR strPropertyName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_children )( 
            IXMLElement2 * This,
            /* [out][retval] */ IXMLElementCollection **pp);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_type )( 
            IXMLElement2 * This,
            /* [out][retval] */ long *plType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_text )( 
            IXMLElement2 * This,
            /* [out][retval] */ BSTR *p);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_text )( 
            IXMLElement2 * This,
            /* [in] */ BSTR p);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *addChild )( 
            IXMLElement2 * This,
            /* [in] */ IXMLElement2 *pChildElem,
            long lIndex,
            long lReserved);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeChild )( 
            IXMLElement2 * This,
            /* [in] */ IXMLElement2 *pChildElem);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            IXMLElement2 * This,
            /* [out][retval] */ IXMLElementCollection **pp);
        
        END_INTERFACE
    } IXMLElement2Vtbl;

    interface IXMLElement2
    {
        CONST_VTBL struct IXMLElement2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLElement2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLElement2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLElement2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLElement2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLElement2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLElement2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLElement2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLElement2_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IXMLElement2_put_tagName(This,p)	\
    (This)->lpVtbl -> put_tagName(This,p)

#define IXMLElement2_get_parent(This,ppParent)	\
    (This)->lpVtbl -> get_parent(This,ppParent)

#define IXMLElement2_setAttribute(This,strPropertyName,PropertyValue)	\
    (This)->lpVtbl -> setAttribute(This,strPropertyName,PropertyValue)

#define IXMLElement2_getAttribute(This,strPropertyName,PropertyValue)	\
    (This)->lpVtbl -> getAttribute(This,strPropertyName,PropertyValue)

#define IXMLElement2_removeAttribute(This,strPropertyName)	\
    (This)->lpVtbl -> removeAttribute(This,strPropertyName)

#define IXMLElement2_get_children(This,pp)	\
    (This)->lpVtbl -> get_children(This,pp)

#define IXMLElement2_get_type(This,plType)	\
    (This)->lpVtbl -> get_type(This,plType)

#define IXMLElement2_get_text(This,p)	\
    (This)->lpVtbl -> get_text(This,p)

#define IXMLElement2_put_text(This,p)	\
    (This)->lpVtbl -> put_text(This,p)

#define IXMLElement2_addChild(This,pChildElem,lIndex,lReserved)	\
    (This)->lpVtbl -> addChild(This,pChildElem,lIndex,lReserved)

#define IXMLElement2_removeChild(This,pChildElem)	\
    (This)->lpVtbl -> removeChild(This,pChildElem)

#define IXMLElement2_get_attributes(This,pp)	\
    (This)->lpVtbl -> get_attributes(This,pp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement2_get_tagName_Proxy( 
    IXMLElement2 * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLElement2_get_tagName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLElement2_put_tagName_Proxy( 
    IXMLElement2 * This,
    /* [in] */ BSTR p);


void __RPC_STUB IXMLElement2_put_tagName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement2_get_parent_Proxy( 
    IXMLElement2 * This,
    /* [out][retval] */ IXMLElement2 **ppParent);


void __RPC_STUB IXMLElement2_get_parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLElement2_setAttribute_Proxy( 
    IXMLElement2 * This,
    /* [in] */ BSTR strPropertyName,
    /* [in] */ VARIANT PropertyValue);


void __RPC_STUB IXMLElement2_setAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLElement2_getAttribute_Proxy( 
    IXMLElement2 * This,
    /* [in] */ BSTR strPropertyName,
    /* [out][retval] */ VARIANT *PropertyValue);


void __RPC_STUB IXMLElement2_getAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLElement2_removeAttribute_Proxy( 
    IXMLElement2 * This,
    /* [in] */ BSTR strPropertyName);


void __RPC_STUB IXMLElement2_removeAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement2_get_children_Proxy( 
    IXMLElement2 * This,
    /* [out][retval] */ IXMLElementCollection **pp);


void __RPC_STUB IXMLElement2_get_children_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement2_get_type_Proxy( 
    IXMLElement2 * This,
    /* [out][retval] */ long *plType);


void __RPC_STUB IXMLElement2_get_type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement2_get_text_Proxy( 
    IXMLElement2 * This,
    /* [out][retval] */ BSTR *p);


void __RPC_STUB IXMLElement2_get_text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLElement2_put_text_Proxy( 
    IXMLElement2 * This,
    /* [in] */ BSTR p);


void __RPC_STUB IXMLElement2_put_text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLElement2_addChild_Proxy( 
    IXMLElement2 * This,
    /* [in] */ IXMLElement2 *pChildElem,
    long lIndex,
    long lReserved);


void __RPC_STUB IXMLElement2_addChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLElement2_removeChild_Proxy( 
    IXMLElement2 * This,
    /* [in] */ IXMLElement2 *pChildElem);


void __RPC_STUB IXMLElement2_removeChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement2_get_attributes_Proxy( 
    IXMLElement2 * This,
    /* [out][retval] */ IXMLElementCollection **pp);


void __RPC_STUB IXMLElement2_get_attributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLElement2_INTERFACE_DEFINED__ */


#ifndef __IXMLAttribute_INTERFACE_DEFINED__
#define __IXMLAttribute_INTERFACE_DEFINED__

/* interface IXMLAttribute */
/* [helpstring][hidden][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLAttribute;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D4D4A0FC-3B73-11d1-B2B4-00C04FB92596")
    IXMLAttribute : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [out][retval] */ BSTR *n) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_value( 
            /* [out][retval] */ BSTR *v) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLAttributeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLAttribute * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLAttribute * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLAttribute * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLAttribute * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLAttribute * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLAttribute * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLAttribute * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
            IXMLAttribute * This,
            /* [out][retval] */ BSTR *n);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_value )( 
            IXMLAttribute * This,
            /* [out][retval] */ BSTR *v);
        
        END_INTERFACE
    } IXMLAttributeVtbl;

    interface IXMLAttribute
    {
        CONST_VTBL struct IXMLAttributeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLAttribute_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLAttribute_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLAttribute_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLAttribute_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLAttribute_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLAttribute_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLAttribute_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLAttribute_get_name(This,n)	\
    (This)->lpVtbl -> get_name(This,n)

#define IXMLAttribute_get_value(This,v)	\
    (This)->lpVtbl -> get_value(This,v)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLAttribute_get_name_Proxy( 
    IXMLAttribute * This,
    /* [out][retval] */ BSTR *n);


void __RPC_STUB IXMLAttribute_get_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLAttribute_get_value_Proxy( 
    IXMLAttribute * This,
    /* [out][retval] */ BSTR *v);


void __RPC_STUB IXMLAttribute_get_value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLAttribute_INTERFACE_DEFINED__ */


#ifndef __IXMLError_INTERFACE_DEFINED__
#define __IXMLError_INTERFACE_DEFINED__

/* interface IXMLError */
/* [helpstring][hidden][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLError;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("948C5AD3-C58D-11d0-9C0B-00C04FC99C8E")
    IXMLError : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetErrorInfo( 
            XML_ERROR *pErrorReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLErrorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLError * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLError * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLError * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetErrorInfo )( 
            IXMLError * This,
            XML_ERROR *pErrorReturn);
        
        END_INTERFACE
    } IXMLErrorVtbl;

    interface IXMLError
    {
        CONST_VTBL struct IXMLErrorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLError_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLError_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLError_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLError_GetErrorInfo(This,pErrorReturn)	\
    (This)->lpVtbl -> GetErrorInfo(This,pErrorReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IXMLError_GetErrorInfo_Proxy( 
    IXMLError * This,
    XML_ERROR *pErrorReturn);


void __RPC_STUB IXMLError_GetErrorInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLError_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMSelection_INTERFACE_DEFINED__
#define __IXMLDOMSelection_INTERFACE_DEFINED__

/* interface IXMLDOMSelection */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMSelection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AA634FC7-5888-44a7-A257-3A47150D3A0E")
    IXMLDOMSelection : public IXMLDOMNodeList
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_expr( 
            /* [retval][out] */ BSTR *expression) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_expr( 
            /* [in] */ BSTR expression) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_context( 
            /* [retval][out] */ IXMLDOMNode **ppNode) = 0;
        
        virtual /* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_context( 
            /* [in] */ IXMLDOMNode *pNode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE peekNode( 
            /* [retval][out] */ IXMLDOMNode **ppNode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE matches( 
            /* [in] */ IXMLDOMNode *pNode,
            /* [retval][out] */ IXMLDOMNode **ppNode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeNext( 
            /* [retval][out] */ IXMLDOMNode **ppNode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeAll( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE clone( 
            /* [retval][out] */ IXMLDOMSelection **ppNode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getProperty( 
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT *value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setProperty( 
            /* [in] */ BSTR name,
            /* [in] */ VARIANT value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMSelectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMSelection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMSelection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMSelection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMSelection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMSelection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMSelection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMSelection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_item )( 
            IXMLDOMSelection * This,
            /* [in] */ long index,
            /* [retval][out] */ IXMLDOMNode **listItem);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IXMLDOMSelection * This,
            /* [retval][out] */ long *listLength);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *nextNode )( 
            IXMLDOMSelection * This,
            /* [retval][out] */ IXMLDOMNode **nextItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *reset )( 
            IXMLDOMSelection * This);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__newEnum )( 
            IXMLDOMSelection * This,
            /* [out][retval] */ IUnknown **ppUnk);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_expr )( 
            IXMLDOMSelection * This,
            /* [retval][out] */ BSTR *expression);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_expr )( 
            IXMLDOMSelection * This,
            /* [in] */ BSTR expression);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_context )( 
            IXMLDOMSelection * This,
            /* [retval][out] */ IXMLDOMNode **ppNode);
        
        /* [helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE *putref_context )( 
            IXMLDOMSelection * This,
            /* [in] */ IXMLDOMNode *pNode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *peekNode )( 
            IXMLDOMSelection * This,
            /* [retval][out] */ IXMLDOMNode **ppNode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *matches )( 
            IXMLDOMSelection * This,
            /* [in] */ IXMLDOMNode *pNode,
            /* [retval][out] */ IXMLDOMNode **ppNode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeNext )( 
            IXMLDOMSelection * This,
            /* [retval][out] */ IXMLDOMNode **ppNode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeAll )( 
            IXMLDOMSelection * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *clone )( 
            IXMLDOMSelection * This,
            /* [retval][out] */ IXMLDOMSelection **ppNode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getProperty )( 
            IXMLDOMSelection * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setProperty )( 
            IXMLDOMSelection * This,
            /* [in] */ BSTR name,
            /* [in] */ VARIANT value);
        
        END_INTERFACE
    } IXMLDOMSelectionVtbl;

    interface IXMLDOMSelection
    {
        CONST_VTBL struct IXMLDOMSelectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMSelection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMSelection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMSelection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMSelection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMSelection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMSelection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMSelection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMSelection_get_item(This,index,listItem)	\
    (This)->lpVtbl -> get_item(This,index,listItem)

#define IXMLDOMSelection_get_length(This,listLength)	\
    (This)->lpVtbl -> get_length(This,listLength)

#define IXMLDOMSelection_nextNode(This,nextItem)	\
    (This)->lpVtbl -> nextNode(This,nextItem)

#define IXMLDOMSelection_reset(This)	\
    (This)->lpVtbl -> reset(This)

#define IXMLDOMSelection_get__newEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__newEnum(This,ppUnk)


#define IXMLDOMSelection_get_expr(This,expression)	\
    (This)->lpVtbl -> get_expr(This,expression)

#define IXMLDOMSelection_put_expr(This,expression)	\
    (This)->lpVtbl -> put_expr(This,expression)

#define IXMLDOMSelection_get_context(This,ppNode)	\
    (This)->lpVtbl -> get_context(This,ppNode)

#define IXMLDOMSelection_putref_context(This,pNode)	\
    (This)->lpVtbl -> putref_context(This,pNode)

#define IXMLDOMSelection_peekNode(This,ppNode)	\
    (This)->lpVtbl -> peekNode(This,ppNode)

#define IXMLDOMSelection_matches(This,pNode,ppNode)	\
    (This)->lpVtbl -> matches(This,pNode,ppNode)

#define IXMLDOMSelection_removeNext(This,ppNode)	\
    (This)->lpVtbl -> removeNext(This,ppNode)

#define IXMLDOMSelection_removeAll(This)	\
    (This)->lpVtbl -> removeAll(This)

#define IXMLDOMSelection_clone(This,ppNode)	\
    (This)->lpVtbl -> clone(This,ppNode)

#define IXMLDOMSelection_getProperty(This,name,value)	\
    (This)->lpVtbl -> getProperty(This,name,value)

#define IXMLDOMSelection_setProperty(This,name,value)	\
    (This)->lpVtbl -> setProperty(This,name,value)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMSelection_get_expr_Proxy( 
    IXMLDOMSelection * This,
    /* [retval][out] */ BSTR *expression);


void __RPC_STUB IXMLDOMSelection_get_expr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMSelection_put_expr_Proxy( 
    IXMLDOMSelection * This,
    /* [in] */ BSTR expression);


void __RPC_STUB IXMLDOMSelection_put_expr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMSelection_get_context_Proxy( 
    IXMLDOMSelection * This,
    /* [retval][out] */ IXMLDOMNode **ppNode);


void __RPC_STUB IXMLDOMSelection_get_context_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE IXMLDOMSelection_putref_context_Proxy( 
    IXMLDOMSelection * This,
    /* [in] */ IXMLDOMNode *pNode);


void __RPC_STUB IXMLDOMSelection_putref_context_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMSelection_peekNode_Proxy( 
    IXMLDOMSelection * This,
    /* [retval][out] */ IXMLDOMNode **ppNode);


void __RPC_STUB IXMLDOMSelection_peekNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMSelection_matches_Proxy( 
    IXMLDOMSelection * This,
    /* [in] */ IXMLDOMNode *pNode,
    /* [retval][out] */ IXMLDOMNode **ppNode);


void __RPC_STUB IXMLDOMSelection_matches_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMSelection_removeNext_Proxy( 
    IXMLDOMSelection * This,
    /* [retval][out] */ IXMLDOMNode **ppNode);


void __RPC_STUB IXMLDOMSelection_removeNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMSelection_removeAll_Proxy( 
    IXMLDOMSelection * This);


void __RPC_STUB IXMLDOMSelection_removeAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMSelection_clone_Proxy( 
    IXMLDOMSelection * This,
    /* [retval][out] */ IXMLDOMSelection **ppNode);


void __RPC_STUB IXMLDOMSelection_clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMSelection_getProperty_Proxy( 
    IXMLDOMSelection * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ VARIANT *value);


void __RPC_STUB IXMLDOMSelection_getProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLDOMSelection_setProperty_Proxy( 
    IXMLDOMSelection * This,
    /* [in] */ BSTR name,
    /* [in] */ VARIANT value);


void __RPC_STUB IXMLDOMSelection_setProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMSelection_INTERFACE_DEFINED__ */


#ifndef __XMLDOMDocumentEvents_DISPINTERFACE_DEFINED__
#define __XMLDOMDocumentEvents_DISPINTERFACE_DEFINED__

/* dispinterface XMLDOMDocumentEvents */
/* [uuid][hidden] */ 


EXTERN_C const IID DIID_XMLDOMDocumentEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("3efaa427-272f-11d2-836f-0000f87a7782")
    XMLDOMDocumentEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct XMLDOMDocumentEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            XMLDOMDocumentEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            XMLDOMDocumentEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            XMLDOMDocumentEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            XMLDOMDocumentEvents * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            XMLDOMDocumentEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            XMLDOMDocumentEvents * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            XMLDOMDocumentEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } XMLDOMDocumentEventsVtbl;

    interface XMLDOMDocumentEvents
    {
        CONST_VTBL struct XMLDOMDocumentEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define XMLDOMDocumentEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define XMLDOMDocumentEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define XMLDOMDocumentEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define XMLDOMDocumentEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define XMLDOMDocumentEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define XMLDOMDocumentEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define XMLDOMDocumentEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __XMLDOMDocumentEvents_DISPINTERFACE_DEFINED__ */


#ifndef __IDSOControl_INTERFACE_DEFINED__
#define __IDSOControl_INTERFACE_DEFINED__

/* interface IDSOControl */
/* [unique][helpstring][hidden][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IDSOControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("310afa62-0575-11d2-9ca9-0060b0ec3d39")
    IDSOControl : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_XMLDocument( 
            /* [retval][out] */ IXMLDOMDocument **ppDoc) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_XMLDocument( 
            /* [in] */ IXMLDOMDocument *ppDoc) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_JavaDSOCompatible( 
            /* [retval][out] */ BOOL *fJavaDSOCompatible) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_JavaDSOCompatible( 
            /* [in] */ BOOL fJavaDSOCompatible) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_readyState( 
            /* [retval][out] */ long *state) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDSOControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDSOControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDSOControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDSOControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDSOControl * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDSOControl * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDSOControl * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDSOControl * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_XMLDocument )( 
            IDSOControl * This,
            /* [retval][out] */ IXMLDOMDocument **ppDoc);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_XMLDocument )( 
            IDSOControl * This,
            /* [in] */ IXMLDOMDocument *ppDoc);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_JavaDSOCompatible )( 
            IDSOControl * This,
            /* [retval][out] */ BOOL *fJavaDSOCompatible);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_JavaDSOCompatible )( 
            IDSOControl * This,
            /* [in] */ BOOL fJavaDSOCompatible);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_readyState )( 
            IDSOControl * This,
            /* [retval][out] */ long *state);
        
        END_INTERFACE
    } IDSOControlVtbl;

    interface IDSOControl
    {
        CONST_VTBL struct IDSOControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDSOControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDSOControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDSOControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDSOControl_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDSOControl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDSOControl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDSOControl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDSOControl_get_XMLDocument(This,ppDoc)	\
    (This)->lpVtbl -> get_XMLDocument(This,ppDoc)

#define IDSOControl_put_XMLDocument(This,ppDoc)	\
    (This)->lpVtbl -> put_XMLDocument(This,ppDoc)

#define IDSOControl_get_JavaDSOCompatible(This,fJavaDSOCompatible)	\
    (This)->lpVtbl -> get_JavaDSOCompatible(This,fJavaDSOCompatible)

#define IDSOControl_put_JavaDSOCompatible(This,fJavaDSOCompatible)	\
    (This)->lpVtbl -> put_JavaDSOCompatible(This,fJavaDSOCompatible)

#define IDSOControl_get_readyState(This,state)	\
    (This)->lpVtbl -> get_readyState(This,state)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDSOControl_get_XMLDocument_Proxy( 
    IDSOControl * This,
    /* [retval][out] */ IXMLDOMDocument **ppDoc);


void __RPC_STUB IDSOControl_get_XMLDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDSOControl_put_XMLDocument_Proxy( 
    IDSOControl * This,
    /* [in] */ IXMLDOMDocument *ppDoc);


void __RPC_STUB IDSOControl_put_XMLDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDSOControl_get_JavaDSOCompatible_Proxy( 
    IDSOControl * This,
    /* [retval][out] */ BOOL *fJavaDSOCompatible);


void __RPC_STUB IDSOControl_get_JavaDSOCompatible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDSOControl_put_JavaDSOCompatible_Proxy( 
    IDSOControl * This,
    /* [in] */ BOOL fJavaDSOCompatible);


void __RPC_STUB IDSOControl_put_JavaDSOCompatible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDSOControl_get_readyState_Proxy( 
    IDSOControl * This,
    /* [retval][out] */ long *state);


void __RPC_STUB IDSOControl_get_readyState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDSOControl_INTERFACE_DEFINED__ */


#ifndef __IXMLHTTPRequest_INTERFACE_DEFINED__
#define __IXMLHTTPRequest_INTERFACE_DEFINED__

/* interface IXMLHTTPRequest */
/* [unique][helpstring][oleautomation][dual][uuid][object] */ 


EXTERN_C const IID IID_IXMLHTTPRequest;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ED8C108D-4349-11D2-91A4-00C04F7969E8")
    IXMLHTTPRequest : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE open( 
            /* [in] */ BSTR bstrMethod,
            /* [in] */ BSTR bstrUrl,
            /* [optional][in] */ VARIANT varAsync,
            /* [optional][in] */ VARIANT bstrUser,
            /* [optional][in] */ VARIANT bstrPassword) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setRequestHeader( 
            /* [in] */ BSTR bstrHeader,
            /* [in] */ BSTR bstrValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getResponseHeader( 
            /* [in] */ BSTR bstrHeader,
            /* [retval][out] */ BSTR *pbstrValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getAllResponseHeaders( 
            /* [retval][out] */ BSTR *pbstrHeaders) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE send( 
            /* [optional][in] */ VARIANT varBody) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE abort( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_status( 
            /* [retval][out] */ long *plStatus) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_statusText( 
            /* [retval][out] */ BSTR *pbstrStatus) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_responseXML( 
            /* [retval][out] */ IDispatch **ppBody) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_responseText( 
            /* [retval][out] */ BSTR *pbstrBody) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_responseBody( 
            /* [retval][out] */ VARIANT *pvarBody) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_responseStream( 
            /* [retval][out] */ VARIANT *pvarBody) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_readyState( 
            /* [retval][out] */ long *plState) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_onreadystatechange( 
            /* [in] */ IDispatch *pReadyStateSink) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLHTTPRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLHTTPRequest * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLHTTPRequest * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLHTTPRequest * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLHTTPRequest * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLHTTPRequest * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLHTTPRequest * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLHTTPRequest * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *open )( 
            IXMLHTTPRequest * This,
            /* [in] */ BSTR bstrMethod,
            /* [in] */ BSTR bstrUrl,
            /* [optional][in] */ VARIANT varAsync,
            /* [optional][in] */ VARIANT bstrUser,
            /* [optional][in] */ VARIANT bstrPassword);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setRequestHeader )( 
            IXMLHTTPRequest * This,
            /* [in] */ BSTR bstrHeader,
            /* [in] */ BSTR bstrValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getResponseHeader )( 
            IXMLHTTPRequest * This,
            /* [in] */ BSTR bstrHeader,
            /* [retval][out] */ BSTR *pbstrValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getAllResponseHeaders )( 
            IXMLHTTPRequest * This,
            /* [retval][out] */ BSTR *pbstrHeaders);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *send )( 
            IXMLHTTPRequest * This,
            /* [optional][in] */ VARIANT varBody);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *abort )( 
            IXMLHTTPRequest * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_status )( 
            IXMLHTTPRequest * This,
            /* [retval][out] */ long *plStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_statusText )( 
            IXMLHTTPRequest * This,
            /* [retval][out] */ BSTR *pbstrStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_responseXML )( 
            IXMLHTTPRequest * This,
            /* [retval][out] */ IDispatch **ppBody);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_responseText )( 
            IXMLHTTPRequest * This,
            /* [retval][out] */ BSTR *pbstrBody);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_responseBody )( 
            IXMLHTTPRequest * This,
            /* [retval][out] */ VARIANT *pvarBody);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_responseStream )( 
            IXMLHTTPRequest * This,
            /* [retval][out] */ VARIANT *pvarBody);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_readyState )( 
            IXMLHTTPRequest * This,
            /* [retval][out] */ long *plState);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_onreadystatechange )( 
            IXMLHTTPRequest * This,
            /* [in] */ IDispatch *pReadyStateSink);
        
        END_INTERFACE
    } IXMLHTTPRequestVtbl;

    interface IXMLHTTPRequest
    {
        CONST_VTBL struct IXMLHTTPRequestVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLHTTPRequest_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLHTTPRequest_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLHTTPRequest_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLHTTPRequest_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLHTTPRequest_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLHTTPRequest_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLHTTPRequest_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLHTTPRequest_open(This,bstrMethod,bstrUrl,varAsync,bstrUser,bstrPassword)	\
    (This)->lpVtbl -> open(This,bstrMethod,bstrUrl,varAsync,bstrUser,bstrPassword)

#define IXMLHTTPRequest_setRequestHeader(This,bstrHeader,bstrValue)	\
    (This)->lpVtbl -> setRequestHeader(This,bstrHeader,bstrValue)

#define IXMLHTTPRequest_getResponseHeader(This,bstrHeader,pbstrValue)	\
    (This)->lpVtbl -> getResponseHeader(This,bstrHeader,pbstrValue)

#define IXMLHTTPRequest_getAllResponseHeaders(This,pbstrHeaders)	\
    (This)->lpVtbl -> getAllResponseHeaders(This,pbstrHeaders)

#define IXMLHTTPRequest_send(This,varBody)	\
    (This)->lpVtbl -> send(This,varBody)

#define IXMLHTTPRequest_abort(This)	\
    (This)->lpVtbl -> abort(This)

#define IXMLHTTPRequest_get_status(This,plStatus)	\
    (This)->lpVtbl -> get_status(This,plStatus)

#define IXMLHTTPRequest_get_statusText(This,pbstrStatus)	\
    (This)->lpVtbl -> get_statusText(This,pbstrStatus)

#define IXMLHTTPRequest_get_responseXML(This,ppBody)	\
    (This)->lpVtbl -> get_responseXML(This,ppBody)

#define IXMLHTTPRequest_get_responseText(This,pbstrBody)	\
    (This)->lpVtbl -> get_responseText(This,pbstrBody)

#define IXMLHTTPRequest_get_responseBody(This,pvarBody)	\
    (This)->lpVtbl -> get_responseBody(This,pvarBody)

#define IXMLHTTPRequest_get_responseStream(This,pvarBody)	\
    (This)->lpVtbl -> get_responseStream(This,pvarBody)

#define IXMLHTTPRequest_get_readyState(This,plState)	\
    (This)->lpVtbl -> get_readyState(This,plState)

#define IXMLHTTPRequest_put_onreadystatechange(This,pReadyStateSink)	\
    (This)->lpVtbl -> put_onreadystatechange(This,pReadyStateSink)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_open_Proxy( 
    IXMLHTTPRequest * This,
    /* [in] */ BSTR bstrMethod,
    /* [in] */ BSTR bstrUrl,
    /* [optional][in] */ VARIANT varAsync,
    /* [optional][in] */ VARIANT bstrUser,
    /* [optional][in] */ VARIANT bstrPassword);


void __RPC_STUB IXMLHTTPRequest_open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_setRequestHeader_Proxy( 
    IXMLHTTPRequest * This,
    /* [in] */ BSTR bstrHeader,
    /* [in] */ BSTR bstrValue);


void __RPC_STUB IXMLHTTPRequest_setRequestHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_getResponseHeader_Proxy( 
    IXMLHTTPRequest * This,
    /* [in] */ BSTR bstrHeader,
    /* [retval][out] */ BSTR *pbstrValue);


void __RPC_STUB IXMLHTTPRequest_getResponseHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_getAllResponseHeaders_Proxy( 
    IXMLHTTPRequest * This,
    /* [retval][out] */ BSTR *pbstrHeaders);


void __RPC_STUB IXMLHTTPRequest_getAllResponseHeaders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_send_Proxy( 
    IXMLHTTPRequest * This,
    /* [optional][in] */ VARIANT varBody);


void __RPC_STUB IXMLHTTPRequest_send_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_abort_Proxy( 
    IXMLHTTPRequest * This);


void __RPC_STUB IXMLHTTPRequest_abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_get_status_Proxy( 
    IXMLHTTPRequest * This,
    /* [retval][out] */ long *plStatus);


void __RPC_STUB IXMLHTTPRequest_get_status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_get_statusText_Proxy( 
    IXMLHTTPRequest * This,
    /* [retval][out] */ BSTR *pbstrStatus);


void __RPC_STUB IXMLHTTPRequest_get_statusText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_get_responseXML_Proxy( 
    IXMLHTTPRequest * This,
    /* [retval][out] */ IDispatch **ppBody);


void __RPC_STUB IXMLHTTPRequest_get_responseXML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_get_responseText_Proxy( 
    IXMLHTTPRequest * This,
    /* [retval][out] */ BSTR *pbstrBody);


void __RPC_STUB IXMLHTTPRequest_get_responseText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_get_responseBody_Proxy( 
    IXMLHTTPRequest * This,
    /* [retval][out] */ VARIANT *pvarBody);


void __RPC_STUB IXMLHTTPRequest_get_responseBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_get_responseStream_Proxy( 
    IXMLHTTPRequest * This,
    /* [retval][out] */ VARIANT *pvarBody);


void __RPC_STUB IXMLHTTPRequest_get_responseStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_get_readyState_Proxy( 
    IXMLHTTPRequest * This,
    /* [retval][out] */ long *plState);


void __RPC_STUB IXMLHTTPRequest_get_readyState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_put_onreadystatechange_Proxy( 
    IXMLHTTPRequest * This,
    /* [in] */ IDispatch *pReadyStateSink);


void __RPC_STUB IXMLHTTPRequest_put_onreadystatechange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLHTTPRequest_INTERFACE_DEFINED__ */


#ifndef __IServerXMLHTTPRequest_INTERFACE_DEFINED__
#define __IServerXMLHTTPRequest_INTERFACE_DEFINED__

/* interface IServerXMLHTTPRequest */
/* [unique][helpstring][oleautomation][dual][uuid][object] */ 


EXTERN_C const IID IID_IServerXMLHTTPRequest;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2e9196bf-13ba-4dd4-91ca-6c571f281495")
    IServerXMLHTTPRequest : public IXMLHTTPRequest
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setTimeouts( 
            /* [in] */ long resolveTimeout,
            /* [in] */ long connectTimeout,
            /* [in] */ long sendTimeout,
            /* [in] */ long receiveTimeout) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE waitForResponse( 
            /* [optional][in] */ VARIANT timeoutInSeconds,
            /* [retval][out] */ VARIANT_BOOL *isSuccessful) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getOption( 
            /* [in] */ SERVERXMLHTTP_OPTION option,
            /* [retval][out] */ VARIANT *value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setOption( 
            /* [in] */ SERVERXMLHTTP_OPTION option,
            /* [in] */ VARIANT value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServerXMLHTTPRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IServerXMLHTTPRequest * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IServerXMLHTTPRequest * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IServerXMLHTTPRequest * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IServerXMLHTTPRequest * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IServerXMLHTTPRequest * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IServerXMLHTTPRequest * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IServerXMLHTTPRequest * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *open )( 
            IServerXMLHTTPRequest * This,
            /* [in] */ BSTR bstrMethod,
            /* [in] */ BSTR bstrUrl,
            /* [optional][in] */ VARIANT varAsync,
            /* [optional][in] */ VARIANT bstrUser,
            /* [optional][in] */ VARIANT bstrPassword);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setRequestHeader )( 
            IServerXMLHTTPRequest * This,
            /* [in] */ BSTR bstrHeader,
            /* [in] */ BSTR bstrValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getResponseHeader )( 
            IServerXMLHTTPRequest * This,
            /* [in] */ BSTR bstrHeader,
            /* [retval][out] */ BSTR *pbstrValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getAllResponseHeaders )( 
            IServerXMLHTTPRequest * This,
            /* [retval][out] */ BSTR *pbstrHeaders);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *send )( 
            IServerXMLHTTPRequest * This,
            /* [optional][in] */ VARIANT varBody);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *abort )( 
            IServerXMLHTTPRequest * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_status )( 
            IServerXMLHTTPRequest * This,
            /* [retval][out] */ long *plStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_statusText )( 
            IServerXMLHTTPRequest * This,
            /* [retval][out] */ BSTR *pbstrStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_responseXML )( 
            IServerXMLHTTPRequest * This,
            /* [retval][out] */ IDispatch **ppBody);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_responseText )( 
            IServerXMLHTTPRequest * This,
            /* [retval][out] */ BSTR *pbstrBody);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_responseBody )( 
            IServerXMLHTTPRequest * This,
            /* [retval][out] */ VARIANT *pvarBody);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_responseStream )( 
            IServerXMLHTTPRequest * This,
            /* [retval][out] */ VARIANT *pvarBody);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_readyState )( 
            IServerXMLHTTPRequest * This,
            /* [retval][out] */ long *plState);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_onreadystatechange )( 
            IServerXMLHTTPRequest * This,
            /* [in] */ IDispatch *pReadyStateSink);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setTimeouts )( 
            IServerXMLHTTPRequest * This,
            /* [in] */ long resolveTimeout,
            /* [in] */ long connectTimeout,
            /* [in] */ long sendTimeout,
            /* [in] */ long receiveTimeout);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *waitForResponse )( 
            IServerXMLHTTPRequest * This,
            /* [optional][in] */ VARIANT timeoutInSeconds,
            /* [retval][out] */ VARIANT_BOOL *isSuccessful);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getOption )( 
            IServerXMLHTTPRequest * This,
            /* [in] */ SERVERXMLHTTP_OPTION option,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setOption )( 
            IServerXMLHTTPRequest * This,
            /* [in] */ SERVERXMLHTTP_OPTION option,
            /* [in] */ VARIANT value);
        
        END_INTERFACE
    } IServerXMLHTTPRequestVtbl;

    interface IServerXMLHTTPRequest
    {
        CONST_VTBL struct IServerXMLHTTPRequestVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServerXMLHTTPRequest_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IServerXMLHTTPRequest_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IServerXMLHTTPRequest_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IServerXMLHTTPRequest_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IServerXMLHTTPRequest_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IServerXMLHTTPRequest_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IServerXMLHTTPRequest_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IServerXMLHTTPRequest_open(This,bstrMethod,bstrUrl,varAsync,bstrUser,bstrPassword)	\
    (This)->lpVtbl -> open(This,bstrMethod,bstrUrl,varAsync,bstrUser,bstrPassword)

#define IServerXMLHTTPRequest_setRequestHeader(This,bstrHeader,bstrValue)	\
    (This)->lpVtbl -> setRequestHeader(This,bstrHeader,bstrValue)

#define IServerXMLHTTPRequest_getResponseHeader(This,bstrHeader,pbstrValue)	\
    (This)->lpVtbl -> getResponseHeader(This,bstrHeader,pbstrValue)

#define IServerXMLHTTPRequest_getAllResponseHeaders(This,pbstrHeaders)	\
    (This)->lpVtbl -> getAllResponseHeaders(This,pbstrHeaders)

#define IServerXMLHTTPRequest_send(This,varBody)	\
    (This)->lpVtbl -> send(This,varBody)

#define IServerXMLHTTPRequest_abort(This)	\
    (This)->lpVtbl -> abort(This)

#define IServerXMLHTTPRequest_get_status(This,plStatus)	\
    (This)->lpVtbl -> get_status(This,plStatus)

#define IServerXMLHTTPRequest_get_statusText(This,pbstrStatus)	\
    (This)->lpVtbl -> get_statusText(This,pbstrStatus)

#define IServerXMLHTTPRequest_get_responseXML(This,ppBody)	\
    (This)->lpVtbl -> get_responseXML(This,ppBody)

#define IServerXMLHTTPRequest_get_responseText(This,pbstrBody)	\
    (This)->lpVtbl -> get_responseText(This,pbstrBody)

#define IServerXMLHTTPRequest_get_responseBody(This,pvarBody)	\
    (This)->lpVtbl -> get_responseBody(This,pvarBody)

#define IServerXMLHTTPRequest_get_responseStream(This,pvarBody)	\
    (This)->lpVtbl -> get_responseStream(This,pvarBody)

#define IServerXMLHTTPRequest_get_readyState(This,plState)	\
    (This)->lpVtbl -> get_readyState(This,plState)

#define IServerXMLHTTPRequest_put_onreadystatechange(This,pReadyStateSink)	\
    (This)->lpVtbl -> put_onreadystatechange(This,pReadyStateSink)


#define IServerXMLHTTPRequest_setTimeouts(This,resolveTimeout,connectTimeout,sendTimeout,receiveTimeout)	\
    (This)->lpVtbl -> setTimeouts(This,resolveTimeout,connectTimeout,sendTimeout,receiveTimeout)

#define IServerXMLHTTPRequest_waitForResponse(This,timeoutInSeconds,isSuccessful)	\
    (This)->lpVtbl -> waitForResponse(This,timeoutInSeconds,isSuccessful)

#define IServerXMLHTTPRequest_getOption(This,option,value)	\
    (This)->lpVtbl -> getOption(This,option,value)

#define IServerXMLHTTPRequest_setOption(This,option,value)	\
    (This)->lpVtbl -> setOption(This,option,value)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IServerXMLHTTPRequest_setTimeouts_Proxy( 
    IServerXMLHTTPRequest * This,
    /* [in] */ long resolveTimeout,
    /* [in] */ long connectTimeout,
    /* [in] */ long sendTimeout,
    /* [in] */ long receiveTimeout);


void __RPC_STUB IServerXMLHTTPRequest_setTimeouts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IServerXMLHTTPRequest_waitForResponse_Proxy( 
    IServerXMLHTTPRequest * This,
    /* [optional][in] */ VARIANT timeoutInSeconds,
    /* [retval][out] */ VARIANT_BOOL *isSuccessful);


void __RPC_STUB IServerXMLHTTPRequest_waitForResponse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IServerXMLHTTPRequest_getOption_Proxy( 
    IServerXMLHTTPRequest * This,
    /* [in] */ SERVERXMLHTTP_OPTION option,
    /* [retval][out] */ VARIANT *value);


void __RPC_STUB IServerXMLHTTPRequest_getOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IServerXMLHTTPRequest_setOption_Proxy( 
    IServerXMLHTTPRequest * This,
    /* [in] */ SERVERXMLHTTP_OPTION option,
    /* [in] */ VARIANT value);


void __RPC_STUB IServerXMLHTTPRequest_setOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IServerXMLHTTPRequest_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_DOMDocument;

#ifdef __cplusplus

class DECLSPEC_UUID("F6D90F11-9C73-11D3-B32E-00C04F990BB4")
DOMDocument;
#endif

EXTERN_C const CLSID CLSID_DOMDocument26;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f1b-c551-11d3-89b9-0000f81fe221")
DOMDocument26;
#endif

EXTERN_C const CLSID CLSID_DOMDocument30;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f32-c551-11d3-89b9-0000f81fe221")
DOMDocument30;
#endif

EXTERN_C const CLSID CLSID_FreeThreadedDOMDocument;

#ifdef __cplusplus

class DECLSPEC_UUID("F6D90F12-9C73-11D3-B32E-00C04F990BB4")
FreeThreadedDOMDocument;
#endif

EXTERN_C const CLSID CLSID_FreeThreadedDOMDocument26;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f1c-c551-11d3-89b9-0000f81fe221")
FreeThreadedDOMDocument26;
#endif

EXTERN_C const CLSID CLSID_FreeThreadedDOMDocument30;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f33-c551-11d3-89b9-0000f81fe221")
FreeThreadedDOMDocument30;
#endif

EXTERN_C const CLSID CLSID_XMLSchemaCache;

#ifdef __cplusplus

class DECLSPEC_UUID("373984c9-b845-449b-91e7-45ac83036ade")
XMLSchemaCache;
#endif

EXTERN_C const CLSID CLSID_XMLSchemaCache26;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f1d-c551-11d3-89b9-0000f81fe221")
XMLSchemaCache26;
#endif

EXTERN_C const CLSID CLSID_XMLSchemaCache30;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f34-c551-11d3-89b9-0000f81fe221")
XMLSchemaCache30;
#endif

EXTERN_C const CLSID CLSID_XSLTemplate;

#ifdef __cplusplus

class DECLSPEC_UUID("2933BF94-7B36-11d2-B20E-00C04F983E60")
XSLTemplate;
#endif

EXTERN_C const CLSID CLSID_XSLTemplate26;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f21-c551-11d3-89b9-0000f81fe221")
XSLTemplate26;
#endif

EXTERN_C const CLSID CLSID_XSLTemplate30;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f36-c551-11d3-89b9-0000f81fe221")
XSLTemplate30;
#endif

EXTERN_C const CLSID CLSID_DSOControl;

#ifdef __cplusplus

class DECLSPEC_UUID("F6D90F14-9C73-11D3-B32E-00C04F990BB4")
DSOControl;
#endif

EXTERN_C const CLSID CLSID_DSOControl26;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f1f-c551-11d3-89b9-0000f81fe221")
DSOControl26;
#endif

EXTERN_C const CLSID CLSID_DSOControl30;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f39-c551-11d3-89b9-0000f81fe221")
DSOControl30;
#endif

EXTERN_C const CLSID CLSID_XMLHTTP;

#ifdef __cplusplus

class DECLSPEC_UUID("F6D90F16-9C73-11D3-B32E-00C04F990BB4")
XMLHTTP;
#endif

EXTERN_C const CLSID CLSID_XMLHTTP26;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f1e-c551-11d3-89b9-0000f81fe221")
XMLHTTP26;
#endif

EXTERN_C const CLSID CLSID_XMLHTTP30;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f35-c551-11d3-89b9-0000f81fe221")
XMLHTTP30;
#endif

EXTERN_C const CLSID CLSID_ServerXMLHTTP;

#ifdef __cplusplus

class DECLSPEC_UUID("afba6b42-5692-48ea-8141-dc517dcf0ef1")
ServerXMLHTTP;
#endif

EXTERN_C const CLSID CLSID_ServerXMLHTTP30;

#ifdef __cplusplus

class DECLSPEC_UUID("afb40ffd-b609-40a3-9828-f88bbe11e4e3")
ServerXMLHTTP30;
#endif

EXTERN_C const CLSID CLSID_SAXXMLReader;

#ifdef __cplusplus

class DECLSPEC_UUID("079aa557-4a18-424a-8eee-e39f0a8d41b9")
SAXXMLReader;
#endif

EXTERN_C const CLSID CLSID_SAXXMLReader30;

#ifdef __cplusplus

class DECLSPEC_UUID("3124c396-fb13-4836-a6ad-1317f1713688")
SAXXMLReader30;
#endif

EXTERN_C const CLSID CLSID_MXXMLWriter;

#ifdef __cplusplus

class DECLSPEC_UUID("fc220ad8-a72a-4ee8-926e-0b7ad152a020")
MXXMLWriter;
#endif

EXTERN_C const CLSID CLSID_MXXMLWriter30;

#ifdef __cplusplus

class DECLSPEC_UUID("3d813dfe-6c91-4a4e-8f41-04346a841d9c")
MXXMLWriter30;
#endif

EXTERN_C const CLSID CLSID_SAXAttributes;

#ifdef __cplusplus

class DECLSPEC_UUID("4dd441ad-526d-4a77-9f1b-9841ed802fb0")
SAXAttributes;
#endif

EXTERN_C const CLSID CLSID_SAXAttributes30;

#ifdef __cplusplus

class DECLSPEC_UUID("3e784a01-f3ae-4dc0-9354-9526b9370eba")
SAXAttributes30;
#endif

EXTERN_C const CLSID CLSID_XMLDocument;

#ifdef __cplusplus

class DECLSPEC_UUID("CFC399AF-D876-11d0-9C10-00C04FC99C8E")
XMLDocument;
#endif
#endif /* __MSXML2_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_msxml2_0167 */
/* [local] */ 

//----------------------------
// MSXML SPECIFIC ERROR CODES 
//----------------------------
#define E_XML_NOTWF 0xC00CE223L  // Validate failed because the document is not well formed.
#define E_XML_NODTD 0xC00CE224L  // Validate failed because a DTD/Schema was not specified in the document.
#define E_XML_INVALID 0xC00CE225L  // Validate failed because of a DTD/Schema violation.
#ifdef __USE_MSXML2_NAMESPACE__
}
#endif


extern RPC_IF_HANDLE __MIDL_itf_msxml2_0167_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msxml2_0167_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atls\allocate.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#include "stdafx.h"

#include "Common.h"
#include "Allocate.h"

#include "AtlTraceModuleManager.h"

#pragma comment(lib, "advapi32.lib")

bool CAtlAllocator::Init(const CHAR *pszFileName, DWORD dwMaxSize)
{
	// REVIEW:
	// We're relying on syncronization provided by the startup code (CRT DllMain/WinMain)
	Close();

	ATLASSERT(!m_hMap && !m_pBufferStart);

	SECURITY_DESCRIPTOR sd;
	SECURITY_ATTRIBUTES sa, *psa = NULL;
	if(!(GetVersion() & 0x80000000))
	{
		::InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
		::SetSecurityDescriptorDacl(&sd, TRUE, NULL, FALSE);
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = &sd;
		sa.bInheritHandle = FALSE;
		psa = &sa;
	}

	__try
	{
		m_hMap = CreateFileMappingA(INVALID_HANDLE_VALUE, psa,
			PAGE_READWRITE | SEC_RESERVE, 0, dwMaxSize, pszFileName);
		if(!m_hMap)
			__leave;
		DWORD dwErr = ::GetLastError();

		m_pBufferStart = (BYTE *)
			MapViewOfFile(m_hMap, FILE_MAP_ALL_ACCESS, 0, 0, 0);
		if(!m_pBufferStart)
			__leave;

		SYSTEM_INFO si;
		GetSystemInfo(&si);

		if(dwErr == ERROR_ALREADY_EXISTS)
		{
			m_pProcess = reinterpret_cast<CAtlTraceProcess *>(m_pBufferStart);

			// Looks like it's already mapped into this process space.
			// Let's do some checking...
			if(IsBadReadPtr(m_pProcess, sizeof(CAtlTraceProcess)) ||
				IsBadReadPtr(m_pProcess->Base(), sizeof(CAtlTraceProcess)) ||
				0 != memcmp(m_pBufferStart, m_pProcess->Base(), m_pProcess->m_dwFrontAlloc))
			{
				// something's not right
				__leave;
			}

			// sure looks valid
			m_pProcess->IncRef();
			m_pProcess = static_cast<CAtlTraceProcess *>(m_pProcess->Base());

			UnmapViewOfFile(m_pBufferStart);
			m_pBufferStart = reinterpret_cast<BYTE *>(m_pProcess);
		}
		else
		{
			// This is just in case sizeof(CAtlTraceProcess) is
			// ever > dwPageSize (doubtful that could ever
			// happen, but it's easy enough to avoid here)
			DWORD dwCurrAlloc = si.dwPageSize;
			while(dwCurrAlloc < sizeof(CAtlTraceProcess))
				dwCurrAlloc += si.dwPageSize;

			if(!VirtualAlloc(m_pBufferStart, dwCurrAlloc, MEM_COMMIT, PAGE_READWRITE))
				__leave;

			m_pProcess = new(m_pBufferStart) CAtlTraceProcess(dwMaxSize);
			m_pProcess->m_dwFrontAlloc = dwCurrAlloc;
			m_pProcess->m_dwCurrFront = sizeof(CAtlTraceProcess);
		}
		m_dwPageSize = si.dwPageSize;
		m_bValid = true;
	}
	__finally
	{
		if(!m_bValid)
		{
			if(m_pBufferStart)
			{
				UnmapViewOfFile(m_pBufferStart);
				m_pBufferStart = NULL;
			}

			if(m_hMap)
			{
				CloseHandle(m_hMap);
				m_hMap = NULL;
			}
		}
	}
	return m_bValid;
}
	
bool CAtlAllocator::Open(const CHAR *pszFileName)
{
	Close();

	__try
	{
		m_hMap = OpenFileMappingA(FILE_MAP_WRITE, FALSE, pszFileName);
		if(!m_hMap)
			__leave;

		m_pBufferStart = (BYTE *)
			MapViewOfFile(m_hMap, FILE_MAP_ALL_ACCESS, 0, 0, 0);
		if(!m_pBufferStart)
			__leave;

		m_pProcess = reinterpret_cast<CAtlTraceProcess *>(m_pBufferStart);
		m_pProcess->IncRef();

		SYSTEM_INFO si;
		GetSystemInfo(&si);
		m_dwPageSize = si.dwPageSize;

		m_bValid = true;
	}
	__finally
	{
		if(!m_bValid)
		{
			if(m_pBufferStart)
			{
				UnmapViewOfFile(m_pBufferStart);
				m_pBufferStart = NULL;
			}
			if(m_hMap)
			{
				CloseHandle(m_hMap);
				m_hMap = NULL;
			}

			m_pProcess = NULL;
		}
	}
	return m_bValid;
}

void CAtlAllocator::Close(bool bForceUnmap)
{
	if(m_bValid)
	{
		if(m_pProcess->DecRef() == 0 || bForceUnmap)
			UnmapViewOfFile(m_pBufferStart);
		m_pBufferStart = NULL;

		CloseHandle(m_hMap);
		m_hMap = NULL;

		m_bValid = false;
	}
}

CAtlTraceModule *CAtlAllocator::GetModule(int iModule) const
{
	if( iModule == -1 )
	{
		return NULL;
	}
	ATLASSERT(iModule < m_pProcess->ModuleCount());
	if(iModule < m_pProcess->ModuleCount())
	{
		BYTE *pb = reinterpret_cast<BYTE *>(m_pProcess) + sizeof(CAtlTraceProcess);
		return reinterpret_cast<CAtlTraceModule *>(pb) + iModule;
	}
	else
		return NULL;
}

/*
CAtlTraceCategory *CAtlAllocator::GetCategory(unsigned nModule, unsigned nCategory) const
{
	ATLASSERT(nModule < m_pProcess->ModuleCount());

	if(nModule < m_pProcess->ModuleCount())
	{
		BYTE *pb = reinterpret_cast<BYTE *>(m_pProcess) + sizeof(CAtlTraceProcess);
		CAtlTraceModule *pModule = reinterpret_cast<CAtlTraceModule *>(pb) + nModule;

		if(IsValidCategoryIndex(pModule->m_nFirstCategory))
		{
			unsigned nOldIndex, nIndex = pModule->m_nFirstCategory;
			CAtlTraceCategory *pCategory;
			do
			{
				pCategory = GetCategoryByIndex(nIndex);
				if(pCategory->m_nCategory == nCategory)
					return pCategory;

				nOldIndex = nIndex;
				nIndex = pCategory->m_nNext;
			}
			while(nOldIndex != nIndex);
		}
	}
	return NULL;
}
*/

/*
bool CAtlAllocator::IsValidCategoryIndex(unsigned nIndex) const
{
	return nIndex < m_pProcess->CategoryCount();
}
*/

CAtlTraceCategory *CAtlAllocator::GetCategory(int iCategory) const
{
	if(iCategory == m_pProcess->CategoryCount())
		return NULL;
	
	ATLASSERT((iCategory < m_pProcess->CategoryCount()) || (iCategory == -1));
	CAtlTraceCategory *pCategory = NULL;
	if(iCategory >= 0)
	{
		BYTE *pb = reinterpret_cast<BYTE *>(m_pProcess) + m_pProcess->MaxSize();
		pCategory = reinterpret_cast<CAtlTraceCategory *>(pb) - iCategory - 1;
	}
	return pCategory;
}

int CAtlAllocator::GetCategoryCount(int iModule) const
{
	UINT nCategories = 0;
	CAtlTraceModule* pModule = GetModule(iModule);
	ATLASSERT(pModule != NULL);
	if(pModule != NULL)
	{
		nCategories = GetCategoryCount( *pModule );
	}

	return nCategories;
}

int CAtlAllocator::GetCategoryCount(const CAtlTraceModule& rModule) const
{
	UINT nCategories = 0;
	int iCategory = rModule.m_iFirstCategory;
	while( iCategory != -1 )
	{
		CAtlTraceCategory* pCategory = GetCategory( iCategory );
		nCategories++;
		iCategory = pCategory->m_iNextCategory;
	}
	return nCategories;
}

int CAtlAllocator::GetModuleCount() const
{
	ATLASSERT(m_pProcess);
	return m_pProcess->ModuleCount();
}

const ULONG kModuleBatchSize = 10;

int CAtlAllocator::AddModule(HINSTANCE hInst)
{
	// bug bug bug - overlap onto the categories!!??

	CAtlTraceProcess *pProcess = GetProcess();
	int iFoundModule = -1;
	while( iFoundModule == -1 )
	{
		for(int iModule = 0; (iModule < pProcess->ModuleCount()) && (iFoundModule == -1); iModule++)
		{
			CAtlTraceModule *pModule = GetModule(iModule);
			ATLASSERT(pModule != NULL);
			bool bFound = pModule->TryAllocate();
			if( bFound )
			{
				pModule->Reset(hInst);
				pModule->m_iFirstCategory = -1;
				pModule->MarkValid( pProcess->GetNextCookie() );
				iFoundModule = iModule;
			}
		}
		if( iFoundModule == -1 )
		{
			ULONG nNewAllocSize = kModuleBatchSize*sizeof( CAtlTraceModule );
			void* pNewModules = reinterpret_cast<BYTE *>(pProcess) + pProcess->m_dwFrontAlloc;
			VirtualAlloc(pNewModules, nNewAllocSize, MEM_COMMIT, PAGE_READWRITE);
			pProcess->m_dwFrontAlloc += nNewAllocSize;
			for( ULONG iNewModule = 0; iNewModule < kModuleBatchSize; iNewModule++ )
			{
				CAtlTraceModule* pNewModule = static_cast< CAtlTraceModule* >( pNewModules )+iNewModule;
				new( pNewModule ) CAtlTraceModule;
			}
			pProcess->IncModuleCount( kModuleBatchSize );
		}
	}

	return iFoundModule;
}

const ULONG kCategoryBatchSize = 10;

int CAtlAllocator::AddCategory(int iModule, const WCHAR *szCategoryName)
{
	int iFoundCategory = -1;
	CAtlTraceProcess *pProcess = GetProcess();
	CAtlTraceModule *pModule = GetModule(iModule);
	if(pModule)
	{
		pModule->TryAddRef();

		while( iFoundCategory == -1 )
		{
			for(int iCategory = 0; (iCategory < pProcess->CategoryCount()) && (iFoundCategory == -1); iCategory++)
			{
				CAtlTraceCategory *pCategory = GetCategory( iCategory );
				ATLASSERT(pCategory != NULL);
				bool bFound = pCategory->TryAllocate();
				if( bFound )
				{
					pCategory->Reset( szCategoryName, pModule->m_nCookie );
					pCategory->m_iNextCategory = pModule->m_iFirstCategory;
					pCategory->MarkValid( pProcess->GetNextCookie() );
					pModule->m_iFirstCategory = iCategory;
					::InterlockedIncrement( &pModule->m_nCategories );
					iFoundCategory = iCategory;
				}
			}

			if( iFoundCategory == -1 )
			{
				ULONG nNewAllocSize = kCategoryBatchSize*sizeof( CAtlTraceCategory );
				void* pNewCategories = reinterpret_cast<BYTE *>(pProcess) + pProcess->MaxSize()-pProcess->m_dwBackAlloc-nNewAllocSize;
				VirtualAlloc(pNewCategories, nNewAllocSize, MEM_COMMIT, PAGE_READWRITE);
				pProcess->m_dwBackAlloc += nNewAllocSize;
				for( ULONG iNewCategory = 0; iNewCategory < kCategoryBatchSize; iNewCategory++ )
				{
					CAtlTraceCategory* pNewCategory = static_cast< CAtlTraceCategory* >( pNewCategories )+iNewCategory;
					new( pNewCategory ) CAtlTraceCategory;
				}
				pProcess->IncCategoryCount( kCategoryBatchSize );
			}
		}

		pModule->Release();
	}

	pProcess->m_bLoaded = false;

	return( iFoundCategory );
}

bool CAtlAllocator::RemoveModule(int iModule)
{
	CAtlTraceModule* pModule = GetModule(iModule);
	if(pModule)
	{
		int iCategory = pModule->m_iFirstCategory;
		while( iCategory != -1 )
		{
			CAtlTraceCategory* pCategory = GetCategory( iCategory );
			iCategory = pCategory->m_iNextCategory;
			::InterlockedDecrement( &pModule->m_nCategories );
			pModule->m_iFirstCategory = iCategory;
			pCategory->Release();
		}

		pModule->Release();
		return true;
	}
	return false;
}

void CAtlAllocator::CleanUp()
{
	Close();
}

void CAtlAllocator::TakeSnapshot()
{
	if( m_bSnapshot )
	{
		ReleaseSnapshot();
	}

	int nModules = GetModuleCount();
	for( int iModule = 0; iModule < nModules; iModule++ )
	{
		CAtlTraceModule* pModule = GetModule( iModule );
		bool bValidModule = pModule->TryAddRef();
		if( bValidModule )
		{
			CTraceSnapshot::CModuleInfo module;
			module.m_dwModule = DWORD_PTR( iModule )+1;
			module.m_iFirstCategory = m_snapshot.m_adwCategories.GetSize();
			module.m_nCategories = pModule->m_nCategories;

			int iCategory = pModule->m_iFirstCategory;
			bool bCategoriesValid = true;
			int nCategories = 0;
			while( (iCategory != -1) && bCategoriesValid )
			{
				CAtlTraceCategory* pCategory = GetCategory( iCategory );
				bool bValidCategory = pCategory->TryAddRef();
				if( bValidCategory )
				{
					if( pCategory->m_nModuleCookie != pModule->m_nCookie )
					{
						bValidCategory = false;
						pCategory->Release();
					}
					else
					{
						m_snapshot.m_adwCategories.Add( DWORD_PTR( iCategory ) );
						nCategories++;
						iCategory = pCategory->m_iNextCategory;
					}
				}
				if( !bValidCategory )
				{
					bCategoriesValid = false;
				}
			}
			if( !bCategoriesValid )
			{
				for( int iCategoryIndex = nCategories-1; iCategoryIndex >= 0; iCategoryIndex-- )
				{
					DWORD_PTR dwCategory = m_snapshot.m_adwCategories[module.m_iFirstCategory+iCategoryIndex];
					m_snapshot.m_adwCategories.RemoveAt( module.m_iFirstCategory+iCategoryIndex );
					GetCategory( int( dwCategory ) )->Release();
				}
				pModule->Release();
			}
			else
			{
				m_snapshot.m_aModules.Add( module );
			}
		}
	}

	m_bSnapshot = true;
}

void CAtlAllocator::ReleaseSnapshot()
{
	if( m_bSnapshot )
	{
		for( int iModule = 0; iModule < m_snapshot.m_aModules.GetSize(); iModule++ )
		{
			GetModule( int( m_snapshot.m_aModules[iModule].m_dwModule-1 ) )->Release();
		}
		for( int iCategory = 0; iCategory < m_snapshot.m_adwCategories.GetSize(); iCategory++ )
		{
			GetCategory( int( m_snapshot.m_adwCategories[iCategory] ) )->Release();
		}
		m_bSnapshot = false;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atls\atlchrdllm.c ===
/* Not shipping */
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atls\atlbase.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#include "StdAfx.H"

#pragma warning( disable: 4073 )  // initializers put in library initialization area

namespace ATL
{

#pragma init_seg( lib )

CAtlBaseModule	_AtlBaseModule;

};  // namespace ATL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atls\atlcommodule.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#include "StdAfx.H"

#pragma warning( disable: 4073 )  // initializers put in library initialization area

namespace ATL
{

#pragma init_seg( lib )

CAtlComModule	_AtlComModule;
};  // namespace ATL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atls\atldebugapi.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#include "StdAfx.h"

#include "Common.h"
#include "AtlTraceModuleManager.h"

namespace ATL
{
static bool ShouldTraceOutput(DWORD_PTR dwModule,
							  DWORD_PTR dwCategory,
							  UINT nLevel,
							  const CAtlTraceCategory **ppCategory,
							  CAtlTraceModule::fnCrtDbgReport_t *pfnCrtDbgReport);

void NotifyTool()
{
	HANDLE hEvent;
	hEvent = OpenEventA(EVENT_MODIFY_STATE, FALSE, g_pszUpdateEventName);

	if(hEvent)
	{
		SetEvent(hEvent);
		CloseHandle(hEvent);
	}
}

// API
DWORD_PTR __stdcall AtlTraceRegister(HINSTANCE hInst,
								int (__cdecl *fnCrtDbgReport)(int,const char *,int,const char *,const char *,...))
{
	int iModule = g_Allocator.AddModule(hInst);
	CAtlTraceModule* pModule = g_Allocator.GetModule(iModule);
	ATLASSERT(pModule != NULL);
	if(pModule != NULL)
	{
		pModule->CrtDbgReport(fnCrtDbgReport);
		NotifyTool();
	}

	return( DWORD_PTR( iModule )+1 );
}

BOOL __stdcall AtlTraceUnregister(DWORD_PTR dwModule)
{
	int iModule = int( dwModule-1 );
	g_Allocator.RemoveModule( iModule );

	NotifyTool();

	return TRUE;
}

DWORD_PTR __stdcall AtlTraceRegisterCategoryA(DWORD_PTR dwModule, const CHAR szCategoryName[ATL_TRACE_MAX_NAME_SIZE])
{
	USES_CONVERSION;
	return AtlTraceRegisterCategoryU(dwModule, A2W(szCategoryName));
}

DWORD_PTR __stdcall AtlTraceRegisterCategoryU(DWORD_PTR dwModule, const WCHAR szCategoryName[ATL_TRACE_MAX_NAME_SIZE])
{
	int iModule = int( dwModule-1 );

	int iCategory = g_Allocator.AddCategory(iModule, szCategoryName);
	NotifyTool();

	return( DWORD_PTR( iCategory )+1 );
}


BOOL __stdcall AtlTraceModifyProcess(DWORD_PTR dwProcess, UINT nLevel, BOOL bEnabled,
									 BOOL bFuncAndCategoryNames, BOOL bFileNameAndLineNo)
{
	CAtlAllocator* pAllocator = reinterpret_cast< CAtlAllocator* >( dwProcess );
#ifdef _DEBUG
	if( pAllocator == NULL )
	{
		pAllocator = &g_Allocator;
	}
#endif  // _DEBUG

	CAtlTraceProcess* pProcess = pAllocator->GetProcess();
	ATLASSERT(pProcess != NULL);
	if(pProcess != NULL)
	{
		pProcess->m_nLevel = nLevel;
		pProcess->m_bEnabled = 0 != bEnabled;
		pProcess->m_bFuncAndCategoryNames = 0 != bFuncAndCategoryNames;
		pProcess->m_bFileNameAndLineNo = 0 != bFileNameAndLineNo;
	}

	return( TRUE );
}

BOOL __stdcall AtlTraceModifyModule(DWORD_PTR dwProcess, DWORD_PTR dwModule, UINT nLevel, ATLTRACESTATUS eStatus)
{
	CAtlAllocator* pAllocator = reinterpret_cast< CAtlAllocator* >( dwProcess );
#ifdef _DEBUG
	if( pAllocator == NULL )
	{
		pAllocator = &g_Allocator;
	}
#endif  // _DEBUG

	int iModule = int( dwModule-1 );

	CAtlTraceModule* pModule = pAllocator->GetModule(iModule);
	ATLASSERT(pModule != NULL);
	if(pModule != NULL)
	{
		switch(eStatus)
		{
		case ATLTRACESTATUS_INHERIT:
			pModule->m_eStatus = CAtlTraceSettings::Inherit;
			break;
		case ATLTRACESTATUS_ENABLED:
			pModule->m_eStatus = CAtlTraceSettings::Enabled;
			break;
		case ATLTRACESTATUS_DISABLED:
			pModule->m_eStatus = CAtlTraceSettings::Disabled;
			break;
		default:
			ATLASSERT( false );
			break;
		}
		pModule->m_nLevel = nLevel;
	}

	return( TRUE );
}

BOOL __stdcall AtlTraceModifyCategory(DWORD_PTR dwProcess, DWORD_PTR dwCategory,
									  UINT nLevel, ATLTRACESTATUS eStatus)
{
	CAtlAllocator* pAllocator = reinterpret_cast< CAtlAllocator* >( dwProcess );
#ifdef _DEBUG
	if( pAllocator == NULL )
	{
		pAllocator = &g_Allocator;
	}
#endif  // _DEBUG

	int iCategory = int( dwCategory-1 );
	CAtlTraceCategory *pCategory = pAllocator->GetCategory( iCategory );
	if(pCategory != NULL)
	{
		switch(eStatus)
		{
		case ATLTRACESTATUS_INHERIT:
			pCategory->m_eStatus = CAtlTraceSettings::Inherit;
			break;
		case ATLTRACESTATUS_ENABLED:
			pCategory->m_eStatus = CAtlTraceSettings::Enabled;
			break;
		case ATLTRACESTATUS_DISABLED:
			pCategory->m_eStatus = CAtlTraceSettings::Disabled;
			break;
		default:
			ATLASSERT(false);
			break;
		}
		pCategory->m_nLevel = nLevel;
	}
	return TRUE;
}

BOOL __stdcall AtlTraceGetProcess(DWORD_PTR dwProcess, UINT *pnLevel, BOOL *pbEnabled,
								  BOOL *pbFuncAndCategoryNames, BOOL *pbFileNameAndLineNo)
{
	CAtlAllocator* pAllocator = reinterpret_cast< CAtlAllocator* >( dwProcess );
#ifdef _DEBUG
	if( pAllocator == NULL )
	{
		pAllocator = &g_Allocator;
	}
#endif  // _DEBUG

	CAtlTraceProcess* pProcess = pAllocator->GetProcess();
	ATLASSERT(pProcess != NULL);
	if(pProcess != NULL)
	{
		if(pnLevel)
			*pnLevel = pProcess->m_nLevel;
		if(pbEnabled)
			*pbEnabled = pProcess->m_bEnabled;
		if(pbFuncAndCategoryNames)
			*pbFuncAndCategoryNames = pProcess->m_bFuncAndCategoryNames;
		if(pbFileNameAndLineNo)
			*pbFileNameAndLineNo = pProcess->m_bFileNameAndLineNo;
	}

	return( TRUE );
}

BOOL __stdcall AtlTraceGetModule(DWORD_PTR dwProcess, DWORD_PTR dwModule, UINT *pnLevel, ATLTRACESTATUS *peStatus)
{
	CAtlAllocator* pAllocator = reinterpret_cast< CAtlAllocator* >( dwProcess );
#ifdef _DEBUG
	if( pAllocator == NULL )
	{
		pAllocator = &g_Allocator;
	}
#endif  // _DEBUG

	int iModule = int( dwModule-1 );
	CAtlTraceModule *pModule = pAllocator->GetModule(iModule);
	ATLASSERT(pModule != NULL);
	if(pModule != NULL)
	{
		if(pnLevel != NULL)
		{
			*pnLevel = pModule->m_nLevel;
		}

		if(peStatus != NULL)
		{
			switch(pModule->m_eStatus)
			{
			case CAtlTraceSettings::Inherit:
				*peStatus = ATLTRACESTATUS_INHERIT;
				break;
			case CAtlTraceSettings::Enabled:
				*peStatus = ATLTRACESTATUS_ENABLED;
				break;
			case CAtlTraceSettings::Disabled:
				*peStatus = ATLTRACESTATUS_DISABLED;
				break;
			default:
				ATLASSERT(false);
				break;
			}
		}
	}
	return TRUE;
}

BOOL __stdcall AtlTraceGetCategory(DWORD_PTR dwProcess, DWORD_PTR dwCategory, UINT *pnLevel,
								   ATLTRACESTATUS *peStatus)
{
	CAtlAllocator* pAllocator = reinterpret_cast< CAtlAllocator* >( dwProcess );
#ifdef _DEBUG
	if( pAllocator == NULL )
	{
		pAllocator = &g_Allocator;
	}
#endif  // _DEBUG

	int iCategory = int( dwCategory-1 );
	CAtlTraceCategory* pCategory = pAllocator->GetCategory( iCategory );
	ATLASSERT(pCategory != NULL);
	if(pCategory != NULL)
	{
		if(pnLevel != NULL)
		{
			*pnLevel = pCategory->m_nLevel;
		}

		if(peStatus != NULL)
		{
			switch(pCategory->m_eStatus)
			{
			case CAtlTraceSettings::Inherit:
				*peStatus = ATLTRACESTATUS_INHERIT;
				break;
			case CAtlTraceSettings::Enabled:
				*peStatus = ATLTRACESTATUS_ENABLED;
				break;
			case CAtlTraceSettings::Disabled:
				*peStatus = ATLTRACESTATUS_DISABLED;
				break;
			}
		}
	}

	return( TRUE );
}

void __stdcall AtlTraceGetUpdateEventNameA(CHAR *pszEventName)
{
	lstrcpyA(pszEventName, g_pszUpdateEventName);
}

void __stdcall AtlTraceGetUpdateEventNameU(WCHAR *pszEventName)
{
	USES_CONVERSION;
	lstrcpyW(pszEventName, A2W(g_pszUpdateEventName));
}

void __cdecl AtlTraceVA(DWORD_PTR dwModule, const char *pszFileName, int nLine,
						DWORD_PTR dwCategory, UINT nLevel, const CHAR *pszFormat, va_list ptr)
{
	const CAtlTraceCategory *pCategory;
	CAtlTraceModule::fnCrtDbgReport_t pfnCrtDbgReport = NULL;
	static const int nCount = 1024;
	CHAR szBuf[nCount] = {'\0'};
	int nLen = 0;

	if(ShouldTraceOutput(dwModule, dwCategory, nLevel, &pCategory, &pfnCrtDbgReport))
	{
		if(g_Allocator.GetProcess()->m_bFileNameAndLineNo)
			nLen += _snprintf(szBuf + nLen, nCount - nLen, "%s(%d) : ", pszFileName, nLine);

		if(pCategory && g_Allocator.GetProcess()->m_bFuncAndCategoryNames)
			nLen += _snprintf(szBuf + nLen, nCount - nLen, "%S: ", pCategory->Name());

		_vsnprintf(szBuf + nLen, nCount - nLen, pszFormat, ptr);

		if(pfnCrtDbgReport != NULL)
			pfnCrtDbgReport(_CRT_WARN, NULL, 0, NULL, "%s", szBuf);
		else
			OutputDebugStringA(szBuf);
	}
}

void __cdecl AtlTraceVU(DWORD_PTR dwModule, const char *pszFileName, int nLine,
						DWORD_PTR dwCategory, UINT nLevel, const WCHAR *pszFormat, va_list ptr)
{
	const CAtlTraceCategory *pCategory;
	CAtlTraceModule::fnCrtDbgReport_t pfnCrtDbgReport = NULL;
	const int nCount = 1024;
	WCHAR szBuf[nCount] = {L'\0'};
	int nLen = 0;

	if(ShouldTraceOutput(dwModule, dwCategory, nLevel, &pCategory, &pfnCrtDbgReport))
	{
		if(g_Allocator.GetProcess()->m_bFileNameAndLineNo)
			nLen += _snwprintf(szBuf + nLen, nCount - nLen, L"%S(%d) : ", pszFileName, nLine);

		if(pCategory && g_Allocator.GetProcess()->m_bFuncAndCategoryNames)
			nLen += _snwprintf(szBuf + nLen, nCount - nLen, L"%s: ", pCategory->Name());

		_vsnwprintf(szBuf + nLen, nCount - nLen, pszFormat, ptr);

		if(pfnCrtDbgReport)
			pfnCrtDbgReport(_CRT_WARN, NULL, 0, NULL, "%S", szBuf);
		else
			OutputDebugStringW(szBuf);
	}

}


// REVIEW: Necessary?
/*void __cdecl AtlTraceU(HINSTANCE hInst, UINT nCategory, UINT nLevel, const WCHAR *szFormat, ...)
{
	va_list ptr;
	va_start(ptr, szFormat);
	AtlTraceVU(hInst, nCategory, nLevel, szFormat, ptr);
	va_end(ptr);
}

void __cdecl AtlTraceA(HINSTANCE hInst, UINT nCategory, UINT nLevel, const CHAR *szFormat, ...)
{
	va_list ptr;
	va_start(ptr, szFormat);
	AtlTraceVA(hInst, nCategory, nLevel, szFormat, ptr);
	va_end(ptr);
}*/

DWORD_PTR __stdcall AtlTraceOpenProcess(DWORD idProcess)
{
	CAtlAllocator* pAllocator = new CAtlAllocator;

	char szBuf[64];
	sprintf(szBuf, g_pszKernelObjFmt, g_pszAllocFileMapName, idProcess);

	if( !pAllocator->Open(szBuf) )
	{
		delete pAllocator;
		return( 0 );
	}

	return( reinterpret_cast< DWORD_PTR >( pAllocator ) );
}

void __stdcall AtlTraceCloseProcess( DWORD_PTR dwProcess )
{
	CAtlAllocator* pAllocator = reinterpret_cast< CAtlAllocator* >( dwProcess );
	pAllocator->Close( true );
	delete pAllocator;
}

void __stdcall AtlTraceSnapshotProcess( DWORD_PTR dwProcess )
{
	CAtlAllocator* pAllocator = reinterpret_cast< CAtlAllocator* >( dwProcess );
	pAllocator->TakeSnapshot();
}

BOOL __stdcall AtlTraceGetProcessInfo(DWORD_PTR dwProcess, ATLTRACEPROCESSINFO* pProcessInfo)
{
	ATLASSERT(pProcessInfo != NULL);

	CAtlAllocator* pAllocator = reinterpret_cast< CAtlAllocator* >( dwProcess );
	ATLASSERT(pAllocator->m_bSnapshot);
	CAtlTraceProcess *pProcess = pAllocator->GetProcess();
	ATLASSERT(pProcess != NULL);

	if(pProcess)
	{
		lstrcpyW(pProcessInfo->szName, pProcess->Name());
		lstrcpyW(pProcessInfo->szPath, pProcess->Path());
		pProcessInfo->dwId = pProcess->Id();
		pProcessInfo->settings.nLevel = pProcess->m_nLevel;
		pProcessInfo->settings.bEnabled = pProcess->m_bEnabled;
		pProcessInfo->settings.bFuncAndCategoryNames = pProcess->m_bFuncAndCategoryNames;
		pProcessInfo->settings.bFileNameAndLineNo = pProcess->m_bFileNameAndLineNo;
		pProcessInfo->nModules = pAllocator->m_snapshot.m_aModules.GetSize();
	}
	return( TRUE );
}

void __stdcall AtlTraceGetModuleInfo(DWORD_PTR dwProcess, int iModule, ATLTRACEMODULEINFO* pModuleInfo)
{
	ATLASSERT(pModuleInfo != NULL);

	CAtlAllocator* pAllocator = reinterpret_cast< CAtlAllocator* >( dwProcess );
	ATLASSERT(pAllocator->m_bSnapshot);
	
	DWORD_PTR dwModule = pAllocator->m_snapshot.m_aModules[iModule].m_dwModule;
	CAtlTraceModule* pModule = pAllocator->GetModule(int(dwModule-1));
	lstrcpyW(pModuleInfo->szName, pModule->Name());
	lstrcpyW(pModuleInfo->szPath, pModule->Path());
	pModuleInfo->nCategories = pModule->m_nCategories;
	pModuleInfo->settings.nLevel = pModule->m_nLevel;
	pModuleInfo->dwModule = dwModule;
	switch(pModule->m_eStatus)
	{
	default:
	case CAtlTraceSettings::Inherit:
		pModuleInfo->settings.eStatus = ATLTRACESTATUS_INHERIT;
		break;
	case CAtlTraceSettings::Enabled:
		pModuleInfo->settings.eStatus = ATLTRACESTATUS_ENABLED;
		break;
	case CAtlTraceSettings::Disabled:
		pModuleInfo->settings.eStatus = ATLTRACESTATUS_DISABLED;
		break;
	}
}

void __stdcall AtlTraceGetCategoryInfo(DWORD_PTR dwProcess, DWORD_PTR dwModule, int iCategory, ATLTRACECATEGORYINFO* pCategoryInfo)
{
	ATLASSERT(pCategoryInfo != NULL);

	CAtlAllocator* pAllocator = reinterpret_cast< CAtlAllocator* >( dwProcess );
	ATLASSERT(pAllocator->m_bSnapshot);
	
	int iModule = int( dwModule-1 );
	CAtlTraceModule* pModule = pAllocator->GetModule( iModule );
	CAtlTraceCategory* pCategory = pAllocator->GetCategory( pModule->m_iFirstCategory );
	for( int iCategoryIndex = 0; iCategoryIndex < iCategory; iCategoryIndex++ )
	{
		pCategory = pAllocator->GetCategory( pCategory->m_iNextCategory );
	}

	lstrcpyW(pCategoryInfo->szName, pCategory->Name());
	pCategoryInfo->settings.nLevel = pCategory->m_nLevel;
	pCategoryInfo->dwCategory = DWORD_PTR( iCategory )+1;
	switch(pCategory->m_eStatus)
	{
	case CAtlTraceSettings::Inherit:
		pCategoryInfo->settings.eStatus = ATLTRACESTATUS_INHERIT;
		break;
	case CAtlTraceSettings::Enabled:
		pCategoryInfo->settings.eStatus = ATLTRACESTATUS_ENABLED;
		break;
	case CAtlTraceSettings::Disabled:
		pCategoryInfo->settings.eStatus = ATLTRACESTATUS_DISABLED;
		break;
	default:
		ATLASSERT( false );
		break;
	}
}

static bool ShouldTraceOutput(DWORD_PTR dwModule,
							  DWORD_PTR dwCategory,
							  UINT nLevel,
							  const CAtlTraceCategory **ppCategory,
							  CAtlTraceModule::fnCrtDbgReport_t *pfnCrtDbgReport)
{
	bool bFound = false;

	ATLASSERT(ppCategory && pfnCrtDbgReport);
	*ppCategory = NULL;
	*pfnCrtDbgReport = NULL;

	CAtlTraceProcess *pProcess = g_Allocator.GetProcess();
	ATLASSERT(pProcess);
	CAtlTraceModule *pModule = g_Allocator.GetModule( int( dwModule-1 ) );

	ATLASSERT(pModule != NULL);
	if(pModule != NULL)
	{
		*pfnCrtDbgReport = pModule->CrtDbgReport();

		CAtlTraceCategory *pCategory = g_Allocator.GetCategory( int( dwCategory ) );
		if( pCategory != NULL )
		{
			bFound = true;
			bool bOut = false;

			if(pProcess->m_bEnabled &&
				pModule->m_eStatus == CAtlTraceSettings::Inherit &&
				pCategory->m_eStatus == CAtlTraceSettings::Inherit &&
				nLevel <= pProcess->m_nLevel)
			{
				bOut = true;
			}
			else if(pModule->m_eStatus == CAtlTraceSettings::Enabled &&
				pCategory->m_eStatus == CAtlTraceSettings::Inherit &&
				nLevel <= pModule->m_nLevel)
			{
				bOut = true;
			}
			else if(pCategory->m_eStatus == CAtlTraceSettings::Enabled &&
				nLevel <= pCategory->m_nLevel)
			{
				bOut = true;
			}

			if(bOut)
			{
				*ppCategory = pProcess->m_bFuncAndCategoryNames ? pCategory : NULL;
				return true;
			}
		}
	}

	return false;
}																							

};  // namespace ATL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atls\atlimage2.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#include "StdAfx.H"

#pragma warning( disable: 4073 )  // initializers put in library initialization area

namespace ATL
{

#pragma init_seg( lib )

CImage::CInitGDIPlus CImage::s_initGDIPlus;

};  // namespace ATL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atls\atldebuginterfacesmodule.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#include "StdAfx.H"

#pragma warning( disable: 4073 )  // initializers put in library initialization area

namespace ATL
{

#pragma init_seg( lib )

CAtlDebugInterfacesModule _AtlDebugInterfacesModule;
};  // namespace ATL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atls\atlrdllm.cpp ===
// Not shipping
#include "StdAfx.H"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atls\atlimage.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#include "StdAfx.H"

#pragma warning( disable: 4073 )  // initializers put in library initialization area

namespace ATL
{

#pragma init_seg( lib )

CImage::CDCCache CImage::s_cache;

};  // namespace ATL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atls\atlstr.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#include "StdAfx.H"

#pragma warning( disable: 4073 )  // initializers put in library initialization area

namespace ATL
{

#pragma init_seg( lib )

CWin32Heap g_strheap( ::GetProcessHeap() );
CAtlStringMgr g_strmgr( &g_strheap );

};  // namespace ATL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atls\atltrace.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#include "StdAfx.H"

#pragma warning( disable: 4073 )  // initializers put in library initialization area

namespace ATL
{

#ifdef _DEBUG

#pragma init_seg( lib )

CTraceCategory atlTraceGeneral("atlTraceGeneral");
CTraceCategory atlTraceCOM("atlTraceCOM");  
CTraceCategory atlTraceQI("atlTraceQI");	
CTraceCategory atlTraceRegistrar("atlTraceRegistrar");
CTraceCategory atlTraceRefcount("atlTraceRefcount");
CTraceCategory atlTraceWindowing("atlTraceWindowing");
CTraceCategory atlTraceControls("atlTraceControls");
CTraceCategory atlTraceHosting("atlTraceHosting"); 
CTraceCategory atlTraceDBClient("atlTraceDBClient");  
CTraceCategory atlTraceDBProvider("atlTraceDBProvider");
CTraceCategory atlTraceSnapin("atlTraceSnapin");
CTraceCategory atlTraceNotImpl("atlTraceNotImpl");   
CTraceCategory atlTraceAllocation("atlTraceAllocation");
CTraceCategory atlTraceException("atlTraceException");
CTraceCategory atlTraceTime("atlTraceTime");
CTraceCategory atlTraceCache("atlTraceCache");
CTraceCategory atlTraceStencil("atlTraceStencil");
CTraceCategory atlTraceString("atlTraceString");
CTraceCategory atlTraceMap("atlTraceMap");	
CTraceCategory atlTraceUtil("atlTraceUtil");		
CTraceCategory atlTraceSecurity("atlTraceSecurity");
CTraceCategory atlTraceSync("atlTraceSync");
CTraceCategory atlTraceISAPI("atlTraceISAPI");		

#pragma warning( disable: 4995 )  // Ignore #pragma deprecated warnings
CTraceCategory atlTraceUser("atlTraceUser");		
CTraceCategory atlTraceUser2("atlTraceUser2");		
CTraceCategory atlTraceUser3("atlTraceUser3");		
CTraceCategory atlTraceUser4("atlTraceUser4");		

#endif

};  // namespace ATL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atls\atlmem.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#include "StdAfx.H"

#pragma warning( disable: 4073 )  // initializers put in library initialization area

namespace ATL
{

#pragma init_seg( lib )

CCRTHeap g_heapCRT;

};  // namespace ATL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atls\atltracemodulemanager.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#include "stdafx.h"
#include "Common.h"
#include "AtlTraceModuleManager.h"

extern HINSTANCE g_hInst;

CAtlTraceModuleInfo::CAtlTraceModuleInfo() :
	m_hInst(NULL),
	m_nCategories(0),
	m_iFirstCategory(-1)
{
	m_szPath[0] = L'\0';
	m_szName[0] = L'\0';
}

void CAtlTraceModuleInfo::Reset(HINSTANCE hInst)
{
	WCHAR szModulePath[MAX_PATH] = {L'\0'};
	if(0 != (GetVersion() & 0x80000000))
	{
		USES_CONVERSION;
		CHAR szTemp[MAX_PATH];
		if(GetModuleFileNameA(hInst, szTemp, MAX_PATH))
			wcscpy(szModulePath, A2W(szTemp));
	}
	else
		GetModuleFileNameW(hInst, szModulePath, MAX_PATH);

	wcsncpy(m_szPath, szModulePath, MAX_PATH);
	WCHAR *pszShortName = m_szPath + wcslen(m_szPath);
	while(pszShortName > m_szPath && *(pszShortName - 1) != L'\\')
		pszShortName--;
	wcsncpy(m_szName, pszShortName, ATL_TRACE_MAX_NAME_SIZE);

	m_hInst = hInst;
	m_nCategories = 0;
	m_iFirstCategory = -1;
}

// Categories
CAtlTraceCategory::CAtlTraceCategory() : 
	m_nModuleCookie(0)
{
	Reset(L"", 0);
}

void CAtlTraceCategory::Reset(const WCHAR *pszName, LONG nModuleCookie)
{
	wcsncpy(m_szName, pszName, ATL_TRACE_MAX_NAME_SIZE);
	m_nModuleCookie = nModuleCookie;
}

// Modules
CAtlTraceModule::CAtlTraceModule() :
	m_pfnCrtDbgReport(NULL)
{
}

void CAtlTraceModule::CrtDbgReport(CAtlTraceModule::fnCrtDbgReport_t pfnCrtDbgReport)
{
#ifdef _DEBUG
	m_pfnCrtDbgReport = pfnCrtDbgReport ? pfnCrtDbgReport : _CrtDbgReport;
#else
	m_pfnCrtDbgReport = pfnCrtDbgReport ? pfnCrtDbgReport : NULL;
#endif
}

// Processes
CAtlTraceProcess::CAtlTraceProcess(DWORD_PTR dwMaxSize) :
	CAtlTraceModuleInfo(),
	m_dwId(GetCurrentProcessId()), m_nRef(1), m_dwMaxSize(dwMaxSize),
	m_dwFrontAlloc(0), m_dwBackAlloc(0), m_dwCurrFront(0), m_dwCurrBack(0),
	m_nLevel(0), m_bLoaded(false), m_bEnabled(true), m_bFuncAndCategoryNames(false), m_bFileNameAndLineNo(false),
	m_nNextCookie( 0 )
{
	m_pvBase = this;
}

LONG CAtlTraceProcess::GetNextCookie()
{
	return( ::InterlockedIncrement( &m_nNextCookie ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atls\atlwinmodule.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#include "StdAfx.H"

#pragma warning( disable: 4073 )  // initializers put in library initialization area

namespace ATL
{

//#pragma init_seg( lib )

CAtlWinModule	_AtlWinModule;
};  // namespace ATL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atls\stdafx.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#include "StdAfx.H"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atls\externs.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#include "stdafx.h"
#include "Common.h"
#include "Allocate.h"

#pragma warning(disable : 4074)
#pragma init_seg(compiler)

const char *g_pszUpdateEventName	= "AtlTraceModuleManager_ProcessAddedStatic3";
const char *g_pszAllocFileMapName	= "AtlDebugAllocator_FileMappingNameStatic3";

const char *g_pszKernelObjFmt = "%s_%0x";

CAtlAllocator g_Allocator;

static bool Init()
{
	const int nSize = 64;
	char szFileMappingName[nSize];

	sprintf(szFileMappingName, g_pszKernelObjFmt,
		g_pszAllocFileMapName, GetCurrentProcessId());

	// REVIEW: surely four megs is enough?
	return g_Allocator.Init(szFileMappingName, 4 * 1024 * 1024);
}

static const bool g_bInitialized = Init();

#ifdef _DEBUG

namespace ATL
{

CTrace g_AtlTrace;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atls\stdafx.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#include <atlbase.h>
#include <atlimage.h>
#include <atlmem.h>
#include <atlstr.h>

#include <atldebugapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atls\common.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

extern const char *g_pszUpdateEventName;
extern const char *g_pszLockMutexName;
extern const char *g_pszLockEventName;
extern const char *g_pszAllocFileMapName;
extern const char *g_pszAllocMutexName;

extern const char *g_pszKernelObjFmt;

extern const wchar_t *g_pszProcessObject;
extern const wchar_t *g_pszReadsInProgress;

extern class CAtlAllocator g_Allocator;
extern class CAtlTraceLock g_Lock;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atls\loadnsave.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#include "stdafx.h"
#include "Common.h"
#include "AtlTraceModuleManager.h"

namespace ATL
{
void NotifyTool();

#if 0
static bool SetSettings(CAtlTraceSettings *pTraceSettings, UINT nLevel, UINT nStatus)
{
	ATLASSERT(pTraceSettings);
	if(!pTraceSettings)
		return false;

	pTraceSettings->m_nLevel = nLevel;
	switch(nStatus)
	{
	case 0:
		pTraceSettings->m_eStatus = CAtlTraceSettings::Inherit;
		break;
	case 1:
		pTraceSettings->m_eStatus = CAtlTraceSettings::Enabled;
		break;
	case 2:
	default:
		pTraceSettings->m_eStatus = CAtlTraceSettings::Disabled;
		break;
	}
	return true;
}

static bool GetSettings(const CAtlTraceSettings &rTraceSettings, UINT *pnStatus)
{
	ATLASSERT(pnStatus);
	if(!pnStatus)
		return false;

	switch(rTraceSettings.m_eStatus)
	{
	case CAtlTraceSettings::Inherit:
		*pnStatus = 0;
		break;
	case CAtlTraceSettings::Enabled:
		*pnStatus = 1;
		break;
	case CAtlTraceSettings::Disabled:
	default:
		*pnStatus = 2;
		break;
	}
	return true;
}

BOOL __stdcall AtlTraceLoadSettingsA(const CHAR *pszFileName, BOOL bForceLoad)
{
	CAtlAllocatorLock lock(&g_Allocator);
	if(!lock.Locked())
		return FALSE;

	CHAR szFileName[_MAX_PATH];
	if(!pszFileName)
	{
		CHAR szDrive[_MAX_DRIVE];
		CHAR szDir[_MAX_DIR];
		CHAR szFName[_MAX_FNAME];
		CHAR szExt[_MAX_EXT];

		::GetModuleFileNameA(NULL, szFileName, MAX_PATH);
		_splitpath(szFileName, szDrive, szDir, szFName, szExt);
		strcpy(szExt, ".trc");
		_makepath(szFileName, szDrive, szDir, szFName, szExt);
		pszFileName = szFileName;
	}

	if(pszFileName)
	{
		if(-1 != GetFileAttributesA(pszFileName))
		{
			// file exists
			CHAR szSection[MAX_PATH], szKey[MAX_PATH], szValue[MAX_PATH];
			CHAR szName[MAX_PATH];
			UINT nModules, nCategories, nStatus, nLevel;
			UINT nModule, nCategory;
			CAtlTraceProcess *pProcess;
			CAtlTraceModule *pModule;
			CAtlTraceCategory *pCategory;
			CHAR *pszProcess = "Process";
			CHAR cEnabled, cFuncAndCategoryNames, cFileNameAndLineInfo;

			pProcess = g_Allocator.GetProcess();
			ATLASSERT(pProcess);
			if(!pProcess)
				return FALSE;

			if(!pProcess->m_bLoaded || bForceLoad)
			{
				pProcess->m_bLoaded = true;

				::GetPrivateProfileStringA(pszProcess, "Info", "", szValue, MAX_PATH, pszFileName);
				if(5 != sscanf(szValue, "ModuleCount:%u, Level:%u, Enabled:%c, "
					"FuncAndCategoryNames:%c, FileNameAndLineNo:%c", &nModules, &pProcess->m_nLevel, &cEnabled,
					&cFuncAndCategoryNames, &cFileNameAndLineInfo))
				{
					return FALSE;
				}
				pProcess->m_bEnabled = cEnabled != 'f';
				pProcess->m_bFuncAndCategoryNames = cFuncAndCategoryNames != 'f';
				pProcess->m_bFileNameAndLineNo = cFileNameAndLineInfo != 'f';

				// REVIEW: conversion in loop
				USES_CONVERSION;
				for(UINT i = 0; i < nModules; i++)
				{
					sprintf(szKey, "Module%d", i);
					::GetPrivateProfileStringA(pszProcess, szKey, "", szSection, MAX_PATH, pszFileName);

					::GetPrivateProfileStringA(szSection, "Name", "", szName, MAX_PATH, pszFileName);
					if(!g_Allocator.FindModule(A2W(szName), &nModule))
						continue;

					pModule = g_Allocator.GetModule(nModule);
					ATLASSERT(pModule);
					if(!pModule)
						return FALSE;

					::GetPrivateProfileStringA(szSection, "Settings", "", szValue, MAX_PATH, pszFileName);
					if(3 != sscanf(szValue, "CategoryCount:%u, Level:%u, Status:%u", &nCategories, &nLevel, &nStatus))
						return FALSE;

					SetSettings(pModule, nLevel, nStatus);

					for(UINT j = 0; j < nCategories; j++)
					{
						sprintf(szKey, "Category%d", j);
						::GetPrivateProfileStringA(szSection, szKey, "", szValue, MAX_PATH, pszFileName);

						if(4 != sscanf(szValue, "Category:%u, Level:%u, Status:%u, Name:%s", &nCategory, &nLevel, &nStatus, szName))
							return FALSE;

						UINT iCategory = pModule->m_nFirstCategory;
						while( iCategory != UINT( -1 ) )
						{
							pCategory = g_Allocator.GetCategoryByIndex(iCategory);

							if( lstrcmpA(W2A(pCategory->Name()), szName) == 0 )
							{
								SetSettings(pCategory, nLevel, nStatus);
							}
							iCategory = pCategory->m_nNext;
						}
					}
				}
				NotifyTool();
			}
		}
	}
	return TRUE;
}

BOOL __stdcall AtlTraceSaveSettingsA(const CHAR *pszFileName)
{
	CAtlAllocatorLock lock(&g_Allocator);
	if(!lock.Locked())
		return FALSE;

	ATLASSERT(pszFileName);
	if(!pszFileName)
		return FALSE;

	BOOL bRetVal = FALSE;

	CHAR szKey[MAX_PATH], szValue[MAX_PATH];
	UINT nCategories, nStatus;
	CAtlTraceProcess *pProcess;
	CAtlTraceModule *pModule;
	CAtlTraceCategory *pCategory;
	LPCSTR pszProcess = "Process";

	pProcess = g_Allocator.GetProcess();
	ATLASSERT(pProcess);
	if(!pProcess)
		return FALSE;

	bRetVal = TRUE;

	sprintf(szValue, "ModuleCount:%u, Level:%u, Enabled:%c, "
		"FuncAndCategoryNames:%c, FileNameAndLineNo:%c", pProcess->ModuleCount(), pProcess->m_nLevel,
		pProcess->m_bEnabled ? 't' : 'f', pProcess->m_bFuncAndCategoryNames ? 't' : 'f',
		pProcess->m_bFileNameAndLineNo ? 't' : 'f');
	::WritePrivateProfileStringA(pszProcess, "Info", szValue, pszFileName);

	// REVIEW: conversion in loop
	USES_CONVERSION;
	for(UINT i = 0; i <  pProcess->ModuleCount(); i++)
	{
		pModule = g_Allocator.GetModule(i);
		ATLASSERT(pModule);
		if(!pModule)
			return FALSE;

		sprintf(szKey, "Module%d", i);
		::WritePrivateProfileStringA(pszProcess, szKey, W2A(pModule->Name()), pszFileName);
		GetSettings(*pModule, &nStatus);

		nCategories = g_Allocator.GetCategoryCount(i);

		::WritePrivateProfileStringA(W2A(pModule->Name()), "Name", W2A(pModule->Path()), pszFileName);
		sprintf(szValue, "CategoryCount:%u, Level:%u, Status:%u", nCategories, pModule->m_nLevel, nStatus);
		::WritePrivateProfileStringA(W2A(pModule->Name()), "Settings", szValue, pszFileName);

		if(g_Allocator.IsValidCategoryIndex(pModule->m_nFirstCategory))
		{
			int j = 0;
			UINT nCategory = pModule->m_nFirstCategory;
			while( nCategory != UINT( -1 ) )
			{
				pCategory = g_Allocator.GetCategoryByIndex(nCategory);

				GetSettings(*pCategory, &nStatus);

				sprintf(szKey, "Category%d", j++);
				sprintf(szValue, "Category:%u, Level:%u, Status:%u, Name:%S",
					0, pCategory->m_nLevel, nStatus, pCategory->Name());
				::WritePrivateProfileStringA(W2A(pModule->Name()), szKey, szValue, pszFileName);

				nCategory = pCategory->m_nNext;
			}
		}
	}
	return bRetVal;
}

BOOL __stdcall AtlTraceLoadSettingsU(const WCHAR *pszFileName, BOOL bForceLoad)
{
	CAtlAllocatorLock lock(&g_Allocator);
	if(!lock.Locked())
		return FALSE;

	WCHAR szFileName[MAX_PATH];
	if(!pszFileName)
	{
		WCHAR szDrive[_MAX_DRIVE];
		WCHAR szDir[_MAX_DIR];
		WCHAR szFName[_MAX_FNAME];
		WCHAR szExt[_MAX_EXT];

		::GetModuleFileNameW(NULL, szFileName, MAX_PATH);
		_wsplitpath(szFileName, szDrive, szDir, szFName, szExt);
		wcscpy(szExt, L".trc");
		_wmakepath(szFileName, szDrive, szDir, szFName, szExt);
		pszFileName = szFileName;
	}

	if(pszFileName)
	{
		if(-1 != GetFileAttributesW(pszFileName))
		{
			// file exists
			WCHAR szSection[MAX_PATH], szKey[MAX_PATH], szValue[MAX_PATH];
			WCHAR szName[MAX_PATH];
			UINT nModules, nCategories, nStatus, nLevel;
			UINT nModule, nCategory;
			CAtlTraceProcess *pProcess;
			CAtlTraceModule *pModule;
			CAtlTraceCategory *pCategory;
			LPCWSTR pszProcess = L"Process";
			WCHAR cEnabled, cFuncAndCategoryNames, cFileNameAndLineInfo;

			pProcess = g_Allocator.GetProcess();
			ATLASSERT(pProcess);
			if(!pProcess)
				return FALSE;

			if(!pProcess->m_bLoaded || bForceLoad)
			{
				pProcess->m_bLoaded = true;

				::GetPrivateProfileStringW(pszProcess, L"Info", L"", szValue, MAX_PATH, pszFileName);
				if(5 != swscanf(szValue, L"ModuleCount:%u, Level:%u, Enabled:%c, "
					L"FuncAndCategoryNames:%c, FileNameAndLineNo:%c", &nModules, &pProcess->m_nLevel, &cEnabled,
					&cFuncAndCategoryNames, &cFileNameAndLineInfo))
				{
					return FALSE;
				}
				pProcess->m_bEnabled = cEnabled != L'f';
				pProcess->m_bFuncAndCategoryNames = cFuncAndCategoryNames != L'f';
				pProcess->m_bFileNameAndLineNo = cFileNameAndLineInfo != L'f';

				for(UINT i = 0; i < nModules; i++)
				{
					swprintf(szKey, L"Module%d", i);
					::GetPrivateProfileStringW(pszProcess, szKey, L"", szSection, MAX_PATH, pszFileName);

					::GetPrivateProfileStringW(szSection, L"Name", L"", szName, MAX_PATH, pszFileName);
					if(!g_Allocator.FindModule(szName, &nModule))
						continue;

					pModule = g_Allocator.GetModule(nModule);
					ATLASSERT(pModule);
					if(!pModule)
						return FALSE;

					::GetPrivateProfileStringW(szSection, L"Settings", L"", szValue, MAX_PATH, pszFileName);
					if(3 != swscanf(szValue, L"CategoryCount:%u, Level:%u, Status:%u", &nCategories, &nLevel, &nStatus))
						return FALSE;

					SetSettings(pModule, nLevel, nStatus);

					for(UINT j = 0; j < nCategories; j++)
					{
						swprintf(szKey, L"Category%d", j);
						::GetPrivateProfileStringW(szSection, szKey, L"", szValue, MAX_PATH, pszFileName);

						if(4 != swscanf(szValue, L"Category:%u, Level:%u, Status:%u, Name:%s", &nCategory, &nLevel, &nStatus, szName))
							return FALSE;

						UINT iCategory = pModule->m_nFirstCategory;
						while( iCategory != UINT( -1 ) )
						{
							pCategory = g_Allocator.GetCategoryByIndex(iCategory);

							if( lstrcmpW(pCategory->Name(), szName) == 0 )
							{
								SetSettings(pCategory, nLevel, nStatus);
							}
							iCategory = pCategory->m_nNext;
						}
					}
				}
				NotifyTool();
			}
		}
	}
	return TRUE;
}

BOOL __stdcall AtlTraceSaveSettingsU(const WCHAR *pszFileName)
{
	CAtlAllocatorLock lock(&g_Allocator);
	if(!lock.Locked())
		return FALSE;

	ATLASSERT(pszFileName);
	if(!pszFileName)
		return FALSE;

	BOOL bRetVal = FALSE;

	WCHAR szKey[MAX_PATH], szValue[MAX_PATH];
	UINT nCategories, nStatus;
	CAtlTraceProcess *pProcess;
	CAtlTraceModule *pModule;
	CAtlTraceCategory *pCategory;
	LPCWSTR pszProcess = L"Process";

	pProcess = g_Allocator.GetProcess();
	ATLASSERT(pProcess);
	if(!pProcess)
		return FALSE;

	bRetVal = TRUE;

	swprintf(szValue, L"ModuleCount:%u, Level:%u, Enabled:%c, "
		L"FuncAndCategoryNames:%c, FileNameAndLineNo:%c", pProcess->ModuleCount(), pProcess->m_nLevel,
		pProcess->m_bEnabled ? L't' : L'f', pProcess->m_bFuncAndCategoryNames ? L't' : L'f',
		pProcess->m_bFileNameAndLineNo ? L't' : L'f');
	::WritePrivateProfileStringW(pszProcess, L"Info", szValue, pszFileName);

	for(UINT i = 0; i <  pProcess->ModuleCount(); i++)
	{
		pModule = g_Allocator.GetModule(i);
		ATLASSERT(pModule);
		if(!pModule)
			return FALSE;

		swprintf(szKey, L"Module%d", i);
		::WritePrivateProfileStringW(pszProcess, szKey, pModule->Name(), pszFileName);
		GetSettings(*pModule, &nStatus);

		nCategories = g_Allocator.GetCategoryCount(i);

		::WritePrivateProfileStringW(pModule->Name(), L"Name", pModule->Path(), pszFileName);
		swprintf(szValue, L"CategoryCount:%u, Level:%u, Status:%u", nCategories, pModule->m_nLevel, nStatus);
		::WritePrivateProfileStringW(pModule->Name(), L"Settings", szValue, pszFileName);

		if(g_Allocator.IsValidCategoryIndex(pModule->m_nFirstCategory))
		{
			int j = 0;
			UINT nCategory = pModule->m_nFirstCategory;
			while( nCategory != UINT( -1 ) )
			{
				pCategory = g_Allocator.GetCategoryByIndex(nCategory);

				GetSettings(*pCategory, &nStatus);

				swprintf(szKey, L"Category%d", j++);
				swprintf(szValue, L"Category:%u, Level:%u, Status:%u, Name:%s",
					0, pCategory->m_nLevel, nStatus, pCategory->Name());
				::WritePrivateProfileStringW(pModule->Name(), szKey, szValue, pszFileName);

				nCategory = pCategory->m_nNext;
			}
		}
	}
	return bRetVal;
}

#endif

}; // namespace ATL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\commd5\atl.cpp ===
/*++

    Copyright (c) 1998 Microsoft Corporation

    Module Name:

        atl.cpp

    Abstract:

        Includes ATL class and function implementations.

    Author:

        Darren L. Anderson (darrenan) 29-Jun-1998

    Revision History:

        29-Jun-1998 darrenan

            Created.
--*/

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\commd5\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\atls\atltracemodulemanager.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#ifndef ATLDEBUG_TRACE_MANAGER
#define ATLDEBUG_TRACE_MANAGER

#include "Allocate.h"

// Names
class CAtlTraceModuleInfo
{
public:
	explicit CAtlTraceModuleInfo();

	void Reset(HINSTANCE hInst);
	HINSTANCE GetInstance() const {return m_hInst;}

	const WCHAR *Path() const {return m_szPath;}
	const WCHAR *Name() const {return m_szName;}

	int m_iFirstCategory;
	LONG m_nCategories;

private:
	WCHAR m_szPath[MAX_PATH], m_szName[_MAX_FNAME];
	HINSTANCE m_hInst;
};

class CAtlTraceSettings
{
public:
	CAtlTraceSettings() : 
		m_nLevel(0), 
		m_eStatus(Inherit), 
		m_nRefCount(0),
		m_nCookie(0)
		{
		}
	
	UINT m_nLevel;
	enum Status
	{
		Inherit = 0, 
		Enabled, 
		Disabled
	};

	Status m_eStatus;

	// Only valid if (m_nRefCount > 0) && (m_nCookie != 0)
	LONG m_nRefCount;
	LONG m_nCookie;

public:
	// Tries to mark the object as allocated.  If the object is not available for allocation, returns false.
	// Call this, then initialize the data, then call MarkValid.  A successful TryAllocate gets a reference
	// to the object
	bool TryAllocate()
	{
		if( m_nCookie != 0 )
		{
			return( false );
		}
		LONG nNewRefCount = ::InterlockedIncrement( &m_nRefCount );
		if( nNewRefCount == 1 )
		{
			// We are the first ones here
			return( true );
		}

		return( false );
	}

	// Marks the object as valid.  
	void MarkValid( LONG nCookie )
	{
		ATLASSERT( nCookie != 0 );
		m_nCookie = nCookie;
	}

	// Tries to get a reference to the object.  If the object is invalid, returns false.  Must call Release to
	// release the reference after a successful TryAddRef
	bool TryAddRef()
	{
		LONG nNewRefCount = ::InterlockedIncrement( &m_nRefCount );
		if( (nNewRefCount > 1) && (m_nCookie != 0) )
		{
			// The object is valid, and we now own a reference to it
			return( true );
		}
		else
		{
			Release();

			return( false );
		}
	}

	// Releases a reference to the object.  If the objects refcount hits zero, the object is invalidated
	void Release()
	{
		LONG nNewRefCount = ::InterlockedDecrement( &m_nRefCount );
		if( nNewRefCount == 0 )
		{
			// We just released the last reference, so mark as invalid
			m_nCookie = 0;
		}
	}
};

// Categories
class CAtlTraceCategory : public CAtlTraceSettings
{
public:
	CAtlTraceCategory();

	const WCHAR *Name() const {return m_szName;}

	void Reset(const WCHAR *pszName, LONG nModuleCookie);

	LONG m_nModuleCookie;
	int m_iNextCategory;

private:
	WCHAR m_szName[ATL_TRACE_MAX_NAME_SIZE];
};

// Modules (DLLs)
class CAtlTraceModule : public CAtlTraceModuleInfo, public CAtlTraceSettings
{
public:
	typedef int (__cdecl *fnCrtDbgReport_t)(int,const CHAR *,int,const CHAR *,const CHAR *,...);

	explicit CAtlTraceModule();

	void CrtDbgReport(fnCrtDbgReport_t pfnCrtDbgReport);
	fnCrtDbgReport_t CrtDbgReport() const {return m_pfnCrtDbgReport;}

private:
	fnCrtDbgReport_t m_pfnCrtDbgReport;
};

// Process Info
class CAtlTraceProcess : public CAtlTraceModuleInfo
{
public:
	explicit CAtlTraceProcess(DWORD_PTR dwMaxSize);
	void Save(FILE *file, UINT nTabs) const;
	bool Load(FILE *file);

	UINT IncRef() {return ++m_nRef;}
	UINT DecRef() {return --m_nRef;}

	DWORD Id() const {return m_dwId;}
	DWORD_PTR MaxSize() const {return m_dwMaxSize;}
	void *Base() const {return m_pvBase;}

	int ModuleCount() const {return m_nModuleCount;}
	int CategoryCount() const {return m_nCategoryCount;}
	void IncModuleCount( UINT nModules ) {m_nModuleCount += nModules;}
	void IncCategoryCount( UINT nCategories ) {m_nCategoryCount += nCategories;}

	LONG GetNextCookie();

	DWORD_PTR m_dwFrontAlloc, m_dwBackAlloc, m_dwCurrFront, m_dwCurrBack;

	UINT m_nLevel;
	bool m_bLoaded, m_bEnabled, m_bFuncAndCategoryNames, m_bFileNameAndLineNo;

private:
	DWORD m_dwId;
	DWORD_PTR m_dwMaxSize;
	UINT m_nRef;
	void *m_pvBase;

	UINT m_nModuleCount, m_nCategoryCount;
	LONG m_nNextCookie;
};

#endif // ATLDEBUG_TRACE_MANAGER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\commd5\comd5.h ===
// CoMD5.h : Declaration of the CCoMD5

#ifndef __COMD5_H_
#define __COMD5_H_

#include "resource.h"       // main symbols
#include "passportservice.h"

/////////////////////////////////////////////////////////////////////////////
// CCoMD5
class ATL_NO_VTABLE CCoMD5 : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CCoMD5, &CLSID_CoMD5>,
    public IPassportService,
	public IDispatchImpl<IMD5, &IID_IMD5, &LIBID_COMMD5Lib>
{
public:
	CCoMD5()
	{
		m_pUnkMarshaler = NULL;
	}


DECLARE_REGISTRY_RESOURCEID(IDR_COMD5)
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CCoMD5)
	COM_INTERFACE_ENTRY(IMD5)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPassportService)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

public:
// IMD5
    STDMETHOD(MD5Hash)(BSTR bstrSource, BSTR* pbstrDigest);
    STDMETHOD(MD5HashASCII)(BSTR bstrSource, BSTR* pbstrDigest);
  
// IPassportService
public:
	STDMETHOD(Initialize)(BSTR configfile, IServiceProvider* p);
	STDMETHOD(Shutdown)();
	STDMETHOD(ReloadState)(IServiceProvider*);
	STDMETHOD(CommitState)(IServiceProvider*);
	STDMETHOD(DumpState)( BSTR* );

};

#endif //__COMD5_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\commd5\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ComMD5.rc
//
#define IDS_PROJNAME                    100
#define IDR_COMD5                       101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\commd5\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__B8C3079D_1B55_11D2_BED2_00C04FB6FA0D__INCLUDED_)
#define AFX_STDAFX_H__B8C3079D_1B55_11D2_BED2_00C04FB6FA0D__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef STRICT
#define STRICT
#endif


#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

#include <comdef.h>

#include "md5.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__B8C3079D_1B55_11D2_BED2_00C04FB6FA0D__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\commd5\commd5.cpp ===
// ComMD5.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f ComMD5ps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "ComMD5.h"

#include "ComMD5_i.c"
#include "CoMD5.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CoMD5, CCoMD5)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\commd5\comd5.cpp ===
// CoMD5.cpp : Implementation of CCoMD5
#include "stdafx.h"
#include "ComMD5.h"
#include "CoMD5.h"
#include "pperr.h"

/////////////////////////////////////////////////////////////////////////////
// CCoMD5

VOID
ToHex(
    LPBYTE pSrc,
    UINT   cSrc,
    LPSTR  pDst
    )

/*++

Routine Description:

    Convert binary data to ASCII hex representation

Arguments:

    pSrc - binary data to convert
    cSrc - length of binary data
    pDst - buffer receiving ASCII representation of pSrc

Return Value:

    Nothing

--*/

{
#define TOHEX(a) ((a)>=10 ? 'a'+(a)-10 : '0'+(a))

    for ( UINT x = 0, y = 0 ; x < cSrc ; ++x )
    {
        UINT v;
        v = pSrc[x]>>4;
        pDst[y++] = TOHEX( v );
        v = pSrc[x]&0x0f;
        pDst[y++] = TOHEX( v );
    }
    pDst[y] = '\0';
}

LONG MD5(UCHAR* pBuf, UINT nBuf, UCHAR* digest)
{
    MD5_CTX context;

    if(pBuf==NULL || IsBadReadPtr((CONST VOID*)pBuf, (UINT)nBuf))
    {
        return ERROR_INVALID_PARAMETER;
    }

    MD5Init (&context);
    MD5Update (&context, pBuf, nBuf);
    MD5Final (&context);

    memcpy(digest, context.digest, 16);

    return ERROR_SUCCESS;
}

STDMETHODIMP
CCoMD5::MD5HashASCII(
    BSTR    bstrSource,
    BSTR*   pbstrDigest
    )
{
    HRESULT hr;
    LONG    lResult;
    UCHAR   achDigest[20];
    CHAR    achDigestStr[36];
    
    lResult = MD5((UCHAR*)(CHAR*)bstrSource, 
                    ::SysStringByteLen(bstrSource), 
                    achDigest);
    if(lResult != ERROR_SUCCESS)
    {
        hr = PP_E_MD5_HASH_FAILED;
        goto Cleanup;
    }

    ToHex(achDigest, 16, achDigestStr);

    *pbstrDigest = ::SysAllocStringByteLen(achDigestStr, ::strlen(achDigestStr));
    if(*pbstrDigest == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    return hr;
}

STDMETHODIMP
CCoMD5::MD5Hash(
    BSTR    bstrSource,
    BSTR*   pbstrDigest
    )
{
    HRESULT hr;
    ATL::CComBSTR asciiDigest;

    hr = MD5HashASCII(bstrSource,  &asciiDigest);

    if (S_OK != hr)
      goto Cleanup;
    
    *pbstrDigest = ::SysAllocString((WCHAR*)_bstr_t((CHAR*)(BSTR)asciiDigest));
    if(*pbstrDigest == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IPassportService implementation

STDMETHODIMP CCoMD5::Initialize(BSTR configfile, IServiceProvider* p)
{
    return S_OK;
}


STDMETHODIMP CCoMD5::Shutdown()
{
    return S_OK;
}


STDMETHODIMP CCoMD5::ReloadState(IServiceProvider*)
{
    return S_OK;
}


STDMETHODIMP CCoMD5::CommitState(IServiceProvider*)
{
    return S_OK;
}


STDMETHODIMP CCoMD5::DumpState(BSTR* pbstrState)
{
	ATLASSERT( *pbstrState != NULL && 
               "CCoMD5:DumpState - "
               "Are you sure you want to hand me a non-null BSTR?" );

	HRESULT hr = S_OK;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\alertlibrary\corealertstuff\passportalertevent.cpp ===
// PassportAlertEvent.cpp: implementation of the PassportEvent class.
//
//////////////////////////////////////////////////////////////////////

#define _PassportExport_
#include "PassportExport.h"

#include <windows.h>
#include <TCHAR.h>
#include "PassportAlertEvent.h"

#define HKEY_EVENTLOG	_T("System\\CurrentControlSet\\Services\\Eventlog\\Application")
#define TYPES_SUPPORTED	_T("TypesSupported")
#define EVENT_MSGFILE	_T("EventMessageFile")
#define CATEGORY_MSGFILE _T("CategoryMessageFile")
#define CATEGORY_COUNT	_T("CategoryCount")
#define DISABLE_EVENTS  _T("DisableEvents")

#define BUFFER_SIZE     512
const DWORD DefaultTypesSupported = 7;
const DWORD DefaultCategoryCount = 7;

const WORD DEFAULT_EVENT_CATEGORY = 0;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
PassportAlertEvent::PassportAlertEvent()
 : m_bDisabled(FALSE)
{
		inited = FALSE;
		m_EventSource = NULL;
		m_defaultCategoryID = 0;
}

PassportAlertEvent::~PassportAlertEvent()
{
}

//////////////////////////////////////////////////////////////////////
// 
// PassportAlertEvent::initLog
//
//////////////////////////////////////////////////////////////////////
BOOL	
PassportAlertEvent::initLog(LPCTSTR applicationName,
							const DWORD defaultCategoryID,
							LPCTSTR eventResourceDllName,  // full path
							const DWORD numberCategories )
{
	HKEY hkResult2 = NULL;
	if (inited)
	{
		return FALSE;
	}

	m_defaultCategoryID = defaultCategoryID;

	TCHAR szEventLogKey[512];
	wsprintf(szEventLogKey, _T("%s\\%s"), HKEY_EVENTLOG, applicationName);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     szEventLogKey,
                     0,
                     KEY_READ,
                     &hkResult2) != ERROR_SUCCESS)
	{
		;//this is OK, events can still be logged w/o strings
	}

	DWORD dwType = 0x07;

	if (RegSetValueEx(hkResult2, TYPES_SUPPORTED, 0, 
		REG_DWORD, (UCHAR*)&dwType, 4) != ERROR_SUCCESS) 
	{
		;////this is OK, events can still be logged w/o strings
	}

	if (eventResourceDllName)
	{
		if (RegSetValueEx(hkResult2, EVENT_MSGFILE, 0, 
			REG_SZ, (UCHAR*)eventResourceDllName, 
			lstrlen(eventResourceDllName)*sizeof(TCHAR)) != ERROR_SUCCESS)
		{
			;////this is OK, events can still be logged w/o strings
		}
		if (RegSetValueEx(hkResult2, _T("CategoryCount"), 0, 
			REG_DWORD, (UCHAR*)&numberCategories, 4) != ERROR_SUCCESS)
		{
			;////this is OK, events can still be logged w/o strings
		}
	}

    DWORD dwLen = sizeof(DWORD);
    RegQueryValueEx(hkResult2, DISABLE_EVENTS, 0, NULL, (UCHAR*)&m_bDisabled, &dwLen);

	RegCloseKey(hkResult2);

	m_EventSource = RegisterEventSource(NULL, applicationName);
    if ( m_EventSource != NULL )
	{
		inited = TRUE;
		return TRUE;
	}
	else
		return FALSE;
}


//////////////////////////////////////////////////////////////////////
// 
// PassportAlertEvent::type
//
//////////////////////////////////////////////////////////////////////
PassportAlertInterface::OBJECT_TYPE 
PassportAlertEvent::type() const
{
	return PassportAlertInterface::EVENT_TYPE;
};

//////////////////////////////////////////////////////////////////////
// 
// PassportAlertEvent::status
//
//////////////////////////////////////////////////////////////////////
BOOL	
PassportAlertEvent::status() const
{
	return inited;

}

//////////////////////////////////////////////////////////////////////
// 
// PassportAlertEvent::closeLog
//
//////////////////////////////////////////////////////////////////////
BOOL	
PassportAlertEvent::closeLog ()
{
	return (DeregisterEventSource (m_EventSource) ? true : false);

}

//////////////////////////////////////////////////////////////////////
// 
// PassportAlertEvent::report
//
//////////////////////////////////////////////////////////////////////
BOOL	
PassportAlertEvent::report(	const PassportAlertInterface::LEVEL level, 
							const DWORD alertId )
{
    if(m_bDisabled)
        return TRUE;

	return ReportEvent ( 
						m_EventSource,
						(WORD)convertEvent(level),
						(WORD)m_defaultCategoryID,
						alertId,
						0, // optional security user Sid
						(WORD)0,
						0,
						NULL,
						NULL );

}


//////////////////////////////////////////////////////////////////////
// 
// PassportAlertEvent::report
//
//////////////////////////////////////////////////////////////////////
BOOL	
PassportAlertEvent::report(	const PassportAlertInterface::LEVEL level, 
							const DWORD alertId, 
							LPCTSTR errorString)
{
    if(m_bDisabled)
        return TRUE;

	TCHAR *pszStrings[1];
	pszStrings[0] = (LPTSTR) errorString; 
	return ReportEvent ( 
						m_EventSource,
						(WORD)convertEvent(level),
						(WORD)m_defaultCategoryID,
						alertId,
						0, // optional security user Sid
						(WORD)1,
						0,
						(LPCTSTR*)pszStrings,
						NULL );

}

//////////////////////////////////////////////////////////////////////
// 
// PassportAlertEvent::report
//
//////////////////////////////////////////////////////////////////////
BOOL	
PassportAlertEvent::report(	const PassportAlertInterface::LEVEL level, 
							const DWORD alertId, 
							const WORD numberErrorStrings, 
							LPCTSTR *errorStrings, 
							const DWORD binaryErrorBytes,
							const LPVOID binaryError )
{

    if(m_bDisabled)
        return TRUE;

	return ReportEvent ( 
						m_EventSource,
						(WORD)convertEvent(level),
						(WORD)m_defaultCategoryID,
						alertId,
						0, // optional security user Sid
						(WORD)numberErrorStrings,
						binaryErrorBytes,
						(LPCTSTR*)errorStrings,
						binaryError );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\alertlibrary\corealertstuff\passportalertevent.h ===
// PassportAlertEvent.h: interface for the PassportAlertEvent class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PASSPORTALERTEVENT_H)
#define AFX_PASSPORTALERTEVENT_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "PassportAlertInterface.h"

class PassportAlertEventImpl;

class PassportExport PassportAlertEvent : public PassportAlertInterface 
{
public:
	PassportAlertEvent();
	virtual ~PassportAlertEvent();

	virtual BOOL	initLog(LPCTSTR applicationName,
							const DWORD defaultCategoryID = 0,
							LPCTSTR eventResourceDllName = NULL,  // full path
							const DWORD numberCategories = 0);

	virtual PassportAlertInterface::OBJECT_TYPE type() const;

	virtual BOOL	status() const;

	virtual BOOL	closeLog ();

 	virtual BOOL	report(	const PassportAlertInterface::LEVEL level, 
							const DWORD alertId );

 	virtual BOOL	report(	const PassportAlertInterface::LEVEL level, 
							const DWORD alertId, 
							LPCTSTR errorString);

	virtual BOOL	report(	const PassportAlertInterface::LEVEL level, 
							const DWORD alertId, 
							const WORD numberErrorStrings, 
							LPCTSTR *errorStrings, 
							const DWORD binaryErrorBytes = 0,
							const LPVOID binaryError = NULL );
private:

    BOOL                      m_bDisabled;

	BOOL	inited;
	DWORD	m_defaultCategoryID;
	HANDLE  m_EventSource;


	static WORD convertEvent ( 
		const PassportAlertInterface::LEVEL level )
	{
	   switch (level)
	   {
			case PassportAlertInterface::ERROR_TYPE:
				return EVENTLOG_ERROR_TYPE;
			case PassportAlertInterface::WARNING_TYPE:
				return EVENTLOG_WARNING_TYPE;
			case PassportAlertInterface::INFORMATION_TYPE:
				return EVENTLOG_INFORMATION_TYPE;
			default:
				return EVENTLOG_ERROR_TYPE;
	   }
	}

};

#endif // !defined(PASSPORTALERTEVENT_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\alertlibrary\corealertstuff\passportalertinterface.cpp ===
//////////////////////////////////////////////////////////////////////
//
// 
//
//////////////////////////////////////////////////////////////////////

#define _PassportExport_
#include "PassportExport.h"

#include "PassportAlertInterface.h"
#include "PassportAlertEvent.h"

PassportExport PassportAlertInterface * CreatePassportAlertObject ( 
						PassportAlertInterface::OBJECT_TYPE type )
{
	switch (type)
	{
	case PassportAlertInterface::EVENT_TYPE:
		return ( PassportAlertInterface * ) new PassportAlertEvent();
	default:
		return NULL;
	}
}


PassportExport void 
DeletePassportAlertObject ( PassportAlertInterface * pObject )
{
	
	if (pObject)
		delete pObject;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\alertlibrary\pmalerts\dllregisterserver.cpp ===
#include <windows.h>
#include <TCHAR.h>
#include "PMAlertsDefs.h"

STDAPI DllRegisterServer(void)
{

	DWORD	dwAllocBufferLength=500;
	LPTSTR	lpszBuffer= new TCHAR[dwAllocBufferLength];
	HKEY	hKey=HKEY_LOCAL_MACHINE;	// handle of open key
	HKEY	hkResult1; 					// address of handle of open key 
	HKEY	hkResult2; 					// address of handle of open key 
	DWORD	ulOptions=0;
	REGSAM	samDesired=KEY_ALL_ACCESS;
	DWORD	Reserved=0;
	DWORD	dwTypesSupported=7;	
	DWORD	dwCategoryCount=2;	

	// Get DLL File Location

	if(!GetCurrentDirectory(dwAllocBufferLength,lpszBuffer))
		goto Error;

	_tcscat(lpszBuffer,_T("\\msppmalr.dll"));

	// Event Logging Registry Settings

	if (RegOpenKeyEx(hKey,
		_T("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application"),
		ulOptions,samDesired,&hkResult1)!=ERROR_SUCCESS)
		goto Error;
	
	if (RegCreateKey(hkResult1,PM_ALERTS_REGISTRY_KEY,
		&hkResult2)!=ERROR_SUCCESS)
	{
		RegCloseKey(hkResult1);
		goto Error;
	}

	if (RegSetValueEx(hkResult2,_T("EventMessageFile"),
		Reserved,REG_EXPAND_SZ,(CONST BYTE *)lpszBuffer,
		_tcslen(lpszBuffer)*sizeof(TCHAR))!=ERROR_SUCCESS)
	{
		RegCloseKey(hkResult1);
		RegCloseKey(hkResult2);
		goto Error;
	}

	if (RegSetValueEx(hkResult2,_T("CategoryMessageFile"),
		Reserved,REG_EXPAND_SZ,(CONST BYTE *)lpszBuffer,
		_tcslen(lpszBuffer)*sizeof(TCHAR))!=ERROR_SUCCESS)
	{
		RegCloseKey(hkResult1);
		RegCloseKey(hkResult2);
		goto Error;
	}

	if (RegSetValueEx(hkResult2,_T("TypesSupported"),
		Reserved,REG_DWORD,(CONST BYTE *)&dwTypesSupported,
		sizeof(DWORD))!=ERROR_SUCCESS)
	{
		RegCloseKey(hkResult1);
		RegCloseKey(hkResult2);
		goto Error;
	}

	if (RegSetValueEx(hkResult2,_T("CategoryCount"),
		Reserved,REG_DWORD,(CONST BYTE *)&dwCategoryCount,
		sizeof(DWORD))!=ERROR_SUCCESS)
	{
		RegCloseKey(hkResult1);
		RegCloseKey(hkResult2);
		goto Error;
	}

	RegCloseKey(hkResult1);
	RegCloseKey(hkResult2);

	delete[] lpszBuffer;

	return(S_OK);

Error:
	delete[] lpszBuffer;
	return(E_UNEXPECTED);
}

STDAPI DllUnregisterServer(void)
{

	HKEY	hKey=HKEY_LOCAL_MACHINE, hkResult1;
	DWORD	ulOptions=0;
	REGSAM	samDesired=KEY_ALL_ACCESS;
	DWORD	Reserved=0;

	if (RegOpenKeyEx(hKey,
		_T("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application"),
		ulOptions,samDesired,&hkResult1) != ERROR_SUCCESS)
	{
		return (E_UNEXPECTED);
	}

	if (RegDeleteKey(hkResult1,PM_ALERTS_REGISTRY_KEY) != ERROR_SUCCESS)
	{
		RegCloseKey(hkResult1);
		return (E_UNEXPECTED);
	}
	
	RegCloseKey(hkResult1);
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\alertlibrary\corealertstuff\passportalertinterface.h ===
// AlertInterface.h: interface for the AlertInterface class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(ALERTINTERFACE_H)
#define ALERTINTERFACE_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <windows.h>
#include "PassportExport.h"

class PassportExport PassportAlertInterface  
{
public:
	inline PassportAlertInterface(void)	{};
	inline virtual ~PassportAlertInterface(void) {};

	enum LEVEL
	{
		INFORMATION_TYPE	= 0,	// on NT, EVENTLOG_INFORMATION_TYPE,
		WARNING_TYPE		= 1,	//		  EVENTLOG_WARNING_TYPE,
		ERROR_TYPE			= 2		//		  EVENTLOG_ERROR_TYPE
	};

	enum OBJECT_TYPE
	{
		EVENT_TYPE		= 100,		// Alerts Logged to Event Log,
		SNMP_TYPE		= 101,		// Alerts Logged to SNMP Traps,
		LOGFILE_TYPE	= 102		// Alerts Logged to disk file
	};

	virtual BOOL	initLog(LPCTSTR applicationName,
							const DWORD defaultCategoryID = 0,
							LPCTSTR eventResourceDllName = NULL,  // full path
							const DWORD numberCategories = 0 ) = 0;

	virtual PassportAlertInterface::OBJECT_TYPE type() const = 0;

	virtual BOOL	status() const = 0;

	virtual BOOL	closeLog ()	= 0;

 	virtual BOOL	report(	const PassportAlertInterface::LEVEL level, 
							const DWORD alertId ) = 0;

 	virtual BOOL	report(	const PassportAlertInterface::LEVEL level, 
							const DWORD alertId, 
							LPCTSTR errorString) = 0;

	virtual BOOL	report(	const PassportAlertInterface::LEVEL level, 
							const DWORD alertId, 
							const WORD numberErrorStrings, 
							LPCTSTR *errorStrings, 
							const DWORD binaryErrorBytes = 0,
							const LPVOID binaryError = NULL ) = 0;


};

// create and returns a pointer to the relevant implementation,
// NULL if none exists (FYI- extern "C" to stop name mangling)
extern "C" PassportExport PassportAlertInterface * 
					CreatePassportAlertObject ( PassportAlertInterface::OBJECT_TYPE type );

extern "C" PassportExport void DeletePassportAlertObject ( PassportAlertInterface * pObject );

#endif // !defined(ALERTINTERFACE_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\alertlibrary\pmalerts\pmalerts.c ===
#include <windows.h>

BOOL WINAPI DllMain( 
    HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved )
{
    return TRUE;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\alertlibrary\pmalerts\pmalertsdefs.h ===
/*++

    Copyright (c) 1998 Microsoft Corporation

    Module Name:

        PMAlertsDefs.h

    Abstract:

		Defines the Registry Key used by the PMAlerts.dll

    Author:

		Christopher Bergh (cbergh) 14-Oct-1988

    Revision History:


--*/

#if !defined(PMALERTSDEFS_H)
#define PMALERTSDEFS_H

//
// defs
//
const TCHAR PM_ALERTS_REGISTRY_KEY[]	= _T("PassportManager");

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\bstrdebug\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	schema.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\bstrdebug\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__70EC6ECF_9549_11D2_95DE_00C04F8E7A70__INCLUDED_)
#define AFX_STDAFX_H__70EC6ECF_9549_11D2_95DE_00C04F8E7A70__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <tchar.h>
#include <atlbase.h>

#include "BstrDebug.h"
#include "BstrHash.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__70EC6ECF_9549_11D2_95DE_00C04F8E7A70__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\bstrdebug\bstrdebug.cpp ===
// BstrDebug.cpp: implementation of the CBstrDebug class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfx.h"

#ifdef MEM_DBG
CBstrDebug g_allocs;
ULONG      g_breakOnBstrAlloc = -1;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CBstrDebug::CBstrDebug() :
  m_allocs("BstrDebugging",LK_DFLT_MAXLOAD,LK_LARGE_TABLESIZE,0), m_numAllocs(0)
{

}

CBstrDebug::~CBstrDebug()
{
  if (m_allocs.Size() > 0)
    {
      ATLTRACE("BstrDebug found leaks!!!\n");
      LK_RETCODE lkrc;
      BSTRLEAKMAP::CConstIterator it;
      const BSTRLEAKMAP& htConst = m_allocs;
      for (lkrc = htConst.InitializeIterator(&it) ;
	   lkrc == LK_SUCCESS ;
	   lkrc = htConst.IncrementIterator(&it))
	{
	  ATLTRACE("Leak allocated from %s Line %d (#%u)\n", it.Record()->m_v->file,
		   it.Record()->m_v->line, it.Record()->m_v->num);
	  delete it.Record()->m_v; // Hah hah.  Try and catch me compiler.
	}
      htConst.CloseIterator(&it);
    }
}

BSTR CBstrDebug::track(BSTR mem, LPSTR message, int line)
{
    if (!mem)
        return NULL;  // We don't care about null pointers...

    ULONG numA = InterlockedIncrement((long*)&m_numAllocs);

#ifdef MEM_DBG
    if (numA == g_breakOnBstrAlloc)
        DebugBreak();
#endif

    const BSTRLEAKMAP::ValueType *pOut = NULL;
    LK_RETCODE lkrc = m_allocs.FindKey((LONG_PTR) mem, &pOut);
    if (lkrc == LK_SUCCESS && pOut != NULL)
    {
        ATLTRACE("BstrDebug::track: Already tracking memory allocated from %s line %d (#%u).  Called from %s line %d (#%u).  Keeping original\n",
                 pOut->m_v->file, pOut->m_v->line, pOut->m_v->num, message, line, numA);
        m_allocs.AddRefRecord(pOut, -1);
    }
    else
    {
        BSTRLEAKMAP::ValueType *pair = 
        new BSTRLEAKMAP::ValueType((LONG_PTR) mem,new bstrAllocInfo(message,line,numA), "BSTRDbg");
        if (pair)
        {
            if (m_allocs.InsertRecord(pair) != LK_SUCCESS)
            {
                ATLTRACE("BstrDebug::track: Couldn't insert record for allocation at %s line %d (#%u).\n",
                         message, line, numA);
                delete pair;
            }
        }
    }
    return mem;
}

void CBstrDebug::release(BSTR mem, LPSTR message, int line)
{
    if (!mem)
        return;

    const BSTRLEAKMAP::ValueType *pOut = NULL;
    LK_RETCODE lkrc = m_allocs.FindKey((LONG_PTR) mem, &pOut);
    if (lkrc == LK_SUCCESS && pOut != NULL)
    {
        delete pOut->m_v;
        m_allocs.AddRefRecord(pOut, -1);
        m_allocs.DeleteKey((LONG_PTR) mem);
    }
    else
    {
        ATLTRACE("BstrDebug::release: Already released memory. Called from %s line %d.\n",
        message, line);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\crypt\binhex.cpp ===
// BinHex.cpp: implementation of the CBinHex class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "BinHex.h"
#include "BstrDebug.h"

// These characters are the legal digits, in order, that are 
// used in Base64 encoding 
//  

const WCHAR rgwchBase64[] = 
    L"ABCDEFGHIJKLMNOPQ" 
    L"RSTUVWXYZabcdefgh" 
    L"ijklmnopqrstuvwxy" 
    L"z0123456789!*"; 

const char rgwchBase64ASCII[] = 
    "ABCDEFGHIJKLMNOPQ" 
    "RSTUVWXYZabcdefgh" 
    "ijklmnopqrstuvwxy" 
    "z0123456789!*"; 


CBinHex::CBinHex()
{
  unsigned char i;
  // 
  // Initialize our decoding array 
  // 
  memset(m_decodeArray, BBAD, 256); 
  for (i = 0; i < 64; i++) 
  { 
    WCHAR wch = rgwchBase64[i];
    m_decodeArray[wch] = i;
  }
}

// This function takes IN a single-char buffer, and puts the binhex
// output into a bstr -- in the bstr, it's ASCII string
//
// Function name    : ToBase64
// Description	    : 
// Return type	    : HRESULT 
// Argument         : LPVOID pv
// Argument         : ULONG cbSize
// Argument         : char prepend
// Argument         : BSTR* pbstr
//
HRESULT CBinHex::ToBase64ASCII(LPVOID pv, UINT cbSize, char prepend, char ivecnpad[9], BSTR* pbstr) 
// 
// Encode and return the bytes in base 64 
// 
{ 
    UINT cb = cbSize, cbSafe, cchNeeded, cbNeeded, i;
    HRESULT hr = S_OK;

    *pbstr = NULL; 
    if (cb % 3)
      cbSafe = cb + 3 - (cb % 3); // For padding
    else
      cbSafe = cb;
    // cbSafe is now a multiple of 3

    cchNeeded  = (cbSafe*4/3);   // 3 normal bytes --> 4 chars
    cbNeeded   = cchNeeded; 

    if (prepend != 0)
      {
	if (ivecnpad != NULL)
	  *pbstr = ALLOC_BSTR_BYTE_LEN(NULL, cbNeeded+2+18); // ivec & kv
	else
	  *pbstr = ALLOC_BSTR_BYTE_LEN(NULL, cbNeeded+2);    // just kv
      }
    else
      *pbstr = ALLOC_BSTR_BYTE_LEN(NULL, cbNeeded);
    if (*pbstr) 
    { 
        BYTE*  pb   = (BYTE*)pv; 
        char* pch = (char*)*pbstr;
        int cchLine = 0; 

	if (prepend != 0)
	  { 
	    *pch++ = (char) prepend;
	    if (ivecnpad != NULL)
	      {
		for (i = 0; i < 9; i++)
		  *pch++ = (char) ivecnpad[i];
	      }
	  }
        // 
        // Main encoding loop 
        // 
        while (cb >= 3) 
        { 
            BYTE b0 =                     ((pb[0]>>2) & 0x3F); 
            BYTE b1 = ((pb[0]&0x03)<<4) | ((pb[1]>>4) & 0x0F); 
            BYTE b2 = ((pb[1]&0x0F)<<2) | ((pb[2]>>6) & 0x03); 
            BYTE b3 = ((pb[2]&0x3F)); 
 
            *pch++ = rgwchBase64ASCII[b0]; 
            *pch++ = rgwchBase64ASCII[b1]; 
            *pch++ = rgwchBase64ASCII[b2]; 
            *pch++ = rgwchBase64ASCII[b3]; 
 
            pb += 3; 
            cb -= 3; 
            
        } 

        if (cb==0) 
        { 
            // nothing to do 
        } 
        else if (cb==1) 
        { 
            BYTE b0 =                     ((pb[0]>>2) & 0x3F); 
            BYTE b1 = ((pb[0]&0x03)<<4) | 0; 
            *pch++ = rgwchBase64ASCII[b0]; 
            *pch++ = rgwchBase64ASCII[b1]; 
            *pch++ = '$'; 
            *pch++ = '$'; 
        } 
        else if (cb==2) 
        { 
            BYTE b0 =                     ((pb[0]>>2) & 0x3F); 
            BYTE b1 = ((pb[0]&0x03)<<4) | ((pb[1]>>4) & 0x0F); 
            BYTE b2 = ((pb[1]&0x0F)<<2) | 0; 
            *pch++ = rgwchBase64ASCII[b0]; 
            *pch++ = rgwchBase64ASCII[b1]; 
            *pch++ = rgwchBase64ASCII[b2]; 
            *pch++ = '$'; 
        } 
         
     } 
    else 
        hr = E_OUTOFMEMORY; 
 
    GIVEAWAY_BSTR(*pbstr);
    return hr; 
} 
 
// This function takes IN a single-char buffer, and puts the binhex
// output into a bstr, but using only ASCII chars
//
// Function name    : ToBase64
// Description	    : 
// Return type	    : HRESULT 
// Argument         : LPVOID pv
// Argument         : ULONG cbSize
// Argument         : char prepend
// Argument         : BSTR* pbstr
//
HRESULT CBinHex::ToBase64(LPVOID pv, UINT cbSize, char prepend, char ivecnpad[9], BSTR* pbstr) 
// 
// Encode and return the bytes in base 64 
// 
{ 
    UINT cb = cbSize, cbSafe, cchNeeded, cbNeeded, i;
    HRESULT hr = S_OK;

    *pbstr = NULL; 
    if (cb % 3)
      cbSafe = cb + 3 - (cb % 3); // For padding
    else
      cbSafe = cb;
    // cbSafe is now a multiple of 3

    cchNeeded  = (cbSafe*4/3);   // 3 normal bytes --> 4 chars
    cbNeeded   = cchNeeded * sizeof(WCHAR); 

    if (prepend != 0)
      {
	if (ivecnpad != NULL)
	  *pbstr = ALLOC_BSTR_BYTE_LEN(NULL, cbNeeded+2+18); // ivec & kv
	else
	  *pbstr = ALLOC_BSTR_BYTE_LEN(NULL, cbNeeded+2);    // just kv
      }
    else
      *pbstr = ALLOC_BSTR_BYTE_LEN(NULL, cbNeeded);
    if (*pbstr) 
    { 
        BYTE*  pb   = (BYTE*)pv; 
        WCHAR* pch = *pbstr;
        int cchLine = 0; 

	if (prepend != 0)
	  { 
	    *pch++ = (WCHAR) prepend;
	    if (ivecnpad != NULL)
	      {
		for (i = 0; i < 9; i++)
		  *pch++ = (WCHAR) ivecnpad[i];
	      }
	  }
        // 
        // Main encoding loop 
        // 
        while (cb >= 3) 
        { 
            BYTE b0 =                     ((pb[0]>>2) & 0x3F); 
            BYTE b1 = ((pb[0]&0x03)<<4) | ((pb[1]>>4) & 0x0F); 
            BYTE b2 = ((pb[1]&0x0F)<<2) | ((pb[2]>>6) & 0x03); 
            BYTE b3 = ((pb[2]&0x3F)); 
 
            *pch++ = rgwchBase64[b0]; 
            *pch++ = rgwchBase64[b1]; 
            *pch++ = rgwchBase64[b2]; 
            *pch++ = rgwchBase64[b3]; 
 
            pb += 3; 
            cb -= 3; 
            
        } 

        if (cb==0) 
        { 
            // nothing to do 
        } 
        else if (cb==1) 
        { 
            BYTE b0 =                     ((pb[0]>>2) & 0x3F); 
            BYTE b1 = ((pb[0]&0x03)<<4) | 0; 
            *pch++ = rgwchBase64[b0]; 
            *pch++ = rgwchBase64[b1]; 
            *pch++ = L'$'; 
            *pch++ = L'$'; 
        } 
        else if (cb==2) 
        { 
            BYTE b0 =                     ((pb[0]>>2) & 0x3F); 
            BYTE b1 = ((pb[0]&0x03)<<4) | ((pb[1]>>4) & 0x0F); 
            BYTE b2 = ((pb[1]&0x0F)<<2) | 0; 
            *pch++ = rgwchBase64[b0]; 
            *pch++ = rgwchBase64[b1]; 
            *pch++ = rgwchBase64[b2]; 
            *pch++ = L'$'; 
        } 
         
     } 
    else 
        hr = E_OUTOFMEMORY; 
 
    GIVEAWAY_BSTR(*pbstr);
    return hr; 
} 
 
 
// This function takes in a bstr using only single-char, and 
// outputs a single-char buffer  
//
// Function name	  : FromBase64
// Description	    : 
// Return type		  : HRESULT 
// Argument         : BSTR bstr
// Argument         : BLOB* pblob
//
HRESULT CBinHex::FromWideBase64(BSTR bstr, BSTR *pblob) 
// 
// Decode and return the Base64 encoded bytes 
// 
{ 
  HRESULT hr = S_OK; 
  int cbNeeded = SysStringLen(bstr)*3/4;
  *pblob = ALLOC_BSTR_BYTE_LEN(NULL,cbNeeded);

  if (*pblob) 
  { 
    // 
    // Loop over the entire input buffer 
    // 
    ULONG bCurrent = 0;         // what we're in the process of filling up 
    int  cbitFilled = 0;        // how many bits in it we've filled 
    BYTE* pb = (BYTE*) *pblob;  // current destination (not filled) 
    // 
    for (WCHAR* pwch=bstr; *pwch; pwch++) 
    { 
        WCHAR wch = *pwch; 
        // 
        // Have we reached the end? 
        // 
        if (wch==L'$') 
            break; 
        // 
        // How much is this character worth? 
        // 
	if (wch > 255)
	  {
	    hr = E_INVALIDARG;
	    break;
	  }
        BYTE bDigit = m_decodeArray[wch]; 
        if (bDigit==BBAD) 
	  { 
            hr = E_INVALIDARG; 
            break; 
	  } 
        // 
        // Add in its contribution 
        // 
        bCurrent <<= 6; 
        bCurrent |= bDigit; 
        cbitFilled += 6; 
        // 
        // If we've got enough, output a byte 
        // 
        if (cbitFilled >= 8) 
        { 
            ULONG b = (bCurrent >> (cbitFilled-8));     // get's top eight valid bits 
            *pb++ = (BYTE)(b&0xFF);                     // store the byte away 
            cbitFilled -= 8; 
        } 
    } // for 
 
    if (hr!=S_OK) 
    { 
      FREE_BSTR(*pblob);
      *pblob = NULL;
    } 
  } 
  else 
    hr = E_OUTOFMEMORY; 

  if (*pblob)
    {
      GIVEAWAY_BSTR(*pblob);
    }

  return hr; 
} 

// This function takes in a bstr using only single-char, and 
// outputs a single-char buffer  
//
// Function name	  : FromBase64
// Description	    : 
// Return type		  : HRESULT 
// Argument         : BSTR bstr
// Argument         : BLOB* pblob
//
HRESULT CBinHex::FromBase64(LPSTR bstr, UINT cbSize, BSTR *pblob) 
// 
// Decode and return the Base64 encoded bytes 
// 
{ 
  HRESULT hr = S_OK; 
  UINT cbNeeded = cbSize*3/4;
  *pblob = ALLOC_BSTR_BYTE_LEN(NULL,cbNeeded);

  if (*pblob) 
  { 
    // 
    // Loop over the entire input buffer 
    // 
    ULONG bCurrent = 0;         // what we're in the process of filling up 
    int  cbitFilled = 0;        // how many bits in it we've filled 
    BYTE* pb = (BYTE*) *pblob;  // current destination (not filled) 
    // 
    for (CHAR* pch=bstr; *pch; pch++) 
    { 
        CHAR ch = *pch;
        // 
        // Have we reached the end? 
        // 
        if (ch=='$') 
            break; 
        // 
        // How much is this character worth? 
        // 
        BYTE bDigit = m_decodeArray[ch]; 
        if (bDigit==BBAD) 
        { 
            hr = E_INVALIDARG; 
            break; 
        } 
        // 
        // Add in its contribution 
        // 
        bCurrent <<= 6; 
        bCurrent |= bDigit; 
        cbitFilled += 6; 
        // 
        // If we've got enough, output a byte 
        // 
        if (cbitFilled >= 8) 
        { 
            ULONG b = (bCurrent >> (cbitFilled-8));     // get's top eight valid bits 
            *pb++ = (BYTE)(b&0xFF);                     // store the byte away 
            cbitFilled -= 8; 
        } 
    } // for 
 
    if (hr!=S_OK) 
    { 
      FREE_BSTR(*pblob);
      *pblob = NULL;
    } 
  } 
  else 
    hr = E_OUTOFMEMORY; 

  if (*pblob)
    {
      GIVEAWAY_BSTR(*pblob);
    }

  return hr; 
} 


HRESULT CBinHex::PartFromBase64(LPSTR lpStr, BYTE *output, ULONG *numOutBytes)
{
  HRESULT hr = S_OK;

  if (!output) return E_INVALIDARG;

  // 
  // Loop over the input buffer until we get numOutBytes in output
  // 
  ULONG bCurrent = 0;         // what we're in the process of filling up 
  int  cbitFilled = 0;        // how many bits in it we've filled 
  ULONG numOut = 0;
  BYTE* pb = (BYTE*) output;  // current destination (not filled) 

  for (CHAR* pch=lpStr; *pch && numOut < *numOutBytes; pch++) 
    { 
      CHAR ch = *pch;
      // 
      // Have we reached the end? 
      // 
      if (ch=='$')
	break; 
      // 
      // How much is this character worth? 
      // 
      BYTE bDigit = m_decodeArray[ch]; 
      if (bDigit==BBAD) 
        { 
	  hr = E_INVALIDARG; 
	  break; 
        } 
      // 
      // Add in its contribution 
      // 
      bCurrent <<= 6; 
      bCurrent |= bDigit; 
      cbitFilled += 6; 
      // 
      // If we've got enough, output a byte 
      // 
      if (cbitFilled >= 8) 
        { 
	  ULONG b = (bCurrent >> (cbitFilled-8));     // get's top eight valid bits 
	  *pb++ = (BYTE)(b&0xFF);                     // store the byte away 
	  cbitFilled -= 8; 
	  numOut++;
        }
    } // for 
  
  _ASSERT(numOut <= *numOutBytes);

  if (hr!=S_OK)
    { 
      *numOutBytes = 0;
    }
  else
    {
      if (numOut < *numOutBytes)
	*numOutBytes = numOut;
    }

  return hr; 
}

HRESULT CBinHex::PartFromWideBase64(LPWSTR bStr, BYTE *output, ULONG *numOutBytes)
{
  HRESULT hr = S_OK;

  if (!output) return E_INVALIDARG;

  // 
  // Loop over the input buffer until we get numOutBytes in output
  // 
  ULONG bCurrent = 0;         // what we're in the process of filling up 
  int  cbitFilled = 0;        // how many bits in it we've filled 
  ULONG numOut = 0;
  BYTE* pb = (BYTE*) output;  // current destination (not filled) 

  for (WCHAR* pwch=bStr; *pwch && numOut < *numOutBytes; pwch++) 
    { 
      WCHAR wch = *pwch;
      // 
      // Have we reached the end? 
      // 
      if (wch==L'$')
	break; 
      // 
      // How much is this character worth? 
      // 
      if (wch > 255)
	{
	  hr = E_INVALIDARG;
	  break;
	}
      BYTE bDigit = m_decodeArray[wch]; 
      if (bDigit==BBAD) 
        { 
	  hr = E_INVALIDARG; 
	  break; 
        } 
      // 
      // Add in its contribution 
      // 
      bCurrent <<= 6; 
      bCurrent |= bDigit; 
      cbitFilled += 6; 
      // 
      // If we've got enough, output a byte 
      // 
      if (cbitFilled >= 8) 
        { 
	  ULONG b = (bCurrent >> (cbitFilled-8));     // get's top eight valid bits 
	  *pb++ = (BYTE)(b&0xFF);                     // store the byte away 
	  cbitFilled -= 8; 
	  numOut++;
        }
    } // for 
  
  _ASSERT(numOut <= *numOutBytes);

  if (hr!=S_OK)
    { 
      *numOutBytes = 0;
    }
  else if (numOut < *numOutBytes)
    {
      *numOutBytes = numOut;
    }

  return hr; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\crypt\cocrypt.cpp ===
// CoCrypt.cpp: implementation of the CCoCrypt class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CoCrypt.h"
#include "hmac.h"
#include "BstrDebug.h"
#include <winsock2.h> // ntohl, htonl
#include <time.h>

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CBinHex CCoCrypt::m_binhex;

CCoCrypt::CCoCrypt() : m_ok(FALSE), m_ivecCtr(0)
{
  //Set seed
  srand((unsigned)time(NULL));

  // randomize the init state
  // Total 62 characters: 0 - 9, a - z, A - Z
  for (int iii=0; iii < 8; iii++)
  {
    int idx = rand() % 62;
    if (idx <= 9)
        m_nextIvec[iii] = '0' + idx;
    else if (idx <= 35)
        m_nextIvec[iii] = 'a' + idx - 10;
    else        
        m_nextIvec[iii] = 'A' + idx - 36;
  }
}

CCoCrypt::~CCoCrypt()
{

}


// Decrypte an encrypted key value without base64 encoding
BOOL CCoCrypt::DecryptKey(BYTE *rawData, UINT cbData, BSTR *pDecrypted)
{
    // we are only dealing with partner key here
    // must be kv + ivec + bh(hmac) long at LEAST
    if (cbData < 25 || cbData > 2048)
    {
        if (pDecrypted) *pDecrypted = NULL;
        return FALSE;
    }

    return decrypt2048((LPWSTR)(&rawData[1]), cbData, pDecrypted, FALSE);
}


BOOL CCoCrypt::Decrypt(LPWSTR rawData, UINT dataSize, 
                       BSTR *pUnencrypted)
{
  // So it goes like this see:
  //  1. De binhex
  //  2. Decrypt
  //  3. Check hmac
  //  4. return data
  if (dataSize < 23) // must be kv + ivec + bh(hmac) long at LEAST
    {
      if (pUnencrypted) *pUnencrypted = NULL;
      return FALSE;
    }
  if (dataSize > 2048)
    return decryptDynamic(rawData+1, dataSize-sizeof(WCHAR), pUnencrypted);
  else
    return decrypt2048(rawData+1, dataSize-sizeof(WCHAR), pUnencrypted);
}

BOOL CCoCrypt::decrypt2048(LPWSTR rawData, UINT dataSize, 
			   BSTR *pUnencrypted, BOOL bEncoded)
{
  unsigned char buf[2048];
  unsigned char ivec[9];
  ULONG lSize = 2048, i;
  unsigned char pad;

  // XXXXXXXX THIS CODE APPEARS BELOW IN DYNAMIC VERSION, CHANGE BOTH!!!
  // FOR SPEED, WE DIDN'T DO FN CALLS OR ALWAYS DO DYNAMIC ALLOC

  if(bEncoded)
    m_binhex.PartFromWideBase64(rawData+9, buf, &lSize);
  else
  {
    lSize = dataSize - 10;
    memcpy(buf, (BYTE*)rawData+9, lSize);
  }

  if(bEncoded)
  {
      for (i = 0; i < 9; i++)
        ivec[i] = (unsigned char) rawData[i];
  }
  else
  {
      memcpy(ivec, rawData, 9);
  }
  pad = ivec[8];

  // Now lsize holds the # of bytes outputted, which after hmac should be %8=0
  if ((lSize-10) % 8 || lSize<=10)
    {
      if (pUnencrypted) *pUnencrypted = NULL;
      return FALSE;
    }

#ifdef UNIX
  des_ede3_cbc_encrypt((C_Block*)(buf+10),(C_Block*)(buf+10), lSize, 
		       ks1, ks2, ks3, (C_Block*)rawData, DES_DECRYPT);
#else
  for (i = 0; i < lSize-10; i+=8)
    {
      CBC(tripledes, 8, buf+10+i,buf+10+i, &ks, DECRYPT, (BYTE*)ivec);
    }
#endif

  // Padding must be >0 and <8
  //if (rawData[8]-65 > 7 || rawData[8] < 65)
  if((pad - 65) > 7 || pad < 65)
    {
      if (pUnencrypted) *pUnencrypted = NULL;
      return FALSE;
    }

  // Now check hmac
  unsigned char hmac[10];
  hmac_sha(m_keyMaterial, 24, buf+10, lSize-10, hmac, 10);
  if (memcmp(hmac, buf, 10) != 0)
    {
      if (pUnencrypted) *pUnencrypted = NULL;
      return FALSE;
    }

  // ok, now make our BSTR blob
  //*pUnencrypted = ALLOC_AND_GIVEAWAY_BSTR_BYTE_LEN((char*) (buf+10),lSize-10-(rawData[8]-65));
  *pUnencrypted = ALLOC_AND_GIVEAWAY_BSTR_BYTE_LEN((char*) (buf+10),lSize-10-(pad-65));
  return TRUE;
}

BOOL CCoCrypt::decryptDynamic(LPWSTR rawData, UINT dataSize, 
			   BSTR *pUnencrypted)
{
  unsigned char *buf = new unsigned char[dataSize];

  if (!buf)
    return FALSE;

  // XXXXXXXX THIS CODE APPEARS ABOVE.  MODIFY BOTH!
  // FOR SPEED, WE DIDN'T DO FN CALLS OR ALWAYS DO DYNAMIC ALLOC

  unsigned char ivec[8];
  ULONG lSize = dataSize, i;

  m_binhex.PartFromWideBase64(rawData+9, buf, &lSize);

  for (i = 0; i < 8; i++)
    ivec[i] = (unsigned char) rawData[i];

  // Now lsize holds the # of bytes outputted, which after hmac should be %8=0
  if ((lSize-10) % 8 || lSize <= 10)
    {
      if (pUnencrypted) *pUnencrypted = NULL;
      delete[] buf;
      return FALSE;
    }

#ifdef UNIX
  des_ede3_cbc_encrypt((C_Block*)(buf+10),(C_Block*)(buf+10), lSize, 
		       ks1, ks2, ks3, (C_Block*)rawData, DES_DECRYPT);
#else
  for (i = 0; i < lSize-10; i+=8)
    {
      CBC(tripledes, 8, buf+10+i,buf+10+i, &ks, DECRYPT, (BYTE*)ivec);
    }
#endif

  // Padding must be >0 and <8
  if (rawData[8]-65 > 7 || rawData[8] < 65)
    {
      if (pUnencrypted) *pUnencrypted = NULL;
      delete[] buf;
      return FALSE;
    }

  // Now check hmac
  unsigned char hmac[10];
  hmac_sha(m_keyMaterial, 24, buf+10, lSize-10, hmac, 10);
  if (memcmp(hmac, buf, 10) != 0)
    {
      if (pUnencrypted) *pUnencrypted = NULL;
      delete[] buf;
      return FALSE;
    }

  // ok, now make our BSTR blob
  *pUnencrypted = ALLOC_AND_GIVEAWAY_BSTR_BYTE_LEN((char*) (buf+10),lSize-10-(rawData[8]-65));

  // XXX END COPY
  delete[] buf;

  return TRUE;
}


// Encrypte a key value without base64 encoding
// bstrIn should be pack with SysAllocStringByteLen()
void CCoCrypt::EncryptKey(int nKeyVer, BSTR bstrIn, BYTE *pEncrypted, UINT &cbOut)
{
    // Find out how big the encrypted blob needs to be:
    // The final pack is:
    // <KeyVersion><IVEC><PADCOUNT>BINHEX(HMAC+3DES(DATA+PAD))
    //
    // So, we're concerned with the size of HMAC+3DES(DATA+PAD)
    BSTR bstrOut;
    int nSize = ::SysStringByteLen(bstrIn);
    int outLen = nSize; // DATA
    if (outLen % 8)
    {
        outLen += (8 - (outLen%8));  // + PAD, if necessary
    }

    // construct the prepended buffer
    char ivec[9];

    // Select an IVEC, and leave a byte for padding count
    memcpy(ivec, m_nextIvec, 8);

    // Fix for the next ivec
    char lc = m_nextIvec[m_ivecCtr];
    short ic = m_ivecCtr;
    if (lc == '9')
    {
        m_ivecCtr = (ic+1)%8;
        m_nextIvec[ic] = 'A';
    }
    else
    {
        if (lc == 'Z')
            m_nextIvec[ic] = 'a';
        else if (lc == 'z')
            m_nextIvec[ic] = '0';
        else
            m_nextIvec[ic] = lc+1;
    }

    if (outLen > 2038) // 10 for HMAC
    {
        cbOut = 0;
        *pEncrypted = NULL;
    }

    encrypt2048(ivec, outLen, nKeyVer, (LPSTR)bstrIn, nSize, &bstrOut, FALSE);
    memcpy(pEncrypted, &bstrOut[0], cbOut = ::SysStringByteLen(bstrOut));
    ::SysFreeString(bstrOut);

}



void CCoCrypt::Encrypt(int keyVersion, 
                       LPSTR rawData, UINT dataSize,
                       BSTR *pEncrypted)
{
  // Find out how big the encrypted blob needs to be:
  // The final pack is:
  // <KeyVersion><IVEC><PADCOUNT>BINHEX(HMAC+3DES(DATA+PAD))
  //
  // So, we're concerned with the size of HMAC+3DES(DATA+PAD)
  // because BinHex will handle the rest
  int outLen = dataSize; // DATA
  if (outLen % 8)
    {
      outLen += (8 - (outLen%8));  // + PAD, if necessary
    }

  // construct the prepended buffer
  char ivec[9];

  // Select an IVEC, and leave a byte for padding count
  memcpy(ivec, m_nextIvec, 8);

  // Fix for the next ivec
  char lc = m_nextIvec[m_ivecCtr];
  short ic = m_ivecCtr;
  if (lc == '9')
    {
      m_ivecCtr = (ic+1)%8;
      m_nextIvec[ic] = 'A';
    }
  else
    {
      if (lc == 'Z')
	m_nextIvec[ic] = 'a';
      else if (lc == 'z')
	m_nextIvec[ic] = '0';
      else
	m_nextIvec[ic] = lc+1;
    }

  if (outLen > 2038) // 10 for HMAC
    encryptDynamic(ivec, outLen, keyVersion, rawData, dataSize, pEncrypted);
  else
    encrypt2048(ivec, outLen, keyVersion, rawData, dataSize, pEncrypted);
}

void CCoCrypt::encrypt2048(char ivec[9], int blockSize, int keyVersion, 
			   LPSTR rawData, UINT dataSize,
			   BSTR *pEncrypted, BOOL bEncode)
{
  unsigned char buf[2048];

  // XXXXXXXX THIS CODE APPEARS BELOW IN DYNAMIC VERSION, CHANGE BOTH!!!
  // FOR SPEED, WE DIDN'T DO FN CALLS OR ALWAYS DO DYNAMIC ALLOC

  // Compute HMAC+3DES(DATA+PAD)

  int padding = blockSize - dataSize;
  ivec[8] = (char) padding+65;

  char ivec2[8];

  memcpy(ivec2,ivec,8);
  memset(buf, 0, 10);  // HMAC
  memcpy(buf+10, rawData, dataSize); // data

  //randomize padding
  for (int iii=0; iii < padding; iii++)
  {
    *(buf+10+dataSize+iii) = (unsigned char) rand();
  }

  // Compute HMAC
  hmac_sha(m_keyMaterial, 24, buf+10, dataSize+padding, buf, 10);

#ifdef UNIX
  des_ede3_cbc_encrypt((C_Block*)(buf+10),(C_Block*)(buf+10), blockSize, 
		       ks1, ks2, ks3, (C_Block*)ivec2, DES_ENCRYPT);
#else
  for (int i = 0; i < blockSize; i+=8)
    {
      CBC(tripledes, 8, buf+10+i, buf+10+i, &ks, ENCRYPT, (BYTE*)ivec2);
    }
#endif

  // Now we've got a buffer of blockSize ready to be binhexed, and have the key
  // version prepended
  keyVersion = keyVersion % 36; // 0 - 9 & A - Z
  char v = (char) ((keyVersion > 9) ? (55+keyVersion) : (48+keyVersion));

  if(bEncode)
  {
      m_binhex.ToBase64(buf, blockSize+10, v, ivec, pEncrypted);
  }
  else
  {
      BYTE tb[2048];
      tb[0] = v;
      memcpy(&tb[1], ivec, 9);
      memcpy(&tb[10], buf, blockSize + 10);
      *pEncrypted = ::SysAllocStringByteLen((LPCSTR)tb, blockSize + 20);
  }
}

void CCoCrypt::encryptDynamic(char ivec[9], int blockSize, int keyVersion, 
			      LPSTR rawData, UINT dataSize,
			      BSTR *pEncrypted)
{
  unsigned char *buf = new unsigned char[blockSize+18];

  if (!buf)
    {
      *pEncrypted= NULL;
      return;
    }

  // XXXXXXXX THIS CODE IS COPIED FROM ABOVE, CHANGE BOTH!!!
  // FOR SPEED, WE DIDN'T DO FN CALLS OR ALWAYS DO DYNAMIC ALLOC

  // Compute HMAC+3DES(DATA+PAD)

  int padding = blockSize - dataSize;
  ivec[8] = (char) padding+65;

  char ivec2[8];

  memcpy(ivec2,ivec,8);
  memset(buf, 0, 10);  // HMAC
  memcpy(buf+10, rawData, dataSize); // data

  //randomize padding
  for (int iii=0; iii < padding; iii++)
  {
    *(buf+10+dataSize+iii) = (unsigned char) rand();
  }

  // Compute HMAC
  hmac_sha(m_keyMaterial, 24, buf+10, dataSize+padding, buf, 10);

#ifdef UNIX
  des_ede3_cbc_encrypt((C_Block*)(buf+10),(C_Block*)(buf+10), blockSize, 
		       ks1, ks2, ks3, (C_Block*)ivec2, DES_ENCRYPT);
#else
  for (int i = 0; i < blockSize; i+=8)
    {
      CBC(tripledes, 8, buf+10+i, buf+10+i, &ks, ENCRYPT, (BYTE*)ivec2);
    }
#endif

  // Now we've got a buffer of blockSize ready to be binhexed, and have the key
  // version prepended
  keyVersion = keyVersion % 36; // 0 - 9 & A - Z
  char v = (char) ((keyVersion > 9) ?
		   (55+keyVersion) : (48+keyVersion));
  m_binhex.ToBase64(buf, blockSize+10, v, ivec, pEncrypted);
  // XXX END COPY

  delete[] buf;
}

void CCoCrypt::setKeyMaterial(BSTR newVal)
{
  if (SysStringByteLen(newVal) != 24)
    {
      m_ok = FALSE;
      return;
    }

  memcpy(m_keyMaterial, (LPSTR)newVal, 24);

#ifdef UNIX

  int ok;
  ok = des_key_sched((C_Block*)(m_keyMaterial), ks1) ||
    des_key_sched((C_Block*)(m_keyMaterial+8), ks2) ||
    des_key_sched((C_Block*)(m_keyMaterial+16), ks3);
  m_ok = (ok == 0);

#else

  tripledes3key(&ks, (BYTE*) m_keyMaterial);
  m_ok = TRUE;

#endif
}

unsigned char *CCoCrypt::getKeyMaterial(DWORD *pdwLen)
{
    if (pdwLen)
        *pdwLen = 24;
    return m_keyMaterial;
}


int CCoCrypt::getKeyVersion(BSTR encrypted)
{
  char c = (char) encrypted[0];

  if (isdigit(c))
    return (c-48);

  if(isalpha(c)) // Key version can be 0 - 9 & A - Z (36)
    return (toupper(c)-65+10);

  return -1;
}


int CCoCrypt::getKeyVersion(BYTE *encrypted)
{
  char c = (char) encrypted[0];

  if (isdigit(c))
    return (c-48);

  if(isalpha(c)) // Key version can be 0 - 9 & A - Z (36)
    return (toupper(c)-65+10);

  return -1;
}


void CCoCrypt::CryptMemberID(BOOL encrypt, long &memberId, long &domainId, long puidScope)
{
  unsigned char buf[256];
  int blockSize = 8;
  char ivec2[8];
  unsigned char hmac[24];
  int operation;
  long nlPUIDScope = htonl(puidScope);  // Make sure our hash is system independent 

#ifdef UNIX
  des_key_schedule ksHMAC1, ksHMAC2, ksHMAC3;

#else
  DES3TABLE ksHMAC;

#endif

  // Initialize HMAC buffer
  memset(hmac, 0, 24);

  // Create the HMAC of the partner ID using the master key passed in
  hmac_sha( m_keyMaterial, 24, (unsigned char *)&nlPUIDScope, 4, hmac, 20);

  // Create the Triple DES table from the HMAC
#ifdef UNIX
  des_key_sched((C_Block*)(hmac), ksHMAC1);
  des_key_sched((C_Block*)(hmac+8), ksHMAC2);
  des_key_sched((C_Block*)(hmac+16), ksHMAC3);

#else
  tripledes3key(&ksHMAC, (BYTE*) hmac);

#endif

  // Init the initial vector to zero
  memset(ivec2,0,8);

  // Make sure member ID is system independent for encryption
  if (encrypt) 
    {
      memberId = htonl(memberId);
      domainId = htonl(domainId);
    }

  // copy ID's into a buffer for crypting
  memcpy(buf, &memberId, 4);
  memcpy(buf + 4, &domainId, 4);

  // Crypt the ID buffer with the Triple DES table
#ifdef UNIX
  if (encrypt) {
      operation = DES_ENCRYPT;
    } else {
      operation = DES_DECRYPT;
    }
  des_ede3_cbc_encrypt((C_Block*)(buf),(C_Block*)(buf), blockSize, 
		       ksHMAC1, ksHMAC2, ksHMAC3, (C_Block*)ivec2, operation);
#else
  if (encrypt) {
      operation = ENCRYPT;
    } else {
      operation = DECRYPT;
    }
  for (int i = 0; i < blockSize; i+=8)
    {
      CBC(tripledes, 8, buf+i, buf+i, &ksHMAC, operation, (BYTE*)ivec2);
    }
#endif

  // Copy crypted data from buffer back into the ID variables
  memcpy(&memberId, buf, 4);
  memcpy(&domainId, buf+4, 4);

  // If decrypting - transform back to host specific number
  if (!encrypt)
    {
      memberId = ntohl(memberId);
      domainId = ntohl(domainId);
    }
}


void CCoCrypt::setWideMaterial(BSTR kvalue)
{
    m_bstrWideMaterial = kvalue;
}

BSTR CCoCrypt::getWideMaterial()
{
    return m_bstrWideMaterial;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\crypt\hmac.h ===
#ifndef _HMAC_H
#define _HMAC_H

void hmac_sha(unsigned char *secretKey, int keyLen,
	      unsigned char *data, int dataLen,
	      unsigned char *out, int outLen);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\crypt\hmac.cpp ===
#include "stdafx.h"

#ifdef UNIX
  #include "sha.cpp"
#else
  #include "nt/sha.h"
#endif

#define SHA_BLOCKSIZE 64

void hmac_sha(unsigned char *k, int lk,
	      unsigned char *d, int ld,
	      unsigned char *out, int t)
{
  A_SHA_CTX ictx, octx ;
  unsigned char    isha[A_SHA_DIGEST_LEN], osha[A_SHA_DIGEST_LEN] ;
  unsigned char    key[A_SHA_DIGEST_LEN] ;
  unsigned char    buf[SHA_BLOCKSIZE] ;
  int     i ;

  if (lk > SHA_BLOCKSIZE) {
    
    A_SHA_CTX         tctx ;
    
    A_SHAInit(&tctx) ;
    A_SHAUpdate(&tctx, k, lk) ;
    A_SHAFinal(&tctx, key) ;
    
    k = key ;
    lk = A_SHA_DIGEST_LEN ;
  }
  
  /**** Inner Digest ****/
  
  A_SHAInit(&ictx) ;

  /* Pad the key for inner digest */
  for (i = 0 ; i < lk ; ++i) buf[i] = k[i] ^ 0x36 ;
  for (i = lk ; i < SHA_BLOCKSIZE ; ++i) buf[i] = 0x36 ;
  
  A_SHAUpdate(&ictx, buf, SHA_BLOCKSIZE) ;
  A_SHAUpdate(&ictx, d, ld) ;
  
  A_SHAFinal(&ictx, isha);

  /**** Outter Digest ****/
  
  A_SHAInit(&octx) ;
  
  /* Pad the key for outter digest */

  for (i = 0 ; i < lk ; ++i) buf[i] = k[i] ^ 0x5C ;
  for (i = lk ; i < SHA_BLOCKSIZE ; ++i) buf[i] = 0x5C ;

  A_SHAUpdate(&octx, buf, SHA_BLOCKSIZE) ;
  A_SHAUpdate(&octx, isha, A_SHA_DIGEST_LEN) ;

  A_SHAFinal(&octx, osha) ;
  
  /* truncate and print the results */
  memcpy(out, osha, (t > A_SHA_DIGEST_LEN) ? A_SHA_DIGEST_LEN : t);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\crypt\cocryptnobinhex.cpp ===
// CoCrypt.cpp: implementation of the CCoCrypt class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CoCryptNoBinhex.h"
#include "BstrDebug.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

const long CCoCryptNoBinhex::s_kKeyLen = 24;


//#define DATA_SIZE       32
//#define VECTOR_SIZE     17

#define DATA_SIZE(a)      ((a)*2)
#define VECTOR_SIZE(a)      ((a)+1)
#define VECTOR_BUF_SIZE(a)  (((a)+1)*2)

CCoCryptNoBinhex::CCoCryptNoBinhex()
{
}

CCoCryptNoBinhex::~CCoCryptNoBinhex()
{
}

bool CCoCryptNoBinhex::Encrypt32(
        const long      lVectLen, 
        const long      lPaddingLen, 
        const BYTE     *byPadding,
        const LPSTR     rawData, 
        UINT            dataSize,
        BYTE           *pEncrypted, 
        UINT            cbOut)
{
    try {
        unsigned char *buf; 
        char *ivec; 

        ivec = static_cast<char *>(_alloca(VECTOR_SIZE(lVectLen) * sizeof(char)));

        buf = static_cast<unsigned char *>(_alloca(VECTOR_BUF_SIZE(lVectLen) * sizeof(unsigned char)));

        if (!ivec || !buf) {
            return false;
        }


        if (dataSize > static_cast<UINT>(DATA_SIZE(lVectLen))) {
            return false;
        }

        int iLen = min (lPaddingLen, VECTOR_SIZE(lVectLen));

        
        memcpy(&ivec[0], byPadding, iLen);

        if (VECTOR_SIZE(lVectLen) - iLen) {
            memset(ivec+iLen, 0xaa, VECTOR_SIZE(lVectLen) - iLen);
        }

        int padding = DATA_SIZE(lVectLen) - dataSize;
        buf[0] = padding+65;
        buf[1] = 0;

        memcpy(buf+2, rawData, dataSize); // data

        for (long i = 0; i < padding; i++) {
            buf[2+dataSize+i] = (char) rand();
        }

        long j = min (VECTOR_SIZE(lVectLen), s_kKeyLen);
        long k = 0;
        
        //  joemull <7/23/99>
        //  This was somewhat hurried.  There is probably a more efficient way to do this.
        for (;;) {
            if (VECTOR_BUF_SIZE(lVectLen) - k > j) {
                CBC(tripledes, j, buf+k, buf+k, &ks, ENCRYPT, (BYTE*)ivec);
            }
            else if (VECTOR_BUF_SIZE(lVectLen) - k > 0) {
                CBC(tripledes, VECTOR_BUF_SIZE(lVectLen) - k, buf+k, buf+k, &ks, ENCRYPT, (BYTE*)ivec);
                break;
            }
            else {
                break;
            }
            k += j;
        }
        
        
        _ASSERT(static_cast<UINT>(VECTOR_BUF_SIZE(lVectLen)) <= cbOut);
        memcpy(pEncrypted, buf, VECTOR_BUF_SIZE(lVectLen));
    }
    catch (...)
    {
        return false;
    }
    return true;
}

bool CCoCryptNoBinhex::Decrypt32(
        const long      lVectLen, 
        const long      lPaddingLen, 
        const BYTE     *byPadding,
        const BYTE     *rawData, 
        UINT            dataSize, 
        BSTR           *pUnencrypted)
{

    try {

        unsigned char *buf; 
        unsigned char *ivec;

        ivec = static_cast<unsigned char *>(_alloca(VECTOR_SIZE(lVectLen) * sizeof(unsigned char)));

        buf = static_cast<unsigned char *>(_alloca(VECTOR_BUF_SIZE(lVectLen) * sizeof(unsigned char)));


        if (!ivec || !buf) {
            return false;
        }


        if (dataSize != static_cast<UINT>(VECTOR_BUF_SIZE(lVectLen))) {
            if (pUnencrypted) {
                *pUnencrypted = NULL;
            }
            return false;
        }

        int iLen = min(lPaddingLen, VECTOR_SIZE(lVectLen)); 


        memcpy(&ivec[0], byPadding, iLen);

        if (VECTOR_SIZE(lVectLen)-iLen) {
            memset(ivec+iLen, 0xaa, VECTOR_SIZE(lVectLen)-iLen);
        }


        memcpy(buf, rawData, dataSize);
        

        long j = min (VECTOR_SIZE(lVectLen), s_kKeyLen);
        long k = 0; 
        
        //  joemull <7/23/99>
        //  This was somewhat hurried.  There is probably a more efficient way to do this.
        for (;;) {
            if (VECTOR_BUF_SIZE(lVectLen) - k > j) {
                CBC(tripledes, j, buf+k, buf+k, &ks, DECRYPT, (BYTE*)ivec);
            }
            else if (VECTOR_BUF_SIZE(lVectLen) - k > 0) {
                CBC(tripledes, VECTOR_BUF_SIZE(lVectLen) - k, buf+k, buf+k, &ks, DECRYPT, (BYTE*)ivec);
                break;
            }
            else {
                break;
            }
            k += j;
        }

        // ok, now make our BSTR blob
        _ASSERT(dataSize-2+65-buf[0] > 0);
        _ASSERT(dataSize-2+65-buf[0] < dataSize+1);

        *pUnencrypted = ALLOC_AND_GIVEAWAY_BSTR_BYTE_LEN((char*) buf+2, dataSize-2+65-buf[0]);
    }
    catch (...)
    {
        return false;
    }
    return true;
}

bool CCoCryptNoBinhex::setKeyMaterial(const char *newVal)
{
    if (lstrlenA(newVal) != s_kKeyLen) {
        return false;
    }
    tripledes3key(&ks, (BYTE*) newVal);
    return true;
}

bool CCoCryptNoBinhex::setKeyMaterial(long cb, const BYTE *newVal)
{
    if (cb != s_kKeyLen) {
        return false;
    }
    tripledes3key(&ks, const_cast<BYTE*>(newVal));
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\crypt\keymanager.cpp ===
// KeyManager.cpp: implementation of the CKeyManager class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <iphlpapi.h>
#include "KeyManager.h"

#ifdef UNIX
  #include "sha.cpp"
#else
  #include "nt/sha.h"
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

typedef struct _ASTAT_
{
  ADAPTER_STATUS adapt;
  NAME_BUFFER    NameBuff [30];
}ASTAT, * PASTAT;

//  NOTE:  NetBios is not thread safe and having two threads running
//  through the CTor at the same time is bad.  Therefore, we use
//  a named mutex so that no more than one thread on a single machine
//  can ever execute the ctor at the same time.
CKeyManager::CKeyManager()
{

#define CRAP "12398sdfksjdflk"
#define CRAP2 "sdflkj31409sd"

    // Key must be at least that long
    _ASSERT(A_SHA_DIGEST_LEN > 12);

    m_ok = FALSE;
    m_dwLoggingEnabled = FALSE;

    //  Check for logging enabled.
    LONG lResult;
    HKEY hkPassport;
    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           TEXT("Software\\Microsoft\\Passport"),
                           0,
                           KEY_READ,
                           &hkPassport);
    if(lResult == ERROR_SUCCESS)
    {
        DWORD dwLen;
        dwLen = sizeof(DWORD);
        lResult = RegQueryValueEx(hkPassport,
                                  TEXT("KeyManLoggingEnabled"),
                                  NULL,
                                  NULL,
                                  (LPBYTE)&m_dwLoggingEnabled,
                                  &dwLen);

#if defined(_DEBUG)

        BYTE    abKey[6];
        dwLen = sizeof(abKey);
        lResult = RegQueryValueEx(hkPassport,
                                  TEXT("CryptKeyOverride"),
                                  NULL,
                                  NULL,
                                  abKey,
                                  &dwLen);
        if(lResult == ERROR_SUCCESS)
        {
            makeDESKey(abKey);
            goto Cleanup;
        }

#endif

        RegCloseKey(hkPassport);
    }

    //  In multi-process scenarios, the CreateMutex call can fail
    //  with access denied.  If this happens, sleep for a short period
    //  of time and try again.
    HANDLE hMutex;
    hMutex = CreateMutex(NULL, FALSE, TEXT("Passport.KeyManager.Ctor"));
    if(hMutex == NULL)
    {
        int nCreateCount;
        for(nCreateCount = 0; nCreateCount < 50 && hMutex == NULL; nCreateCount++)
        {
            Sleep(100);
            hMutex = CreateMutex(NULL, FALSE, TEXT("Passport.KeyManager.Ctor"));
        }

        if(hMutex == NULL)
        {
            DWORD dwError = GetLastError();
            LogBlob((LPBYTE)&dwError, sizeof(DWORD), "CREATE MUTEX ERROR");
            goto Cleanup;
        }
    }

    WaitForSingleObject(hMutex, INFINITE);

    //
    //  Get adapter information
    //

    ULONG               ulBufSize;
    PIP_ADAPTER_INFO    pHead;
    DWORD               dwResult;

    ulBufSize = 0;
    pHead = NULL;
    dwResult = GetAdaptersInfo(pHead, &ulBufSize);
    if(dwResult == ERROR_BUFFER_OVERFLOW)
    {
        if(ulBufSize == 0)
        {
            LogBlob(NULL, 0, "NO ADAPTERS!");
            goto Cleanup;
        }

        pHead = (PIP_ADAPTER_INFO)malloc(ulBufSize);

        if(pHead == NULL)
        {
            LogBlob(NULL, 0, "OUT OF MEMORY!");
            goto Cleanup;
        }

        dwResult = GetAdaptersInfo(pHead, &ulBufSize);
        if(dwResult != NO_ERROR)
            goto Cleanup;

        //
        //  Make all the keys.
        //

        unsigned char zeros[8];
        memset( zeros, 0, 8 );

        PIP_ADAPTER_INFO pCurrent;
        for(pCurrent = pHead; pCurrent != NULL ; pCurrent = pCurrent->Next)
        {
            if (memcmp(pCurrent->Address, zeros, 6)==0)
            {
                LogBlob((LPBYTE)pCurrent->Address, 6, "CANDIDATE MAC");
                continue;
            }

            // Now generate a DES key
            makeDESKey(pCurrent->Address);

            break;
        }
    }
    else if(dwResult == ERROR_NO_DATA)
    {
        LogBlob(NULL, 0, "NO ADAPTERS!");
        goto Cleanup;
    }
    else
    {
        //
        //  This machine doesn't support the necessary iphlpapi functions, so try
        //  netbios instead.  This won't work if the machine has netbios disabled,
        //  but it's the best we can do.
        //

        NCB Ncb;
        LANA_ENUM lenum;
        memset( &Ncb, 0, sizeof(Ncb) );
        Ncb.ncb_command = NCBENUM;
        Ncb.ncb_buffer = (UCHAR *)&lenum;
        Ncb.ncb_length = sizeof(lenum);

        UCHAR uRetCode;
        uRetCode = Netbios( &Ncb );

        if(lenum.length == 0)
        {
            LogBlob(NULL, 0, "NO ADAPTERS!");
        }

        unsigned char zeros[8];
        memset( zeros, 0, 8 );

        int i;
        for(i=0; i < lenum.length ;i++)
        {
            memset( &Ncb, 0, sizeof(Ncb) );
            Ncb.ncb_command = NCBRESET;
            Ncb.ncb_lana_num = lenum.lana[i];

            uRetCode = Netbios( &Ncb );
            if (uRetCode != 0)
                continue;

            memset( &Ncb, 0, sizeof (Ncb) );
            Ncb.ncb_command = NCBASTAT;
            Ncb.ncb_lana_num = lenum.lana[i];

            strcpy( (char*)Ncb.ncb_callname,  "*		      " );
            
            ASTAT Adapter;
            Ncb.ncb_buffer = (unsigned char *) &Adapter;
            Ncb.ncb_length = sizeof(Adapter);

            uRetCode = Netbios( &Ncb );
            if (uRetCode != 0)
                continue;


            if (memcmp(Adapter.adapt.adapter_address, zeros, 6)==0)
            {
                LogBlob((LPBYTE)&Adapter.adapt.adapter_address, 6, "CANDIDATE MAC");
                continue;
            }

            // Now generate a DES key
            makeDESKey(Adapter.adapt.adapter_address);

            break;
        }
    }


    // If we didn't find one, we break out w/m_ok = FALSE
Cleanup:
    if(!m_ok)
        LogBlob(NULL, 0, "CTOR NO MAC ADDRESS");

    if(pHead != NULL)
        free(pHead);

    if(hMutex)
    {
        ReleaseMutex(hMutex);
        CloseHandle(hMutex);
    }
}

CKeyManager::~CKeyManager()
{

}

#define ToHex(n) ((n > 9) ? ('A' + (n - 10)) : ('0' + n))

void CKeyManager::LogBlob(
    LPBYTE  pbBlob,
    DWORD   dwBlobLen,
    LPCSTR  pszCaption)
{
    HANDLE  hFile;
    BYTE    bZero = 0;
    TCHAR   achBuf[2048];
    CHAR    achOutput[8];
    DWORD   dwBytesWritten;
    UINT    i;
    const CHAR achSep[] = " = ";
    const CHAR achEOL[] = "\r\n";

    if(!m_dwLoggingEnabled)
        return;

    GetSystemDirectory(achBuf, sizeof(achBuf));
    lstrcat(achBuf, TEXT("\\ppkeyman.log"));

    hFile = CreateFile(achBuf,
               GENERIC_WRITE,
               0,
               NULL,
               OPEN_ALWAYS,
               FILE_ATTRIBUTE_NORMAL,
               NULL);
    if(hFile == INVALID_HANDLE_VALUE) return;

    SetFilePointer(hFile, 0, NULL, FILE_END);

    WriteFile(hFile, pszCaption, lstrlenA(pszCaption), &dwBytesWritten, NULL);
    WriteFile(hFile, achSep, 3, &dwBytesWritten, NULL);

    for(i = 0; i < dwBlobLen; i++)
    {
        BYTE bHigh = (pbBlob[i] >> 4) & 0xF;
        BYTE bLow  = pbBlob[i] & 0xF;

        achOutput[0] = ToHex(bHigh);
        achOutput[1] = ToHex(bLow);
    
        WriteFile(hFile, achOutput, 2, &dwBytesWritten, NULL);
    }

    WriteFile(hFile, achEOL, 2, &dwBytesWritten, NULL);

    CloseHandle(hFile);
}

void CKeyManager::makeDESKey(LPBYTE pbKey)
{
    LogBlob(pbKey, 6, "MAC");

    unsigned char key[2*A_SHA_DIGEST_LEN];
    A_SHA_CTX ictx;
    A_SHAInit(&ictx);

    A_SHAUpdate(&ictx, (BYTE*) CRAP, strlen(CRAP));
    A_SHAUpdate(&ictx, pbKey, 6);
    A_SHAUpdate(&ictx, (BYTE*) CRAP2, strlen(CRAP2));
    A_SHAFinal(&ictx, key);

    A_SHAInit(&ictx);
    A_SHAUpdate(&ictx, (BYTE*) CRAP2, strlen(CRAP2));
    A_SHAUpdate(&ictx, pbKey, 6);
    A_SHAUpdate(&ictx, (BYTE*) CRAP, strlen(CRAP));
    A_SHAFinal(&ictx, key+12);

#ifdef UNIX
    int ok;
    ok = des_key_sched((C_Block*)(key), ks1) ||
    des_key_sched((C_Block*)(key+8), ks2) ||
    des_key_sched((C_Block*)(key+16), ks3);
    m_ok = (ok == 0);
#else
    tripledes3key(&m_ks, (BYTE*) key);
    m_ok = TRUE;
#endif
}

static unsigned char kdsync[] = { 0x01, 0x10, 0x01, 0x10, 0x01, 0x10, 0x01, 0x10 };

HRESULT CKeyManager::encryptKey(BYTE input[24], BYTE output[32])
{
  char ivec[9];

  if (!m_ok)
  {
      LogBlob(NULL, 0, "ENCRYPT !!!INVALID KEY MANAGER OBJECT!!!");
      return E_FAIL;
  }

  LogBlob((LPBYTE)&m_ks, sizeof(DES3TABLE), "ENCRYPT KEY");
  LogBlob(input,  24, "ENCRYPT IN ");

  memcpy(ivec, "12345678", 8);

  // Do a simple DES encryption using our key
#ifdef UNIX
  des_ede3_cbc_encrypt((C_Block*)(kdsync), (C_Block*)(output), 8,
		       ks1, ks2, ks3, (C_Block*) ivec, DES_ENCRYPT);
  des_ede3_cbc_encrypt((C_Block*)(input), (C_Block*)(output+8), 24,
		       ks1, ks2, ks3, (C_Block*) ivec, DES_ENCRYPT);
#else
  CBC(tripledes, 8, output, kdsync, &m_ks, 1, (BYTE*)ivec);
  CBC(tripledes, 8, output+8, input, &m_ks, 1, (BYTE*)ivec);
  CBC(tripledes, 8, output+16, input+8, &m_ks, 1, (BYTE*)ivec);
  CBC(tripledes, 8, output+24, input+16, &m_ks, 1, (BYTE*)ivec);
#endif

  LogBlob(output, 32, "ENCRYPT OUT");

  return S_OK;
}

HRESULT CKeyManager::decryptKey(BYTE input[32], BYTE output[24])
{
  char ivec[9];

  if (!m_ok)
  {
      LogBlob(NULL, 0, "DECRYPT !!!INVALID KEY MANAGER OBJECT!!!");
      return E_FAIL;
  }

  LogBlob((LPBYTE)&m_ks, sizeof(DES3TABLE), "DECRYPT KEY");
  LogBlob(input,  32, "DECRYPT IN ");

  memcpy(ivec, "12345678", 8);

  // Do simple DES decryption
  unsigned char syncin[8];

#ifdef UNIX
  des_ede3_cbc_encrypt((C_Block*)(input),(C_Block*)(syncin), 8,
		       ks1, ks2, ks3, (C_Block*) ivec, DES_DECRYPT);
  des_ede3_cbc_encrypt((C_Block*)(input+8),(C_Block*)(output), 24,
		       ks1, ks2, ks3, (C_Block*) ivec, DES_DECRYPT);
#else
  CBC(tripledes, 8, syncin, input, &m_ks, 0, (BYTE*)ivec);
  CBC(tripledes, 8, output, input+8, &m_ks, 0, (BYTE*)ivec);
  CBC(tripledes, 8, output+8, input+16, &m_ks, 0, (BYTE*)ivec);
  CBC(tripledes, 8, output+16, input+24, &m_ks, 0, (BYTE*)ivec);
#endif

  LogBlob(output, 24, "DECRYPT OUT");

  if (memcmp(kdsync,syncin,8) != 0)
  {
      LogBlob((LPBYTE)&kdsync, 8, "DECRYPT KDSYNC");
      LogBlob((LPBYTE)&syncin, 8, "DECRYPT SYNCIN");
      return E_FAIL;
  }

  return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\crypt\sign.cpp ===
#include "stdafx.h"
#include <wincrypt.h>

// Sign.cpp
/*****************************************************************************/
HRESULT Hash_SignData(PBYTE pbBuffer, UINT dwBufferLen, BSTR* pBinSignature)
{
    HCRYPTPROV hProv = 0;
    HCRYPTHASH hHash = 0;

    PBYTE pbSignature = NULL;
    DWORD dwSignatureLen;

    DWORD dwCount;
    DWORD dwErr = 0;
    HRESULT hr = S_OK;

    if (!pbBuffer || !pBinSignature || dwBufferLen == 0) 
      return E_INVALIDARG;
    
    // Get handle to the default provider.
    if(!CryptAcquireContext(&hProv, L"MicrosoftPassport", MS_DEF_PROV, 
                                    PROV_RSA_FULL, CRYPT_MACHINE_KEYSET)) 
    {
      dwErr = GetLastError();
      goto Cleanup;
    }

    //
    // Hash .
    //

    // Create a hash object.
    if(!CryptCreateHash(hProv, CALG_MD5, 0, 0, &hHash)) 
    {
      dwErr = GetLastError();
      goto Cleanup;
    }

    // Add data to hash object.
    if(!CryptHashData(hHash, pbBuffer, dwBufferLen, 0)) 
    {
       dwErr = GetLastError();
       goto Cleanup;
    }

    //
    // Sign hash object.
    //

    // Determine size of signature.
    dwCount = 0;
    if(!CryptSignHash(hHash, AT_SIGNATURE, NULL, 0, NULL, &dwSignatureLen)) 
    {
       dwErr = GetLastError();
       goto Cleanup;
    }

    // Allocate memory for 'pbSignature'.
    if((pbSignature = (PBYTE)malloc(dwSignatureLen)) == NULL) 
    {
      dwErr = E_OUTOFMEMORY;
      goto Cleanup;
    }

    // Sign hash object (with signature key).
    if(!CryptSignHash(hHash, AT_SIGNATURE, NULL, 0, pbSignature, &dwSignatureLen)) 
    {
      dwErr = GetLastError();
      goto Cleanup;
    }

    *pBinSignature = ::SysAllocStringByteLen(NULL, dwSignatureLen);
    if(*pBinSignature)
      memcpy(*pBinSignature, pbSignature, dwSignatureLen);
    else
      hr = E_OUTOFMEMORY; 

Cleanup:
   
    //
    if(pbSignature) free(pbSignature);

    // Release crypto handles.
    if(hHash) CryptDestroyHash(hHash);
    if(hProv) CryptReleaseContext(hProv, 0);

    if(dwErr != 0)
       hr = HRESULT_FROM_WIN32(dwErr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\crypt\sha.cpp ===
/*
SHA-1 in C
By Steve Reid <steve@edmweb.com>
100% Public Domain

Test Vectors (from FIPS PUB 180-1)
"abc"
  A9993E36 4706816A BA3E2571 7850C26C 9CD0D89D
"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"
  84983E44 1C3BD26E BAAE4AA1 F95129E5 E54670F1
A million repetitions of "a"
  34AA973C D4C4DAA4 F61EEB2B DBAD2731 6534016F
*/

/* #define LITTLE_ENDIAN * This should be #define'd if true. */
/* #define SHA1HANDSOFF * Copies data before messing with it. */

#define LITTLE_ENDIAN
#define SHA1HANDSOFF

#include <stdio.h>
#include <string.h>

typedef struct {
    unsigned long state[5];
    unsigned long count[2];
    unsigned char buffer[64];
} A_SHA_CTX;

#define A_SHA_DIGEST_LEN 20

void A_SHATransform(unsigned long state[5], unsigned char buffer[64]);
void A_SHAInit(A_SHA_CTX* context);
void A_SHAUpdate(A_SHA_CTX* context, unsigned char* data, unsigned int len);
void A_SHAFinal(A_SHA_CTX* context, unsigned char digest[A_SHA_DIGEST_LEN]);

#define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))

/* blk0() and blk() perform the initial expand. */
/* I got the idea of expanding during the round function from SSLeay */
#ifdef LITTLE_ENDIAN
#define blk0(i) (block->l[i] = (rol(block->l[i],24)&0xFF00FF00) \
    |(rol(block->l[i],8)&0x00FF00FF))
#else
#define blk0(i) block->l[i]
#endif
#define blk(i) (block->l[i&15] = rol(block->l[(i+13)&15]^block->l[(i+8)&15] \
    ^block->l[(i+2)&15]^block->l[i&15],1))

/* (R0+R1), R2, R3, R4 are the different operations used in SHA1 */
#define R0(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk0(i)+0x5A827999+rol(v,5);w=rol(w,30);
#define R1(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk(i)+0x5A827999+rol(v,5);w=rol(w,30);
#define R2(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0x6ED9EBA1+rol(v,5);w=rol(w,30);
#define R3(v,w,x,y,z,i) z+=(((w|x)&y)|(w&x))+blk(i)+0x8F1BBCDC+rol(v,5);w=rol(w,30);
#define R4(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0xCA62C1D6+rol(v,5);w=rol(w,30);


/* Hash a single 512-bit block. This is the core of the algorithm. */

void A_SHATransform(unsigned long state[5], unsigned char buffer[64])
{
unsigned long a, b, c, d, e;
typedef union {
    unsigned char c[64];
    unsigned long l[16];
} CHAR64LONG16;
CHAR64LONG16* block;
#ifdef SHA1HANDSOFF
static unsigned char workspace[64];
    block = (CHAR64LONG16*)workspace;
    memcpy(block, buffer, 64);
#else
    block = (CHAR64LONG16*)buffer;
#endif
    /* Copy context->state[] to working vars */
    a = state[0];
    b = state[1];
    c = state[2];
    d = state[3];
    e = state[4];
    /* 4 rounds of 20 operations each. Loop unrolled. */
    R0(a,b,c,d,e, 0); R0(e,a,b,c,d, 1); R0(d,e,a,b,c, 2); R0(c,d,e,a,b, 3);
    R0(b,c,d,e,a, 4); R0(a,b,c,d,e, 5); R0(e,a,b,c,d, 6); R0(d,e,a,b,c, 7);
    R0(c,d,e,a,b, 8); R0(b,c,d,e,a, 9); R0(a,b,c,d,e,10); R0(e,a,b,c,d,11);
    R0(d,e,a,b,c,12); R0(c,d,e,a,b,13); R0(b,c,d,e,a,14); R0(a,b,c,d,e,15);
    R1(e,a,b,c,d,16); R1(d,e,a,b,c,17); R1(c,d,e,a,b,18); R1(b,c,d,e,a,19);
    R2(a,b,c,d,e,20); R2(e,a,b,c,d,21); R2(d,e,a,b,c,22); R2(c,d,e,a,b,23);
    R2(b,c,d,e,a,24); R2(a,b,c,d,e,25); R2(e,a,b,c,d,26); R2(d,e,a,b,c,27);
    R2(c,d,e,a,b,28); R2(b,c,d,e,a,29); R2(a,b,c,d,e,30); R2(e,a,b,c,d,31);
    R2(d,e,a,b,c,32); R2(c,d,e,a,b,33); R2(b,c,d,e,a,34); R2(a,b,c,d,e,35);
    R2(e,a,b,c,d,36); R2(d,e,a,b,c,37); R2(c,d,e,a,b,38); R2(b,c,d,e,a,39);
    R3(a,b,c,d,e,40); R3(e,a,b,c,d,41); R3(d,e,a,b,c,42); R3(c,d,e,a,b,43);
    R3(b,c,d,e,a,44); R3(a,b,c,d,e,45); R3(e,a,b,c,d,46); R3(d,e,a,b,c,47);
    R3(c,d,e,a,b,48); R3(b,c,d,e,a,49); R3(a,b,c,d,e,50); R3(e,a,b,c,d,51);
    R3(d,e,a,b,c,52); R3(c,d,e,a,b,53); R3(b,c,d,e,a,54); R3(a,b,c,d,e,55);
    R3(e,a,b,c,d,56); R3(d,e,a,b,c,57); R3(c,d,e,a,b,58); R3(b,c,d,e,a,59);
    R4(a,b,c,d,e,60); R4(e,a,b,c,d,61); R4(d,e,a,b,c,62); R4(c,d,e,a,b,63);
    R4(b,c,d,e,a,64); R4(a,b,c,d,e,65); R4(e,a,b,c,d,66); R4(d,e,a,b,c,67);
    R4(c,d,e,a,b,68); R4(b,c,d,e,a,69); R4(a,b,c,d,e,70); R4(e,a,b,c,d,71);
    R4(d,e,a,b,c,72); R4(c,d,e,a,b,73); R4(b,c,d,e,a,74); R4(a,b,c,d,e,75);
    R4(e,a,b,c,d,76); R4(d,e,a,b,c,77); R4(c,d,e,a,b,78); R4(b,c,d,e,a,79);
    /* Add the working vars back into context.state[] */
    state[0] += a;
    state[1] += b;
    state[2] += c;
    state[3] += d;
    state[4] += e;
    /* Wipe variables */
    a = b = c = d = e = 0;
}


/* A_SHAInit - Initialize new context */

void A_SHAInit(A_SHA_CTX* context)
{
    /* A_SHA initialization constants */
    context->state[0] = 0x67452301;
    context->state[1] = 0xEFCDAB89;
    context->state[2] = 0x98BADCFE;
    context->state[3] = 0x10325476;
    context->state[4] = 0xC3D2E1F0;
    context->count[0] = context->count[1] = 0;
}


/* Run your data through this. */

void A_SHAUpdate(A_SHA_CTX* context, unsigned char* data, unsigned int len)
{
unsigned int i, j;

    j = (context->count[0] >> 3) & 63;
    if ((context->count[0] += len << 3) < (len << 3)) context->count[1]++;
    context->count[1] += (len >> 29);
    if ((j + len) > 63) {
        memcpy(&context->buffer[j], data, (i = 64-j));
        A_SHATransform(context->state, context->buffer);
        for ( ; i + 63 < len; i += 64) {
            A_SHATransform(context->state, &data[i]);
        }
        j = 0;
    }
    else i = 0;
    memcpy(&context->buffer[j], &data[i], len - i);
}


/* Add padding and return the message digest. */

void A_SHAFinal(A_SHA_CTX* context, unsigned char digest[20])
{
unsigned long i, j;
unsigned char finalcount[8];

    for (i = 0; i < 8; i++) {
        finalcount[i] = (unsigned char)((context->count[(i >= 4 ? 0 : 1)]
         >> ((3-(i & 3)) * 8) ) & 255);  /* Endian independent */
    }
    A_SHAUpdate(context, (unsigned char *)"\200", 1);
    while ((context->count[0] & 504) != 448) {
        A_SHAUpdate(context, (unsigned char *)"\0", 1);
    }
    A_SHAUpdate(context, finalcount, 8);  /* Should cause a A_SHATransform() */
    for (i = 0; i < 20; i++) {
        digest[i] = (unsigned char)
         ((context->state[i>>2] >> ((3-(i & 3)) * 8) ) & 255);
    }
    /* Wipe variables */
    i = j = 0;
    memset(context->buffer, 0, 64);
    memset(context->state, 0, 20);
    memset(context->count, 0, 8);
    memset(&finalcount, 0, 8);
#ifdef SHA1HANDSOFF  /* make SHA1Transform overwrite it's own static vars */
    A_SHATransform(context->state, context->buffer);
#endif
}
 
/* ----------------------------- SHS Test code --------------------------- */
/* 
void main(void)
{
  A_SHA_CTX shsInfo;
  long i;
  unsigned char digestChar[20];

  A_SHAInit(&shsInfo);
  A_SHAUpdate(&shsInfo, "This is a test..!", 16);
  A_SHAFinal(digestChar, &shsInfo);

  for (i = 0; i < 20; i+=4)
    {
      printf("%x %x %x %x\n", 
	     digestChar[i], digestChar[i+1],
	     digestChar[i+2], digestChar[i+3]);
    }
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\crypt\keymanagerhash.cpp ===
// KeyManager.cpp: implementation of the CKeyManager class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <iphlpapi.h>
#include <wbemidl.h>
#include "KeyManagerHash.h"

#ifdef UNIX
  #include "sha.cpp"
#else
  #include "nt/sha.h"
#endif
HRESULT WMIIsNicMAC(BSTR bstrInstanceName);

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

typedef struct _ASTAT_
{
  ADAPTER_STATUS adapt;
  NAME_BUFFER    NameBuff [30];
}ASTAT, * PASTAT;

//  NOTE:  NetBios is not thread safe and having two threads running
//  through the CTor at the same time is bad.  Therefore, we use
//  a named mutex so that no more than one thread on a single machine
//  can ever execute the ctor at the same time.
CKeyManagerHash::CKeyManagerHash()
{
    ULONG               ulBufSize = 0;
    PIP_ADAPTER_INFO    pHead = NULL;
    DWORD               dwResult = 0;

#define CRAP "12398sdfksjdflk"
#define CRAP2 "sdflkj31409sd"

    // Key must be at least that long
    _ASSERT(A_SHA_DIGEST_LEN > 12);

    m_pks = NULL;
    m_nKeys = 0;
    m_nEncryptKey = (ULONG)-1;
    m_ok = FALSE;
    m_dwLoggingEnabled = FALSE;

    //  Check for logging enabled.
    LONG lResult;
    HKEY hkPassport;
    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           TEXT("Software\\Microsoft\\Passport"),
                           0,
                           KEY_READ,
                           &hkPassport);
    if(lResult == ERROR_SUCCESS)
    {
        DWORD dwLen;
        dwLen = sizeof(DWORD);
        lResult = RegQueryValueEx(hkPassport,
                                  TEXT("KeyManLoggingEnabled"),
                                  NULL,
                                  NULL,
                                  (LPBYTE)&m_dwLoggingEnabled,
                                  &dwLen);

#if defined(_DEBUG)

        BYTE    abKey[6];
        dwLen = sizeof(abKey);
        lResult = RegQueryValueEx(hkPassport,
                                  TEXT("CryptKeyOverride"),
                                  NULL,
                                  NULL,
                                  abKey,
                                  &dwLen);
        if(lResult == ERROR_SUCCESS)
        {
            m_nKeys = 1;
            m_pks = new DES3TABLE[1];
            m_nEncryptKey = 1;
            makeDESKey(abKey, 0);
            m_ok = TRUE;
            goto Cleanup;
        }

#endif

        RegCloseKey(hkPassport);
    }

    //  In multi-process scenarios, the CreateMutex call can fail
    //  with access denied.  If this happens, sleep for a short period
    //  of time and try again.
    HANDLE hMutex;
    hMutex = CreateMutex(NULL, FALSE, TEXT("Passport.KeyManager.Ctor"));
    if(hMutex == NULL)
    {
        int nCreateCount;
        for(nCreateCount = 0; nCreateCount < 50 && hMutex == NULL; nCreateCount++)
        {
            Sleep(100);
            hMutex = CreateMutex(NULL, FALSE, TEXT("Passport.KeyManager.Ctor"));
        }

        if(hMutex == NULL)
        {
            DWORD dwError = GetLastError();
            LogBlob((LPBYTE)&dwError, sizeof(DWORD), "CREATE MUTEX ERROR");
            goto Cleanup;
        }
    }

    WaitForSingleObject(hMutex, INFINITE);
#if 0
    HRESULT hr;
    
    hr = LoadKeysFromWMI();
    
    //
    //  If WMI failed, try IPHLPAPI and NetBios.
    //

    if(hr != S_OK)
#endif
    {
        //
        //  Get adapter information
        //

        ulBufSize = 0;
        dwResult = GetAdaptersInfo(pHead, &ulBufSize);
        if(dwResult == ERROR_BUFFER_OVERFLOW)
        {
            if(ulBufSize == 0)
            {
                LogBlob(NULL, 0, "NO ADAPTERS!");
                goto Cleanup;
            }

            pHead = (PIP_ADAPTER_INFO)malloc(ulBufSize);

            if(pHead == NULL)
            {
                LogBlob(NULL, 0, "OUT OF MEMORY!");
                goto Cleanup;
            }

            dwResult = GetAdaptersInfo(pHead, &ulBufSize);
            if(dwResult != NO_ERROR)
                goto Cleanup;

            //
            //  How many adapters are there?
            //

            PIP_ADAPTER_INFO pCurrent;
            for(pCurrent = pHead; pCurrent != NULL; pCurrent = pCurrent->Next)
                m_nKeys++;

            //
            //  Make a key table big enough to hold all of them.
            //

            m_pks = new DES3TABLE[m_nKeys];
            if(m_pks == NULL)
                goto Cleanup;
            memset(m_pks, 0, sizeof(DES3TABLE) * m_nKeys);

            //
            //  Make all the keys.
            //

            unsigned char zeros[8];
            memset( zeros, 0, 8 );

            int i;
            for(pCurrent = pHead, i = 0; pCurrent != NULL ; pCurrent = pCurrent->Next, i++)
            {
                if (memcmp(pCurrent->Address, zeros, 6) == 0)
                {
                    LogBlob((LPBYTE)pCurrent->Address, 6, "CANDIDATE MAC");
                    continue;
                }

                // Now generate a DES key
                if(m_nEncryptKey == (ULONG)-1)
                    m_nEncryptKey = i;

                makeDESKey(pCurrent->Address, i);
            }
        }
        else if(dwResult == ERROR_NO_DATA)
        {
            LogBlob(NULL, 0, "NO ADAPTERS!");
            goto Cleanup;
        }
        else
        {
            //
            //  This machine doesn't support the necessary iphlpapi functions, so try
            //  netbios instead.  This won't work if the machine has netbios disabled,
            //  but it's the best we can do.
            //

            NCB Ncb;
            LANA_ENUM lenum;
            memset( &Ncb, 0, sizeof(Ncb) );
            Ncb.ncb_command = NCBENUM;
            Ncb.ncb_buffer = (UCHAR *)&lenum;
            Ncb.ncb_length = sizeof(lenum);

            UCHAR uRetCode;
            uRetCode = Netbios( &Ncb );

            if(lenum.length == 0)
            {
                LogBlob(NULL, 0, "NO ADAPTERS!");
            }
            else
            {
                m_nKeys = lenum.length;
                m_pks = new DES3TABLE[m_nKeys];
                if(m_pks == NULL)
                    goto Cleanup;
                memset(m_pks, 0, sizeof(DES3TABLE) * m_nKeys);
            }

            unsigned char zeros[8];
            memset( zeros, 0, 8 );

            int i;
            for(i=0; i < lenum.length ;i++)
            {
                memset( &Ncb, 0, sizeof(Ncb) );
                Ncb.ncb_command = NCBRESET;
                Ncb.ncb_lana_num = lenum.lana[i];

                uRetCode = Netbios( &Ncb );
                if (uRetCode != 0)
                    continue;

                memset( &Ncb, 0, sizeof (Ncb) );
                Ncb.ncb_command = NCBASTAT;
                Ncb.ncb_lana_num = lenum.lana[i];

                strcpy( (char*)Ncb.ncb_callname,  "*		      " );

                ASTAT Adapter;
                Ncb.ncb_buffer = (unsigned char *) &Adapter;
                Ncb.ncb_length = sizeof(Adapter);

                uRetCode = Netbios( &Ncb );
                if (uRetCode != 0)
                    continue;

                if (memcmp(Adapter.adapt.adapter_address, zeros, 6)==0)
                {
                    LogBlob((LPBYTE)&Adapter.adapt.adapter_address, 6, "CANDIDATE MAC");
                    continue;
                }

                // Now generate a DES key
                if(m_nEncryptKey == (ULONG)-1)
                    m_nEncryptKey = i;

                makeDESKey(Adapter.adapt.adapter_address, i);
            }
        }
    }

Cleanup:
    if(!m_ok)
        LogBlob(NULL, 0, "CTOR NO MAC ADDRESS");

    if(pHead != NULL)
        free(pHead);

    if(hMutex)
    {
        ReleaseMutex(hMutex);
        CloseHandle(hMutex);
    }
}

CKeyManagerHash::~CKeyManagerHash()
{
    if(m_pks)
        delete [] m_pks;
}

#define ToHex(n) ((n > 9) ? ('A' + (n - 10)) : ('0' + n))

void CKeyManagerHash::LogBlob(
    LPBYTE  pbBlob,
    DWORD   dwBlobLen,
    LPCSTR  pszCaption)
{
    HANDLE  hFile;
    BYTE    bZero = 0;
    TCHAR   achBuf[2048];
    CHAR    achOutput[8];
    DWORD   dwBytesWritten;
    UINT    i;
    const CHAR achSep[] = " = ";
    const CHAR achEOL[] = "\r\n";

    if(!m_dwLoggingEnabled)
        return;

    GetSystemDirectory(achBuf, sizeof(achBuf));
    lstrcat(achBuf, TEXT("\\ppkeyman.log"));

    hFile = CreateFile(achBuf,
               GENERIC_WRITE,
               0,
               NULL,
               OPEN_ALWAYS,
               FILE_ATTRIBUTE_NORMAL,
               NULL);
    if(hFile == INVALID_HANDLE_VALUE) return;

    SetFilePointer(hFile, 0, NULL, FILE_END);

    WriteFile(hFile, pszCaption, lstrlenA(pszCaption), &dwBytesWritten, NULL);
    WriteFile(hFile, achSep, 3, &dwBytesWritten, NULL);

    for(i = 0; i < dwBlobLen; i++)
    {
        BYTE bHigh = (pbBlob[i] >> 4) & 0xF;
        BYTE bLow  = pbBlob[i] & 0xF;

        achOutput[0] = ToHex(bHigh);
        achOutput[1] = ToHex(bLow);
    
        WriteFile(hFile, achOutput, 2, &dwBytesWritten, NULL);
    }

    WriteFile(hFile, achEOL, 2, &dwBytesWritten, NULL);

    CloseHandle(hFile);
}

void CKeyManagerHash::makeDESKey(LPBYTE pbKey, ULONG nKey)
{
    LogBlob(pbKey, 6, "MAC");

    unsigned char key[2*A_SHA_DIGEST_LEN];
    A_SHA_CTX ictx;
    A_SHAInit(&ictx);

    A_SHAUpdate(&ictx, (BYTE*) CRAP, strlen(CRAP));
    A_SHAUpdate(&ictx, pbKey, 6);
    A_SHAUpdate(&ictx, (BYTE*) CRAP2, strlen(CRAP2));
    A_SHAFinal(&ictx, key);

    A_SHAInit(&ictx);
    A_SHAUpdate(&ictx, (BYTE*) CRAP2, strlen(CRAP2));
    A_SHAUpdate(&ictx, pbKey, 6);
    A_SHAUpdate(&ictx, (BYTE*) CRAP, strlen(CRAP));
    A_SHAFinal(&ictx, key+12);

#ifdef UNIX
    int ok;
    ok = des_key_sched((C_Block*)(key), ks1) ||
    des_key_sched((C_Block*)(key+8), ks2) ||
    des_key_sched((C_Block*)(key+16), ks3);
    m_ok = (ok == 0);
#else
    tripledes3key(&(m_pks[nKey]), (BYTE*) key);
    m_ok = TRUE;
#endif
}

static unsigned char kdsync[] = { 0x01, 0x10, 0x01, 0x10, 0x01, 0x10, 0x01, 0x10 };

HRESULT CKeyManagerHash::encryptKey(RAWKEY input, ENCKEY output)
{
    HRESULT     hr;
    char        ivec[9];
    BYTE        inBuf[48];
    A_SHA_CTX   ctx;

    if (!m_ok)
    {
        LogBlob(NULL, 0, "ENCRYPT !!!INVALID KEY MANAGER OBJECT!!!");
        hr = E_FAIL;
        goto Cleanup;
    }

    LogBlob((LPBYTE)&(m_pks[m_nEncryptKey]), sizeof(DES3TABLE), "ENCRYPT KEY");
    LogBlob(input,  sizeof(RAWKEY), "ENCRYPT IN ");

    memcpy(ivec, "12345678", 8);

    // build up the input buffer + sha-1 hash
    memcpy(inBuf, input, sizeof(RAWKEY));

    A_SHAInit(&ctx);
    A_SHAUpdate(&ctx, inBuf, sizeof(RAWKEY));
    A_SHAFinal(&ctx, inBuf + sizeof(RAWKEY));

    memset(inBuf + 44, 0, 4);

    // Do a simple DES encryption using our key
    // We only encrypt 40 of the 44 bytes
#ifdef UNIX
    des_ede3_cbc_encrypt((C_Block*)(kdsync), (C_Block*)(output), 8,
		       ks1, ks2, ks3, (C_Block*) ivec, DES_ENCRYPT);
    des_ede3_cbc_encrypt((C_Block*)(input), (C_Block*)(output+8), 24,
		       ks1, ks2, ks3, (C_Block*) ivec, DES_ENCRYPT);
#else
    CBC(tripledes, 8, output,    kdsync,   &(m_pks[m_nEncryptKey]), 1, (BYTE*)ivec);
    CBC(tripledes, 8, output+8,  inBuf,    &(m_pks[m_nEncryptKey]), 1, (BYTE*)ivec);
    CBC(tripledes, 8, output+16, inBuf+8,  &(m_pks[m_nEncryptKey]), 1, (BYTE*)ivec);
    CBC(tripledes, 8, output+24, inBuf+16, &(m_pks[m_nEncryptKey]), 1, (BYTE*)ivec);
    CBC(tripledes, 8, output+32, inBuf+24, &(m_pks[m_nEncryptKey]), 1, (BYTE*)ivec);
    CBC(tripledes, 8, output+40, inBuf+32, &(m_pks[m_nEncryptKey]), 1, (BYTE*)ivec);
    CBC(tripledes, 8, output+48, inBuf+40, &(m_pks[m_nEncryptKey]), 1, (BYTE*)ivec);
#endif

    LogBlob(output, sizeof(ENCKEY), "ENCRYPT OUT");

    hr = S_OK;

Cleanup:

    return hr;
}

HRESULT CKeyManagerHash::decryptKey(ENCKEY input, RAWKEY output)
{
    HRESULT     hr;
    char        ivec[9];
    BYTE        outBuf[48];
    BYTE        hashOut[A_SHA_DIGEST_LEN];
    A_SHA_CTX   ctx;
    ULONG       nCurKey;
    DES3TABLE   nullTable;

    memset(&nullTable, 0, sizeof(DES3TABLE));

    if (!m_ok)
    {
        LogBlob(NULL, 0, "DECRYPT !!!INVALID KEY MANAGER OBJECT!!!");
        hr = E_FAIL;
        goto Cleanup;
    }

    //LogBlob((LPBYTE)&m_ks, sizeof(DES3TABLE), "DECRYPT KEY");
    LogBlob(input,  sizeof(ENCKEY), "DECRYPT IN ");

    memcpy(ivec, "12345678", 8);

    // Do simple DES decryption
    unsigned char syncin[8];

    for(nCurKey = 0; nCurKey < m_nKeys; nCurKey++)
    {
        if(memcmp(&(m_pks[nCurKey]), &nullTable, sizeof(DES3TABLE)) == 0)
            continue;

#ifdef UNIX
        des_ede3_cbc_encrypt((C_Block*)(input),(C_Block*)(syncin), 8,
		           ks1, ks2, ks3, (C_Block*) ivec, DES_DECRYPT);
        des_ede3_cbc_encrypt((C_Block*)(input+8),(C_Block*)(output), 24,
		           ks1, ks2, ks3, (C_Block*) ivec, DES_DECRYPT);
#else
        CBC(tripledes, 8, syncin,    input,    &(m_pks[nCurKey]), 0, (BYTE*)ivec);
        CBC(tripledes, 8, outBuf,    input+8,  &(m_pks[nCurKey]), 0, (BYTE*)ivec);
        CBC(tripledes, 8, outBuf+8,  input+16, &(m_pks[nCurKey]), 0, (BYTE*)ivec);
        CBC(tripledes, 8, outBuf+16, input+24, &(m_pks[nCurKey]), 0, (BYTE*)ivec);
        CBC(tripledes, 8, outBuf+24, input+32, &(m_pks[nCurKey]), 0, (BYTE*)ivec);
        CBC(tripledes, 8, outBuf+32, input+40, &(m_pks[nCurKey]), 0, (BYTE*)ivec);
        CBC(tripledes, 8, outBuf+40, input+48, &(m_pks[nCurKey]), 0, (BYTE*)ivec);
#endif

        LogBlob(outBuf, 48, "DECRYPT OUT");

        if (memcmp(kdsync,syncin,8) != 0)
        {
            LogBlob((LPBYTE)&kdsync, 8, "DECRYPT KDSYNC");
            LogBlob((LPBYTE)&syncin, 8, "DECRYPT SYNCIN");
            continue;
        }

          //  compute and compare hash

        A_SHAInit(&ctx);
        A_SHAUpdate(&ctx, outBuf, sizeof(RAWKEY));
        A_SHAFinal(&ctx, hashOut);

        if(memcmp(outBuf + sizeof(RAWKEY), hashOut, A_SHA_DIGEST_LEN) != 0)
        {
            LogBlob((LPBYTE)outBuf + sizeof(RAWKEY), A_SHA_DIGEST_LEN, "OUTBUF HASH");
            LogBlob((LPBYTE)hashOut, A_SHA_DIGEST_LEN, "COMPUTED HASH");
            continue;
        }

        memcpy(output, outBuf, sizeof(RAWKEY));
        hr = S_OK;
        goto Cleanup;
    }

    hr = E_FAIL;

Cleanup:

    return hr;
}

#define MAX_WMI_ADDRESSES 32

HRESULT CKeyManagerHash::LoadKeysFromWMI()
{
    HRESULT                 hr;
    bool                    bMadeKeys = false;
    IWbemLocator*           piLocator = NULL;
    IWbemServices*          piServices = NULL;
    IWbemClassObject*       piClassObject = NULL;
    IEnumWbemClassObject*   piEnumObjects = NULL;
    IClientSecurity*        piClientSecurity = NULL;
    IWbemClassObject*       apiObjects[MAX_WMI_ADDRESSES];
    BSTR                    bstrRootName = SysAllocString(L"root\\wmi");
    BSTR                    bstrClassName = SysAllocString(L"MsNdis_EthernetPermanentAddress");

    
    if(bstrRootName == NULL || bstrClassName == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    memset(apiObjects, 0, sizeof(apiObjects));

    hr = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_SERVER, IID_IWbemLocator, (void**)&piLocator);
    if(FAILED(hr))
        goto Cleanup;

    hr = piLocator->ConnectServer(bstrRootName,
                                  NULL,
                                  NULL,
                                  NULL,
                                  0,
                                  NULL,
                                  NULL,
                                  &piServices);
    if(FAILED(hr))
        goto Cleanup;

    hr = piServices->QueryInterface(IID_IClientSecurity, 
										  (void**)&piClientSecurity);
    if(FAILED(hr))
        goto Cleanup;

	hr = piClientSecurity->SetBlanket(piServices, 
				 			         RPC_C_AUTHN_WINNT, 
				 			         RPC_C_AUTHZ_NONE,
				 			         NULL, 
				 			         RPC_C_AUTHN_LEVEL_CONNECT, 
				 			         RPC_C_IMP_LEVEL_IMPERSONATE,
				 			         NULL, 
				 			         EOAC_NONE);
    if(FAILED(hr))
        goto Cleanup;

    hr = piServices->CreateInstanceEnum(bstrClassName,
                                        0,
                                        NULL,
                                        &piEnumObjects);

    if(FAILED(hr))
        goto Cleanup;


    hr = piEnumObjects->Next(WBEM_INFINITE, MAX_WMI_ADDRESSES, apiObjects, &m_nKeys);
    if(FAILED(hr))
        goto Cleanup;

    //
    //  Make a key table big enough to hold all of them.
    //

    m_pks = new DES3TABLE[m_nKeys];
    if(m_pks == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    memset(m_pks, 0, sizeof(DES3TABLE) * m_nKeys);

    //
    //  Make all the keys.
    //

    unsigned char zeros[8];
    memset( zeros, 0, 8 );

    ULONG i;
    for(i = 0; i < m_nKeys; i++)
    {
        VARIANT vValue;
        CIMTYPE type;
        LONG lFlavor;
		VARIANT vInstanceName;
		VariantInit(&vInstanceName);

        VariantInit(&vValue);


        hr = apiObjects[i]->Get(L"NdisPermanentAddress", 0, &vValue, &type, &lFlavor);
		if (SUCCEEDED(hr))
	        hr = apiObjects[i]->Get(L"InstanceName", 0, &vInstanceName, NULL, NULL);
        if(SUCCEEDED(hr))
        {
            IWbemClassObject* piAddress = NULL;
            hr = vValue.punkVal->QueryInterface(IID_IWbemClassObject, (void**)&piAddress);
            if(SUCCEEDED(hr))
            {
                VARIANT vAddrVal;
                VariantInit(&vAddrVal);
        
                hr = piAddress->Get(L"Address", 0, &vAddrVal, NULL, NULL);
                if(SUCCEEDED(hr))
                {
                    //
                    //  Make sure we have an array, and it's the correct length.
                    //

                    if((vAddrVal.vt & VT_ARRAY) && 
                        vAddrVal.parray->rgsabound[0].cElements == 6)
                    {
                        LPBYTE puiAddress;

                        SafeArrayAccessData(vAddrVal.parray, (void**)&puiAddress);

                        if (memcmp(puiAddress, zeros, 6) == 0 || S_OK != WMIIsNicMAC(vInstanceName.bstrVal))
                        {
                            LogBlob((LPBYTE)puiAddress, 6, "CANDIDATE MAC");

							// prevent memory leak
	                        SafeArrayUnaccessData(vAddrVal.parray);
				            VariantClear(&vValue);
				            piAddress->Release();
							VariantClear(&vInstanceName);

                            continue;
                        }
						
                        // Now generate a DES key
                        if(m_nEncryptKey == (ULONG)-1)
                            m_nEncryptKey = i;
						
                        makeDESKey(puiAddress, i);

                        SafeArrayUnaccessData(vAddrVal.parray);

                        bMadeKeys = true;
                    }
                }
                piAddress->Release();
            }
			VariantClear(&vInstanceName);
            VariantClear(&vValue);
        }
    }

    hr = bMadeKeys ? S_OK : S_FALSE;

Cleanup:

    if(piLocator != NULL)
    {
        piLocator->Release();
    }

    if(piServices != NULL)
    {
        piServices->Release();
    }

    if(piClientSecurity != NULL)
    {
        piClientSecurity->Release();
    }

    if(piEnumObjects != NULL)
    {
        piEnumObjects->Release();
    }

    for(i = 0; i < MAX_WMI_ADDRESSES; i++)
    {
        if(apiObjects[i] != NULL)
        {
            apiObjects[i]->Release();
        }
    }

    SysFreeString(bstrRootName);
    SysFreeString(bstrClassName);

    return hr;
}

HRESULT WMIIsNicMAC(BSTR bstrInstanceName)
{
    HRESULT                 hr;
    IWbemLocator*           piLocator = NULL;
    IWbemServices*          piServices = NULL;
    IWbemClassObject*       piClassObject = NULL;
    IEnumWbemClassObject*   piNICEnumObjects = NULL;
    IClientSecurity*        piClientSecurity = NULL;
    IWbemClassObject*       nicObjects[MAX_WMI_ADDRESSES];
    BSTR                    bstrRootName = SysAllocString(L"root\\cimv2");
	BSTR					bstrQuery = SysAllocString(L"select * from win32_networkadapterconfiguration where ipenabled = true and "
														L"macaddress != NULL and settingid != NULL");
	BSTR					bstrWQL = SysAllocString(L"WQL");
	ULONG					nNicAddresses=0;

    
    if(bstrRootName == NULL || bstrQuery == NULL || bstrWQL == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

	memset(nicObjects, 0, sizeof(nicObjects));

    hr = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_SERVER, IID_IWbemLocator, (void**)&piLocator);
    if(FAILED(hr))
        goto Cleanup;

    hr = piLocator->ConnectServer(bstrRootName,
                                  NULL,
                                  NULL,
                                  NULL,
                                  0,
                                  NULL,
                                  NULL,
                                  &piServices);
    if(FAILED(hr))
        goto Cleanup;

    hr = piServices->QueryInterface(IID_IClientSecurity, 
										  (void**)&piClientSecurity);
    if(FAILED(hr))
        goto Cleanup;

	hr = piClientSecurity->SetBlanket(piServices, 
				 			         RPC_C_AUTHN_WINNT, 
				 			         RPC_C_AUTHZ_NONE,
				 			         NULL, 
				 			         RPC_C_AUTHN_LEVEL_CONNECT, 
				 			         RPC_C_IMP_LEVEL_IMPERSONATE,
				 			         NULL, 
				 			         EOAC_NONE);
    if(FAILED(hr))
        goto Cleanup;

    hr = piServices->ExecQuery( bstrWQL, 
                                    bstrQuery,
                                    WBEM_FLAG_RETURN_IMMEDIATELY, 
                                    NULL,
                                    &piNICEnumObjects);
    if(FAILED(hr))
        goto Cleanup;

    hr = piNICEnumObjects->Next(WBEM_INFINITE, MAX_WMI_ADDRESSES, nicObjects, &nNicAddresses);
    if(FAILED(hr))
        goto Cleanup;

	/////////////
	// if it IS a nic card
	VARIANT vValue;
	CIMTYPE type;
	LONG lFlavor;
	for (ULONG i=0; i < nNicAddresses; i++)
	{
		VariantInit(&vValue);
		nicObjects[i]->Get(L"Caption", 0, &vValue, &type, &lFlavor);
		if (vValue.vt == VT_BSTR && wcsstr(vValue.bstrVal, bstrInstanceName))
		{
			hr = S_OK;
			VariantClear(&vValue);
			goto Cleanup;
		}
		VariantClear(&vValue);
	}

Cleanup:

    if(piLocator != NULL)
    {
        piLocator->Release();
    }

    if(piServices != NULL)
    {
        piServices->Release();
    }

    if(piClientSecurity != NULL)
    {
        piClientSecurity->Release();
    }

	if (piNICEnumObjects != NULL)
	{
		piNICEnumObjects->Release();
	}

    for(i = 0; i < MAX_WMI_ADDRESSES; i++)
    {
		if (nicObjects[i] != NULL)
		{
			nicObjects[i]->Release();
		}
    }

    SysFreeString(bstrRootName);
	SysFreeString(bstrQuery);
	SysFreeString(bstrWQL);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\crypt\keycrypto.cpp ===
// KeyManager.cpp: implementation of the CKeyManager class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "keycrypto.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

// this is a optional Entropy ... 
static const BYTE __STR_CRAP[] = "1^k\0\x99$\0\\*m$\0.)\nj#\t&H\0%!FhLG%@-<v";
static LPCWSTR __STR_DESC = L"passport2.0";

CKeyCrypto::CKeyCrypto()
{
    m_EntropyBlob.pbData = (PBYTE)__STR_CRAP;
    m_EntropyBlob.cbData = (DWORD)sizeof(__STR_CRAP);
}

HRESULT CKeyCrypto::encryptKey(DATA_BLOB* input, DATA_BLOB* output)
{
    if (!input || !output)
       return E_INVALIDARG;

    HRESULT     hr = S_OK;

    if(!::CryptProtectData(input, __STR_DESC, &m_EntropyBlob, NULL, NULL, 
                     CRYPTPROTECT_LOCAL_MACHINE | CRYPTPROTECT_UI_FORBIDDEN,
                     output))
    {
      hr = HRESULT_FROM_WIN32(::GetLastError());
    }

    return hr;
}

HRESULT CKeyCrypto::decryptKey(DATA_BLOB* input, DATA_BLOB* output)
{
    if (!input || !output)
       return E_INVALIDARG;

    HRESULT     hr = S_OK;
    LPWSTR      pstrDesc = NULL;

    if(!::CryptUnprotectData(input, &pstrDesc, &m_EntropyBlob, NULL, NULL, 
                     CRYPTPROTECT_UI_FORBIDDEN, output))
    {
       hr = HRESULT_FROM_WIN32(::GetLastError());
    }

    // this error case should never happen -- if crytoAPI doing the right things
    if(!pstrDesc) 
       hr = E_FAIL;
    else
    {
      if ( wcscmp(pstrDesc, __STR_DESC) != 0)
         hr = E_FAIL;
      ::LocalFree(pstrDesc);
    }
    
    return hr;
}


BOOL CKeyCrypto::IsFromThis(PBYTE pData, ULONG cb)
{
   if(pData == NULL || cb == 0)
      return FALSE;

   BOOL bRet = FALSE;

   DATA_BLOB   iBlob;
   DATA_BLOB   oBlob;
   
   ZeroMemory(&oBlob, sizeof(DATA_BLOB));
   
   iBlob.cbData = cb;
   iBlob.pbData = pData;

   if (decryptKey(&iBlob, &oBlob) == S_OK)
      bRet = TRUE;

   if (oBlob.pbData)
      ::LocalFree(oBlob.pbData);

   return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\crypt\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	crypt.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\crypt\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__70EC6ECA_9549_11D2_95DE_00C04F8E7A70__INCLUDED_)
#define AFX_STDAFX_H__70EC6ECA_9549_11D2_95DE_00C04F8E7A70__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0403
#endif

#include <comdef.h>
#include <crtdbg.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__70EC6ECA_9549_11D2_95DE_00C04F8E7A70__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\digest\debug.hpp ===
#ifndef DEBUG_HPP
#define DEBUG_HPP


// define DRDDEBUG if you want to unit test the ReturnWithProfile(..) 
// function, regardless of what AuthenticateMember returned.
//#define DRDDEBUG


#ifdef DBG

#define _DEBUG

#include <string.h>
//#include <fstream.h>
//#include <iomanip.h>

#include "PassportGuard.hpp"
#include "PassportLock.hpp"


#define DRDREGISTRYVALUELEN 1024

// The constants aren't used by the PASSPORTLOG macro at the moment, just 
// a place holder for future functionality.
//
// Debug constants used to configure what gets logged.  Will be moved out of
// here an into the registry eventually.  Add yours to the list.
#define CACHE_DBGNUM                   100
#define CACHEEXTENSION_DBGNUM          101

#define DOMAINMAP_DBGNUM               200

#define PPSSPI_DBGNUM                  300



#ifndef PASSPORTDEBUGAPI
#define PASSPORTDEBUGAPI __declspec(dllimport)
#endif

// this is the maxium number of groups we can handle...make sure this is at least big
// enough to handle all of the groups we have
#define MAXNUMBER_OF_LOGGINGGROUPS     100


// To print out a number in HEX, preceded the insertion of the number with:
//       <<hex<<setw(8)<<setfill('0')
// and put this after the number:
//       <<dec<<setfill(' ')
// so you end up with:
//    PASSPORTLOG(PPSSPI_DBGNUM, "Exiting RevertSecurityContext with status = "<<hex<<setw(8)<<setfill('0')<<Status<<dec<<setfill(' ')<<".\n");


class PASSPORTDEBUGAPI PassportDebug
{
public:
   static PassportLock mLock;
   static bool OKToLog(int logGroupNumber);

private:
   static LONG PassportDebug::ReadItemFromRegistry(LPCSTR subkeyName, LPSTR valueName,
                                          DWORD sizeOfData, void * dataBuffer);
   
   static bool bInitialized;
   static INT groupsArray[MAXNUMBER_OF_LOGGINGGROUPS];
   static INT numberOfGroups;

};//class PassportDebug



#define PASSPORTLOG(lognum, string) { \
   PassportGuard<PassportLock> Guard(PassportDebug::mLock); \
   if (PassportDebug::OKToLog(lognum)) { \
      ofstream outFile("C:\\passport.txt", ios::out | ios::app); \
      if (outFile && outFile.good()) \
         outFile << string; \
      outFile.close(); \
   } \
}



#define PASSPORT_RECYCLE_DEBUG_LOGS { \
   ofstream outFile("C:\\passport.txt", ios::out | ios::trunc); \
   outFile.close(); \
}




#else /* DBG*/


#define PASSPORTLOG(lognum, string)


#endif /* DBG*/








//nothing below this line
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\digest\authparse.cpp ===
/*++

    Copyright (c) 1998 Microsoft Corporation

    Module Name:

        AuthParse.cpp

    Abstract:

        Implementation of the ParseAuthorizationHeader function.

    Author:

        Darren L. Anderson (darrenan) 20-Aug-1998

    Revision History:

        20-Aug-1998 darrenan - Created
		27-Mar-2000 cambler - Fixed logic problem in ParseAuthorizationHeader()
    
--*/

#include "precomp.h"

LPCSTR g_ppszDigestNames[] =
{
    "username",
    "realm",
    "nonce",
    "uri",
    "response",
    "digest",
    "algorithm",
    "opaque",
    "cnonce",
    "qop",
    "nc"
};


LPSTR 
SkipWhite( 
    LPSTR p 
    )
/*++

Routine Description:

    Skip white space and ','

Arguments:

    p - ptr to string

Return Value:

    updated ptr after skiping white space

--*/
{
    while (isspace(*p) || *p == ',' )
    {
        ++p;
    }

    return p;
}
BOOL
ParseAuthorizationHeader(
    LPSTR pszHeader, 
    LPSTR pValueTable[DIGEST_AUTH_LAST]
    )

/*++

Routine Description:

    ParseAuthorizationHeader - This method takes a single string containing a
                               Digest authorization header and returns an array of
                               pointers to header values such as 'username', 'nonce',
                               etc.

Arguments:

    pszHeader   - Pointer to the authorization header.  The header should not contain
                  the "Authorization: Digest " portion of the header, just the name/
                  value pairs themselves.

    pValueTable - An array of string pointers.  The elements of the array will be
                  filled in by this method.  Elements in the array corresponding to
                  non-existent name/value pairs will be NULL on return.

Return Value:

    TRUE  - The header was parsed successfully.
    FALSE - The header was not parsed.  Bad structure in the header. 
	(RAID 4798: or the header was empty, or contained gibberish with at least one space)

--*/

{
    BOOL    bReturn = FALSE;
    PSTR    pszBeginName;
    PSTR    pszEndName;
    PSTR    pszBeginVal;
    PSTR    pszEndVal;
    int     ch;

    // NULL the array.

    for (UINT uTable = 0; uTable < DIGEST_AUTH_LAST; uTable++)
        pValueTable[uTable] = NULL;

    while (*pszHeader) {

        pszEndVal = NULL;

        pszHeader = SkipWhite(pszHeader);

        if (*pszHeader == '\0')
            break;

        pszBeginName = pszHeader;

        for (pszEndName = pszHeader ; (ch = *pszEndName) && ch != '=' && ch != ' ' ; ++pszEndName)
        {
			// Loop does the work - advance the pszEndName pointer until it's either an "=" or " " (or NULL)
        }

		if (*pszEndName) {

            *pszEndName = '\0';

			// We now have a name, pointed to by pszBeginName. Let's get a value...

            if (*(pszEndName + 1) == '"') {

				// The value starts with a quote

                for (pszBeginVal = ++pszEndName ; (ch = *pszBeginVal) && ch != '"' ; ++pszBeginVal)
                {
					// Loop does the work - advance the pszBeginVal pointer until it's a quote (or NULL)
                }

                if (*pszBeginVal == '"') {

					// The value was bound by quotes

                    ++pszBeginVal;

                    for (pszEndVal = pszBeginVal ; (ch = *pszEndVal) ; ++pszEndVal)
                    {
                        if (ch == '"')
                        {
                            break;
                        }
                    }
                }

            } else {

                pszBeginVal = ++pszEndName;

                for ( pszEndVal = pszBeginVal ; (ch = *pszEndVal) && ch != ',' ; ++pszEndVal)
                {
					// Loop does the work - advance the pszEndVal pointer until it's a comma (or NULL)
                }
            }

            //
            //  At this point, pszBeginName points to the parsed parameter name, and
            //  pszBeginVal points to the parsed parameter value.
            //

            // find name in table

			UINT nCurrent;

            for (nCurrent = 0 ; nCurrent < DIGEST_AUTH_LAST ; ++nCurrent)
                if (!_stricmp( g_ppszDigestNames[nCurrent], pszBeginName))
					break;

            // Set the table entry equal to the value and note that we've actually found something

            if (nCurrent < DIGEST_AUTH_LAST) {

                pValueTable[nCurrent] = pszBeginVal;

				bReturn = TRUE;
            }

            // Are we at the end of the header string?

            if (pszEndVal && *pszEndVal) {

                // No, terminate value and loop.

                *pszEndVal = '\0';

                pszHeader = ++pszEndVal;

                continue;

            } else

                // yes, break out of the loop and return.

                break;

        } else

			// yes, break out of the loop and return. We got to the end without
			// finding "=" or " ", so there's nothing else to do.

			break;
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\digest\base64.cpp ===
//#include <string.h>
//#include "base64.h"
#include "precomp.h"

#define	true	1

const char cToBase64[66] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
const Byte cFromBase64[257] =
{
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0x3e, 0xff, 0xff, 0xff, 0x3f,
	0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,
	0x3c, 0x3d, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff,

	0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
	0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
	0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16,
	0x17, 0x18, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff,

	0xff, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
	0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
	0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30,
	0x31, 0x32, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,

	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x3d
};

const char cToUU[66] =
{
	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
	0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
	0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
	0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
	0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
	0x0a
};
const Byte cFromUU[257] =
{
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
	0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
	
	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
	0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
	0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,

	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x0a
};

const char cToMSUU[66] =
{
	0x60, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
	0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
	0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
	
	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
	0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
	0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
	0x3d
};
const Byte cFromMSUU[257] =
{
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

	0xff, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
	0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
	
	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
	0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
	0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,

	0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x3d
};

void WINAPI	Base64_DecodeBytes(							// base-64 decode a series of blocks
						const char *pSource,		// the source (can be the same as the destination)
						char *pTerminate,			// the source termination characters
						Byte *rDest,				// the destination (can be the same as the source)
						SInt32 *rSize)				// the number of source bytes
{
	SixBit_DecodeBytes(pSource, pTerminate, cFromBase64, rDest, rSize);
}

void WINAPI UU_DecodeBytes(								// uu decode a series of blocks
						const char *pSource,		// the source (can be the same as the destination)
						char *pTerminate,			// the source termination characters
						Byte *rDest,				// the destination (can be the same as the source)
						SInt32 *rSize)				// the number of source bytes
{
	SixBit_DecodeBytes(pSource, pTerminate, cFromUU, rDest, rSize);
}

void WINAPI MSUU_DecodeBytes(							// ms uu decode a series of blocks
						const char *pSource,		// the source (can be the same as the destination)
						char *pTerminate,			// the source termination characters
						Byte *rDest,				// the destination (can be the same as the source)
						SInt32 *rSize)				// the number of source bytes
{
	SixBit_DecodeBytes(pSource, pTerminate, cFromMSUU, rDest, rSize);
}

void WINAPI SixBit_DecodeBytes(							// six bit decode a series of blocks
						const char *pSource,		// the source (can be the same as the destination)
						char * pUnused,			// the source termination characters
						const Byte *pFromTable,		// conversion table
						Byte *rDest,				// the destination (can be the same as the source)
						SInt32 *rSize)				// the number of source bytes
{
	SInt32			vLength;
	char			vRemainder[4];
	SInt32			vRemainderSize;
	SInt32			vSize;
	
	// find the offset of the first termination char
	
	//vLength = String_FindAnyChar(pSource, pTerminate) - pSource;
	vLength = strlen(pSource);
	
	// decode
	
	vRemainderSize = 0;
	SixBit_DecodeStream(
						(Byte*)vRemainder, // pRemainter
						&vRemainderSize, // pRemainderSize
						pSource,
						vLength,
						true, // pTerminate
						pFromTable,
						rDest,
						&vSize);
	
	// if there is a remainder
	
	if (vRemainderSize)
	{
		while (vRemainderSize < (int)sizeof(vRemainder))
			vRemainder[vRemainderSize++] = pFromTable[256];
		SixBit_DecodeStream(
							NULL, // pRemainter
							NULL, // pRemainderSize
							vRemainder,
							vRemainderSize,
							true, // pTerminate
							pFromTable,
							&rDest[vSize],
							NULL);
		vSize += 3;
	}
	
	if (rSize)
		*rSize = vSize;
#ifdef WIN32
	pUnused; // just to get rid of a compiler warning in a cross platform way
#else
	if (pUnused) ;
#endif
	return;
}

void WINAPI Base64_DecodeStream(						// base-64 decode a stream of bytes
						Byte *pRemainder,			// the remainder from a previous decode (returns any new remainder)
						SInt32 *pRemainderSize,		// the size of the remainder (returns new new remainder size)
						const char *pSource,		// the source
						SInt32 pSourceSize,			// the source size
						Boolean pTerminate,			// meaningless (for Base64_EncodeStream() compatibility)
						Byte *rDest,				// the destination
						SInt32 *rDestSize)			// returns the destination size
{
	SixBit_DecodeStream(pRemainder,
						pRemainderSize,
						pSource,
						pSourceSize,
						pTerminate,
						cFromBase64,
						rDest,
						rDestSize);
						
	return;
}

void WINAPI UU_DecodeStream(							// uu decode a stream of bytes
						Byte *pRemainder,			// the remainder from a previous decode (returns any new remainder)
						SInt32 *pRemainderSize,		// the size of the remainder (returns new new remainder size)
						const char *pSource,		// the source
						SInt32 pSourceSize,			// the source size
						Boolean pTerminate,			// meaningless (for Base64_EncodeStream() compatibility)
						Byte *rDest,				// the destination
						SInt32 *rDestSize)			// returns the destination size
{
	SixBit_DecodeStream(pRemainder,
						pRemainderSize,
						pSource,
						pSourceSize,
						pTerminate,
						cFromUU,
						rDest,
						rDestSize);
						
	return;
}

void WINAPI MSUU_DecodeStream(							// ms uu decode a stream of bytes
						Byte *pRemainder,			// the remainder from a previous decode (returns any new remainder)
						SInt32 *pRemainderSize,		// the size of the remainder (returns new new remainder size)
						const char *pSource,		// the source
						SInt32 pSourceSize,			// the source size
						Boolean pTerminate,			// meaningless (for Base64_EncodeStream() compatibility)
						Byte *rDest,				// the destination
						SInt32 *rDestSize)			// returns the destination size
{
	SixBit_DecodeStream(pRemainder,
						pRemainderSize,
						pSource,
						pSourceSize,
						pTerminate,
						cFromMSUU,
						rDest,
						rDestSize);
						
	return;
}

void WINAPI SixBit_DecodeStream(						// base-64 decode a stream of bytes
						Byte *pRemainder,			// the remainder from a previous decode (returns any new remainder)
						SInt32 *pRemainderSize,		// the size of the remainder (returns new new remainder size)
						const char *pSource,		// the source
						SInt32 pSourceSize,			// the source size
						Boolean bUnused,			// meaningless (for Base64_EncodeStream() compatibility)
						const Byte *pFromTable,		// conversion table
						Byte *rDest,				// the destination
						SInt32 *rDestSize)			// returns the destination size
{
	Byte			vTemp[4];
	Byte			*vRemainderBuffer;
	Byte			*vRemainder;
	SInt32			vRemainderSize;
	SInt32			vPaddingSize = 0;
	const char		*vSource;
	const char		*vSourceMax;
	Byte			*vDest;
	
	// init some handy variables
	{
		vRemainderBuffer = pRemainder ? pRemainder : vTemp;
		vRemainder = vRemainderBuffer;
		vRemainderSize = (pRemainderSize) ? *pRemainderSize : 0;
		vSource = pSource;
		vSourceMax = vSource + pSourceSize;
		vDest = rDest;
	}
	
	// convert the source
	
	while (true)
	{
		// copy data from the source to the remainder to create a full block
		
		while (vRemainderSize < 4)
		{
			Byte	vSourceBits;
			
			do
			{
				// break on end of source
				
				if (vSource >= vSourceMax)
					goto jEndOfSource;
					
				// get some bits
				
				vSourceBits = pFromTable[(Byte) *vSource++];
			}
			while (vSourceBits == 0xff);
			
			// if padding character
			
			if (vSourceBits == 0xfe)
			{
				vSourceBits = 0;
				vPaddingSize++;
			}
			
			// copy the bits to the remainder
			
			*vRemainder++ = vSourceBits;
			vRemainderSize++;
		}
			
		// squeeze the non-data bits from the block
		{
			vRemainder = vRemainderBuffer;
			vRemainderBuffer[0] = (vRemainderBuffer[0] << 2) | ((vRemainderBuffer[1] & 0x30) >> 4);
			vRemainderBuffer[1] = (vRemainderBuffer[1] << 4) | ((vRemainderBuffer[2] & 0x3c) >> 2);
			vRemainderBuffer[2] = (vRemainderBuffer[2] << 6) | (vRemainderBuffer[3] & 0x3f);
		}
		
		// copy the results into the destination buffer

		if (vPaddingSize == 0)
		{
			*vDest++ = *vRemainder++;
			*vDest++ = *vRemainder++;
			*vDest++ = *vRemainder++;
		}
		else // vPaddingSize > 0
		{
			*vDest++ = *vRemainder++;
			if (vPaddingSize == 1)
				*vDest++ = *vRemainder++;
			break;
		}
		
		// reset for the next loop
		
		vRemainder = vRemainderBuffer;
		vRemainderSize = 0;
	}
	jEndOfSource:
	
	// return the results
	
	if (pRemainderSize)
		*pRemainderSize = (vRemainderSize % 4);
	if (rDestSize)
		*rDestSize = (long) (vDest - rDest);
	
#ifdef WIN32
	bUnused; // just to get rid of a compiler warning in a cross platform way
#else
	if (bUnused) ;
#endif
	return;
}

void WINAPI Base64_EncodeStream(						// base-64 encode a stream of bytes
						Byte *pRemainder,			// the remainder from a previous encode (returns any new remainder)
						SInt32 *pRemainderSize,		// the size of the remainder (returns new new remainder size)
						const Byte *pSource,		// the source
						SInt32 pSourceSize,			// the source size
						Boolean pTerminate,			// terminate the stream
						char *rDest,				// the destination
						SInt32 *rDestSize)			// the destination size
{
	SixBit_EncodeStream(pRemainder,
						pRemainderSize,
						pSource,
						pSourceSize,
						pTerminate,
						cToBase64,
						rDest,
						rDestSize);
						
	return;
}

void WINAPI UU_EncodeStream(							// uu encode a stream of bytes
						Byte *pRemainder,			// the remainder from a previous encode (returns any new remainder)
						SInt32 *pRemainderSize,		// the size of the remainder (returns new new remainder size)
						const Byte *pSource,		// the source
						SInt32 pSourceSize,			// the source size
						Boolean pTerminate,			// terminate the stream
						char *rDest,				// the destination
						SInt32 *rDestSize)			// the destination size
{
	SixBit_EncodeStream(pRemainder,
						pRemainderSize,
						pSource,
						pSourceSize,
						pTerminate,
						cToUU,
						rDest,
						rDestSize);
						
	return;
}

void WINAPI MSUU_EncodeStream(							// ms uu encode a stream of bytes
						Byte *pRemainder,			// the remainder from a previous encode (returns any new remainder)
						SInt32 *pRemainderSize,		// the size of the remainder (returns new new remainder size)
						const Byte *pSource,		// the source
						SInt32 pSourceSize,			// the source size
						Boolean pTerminate,			// terminate the stream
						char *rDest,				// the destination
						SInt32 *rDestSize)			// the destination size
{
	SixBit_EncodeStream(pRemainder,
						pRemainderSize,
						pSource,
						pSourceSize,
						pTerminate,
						cToMSUU,
						rDest,
						rDestSize);
						
	return;
}

void WINAPI SixBit_EncodeStream(						// base-64 encode a stream of bytes
						Byte *pRemainder,			// the remainder from a previous encode (returns any new remainder)
						SInt32 *pRemainderSize,		// the size of the remainder (returns new new remainder size)
						const Byte *pSource,		// the source
						SInt32 pSourceSize,			// the source size
						Boolean pTerminate,			// terminate the stream
						const char *pToTable,		// conversion table
						char *rDest,				// the destination
						SInt32 *rDestSize)			// the destination size
{
	Byte			*vRemainder;
	SInt32			vRemainderSize;
	const Byte		*vSource;
	SInt32			vSourceSize;
	char			*vDest;
	Byte			vNewRemainder[3];
	SInt32			vNewRemainderSize;
	
	// init some handy variables
	{
		vRemainder = pRemainder;
		vRemainderSize = (pRemainderSize) ? *pRemainderSize : 0;
		vSource = pSource;
		vSourceSize = pSourceSize;
		vDest = rDest;
	}
	
	// first clean up for any remainder from a previous encode
	
	if (vRemainderSize)
	{
		// copy data from the source to the remainder to create a full block
		
		for (; vRemainderSize < 3 && vSourceSize > 0; vRemainderSize++, vSourceSize--)
			*vRemainder++ = *vSource++;
		vDest += 4;
	}
	
	// save any remainder from the encoding we are about to do
	
	if (!pTerminate)
	{
		vNewRemainderSize = vSourceSize % 3;
		vSourceSize -= vNewRemainderSize;
		*(UInt32 *) vNewRemainder = *(UInt32 *) (vSource + vSourceSize);
	}
	else // !pTerminate
		vNewRemainderSize = 0;
	
	// if there are enough source bytes left to make full blocks
	
	if (vSourceSize > 0)
		SixBit_EncodeBytes(vSource, vSourceSize, pToTable, vDest, NULL);
		
	// if there is an old remainder to convert
	
	if (vRemainderSize)
		SixBit_EncodeBytes(pRemainder, 3, pToTable, vDest - 4, NULL);
		
	// save the new remainder

	if (pRemainder)
		for (*pRemainderSize = vNewRemainderSize--; vNewRemainderSize >= 0; vNewRemainderSize--)
			pRemainder[vNewRemainderSize] = vNewRemainder[vNewRemainderSize];
		
	// return the number of bytes transferred
	
	if (rDestSize)
		*rDestSize = ((2 + (vRemainderSize + vSourceSize)) / 3) * 4;
		
	return;
}

void WINAPI Base64_EncodeBytes(							// base-64 encode a series of blocks
						const Byte *pSource,		// the source (can be the same as the destination)
						SInt32 pSourceSize,			// the number of source bytes
						char *rDest,				// the destination (can be the same as the source)
						SInt32 *rDestSize)			// returns the dest size
{
	SixBit_EncodeBytes(pSource, pSourceSize, cToBase64, rDest, rDestSize);
	
	return;
}

void WINAPI UU_EncodeBytes(								// uu encode a series of blocks
						const Byte *pSource,		// the source (can be the same as the destination)
						SInt32 pSourceSize,			// the number of source bytes
						char *rDest,				// the destination (can be the same as the source)
						SInt32 *rDestSize)			// returns the dest size
{
	SixBit_EncodeBytes(pSource, pSourceSize, cToUU, rDest, rDestSize);
	
	return;
}

void WINAPI MSUU_EncodeBytes(							// ms uu encode a series of blocks
						const Byte *pSource,		// the source (can be the same as the destination)
						SInt32 pSourceSize,			// the number of source bytes
						char *rDest,				// the destination (can be the same as the source)
						SInt32 *rDestSize)			// returns the dest size
{
	SixBit_EncodeBytes(pSource, pSourceSize, cToMSUU, rDest, rDestSize);
	
	return;
}

void WINAPI SixBit_EncodeBytes(							// six bit encode a series of blocks
						const Byte *pSource,		// the source (can be the same as the destination)
						SInt32 pSourceSize,			// the number of source bytes
						const char *pToTable,		// conversion table
						char *rDest,				// the destination (can be the same as the source)
						SInt32 *rDestSize)			// returns the dest size
{
	SInt32			vPartBlockSize;
	SInt32			vWholeBlockSize;
	SInt32			vWholeBlockCount;
	char			*vDest;
	SInt32			vDestSize;
	const Byte		*vSource;
	Byte			vTemp[4];
	
	vDestSize = ((pSourceSize + 2) / 3) * 4;
	
	if (rDestSize)
		*rDestSize = vDestSize;
		
	// init some convenient variables
	{
		vPartBlockSize = pSourceSize % 3;
		vWholeBlockSize = pSourceSize - vPartBlockSize;
		vWholeBlockCount = vWholeBlockSize / 3;
		vSource = pSource + vWholeBlockSize;
		vDest = rDest + vWholeBlockCount * 4;
	}
	
	// do a partial block at the end first in case the source and dest are the same
	
	if (vPartBlockSize)
	{
		// make copy of the data with non-significant bytes nulled out
		{
			*(UInt32 *) vTemp = *(UInt32 *) vSource;
			vTemp[2] = 0;
			if (vPartBlockSize == 1)
				vTemp[1] = 0;
		}
			
		// encode it and replace non-significant bytes with padding
		
		SixBit_EncodeBytes(vTemp, 3, pToTable, vDest, NULL);
		vDest[3] = pToTable[64];
		if (vPartBlockSize == 1)
			vDest[2] = pToTable[64];
	}
	
	// now do the whole blocks (we start at the end in case the source and dest are the same)
	
	while (vSource > pSource)
	{
		// decrement the pointers
		
		vSource -= 3;
		vDest -= 4;

		// encode the block (put it into a temp buffer first in case we are encoding in place)
		
		vTemp[0] = pToTable[vSource[0] >> 2];
		vTemp[1] = pToTable[((vSource[0] & 0x03) << 4) | (vSource[1] >> 4)];
		vTemp[2] = pToTable[((vSource[1] & 0x0f) << 2) | ((vSource[2] & 0xc0) >> 6)];
		vTemp[3] = pToTable[vSource[2] & 0x3f];
		
		// copy the block into place
		
		*(UInt32 *) vDest = *(UInt32 *) vTemp;
	}
	
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\digest\base64_old.cpp ===
///////////////////////////////////////////////////////////////////////
// This file is obselected
// See current version of Base64.cpp
///////////////////////////////////////////////////////////////////////

/*++

    Copyright (c) 1998 Microsoft Corporation

    Module Name:

        Base64.cpp

    Abstract:

        Base64 encode/decode functions.

    Author:

        Darren L. Anderson (darrenan) 6-Aug-1998

    Revision History:

        6-Aug-1998 darrenan

            Created.

--*/

#include "precomp.h"
#include <malloc.h>

CHAR    g_achBase64EncodeTable[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
BYTE    g_achBase64DecodeTable[] = 
{
    0x3E,0xFF,0xFF,0xFF,0x3F,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0xFF,
    0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,
    0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,
    0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0x20,0x21,0x22,0x23,
    0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,0x30,0x31,0x32,0x33
};

HRESULT WINAPI
Base64DecodeW(
    LPCWSTR pszSrc,
    ULONG   ulSrcSize,
    LPBYTE  pDst
    )

/*++

Routine Description:

    Base64Decode    This method decodes a Base-64 encoded chunk of binary data.

Arguments:

    pszSrc      Points to Base64-encoded string to decode.

    ulSrcSize   Length of the string pointed to by pszSrc, not including 
                terminating null character.

    pDst        Buffer to copy the decoded binary data into.  The size of this
                buffer must be ((pszSrc / 4) + 1) * 3

Return Value:

     0 - Decode was successful.

--*/

{
    LPSTR pszABuf = (LPSTR)alloca(ulSrcSize);

    WideCharToMultiByte(CP_ACP, 0, pszSrc, ulSrcSize, pszABuf, ulSrcSize, NULL, NULL);

    return Base64DecodeA(pszABuf, ulSrcSize, pDst);
}

HRESULT WINAPI
Base64DecodeA(
    LPCSTR  pszSrc,
    ULONG   ulSrcSize,
    LPBYTE  pDst
    )

/*++

Routine Description:

    Base64Decode    This method decodes a Base-64 encoded chunk of binary data.

Arguments:

    pszSrc      Points to Base64-encoded string to decode.

    ulSrcSize   Length of the string pointed to by pszSrc, not including 
                terminating null character.

    pDst        Buffer to copy the decoded binary data into.  The size of this
                buffer must be ((pszSrc / 4) + 1) * 3

Return Value:

     0 - Decode was successful.

--*/

{
    ULONG   ulIndex;
    ULONG   ulCurOut;
    DWORD   dwGroup;
    DWORD   dwCur;
    CHAR    chCur;

    dwGroup  = 0;
    ulCurOut = 0;

    if(ulSrcSize % 4 != 0)
        return E_FAIL;

    for(ulIndex = 0; ulIndex < ulSrcSize; ulIndex++)
    {
        chCur = pszSrc[ulIndex];
        dwCur = g_achBase64DecodeTable[chCur - '+'];

        _ASSERT(dwCur != 0xFF);

        dwGroup |= (dwCur << (6 * (ulIndex & 0x3)));

        if((ulIndex & 0x3) == 0x3)
        {
            pDst[ulCurOut++] = (CHAR)( dwGroup        & 0xff);
            pDst[ulCurOut++] = (CHAR)((dwGroup >>  8) & 0xff);
            pDst[ulCurOut++] = (CHAR)((dwGroup >> 16) & 0xff);

            dwGroup = 0;
        }
    }

    pDst[ulCurOut] = 0;

    return S_OK;
}

HRESULT WINAPI
Base64EncodeW(
    const LPBYTE    pSrc,
    ULONG           ulSrcSize,
    LPWSTR          pszDst
    )

/*++

Routine Description:

    Base64Encode    This method converts a buffer of arbitrary binary data into
                    a Base-64 encoded string.

Arguments:

    pSrc        Points to the buffer of bytes to encode.

    ulSrcSize   Number of bytes in pSrc to encode.

    pszDst      Buffer to copy the encoded output into.  The length of the buffer
                must be (((ulSrcSize / 3) + 1) * 4) + 1.

Return Value:

     0 - Encoding successful.

--*/

{
    HRESULT hr;
    ULONG   ulBufLen = (((ulSrcSize / 3) + 1) * 4) + 1;
    LPSTR   pszABuf = (LPSTR)alloca(ulBufLen);
    int     nResult;

    hr = Base64EncodeA(pSrc, ulSrcSize, pszABuf);
    if(hr != S_OK)
        goto Cleanup;

    nResult = MultiByteToWideChar(CP_ACP, 0, pszABuf, ulBufLen, pszDst, ulBufLen);
    pszDst[nResult] = 0;

Cleanup:

    return hr;
}

HRESULT WINAPI
Base64EncodeA(
    const LPBYTE    pSrc,
    ULONG           ulSrcSize,
    LPSTR           pszDst
    )

/*++

Routine Description:

    Base64Encode    This method converts a buffer of arbitrary binary data into
                    a Base-64 encoded string.

Arguments:

    pSrc        Points to the buffer of bytes to encode.

    ulSrcSize   Number of bytes in pSrc to encode.

    pszDst      Buffer to copy the encoded output into.  The length of the buffer
                must be (((ulSrcSize / 3) + 1) * 4) + 1.

Return Value:

     0 - Encoding successful.

--*/

{
    DWORD   dwGroup;
    ULONG   ulCurGroup = 0, ulIndex;

    for(ulIndex = 0; ulIndex < (ulSrcSize - (ulSrcSize % 3)); ulIndex += 3)
    {
        dwGroup = pSrc[ulIndex+2] | (pSrc[ulIndex+1] << 8) | (pSrc[ulIndex] << 16);

        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 18) & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 12) & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 6)  & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[  dwGroup        & 0x3f ];
    }

    //  Do the end special case.
    switch(ulSrcSize % 3)
    {
    case 2:
        dwGroup = (pSrc[ulIndex+1]  << 8)| (pSrc[ulIndex] << 16);

        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 18) & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 12) & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 6)  & 0x3f ];
        pszDst[ulCurGroup++] = '=';

        break;

    case 1:
        dwGroup = pSrc[ulIndex] << 16;

        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 18)  & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 12)  & 0x3f ];
        pszDst[ulCurGroup++] = '=';
        pszDst[ulCurGroup++] = '=';

        break;
    }

    //  Null terminate the string.
    pszDst[ulCurGroup] = 0; 
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\lkrhash\dllmain.cpp ===
// DllMain

#include <precomp.hxx>

#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT
#include <irtldbg.h>
#include <lkrhash.h>
#include "_locks.h"


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID /*lpReserved*/)
{
    BOOL  fReturn = TRUE;  // ok
    
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hInstance);
        Locks_Initialize();
        IRTL_DEBUG_INIT();
        IRTLTRACE(_T("LKRhash::DllMain::DLL_PROCESS_ATTACH\n"));
        fReturn = LKRHashTableInit();
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        IRTLTRACE(_T("LKRhash::DllMain::DLL_PROCESS_DETACH\n"));
        LKRHashTableUninit();
        IRTL_DEBUG_TERM();
        Locks_Cleanup();
    }

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\crypt\validatekeylog\validatekeylog.cpp ===
#include <windows.h>
#include <vector>
#include <stdio.h>
#include "des.h"
#include "tripldes.h"
#include "modes.h"

using namespace std;

void
Usage()
{
    printf("Missing file name!");
    exit(0);
}

LPSTR apszOps[] = 
{
    "MAC",
    "ENCRYPT KEY",
    "ENCRYPT IN",
    "ENCRYPT OUT",
    "DECRYPT KEY",
    "DECRYPT IN",
    "DECRYPT OUT",
    NULL
};
     
typedef enum { CRYPT_OP_ENCRYPT, CRYPT_OP_DECRYPT } CRYPT_OP;

typedef struct
{
    CRYPT_OP    op;
    BYTE        achInput[32];
    BYTE        achOutput[32];
    DES3TABLE   key;
}
CRYPT_OP_LOG_ENTRY;

typedef struct
{
    CHAR        achMac[6];
}
MAC_ADDRESS;

vector<CRYPT_OP_LOG_ENTRY> encryptLog;
vector<CRYPT_OP_LOG_ENTRY> decryptLog;
vector<MAC_ADDRESS> macLog;

#define CHARTONUM(a) ((a >= '0' && a <= '9') ? (a - '0') : (a - 'A' + 10))

BYTE
AsciiByteToByte(
    LPCSTR  pszAsciiByte
    )
{
    return (BYTE)((CHARTONUM(pszAsciiByte[0]) << 4) + CHARTONUM(pszAsciiByte[1]));
}

int
HexStringToBinary(
    LPCSTR  pszHexString,
    LPBYTE  lpBuffer
    )
{
    int     i;
    
    if(!pszHexString)
        return -1;
    
    for(i = 0; pszHexString[i << 1]; i++)
    {
        lpBuffer[i] = AsciiByteToByte(&(pszHexString[i << 1]));
        if(!pszHexString[(i << 1) + 1])
            break;
    }

    return 0;
}

int
GetLineOp(
    LPSTR   pszLine
    )
{
    int i;

    for(i = 0; apszOps[i]; i++)
    {
        if(strncmp(apszOps[i], pszLine, lstrlen(apszOps[i])) == 0)
            return i;
    }

    return -1;
}

//  Return a line from the file, not including carriage return or line feed chars,
//  null terminated.
int ReadLine(
    HANDLE  hFile,
    LPSTR   pszBuf,
    ULONG   ulBufLen
    )
{
    DWORD   dwBytesRead;
    LPSTR   pszCur;
    DWORD   dwTotalBytesRead = 0;
    CHAR    chCur;
    int     nResult;

    if(!pszBuf)
        return -1;

    pszCur = pszBuf;

    do
    {
        nResult = ReadFile(hFile, &chCur, 1, &dwBytesRead, NULL);
        if(!nResult)
            return -1;

        //  EOF?
        if(!dwBytesRead)
            return -1;

        dwTotalBytesRead += dwBytesRead;
        if(chCur != '\r' && chCur != '\n')
            *(pszCur++) = chCur;
        else
        {
            *(pszCur++) = '\0';
            break;
        }
    }
    while(dwBytesRead && dwTotalBytesRead <= ulBufLen);

    do
    {
        nResult = ReadFile(hFile, &chCur, 1, &dwBytesRead, NULL);
        if(!nResult)
            return -1;
        // EOF?
        if(!dwBytesRead)
            return -1;
    }
    while(chCur == '\r' || chCur == '\n');

    SetFilePointer(hFile, -1, NULL, FILE_CURRENT);

    return 0;
}

int
LoadLogFile(
    LPSTR   pszLogFile
    )
{
    HANDLE  hFile;
    CHAR    achBuf[2048];
    LPSTR   pszBinStart;
    int     nEqualLen = lstrlenA(" = ");

    hFile = CreateFile(pszLogFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if(hFile == INVALID_HANDLE_VALUE)
        return -1;

    while(ReadLine(hFile, achBuf, sizeof(achBuf)) == 0)
    {
        switch(GetLineOp(achBuf))
        {
        case 0: // MAC
            {
                MAC_ADDRESS macAddress;
                vector<MAC_ADDRESS>::iterator it;

                pszBinStart = strstr(achBuf, " = ");
                if(pszBinStart)
                    pszBinStart += nEqualLen;

                HexStringToBinary(pszBinStart, (LPBYTE)&macAddress);

                for(it = macLog.begin() ; it != macLog.end(); it++)
                {
                    if(memcmp(&macAddress, &(*it), sizeof(MAC_ADDRESS)) == 0)
                        break;
                }

                if(it == macLog.end())
                {
                    macLog.push_back(macAddress);
                }
            }
            break;

        case 1: // ENCRYPT KEY
            {
                CRYPT_OP_LOG_ENTRY logEntry;
                vector<CRYPT_OP_LOG_ENTRY>::iterator it;

                ZeroMemory(&logEntry, sizeof(CRYPT_OP_LOG_ENTRY));

                logEntry.op = CRYPT_OP_ENCRYPT;

                pszBinStart = strstr(achBuf, " = ");
                if(pszBinStart)
                    pszBinStart += nEqualLen;

                HexStringToBinary(pszBinStart, (LPBYTE)&logEntry.key);

                ReadLine(hFile, achBuf, sizeof(achBuf));

                pszBinStart = strstr(achBuf, " = ");
                if(pszBinStart)
                    pszBinStart += nEqualLen;

                HexStringToBinary(pszBinStart, (LPBYTE)&logEntry.achInput);

                ReadLine(hFile, achBuf, sizeof(achBuf));

                pszBinStart = strstr(achBuf, " = ");
                if(pszBinStart)
                    pszBinStart += nEqualLen;

                HexStringToBinary(pszBinStart, (LPBYTE)&logEntry.achOutput);

                for(it = encryptLog.begin(); it != encryptLog.end(); it++)
                {
                    if(memcmp(&logEntry, &(*it), sizeof(CRYPT_OP_LOG_ENTRY)) == 0)
                        break;
                }

                if(it == encryptLog.end())
                    encryptLog.push_back(logEntry);
            }
            break;

        case 4: // DECRYPT KEY
            {
                CRYPT_OP_LOG_ENTRY logEntry;
                vector<CRYPT_OP_LOG_ENTRY>::iterator it;

                ZeroMemory(&logEntry, sizeof(CRYPT_OP_LOG_ENTRY));

                logEntry.op = CRYPT_OP_DECRYPT;

                pszBinStart = strstr(achBuf, " = ");
                if(pszBinStart)
                    pszBinStart += nEqualLen;

                HexStringToBinary(pszBinStart, (LPBYTE)&logEntry.key);

                ReadLine(hFile, achBuf, sizeof(achBuf));

                pszBinStart = strstr(achBuf, " = ");
                if(pszBinStart)
                    pszBinStart += nEqualLen;

                HexStringToBinary(pszBinStart, (LPBYTE)&logEntry.achInput);

                ReadLine(hFile, achBuf, sizeof(achBuf));

                pszBinStart = strstr(achBuf, " = ");
                if(pszBinStart)
                    pszBinStart += nEqualLen;

                HexStringToBinary(pszBinStart, (LPBYTE)&logEntry.achOutput);

                for(it = decryptLog.begin(); it != decryptLog.end(); it++)
                {
                    if(memcmp(&logEntry, &(*it), sizeof(CRYPT_OP_LOG_ENTRY)) == 0)
                        break;
                }

                if(it == decryptLog.end())
                    decryptLog.push_back(logEntry);
            }
            break;

        default: //  Anything else is an error, ignore it.
            continue;
        }

    }

    return 0;
}

#define NUM2CHAR(n) ((n < 0xA) ? ('0' + n) : 'A' + (n - 10))
void
PrintByte(
    BYTE    b
    )
{
    CHAR    achBuf[3];
    BYTE    bLow, bHigh;

    bLow = b & 0xF;
    bHigh = (b >> 4) & 0xF;

    achBuf[0] = NUM2CHAR(bHigh);
    achBuf[1] = NUM2CHAR(bLow);
    achBuf[2] = 0;

    printf(achBuf);
}

void
PrintBlob(
    LPBYTE  lpBlob,
    DWORD   dwSizeofBlob
    )
{
    DWORD   dwCur;

    for(dwCur = 0; dwCur < dwSizeofBlob; dwCur++)
    {
        PrintByte(lpBlob[dwCur]);
    }
}


void
PrintLog(
    CRYPT_OP_LOG_ENTRY logEntry
    )
{
    printf("\tKey = ");
    PrintBlob((LPBYTE)&logEntry.key, sizeof(DES3TABLE));
    printf("\n\tInput = ");
    PrintBlob((LPBYTE)&logEntry.achInput, 32);
    printf("\n\tOutput = ");
    PrintBlob((LPBYTE)&logEntry.achOutput, 32);
    printf("\n\n");
}

bool
ValidateLogFile()
{
    vector<CRYPT_OP_LOG_ENTRY>::iterator it_decrypt, it_encrypt;

    //  If more than one MAC address were used, print out a message.
    if(macLog.size() > 1)
        printf("Multiple MAC addresses were used for encryption during this run.\n");

    //  Now loop through decryption log.  For each item, there should be a corresponding
    //  entry in the encryption log where decrypt.in == encrypt.out and vice versa.
    for(it_decrypt = decryptLog.begin(); it_decrypt != decryptLog.end(); it_decrypt++)
    {
        for(it_encrypt = encryptLog.begin(); it_encrypt != encryptLog.end(); it_encrypt++)
        {
            if(memcmp(&((*it_decrypt).achInput), &((*it_encrypt).achOutput), 32) == 0 &&
               memcmp(&((*it_decrypt).achOutput), &((*it_encrypt).achInput), 32) == 0)
               break;
        }

        if(it_encrypt == encryptLog.end())
        {
            printf("Found a decryption entry w/o a matching encryption entry:\n");
            PrintLog(*it_decrypt);
        }
    }
    
    return true;
}


int main(
    int argc,
    char** argv
    )
{
    LPSTR pszLogFile;

    if(argc !=2)
        Usage();

    pszLogFile = argv[1];

    LoadLogFile(pszLogFile);

    ValidateLogFile();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\digest\precomp.h ===
/*++

    Copyright (c) 1998 Microsoft Corporation

    Module Name:

        precomp.h

    Abstract:

        All pre-compiled headers included here.

    Author:

        Darren L. Anderson (darrenan) 6-Aug-1998

    Revision History:

        6-Aug-1998 darrenan

            Created.

--*/

#ifndef _PRECOMP_H
#define _PRECOMP_H

#ifndef STRICT
#define STRICT
#endif

#define _ATL_APARTMENT_THREADED


#include <windows.h>
#include <crtdbg.h>

#include "digest.h"
#include "md5.h"

#endif // !defined(_PRECOMP_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\digest\digest.cpp ===
/*++

    Copyright (c) 1998 Microsoft Corporation

    Module Name:

        DigestAuth.cpp

    Abstract:

        Performs digest authentication MD5 calculations.
        MD5.cpp is an external dependency.

    Author:

        Darren L. Anderson (darrenan) 5-Aug-1998

    Revision History:

        5-Aug-1998 darrenan

            Created.

--*/

#include "precomp.h"
#include <malloc.h>
#include <time.h>
#include "pperr.h"
#include "binhex.h"

typedef enum { ALGO_MD5, ALGO_MD5_SESS } DIGEST_ALGORITHM;
typedef enum { QOP_NONE, QOP_AUTH, QOP_AUTH_INT } DIGEST_QOP;

DIGEST_ALGORITHM WINAPI
AlgorithmFromString(
    LPCSTR  pszAlgorithm
    )
{
    DIGEST_ALGORITHM Algorithm;

    if(pszAlgorithm == NULL)
        Algorithm = ALGO_MD5;
    else if(_stricmp("MD5-sess", pszAlgorithm) == 0)
        Algorithm = ALGO_MD5_SESS;
    else if(_stricmp("MD5", pszAlgorithm) == 0)
        Algorithm = ALGO_MD5;
    else
        Algorithm = ALGO_MD5;

    return Algorithm;
}

DIGEST_QOP WINAPI
QopFromString(
    LPCSTR  pszQOP
    )
{
    DIGEST_QOP  Qop;

    if(pszQOP == NULL)
        Qop = QOP_NONE;
    else if(strcmp("auth", pszQOP) == 0)
        Qop = QOP_AUTH;
    else if(strcmp("auth-int", pszQOP) == 0)
        Qop = QOP_AUTH_INT;
    else
        Qop = QOP_NONE;

    return Qop;
}

VOID WINAPI
ToHex(
    LPBYTE pSrc,
    UINT   cSrc,
    LPSTR  pDst
    )

/*++

Routine Description:

    Convert binary data to ASCII hex representation

Arguments:

    pSrc - binary data to convert
    cSrc - length of binary data
    pDst - buffer receiving ASCII representation of pSrc

Return Value:

    Nothing

--*/

{
#define TOHEX(a) ((a)>=10 ? 'a'+(a)-10 : '0'+(a))

    for ( UINT x = 0, y = 0 ; x < cSrc ; ++x )
    {
        UINT v;
        v = pSrc[x]>>4;
        pDst[y++] = TOHEX( v );
        v = pSrc[x]&0x0f;
        pDst[y++] = TOHEX( v );
    }
    pDst[y] = '\0';
}

LONG MD5(UCHAR* pBuf, UINT nBuf, UCHAR* digest)
{
    MD5_CTX context;

    if(pBuf==NULL || IsBadReadPtr((CONST VOID*)pBuf, (UINT)nBuf))
    {
        return ERROR_INVALID_PARAMETER;
    }

    MD5Init (&context);
    MD5Update (&context, pBuf, nBuf);
    MD5Final (&context);

    memcpy(digest, context.digest, 16);

    return ERROR_SUCCESS;
}

HRESULT WINAPI
DigestFromCreds(
    IN  LPCSTR  pszAlgorithm,
    IN  LPCSTR  pszUsername,
    IN  LPCSTR  pszRealm,
    IN  LPCSTR  pszPassword,
    IN  LPCSTR  pszNonce,
    IN  LPCSTR  pszNonceCount,
    IN  LPCSTR  pszCNonce,
    IN  LPCSTR  pszQOP,
    IN  LPCSTR  pszMethod,
    IN  LPCSTR  pszURI,
    IN  LPCSTR  pszEntityDigest,
    OUT LPSTR   pszSessionKey,
    OUT LPSTR   pszResult
    )

/*++

Routine Description:

    DigestFromCreds         Produces a hexadecimally encoded string containing the
                            Digest response given the arguments below.

Arguments:

    pszAlgorithm            The algorithm being used to calculate the response.
                            If NULL or "", assume "MD5".  Possible values are
                            "MD5" and "MD5-Sess".

    pszUsername             Member's passport ID.

    pszRealm                Realm, should be constant.
    
    pszPassword             Member's password.

    pszNonce                Nonce.    
    
    pszNonceCount           The Nonce Count.  MUST be NULL if pszQOP is NULL or "".
                            Otherwise, Nonce Count is REQUIRED.

    pszCNonce               The Client nonce.  May be NULL or "".
    
    pszQOP                  The Quality of Privacy.  May be NULL, "", "auth" or 
                            "auth-int".  If it's NULL or "" then RFC 2069 style
                            digest is being performed.

    pszMethod               HTTP method used in the request.  REQUIRED.

    pszURI                  Resource being requested.  REQUIRED.

    pszEntityDigest         Entity Digest.  May be NULL if qop="auth" or nothing.
                            REQUIRED if qop="auth-int".

    pszSessionKey           Session key returned to caller.  Session key is MD5(A1).

    pszResult               Destination buffer for result.  Should point to a buffer
                            of at least MIN_OUTPUT_BUF_LEN characters.
    
Return Value:

    S_OK                    Call was successful.


--*/

{
    HRESULT             hr;
    DIGEST_ALGORITHM    Algorithm;
    DIGEST_QOP          Qop;
    CHAR                achWork     [512];
    UCHAR               achDigest   [ 16];
    CHAR                achHashOfA1 [DIGESTBUF_LEN];

    //
    //  Detect the algorithm and QOP.
    //

    Algorithm = AlgorithmFromString(pszAlgorithm);
    Qop       = QopFromString(pszQOP);

    //  Compute the digest.

    //
    //  Build A1.
    //  For MD5 this is username@domain:realm:password
    //  For MD5-Sess this is MD5(username@domain:realm:password):nonce:cnonce
    //

    strcpy(achWork, pszUsername);
    strcat(achWork, ":");
    strcat(achWork, pszRealm);
    strcat(achWork, ":");
    strcat(achWork, pszPassword);

    if(Algorithm == ALGO_MD5_SESS)
    {
        //  Hash it.
        MD5((UCHAR*)achWork, strlen(achWork), achDigest);
        ToHex(achDigest, 16, achHashOfA1);

        strcpy(achWork, achHashOfA1);
        strcat(achWork, ":");
        strcat(achWork, pszNonce);
        strcat(achWork, ":");
        strcat(achWork, pszCNonce);
    }

    //  Hash it.
    MD5((UCHAR*)achWork, strlen(achWork), achDigest);
    ToHex(achDigest, 16, achHashOfA1);
    
    hr = DigestFromKey(
                pszAlgorithm,
                achHashOfA1,
                pszNonce,
                pszNonceCount,
                pszCNonce,
                pszQOP,
                pszMethod,
                pszURI,
                pszEntityDigest,
                pszResult
                );

    if(hr != S_OK)
        goto Cleanup;

    strcpy(pszSessionKey, achHashOfA1);

Cleanup:
    return hr;
}


HRESULT WINAPI
DigestFromKey(
    IN  LPCSTR  pszAlgorithm,
    IN  LPCSTR  pszSessionKey,
    IN  LPCSTR  pszNonce,
    IN  LPCSTR  pszNonceCount,
    IN  LPCSTR  pszCNonce,
    IN  LPCSTR  pszQOP,
    IN  LPCSTR  pszMethod,
    IN  LPCSTR  pszURI,
    IN  LPCSTR  pszEntityDigest,
    OUT LPSTR   pszResult
    )

/*++

Routine Description:

    DigestFromCreds         Produces a hexadecimally encoded string containing the
                            Digest response given the arguments below.

Arguments:

    pszAlgorithm            The algorithm being used to calculate the response.
                            If NULL or "", assume "MD5".  Possible values are
                            "MD5" and "MD5-Sess".

    pszSessionKey           Pre-computed MD5(A1).

    pszNonce                Nonce.    
    
    pszNonceCount           The Nonce Count.  MUST be NULL if pszQOP is NULL or "".
                            Otherwise, Nonce Count is REQUIRED.

    pszCNonce               The Client nonce.  May be NULL or "".
    
    pszQOP                  The Quality of Privacy.  May be NULL, "", "auth" or 
                            "auth-int".  If it's NULL or "" then RFC 2069 style
                            digest is being performed.

    pszMethod               HTTP method used in the request.  REQUIRED.

    pszURI                  Resource being requested.  REQUIRED.

    pszEntityDigest         Entity Digest.  May be NULL if qop="auth" or nothing.
                            REQUIRED if qop="auth-int".

    pszResult               Destination buffer for result.  Should point to a buffer
                            of at least MIN_OUTPUT_BUF_LEN characters.
    
Return Value:

    S_OK                    Call was successful.
    E_POINTER               A required parameter was NULL.

--*/

{
    HRESULT             hr;
    DIGEST_ALGORITHM    Algorithm;
    DIGEST_QOP          Qop;
    CHAR                achWork     [512];
    UCHAR               achDigest   [ 16];
    CHAR                achHashOut  [ 36];

    //
    //  Detect the algorithm and QOP.
    //

    Algorithm = AlgorithmFromString(pszAlgorithm);
    Qop       = QopFromString(pszQOP);

    //  Compute the digest.

    //
    //  Build A2
    //  For qop="auth" this is method:uri
    //  For qop="auth-int" this is method:uri:entitydigest
    //

    strcpy(achWork, pszMethod);
    strcat(achWork, ":");
    strcat(achWork, pszURI);

    if(Qop == QOP_AUTH_INT)
    {
        strcat(achWork, ":");
        strcat(achWork, pszEntityDigest);
    }

    //  Hash it.
    MD5((UCHAR*)achWork, strlen(achWork), achDigest);
    ToHex(achDigest, 16, achHashOut);

    //
    //  Compute final chunk.
    //  For qop="" this is MD5(key:nonce:MD5(A2))
    //  For qop="auth" or qop="auth-int" this is 
    //      MD5(key:nonce:nc:cnonce:qop:MD5(A2))
    //

    strcpy(achWork, pszSessionKey);
    strcat(achWork, ":");
    strcat(achWork, pszNonce);
    strcat(achWork, ":");

    if(Qop != QOP_NONE)
    {
        strcat(achWork, pszNonceCount);
        strcat(achWork, ":");
        strcat(achWork, pszCNonce);
        strcat(achWork, ":");
        strcat(achWork, pszQOP);
        strcat(achWork, ":");
    }
     
    strcat(achWork, achHashOut);
    
    //  Hash it.
    MD5((UCHAR*)achWork, strlen(achWork), achDigest);
    ToHex(achDigest, 16, pszResult);

    hr = S_OK;

    return hr;
}


static const unsigned char g_kPK[] = "Opcutla$14chowx Tcolino!";
////////////////////////////////////////////////////////////////////
// Generate a time base nonce for digest
//
// IN BYTE *pSrcStr -- Input string should be current time
// IN long lSrcSize -- Input string size (does not need to be 0 termainate)
// OUT BYTE *pDestStr -- Return string buffer.
// IN/OUT long *lDestSize -- Input size of return dest buffer
//                           Return string size.
//
// Encode buffer size should be >= (((lSrcSize / 3) + 1) * 4) + 1)
// Decode buffer size should be >= (((lSrcSize / 4) + 1) * 3)
/////////////////////////////////////////////////////////////////////
HRESULT WINAPI GenerateNonce(BYTE *pSrcStr, long lSrcSize, 
                          BYTE *pDestStr, long *lDestSize)
{
    HRESULT hr = E_FAIL; 
    long    len;
    long    bufsz;
    BYTE    digest[17];
    BYTE    buf[125];
    BYTE    *tb = (BYTE*)alloca(lSrcSize + 18);
    CBinHex binHexIt;
    BSTR    bstrNonce = NULL;
    WCHAR   *lpwsz;

    if(!pSrcStr || !pDestStr || lSrcSize < 1)
        goto exit;

    memset(digest, 0, sizeof(digest));
    memcpy(tb, pSrcStr, lSrcSize);

    // use ':' to separate the input str from the pk.
    tb[lSrcSize] = ':'; 
    memcpy(buf, pSrcStr, lSrcSize);
    memcpy(buf + lSrcSize, g_kPK, sizeof(g_kPK));
    len = lSrcSize + sizeof(g_kPK);

    //digest form MD5() is always 16 byte long
    MD5(buf, len, digest);
    memcpy(tb + lSrcSize + 1, digest, 16);

    len = lSrcSize + 17;
    bufsz = sizeof(buf);

    // encode it all to make nonce - returns an allocated BSTR
    // so make sure at the end of function to free it.
    hr = binHexIt.ToBase64( (LPVOID)tb, len, 0, NULL, &bstrNonce);
    if (FAILED(hr))
    {
        goto exit;
    }

    bufsz = SysStringLen(bstrNonce);
    if (bufsz >= *lDestSize) // must be room for str + null
    {
        *lDestSize = 0;
        hr = E_INVALIDARG;
        goto exit;
    }

    *lDestSize = bufsz;
    // convert ascii string in BSTR to char string
    lpwsz = bstrNonce;
    for (;bufsz > 0; bufsz--)
    {
        *pDestStr++ = (BYTE) *lpwsz++;     // lpcwsz must be true ASCII) !!
    }
    *pDestStr = 0;
    hr = S_OK;

exit:
    SysFreeString(bstrNonce);
    return hr;
}


//////////////////////////////////////////////////////////////////
// Check if the nonce match
//
// IN BYTE *pNonce -- input string(Nonce) to be check
// IN long lSrcSize -- input string size.
// IN long lTimeoutWindow -- maximum time the nonce is valid
// IN long lCurTime -- compare the current session time with nonce.
//
// Encode buffer size should be >= (((lSrcSize / 3) + 1) * 4) + 1)
// Decode buffer size should be >= (((lSrcSize / 4) + 1) * 3)
//////////////////////////////////////////////////////////////////
HRESULT WINAPI CheckNonce(BYTE *pNonce, long lSrcSize, 
                          long lTimeoutWindow, long lCurTime)
{
    long    bufsz = (((lSrcSize / 4) + 1) * 3);
    long    len = (((lSrcSize / 3) + 1) * 4) + 2;
    BYTE    *buf = (BYTE*)alloca(bufsz);
    BYTE    *digest = (BYTE*)alloca(len);
    long    dlen = len;
    CBinHex binHexIt;
    HRESULT hr;

    if(!pNonce || lSrcSize < 1)
        return E_FAIL;

    pNonce[lSrcSize] = '\0'; //make it 0 terminate
    // decode nonce
    hr = binHexIt.PartFromBase64((LPSTR)pNonce, (LPBYTE)buf, (ULONG *)&bufsz);
    if(FAILED(hr))
    {
        return hr;
    }
    buf[bufsz] = '\0';

    BYTE *end = (BYTE*)strchr((const char*)buf, ':');
    if(!end)
        return PP_E_DIGEST_NONCE_MISSMATCH;

    len = (long) (end - buf);

    if(FAILED(GenerateNonce(buf, len, digest, &dlen)))
        return E_FAIL;

    digest[dlen] = '\0';

    buf[len] = '\0';
    long ntime = atoi((const char*)buf);

    // If current time is not passed in, get it
    if (!lCurTime)
    {
        lCurTime = (long) time(NULL);
    }
    if((lCurTime - ntime) > lTimeoutWindow) 
        return PP_E_DIGEST_RESPONSE_TIMEOUT;

    int ret = strcmp((const char*) pNonce, (const char*) digest);

    return ret ? PP_E_DIGEST_NONCE_MISSMATCH : S_OK;

}


///////////////////////////////////////////////////////////////////////////////////
// Description:
//
//    Base64EncodeA    This method only provides backward compatibility for 
//                      existing components.                         
//                  
// Arguments:
//
//    pSrc        Points to the buffer of bytes to encode.
//
//    ulSrcSize   Number of bytes in pSrc to encode.
//
//    pszDst      Buffer to copy the encoded output into.  The length of the buffer
//                must be (((ulSrcSize / 3) + 1) * 4) + 1.
//
//Return Value:
//
//     0 - Encoding successful.
////////////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI
Base64EncodeA(const LPBYTE  pSrc,
              ULONG         ulSrcSize,
              LPSTR         pszDst)
{
    long lBufLen = -1; //
    Base64_EncodeBytes(pSrc, ulSrcSize, pszDst, &lBufLen);
    pszDst[lBufLen] = '\0';
    
    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////////
// Description:
//
//    Base64EncodeW    This method only provides backward compatibility for 
//                      existing components.                         
//                  
// Arguments:
//
//    pSrc        Points to the buffer of bytes to encode.
//
//    ulSrcSize   Number of bytes in pSrc to encode.
//
//    pszDst      Buffer to copy the encoded output into.  The length of the buffer
//                must be (((ulSrcSize / 3) + 1) * 4) + 1.
//
//Return Value:
//
//     0 - Encoding successful.
////////////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI
Base64EncodeW(const LPBYTE  pSrc,
              ULONG         ulSrcSize,
              LPWSTR        pszDst)
{
    HRESULT hr = S_OK;
    LONG    lBufLen = (((ulSrcSize / 3) + 1) * 4) + 1;
    LPSTR   pszABuf = (LPSTR)alloca(lBufLen);
    int     nResult;

    Base64_EncodeBytes(pSrc, ulSrcSize, (char*)pszABuf, &lBufLen);
    pszABuf[lBufLen] = '\0';

    nResult = MultiByteToWideChar(CP_ACP, 0, pszABuf, lBufLen, pszDst, lBufLen);
    pszDst[nResult] = 0;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\lkrhash\_locks.h ===
#define LOCKS_SWITCH_TO_THREAD

extern "C" {

BOOL
Locks_Initialize();

BOOL
Locks_Cleanup();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\lkrhash\irtldbg.cpp ===
// Implementation of debug support functions

#include "precomp.hxx"

#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <malloc.h>

#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT
#include <irtldbg.h>


IRTL_DLLEXP
void __cdecl
IrtlTrace(
    LPCTSTR ptszFormat,
    ...)
{
    TCHAR tszBuff[2048];
    va_list args;
    
    va_start(args, ptszFormat);
    _vstprintf(tszBuff, ptszFormat, args);
    va_end(args);

    OutputDebugString(tszBuff);
}



#ifdef _DEBUG

# if defined(USE_DEBUG_CRTS)  &&  defined(_MSC_VER)  &&  (_MSC_VER >= 1000)


#  ifdef RUNNING_AS_SERVICE

// The default assertion mechanism set up by Visual C++ 4 will not
// work with Active Server Pages because it's running inside a service
// and there is no desktop to interact with.

// Note: for this to work properly, #define _WIN32_WINNT 0x400 before
// including <winuser.h> or MB_SERVICE_NOTIFICATION won't be #define'd.

int __cdecl
AspAssertHandler(
    int   nReportType,
    char* pszErrorText,
    int*  pnReturn)
{
    const char szInfo[] = " (Press ABORT to terminate IIS,"
                          " RETRY to debug this failure,"
                          " or IGNORE to continue.)";
    char* pszMessageTitle = NULL;
    
    // These flags enable message boxes to show up on the user's console
    switch (nReportType)
    {
    case _CRT_WARN:
        // If using MFC's TRACE macro (AfxTrace), the report hook
        // (AspAssertHandler) will get called with _CRT_WARN.  Ignore.
        pszMessageTitle = "Warning";
        *pnReturn = 0;
        return FALSE;

    case _CRT_ERROR:
        pszMessageTitle = "Fatal Error";
        break;

    case _CRT_ASSERT:
        pszMessageTitle = "Assertion Failed";
        break;
    }   
    
    char* pszMessageText =
        static_cast<char*>(_alloca(strlen(pszErrorText) + strlen(szInfo) + 1));

    strcpy(pszMessageText, pszErrorText);
    strcat(pszMessageText, szInfo);
    
    const int n = MessageBoxA(NULL, pszMessageText, pszMessageTitle,
                              (MB_SERVICE_NOTIFICATION | MB_TOPMOST
                               | MB_ABORTRETRYIGNORE | MB_ICONEXCLAMATION));

    if (n == IDABORT)
    {
        exit(1);
    }
    else if (n == IDRETRY)
    {
        *pnReturn = 1;   // tell _CrtDbgReport to start the debugger
        return TRUE;     // tell _CrtDbgReport to run
    }
    
    *pnReturn = 0;       // nothing for _CrtDbgReport to do

    return FALSE;
}

#  endif // RUNNING_AS_SERVICE
# endif // _MSC_VER >= 1000



void
IrtlDebugInit()
{
# if defined(USE_DEBUG_CRTS)  &&  defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
#  ifdef RUNNING_AS_SERVICE
    // If we end up in _CrtDbgReport, don't put up a message box
    // _CrtSetReportMode(_CRT_WARN,   _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_ERROR,  _CRTDBG_MODE_DEBUG);

    // Use AspAssertHandler to put up a message box instead
    _CrtSetReportHook(AspAssertHandler);
#  endif // RUNNING_AS_SERVICE

    
    // Enable debug heap allocations & check for memory leaks at program exit
    // The memory leak check will not be performed if inetinfo.exe is
    // run directly under a debugger, only if it is run as a service.
    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF
                   | _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG));
# endif // _MSC_VER >= 1000
}



void
IrtlDebugTerm()
{
# if defined(USE_DEBUG_CRTS)  &&  defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
#  ifdef RUNNING_AS_SERVICE
    // Turn off AspAssertHandler, so that we don't get numerous message boxes
    // if there are memory leaks on shutdown
    _CrtSetReportHook(NULL);
#  endif // RUNNING_AS_SERVICE
# endif // _MSC_VER >= 1000
}

#endif //_DEBUG



BOOL
IsValidString(
    LPCTSTR ptsz,
    int nLength /* =-1 */)
{
    if (ptsz == NULL)
        return FALSE;

    return !IsBadStringPtr(ptsz, nLength);
}



BOOL
IsValidAddress(
    LPCVOID pv,
    UINT nBytes,
    BOOL fReadWrite /* =TRUE */)
{
    return (pv != NULL
            &&  !IsBadReadPtr(pv, nBytes)
            &&  (!fReadWrite  ||  !IsBadWritePtr((LPVOID) pv, nBytes)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\nexusobjects\nexus.cpp ===
#include "precomp.h"

PpNotificationThread    g_NotificationThread;
LONG                    g_bStarted;

BOOL WINAPI DllMain(
    HINSTANCE   hinstDLL,   // handle to DLL module
    DWORD       fdwReason,  // reason for calling function
    LPVOID      lpvReserved // reserved
)
{
    switch(fdwReason)
    {
    case DLL_PROCESS_ATTACH:

        g_bStarted = FALSE;

        DisableThreadLibraryCalls(hinstDLL);

#ifdef MEM_DBG
	{
	  int tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );
	  tmpFlag |= _CRTDBG_ALLOC_MEM_DF;
	  tmpFlag |= _CRTDBG_LEAK_CHECK_DF;
	  _CrtSetDbgFlag( tmpFlag );
	  char *myBuf = new char[64];
	  strcpy(myBuf, "Nexus leak ok!"); // Let em know it's working
	}
#endif

        if(!g_pAlert)
        {
            g_pAlert = CreatePassportAlertObject(PassportAlertInterface::EVENT_TYPE);
            if(g_pAlert)
            {
                g_pAlert->initLog(PM_ALERTS_REGISTRY_KEY, EVCAT_NEXUS, NULL, 1);
            }
            else
                _ASSERT(g_pAlert);
        }

        break;

    case DLL_PROCESS_DETACH:

        delete g_pAlert;

        if(g_bStarted)
        {
            // DARRENAN 4092
            // Remove lines that wait for thread to stop, a 
            // guaranteed deadlock.
         
            g_NotificationThread.stop();
        }

        break;

    default:

        break;
    }

    return TRUE;
}

HANDLE WINAPI
RegisterCCDUpdateNotification(
    LPCTSTR pszCCDName,
    ICCDUpdate* piCCDUpdate
    )
{
    HANDLE  hClientHandle;
    HRESULT hr;

    hr = g_NotificationThread.AddCCDClient(tstring(pszCCDName), piCCDUpdate, &hClientHandle);
    if(hr != S_OK)
    {
        hClientHandle = NULL;
    }

    if(!InterlockedExchange(&g_bStarted, TRUE))    
        g_NotificationThread.start();

    return hClientHandle;
}

BOOL WINAPI
UnregisterCCDUpdateNotification(
    HANDLE hNotificationHandle
    )
{
    return (g_NotificationThread.RemoveClient(hNotificationHandle) == S_OK);
}

HANDLE WINAPI
RegisterConfigChangeNotification(
    IConfigurationUpdate* piConfigUpdate
    )
{
    HANDLE  hClientHandle;
    HRESULT hr;

    hr = g_NotificationThread.AddLocalConfigClient(piConfigUpdate, &hClientHandle);
    if(hr != S_OK)
    {
        hClientHandle = NULL;
    }

    if(!InterlockedExchange(&g_bStarted, TRUE))
        g_NotificationThread.start();

    return hClientHandle;
}

BOOL WINAPI
UnregisterConfigChangeNotification(
    HANDLE hNotificationHandle
    )
{
    return (g_NotificationThread.RemoveClient(hNotificationHandle) == S_OK);
}

BOOL WINAPI
GetCCD(
    LPCTSTR         pszCCDName,
    IXMLDocument**  ppiXMLDocument,
    BOOL            bForceFetch
    )
{
    return (g_NotificationThread.GetCCD(tstring(pszCCDName), ppiXMLDocument, bForceFetch) == S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\passport\common\lkrhash\lkrhash.cpp ===
/*++

   Copyright    (c) 1998-2000    Microsoft Corporation

   Module  Name :
       LKRhash.cpp

   Abstract:
       Implements LKRhash: a fast, scalable, cache- and MP-friendly hash table

   Author:
       Paul (Per-Ake) Larson, palarson@microsoft.com, July 1997
       Murali R. Krishnan    (MuraliK)
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:
       Jan 1998   - Massive cleanup and rewrite.  Templatized.
       10/01/1998 - Change name from LKhash to LKRhash

--*/

#include "precomp.hxx"


#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT
#include <lkrhash.h>

#ifdef __LKRHASH_NAMESPACE__
namespace LKRHash {
#endif // __LKRHASH_NAMESPACE__

#ifdef LKR_COUNTDOWN
const int NODE_BEGIN = CLKRHashTable::NODES_PER_CLUMP-1;
const int NODE_END   = -1;
const int NODE_STEP  = -1;
#define FOR_EACH_NODE(x)    for (x = NODES_PER_CLUMP;  --x >= 0;  )
#else // !LKR_COUNTDOWN
const int NODE_BEGIN = 0;
const int NODE_END   = CLKRHashTable::NODES_PER_CLUMP;
const int NODE_STEP  = +1;
#define FOR_EACH_NODE(x)    for (x = 0;  x < NODES_PER_CLUMP;  ++x)
#endif // !LKR_COUNTDOWN


#ifdef LKRHASH_ALLOCATOR_NEW

# define DECLARE_ALLOCATOR(CLASS)                        \
  CLKRhashAllocator* CLASS::sm_palloc = NULL;            \

# define DECLARE_ALLOCATOR_LHTSUBCLASS(CLASS)            \
  CLKRhashAllocator* CLKRLinearHashTable::CLASS::sm_palloc = NULL; \


  // DECLARE_ALLOCATOR(CLKRLinearHashTable);
  // DECLARE_ALLOCATOR(CLKRHashTable);
  DECLARE_ALLOCATOR_LHTSUBCLASS(CNodeClump);
  DECLARE_ALLOCATOR_LHTSUBCLASS(CSmallSegment);
  DECLARE_ALLOCATOR_LHTSUBCLASS(CMediumSegment);
  DECLARE_ALLOCATOR_LHTSUBCLASS(CLargeSegment);

#endif // LKRHASH_ALLOCATOR_NEW


static bool s_fInitialized = false;


// -------------------------------------------------------------------------
// Initialize per-class allocators
// -------------------------------------------------------------------------

bool
LKRHashTableInit()
{
    bool f = true;

    IRTLTRACE(_T("LKRHashTableInit\n"));

#define INIT_ALLOCATOR(CLASS, N)                                \
    LKRHASH_ALLOCATOR_INIT(CLASS, N, f);                         \

#define INIT_ALLOCATOR_LHTSUBCLASS(CLASS, N)                    \
    LKRHASH_ALLOCATOR_INIT(CLKRLinearHashTable::CLASS, N, f);     \


    // INIT_ALLOCATOR(CLKRLinearHashTable,        20);
    // INIT_ALLOCATOR(CLKRHashTable,               4);
    INIT_ALLOCATOR_LHTSUBCLASS(CNodeClump,    200);
    INIT_ALLOCATOR_LHTSUBCLASS(CSmallSegment,   5);
    INIT_ALLOCATOR_LHTSUBCLASS(CMediumSegment,  5);
    INIT_ALLOCATOR_LHTSUBCLASS(CLargeSegment,   5);

    s_fInitialized = f;

    return f;
} // LKRHashTableInit



// -------------------------------------------------------------------------
// Destroy per-class allocators
// -------------------------------------------------------------------------

void
LKRHashTableUninit()
{
#define UNINIT_ALLOCATOR(CLASS)                        \
    LKRHASH_ALLOCATOR_UNINIT(CLASS);                    \

#define UNINIT_ALLOCATOR_LHTSUBCLASS(CLASS)            \
    LKRHASH_ALLOCATOR_UNINIT(CLKRLinearHashTable::CLASS);\

    // UNINIT_ALLOCATOR(CLKRLinearHashTable);
    // UNINIT_ALLOCATOR(CLKRHashTable);
    UNINIT_ALLOCATOR_LHTSUBCLASS(CNodeClump);
    UNINIT_ALLOCATOR_LHTSUBCLASS(CSmallSegment);
    UNINIT_ALLOCATOR_LHTSUBCLASS(CMediumSegment);
    UNINIT_ALLOCATOR_LHTSUBCLASS(CLargeSegment);

    s_fInitialized = false;

    IRTLTRACE(_T("LKRHashTableUninit done\n"));
} // LKRHashTableUninit



// -------------------------------------------------------------------------
// class static member variables
// -------------------------------------------------------------------------

#ifdef LOCK_INSTRUMENTATION
LONG CLKRLinearHashTable::CBucket::sm_cBuckets    = 0;

LONG CLKRLinearHashTable::sm_cTables              = 0;
#endif // LOCK_INSTRUMENTATION


#ifndef LKR_NO_GLOBAL_LIST
CLockedDoubleList CLKRLinearHashTable::sm_llGlobalList;
CLockedDoubleList CLKRHashTable::sm_llGlobalList;
#endif // LKR_NO_GLOBAL_LIST



// CLKRLinearHashTable --------------------------------------------------------
// Public Constructor for class CLKRLinearHashTable.
// -------------------------------------------------------------------------

CLKRLinearHashTable::CLKRLinearHashTable(
    LPCSTR          pszName,        // An identifier for debugging
    PFnExtractKey   pfnExtractKey,  // Extract key from record
    PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    PFnEqualKeys    pfnEqualKeys,   // Compare two keys
    PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    double          maxload,        // Upperbound on the average chain length
    DWORD           initsize,       // Initial size of hash table.
    DWORD         /*num_subtbls*/   // for compatiblity with CLKRHashTable
    )
    :
#ifdef LOCK_INSTRUMENTATION
      m_Lock(_LockName()),
#endif // LOCK_INSTRUMENTATION
      m_nTableLockType(TableLock::LockType()),
      m_nBucketLockType(BucketLock::LockType()),
      m_phtParent(NULL)
{
    STATIC_ASSERT(1 <= LK_DFLT_MAXLOAD  && LK_DFLT_MAXLOAD <= NODES_PER_CLUMP);
    STATIC_ASSERT(0 <= NODE_BEGIN  &&  NODE_BEGIN < NODES_PER_CLUMP);
    STATIC_ASSERT(!(0 <= NODE_END  &&  NODE_END < NODES_PER_CLUMP));

    IRTLVERIFY(LK_SUCCESS
               == _Initialize(pfnExtractKey, pfnCalcKeyHash, pfnEqualKeys,
                              pfnAddRefRecord, pszName, maxload, initsize));

    _InsertThisIntoGlobalList();
} // CLKRLinearHashTable::CLKRLinearHashTable



// CLKRLinearHashTable --------------------------------------------------------
// Private Constructor for class CLKRLinearHashTable, used by CLKRHashTable.
// -------------------------------------------------------------------------

CLKRLinearHashTable::CLKRLinearHashTable(
    LPCSTR          pszName,        // An identifier for debugging
    PFnExtractKey   pfnExtractKey,  // Extract key from record
    PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    PFnEqualKeys    pfnEqualKeys,   // Compare two keys
    PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    double          maxload,        // Upperbound on the average chain length
    DWORD           initsize,       // Initial size of hash table.
    CLKRHashTable*  phtParent       // Owning table.
    )
    :
#ifdef LOCK_INSTRUMENTATION
      m_Lock(_LockName()),
#endif // LOCK_INSTRUMENTATION
      m_nTableLockType(TableLock::LockType()),
      m_nBucketLockType(BucketLock::LockType()),
      m_phtParent(phtParent)
{
    IRTLASSERT(m_phtParent != NULL);
    IRTLVERIFY(LK_SUCCESS
               == _Initialize(pfnExtractKey, pfnCalcKeyHash, pfnEqualKeys,
                              pfnAddRefRecord, pszName, maxload, initsize));

    _InsertThisIntoGlobalList();
} // CLKRLinearHashTable::CLKRLinearHashTable



// _Initialize -------------------------------------------------------------
// Do all the real work of constructing a CLKRLinearHashTable
// -------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_Initialize(
    PFnExtractKey   pfnExtractKey,
    PFnCalcKeyHash  pfnCalcKeyHash,
    PFnEqualKeys    pfnEqualKeys,
    PFnAddRefRecord pfnAddRefRecord,
    LPCSTR          pszName,
    double          maxload,
    DWORD           initsize)
{
    m_dwSignature =     SIGNATURE;
    m_dwBktAddrMask0 =  0;
    m_dwBktAddrMask1 =  0;
    m_iExpansionIdx =   0;
    m_paDirSegs =       NULL;
    m_lkts =            LK_MEDIUM_TABLESIZE;
    m_dwSegBits =       0;
    m_dwSegSize =       0;
    m_dwSegMask =       0;
    m_lkrcState =       LK_UNUSABLE;
    m_MaxLoad =         LK_DFLT_MAXLOAD;
    m_nLevel =          0;
    m_cDirSegs =        0;
    m_cRecords =        0;
    m_cActiveBuckets =  0;
    m_wBucketLockSpins= LOCK_USE_DEFAULT_SPINS;
    m_pfnExtractKey =   pfnExtractKey;
    m_pfnCalcKeyHash =  pfnCalcKeyHash;
    m_pfnEqualKeys =    pfnEqualKeys;
    m_pfnAddRefRecord = pfnAddRefRecord;

    strncpy(m_szName, pszName, NAME_SIZE-1);
    m_szName[NAME_SIZE-1] = '\0';

    IRTLASSERT(m_pfnExtractKey != NULL
               && m_pfnCalcKeyHash != NULL
               && m_pfnEqualKeys != NULL
               && m_pfnAddRefRecord != NULL);

    IRTLASSERT(s_fInitialized);

    if (!s_fInitialized)
        return (m_lkrcState = LK_NOT_INITIALIZED);

    if (m_pfnExtractKey == NULL
            || m_pfnCalcKeyHash == NULL
            || m_pfnEqualKeys == NULL
            || m_pfnAddRefRecord == NULL)
        return (m_lkrcState = LK_BAD_PARAMETERS);

    // Choose the size of the segments according to the desired "size" of
    // the table, small, medium, or large.
    if (initsize == LK_SMALL_TABLESIZE)
    {
        _SetSegVars(LK_SMALL_TABLESIZE);
        initsize = CSmallSegment::INITSIZE;
    }
    else if (initsize == LK_MEDIUM_TABLESIZE)
    {
        _SetSegVars(LK_MEDIUM_TABLESIZE);
        initsize = CMediumSegment::INITSIZE;
    }
    else if (initsize == LK_LARGE_TABLESIZE)
    {
        _SetSegVars(LK_LARGE_TABLESIZE);
        initsize = CLargeSegment::INITSIZE;
    }

    // specified an explicit initial size
    else
    {
        // force Small::INITSIZE <= initsize <= MAX_DIRSIZE * Large::INITSIZE
        initsize = min(max(initsize, CSmallSegment::INITSIZE),
                       (MAX_DIRSIZE >> CLargeSegment::SEGBITS)
                            * CLargeSegment::INITSIZE);

        // Guess a table size
        if (initsize <= 8 * CSmallSegment::INITSIZE)
            _SetSegVars(LK_SMALL_TABLESIZE);
        else if (initsize >= CLargeSegment::INITSIZE)
            _SetSegVars(LK_LARGE_TABLESIZE);
        else
            _SetSegVars(LK_MEDIUM_TABLESIZE);
    }

    m_cActiveBuckets = initsize;

    // TODO: better sanity check for ridiculous values?
    m_MaxLoad = (maxload <= 1.0)  ?  LK_DFLT_MAXLOAD  :  maxload;
    m_MaxLoad = min(m_MaxLoad, 10 * NODES_PER_CLUMP);

    // adjust m_dwBktAddrMask0 (== m_dwSegMask) to make it large
    // enough to distribute the buckets across the address space
    for (DWORD tmp = m_cActiveBuckets >> m_dwSegBits;  tmp > 1;  tmp >>= 1)
    {
        ++m_nLevel;
        m_dwBktAddrMask0 = (m_dwBktAddrMask0 << 1) | 1;
    }

    m_dwBktAddrMask1 = (m_dwBktAddrMask0 << 1) | 1;

    IRTLASSERT(_H1(m_cActiveBuckets) == m_cActiveBuckets);
    m_iExpansionIdx = m_cActiveBuckets & m_dwBktAddrMask0;

    // create and clear directory of segments
    DWORD dirsize = MIN_DIRSIZE;
    while (dirsize < (m_cActiveBuckets >> m_dwSegBits))
        dirsize <<= 1;

    dirsize = min(dirsize, MAX_DIRSIZE);
    IRTLASSERT(dirsize * m_dwSegSize >= m_cActiveBuckets);

    m_lkrcState = LK_ALLOC_FAIL;
    m_paDirSegs = _AllocateSegmentDirectory(dirsize);

    if (m_paDirSegs != NULL)
    {
        m_cDirSegs = dirsize;
        IRTLASSERT(m_cDirSegs >= MIN_DIRSIZE
                   &&  (m_cDirSegs & (m_cDirSegs-1)) == 0);  // == (1 << N)

        // create and initialize only the required segments
        DWORD dwMaxSegs = (m_cActiveBuckets + m_dwSegSize - 1) >> m_dwSegBits;

        IRTLTRACE(_T("m_lkts = %d, m_cActiveBuckets = %lu, ")
                  _T("m_dwSegSize = %lu, bits = %lu\n")
                  _T("m_cDirSegs = %lu, dwMaxSegs = %lu, ")
                  _T("segment total size = %lu bytes\n"),
                  m_lkts, m_cActiveBuckets,
                  m_dwSegSize, m_dwSegBits,
                  m_cDirSegs, dwMaxSegs,
                  m_dwSegSize * sizeof(CBucket));

        m_lkrcState = LK_SUCCESS; // so IsValid/IsUsable won't fail

        for (DWORD i = 0;  i < dwMaxSegs;  i++)
        {
            CSegment* pSeg = _AllocateSegment();
            if (pSeg != NULL)
                m_paDirSegs[i].m_pseg = pSeg;
            else
            {
                // problem: deallocate everything
                m_lkrcState = LK_ALLOC_FAIL;
                for (DWORD j = i;  j-- > 0;  )
                {
                    _FreeSegment(m_paDirSegs[j].m_pseg);
                    m_paDirSegs[j].m_pseg = NULL;
                }
                _FreeSegmentDirectory(m_paDirSegs);
                break;
            }
        }
    }

    if (m_lkrcState != LK_SUCCESS)
    {
        m_paDirSegs      = NULL;
        m_cDirSegs       = 0;
        m_cActiveBuckets = 0;
        m_iExpansionIdx  = 0;
    }

    return m_lkrcState;
} // CLKRLinearHashTable::_Initialize



// CLKRHashTable ----------------------------------------------------------
// Constructor for class CLKRHashTable.
// ---------------------------------------------------------------------

CLKRHashTable::CLKRHashTable(
    LPCSTR          pszName,        // An identifier for debugging
    PFnExtractKey   pfnExtractKey,  // Extract key from record
    PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    PFnEqualKeys    pfnEqualKeys,   // Compare two keys
    PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    double          maxload,        // Bound on the average chain length
    DWORD           initsize,       // Initial size of hash table.
    DWORD           num_subtbls     // Number of subordinate hash tables.
    )
    : m_dwSignature(SIGNATURE),
      m_cSubTables(0),
      m_palhtDir(NULL),
      m_pfnExtractKey(pfnExtractKey),
      m_pfnCalcKeyHash(pfnCalcKeyHash),
      m_lkrcState(LK_BAD_PARAMETERS)
{
    strncpy(m_szName, pszName, NAME_SIZE-1);
    m_szName[NAME_SIZE-1] = '\0';

    _InsertThisIntoGlobalList();

    IRTLASSERT(pfnExtractKey != NULL
               && pfnCalcKeyHash != NULL
               && pfnEqualKeys != NULL
               && pfnAddRefRecord != NULL);

    if (pfnExtractKey == NULL
            || pfnCalcKeyHash == NULL
            || pfnEqualKeys == NULL
            || pfnAddRefRecord == NULL)
        return;

    if (!s_fInitialized)
    {
        m_lkrcState = LK_NOT_INITIALIZED;
        return;
    }

    LK_TABLESIZE lkts = NumSubTables(initsize, num_subtbls);

#ifdef _DEBUG
    int cBuckets = initsize;
    if (initsize == LK_SMALL_TABLESIZE)
        cBuckets = SubTable::CSmallSegment::INITSIZE;
    else if (initsize == LK_MEDIUM_TABLESIZE)
        cBuckets = SubTable::CMediumSegment::INITSIZE;
    else if (initsize == LK_LARGE_TABLESIZE)
        cBuckets = SubTable::CLargeSegment::INITSIZE;

    IRTLTRACE(_T("CLKRHashTable: %s, %d subtables, initsize = %d, ")
              _T("total #buckets = %d\n" ),
              ((lkts == LK_SMALL_TABLESIZE) ? "small" : 
               (lkts == LK_MEDIUM_TABLESIZE) ? "medium" : "large"),
              num_subtbls, initsize, cBuckets * num_subtbls);
#endif

    m_lkrcState = LK_ALLOC_FAIL;
    m_palhtDir  = _AllocateSubTableArray(num_subtbls);

    if (m_palhtDir == NULL)
        return;
    else
    {
        m_cSubTables = num_subtbls;
        for (DWORD i = 0;  i < m_cSubTables;  i++)
            m_palhtDir[i] = NULL;
    }

    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        m_palhtDir[i] = _AllocateSubTable(pszName, pfnExtractKey,
                                          pfnCalcKeyHash, pfnEqualKeys,
                                          pfnAddRefRecord, maxload,
                                          initsize, this);

        // Failed to allocate a subtable.  Destroy everything allocated so far.
        if (m_palhtDir[i] == NULL  ||  !m_palhtDir[i]->IsValid())
        {
            for (DWORD j = i;  j-- > 0;  )
                _FreeSubTable(m_palhtDir[j]);
            _FreeSubTableArray(m_palhtDir);
            m_cSubTables = 0;
            m_palhtDir   = NULL;

            return;
        }
    }

#ifdef LKR_SUBTABLE_MASK
    m_nSubTableMask = m_cSubTables - 1;
    // power of 2?
    if ((m_nSubTableMask & m_cSubTables) != 0)
        m_nSubTableMask = -1;
#endif // LKR_SUBTABLE_MASK

    m_lkrcState = LK_SUCCESS; // so IsValid/IsUsable won't fail
} // CLKRHashTable::CLKRHashTable



// ~CLKRLinearHashTable ------------------------------------------------------
// Destructor for class CLKRLinearHashTable
//-------------------------------------------------------------------------

CLKRLinearHashTable::~CLKRLinearHashTable()
{
    // must acquire all locks before deleting to make sure
    // that no other threads are using the table
    WriteLock();
    _Clear(false);
    WriteUnlock();

    _RemoveThisFromGlobalList();

    m_dwSignature = SIGNATURE_FREE;
    m_lkrcState = LK_UNUSABLE; // so IsUsable will fail
} // CLKRLinearHashTable::~CLKRLinearHashTable



// ~CLKRHashTable ------------------------------------------------------------
// Destructor for class CLKRHashTable
//-------------------------------------------------------------------------
CLKRHashTable::~CLKRHashTable()
{
    // delete in reverse order, just like delete[].
    for (DWORD i = m_cSubTables;  i-- > 0;  )
        _FreeSubTable(m_palhtDir[i]);

    _FreeSubTableArray(m_palhtDir);

    _RemoveThisFromGlobalList();

    m_dwSignature = SIGNATURE_FREE;
    m_lkrcState = LK_UNUSABLE; // so IsUsable will fail
} // CLKRHashTable::~CLKRHashTable



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::NumSubTables
// Synopsis: 
//------------------------------------------------------------------------

LK_TABLESIZE
CLKRLinearHashTable::NumSubTables(
    DWORD& rinitsize,
    DWORD& rnum_subtbls)
{
    LK_TABLESIZE lkts = LK_MEDIUM_TABLESIZE;

    return lkts;
} // CLKRLinearHashTable::NumSubTables



//------------------------------------------------------------------------
// Function: CLKRHashTable::NumSubTables
// Synopsis: 
//------------------------------------------------------------------------

LK_TABLESIZE
CLKRHashTable::NumSubTables(
    DWORD& rinitsize,
    DWORD& rnum_subtbls)
{
    LK_TABLESIZE lkts;
    
    // Establish the table size
    if (rinitsize == LK_SMALL_TABLESIZE
        ||  rinitsize == LK_MEDIUM_TABLESIZE
        ||  rinitsize == LK_LARGE_TABLESIZE)
    {
        lkts = static_cast<LK_TABLESIZE>(rinitsize);
    }
    else
    {
        if (rnum_subtbls != LK_DFLT_NUM_SUBTBLS)
        {
            rinitsize = (rinitsize - 1) / rnum_subtbls + 1;

            if (rinitsize <= SubTable::CSmallSegment::SEGSIZE)
                lkts = LK_SMALL_TABLESIZE;
            else if (rinitsize >= SubTable::CLargeSegment::SEGSIZE)
                lkts = LK_LARGE_TABLESIZE;
            else
                lkts = LK_MEDIUM_TABLESIZE;
        }
        else
        {
            lkts = LK_MEDIUM_TABLESIZE;
        }
    }

    // Choose a suitable number of subtables
    if (rnum_subtbls == LK_DFLT_NUM_SUBTBLS)
    {
        int nCPUs = NumProcessors();
        switch (lkts)
        {
        case LK_SMALL_TABLESIZE:
            rnum_subtbls = min(1, nCPUs);
            break;
        
        case LK_MEDIUM_TABLESIZE:
            rnum_subtbls = 2 * nCPUs;
            break;
        
        case LK_LARGE_TABLESIZE:
            rnum_subtbls = 4 * nCPUs;
            break;
        }
    }

    rnum_subtbls = min(64, rnum_subtbls);

    return lkts;
} // CLKRHashTable::NumSubTables



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FindBucket
// Synopsis: Find a bucket, given its signature. The bucket is locked
//           before returning. Assumes table is already locked, to avoid
//           race conditions.
//------------------------------------------------------------------------

LOCK_FORCEINLINE
CLKRLinearHashTable::CBucket*
CLKRLinearHashTable::_FindBucket(
    DWORD dwSignature,
    bool  fLockForWrite) const
{
    IRTLASSERT(IsValid());
    IRTLASSERT(m_dwBktAddrMask0 > 0);
    IRTLASSERT((m_dwBktAddrMask0 & (m_dwBktAddrMask0+1)) == 0); // 00011..111
    IRTLASSERT(m_dwBktAddrMask0 == (1U << m_nLevel) - 1);
    IRTLASSERT(m_dwBktAddrMask1 == ((m_dwBktAddrMask0 << 1) | 1));
    IRTLASSERT((m_dwBktAddrMask1 & (m_dwBktAddrMask1+1)) == 0);
    IRTLASSERT(0 <= m_iExpansionIdx && m_iExpansionIdx <= m_dwBktAddrMask0);
    IRTLASSERT(0 < m_dwSegBits  &&  m_dwSegBits < 20
               &&  m_dwSegSize == (1U << m_dwSegBits)
               &&  m_dwSegMask == (m_dwSegSize - 1));
    IRTLASSERT(IsReadLocked()  ||  IsWriteLocked());
    
    const DWORD dwBktAddr = _BucketAddress(dwSignature);
    IRTLASSERT(dwBktAddr < m_cActiveBuckets);
    
    CBucket* const pbkt = _Bucket(dwBktAddr);
    IRTLASSERT(pbkt != NULL);
    
    if (fLockForWrite)
        pbkt->WriteLock();
    else
        pbkt->ReadLock();
    
    return pbkt;
} // CLKRLinearHashTable::_FindBucket



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_IsNodeCompact
// Synopsis: validates that a node is correctly compacted
//------------------------------------------------------------------------

int
CLKRLinearHashTable::_IsNodeCompact(
    CBucket* const pbkt) const
{
    CNodeClump* pncCurr;
    CNodeClump* pncPrev;
    bool fEmpty  = pbkt->m_ncFirst.InvalidSignature(NODE_BEGIN);
    int  cErrors = fEmpty ? !pbkt->m_ncFirst.IsLastClump() : 0;

    for (pncCurr = &pbkt->m_ncFirst, pncPrev = NULL;
         pncCurr != NULL;
         pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (fEmpty)
            {
                cErrors += (!pncCurr->InvalidSignature(i));
                cErrors += (!pncCurr->IsEmptyNode(i));
            }
            else if (pncCurr->InvalidSignature(i))
            {
                fEmpty = true;
                cErrors += (!pncCurr->IsEmptyNode(i));
                cErrors += (!pncCurr->IsLastClump());
            }
            else // still in non-empty portion
            {
                cErrors += (pncCurr->InvalidSignature(i));
                cErrors += (pncCurr->IsEmptyNode(i));
            }
        }
    }

    return cErrors;
} // CLKRLinearHashTable::_IsNodeCompact



LOCK_FORCEINLINE
CLKRHashTable::SubTable*
CLKRHashTable::_SubTable(
    DWORD dwSignature) const
{
    IRTLASSERT(m_lkrcState == LK_SUCCESS
               &&  m_palhtDir != NULL  &&  m_cSubTables > 0);
    
    const DWORD PRIME = 1048583UL;  // used to scramble the hash sig
    DWORD       index = dwSignature;
    
#ifdef LKR_BITSCRAMBLE_SUBTABLE_INDEX
    index = (((index * PRIME + 12345) >> 16)
             | ((index * 69069 + 1) & 0xffff0000));
#else // !LKR_BITSCRAMBLE_SUBTABLE_INDEX
    index %= PRIME;
#endif // !LKR_BITSCRAMBLE_SUBTABLE_INDEX
    
#ifdef LKR_SUBTABLE_BITMASK
# ifdef LKR_SUBTABLE_MASK
    if (m_nSubTableMask >= 0)
        index &= m_nSubTableMask;
# else // !LKR_SUBTABLE_MASK
    if ((m_cSubTables & (m_cSubTables-1)) == 0)
        index &= (m_cSubTables-1);
# endif // !LKR_SUBTABLE_MASK
    else
#endif // LKR_SUBTABLE_BITMASK
        index %= m_cSubTables;

    return m_palhtDir[index];
} // CLKRHashTable::_SubTable



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_InsertRecord
// Synopsis: Inserts a new record into the hash table. If this causes the
//           average chain length to exceed the upper bound, the table is
//           expanded by one bucket.
// Output:   LK_SUCCESS,    if the record was inserted.
//           LK_KEY_EXISTS, if the record was not inserted (because a record
//               with the same key value already exists in the table, unless
//               fOverwrite==true).
//           LK_ALLOC_FAIL, if failed to allocate the required space
//           LK_UNUSABLE,   if hash table not in usable state
//           LK_BAD_RECORD, if record is bad.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_InsertRecord(
    const void* pvRecord,   // Pointer to the record to add to table
    DWORD       dwSignature,// hash signature
    bool        fOverwrite  // overwrite record if key already present
    )
{
    IRTLASSERT(IsUsable()
               &&  pvRecord != NULL
               &&  dwSignature != HASH_INVALID_SIGNATURE);

    // find the beginning of the correct bucket chain
    WriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    CBucket* const pbkt = _FindBucket(dwSignature, true);
    IRTLASSERT(pbkt != NULL);
    IRTLASSERT(pbkt->IsWriteLocked());
    WriteUnlock();

    // check that no record with the same key value exists
    // and save a pointer to the last element on the chain
    LK_RETCODE lkrc = LK_SUCCESS;
    CNodeClump* pncFree = NULL;
    int         iFreePos = NODE_BEGIN - NODE_STEP;
    CNodeClump* pncPrev;
    CNodeClump* pncCurr;
    bool        fUpdate = false;
    const DWORD_PTR pnKey = _ExtractKey(pvRecord);

    // walk down the entire bucket chain, looking for matching hash
    // signatures and keys
    for (pncCurr = &pbkt->m_ncFirst, pncPrev = NULL;
         pncCurr != NULL;
         pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (pncCurr->IsEmptySlot(i))
            {
                IRTLASSERT(pncCurr->IsEmptyAndInvalid(i));
                IRTLASSERT(0 == _IsNodeCompact(pbkt));
                IRTLASSERT(pncCurr->IsLastClump());

                pncFree  = pncCurr;
                iFreePos = i;
                goto insert;
            }

            if (dwSignature == pncCurr->m_dwKeySigs[i]
                &&  (
#ifdef LKR_EQUALKEYS
                    pvRecord == pncCurr->m_pvNode[i]  ||
#endif// LKR_EQUALKEYS
                    _EqualKeys(pnKey,  _ExtractKey(pncCurr->m_pvNode[i]))))
            {
                if (fOverwrite)
                {
                    // If we allow overwrites, this is the slot to do it to
                    fUpdate  = true;
                    pncFree  = pncCurr;
                    iFreePos = i;
                    goto insert;
                }
                else
                {
                    // overwrites forbidden: return an error
                    lkrc = LK_KEY_EXISTS;
                    goto exit;
                }
            }
        }
    }

  insert:
    if (pncFree != NULL)
    {
        pncCurr = pncFree;
        IRTLASSERT(0 <= iFreePos  &&  iFreePos < NODES_PER_CLUMP);
    }
    else
    {
        // No free slots.  Attach the new node to the end of the chain
        IRTLASSERT(iFreePos == NODE_BEGIN - NODE_STEP);
        pncCurr = _AllocateNodeClump();

        if (pncCurr == NULL)
        {
            lkrc = LK_ALLOC_FAIL;
            goto exit;
        }

        IRTLASSERT(pncPrev != NULL  &&  pncPrev->IsLastClump());
        pncPrev->m_pncNext = pncCurr;
        iFreePos = NODE_BEGIN;
    }

    // Bump the new record's reference count upwards
    _AddRefRecord(pvRecord, +1);

    if (fUpdate)
    {
        // We're overwriting an existing record.  Adjust the old record's
        // refcount downwards.  (Doing ++new, --old in this order ensures
        // that the refcount won't briefly go to zero if new and old are
        // the same record.)
        IRTLASSERT(!pncCurr->IsEmptyAndInvalid(iFreePos));
        _AddRefRecord(pncCurr->m_pvNode[iFreePos], -1);
    }
    else
    {
        IRTLASSERT(pncCurr->IsEmptyAndInvalid(iFreePos));
        InterlockedIncrement(reinterpret_cast<LONG*>(&m_cRecords));
    }

    pncCurr->m_dwKeySigs[iFreePos] = dwSignature;
    pncCurr->m_pvNode[iFreePos]    = pvRecord;

  exit:
    pbkt->WriteUnlock();

    if (lkrc == LK_SUCCESS)
    {
        // If the average load factor has grown too high, we grow the
        // table one bucket at a time.
        while (m_cRecords > m_MaxLoad * m_cActiveBuckets)
        {
            // If _Expand returns an error code (viz. LK_ALLOC_FAIL), it
            // just means that there isn't enough spare memory to expand
            // the table by one bucket. This is likely to cause problems
            // elsewhere soon, but this hashtable has not been corrupted.
            // If the call to _AllocateNodeClump above failed, then we do
            // have a real error that must be propagated back to the caller
            // because we were unable to insert the element at all.
            if (_Expand() != LK_SUCCESS)
                break;  // expansion failed
        }
    }

    return lkrc;
} // CLKRLinearHashTable::_InsertRecord



// Thin wrapper for the corresponding method in CLKRLinearHashTable

LK_RETCODE
CLKRHashTable::InsertRecord(
    const void* pvRecord,
    bool fOverwrite /*=false*/)
{
    if (!IsUsable())
        return m_lkrcState;
    
    if (pvRecord == NULL)
        return LK_BAD_RECORD;
    
    LKRHASH_GLOBAL_WRITE_LOCK();    // usu. no-op
    DWORD     hash_val  = _CalcKeyHash(_ExtractKey(pvRecord));
    SubTable* const pst = _SubTable(hash_val);
    LK_RETCODE lk = pst->_InsertRecord(pvRecord, hash_val, fOverwrite);
    LKRHASH_GLOBAL_WRITE_UNLOCK();    // usu. no-op
    return lk;
} // CLKRLinearHashTable::InsertRecord



//-------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_DeleteKey
// Synopsis: Deletes the record with the given key value from the hash
//           table (if it exists).
// Returns:  LK_SUCCESS, if record found and deleted.
//           LK_NO_SUCH_KEY, if no record with the given key value was found.
//           LK_UNUSABLE, if hash table not in usable state
//-------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_DeleteKey(
    const DWORD_PTR pnKey,      // Key value of the record, depends on key type
    DWORD           dwSignature
    )
{
    IRTLASSERT(IsUsable());

    LK_RETCODE lkrc = LK_NO_SUCH_KEY;

    // locate the beginning of the correct bucket chain
    WriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    CBucket* const pbkt = _FindBucket(dwSignature, true);
    IRTLASSERT(pbkt != NULL);
    IRTLASSERT(pbkt->IsWriteLocked());
    WriteUnlock();

    // scan down the bucket chain, looking for the victim
    for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
         pncCurr != NULL;
         pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (pncCurr->IsEmptySlot(i))
            {
                IRTLASSERT(pncCurr->IsEmptyAndInvalid(i));
                IRTLASSERT(0 == _IsNodeCompact(pbkt));
                IRTLASSERT(pncCurr->IsLastClump());
                goto exit;
            }

            if (dwSignature != pncCurr->m_dwKeySigs[i])
                continue;

            const DWORD_PTR pnKey2 = _ExtractKey(pncCurr->m_pvNode[i]);

            if (
#ifdef LKR_EQUALKEYS
                pnKey == pnKey2  ||
#endif// LKR_EQUALKEYS
                _EqualKeys(pnKey,  pnKey2))
            {
                IRTLVERIFY(_DeleteNode(pbkt, pncCurr, pncPrev, i));

                lkrc = LK_SUCCESS;
                goto exit;
            }
        }
    }

  exit:
    pbkt->WriteUnlock();

    if (lkrc == LK_SUCCESS)
    {
        // contract the table if necessary
        double maxcontract = 1.0 / static_cast<double>(m_MaxLoad);

        for (int contractions = 0;
             m_cRecords < m_MaxLoad * m_cActiveBuckets
                 &&  m_cActiveBuckets > m_dwSegSize * MIN_DIRSIZE
                 &&  contractions < maxcontract;
             ++contractions)
        {
            // If _Contract returns an error code (viz. LK_ALLOC_FAIL), it
            // just means that there isn't enough spare memory to contract
            // the table by one bucket. This is likely to cause problems
            // elsewhere soon, but this hashtable has not been corrupted.
            if (_Contract() != LK_SUCCESS)
                break;
        }
    }

    return lkrc;
} // CLKRLinearHashTable::_DeleteKey



// Thin wrapper for the corresponding method in CLKRLinearHashTable

LK_RETCODE
CLKRHashTable::DeleteKey(
    const DWORD_PTR pnKey)
{
    if (!IsUsable())
        return m_lkrcState;
    
    LKRHASH_GLOBAL_WRITE_LOCK();    // usu. no-op
    DWORD     hash_val  = _CalcKeyHash(pnKey);
    SubTable* const pst = _SubTable(hash_val);
    LK_RETCODE lk       = pst->_DeleteKey(pnKey, hash_val);
    LKRHASH_GLOBAL_WRITE_UNLOCK();    // usu. no-op
    return lk;
} // CLKRLinearHashTable::DeleteKey



//-------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_DeleteRecord
// Synopsis: Deletes the specified record from the hash table (if it
//           exists).  This is not the same thing as calling
//           DeleteKey(_ExtractKey(pvRecord)).  If _DeleteKey were called for
//           a record that doesn't exist in the table, it could delete some
//           completely unrelated record that happened to have the same key.
// Returns:  LK_SUCCESS, if record found and deleted.
//           LK_NO_SUCH_KEY, if the record is not found in the table.
//           LK_UNUSABLE, if hash table not in usable state.
//-------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_DeleteRecord(
    const void* pvRecord,   // Pointer to the record to delete from the table
    DWORD       dwSignature
    )
{
    IRTLASSERT(IsUsable()  &&  pvRecord != NULL);

    LK_RETCODE lkrc = LK_NO_SUCH_KEY;

    // locate the beginning of the correct bucket chain
    WriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    CBucket* const pbkt = _FindBucket(dwSignature, true);
    IRTLASSERT(pbkt != NULL);
    IRTLASSERT(pbkt->IsWriteLocked());
    WriteUnlock();

    const DWORD_PTR pnKey = _ExtractKey(pvRecord);
    IRTLASSERT(dwSignature == _CalcKeyHash(pnKey));

    // scan down the bucket chain, looking for the victim
    for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
         pncCurr != NULL;
         pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (pncCurr->IsEmptySlot(i))
            {
                IRTLASSERT(pncCurr->IsEmptyAndInvalid(i));
                IRTLASSERT(0 == _IsNodeCompact(pbkt));
                IRTLASSERT(pncCurr->IsLastClump());
                goto exit;
            }

            if (pncCurr->m_pvNode[i] == pvRecord)
            {
                IRTLASSERT(_EqualKeys(pnKey,
                                      _ExtractKey(pncCurr->m_pvNode[i])));
                IRTLASSERT(dwSignature == pncCurr->m_dwKeySigs[i]);

                IRTLVERIFY(_DeleteNode(pbkt, pncCurr, pncPrev, i));

                lkrc = LK_SUCCESS;
                goto exit;
            }
        }
    }

  exit:
    pbkt->WriteUnlock();

    if (lkrc == LK_SUCCESS)
    {
        // contract the table if necessary
        double maxcontract = 1.0 / static_cast<double>(m_MaxLoad);

        for (int contractions = 0;
             m_cRecords < m_MaxLoad * m_cActiveBuckets
                 &&  m_cActiveBuckets > m_dwSegSize * MIN_DIRSIZE
                 &&  contractions < maxcontract;
             ++contractions)
        {
            // If _Contract returns an error code (viz. LK_ALLOC_FAIL), it
            // just means that there isn't enough spare memory to contract
            // the table by one bucket. This is likely to cause problems
            // elsewhere soon, but this hashtable has not been corrupted.
            if (_Contract() != LK_SUCCESS)
                break;
        }
    }

    return lkrc;
} // CLKRLinearHashTable::_DeleteRecord



// Thin wrapper for the corresponding method in CLKRLinearHashTable

LK_RETCODE
CLKRHashTable::DeleteRecord(
    const void* pvRecord)
{
    if (!IsUsable())
        return m_lkrcState;
    
    if (pvRecord == NULL)
        return LK_BAD_RECORD;
    
    LKRHASH_GLOBAL_WRITE_LOCK();    // usu. no-op
    DWORD     hash_val  = _CalcKeyHash(_ExtractKey(pvRecord));
    SubTable* const pst = _SubTable(hash_val);
    LK_RETCODE lk       = pst->_DeleteRecord(pvRecord, hash_val);
    LKRHASH_GLOBAL_WRITE_UNLOCK();    // usu. no-op
    return lk;
} // CLKRLinearHashTable::DeleteRecord



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_DeleteNode
// Synopsis: Deletes a node; removes the node clump if empty
// Returns:  true if successful
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::_DeleteNode(
    CBucket*     pbkt,      // bucket chain containing node
    CNodeClump*& rpnc,      // actual node
    CNodeClump*& rpncPrev,  // predecessor of actual node, or NULL
    int&         riNode)    // index within node
{
    IRTLASSERT(pbkt != NULL  &&  pbkt->IsWriteLocked());
    IRTLASSERT(rpnc != NULL);
    IRTLASSERT(rpncPrev == NULL  ||  rpncPrev->m_pncNext == rpnc);
    IRTLASSERT(0 <= riNode  &&  riNode < NODES_PER_CLUMP);
    IRTLASSERT(!rpnc->IsEmptyAndInvalid(riNode));

#ifdef _DEBUG
    // Check that the node clump really does belong to the bucket
    CNodeClump* pnc1 = &pbkt->m_ncFirst;

    while (pnc1 != NULL  &&  pnc1 != rpnc)
         pnc1 = pnc1->m_pncNext;

    IRTLASSERT(pnc1 == rpnc);
#endif // _DEBUG

    // Release the reference to the record
    _AddRefRecord(rpnc->m_pvNode[riNode], -1);

    IRTLASSERT(0 == _IsNodeCompact(pbkt));

    // Compact the nodeclump by moving the very last node back to the
    // newly freed slot
    CNodeClump* pnc2   = rpnc;
    int         iNode2 = riNode;

    // Find the last nodeclump in the chain
    while (!pnc2->IsLastClump())
    {
         pnc2 = pnc2->m_pncNext;
         iNode2 = NODE_BEGIN;
    }

    IRTLASSERT(0 <= iNode2  &&  iNode2 < NODES_PER_CLUMP);
    IRTLASSERT(!pnc2->IsEmptyAndInvalid(iNode2));

    // Find the first empty slot in the nodeclump
    while (iNode2 != NODE_END  &&  !pnc2->IsEmptySlot(iNode2))
    {
        iNode2 += NODE_STEP;
    }

    // Back up to last non-empty slot
    iNode2 -= NODE_STEP;
    IRTLASSERT(0 <= iNode2  &&  iNode2 < NODES_PER_CLUMP
               &&  !pnc2->IsEmptyAndInvalid(iNode2));
    IRTLASSERT(iNode2+NODE_STEP == NODE_END
               ||  pnc2->IsEmptyAndInvalid(iNode2+NODE_STEP));

#ifdef _DEBUG
    // Check that all the remaining nodes are empty
    IRTLASSERT(pnc2->IsLastClump());
    for (int iNode3 = iNode2 + NODE_STEP;
         iNode3 != NODE_END;
         iNode3 += NODE_STEP)
    {
        IRTLASSERT(pnc2->IsEmptyAndInvalid(iNode3));
    }
#endif // _DEBUG

    // Move the last node's data back to the current node
    rpnc->m_pvNode[riNode]    = pnc2->m_pvNode[iNode2];
    rpnc->m_dwKeySigs[riNode] = pnc2->m_dwKeySigs[iNode2];

    // Blank the old last node.
    // Correct even if (rpnc, riNode) == (pnc2, iNode2).
    pnc2->m_pvNode[iNode2]    = NULL;
    pnc2->m_dwKeySigs[iNode2] = HASH_INVALID_SIGNATURE;

    IRTLASSERT(0 == _IsNodeCompact(pbkt));

    // Back up riNode by one, so that the next iteration of the loop
    // calling _DeleteNode will end up pointing to the same spot.
    if (riNode != NODE_BEGIN)
    {
        riNode -= NODE_STEP;
    }
    else
    {
        // rewind rpnc and rpncPrev to previous node
        if (rpnc == &pbkt->m_ncFirst)
        {
            riNode = NODE_BEGIN - NODE_STEP;
        }
        else
        {
            riNode = NODE_END;
            rpnc = rpncPrev;
            if (rpnc == &pbkt->m_ncFirst)
            {
                rpncPrev = NULL;
            }
            else
            {
                for (rpncPrev = &pbkt->m_ncFirst;
                     rpncPrev->m_pncNext != rpnc;
                     rpncPrev = rpncPrev->m_pncNext)
                {}
            }
        }
    }

    // Is the last node clump now completely empty?  Delete, if possible
    if (iNode2 == NODE_BEGIN  &&  pnc2 != &pbkt->m_ncFirst)
    {
        // Find preceding nodeclump
        CNodeClump* pnc3 = &pbkt->m_ncFirst;
        while (pnc3->m_pncNext != pnc2)
        {
            pnc3 = pnc3->m_pncNext;
            IRTLASSERT(pnc3 != NULL);
        }

        pnc3->m_pncNext = NULL;
#ifdef _DEBUG
        pnc2->m_pncNext = NULL; // or dtor will ASSERT
#endif // _DEBUG
        _FreeNodeClump(pnc2);
    }

    IRTLASSERT(rpncPrev == NULL  ||  rpncPrev->m_pncNext == rpnc);

    InterlockedDecrement(reinterpret_cast<LONG*>(&m_cRecords));

    return true;
} // CLKRLinearHashTable::_DeleteNode



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FindKey
// Synopsis: Locate the record associated with the given key value.
// Returns:  Pointer to the record, if it is found.
//           NULL, if the record is not found.
// Returns:  LK_SUCCESS, if record found (record is returned in *ppvRecord)
//           LK_BAD_RECORD, if ppvRecord is invalid
//           LK_NO_SUCH_KEY, if no record with the given key value was found.
//           LK_UNUSABLE, if hash table not in usable state
// Note:     the record is AddRef'd.  You must decrement the reference count
//           when you are finished with the record (if you're implementing
//           refcounting semantics).
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_FindKey(
    const DWORD_PTR  pnKey,  // Key value of the record, depends on key type
    DWORD        dwSignature,// hash signature
    const void** ppvRecord   // resultant record
    ) const
{
    IRTLASSERT(IsUsable()  &&  ppvRecord != NULL);

   